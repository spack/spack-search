{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/configure.ac": "# Process this file with autoconf to produce a configure script.\n#AC_PREREQ([2.62])\n\n# This line is parsed by tools besides autoconf, such as msvc/mono.winconfig.targets.\n# It should remain in the format they expect.\n#\nAC_INIT(mono, [6.8.0.105],\n        [https://github.com/mono/mono/issues/new])\n\nAC_CONFIG_SRCDIR([README.md])\nAC_CONFIG_MACRO_DIR([m4])\n\nif test \"x$host_alias\" = \"x\"; then\n\tbuild_uname_all=`(uname -a) 2>/dev/null`\n\tcase \"$build_uname_all\" in\n\tCYGWIN*)\n\t\tAC_MSG_NOTICE([Run configure using ./configure --host=i686-w64-mingw32 or --host=x86_64-w64-mingw32])\n\t\tAC_MSG_NOTICE([Falling back using --host=x86_64-w64-mingw32 as default.])\n\t\thost_alias=x86_64-w64-mingw32\n\t\t;;\n\tesac\nfi\n\nAC_CANONICAL_SYSTEM\nAC_CANONICAL_HOST\n\n# Gross hack to enable 'make dist' on automake 1.9+tar 1.14.\n# The extra brackets are to foil regex-based scans.\nm4_ifdef([_A][M_PROG_TAR],[_A][M_SET_OPTION([tar-ustar])])\n\nAM_INIT_AUTOMAKE([1.9 dist-xz tar-ustar no-dist-gzip foreign]\n                 m4_esyscmd([case `automake --version | head -n 1` in    # parallel-tests is default in automake 1.13+, we need to explicitly enable it\n                             *1.11*|*1.12*) echo parallel-tests;;        # for 1.11 and 1.12 but not below as those versions don't recognize the flag\n                             esac]))                                     # TODO: remove this hack once we require automake 1.11+\n\nAC_CONFIG_HEADERS([config.h])\nAM_MAINTAINER_MODE\nm4_ifdef([AM_EXTRA_RECURSIVE_TARGETS], AM_EXTRA_RECURSIVE_TARGETS([test]))\nm4_ifdef([AM_EXTRA_RECURSIVE_TARGETS], AM_EXTRA_RECURSIVE_TARGETS([test-bundle]))\n\nAPI_VER=2.0\nAC_SUBST(API_VER)\n\nAC_PROG_LN_S\n\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n\nMONO_VERSION_MAJOR=`echo $VERSION | cut -d . -f 1`\nMONO_VERSION_MINOR=`echo $VERSION | cut -d . -f 2`\nMONO_VERSION_BUILD=`echo $VERSION | cut -d . -f 3`\n\n#\n# This is the version of the corlib-runtime interface. When\n# making changes to this interface (by changing the layout\n# of classes the runtime knows about, changing icall signature or\n# semantics etc), change this variable.\n#\n# This must be unique relative to corlib interface and semantics.\n#\n# If you change corlib such that a runtime change is required, or\n# vice versa, change this string. Examples include removing icalls,\n# adding icalls, changing icall signatures, and changing type layouts\n# that both sides know.\n#\n# It is an arbitrary string and should be parsed as such.\n# A guid works and is encouraged.\n#\n# Generate it with uuidgen. For example:\n# perl -pi.bak -e \"s/^MONO_CORLIB_VERSION=\\S+/MONO_CORLIB_VERSION=`uuidgen`/\" configure.ac\n#\n# There is no ordering of corlib versions, no old or new,\n# an exact match is required between corlib and runtime.\n#\n# This line is parsed by tools besides autoconf, such as msvc/mono.winconfig.targets.\n# It should remain in the format they expect.\n#\nMONO_CORLIB_VERSION=ABB721D6-116A-4555-B4FD-9248146D2051\n\n#\n# Put a quoted #define in config.h.\n# Substitute @MONO_CORLIB_VERSION@ unquoted.\n#\nAC_DEFINE_UNQUOTED(MONO_CORLIB_VERSION,\"$MONO_CORLIB_VERSION\",[Version of the corlib-runtime interface])\nAC_SUBST(MONO_CORLIB_VERSION)\n\ncase $host_os in\n*cygwin* )\n\t\t echo \"Run configure using ./configure --host=i686-w64-mingw32 or --host=x86_64-w64-mingw32\"\n\t\t exit 1\nesac\n\n# In case of cygwin, override LN_S, irrespective of what it determines.\n# The build uses cygwin, but the actual runtime doesn't.\ncase $host_os in\n*cygwin* ) LN_S='cp -p';;\nesac\n\n#\n# libgc defaults\n#\nlibgc_configure_args=\n\n# These variables are the CPPFLAGS/CFLAGS passed to libgc's configure\n# libgc should inherit the original CFLAGS/CPPFLAGS passed to configure, i.e. -O0\nCPPFLAGS_FOR_LIBGC=$CPPFLAGS\nCFLAGS_FOR_LIBGC=$CFLAGS\nCPPFLAGS_FOR_BTLS=$CPPFLAGS\nCFLAGS_FOR_BTLS=$CFLAGS\n\n# libgc uses some deprecated APIs\nCFLAGS_FOR_LIBGC=\"$CFLAGS -Wno-deprecated-declarations\"\n\n#\n# These are the flags that need to be stored in the mono.pc file for \n# compiling code that will embed Mono\n#\nlibmono_cflags=\"\"\nlibmono_ldflags=\"\"\nAC_SUBST(libmono_cflags)\nAC_SUBST(libmono_ldflags)\n\n# Variable to have relocatable .pc files (lib, or lib64)\n# realpath isn't always available, and requires that all but the tip of the provided\n# path exists. Fall back to the old behaviour, but realpath allows depth >1\n# e.g. Debian puts Mono in /usr/bin and libs in /usr/lib/x86_64-linux-gnu/ which is\n# too deep for the old method to work\nreloc_libdir=`realpath --relative-to=${prefix} ${libdir} 2> /dev/null || basename ${libdir}`\nAC_SUBST(reloc_libdir)\n\n# Set to yes if Unix sockets cannot be created in an anonymous namespace\nneed_link_unlink=no\n\n#Set to extra linker flags to be passed to the runtime binaries (mono /mono-sgen)\nextra_runtime_ldflags=\"\"\n\n# Thread configuration inspired by sleepycat's db\nAC_MSG_CHECKING([host platform characteristics])\n\nlibgc_threads=no\nhas_dtrace=no\nparallel_mark=yes\nikvm_native=yes\n\nhost_win32=no\ntarget_win32=no\ntarget_wasm=no\nplatform_android=no\nplatform_tizen=no\nplatform_ios=no\nhost_darwin=no\nhost_linux=no\nbuild_darwin=no\n\ncase \"$host\" in\n\twasm32*)\n\t\tCFLAGS=\"$CFLAGS -D_REENTRANT -D_GNU_SOURCE -s WASM=1\"\n\t\tCPPFLAGS=\"$CPPFLAGS -D_REENTRANT -DUSE_MMAP -s WASM=1\"\n\t\tlibgc_threads=pthreads\n\t\tplatform_wasm=yes\n\t\t# FIXME:\n\t\tRID=\"osx-x64\"\n\t\tCOREARCH=\"x64\"\n\t\tCORETARGETS=\"-p:TargetsUnix=true -p:TargetsOSX=true\"\n\t\tbuild_darwin=yes\n\t\t;;\n\t*-mingw*|*-*-cygwin*)\n\t\tAC_DEFINE(DISABLE_PORTABILITY,1,[Disable the io-portability layer])\n\t\tAC_DEFINE(HOST_NO_SYMLINKS,1,[This platform does not support symlinks])\n\t\thost_win32=yes\n\t\tmono_cv_clang=no\n\t\tif test \"x$cross_compiling\" = \"xno\"; then\n\t\t\tif test \"x$host\" = \"x$build\" -a \"x$host\" = \"x$target\"; then\n\t\t\t\ttarget_win32=yes\n\t\t\tfi\n\t\telse\n\t\t\tif test \"x$host\" = \"x$target\"; then\n\t\t\t\ttarget_win32=yes\n\t\t\tfi\n\t\tfi\n\t\tHOST_CC=\"gcc\"\n\t\tRID=\"win-x86\"\n\t\tCORETARGETS=\"-p:TargetsWindows=true\"\n\t\tCOREARCH=\"x86\"\n\t\t# Boehm not supported on 64-bit Windows.\n\t\tcase \"$host\" in\n\t\tx86_64-*-* | amd64-*-*)\n\t\t\tsupport_boehm=no\n\t\t\twith_gc=sgen\n\t\t\tRID=\"win-x64\"\n\t\t\tCOREARCH=\"x64\"\n\t\t\t;;\n\t\tesac\n\n\t\t# Windows 7 or later is required\n\t\tWIN32_CPPFLAGS=\"-DWINVER=0x0601 -D_WIN32_WINNT=0x0601 -D_WIN32_IE=0x0501 -D_UNICODE -DUNICODE -DWIN32_THREADS -DFD_SETSIZE=1024\"\n\t\tCPPFLAGS=\"$CPPFLAGS $WIN32_CPPFLAGS\"\n\t\tWIN32_LDFLAGS=\"-lbcrypt -lmswsock -lws2_32 -lole32 -loleaut32 -lpsapi -lversion -ladvapi32 -lwinmm -lkernel32 -liphlpapi -static-libgcc\"\n\t\tLDFLAGS=\"$LDFLAGS $WIN32_LDFLAGS\"\n\t\tlibmono_cflags=\"-mms-bitfields -mwindows\"\n\t\tlibmono_ldflags=\"-mms-bitfields -mwindows\"\n\t\tlibgc_threads=win32\n\t\twith_sigaltstack=no\n\t\twith_tls=pthread\n\t\twith_sgen_default_concurrent=yes\n\t\tLN_S=cp\n\n\t\t# This forces libgc to use the DllMain based thread registration code on win32\n\t\tlibgc_configure_args=\"$libgc_configure_args --enable-win32-dllmain=yes\"\n\t\t;;\n\t*-*-*netbsd*)\n\t\tCPPFLAGS=\"$CPPFLAGS -D_REENTRANT -DGC_NETBSD_THREADS -D_GNU_SOURCE\"\n\t\tlibmono_cflags=\"-D_REENTRANT\"\n\t\tLDFLAGS=\"$LDFLAGS -pthread\"\n\t\tCPPFLAGS=\"$CPPFLAGS -DHOST_BSD\"\n\t\tlibmono_ldflags=\"-pthread\"\n\t\tneed_link_unlink=yes\n\t\tlibgc_threads=pthreads\n\t\twith_sigaltstack=no\n\t\tuse_sigposix=yes\n\t\twith_sgen_default_concurrent=yes\n\t\t;;\n\t*-*-kfreebsd*-gnu)\n\t\tCPPFLAGS=\"$CPPFLAGS -DGC_FREEBSD_THREADS -D_GNU_SOURCE -D_REENTRANT -DUSE_MMAP -DUSE_MUNMAP -DTHREAD_LOCAL_ALLOC -pthread\"\n\t\tlibmono_cflags=\"-D_REENTRANT -DTHREAD_LOCAL_ALLOC -pthread\"\n\t\tlibmono_ldflags=\"-lpthread -pthread\"\n\t\tlibgc_threads=pthreads\n\t\tneed_link_unlink=yes\n\t\twith_sigaltstack=no\n\t\tuse_sigposix=yes\n\t\twith_sgen_default_concurrent=yes\n\t\t;;\n\t*-*-*freebsd*)\n\t\tdnl For close_my_fds\n\t\tLDFLAGS=\"$LDFLAGS -lutil\"\n\t\tif test \"x$PTHREAD_CFLAGS\" = \"x\"; then\n\t\t\tCPPFLAGS=\"$CPPFLAGS -DGC_FREEBSD_THREADS\"\n\t\t\tlibmono_cflags=\n\t\telse\n\t\t\tCPPFLAGS=\"$CPPFLAGS $PTHREAD_CFLAGS -DGC_FREEBSD_THREADS\"\n\t\t\tlibmono_cflags=\"$PTHREAD_CFLAGS\"\n\t\tfi\n\t\tif test \"x$PTHREAD_LIBS\" = \"x\"; then\n\t\t\tLDFLAGS=\"$LDFLAGS -pthread -L/usr/local/lib\"\n\t\t\tlibmono_ldflags=\"-pthread\"\n\t\telse\n\t\t\tLDFLAGS=\"$LDFLAGS $PTHREAD_LIBS -L/usr/local/lib\"\n\t\t\tlibmono_ldflags=\"$PTHREAD_LIBS\"\n\t\tfi\n\t\tCPPFLAGS=\"$CPPFLAGS -DHOST_BSD -D_WITH_GETLINE\"\n\t\tneed_link_unlink=yes\n\t\tAC_DEFINE(PTHREAD_POINTER_ID, 1, [pthread is a pointer])\n\t\tlibgc_threads=pthreads\n\t\tuse_sigposix=yes\n\t\thas_dtrace=yes\n\t\tcase \"$host\" in\n\t\taarch64-*)\n\t\t\tsupport_boehm=no\n\t\t\twith_gc=sgen\n\t\t\t;;\n\t\triscv*)\n\t\t\tsupport_boehm=no\n\t\t\twith_gc=sgen\n\t\t\t;;\n\t\tesac\n\t\twith_sgen_default_concurrent=yes\n\t\t;;\n\t*-*-*openbsd*)\n\t\tCPPFLAGS=\"$CPPFLAGS -D_THREAD_SAFE -DGC_OPENBSD_THREADS -DHOST_BSD -D_REENTRANT -DUSE_MMAP\"\n\t\tLDFLAGS=\"${LDFLAGS} -Wl,-zwxneeded\"\n\t\tif test \"x$disable_munmap\" != \"xyes\"; then\n\t\tCPPFLAGS=\"$CPPFLAGS -DUSE_MUNMAP\"\n\t\tfi\n\t\tlibmono_cflags=\"-D_THREAD_SAFE -D_REENTRANT\"\n\t\tLDFLAGS=\"$LDFLAGS -pthread\"\n\t\tneed_link_unlink=yes\n\t\tAC_DEFINE(PTHREAD_POINTER_ID)\n\t\tlibgc_threads=pthreads\n\t\twith_tls=pthread\n\t\twith_sigaltstack=no\n\t\tuse_sigposix=yes\n\t\twith_sgen_default_concurrent=yes\n\t\t;;\n\t*-*-linux-android*)\n\t\tplatform_android=yes\n\t\tAC_DEFINE(HOST_ANDROID,1,[Targeting the Android platform])\n\t\tAC_DEFINE(TARGET_ANDROID,1,[Targeting the Android platform])\n\n\t\tCPPFLAGS=\"$CPPFLAGS -DGC_LINUX_THREADS -D_GNU_SOURCE -D_REENTRANT -DUSE_MMAP\"\n\t\tif test \"x$disable_munmap\" != \"xyes\"; then\n\t\t\tCPPFLAGS=\"$CPPFLAGS -DUSE_MUNMAP\"\n\t\tfi\n\t\tlibmono_cflags=\"-D_REENTRANT\"\n\t\tlibgc_threads=pthreads\n\t\tuse_sigposix=yes\n\n\t\twith_tls=pthread\n\t\twith_sigaltstack=no\n\t\twith_static_mono=no\n\n\t\t# Android doesn't support boehm, as it's missing <link.h>\n\t\tsupport_boehm=no\n\t\twith_gc=sgen\n\n\t\t# isinf(3) requires -lm\n\t\tLDFLAGS=\"$LDFLAGS -lm\"\n\n\t\t# Bionic's <pthread.h> sets PTHREAD_STACK_MIN=2*PAGE_SIZE; doesn't define\n\t\t# PAGE_SIZE; breaks mono/io-layer/collection.c\n\t\t# Bionic doesn't provide S_IWRITE; breaks io-layer/io.c\n\t\tCFLAGS=\"$CFLAGS -DPAGE_SIZE=4096 -DS_IWRITE=S_IWUSR\"\n\t\tCXXFLAGS=\"$CXXFLAGS -DPAGE_SIZE=4096 -DS_IWRITE=S_IWUSR\"\n\n\t\t# FIXME? Only if __ANDROID_API__ < 24?\n\t\t# FILE32API means \"long\", which is stuck at 32bits for 32bit ABI (64bits for 64bit ABI).\n\t\t# ABI 24 introduces the \"o\" for \"file offset\" variations, which can be widened to 64bits for 32bit ABI (and still 64bits for 64bit).\n\t\t# Android itself uses FILE32API, and mono should use system zlib on Android anyway.\n\t\tZLIB_CFLAGS=\"$ZLIB_CFLAGS -DUSE_FILE32API\"\n\n\t\t# to bypass the underscore linker check, can't work when cross-compiling\n\t\tmono_cv_uscore=yes\n\t\tmono_cv_clang=no\n\t\t;;\n\t*-*-linux*)\n\t\thost_linux=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -DGC_LINUX_THREADS -D_GNU_SOURCE -D_REENTRANT -DUSE_MMAP\"\n\t\tif test \"x$disable_munmap\" != \"xyes\"; then\n\t\t\tCPPFLAGS=\"$CPPFLAGS -DUSE_MUNMAP\"\n\t\tfi\n\t\tlibmono_cflags=\"-D_REENTRANT\"\n\t\tlibgc_threads=pthreads\n\t\tCORETARGETS=\"-p:TargetsUnix=true\"\n\t\tuse_sigposix=yes\n\t\tif test \"x$cross_compiling\" != \"xno\"; then\n                \t# to bypass the underscore linker check, not\n                \t# available during cross-compilation\n                \tmono_cv_uscore=no\n                fi\n\t\tcase \"$host\" in\n\t\t*-tizen-linux-*)\n\t\t\tplatform_tizen=yes\n\t\t\t;;\n\t\tesac\n\t\tcase \"$host\" in\n\t\tppc64-*)\n\t\t\tRID=\"linux-ppc64\"\n\t\t\t;;\n\t\tppc64le-*)\n\t\t\tRID=\"linux-ppc64el\"\n\t\t\t;;\n\t\tmipsel-*)\n\t\t\tRID=\"linux-mipsel\"\n\t\t\t;;\n\t\tx86-*)\n\t\t\tRID=\"linux-x86\"\n\t\t\tCOREARCH=\"x86\"\n\t\t\t;;\n\t\tx86_64-*)\n\t\t\tRID=\"linux-x64\"\n\t\t\tCOREARCH=\"x64\"\n\t\t\t;;\n\t\tarm-*)\n\t\t\t# deal with this in the FPU detection section, since\n\t\t\t# we cannot determine FPU from triplet and don't want\n\t\t\t# to duplicate the logic\n\t\t\t;;\n\t\taarch64-*)\n\t\t\tsupport_boehm=no\n\t\t\twith_gc=sgen\n\t\t\tRID=\"linux-arm64\"\n\t\t\tCOREARCH=\"arm64\"\n\t\t\t;;\n\t\tpowerpc*-*-linux*)\n\t\t\t# https://bugzilla.novell.com/show_bug.cgi?id=504411\n\t\t\tdisable_munmap=yes\n\t\t\t;;\n\t\triscv*)\n\t\t\tsupport_boehm=no\n\t\t\twith_gc=sgen\n\t\t\t;;\n\t\tesac\n\t\twith_sgen_default_concurrent=yes\n\t\t;;\n\t*-*-nacl*)\n\t\techo \"nacl no longer supported.\"\n\t\texit 1\n\t\t;;\n\t*-*-hpux*)\n\t\tCPPFLAGS=\"$CPPFLAGS -DGC_HPUX_THREADS -D_HPUX_SOURCE -D_XOPEN_SOURCE_EXTENDED -D_REENTRANT\"\n\t\t# +ESdbgasm only valid on bundled cc on RISC\n\t\t# silently ignored for ia64\n\t\tif test $GCC != \"yes\"; then\n\t\t\tCFLAGS=\"$CFLAGS +ESdbgasm\"\n\t\t\t# Arrange for run-time dereferencing of null\n\t\t\t# pointers to produce a SIGSEGV signal.\n\t\t\tLDFLAGS=\"$LDFLAGS -z\"\n\t\tfi\n\t\tCFLAGS=\"$CFLAGS +ESdbgasm\"\n\t\tLDFLAGS=\"$LDFLAGS -z\"\n\t\tlibmono_cflags=\"-D_REENTRANT\"\n\t\tlibmono_ldflags=\"-lpthread\"\n\t\tlibgc_threads=pthreads\n\t\tneed_link_unlink=yes\n\t\tuse_sigposix=yes\n\t\t;;\n\t*-*-solaris*)\n\t\tCPPFLAGS=\"$CPPFLAGS -DGC_SOLARIS_THREADS -DGC_SOLARIS_PTHREADS -D_REENTRANT -D_POSIX_PTHREAD_SEMANTICS -DUSE_MMAP -DUSE_MUNMAP -DHOST_SOLARIS\"\n\t\tneed_link_unlink=yes\n\t\tlibmono_cflags=\"-D_REENTRANT\"\n\t\tlibgc_threads=pthreads\n\t\thas_dtrace=yes\n\t\tuse_sigposix=yes\n\t\tenable_solaris_tar_check=yes\n\t\t;;\n\t*-*-darwin*)\n\t\tparallel_mark=\"Disabled_Currently_Hangs_On_MacOSX\"\n\t\thost_darwin=yes\n\t\ttarget_mach=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -D_THREAD_SAFE -DGC_MACOSX_THREADS -DUSE_MMAP -DUSE_MUNMAP\"\n\t\tlibmono_cflags=\"-D_THREAD_SAFE\"\n\t\tneed_link_unlink=yes\n\t\tAC_DEFINE(PTHREAD_POINTER_ID)\n\t\tAC_DEFINE(USE_MACH_SEMA, 1, [...])\n\t\tCORETARGETS=\"-p:TargetsUnix=true -p:TargetsOSX=true\"\n\t\tlibgc_threads=pthreads\n\t\thas_dtrace=yes\n\t\tif test \"x$cross_compiling\" = \"xyes\"; then\n\t\t\thas_broken_apple_cpp=yes\n\t\tfi\n\t\tdnl Snow Leopard is horribly broken -- it reports itself as i386-apple-darwin*, but\n\t\tdnl its gcc defaults to 64-bit mode.  They have also deprecated the usage of ucontext\n\t\tdnl we need to set some flags to build our 32-bit binaries on 10.6 properly\n\t\tcase \"$host\" in\n\t\t\tdnl Snow Leopard and newer config.guess reports as this\n\t\t\ti*86-*-darwin*)\n\t\t\t\tBROKEN_DARWIN_FLAGS=\"-arch i386\"\n\t\t\t\tBROKEN_DARWIN_CPPFLAGS=\"\"\n\t\t\t\tCPPFLAGS=\"$CPPFLAGS $BROKEN_DARWIN_CPPFLAGS\"\n\t\t\t\tCFLAGS=\"$CFLAGS $BROKEN_DARWIN_FLAGS\"\n\t\t\t\tCXXFLAGS=\"$CXXFLAGS $BROKEN_DARWIN_FLAGS\"\n\t\t\t\tCCASFLAGS=\"$CCASFLAGS $BROKEN_DARWIN_FLAGS\"\n\t\t\t\tCPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC $BROKEN_DARWIN_CPPFLAGS\"\n\t\t\t\tCFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC $BROKEN_DARWIN_FLAGS\"\n\t\t\t\twith_sgen_default_concurrent=yes\n\t\t\t\tRID=\"osx-x86\"\n\t\t\t\tCOREARCH=\"x86\"\n\t\t\t\t;;\n\t\t\tx*64-*-darwin*)\n\t\t\t\twith_sgen_default_concurrent=yes\n\t\t\t\tRID=\"osx-x64\"\n\t\t\t\tCOREARCH=\"x64\"\n\t\t\t\t;;\n\t\t\tarm*-darwin*)\n\t\t\t\tplatform_ios=yes\n\t\t\t\thas_dtrace=no\n\t\t\t\t;;\n\t\t\taarch64*-darwin*)\n\t\t\t\tplatform_ios=yes\n\t\t\t\t;;\n\t\tesac\n\t\t;;\n\t*-*-haiku*)\n\t\tdnl BSD_SOURCE is for getifaddrs\n\t\tCPPFLAGS=\"$CPPFLAGS -D_BSD_SOURCE -D_REENTRANT -D_THREAD_SAFE\"\n\t\tlibmono_cflags=\"-D_REENTRANT -D_THREAD_SAFE\"\n\t\tLIBS=\"$LIBS -lnetwork -ltextencoding\"\n\t\tneed_link_unlink=yes\n\t\tAC_DEFINE(PTHREAD_POINTER_ID)\n\t\tdnl Haiku does not support static TLS with __thread\n\t\twith_tls=pthread\n\t\tlibgc_threads=pthreads\n\t\tuse_sigposix=yes\n\t\twith_sigaltstack=no\n\t\t;;\n\t*-*-fuchsia*)\n\t\tAC_DEFINE(DISABLE_PORTABILITY,1,[Disable the io-portability layer])\n\t\tAC_DEFINE(HOST_FUCHSIA,1,[Targeting the Fuchsia platform])\n\t\tfuchsia=true\n\t\twith_tls=pthread\n\t\twith_sigaltstack=yes\n\t\twith_static_mono=no\n\t\tsupport_boehm=no\n\t\twith_gc=sgen\n\t\tmono_cv_uscore=yes\n\t\tmono_cv_clang=no\n\t\t;;\n\t*-*-aix*|*-*-os400*)\n\t\tdnl IMPORTANT: For svr4 sonames on AIX, you should set\n\t\tdnl `OBJECT_MODE=64` when configuring.\n\t\tdnl libtool cannot generate functioning svr4 sonames on\n\t\tdnl 64-bit without it.\n\t\tdnl Unfortunately, everything is complicated by the fact that\n\t\tdnl gcc doesn't respect this variable. (otherwise we could set\n\t\tdnl it for build time for configure and make)\n\t\tdnl On IBM i PASE using IBM's packages, GCC *does* respect this\n\t\tdnl variable, and builds are 64-bit by default. svr4 sonames\n\t\tdnl must still be specified when configuring on i, however.\n\t\tdnl As such, because Mono doesn't support 32-bit AIX or PASE,\n\t\tdnl set up a 64-bit build (assming GCC; XLC not supported)\n\t\tdnl regardless of what variable is used.\n\t\tcase $host_os in\n\t\t\taix*)\n\t\t\tif test \"x$OBJECT_MODE\" = \"x64\" && test \"x$CC\" = \"x\" && test \"x$CXX\" = \"x\"; then\n\t\t\t\tdnl HACK: Set -maix64 at the GCC invocation\n\t\t\t\tdnl level explicitly to work around the fact\n\t\t\t\tdnl GCC in default maix32 mode explodes when\n\t\t\t\tdnl binutils respects OBJECT_MODE.\n\t\t\t\tdnl When that check occurs, flags are not\n\t\t\t\tdnl passed to to the compiler, so GCC has no\n\t\t\t\tdnl chance to change its mode.\n\t\t\t\tdnl Otherwise, it may enter a state where it\n\t\t\t\tdnl runs, but uses the libtool \"compile\"\n\t\t\t\tdnl wrapper, which subtly breaks other things.\n\t\t\t\tdnl This should propagate to all uses of CC.\n\t\t\t\tdnl This is only set if not manually set.\n\t\t\t\tCC=\"gcc -maix64\"\n\t\t\t\tCXX=\"g++ -maix64\"\n\t\t\t\techo\n\t\t\tfi\n\t\t\t;;\n\t\t\tdnl Not needed on i because it defaults to 64-bit and\n\t\t\tdnl has a GCC smart enough to respect OBJECT_MODE.\n\t\tesac\n\t\tdnl We still set this for *FLAGS, however, because we may not\n\t\tdnl be setting OBJECT_MODE.\n\t\tLDFLAGS=\"$LDFLAGS -maix64\"\n\t\tCPPFLAGS=\"$CPPFLAGS -maix64 -DGC_AIX_THREADS -D_ALL_SOURCE -D_THREAD_SAFE -D_LARGE_FILES -D_REENTRANT\"\n\t\tlibmono_cflags=\"-D_THREAD_SAFE -D_REENTRANT\"\n\t\tdnl Would you believe GNU nm doesn't know how to process AIX libraries?\n\t\tdnl Hardcode IBM binutils in case GNU ones end up on our path. Also\n\t\tdnl specifiy 64-bit mode for tools. (OBJECT_MODE is finicky with cmake.)\n\t\tdnl XXX: We should stop the hardcoding madness\n\t\tAR=\"/usr/bin/ar -X64\"\n\t\tNM=\"/usr/bin/nm -X64\"\n\t\tSTRIP=\"/usr/bin/strip -X64\"\n\t\tRANLIB=\"/usr/bin/ranlib -X64\"\n\t\tdnl SGen is the future (changes to Boehm support code would be\n\t\tdnl required if you wish to re-enable Boehm)\n\t\tsupport_boehm=no\n\t\twith_gc=sgen\n\t\tneed_link_unlink=yes\n\t\tuse_sigposix=yes\n\t\tdnl Similar limitation to macOS about the first thread and the\n\t\tdnl guard page, except sometimes the runtime hangs. Disable for\n\t\tdnl now until cause can be determined or it seems OK enough.\n\t\twith_sigaltstack=no\n\t\tdnl use pthread TLS, __thread has issues with the compiler flags we use\n\t\twith_tls=pthread\n\t\tdnl ppc Linux is the same? test further\n\t\tdisable_munmap=yes\n\t\tRID=\"aix-ppc64\"\n\t\tCORETARGETS=\"-p:TargetsUnix=true\"\n\t\t;;\n\t*)\n\t\tAC_MSG_WARN([*** Please add $host to configure.ac checks!])\n\t\t;;\nesac\n\nAC_MSG_RESULT(ok)\n\nif test x$need_link_unlink = xyes; then\n   AC_DEFINE(NEED_LINK_UNLINK, 1, [Define if Unix sockets cannot be created in an anonymous namespace])\nfi\n\nif test x$host_win32 = xyes; then\n   AC_DEFINE(HOST_WIN32, 1, [Host Platform is Win32])\nfi\n\nif test x$target_win32 = xyes; then\n   AC_DEFINE(TARGET_WIN32, 1, [Target Platform is Win32])\nfi\n\nif test x$host_darwin = xyes; then\n   AC_DEFINE(HOST_DARWIN, 1, [Host Platform is Darwin])\nfi\n\n# Defined for all targets/platforms using classic Windows API support.\nAC_DEFINE(HAVE_CLASSIC_WINAPI_SUPPORT, 1, [Use classic Windows API support])\nAC_DEFINE(HAVE_UWP_WINAPI_SUPPORT, 0, [Don't use UWP Windows API support])\n\nAC_SUBST(extra_runtime_ldflags)\nAM_CONDITIONAL(HOST_WIN32, test x$host_win32 = xyes)\nAM_CONDITIONAL(TARGET_WIN32, test x$target_win32 = xyes)\nAM_CONDITIONAL(HOST_LINUX, echo x$target_os | grep -q linux)\nAM_CONDITIONAL(HOST_DARWIN, test x$host_darwin = xyes)\nAM_CONDITIONAL(HOST_SIGPOSIX, test x$use_sigposix = xyes)\nAM_CONDITIONAL(HOST_ANDROID, test x$platform_android = xyes)\nAM_CONDITIONAL(HOST_TIZEN, test x$platform_tizen = xyes)\nAM_CONDITIONAL(HOST_IOS, test x$platform_ios = xyes)\nAM_CONDITIONAL(HOST_WASM, test x$platform_wasm = xyes)\n\nif test -z \"$HOST_DARWIN_TRUE\"; then :\nPLATFORM_AOT_SUFFIX=.dylib\nPLATFORM_AOT_PREFIX=lib\nfi\n\nif test -z \"$HOST_LINUX_TRUE\"; then :\nPLATFORM_AOT_SUFFIX=.so\nPLATFORM_AOT_PREFIX=lib\nfi\n\nif test -z \"$HOST_WIN32_TRUE\"; then :\nPLATFORM_AOT_SUFFIX=.dll\nPLATFORM_AOT_PREFIX=\nfi\n\nAC_SUBST(PLATFORM_AOT_SUFFIX)\nAC_SUBST(PLATFORM_AOT_PREFIX)\n\nif test -z \"$HOST_WASM_TRUE\"; then :\nAC_DEFINE(HAVE_UTIME)\nAC_DEFINE(HAVE_UTIMES)\nfi\n\n## PLATFORM_AOT_SUFFIX not so simple for windows :-)\n\nAC_CHECK_TOOL(CC, gcc, gcc)\nAC_PROG_CC\nAC_CHECK_TOOL(CXX, g++, g++)\nAC_PROG_CXX\nAM_PROG_AS\nAC_PROG_INSTALL\nAC_PROG_AWK\nAM_PROG_CC_C_O\ndnl We should use AM_PROG_AS, but it's not available on automake/aclocal 1.4\n: ${CCAS='$(CC)'}\n# Set ASFLAGS if not already set.\n: ${CCASFLAGS='$(CFLAGS)'}\nAC_SUBST(CCAS)\nAC_SUBST(CCASFLAGS)\n\nif test \"x$CXX\" = \"xno\"; then\n\tAC_MSG_ERROR([No c++ compiler found. You need to install a c++ compiler])\nfi\n\n# AC_PROG_CXX helpfully sets CXX to g++ even if no c++ compiler is found so check\n# GXX instead. See http://lists.gnu.org/archive/html/bug-autoconf/2002-04/msg00056.html\nif test \"x$CXX\" = \"xg++\"; then\n\tif test \"x$GXX\" != \"xyes\"; then\n\t\t# automake/libtool is so broken, it requires g++ even if the c++ sources\n\t\t# are inside automake conditionals\n\t\tAC_MSG_ERROR([You need to install g++])\n\tfi\nfi\n\ndnl may require a specific autoconf version\ndnl AC_PROG_CC_FOR_BUILD\ndnl CC_FOR_BUILD not automatically detected\nCC_FOR_BUILD=$CC\nCFLAGS_FOR_BUILD=$CFLAGS\nBUILD_EXEEXT=\nif test \"x$cross_compiling\" = \"xyes\"; then\n\tCC_FOR_BUILD=cc\n\tCFLAGS_FOR_BUILD=\n\tBUILD_EXEEXT=\"\"\nfi\nAC_SUBST(CC_FOR_BUILD)\nAC_SUBST(CFLAGS_FOR_BUILD)\nAC_SUBST(HOST_CC)\nAC_SUBST(BUILD_EXEEXT)\n\nAM_CONDITIONAL(CROSS_COMPILING, [test x$cross_compiling = xyes])\nAM_CONDITIONAL(USE_BATCH_FILES, [test x$host_win32 = xyes -a x$cross_compiling = xyes])\n\n# Set STDC_HEADERS\nAC_HEADER_STDC\nAC_LIBTOOL_WIN32_DLL\n# This causes monodis to not link correctly\n#AC_DISABLE_FAST_INSTALL\n\n#lookup makedev() header\nAC_HEADER_MAJOR\n\nAM_PROG_LIBTOOL\n# Use dolt (http://dolt.freedesktop.org/) instead of libtool for building.\nDOLT\n\nexport_ldflags=`(./libtool --config; echo eval echo \\\\$export_dynamic_flag_spec) | sh`\nAC_SUBST(export_ldflags)\n\n# Test whenever ld supports -version-script\nAC_PROG_LD\nAC_PROG_LD_GNU\n\nAC_CHECK_HEADERS(sys/filio.h sys/sockio.h netdb.h utime.h sys/utime.h semaphore.h sys/un.h linux/rtc.h sys/syscall.h sys/mkdev.h sys/uio.h sys/param.h sys/sysctl.h libproc.h sys/prctl.h copyfile.h)\nAC_CHECK_HEADERS(sys/param.h sys/socket.h sys/ipc.h sys/utsname.h alloca.h ucontext.h pwd.h sys/select.h netinet/tcp.h netinet/in.h unistd.h sys/types.h link.h asm/sigcontext.h sys/inotify.h arpa/inet.h complex.h unwind.h)\n\n# zlib/configure checks for unistd.h existance and defines HAVE_UNISTD_H on the compiler\n# command line (not config.h) if it is present.\nAC_CHECK_HEADER(unistd.h,\n    [HAVE_UNISTD_H=1\n     ZLIB_CFLAGS=\"$ZLIB_CFLAGS -DHAVE_UNISTD_H\"],\n    [HAVE_UNISTD_H=0])\n\nAC_SUBST(HAVE_UNISTD_H)\n\nAC_CHECK_HEADERS([linux/netlink.h linux/rtnetlink.h],\n                  [], [], [#include <stddef.h>\n\t\t  #include <sys/socket.h>\n\t\t  #include <linux/socket.h>])\n\nAC_CHECK_HEADERS(sys/user.h, [], [],\n[\n#ifdef HAVE_SYS_PARAM_H\n# include <sys/param.h>\n#endif\n])\n\nAC_CHECK_HEADERS(linux/serial.h)\n\ncase \"$host\" in\n\t# Use bundled zlib on Windows to be sure it is static.\n\t*-mingw*|*-cygwin*)\n\t\thave_sys_zlib=no\n\t\tzlib_msg=\"bundled zlib\"\n\t\t;;\n\t*)\n\t\tAC_CHECK_HEADER(zlib.h, [have_sys_zlib=yes], [have_sys_zlib=no])\n\t\tif test x$have_sys_zlib = xyes; then\n\t\t\tAC_TRY_COMPILE([#include <zlib.h>], [\n\t\t\t\t#if defined(ZLIB_VERNUM) && (ZLIB_VERNUM >= 0x1230)\n\t\t\t\t#else\n\t\t\t\t#error No good zlib found\n\t\t\t\t#endif\n\t\t\t],[\n\t\t\t\tAC_MSG_RESULT(Using system zlib)\n\t\t\t\tzlib_msg=\"system zlib\"\n\t\t\t\thave_sys_zlib=yes\n\t\t\t],[\n\t\t\t\tAC_MSG_RESULT(zlib too old, using embedded zlib)\n\t\t\t\thave_sys_zlib=no\n\t\t\t\tzlib_msg=\"bundled zlib\"\n\t\t\t])\n\t\telse\n\t\t\tAC_MSG_RESULT(zlib not found, using embedded zlib)\n\t\t\thave_sys_zlib=no\n\t\t\tzlib_msg=\"bundled zlib\"\n\t\tfi\n\t\t;;\nesac\n\nAC_ARG_WITH(static-zlib, [  --with-static-zlib=PATH    use the specified static zlib instead of -lz],[STATIC_ZLIB_PATH=$with_static_zlib],[STATIC_ZLIB_PATH=])\nif test \"x$STATIC_ZLIB_PATH\" != \"x\"; then\n\thave_static_zlib=yes\n\thave_sys_zlib=no\n\tzlib_msg=\"static zlib from $STATIC_ZLIB_PATH\"\n\tAC_SUBST(STATIC_ZLIB_PATH)\nfi\n\nAM_CONDITIONAL(HAVE_STATIC_ZLIB, test x$have_static_zlib = xyes)\nAM_CONDITIONAL(HAVE_SYS_ZLIB, test x$have_sys_zlib = xyes)\nif test x$have_static_zlib = xyes; then\n\tAC_DEFINE(HAVE_STATIC_ZLIB, 1, [Use static zlib])\nfi\nif test x$have_sys_zlib = xyes; then\n\tAC_DEFINE(HAVE_SYS_ZLIB, 1, [Use OS-provided zlib])\nfi\n# for mono/metadata/debug-symfile.c\nAC_CHECK_HEADERS(elf.h)\n\n# for support\nAC_CHECK_HEADERS(poll.h)\nAC_CHECK_HEADERS(sys/poll.h)\nAC_CHECK_HEADERS(sys/wait.h)\nAC_CHECK_HEADERS(grp.h)\nAC_CHECK_HEADERS(syslog.h)\nAC_CHECK_FUNCS(vsyslog)\n\n# for mono/dis\nAC_CHECK_HEADERS(wchar.h)\n\n# for Linux statfs support\nAC_CHECK_HEADERS(linux/magic.h)\n\n# For Android NDK unified headers\nif test x$platform_android = xyes; then\n\tAC_CHECK_HEADERS(machine/endian.h sys/endian.h)\n\tAC_CHECK_HEADERS(android/legacy_signal_inlines.h, [have_android_signal_inlines=yes], [have_android_signal_inlines=no])\n\tAC_CHECK_HEADERS(android/ndk-version.h)\n\n\t# Make sure SIGRT{MIN,MAX} work - they will fail to work with unified headers if building for\n\t# API level < 21 *and* android/legacy_signal_inlines.h doesn't declare (and define) the required\n\t# libc APIs to obtain values for SIGRT{MIN,MAX}. We perform the check only if android/legacy_signal_inlines.h\n\t# is found because in other cases the macros will either work (for NDK < 14) or fail if the legacy header\n\t# doesn't contain the required definitions (NDK 14)\n\tif test x$have_android_signal_inlines = xyes; then\n\t\tAC_MSG_CHECKING([Whether Android SIGRTMIN/SGRTMAX macros are valid])\n\t\tAC_COMPILE_IFELSE([\n\t\t\tAC_LANG_PROGRAM([#include <signal.h>\n\t\t\t\t#include <android/legacy_signal_inlines.h>],[\n\t\t\t\tint i;\n\t\t\t\tfor (i = SIGRTMIN + 1; i < SIGRTMAX; ++i) {\n\t\t\t\t}\n\t\t\t])],[\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\tandroid_sigrtminmax_work=yes\n\t\t\t],[\n\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t\tandroid_sigrtminmax_work=no\n\t\t\t]\n\t\t)\n\n\t\tif test x$android_sigrtminmax_work = xno; then\n\t\t\tAC_MSG_ERROR([Android SIGRTMIN/SIGRTMAX macros don't work in this NDK])\n\t\tfi\n\tfi\n\n\t# Attempt to detect whether we're using Android NDK unified headers\n\tAC_CHECK_HEADERS(android/api-level.h, [have_android_api_level=yes], [have_android_api_level=no])\n\tAC_CHECK_HEADERS(android/versioning.h, [have_android_versioning=yes], [have_android_versioning=no])\n\n\tandroid_unified_headers=no\n\tif test x$have_android_api_level = xyes; then\n\t\tif test x$have_android_versioning = xyes; then\n\t\t\tAC_MSG_CHECKING([whether using Android NDK unified headers])\n\n\t\t\t# Both macros are defined only in the NDK unified headers\n\t\t\tAC_COMPILE_IFELSE([\n\t\t\t\tAC_LANG_PROGRAM([\n\t\t\t\t\t#include <android/api-level.h>\n\t\t\t\t\t#include <android/versioning.h>\n\t\t\t\t],[\n\t\t\t\t\t#if __ANDROID_API_O__ == 26 && defined(__INTRODUCED_IN)\n\t\t\t\t\t#else\n\t\t\t\t\t\t#error __ANDROID_API_O__ != 26 or the __INTRODUCED_IN macro not defined\n\t\t\t\t\t#endif\n\t\t\t\t])],[\n\t\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\t\tandroid_unified_headers=yes\n\t\t\t\t],[\n\t\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t\t\tandroid_unified_headers=no\n\t\t\t\t]\n\t\t\t)\n\t\tfi\n\tfi\n\n\tif test x$android_unified_headers = xyes; then\n\t\tAC_DEFINE(ANDROID_UNIFIED_HEADERS, 1, [Whether Android NDK unified headers are used])\n\tfi\nfi # Android\n\n# not 64 bit clean in cross-compile\nAC_CHECK_SIZEOF(void *)\nAC_CHECK_SIZEOF(long)\n\nAC_CHECK_SIZEOF(int)\nAC_CHECK_SIZEOF(long long)\n\nAC_CACHE_CHECK([for clang],\n\tmono_cv_clang,[\n\tAC_TRY_COMPILE([], [\n\t\t#ifdef __clang__\n\t\t#else\n\t\t#error \"FAILED\"\n\t\t#endif\n\t],\n\t[mono_cv_clang=yes],\n\t[mono_cv_clang=no],\n\t[])\n])\n\nAC_ARG_ENABLE(visibility-hidden,\n[  --disable-visibility-hidden    disable usage of -fvisiblity=hidden],\n   disable_visibility_hidden=yes, disable_visibility_hidden=no)\n\nWARN=''\nif test x\"$GCC\" = xyes; then\n\t\tWARN='-Wall -Wunused -Wmissing-declarations -Wpointer-arith -Wno-cast-qual -Wwrite-strings -Wno-switch -Wno-switch-enum -Wno-unused-value -Wno-attributes'\n\t\tCFLAGS=\"$CFLAGS -Wmissing-prototypes -Wstrict-prototypes -Wnested-externs -Wno-format-zero-length\"\n\n\t\t# We require C99 with some GNU extensions, e.g. `linux` macro\n\t\tCFLAGS=\"$CFLAGS -std=gnu99\"\n\n\t\t# The runtime code does not respect ANSI C strict aliasing rules\n\t\tCFLAGS=\"$CFLAGS -fno-strict-aliasing\"\n\n\t\t# We rely on signed overflow to behave\n\t\tCFLAGS=\"$CFLAGS -fwrapv\"\n\n\t\tCFLAGS=\"$CFLAGS -DMONO_DLL_EXPORT\"\n\t\tif test x\"$disable_visibility_hidden\" = xno; then\n\t\t   # Don't export any symbols by default\n\t\t   SHARED_CFLAGS=\"-fvisibility=hidden\"\n\t\t   CXXFLAGS=\"$CXXFLAGS -fvisibility=hidden\"\n\t\tfi\n\n\t\tORIG_CFLAGS=$CFLAGS\n\t\t# Check for the normal version, since gcc ignores unknown -Wno options\n\t\tCFLAGS=\"$CFLAGS -Wunused-but-set-variable -Werror\"\n\t\tAC_MSG_CHECKING(for -Wno-unused-but-set-variable option to gcc)\n\t\tAC_TRY_COMPILE([],[\n\t\t], [\n\t\t   AC_MSG_RESULT(yes)\n\t\t   CFLAGS=\"$ORIG_CFLAGS -Wno-unused-but-set-variable\"\n\t\t], [\n\t\t   AC_MSG_RESULT(no)\n\t\t   CFLAGS=$ORIG_CFLAGS\n\t\t])\n\n\t\tif test \"x$mono_cv_clang\" = \"xyes\"; then\n\t   \t   # https://bugzilla.samba.org/show_bug.cgi?id=8118\n\t   \t   WARN=\"$WARN -Qunused-arguments\"\n\t\t   WARN=\"$WARN -Wno-unused-function -Wno-tautological-compare -Wno-parentheses-equality -Wno-self-assign -Wno-return-stack-address -Wno-constant-logical-operand\"\n\t\t   # We rely on zero length arrays in structs\n\t\t   WARN=\"$WARN -Wno-zero-length-array\"\n\t\tfi\nelse\n\t# The Sun Forte compiler complains about inline functions that access static variables\n\t# so disable all inlining.\n\tcase \"$host\" in\n\t*-*-solaris*)\n\t\tCFLAGS=\"$CFLAGS -Dinline=\"\n\t\t;;\n\tesac\nfi\nCFLAGS=\"$WARN $CFLAGS -g\"\nCFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -g\"\nCPPFLAGS=\"$WARN $CPPFLAGS -g\"\n\n# Where's the 'mcs' source tree?\nif test -d $srcdir/mcs; then\n  mcsdir=mcs\nelse\n  mcsdir=../mcs\nfi\n\nAC_ARG_WITH(mcs-path, [  --with-mcs-path=/path/to/mcs      Specify an alternate mcs source tree],\n\tif test x$with_mcs_path != \"x\" -a -d $with_mcs_path ; then\n\t\tmcsdir=$with_mcs_path\n\tfi\n)\n\nAC_ARG_WITH(jumptables, [  --with-jumptables=yes,no      enable/disable support for jumptables (ARM-only for now) (defaults to no)],[],[with_jumptables=no])\n\nAC_ARG_WITH(core,       [  --with-core=only       controls whether to build Mono as a .NET Core runtime (defaults to no)],[],[with_core=no])\nif test x$with_core = xonly; then\n    AC_DEFINE(ENABLE_NETCORE,1,[Enables the support for .NET Core Features in the MonoVM])\n    with_runtime_preset=netcore\nfi\nAM_CONDITIONAL(ENABLE_NETCORE, test x$with_core = xonly)\n\n#\n# A sanity check to catch cases where the package was unpacked\n# with an ancient tar program (Solaris)\n#\nAC_ARG_ENABLE(solaris-tar-check,\n[  --disable-solaris-tar-check    disable solaris tar check],\n   do_solaris_tar_check=no, do_solaris_tar_check=yes)\n\nif test x\"$do_solaris_tar_check\" = xyes -a x\"$enable_solaris_tar_check\" = xyes; then\n   \tAC_MSG_CHECKING(integrity of package)\n\tif test -f $mcsdir/class/System.Runtime.Serialization.Formatters.Soap/System.Runtime.Serialization.Formatters.Soap/SoapTypeMapper.cs\n   \tthen\n\t\tAC_MSG_RESULT(ok)\n   \telse\n\t\terrorm=\"Your mono distribution is incomplete;  if unpacking from a tar file, make sure you use GNU tar;  see http://www.mono-project.com/IncompletePackage for more details\"\n\t\tAC_MSG_ERROR([$errorm])\n\tfi\nfi\n\nif test \"x$with_mcs_path\" != \"x\"; then\nmcs_topdir=$(cd \"$mcsdir\" && pwd)\nmcs_topdir_from_srcdir=$mcs_topdir\nelse\nmcs_topdir=$(cd \"$srcdir/$mcsdir\" && pwd)\nmcs_topdir_from_srcdir='$(top_builddir)'/$mcsdir\nfi\n\n# Convert mcs_topdir* paths to Windows syntax.\nif test x$cross_compiling$host_win32 = xnoyes; then\n  mcs_topdir=$(cygpath -m $mcs_topdir)\n  case $mcs_topdir_from_srcdir in\n    /cygdrive/*)\n\tmcs_topdir_from_srcdir=$(cygpath -m $mcs_topdir_from_srcdir)\n\t;;\n  esac\nfi\n\nAC_SUBST([mcs_topdir])\nAC_SUBST([mcs_topdir_from_srcdir])\n\n# gettext: prepare the translation directories. \n# we do not configure the full gettext, as we consume it dynamically from C#\nAM_PO_SUBDIRS\n\nif test \"x$USE_NLS\" = \"xyes\"; then\n   AC_CHECK_PROG(HAVE_MSGFMT, msgfmt,yes,no)\n\n   if test \"x$HAVE_MSGFMT\" = \"xno\"; then\n\t  AC_MSG_ERROR([msgfmt not found. You need to install the 'gettext' package, or pass --enable-nls=no to configure.])\n   fi\nfi\n\nAC_PATH_PROG(PKG_CONFIG, pkg-config, no)\n\npkg_config_path=\nAC_ARG_WITH(crosspkgdir, [  --with-crosspkgdir=/path/to/pkg-config/dir      Change pkg-config dir to custom dir],\n\tif test x$with_crosspkgdir = \"x\"; then\n\t\tif test -s $PKG_CONFIG_PATH; then\n\t\t\tpkg_config_path=$PKG_CONFIG_PATH\n\t\tfi\n\telse\n\t\tpkg_config_path=$with_crosspkgdir\n\t\tPKG_CONFIG_PATH=$pkg_config_path\n\t\texport PKG_CONFIG_PATH\n\tfi\n)\n\nAC_ARG_ENABLE(ninja,[  --enable-ninja    Enable using ninja where available], enable_ninja=$enableval)\nAC_CHECK_PROG(HAVE_NINJA, ninja, yes, no)\nAM_CONDITIONAL(NINJA, test x$enable_ninja = xyes -a x$HAVE_NINJA != xno)\n\nAC_ARG_ENABLE(werror, [  --enable-werror Pass -Werror to the C compiler], werror_flag=$enableval, werror_flag=no)\nif test x$werror_flag = xyes; then\n\tWERROR_CFLAGS=\"-Werror\"\nfi\nAC_SUBST([WERROR_CFLAGS])\nAC_SUBST([SHARED_CFLAGS])\n\nGLIB_CFLAGS='-I$(top_srcdir)/mono/eglib -I$(top_builddir)/mono/eglib'\n  \nAC_SUBST(GLIB_CFLAGS)\n\n# Enable support for fast thread-local storage\n# Some systems have broken support, so we allow to disable it.\nAC_ARG_WITH(tls, [  --with-tls=__thread,pthread    select Thread Local Storage implementation (defaults to __thread)],[],[with_tls=__thread])\n\n# Enable support for using sigaltstack for SIGSEGV and stack overflow handling\n# This does not work on some platforms (bug #55253)\nAC_ARG_WITH(sigaltstack, [  --with-sigaltstack=yes,no      enable/disable support for sigaltstack (defaults to yes)],[],[with_sigaltstack=yes])\n\nAC_ARG_WITH(static_mono, [  --with-static_mono=yes,no      link mono statically to libmono (faster) (defaults to yes)],[],[with_static_mono=yes])\nAC_ARG_WITH(shared_mono, [  --with-shared_mono=yes,no      build a shared libmono library (defaults to yes)],[],[with_shared_mono=yes])\n# Same as --with-shared_mono=no\nAC_ARG_ENABLE(libraries, [  --disable-libraries disable the build of libmono], enable_libraries=$enableval, enable_libraries=yes)\n\nif test \"x$enable_static\" = \"xno\"; then\n   with_static_mono=no\nfi\n\nif test \"x$enable_shared\" = \"xno\"; then\n   with_shared_mono=no\nfi\n\nif test \"x$enable_libraries\" = \"xno\"; then\n   with_shared_mono=no\nfi\n\nAM_CONDITIONAL(DISABLE_LIBRARIES, test x$enable_libraries = xno)\n\nif test \"x$host_win32\" = \"xyes\"; then\n   # Boehm GC requires the runtime to be in its own dll\n   with_static_mono=no\nfi\n\nAM_CONDITIONAL(STATIC_MONO, test x$with_static_mono != xno)\nAM_CONDITIONAL(SHARED_MONO, test x$with_shared_mono != xno)\nAC_ARG_ENABLE(mcs-build, [  --disable-mcs-build disable the build of the mcs directory], try_mcs_build=$enableval, enable_mcs_build=yes)\nAC_ARG_ENABLE(support-build, [  --disable-support-build disable the build of the support directory], try_support_build=$enableval, enable_support_build=yes)\n\nAC_ARG_WITH(xen_opt,   [  --with-xen_opt=yes,no          Enable Xen-specific behaviour (defaults to yes)],[],[with_xen_opt=yes])\nif test \"x$with_xen_opt\" = \"xyes\" -a \"x$mono_cv_clang\" = \"xno\"; then\n\tAC_DEFINE(MONO_XEN_OPT, 1, [Xen-specific behaviour])\n\tORIG_CFLAGS=$CFLAGS\n\tCFLAGS=\"$CFLAGS -mno-tls-direct-seg-refs\"\n\tAC_MSG_CHECKING(for -mno-tls-direct-seg-refs option to gcc)\n\tAC_TRY_COMPILE([], [\n\t], [\n\t   AC_MSG_RESULT(yes)\n\t   # Pass it to libgc as well\n\t   CFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -mno-tls-direct-seg-refs\"\n\t], [\n\t   AC_MSG_RESULT(no)\n\t   CFLAGS=$ORIG_CFLAGS\n\t])\nfi\n\nAC_ARG_ENABLE(small-config, [  --enable-small-config Enable tweaks to reduce requirements (and capabilities)], enable_small_config=$enableval, enable_small_config=no)\n\nif test x$enable_small_config = xyes; then\n\tAC_DEFINE(MONO_SMALL_CONFIG,1,[Reduce runtime requirements (and capabilities)])\n\tCFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -DSMALL_CONFIG\"\nfi\n\nAC_ARG_ENABLE(system-aot, [  --enable-system-aot  Enable the Ahead-Of-Time compilation of system assemblies during the build (on by default on some platforms)], enable_system_aot=$enableval, enable_system_aot=default)\n\nDISABLED_FEATURES=none\ncsc_compiler=default\nendian=unknown\nAC_C_BIGENDIAN([endian=big],[endian=little],[endian=unknown])\nAC_MSG_CHECKING([CSharp compiler to use])\nAC_ARG_WITH(csc, [  --with-csc=mcs,roslyn,default      Configures the CSharp compiler to use],[\n   if test x$withval = xmcs; then\n       csc_compiler=mcs\n   elif test x$withval = xroslyn; then\n       csc_compiler=roslyn\n   elif test x$withval = xdefault; then\n       :\n   else\n       AC_MSG_ERROR([You must supply one of \"mcs\", \"roslyn\" or \"default\" to the --with-csc option])\n   fi\n],[csc_compiler=default])\n\nif test $csc_compiler = default; then\n   if test $endian = big; then\n      csc_compiler=mcs\n   elif test $endian = little; then\n      case \"$host\" in\n        powerpc*) csc_compiler=mcs ;;\n        *) csc_compiler=roslyn ;;\n      esac\n   else\n      csc_compiler=mcs\n   fi\nfi\nAC_MSG_RESULT($csc_compiler)\n\nAC_ARG_WITH(jemalloc,             [  --with-jemalloc=yes,no               If jemalloc is enabled (defaults to no)],                                     [], [with_jemalloc=no])\nAC_ARG_WITH(jemalloc-always,      [  --with-jemalloc_always=yes,no        If jemalloc is enabled and always used (defaults to yes)],                    [], [with_jemalloc_always=no])\nAC_ARG_WITH(jemalloc-assert,      [  --with-jemalloc_assert=yes,no        If jemalloc performs runtime checks for memory correctness (defaults to no)], [], [with_jemalloc_assert=no])\n\n\nif test x$target_win32 = xyes; then\nwith_jemalloc=no\nwith_jemalloc_assert=no\nwith_jemalloc_always=no\nfi\n\nAM_CONDITIONAL(MONO_JEMALLOC_ASSERT, [test \"x$with_jemalloc_assert\" = \"xyes\"])\nif test \"x$with_jemalloc_assert\" = \"xyes\"; then\nJEMALLOC_CFLAGS+=\" -DMONO_JEMALLOC_ASSERT\"\nAC_DEFINE(MONO_JEMALLOC_ASSERT, 1, [Make jemalloc assert for mono])\nAC_SUBST(MONO_JEMALLOC_ASSERT, 1)\nfi\n\nAM_CONDITIONAL(MONO_JEMALLOC_DEFAULT, [test \"x$with_jemalloc_always\" = \"xyes\"])\nif test \"x$with_jemalloc_always\" = \"xyes\"; then\nwith_jemalloc=yes\nJEMALLOC_CFLAGS+=\" -DMONO_JEMALLOC_DEFAULT\"\nAC_DEFINE(MONO_JEMALLOC_DEFAULT, 1, [Make jemalloc default for mono])\nAC_SUBST(MONO_JEMALLOC_DEFAULT, 1)\nfi\n\nAM_CONDITIONAL(MONO_JEMALLOC_ENABLED, [test \"x$with_jemalloc\" = \"xyes\"])\nif test \"x$with_jemalloc\" = \"xyes\"; then\nJEMALLOC_LDFLAGS=\"-L`pwd`/mono/utils/jemalloc/jemalloc/lib -ljemalloc_pic\"\nJEMALLOC_CFLAGS+=\" -DMONO_JEMALLOC_ENABLED -I `pwd`/mono/utils/jemalloc/jemalloc/include\"\nJEMALLOC_AUTOCONF_FLAGS=\" --build=$target --host=$host\"\n\nif test \"x$target_mach\" = \"xyes\"; then\n\tJEMALLOC_CPPFLAGS=\" -stdlib=libc++ \"\nfi\n\nAC_DEFINE(MONO_JEMALLOC_ENABLED, 1, [Enable jemalloc usage for mono])\nAC_SUBST(MONO_JEMALLOC_ENABLED, 1)\n\nAC_SUBST(JEMALLOC_CFLAGS)\nAC_SUBST(JEMALLOC_CPPFLAGS)\nAC_SUBST(JEMALLOC_LDFLAGS)\nAC_SUBST(JEMALLOC_AUTOCONF_FLAGS)\nfi\n\n# Terminology:\n# Crash privacy - Attempts to not send identifying information in the crash dump / to protect the obscurity of the program control flow\n# MERP - The MS telemetry profile. Not for general use.\n# Structured crashes - crashes at runtime that trigger a stack walk by mono that happens cooperatively\n\n# Structured crashes are not merp crashes. Structured crashes are json dumps made by mono during crashes. Merp upload is going to use the dumping code is a very specific way, and is enabled at runtime with an icall.\n\n#--with-crash_privacy=yes --with-structured_crashes=no means we don't wanna dump in non-merp-enabled builds, and we want to not send symbol strings. This is going to be the default pair of settings for VS4Mac.\n#--with-crash_privacy=yes --with-structured_crashes=yes means you want to see crashes on your console, and you want to not see unmanaged symbol names. This is an option for proprietary apps that have manual bugs filed.\n#--with-crash_privacy=no --with-structured_crashes=no means you want to see no crash dumps on failure and you don't care about privacy. This is how you'd set a \"don't want it, don't care\" configuration.\n#--with-crash_privacy=no --with-structured_crashes=yes means you want full crashes and you want to see them in the terminal, not on telemetry. This is going to be how we build for CI.\n\nAC_ARG_WITH(crash-privacy,       [  --with-crash_privacy=yes,no         If you want your crashes to not include names of symbols present in the binary. ], [], [with_crash_privacy=yes])\nAC_ARG_WITH(structured-crashes,  [  --with-structured_crashes=yes,no    If you want your unmanaged crashes to result in a small crash dump file. ],        [], [with_structured_crashes=yes])\nAC_ARG_ENABLE(crash-reporting,  [  --disable-crash-reporting            Enable or Disable crash reporting subsystem],        [crash_reporting=$enableval], [crash_reporting=yes])\n\nif test \"x$with_crash_privacy\" = \"xyes\"; then\nAC_DEFINE(MONO_PRIVATE_CRASHES,1,[Do not include names of unmanaged functions in the crash dump])\nfi\n\nif test \"x$with_structured_crashes\" = \"xno\"; then\nAC_DEFINE(DISABLE_STRUCTURED_CRASH,1,[Do not create structured crash files during unmanaged crashes])\nfi\n\ncase \"$host\" in\n\t*-mingw*|*-*-cygwin*|*-*-aix*|*-*-os400*)\n\t\tcrash_reporting=no\n\t\t;;\nesac\n\nif test \"x$crash_reporting\" != \"xyes\"; then\nCFLAGS=\"$CFLAGS -DDISABLE_CRASH_REPORTING=1\"\nCXXFLAGS=\"$CXXFLAGS -DDISABLE_CRASH_REPORTING=1\"\nfi\n\nAC_ARG_ENABLE(monodroid, [ --enable-monodroid Enable runtime support for Monodroid (Xamarin.Android)], enable_monodroid=$enableval, enable_monodroid=no)\nAM_CONDITIONAL(ENABLE_MONODROID, test x$enable_monodroid = xyes)\n\nAC_ARG_ENABLE(monotouch, [ --enable-monotouch Enable runtime support for Monotouch (Xamarin.iOS and Xamarin.Mac)], enable_monotouch=$enableval, enable_monotouch=no)\nAM_CONDITIONAL(ENABLE_MONOTOUCH, test x$enable_monotouch = xyes)\n\nif test x$enable_monodroid = xyes; then\n\tAC_DEFINE(ENABLE_MONODROID, 1, [Enable runtime support for Monodroid (Xamarin.Android)])\nfi\n\nif test x$enable_monotouch = xyes; then\n\tAC_DEFINE(ENABLE_MONOTOUCH, 1, [Enable runtime support for Monotouch (Xamarin.iOS and Xamarin.Mac)])\nfi\n\nAC_ARG_ENABLE(cxx, [  --enable-cxx   compile some code as C++])\n\n# mono/corefx/native has a lot of invalid C++98 in its headers\n# dotnet/corefx/native looks a lot better, i.e. 44e5bdafb8d989a220c9cf1b94f31a64a6e4f052\n#CXXFLAGS_COMMON=' -std=gnu++98 -fno-exceptions -fno-rtti '\nCXXFLAGS_COMMON=' -std=gnu++0x -fno-exceptions -fno-rtti '\n# \"c++0x\" instead of C++11, for compat with Centos6/gcc4.4\n\n# -stdlib=libc++ is needed by clang for iOS 6.0 (-miphoneos-version-min=6.0)\n# to support C++11 headers but it does not seem to harm elsewhere, so over-approximate\n# and add it whenever we're running clang on Darwin.\nif test \"x$mono_cv_clang\" = xyes -a x$host_darwin = xyes; then\n\tCXXFLAGS_COMMON=\"$CXXFLAGS_COMMON -stdlib=libc++\"\nfi\n\nAC_SUBST(CXXFLAGS_COMMON)\n\nif test \"x$enable_cxx\" = \"xyes\"; then\n\n\tCXX_ADD_CFLAGS=\" -xc++ $CXXFLAGS_COMMON \"\n\n\t# -std=gnu99 -xc++ is not allowed and errors.\n\tCXX_REMOVE_CFLAGS=-std=gnu99\n\t# These give warnings and should be removed. They are C-only.\n\t# i.e. C++ never allows these, they are always errors and their warningness is not controllable.\n\tCXX_REMOVE_CFLAGS=\"$CXX_REMOVE_CFLAGS -Wmissing-prototypes -Wstrict-prototypes -Wnested-externs\"\n\t# Likewise with CentOS 6 gcc 4.4.\n\tCXX_REMOVE_CFLAGS=\"$CXX_REMOVE_CFLAGS -Werror-implicit-function-declaration\"\n\n\t# The C-only-ness of -Wno-format-zero-length varies with gcc version.\n\t# It is C-only prior to 4.7. Using it with C++ prior to 4.7\n\t# generates a warning every time we run gcc which is very unsightly.\n\t# The warning is for e.g. sprintf(foo, \"\") which can just be\n\t# foo[0] = 0 but Mono's use is more elaborate, not as easy to \"fix\",\n\t# and completely legal and valid.\n\t# We have to switch to C++ and not just use -xc++ because of -std=gnu99 (error when combined with -xc++).\n\t# Alternatively, just run $CXX -xc++ -c /dev/null.\n\tAC_LANG_PUSH(C++)\n\tORIG_CXXFLAGS=$CXXFLAGS\n\tCXXFLAGS=\"$CXXFLAGS -Werror -Wno-format-zero-length -xc++ \"\n\tAC_MSG_CHECKING(or C-only-ness of -Wno-format-zero-length)\n\tAC_TRY_COMPILE([ ], [ ], [ AC_MSG_RESULT(yes) ],\n\t\t\t\t [ AC_MSG_RESULT(no)\n\t\t\t\t   CXX_REMOVE_CFLAGS=\"$CXX_REMOVE_CFLAGS -Wno-format-zero-length\" ])\n\tCXXFLAGS=$ORIG_CXXFLAGS\n\tAC_LANG_POP(C++)\nfi\nAC_SUBST(CXX_ADD_CFLAGS)\nAC_SUBST(CXX_REMOVE_CFLAGS)\n\n#\n# Set the build profiles and options before things which use them\n#\n\nAC_ARG_WITH(profile4_x,          [  --with-profile4_x=yes,no            If you want to install the 4.x FX (defaults to yes)],                       [], [with_profile4_x=default])\nAC_ARG_WITH(monodroid,           [  --with-monodroid=yes,no             If you want to build the MonoDroid assemblies (defaults to no)],            [], [with_monodroid=default])\nAC_ARG_WITH(monotouch,           [  --with-monotouch=yes,no             If you want to build the Xamarin.iOS assemblies (defaults to no)],          [], [with_monotouch=default])\nAC_ARG_WITH(monotouch_watch,     [  --with-monotouch_watch=yes,no       If you want to build the Xamarin.WatchOS assemblies (defaults to no)],      [], [with_monotouch_watch=default])\nAC_ARG_WITH(monotouch_tv,        [  --with-monotouch_tv=yes,no          If you want to build the Xamarin.TVOS assemblies (defaults to no)],         [], [with_monotouch_tv=default])\nAC_ARG_WITH(bitcode,             [  --with-bitcode=yes,no               If bitcode is enabled (defaults to no)],                                    [], [with_bitcode=default])\nAC_ARG_WITH(xammac,              [  --with-xammac=yes,no                If you want to build the Xamarin.Mac assemblies (defaults to no)],          [], [with_xammac=default])\nAC_ARG_WITH(testing_aot_full_interp,  [  --with-testing_aot_full_interp=yes,no    If you want to build the testing_aot_full_interp assemblies (defaults to no)],   [], [with_testing_aot_full_interp=default])\nAC_ARG_WITH(testing_aot_hybrid,  [  --with-testing_aot_hybrid=yes,no    If you want to build the testing_aot_hybrid assemblies (defaults to no)],   [], [with_testing_aot_hybrid=default])\nAC_ARG_WITH(testing_aot_full,    [  --with-testing_aot_full=yes,no      If you want to build the testing_aot_full assemblies (defaults to no)],     [], [with_testing_aot_full=default])\nAC_ARG_WITH(winaot,              [  --with-winaot=yes,no                If you want to build the Windows friendly AOT assemblies (defaults to no)], [], [with_winaot=default])\nAC_ARG_WITH(testing_winaot_interp,    [  --with-testing_winaot_interp=yes,no      If you want to build the Windows friendly AOT + Interpreter testing assemblies (defaults to no)], [], [with_testing_winaot_interp=default])\nAC_ARG_WITH(orbis,               [  --with-orbis=yes,no                 If you want to build the Orbis assemblies (defaults to no)], [], [with_orbis=default])\nAC_ARG_WITH(unreal,              [  --with-unreal=yes,no                If you want to build the Unreal assemblies (defaults to no)], [], [with_unreal=default])\nAC_ARG_WITH(wasm,                [  --with-wasm=yes,no                  If you want to build the WebAssembly (defaults to no)], [], [with_wasm=default])\n\n\nAC_ARG_WITH(runtime-preset, [  --with-runtime-preset=net_4_x,all,aot,aot_llvm,hybridaot,hybridaot_llvm,fullaot,fullaot_llvm,winaot,winaotinterp,winaot_llvm,winaotinterp_llvm,bitcode,bitcodeinterp,unreal,fullaotinterp,fullaotinterp_llvm  Which default profile to build (defaults to net_4_x)],  [], [with_runtime_preset=net_4_x])\nAC_ARG_WITH(spectre-mitigation,             [  --with-spectre-mitigation=yes,no   If you want to build the runtime with compiler flags that enable Spectre mitigation (defaults to no)], [], [with_spectre_mitigation=default])\nAC_ARG_WITH(spectre-indirect-branch-choice,   [  --with-spectre-indirect-branch-choice=keep,thunk,inline,extern   Convert indirect branches to the specified kind of thunk (defaults to inline)], [], [with_spectre_indirect_branch_choice=inline])\nAC_ARG_WITH(spectre-function-return-choice, [  --with-spectre-function-return-choice=keep,thunk,inline,extern   Convert function return instructions to the specified kind of thunk (defaults to inline)], [], [with_spectre_function_return_choice=inline])\n\ndnl\ndnl Spectre compiler mitigation flag checks\ndnl\nif test \"x$with_spectre_mitigation\" = \"xyes\"; then\n   AC_MSG_NOTICE([Compiler Spectre mitigation support checks])\n   SPECTRE_CFLAGS=\n   SPECTRE_INDIRECT_BRANCH_KIND=\n   case \"x$with_spectre_indirect_branch_choice\" in\n       xkeep) SPECTRE_INDIRECT_BRANCH_KIND=keep ;;\n       xthunk) SPECTRE_INDIRECT_BRANCH_KIND=thunk ;;\n       xinline) SPECTRE_INDIRECT_BRANCH_KIND=thunk-inline ;;\n       xextern) SPECTRE_INDIRECT_BRANCH_KIND=thunk-extern ;;\n       *) AC_MSG_ERROR([Invalid indirect jump thunk kind ($with_spectre_indirect_branch_choice)]) ;;\n   esac\n\n   SPECTRE_FUNCTION_RETURN_KIND=\"\"\n   case \"x$with_spectre_function_return_choice\" in\n       xkeep) SPECTRE_FUNCTION_RETURN_KIND=keep ;;\n       xthunk) SPECTRE_FUNCTION_RETURN_KIND=thunk ;;\n       xinline) SPECTRE_FUNCTION_RETURN_KIND=thunk-inline ;;\n       xextern) SPECTRE_FUNCTION_RETURN_KIND=thunk-extern ;;\n       *) AC_MSG_ERROR([Invalid function return thunk kind ($with_spectre_function_return_choice)]) ;;\n   esac\n\n   AX_CHECK_COMPILE_FLAG(\n\t[ -mindirect-branch=$SPECTRE_INDIRECT_BRANCH_KIND ],\n\t[ SPECTRE_CFLAGS=\"$SPECTRE_CFLAGS -mindirect-branch=$SPECTRE_INDIRECT_BRANCH_KIND\" ]\n   )\n\n   AX_CHECK_COMPILE_FLAG(\n\t[ -mfunction-return=$SPECTRE_FUNCTION_RETURN_KIND ],\n\t[ SPECTRE_CFLAGS=\"$SPECTRE_CFLAGS -mfunction-return=$SPECTRE_FUNCTION_RETURN_KIND\" ]\n   )\n\n   if test \"x$SPECTRE_CFLAGS\" != \"x\" ; then\n        CFLAGS=\"$CFLAGS $SPECTRE_CFLAGS\"\n\tCXXFLAGS=\"$CXXFLAGS $SPECTRE_CFLAGS\"\n\tspectre_mitigation_status=\"mitigation enabled\"\n   fi\nelse\n\tspectre_mitigation_status=\"no mitigation\"\nfi\n\ndnl\ndnl Profile defaults\ndnl\nTEST_PROFILE=default\nenable_llvm_default=no\n\nwith_profile4_x_default=no\nwith_monodroid_default=no\nwith_monotouch_default=no\nwith_monotouch_watch_default=no\nwith_monotouch_tv_default=no\nwith_xammac_default=no\nwith_testing_aot_full_interp_default=no\nwith_testing_aot_hybrid_default=no\nwith_testing_aot_full_default=no\nwith_winaot_default=no\nwith_testing_winaot_interp_default=no\nwith_orbis_default=no\nwith_unreal_default=no\nwith_wasm_default=no\n\nwith_bitcode_default=no\nenable_cooperative_suspend_default=no\nenable_hybrid_suspend_default=no\n\n# For the sake of clearer error messages, these numbers should all be different from each other.\nINVARIANT_AOT_OPTIONS=nimt-trampolines=2000,ntrampolines=10000,nrgctx-fetch-trampolines=256,ngsharedvt-trampolines=4400,nftnptr-arg-trampolines=4000,nrgctx-trampolines=21000\n\nAOT_BUILD_ATTRS=$INVARIANT_AOT_OPTIONS\n\nMONO_LLVM_PATH_OPTION=llvm-path=\"`pwd`/llvm/usr/bin\"\n\nif test x$cross_compiling = xyes -o x$enable_mcs_build = xno; then\n   DISABLE_MCS_DOCS_default=yes\nelif test x$with_runtime_preset = xnetcore; then\n   DISABLE_MCS_DOCS_default=yes\n   BTLS_SUPPORTED=no\n   enable_mcs_build=no\n   enable_support_build=no\n\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_reflection_emit_save='yes'\n   mono_feature_disable_appdomains='yes'\n   mono_feature_disable_cleanup='yes'\n   mono_feature_disable_assembly_remapping='yes'\n   mono_feature_disable_security='yes'\n   mono_feature_disable_mdb='yes'\n   mono_feature_disable_com='yes'\n   mono_feature_disable_gac='yes'\n   mono_feature_disable_perfcounters='yes'\n   mono_feature_disable_attach='yes'\n   disable_mono_native=yes\n   support_boehm=no\nelif test x$with_runtime_preset = xnet_4_x; then\n   with_profile4_x_default=yes\n   TEST_PROFILE=net_4_x\nelif test x$with_runtime_preset = xall; then\n   with_profile4_x_default=yes\n   with_monodroid_default=yes\n   with_monotouch_default=yes\n   with_monotouch_watch_default=yes\n   with_monotouch_tv_default=yes\n   with_xammac_default=yes\n   with_winaot_default=yes\n   with_testing_winaot_interp_default=yes\n   with_orbis_default=yes\n   with_unreal_default=yes\n   with_wasm_default=yes\n   with_testing_aot_full_interp_default=yes\n   with_testing_aot_hybrid_default=yes\n   with_testing_aot_full_default=yes\n   TEST_PROFILE=net_4_x\nelif test x$with_runtime_preset = xbitcode; then\n   DISABLE_MCS_DOCS_default=yes\n   with_testing_aot_full_default=yes\n   with_bitcode_default=yes\n   enable_cooperative_suspend_default=yes\n   # FIXME: use TEST_PROFILE=testing_aot_full\n   TEST_PROFILE=testing_aot_bitcode\n   PLATFORM_TEST_HARNESS_EXCLUDES=BitcodeNotSupported\n   enable_llvm_default=yes\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_reflection_emit_save='yes'\n   mono_feature_disable_reflection_emit='yes'\n   mono_feature_disable_appdomains='yes'\n\n   # We need at least clang++-6.0 to read the LLVM IR produced by the runtime\n   AOT_BUILD_FLAGS=\"--runtime=mobile --aot=llvmonly,clangxx=clang++-6.0,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --llvmonly\"\n   AOT_MODE=\"llvmonly\"\nelif test x$with_runtime_preset = xbitcodeinterp; then\n   with_testing_aot_full_interp_default=yes\n   with_bitcode_default=yes\n   enable_cooperative_suspend_default=yes\n   # FIXME: use TEST_PROFILE=testing_aot_full_interp\n   TEST_PROFILE=testing_aot_bitcode_interp\n   PLATFORM_TEST_HARNESS_EXCLUDES=BitcodeNotSupported\n   enable_llvm_default=yes\n\n   # mscorlib.dll aot compilation crashes\n   mono_feature_disable_com='yes'\n\n   # We need at least clang++-6.0 to read the LLVM IR produced by the runtime\n   AOT_BUILD_FLAGS=\"--aot=llvmonly,interp,clangxx=clang++-6.0,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--llvmonly-interp\"\nelif test x$with_runtime_preset = xfullaot; then\n   DISABLE_MCS_DOCS_default=yes\n   with_testing_aot_full_default=yes\n   TEST_PROFILE=testing_aot_full\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_reflection_emit_save='yes'\n   mono_feature_disable_reflection_emit='yes'\n   mono_feature_disable_appdomains='yes'\n\n   AOT_BUILD_FLAGS=\"--runtime=mobile -O=gsharedvt --aot=full,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --full-aot\"\n   AOT_MODE=\"full\"\nelif test x$with_runtime_preset = xfullaot_llvm; then\n   DISABLE_MCS_DOCS_default=yes\n   with_testing_aot_full_default=yes\n   TEST_PROFILE=testing_aot_full\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_reflection_emit_save='yes'\n   mono_feature_disable_reflection_emit='yes'\n   mono_feature_disable_appdomains='yes'\n\n   AOT_BUILD_FLAGS=\"--runtime=mobile -O=gsharedvt --llvm --aot=full,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --full-aot\"\n   AOT_MODE=\"full\"\nelif test x$with_runtime_preset = xhybridaot; then\n   DISABLE_MCS_DOCS_default=yes\n   with_testing_aot_hybrid_default=yes\n   TEST_PROFILE=testing_aot_hybrid \n\n   AOT_BUILD_FLAGS=\"--runtime=mobile --aot=hybrid,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --hybrid-aot\"\nelif test x$with_runtime_preset = xhybridaot_llvm; then\n   DISABLE_MCS_DOCS_default=yes\n   with_testing_aot_hybrid_default=yes\n   TEST_PROFILE=testing_aot_hybrid\n\n   AOT_BUILD_FLAGS=\"--runtime=mobile --llvm --aot=hybrid,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --hybrid-aot\"\nelif test x$with_runtime_preset = xfullaotinterp; then\n   with_testing_aot_full_interp_default=yes\n   TEST_PROFILE=testing_aot_full_interp\n\n   # mscorlib.dll aot compilation crashes\n   mono_feature_disable_com='yes'\n\n   AOT_BUILD_FLAGS=\"--aot=full,interp,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--full-aot-interp\"\nelif test x$with_runtime_preset = xfullaotinterp_llvm; then\n   with_testing_aot_full_interp_default=yes\n   TEST_PROFILE=testing_aot_full_interp\n\n   # mscorlib.dll aot compilation crashes\n   mono_feature_disable_com='yes'\n\n   AOT_BUILD_FLAGS=\"-O=gsharedvt --llvm --aot=full,interp,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--full-aot-interp\"\nelif test x$with_runtime_preset = xaot; then\n   with_profile4_x_default=yes\n\n   AOT_BUILD_FLAGS=\"--aot=$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"\"\n\n   DISABLE_MCS_DOCS_default=yes\nelif test x$with_runtime_preset = xaot_llvm; then\n   with_profile4_x_default=yes\n\n   AOT_BUILD_FLAGS=\"--llvm --aot=$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"\"\n\n   DISABLE_MCS_DOCS_default=yes\nelif test x$with_runtime_preset = xwinaot; then\n   DISABLE_MCS_DOCS_default=yes\n   with_winaot_default=yes\n   TEST_PROFILE=winaot\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_reflection_emit_save='yes'\n   mono_feature_disable_reflection_emit='yes'\n   mono_feature_disable_appdomains='yes'\n\n   AOT_BUILD_FLAGS=\"--runtime=mobile -O=gsharedvt --aot=full,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --full-aot\"\n   AOT_MODE=\"full\"\nelif test x$with_runtime_preset = xwinaotinterp; then\n   DISABLE_MCS_DOCS_default=yes\n   with_testing_winaot_interp_default=yes\n   TEST_PROFILE=testing_winaot_interp\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_appdomains='yes'\n\n   AOT_BUILD_FLAGS=\"--aot=full,interp,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--full-aot-interp\"\nelif test x$with_runtime_preset = xwinaotinterp_llvm; then\n   DISABLE_MCS_DOCS_default=yes\n   with_testing_winaot_interp_default=yes\n   TEST_PROFILE=testing_winaot_interp\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_appdomains='yes'\n\n   INVARIANT_AOT_OPTIONS=\"llvmllc=-mattr=sse4.1,$INVARIANT_AOT_OPTIONS\"\n   AOT_BUILD_FLAGS=\"-O=gsharedvt --llvm --aot=full,interp,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--full-aot-interp\"\nelif test x$with_runtime_preset = xwinaot_llvm; then\n   DISABLE_MCS_DOCS_default=yes\n   with_winaot_default=yes\n   TEST_PROFILE=winaot\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_reflection_emit_save='yes'\n   mono_feature_disable_reflection_emit='yes'\n   mono_feature_disable_appdomains='yes'\n\n   INVARIANT_AOT_OPTIONS=\"llvmllc=-mattr=sse4.1,$INVARIANT_AOT_OPTIONS\"\n   AOT_BUILD_FLAGS=\"--runtime=mobile -O=gsharedvt --llvm --aot=full,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --full-aot\"\n   AOT_MODE=\"full\"\nelif test x$with_runtime_preset = xorbis; then\n   DISABLE_MCS_DOCS_default=yes\n   with_orbis_default=yes\n   TEST_PROFILE=orbis\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_reflection_emit_save='yes'\n   mono_feature_disable_reflection_emit='yes'\n   mono_feature_disable_appdomains='yes'\n\n   AOT_BUILD_FLAGS=\"--runtime=mobile --aot=full,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --full-aot\"\n   AOT_MODE=\"full\"\nelif test x$with_runtime_preset = xunreal; then\n   DISABLE_MCS_DOCS_default=yes\n   with_unreal_default=yes\n   TEST_PROFILE=unreal\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_appdomains='no'\n\n   AOT_BUILD_FLAGS=\"--runtime=mobile --aot=hybrid,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --hybrid-aot\"\nelif test x$with_runtime_preset = xwasm; then\n   DISABLE_MCS_DOCS_default=yes\n   with_wasm_default=yes\n   TEST_PROFILE=wasm\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_reflection_emit_save='yes'\n   mono_feature_disable_reflection_emit='yes'\n   mono_feature_disable_appdomains='yes'\n\n   AOT_BUILD_FLAGS=\"--runtime=mobile --aot=full,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --full-aot\"\nelse\n   TEST_PROFILE=net_4_x\n   with_profile4_x_default=yes\nfi\n\nif test \"x$AOT_BUILD_FLAGS\" != \"x\"; then :\n   AC_SUBST(AOT_BUILD_FLAGS)\n   AC_SUBST(AOT_RUN_FLAGS)\n   # For llvmonlycheck + fullaotcheck\n   AC_SUBST(INVARIANT_AOT_OPTIONS)\nfi\n\nAC_SUBST(TEST_PROFILE)\n\nif test \"x$with_profile4_x\" = \"xdefault\"; then\n   with_profile4_x=$with_profile4_x_default\nfi\nif test \"x$with_monodroid\" = \"xdefault\"; then\n   with_monodroid=$with_monodroid_default\nfi\nif test \"x$with_monotouch\" = \"xdefault\"; then\n   with_monotouch=$with_monotouch_default\nfi\nif test \"x$with_monotouch_watch\" = \"xdefault\"; then\n   with_monotouch_watch=$with_monotouch_watch_default\nfi\nif test \"x$with_monotouch_tv\" = \"xdefault\"; then\n   with_monotouch_tv=$with_monotouch_tv_default\nfi\nif test \"x$with_bitcode\" = \"xdefault\"; then\n   with_bitcode=$with_bitcode_default\nfi\nif test \"x$with_xammac\" = \"xdefault\"; then\n   with_xammac=$with_xammac_default\nfi\nif test \"x$with_testing_aot_full_interp\" = \"xdefault\"; then\n   with_testing_aot_full_interp=$with_testing_aot_full_interp_default\nfi\nif test \"x$with_testing_aot_hybrid\" = \"xdefault\"; then\n   with_testing_aot_hybrid=$with_testing_aot_hybrid_default\nfi\nif test \"x$with_testing_aot_full\" = \"xdefault\"; then\n   with_testing_aot_full=$with_testing_aot_full_default\nfi\nif test \"x$with_winaot\" = \"xdefault\"; then\n   with_winaot=$with_winaot_default\nfi\nif test \"x$with_testing_winaot_interp\" = \"xdefault\"; then\n   with_testing_winaot_interp=$with_testing_winaot_interp_default\nfi\nif test \"x$with_orbis\" = \"xdefault\"; then\n   with_orbis=$with_orbis_default\nfi\nif test \"x$with_unreal\" = \"xdefault\"; then\n   with_unreal=$with_unreal_default\nfi\nif test \"x$with_wasm\" = \"xdefault\"; then\n   with_wasm=$with_wasm_default\nfi\n\n\nAM_CONDITIONAL(INSTALL_4_x, [test \"x$with_profile4_x\" = \"xyes\"])\nAM_CONDITIONAL(INSTALL_MONODROID, [test \"x$with_monodroid\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_MONOTOUCH, [test \"x$with_monotouch\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_MONOTOUCH_WATCH, [test \"x$with_monotouch_watch\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_MONOTOUCH_TV, [test \"x$with_monotouch_tv\" != \"xno\"])\nAM_CONDITIONAL(BITCODE, test \"x$with_bitcode\" = \"xyes\")\nAM_CONDITIONAL(INSTALL_XAMMAC, [test \"x$with_xammac\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_TESTING_AOT_FULL_INTERP, [test \"x$with_testing_aot_full_interp\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_TESTING_AOT_HYBRID, [test \"x$with_testing_aot_hybrid\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_TESTING_AOT_FULL, [test \"x$with_testing_aot_full\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_WINAOT, [test \"x$with_winaot\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_TESTING_WINAOT_INTERP, [test \"x$with_testing_winaot_interp\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_ORBIS, [test \"x$with_orbis\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_UNREAL, [test \"x$with_unreal\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_WASM, [test \"x$with_wasm\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_NETCORE, [test \"x$with_core\" != \"xno\"])\n\nAM_CONDITIONAL(HYBRID_AOT_TESTS, [test \"x$TEST_PROFILE\" = \"xtesting_aot_hybrid\"] || [test \"x$TEST_PROFILE\" = \"xunreal\"])\nAM_CONDITIONAL(FULL_AOT_TESTS, [test \"x$TEST_PROFILE\" = \"xtesting_aot_full\"] || [test \"x$TEST_PROFILE\" = \"xtesting_aot_bitcode\"] || [test \"x$TEST_PROFILE\" = \"xwinaot\"] || [test \"x$TEST_PROFILE\" = \"xorbis\"] || [test \"x$TEST_PROFILE\" = \"xwasm\"])\nAM_CONDITIONAL(FULL_AOT_INTERP_TESTS, [test \"x$TEST_PROFILE\" = \"xtesting_aot_full_interp\"] || [test \"x$TEST_PROFILE\" = \"xtesting_aot_bitcode_interp\"] || [test \"x$TEST_PROFILE\" = \"xtesting_winaot_interp\"])\nAM_CONDITIONAL(DEFAULT_TESTS, [test \"x$TEST_PROFILE\" = \"xnet_4_x\"])\n\ndefault_profile=net_4_x\nif test -z \"$INSTALL_MONODROID_TRUE\"; then :\n   default_profile=monodroid\nfi\nif test -z \"$INSTALL_MONOTOUCH_TRUE\"; then :\n   default_profile=monotouch\nfi\nif test -z \"$INSTALL_XAMMAC_TRUE\"; then :\n   default_profile=xammac\nfi\nif test -z \"$INSTALL_TESTING_AOT_FULL_INTERP_TRUE\"; then :\n   default_profile=testing_aot_full_interp\nfi\nif test -z \"$INSTALL_TESTING_AOT_HYBRID_TRUE\"; then :\n   default_profile=testing_aot_hybrid\nfi\nif test -z \"$INSTALL_TESTING_AOT_FULL_TRUE\"; then :\n   default_profile=testing_aot_full\nfi\nif test -z \"$INSTALL_WINAOT_TRUE\"; then :\n   default_profile=winaot\nfi\nif test -z \"$INSTALL_TESTING_WINAOT_INTERP_TRUE\"; then :\n   default_profile=testing_winaot_interp\nfi\nif test -z \"$INSTALL_ORBIS_TRUE\"; then :\n   default_profile=orbis\nfi\nif test -z \"$INSTALL_UNREAL_TRUE\"; then :\n   default_profile=unreal\nfi\nif test -z \"$INSTALL_WASM_TRUE\"; then :\n   default_profile=wasm\nfi\nif test -z \"$INSTALL_4_x_TRUE\"; then :\n   default_profile=net_4_x\nfi\nDEFAULT_PROFILE=$default_profile\nAC_SUBST(DEFAULT_PROFILE)\n\n#\n# End build profile configuration\n#\n\nif test x$USE_NLS = xprofile_default; then\n\n\tAC_MSG_CHECKING([NLS used])\n\n\t# We make the default value for USE_NLS\n\t# \"no\" on OSX because it isn't available on most\n\t# default OSX installs. The most common configurations will\n\t# all disable it, so this saves us typing.\n\tif test x$host_darwin = xyes; then\n\t\tUSE_NLS=no;\n\telse\n\t\tUSE_NLS=yes;\n\tfi\n\n\tAC_SUBST([USE_NLS])\n\tAC_MSG_RESULT([$USE_NLS])\nfi\n\nAC_ARG_ENABLE(static-gcc-libs, [  --enable-static-gcc-libs      Statically link GCC support libs (for MinGW32)])\nif test \"x$enable_static_gcc_libs\" = \"xyes\"; then\n\t# llvm/build.mk doesn't use automake, so make a regular make variable for it.\n\tAC_SUBST(STATIC_GCC_LIBS,1)\nfi\nAM_CONDITIONAL(ENABLE_STATIC_GCC_LIBS, test \"x$enable_static_gcc_libs\" = \"xyes\")\n\nAC_ARG_ENABLE(minimal, [  --enable-minimal=LIST      drop support for LIST subsystems.\n     LIST is a comma-separated list from: aot, profiler, decimal, pinvoke, debug, appdomains, verifier, \n     reflection_emit, reflection_emit_save, large_code, logging, com, ssa, generics, attach, jit, interpreter, simd, soft_debug, perfcounters, normalization, desktop_loader, shared_perfcounters, remoting,\n\t security, lldb, mdb, assert_messages, cleanup, sgen_marksweep_conc, sgen_split_nursery, sgen_gc_bridge, sgen_debug_helpers, sockets, gac.],\n[\n\tfor feature in `echo \"$enable_minimal\" | sed -e \"s/,/ /g\"`; do\n\t\teval \"mono_feature_disable_$feature='yes'\"\n\tdone\n\tDISABLED_FEATURES=$enable_minimal\n\tdisabled=\"Disabled:      $enable_minimal\"\n],[])\n\nAC_DEFINE_UNQUOTED(DISABLED_FEATURES, \"$DISABLED_FEATURES\", [String of disabled features])\n\nif test \"x$mono_feature_disable_aot\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_AOT, 1, [Disable AOT Compiler])\n\tenable_system_aot=no\n\tAC_MSG_NOTICE([Disabled AOT compiler])\nfi\n\nif test \"x$mono_feature_disable_profiler\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_PROFILER, 1, [Disable default profiler support])\n\tAC_MSG_NOTICE([Disabled support for the profiler])\nfi\nAM_CONDITIONAL(DISABLE_PROFILER, test x$mono_feature_disable_profiler = xyes)\n\nif test \"x$mono_feature_disable_decimal\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_DECIMAL, 1, [Disable System.Decimal support])\n\tAC_MSG_NOTICE([Disabled support for decimal])\nfi\n\nif test \"x$mono_feature_disable_pinvoke\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_PINVOKE, 1, [Disable P/Invoke support])\n\tAC_MSG_NOTICE([Disabled support for P/Invoke])\nfi\n\nif test \"x$mono_feature_disable_debug\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_DEBUG, 1, [Disable runtime debugging support])\n\tAC_MSG_NOTICE([Disabled support for runtime debugging])\nfi\n\nif test \"x$mono_feature_disable_reflection_emit\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_REFLECTION_EMIT, 1, [Disable reflection emit support])\n\tmono_feature_disable_reflection_emit_save=yes\n\tAC_MSG_NOTICE([Disabled support for Reflection.Emit])\nfi\n\nif test \"x$mono_feature_disable_reflection_emit_save\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_REFLECTION_EMIT_SAVE, 1, [Disable assembly saving support in reflection emit])\n\tAC_MSG_NOTICE([Disabled support for Reflection.Emit.Save])\nfi\n\nif test \"x$mono_feature_disable_large_code\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_LARGE_CODE, 1, [Disable support for huge assemblies])\n\tAC_MSG_NOTICE([Disabled support for large assemblies])\nfi\n\nif test \"x$mono_feature_disable_logging\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_LOGGING, 1, [Disable support debug logging])\n\tAC_MSG_NOTICE([Disabled support for logging])\nfi\n\nif test \"x$mono_feature_disable_com\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_COM, 1, [Disable COM support])\n\tAC_MSG_NOTICE([Disabled COM support])\nfi\n\nif test \"x$mono_feature_disable_ssa\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SSA, 1, [Disable advanced SSA JIT optimizations])\n\tAC_MSG_NOTICE([Disabled SSA JIT optimizations])\nfi\n\nif test \"x$mono_feature_disable_generics\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_GENERICS, 1, [Disable generics support])\n\tAC_MSG_NOTICE([Disabled Generics Support])\nfi\n\nif test \"x$mono_feature_disable_shadowcopy\" = \"xyes\"; then\n   \tAC_DEFINE(DISABLE_SHADOW_COPY, 1, [Disable Shadow Copy for AppDomains])\n\tAC_MSG_NOTICE([Disabled Shadow copy for AppDomains])\nfi\n\nif test \"x$mono_feature_disable_portability\" = \"xyes\"; then\n   \tAC_DEFINE(DISABLE_PORTABILITY, 1, [Disables the IO portability layer])\n\tAC_MSG_NOTICE([Disabled IO Portability layer])\nfi\n\nif test \"x$mono_feature_disable_attach\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_ATTACH, 1, [Disable agent attach support])\n\tAC_MSG_NOTICE([Disabled agent attach])\nfi\n\nif test \"x$mono_feature_disable_verifier\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_VERIFIER, 1, [Disables the verifier])\n\tAC_MSG_NOTICE([Disabled the metadata and IL verifiers])\nfi\n\nif test \"x$mono_feature_disable_jit\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_JIT, 1, [Disable the JIT, only full-aot mode or interpreter will be supported by the runtime.])\n\tAC_MSG_NOTICE([Disabled the JIT engine, only full AOT or interpreter will be supported])\nfi\n\nAM_CONDITIONAL(DISABLE_JIT, test x$mono_feature_disable_jit = xyes)\n\nif test \"x$mono_feature_disable_interpreter\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_INTERPRETER, 1, [Disable the interpreter.])\n\tAC_MSG_NOTICE([Disabled the interpreter])\nfi\n\nAM_CONDITIONAL(DISABLE_INTERPRETER, test x$mono_feature_disable_interpreter = xyes)\n\nif test \"x$mono_feature_disable_interpreter\" != \"xyes\" -o \"x$mono_feature_disable_jit\" != \"xyes\"; then\n\tAC_DEFINE(ENABLE_ILGEN, 1, [Some VES is available at runtime])\nfi\n\nAM_CONDITIONAL(ENABLE_ILGEN, test x$mono_feature_disable_interpreter != xyes -o x$mono_feature_disable_jit != xyes)\n\nif test \"x$mono_feature_disable_simd\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SIMD, 1, [Disable SIMD intrinsics related optimizations.])\n\tAC_MSG_NOTICE([Disabled SIMD support])\nfi\n\nif test \"x$mono_feature_disable_soft_debug\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_DEBUGGER_AGENT, 1, [Disable Soft Debugger Agent.])\n\tAC_MSG_NOTICE([Disabled Soft Debugger.])\nfi\n\nAM_CONDITIONAL(DISABLE_DEBUGGER_AGENT, test x$mono_feature_disable_debugger_agent = xyes)\n\nif test \"x$mono_feature_disable_perfcounters\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_PERFCOUNTERS, 1, [Disable Performance Counters.])\n\tAC_MSG_NOTICE([Disabled Performance Counters.])\nfi\nif test \"x$mono_feature_disable_normalization\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_NORMALIZATION, 1, [Disable String normalization support.])\n\tAC_MSG_NOTICE([Disabled String normalization support.])\nfi\n\n#TODO: remove assembly_remapping feature name once everyone is using desktop_loader\nif test \"x$mono_feature_disable_assembly_remapping\" = \"xyes\" || test \"x$mono_feature_disable_desktop_loader\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_DESKTOP_LOADER, 1, [Disable desktop assembly loader semantics.])\n\tAC_MSG_NOTICE([Disabled desktop assembly loader semantics.])\nfi\n\nif test \"x$mono_feature_disable_shared_perfcounters\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SHARED_PERFCOUNTERS, 1, [Disable shared perfcounters.])\n\tAC_MSG_NOTICE([Disabled Shared perfcounters.])\nfi\n\nif test \"x$mono_feature_disable_appdomains\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_APPDOMAINS, 1, [Disable support for multiple appdomains.])\n\tAC_MSG_NOTICE([Disabled support for multiple appdomains.])\nfi\n\nif test \"x$mono_feature_disable_remoting\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_REMOTING, 1, [Disable remoting support (This disables type proxies and make com non-functional)])\n\tAC_MSG_NOTICE([Disabled remoting])\nfi\n\nif test \"x$mono_feature_disable_security\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SECURITY, 1, [Disable CAS/CoreCLR security])\n\tAC_MSG_NOTICE([Disabled CAS/CoreCLR security manager (used e.g. for Moonlight)])\nfi\n\nif test \"x$mono_feature_disable_lldb\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_LLDB, 1, [Disable support code for the LLDB plugin.])\n\tAC_MSG_NOTICE([Disabled LLDB plugin support code.])\nfi\n\nif test \"x$mono_feature_disable_mdb\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_MDB, 1, [Disable support for .mdb symbol files.])\n\tAC_MSG_NOTICE([Disabled support for .mdb symbol files.])\nfi\n\nif test \"x$mono_feature_disable_assert_messages\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_ASSERT_MESSAGES, 1, [Disable assertion messages.])\n\tAC_MSG_NOTICE([Disabled assertion messages.])\nfi\n\nif test \"x$mono_feature_disable_cleanup\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_CLEANUP, 1, [Disable runtime cleanup.])\n\tAC_MSG_NOTICE([Disabled runtime cleanup.])\nfi\n\nif test \"x$mono_feature_disable_sgen_marksweep_conc\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SGEN_MAJOR_MARKSWEEP_CONC, 1, [Disable concurrent gc support in SGEN.])\n\tAC_MSG_NOTICE([Disabled concurrent gc support in SGEN.])\nfi\n\n\nif test \"x$mono_feature_disable_sgen_split_nursery\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SGEN_SPLIT_NURSERY, 1, [Disable minor=split support in SGEN.])\n\tAC_MSG_NOTICE([Disabled minor=split support in SGEN.])\nfi\n\nif test \"x$mono_feature_disable_sgen_gc_bridge\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SGEN_GC_BRIDGE, 1, [Disable gc bridge support in SGEN.])\n\tAC_MSG_NOTICE([Disabled gc bridge support in SGEN.])\nfi\n\nif test \"x$mono_feature_disable_sgen_debug_helpers\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SGEN_DEBUG_HELPERS, 1, [Disable debug helpers in SGEN.])\n\tAC_MSG_NOTICE([Disabled debug helpers in SGEN.])\nfi\n\nif test \"x$mono_feature_disable_sockets\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SOCKETS, 1, [Disable sockets])\n\tAC_MSG_NOTICE([Disabled sockets])\nfi\n\nif test \"x$mono_feature_disable_gac\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_GAC, 1, [Disable GAC])\n\tAC_MSG_NOTICE([Disabled GAC support])\nfi\n\nAC_ARG_ENABLE(executables, [  --disable-executables disable the build of the runtime executables], enable_executables=$enableval, enable_executables=yes)\nAM_CONDITIONAL(DISABLE_EXECUTABLES, test x$enable_executables = xno)\n\nhas_extension_module=no\nAC_ARG_ENABLE(extension-module, [  --enable-extension-module=LIST enable the core-extensions from LIST],\n[\n\tfor extension in `echo \"$enable_extension_module\" | sed -e \"s/,/ /g\"`; do\n\t\tif test x$extension = xdefault ; then\n\t\t\thas_extension_module=yes;\n\t\tfi\n\tdone\n\tif test x$enable_extension_module = xyes; then\n\t\thas_extension_module=yes;\n\tfi\n], [])\n\nAM_CONDITIONAL([HAS_EXTENSION_MODULE], [test x$has_extension_module != xno])\n\nif test x$has_extension_module != xno ; then\n\tAC_DEFINE([ENABLE_EXTENSION_MODULE], 1, [Extension module enabled])\n\tAC_MSG_NOTICE([Enabling mono extension module.])\nfi\n\n# Deprecated\nAC_ARG_ENABLE(gsharedvt, [  --enable-gsharedvt Enable generic valuetype sharing (Deprecated)], enable_gsharedvt=$enableval, enable_gsharedvt=no)\n\nAC_MSG_CHECKING(for visibility __attribute__)\nAC_COMPILE_IFELSE([\n\tAC_LANG_SOURCE([[\n\t\tvoid __attribute__ ((visibility (\"hidden\"))) doit (void) {}\n   \t\tint main () { doit (); return 0; }\n   \t]])\n], [\n   have_visibility_hidden=yes\n   AC_MSG_RESULT(yes)\n], [\n   have_visibility_hidden=no\n   AC_MSG_RESULT(no)\n])\n\ndnl\ndnl Boehm GC configuration\ndnl\n\nAC_ARG_WITH(libgc,   [  --with-libgc=included,none  Controls the Boehm GC config, default=included],[libgc=$with_libgc],[libgc=included])\n\nAC_ARG_ENABLE(boehm, [  --disable-boehm            Disable the Boehm GC.], support_boehm=$enableval,support_boehm=${support_boehm:-yes})\nAM_CONDITIONAL(SUPPORT_BOEHM, test x$support_boehm = xyes)\n\nif test \"x$support_boehm\" = \"xyes\"; then\n\n\tAC_ARG_ENABLE(parallel-mark, [  --enable-parallel-mark     Enables Boehm GC Parallel Marking], enable_parallel_mark=$enableval, enable_parallel_mark=$parallel_mark)\n\tif test x$enable_parallel_mark = xyes; then\n\t\tlibgc_configure_args=\"$libgc_configure_args --enable-parallel-mark\"\n\tfi\n\n\tgc_msg=\"\"\n\tLIBGC_CPPFLAGS=\n\tLIBGC_LIBS=\n\tLIBGC_STATIC_LIBS=\n\tlibgc_dir=\n\tcase \"x$libgc\" in\n\t\txincluded)\n\t\t\tif test \"x$support_boehm\" = \"xyes\"; then\n\t\t\t\tlibgc_dir=libgc\n\t\t\tfi\n\n\t\t\tLIBGC_CPPFLAGS='-I$(top_srcdir)/libgc/include'\n\t\t\tLIBGC_LIBS='$(top_builddir)/libgc/libmonogc.la'\n\t\t\tLIBGC_STATIC_LIBS='$(top_builddir)/libgc/libmonogc-static.la'\n\n\t\t\tBOEHM_DEFINES=\"-DHAVE_BOEHM_GC\"\n\n\t\t\tif test x$target_win32 = xyes; then\n\t\t\t\tBOEHM_DEFINES=\"$BOEHM_DEFINES -DGC_NOT_DLL\"\n\t\t\t\tCFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -DGC_BUILD -DGC_NOT_DLL\"\n\t\t\tfi\n\n\t\t\tgc_msg=\"Included Boehm GC with typed GC\"\n\t\t\tif test x$enable_parallel_mark = xyes; then\n\t\t\t\tAC_DEFINE_UNQUOTED(DEFAULT_GC_NAME, \"Included Boehm (with typed GC and Parallel Mark)\", [GC description])\n\t\t\t\tgc_msg=\"$gc_msg and parallel mark\"\n\t\t\telse\n\t\t\t\tAC_DEFINE_UNQUOTED(DEFAULT_GC_NAME, \"Included Boehm (with typed GC)\", [GC description])\n\t\t\tfi\n\t\t\t;;\n\n\t\txboehm|xbohem|xyes)\n\t\t\tAC_MSG_WARN(\"External Boehm is no longer supported\")\n\t\t\t;;\n\n\t\txsgen)\n\t\t\tAC_MSG_WARN(\"Use --with-sgen instead, --with-libgc= controls Boehm configuration\")\n\t\t\t;;\n\n\t\txnone)\n\t\t\tAC_MSG_WARN(\"Compiling mono without GC.\")\n\t\t\tAC_DEFINE_UNQUOTED(DEFAULT_GC_NAME, \"none\", [GC description])\n\t\t\tAC_DEFINE(HAVE_NULL_GC,1,[No GC support.])\n\t\t\tgc_msg=\"none\"\n\t\t\t;;\n\t\t*)\n\t\t\tAC_MSG_ERROR([Invalid argument $libgc to --with-libgc.])\n\t\t\t;;\n\tesac\n\n\tAC_ARG_WITH(large-heap, [  --with-large-heap=yes,no       Enable support for GC heaps larger than 3GB (defaults to no)], [large_heap=$withval], [large_heap=no])\n\tif test \"x$large_heap\" = \"xyes\"; then\n\t   CPPFLAGS=\"$CPPFLAGS -DLARGE_CONFIG\"\n\tfi\n\n\tAC_SUBST(LIBGC_CPPFLAGS)\n\tAC_SUBST(LIBGC_LIBS)\n\tAC_SUBST(LIBGC_STATIC_LIBS)\n\tAC_SUBST(libgc_dir)\n\tAC_SUBST(BOEHM_DEFINES)\n\nfi\nAM_CONDITIONAL(SUPPORT_NULLGC, test \"x$libgc\" = \"xnone\")\n\ndnl\ndnl End of Boehm GC Configuration\ndnl\n\ndnl *************************************\ndnl *** Checks for zero length arrays ***\ndnl *************************************\nAC_MSG_CHECKING(whether $CC supports zero length arrays)\nAC_TRY_COMPILE([\n\tstruct s {\n\t\tint  length;\n\t\tchar data [0];\n\t};\n], [], [\n\tAC_MSG_RESULT(yes)\n\tAC_DEFINE_UNQUOTED(MONO_ZERO_LEN_ARRAY, 0, [Length of zero length arrays])\n], [\n\tAC_MSG_RESULT(no)\n\tAC_DEFINE_UNQUOTED(MONO_ZERO_LEN_ARRAY, 1, [Length of zero length arrays])\n])\n\ndnl ***********************************\ndnl *** Checks for signals\ndnl ***********************************\nAC_CHECK_HEADERS(signal.h)\nAC_CHECK_FUNCS(sigaction)\nAC_CHECK_FUNCS(kill)\nAC_CHECK_FUNCS(signal)\n\n# signal() is declared inline in Android headers\n# so we need to workaround it by overriding the check.\nif test x$platform_android = xyes; then\n\tAC_DEFINE(HAVE_SIGNAL,1)\nfi\n\n# `target_ios=yes` does not detect watch devices and fails when cross-compiling\nAC_MONO_APPLE_TARGET(TARGET_OS_IPHONE, [mono_native_platform_ios=yes])\n\nif test x$host_win32 = xno; then\n\tdnl *************************************\n\tdnl *** Checks for time capabilities ***\n\tdnl *************************************\n\n\tAC_MSG_CHECKING(for CLOCK_MONOTONIC)\n\tAC_TRY_COMPILE([#include <time.h>], [\n\t\tconst int foo = CLOCK_MONOTONIC;\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_CLOCK_MONOTONIC, 1, [CLOCK_MONOTONIC])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_MSG_CHECKING(for CLOCK_MONOTONIC_COARSE)\n\tAC_TRY_COMPILE([#include <time.h>], [\n\t\tconst int foo = CLOCK_MONOTONIC_COARSE;\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_CLOCK_MONOTONIC_COARSE, 1, [CLOCK_MONOTONIC_COARSE])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_MSG_CHECKING(for CLOCK_REALTIME)\n\tAC_TRY_COMPILE([#include <time.h>], [\n\t\tconst int foo = CLOCK_REALTIME;\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_CLOCK_REALTIME, 1, [CLOCK_REALTIME])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_CHECK_FUNC(mach_absolute_time, [AC_DEFINE(HAVE_MACH_ABSOLUTE_TIME, 1, [mach_absolute_time])])\n\tAC_CHECK_FUNC(gethrtime, [AC_DEFINE(HAVE_GETHRTIME, 1, [gethrtime])])\n\tAC_CHECK_FUNC(read_real_time, [AC_DEFINE(HAVE_READ_REAL_TIME, 1, [read_real_time])])\n\tAC_CHECK_FUNC(mach_timebase_info, [AC_DEFINE(HAVE_MACH_TIMEBASE_INFO, 1, [mach_timebase_info])])\n\tAC_CHECK_FUNC(futimes,            [AC_DEFINE(HAVE_FUTIMES, 1, [futimes])])\n\tAC_CHECK_FUNC(futimens,           [AC_DEFINE(HAVE_FUTIMENS, 1, [futimens])])\n\n\tdnl hires monotonic clock support\n\tAC_SEARCH_LIBS(clock_gettime, rt)\n\tAC_CHECK_FUNCS(clock_nanosleep)\n\n\tdnl dynamic loader support\n\tAC_CHECK_FUNC(dlopen, DL_LIB=\"\",\n\t\tAC_CHECK_LIB(dl, dlopen, DL_LIB=\"-ldl\", dl_support=no)\n\t)\n\tif test x$dl_support = xno; then\n\t\tAC_MSG_WARN([No dynamic loading support available])\n\telse\n\t\tLIBS=\"$LIBS $DL_LIB\"\n\t\tdnl from glib's configure.ac\n\t\tif test \"x$cross_compiling\" = \"xyes\"; then\n\t\t   AC_MSG_RESULT(cross compiling, assuming no)\n\t\t   mono_cv_uscore=no\n\t\telse\n\t\t\tAC_CACHE_CHECK([for preceeding underscore in symbols],\n\t\t\t  mono_cv_uscore,[\n\t\t\t  AC_TRY_RUN([#include <dlfcn.h>\n\t\t\t  int mono_underscore_test (void) { return 42; }\n\t\t\t  int main() {\n\t\t\t    void *f1 = (void*)0, *f2 = (void*)0, *handle;\n\t\t\t    handle = dlopen ((void*)0, 0);\n\t\t\t    if (handle) {\n\t\t\t      f1 = dlsym (handle, \"mono_underscore_test\");\n\t\t\t      f2 = dlsym (handle, \"_mono_underscore_test\");\n\t\t\t    } return (!f2 || f1);\n\t\t\t  }],\n\t\t\t\t[mono_cv_uscore=yes],\n\t\t\t\t[mono_cv_uscore=no],\n\t\t\t  [])\n\t\t  ])\n\t\tfi\n\t\tif test \"x$mono_cv_uscore\" = \"xyes\"; then\n\t\t\tAC_DEFINE(MONO_DL_NEED_USCORE, 1, [Does dlsym require leading underscore.])\n\t\tfi\n\t\tAC_CHECK_FUNC(dlerror)\n\tfi\n\n\tdnl ******************************************************************\n\tdnl *** Checks for the IKVM JNI interface library                  ***\n\tdnl ******************************************************************\n\tAC_ARG_WITH(ikvm-native, [  --with-ikvm-native=yes,no      build the IKVM JNI interface library (defaults to yes)],[with_ikvm_native=$withval],[with_ikvm_native=$ikvm_native])\n\n\tikvm_native_dir=\n\tif test x$with_ikvm_native = xyes; then\n\t\tikvm_native_dir=ikvm-native\n\t\tjdk_headers_found=\"IKVM Native\"\n\tfi\n\n\tAC_SUBST(ikvm_native_dir)\n\n\tAC_CHECK_HEADERS(execinfo.h)\n\n\tAC_CHECK_HEADERS(sys/auxv.h sys/resource.h)\n\n\tAC_CHECK_FUNCS(getgrgid_r)\n\tAC_CHECK_FUNCS(getgrnam_r)\n\tAC_CHECK_FUNCS(getresuid)\n\tAC_CHECK_FUNCS(setresuid)\n\tAC_CHECK_FUNCS(kqueue)\n\tAC_CHECK_FUNCS(backtrace_symbols)\n\tAC_CHECK_FUNCS(mkstemp)\n\tAC_CHECK_FUNCS(mmap)\n\tAC_CHECK_FUNCS(madvise)\n\tAC_CHECK_FUNCS(getrusage)\n\tAC_CHECK_FUNCS(getpriority)\n\tAC_CHECK_FUNCS(setpriority)\n\tAC_CHECK_FUNCS(dl_iterate_phdr)\n\tAC_CHECK_FUNCS(dladdr)\n\tAC_CHECK_FUNCS(sysconf)\n\tAC_CHECK_FUNCS(getrlimit)\n\tAC_CHECK_FUNCS(prctl)\n\tAC_CHECK_FUNCS(arc4random)\n\tAC_CHECK_FUNCS(nl_langinfo)\n\n\tAC_CHECK_FUNCS(sched_getaffinity)\n\tAC_CHECK_FUNCS(sched_setaffinity)\n\tAC_CHECK_FUNCS(sched_getcpu)\n\n\tif test x$platform_android != xyes; then\n\t\tAC_CHECK_FUNCS(getpwnam_r)\n\t\tAC_CHECK_FUNCS(getpwuid_r)\n\tfi\n\n\tAC_CHECK_FUNCS(readlink)\n\tAC_CHECK_FUNCS(chmod)\n\tAC_CHECK_FUNCS(lstat)\n\tAC_CHECK_FUNCS(getdtablesize)\n\n\tAC_CHECK_FUNCS(ftruncate)\n\tAC_CHECK_FUNCS(msync)\n\n\tAC_CHECK_FUNCS(gethostname getpeername)\n\tAC_CHECK_FUNCS(utime utimes)\n\n\tAC_CHECK_FUNCS(openlog closelog)\n\tAC_CHECK_FUNCS(atexit)\n\tAC_CHECK_FUNCS(popen)\n\n\tAC_FUNC_STRERROR_R()\n\n\tdnl ****************************************************************\n\tdnl *** Check for sched_setaffinity from glibc versions before   ***\n\tdnl *** 2.3.4. The older versions of the function only take 2    ***\n\tdnl *** parameters, not 3.                                       ***\n\tdnl ***                                                          ***\n\tdnl *** Because the interface change was not made in a minor     ***\n\tdnl *** version rev, the __GLIBC__ and __GLIBC_MINOR__ macros    ***\n\tdnl *** won't always indicate the interface sched_affinity has.  ***\n\tdnl ****************************************************************\n\tAC_MSG_CHECKING(for sched_setaffinity from glibc < 2.3.4)\n\tAC_TRY_COMPILE([#include <sched.h>], [\n            int mask = 1; \n            sched_setaffinity(0, &mask);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(GLIBC_BEFORE_2_3_4_SCHED_SETAFFINITY, 1, [Have GLIBC_BEFORE_2_3_4_SCHED_SETAFFINITY])\n\t], [\n\t\t# We have the new, three-parameter version\n\t\tAC_MSG_RESULT(no)\n\t])\n\tAC_TRY_COMPILE([#include <sched.h>], [\n\t     CPU_COUNT((void *) 0);\n\t], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(GLIBC_HAS_CPU_COUNT, 1, [GLIBC has CPU_COUNT macro in sched.h])\n\t], [\n\t\t# We have the new, three-parameter version\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl ******************************************************************\n\tdnl *** Check for large file support                               ***\n\tdnl *** (If we were using autoconf 2.50 we'd use AC_SYS_LARGEFILE) ***\n\tdnl ******************************************************************\n\t\n\t# Check that off_t can represent 2**63 - 1 correctly, working around\n\t# potential compiler bugs.  Defines LARGE_FILE_SUPPORT, adds $1 to\n\t# CPPFLAGS and sets $large_offt to yes if the test succeeds\n\tlarge_offt=no\n\tAC_DEFUN([LARGE_FILES], [\n\t\tlarge_CPPFLAGS=$CPPFLAGS\n\t\tCPPFLAGS=\"$CPPFLAGS $1\"\n\t\tAC_TRY_COMPILE([\n\t\t\t#include <sys/types.h>\n\t\t\t#include <limits.h>\n\t\t], [\n\t\t\t/* Lifted this compile time assert method from: http://www.jaggersoft.com/pubs/CVu11_3.html */\n\t\t\t#define COMPILE_TIME_ASSERT(pred) \\\n\t\t\t\tswitch(0){case 0:case pred:;}\n\t\t\tCOMPILE_TIME_ASSERT(sizeof(off_t) * CHAR_BIT == 64);\n\t\t], [\n\t\t\tAC_MSG_RESULT(ok)\n\t\t\tAC_DEFINE(HAVE_LARGE_FILE_SUPPORT, 1, [Have large file support])\n\t\t\tlarge_CPPFLAGS=\"$large_CPPFLAGS $1\"\n\t\t\tlarge_offt=yes\n\t\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t\t])\n\t\tCPPFLAGS=$large_CPPFLAGS\n\t])\n\n\tAC_MSG_CHECKING(if off_t is 64 bits wide)\n\tLARGE_FILES(\"\")\n\tif test $large_offt = no; then\n\t\tAC_MSG_CHECKING(if _FILE_OFFSET_BITS=64 gives 64 bit off_t)\n\t\tLARGE_FILES(\"-D_FILE_OFFSET_BITS=64\")\n\tfi\n\tif test $large_offt = no; then\n\t\tAC_MSG_WARN([No 64 bit file size support available])\n\tfi\n\t\n\tdnl *****************************\n\tdnl *** Checks for libsocket  ***\n\tdnl *****************************\n\tAC_CHECK_LIB(socket, socket, LIBS=\"$LIBS -lsocket\")\n\n\tcase \"$host\" in\n\t\t*-*-*freebsd*)\n\t\t\tdnl *****************************\n\t\t\tdnl *** Checks for libinotify ***\n\t\t\tdnl *****************************\n\t\t\tAC_CHECK_LIB(inotify, inotify_init, LIBS=\"$LIBS -linotify\")\n\tesac\n\n\tdnl *******************************\n\tdnl *** Checks for MSG_NOSIGNAL ***\n\tdnl *******************************\n\tAC_MSG_CHECKING(for MSG_NOSIGNAL)\n\tAC_TRY_COMPILE([#include <sys/socket.h>], [\n\t\tint f = MSG_NOSIGNAL;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_MSG_NOSIGNAL, 1, [Have MSG_NOSIGNAL])\n\t], [\n\t\t# We'll have to use signals\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *****************************\n\tdnl *** Checks for IPPROTO_IP ***\n\tdnl *****************************\n\tAC_MSG_CHECKING(for IPPROTO_IP)\n\tAC_TRY_COMPILE([#include <netinet/in.h>], [\n\t\tint level = IPPROTO_IP;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IPPROTO_IP, 1, [Have IPPROTO_IP])\n\t], [\n\t\t# We'll have to use getprotobyname\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *******************************\n\tdnl *** Checks for IPPROTO_IPV6 ***\n\tdnl *******************************\n\tAC_MSG_CHECKING(for IPPROTO_IPV6)\n\tAC_TRY_COMPILE([#include <netinet/in.h>], [\n\t\tint level = IPPROTO_IPV6;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IPPROTO_IPV6, 1, [Have IPPROTO_IPV6])\n\t], [\n\t\t# We'll have to use getprotobyname\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl ******************************\n\tdnl *** Checks for IPPROTO_TCP ***\n\tdnl ******************************\n\tAC_MSG_CHECKING(for IPPROTO_TCP)\n\tAC_TRY_COMPILE([#include <netinet/in.h>], [\n\t\tint level = IPPROTO_TCP;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IPPROTO_TCP, 1, [Have IPPROTO_TCP])\n\t], [\n\t\t# We'll have to use getprotobyname\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *****************************\n\tdnl *** Checks for SOL_IP     ***\n\tdnl *****************************\n\tAC_MSG_CHECKING(for SOL_IP)\n\tAC_TRY_COMPILE([#include <netdb.h>], [\n\t\tint level = SOL_IP;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_SOL_IP, 1, [Have SOL_IP])\n\t], [\n\t\t# We'll have to use getprotobyname\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *****************************\n\tdnl *** Checks for SOL_IPV6     ***\n\tdnl *****************************\n\tAC_MSG_CHECKING(for SOL_IPV6)\n\tAC_TRY_COMPILE([#include <netdb.h>], [\n\t\tint level = SOL_IPV6;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_SOL_IPV6, 1, [Have SOL_IPV6])\n\t], [\n\t\t# We'll have to use getprotobyname\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *****************************\n\tdnl *** Checks for SOL_TCP    ***\n\tdnl *****************************\n\tAC_MSG_CHECKING(for SOL_TCP)\n\tAC_TRY_COMPILE([#include <netdb.h>], [\n\t\tint level = SOL_TCP;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_SOL_TCP, 1, [Have SOL_TCP])\n\t], [\n\t\t# We'll have to use getprotobyname\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *****************************\n\tdnl *** Checks for IP_PKTINFO ***\n\tdnl *****************************\n\tAC_MSG_CHECKING(for IP_PKTINFO)\n\tAC_TRY_COMPILE([#include <linux/in.h>], [\n\t\tint level = IP_PKTINFO;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IP_PKTINFO, 1, [Have IP_PKTINFO])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *****************************\n\tdnl *** Checks for IPV6_PKTINFO ***\n\tdnl *****************************\n\tAC_MSG_CHECKING(for IPV6_PKTINFO)\n\tAC_TRY_COMPILE([#include <netdb.h>], [\n\t\tint level = IPV6_PKTINFO;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IPV6_PKTINFO, 1, [Have IPV6_PKTINFO])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Checks for IP_DONTFRAG     ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for IP_DONTFRAG)\n\tAC_TRY_COMPILE([#include <netinet/in.h>], [\n\t\tint level = IP_DONTFRAG;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IP_DONTFRAG, 1, [Have IP_DONTFRAG])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Checks for IP_DONTFRAGMENT ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for IP_DONTFRAGMENT)\n\tAC_TRY_COMPILE([#include <Ws2ipdef.h>], [\n\t\tint level = IP_DONTFRAGMENT;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IP_DONTFRAGMENT, 1, [Have IP_DONTFRAGMENT])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Checks for IP_MTU_DISCOVER ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for IP_MTU_DISCOVER)\n\tAC_TRY_COMPILE([#include <linux/in.h>], [\n\t\tint level = IP_MTU_DISCOVER;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IP_MTU_DISCOVER, 1, [Have IP_MTU_DISCOVER])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Checks for  IP_PMTUDISC_DO ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for IP_PMTUDISC_DO)\n\tAC_TRY_COMPILE([#include <linux/in.h>], [\n\t\tint level = IP_PMTUDISC_DO;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IP_PMTUDISC_DO, 1, [Have IP_PMTUDISC_DO])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n \tdnl *********************************\n\tdnl *** Check for struct ip_mreqn ***\n\tdnl *********************************\n\tAC_MSG_CHECKING(for struct ip_mreqn)\n\tAC_TRY_COMPILE([#include <netinet/in.h>], [\n\t\tstruct ip_mreqn mreq;\n\t\tmreq.imr_address.s_addr = 0;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_STRUCT_IP_MREQN, 1, [Have struct ip_mreqn])\n\t], [\n\t\t# We'll just have to try and use struct ip_mreq\n\t\tAC_MSG_RESULT(no)\n\t\tAC_MSG_CHECKING(for struct ip_mreq)\n\t\tAC_TRY_COMPILE([#include <netinet/in.h>], [\n\t\t\tstruct ip_mreq mreq;\n\t\t\tmreq.imr_interface.s_addr = 0;\n\t\t], [\n\t\t\t# Yes, we have it...\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_STRUCT_IP_MREQ, 1, [Have struct ip_mreq])\n\t\t], [\n\t\t\t# No multicast support\n\t\t\tAC_MSG_RESULT(no)\n\t\t])\n\t])\n\t\n\tdnl **********************************\n\tdnl *** Check for getaddrinfo ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for getaddrinfo)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <netdb.h>\n\t], [\n\t\tgetaddrinfo(NULL,NULL,NULL,NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETADDRINFO, 1, [Have getaddrinfo])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for gethostbyname2_r ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for gethostbyname2_r)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <netdb.h>\n\t], [\n\n\t\tgethostbyname2_r(NULL,0,NULL,NULL,0,NULL,NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETHOSTBYNAME2_R, 1, [Have gethostbyname2_r])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for gethostbyname2 ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for gethostbyname2)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <netdb.h>\n\t], [\n\t\tgethostbyname2(NULL,0);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETHOSTBYNAME2, 1, [Have gethostbyname2])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for gethostbyname ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for gethostbyname)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <netdb.h>\n\t], [\n\t\tgethostbyname(NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETHOSTBYNAME, 1, [Have gethostbyname])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for getprotobyname ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for getprotobyname)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <netdb.h>\n\t], [\n\t\tgetprotobyname(NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETPROTOBYNAME, 1, [Have getprotobyname])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for getprotobyname_r ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for getprotobyname_r)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <netdb.h>\n\t], [\n\t\tgetprotobyname_r(NULL, NULL, NULL, 0, NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETPROTOBYNAME_R, 1, [Have getprotobyname_r])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for getnameinfo ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for getnameinfo)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <netdb.h>\n\t], [\n\t\tgetnameinfo (NULL, 0, NULL, 0, NULL, 0, 0);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETNAMEINFO, 1, [Have getnameinfo])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\n\tdnl **********************************\n\tdnl *** Check for inet_ntop ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for inet_ntop)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <arpa/inet.h>\n\t], [\n\t\tinet_ntop (0, NULL, NULL, 0);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_INET_NTOP, 1, [Have inet_ntop])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *****************************\n\tdnl *** Checks for libnsl     ***\n\tdnl *****************************\n\tAC_CHECK_FUNC(gethostbyaddr, , AC_CHECK_LIB(nsl, gethostbyaddr, LIBS=\"$LIBS -lnsl\"))\n\n\tAC_CHECK_FUNCS(inet_pton inet_aton)\n\n\tdnl *****************************\n\tdnl *** Checks for libxnet    ***\n\tdnl *****************************\n\tcase \"${host}\" in\n\t\t*solaris* )\n\t\t\tAC_MSG_CHECKING(for Solaris XPG4 support)\n\t\t\tif test -f /usr/lib/libxnet.so; then\n\t\t\t\tCPPFLAGS=\"$CPPFLAGS -D_XOPEN_SOURCE=500\"\n\t    \t\t\tCPPFLAGS=\"$CPPFLAGS -D__EXTENSIONS__\"\n\t\t\t\tCPPFLAGS=\"$CPPFLAGS -D_XOPEN_SOURCE_EXTENDED=1\"\n           \t\t\tLIBS=\"$LIBS -lxnet\"\n  \t    \t\t\tAC_MSG_RESULT(yes)\n\t\t\telse\n  \t    \t\t\tAC_MSG_RESULT(no)\n\t\t\tfi\n\n\t\t\tif test \"$GCC\" = \"yes\"; then\n\t\t    \t\tCFLAGS=\"$CFLAGS -Wno-char-subscripts\"\n\t\t\tfi\n    \t\t;;\n\tesac\n\n\tdnl *****************************\n\tdnl *** Checks for libpthread ***\n\tdnl *****************************\n# on FreeBSD -STABLE, the pthreads functions all reside in libc_r\n# and libpthread does not exist\n#\n\tcase \"${host}\" in\n\t\t*-*-*haiku*)\n\t\t\tdnl Haiku has pthread in libroot (libc equiv)\n\t\t\tAC_CHECK_LIB(pthread, main, LIBS=\"$LIBS\")\n\t\t;;\n\t\t*-*-*freebsd*)\n\t\t\tAC_CHECK_LIB(pthread, main, LIBS=\"$LIBS -pthread\")\n\t\t;;\n\t\t*-*-*openbsd*)\n\t\t\tAC_CHECK_LIB(pthread, main, LIBS=\"$LIBS -pthread\")\n\t\t;;\n\t\t*)\n\t\t\tAC_CHECK_LIB(pthread, main, LIBS=\"$LIBS -lpthread\")\n\t\t;;\n\tesac\n\tAC_CHECK_HEADERS(pthread.h)\n\tAC_CHECK_HEADERS(pthread_np.h)\n\tAC_CHECK_FUNCS(pthread_mutex_timedlock)\n\tAC_CHECK_FUNCS(pthread_getattr_np pthread_attr_get_np pthread_getname_np pthread_setname_np pthread_cond_timedwait_relative_np)\n\tAC_CHECK_FUNCS(pthread_kill)\n\tAC_MSG_CHECKING(for PTHREAD_MUTEX_RECURSIVE)\n\tAC_TRY_COMPILE([ #include <pthread.h>], [\n\t\tpthread_mutexattr_t attr;\n\t\tpthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n\t], [\n\t\tAC_MSG_RESULT(ok)\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t\tAC_ERROR(Posix system lacks support for recursive mutexes)\n\t])\n\tAC_CHECK_FUNCS(pthread_attr_setstacksize)\n\tAC_CHECK_FUNCS(pthread_attr_getstack pthread_attr_getstacksize)\n\tAC_CHECK_FUNCS(pthread_get_stacksize_np pthread_get_stackaddr_np)\n\tdnl check that pthread_mutexattr_setprotocol is declared\n\tAC_CHECK_DECLS([pthread_mutexattr_setprotocol], [], [], [[#include <pthread.h>]])\n\tAC_CHECK_FUNCS(mincore mlock munlock)\n\n\tdnl ***********************************\n\tdnl *** Checks for working __thread ***\n\tdnl ***********************************\n\tAC_MSG_CHECKING(for working __thread)\n\tif test \"x$with_tls\" != \"x__thread\"; then\n\t\tAC_MSG_RESULT(disabled)\n\telif test \"x$cross_compiling\" = \"xyes\"; then\n\t\tAC_MSG_RESULT(cross compiling, assuming yes)\n\telse\n\t\tAC_TRY_RUN([\n\t\t\t#if defined(__APPLE__) && defined(__clang__)\n\t\t\t#error \"__thread does not currently work with clang on Mac OS X\"\n\t\t\t#endif\n\t\t\t\n\t\t\t#include <unistd.h>\n\t\t\t#include <pthread.h>\n\t\t\t__thread int i;\n\t\t\tstatic int res1, res2;\n\n\t\t\tvoid thread_main (void *arg)\n\t\t\t{\n\t\t\t\ti = arg;\n\t\t\t\tsleep (1);\n\t\t\t\tif (arg == 1)\n\t\t\t\t\tres1 = (i == arg);\n\t\t\t\telse\n\t\t\t\t\tres2 = (i == arg);\n\t\t\t}\n\n\t\t\tint main () {\n\t\t\t\tpthread_t t1, t2;\n\n\t\t\t\ti = 5;\n\n\t\t\t\tpthread_create (&t1, NULL, thread_main, 1);\n\t\t\t\tpthread_create (&t2, NULL, thread_main, 2);\n\n\t\t\t\tpthread_join (t1, NULL);\n\t\t\t\tpthread_join (t2, NULL);\n\n\t\t\t\treturn !(res1 + res2 == 2);\n\t\t\t}\n\t\t], [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t], [\n\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t\twith_tls=pthread\n\t\t])\n\tfi\n\n\tdnl **************************************\n\tdnl *** Checks for working sigaltstack ***\n\tdnl **************************************\n\tAC_MSG_CHECKING(for working sigaltstack)\n\tif test \"x$with_sigaltstack\" != \"xyes\"; then\n\t\tAC_MSG_RESULT(disabled)\n\telif test \"x$cross_compiling\" = \"xyes\"; then\n\t\tAC_MSG_RESULT(cross compiling, assuming no)\n\t\twith_sigaltstack=no\n\telse\n\t\tAC_TRY_RUN([\n\t\t\t#include <stdio.h>\n\t\t\t#include <stdlib.h>\n\t\t\t#include <unistd.h>\n\t\t\t#include <signal.h>\n\t\t\t#include <pthread.h>\n\t\t\t#include <sys/wait.h>\n\t\t\t#if defined(__FreeBSD__) || defined(__NetBSD__)\n\t\t\t#define SA_STACK SA_ONSTACK\n\t\t\t#endif\n\t\t\tstatic void\n\t\t\tsigsegv_signal_handler (int _dummy, siginfo_t *info, void *context)\n\t\t\t{\n\t\t\t\texit (0);\n\t\t\t}\n\n\t\t\tvolatile char*__ptr = NULL;\n\t\t\tstatic void *\n\t\t\tloop (void *ignored)\n\t\t\t{\n\t\t\t\t*__ptr = 0;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tstatic void\n\t\t\tchild ()\n\t\t\t{\n\t\t\t\tstruct sigaction sa;\n\t\t\t\tstack_t sas;\n\t\t\t\tpthread_t id;\n\t\t\t\tpthread_attr_t attr;\n\n\t\t\t\tsa.sa_sigaction = sigsegv_signal_handler;\n\t\t\t\tsigemptyset (&sa.sa_mask);\n\t\t\t\tsa.sa_flags = SA_SIGINFO | SA_ONSTACK;\n\t\t\t\tif (sigaction (SIGSEGV, &sa, NULL) == -1) {\n\t\t\t\t\tperror (\"sigaction\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t/* x86 darwin deliver segfaults using SIGBUS */\n\t\t\t\tif (sigaction (SIGBUS, &sa, NULL) == -1) {\n\t\t\t\t\tperror (\"sigaction\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsas.ss_sp = malloc (SIGSTKSZ);\n\t\t\t\tsas.ss_size = SIGSTKSZ;\n\t\t\t\tsas.ss_flags = 0;\n\t\t\t\tif (sigaltstack (&sas, NULL) == -1) {\n\t\t\t\t\tperror (\"sigaltstack\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tpthread_attr_init (&attr);\n\t\t\t\tif (pthread_create(&id, &attr, loop, &attr) != 0) {\n\t\t\t\t\tprintf (\"pthread_create\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tsleep (100);\n\t\t\t}\n\n\t\t\tint\n\t\t\tmain ()\n\t\t\t{\n\t\t\t\tpid_t son;\n\t\t\t\tint status;\n\t\t\t\tint i;\n\n\t\t\t\tson = fork ();\n\t\t\t\tif (son == -1) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tif (son == 0) {\n\t\t\t\t\tchild ();\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < 300; ++i) {\n\t\t\t\t\twaitpid (son, &status, WNOHANG);\n\t\t\t\t\tif (WIFEXITED (status) && WEXITSTATUS (status) == 0)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tusleep (10000);\n\t\t\t\t}\n\n\t\t\t\tkill (son, SIGKILL);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t], [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\tAC_DEFINE(HAVE_WORKING_SIGALTSTACK, 1, [Have a working sigaltstack])\n\t\t], [\n\t\t\t\twith_sigaltstack=no\n\t\t\t\tAC_MSG_RESULT(no)\n\t\t])\n\tfi\n\n\tdnl ********************************\n\tdnl *** Checks for semaphore lib ***\n\tdnl ********************************\n\t# 'Real Time' functions on Solaris\n\t# posix4 on Solaris 2.6\n\t# pthread (first!) on Linux\n\tAC_SEARCH_LIBS(sem_init, pthread rt posix4) \n\n\tAC_SEARCH_LIBS(shm_open, pthread rt posix4) \n\tAC_CHECK_FUNCS(shm_open)\n\n\tdnl ********************************\n\tdnl *** Checks for timezone stuff **\n\tdnl ********************************\n\tAC_CACHE_CHECK(for tm_gmtoff in struct tm, ac_cv_struct_tm_gmtoff,\n\t\tAC_TRY_COMPILE([\n\t\t\t#include <time.h>\n\t\t\t], [\n\t\t\tstruct tm tm;\n\t\t\ttm.tm_gmtoff = 1;\n\t\t\t], ac_cv_struct_tm_gmtoff=yes, ac_cv_struct_tm_gmtoff=no))\n\tif test $ac_cv_struct_tm_gmtoff = yes; then\n\t\tAC_DEFINE(HAVE_TM_GMTOFF, 1, [Have tm_gmtoff])\n\telse\n\t\tAC_CACHE_CHECK(for timezone variable, ac_cv_var_timezone,\n\t\t\tAC_TRY_COMPILE([\n\t\t\t\t#include <time.h>\n\t\t\t], [\n\t\t\t\ttimezone = 1;\n\t\t\t], ac_cv_var_timezone=yes, ac_cv_var_timezone=no))\n\t\tif test $ac_cv_var_timezone = yes; then\n\t\t\tAC_DEFINE(HAVE_TIMEZONE, 1, [Have timezone variable])\n\t\telse\n\t\t\tAC_ERROR(unable to find a way to determine timezone)\n\t\tfi\n\tfi\n\n\tdnl *********************************\n\tdnl *** Checks for math functions ***\n\tdnl *********************************\n\tAC_SEARCH_LIBS(sqrtf, m)\n\n\tdnl ****************************************************************\n\tdnl *** Checks for working poll() (macosx defines it but doesn't ***\n\tdnl *** have it in the library (duh))                            ***\n\tdnl ****************************************************************\n\tAC_CHECK_FUNCS(poll)\n\n\tdnl **********************************\n\tdnl *** epoll\t\t\t   ***\n\tdnl **********************************\n\tAC_CHECK_HEADERS(sys/epoll.h)\n\thaveepoll=no\n\tAC_CHECK_FUNCS(epoll_ctl, [haveepoll=yes], )\n\tif test \"x$haveepoll\" = \"xyes\" -a \"x$ac_cv_header_sys_epoll_h\" = \"xyes\"; then\n\t\tAC_DEFINE(HAVE_EPOLL, 1, [epoll supported])\n\tfi\n\n\thavekqueue=no\n\n\tAC_CHECK_HEADERS(sys/event.h)\n\tAC_CHECK_FUNCS(kqueue, [havekqueue=yes], )\n\n\tdnl **************************************\n\tdnl * Darwin has a race that prevents us from using reliably:\n\tdnl * http://lists.apple.com/archives/darwin-dev/2011/Jun/msg00016.html\n\tdnl * Since kqueue is mostly used for scaling large web servers, \n\tdnl * and very few folks run Mono on large web servers on OSX, falling\n\tdnl * back \n\tdnl **************************************\n\tif test \"x$havekqueue\" = \"xyes\" -a \"x$ac_cv_header_sys_event_h\" = \"xyes\"; then\n\t\tif test \"x$host_darwin\" = \"xno\"; then\n\t\t\tAC_DEFINE(USE_KQUEUE_FOR_THREADPOOL, 1, [Use kqueue for the threadpool])\n\t\tfi\n\tfi\n\n\tdnl ******************************\n\tdnl *** Checks for SIOCGIFCONF ***\n\tdnl ******************************\n\tAC_CHECK_HEADERS(sys/ioctl.h)\n\tAC_CHECK_HEADERS(net/if.h, [], [],\n\t   [\n\t   #ifdef HAVE_SYS_TYPES_H\n\t   # include <sys/types.h>\n\t   #endif\n\t   #ifdef HAVE_SYS_SOCKET_H\n\t   # include <sys/socket.h>\n\t   #endif\n\t   ])\n\tAC_MSG_CHECKING(for ifreq)\n\tAC_TRY_COMPILE([\n\t\t#include <stdio.h>\n\t\t#include <sys/ioctl.h>\n\t\t#include <net/if.h>\n\t\t], [\n\t\tstruct ifconf ifc;\n\t\tstruct ifreq *ifr;\n\t\tvoid *x;\n\t\tifc.ifc_len = 0;\n\t\tifc.ifc_buf = NULL;\n\t\tx = (void *) &ifr->ifr_addr;\n\t\t],[\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_SIOCGIFCONF, 1, [Can get interface list])\n\t\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t\t])\n\tdnl **********************************\n\tdnl ***     Checks for sin_len     ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for sockaddr_in.sin_len)\n\tAC_TRY_COMPILE([\n\t\t#include <netinet/in.h>\n\t\t], [\n\t\tstruct sockaddr_in saddr;\n\t\tsaddr.sin_len = sizeof (saddr);\n\t\t],[\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_SOCKADDR_IN_SIN_LEN, 1, [sockaddr_in has sin_len])\n\t\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t\t])\t\n\tdnl **********************************\n\tdnl ***    Checks for sin6_len     ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for sockaddr_in6.sin6_len)\n\tAC_TRY_COMPILE([\n\t\t#include <netinet/in.h>\n\t\t], [\n\t\tstruct sockaddr_in6 saddr6;\n\t\tsaddr6.sin6_len = sizeof (saddr6);\n\t\t],[\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_SOCKADDR_IN6_SIN_LEN, 1, [sockaddr_in6 has sin6_len])\n\t\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t\t])\n\tdnl **********************************\n\tdnl *** Check for getifaddrs       ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for getifaddrs)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <sys/types.h>\n\t\t#include <sys/socket.h>\n\t\t#ifdef HAVE_NET_IF_H\n\t\t#include <net/if.h>\n\t\t#endif\n\t\t#include <ifaddrs.h>\n\t], [\n\t\tgetifaddrs(NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETIFADDRS, 1, [Have getifaddrs])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\tdnl **********************************\n\tdnl *** Check for if_nametoindex   ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for if_nametoindex)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <sys/types.h>\n\t\t#include <sys/socket.h>\n\t\t#include <net/if.h>\n\t], [\n\t\tif_nametoindex(NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IF_NAMETOINDEX, 1, [Have if_nametoindex])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\tdnl **********************************\n\tdnl *** Check for access ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for access)\n\t\tAC_TRY_LINK([\n\t\t#include <unistd.h>\n\t], [\n\t\taccess(NULL,0);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_ACCESS, 1, [Have access])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\t\t\t\n\tdnl **********************************\n\tdnl *** Checks for proclib         ***\n\tdnl **********************************\n\tAC_CHECK_HEADER(sys/errno.h, [AC_DEFINE(HAVE_SYS_ERRNO_H, 1, Define to 1 if you have the <sys/errno.h> header file.)])\n\tdnl **********************************\n\tdnl *** Checks for MonoPosixHelper ***\n\tdnl **********************************\n\tAC_CHECK_HEADERS(checklist.h)\n\tAC_CHECK_HEADERS(pathconf.h)\n\tAC_CHECK_HEADERS(fstab.h)\n\tAC_CHECK_HEADERS(attr/xattr.h)\n\tAC_CHECK_HEADERS(sys/extattr.h)\n\tAC_CHECK_HEADERS(sys/sendfile.h)\n\tAC_CHECK_HEADERS(sys/statvfs.h)\n\tAC_CHECK_HEADERS(sys/statfs.h)\n\tAC_CHECK_HEADERS(sys/vfstab.h)\n\tAC_CHECK_HEADERS(sys/xattr.h)\n\tAC_CHECK_HEADERS(sys/mman.h)\n\tAC_CHECK_HEADERS(sys/param.h)\n\tAC_CHECK_HEADERS(sys/mount.h, [], [],\n\t\t[\n\t\t#ifdef HAVE_SYS_PARAM_H\n\t\t# include <sys/param.h>\n\t\t#endif\n\t\t])\n\tAC_CHECK_HEADERS(sys/mount.h)\n\tAC_CHECK_FUNCS(confstr)\n\tAC_CHECK_FUNCS(seekdir telldir)\n\tAC_CHECK_FUNCS(getdomainname)\n\tAC_CHECK_FUNCS(setdomainname)\n\tAC_CHECK_FUNCS(endgrent getgrent fgetgrent setgrent)\n\tAC_CHECK_FUNCS(setgroups)\n\tAC_CHECK_FUNCS(endpwent getpwent fgetpwent setpwent)\n\tAC_CHECK_FUNCS(getfsstat)\n\tAC_CHECK_FUNCS(lutimes futimes)\n\tAC_CHECK_FUNCS(mremap)\n\tAC_CHECK_FUNCS(remap_file_pages)\n\tAC_CHECK_FUNCS(posix_fadvise)\n\tAC_CHECK_FUNCS(posix_fallocate)\n\tAC_CHECK_FUNCS(posix_madvise)\n\tAC_CHECK_FUNCS(vsnprintf)\n\tAC_CHECK_FUNCS(sendfile)\n\tAC_CHECK_FUNCS(gethostid sethostid)\n\tAC_CHECK_FUNCS(sethostname)\n\tAC_CHECK_FUNCS(statfs)\n\tAC_CHECK_FUNCS(fstatfs)\n\tAC_CHECK_FUNCS(statvfs)\n\tAC_CHECK_FUNCS(fstatvfs)\n\tAC_CHECK_FUNCS(stime)\n\tAC_CHECK_FUNCS(ttyname_r)\n\tAC_CHECK_FUNCS(psignal)\n\tAC_CHECK_FUNCS(getlogin_r)\n\tAC_CHECK_FUNCS(lockf)\n\tAC_CHECK_FUNCS(swab)\n\tAC_CHECK_FUNCS(setusershell endusershell)\n\tAC_CHECK_FUNCS(futimens utimensat)\n\tAC_CHECK_FUNCS(fstatat mknodat readlinkat)\n\tAC_CHECK_FUNCS(readv writev preadv pwritev)\n\tAC_CHECK_FUNCS(setpgid)\n\tAC_CHECK_FUNCS(system)\n\tAC_CHECK_FUNCS(fork execv execve)\n\tAC_CHECK_FUNCS(waitpid)\n\tAC_CHECK_FUNCS(accept4)\n\tAC_CHECK_FUNCS(localtime_r)\n\tAC_CHECK_FUNCS(mkdtemp)\n\tAC_CHECK_SIZEOF(size_t)\n\tAC_CHECK_TYPES([blksize_t], [AC_DEFINE(HAVE_BLKSIZE_T)], , \n\t\t[#include <sys/types.h>\n\t\t #include <sys/stat.h>\n\t\t #include <unistd.h>])\n\tAC_CHECK_TYPES([blkcnt_t], [AC_DEFINE(HAVE_BLKCNT_T)], ,\n\t\t[#include <sys/types.h>\n\t\t #include <sys/stat.h>\n\t\t #include <unistd.h>])\n\tAC_CHECK_TYPES([suseconds_t], [AC_DEFINE(HAVE_SUSECONDS_T)], ,\n\t\t[#include <sys/time.h>])\n\tAC_CHECK_TYPES([struct cmsghdr], [AC_DEFINE(HAVE_STRUCT_CMSGHDR)], ,\n\t\t[#include <sys/socket.h>])\n\tAC_CHECK_TYPES([struct flock], [AC_DEFINE(HAVE_STRUCT_FLOCK)], ,\n\t\t[#include <unistd.h>\n\t\t #include <fcntl.h>])\n\tAC_CHECK_TYPES([struct iovec], [AC_DEFINE(HAVE_STRUCT_IOVEC)], ,\n\t\t[#include <sys/uio.h>])\n\tAC_CHECK_TYPES([struct linger], [AC_DEFINE(HAVE_STRUCT_LINGER)], ,\n\t\t[#include <sys/socket.h>])\n\tAC_CHECK_TYPES([struct pollfd], [AC_DEFINE(HAVE_STRUCT_POLLFD)], ,\n\t\t[#include <sys/poll.h>])\n\tAC_CHECK_TYPES([struct sockaddr], [AC_DEFINE(HAVE_STRUCT_SOCKADDR)], ,\n\t\t[#include <sys/socket.h>])\n\tAC_CHECK_TYPES([struct sockaddr_storage], [AC_DEFINE(HAVE_STRUCT_SOCKADDR_STORAGE)], ,\n\t\t[#include <sys/socket.h>])\n\tAC_CHECK_TYPES([struct sockaddr_in], [AC_DEFINE(HAVE_STRUCT_SOCKADDR_IN)], ,\n\t\t[#include <netinet/in.h>])\n\tAC_CHECK_TYPES([struct sockaddr_in6], [AC_DEFINE(HAVE_STRUCT_SOCKADDR_IN6)], ,\n\t\t[#include <netinet/in.h>])\n\tAC_CHECK_TYPES([struct sockaddr_un], [AC_DEFINE(HAVE_STRUCT_SOCKADDR_UN)], ,\n\t\t[#include <sys/un.h>])\n\tAC_CHECK_TYPES([struct stat], [AC_DEFINE(HAVE_STRUCT_STAT)], ,\n\t\t[#include <sys/types.h>\n\t\t #include <sys/stat.h>\n\t\t #include <unistd.h>])\n\tAC_CHECK_TYPES([struct timespec], [AC_DEFINE(HAVE_STRUCT_TIMESPEC)], ,\n\t\t[#include <time.h>])\n\tAC_CHECK_TYPES([struct timeval], [AC_DEFINE(HAVE_STRUCT_TIMEVAL)], ,\n\t\t[#include <sys/time.h>\n\t\t #include <sys/types.h>\n\t\t #include <utime.h>])\n\tAC_CHECK_TYPES([struct timezone], [AC_DEFINE(HAVE_STRUCT_TIMEZONE)], ,\n\t\t[#include <sys/time.h>])\n\tAC_CHECK_TYPES([struct utimbuf], [AC_DEFINE(HAVE_STRUCT_UTIMBUF)], ,\n\t\t[#include <sys/types.h>\n\t\t #include <utime.h>])\n\tAC_CHECK_MEMBERS(\n\t\t[struct dirent.d_off, struct dirent.d_reclen, struct dirent.d_type],,, \n\t\t[#include <sys/types.h>\n\t\t #include <dirent.h>])\n\tAC_CHECK_MEMBERS(\n\t\t[struct passwd.pw_gecos],,, \n\t\t[#include <sys/types.h>\n\t\t #include <pwd.h>])\n\tAC_CHECK_MEMBERS(\n\t\t[struct statfs.f_flags],,, \n\t\t[#include <sys/types.h>\n\t\t #include <sys/vfs.h>])\n\tAC_CHECK_MEMBERS(\n\t\t[struct stat.st_atim, struct stat.st_mtim, struct stat.st_atimespec, struct stat.st_ctim],,, \n\t\t[#include <sys/types.h>\n\t\t #include <sys/stat.h>\n\t\t #include <unistd.h>])\n\n\tdnl Favour xattr through glibc, but use libattr if we have to\n\tAC_CHECK_FUNC(lsetxattr, ,\n\t\tAC_CHECK_LIB(attr, lsetxattr, XATTR_LIB=\"-lattr\",)\n\t)\n\tAC_SUBST(XATTR_LIB)\n\n\tdnl kinfo_proc.kp_proc works on darwin but fails on other simil-bsds\n\tAC_CHECK_MEMBERS(\n\t\t[struct kinfo_proc.kp_proc],,, \n\t\t[#include <sys/types.h>\n\t\t #include <sys/param.h>\n\t\t #include <sys/sysctl.h>\n\t\t #include <sys/proc.h>\n\t\t ])\n\n\tdnl *********************************\n\tdnl *** Checks for Windows compilation ***\n\tdnl *********************************\n\tAC_CHECK_HEADERS(sys/time.h)\n\tAC_CHECK_HEADERS(sys/param.h)\n\tAC_CHECK_HEADERS(dirent.h)\n\n\tdnl ******************************************\n\tdnl *** Checks for OSX and iOS compilation ***\n\tdnl ******************************************\n\tAC_CHECK_HEADERS(CommonCrypto/CommonDigest.h)\n\n\tdnl *********************************\n\tdnl *** Check for Console 2.0 I/O ***\n\tdnl *********************************\n\tAC_CHECK_HEADERS([curses.h])\n\tAC_CHECK_HEADERS([term.h], [], [],\n\t[#if HAVE_CURSES_H\n\t #include <curses.h>\n\t #endif\n\t])\n\tAC_CHECK_HEADERS([termios.h])\n\n\tdnl *********************************\n\tdnl *** Checks for random         ***\n\tdnl *********************************\n\tif test x$host_darwin = xno; then\n\t\tAC_CHECK_HEADERS(sys/random.h)\n\t\tAC_CHECK_FUNCS(getrandom getentropy)\n\tfi\n\n\tdnl *********************************\n\tdnl *** Checks for Mono.Native    ***\n\tdnl *********************************\n\n\t# Translated from CMake in external/corefx/src/Native/Unix/configure.cmake, keep in sync!\n\t# Note: check_c_source_compiles in CMake is AC_TRY_LINK in autoconf\n\n\tAC_MSG_CHECKING(for linux/in.h)\n\tAC_TRY_COMPILE([\n\t\t#include <sys/socket.h>\n\t\t#include <linux/in.h>\n\t], [\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_LINUX_IN_H, 1, [linux/in.h])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_CHECK_HEADERS([linux/if_packet.h])\n\n\tAC_MSG_CHECKING(for struct in_pktinfo)\n\tAC_TRY_COMPILE([\n\t\t#ifdef HAVE_LINUX_IN_H\n\t\t#include <sys/socket.h>\n\t\t#include <linux/in.h>\n\t\t#else\n\t\t#include <netinet/in.h>\n\t\t#endif\n\t], [\n\t\tstruct in_pktinfo pktinfo;\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IN_PKTINFO, 1, [struct in_pktinfo])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_MSG_CHECKING(for struct ip_mreqn)\n\tAC_TRY_COMPILE([\n\t\t#if HAVE_LINUX_IN_H\n\t\t#include <sys/socket.h>\n\t\t#include <linux/in.h>\n\t\t#else\n\t\t#include <netinet/in.h>\n\t\t#endif\n\t], [\n\t\tstruct ip_mreqn mreqn;\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IP_MREQN, 1, struct ip_mreqn)\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tif test x$host_darwin = xno; then\n\t\tAC_CHECK_TYPES([struct flock64], [AC_DEFINE(HAVE_FLOCK64, 1, struct flock64)], , [#include <fcntl.h>])\n\tfi\n\n\tAC_CHECK_DECL(O_CLOEXEC,         [AC_DEFINE(HAVE_O_CLOEXEC, 1, [O_CLOEXEC])], [], [[#include <fcntl.h>]])\n\tAC_CHECK_DECL(F_DUPFD_CLOEXEC,   [AC_DEFINE(HAVE_F_DUPFD_CLOEXEC, 1, [F_DUPFD_CLOEXEC])], [], [[#include <fcntl.h>]])\n\n\t# AC_CHECK_FUNC(getifaddrs,           [AC_DEFINE(HAVE_GETIFADDRS, 1, [getifaddrs])]) # already done above\n\tAC_CHECK_FUNC(Qp2getifaddrs,     [AC_DEFINE(HAVE_QP2GETIFADDRS, 1, [Qp2getifaddrs])])\n\n\tAC_CHECK_FUNC(lseek64,           [AC_DEFINE(HAVE_LSEEK64, 1, [lseek64])])\n\tAC_CHECK_FUNC(mmap64,            [AC_DEFINE(HAVE_MMAP64, 1, [mmap64])])\n\tAC_CHECK_FUNC(ftruncate64,       [AC_DEFINE(HAVE_FTRUNCATE64, 1, [ftruncate64])])\n\tAC_CHECK_FUNC(posix_fadvise64,   [AC_DEFINE(HAVE_POSIX_FADVISE64, 1, [posix_fadvise64])])\n\n\tif test \"x$mono_native_platform_ios\" = \"xno\"; then\n\t\t# On iOS, `stat64()` is deprecated and there is no `struct stat64` and `stat()`\n\t\t# is either 32-bit or 64-bit based on the device / simulator that you're running on.\n\t\tAC_CHECK_FUNC(stat64,            [AC_DEFINE(HAVE_STAT64, 1, [stat64])])\n\tfi\n\n\tAC_CHECK_DECL(pipe2,             [AC_DEFINE(HAVE_PIPE2, 1, [pipe2])])\n\tAC_CHECK_FUNC(getmntinfo,        [AC_DEFINE(HAVE_GETMNTINFO, 1, [getmntinfo])], [], [[#include <unistd.h>]])\n\tAC_CHECK_FUNC(strcpy_s,          [AC_DEFINE(HAVE_STRCPY_S, 1, [strcpy_s])])\n\tAC_CHECK_FUNC(strlcpy,           [AC_DEFINE(HAVE_STRLCPY, 1, [strlcpy])])\n\tAC_CHECK_FUNC(posix_fadvise,     [AC_DEFINE(HAVE_POSIX_ADVISE, 1, [posix_fadvise])]) # the define is called HAVE_POSIX_ADVISE in corefx, not a typo\n\tAC_CHECK_FUNC(ioctl,             [AC_DEFINE(HAVE_IOCTL, 1, [ioctl])])\n\tAC_CHECK_FUNC(sched_getaffinity, [AC_DEFINE(HAVE_SCHED_GETAFFINITY, 1, [sched_getaffinity])])\n\tAC_CHECK_FUNC(sched_setaffinity, [AC_DEFINE(HAVE_SCHED_SETAFFINITY, 1, [sched_setaffinity])])\n\n\tif test \"x$platform_android\" != \"xyes\"; then\n\t\tAC_CHECK_FUNC(arc4random_buf,    [AC_DEFINE(HAVE_ARC4RANDOM_BUF, 1, [arc4random_buf])])\n\tfi\n\n\tAC_CHECK_DECL(TIOCGWINSZ,        [AC_DEFINE(HAVE_TIOCGWINSZ, 1, [TIOCGWINSZ])], [], [[#include <sys/ioctl.h>]])\n\tAC_CHECK_FUNC(tcgetattr,         [AC_DEFINE(HAVE_TCGETATTR, 1, [tcgetattr])])\n\tAC_CHECK_FUNC(tcsetattr,         [AC_DEFINE(HAVE_TCSETATTR, 1, [tcsetattr])])\n\tAC_CHECK_DECL(ECHO,              [AC_DEFINE(HAVE_ECHO, 1, [ECHO])], [], [[#include <termios.h>]])\n\tAC_CHECK_DECL(ICANON,            [AC_DEFINE(HAVE_ICANON, 1, [ICANON])], [], [[#include <termios.h>]])\n\tAC_CHECK_DECL(TCSANOW,           [AC_DEFINE(HAVE_TCSANOW, 1, [TCSANOW])], [], [[#include <termios.h>]])\n\n\tAC_CHECK_DECL(lchflags,          [AC_DEFINE(HAVE_LCHFLAGS, 1, [lchflags])], [], \n\t\t[[#include <sys/types.h> \n\t\t#include <sys/stat.h>]])\n\tAC_CHECK_MEMBER(struct stat.st_flags,\n\t\t[AC_DEFINE(HAVE_STAT_FLAGS, 1, [struct stat.st_flags])],\n\t\t[],\n\t\t[#include <sys/types.h>\n\t\t#include <sys/stat.h>])\n\n\tAC_CHECK_MEMBER(struct stat.st_birthtimespec,\n\t\t[AC_DEFINE(HAVE_STAT_BIRTHTIME, 1, [struct stat.st_birthtimespec])],\n\t\t[],\n\t\t[#include <sys/types.h>\n\t\t#include <sys/stat.h>])\n\tAC_CHECK_MEMBER(struct stat.st_atimespec,\n\t\t[AC_DEFINE(HAVE_STAT_TIMESPEC, 1, [struct stat.st_atimespec])],\n\t\t[],\n\t\t[#include <sys/types.h>\n\t\t#include <sys/stat.h>])\n\tAC_CHECK_MEMBER(struct stat.st_atim,\n\t\t[AC_DEFINE(HAVE_STAT_TIM, 1, [struct stat.st_atim])],\n\t\t[],\n\t\t[#include <sys/types.h>\n\t\t#include <sys/stat.h>])\n\tAC_CHECK_MEMBER(struct stat.st_atimensec,\n\t\t[AC_DEFINE(HAVE_STAT_NSEC, 1, [struct stat.st_atimensec])],\n\t\t[],\n\t\t[#include <sys/types.h>\n\t\t#include <sys/stat.h>])\n\tAC_CHECK_MEMBER(struct dirent.d_namlen,       [AC_DEFINE(HAVE_DIRENT_NAME_LEN, 1, [struct dirent.d_namlen])], [], [#include <dirent.h>])\n\tAC_CHECK_MEMBER(struct statfs.f_fstypename,   [AC_DEFINE(HAVE_STATFS_FSTYPENAME, 1, [struct statfs.f_fstypename])], [], [#include <sys/mount.h>])\n\tAC_CHECK_MEMBER(struct statvfs.f_fstypename,  [AC_DEFINE(HAVE_STATVFS_FSTYPENAME, 1, [struct statvfs.f_fstypename])], [], [#include <sys/mount.h>])\n\n\tAC_MSG_CHECKING(for struct statfs)\n\tAC_TRY_COMPILE([\n\t\t#if defined(HAVE_STATFS_FSTYPENAME) || defined(HAVE_STATVFS_FSTYPENAME)\n\t\t#include <sys/mount.h>\n\t\t#else\n\t\t#include <sys/statfs.h>\n\t\t#endif\n\t], [\n\t\tstruct statfs;\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_STATFS, 1, [struct statfs])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tif test \"x$ac_cv_func_strerror_r_char_p\" = \"xyes\" ; then\n\t\tAC_DEFINE(HAVE_GNU_STRERROR_R, 1, [char* strerror(int errnum, char *buf, size_t buflen)])\n\tfi\n\n\tAC_MSG_CHECKING(for readdir_r)\n\tAC_TRY_LINK([\n\t\t#include <dirent.h>\n\t], [\n\t\tDIR* dir;\n\t\tstruct dirent* entry;\n\t\tstruct dirent* result;\n\t\treaddir_r(dir, entry, &result);\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_READDIR_R, 1, [readdir_r])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_MSG_CHECKING(for kevent with void *data)\n\tAC_TRY_LINK([\n\t\t#include <sys/types.h>\n\t\t#include <sys/event.h>\n\t], [\n\t\tstruct kevent event;\n\t\tvoid* data;\n\t\tEV_SET(&event, 0, EVFILT_READ, 0, 0, 0, data);\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(KEVENT_HAS_VOID_UDATA, 1, [kevent with void *data])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_CHECK_MEMBER(struct fd_set.fds_bits,   [AC_DEFINE(HAVE_FDS_BITS, 1, [struct fd_set.fds_bits])], [], [[#include <sys/select.h>]])\n\tAC_CHECK_MEMBER(struct fd_set.__fds_bits, [AC_DEFINE(HAVE_PRIVATE_FDS_BITS, 1, [struct fd_set.__fds_bits])], [], [[#include <sys/select.h>]])\n\n\tAC_MSG_CHECKING(for sendfile with 4 arguments)\n\tAC_TRY_LINK([\n\t\t#include <sys/sendfile.h>\n\t], [\n\t\t#if defined(TARGET_ANDROID)\n\t\t#if !defined(__ANDROID_API__)\n\t\t#error No definition for __ANDROID_API__ even though we're targeting TARGET_ANDROID\n\t\t#elif __ANDROID_API__ < 21\n\t\t#error sendfile is not supported on this Android API level\n\t\t#endif\n\t\t#endif\n\n\t\tint result = sendfile(0, 0, 0, 0);\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_SENDFILE_4, 1, [sendfile with 4 arguments])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tORIG_CFLAGS=\"$CFLAGS\"\n\tCFLAGS=\"$CFLAGS -Werror-implicit-function-declaration\"\n\n\tAC_MSG_CHECKING(for sendfile with 6 arguments)\n\tAC_TRY_LINK([\n\t\t#include <stdlib.h>\n\t\t#include <sys/types.h>\n\t\t#include <sys/socket.h>\n\t\t#include <sys/uio.h>\n\t], [\n\t\tint result = sendfile(0, 0, 0, NULL, NULL, 0);\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_SENDFILE_6, 1, [sendfile with 6 arguments])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tCFLAGS=\"$ORIG_CFLAGS\"\n\n\tAC_CHECK_FUNC(fcopyfile,     [AC_DEFINE(HAVE_FCOPYFILE, 1, [fcopyfile])])\n\tAC_CHECK_FUNC(epoll_create1, [AC_DEFINE(HAVE_EPOLL, 1, [epoll_create1])])\n\tAC_CHECK_FUNC(accept4,       [AC_DEFINE(HAVE_ACCEPT4, 1, [accept4])])\n\tAC_CHECK_FUNC(kqueue,        [AC_DEFINE(HAVE_KQUEUE, 1, [kqueue])])\n\n\tORIG_CFLAGS=\"$CFLAGS\"\n\tCFLAGS=\"$CFLAGS -Werror=sign-conversion\"\n\n\tAC_MSG_CHECKING(for getnameinfo with signed flags)\n\tAC_TRY_LINK([\n\t\t#include <sys/types.h>\n\t\t#include <netdb.h>\n\t], [\n\t\tconst struct sockaddr *addr;\n\t\tsocklen_t addrlen;\n\t\tchar *host;\n\t\tsocklen_t hostlen;\n\t\tchar *serv;\n\t\tsocklen_t servlen;\n\t\tint flags;\n\t\tint result = getnameinfo(addr, addrlen, host, hostlen, serv, servlen, flags);\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETNAMEINFO_SIGNED_FLAGS, 1, [getnameinfo with signed flags])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tCFLAGS=\"$ORIG_CFLAGS\"\n\n\tif test \"x$host_linux\" = \"xyes\"; then\n\t\tAC_DEFINE(HAVE_SUPPORT_FOR_DUAL_MODE_IPV4_PACKET_INFO, 1, [HAVE_SUPPORT_FOR_DUAL_MODE_IPV4_PACKET_INFO])\n\telse\n\t\tAC_DEFINE(HAVE_SUPPORT_FOR_DUAL_MODE_IPV4_PACKET_INFO, 0, [HAVE_SUPPORT_FOR_DUAL_MODE_IPV4_PACKET_INFO])\n\tfi\n\n\t# HAVE_CLOCK_MONOTONIC check already done above\n\t# HAVE_CLOCK_REALTIME check already done above\n\t# HAVE_MACH_ABSOLUTE_TIME check already done above\n\t# HAVE_MACH_TIMEBASE_INFO check already done above\n\t# HAVE_FUTIMES check already done above\n\t# HAVE_FUTIMENS check already done above\n\n\tORIG_CFLAGS=\"$CFLAGS\"\n\tCFLAGS=\"$CFLAGS -Werror=sign-conversion\"\n\n\tAC_MSG_CHECKING(for bind with unsigned addrlen)\n\tAC_TRY_LINK([\n\t\t#include <sys/socket.h>\n\t], [\n\t\tint fd;\n\t\tstruct sockaddr* addr;\n\t\tsocklen_t addrLen;\n\t\tbind(fd, addr, addrLen);\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(BIND_ADDRLEN_UNSIGNED, 1, [bind with unsigned addrlen])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_MSG_CHECKING(for struct ipv6_mreq with unsigned ipv6mr_interface)\n\tAC_TRY_LINK([\n\t\t#include <netinet/in.h>\n\t\t#include <netinet/tcp.h>\n\t], [\n\t\tstruct ipv6_mreq opt;\n\t\tunsigned int index = 0;\n\t\topt.ipv6mr_interface = index;\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(IPV6MR_INTERFACE_UNSIGNED, 1, [struct ipv6_mreq with unsigned ipv6mr_interface])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_MSG_CHECKING(for inotify_rm_watch with unsigned wd)\n\tAC_TRY_LINK([\n\t\t#include <sys/inotify.h>\n\t], [\n\t\tintptr_t fd;\n\t\tuint32_t wd;\n\t\tint result = inotify_rm_watch(fd, wd);\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(INOTIFY_RM_WATCH_WD_UNSIGNED, 1, [inotify_rm_watch with unsigned wd])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tCFLAGS=\"$ORIG_CFLAGS\"\n\n\tAC_MSG_CHECKING(for shm_open that works well enough with mmap)\n\tif test \"x$ac_cv_func_shm_open\" = \"xno\" -o \"x$ac_cv_func_shm_open_working_with_mmap\" = \"xno\" ; then\n\t\tAC_MSG_RESULT(no)\n\telif test \"x$cross_compiling\" = \"xyes\"; then\n\t\tAC_MSG_RESULT(cross compiling, assuming yes)\n\t\tAC_DEFINE(HAVE_SHM_OPEN_THAT_WORKS_WELL_ENOUGH_WITH_MMAP, 1, [shm_open that works well enough with mmap])\n\telse\n\t\tAC_TRY_RUN([\n\t\t\t#include <sys/mman.h>\n\t\t\t#include <fcntl.h>\n\t\t\t#include <unistd.h>\n\n\t\t\tint main ()\n\t\t\t{\n\t\t\t#ifdef __PASE__\n\t\t\t\t/* IBM i doesn't implement this and returns SIGILL */\n\t\t\t\treturn -1;\n\t\t\t#endif\n\t\t\t\tint fd = shm_open(\"/mono_configure_shm_open\", O_CREAT | O_RDWR, 0777);\n\t\t\t\tif (fd == -1)\n\t\t\t\t\treturn -1;\n\n\t\t\t\tshm_unlink(\"/mono_configure_shm_open\");\n\n\t\t\t\t// NOTE: PROT_EXEC and MAP_PRIVATE don't work well with shm_open\n\t\t\t\t//       on at least the current version of Mac OS X\n\n\t\t\t\tif (mmap(NULL, 1, PROT_EXEC, MAP_PRIVATE, fd, 0) == MAP_FAILED)\n\t\t\t\t\treturn -1;\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t],[\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_SHM_OPEN_THAT_WORKS_WELL_ENOUGH_WITH_MMAP, 1, [shm_open that works well enough with mmap])\n\t\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t\t])\n\tfi\n\n\tAC_MSG_CHECKING(for getpriority with int who)\n\tAC_TRY_LINK([\n\t\t#include <sys/resource.h>\n\t], [\n\t\tint which;\n\t\tint who;\n\t\tint result = getpriority(which, who);\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(PRIORITY_REQUIRES_INT_WHO, 1, [getpriority with int who])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_MSG_CHECKING(for kevent with int parameters)\n\tAC_TRY_LINK([\n\t\t#include <sys/types.h>\n\t\t#include <sys/event.h>\n\t], [\n\t\tint kg;\n\t\tconst struct kevent* chagelist;\n\t\tint nchanges;\n\t\tstruct kevent* eventlist;\n\t\tint nevents;\n\t\tconst struct timespec* timeout;\n\t\tint result = kevent(kg, chagelist, nchanges, eventlist, nevents, timeout);\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(KEVENT_REQUIRES_INT_PARAMS, 1, [kevent with int parameters])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_CHECK_FUNCS(mkstemps)\n\t# AC_CHECK_FUNCS(mkstemp) # already done above\n\n\tif test \"x$ac_cv_func_mkstemps\" != \"xyes\" -a \"x$ac_cv_func_mkstemp\" != \"xyes\"; then\n\t\tAC_MSG_ERROR([Cannot find mkstemps or mkstemp on this platform])\n\tfi\n\n\tAC_MSG_CHECKING(for tcp/var.h)\n\tAC_TRY_LINK([\n\t\t#include <sys/types.h>\n\t\t#include <sys/socketvar.h>\n\t\t#include <netinet/ip.h>\n\t\t#include <netinet/tcp.h>\n\t\t#include <netinet/tcp_var.h>\n\t], [\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_TCP_VAR_H, 1, [tcp/var.h])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_CHECK_HEADERS([sys/cdefs.h])\n\n\tAC_MSG_CHECKING(for TCPSTATE enum in netinet/tcp.h)\n\tAC_TRY_LINK([\n\t\t#ifdef HAVE_SYS_CDEFS_H\n\t\t#include <sys/cdefs.h>\n\t\t#endif\n\t\t#include <netinet/tcp.h>\n\t], [\n\t\tint result = TCP_ESTABLISHED;\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_TCP_H_TCPSTATE_ENUM, 1, [TCPSTATE enum in netinet/tcp.h])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_CHECK_DECL(TCPS_ESTABLISHED, [AC_DEFINE(HAVE_TCP_FSM_H, 1, [HAVE_TCP_FSM_H])], [], [[#include <netinet/tcp_fsm.h>]])\n\n\tAC_MSG_CHECKING(for struct rt_msghdr)\n\tAC_TRY_COMPILE([\n\t\t#include <sys/types.h>\n\t\t#include <net/route.h>\n\t], [\n\t\tstruct rt_msghdr;\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_RT_MSGHDR, 1, [struct rt_msghdr])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_CHECK_HEADERS([sys/sysctl.h])\n\tAC_CHECK_HEADERS([linux/rtnetlink.h])\n\n\tAC_CHECK_FUNC(getpeereid,    [AC_DEFINE(HAVE_GETPEEREID, 1, [getpeereid])])\n\t#AC_CHECK_FUNC(getdomainname, [AC_DEFINE(HAVE_GETDOMAINNAME, 1, [getdomainname])]) # already done above\n\tAC_CHECK_FUNC(uname,         [AC_DEFINE(HAVE_UNAME, 1, [uname])])\n\n\tORIG_CFLAGS=\"$CFLAGS\"\n\tCFLAGS=\"$CFLAGS -Werror=shorten-64-to-32\"\n\n\tAC_MSG_CHECKING(for getdomainname with size_t namelen)\n\tAC_TRY_LINK([\n\t\t#include <unistd.h>\n\t], [\n\t\tsize_t namelen = 20;\n\t\tchar name[20];\n\t\tint result = getdomainname(name, namelen);\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETDOMAINNAME_SIZET, 1, [getdomainname with size_t namelen])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tCFLAGS=\"$ORIG_CFLAGS\"\n\n\tAC_CHECK_FUNC(inotify_init, [AC_DEFINE(HAVE_INOTIFY_INIT, 1, [inotify_init])])\n\tAC_CHECK_FUNC(inotify_add_watch, [AC_DEFINE(HAVE_INOTIFY_ADD_WATCH, 1, [inotify_add_watch])])\n\tAC_CHECK_FUNC(inotify_rm_watch, [AC_DEFINE(HAVE_INOTIFY_RM_WATCH, 1, [inotify_rm_watch])])\n\n\tif test \"x$ac_cv_func_inotify_init\" = \"xyes\" -a \"x$ac_cv_func_inotify_add_watch\" = \"xyes\" -a \"x$ac_cv_func_inotify_rm_watch\" = \"xyes\"; then\n\t\tAC_DEFINE(HAVE_INOTIFY, 1, [HAVE_INOTIFY])\n\telif test \"x$host_linux\" = \"xyes\"; then\n\t\tAC_MSG_ERROR([Cannot find inotify functions on a Linux platform.])\n\tfi\n\n\t# HAVE_CURLM_ADDED_ALREADY check skipped because we don't use libcurl in mono\n\t# HAVE_CURL_HTTP_VERSION_2TLS check skipped because we don't use libcurl in mono\n\t# HAVE_CURLPIPE_MULTIPLEX check skipped because we don't use libcurl in mono\n\t# HAVE_CURL_SSLVERSION_TLSv1_012 check skipped because we don't use libcurl in mono\n\n\tenable_gss=no;\n\tAC_MSG_CHECKING(for GSS/GSS.h)\n\tAC_TRY_COMPILE([\n\t\t\t#include <GSS/GSS.h>\n\t], [\n\t],[\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_GSSFW_HEADERS, 1, [GSS/GSS.h])\n\t\t\tAC_DEFINE(HAVE_GSS_SPNEGO_MECHANISM, 1, [GSS_SPNEGO_MECHANISM])\n\t\t\tenable_gss=yes\n\t\t\tAC_DEFINE(ENABLE_GSS, 1, [ENABLE_GSS])\n\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_MSG_CHECKING(for gssapi/gssapi_ext.h)\n\tAC_TRY_COMPILE([\n\t\t\t#include <gssapi/gssapi_ext.h>\n\t], [\n\t],[\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tenable_gss=yes\n\t\t\tAC_DEFINE(ENABLE_GSS, 1, [ENABLE_GSS])\n\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_MSG_CHECKING(for GSS_SPNEGO_MECHANISM)\n\tAC_TRY_COMPILE([\n\t\t\t#include <gssapi/gssapi_ext.h>\n\t\t\t#include <gssapi/gssapi_krb5.h>\n\t\t\tgss_OID_set_desc gss_mech_spnego_OID_set_desc = {.count = 1, .elements = GSS_SPNEGO_MECHANISM};\n\t], [\n\t],[\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_GSS_SPNEGO_MECHANISM, 1, [GSS_SPNEGO_MECHANISM])\n\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAM_CONDITIONAL(ENABLE_GSS, test x$enable_gss = xyes)\n\n\tAC_CHECK_HEADERS([crt_externs.h])\n\n\tAC_MSG_CHECKING(for _NSGetEnviron)\n\tAC_TRY_LINK([\n\t\t#include <crt_externs.h>\n\t], [\n\t\tchar **result = *(_NSGetEnviron());\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_NSGETENVIRON, 1, [_NSGetEnviron])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_CHECK_DECL(IN_EXCL_UNLINK, [AC_DEFINE(HAVE_IN_EXCL_UNLINK, 1, [IN_EXCL_UNLINK])], [], [[#include <sys/inotify.h>]])\n\n\t# *** End of Mono.Native checks ***\nelse\n\tAM_CONDITIONAL(ENABLE_GSS, false)\n\n\tdnl *********************************\n\tdnl *** Checks for Windows compilation ***\n\tdnl *********************************\n\tAC_CHECK_HEADERS(winternl.h)\n\n\tjdk_headers_found=no\n\tAC_CHECK_LIB(ws2_32, main, LIBS=\"$LIBS -lws2_32\", AC_ERROR(bad mingw install?))\n\tAC_CHECK_LIB(psapi, main, LIBS=\"$LIBS -lpsapi\", AC_ERROR(bad mingw install?))\n\tAC_CHECK_LIB(ole32, main, LIBS=\"$LIBS -lole32\", AC_ERROR(bad mingw install?))\n\tAC_CHECK_LIB(winmm, main, LIBS=\"$LIBS -lwinmm\", AC_ERROR(bad mingw install?))\n\tAC_CHECK_LIB(oleaut32, main, LIBS=\"$LIBS -loleaut32\", AC_ERROR(bad mingw install?))\n\tAC_CHECK_LIB(advapi32, main, LIBS=\"$LIBS -ladvapi32\", AC_ERROR(bad mingw install?))\n\tAC_CHECK_LIB(version, main, LIBS=\"$LIBS -lversion\", AC_ERROR(bad mingw install?))\n\n\tdnl *********************************\n\tdnl *** Check for struct ip_mreqn ***\n\tdnl *********************************\n\tAC_MSG_CHECKING(for struct ip_mreqn)\n\tAC_TRY_COMPILE([#include <ws2tcpip.h>], [\n\t\tstruct ip_mreqn mreq;\n\t\tmreq.imr_address.s_addr = 0;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_STRUCT_IP_MREQN)\n\t], [\n\t\t# We'll just have to try and use struct ip_mreq\n\t\tAC_MSG_RESULT(no)\n\t\tAC_MSG_CHECKING(for struct ip_mreq)\n\t\tAC_TRY_COMPILE([#include <ws2tcpip.h>], [\n\t\t\tstruct ip_mreq mreq;\n\t\t\tmreq.imr_interface.s_addr = 0;\n\t\t], [\n\t\t\t# Yes, we have it...\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_STRUCT_IP_MREQ)\n\t\t], [\n\t\t\t# No multicast support\n\t\t\tAC_MSG_RESULT(no)\n\t\t])\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for getaddrinfo ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for getaddrinfo)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <winsock2.h>\n\t\t#include <ws2tcpip.h>\n\t], [\n\t\tgetaddrinfo(NULL,NULL,NULL,NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETADDRINFO, 1, [Have getaddrinfo])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for gethostbyname ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for gethostbyname)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <winsock2.h>\n\t\t#include <ws2tcpip.h>\n\t], [\n\t\tgethostbyname(NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETHOSTBYNAME, 1, [Have gethostbyname])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for getprotobyname ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for getprotobyname)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <winsock2.h>\n\t\t#include <ws2tcpip.h>\n\t], [\n\t\tgetprotobyname(NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETPROTOBYNAME, 1, [Have getprotobyname])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for getnameinfo ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for getnameinfo)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <winsock2.h>\n\t\t#include <ws2tcpip.h>\n\t], [\n\t\tgetnameinfo (NULL, 0, NULL, 0, NULL, 0, 0);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETNAMEINFO, 1, [Have getnameinfo])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for inet_ntop ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for inet_ntop)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <winsock2.h>\n\t\t#include <ws2tcpip.h>\n\t], [\n\t\tinet_ntop (0, NULL, NULL, 0);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_INET_NTOP, 1, [Have inet_ntop])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for inet_pton ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for inet_pton)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <winsock2.h>\n\t\t#include <ws2tcpip.h>\n\t], [\n\t\t#ifndef inet_pton\n\t\t(void) inet_pton;\n\t\t#endif\n\t\tinet_pton (0, NULL, NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_INET_PTON, 1, [Have inet_pton])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\nfi\n\ndnl socklen_t check\nAC_MSG_CHECKING(for socklen_t)\nAC_TRY_COMPILE([\n#include <sys/types.h>\n#include <sys/socket.h>\n],[\n  socklen_t foo;\n],[\nac_cv_c_socklen_t=yes\n\tAC_DEFINE(HAVE_SOCKLEN_T, 1, [Have socklen_t])\n\tAC_MSG_RESULT(yes)\n],[\n\tAC_MSG_RESULT(no)\n])\n\nAC_CHECK_FUNCS(execvp)\n\ndnl ****************************\ndnl *** Look for /dev/random ***\ndnl ****************************\n\nAC_MSG_CHECKING([if usage of random device is requested])\nAC_ARG_ENABLE(dev-random,\n[  --disable-dev-random    disable the use of the random device (enabled by default)],\ntry_dev_random=$enableval, try_dev_random=yes)\n\nAC_MSG_RESULT($try_dev_random)\n\ncase \"{$build}\" in\n\ndnl IBM i does not have /dev/random, use unblocking only\n\n    *-*-os400*)\n    NAME_DEV_RANDOM=\"/dev/urandom\"\n    ;;\n\ndnl Win32 does not have /dev/random, they have their own method...\n\n    *-mingw*|*-*-cygwin*)\n    ac_cv_have_dev_random=no\n    ;;\n\ndnl Everywhere else, it's /dev/random\n\n    *)\n    NAME_DEV_RANDOM=\"/dev/random\"\n    ;;\nesac\n\nAC_DEFINE_UNQUOTED(NAME_DEV_RANDOM, \"$NAME_DEV_RANDOM\", [Name of /dev/random])\n\ndnl Now check if the device actually exists\n\nif test \"x$try_dev_random\" = \"xyes\"; then\n    AC_CACHE_CHECK(for random device, ac_cv_have_dev_random,\n    [if test -r \"$NAME_DEV_RANDOM\" ; then\n        ac_cv_have_dev_random=yes; else ac_cv_have_dev_random=no; fi])\n    if test \"x$ac_cv_have_dev_random\" = \"xyes\"; then\n        AC_DEFINE(HAVE_CRYPT_RNG, 1, [Have /dev/random])\n    fi\nelse\n    AC_MSG_CHECKING(for random device)\n    ac_cv_have_dev_random=no\n    AC_MSG_RESULT(has been disabled)\nfi\n\nif test \"x$host_win32\" = \"xyes\"; then\n    AC_DEFINE(HAVE_CRYPT_RNG)\nfi\n\nif test \"x$ac_cv_have_dev_random\" = \"xno\" \\\n    && test \"x$host_win32\" = \"xno\"; then\n    AC_MSG_WARN([[\n***\n*** A system-provided entropy source was not found on this system.\n*** Because of this, the System.Security.Cryptography random number generator\n*** will throw a NotImplemented exception.\n***\n*** If you are seeing this message, and you know your system DOES have an\n*** entropy collection in place, please report an issue on GitHub and\n*** provide information about the system and how to access the random device.\n***\n*** Otherwise you can install either egd or prngd and set the environment\n*** variable MONO_EGD_SOCKET to point to the daemon's socket to use that.\n***]])\nfi\n\nAC_ARG_ENABLE(bcl-opt, [  --disable-bcl-opt\tBCL is compiled with no optimizations (allows accurate BCL debugging)], test_bcl_opt=$enableval, test_bcl_opt=yes)\n\nAC_MSG_CHECKING([if big-arrays are to be enabled])\nAC_ARG_ENABLE(big-arrays,  [  --enable-big-arrays\tEnable the allocation and indexing of arrays greater than Int32.MaxValue], enable_big_arrays=$enableval, enable_big_arrays=no)\nif test \"x$enable_big_arrays\" = \"xyes\" ; then\n    if  test \"x$ac_cv_sizeof_void_p\" = \"x8\"; then\n\tAC_DEFINE(MONO_BIG_ARRAYS,1,[Enable the allocation and indexing of arrays greater than Int32.MaxValue])\n    else\n        AC_MSG_ERROR([The allocation and indexing of arrays greater than Int32.MaxValue is not supported on this platform.])\n    fi\nfi\nAC_MSG_RESULT($enable_big_arrays)\n\ndnl **************\ndnl *** DTRACE ***\ndnl **************\n\nAC_ARG_ENABLE(dtrace,[  --enable-dtrace\tEnable DTrace probes], enable_dtrace=$enableval, enable_dtrace=$has_dtrace)\n\nif test \"x$enable_dtrace\" = \"xyes\"; then\n   if test \"x$has_dtrace\" = \"xno\"; then\n   \t  AC_MSG_ERROR([DTrace probes are not supported on this platform.])\n   fi\n   AC_PATH_PROG(DTRACE, [dtrace], [no], [$PATH:/usr/sbin])\n   if test \"x$DTRACE\" = \"xno\"; then\n   \t  AC_MSG_RESULT([dtrace utility not found, dtrace support disabled.])\n\t  enable_dtrace=no\n   elif ! $DTRACE -h -s $srcdir/data/mono.d > /dev/null 2>&1; then\n\t  AC_MSG_RESULT([dtrace doesn't support -h option, dtrace support disabled.])\n\t  enable_dtrace=no\n   fi\nfi\n\ndtrace_g=no\nif test \"x$enable_dtrace\" = \"xyes\"; then\n\tAC_DEFINE(ENABLE_DTRACE, 1, [Enable DTrace probes])\n\tDTRACEFLAGS=\n\tif test \"x$ac_cv_sizeof_void_p\" = \"x8\"; then\n\t\tcase \"$host\" in\n\t\t\tpowerpc-*-darwin*)\n\t\t\tDTRACEFLAGS=\"-arch ppc64\"\n\t\t\t;;\n\t\t\ti*86-*-darwin*)\n\t\t\tDTRACEFLAGS=\"-arch x86_64\"\n\t\t\t;;\n\t\t\t*)\n\t\t\tDTRACEFLAGS=-64\n\t\t\t;;\n\t\tesac\n\telse\n\t\tcase \"$host\" in\n\t\t\tpowerpc-*-darwin*)\n\t\t\tDTRACEFLAGS=\"-arch ppc\"\n\t\t\t;;\n\t\t\ti*86-*-darwin*)\n\t\t\tDTRACEFLAGS=\"-arch i386\"\n\t\t\t;;\n\t\t\t*)\n\t\t\tDTRACEFLAGS=-32\n\t\t\t;;\n\t\tesac\n\tfi\n\tAC_SUBST(DTRACEFLAGS)\n\tcase \"$host\" in\n\t\t*-*-solaris*)\n\t\tdtrace_g=yes\n\t\t;;\n\tesac\n\tAC_CHECK_HEADERS([sys/sdt.h])\nfi\nAM_CONDITIONAL(ENABLE_DTRACE, [test x$enable_dtrace = xyes])\nAM_CONDITIONAL(DTRACE_G_REQUIRED, [test x$dtrace_g = xyes])\n\ndnl **************************\ndnl *** AOT cross offsets  ***\ndnl **************************\n\nAC_ARG_WITH(cross-offsets, [  --with-cross-offsets=<offsets file path>    Explicit AOT cross offsets file],\n    AC_DEFINE_UNQUOTED(MONO_OFFSETS_FILE, \"$withval\", [AOT cross offsets file]))\n\ndnl **************\ndnl ***  LLVM  ***\ndnl **************\n\nAC_ARG_ENABLE(llvm,[  --enable-llvm\tEnable the LLVM back-end], enable_llvm=$enableval, enable_llvm=default)\nAC_ARG_ENABLE(loadedllvm,[  --enable-loadedllvm\tLoad the LLVM back-end dynamically], enable_llvm=$enableval && enable_loadedllvm=$enableval, enable_loadedllvm=no)\nAC_ARG_ENABLE(llvm-version-check,[  --enable-llvm-version-check Check that the LLVM matches the version expected by mono], enable_llvm_version_check=$enableval, enable_llvm_version_check=no)\nAC_ARG_ENABLE(llvm-runtime,[  --enable-llvm-runtime\tEnable runtime support for llvmonly code], enable_llvm_runtime=$enableval, enable_llvm_runtime=no)\nAC_ARG_ENABLE(llvm-asserts,[  --enable-llvm-asserts Enable llvm asserts (option to LLVM in CMake)], enable_llvm_asserts=$enableval, enable_llvm_asserts=no)\n\nAC_ARG_WITH(llvm, [  --with-llvm=<llvm prefix>    Enable the LLVM back-end], enable_llvm=yes,)\n\nif test \"x$enable_llvm\" = \"xdefault\"; then\n   enable_llvm=$enable_llvm_default\nfi\n\nenable_llvm_msvc_only=\"no\"\nif test \"x$enable_llvm\" = \"xyes\"; then\n\tif test \"x$host_win32\" = \"xyes\"; then\n\t\tif test \"x$cross_compiling\" = \"xno\"; then\n\t\t\tcase \"$target\" in\n\t\t\tx86_64*)\n\t\t\t\tAC_MSG_WARN(\"LLVM for host=Windows and target=Windows is only supported on x64 MSVC builds. Disabling LLVM for GCC build.\")\n\t\t\t\tenable_llvm_msvc_only=\"yes\"\n\t\t\t\t;;\n\t\t\ti686*)\n\t\t\t\tAC_MSG_ERROR(\"LLVM for host=Windows and target=Windows is only supported for x64 builds.\")\n\t\t\t\t;;\n\t\t\tesac\n\t\tfi\n\t\tif test \"x$enable_loadedllvm\" = \"xyes\"; then\n\t\t\tAC_MSG_WARN(\"Loadable LLVM currently not supported on Windows. Disabling feature.\")\n\t\t\tenable_loadedllvm=no\n\t\tfi\n\tfi\nfi\n\ninternal_llvm=\"no\"\nif test \"x$enable_llvm\" = \"xyes\"; then\n\tif test \"x$with_llvm\" != \"x\"; then\n\t\tEXTERNAL_LLVM_CONFIG=$with_llvm/bin/llvm-config\n\t\tif test x$host_win32 = xyes; then\n\t\t\tEXTERNAL_LLVM_CONFIG=$EXTERNAL_LLVM_CONFIG.exe\n\t\tfi\n\t\tif test ! -x $EXTERNAL_LLVM_CONFIG; then\n\t\t\tAC_MSG_ERROR([LLVM executable $EXTERNAL_LLVM_CONFIG not found.])\n\t\tfi\n\telse\n\t\tinternal_llvm=yes\n\tfi\n\n\tLLVM_CODEGEN_LIBS=\"x86codegen\"\n\tcase \"$target\" in\n\tarm*)\n\t\tLLVM_CODEGEN_LIBS=\"armcodegen\"\n\t\t;;\n\taarch64*)\n\t\tLLVM_CODEGEN_LIBS=\"aarch64codegen\"\n\t\t;;\n\tpowerpc*)\n\t\tLLVM_CODEGEN_LIBS=\"powerpccodegen\"\n\t\t;;\n\tesac\n\tif test \"x$host\" != \"x$target\"; then\n\t\t# No need for jit libs\n\t\tLLVM_CODEGEN_LIBS=\n\tfi\n\n\tAC_SUBST(LLVM_CODEGEN_LIBS)\n\tAC_SUBST(EXTERNAL_LLVM_CONFIG)\n\n\tif test \"x$host_win32\" = \"xyes\" && test \"x$cross_compiling\" = \"xno\" &&  test \"x$internal_llvm\" = \"xno\"; then\n\t\tEXTERNAL_LLVM_CONFIG_WIN32=$(cygpath -m $EXTERNAL_LLVM_CONFIG)\n\t\tAC_SUBST(EXTERNAL_LLVM_CONFIG_WIN32)\n\tfi\n\tif test \"x$enable_llvm_msvc_only\" != \"xyes\"; then\n\t\tAC_DEFINE(ENABLE_LLVM, 1, [Enable the LLVM back end])\n\telse\n\t\tAC_DEFINE(ENABLE_LLVM_MSVC_ONLY, 1, [Enable the LLVM back end])\n\tfi\nfi # ENABLE_LLVM\n\n# AC_DEFINE necessary for correct restore behavior on Linux\nAM_CONDITIONAL(INTERNAL_LLVM, [test \"x$internal_llvm\" != \"xno\" && test \"x$enable_llvm_msvc_only\" != \"xyes\"])\nif test \"x$internal_llvm\" != \"xno\"; then\n\tif test \"x$enable_llvm_msvc_only\" != \"xyes\"; then\n\t\tAC_DEFINE(INTERNAL_LLVM, 1, [LLVM used is being build during mono build])\n\telse\n\t\tAC_DEFINE(INTERNAL_LLVM_MSVC_ONLY, 1, [LLVM used is being build during mono build])\n\tfi\nfi\n\nAM_CONDITIONAL(INTERNAL_LLVM_ASSERTS, [test \"x$enable_llvm_asserts\" != \"xno\" && test \"x$enable_llvm_msvc_only\" != \"xyes\"])\nif test \"x$enable_llvm_asserts\" != \"xno\"; then\n\tif test \"x$enable_llvm_msvc_only\" != \"xyes\"; then\n\t\tAC_DEFINE(INTERNAL_LLVM_ASSERTS, 1, [Build LLVM with assertions])\n\telse\n\t\tAC_DEFINE(INTERNAL_LLVM_ASSERTS_MSVC_ONLY, 1, [Build LLVM with assertions])\n\tfi\nfi\n\nAM_CONDITIONAL(ENABLE_LLVM, [test x$enable_llvm = xyes && test x$enable_llvm_msvc_only != xyes])\n\nAM_CONDITIONAL(LOADED_LLVM, [test x$enable_loadedllvm = xyes && test x$enable_llvm_msvc_only != xyes])\nif test \"x$enable_loadedllvm\" = \"xyes\"; then\n\tif test \"x$enable_llvm_msvc_only\" != \"xyes\"; then\n\t\tAC_DEFINE(MONO_LLVM_LOADED, 1, [The LLVM back end is dynamically loaded])\n\tfi\nfi\n\nif test \"x$enable_llvm\" = \"xyes\"; then\n\tenable_llvm_runtime=yes\nfi\n\nAM_CONDITIONAL(ENABLE_LLVM_RUNTIME, [test x$enable_llvm_runtime = xyes && test x$enable_llvm_msvc_only != xyes])\nif test \"x$enable_llvm_runtime\" = \"xyes\"; then\n\tif test \"x$enable_llvm_msvc_only\" != \"xyes\"; then\n\t\tAC_DEFINE(ENABLE_LLVM_RUNTIME, 1, [Runtime support code for llvm enabled])\n\telse\n\t\tAC_DEFINE(ENABLE_LLVM_RUNTIME_MSVC_ONLY, 1, [Runtime support code for llvm enabled])\n\tfi\nfi\n\nTARGET=\"unknown\"\nACCESS_UNALIGNED=\"yes\"\n\nLIBC=\"libc.so.6\"\nINTL=\"libc.so.6\"\nSQLITE=\"libsqlite.so.0\"\nSQLITE3=\"libsqlite3.so.0\"\nODBC=\"libodbc.so.2\"\nX11=\"libX11.so\"\nGDKX11=\"libgdk-x11-2.0.so.0\"\nGTKX11=\"libgtk-x11-2.0.so.0\"\nXINERAMA=\"libXinerama.so.1\"\n\nsizeof_register=\"SIZEOF_VOID_P\"\n\njit_wanted=true\nboehm_supported=true\nBTLS_SUPPORTED=no\nBTLS_PLATFORM=\nINTERP_CFLAGS=\"\"\n\ncase \"$host\" in\n\twasm32*)\n\t\tTARGET=WASM\n\t\tarch_target=wasm\n\t\tBTLS_SUPPORTED=no\n\t\tACCESS_UNALIGNED=\"no\"\n\t\twith_tls=pthread\n\t\ttarget_wasm=yes\n\t\tif test \"x$mono_cv_clang\" = \"xyes\"; then\n\t\t   INTERP_CFLAGS=\"-mllvm -join-liveintervals=false\"\n\t\t   AC_SUBST(INTERP_CFLAGS)\n\t\tfi\n\t\t;;\n\tmips*)\n\t\tTARGET=MIPS;\n\t\tarch_target=mips;\n\t\twith_tls=pthread;\n\t\tACCESS_UNALIGNED=\"no\"\n\n\t\tAC_MSG_CHECKING(for mips n32)\n\t\tAC_TRY_COMPILE([],[\n\t\t#if _MIPS_SIM != _ABIN32\n\t\t#error Not mips n32\n\t\t#endif\n\t\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tsizeof_register=8\n\t\t],[\n\t\tAC_MSG_RESULT(no)\n\t\t])\n\t\t;;\n\ti*86-*-*)\n\t\tTARGET=X86;\n\t\tarch_target=x86;\n\t\tcase $host_os in\n\t\t  solaris*)\n\t\t\tLIBC=\"libc.so\"\n\t\t\tINTL=\"libintl.so\"\n\t\t\tif test \"x$ac_cv_sizeof_void_p\" = \"x8\"; then\n\t\t\t\tTARGET=AMD64\n\t\t\t\tarch_target=amd64\n\t\t\tfi\n\n\t\t\t# On solaris 10 x86, gcc prints a warning saying 'visibility attribute not supported on this configuration; ignored', but linking fails. A test case:\n\t\t\t# int astruct __attribute__ ((visibility (\"hidden\")));\n\t\t\t# void foo ()\n\t\t\t# {\n\t\t\t#\tvoid *p = &astruct;\n\t\t\t# }\n\t\t\t# gcc -fPIC --shared -o libfoo.so foo.c\n\t\t\t# yields:\n\t\t\t# foo.c:6: warning: visibility attribute not supported in this configuration; ignored\n\t\t\t# ld: fatal: relocation error: R_386_GOTOFF: file /var/tmp//ccxYR96k.o: symbol astruct: relocation must bind locally\n\t\t\thave_visibility_hidden=no\n\t\t\t;;\n\t\t  mingw*|cygwin*)\n\t\t\thave_visibility_hidden=no\n\t\t\tBTLS_SUPPORTED=no\n\t\t\tBTLS_PLATFORM=i386\n\t\t\t;;\n\t\t  haiku*)\n\t\t\tLIBC=libroot.so\n\t\t\t;;\n\t\t  linux*)\n\t\t\tAOT_SUPPORTED=\"yes\"\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=i386\n\t\t\tAC_CHECK_HEADER(stdalign.h,[],[BTLS_SUPPORTED=no])\n\t\t\t;;\n\t\t  darwin*)\n\t\t\tAOT_SUPPORTED=\"yes\"\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=i386\n\t\t\t;;\n\t\t  openbsd*|freebsd*|kfreebsd-gnu*)\n\t\t\tAOT_SUPPORTED=\"yes\"\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=i386\n\t\t        ;;\n\t\tesac\n\t\t;;\n\tx86_64-*-* | amd64-*-*)\n\t\tTARGET=AMD64;\n\t\tarch_target=amd64;\n\t\tif test \"x$ac_cv_sizeof_void_p\" = \"x4\"; then\n\t\t\tAC_DEFINE(MONO_ARCH_ILP32, 1, [64 bit mode with 4 byte longs and pointers])\n\t\t\tsizeof_register=8\n\t\tfi\n\t\tcase $host_os in\n\t\t  linux*)\n\t\t\tAOT_SUPPORTED=\"yes\"\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=x86_64\n\t\t\tAC_CHECK_HEADER(stdalign.h,[],[BTLS_SUPPORTED=no])\n\t\t\t;;\n\t\t  darwin*)\n\t\t\tAOT_SUPPORTED=\"yes\"\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=x86_64\n\t\t\tboehm_supported=false\n\t\t\t;;\n\t\t  openbsd*|freebsd*|kfreebsd-gnu*)\n\t\t\tAOT_SUPPORTED=\"yes\"\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=x86_64\n\t\t\t;;\n\t\t  mingw*|cygwin*)\n\t\t\tBTLS_SUPPORTED=no\n\t\t\tBTLS_PLATFORM=x86_64\n\t\t\t;;\n\t\tesac\n\t\t;;\n\tsparc*-*-*)\n\t\tif test \"x$ac_cv_sizeof_void_p\" = \"x8\"; then\n\t\t   TARGET=SPARC64\n\t\telse\n\t\t\tTARGET=SPARC\n\t\tfi\n\t\tarch_target=sparc;\n\t\tACCESS_UNALIGNED=\"no\"\n\t\tcase $host_os in\n\t\t  linux*) ;;\n\t\t  *)\n\t\t\tLIBC=\"libc.so\"\n\t\t\tINTL=\"libintl.so\"\n\t\tesac\n\t\tif test x\"$GCC\" = xyes; then\n\t\t\t# We don't support v8 cpus\n\t\t\tCFLAGS=\"$CFLAGS -Wno-cast-align -mcpu=v9\"\n\t\tfi\n\t\tif test x\"$AR\" = xfalse; then\n\t\t\tAC_MSG_ERROR([The required utility 'ar' is not found in your PATH. Usually it can be found in /usr/ccs/bin.])\n\t\tfi\n\t\t;;\n\t*-mingw*|*-*-cygwin*)\n\t\t# When this is enabled, it leads to very strange crashes at runtime (gcc-3.4.4)\n\t\thave_visibility_hidden=no\n\t\tINTL=\"intl\"\n\t\tcase \"$host\" in\n\t\t\tx86_64*mingw*)\n\t\t\t\t# Old Boehm fails to compile for x86_64-mingw.\n\t\t\t\t# It is trivial to fix, but just silently drop it.\n\t\t\t\tboehm_supported=false\n\t\t\t\t;;\n\t\tesac\n\t\t;;\n\tmacppc-*-openbsd* | powerpc*-*-linux* | powerpc-*-openbsd* | \\\n        powerpc-*-sysv* | powerpc-*-darwin* | powerpc-*-netbsd* | \\\n        powerpc-*-freebsd* | powerpc*-*-aix* | powerpc*-*-os400* )\n\t\tif test \"x$ac_cv_sizeof_void_p\" = \"x8\"; then\n\t\t\tTARGET=POWERPC64;\n\t\t\tCPPFLAGS=\"$CPPFLAGS -D__mono_ppc__ -D__mono_ppc64__\"\n\t\t\tif ! (echo $CC | grep -q -- 'clang'); then\n\t\t\t\tCFLAGS=\"$CFLAGS -mminimal-toc\"\n\t\t\tfi\n\t\telse\n\t\t\tTARGET=POWERPC;\n\t\t\tCPPFLAGS=\"$CPPFLAGS -D__mono_ppc__\"\n\t\tfi\n\t\tarch_target=ppc;\n\t\tcase $host_os in\n\t\t  aix*|os400*)\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=powerpc\n\t\t\t;;\n\t\t  linux*)\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=powerpc\n\t\t\t;;\n\t\tesac\n\t\t;;\n\tarmv7k-*-darwin*)\n\t\tTARGET=ARM;\n\t\tTARGET_SYS=WATCHOS\n\t\tarch_target=arm;\n\t\tarm_fpu=VFP_HARD\n\t\tACCESS_UNALIGNED=\"no\"\n\t\tCPPFLAGS=\"$CPPFLAGS -D__ARM_EABI__\"\n\t\t;;\n\n\tarm*-darwin*)\n\t\tTARGET=ARM;\n\t\tarch_target=arm;\n\t\tACCESS_UNALIGNED=\"no\"\n\t\tCPPFLAGS=\"$CPPFLAGS -D__ARM_EABI__\"\n\t\t;;\n\tarm*-linux*)\n\t\tTARGET=ARM;\n\t\tarch_target=arm;\n\t\tACCESS_UNALIGNED=\"no\"\n\t\tAOT_SUPPORTED=\"yes\"\n\t\tCPPFLAGS=\"$CPPFLAGS -D__ARM_EABI__\"\n\t\tBTLS_SUPPORTED=yes\n\t\tBTLS_PLATFORM=arm\n\t\tAC_CHECK_HEADER(stdalign.h,[],[BTLS_SUPPORTED=no])\n\t\tcase \"$target\" in\n\t\tarm*-linux*-gnueabi)\n\t\t\tBTLS_PLATFORM=armsoft\n\t\t\t;;\n\t\tesac\n\t\t;;\n\tarm*-netbsd*-eabi*)\n\t\tTARGET=ARM;\n\t\tarch_target=arm;\n\t\tACCESS_UNALIGNED=\"no\"\n\t\tCPPFLAGS=\"$CPPFLAGS -D__ARM_EABI__\"\n\t\t;;\n\taarch64-*darwin*ilp32)\n\t\tTARGET=ARM6432\n\t\tarch_target=arm64\n\t\tAC_DEFINE(MONO_ARCH_ILP32, 1, [64 bit mode with 4 byte longs and pointers])\n\t\tsizeof_register=8\n\t\t# assuming no other target other than watchOS is using aarch64*darwin triple\n\t\tTARGET_SYS=WATCHOS\n\t\t;;\n\taarch64-*)\n\t\t# https://lkml.org/lkml/2012/7/15/133\n\t\tTARGET=ARM64\n\t\tarch_target=arm64\n\t\tboehm_supported=false\n\t\tAOT_SUPPORTED=\"yes\"\n\t\tBTLS_SUPPORTED=yes\n\t\tBTLS_PLATFORM=aarch64\n\t\tAC_CHECK_HEADER(stdalign.h,[],[BTLS_SUPPORTED=no])\n\t\t;;\n\ts390x-*-linux*)\n\t\tTARGET=S390X;\n\t\tarch_target=s390x;\n\t\tACCESS_UNALIGNED=\"yes\"\n\t\tBTLS_SUPPORTED=yes\n\t\tBTLS_PLATFORM=s390x\n\t\tCFLAGS=\"$CFLAGS -mbackchain -D__USE_STRING_INLINES\"\n\t\t;;\n\triscv32-*)\n\t\tTARGET=RISCV32\n\t\tACCESS_UNALIGNED=no\n\t\tAOT_SUPPORTED=no\n\t\tBTLS_SUPPORTED=yes\n\t\tBTLS_PLATFORM=riscv32\n\t\tarch_target=riscv32\n\t\tboehm_supported=false\n\t\t;;\n\triscv64*)\n\t\tTARGET=RISCV64\n\t\tACCESS_UNALIGNED=no\n\t\tAOT_SUPPORTED=no\n\t\tBTLS_SUPPORTED=yes\n\t\tBTLS_PLATFORM=riscv64\n\t\tarch_target=riscv64\n\t\tboehm_supported=false\n\t\t;;\nesac\n\nHOST=$TARGET\n\nif test \"x$host\" != \"x$target\"; then\n   AC_DEFINE(MONO_CROSS_COMPILE,1,[The runtime is compiled for cross-compiling mode])\n   enable_mcs_build=no\n   enable_support_build=no\n   BTLS_SUPPORTED=no\n   # Can't use tls, since it depends on the runtime detection of tls offsets\n   # in mono-compiler.h\n   with_tls=pthread\n   target_mach=no\n   case \"$target\" in\n   wasm32*)\n\t\tTARGET=WASM\n\t\tarch_target=wasm\n\t\tAC_DEFINE(TARGET_WASM, 1, [Target wasm])\n\t\t;;\n   arm*-darwin*)\n\t\tTARGET=ARM;\n\t\tCPPFLAGS=\"$CPPFLAGS -D__ARM_EABI__\"\n\t\tcase \"$target\" in\n\t\tarmv7k-*)\n\t\t\tarm_fpu=VFP_HARD\n\t\t\tAC_DEFINE(TARGET_WATCHOS, 1, [...])\n\t\t\t;;\n\t\tesac\t\t\n\t\t;;\n   powerpc64-ps3-linux-gnu)\n\t\tTARGET=POWERPC64\n\t\tarch_target=powerpc64\n\t\tAC_DEFINE(TARGET_PS3, 1, [...])\n\t\t# It would be better to just use TARGET_POWERPC64, but lots of code already\n\t\t# uses this define\n\t\tAC_DEFINE(__mono_ppc64__, 1, [...])\n\t\tAC_DEFINE(MONO_ARCH_ILP32, 1, [64 bit mode with 4 byte longs and pointers])\n\t\tsizeof_register=8\n\t\ttarget_byte_order=G_BIG_ENDIAN\n\t\t;;\n   powerpc64-xbox360-linux-gnu)\n\t\tTARGET=POWERPC64\n\t\tarch_target=powerpc64\n\t\tAC_DEFINE(TARGET_XBOX360, 1, [...])\n\t\t# It would be better to just use TARGET_POWERPC64, but lots of code already\n\t\t# uses this define\n\t\tsizeof_register=8\n\t\ttarget_byte_order=G_BIG_ENDIAN\n\t\t;;\n   arm*-linux-*)\n\t\tTARGET=ARM;\n\t\tCPPFLAGS=\"$CPPFLAGS -D__ARM_EABI__\"\n\t\t;;\n   arm*-netbsd*-eabi*)\n\t\tTARGET=ARM;\n\t\tCPPFLAGS=\"$CPPFLAGS -D__ARM_EABI__\"\n\t\t;;\n   i686*-linux-*)\n\t\tTARGET=X86;\n\t\t;;\n   i*86-apple-*)\n\t\tTARGET=X86;\n\t\t;;\n   x86_64*-linux-*)\n\t\tTARGET=AMD64;\n\t\t;;\n   x86_64-ps4-freebsd)\n\t\tTARGET=AMD64;\n\t\tAC_DEFINE(TARGET_PS4, 1, [...])\n\t\tAC_DEFINE(DISABLE_HW_TRAPS, 1, [...])\n\t\tCPPFLAGS=\"$CPPFLAGS\"\n\t\ttarget_win32=no\n\t\t;;\n\taarch64*darwin*_ilp32)\n\t\tTARGET=ARM6432;\n\t\tAC_DEFINE(MONO_ARCH_ILP32, 1, [64 bit mode with 4 byte longs and pointers])\n\t\tsizeof_register=8\n\t\tAC_DEFINE(TARGET_WATCHOS, 1, [...])\n\t\t;;\n\taarch64-*)\n\t\tTARGET=ARM64\n\t\t;;\n\triscv32*)\n\t\tTARGET=RISCV32\n\t\tAC_DEFINE([TARGET_RISCV], [1], [Target is RISC-V])\n\t\tAC_DEFINE([TARGET_RISCV32], [1], [Target is 32-bit RISC-V])\n\t\tarch_target=riscv32\n\t\ttarget_mach=no\n\t\twith_tls=pthread\n\t\t;;\n\triscv64*)\n\t\tTARGET=RISCV64\n\t\tAC_DEFINE([TARGET_RISCV], [1], [Target is RISC-V])\n\t\tAC_DEFINE([TARGET_RISCV64], [1], [Target is 64-bit RISC-V])\n\t\tarch_target=riscv64\n\t\ttarget_mach=no\n\t\twith_tls=pthread\n\t\t;;\n\tx86_64-google-fuchsia)\n\t\tTARGET=AMD64\n\t\ttarget_win32=nop\n\t\tAC_DEFINE(HOST_FUCHSIA,1,[Targeting the Fuchsia platform])\n\t\t;;\n\t*)\n\t\tAC_MSG_ERROR([Cross compiling is not supported for target $target])\n\tesac\n\n\tcase \"$target\" in\n\t*-darwin*)\n\t\ttarget_mach=yes\n\t\t;;\n\t*-linux-android*)\n\t\tAC_DEFINE(TARGET_ANDROID, 1, [...])\n\t\t;;\n\tesac\nfi\n\ncase \"$TARGET\" in\nWASM)\n\tAC_DEFINE(TARGET_WASM, 1, [...])\n\tarch_target=wasm\n\t;;\nX86)\n\tAC_DEFINE(TARGET_X86, 1, [...])\n\tarch_target=x86\n\t;;\nAMD64)\n\tAC_DEFINE(TARGET_AMD64, 1, [...])\n\tarch_target=amd64\n\t;;\nARM)\n\tAC_DEFINE(TARGET_ARM, 1, [...])\n\tarch_target=arm\n\tACCESS_UNALIGNED=\"no\"\n\t;;\nARM64|ARM6432)\n\tAC_DEFINE(TARGET_ARM64, 1, [...])\n\tarch_target=arm64\n\t;;\nPOWERPC)\n\tAC_DEFINE(TARGET_POWERPC, 1, [...])\n\t;;\nPOWERPC64)\n\tAC_DEFINE(TARGET_POWERPC, 1, [...])\n\tAC_DEFINE(TARGET_POWERPC64, 1, [...])\n\t;;\nS390X)\n\tAC_DEFINE(TARGET_S390X, 1, [...])\n\t;;\nMIPS)\n\tAC_DEFINE(TARGET_MIPS, 1, [...])\n\t;;\nSPARC)\n\tAC_DEFINE(TARGET_SPARC, 1, [...])\n\t;;\nSPARC64)\n\tAC_DEFINE(TARGET_SPARC64, 1, [...])\n\t;;\nRISCV32)\n\tAC_DEFINE([TARGET_RISCV], [1], [Target is RISC-V])\n\tAC_DEFINE([TARGET_RISCV32], [1], [Target is 32-bit RISC-V])\n\t;;\nRISCV64)\n\tAC_DEFINE([TARGET_RISCV], [1], [Target is RISC-V])\n\tAC_DEFINE([TARGET_RISCV64], [1], [Target is 64-bit RISC-V])\n\t;;\nesac\n\ncase \"$TARGET\" in\n*32* | ARM | X86 | POWERPC | MIPS | SPARC | WASM | ARM6432)\n    target_sizeof_void_p=4\n    ;;\n*64* | S390X)\n    target_sizeof_void_p=8\n    ;;\n*)\n    AC_MSG_ERROR([unknown target])\n    ;;\nesac\n\ncase \"$HOST\" in\nWASM)\n\tAC_DEFINE(HOST_WASM, 1, [...])\n\t;;\nX86)\n\tAC_DEFINE(HOST_X86, 1, [...])\n\t;;\nAMD64)\n\tAC_DEFINE(HOST_AMD64, 1, [...])\n\t;;\nARM)\n\tAC_DEFINE(HOST_ARM, 1, [...])\n\t;;\nARM64)\n\tAC_DEFINE(HOST_ARM64, 1, [...])\n\t;;\nPOWERPC)\n\tAC_DEFINE(HOST_POWERPC, 1, [...])\n\t;;\nPOWERPC64)\n\tAC_DEFINE(HOST_POWERPC, 1, [...])\n\tAC_DEFINE(HOST_POWERPC64, 1, [...])\n\t;;\nS390X)\n\tAC_DEFINE(HOST_S390X, 1, [...])\n\t;;\nMIPS)\n\tAC_DEFINE(HOST_MIPS, 1, [...])\n\t;;\nSPARC)\n\tAC_DEFINE(HOST_SPARC, 1, [...])\n\t;;\nSPARC64)\n\tAC_DEFINE(HOST_SPARC64, 1, [...])\n\t;;\nRISCV32)\n\tAC_DEFINE([HOST_RISCV], [1], [Host is RISC-V])\n\tAC_DEFINE([HOST_RISCV32], [1], [Host is 32-bit RISC-V])\n\t;;\nRISCV64)\n\tAC_DEFINE([HOST_RISCV], [1], [Host is RISC-V])\n\tAC_DEFINE([HOST_RISCV64], [1], [Host is 64-bit RISC-V])\n\t;;\nesac\n\nMONO_ARCH_GSHAREDVT_SUPPORTED=0\ncase \"$HOST\" in\nX86 | AMD64 | ARM | ARM64)\n\tMONO_ARCH_GSHAREDVT_SUPPORTED=1 # keep in sync with mini-{x86,amd64,arm,arm64}.h\n\t;;\nesac\n\nAM_CONDITIONAL(MONO_ARCH_GSHAREDVT_SUPPORTED, test $MONO_ARCH_GSHAREDVT_SUPPORTED = 1)\nAM_CONDITIONAL(TARGET_WASM, test $arch_target = wasm)\n\ndnl *************\ndnl *** VTUNE ***\ndnl *************\n\nAC_ARG_ENABLE(vtune,[  --enable-vtune\tEnable the VTUNE back-end], enable_vtune=$enableval, enable_vtune=no)\nAC_ARG_WITH(vtune, [  --with-vtune=<vtune prefix>\tEnable jit vtune profiling], enable_vtune=yes,)\n\nAM_CONDITIONAL(HAVE_VTUNE, test x$enable_vtune = xyes)\n\nif test \"x$enable_vtune\" = \"xyes\"; then\n\tif test \"x$with_vtune\" = \"x\"; then\n\t\tVTUNE_PATH=/opt/intel/vtune_amplifier_xe\n\telse\n\t\tVTUNE_PATH=$with_vtune\n\tfi\n\tVTUNE_INCLUDE=$VTUNE_PATH/include\n\tcase \"$TARGET\" in\n\tX86)\n\t\tVTUNE_LIB=$VTUNE_PATH/lib32\n\t\t;;\n\tAMD64)\n\t\tVTUNE_LIB=$VTUNE_PATH/lib64\n\t\t;;\n\t*)\n\t\tAC_MSG_ERROR([Unsupported target $TARGET for VTUNE.])\n\t\t;;\n\tesac\n\tif test ! -f $VTUNE_INCLUDE/jitprofiling.h; then\n\t\tAC_MSG_ERROR([VTUNE $VTUNE_INCLUDE/jitprofiling.h not found.])\n\tfi\n\tif test ! -f $VTUNE_LIB/libjitprofiling.a; then\n\t\tAC_MSG_ERROR([VTUNE $VTUNE_LIB/libjitprofiling.a not found.])\n\tfi\n\n\tVTUNE_CFLAGS=-I$VTUNE_INCLUDE\n\tVTUNE_LIBS=\"-L/$VTUNE_LIB/ -ljitprofiling\"\n\n\tAC_SUBST(VTUNE_LIBS)\n\tAC_SUBST(VTUNE_CFLAGS)\nfi\ndnl Use GCC atomic ops if they work on the target.\nif test x$GCC = \"xyes\"; then\n\tcase $TARGET in\n\tX86 | AMD64 | ARM | ARM64 | ARM6432 | POWERPC | POWERPC64 | MIPS | S390X | SPARC | SPARC64 | RISCV32 | RISCV64)\n\t\tAC_DEFINE(USE_GCC_ATOMIC_OPS, 1, [...])\n\t\t;;\n\tesac\nfi\n\nif test \"x$target_mach\" = \"xyes\"; then\n\n   if test \"x$TARGET_SYS\" = \"xWATCHOS\"; then\n\t  AC_DEFINE(TARGET_WATCHOS,1,[The JIT/AOT targets WatchOS])\n\t  CPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC -DTARGET_WATCHOS\"\n\t  CFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -DTARGET_WATCHOS\"\n\t  BTLS_SUPPORTED=no\n   elif test \"x$TARGET\" = \"xARM\" -o \"x$TARGET\" = \"xARM64\" -o \"x$TARGET\" = \"xARM6432\"; then\n   \t  AC_DEFINE(TARGET_IOS,1,[The JIT/AOT targets iOS])\n\t  CPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC -DTARGET_IOS\"\n\t  CFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -DTARGET_IOS\"\n\t  BTLS_SUPPORTED=no\n\t  target_ios=yes\n   else\n       AC_TRY_COMPILE([#include \"TargetConditionals.h\"],[\n       #if TARGET_IPHONE_SIMULATOR == 1 || TARGET_OS_IPHONE == 1\n       #error fail this for ios\n       #endif\n       ], [\n\t   \t  AC_DEFINE(TARGET_OSX,1,[The JIT/AOT targets OSX])\n          CPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC -DTARGET_OSX\"\n          CFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -DTARGET_OSX\"\n          target_osx=yes\n       ], [\n          AC_DEFINE(TARGET_IOS,1,[The JIT/AOT targets iOS])\n          CPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC -DTARGET_IOS\"\n          CFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -DTARGET_IOS\"\n          BTLS_SUPPORTED=no\n\t\t  target_ios=yes\n       ])\n\tfi\n   AC_DEFINE(TARGET_MACH,1,[The JIT/AOT targets Apple platforms])\nfi\n\nAM_CONDITIONAL(TARGET_OSX, test x$target_osx = xyes)\n\nAC_SUBST(SIZEOF_VOID_P,[$ac_cv_sizeof_void_p])\n\nif test \"x$target_byte_order\" = \"xG_BIG_ENDIAN\"; then\n   AC_DEFINE(TARGET_BYTE_ORDER,G_BIG_ENDIAN,[byte order of target])\nelif test \"x$target_byte_order\" = \"xG_LITTLE_ENDIAN\"; then\n   AC_DEFINE(TARGET_BYTE_ORDER,G_LITTLE_ENDIAN,[byte order of target])\nelse\n   AC_DEFINE(TARGET_BYTE_ORDER,G_BYTE_ORDER,[byte order of target])\nfi\n\nAC_DEFINE_UNQUOTED(TARGET_SIZEOF_VOID_P,${target_sizeof_void_p},[wordsize of target])\n\nif test \"x$sizeof_register\" = \"x4\"; then\n  AC_DEFINE(SIZEOF_REGISTER,4,[size of target machine integer registers])\nelif test \"x$sizeof_register\" = \"x8\"; then\n  AC_DEFINE(SIZEOF_REGISTER,8,[size of target machine integer registers])\nelse\n  AC_DEFINE_UNQUOTED(SIZEOF_REGISTER,${target_sizeof_void_p},[size of target machine integer registers])\nfi\n\n# zlib/configure detects visibility support similarly and defines HAVE_HIDDEN\n# on the compiler command line (not config.h).\nif test \"x$have_visibility_hidden\" = \"xyes\"; then\n   AC_DEFINE(HAVE_VISIBILITY_HIDDEN, 1, [Support for the visibility (\"hidden\") attribute])\n   ZLIB_CFLAGS=\"$ZLIB_CFLAGS -DHAVE_HIDDEN\"\nfi\n\nif test \"x$have_deprecated\" = \"xyes\"; then\n   AC_DEFINE(HAVE_DEPRECATED, 1, [Support for the deprecated attribute])\nfi\n\ndnl \ndnl Simple Generational checks (sgen)\ndnl\nSGEN_DEFINES=\nAC_ARG_WITH(sgen,                    [  --with-sgen=yes,no             Extra Generational GC, default=yes],[buildsgen=$with_sgen],[buildsgen=yes])\nAC_ARG_WITH(sgen-default-concurrent, [  --with-sgen-default-concurrent=yes,no             Use Concurrent GC, default=no],[],[with_sgen_default_concurrent=no])\nif test x$buildsgen = xyes; then\n   AC_DEFINE(HAVE_MOVING_COLLECTOR, 1, [Moving collector])\n   SGEN_DEFINES=\"-DHAVE_SGEN_GC\"\n\n\tconc_gc_msg=\"\"\n   if test x$with_sgen_default_concurrent != xno; then\n       AC_DEFINE(HAVE_CONC_GC_AS_DEFAULT, 1, [Defaults to concurrent GC])\n\t   conc_gc_msg=\" (concurrent by default)\"\n   fi\n\n   if test \"x$gc_msg\" = \"x\"; then\n      gc_msg=\"sgen$conc_gc_msg\"\n   else\n      gc_msg=\"sgen$conc_gc_msg and $gc_msg\"\n   fi\nfi\nAC_SUBST(SGEN_DEFINES)\nAM_CONDITIONAL(SUPPORT_SGEN, test x$buildsgen = xyes)\n\njit_status=\"Building and using the JIT\"\n\nlibsuffix=\".so\"\n\ncase \"$host\" in\n     *-*-aix*)\n\tdnl on AIX/PASE, shared libraries can be and usually are inside archives\n\tdnl so, we specify them by libfoo.a(libfoo.so.0) for libtool's conventions,\n\tdnl or libfoo.a(shr[_64].o) for the AIX system convention,\n\tdnl or lib.so[.0](shr[_64].o) for libtool's hybrid convention\n\tdnl we may hardcode 64-bit names at times, but we don't do 32-bit AIX\n\tLIBC=\"libc.a(shr_64.o)\"\n\t# Thanks, I hate it! This is crumbly, especially the one-liner.\n\tAC_MSG_CHECKING([how to dlopen libintl])\n\tAC_LINK_IFELSE([AC_LANG_SOURCE([\n\t\t/* XXX: Check for libintl header/gettext func better? */\n\t\t#include <libintl.h>\n\n\t\tint main (void) {\n\t\t\tgettext(\"Dummy for autoconf\");\n\t\t\treturn 1;\n\t\t}\n\t])],\n\t[\n\tINTL=\"$(dump -X64 -Hp conftest$EXEEXT | grep libintl | cut -c 38- | tr -s \" \" | awk '{print $1\"(\"$2\")\"}')\"\n\tAC_MSG_RESULT([yes, $INTL])\n\t],\n\t[\n\tINTL=\"libintl.a(libintl.so.8)\"\n\tAC_MSG_RESULT([no, falling back to $INTL])\n\t])\n\tSQLITE3=\"libsqlite3.a(libsqlite3.so.0)\"\n\t# it's very tempting to set a libsuffix, but it depends on the soname value\n\t;;\n     *-*-os400*)\n\tdnl However, IBM's packages for i try to be more \"normal\" than the AIX world, naming wise.\n\tdnl The library archives has \"normal\" .so names, but they're members with predictable \"shr\" names for fat libraries.\n\tLIBC=\"libc.a(shr_64.o)\"\n\tINTL=\"libintl.so(shr_64.o)\"\n\tSQLITE3=\"libsqlite3.so(shr_64.o)\"\n\t# likewise, it's safer to assume \".so(shr_64.o)\" due to official IBM packages being built this way, but as with AIX, others may not be guaranteed\n\t# it may be worth revisiting this in the future\n\t;;\n     *-*-darwin*)\n\tlibsuffix=\".dylib\"\n\tLIBC=\"libc.dylib\"\n\tINTL=\"libintl.dylib\"\n\tSQLITE=\"libsqlite.0.dylib\"\n\tSQLITE3=\"libsqlite3.0.dylib\"\n\tX11=\"libX11.dylib\"\n\tGDKX11=\"libgdk-x11-2.0.dylib\"\n\tGTKX11=\"libgtk-x11-2.0.dylib\"\n\t;;\n     *-*-*netbsd*)\n\tLIBC=\"libc.so\"\n\tINTL=\"libintl.so\"\n\tSQLITE=\"libsqlite.so\"\n\tSQLITE3=\"libsqlite3.so\"\n\t;;\n     *-*-kfreebsd*-gnu)\n\tLIBC=\"libc.so.0.1\"\n\tINTL=\"libc.so.0.1\"\n\tX11=\"libX11.so.6\"\n\t;;\n    *-*-*freebsd*)\n    \tLIBC=\"libc.so.7\"\n\tINTL=\"libintl.so\"\n\tSQLITE=\"libsqlite.so\"\n\tSQLITE3=\"libsqlite3.so\"\n\t;;\n    *-*-*openbsd*)\n    \tLIBC=\"libc.so\"\n\tINTL=\"libintl.so\"\n        SQLITE=\"libsqlite.so\"\n        SQLITE3=\"libsqlite3.so\"\n\t;;\n    *-*-*linux*)\n\tAC_PATH_X\n\tdlsearch_path=`(libtool --config ; echo eval echo \\\\$sys_lib_dlsearch_path_spec) | sh`\n\tAC_MSG_CHECKING(for the soname of libX11.so)\n\tfor i in $x_libraries $dlsearch_path; do\n\t\tfor r in 4 5 6; do\n\t\t\tif test -f $i/libX11.so.$r; then\n\t\t\t\tX11=libX11.so.$r\n\t\t\t\tAC_MSG_RESULT($X11)\n\t\t\tfi\n\t\tdone\n\tdone\n\t\n\tif test \"x$X11\" = \"xlibX11.so\"; then\n\t\tAC_MSG_WARN([Could not find libX11.so. Do you have X.org or XFree86 installed? Assuming libX11.so.6...]);\n\t\tX11=libX11.so.6\n\tfi\n\t;;\nesac\n\nAC_SUBST(libsuffix)\n\n######################################\n# EGLIB CHECKS\n######################################\n\nGNUC_PRETTY=\nGNUC_UNUSED=\nBREAKPOINT=\"G_STMT_START { raise (SIGTRAP); } G_STMT_END\"\nif test x$GCC = xyes; then\n   GNUC_UNUSED='__attribute__((__unused__))'\n   GNUC_NORETURN='__attribute__((__noreturn__))'\n   case $host_cpu in\n     i*86|x86_64) BREAKPOINT=\"G_STMT_START { __asm__ (\\\"int \\$03\\\"); } G_STMT_END\" ;;\n   esac\nfi\nAC_SUBST(GNUC_PRETTY)\nAC_SUBST(GNUC_UNUSED)\nAC_SUBST(GNUC_NORETURN)\nAC_SUBST(BREAKPOINT)\n\nAC_C_BIGENDIAN([ORDER=G_BIG_ENDIAN],[ORDER=G_LITTLE_ENDIAN])\n\ncase $host in\n*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows*)\n    PATHSEP='\\\\'\n    SEARCHSEP=';'\n    OS=\"WIN32\"\n    PIDTYPE='void *'\n    ;;\n*)\n    PATHSEP='/'\n    SEARCHSEP=':'\n    OS=\"UNIX\"\n    PIDTYPE='int'\n    ;;\nesac\n\ncase $host in\n\t*-*-solaris*)\n\tCFLAGS=\"$CFLAGS -D_POSIX_PTHREAD_SEMANTICS\"\n\t;;\nesac\n\ncase $target in\narm*-darwin*|aarch64*-*|riscv*)\n    CFLAGS=\"$CFLAGS -U_FORTIFY_SOURCE\"\n    ;;\ni*86-*-darwin*)\n    ORDER=G_LITTLE_ENDIAN\n    ;;\n*-*-haiku*)\n    LDFLAGS=\"$LDFLAGS -ltextencoding\"\n    ;;\n*-*-openbsd*)\n    CFLAGS=\"$CFLAGS -pthread\"\n    LDFLAGS=\"$LDFLAGS -pthread\"\n    ;;\nesac\n\nAC_SUBST(ORDER)\nAC_SUBST(PATHSEP)\nAC_SUBST(SEARCHSEP)\nAC_SUBST(OS)\nAC_SUBST(PIDTYPE)\n\n# Defined for all targets/platforms using classic Windows API support.\nAC_DEFINE(HAVE_CLASSIC_WINAPI_SUPPORT, 1, [Use classic Windows API support])\nAC_DEFINE(HAVE_UWP_WINAPI_SUPPORT, 0, [Don't use UWP Windows API support])\n\nAC_CHECK_FUNCS(strlcpy stpcpy strtok_r rewinddir vasprintf)\nAC_CHECK_FUNCS(getrlimit)\nAC_CHECK_FUNCS(fork execv execve)\nAC_CHECK_FUNCS(waitpid)\n\nAC_ARG_WITH([overridable-allocators], [  --with-overridable-allocators\tallow g_*alloc/g_free to call custom allocators set via g_mem_set_vtable])\n\nif test x$with_overridable_allocators = xyes; then\n\tAC_DEFINE(ENABLE_OVERRIDABLE_ALLOCATORS,1,[Overridable allocator support enabled])\n  AC_MSG_NOTICE([Overridable allocator support enabled])\nelse\n  AC_MSG_NOTICE([Overridable allocator support disabled])\nfi\n\n#\n# Mono currently supports 10.6, but strndup is not available prior to 10.7; avoiding\n# the detection of strndup on OS X so Mono built on 10.7+ still runs on 10.6. This can be\n# removed once support for 10.6 is dropped.\n#\n# iOS detection of strndup and getpwuid_r is faulty for some reason so let's simply avoid it\n#\nif test x$target_osx = xyes; then\nAC_CHECK_FUNCS(getpwuid_r)\nelif test x$target_ios = xno; then\nAC_CHECK_FUNCS(strndup getpwuid_r)\nfi\n\nAC_SEARCH_LIBS(sqrtf, m)\n\n# nanosleep may not be part of libc, also search it in other libraries\nAC_SEARCH_LIBS(nanosleep, rt)\n\nAC_SEARCH_LIBS(dlopen, dl)\n\n# AIX/OS400 -bsymbolic\n# Apple -bind_at_load\n# The rest GNU.\n#\nAX_APPEND_LINK_FLAGS([-Wl,--export-dynamic -Wl,-Bsymbolic -bsymbolic -Wl,-z,now -Wl,-bind_at_load])\n\nAC_CHECK_HEADERS(getopt.h sys/select.h sys/time.h sys/wait.h pwd.h iconv.h sys/types.h sys/resource.h)\ndnl giconv.c will check on HAVE_ICONV_H but we need this for link time\nAC_CHECK_LIB(iconv, iconv_open)\nAC_CHECK_HEADER(alloca.h, [HAVE_ALLOCA_H=1], [HAVE_ALLOCA_H=0])\nAC_SUBST(HAVE_ALLOCA_H)\n\n# Get the exact type of size_t, not just its size.\n# This is so we can find an exact printf format among u, lu, llu, I64u.\n# To avoid warnings about slight mismatches.\n# C99 runtime \"zu\" dependency is being avoided here.\n#\n# We have to compile as C++ because C is too lenient\n# and lets the wrong thing compile, with warnings.\n#\n# Note: \"zu\" or ifdef <something> have the advantage\n# of producing installable \"biarch\" headers. i.e. one Mac header\n# for Mac/x86 and Mac/amd64.\n\nAC_LANG_PUSH(C++)\n\n# Check long before int because it is the overwhelming Unix answer,\n# across 32bit and 64bit systems -- fewer compiler invocations in autoconf.\n#\n# long ahead of int also tends to produce biarch-compatible headers except Windows.\n#\nAC_MSG_CHECKING(if size_t is unsigned long)\nAC_COMPILE_IFELSE([AC_LANG_SOURCE([\n\t#include <stddef.h>\n\tunsigned long *a = (size_t*)0;\n])], [\n\tAC_MSG_RESULT(yes)\n\tAC_SUBST(GSIZE_FORMAT, '\"lu\"')\n], [\n\tAC_MSG_RESULT(no)\n\tAC_MSG_CHECKING(if size_t is unsigned int)\n\tAC_COMPILE_IFELSE([AC_LANG_SOURCE([\n\t\t#include <stddef.h>\n\t\tunsigned *a = (size_t*)0;\n\t])], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_SUBST(GSIZE_FORMAT, '\"u\"')\n\t], [\n# At this point the majority of systems have their answer,\n# and we descend into non-standard or new-standard territory.\n#\n# Check __int64 first because I64 on some systems predates ll, enabling\n# new compiler/old runtime interop, and the types always have the same size.\n\t\tAC_MSG_RESULT(no)\n\t\tAC_MSG_CHECKING(if size_t is unsigned __int64)\n\t\tAC_COMPILE_IFELSE([AC_LANG_SOURCE([\n\t\t\t#include <stddef.h>\n\t\t\tunsigned __int64 *a = (size_t*)0;\n\t\t])], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_SUBST(GSIZE_FORMAT, '\"I64u\"')\n\t\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t\t\tAC_MSG_CHECKING(if size_t is unsigned long long)\n\t\t\tAC_COMPILE_IFELSE([AC_LANG_SOURCE([\n\t\t\t\t#include <stddef.h>\n\t\t\t\tunsigned long long *a = (size_t*)0;\n\t\t\t])], [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\tAC_SUBST(GSIZE_FORMAT, '\"llu\"')\n\t\t\t], [\n\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t\tAC_MSG_ERROR(Unable to determine size_t among unsigned long, int, __int64, long long)\n\t\t\t] )\n\t\t] )\n\t] )\n] )\n\nAC_LANG_POP\n\n# If size_t/ptrdiff_t is correct, use it. Otherwise C99 [u]intptr_t.\n# This provides for an exact match with functions that\n# take size_t like malloc and pthread_attr_getstacksize, avoiding warnings.\n# uintptr_t is not necessarily the same.\n#\n# ptrdiff_t is preferred over ssize_t as it is C89 vs. new Posix.\n# ssize_t looks nicer but ptrdiff_t is wrapped up as gssize anyway.\n\nif test $ac_cv_sizeof_void_p = $ac_cv_sizeof_size_t; then\n   GSIZE=\"size_t\"\n   GSSIZE=\"ptrdiff_t\"\nelse\n   GSIZE=\"uintptr_t\"\n   GSSIZE=\"intptr_t\"\nfi\n\nAC_SUBST(GSIZE)\nAC_SUBST(GSSIZE)\nAC_SUBST(GSIZE_FORMAT)\n\n#\n# END OF EGLIB CHECKS\n#\n\nAC_ARG_WITH([libgdiplus],\n\t[  --with-libgdiplus=installed|sibling|<path>\tOverride the libgdiplus used for System.Drawing tests (defaults to installed)],\n\t[], [with_libgdiplus=installed])\n\n# default install location\nlibgdiplus_install_loc=libgdiplus${libsuffix}\ncase \"$host\" in\n    *-*-*linux*)\n    libgdiplus_install_loc=libgdiplus${libsuffix}.0\n    ;;\nesac\n\ncase $with_libgdiplus in\n    no)\n    libgdiplus_loc=\n    ;;\n\n    installed)\n    libgdiplus_loc=\n    if test x$cross_compiling = xno; then\n        if test x$host_darwin = xyes; then\n\t    a=/Library/Frameworks/Mono.framework/Versions/Current/lib/$libgdiplus_install_loc\n\t    if test -x $a; then\n\t      libgdiplus_install_loc=$a\n\t      libgdiplus_loc=$a\n\t    fi\n\tfi\n    fi\n    ;;\n\n    yes|sibling)\n    libgdiplus_loc=`cd ../libgdiplus && pwd`/src/libgdiplus.la\n    ;;\n\n    /*) # absolute path, assume it is an install location\n    libgdiplus_loc=$with_libgdiplus\n    libgdiplus_install_loc=$with_libgdiplus\n    ;;\n\n    *)\n    libgdiplus_loc=`pwd`/$with_libgdiplus\n    ;;\nesac\nAC_SUBST(libgdiplus_loc)\nAC_SUBST(libgdiplus_install_loc)\n\nAC_ARG_ENABLE(icall-symbol-map,[  --enable-icall-symbol-map Generate tables which map icall functions to their C symbols], icall_symbol_map=$enableval, icall_symbol_map=no)\nif test \"x$icall_symbol_map\" = \"xyes\"; then\n   AC_DEFINE(ENABLE_ICALL_SYMBOL_MAP, 1, [Icall symbol map enabled])\nfi\n\nAC_ARG_ENABLE(icall-export,[  --enable-icall-export Export icall functions], icall_export=$enableval, icall_export=no)\nif test \"x$icall_export\" = \"xyes\"; then\n   AC_DEFINE(ENABLE_ICALL_EXPORT, 1, [Icall export enabled])\nfi\n\nAC_ARG_ENABLE(icall-tables,[  --disable-icall-tables Disable the runtime lookup of icalls], icall_tables=$enableval, icall_tables=yes)\nif test \"x$icall_tables\" = \"xno\"; then\n   AC_DEFINE(DISABLE_ICALL_TABLES, 1, [Icall tables disabled])\nfi\n\nAM_CONDITIONAL(DISABLE_ICALL_TABLES, test x$icall_tables = xno)\n\nif test \"x$with_tls\" = \"x__thread\"; then\n\tAC_DEFINE(MONO_KEYWORD_THREAD, __thread, [Have __thread keyword])\n\t# Pass the information to libgc\n\tCPPFLAGS=\"$CPPFLAGS -DUSE_COMPILER_TLS\"\n\tAC_MSG_CHECKING(if the tls_model attribute is supported)\n\tAC_TRY_COMPILE([static __thread int foo __attribute__((tls_model(\"initial-exec\")));], [\n\t\t], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_TLS_MODEL_ATTR, 1, [tls_model available])\n\t\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t])\nfi\n\nif test ${TARGET} = ARM; then\n\tdnl ******************************************\n\tdnl *** Check to see what FPU is available ***\n\tdnl ******************************************\n\tAC_MSG_CHECKING(which FPU to use)\n\n\t#\n\t# This is a bit tricky:\n\t#\n\t# if (__ARM_PCS_VFP) {\n\t# \t/* mfloat-abi=hard == VFP with hard ABI */\n\t# } elif (!__SOFTFP__) {\n\t# \t/* mfloat-abi=softfp == VFP with soft ABI */\n\t# } else {\n\t# \t/* mfloat-abi=soft == no VFP */\n\t# }\n\t#\n\t# The exception is iOS (w/ GCC) where none of the above\n\t# are defined (but iOS always uses the 'softfp' ABI).\n\t#\n\t# No support for FPA.\n\t#\n\n\tfpu=NONE\n\n\t# iOS GCC always uses the 'softfp' ABI.\n\tif test x\"$GCC\" = xyes && test x$host_darwin = xyes; then\n\t\tfpu=VFP\n\tfi\n\n\t# Are we using the 'hard' ABI?\n\tif test x$fpu = xNONE; then\n\t\tAC_TRY_COMPILE([], [\n\t\t\t#ifndef __ARM_PCS_VFP\n\t\t\t#error \"Float ABI is not 'hard'\"\n\t\t\t#endif\n\t\t], [\n\t\t\tfpu=VFP_HARD\n\t\t], [\n\t\t\tfpu=NONE\n\t\t])\n\tfi\n\n\t# No 'hard' ABI. 'soft' or 'softfp'?\n\tif test x$fpu = xNONE; then\n\t\tAC_TRY_COMPILE([], [\n\t\t\t#ifdef __SOFTFP__\n\t\t\t#error \"Float ABI is not 'softfp'\"\n\t\t\t#endif\n\t\t], [\n\t\t\tfpu=VFP\n\t\t], [\n\t\t\tfpu=NONE\n\t\t])\n\tfi\n\n\tif test x$arm_fpu != x; then\n\t   fpu=$arm_fpu\n\tfi\n\n\tAC_MSG_RESULT($fpu)\n\tCPPFLAGS=\"$CPPFLAGS -DARM_FPU_$fpu=1\"\n\tunset fpu\n\n\tdnl *********************************************\n\tdnl *** Check which ARM version(s) we can use ***\n\tdnl *********************************************\n\tAC_MSG_CHECKING(which ARM version to use)\n\n\tAC_TRY_COMPILE([], [\n\t\t#if !defined(__ARM_ARCH_5T__) && !defined(__ARM_ARCH_5TE__) && !defined(__ARM_ARCH_5TEJ__)\n\t\t#error Not on ARM v5.\n\t\t#endif\n\t], [\n\t\tarm_v5=yes\n\n\t\tarm_ver=ARMv5\n\t], [])\n\n\tAC_TRY_COMPILE([], [\n\t\t#if !defined(__ARM_ARCH_6J__) && !defined(__ARM_ARCH_6ZK__) && !defined(__ARM_ARCH_6K__) && !defined(__ARM_ARCH_6T2__) && !defined(__ARM_ARCH_6M__)\n\t\t#error Not on ARM v6.\n\t\t#endif\n\t], [\n\t\tarm_v5=yes\n\t\tarm_v6=yes\n\n\t\tarm_ver=ARMv6\n\t], [])\n\n\tAC_TRY_COMPILE([], [\n\t\t#if !defined(__ARM_ARCH_7A__) && !defined(__ARM_ARCH_7R__) && !defined(__ARM_ARCH_7EM__) && !defined(__ARM_ARCH_7M__) && !defined(__ARM_ARCH_7S__)\n\t\t#error Not on ARM v7.\n\t\t#endif\n\t], [\n\t\tarm_v5=yes\n\t\tarm_v6=yes\n\t\tarm_v7=yes\n\n\t\tarm_ver=ARMv7\n\t], [])\n\n\tAC_MSG_RESULT($arm_ver)\n\n\tif test x$arm_v5 = xyes; then\n\t\tAC_DEFINE(HAVE_ARMV5, 1, [ARM v5])\n\t\tCPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC -DHAVE_ARMV5=1\"\n\tfi\n\n\tif test x$arm_v6 = xyes; then\n\t\tAC_DEFINE(HAVE_ARMV6, 1, [ARM v6])\n\t\tCPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC -DHAVE_ARMV6=1\"\n\tfi\n\n\tif test x$arm_v7 = xyes; then\n\t\tAC_DEFINE(HAVE_ARMV7, 1, [ARM v7])\n\t\tCPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC -DHAVE_ARMV7=1\"\n\tfi\n\n\tif test x$host_linux = xyes; then\n\t\tRID=\"linux-arm\"\n\t\tCOREARCH=\"arm\"\n\t\tif test x$fpu = xNONE; then\n\t\t\tRID=\"linux-armel\"\n\t\t\tCOREARCH=\"armel\"\n\t\tfi\n\tfi\nfi\n\nAC_SUBST(RID)\nAC_SUBST(COREARCH)\nAC_SUBST(CORETARGETS)\n\nif test ${TARGET} = RISCV32 -o ${TARGET} = RISCV64; then\n\tAC_ARG_WITH([riscv-fpabi], [  --with-riscv-fpabi=auto,double,soft   Select RISC-V floating point ABI (auto)], [fpabi=$withval], [fpabi=double])\n\n\tAC_MSG_CHECKING([which RISC-V floating point ABI to use])\n\n\tif test x$fpabi = xauto; then\n\t\tAC_TRY_COMPILE([], [\n\t\t\t#ifdef __riscv_float_abi_double\n\t\t\t#error \"double\"\n\t\t\t#endif\n\t\t], [\n\t\t\tfpabi=auto\n\t\t], [\n\t\t\tfpabi=double\n\t\t])\n\tfi\n\n\tif test x$fpabi = xauto; then\n\t\tAC_TRY_COMPILE([], [\n\t\t\t#ifdef __riscv_float_abi_single\n\t\t\t#error \"single\"\n\t\t\t#endif\n\t\t], [\n\t\t\tfpabi=auto\n\t\t], [\n\t\t\tfpabi=single\n\t\t])\n\tfi\n\n\tif test x$fpabi = xauto; then\n\t\tAC_TRY_COMPILE([], [\n\t\t\t#ifdef __riscv_float_abi_soft\n\t\t\t#error \"soft\"\n\t\t\t#endif\n\t\t], [\n\t\t\tfpabi=auto\n\t\t], [\n\t\t\tfpabi=soft\n\t\t])\n\tfi\n\n\tcase $fpabi in\n\tdouble)\n\t\tAC_DEFINE([RISCV_FPABI_DOUBLE], [1], [RISC-V FPABI is double-precision])\n\t\tAC_MSG_RESULT([double-precision])\n\t\t;;\n\tsingle)\n\t\tAC_DEFINE([RISCV_FPABI_SINGLE], [1], [RISC-V FPABI is single-precision])\n\t\tAC_MSG_ERROR([single-precision, not supported])\n\t\t;;\n\tsoft)\n\t\tAC_DEFINE([RISCV_FPABI_SOFT], [1], [RISC-V FPABI is soft float])\n\t\tAC_MSG_RESULT([soft float])\n\t\t;;\n\tauto)\n\t\tAC_MSG_ERROR([unknown])\n\t\t;;\n\t*)\n\t\tAC_MSG_ERROR([invalid option: $fpabi])\n\t\t;;\n\tesac\nfi\n\nif test ${TARGET} = unknown; then\n\tCPPFLAGS=\"$CPPFLAGS -DNO_PORT\"\n\tAC_MSG_WARN(\"mono has not been ported to $host: some things may not work.\")\nfi\n\nif test \"x$platform_android\" = \"xyes\"; then\n\tcase \"x${TARGET}\" in\n\txARM)\n\t\tcase \"x$arm_ver\" in\n\t\txARMv5)\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=android-armv5\n\t\t\t;;\n\t\txARMv6)\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=android-armv6\n\t\t\t;;\n\t\txARMv7)\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=android-armv7\n\t\t\t;;\n\t\t*)\n\t\t\tBTLS_SUPPORTED=no\n\t\t\t;;\n\t\tesac\n\t\t;;\n\txARM64)\n\t\tBTLS_SUPPORTED=yes\n\t\tBTLS_PLATFORM=android-v8a\n\t\t;;\n\txX86)\n\t\tBTLS_SUPPORTED=yes\n\t\tBTLS_PLATFORM=android-x86\n\t\t;;\n\txAMD64)\n\t\tBTLS_SUPPORTED=yes\n\t\tBTLS_PLATFORM=android-x64\n\t\t;;\n\t*)\n\t\tBTLS_SUPPORTED=no\n\t\t;;\n\tesac\nfi\n\nif test ${ACCESS_UNALIGNED} = no; then\n\tCPPFLAGS=\"$CPPFLAGS -DNO_UNALIGNED_ACCESS\"\nfi\n\nif test x$host_darwin = xyes; then\n\tAC_MSG_CHECKING([for ranlib that supports -no_warning_for_no_symbols option])\n\tAS_IF(\n\t\t[$RANLIB -no_warning_for_no_symbols 2>&1 | grep -q \"unknown option\"],\n\t\t[AC_MSG_RESULT([no])],\n\t\t[\n\t\t\t# avoid AR calling ranlib, libtool calls it anyway. suppress no symbols warning.\n\t\t\tAR_FLAGS=\"Scru\"\n\t\t\tRANLIB=\"$RANLIB -no_warning_for_no_symbols\"\n\t\t\tAC_MSG_RESULT([yes])\n\t\t]\n\t)\nfi\n\ncase \"x$libgc\" in\n\txincluded)\n\t\t# Pass CPPFLAGS to libgc configure\n\t\t# We should use a separate variable for this to avoid passing useless and\n\t\t# potentially problematic defines to libgc (like -D_FILE_OFFSET_BITS=64)\n\t\t# This should be executed late so we pick up the final version of CPPFLAGS\n\t\t# The problem with this approach, is that during a reconfigure, the main\n\t\t# configure scripts gets invoked with these arguments, so we use separate\n\t\t# variables understood by libgc's configure to pass CPPFLAGS and CFLAGS.\n\t\tTMP_CPPFLAGS=\"$CPPFLAGS $CPPFLAGS_FOR_LIBGC\"\n\t\tif test x$TARGET = xSPARC -o x$TARGET = xSPARC64; then\n\t\t\tTMP_CPPFLAGS=`echo $TMP_CPPFLAGS | sed -e 's/-D_FILE_OFFSET_BITS=64//g'`\n\t\tfi\n\t\t# Don't pass -finstrument-for-thread-suspension in, \n\t\t# if these are instrumented it will be very bad news \n\t\t# (infinite recursion, undefined parking behavior, etc)\n\t\tTMP_CPPFLAGS=`echo $TMP_CPPFLAGS | sed -e 's/-finstrument-for-thread-suspension//g'`\n\t\tac_configure_args=\"$ac_configure_args --disable-embed-check --with-libgc-threads=$libgc_threads $libgc_configure_args \\\"CPPFLAGS_FOR_LIBGC=$TMP_CPPFLAGS\\\" \\\"CFLAGS_FOR_LIBGC=$CFLAGS_FOR_LIBGC\\\"\"\n\t\tif test \"x$support_boehm\" = \"xyes\"; then\n\t\t\tAC_CONFIG_SUBDIRS(libgc)\n\t\tfi\n\t\t;;\nesac\n\nMALLOC_MEMPOOLS=no\nAC_ARG_WITH(malloc_mempools,[  --with-malloc-mempools=yes,no  Use malloc for each single mempool allocation (only for runtime debugging, defaults to no)],[\n\tif test x$with_malloc_mempools = xyes; then\n\t\tMALLOC_MEMPOOLS=yes\n\t\tAC_DEFINE(USE_MALLOC_FOR_MEMPOOLS,1,[Use malloc for each single mempool allocation])\n\tfi\n])\n\n\nDISABLE_MCS_DOCS=default\nAC_ARG_WITH(mcs_docs,[  --with-mcs-docs=yes,no         If you want to build the documentation under mcs (defaults to yes)],[\n\tif test x$with_mcs_docs != xyes; then\n\t\tDISABLE_MCS_DOCS=yes\n\tfi\n])\nif test -n \"$INSTALL_4_x_TRUE\"; then :\n\tDISABLE_MCS_DOCS=yes\nfi\nif test \"x$DISABLE_MCS_DOCS\" = \"xdefault\"; then\n   DISABLE_MCS_DOCS=$DISABLE_MCS_DOCS_default\nfi\n\nAC_ARG_WITH(lazy_gc_thread_creation, [  --with-lazy-gc-thread-creation=yes|no      Enable lazy runtime thread creation, embedding host must do it explicitly (defaults to no)],[\n\tif test x$with_lazy_gc_thread_creation != xno ; then\n\t\tAC_DEFINE(LAZY_GC_THREAD_CREATION,1,[Enable lazy gc thread creation by the embedding host.])\n\tfi\n], [with_lazy_gc_thread_creation=no])\n\ndnl *****************************\ndnl *** Thread suspend policy ***\ndnl *****************************\n\ndnl Set a default hybrid or cooperative suspend on some platforms\n\ndnl Coop default is set by the bitcode preset.\n\ndnl If coop isn't on by default, maybe hybrid should be?\nif test x$enable_cooperative_suspend_default != xyes; then\n\tcase $HOST in\n\tX86 | AMD64)\n\t\tdnl Some host/target confusion, there's no host_osx (and\n\t\tdnl host_darwin would be true on iOS not just macOS).\n\t\tif test x$target_osx = xyes; then\n\t\t\tenable_hybrid_suspend_default=yes\n\t\telif test x$host_linux = xyes -o x$host_win32 = xyes; then\n\t\t\tenable_hybrid_suspend_default=yes\n\t\tfi\n\t\t;;\n\tesac\nfi\n\ndnl Now check if there were flags overriding the defaults\n\nAC_ARG_WITH(cooperative_gc,        [  --with-cooperative-gc=yes|no        Enable cooperative stop-the-world garbage collection (sgen only) (defaults to no)], [AC_MSG_WARN([--with-cooperative-gc is deprecated, use --enable-cooperative-suspend instead])], [with_cooperative_gc=default])\nAC_ARG_ENABLE(cooperative_suspend, [  --enable-cooperative-suspend      Enable cooperative stop-the-world garbage collection (sgen only) (defaults to no)], [], [enable_cooperative_suspend=default])\n\nif test x$enable_cooperative_suspend = xdefault -a x$with_cooperative_gc != xdefault; then\n\tenable_cooperative_suspend=$with_cooperative_gc\nfi\n\nif test x$enable_cooperative_suspend = xdefault; then\n\tenable_cooperative_suspend=$enable_cooperative_suspend_default\nfi\n\nif test x$enable_cooperative_suspend != xno; then\n\tAC_DEFINE(ENABLE_COOP_SUSPEND,1,[Enable cooperative stop-the-world garbage collection.])\n\tenable_hybrid_suspend_default=no\nfi\n\nAM_CONDITIONAL([ENABLE_COOP_SUSPEND], [test x$enable_cooperative_suspend != xno])\n\nAC_ARG_ENABLE(hybrid_suspend, [ --enable-hybrid-suspend     Enable hybrid stop-the-world garbage collection (sgen only) - cooperative suspend for threads running managed and runtime code, and preemptive suspend for threads running native and P/Invoke code (defaults to no)], [], [enable_hybrid_suspend=default])\n\nif test x$enable_hybrid_suspend = xdefault; then\n   enable_hybrid_suspend=$enable_hybrid_suspend_default\nfi\n\nif test x$enable_hybrid_suspend != xno -a x$enable_cooperative_suspend != xno ; then\n\tAC_MSG_ERROR([Hybrid suspend and Cooperative suspend cannot be both enabled.])\nfi\n\nif test x$enable_hybrid_suspend != xno ; then\n\tAC_DEFINE(ENABLE_HYBRID_SUSPEND,1,[Enable hybrid suspend for GC stop-the-world])\nfi\n\nAM_CONDITIONAL([ENABLE_HYBRID_SUSPEND], [test x$enable_hybrid_suspend != xno])\n\ndnl End of thread suspend policy\n\ndnl ***************************\ndnl *** feature experiments ***\ndnl ***************************\n\ndnl When adding experiments, also add to mono/utils/mono-experiments.def\nAC_ARG_ENABLE(experiment, [ --enable-experiment=LIST       Enable experimental fatures from the comma-separate LIST.  Available experiments: null],[\n\n\tif test x$enable_experiment != x ; then\n\t\tAC_DEFINE(ENABLE_EXPERIMENTS,1,[Enable feature experiments])\n\tfi\n\tfor feature in `echo \"$enable_experiment\" | sed -e \"s/,/ /g\"`; do\n\t\teval \"mono_experiment_test_enable_$feature='yes'\"\n\tdone\n\n\tif test \"x$mono_experiment_test_enable_all\" = \"xyes\"; then\n\t\teval \"mono_experiment_test_enable_null='yes'\"\n\t\ttrue\n\tfi\n\n\tif test \"x$mono_experiment_test_enable_null\" = \"xyes\"; then\n\t\tAC_DEFINE(ENABLE_EXPERIMENT_null, 1, [Enable experiment 'null'])\n\tfi\n],[])\n\ndnl **********************\ndnl *** checked builds ***\ndnl **********************\n\nAC_ARG_ENABLE(checked_build, [  --enable-checked-build=LIST      To enable checked build (expensive asserts), configure with a comma-separated LIST of checked build modules and then include that same list in the environment variable MONO_CHECK_MODE at runtime. Recognized checked build modules: all, gc, metadata, thread, private_types, crash_reporting],[\n\n\tif test x$enable_checked_build != x ; then\n\t\tAC_DEFINE(ENABLE_CHECKED_BUILD,1,[Enable checked build])\n\tfi\n\tfor feature in `echo \"$enable_checked_build\" | sed -e \"s/,/ /g\"`; do\n\t\teval \"mono_checked_build_test_enable_$feature='yes'\"\n\tdone\n\n\tif test \"x$mono_checked_build_test_enable_all\" = \"xyes\"; then\n\t\teval \"mono_checked_build_test_enable_gc='yes'\"\n\t\teval \"mono_checked_build_test_enable_metadata='yes'\"\n\t\teval \"mono_checked_build_test_enable_thread='yes'\"\n\t\teval \"mono_checked_build_test_enable_private_types='yes'\"\n\t\teval \"mono_checked_build_test_enable_crash_reporting='yes'\"\n\tfi\n\n\tif test \"x$mono_checked_build_test_enable_gc\" = \"xyes\"; then\n\t\tAC_DEFINE(ENABLE_CHECKED_BUILD_GC, 1, [Enable GC checked build])\n\tfi\n\n\tif test \"x$mono_checked_build_test_enable_metadata\" = \"xyes\"; then\n\t\tAC_DEFINE(ENABLE_CHECKED_BUILD_METADATA, 1, [Enable metadata checked build])\n\tfi\n\n\tif test \"x$mono_checked_build_test_enable_thread\" = \"xyes\"; then\n\t\tAC_DEFINE(ENABLE_CHECKED_BUILD_THREAD, 1, [Enable thread checked build])\n\tfi\n\n\tif test \"x$mono_checked_build_test_enable_private_types\" = \"xyes\"; then\n\t\tAC_DEFINE(ENABLE_CHECKED_BUILD_PRIVATE_TYPES, 1, [Enable private types checked build])\n\tfi\n\n\tif test \"x$mono_checked_build_test_enable_crash_reporting\" = \"xyes\"; then\n\t\t# Required\n\t\twith_overridable_allocators=yes\n\t\tAC_DEFINE(ENABLE_OVERRIDABLE_ALLOCATORS,1,[Overridable allocator support enabled])\n\n\t\tAC_DEFINE(ENABLE_CHECKED_BUILD_CRASH_REPORTING, 1, [Enable private types checked build])\n\tfi\n], [])\n\ndnl End of checked builds\n\nAM_CONDITIONAL(NEED_VASPRINTF, test x$ac_cv_func_vasprintf = xno || test x$with_overridable_allocators = xyes)\n\nAC_CHECK_HEADER([malloc.h], \n\t\t[AC_DEFINE([HAVE_USR_INCLUDE_MALLOC_H], [1], \n\t\t\t[Define to 1 if you have /usr/include/malloc.h.])],,)\n\n# When --disable-shared is used, libtool transforms libmono-2.0.la into libmono-2.0.so\n# instead of libmono-static.a\nif test \"x$enable_shared\" = \"xno\" -a \"x$enable_executables\" = \"xyes\"; then\n   LIBMONO_LA=libmini-static.la\nelse\n   if test x$buildsgen = xyes; then\n      LIBMONO_LA=libmonosgen-$API_VER.la\n   else\n      LIBMONO_LA=libmonoboehm-$API_VER.la\n   fi\nfi\nAC_SUBST(LIBMONO_LA)\n\ndnl **************\ndnl ***  Btls  ***\ndnl **************\n\nAC_ARG_ENABLE(btls, [  --disable-btls             Disable the BoringTls provider], enable_btls=$enableval, enable_btls=$BTLS_SUPPORTED)\nAC_ARG_ENABLE(btls-lib, [  --disable-btls-lib             Disable building the BTLS native library], enable_btls_lib=$enableval, enable_btls_lib=$BTLS_SUPPORTED)\nAC_ARG_WITH(btls_android_ndk, [  --with-btls-android-ndk        Android NDK for BoringTls])\nAC_ARG_WITH(btls_android_api, [  --with-btls-android-api        Android NDK API level for BTLS build])\nAC_ARG_WITH(btls_android_cmake_toolchain, [  --with-btls-android-cmake-toolchain        Path to the cmake toolchain file for Android])\nAC_ARG_WITH(btls_android_ndk_asm_workaround, [  --with-btls-android-ndk-asm-workaround        Work around a problem with NDK r18+ clang compiler when compiling some AES assembly for ARM])\n\nif test \"x$with_btls_android_api\" = \"x\" ; then\n\tcase \"$BTLS_PLATFORM\" in\n\t\tandroid-armv5)\n\t\t\twith_btls_android_api=16\" ;;\n\t\tandroid-armv6)\n\t\t\twith_btls_android_api=16\" ;;\n\t\tandroid-armv7)\n\t\t\twith_btls_android_api=16 ;;\n\t\tandroid-v8a)\n\t\t\twith_btls_android_api=21 ;;\n\t\tandroid-x86)\n\t\t\twith_btls_android_api=16 ;;\n\t\tandroid-x64)\n\t\t\twith_btls_android_api=21 ;;\n\tesac\nfi\n\nif test \"x$enable_btls\" = \"xno\"; then\n   enable_btls_lib=no\nfi\n\nAM_CONDITIONAL(BTLS, test x$enable_btls_lib = xyes)\n\nbtls_android=no\nif test \"x$enable_btls\" = \"xyes\"; then\n\tAC_PATH_PROG(CMAKE, [cmake], [no], [$PATH:/Applications/CMake.app/Contents/bin:/usr/local/bin])\n\tif test \"x$CMAKE\" = \"xno\"; then\n\t\tAC_MSG_ERROR(\"cmake not found\")\n\tfi\n\n\tBTLS_ROOT=`cd $srcdir && pwd`/external/boringssl\n\tAC_SUBST(BTLS_ROOT)\n\n\tbtls_arch=\n\tbtls_cflags=\n\tBTLS_CMAKE_ARGS=\n\n\tif test \"x$host_win32\" = \"xyes\"; then\n\t\tAC_CHECK_PROG(HAVE_YASM, yasm, yes, no)\n\tfi\n\n\tcase \"$BTLS_PLATFORM\" in\n\ti386)\n\t\tbtls_arch=i386\n\t\tbtls_cflags=\"-m32\"\n\t\tcase $host_os in\n\t\t\tdarwin*)\n\t\t\t\tbtls_cflags=\"$btls_cflags -arch i386\"\n\t\t\t\t;;\n\t\t\tmingw*|cygwin*)\n\t\t\t\tbtls_cflags=\"-DNOCRYPT $WIN32_CPPFLAGS\"\n\t\t\t\tif test \"x$HAVE_YASM\" != \"xyes\"; then\n\t\t\t\t\tBTLS_CMAKE_ARGS=\"-DOPENSSL_NO_ASM=1\"\n\t\t\t\tfi\n\t\t\t\t;;\n\t\tesac\n\t\t;;\n\tx86_64)\n\t\tbtls_arch=x86_64\n\t\tcase $host_os in\n\t\t\tmingw*|cygwin*)\n\t\t\t\tbtls_cflags=\"-DNOCRYPT $WIN32_CPPFLAGS\"\n\t\t\t\tif test \"x$HAVE_YASM\" != \"xyes\"; then\n\t\t\t\t\tBTLS_CMAKE_ARGS=\"-DOPENSSL_NO_ASM=1\"\n\t\t\t\tfi\n\t\t\t\t;;\n\t\tesac\n\t\t;;\n\tarm)\n\t\tbtls_arch=arm\n\t\tbtls_cflags=\"-DOPENSSL_NO_ASM=1\"\n\t\t;;\n\tarmsoft)\n\t\tbtls_arch=arm\n\t\tbtls_cflags=\"-DOPENSSL_NO_ASM=1\"\n\t\t;;\n\taarch64)\n\t\tbtls_arch=aarch64\n\t\tbtls_cflags=\"-march=armv8-a+crypto\"\n\t\t;;\n\ts390x)\n\t\tbtls_arch=s390x\n\t\t;;\n\tpowerpc)\n\t\tbtls_arch=powerpc\n\t\tcase $host_os in\n\t\t\taix*|os400*)\n\t\t\t\tbtls_cflags=\"$btls_cflags -maix64 -mminimal-toc -pthread -D_ALL_SOURCE -D_THREAD_SAFE -D_REENTRANT\"\n\t\t\t\tBTLS_CMAKE_ARGS=\"$BTLS_CMAKE_ARGS -DCMAKE_AR=/usr/bin/ar -DCMAKE_C_ARCHIVE_CREATE=\\\"<CMAKE_AR> -X64 cr <TARGET> <LINK_FLAGS> <OBJECTS>\\\"\"\n\t\tesac\n\t\t;;\n\tandroid-armv5)\n\t\tBTLS_CMAKE_ARGS=\"-DANDROID_ABI=\\\"armeabi\\\" -DANDROID_NATIVE_API_LEVEL=$with_btls_android_api\"\n\t\t;;\n\tandroid-armv6)\n\t\tBTLS_CMAKE_ARGS=\"-DANDROID_ABI=\\\"armeabi\\\" -DANDROID_NATIVE_API_LEVEL=$with_btls_android_api\"\n\t\t;;\n\tandroid-armv7)\n\t\tBTLS_CMAKE_ARGS=\"-DANDROID_ABI=\\\"armeabi-v7a\\\" -DANDROID_NATIVE_API_LEVEL=$with_btls_android_api\"\n\t\t;;\n\tandroid-v8a)\n\t\tBTLS_CMAKE_ARGS=\"-DANDROID_ABI=\\\"arm64-v8a\\\" -DANDROID_NATIVE_API_LEVEL=$with_btls_android_api\"\n\t\t;;\n\tandroid-x86)\n\t\tBTLS_CMAKE_ARGS=\"-DANDROID_ABI=\\\"x86\\\" -DANDROID_NATIVE_API_LEVEL=$with_btls_android_api\"\n\t\t;;\n\tandroid-x64)\n\t\tBTLS_CMAKE_ARGS=\"-DANDROID_ABI=\\\"x86_64\\\" -DANDROID_NATIVE_API_LEVEL=$with_btls_android_api\"\n\t\t;;\n\triscv32)\n\t\tbtls_arch=riscv32\n\t\t;;\n\triscv64)\n\t\tbtls_arch=riscv64\n\t\t;;\n\t*)\n\t\tAC_MSG_ERROR(Invalid BTLS platform)\n\tesac\n\n\tif test \"x$platform_android\" = \"xyes\"; then\n\t   \tif test \"x$with_btls_android_cmake_toolchain\" = \"x\"; then\n\t\t   with_btls_android_cmake_toolchain=\"$BTLS_ROOT/util/android-cmake/android.toolchain.cmake\"\n\t\tfi\n\n\t\tif test \"x$with_btls_android_ndk_asm_workaround\" != \"x\"; then\n\t\t   BTLS_CMAKE_ARGS=\"$BTLS_CMAKE_ARGS -DENABLE_NDK_ARM_WORKAROUND=ON\"\n\t\tfi\n\n\t\tbtls_android=yes\n\t\tBTLS_CMAKE_ARGS=\"$BTLS_CMAKE_ARGS -DCMAKE_TOOLCHAIN_FILE=$with_btls_android_cmake_toolchain\"\n\t\tif test \"x$with_btls_android_ndk\" != \"x\"; then\n\t\t\tBTLS_CMAKE_ARGS=\"$BTLS_CMAKE_ARGS -DANDROID_NDK=\\\"$with_btls_android_ndk\\\"\"\n\t\telse\n\t\t\tAC_MSG_ERROR([Need to pass the --with-btls-android-ndk argument when building with BTLS support on Android.])\n\t\tfi\n\tfi\n\n\tif test \"x$btls_arch\" != \"x\"; then\n\t\tBTLS_CMAKE_ARGS=\"$BTLS_CMAKE_ARGS -DBTLS_ARCH=\\\"$btls_arch\\\"\"\n\tfi\n\n\tBTLS_CFLAGS=\"$CPPFLAGS_FOR_BTLS $btls_cflags\"\n\tAC_SUBST(BTLS_ARCH)\n\tAC_SUBST(BTLS_CFLAGS)\n\tAC_SUBST(BTLS_PLATFORM)\n\tAC_SUBST(BTLS_CMAKE_ARGS)\n\n\tAC_DEFINE(HAVE_BTLS, 1, [BoringTls is supported])\nelse\n\tenable_btls=no\nfi\n\nAM_CONDITIONAL(BTLS_ANDROID, test x$btls_android = xyes)\n\nif test x$DISABLE_MCS_DOCS = xyes; then\n   docs_dir=\"\"\nelse\n   docs_dir=docs\nfi\nAC_SUBST(docs_dir)\n\n## Maybe should also disable if mcsdir is invalid.  Let's punt the issue for now.\nAM_CONDITIONAL(BUILD_MCS, [test x$cross_compiling = xno && test x$enable_mcs_build != xno])\nAM_CONDITIONAL(BUILD_SUPPORT, [test x$enable_support_build != xno])\n\nlibmono_ldflags=\"$libmono_ldflags $LIBS\"\n\nAM_CONDITIONAL(MIPS_GCC, test ${TARGET}${ac_cv_prog_gcc} = MIPSyes)\nAM_CONDITIONAL(MIPS_SGI, test ${TARGET}${ac_cv_prog_gcc} = MIPSno)\nAM_CONDITIONAL(SPARC, test x$TARGET = xSPARC)\nAM_CONDITIONAL(SPARC64, test x$TARGET = xSPARC64)\nAM_CONDITIONAL(X86, test x$TARGET = xX86)\nAM_CONDITIONAL(AMD64, test x$TARGET = xAMD64)\nAM_CONDITIONAL(MIPS, test x$TARGET = xMIPS)\nAM_CONDITIONAL(POWERPC, test x$TARGET = xPOWERPC)\nAM_CONDITIONAL(POWERPC64, test x$TARGET = xPOWERPC64)\nAM_CONDITIONAL(ARM, test x$TARGET = xARM)\nAM_CONDITIONAL(ARM64, test x$TARGET = xARM64 -o x$TARGET = xARM6432)\nAM_CONDITIONAL(S390X, test x$TARGET = xS390X)\nAM_CONDITIONAL([RISCV], [test x$TARGET = xRISCV32 -o x$TARGET = xRISCV64])\nAM_CONDITIONAL([RISCV32], [test x$TARGET = xRISCV32])\nAM_CONDITIONAL([RISCV64], [test x$TARGET = xRISCV64])\nAM_CONDITIONAL(WASM, test x$TARGET = xWASM)\nAM_CONDITIONAL(HOST_X86, test x$HOST = xX86)\nAM_CONDITIONAL(HOST_AMD64, test x$HOST = xAMD64)\nAM_CONDITIONAL(HOST_ARM, test x$HOST = xARM)\nAM_CONDITIONAL(HOST_ARM64, test x$HOST = xARM64)\nAM_CONDITIONAL([HOST_RISCV], [test x$HOST = xRISCV32 -o x$HOST = xRISCV64])\nAM_CONDITIONAL([HOST_RISCV32], [test x$HOST = xRISCV32])\nAM_CONDITIONAL([HOST_RISCV64], [test x$HOST = xRISCV64])\nAM_CONDITIONAL(HOST_WASM, test x$HOST = xWASM)\n\nAM_CONDITIONAL(CROSS_COMPILE, test \"x$host\" != \"x$target\")\n\nAC_SUBST(LIBC)\nAC_SUBST(INTL)\nAC_SUBST(SQLITE)\nAC_SUBST(SQLITE3)\nAC_SUBST(ODBC)\nAC_SUBST(X11)\nAC_SUBST(GDKX11)\nAC_SUBST(GTKX11)\nAC_SUBST(XINERAMA)\nAC_DEFINE_UNQUOTED(MONO_ARCHITECTURE,\"$arch_target\",[The architecture this is running on])\nAC_SUBST(arch_target)\n\n#This must always be defined when building the runtime\nAC_DEFINE(MONO_INSIDE_RUNTIME,1, [Disable banned functions from being used by the runtime])\n\nmono_build_root=`pwd`\nAC_SUBST(mono_build_root)\n\nAC_ARG_ENABLE(msvc_only,[  --enable-msvc-only    Build only with Visual Studio (msvc) (defaults to no). Disable gcc build.], enable_msvc_only=$enableval, enable_msvc_only=no)\nif test x$host_win32 = xno; then\n\tif test x$enable_msvc_only = xyes; then\n\t\techo \"Error, --enable-msvc-only only supported for Windows builds.\"\n\t\texit 1\n\tfi\nfi\nAM_CONDITIONAL(ENABLE_MSVC_ONLY, test x$enable_msvc_only = xyes)\n\nAC_ARG_ENABLE(msvc,[  --enable-msvc    Build with Visual Studio (msvc) (defaults to no)], enable_msvc=$enableval, enable_msvc=no)\nif test x$host_win32 = xno; then\n\tif test x$enable_msvc = xyes; then\n\t\techo \"Error, --enable-msvc only supported for Windows builds.\"\n\t\texit 1\n\tfi\nfi\nif test x$enable_msvc_only = xyes; then\n\tenable_msvc=yes\nfi\nAM_CONDITIONAL(ENABLE_MSVC, test x$enable_msvc = xyes)\n\nif test \"x$enable_msvc\" = \"xyes\"; then\n\tif test \"x$support_boehm\" = \"xyes\"; then\n\t\techo \"Error, Boehm GC is not supported when using --enable-msvc.\"\n\t\texit 1\n\tfi\n\tmono_msvc_build_dir='$(top_srcdir)'/msvc/build/sgen\n\tif test \"x$host_cpu\" = \"xi686\"; then\n\t\tmono_msvc_build_lib_dir='$(mono_msvc_build_dir)'/Win32/lib/Release\n\t\tmono_msvc_build_bin_dir='$(mono_msvc_build_dir)'/Win32/bin/Release\n\t\tmono_runtime=msvc/build/sgen/Win32/bin/Release/mono-sgen.exe\n\t\tmono_runtime_wrapper=$mono_runtime\n\telse\n\t\tmono_msvc_build_lib_dir='$(mono_msvc_build_dir)'/x64/lib/Release\n\t\tmono_msvc_build_bin_dir='$(mono_msvc_build_dir)'/x64/bin/Release\n\t\tmono_runtime=msvc/build/sgen/x64/bin/Release/mono-sgen.exe\n\t\tmono_runtime_wrapper=msvc/build/sgen/x64/bin/Release/mono-sgen-msvc.sh\n\tfi\n\tAC_SUBST(mono_msvc_build_dir)\n\tAC_SUBST(mono_msvc_build_lib_dir)\n\tAC_SUBST(mono_msvc_build_bin_dir)\nelse\n\tmono_runtime=mono/mini/mono\n\tmono_runtime_wrapper=$mono_runtime\nfi\n\nAC_SUBST(mono_runtime)\nAC_SUBST(mono_runtime_wrapper)\n\nCSC_LOCATION=`cd $srcdir && pwd`/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/csc.exe\nVBCS_LOCATION=`cd $srcdir && pwd`/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/VBCSCompiler.exe\n\nif test $csc_compiler = mcs; then\n  CSC=$mcs_topdir/class/lib/build/mcs.exe\nelse\n  CSC=$CSC_LOCATION\nfi\n\nAM_CONDITIONAL([CSC_IS_ROSLYN], [test x$csc_compiler != xmcs])\n\nmono_cfg_root=$mono_build_root/runtime\nif test x$host_win32 = xyes; then\n  if test \"x$cross_compiling\" = \"xno\"; then\n    mono_cfg_dir=`cygpath -w -a $mono_cfg_root`\\\\etc\n    CSC=`cygpath -m -a $CSC`\n    CSC_LOCATION=`cygpath -m -a $CSC_LOCATION`\n    VBCS_LOCATION=`cygpath -m -a $VBCS_LOCATION`\n  else\n    mono_cfg_dir=`echo $mono_cfg_root | tr '/' '\\\\'`\\\\etc\n  fi\nelse\n  mono_cfg_dir=$mono_cfg_root/etc\nfi\n\nif test \"x$platform_android\" = \"xyes\"; then\n  mono_cfg_dir=\nfi\n\nAC_SUBST(mono_cfg_dir)\n\nAC_SUBST(CSC)\n\nAC_CONFIG_FILES([po/mcs/Makefile.in])\n\nAC_CONFIG_FILES([acceptance-tests/microbench-perf.sh],[chmod +x acceptance-tests/microbench-perf.sh])\nAC_CONFIG_FILES([runtime/mono-wrapper],[chmod +x runtime/mono-wrapper])\nAC_CONFIG_FILES([runtime/monodis-wrapper],[chmod +x runtime/monodis-wrapper])\nAC_CONFIG_FILES([runtime/bin/mono-hang-watchdog],[chmod +x runtime/bin/mono-hang-watchdog])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/1.0/machine.config],\n[   depth=../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/1.0\n    cd runtime/etc/mono/1.0\n    rm -f machine.config\n    $LN_S $reldir/data/net_1_1/machine.config machine.config\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/2.0/machine.config],\n[   depth=../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/2.0\n    cd runtime/etc/mono/2.0\n    rm -f machine.config\n    $LN_S $reldir/data/net_2_0/machine.config machine.config\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/2.0/web.config],\n[   depth=../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/2.0\n    cd runtime/etc/mono/2.0\n    rm -f web.config\n    $LN_S $reldir/data/net_2_0/web.config web.config\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/browscap.ini],\n[   depth=../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/\n    cd runtime/etc/mono/\n    rm -f browscap.ini\n    $LN_S $reldir/data/browscap.ini browscap.ini\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/2.0/Browsers/Compat.browser],\n[   depth=../../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/2.0/Browsers/\n    cd runtime/etc/mono/2.0/Browsers\n    rm -f Compat.browser\n    $LN_S $reldir/data/Browsers/Compat.browser Compat.browser\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/4.0/Browsers/Compat.browser],\n[   depth=../../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/4.0/Browsers/\n    cd runtime/etc/mono/4.0/Browsers\n    rm -f Compat.browser\n    $LN_S $reldir/data/Browsers/Compat.browser Compat.browser\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/4.5/Browsers/Compat.browser],\n[   depth=../../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/4.5/Browsers/\n    cd runtime/etc/mono/4.5/Browsers\n    rm -f Compat.browser\n    $LN_S $reldir/data/Browsers/Compat.browser Compat.browser\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/4.0/machine.config],\n[   depth=../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/4.0\n    cd runtime/etc/mono/4.0\n    rm -f machine.config\n    $LN_S $reldir/data/net_4_0/machine.config machine.config\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/4.0/web.config],\n[   depth=../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/4.0\n    cd runtime/etc/mono/4.0\n    rm -f web.config\n    $LN_S $reldir/data/net_4_0/web.config web.config\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/4.5/machine.config],\n[   depth=../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/4.5\n    cd runtime/etc/mono/4.5\n    rm -f machine.config\n    $LN_S $reldir/data/net_4_5/machine.config machine.config\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/4.5/web.config],\n[   depth=../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/4.5\n    cd runtime/etc/mono/4.5\n    rm -f web.config\n    $LN_S $reldir/data/net_4_5/web.config web.config\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([quiet-libtool], [sed -e 's/echo \"copying selected/# \"copying selected/g' < libtool > libtool.tmp && mv libtool.tmp libtool && chmod a+x libtool; sed -e 's/$ECHO \"copying selected/# \"copying selected/g' < libtool > libtool.tmp && mv libtool.tmp libtool && chmod a+x libtool])\nAC_CONFIG_COMMANDS([nolock-libtool], [sed -e 's/lock_old_archive_extraction=yes/lock_old_archive_extraction=no/g' < libtool > libtool.tmp && mv libtool.tmp libtool && chmod a+x libtool])\nAC_CONFIG_COMMANDS([clean-llvm], [rm -f llvm/llvm_config.mk])\n\n#\n# Mono.Native Support\n# -------------------\n# Mono.Native is the new name for both System.Native and System.Security.Cryptography.Apple.\n# It is built as a stand-alone shared library and not bundled with the runtime because we\n# may need to build two different versions of it.\n#\n# Starting with macOS 10.12+ and iOS 10+, Apple introduced a new Unified API for some of the\n# crypto primitives that we're using as part of System.Security.Cryptography.Apple.\n#\n# On Desktop, we can check at runtime whether the OS version is recent enough and switch\n# implementation accordingly.  We build a single `libmono-native` shared library.\n#\n# However, on Mobile we cannot have any undefined symbols as this would break Bitcode.\n#\n# During the mobile build, we are called with `CFLAGS` containing an explicit minium version flag,\n# which is eiter `-mmacosx-version-min=`, `-mios-simulator-version-min=` or `-miphoneos-version-min=`\n# depending on platform.\n#\n# We build two versions of the shared library:\n# - `libmono-native-compat` is built with whichever minimum version is passed to us via `CFLAGS`.\n# - `libmono-native-unifed` is built with the minimum version set to macOS 10.12+ / iOS 10+.\n#\n# For testing purpuses, there is a function called `mono_native_get_platform_type ()`\n# (see mono/native/mono-native-platform.c), which returns a `MonoNativePlatformType` enum value.\n# There is also `Mono.MonoNativePlatform.GetPlatformType ()` (see mcs/class/corlib/Test/Mono/MonoNativePlatform.cs).\n#\n# This can be called by automated tests both to ensure that the library has been correctly installed and also\n# to verify that it's the correct version of it.\n#\n\nAC_MSG_CHECKING([Mono.Native support])\nsed_version_pattern='[[0-9]]\\{1,2\\}\\(\\.[[0-9]]\\{1,2\\}\\)'\nif test x$disable_mono_native = xyes; then\n\tmono_native=no\nelif test x$target_osx = xyes; then\n\tMONO_NATIVE_CC=$CC\n\tMONO_NATIVE_CXX=$CXX\n\tMONO_NATIVE_CCASFLAGS=$CCASFLAGS\n\tMONO_NATIVE_CPPFLAGS=$CPPFLAGS\n\tMONO_NATIVE_CXXFLAGS=$CXXFLAGS\n\tMONO_NATIVE_CFLAGS=$CFLAGS\n\tMONO_NATIVE_LDFLAGS=$LDFLAGS\n\n\tmono_native=yes\n\tMONO_NATIVE_PLATFORM=macos\n\tMONO_NATIVE_PLATFORM_TYPE=\"MONO_NATIVE_PLATFORM_TYPE_MACOS\"\n\n\tif test x$enable_gss = xyes; then\n\t\tMONO_NATIVE_LDFLAGS=\"$MONO_NATIVE_LDFLAGS -framework GSS\"\n\tfi\n\n\tAC_MONO_APPLE_AVAILABLE(mono_native_compat, [whether we need the compatibility layer],\n\t\t[!(MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_12)])\n\n\tif test x$mono_native_compat = xyes; then\n\t\tmono_native_compat=yes\n\t\tmono_native_text=\"Mac OSX (compat + unified v10.12)\"\n\t\tMONO_NATIVE_COMPAT_CCASFLAGS=$MONO_NATIVE_CCASFLAGS\n\t\tMONO_NATIVE_COMPAT_CPPFLAGS=$MONO_NATIVE_CPPFLAGS\n\t\tMONO_NATIVE_COMPAT_CXXFLAGS=$MONO_NATIVE_CXXFLAGS\n\t\tMONO_NATIVE_COMPAT_CFLAGS=$MONO_NATIVE_CFLAGS\n\t\tMONO_NATIVE_COMPAT_LDFLAGS=$MONO_NATIVE_LDFLAGS\n\n\t\tsed_remove_mac_version_pattern=\"s/-mmacosx-version-min=$sed_version_pattern//g\"\n\t\tMONO_NATIVE_UNIFIED_CCASFLAGS=\"`echo $CCASFLAGS | sed -e $sed_remove_mac_version_pattern` -mmacosx-version-min=10.12\"\n\t\tMONO_NATIVE_UNIFIED_CPPFLAGS=\"`echo $CPPFLAGS | sed -e $sed_remove_mac_version_pattern` -mmacosx-version-min=10.12\"\n\t\tMONO_NATIVE_UNIFIED_CXXFLAGS=\"`echo $CXXFLAGS | sed -e $sed_remove_mac_version_pattern` -mmacosx-version-min=10.12\"\n\t\tMONO_NATIVE_UNIFIED_CFLAGS=\"`echo $CFLAGS | sed -e $sed_remove_mac_version_pattern` -mmacosx-version-min=10.12\"\n\t\tMONO_NATIVE_UNIFIED_LDFLAGS=\"`echo $LDFLAGS | sed -e $sed_remove_mac_version_pattern` -mmacosx-version-min=10.12\"\n\telse\n\t\tmono_native_compat=no\n\t\tmono_native_text=\"Mac OSX\"\n\tfi\nelif test x$mono_native_platform_ios = xyes; then\n\tAC_MONO_APPLE_TARGET(TARGET_OS_SIMULATOR, [mono_native_ios_sim=yes], [mono_native_ios_sim=no])\n\n\tAC_MONO_APPLE_TARGET(TARGET_OS_IOS, [\n\t\tif test x$mono_native_ios_sim = xyes; then\n\t\t\tmono_native_ios_target=ios-simulator\n\t\t\tmono_native_text=\"iOS Simulator\"\n\t\t\tMONO_NATIVE_PLATFORM_TYPE=\"MONO_NATIVE_PLATFORM_TYPE_IOS | MONO_NATIVE_PLATFORM_TYPE_IPHONE | MONO_NATIVE_PLATFORM_TYPE_SIMULATOR\"\n\t\telse\n\t\t\tmono_native_ios_target=iphoneos\n\t\t\tmono_native_text=\"iOS Device\"\n\t\t\tMONO_NATIVE_PLATFORM_TYPE=\"MONO_NATIVE_PLATFORM_TYPE_IOS | MONO_NATIVE_PLATFORM_TYPE_IPHONE | MONO_NATIVE_PLATFORM_TYPE_DEVICE\"\n\t\tfi\n\t\tmono_native_unified_version=\"10.0\"\n\t\tmono_native_compat_check=\"__IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_10_0\"\n\t], [\n\t\tAC_MONO_APPLE_TARGET(TARGET_OS_TV, [\n\t\t\tif test x$mono_native_ios_sim = xyes; then\n\t\t\t\tmono_native_ios_target=tvos-simulator\n\t\t\t\tmono_native_text=\"AppleTV Simulator\"\n\t\t\t\tMONO_NATIVE_PLATFORM_TYPE=\"MONO_NATIVE_PLATFORM_TYPE_IOS | MONO_NATIVE_PLATFORM_TYPE_TV | MONO_NATIVE_PLATFORM_TYPE_SIMULATOR\"\n\t\t\telse\n\t\t\t\tmono_native_ios_target=tvos\n\t\t\t\tmono_native_text=\"AppleTV Device\"\n\t\t\t\tMONO_NATIVE_PLATFORM_TYPE=\"MONO_NATIVE_PLATFORM_TYPE_IOS | MONO_NATIVE_PLATFORM_TYPE_TV | MONO_NATIVE_PLATFORM_TYPE_DEVICE\"\n\t\t\tfi\n\t\t\tmono_native_unified_version=\"10.0\"\n\t\t\tmono_native_compat_check=\"__TV_OS_VERSION_MIN_REQUIRED >= __TVOS_10_0\"\n\t\t], [\n\t\t\tAC_MONO_APPLE_TARGET(TARGET_OS_WATCH, [\n\t\t\t\tif test x$mono_native_ios_sim = xyes; then\n\t\t\t\t\tmono_native_ios_target=watchos-simulator\n\t\t\t\t\tmono_native_text=\"Apple Watch Simulator\"\n\t\t\t\t\tMONO_NATIVE_PLATFORM_TYPE=\"MONO_NATIVE_PLATFORM_TYPE_IOS | MONO_NATIVE_PLATFORM_TYPE_WATCH | MONO_NATIVE_PLATFORM_TYPE_SIMULATOR\"\n\t\t\t\telse\n\t\t\t\t\tmono_native_ios_target=watchos\n\t\t\t\t\tmono_native_text=\"Apple Watch Device\"\n\t\t\t\t\tMONO_NATIVE_PLATFORM_TYPE=\"MONO_NATIVE_PLATFORM_TYPE_IOS | MONO_NATIVE_PLATFORM_TYPE_WATCH | MONO_NATIVE_PLATFORM_TYPE_DEVICE\"\n\t\t\t\tfi\n\t\t\t\tmono_native_unified_version=\"5.0\"\n\t\t\t\tmono_native_compat_check=\"__WATCH_OS_VERSION_MIN_REQUIRED >= __WATCHOS_5_0\"\n\t\t\t], [\n\t\t\t\tAC_MSG_ERROR([Unknown iOS Target])\n\t\t\t])\n\t\t])\n\t])\n\n\tAC_MONO_APPLE_AVAILABLE(mono_native_compat, [whether we need the compatibility layer], [!($mono_native_compat_check)])\n\n\tif test x$with_bitcode = xyes; then\n\t\tmono_native_ldflags=\"-framework CoreFoundation -framework Foundation -no-undefined -fatal_warnings\"\n\t\tMONO_NATIVE_LIBADD=\"../mini/$LIBMONO_LA\"\n\telse\n\t\tmono_native_ldflags=\"-framework CoreFoundation -framework Foundation -fatal_warnings\"\n\tfi\n\n\tif test x$enable_gss = xyes; then\n\t\tmono_native_ldflags=\"$mono_native_ldflags -framework GSS\"\n\tfi\n\n\tMONO_NATIVE_CC=$CC\n\tMONO_NATIVE_CXX=$CXX\n\tMONO_NATIVE_CCASFLAGS=$CCASFLAGS\n\tMONO_NATIVE_CPPFLAGS=$CPPFLAGS\n\tMONO_NATIVE_CXXFLAGS=$CXXFLAGS\n\tMONO_NATIVE_CFLAGS=$CFLAGS\n\tMONO_NATIVE_LDFLAGS=\"$LDFLAGS $mono_native_ldflags\"\n\n\tif test x$mono_native_compat = xyes; then\n\t\tmono_native_text=\"$mono_native_text (compat + unified v$mono_native_unified_version)\"\n\t\tMONO_NATIVE_COMPAT_CCASFLAGS=$MONO_NATIVE_CCASFLAGS\n\t\tMONO_NATIVE_COMPAT_CPPFLAGS=$MONO_NATIVE_CPPFLAGS\n\t\tMONO_NATIVE_COMPAT_CXXFLAGS=$MONO_NATIVE_CXXFLAGS\n\t\tMONO_NATIVE_COMPAT_CFLAGS=$MONO_NATIVE_CFLAGS\n\t\tMONO_NATIVE_COMPAT_LDFLAGS=$MONO_NATIVE_LDFLAGS\n\n\t\tsed_remove_ios_version_pattern=\"s/-m\\(.*\\)-version-min=$sed_version_pattern//g\"\n\t\tMONO_NATIVE_UNIFIED_CCASFLAGS=\"`echo $CCASFLAGS | sed -e $sed_remove_ios_version_pattern` -m$mono_native_ios_target-version-min=$mono_native_unified_version\"\n\t\tMONO_NATIVE_UNIFIED_CPPFLAGS=\"`echo $CPPFLAGS | sed -e $sed_remove_ios_version_pattern` -m$mono_native_ios_target-version-min=$mono_native_unified_version\"\n\t\tMONO_NATIVE_UNIFIED_CXXFLAGS=\"`echo $CXXFLAGS | sed -e $sed_remove_ios_version_pattern` -m$mono_native_ios_target-version-min=$mono_native_unified_version\"\n\t\tMONO_NATIVE_UNIFIED_CFLAGS=\"`echo $CFLAGS | sed -e $sed_remove_ios_version_pattern` -m$mono_native_ios_target-version-min=$mono_native_unified_version\"\n\t\tMONO_NATIVE_UNIFIED_LDFLAGS=\"`echo $LDFLAGS $mono_native_ldflags | sed -e $sed_remove_ios_version_pattern` -m$mono_native_ios_target-version-min=$mono_native_unified_version\"\n\tfi\n\n\tmono_native=yes\n\tMONO_NATIVE_PLATFORM=ios\nelif test x$host_linux = xyes; then\n\tmono_native_text=\"Linux\"\n\tMONO_NATIVE_CC=$CC\n\tMONO_NATIVE_CXX=$CXX\n\tMONO_NATIVE_CCASFLAGS=$CCASFLAGS\n\tMONO_NATIVE_CPPFLAGS=$CPPFLAGS\n\tMONO_NATIVE_CXXFLAGS=$CXXFLAGS\n\tMONO_NATIVE_CFLAGS=$CFLAGS\n\tMONO_NATIVE_LDFLAGS=$LDFLAGS\n\tif test x$enable_gss = xyes; then\n\t\tMONO_NATIVE_LDFLAGS=\"$MONO_NATIVE_LDFLAGS -lgssapi_krb5\"\n\telse\n\t\tAC_MSG_WARN([GSS is not enabled, it requires libkrb5-dev package])\n\tfi\n\tmono_native=yes\n\tmono_native_compat=no\n\tMONO_NATIVE_PLATFORM=linux\n\n\tMONO_NATIVE_PLATFORM_TYPE=\"MONO_NATIVE_PLATFORM_TYPE_LINUX\"\nelif test x$target_wasm = xyes; then\n\tmono_native_text=\"wasm\"\n\tMONO_NATIVE_CC=$CC\n\tMONO_NATIVE_CXX=$CXX\n\tMONO_NATIVE_CCASFLAGS=$CCASFLAGS\n\t# The system.native code uses _WASM_ to check for wasm\n\tMONO_NATIVE_CPPFLAGS=\"$CPPFLAGS -D_WASM_\"\n\tMONO_NATIVE_CXXFLAGS=$CXXFLAGS\n\tMONO_NATIVE_CFLAGS=$CFLAGS\n\tMONO_NATIVE_LDFLAGS=$LDFLAGS\n\n\tmono_native=yes\n\tmono_native_compat=no\n\tMONO_NATIVE_PLATFORM=linux\n\n\tMONO_NATIVE_PLATFORM_TYPE=\"MONO_NATIVE_PLATFORM_TYPE_LINUX\"\nelif case $host_os in aix*|os400*) true;; *) false;; esac; then\n\tmono_native_text=\"AIX\"\n\tMONO_NATIVE_CC=$CC\n\tMONO_NATIVE_CXX=$CXX\n\tMONO_NATIVE_CCASFLAGS=$CCASFLAGS\n\tMONO_NATIVE_CPPFLAGS=$CPPFLAGS\n\tMONO_NATIVE_CXXFLAGS=$CXXFLAGS\n\tMONO_NATIVE_CFLAGS=$CFLAGS\n\tdnl nosymbolic- is a hack in case -G for linking is used, as -G seems\n\tdnl to change the way unresolved symbols work on library load in an\n\tdnl incompatible manner. (as references to runtime functions are\n\tdnl resolved later) Default params otherwise are that, so seems OK.\n\tdnl Likewise, we don't seem to need to cover the entire runtime with\n\tdnl it either, on both AIX and PASE. -brtl from -G does seem to spew\n\tdnl Big Scary TOC Warnings (tm) from the linker, but it doesn't seem\n\tdnl problematic with gcc's -mminimal-toc.\n\tdnl ----\n\tdnl flock in AIX exists in libbsd (not the same as freedesktop.org\n\tdnl libbsd) which Mono.Native needs.\n\tdnl Because of the way that the library is built by default, unresolved\n\tdnl references are kept and resolved at runtime. Often, the dependency\n\tdnl chain means libbsd is loaded anyways, but not necessarily. It's\n\tdnl better to explicitly link it, even though it has it shadows libc's\n\tdnl ioctl with its own. (As for the other unresolved imports, those\n\tdnl should be provided by the Mono runtime loaded.)\n\tMONO_NATIVE_LDFLAGS=\"$LDFLAGS -lbsd -Wl,-bnosymbolic-\"\n\n\tmono_native=yes\n\tmono_native_compat=no\n\tMONO_NATIVE_PLATFORM=aix\n\n\tMONO_NATIVE_PLATFORM_TYPE=\"MONO_NATIVE_PLATFORM_TYPE_AIX\"\nelif case $host_os in freebsd*) true;; *) false;; esac; then\n\tmono_native_text=\"FreeBSD\"\n\tMONO_NATIVE_CC=$CC\n\tMONO_NATIVE_CXX=$CXX\n\tMONO_NATIVE_CPPFLAGS=$CPPFLAGS\n\tMONO_NATIVE_CXXFLAGS=$CXXFLAGS\n\tMONO_NATIVE_CFLAGS=$CFLAGS\n\tMONO_NATIVE_LDFLAGS=$LDFLAGS\n\n\tmono_native=yes\n\tmono_native_compat=no\n\tMONO_NATIVE_PLATFORM=freebsd\n\tAC_MSG_CHECKING([Mono.Native support])\n\tAC_MSG_RESULT(freebsd)\n\n\tMONO_NATIVE_PLATFORM_TYPE=\"MONO_NATIVE_PLATFORM_TYPE_FREEBSD\"\nelif case $host_os in netbsd*) true;; *) false;; esac; then\n\tmono_native_text=\"NetBSD\"\n\tMONO_NATIVE_CC=$CC\n\tMONO_NATIVE_CXX=$CXX\n\tMONO_NATIVE_CPPFLAGS=$CPPFLAGS\n\tMONO_NATIVE_CXXFLAGS=$CXXFLAGS\n\tMONO_NATIVE_CFLAGS=$CFLAGS\n\tMONO_NATIVE_LDFLAGS=$LDFLAGS\n\n\tmono_native=yes\n\tmono_native_compat=no\n\tMONO_NATIVE_PLATFORM=netbsd\n\tAC_MSG_CHECKING([Mono.Native support])\n\tAC_MSG_RESULT(netbsd)\n\n\tMONO_NATIVE_PLATFORM_TYPE=\"MONO_NATIVE_PLATFORM_TYPE_NETBSD\"\nelif case $host_os in haiku*) true;; *) false;; esac; then\n\tmono_native_text=\"Haiku\"\n\tMONO_NATIVE_CC=$CC\n\tMONO_NATIVE_CXX=$CXX\n\tMONO_NATIVE_CPPFLAGS=$CPPFLAGS\n\tMONO_NATIVE_CXXFLAGS=$CXXFLAGS\n\tMONO_NATIVE_CFLAGS=$CFLAGS\n\tMONO_NATIVE_LDFLAGS=$LDFLAGS\n\n\tmono_native=yes\n\tmono_native_compat=no\n\tMONO_NATIVE_PLATFORM=haiku\n\tAC_MSG_CHECKING([Mono.Native support])\n\tAC_MSG_RESULT(haiku)\n\n\tMONO_NATIVE_PLATFORM_TYPE=\"MONO_NATIVE_PLATFORM_TYPE_HAIKU\"\nelif test x$platform_android = xyes; then\n\tmono_native_text=\"Android\"\n\tMONO_NATIVE_CC=$CC\n\tMONO_NATIVE_CXX=$CXX\n\tMONO_NATIVE_CPPFLAGS=$CPPFLAGS\n\tMONO_NATIVE_CXXFLAGS=$CXXFLAGS\n\tMONO_NATIVE_CFLAGS=$CFLAGS\n\tMONO_NATIVE_LDFLAGS=$LDFLAGS\n\tMONO_NATIVE_LIBADD=\"../mini/$LIBMONO_LA\"\n\n\tmono_native=yes\n\tmono_native_compat=no\n\tMONO_NATIVE_PLATFORM=android\n\n\tMONO_NATIVE_PLATFORM_TYPE=\"MONO_NATIVE_PLATFORM_TYPE_ANDROID\"\nelse\n\tmono_native=no\n\tmono_native_text=\"no\"\nfi\n\nAC_MSG_RESULT($mono_native_text)\n\nif test x$mono_native_compat = xyes; then\n\tMONO_NATIVE_LIBRARY_NAME=libmono-native-compat\nelse\n\tMONO_NATIVE_LIBRARY_NAME=libmono-native\nfi\n\nAC_SUBST(MONO_NATIVE_PLATFORM)\nAC_SUBST(MONO_NATIVE_CC)\nAC_SUBST(MONO_NATIVE_CXX)\nAC_SUBST(MONO_NATIVE_CCASFLAGS)\nAC_SUBST(MONO_NATIVE_COMPAT_CCASFLAGS)\nAC_SUBST(MONO_NATIVE_UNIFIED_CCASFLAGS)\nAC_SUBST(MONO_NATIVE_CPPFLAGS)\nAC_SUBST(MONO_NATIVE_COMPAT_CPPFLAGS)\nAC_SUBST(MONO_NATIVE_UNIFIED_CPPFLAGS)\nAC_SUBST(MONO_NATIVE_CXXFLAGS)\nAC_SUBST(MONO_NATIVE_COMPAT_CXXFLAGS)\nAC_SUBST(MONO_NATIVE_UNIFIED_CXXFLAGS)\nAC_SUBST(MONO_NATIVE_CFLAGS)\nAC_SUBST(MONO_NATIVE_COMPAT_CFLAGS)\nAC_SUBST(MONO_NATIVE_UNIFIED_CFLAGS)\nAC_SUBST(MONO_NATIVE_LDFLAGS)\nAC_SUBST(MONO_NATIVE_COMPAT_LDFLAGS)\nAC_SUBST(MONO_NATIVE_UNIFIED_LDFLAGS)\nAC_SUBST(MONO_NATIVE_LIBRARY_NAME)\nAC_SUBST(MONO_NATIVE_LIBADD)\n\nAM_CONDITIONAL(MONO_NATIVE, test x$mono_native = xyes)\nAM_CONDITIONAL(MONO_NATIVE_COMPAT, test x$mono_native_compat = xyes)\nAM_CONDITIONAL(MONO_NATIVE_PLATFORM_MACOS, test x$MONO_NATIVE_PLATFORM = xmacos)\nAM_CONDITIONAL(MONO_NATIVE_PLATFORM_IOS, test x$MONO_NATIVE_PLATFORM = xios)\nAM_CONDITIONAL(MONO_NATIVE_PLATFORM_LINUX, test x$MONO_NATIVE_PLATFORM = xlinux)\nAM_CONDITIONAL(MONO_NATIVE_PLATFORM_AIX, test x$MONO_NATIVE_PLATFORM = xaix)\nAM_CONDITIONAL(MONO_NATIVE_PLATFORM_ANDROID, test x$MONO_NATIVE_PLATFORM = xandroid)\nAM_CONDITIONAL(MONO_NATIVE_PLATFORM_FREEBSD, test x$MONO_NATIVE_PLATFORM = xfreebsd)\nAM_CONDITIONAL(MONO_NATIVE_PLATFORM_NETBSD, test x$MONO_NATIVE_PLATFORM = xnetbsd)\nAM_CONDITIONAL(MONO_NATIVE_PLATFORM_HAIKU, test x$MONO_NATIVE_PLATFORM = xhaiku)\n\nMONO_NATIVE_PLATFORM_TYPE_COMPAT=\"$MONO_NATIVE_PLATFORM_TYPE | MONO_NATIVE_PLATFORM_TYPE_COMPAT\"\nMONO_NATIVE_PLATFORM_TYPE_UNIFIED=\"$MONO_NATIVE_PLATFORM_TYPE | MONO_NATIVE_PLATFORM_TYPE_UNIFIED\"\nAC_SUBST(MONO_NATIVE_PLATFORM_TYPE)\nAC_SUBST(MONO_NATIVE_PLATFORM_TYPE_COMPAT)\nAC_SUBST(MONO_NATIVE_PLATFORM_TYPE_UNIFIED)\n\n### C++ Linker selection\n#\n# We have to lie to autotools, sometimes.\n#\n# If we're building with llvm compiled into Mono, set MONO_CXXLD to CXX,\n# otherwise to CC.  We want C linking even if we're compiling with C++ enabled\n# because we do not want to link inthe C++ runtime library (-lstdc++ or -lc++),\n# except if we're linking with LLVM which relies on it.\n#\n# Explanation of the hack:\n#\n# According to\n# https://www.gnu.org/software/automake/manual/html_node/How-the-Linker-is-Chosen.html,\n# automake chooses the linker that it used to compile a target based on the\n# _SOURCES for that target.  If the target is comprised of only C code, it\n# chooses the C linker (on Linux and OSX this is just gcc or clang called with\n# linker arguments and a -o).  If the target _SOURCES include at least one C++ file, \n# then automake chooses the C++ linker (usually g++ or clang++ called with linker arguments and -o).\n#\n# The problem for Mono is that we don't want the C++ runtime library (libstdc++\n# or libc++) linked in - even when Mono is written in C++, we take care not to\n# require the runtime library.  As a result, we don't want g++ or clang++ to do\n# the linking.  On the other hand if LLVM is enabled, then we _must_ use the\n# C++ linker - LLVM doesn't have the same restrictions.\n#\n# So the trick is we set MONO_CXXLD here to $CXX or $CC and in\n#  mono/mini/Makefile.am.in we have CCLD=$MONO_CXXLD and CXXLD=$MONO_CXXLD which bypasses\n#  automake's autodetection and lets us use the linker that we want.\n#\nif test \"x$enable_llvm_runtime\" = \"xyes\"; then\n\tAC_SUBST(MONO_CXXLD, [$CXX])\nelse\n\tAC_SUBST(MONO_CXXLD, [$CC])\nfi\n\n### Set -Werror options\n#\n# Anything involving -Werror must be done late because autoconf depends on compiling with warnings to be success.\n#\nif test x\"$GCC\" = xyes; then\n\n\tif test \"x$with_jemalloc\" != \"xyes\"; then\n\n\t\t# incompatible-pointer-types requires gcc circa 5.x\n\n\t\tORIG_CFLAGS=$CFLAGS\n\t\tCFLAGS=\"$CFLAGS -Wincompatible-pointer-types -Werror\"\n\t\tAC_MSG_CHECKING(for -Wincompatible-pointer-types option to gcc)\n\t\tAC_TRY_COMPILE([],[\n\t\t], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tCFLAGS=\"$ORIG_CFLAGS -Werror=incompatible-pointer-types\"\n\t\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t\t\tCFLAGS=$ORIG_CFLAGS\n\t\t])\n\n\t\tCFLAGS=\"$CFLAGS -Werror=return-type\"\n\tfi\n\n\t# Implicit function declarations are not 64 bit safe\n\t# Do this late, since this causes lots of configure tests to fail\n\tCFLAGS=\"$CFLAGS -Werror-implicit-function-declaration\"\n\t# jay has a lot of implicit declarations\n\tJAY_CFLAGS=\"-Wno-implicit-function-declaration\"\nfi\n\n# zlib/configure checks if this program compiles and if so\n# defines _LARGEFILE64_SOURCE on the compiler command line (not config.h).\n#\nAC_MSG_CHECKING([for large file support])\nAC_COMPILE_IFELSE(\n\t[AC_LANG_SOURCE([\n\t\t#include <sys/types.h>\n\t\toff64_t dummy = 0;\n\t])], [\n\t\tAC_MSG_RESULT(yes)\n\t\t# FIXME The ramifications of _LARGEFILE64_SOURCE are not understood.\n\t\t# ZLIB_CFLAGS=\"$ZLIB_CFLAGS -D_LARGEFILE64_SOURCE=1\"\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\nAC_SUBST(CFLAGS)\nAC_SUBST(CPPFLAGS)\nAC_SUBST(LDFLAGS)\nAC_SUBST(ZLIB_CFLAGS)\n\n# Update all submodules recursively to ensure everything is checked out\nif test \"x$with_core\" != \"xonly\"; then\n\t(cd $srcdir && scripts/update_submodules.sh)\nfi\n\nAC_OUTPUT([\nMakefile\nmono-uninstalled.pc\nacceptance-tests/Makefile\nllvm/Makefile\nscripts/mono-find-provides\nscripts/mono-find-requires\nmk/Makefile\nmono/Makefile\nmono/btls/Makefile\nmono/native/Makefile\nmono/utils/Makefile\nmono/utils/jemalloc/Makefile\nmono/metadata/Makefile\nmono/dis/Makefile\nmono/cil/Makefile\nmono/arch/Makefile\nmono/arch/x86/Makefile\nmono/arch/amd64/Makefile\nmono/arch/ppc/Makefile\nmono/arch/sparc/Makefile\nmono/arch/s390x/Makefile\nmono/arch/arm/Makefile\nmono/arch/arm64/Makefile\nmono/arch/mips/Makefile\nmono/arch/riscv/Makefile\nmono/sgen/Makefile\nmono/native/platform-type.c\nmono/native/platform-type-compat.c\nmono/native/platform-type-unified.c\nmono/tests/Makefile\nmono/tests/assembly-load-reference/Makefile\nmono/tests/tests-config\nmono/tests/gc-descriptors/Makefile\nmono/tests/testing_gac/Makefile\nmono/tests/fullaot-mixed/Makefile\nmono/tests/llvmonly-mixed/Makefile\nmono/unit-tests/Makefile\nmono/benchmark/Makefile\nmono/mini/Makefile\nmono/profiler/Makefile\nmono/eglib/Makefile\nmono/eglib/eglib-config.h\nmono/eglib/test/Makefile\nm4/Makefile\nikvm-native/Makefile\nscripts/Makefile\nman/Makefile\ndocs/Makefile\ndata/Makefile\ndata/net_2_0/Makefile\ndata/net_4_0/Makefile\ndata/net_4_5/Makefile\ndata/net_2_0/Browsers/Makefile\ndata/net_4_0/Browsers/Makefile\ndata/net_4_5/Browsers/Makefile\ndata/mint.pc\ndata/mono-2.pc\ndata/monosgen-2.pc\ndata/mono.pc\ndata/mono-cairo.pc\ndata/mono-options.pc\ndata/mono-lineeditor.pc\ndata/monodoc.pc\ndata/dotnet.pc\ndata/dotnet35.pc\ndata/wcf.pc\ndata/cecil.pc\ndata/system.web.extensions_1.0.pc\ndata/system.web.extensions.design_1.0.pc\ndata/system.web.mvc.pc\ndata/system.web.mvc2.pc\ndata/system.web.mvc3.pc\ndata/aspnetwebstack.pc\ndata/reactive.pc\nsamples/Makefile\nsupport/Makefile\ndata/config\ntools/Makefile\ntools/locale-builder/Makefile\ntools/sgen/Makefile\ntools/pedump/Makefile\ntools/mono-hang-watchdog/Makefile\nruntime/Makefile\nmsvc/Makefile\npo/Makefile\nnetcore/corerun/Makefile\n])\n\nif test x$host_win32 = xyes; then\n   # Get rid of 'cyg' prefixes in library names\n   sed -e \"s/\\/cyg\\//\\/\\//\" libtool > libtool.new; mv libtool.new libtool; chmod 755 libtool\n   # libtool seems to inherit -mno-cygwin from our CFLAGS, and uses it to compile its executable\n   # wrapper scripts which use exec(). gcc has no problem compiling+linking this, but the resulting\n   # executable doesn't work...\n   sed -e \"s,-mno-cygwin,,g\" libtool > libtool.new; mv libtool.new libtool; chmod 755 libtool\nfi\n\nif test x$host_darwin = xyes; then\n   # This doesn't seem to be required and it slows down parallel builds\n   sed -e 's,lock_old_archive_extraction=yes,lock_old_archive_extraction=no,g' < libtool > libtool.new && mv libtool.new libtool && chmod +x libtool\nfi\n\nforce_enable_compiler_server=no;\n\nAC_MSG_CHECKING([compiler server])\nAC_ARG_WITH(compiler-server, [  --with-compiler-server=yes,no,default,force      Enables or disables compiler server],[\n   if test x$withval = xyes; then\n       enable_compiler_server=yes;\n   # force will bypass any automatic disables to allow you to test the compiler server\n   #  in scenarios where it is disabled\n   elif test x$withval = xforce; then\n       enable_compiler_server=yes;\n       force_enable_compiler_server=yes;\n   elif test x$withval = xno; then\n       enable_compiler_server=no;\n   elif test x$withval = xdefault; then\n       enable_compiler_server=yes;\n   else\n       AC_MSG_ERROR([You must supply one of \"yes\", \"no\", \"default\" or \"force\" to the --with-compiler-server option])\n   fi\n],[enable_compiler_server=yes])\n\nAC_MSG_RESULT($enable_compiler_server)\n\nif test x$enable_compiler_server = xyes; then\n   if test x$force_enable_compiler_server = xyes; then\n       AC_MSG_WARN([forcing compiler server to stay enabled])\n   elif test x$host_darwin = xyes || test x$host_win32 = xyes; then\n       AC_MSG_WARN([compiler server temporarily disabled on darwin and win32])\n       enable_compiler_server=no;\n   elif test x$csc_compiler = xmcs; then\n       AC_MSG_WARN([mcs does not support the compiler server])\n       enable_compiler_server=no;\n   fi\nfi\n\n(\n  case $prefix in\n  NONE) prefix=$ac_default_prefix ;;\n  esac\n  case $exec_prefix in\n  NONE) exec_prefix='${prefix}' ;;\n  esac\n\n  #\n  # If we are cross compiling, we don't build in the mcs/ tree.  Let us not clobber\n  # any existing config.make.  This allows people to share the same source tree\n  # with different build directories, one native and one cross\n  #\n  if test x$cross_compiling = xno && test x$enable_mcs_build != xno; then\n\n    test -w $mcs_topdir/build || chmod +w $mcs_topdir/build\n\n    echo \"prefix=$prefix\" > $mcs_topdir/build/config.make\n    echo \"exec_prefix=$exec_prefix\" >> $mcs_topdir/build/config.make\n    echo \"sysconfdir=$sysconfdir\" >> $mcs_topdir/build/config.make\n    echo 'mono_libdir=${exec_prefix}/lib' >> $mcs_topdir/build/config.make\n    echo \"mono_build_root=$mono_build_root\" >> $mcs_topdir/build/config.make\n    echo \"RUNTIME = $mono_build_root/runtime/mono-wrapper\" >> $mcs_topdir/build/config.make\n    echo \"JAY_CFLAGS = $JAY_CFLAGS\" >> $mcs_topdir/build/config.make\n    echo \"VERSION = $VERSION\" >> $mcs_topdir/build/config.make\n\n    case $INSTALL in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) mcs_INSTALL=$INSTALL ;;\n    *) mcs_INSTALL=$mono_build_root/$INSTALL ;;\n    esac\n\n    echo \"INSTALL = $mcs_INSTALL\" >> $mcs_topdir/build/config.make\n\n    export VERSION\n    [myver=$($AWK 'BEGIN {\n      split (ENVIRON[\"VERSION\"] \".0.0.0\", vsplit, \".\")\n      if(length(vsplit [1]) > 4) {\n        split (substr(ENVIRON[\"VERSION\"], 0, 4) \".\" substr(ENVIRON[\"VERSION\"], 5) \".0.0\", vsplit, \".\")\n      }\n      print vsplit [1] \".\" vsplit [2] \".\" vsplit [3] \".\" vsplit [4]\n    }')]\n\n    echo \"MONO_VERSION = $myver\" >> $mcs_topdir/build/config.make\n    echo \"MONO_CORLIB_VERSION = $MONO_CORLIB_VERSION\" >> $mcs_topdir/build/config.make\n\n    if test x$host_darwin = xyes; then\n      echo \"BUILD_PLATFORM = macos\" >> $mcs_topdir/build/config.make\n      echo \"HOST_PLATFORM ?= macos\" >> $mcs_topdir/build/config.make\n      echo \"XTEST_PLATFORM ?= osx\" >> $mcs_topdir/build/config.make\n    elif test x$host_win32 = xyes; then\n      echo \"BUILD_PLATFORM = win32\" >> $mcs_topdir/build/config.make\n      echo \"HOST_PLATFORM ?= win32\" >> $mcs_topdir/build/config.make\n      echo \"XTEST_PLATFORM ?= windows\" >> $mcs_topdir/build/config.make\n    elif test x$host_linux = xyes; then\n      echo \"BUILD_PLATFORM = linux\" >> $mcs_topdir/build/config.make\n      echo \"HOST_PLATFORM ?= linux\" >> $mcs_topdir/build/config.make\n      echo \"XTEST_PLATFORM ?= linux\" >> $mcs_topdir/build/config.make\n    else\n      echo \"BUILD_PLATFORM = unix\" >> $mcs_topdir/build/config.make\n      echo \"HOST_PLATFORM ?= unix\" >> $mcs_topdir/build/config.make\n      echo \"XTEST_PLATFORM ?= unix\" >> $mcs_topdir/build/config.make\n    fi\n\n    echo \"PLATFORM_AOT_PREFIX = $PLATFORM_AOT_PREFIX\" >> $mcs_topdir/build/config.make\n    if test \"x$PLATFORM_AOT_SUFFIX\" != \"x\"; then\n      echo \"PLATFORM_AOT_SUFFIX = $PLATFORM_AOT_SUFFIX\" >> $mcs_topdir/build/config.make\n    fi\n\n\tif test x$AOT_SUPPORTED = xyes -a x$enable_system_aot = xdefault; then\n\t   enable_system_aot=yes\n\tfi\n\n    if test x$host_win32 = xno -a x$enable_system_aot = xyes; then\n      echo \"ENABLE_AOT = 1\" >> $mcs_topdir/build/config.make\n    fi\n\n    if test x$DISABLE_MCS_DOCS = xyes; then\n      echo \"DISABLE_MCS_DOCS = yes\" >> $mcs_topdir/build/config.make\n    fi\n\n    if test x$has_extension_module != xno; then\n        echo \"EXTENSION_MODULE = 1\" >> $srcdir/$mcsdir/build/config.make\n    fi\n    \n    echo \"DEFAULT_PROFILE = $default_profile\" >> $srcdir/$mcsdir/build/config.make\n    \n    if test \"x$test_bcl_opt\" = \"xyes\"; then    \n      echo \"BCL_OPTIMIZE = 1\" >> $srcdir/$mcsdir/build/config.make\n    fi\n\n    echo \"STANDALONE_CSC_LOCATION=$CSC_LOCATION\" >> $srcdir/$mcsdir/build/config.make\n    echo \"SERVER_CSC_LOCATION?=$CSC_LOCATION\" >> $srcdir/$mcsdir/build/config.make\n    echo \"VBCS_LOCATION?=$VBCS_LOCATION\" >> $srcdir/$mcsdir/build/config.make\n\n    if test $csc_compiler = mcs; then\n      echo \"MCS_MODE = 1\" >> $srcdir/$mcsdir/build/config.make\n    fi\n\n    if test \"x$AOT_BUILD_FLAGS\" != \"x\" ; then\n      echo \"AOT_RUN_FLAGS=$AOT_RUN_FLAGS\" >> $srcdir/$mcsdir/build/config.make\n      echo \"AOT_BUILD_ATTRS=$AOT_BUILD_ATTRS\" >> $srcdir/$mcsdir/build/config.make\n\n      if test \"x$internal_llvm\" != \"xno\" && test \"x$enable_llvm_msvc_only\" = \"xno\"; then\n        echo \"AOT_BUILD_FLAGS=$AOT_BUILD_FLAGS,$MONO_LLVM_PATH_OPTION\" >> $srcdir/$mcsdir/build/config.make\n      else\n        echo \"AOT_BUILD_FLAGS=$AOT_BUILD_FLAGS\" >> $srcdir/$mcsdir/build/config.make\n      fi\n    fi\n\n    if test \"x$AOT_MODE\" != \"x\" ; then\n      echo \"AOT_MODE=$AOT_MODE\" >> $srcdir/$mcsdir/build/config.make\n    fi\n\n    if test \"x$enable_btls\" = \"xyes\"; then\n      echo \"HAVE_BTLS=1\" >> $srcdir/$mcsdir/build/config.make\n    fi\n\n    if test \"x$mono_native\" = \"xyes\"; then\n      echo \"MONO_NATIVE_SUPPORTED=true\" >> $srcdir/$mcsdir/build/config.make\n    else\n      echo \"MONO_NATIVE_SUPPORTED=false\" >> $srcdir/$mcsdir/build/config.make\n    fi\n\n    if test x$mono_native_compat = xyes; then\n      echo \"MONO_NATIVE_USING_COMPAT=true\" >> $srcdir/$mcsdir/build/config.make\n    else\n      echo \"MONO_NATIVE_USING_COMPAT=false\" >> $srcdir/$mcsdir/build/config.make\n    fi\n\n    echo \"MONO_NATIVE_PLATFORM_TYPE=$MONO_NATIVE_PLATFORM_TYPE\" >> $srcdir/$mcsdir/build/config.make\n    echo \"MONO_NATIVE_PLATFORM=$MONO_NATIVE_PLATFORM\" >> $srcdir/$mcsdir/build/config.make\n    if test x$enable_compiler_server = xyes; then\n      echo \"ENABLE_COMPILER_SERVER?=1\" >> $srcdir/$mcsdir/build/config.make\n    else\n      echo \"ENABLE_COMPILER_SERVER?=0\" >> $srcdir/$mcsdir/build/config.make\n    fi\n    echo \"COMPILER_SERVER_PIPENAME?=monomake\" >> $srcdir/$mcsdir/build/config.make\n\n\tif test x$enable_msvc_only = xyes; then\n\t\techo \"ENABLE_MSVC_ONLY=1\" >> $srcdir/$mcsdir/build/config.make\n\tfi\n\n  fi\n\n)\n\nlibgdiplus_msg=${libgdiplus_loc:-assumed to be installed}\n\nbtls_platform_string=\nif test x$enable_btls = xyes; then\n\tif test x$btls_android = xyes; then\n\t\tbtls_platform_string=\" (android:$BTLS_PLATFORM)\"\n\telse\n\t\tbtls_platform_string=\" ($BTLS_PLATFORM)\"\n\tfi\nfi\n\nthread_suspend_msg=\nif test x$buildsgen = xyes; then\n\tif test x$enable_cooperative_suspend != xno; then\n\t\tthread_suspend_msg=\"Suspend:       Cooperative\"\n\telif test x$enable_hybrid_suspend != xno; then\n\t\tthread_suspend_msg=\"Suspend:       Hybrid\"\n\telse\n\t\tthread_suspend_msg=\"Suspend:       Preemptive\"\n\tfi\nfi\n\nif test \"x$with_core\" = \"xonly\"; then\n  if test ! -d netcore; then\n    # Out of tree builds\n    mkdir -p netcore\n    echo \"all:\" > netcore/Makefile\n  fi\n  echo \"VERSION = $VERSION\" > netcore/config.make\n  echo \"RID = $RID\" >> netcore/config.make\n  echo \"COREARCH = $COREARCH\" >> netcore/config.make\n  echo \"CORETARGETS = $CORETARGETS\" >> netcore/config.make\n  echo \"MONO_CORLIB_VERSION = $MONO_CORLIB_VERSION\" >> netcore/config.make\n\n  if test x$build_darwin = xyes; then\n    echo \"HOST_PLATFORM ?= macos\" >> netcore/config.make\n  elif test x$host_darwin = xyes; then\n    echo \"HOST_PLATFORM ?= macos\" >> netcore/config.make\n  elif test x$host_win32 = xyes; then\n    echo \"HOST_PLATFORM ?= win32\" >> netcore/config.make\n  elif test x$host_linux = xyes; then\n    echo \"HOST_PLATFORM ?= linux\" >> netcore/config.make\n  else\n    echo \"HOST_PLATFORM ?= unix\" >> netcore/config.make\n  fi\nfi\n\n\t\necho \"\n\tmcs source:    $mcsdir\n\tC# Compiler:   $csc_compiler\n\tCompilerServer:$enable_compiler_server\n\n   Engine:\n\tHost:\t       $host\n\tTarget:\t       $target\n\tGC:\t       $gc_msg \n\t$thread_suspend_msg\n\tTLS:           $with_tls\n\tSIGALTSTACK:   $with_sigaltstack\n\tEngine:        $jit_status\n\tBigArrays:     $enable_big_arrays\n\tDTrace:        $enable_dtrace\n\tLLVM Back End: $enable_llvm (dynamically loaded: $enable_loadedllvm, built in-tree: $internal_llvm, assertions: $enable_llvm_asserts, msvc only: $enable_llvm_msvc_only)\n\tSpectre:       $spectre_mitigation_status\n\tMono.Native:   $mono_native_text\n\n   Libraries:\n\t.NET 4.x:        $with_profile4_x\n\tXamarin.Android: $with_monodroid\n\tXamarin.iOS:     $with_monotouch\n\tXamarin.WatchOS: $with_monotouch_watch\n\tXamarin.TVOS:    $with_monotouch_tv\n\tXamarin.Mac:     $with_xammac\n\tWindows AOT:     $with_winaot\n\tOrbis:           $with_orbis\n\tUnreal:          $with_unreal\n\tWebAssembly:     $with_wasm\n\tTest profiles:   AOT Full ($with_testing_aot_full), AOT Hybrid ($with_testing_aot_hybrid), AOT Full Interp ($with_testing_aot_full_interp), Windows Full AOT Interp ($with_testing_winaot_interp)\n\tJNI support:     $jdk_headers_found\n\tlibgdiplus:      $libgdiplus_msg\n\tzlib:            $zlib_msg\n\tBTLS:            $enable_btls$btls_platform_string\n\tjemalloc:        $with_jemalloc (always use: $with_jemalloc_always)\n\tcrash reporting: $crash_reporting (private crashes: $with_crash_privacy)\n\t.NET Core:       $with_core\n\t$disabled\n\"\nif test x$with_static_mono = xno -a \"x$host_win32\" != \"xyes\"; then\n   AC_MSG_WARN([Turning off static Mono is a risk, you might run into unexpected bugs])\nfi\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/ltmain.sh": "#! /bin/sh\n## DO NOT EDIT - This file generated from ./build-aux/ltmain.in\n##               by inline-source v2014-01-03.01\n\n# libtool (GNU libtool) 2.4.6\n# Provide generalized library-building support services.\n# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996\n\n# Copyright (C) 1996-2015 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# GNU Libtool is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\nPROGRAM=libtool\nPACKAGE=libtool\nVERSION=\"2.4.6 Debian-2.4.6-0.1\"\npackage_revision=2.4.6\n\n\n## ------ ##\n## Usage. ##\n## ------ ##\n\n# Run './libtool --help' for help with using this script from the\n# command line.\n\n\n## ------------------------------- ##\n## User overridable command paths. ##\n## ------------------------------- ##\n\n# After configure completes, it has a better idea of some of the\n# shell tools we need than the defaults used by the functions shared\n# with bootstrap, so set those here where they can still be over-\n# ridden by the user, but otherwise take precedence.\n\n: ${AUTOCONF=\"autoconf\"}\n: ${AUTOMAKE=\"automake\"}\n\n\n## -------------------------- ##\n## Source external libraries. ##\n## -------------------------- ##\n\n# Much of our low-level functionality needs to be sourced from external\n# libraries, which are installed to $pkgauxdir.\n\n# Set a version string for this script.\nscriptversion=2015-01-20.17; # UTC\n\n# General shell script boiler plate, and helper functions.\n# Written by Gary V. Vaughan, 2004\n\n# Copyright (C) 2004-2015 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 3 of the License, or\n# (at your option) any later version.\n\n# As a special exception to the GNU General Public License, if you distribute\n# this file as part of a program or library that is built using GNU Libtool,\n# you may include this file under the same distribution terms that you use\n# for the rest of that program.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNES FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program. If not, see <http://www.gnu.org/licenses/>.\n\n# Please report bugs or propose patches to gary@gnu.org.\n\n\n## ------ ##\n## Usage. ##\n## ------ ##\n\n# Evaluate this file near the top of your script to gain access to\n# the functions and variables defined here:\n#\n#   . `echo \"$0\" | ${SED-sed} 's|[^/]*$||'`/build-aux/funclib.sh\n#\n# If you need to override any of the default environment variable\n# settings, do that before evaluating this file.\n\n\n## -------------------- ##\n## Shell normalisation. ##\n## -------------------- ##\n\n# Some shells need a little help to be as Bourne compatible as possible.\n# Before doing anything else, make sure all that help has been provided!\n\nDUALCASE=1; export DUALCASE # for MKS sh\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in *posix*) set -o posix ;; esac\nfi\n\n# NLS nuisances: We save the old values in case they are required later.\n_G_user_locale=\n_G_safe_locale=\nfor _G_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\ndo\n  eval \"if test set = \\\"\\${$_G_var+set}\\\"; then\n          save_$_G_var=\\$$_G_var\n          $_G_var=C\n\t  export $_G_var\n\t  _G_user_locale=\\\"$_G_var=\\\\\\$save_\\$_G_var; \\$_G_user_locale\\\"\n\t  _G_safe_locale=\\\"$_G_var=C; \\$_G_safe_locale\\\"\n\tfi\"\ndone\n\n# CDPATH.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\n# Make sure IFS has a sensible default\nsp=' '\nnl='\n'\nIFS=\"$sp\t$nl\"\n\n# There are apparently some retarded systems that use ';' as a PATH separator!\nif test \"${PATH_SEPARATOR+set}\" != set; then\n  PATH_SEPARATOR=:\n  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {\n    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||\n      PATH_SEPARATOR=';'\n  }\nfi\n\n\n\n## ------------------------- ##\n## Locate command utilities. ##\n## ------------------------- ##\n\n\n# func_executable_p FILE\n# ----------------------\n# Check that FILE is an executable regular file.\nfunc_executable_p ()\n{\n    test -f \"$1\" && test -x \"$1\"\n}\n\n\n# func_path_progs PROGS_LIST CHECK_FUNC [PATH]\n# --------------------------------------------\n# Search for either a program that responds to --version with output\n# containing \"GNU\", or else returned by CHECK_FUNC otherwise, by\n# trying all the directories in PATH with each of the elements of\n# PROGS_LIST.\n#\n# CHECK_FUNC should accept the path to a candidate program, and\n# set $func_check_prog_result if it truncates its output less than\n# $_G_path_prog_max characters.\nfunc_path_progs ()\n{\n    _G_progs_list=$1\n    _G_check_func=$2\n    _G_PATH=${3-\"$PATH\"}\n\n    _G_path_prog_max=0\n    _G_path_prog_found=false\n    _G_save_IFS=$IFS; IFS=${PATH_SEPARATOR-:}\n    for _G_dir in $_G_PATH; do\n      IFS=$_G_save_IFS\n      test -z \"$_G_dir\" && _G_dir=.\n      for _G_prog_name in $_G_progs_list; do\n        for _exeext in '' .EXE; do\n          _G_path_prog=$_G_dir/$_G_prog_name$_exeext\n          func_executable_p \"$_G_path_prog\" || continue\n          case `\"$_G_path_prog\" --version 2>&1` in\n            *GNU*) func_path_progs_result=$_G_path_prog _G_path_prog_found=: ;;\n            *)     $_G_check_func $_G_path_prog\n\t\t   func_path_progs_result=$func_check_prog_result\n\t\t   ;;\n          esac\n          $_G_path_prog_found && break 3\n        done\n      done\n    done\n    IFS=$_G_save_IFS\n    test -z \"$func_path_progs_result\" && {\n      echo \"no acceptable sed could be found in \\$PATH\" >&2\n      exit 1\n    }\n}\n\n\n# We want to be able to use the functions in this file before configure\n# has figured out where the best binaries are kept, which means we have\n# to search for them ourselves - except when the results are already set\n# where we skip the searches.\n\n# Unless the user overrides by setting SED, search the path for either GNU\n# sed, or the sed that truncates its output the least.\ntest -z \"$SED\" && {\n  _G_sed_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/\n  for _G_i in 1 2 3 4 5 6 7; do\n    _G_sed_script=$_G_sed_script$nl$_G_sed_script\n  done\n  echo \"$_G_sed_script\" 2>/dev/null | sed 99q >conftest.sed\n  _G_sed_script=\n\n  func_check_prog_sed ()\n  {\n    _G_path_prog=$1\n\n    _G_count=0\n    printf 0123456789 >conftest.in\n    while :\n    do\n      cat conftest.in conftest.in >conftest.tmp\n      mv conftest.tmp conftest.in\n      cp conftest.in conftest.nl\n      echo '' >> conftest.nl\n      \"$_G_path_prog\" -f conftest.sed <conftest.nl >conftest.out 2>/dev/null || break\n      diff conftest.out conftest.nl >/dev/null 2>&1 || break\n      _G_count=`expr $_G_count + 1`\n      if test \"$_G_count\" -gt \"$_G_path_prog_max\"; then\n        # Best one so far, save it but keep looking for a better one\n        func_check_prog_result=$_G_path_prog\n        _G_path_prog_max=$_G_count\n      fi\n      # 10*(2^10) chars as input seems more than enough\n      test 10 -lt \"$_G_count\" && break\n    done\n    rm -f conftest.in conftest.tmp conftest.nl conftest.out\n  }\n\n  func_path_progs \"sed gsed\" func_check_prog_sed $PATH:/usr/xpg4/bin\n  rm -f conftest.sed\n  SED=$func_path_progs_result\n}\n\n\n# Unless the user overrides by setting GREP, search the path for either GNU\n# grep, or the grep that truncates its output the least.\ntest -z \"$GREP\" && {\n  func_check_prog_grep ()\n  {\n    _G_path_prog=$1\n\n    _G_count=0\n    _G_path_prog_max=0\n    printf 0123456789 >conftest.in\n    while :\n    do\n      cat conftest.in conftest.in >conftest.tmp\n      mv conftest.tmp conftest.in\n      cp conftest.in conftest.nl\n      echo 'GREP' >> conftest.nl\n      \"$_G_path_prog\" -e 'GREP$' -e '-(cannot match)-' <conftest.nl >conftest.out 2>/dev/null || break\n      diff conftest.out conftest.nl >/dev/null 2>&1 || break\n      _G_count=`expr $_G_count + 1`\n      if test \"$_G_count\" -gt \"$_G_path_prog_max\"; then\n        # Best one so far, save it but keep looking for a better one\n        func_check_prog_result=$_G_path_prog\n        _G_path_prog_max=$_G_count\n      fi\n      # 10*(2^10) chars as input seems more than enough\n      test 10 -lt \"$_G_count\" && break\n    done\n    rm -f conftest.in conftest.tmp conftest.nl conftest.out\n  }\n\n  func_path_progs \"grep ggrep\" func_check_prog_grep $PATH:/usr/xpg4/bin\n  GREP=$func_path_progs_result\n}\n\n\n## ------------------------------- ##\n## User overridable command paths. ##\n## ------------------------------- ##\n\n# All uppercase variable names are used for environment variables.  These\n# variables can be overridden by the user before calling a script that\n# uses them if a suitable command of that name is not already available\n# in the command search PATH.\n\n: ${CP=\"cp -f\"}\n: ${ECHO=\"printf %s\\n\"}\n: ${EGREP=\"$GREP -E\"}\n: ${FGREP=\"$GREP -F\"}\n: ${LN_S=\"ln -s\"}\n: ${MAKE=\"make\"}\n: ${MKDIR=\"mkdir\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n: ${SHELL=\"${CONFIG_SHELL-/bin/sh}\"}\n\n\n## -------------------- ##\n## Useful sed snippets. ##\n## -------------------- ##\n\nsed_dirname='s|/[^/]*$||'\nsed_basename='s|^.*/||'\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nsed_quote_subst='s|\\([`\"$\\\\]\\)|\\\\\\1|g'\n\n# Same as above, but do not quote variable references.\nsed_double_quote_subst='s/\\([\"`\\\\]\\)/\\\\\\1/g'\n\n# Sed substitution that turns a string into a regex matching for the\n# string literally.\nsed_make_literal_regex='s|[].[^$\\\\*\\/]|\\\\&|g'\n\n# Sed substitution that converts a w32 file name or path\n# that contains forward slashes, into one that contains\n# (escaped) backslashes.  A very naive implementation.\nsed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n\n# Re-'\\' parameter expansions in output of sed_double_quote_subst that\n# were '\\'-ed in input to the same.  If an odd number of '\\' preceded a\n# '$' in input to sed_double_quote_subst, that '$' was protected from\n# expansion.  Since each input '\\' is now two '\\'s, look for any number\n# of runs of four '\\'s followed by two '\\'s and then a '$'.  '\\' that '$'.\n_G_bs='\\\\'\n_G_bs2='\\\\\\\\'\n_G_bs4='\\\\\\\\\\\\\\\\'\n_G_dollar='\\$'\nsed_double_backslash=\"\\\n  s/$_G_bs4/&\\\\\n/g\n  s/^$_G_bs2$_G_dollar/$_G_bs&/\n  s/\\\\([^$_G_bs]\\\\)$_G_bs2$_G_dollar/\\\\1$_G_bs2$_G_bs$_G_dollar/g\n  s/\\n//g\"\n\n\n## ----------------- ##\n## Global variables. ##\n## ----------------- ##\n\n# Except for the global variables explicitly listed below, the following\n# functions in the '^func_' namespace, and the '^require_' namespace\n# variables initialised in the 'Resource management' section, sourcing\n# this file will not pollute your global namespace with anything\n# else. There's no portable way to scope variables in Bourne shell\n# though, so actually running these functions will sometimes place\n# results into a variable named after the function, and often use\n# temporary variables in the '^_G_' namespace. If you are careful to\n# avoid using those namespaces casually in your sourcing script, things\n# should continue to work as you expect. And, of course, you can freely\n# overwrite any of the functions or variables defined here before\n# calling anything to customize them.\n\nEXIT_SUCCESS=0\nEXIT_FAILURE=1\nEXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.\nEXIT_SKIP=77\t  # $? = 77 is used to indicate a skipped test to automake.\n\n# Allow overriding, eg assuming that you follow the convention of\n# putting '$debug_cmd' at the start of all your functions, you can get\n# bash to show function call trace with:\n#\n#    debug_cmd='eval echo \"${FUNCNAME[0]} $*\" >&2' bash your-script-name\ndebug_cmd=${debug_cmd-\":\"}\nexit_cmd=:\n\n# By convention, finish your script with:\n#\n#    exit $exit_status\n#\n# so that you can set exit_status to non-zero if you want to indicate\n# something went wrong during execution without actually bailing out at\n# the point of failure.\nexit_status=$EXIT_SUCCESS\n\n# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh\n# is ksh but when the shell is invoked as \"sh\" and the current value of\n# the _XPG environment variable is not equal to 1 (one), the special\n# positional parameter $0, within a function call, is the name of the\n# function.\nprogpath=$0\n\n# The name of this program.\nprogname=`$ECHO \"$progpath\" |$SED \"$sed_basename\"`\n\n# Make sure we have an absolute progpath for reexecution:\ncase $progpath in\n  [\\\\/]*|[A-Za-z]:\\\\*) ;;\n  *[\\\\/]*)\n     progdir=`$ECHO \"$progpath\" |$SED \"$sed_dirname\"`\n     progdir=`cd \"$progdir\" && pwd`\n     progpath=$progdir/$progname\n     ;;\n  *)\n     _G_IFS=$IFS\n     IFS=${PATH_SEPARATOR-:}\n     for progdir in $PATH; do\n       IFS=$_G_IFS\n       test -x \"$progdir/$progname\" && break\n     done\n     IFS=$_G_IFS\n     test -n \"$progdir\" || progdir=`pwd`\n     progpath=$progdir/$progname\n     ;;\nesac\n\n\n## ----------------- ##\n## Standard options. ##\n## ----------------- ##\n\n# The following options affect the operation of the functions defined\n# below, and should be set appropriately depending on run-time para-\n# meters passed on the command line.\n\nopt_dry_run=false\nopt_quiet=false\nopt_verbose=false\n\n# Categories 'all' and 'none' are always available.  Append any others\n# you will pass as the first argument to func_warning from your own\n# code.\nwarning_categories=\n\n# By default, display warnings according to 'opt_warning_types'.  Set\n# 'warning_func'  to ':' to elide all warnings, or func_fatal_error to\n# treat the next displayed warning as a fatal error.\nwarning_func=func_warn_and_continue\n\n# Set to 'all' to display all warnings, 'none' to suppress all\n# warnings, or a space delimited list of some subset of\n# 'warning_categories' to display only the listed warnings.\nopt_warning_types=all\n\n\n## -------------------- ##\n## Resource management. ##\n## -------------------- ##\n\n# This section contains definitions for functions that each ensure a\n# particular resource (a file, or a non-empty configuration variable for\n# example) is available, and if appropriate to extract default values\n# from pertinent package files. Call them using their associated\n# 'require_*' variable to ensure that they are executed, at most, once.\n#\n# It's entirely deliberate that calling these functions can set\n# variables that don't obey the namespace limitations obeyed by the rest\n# of this file, in order that that they be as useful as possible to\n# callers.\n\n\n# require_term_colors\n# -------------------\n# Allow display of bold text on terminals that support it.\nrequire_term_colors=func_require_term_colors\nfunc_require_term_colors ()\n{\n    $debug_cmd\n\n    test -t 1 && {\n      # COLORTERM and USE_ANSI_COLORS environment variables take\n      # precedence, because most terminfo databases neglect to describe\n      # whether color sequences are supported.\n      test -n \"${COLORTERM+set}\" && : ${USE_ANSI_COLORS=\"1\"}\n\n      if test 1 = \"$USE_ANSI_COLORS\"; then\n        # Standard ANSI escape sequences\n        tc_reset='\u001b[0m'\n        tc_bold='\u001b[1m';   tc_standout='\u001b[7m'\n        tc_red='\u001b[31m';   tc_green='\u001b[32m'\n        tc_blue='\u001b[34m';  tc_cyan='\u001b[36m'\n      else\n        # Otherwise trust the terminfo database after all.\n        test -n \"`tput sgr0 2>/dev/null`\" && {\n          tc_reset=`tput sgr0`\n          test -n \"`tput bold 2>/dev/null`\" && tc_bold=`tput bold`\n          tc_standout=$tc_bold\n          test -n \"`tput smso 2>/dev/null`\" && tc_standout=`tput smso`\n          test -n \"`tput setaf 1 2>/dev/null`\" && tc_red=`tput setaf 1`\n          test -n \"`tput setaf 2 2>/dev/null`\" && tc_green=`tput setaf 2`\n          test -n \"`tput setaf 4 2>/dev/null`\" && tc_blue=`tput setaf 4`\n          test -n \"`tput setaf 5 2>/dev/null`\" && tc_cyan=`tput setaf 5`\n        }\n      fi\n    }\n\n    require_term_colors=:\n}\n\n\n## ----------------- ##\n## Function library. ##\n## ----------------- ##\n\n# This section contains a variety of useful functions to call in your\n# scripts. Take note of the portable wrappers for features provided by\n# some modern shells, which will fall back to slower equivalents on\n# less featureful shells.\n\n\n# func_append VAR VALUE\n# ---------------------\n# Append VALUE onto the existing contents of VAR.\n\n  # We should try to minimise forks, especially on Windows where they are\n  # unreasonably slow, so skip the feature probes when bash or zsh are\n  # being used:\n  if test set = \"${BASH_VERSION+set}${ZSH_VERSION+set}\"; then\n    : ${_G_HAVE_ARITH_OP=\"yes\"}\n    : ${_G_HAVE_XSI_OPS=\"yes\"}\n    # The += operator was introduced in bash 3.1\n    case $BASH_VERSION in\n      [12].* | 3.0 | 3.0*) ;;\n      *)\n        : ${_G_HAVE_PLUSEQ_OP=\"yes\"}\n        ;;\n    esac\n  fi\n\n  # _G_HAVE_PLUSEQ_OP\n  # Can be empty, in which case the shell is probed, \"yes\" if += is\n  # useable or anything else if it does not work.\n  test -z \"$_G_HAVE_PLUSEQ_OP\" \\\n    && (eval 'x=a; x+=\" b\"; test \"a b\" = \"$x\"') 2>/dev/null \\\n    && _G_HAVE_PLUSEQ_OP=yes\n\nif test yes = \"$_G_HAVE_PLUSEQ_OP\"\nthen\n  # This is an XSI compatible shell, allowing a faster implementation...\n  eval 'func_append ()\n  {\n    $debug_cmd\n\n    eval \"$1+=\\$2\"\n  }'\nelse\n  # ...otherwise fall back to using expr, which is often a shell builtin.\n  func_append ()\n  {\n    $debug_cmd\n\n    eval \"$1=\\$$1\\$2\"\n  }\nfi\n\n\n# func_append_quoted VAR VALUE\n# ----------------------------\n# Quote VALUE and append to the end of shell variable VAR, separated\n# by a space.\nif test yes = \"$_G_HAVE_PLUSEQ_OP\"; then\n  eval 'func_append_quoted ()\n  {\n    $debug_cmd\n\n    func_quote_for_eval \"$2\"\n    eval \"$1+=\\\\ \\$func_quote_for_eval_result\"\n  }'\nelse\n  func_append_quoted ()\n  {\n    $debug_cmd\n\n    func_quote_for_eval \"$2\"\n    eval \"$1=\\$$1\\\\ \\$func_quote_for_eval_result\"\n  }\nfi\n\n\n# func_append_uniq VAR VALUE\n# --------------------------\n# Append unique VALUE onto the existing contents of VAR, assuming\n# entries are delimited by the first character of VALUE.  For example:\n#\n#   func_append_uniq options \" --another-option option-argument\"\n#\n# will only append to $options if \" --another-option option-argument \"\n# is not already present somewhere in $options already (note spaces at\n# each end implied by leading space in second argument).\nfunc_append_uniq ()\n{\n    $debug_cmd\n\n    eval _G_current_value='`$ECHO $'$1'`'\n    _G_delim=`expr \"$2\" : '\\(.\\)'`\n\n    case $_G_delim$_G_current_value$_G_delim in\n      *\"$2$_G_delim\"*) ;;\n      *) func_append \"$@\" ;;\n    esac\n}\n\n\n# func_arith TERM...\n# ------------------\n# Set func_arith_result to the result of evaluating TERMs.\n  test -z \"$_G_HAVE_ARITH_OP\" \\\n    && (eval 'test 2 = $(( 1 + 1 ))') 2>/dev/null \\\n    && _G_HAVE_ARITH_OP=yes\n\nif test yes = \"$_G_HAVE_ARITH_OP\"; then\n  eval 'func_arith ()\n  {\n    $debug_cmd\n\n    func_arith_result=$(( $* ))\n  }'\nelse\n  func_arith ()\n  {\n    $debug_cmd\n\n    func_arith_result=`expr \"$@\"`\n  }\nfi\n\n\n# func_basename FILE\n# ------------------\n# Set func_basename_result to FILE with everything up to and including\n# the last / stripped.\nif test yes = \"$_G_HAVE_XSI_OPS\"; then\n  # If this shell supports suffix pattern removal, then use it to avoid\n  # forking. Hide the definitions single quotes in case the shell chokes\n  # on unsupported syntax...\n  _b='func_basename_result=${1##*/}'\n  _d='case $1 in\n        */*) func_dirname_result=${1%/*}$2 ;;\n        *  ) func_dirname_result=$3        ;;\n      esac'\n\nelse\n  # ...otherwise fall back to using sed.\n  _b='func_basename_result=`$ECHO \"$1\" |$SED \"$sed_basename\"`'\n  _d='func_dirname_result=`$ECHO \"$1\"  |$SED \"$sed_dirname\"`\n      if test \"X$func_dirname_result\" = \"X$1\"; then\n        func_dirname_result=$3\n      else\n        func_append func_dirname_result \"$2\"\n      fi'\nfi\n\neval 'func_basename ()\n{\n    $debug_cmd\n\n    '\"$_b\"'\n}'\n\n\n# func_dirname FILE APPEND NONDIR_REPLACEMENT\n# -------------------------------------------\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\neval 'func_dirname ()\n{\n    $debug_cmd\n\n    '\"$_d\"'\n}'\n\n\n# func_dirname_and_basename FILE APPEND NONDIR_REPLACEMENT\n# --------------------------------------------------------\n# Perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# For efficiency, we do not delegate to the functions above but instead\n# duplicate the functionality here.\neval 'func_dirname_and_basename ()\n{\n    $debug_cmd\n\n    '\"$_b\"'\n    '\"$_d\"'\n}'\n\n\n# func_echo ARG...\n# ----------------\n# Echo program name prefixed message.\nfunc_echo ()\n{\n    $debug_cmd\n\n    _G_message=$*\n\n    func_echo_IFS=$IFS\n    IFS=$nl\n    for _G_line in $_G_message; do\n      IFS=$func_echo_IFS\n      $ECHO \"$progname: $_G_line\"\n    done\n    IFS=$func_echo_IFS\n}\n\n\n# func_echo_all ARG...\n# --------------------\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\"\n}\n\n\n# func_echo_infix_1 INFIX ARG...\n# ------------------------------\n# Echo program name, followed by INFIX on the first line, with any\n# additional lines not showing INFIX.\nfunc_echo_infix_1 ()\n{\n    $debug_cmd\n\n    $require_term_colors\n\n    _G_infix=$1; shift\n    _G_indent=$_G_infix\n    _G_prefix=\"$progname: $_G_infix: \"\n    _G_message=$*\n\n    # Strip color escape sequences before counting printable length\n    for _G_tc in \"$tc_reset\" \"$tc_bold\" \"$tc_standout\" \"$tc_red\" \"$tc_green\" \"$tc_blue\" \"$tc_cyan\"\n    do\n      test -n \"$_G_tc\" && {\n        _G_esc_tc=`$ECHO \"$_G_tc\" | $SED \"$sed_make_literal_regex\"`\n        _G_indent=`$ECHO \"$_G_indent\" | $SED \"s|$_G_esc_tc||g\"`\n      }\n    done\n    _G_indent=\"$progname: \"`echo \"$_G_indent\" | $SED 's|.| |g'`\"  \" ## exclude from sc_prohibit_nested_quotes\n\n    func_echo_infix_1_IFS=$IFS\n    IFS=$nl\n    for _G_line in $_G_message; do\n      IFS=$func_echo_infix_1_IFS\n      $ECHO \"$_G_prefix$tc_bold$_G_line$tc_reset\" >&2\n      _G_prefix=$_G_indent\n    done\n    IFS=$func_echo_infix_1_IFS\n}\n\n\n# func_error ARG...\n# -----------------\n# Echo program name prefixed message to standard error.\nfunc_error ()\n{\n    $debug_cmd\n\n    $require_term_colors\n\n    func_echo_infix_1 \"  $tc_standout${tc_red}error$tc_reset\" \"$*\" >&2\n}\n\n\n# func_fatal_error ARG...\n# -----------------------\n# Echo program name prefixed message to standard error, and exit.\nfunc_fatal_error ()\n{\n    $debug_cmd\n\n    func_error \"$*\"\n    exit $EXIT_FAILURE\n}\n\n\n# func_grep EXPRESSION FILENAME\n# -----------------------------\n# Check whether EXPRESSION matches any line of FILENAME, without output.\nfunc_grep ()\n{\n    $debug_cmd\n\n    $GREP \"$1\" \"$2\" >/dev/null 2>&1\n}\n\n\n# func_len STRING\n# ---------------\n# Set func_len_result to the length of STRING. STRING may not\n# start with a hyphen.\n  test -z \"$_G_HAVE_XSI_OPS\" \\\n    && (eval 'x=a/b/c;\n      test 5aa/bb/cc = \"${#x}${x%%/*}${x%/*}${x#*/}${x##*/}\"') 2>/dev/null \\\n    && _G_HAVE_XSI_OPS=yes\n\nif test yes = \"$_G_HAVE_XSI_OPS\"; then\n  eval 'func_len ()\n  {\n    $debug_cmd\n\n    func_len_result=${#1}\n  }'\nelse\n  func_len ()\n  {\n    $debug_cmd\n\n    func_len_result=`expr \"$1\" : \".*\" 2>/dev/null || echo $max_cmd_len`\n  }\nfi\n\n\n# func_mkdir_p DIRECTORY-PATH\n# ---------------------------\n# Make sure the entire path to DIRECTORY-PATH is available.\nfunc_mkdir_p ()\n{\n    $debug_cmd\n\n    _G_directory_path=$1\n    _G_dir_list=\n\n    if test -n \"$_G_directory_path\" && test : != \"$opt_dry_run\"; then\n\n      # Protect directory names starting with '-'\n      case $_G_directory_path in\n        -*) _G_directory_path=./$_G_directory_path ;;\n      esac\n\n      # While some portion of DIR does not yet exist...\n      while test ! -d \"$_G_directory_path\"; do\n        # ...make a list in topmost first order.  Use a colon delimited\n\t# list incase some portion of path contains whitespace.\n        _G_dir_list=$_G_directory_path:$_G_dir_list\n\n        # If the last portion added has no slash in it, the list is done\n        case $_G_directory_path in */*) ;; *) break ;; esac\n\n        # ...otherwise throw away the child directory and loop\n        _G_directory_path=`$ECHO \"$_G_directory_path\" | $SED -e \"$sed_dirname\"`\n      done\n      _G_dir_list=`$ECHO \"$_G_dir_list\" | $SED 's|:*$||'`\n\n      func_mkdir_p_IFS=$IFS; IFS=:\n      for _G_dir in $_G_dir_list; do\n\tIFS=$func_mkdir_p_IFS\n        # mkdir can fail with a 'File exist' error if two processes\n        # try to create one of the directories concurrently.  Don't\n        # stop in that case!\n        $MKDIR \"$_G_dir\" 2>/dev/null || :\n      done\n      IFS=$func_mkdir_p_IFS\n\n      # Bail out if we (or some other process) failed to create a directory.\n      test -d \"$_G_directory_path\" || \\\n        func_fatal_error \"Failed to create '$1'\"\n    fi\n}\n\n\n# func_mktempdir [BASENAME]\n# -------------------------\n# Make a temporary directory that won't clash with other running\n# libtool processes, and avoids race conditions if possible.  If\n# given, BASENAME is the basename for that directory.\nfunc_mktempdir ()\n{\n    $debug_cmd\n\n    _G_template=${TMPDIR-/tmp}/${1-$progname}\n\n    if test : = \"$opt_dry_run\"; then\n      # Return a directory name, but don't create it in dry-run mode\n      _G_tmpdir=$_G_template-$$\n    else\n\n      # If mktemp works, use that first and foremost\n      _G_tmpdir=`mktemp -d \"$_G_template-XXXXXXXX\" 2>/dev/null`\n\n      if test ! -d \"$_G_tmpdir\"; then\n        # Failing that, at least try and use $RANDOM to avoid a race\n        _G_tmpdir=$_G_template-${RANDOM-0}$$\n\n        func_mktempdir_umask=`umask`\n        umask 0077\n        $MKDIR \"$_G_tmpdir\"\n        umask $func_mktempdir_umask\n      fi\n\n      # If we're not in dry-run mode, bomb out on failure\n      test -d \"$_G_tmpdir\" || \\\n        func_fatal_error \"cannot create temporary directory '$_G_tmpdir'\"\n    fi\n\n    $ECHO \"$_G_tmpdir\"\n}\n\n\n# func_normal_abspath PATH\n# ------------------------\n# Remove doubled-up and trailing slashes, \".\" path components,\n# and cancel out any \"..\" path components in PATH after making\n# it an absolute path.\nfunc_normal_abspath ()\n{\n    $debug_cmd\n\n    # These SED scripts presuppose an absolute path with a trailing slash.\n    _G_pathcar='s|^/\\([^/]*\\).*$|\\1|'\n    _G_pathcdr='s|^/[^/]*||'\n    _G_removedotparts=':dotsl\n\t\ts|/\\./|/|g\n\t\tt dotsl\n\t\ts|/\\.$|/|'\n    _G_collapseslashes='s|/\\{1,\\}|/|g'\n    _G_finalslash='s|/*$|/|'\n\n    # Start from root dir and reassemble the path.\n    func_normal_abspath_result=\n    func_normal_abspath_tpath=$1\n    func_normal_abspath_altnamespace=\n    case $func_normal_abspath_tpath in\n      \"\")\n        # Empty path, that just means $cwd.\n        func_stripname '' '/' \"`pwd`\"\n        func_normal_abspath_result=$func_stripname_result\n        return\n        ;;\n      # The next three entries are used to spot a run of precisely\n      # two leading slashes without using negated character classes;\n      # we take advantage of case's first-match behaviour.\n      ///*)\n        # Unusual form of absolute path, do nothing.\n        ;;\n      //*)\n        # Not necessarily an ordinary path; POSIX reserves leading '//'\n        # and for example Cygwin uses it to access remote file shares\n        # over CIFS/SMB, so we conserve a leading double slash if found.\n        func_normal_abspath_altnamespace=/\n        ;;\n      /*)\n        # Absolute path, do nothing.\n        ;;\n      *)\n        # Relative path, prepend $cwd.\n        func_normal_abspath_tpath=`pwd`/$func_normal_abspath_tpath\n        ;;\n    esac\n\n    # Cancel out all the simple stuff to save iterations.  We also want\n    # the path to end with a slash for ease of parsing, so make sure\n    # there is one (and only one) here.\n    func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n          -e \"$_G_removedotparts\" -e \"$_G_collapseslashes\" -e \"$_G_finalslash\"`\n    while :; do\n      # Processed it all yet?\n      if test / = \"$func_normal_abspath_tpath\"; then\n        # If we ascended to the root using \"..\" the result may be empty now.\n        if test -z \"$func_normal_abspath_result\"; then\n          func_normal_abspath_result=/\n        fi\n        break\n      fi\n      func_normal_abspath_tcomponent=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n          -e \"$_G_pathcar\"`\n      func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n          -e \"$_G_pathcdr\"`\n      # Figure out what to do with it\n      case $func_normal_abspath_tcomponent in\n        \"\")\n          # Trailing empty path component, ignore it.\n          ;;\n        ..)\n          # Parent dir; strip last assembled component from result.\n          func_dirname \"$func_normal_abspath_result\"\n          func_normal_abspath_result=$func_dirname_result\n          ;;\n        *)\n          # Actual path component, append it.\n          func_append func_normal_abspath_result \"/$func_normal_abspath_tcomponent\"\n          ;;\n      esac\n    done\n    # Restore leading double-slash if one was found on entry.\n    func_normal_abspath_result=$func_normal_abspath_altnamespace$func_normal_abspath_result\n}\n\n\n# func_notquiet ARG...\n# --------------------\n# Echo program name prefixed message only when not in quiet mode.\nfunc_notquiet ()\n{\n    $debug_cmd\n\n    $opt_quiet || func_echo ${1+\"$@\"}\n\n    # A bug in bash halts the script if the last line of a function\n    # fails when set -e is in force, so we need another command to\n    # work around that:\n    :\n}\n\n\n# func_relative_path SRCDIR DSTDIR\n# --------------------------------\n# Set func_relative_path_result to the relative path from SRCDIR to DSTDIR.\nfunc_relative_path ()\n{\n    $debug_cmd\n\n    func_relative_path_result=\n    func_normal_abspath \"$1\"\n    func_relative_path_tlibdir=$func_normal_abspath_result\n    func_normal_abspath \"$2\"\n    func_relative_path_tbindir=$func_normal_abspath_result\n\n    # Ascend the tree starting from libdir\n    while :; do\n      # check if we have found a prefix of bindir\n      case $func_relative_path_tbindir in\n        $func_relative_path_tlibdir)\n          # found an exact match\n          func_relative_path_tcancelled=\n          break\n          ;;\n        $func_relative_path_tlibdir*)\n          # found a matching prefix\n          func_stripname \"$func_relative_path_tlibdir\" '' \"$func_relative_path_tbindir\"\n          func_relative_path_tcancelled=$func_stripname_result\n          if test -z \"$func_relative_path_result\"; then\n            func_relative_path_result=.\n          fi\n          break\n          ;;\n        *)\n          func_dirname $func_relative_path_tlibdir\n          func_relative_path_tlibdir=$func_dirname_result\n          if test -z \"$func_relative_path_tlibdir\"; then\n            # Have to descend all the way to the root!\n            func_relative_path_result=../$func_relative_path_result\n            func_relative_path_tcancelled=$func_relative_path_tbindir\n            break\n          fi\n          func_relative_path_result=../$func_relative_path_result\n          ;;\n      esac\n    done\n\n    # Now calculate path; take care to avoid doubling-up slashes.\n    func_stripname '' '/' \"$func_relative_path_result\"\n    func_relative_path_result=$func_stripname_result\n    func_stripname '/' '/' \"$func_relative_path_tcancelled\"\n    if test -n \"$func_stripname_result\"; then\n      func_append func_relative_path_result \"/$func_stripname_result\"\n    fi\n\n    # Normalisation. If bindir is libdir, return '.' else relative path.\n    if test -n \"$func_relative_path_result\"; then\n      func_stripname './' '' \"$func_relative_path_result\"\n      func_relative_path_result=$func_stripname_result\n    fi\n\n    test -n \"$func_relative_path_result\" || func_relative_path_result=.\n\n    :\n}\n\n\n# func_quote_for_eval ARG...\n# --------------------------\n# Aesthetically quote ARGs to be evaled later.\n# This function returns two values:\n#   i) func_quote_for_eval_result\n#      double-quoted, suitable for a subsequent eval\n#  ii) func_quote_for_eval_unquoted_result\n#      has all characters that are still active within double\n#      quotes backslashified.\nfunc_quote_for_eval ()\n{\n    $debug_cmd\n\n    func_quote_for_eval_unquoted_result=\n    func_quote_for_eval_result=\n    while test 0 -lt $#; do\n      case $1 in\n        *[\\\\\\`\\\"\\$]*)\n\t  _G_unquoted_arg=`printf '%s\\n' \"$1\" |$SED \"$sed_quote_subst\"` ;;\n        *)\n          _G_unquoted_arg=$1 ;;\n      esac\n      if test -n \"$func_quote_for_eval_unquoted_result\"; then\n\tfunc_append func_quote_for_eval_unquoted_result \" $_G_unquoted_arg\"\n      else\n        func_append func_quote_for_eval_unquoted_result \"$_G_unquoted_arg\"\n      fi\n\n      case $_G_unquoted_arg in\n        # Double-quote args containing shell metacharacters to delay\n        # word splitting, command substitution and variable expansion\n        # for a subsequent eval.\n        # Many Bourne shells cannot handle close brackets correctly\n        # in scan sets, so we specify it separately.\n        *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n          _G_quoted_arg=\\\"$_G_unquoted_arg\\\"\n          ;;\n        *)\n          _G_quoted_arg=$_G_unquoted_arg\n\t  ;;\n      esac\n\n      if test -n \"$func_quote_for_eval_result\"; then\n\tfunc_append func_quote_for_eval_result \" $_G_quoted_arg\"\n      else\n        func_append func_quote_for_eval_result \"$_G_quoted_arg\"\n      fi\n      shift\n    done\n}\n\n\n# func_quote_for_expand ARG\n# -------------------------\n# Aesthetically quote ARG to be evaled later; same as above,\n# but do not quote variable references.\nfunc_quote_for_expand ()\n{\n    $debug_cmd\n\n    case $1 in\n      *[\\\\\\`\\\"]*)\n\t_G_arg=`$ECHO \"$1\" | $SED \\\n\t    -e \"$sed_double_quote_subst\" -e \"$sed_double_backslash\"` ;;\n      *)\n        _G_arg=$1 ;;\n    esac\n\n    case $_G_arg in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting and command substitution for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        _G_arg=\\\"$_G_arg\\\"\n        ;;\n    esac\n\n    func_quote_for_expand_result=$_G_arg\n}\n\n\n# func_stripname PREFIX SUFFIX NAME\n# ---------------------------------\n# strip PREFIX and SUFFIX from NAME, and store in func_stripname_result.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\nif test yes = \"$_G_HAVE_XSI_OPS\"; then\n  eval 'func_stripname ()\n  {\n    $debug_cmd\n\n    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\n    # positional parameters, so assign one to ordinary variable first.\n    func_stripname_result=$3\n    func_stripname_result=${func_stripname_result#\"$1\"}\n    func_stripname_result=${func_stripname_result%\"$2\"}\n  }'\nelse\n  func_stripname ()\n  {\n    $debug_cmd\n\n    case $2 in\n      .*) func_stripname_result=`$ECHO \"$3\" | $SED -e \"s%^$1%%\" -e \"s%\\\\\\\\$2\\$%%\"`;;\n      *)  func_stripname_result=`$ECHO \"$3\" | $SED -e \"s%^$1%%\" -e \"s%$2\\$%%\"`;;\n    esac\n  }\nfi\n\n\n# func_show_eval CMD [FAIL_EXP]\n# -----------------------------\n# Unless opt_quiet is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.\nfunc_show_eval ()\n{\n    $debug_cmd\n\n    _G_cmd=$1\n    _G_fail_exp=${2-':'}\n\n    func_quote_for_expand \"$_G_cmd\"\n    eval \"func_notquiet $func_quote_for_expand_result\"\n\n    $opt_dry_run || {\n      eval \"$_G_cmd\"\n      _G_status=$?\n      if test 0 -ne \"$_G_status\"; then\n\teval \"(exit $_G_status); $_G_fail_exp\"\n      fi\n    }\n}\n\n\n# func_show_eval_locale CMD [FAIL_EXP]\n# ------------------------------------\n# Unless opt_quiet is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.  Use the saved locale for evaluation.\nfunc_show_eval_locale ()\n{\n    $debug_cmd\n\n    _G_cmd=$1\n    _G_fail_exp=${2-':'}\n\n    $opt_quiet || {\n      func_quote_for_expand \"$_G_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    $opt_dry_run || {\n      eval \"$_G_user_locale\n\t    $_G_cmd\"\n      _G_status=$?\n      eval \"$_G_safe_locale\"\n      if test 0 -ne \"$_G_status\"; then\n\teval \"(exit $_G_status); $_G_fail_exp\"\n      fi\n    }\n}\n\n\n# func_tr_sh\n# ----------\n# Turn $1 into a string suitable for a shell variable name.\n# Result is stored in $func_tr_sh_result.  All characters\n# not in the set a-zA-Z0-9_ are replaced with '_'. Further,\n# if $1 begins with a digit, a '_' is prepended as well.\nfunc_tr_sh ()\n{\n    $debug_cmd\n\n    case $1 in\n    [0-9]* | *[!a-zA-Z0-9_]*)\n      func_tr_sh_result=`$ECHO \"$1\" | $SED -e 's/^\\([0-9]\\)/_\\1/' -e 's/[^a-zA-Z0-9_]/_/g'`\n      ;;\n    * )\n      func_tr_sh_result=$1\n      ;;\n    esac\n}\n\n\n# func_verbose ARG...\n# -------------------\n# Echo program name prefixed message in verbose mode only.\nfunc_verbose ()\n{\n    $debug_cmd\n\n    $opt_verbose && func_echo \"$*\"\n\n    :\n}\n\n\n# func_warn_and_continue ARG...\n# -----------------------------\n# Echo program name prefixed warning message to standard error.\nfunc_warn_and_continue ()\n{\n    $debug_cmd\n\n    $require_term_colors\n\n    func_echo_infix_1 \"${tc_red}warning$tc_reset\" \"$*\" >&2\n}\n\n\n# func_warning CATEGORY ARG...\n# ----------------------------\n# Echo program name prefixed warning message to standard error. Warning\n# messages can be filtered according to CATEGORY, where this function\n# elides messages where CATEGORY is not listed in the global variable\n# 'opt_warning_types'.\nfunc_warning ()\n{\n    $debug_cmd\n\n    # CATEGORY must be in the warning_categories list!\n    case \" $warning_categories \" in\n      *\" $1 \"*) ;;\n      *) func_internal_error \"invalid warning category '$1'\" ;;\n    esac\n\n    _G_category=$1\n    shift\n\n    case \" $opt_warning_types \" in\n      *\" $_G_category \"*) $warning_func ${1+\"$@\"} ;;\n    esac\n}\n\n\n# func_sort_ver VER1 VER2\n# -----------------------\n# 'sort -V' is not generally available.\n# Note this deviates from the version comparison in automake\n# in that it treats 1.5 < 1.5.0, and treats 1.4.4a < 1.4-p3a\n# but this should suffice as we won't be specifying old\n# version formats or redundant trailing .0 in bootstrap.conf.\n# If we did want full compatibility then we should probably\n# use m4_version_compare from autoconf.\nfunc_sort_ver ()\n{\n    $debug_cmd\n\n    printf '%s\\n%s\\n' \"$1\" \"$2\" \\\n      | sort -t. -k 1,1n -k 2,2n -k 3,3n -k 4,4n -k 5,5n -k 6,6n -k 7,7n -k 8,8n -k 9,9n\n}\n\n# func_lt_ver PREV CURR\n# ---------------------\n# Return true if PREV and CURR are in the correct order according to\n# func_sort_ver, otherwise false.  Use it like this:\n#\n#  func_lt_ver \"$prev_ver\" \"$proposed_ver\" || func_fatal_error \"...\"\nfunc_lt_ver ()\n{\n    $debug_cmd\n\n    test \"x$1\" = x`func_sort_ver \"$1\" \"$2\" | $SED 1q`\n}\n\n\n# Local variables:\n# mode: shell-script\n# sh-indentation: 2\n# eval: (add-hook 'before-save-hook 'time-stamp)\n# time-stamp-pattern: \"10/scriptversion=%:y-%02m-%02d.%02H; # UTC\"\n# time-stamp-time-zone: \"UTC\"\n# End:\n#! /bin/sh\n\n# Set a version string for this script.\nscriptversion=2014-01-07.03; # UTC\n\n# A portable, pluggable option parser for Bourne shell.\n# Written by Gary V. Vaughan, 2010\n\n# Copyright (C) 2010-2015 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# Please report bugs or propose patches to gary@gnu.org.\n\n\n## ------ ##\n## Usage. ##\n## ------ ##\n\n# This file is a library for parsing options in your shell scripts along\n# with assorted other useful supporting features that you can make use\n# of too.\n#\n# For the simplest scripts you might need only:\n#\n#   #!/bin/sh\n#   . relative/path/to/funclib.sh\n#   . relative/path/to/options-parser\n#   scriptversion=1.0\n#   func_options ${1+\"$@\"}\n#   eval set dummy \"$func_options_result\"; shift\n#   ...rest of your script...\n#\n# In order for the '--version' option to work, you will need to have a\n# suitably formatted comment like the one at the top of this file\n# starting with '# Written by ' and ending with '# warranty; '.\n#\n# For '-h' and '--help' to work, you will also need a one line\n# description of your script's purpose in a comment directly above the\n# '# Written by ' line, like the one at the top of this file.\n#\n# The default options also support '--debug', which will turn on shell\n# execution tracing (see the comment above debug_cmd below for another\n# use), and '--verbose' and the func_verbose function to allow your script\n# to display verbose messages only when your user has specified\n# '--verbose'.\n#\n# After sourcing this file, you can plug processing for additional\n# options by amending the variables from the 'Configuration' section\n# below, and following the instructions in the 'Option parsing'\n# section further down.\n\n## -------------- ##\n## Configuration. ##\n## -------------- ##\n\n# You should override these variables in your script after sourcing this\n# file so that they reflect the customisations you have added to the\n# option parser.\n\n# The usage line for option parsing errors and the start of '-h' and\n# '--help' output messages. You can embed shell variables for delayed\n# expansion at the time the message is displayed, but you will need to\n# quote other shell meta-characters carefully to prevent them being\n# expanded when the contents are evaled.\nusage='$progpath [OPTION]...'\n\n# Short help message in response to '-h' and '--help'.  Add to this or\n# override it after sourcing this library to reflect the full set of\n# options your script accepts.\nusage_message=\"\\\n       --debug        enable verbose shell tracing\n   -W, --warnings=CATEGORY\n                      report the warnings falling in CATEGORY [all]\n   -v, --verbose      verbosely report processing\n       --version      print version information and exit\n   -h, --help         print short or long help message and exit\n\"\n\n# Additional text appended to 'usage_message' in response to '--help'.\nlong_help_message=\"\nWarning categories include:\n       'all'          show all warnings\n       'none'         turn off all the warnings\n       'error'        warnings are treated as fatal errors\"\n\n# Help message printed before fatal option parsing errors.\nfatal_help=\"Try '\\$progname --help' for more information.\"\n\n\n\n## ------------------------- ##\n## Hook function management. ##\n## ------------------------- ##\n\n# This section contains functions for adding, removing, and running hooks\n# to the main code.  A hook is just a named list of of function, that can\n# be run in order later on.\n\n# func_hookable FUNC_NAME\n# -----------------------\n# Declare that FUNC_NAME will run hooks added with\n# 'func_add_hook FUNC_NAME ...'.\nfunc_hookable ()\n{\n    $debug_cmd\n\n    func_append hookable_fns \" $1\"\n}\n\n\n# func_add_hook FUNC_NAME HOOK_FUNC\n# ---------------------------------\n# Request that FUNC_NAME call HOOK_FUNC before it returns.  FUNC_NAME must\n# first have been declared \"hookable\" by a call to 'func_hookable'.\nfunc_add_hook ()\n{\n    $debug_cmd\n\n    case \" $hookable_fns \" in\n      *\" $1 \"*) ;;\n      *) func_fatal_error \"'$1' does not accept hook functions.\" ;;\n    esac\n\n    eval func_append ${1}_hooks '\" $2\"'\n}\n\n\n# func_remove_hook FUNC_NAME HOOK_FUNC\n# ------------------------------------\n# Remove HOOK_FUNC from the list of functions called by FUNC_NAME.\nfunc_remove_hook ()\n{\n    $debug_cmd\n\n    eval ${1}_hooks='`$ECHO \"\\$'$1'_hooks\" |$SED \"s| '$2'||\"`'\n}\n\n\n# func_run_hooks FUNC_NAME [ARG]...\n# ---------------------------------\n# Run all hook functions registered to FUNC_NAME.\n# It is assumed that the list of hook functions contains nothing more\n# than a whitespace-delimited list of legal shell function names, and\n# no effort is wasted trying to catch shell meta-characters or preserve\n# whitespace.\nfunc_run_hooks ()\n{\n    $debug_cmd\n\n    case \" $hookable_fns \" in\n      *\" $1 \"*) ;;\n      *) func_fatal_error \"'$1' does not support hook funcions.n\" ;;\n    esac\n\n    eval _G_hook_fns=\\$$1_hooks; shift\n\n    for _G_hook in $_G_hook_fns; do\n      eval $_G_hook '\"$@\"'\n\n      # store returned options list back into positional\n      # parameters for next 'cmd' execution.\n      eval _G_hook_result=\\$${_G_hook}_result\n      eval set dummy \"$_G_hook_result\"; shift\n    done\n\n    func_quote_for_eval ${1+\"$@\"}\n    func_run_hooks_result=$func_quote_for_eval_result\n}\n\n\n\n## --------------- ##\n## Option parsing. ##\n## --------------- ##\n\n# In order to add your own option parsing hooks, you must accept the\n# full positional parameter list in your hook function, remove any\n# options that you action, and then pass back the remaining unprocessed\n# options in '<hooked_function_name>_result', escaped suitably for\n# 'eval'.  Like this:\n#\n#    my_options_prep ()\n#    {\n#        $debug_cmd\n#\n#        # Extend the existing usage message.\n#        usage_message=$usage_message'\n#      -s, --silent       don'\\''t print informational messages\n#    '\n#\n#        func_quote_for_eval ${1+\"$@\"}\n#        my_options_prep_result=$func_quote_for_eval_result\n#    }\n#    func_add_hook func_options_prep my_options_prep\n#\n#\n#    my_silent_option ()\n#    {\n#        $debug_cmd\n#\n#        # Note that for efficiency, we parse as many options as we can\n#        # recognise in a loop before passing the remainder back to the\n#        # caller on the first unrecognised argument we encounter.\n#        while test $# -gt 0; do\n#          opt=$1; shift\n#          case $opt in\n#            --silent|-s) opt_silent=: ;;\n#            # Separate non-argument short options:\n#            -s*)         func_split_short_opt \"$_G_opt\"\n#                         set dummy \"$func_split_short_opt_name\" \\\n#                             \"-$func_split_short_opt_arg\" ${1+\"$@\"}\n#                         shift\n#                         ;;\n#            *)            set dummy \"$_G_opt\" \"$*\"; shift; break ;;\n#          esac\n#        done\n#\n#        func_quote_for_eval ${1+\"$@\"}\n#        my_silent_option_result=$func_quote_for_eval_result\n#    }\n#    func_add_hook func_parse_options my_silent_option\n#\n#\n#    my_option_validation ()\n#    {\n#        $debug_cmd\n#\n#        $opt_silent && $opt_verbose && func_fatal_help \"\\\n#    '--silent' and '--verbose' options are mutually exclusive.\"\n#\n#        func_quote_for_eval ${1+\"$@\"}\n#        my_option_validation_result=$func_quote_for_eval_result\n#    }\n#    func_add_hook func_validate_options my_option_validation\n#\n# You'll alse need to manually amend $usage_message to reflect the extra\n# options you parse.  It's preferable to append if you can, so that\n# multiple option parsing hooks can be added safely.\n\n\n# func_options [ARG]...\n# ---------------------\n# All the functions called inside func_options are hookable. See the\n# individual implementations for details.\nfunc_hookable func_options\nfunc_options ()\n{\n    $debug_cmd\n\n    func_options_prep ${1+\"$@\"}\n    eval func_parse_options \\\n        ${func_options_prep_result+\"$func_options_prep_result\"}\n    eval func_validate_options \\\n        ${func_parse_options_result+\"$func_parse_options_result\"}\n\n    eval func_run_hooks func_options \\\n        ${func_validate_options_result+\"$func_validate_options_result\"}\n\n    # save modified positional parameters for caller\n    func_options_result=$func_run_hooks_result\n}\n\n\n# func_options_prep [ARG]...\n# --------------------------\n# All initialisations required before starting the option parse loop.\n# Note that when calling hook functions, we pass through the list of\n# positional parameters.  If a hook function modifies that list, and\n# needs to propogate that back to rest of this script, then the complete\n# modified list must be put in 'func_run_hooks_result' before\n# returning.\nfunc_hookable func_options_prep\nfunc_options_prep ()\n{\n    $debug_cmd\n\n    # Option defaults:\n    opt_verbose=false\n    opt_warning_types=\n\n    func_run_hooks func_options_prep ${1+\"$@\"}\n\n    # save modified positional parameters for caller\n    func_options_prep_result=$func_run_hooks_result\n}\n\n\n# func_parse_options [ARG]...\n# ---------------------------\n# The main option parsing loop.\nfunc_hookable func_parse_options\nfunc_parse_options ()\n{\n    $debug_cmd\n\n    func_parse_options_result=\n\n    # this just eases exit handling\n    while test $# -gt 0; do\n      # Defer to hook functions for initial option parsing, so they\n      # get priority in the event of reusing an option name.\n      func_run_hooks func_parse_options ${1+\"$@\"}\n\n      # Adjust func_parse_options positional parameters to match\n      eval set dummy \"$func_run_hooks_result\"; shift\n\n      # Break out of the loop if we already parsed every option.\n      test $# -gt 0 || break\n\n      _G_opt=$1\n      shift\n      case $_G_opt in\n        --debug|-x)   debug_cmd='set -x'\n                      func_echo \"enabling shell trace mode\"\n                      $debug_cmd\n                      ;;\n\n        --no-warnings|--no-warning|--no-warn)\n                      set dummy --warnings none ${1+\"$@\"}\n                      shift\n\t\t      ;;\n\n        --warnings|--warning|-W)\n                      test $# = 0 && func_missing_arg $_G_opt && break\n                      case \" $warning_categories $1\" in\n                        *\" $1 \"*)\n                          # trailing space prevents matching last $1 above\n                          func_append_uniq opt_warning_types \" $1\"\n                          ;;\n                        *all)\n                          opt_warning_types=$warning_categories\n                          ;;\n                        *none)\n                          opt_warning_types=none\n                          warning_func=:\n                          ;;\n                        *error)\n                          opt_warning_types=$warning_categories\n                          warning_func=func_fatal_error\n                          ;;\n                        *)\n                          func_fatal_error \\\n                             \"unsupported warning category: '$1'\"\n                          ;;\n                      esac\n                      shift\n                      ;;\n\n        --verbose|-v) opt_verbose=: ;;\n        --version)    func_version ;;\n        -\\?|-h)       func_usage ;;\n        --help)       func_help ;;\n\n\t# Separate optargs to long options (plugins may need this):\n\t--*=*)        func_split_equals \"$_G_opt\"\n\t              set dummy \"$func_split_equals_lhs\" \\\n                          \"$func_split_equals_rhs\" ${1+\"$@\"}\n                      shift\n                      ;;\n\n       # Separate optargs to short options:\n        -W*)\n                      func_split_short_opt \"$_G_opt\"\n                      set dummy \"$func_split_short_opt_name\" \\\n                          \"$func_split_short_opt_arg\" ${1+\"$@\"}\n                      shift\n                      ;;\n\n        # Separate non-argument short options:\n        -\\?*|-h*|-v*|-x*)\n                      func_split_short_opt \"$_G_opt\"\n                      set dummy \"$func_split_short_opt_name\" \\\n                          \"-$func_split_short_opt_arg\" ${1+\"$@\"}\n                      shift\n                      ;;\n\n        --)           break ;;\n        -*)           func_fatal_help \"unrecognised option: '$_G_opt'\" ;;\n        *)            set dummy \"$_G_opt\" ${1+\"$@\"}; shift; break ;;\n      esac\n    done\n\n    # save modified positional parameters for caller\n    func_quote_for_eval ${1+\"$@\"}\n    func_parse_options_result=$func_quote_for_eval_result\n}\n\n\n# func_validate_options [ARG]...\n# ------------------------------\n# Perform any sanity checks on option settings and/or unconsumed\n# arguments.\nfunc_hookable func_validate_options\nfunc_validate_options ()\n{\n    $debug_cmd\n\n    # Display all warnings if -W was not given.\n    test -n \"$opt_warning_types\" || opt_warning_types=\" $warning_categories\"\n\n    func_run_hooks func_validate_options ${1+\"$@\"}\n\n    # Bail if the options were screwed!\n    $exit_cmd $EXIT_FAILURE\n\n    # save modified positional parameters for caller\n    func_validate_options_result=$func_run_hooks_result\n}\n\n\n\n## ----------------- ##\n## Helper functions. ##\n## ----------------- ##\n\n# This section contains the helper functions used by the rest of the\n# hookable option parser framework in ascii-betical order.\n\n\n# func_fatal_help ARG...\n# ----------------------\n# Echo program name prefixed message to standard error, followed by\n# a help hint, and exit.\nfunc_fatal_help ()\n{\n    $debug_cmd\n\n    eval \\$ECHO \\\"\"Usage: $usage\"\\\"\n    eval \\$ECHO \\\"\"$fatal_help\"\\\"\n    func_error ${1+\"$@\"}\n    exit $EXIT_FAILURE\n}\n\n\n# func_help\n# ---------\n# Echo long help message to standard output and exit.\nfunc_help ()\n{\n    $debug_cmd\n\n    func_usage_message\n    $ECHO \"$long_help_message\"\n    exit 0\n}\n\n\n# func_missing_arg ARGNAME\n# ------------------------\n# Echo program name prefixed message to standard error and set global\n# exit_cmd.\nfunc_missing_arg ()\n{\n    $debug_cmd\n\n    func_error \"Missing argument for '$1'.\"\n    exit_cmd=exit\n}\n\n\n# func_split_equals STRING\n# ------------------------\n# Set func_split_equals_lhs and func_split_equals_rhs shell variables after\n# splitting STRING at the '=' sign.\ntest -z \"$_G_HAVE_XSI_OPS\" \\\n    && (eval 'x=a/b/c;\n      test 5aa/bb/cc = \"${#x}${x%%/*}${x%/*}${x#*/}${x##*/}\"') 2>/dev/null \\\n    && _G_HAVE_XSI_OPS=yes\n\nif test yes = \"$_G_HAVE_XSI_OPS\"\nthen\n  # This is an XSI compatible shell, allowing a faster implementation...\n  eval 'func_split_equals ()\n  {\n      $debug_cmd\n\n      func_split_equals_lhs=${1%%=*}\n      func_split_equals_rhs=${1#*=}\n      test \"x$func_split_equals_lhs\" = \"x$1\" \\\n        && func_split_equals_rhs=\n  }'\nelse\n  # ...otherwise fall back to using expr, which is often a shell builtin.\n  func_split_equals ()\n  {\n      $debug_cmd\n\n      func_split_equals_lhs=`expr \"x$1\" : 'x\\([^=]*\\)'`\n      func_split_equals_rhs=\n      test \"x$func_split_equals_lhs\" = \"x$1\" \\\n        || func_split_equals_rhs=`expr \"x$1\" : 'x[^=]*=\\(.*\\)$'`\n  }\nfi #func_split_equals\n\n\n# func_split_short_opt SHORTOPT\n# -----------------------------\n# Set func_split_short_opt_name and func_split_short_opt_arg shell\n# variables after splitting SHORTOPT after the 2nd character.\nif test yes = \"$_G_HAVE_XSI_OPS\"\nthen\n  # This is an XSI compatible shell, allowing a faster implementation...\n  eval 'func_split_short_opt ()\n  {\n      $debug_cmd\n\n      func_split_short_opt_arg=${1#??}\n      func_split_short_opt_name=${1%\"$func_split_short_opt_arg\"}\n  }'\nelse\n  # ...otherwise fall back to using expr, which is often a shell builtin.\n  func_split_short_opt ()\n  {\n      $debug_cmd\n\n      func_split_short_opt_name=`expr \"x$1\" : 'x-\\(.\\)'`\n      func_split_short_opt_arg=`expr \"x$1\" : 'x-.\\(.*\\)$'`\n  }\nfi #func_split_short_opt\n\n\n# func_usage\n# ----------\n# Echo short help message to standard output and exit.\nfunc_usage ()\n{\n    $debug_cmd\n\n    func_usage_message\n    $ECHO \"Run '$progname --help |${PAGER-more}' for full usage\"\n    exit 0\n}\n\n\n# func_usage_message\n# ------------------\n# Echo short help message to standard output.\nfunc_usage_message ()\n{\n    $debug_cmd\n\n    eval \\$ECHO \\\"\"Usage: $usage\"\\\"\n    echo\n    $SED -n 's|^# ||\n        /^Written by/{\n          x;p;x\n        }\n\th\n\t/^Written by/q' < \"$progpath\"\n    echo\n    eval \\$ECHO \\\"\"$usage_message\"\\\"\n}\n\n\n# func_version\n# ------------\n# Echo version message to standard output and exit.\nfunc_version ()\n{\n    $debug_cmd\n\n    printf '%s\\n' \"$progname $scriptversion\"\n    $SED -n '\n        /(C)/!b go\n        :more\n        /\\./!{\n          N\n          s|\\n# | |\n          b more\n        }\n        :go\n        /^# Written by /,/# warranty; / {\n          s|^# ||\n          s|^# *$||\n          s|\\((C)\\)[ 0-9,-]*[ ,-]\\([1-9][0-9]* \\)|\\1 \\2|\n          p\n        }\n        /^# Written by / {\n          s|^# ||\n          p\n        }\n        /^warranty; /q' < \"$progpath\"\n\n    exit $?\n}\n\n\n# Local variables:\n# mode: shell-script\n# sh-indentation: 2\n# eval: (add-hook 'before-save-hook 'time-stamp)\n# time-stamp-pattern: \"10/scriptversion=%:y-%02m-%02d.%02H; # UTC\"\n# time-stamp-time-zone: \"UTC\"\n# End:\n\n# Set a version string.\nscriptversion='(GNU libtool) 2.4.6'\n\n\n# func_echo ARG...\n# ----------------\n# Libtool also displays the current mode in messages, so override\n# funclib.sh func_echo with this custom definition.\nfunc_echo ()\n{\n    $debug_cmd\n\n    _G_message=$*\n\n    func_echo_IFS=$IFS\n    IFS=$nl\n    for _G_line in $_G_message; do\n      IFS=$func_echo_IFS\n      $ECHO \"$progname${opt_mode+: $opt_mode}: $_G_line\"\n    done\n    IFS=$func_echo_IFS\n}\n\n\n# func_warning ARG...\n# -------------------\n# Libtool warnings are not categorized, so override funclib.sh\n# func_warning with this simpler definition.\nfunc_warning ()\n{\n    $debug_cmd\n\n    $warning_func ${1+\"$@\"}\n}\n\n\n## ---------------- ##\n## Options parsing. ##\n## ---------------- ##\n\n# Hook in the functions to make sure our own options are parsed during\n# the option parsing loop.\n\nusage='$progpath [OPTION]... [MODE-ARG]...'\n\n# Short help message in response to '-h'.\nusage_message=\"Options:\n       --config             show all configuration variables\n       --debug              enable verbose shell tracing\n   -n, --dry-run            display commands without modifying any files\n       --features           display basic configuration information and exit\n       --mode=MODE          use operation mode MODE\n       --no-warnings        equivalent to '-Wnone'\n       --preserve-dup-deps  don't remove duplicate dependency libraries\n       --quiet, --silent    don't print informational messages\n       --tag=TAG            use configuration variables from tag TAG\n   -v, --verbose            print more informational messages than default\n       --version            print version information\n   -W, --warnings=CATEGORY  report the warnings falling in CATEGORY [all]\n   -h, --help, --help-all   print short, long, or detailed help message\n\"\n\n# Additional text appended to 'usage_message' in response to '--help'.\nfunc_help ()\n{\n    $debug_cmd\n\n    func_usage_message\n    $ECHO \"$long_help_message\n\nMODE must be one of the following:\n\n       clean           remove files from the build directory\n       compile         compile a source file into a libtool object\n       execute         automatically set library path, then run a program\n       finish          complete the installation of libtool libraries\n       install         install libraries or executables\n       link            create a library or an executable\n       uninstall       remove libraries from an installed directory\n\nMODE-ARGS vary depending on the MODE.  When passed as first option,\n'--mode=MODE' may be abbreviated as 'MODE' or a unique abbreviation of that.\nTry '$progname --help --mode=MODE' for a more detailed description of MODE.\n\nWhen reporting a bug, please describe a test case to reproduce it and\ninclude the following information:\n\n       host-triplet:   $host\n       shell:          $SHELL\n       compiler:       $LTCC\n       compiler flags: $LTCFLAGS\n       linker:         $LD (gnu? $with_gnu_ld)\n       version:        $progname (GNU libtool) 2.4.6\n       automake:       `($AUTOMAKE --version) 2>/dev/null |$SED 1q`\n       autoconf:       `($AUTOCONF --version) 2>/dev/null |$SED 1q`\n\nReport bugs to <bug-libtool@gnu.org>.\nGNU libtool home page: <http://www.gnu.org/s/libtool/>.\nGeneral help using GNU software: <http://www.gnu.org/gethelp/>.\"\n    exit 0\n}\n\n\n# func_lo2o OBJECT-NAME\n# ---------------------\n# Transform OBJECT-NAME from a '.lo' suffix to the platform specific\n# object suffix.\n\nlo2o=s/\\\\.lo\\$/.$objext/\no2lo=s/\\\\.$objext\\$/.lo/\n\nif test yes = \"$_G_HAVE_XSI_OPS\"; then\n  eval 'func_lo2o ()\n  {\n    case $1 in\n      *.lo) func_lo2o_result=${1%.lo}.$objext ;;\n      *   ) func_lo2o_result=$1               ;;\n    esac\n  }'\n\n  # func_xform LIBOBJ-OR-SOURCE\n  # ---------------------------\n  # Transform LIBOBJ-OR-SOURCE from a '.o' or '.c' (or otherwise)\n  # suffix to a '.lo' libtool-object suffix.\n  eval 'func_xform ()\n  {\n    func_xform_result=${1%.*}.lo\n  }'\nelse\n  # ...otherwise fall back to using sed.\n  func_lo2o ()\n  {\n    func_lo2o_result=`$ECHO \"$1\" | $SED \"$lo2o\"`\n  }\n\n  func_xform ()\n  {\n    func_xform_result=`$ECHO \"$1\" | $SED 's|\\.[^.]*$|.lo|'`\n  }\nfi\n\n\n# func_fatal_configuration ARG...\n# -------------------------------\n# Echo program name prefixed message to standard error, followed by\n# a configuration failure hint, and exit.\nfunc_fatal_configuration ()\n{\n    func__fatal_error ${1+\"$@\"} \\\n      \"See the $PACKAGE documentation for more information.\" \\\n      \"Fatal configuration error.\"\n}\n\n\n# func_config\n# -----------\n# Display the configuration for all the tags in this script.\nfunc_config ()\n{\n    re_begincf='^# ### BEGIN LIBTOOL'\n    re_endcf='^# ### END LIBTOOL'\n\n    # Default configuration.\n    $SED \"1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\\$d\" < \"$progpath\"\n\n    # Now print the configurations for the tags.\n    for tagname in $taglist; do\n      $SED -n \"/$re_begincf TAG CONFIG: $tagname\\$/,/$re_endcf TAG CONFIG: $tagname\\$/p\" < \"$progpath\"\n    done\n\n    exit $?\n}\n\n\n# func_features\n# -------------\n# Display the features supported by this script.\nfunc_features ()\n{\n    echo \"host: $host\"\n    if test yes = \"$build_libtool_libs\"; then\n      echo \"enable shared libraries\"\n    else\n      echo \"disable shared libraries\"\n    fi\n    if test yes = \"$build_old_libs\"; then\n      echo \"enable static libraries\"\n    else\n      echo \"disable static libraries\"\n    fi\n\n    exit $?\n}\n\n\n# func_enable_tag TAGNAME\n# -----------------------\n# Verify that TAGNAME is valid, and either flag an error and exit, or\n# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist\n# variable here.\nfunc_enable_tag ()\n{\n    # Global variable:\n    tagname=$1\n\n    re_begincf=\"^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\\$\"\n    re_endcf=\"^# ### END LIBTOOL TAG CONFIG: $tagname\\$\"\n    sed_extractcf=/$re_begincf/,/$re_endcf/p\n\n    # Validate tagname.\n    case $tagname in\n      *[!-_A-Za-z0-9,/]*)\n        func_fatal_error \"invalid tag name: $tagname\"\n        ;;\n    esac\n\n    # Don't test for the \"default\" C tag, as we know it's\n    # there but not specially marked.\n    case $tagname in\n        CC) ;;\n    *)\n        if $GREP \"$re_begincf\" \"$progpath\" >/dev/null 2>&1; then\n\t  taglist=\"$taglist $tagname\"\n\n\t  # Evaluate the configuration.  Be careful to quote the path\n\t  # and the sed script, to avoid splitting on whitespace, but\n\t  # also don't use non-portable quotes within backquotes within\n\t  # quotes we have to do it in 2 steps:\n\t  extractedcf=`$SED -n -e \"$sed_extractcf\" < \"$progpath\"`\n\t  eval \"$extractedcf\"\n        else\n\t  func_error \"ignoring unknown tag $tagname\"\n        fi\n        ;;\n    esac\n}\n\n\n# func_check_version_match\n# ------------------------\n# Ensure that we are using m4 macros, and libtool script from the same\n# release of libtool.\nfunc_check_version_match ()\n{\n    if test \"$package_revision\" != \"$macro_revision\"; then\n      if test \"$VERSION\" != \"$macro_version\"; then\n        if test -z \"$macro_version\"; then\n          cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from an older release.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n        else\n          cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n        fi\n      else\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,\n$progname: but the definition of this LT_INIT comes from revision $macro_revision.\n$progname: You should recreate aclocal.m4 with macros from revision $package_revision\n$progname: of $PACKAGE $VERSION and run autoconf again.\n_LT_EOF\n      fi\n\n      exit $EXIT_MISMATCH\n    fi\n}\n\n\n# libtool_options_prep [ARG]...\n# -----------------------------\n# Preparation for options parsed by libtool.\nlibtool_options_prep ()\n{\n    $debug_mode\n\n    # Option defaults:\n    opt_config=false\n    opt_dlopen=\n    opt_dry_run=false\n    opt_help=false\n    opt_mode=\n    opt_preserve_dup_deps=false\n    opt_quiet=false\n\n    nonopt=\n    preserve_args=\n\n    # Shorthand for --mode=foo, only valid as the first argument\n    case $1 in\n    clean|clea|cle|cl)\n      shift; set dummy --mode clean ${1+\"$@\"}; shift\n      ;;\n    compile|compil|compi|comp|com|co|c)\n      shift; set dummy --mode compile ${1+\"$@\"}; shift\n      ;;\n    execute|execut|execu|exec|exe|ex|e)\n      shift; set dummy --mode execute ${1+\"$@\"}; shift\n      ;;\n    finish|finis|fini|fin|fi|f)\n      shift; set dummy --mode finish ${1+\"$@\"}; shift\n      ;;\n    install|instal|insta|inst|ins|in|i)\n      shift; set dummy --mode install ${1+\"$@\"}; shift\n      ;;\n    link|lin|li|l)\n      shift; set dummy --mode link ${1+\"$@\"}; shift\n      ;;\n    uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)\n      shift; set dummy --mode uninstall ${1+\"$@\"}; shift\n      ;;\n    esac\n\n    # Pass back the list of options.\n    func_quote_for_eval ${1+\"$@\"}\n    libtool_options_prep_result=$func_quote_for_eval_result\n}\nfunc_add_hook func_options_prep libtool_options_prep\n\n\n# libtool_parse_options [ARG]...\n# ---------------------------------\n# Provide handling for libtool specific options.\nlibtool_parse_options ()\n{\n    $debug_cmd\n\n    # Perform our own loop to consume as many options as possible in\n    # each iteration.\n    while test $# -gt 0; do\n      _G_opt=$1\n      shift\n      case $_G_opt in\n        --dry-run|--dryrun|-n)\n                        opt_dry_run=:\n                        ;;\n\n        --config)       func_config ;;\n\n        --dlopen|-dlopen)\n                        opt_dlopen=\"${opt_dlopen+$opt_dlopen\n}$1\"\n                        shift\n                        ;;\n\n        --preserve-dup-deps)\n                        opt_preserve_dup_deps=: ;;\n\n        --features)     func_features ;;\n\n        --finish)       set dummy --mode finish ${1+\"$@\"}; shift ;;\n\n        --help)         opt_help=: ;;\n\n        --help-all)     opt_help=': help-all' ;;\n\n        --mode)         test $# = 0 && func_missing_arg $_G_opt && break\n                        opt_mode=$1\n                        case $1 in\n                          # Valid mode arguments:\n                          clean|compile|execute|finish|install|link|relink|uninstall) ;;\n\n                          # Catch anything else as an error\n                          *) func_error \"invalid argument for $_G_opt\"\n                             exit_cmd=exit\n                             break\n                             ;;\n                        esac\n                        shift\n                        ;;\n\n        --no-silent|--no-quiet)\n                        opt_quiet=false\n                        func_append preserve_args \" $_G_opt\"\n                        ;;\n\n        --no-warnings|--no-warning|--no-warn)\n                        opt_warning=false\n                        func_append preserve_args \" $_G_opt\"\n                        ;;\n\n        --no-verbose)\n                        opt_verbose=false\n                        func_append preserve_args \" $_G_opt\"\n                        ;;\n\n        --silent|--quiet)\n                        opt_quiet=:\n                        opt_verbose=false\n                        func_append preserve_args \" $_G_opt\"\n                        ;;\n\n        --tag)          test $# = 0 && func_missing_arg $_G_opt && break\n                        opt_tag=$1\n                        func_append preserve_args \" $_G_opt $1\"\n                        func_enable_tag \"$1\"\n                        shift\n                        ;;\n\n        --verbose|-v)   opt_quiet=false\n                        opt_verbose=:\n                        func_append preserve_args \" $_G_opt\"\n                        ;;\n\n\t# An option not handled by this hook function:\n        *)\t\tset dummy \"$_G_opt\" ${1+\"$@\"};\tshift; break  ;;\n      esac\n    done\n\n\n    # save modified positional parameters for caller\n    func_quote_for_eval ${1+\"$@\"}\n    libtool_parse_options_result=$func_quote_for_eval_result\n}\nfunc_add_hook func_parse_options libtool_parse_options\n\n\n\n# libtool_validate_options [ARG]...\n# ---------------------------------\n# Perform any sanity checks on option settings and/or unconsumed\n# arguments.\nlibtool_validate_options ()\n{\n    # save first non-option argument\n    if test 0 -lt $#; then\n      nonopt=$1\n      shift\n    fi\n\n    # preserve --debug\n    test : = \"$debug_cmd\" || func_append preserve_args \" --debug\"\n\n    case $host in\n      # Solaris2 added to fix http://debbugs.gnu.org/cgi/bugreport.cgi?bug=16452\n      # see also: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=59788\n      *cygwin* | *mingw* | *pw32* | *cegcc* | *solaris2* | *os2*)\n        # don't eliminate duplications in $postdeps and $predeps\n        opt_duplicate_compiler_generated_deps=:\n        ;;\n      *)\n        opt_duplicate_compiler_generated_deps=$opt_preserve_dup_deps\n        ;;\n    esac\n\n    $opt_help || {\n      # Sanity checks first:\n      func_check_version_match\n\n      test yes != \"$build_libtool_libs\" \\\n        && test yes != \"$build_old_libs\" \\\n        && func_fatal_configuration \"not configured to build any kind of library\"\n\n      # Darwin sucks\n      eval std_shrext=\\\"$shrext_cmds\\\"\n\n      # Only execute mode is allowed to have -dlopen flags.\n      if test -n \"$opt_dlopen\" && test execute != \"$opt_mode\"; then\n        func_error \"unrecognized option '-dlopen'\"\n        $ECHO \"$help\" 1>&2\n        exit $EXIT_FAILURE\n      fi\n\n      # Change the help message to a mode-specific one.\n      generic_help=$help\n      help=\"Try '$progname --help --mode=$opt_mode' for more information.\"\n    }\n\n    # Pass back the unparsed argument list\n    func_quote_for_eval ${1+\"$@\"}\n    libtool_validate_options_result=$func_quote_for_eval_result\n}\nfunc_add_hook func_validate_options libtool_validate_options\n\n\n# Process options as early as possible so that --help and --version\n# can return quickly.\nfunc_options ${1+\"$@\"}\neval set dummy \"$func_options_result\"; shift\n\n\n\n## ----------- ##\n##    Main.    ##\n## ----------- ##\n\nmagic='%%%MAGIC variable%%%'\nmagic_exe='%%%MAGIC EXE variable%%%'\n\n# Global variables.\nextracted_archives=\nextracted_serial=0\n\n# If this variable is set in any of the actions, the command in it\n# will be execed at the end.  This prevents here-documents from being\n# left over by shells.\nexec_cmd=\n\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n$1\n_LTECHO_EOF'\n}\n\n# func_generated_by_libtool\n# True iff stdin has been generated by Libtool. This function is only\n# a basic sanity check; it will hardly flush out determined imposters.\nfunc_generated_by_libtool_p ()\n{\n  $GREP \"^# Generated by .*$PACKAGE\" > /dev/null 2>&1\n}\n\n# func_lalib_p file\n# True iff FILE is a libtool '.la' library or '.lo' object file.\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_lalib_p ()\n{\n    test -f \"$1\" &&\n      $SED -e 4q \"$1\" 2>/dev/null | func_generated_by_libtool_p\n}\n\n# func_lalib_unsafe_p file\n# True iff FILE is a libtool '.la' library or '.lo' object file.\n# This function implements the same check as func_lalib_p without\n# resorting to external programs.  To this end, it redirects stdin and\n# closes it afterwards, without saving the original file descriptor.\n# As a safety measure, use it only where a negative result would be\n# fatal anyway.  Works if 'file' does not exist.\nfunc_lalib_unsafe_p ()\n{\n    lalib_p=no\n    if test -f \"$1\" && test -r \"$1\" && exec 5<&0 <\"$1\"; then\n\tfor lalib_p_l in 1 2 3 4\n\tdo\n\t    read lalib_p_line\n\t    case $lalib_p_line in\n\t\t\\#\\ Generated\\ by\\ *$PACKAGE* ) lalib_p=yes; break;;\n\t    esac\n\tdone\n\texec 0<&5 5<&-\n    fi\n    test yes = \"$lalib_p\"\n}\n\n# func_ltwrapper_script_p file\n# True iff FILE is a libtool wrapper script\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_script_p ()\n{\n    test -f \"$1\" &&\n      $lt_truncate_bin < \"$1\" 2>/dev/null | func_generated_by_libtool_p\n}\n\n# func_ltwrapper_executable_p file\n# True iff FILE is a libtool wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_executable_p ()\n{\n    func_ltwrapper_exec_suffix=\n    case $1 in\n    *.exe) ;;\n    *) func_ltwrapper_exec_suffix=.exe ;;\n    esac\n    $GREP \"$magic_exe\" \"$1$func_ltwrapper_exec_suffix\" >/dev/null 2>&1\n}\n\n# func_ltwrapper_scriptname file\n# Assumes file is an ltwrapper_executable\n# uses $file to determine the appropriate filename for a\n# temporary ltwrapper_script.\nfunc_ltwrapper_scriptname ()\n{\n    func_dirname_and_basename \"$1\" \"\" \".\"\n    func_stripname '' '.exe' \"$func_basename_result\"\n    func_ltwrapper_scriptname_result=$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper\n}\n\n# func_ltwrapper_p file\n# True iff FILE is a libtool wrapper script or wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_p ()\n{\n    func_ltwrapper_script_p \"$1\" || func_ltwrapper_executable_p \"$1\"\n}\n\n\n# func_execute_cmds commands fail_cmd\n# Execute tilde-delimited COMMANDS.\n# If FAIL_CMD is given, eval that upon failure.\n# FAIL_CMD may read-access the current command in variable CMD!\nfunc_execute_cmds ()\n{\n    $debug_cmd\n\n    save_ifs=$IFS; IFS='~'\n    for cmd in $1; do\n      IFS=$sp$nl\n      eval cmd=\\\"$cmd\\\"\n      IFS=$save_ifs\n      func_show_eval \"$cmd\" \"${2-:}\"\n    done\n    IFS=$save_ifs\n}\n\n\n# func_source file\n# Source FILE, adding directory component if necessary.\n# Note that it is not necessary on cygwin/mingw to append a dot to\n# FILE even if both FILE and FILE.exe exist: automatic-append-.exe\n# behavior happens only for exec(3), not for open(2)!  Also, sourcing\n# 'FILE.' does not work on cygwin managed mounts.\nfunc_source ()\n{\n    $debug_cmd\n\n    case $1 in\n    */* | *\\\\*)\t. \"$1\" ;;\n    *)\t\t. \"./$1\" ;;\n    esac\n}\n\n\n# func_resolve_sysroot PATH\n# Replace a leading = in PATH with a sysroot.  Store the result into\n# func_resolve_sysroot_result\nfunc_resolve_sysroot ()\n{\n  func_resolve_sysroot_result=$1\n  case $func_resolve_sysroot_result in\n  =*)\n    func_stripname '=' '' \"$func_resolve_sysroot_result\"\n    func_resolve_sysroot_result=$lt_sysroot$func_stripname_result\n    ;;\n  esac\n}\n\n# func_replace_sysroot PATH\n# If PATH begins with the sysroot, replace it with = and\n# store the result into func_replace_sysroot_result.\nfunc_replace_sysroot ()\n{\n  case $lt_sysroot:$1 in\n  ?*:\"$lt_sysroot\"*)\n    func_stripname \"$lt_sysroot\" '' \"$1\"\n    func_replace_sysroot_result='='$func_stripname_result\n    ;;\n  *)\n    # Including no sysroot.\n    func_replace_sysroot_result=$1\n    ;;\n  esac\n}\n\n# func_infer_tag arg\n# Infer tagged configuration to use if any are available and\n# if one wasn't chosen via the \"--tag\" command line option.\n# Only attempt this if the compiler in the base compile\n# command doesn't match the default compiler.\n# arg is usually of the form 'gcc ...'\nfunc_infer_tag ()\n{\n    $debug_cmd\n\n    if test -n \"$available_tags\" && test -z \"$tagname\"; then\n      CC_quoted=\n      for arg in $CC; do\n\tfunc_append_quoted CC_quoted \"$arg\"\n      done\n      CC_expanded=`func_echo_all $CC`\n      CC_quoted_expanded=`func_echo_all $CC_quoted`\n      case $@ in\n      # Blanks in the command may have been stripped by the calling shell,\n      # but not from the CC environment variable when configure was run.\n      \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n      \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*) ;;\n      # Blanks at the start of $base_compile will cause this to fail\n      # if we don't check for them as well.\n      *)\n\tfor z in $available_tags; do\n\t  if $GREP \"^# ### BEGIN LIBTOOL TAG CONFIG: $z$\" < \"$progpath\" > /dev/null; then\n\t    # Evaluate the configuration.\n\t    eval \"`$SED -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`\"\n\t    CC_quoted=\n\t    for arg in $CC; do\n\t      # Double-quote args containing other shell metacharacters.\n\t      func_append_quoted CC_quoted \"$arg\"\n\t    done\n\t    CC_expanded=`func_echo_all $CC`\n\t    CC_quoted_expanded=`func_echo_all $CC_quoted`\n\t    case \"$@ \" in\n\t    \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n\t    \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*)\n\t      # The compiler in the base compile command matches\n\t      # the one in the tagged configuration.\n\t      # Assume this is the tagged configuration we want.\n\t      tagname=$z\n\t      break\n\t      ;;\n\t    esac\n\t  fi\n\tdone\n\t# If $tagname still isn't set, then no tagged configuration\n\t# was found and let the user know that the \"--tag\" command\n\t# line option must be used.\n\tif test -z \"$tagname\"; then\n\t  func_echo \"unable to infer tagged configuration\"\n\t  func_fatal_error \"specify a tag with '--tag'\"\n#\telse\n#\t  func_verbose \"using $tagname tagged configuration\"\n\tfi\n\t;;\n      esac\n    fi\n}\n\n\n\n# func_write_libtool_object output_name pic_name nonpic_name\n# Create a libtool object file (analogous to a \".la\" file),\n# but don't create it if we're doing a dry run.\nfunc_write_libtool_object ()\n{\n    write_libobj=$1\n    if test yes = \"$build_libtool_libs\"; then\n      write_lobj=\\'$2\\'\n    else\n      write_lobj=none\n    fi\n\n    if test yes = \"$build_old_libs\"; then\n      write_oldobj=\\'$3\\'\n    else\n      write_oldobj=none\n    fi\n\n    $opt_dry_run || {\n      cat >${write_libobj}T <<EOF\n# $write_libobj - a libtool object file\n# Generated by $PROGRAM (GNU $PACKAGE) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# Name of the PIC object.\npic_object=$write_lobj\n\n# Name of the non-PIC object\nnon_pic_object=$write_oldobj\n\nEOF\n      $MV \"${write_libobj}T\" \"$write_libobj\"\n    }\n}\n\n\n##################################################\n# FILE NAME AND PATH CONVERSION HELPER FUNCTIONS #\n##################################################\n\n# func_convert_core_file_wine_to_w32 ARG\n# Helper function used by file name conversion functions when $build is *nix,\n# and $host is mingw, cygwin, or some other w32 environment. Relies on a\n# correctly configured wine environment available, with the winepath program\n# in $build's $PATH.\n#\n# ARG is the $build file name to be converted to w32 format.\n# Result is available in $func_convert_core_file_wine_to_w32_result, and will\n# be empty on error (or when ARG is empty)\nfunc_convert_core_file_wine_to_w32 ()\n{\n  $debug_cmd\n\n  func_convert_core_file_wine_to_w32_result=$1\n  if test -n \"$1\"; then\n    # Unfortunately, winepath does not exit with a non-zero error code, so we\n    # are forced to check the contents of stdout. On the other hand, if the\n    # command is not found, the shell will set an exit code of 127 and print\n    # *an error message* to stdout. So we must check for both error code of\n    # zero AND non-empty stdout, which explains the odd construction:\n    func_convert_core_file_wine_to_w32_tmp=`winepath -w \"$1\" 2>/dev/null`\n    if test \"$?\" -eq 0 && test -n \"$func_convert_core_file_wine_to_w32_tmp\"; then\n      func_convert_core_file_wine_to_w32_result=`$ECHO \"$func_convert_core_file_wine_to_w32_tmp\" |\n        $SED -e \"$sed_naive_backslashify\"`\n    else\n      func_convert_core_file_wine_to_w32_result=\n    fi\n  fi\n}\n# end: func_convert_core_file_wine_to_w32\n\n\n# func_convert_core_path_wine_to_w32 ARG\n# Helper function used by path conversion functions when $build is *nix, and\n# $host is mingw, cygwin, or some other w32 environment. Relies on a correctly\n# configured wine environment available, with the winepath program in $build's\n# $PATH. Assumes ARG has no leading or trailing path separator characters.\n#\n# ARG is path to be converted from $build format to win32.\n# Result is available in $func_convert_core_path_wine_to_w32_result.\n# Unconvertible file (directory) names in ARG are skipped; if no directory names\n# are convertible, then the result may be empty.\nfunc_convert_core_path_wine_to_w32 ()\n{\n  $debug_cmd\n\n  # unfortunately, winepath doesn't convert paths, only file names\n  func_convert_core_path_wine_to_w32_result=\n  if test -n \"$1\"; then\n    oldIFS=$IFS\n    IFS=:\n    for func_convert_core_path_wine_to_w32_f in $1; do\n      IFS=$oldIFS\n      func_convert_core_file_wine_to_w32 \"$func_convert_core_path_wine_to_w32_f\"\n      if test -n \"$func_convert_core_file_wine_to_w32_result\"; then\n        if test -z \"$func_convert_core_path_wine_to_w32_result\"; then\n          func_convert_core_path_wine_to_w32_result=$func_convert_core_file_wine_to_w32_result\n        else\n          func_append func_convert_core_path_wine_to_w32_result \";$func_convert_core_file_wine_to_w32_result\"\n        fi\n      fi\n    done\n    IFS=$oldIFS\n  fi\n}\n# end: func_convert_core_path_wine_to_w32\n\n\n# func_cygpath ARGS...\n# Wrapper around calling the cygpath program via LT_CYGPATH. This is used when\n# when (1) $build is *nix and Cygwin is hosted via a wine environment; or (2)\n# $build is MSYS and $host is Cygwin, or (3) $build is Cygwin. In case (1) or\n# (2), returns the Cygwin file name or path in func_cygpath_result (input\n# file name or path is assumed to be in w32 format, as previously converted\n# from $build's *nix or MSYS format). In case (3), returns the w32 file name\n# or path in func_cygpath_result (input file name or path is assumed to be in\n# Cygwin format). Returns an empty string on error.\n#\n# ARGS are passed to cygpath, with the last one being the file name or path to\n# be converted.\n#\n# Specify the absolute *nix (or w32) name to cygpath in the LT_CYGPATH\n# environment variable; do not put it in $PATH.\nfunc_cygpath ()\n{\n  $debug_cmd\n\n  if test -n \"$LT_CYGPATH\" && test -f \"$LT_CYGPATH\"; then\n    func_cygpath_result=`$LT_CYGPATH \"$@\" 2>/dev/null`\n    if test \"$?\" -ne 0; then\n      # on failure, ensure result is empty\n      func_cygpath_result=\n    fi\n  else\n    func_cygpath_result=\n    func_error \"LT_CYGPATH is empty or specifies non-existent file: '$LT_CYGPATH'\"\n  fi\n}\n#end: func_cygpath\n\n\n# func_convert_core_msys_to_w32 ARG\n# Convert file name or path ARG from MSYS format to w32 format.  Return\n# result in func_convert_core_msys_to_w32_result.\nfunc_convert_core_msys_to_w32 ()\n{\n  $debug_cmd\n\n  # awkward: cmd appends spaces to result\n  func_convert_core_msys_to_w32_result=`( cmd //c echo \"$1\" ) 2>/dev/null |\n    $SED -e 's/[ ]*$//' -e \"$sed_naive_backslashify\"`\n}\n#end: func_convert_core_msys_to_w32\n\n\n# func_convert_file_check ARG1 ARG2\n# Verify that ARG1 (a file name in $build format) was converted to $host\n# format in ARG2. Otherwise, emit an error message, but continue (resetting\n# func_to_host_file_result to ARG1).\nfunc_convert_file_check ()\n{\n  $debug_cmd\n\n  if test -z \"$2\" && test -n \"$1\"; then\n    func_error \"Could not determine host file name corresponding to\"\n    func_error \"  '$1'\"\n    func_error \"Continuing, but uninstalled executables may not work.\"\n    # Fallback:\n    func_to_host_file_result=$1\n  fi\n}\n# end func_convert_file_check\n\n\n# func_convert_path_check FROM_PATHSEP TO_PATHSEP FROM_PATH TO_PATH\n# Verify that FROM_PATH (a path in $build format) was converted to $host\n# format in TO_PATH. Otherwise, emit an error message, but continue, resetting\n# func_to_host_file_result to a simplistic fallback value (see below).\nfunc_convert_path_check ()\n{\n  $debug_cmd\n\n  if test -z \"$4\" && test -n \"$3\"; then\n    func_error \"Could not determine the host path corresponding to\"\n    func_error \"  '$3'\"\n    func_error \"Continuing, but uninstalled executables may not work.\"\n    # Fallback.  This is a deliberately simplistic \"conversion\" and\n    # should not be \"improved\".  See libtool.info.\n    if test \"x$1\" != \"x$2\"; then\n      lt_replace_pathsep_chars=\"s|$1|$2|g\"\n      func_to_host_path_result=`echo \"$3\" |\n        $SED -e \"$lt_replace_pathsep_chars\"`\n    else\n      func_to_host_path_result=$3\n    fi\n  fi\n}\n# end func_convert_path_check\n\n\n# func_convert_path_front_back_pathsep FRONTPAT BACKPAT REPL ORIG\n# Modifies func_to_host_path_result by prepending REPL if ORIG matches FRONTPAT\n# and appending REPL if ORIG matches BACKPAT.\nfunc_convert_path_front_back_pathsep ()\n{\n  $debug_cmd\n\n  case $4 in\n  $1 ) func_to_host_path_result=$3$func_to_host_path_result\n    ;;\n  esac\n  case $4 in\n  $2 ) func_append func_to_host_path_result \"$3\"\n    ;;\n  esac\n}\n# end func_convert_path_front_back_pathsep\n\n\n##################################################\n# $build to $host FILE NAME CONVERSION FUNCTIONS #\n##################################################\n# invoked via '$to_host_file_cmd ARG'\n#\n# In each case, ARG is the path to be converted from $build to $host format.\n# Result will be available in $func_to_host_file_result.\n\n\n# func_to_host_file ARG\n# Converts the file name ARG from $build format to $host format. Return result\n# in func_to_host_file_result.\nfunc_to_host_file ()\n{\n  $debug_cmd\n\n  $to_host_file_cmd \"$1\"\n}\n# end func_to_host_file\n\n\n# func_to_tool_file ARG LAZY\n# converts the file name ARG from $build format to toolchain format. Return\n# result in func_to_tool_file_result.  If the conversion in use is listed\n# in (the comma separated) LAZY, no conversion takes place.\nfunc_to_tool_file ()\n{\n  $debug_cmd\n\n  case ,$2, in\n    *,\"$to_tool_file_cmd\",*)\n      func_to_tool_file_result=$1\n      ;;\n    *)\n      $to_tool_file_cmd \"$1\"\n      func_to_tool_file_result=$func_to_host_file_result\n      ;;\n  esac\n}\n# end func_to_tool_file\n\n\n# func_convert_file_noop ARG\n# Copy ARG to func_to_host_file_result.\nfunc_convert_file_noop ()\n{\n  func_to_host_file_result=$1\n}\n# end func_convert_file_noop\n\n\n# func_convert_file_msys_to_w32 ARG\n# Convert file name ARG from (mingw) MSYS to (mingw) w32 format; automatic\n# conversion to w32 is not available inside the cwrapper.  Returns result in\n# func_to_host_file_result.\nfunc_convert_file_msys_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_file_result=$1\n  if test -n \"$1\"; then\n    func_convert_core_msys_to_w32 \"$1\"\n    func_to_host_file_result=$func_convert_core_msys_to_w32_result\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_msys_to_w32\n\n\n# func_convert_file_cygwin_to_w32 ARG\n# Convert file name ARG from Cygwin to w32 format.  Returns result in\n# func_to_host_file_result.\nfunc_convert_file_cygwin_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_file_result=$1\n  if test -n \"$1\"; then\n    # because $build is cygwin, we call \"the\" cygpath in $PATH; no need to use\n    # LT_CYGPATH in this case.\n    func_to_host_file_result=`cygpath -m \"$1\"`\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_cygwin_to_w32\n\n\n# func_convert_file_nix_to_w32 ARG\n# Convert file name ARG from *nix to w32 format.  Requires a wine environment\n# and a working winepath. Returns result in func_to_host_file_result.\nfunc_convert_file_nix_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_file_result=$1\n  if test -n \"$1\"; then\n    func_convert_core_file_wine_to_w32 \"$1\"\n    func_to_host_file_result=$func_convert_core_file_wine_to_w32_result\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_nix_to_w32\n\n\n# func_convert_file_msys_to_cygwin ARG\n# Convert file name ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.\n# Returns result in func_to_host_file_result.\nfunc_convert_file_msys_to_cygwin ()\n{\n  $debug_cmd\n\n  func_to_host_file_result=$1\n  if test -n \"$1\"; then\n    func_convert_core_msys_to_w32 \"$1\"\n    func_cygpath -u \"$func_convert_core_msys_to_w32_result\"\n    func_to_host_file_result=$func_cygpath_result\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_msys_to_cygwin\n\n\n# func_convert_file_nix_to_cygwin ARG\n# Convert file name ARG from *nix to Cygwin format.  Requires Cygwin installed\n# in a wine environment, working winepath, and LT_CYGPATH set.  Returns result\n# in func_to_host_file_result.\nfunc_convert_file_nix_to_cygwin ()\n{\n  $debug_cmd\n\n  func_to_host_file_result=$1\n  if test -n \"$1\"; then\n    # convert from *nix to w32, then use cygpath to convert from w32 to cygwin.\n    func_convert_core_file_wine_to_w32 \"$1\"\n    func_cygpath -u \"$func_convert_core_file_wine_to_w32_result\"\n    func_to_host_file_result=$func_cygpath_result\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_nix_to_cygwin\n\n\n#############################################\n# $build to $host PATH CONVERSION FUNCTIONS #\n#############################################\n# invoked via '$to_host_path_cmd ARG'\n#\n# In each case, ARG is the path to be converted from $build to $host format.\n# The result will be available in $func_to_host_path_result.\n#\n# Path separators are also converted from $build format to $host format.  If\n# ARG begins or ends with a path separator character, it is preserved (but\n# converted to $host format) on output.\n#\n# All path conversion functions are named using the following convention:\n#   file name conversion function    : func_convert_file_X_to_Y ()\n#   path conversion function         : func_convert_path_X_to_Y ()\n# where, for any given $build/$host combination the 'X_to_Y' value is the\n# same.  If conversion functions are added for new $build/$host combinations,\n# the two new functions must follow this pattern, or func_init_to_host_path_cmd\n# will break.\n\n\n# func_init_to_host_path_cmd\n# Ensures that function \"pointer\" variable $to_host_path_cmd is set to the\n# appropriate value, based on the value of $to_host_file_cmd.\nto_host_path_cmd=\nfunc_init_to_host_path_cmd ()\n{\n  $debug_cmd\n\n  if test -z \"$to_host_path_cmd\"; then\n    func_stripname 'func_convert_file_' '' \"$to_host_file_cmd\"\n    to_host_path_cmd=func_convert_path_$func_stripname_result\n  fi\n}\n\n\n# func_to_host_path ARG\n# Converts the path ARG from $build format to $host format. Return result\n# in func_to_host_path_result.\nfunc_to_host_path ()\n{\n  $debug_cmd\n\n  func_init_to_host_path_cmd\n  $to_host_path_cmd \"$1\"\n}\n# end func_to_host_path\n\n\n# func_convert_path_noop ARG\n# Copy ARG to func_to_host_path_result.\nfunc_convert_path_noop ()\n{\n  func_to_host_path_result=$1\n}\n# end func_convert_path_noop\n\n\n# func_convert_path_msys_to_w32 ARG\n# Convert path ARG from (mingw) MSYS to (mingw) w32 format; automatic\n# conversion to w32 is not available inside the cwrapper.  Returns result in\n# func_to_host_path_result.\nfunc_convert_path_msys_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_path_result=$1\n  if test -n \"$1\"; then\n    # Remove leading and trailing path separator characters from ARG.  MSYS\n    # behavior is inconsistent here; cygpath turns them into '.;' and ';.';\n    # and winepath ignores them completely.\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_msys_to_w32 \"$func_to_host_path_tmp1\"\n    func_to_host_path_result=$func_convert_core_msys_to_w32_result\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_msys_to_w32\n\n\n# func_convert_path_cygwin_to_w32 ARG\n# Convert path ARG from Cygwin to w32 format.  Returns result in\n# func_to_host_file_result.\nfunc_convert_path_cygwin_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_path_result=$1\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_to_host_path_result=`cygpath -m -p \"$func_to_host_path_tmp1\"`\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_cygwin_to_w32\n\n\n# func_convert_path_nix_to_w32 ARG\n# Convert path ARG from *nix to w32 format.  Requires a wine environment and\n# a working winepath.  Returns result in func_to_host_file_result.\nfunc_convert_path_nix_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_path_result=$1\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_path_wine_to_w32 \"$func_to_host_path_tmp1\"\n    func_to_host_path_result=$func_convert_core_path_wine_to_w32_result\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_nix_to_w32\n\n\n# func_convert_path_msys_to_cygwin ARG\n# Convert path ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.\n# Returns result in func_to_host_file_result.\nfunc_convert_path_msys_to_cygwin ()\n{\n  $debug_cmd\n\n  func_to_host_path_result=$1\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_msys_to_w32 \"$func_to_host_path_tmp1\"\n    func_cygpath -u -p \"$func_convert_core_msys_to_w32_result\"\n    func_to_host_path_result=$func_cygpath_result\n    func_convert_path_check : : \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" : \"$1\"\n  fi\n}\n# end func_convert_path_msys_to_cygwin\n\n\n# func_convert_path_nix_to_cygwin ARG\n# Convert path ARG from *nix to Cygwin format.  Requires Cygwin installed in a\n# a wine environment, working winepath, and LT_CYGPATH set.  Returns result in\n# func_to_host_file_result.\nfunc_convert_path_nix_to_cygwin ()\n{\n  $debug_cmd\n\n  func_to_host_path_result=$1\n  if test -n \"$1\"; then\n    # Remove leading and trailing path separator characters from\n    # ARG. msys behavior is inconsistent here, cygpath turns them\n    # into '.;' and ';.', and winepath ignores them completely.\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_path_wine_to_w32 \"$func_to_host_path_tmp1\"\n    func_cygpath -u -p \"$func_convert_core_path_wine_to_w32_result\"\n    func_to_host_path_result=$func_cygpath_result\n    func_convert_path_check : : \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" : \"$1\"\n  fi\n}\n# end func_convert_path_nix_to_cygwin\n\n\n# func_dll_def_p FILE\n# True iff FILE is a Windows DLL '.def' file.\n# Keep in sync with _LT_DLL_DEF_P in libtool.m4\nfunc_dll_def_p ()\n{\n  $debug_cmd\n\n  func_dll_def_p_tmp=`$SED -n \\\n    -e 's/^[\t ]*//' \\\n    -e '/^\\(;.*\\)*$/d' \\\n    -e 's/^\\(EXPORTS\\|LIBRARY\\)\\([\t ].*\\)*$/DEF/p' \\\n    -e q \\\n    \"$1\"`\n  test DEF = \"$func_dll_def_p_tmp\"\n}\n\n\n# func_mode_compile arg...\nfunc_mode_compile ()\n{\n    $debug_cmd\n\n    # Get the compilation command and the source file.\n    base_compile=\n    srcfile=$nonopt  #  always keep a non-empty value in \"srcfile\"\n    suppress_opt=yes\n    suppress_output=\n    arg_mode=normal\n    libobj=\n    later=\n    pie_flag=\n\n    for arg\n    do\n      case $arg_mode in\n      arg  )\n\t# do not \"continue\".  Instead, add this to base_compile\n\tlastarg=$arg\n\targ_mode=normal\n\t;;\n\n      target )\n\tlibobj=$arg\n\targ_mode=normal\n\tcontinue\n\t;;\n\n      normal )\n\t# Accept any command-line options.\n\tcase $arg in\n\t-o)\n\t  test -n \"$libobj\" && \\\n\t    func_fatal_error \"you cannot specify '-o' more than once\"\n\t  arg_mode=target\n\t  continue\n\t  ;;\n\n\t-pie | -fpie | -fPIE)\n          func_append pie_flag \" $arg\"\n\t  continue\n\t  ;;\n\n\t-shared | -static | -prefer-pic | -prefer-non-pic)\n\t  func_append later \" $arg\"\n\t  continue\n\t  ;;\n\n\t-no-suppress)\n\t  suppress_opt=no\n\t  continue\n\t  ;;\n\n\t-Xcompiler)\n\t  arg_mode=arg  #  the next one goes into the \"base_compile\" arg list\n\t  continue      #  The current \"srcfile\" will either be retained or\n\t  ;;            #  replaced later.  I would guess that would be a bug.\n\n\t-Wc,*)\n\t  func_stripname '-Wc,' '' \"$arg\"\n\t  args=$func_stripname_result\n\t  lastarg=\n\t  save_ifs=$IFS; IFS=,\n\t  for arg in $args; do\n\t    IFS=$save_ifs\n\t    func_append_quoted lastarg \"$arg\"\n\t  done\n\t  IFS=$save_ifs\n\t  func_stripname ' ' '' \"$lastarg\"\n\t  lastarg=$func_stripname_result\n\n\t  # Add the arguments to base_compile.\n\t  func_append base_compile \" $lastarg\"\n\t  continue\n\t  ;;\n\n\t*)\n\t  # Accept the current argument as the source file.\n\t  # The previous \"srcfile\" becomes the current argument.\n\t  #\n\t  lastarg=$srcfile\n\t  srcfile=$arg\n\t  ;;\n\tesac  #  case $arg\n\t;;\n      esac    #  case $arg_mode\n\n      # Aesthetically quote the previous argument.\n      func_append_quoted base_compile \"$lastarg\"\n    done # for arg\n\n    case $arg_mode in\n    arg)\n      func_fatal_error \"you must specify an argument for -Xcompile\"\n      ;;\n    target)\n      func_fatal_error \"you must specify a target with '-o'\"\n      ;;\n    *)\n      # Get the name of the library object.\n      test -z \"$libobj\" && {\n\tfunc_basename \"$srcfile\"\n\tlibobj=$func_basename_result\n      }\n      ;;\n    esac\n\n    # Recognize several different file suffixes.\n    # If the user specifies -o file.o, it is replaced with file.lo\n    case $libobj in\n    *.[cCFSifmso] | \\\n    *.ada | *.adb | *.ads | *.asm | \\\n    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \\\n    *.[fF][09]? | *.for | *.java | *.go | *.obj | *.sx | *.cu | *.cup)\n      func_xform \"$libobj\"\n      libobj=$func_xform_result\n      ;;\n    esac\n\n    case $libobj in\n    *.lo) func_lo2o \"$libobj\"; obj=$func_lo2o_result ;;\n    *)\n      func_fatal_error \"cannot determine name of library object from '$libobj'\"\n      ;;\n    esac\n\n    func_infer_tag $base_compile\n\n    for arg in $later; do\n      case $arg in\n      -shared)\n\ttest yes = \"$build_libtool_libs\" \\\n\t  || func_fatal_configuration \"cannot build a shared library\"\n\tbuild_old_libs=no\n\tcontinue\n\t;;\n\n      -static)\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tcontinue\n\t;;\n\n      -prefer-pic)\n\tpic_mode=yes\n\tcontinue\n\t;;\n\n      -prefer-non-pic)\n\tpic_mode=no\n\tcontinue\n\t;;\n      esac\n    done\n\n    func_quote_for_eval \"$libobj\"\n    test \"X$libobj\" != \"X$func_quote_for_eval_result\" \\\n      && $ECHO \"X$libobj\" | $GREP '[]~#^*{};<>?\"'\"'\"'\t &()|`$[]' \\\n      && func_warning \"libobj name '$libobj' may not contain shell special characters.\"\n    func_dirname_and_basename \"$obj\" \"/\" \"\"\n    objname=$func_basename_result\n    xdir=$func_dirname_result\n    lobj=$xdir$objdir/$objname\n\n    test -z \"$base_compile\" && \\\n      func_fatal_help \"you must specify a compilation command\"\n\n    # Delete any leftover library objects.\n    if test yes = \"$build_old_libs\"; then\n      removelist=\"$obj $lobj $libobj ${libobj}T\"\n    else\n      removelist=\"$lobj $libobj ${libobj}T\"\n    fi\n\n    # On Cygwin there's no \"real\" PIC flag so we must build both object types\n    case $host_os in\n    cygwin* | mingw* | pw32* | os2* | cegcc*)\n      pic_mode=default\n      ;;\n    esac\n    if test no = \"$pic_mode\" && test pass_all != \"$deplibs_check_method\"; then\n      # non-PIC code in shared libraries is not supported\n      pic_mode=default\n    fi\n\n    # Calculate the filename of the output object if compiler does\n    # not support -o with -c\n    if test no = \"$compiler_c_o\"; then\n      output_obj=`$ECHO \"$srcfile\" | $SED 's%^.*/%%; s%\\.[^.]*$%%'`.$objext\n      lockfile=$output_obj.lock\n    else\n      output_obj=\n      need_locks=no\n      lockfile=\n    fi\n\n    # Lock this critical section if it is needed\n    # We use this script file to make the link, it avoids creating a new file\n    if test yes = \"$need_locks\"; then\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    elif test warn = \"$need_locks\"; then\n      if test -f \"$lockfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile exists and contains:\n`cat $lockfile 2>/dev/null`\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support '-c' and '-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n      func_append removelist \" $output_obj\"\n      $ECHO \"$srcfile\" > \"$lockfile\"\n    fi\n\n    $opt_dry_run || $RM $removelist\n    func_append removelist \" $lockfile\"\n    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15\n\n    func_to_tool_file \"$srcfile\" func_convert_file_msys_to_w32\n    srcfile=$func_to_tool_file_result\n    func_quote_for_eval \"$srcfile\"\n    qsrcfile=$func_quote_for_eval_result\n\n    # Only build a PIC object if we are building libtool libraries.\n    if test yes = \"$build_libtool_libs\"; then\n      # Without this assignment, base_compile gets emptied.\n      fbsd_hideous_sh_bug=$base_compile\n\n      if test no != \"$pic_mode\"; then\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      else\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile\"\n      fi\n\n      func_mkdir_p \"$xdir$objdir\"\n\n      if test -z \"$output_obj\"; then\n\t# Place PIC objects in $objdir\n\tfunc_append command \" -o $lobj\"\n      fi\n\n      func_show_eval_locale \"$command\"\t\\\n          'test -n \"$output_obj\" && $RM $removelist; exit $EXIT_FAILURE'\n\n      if test warn = \"$need_locks\" &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support '-c' and '-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed, then go on to compile the next one\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$lobj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$lobj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n\n      # Allow error messages only from the first compilation.\n      if test yes = \"$suppress_opt\"; then\n\tsuppress_output=' >/dev/null 2>&1'\n      fi\n    fi\n\n    # Only build a position-dependent object if we build old libraries.\n    if test yes = \"$build_old_libs\"; then\n      if test yes != \"$pic_mode\"; then\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile$pie_flag\"\n      else\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      fi\n      if test yes = \"$compiler_c_o\"; then\n\tfunc_append command \" -o $obj\"\n      fi\n\n      # Suppress compiler output if we already did a PIC compilation.\n      func_append command \"$suppress_output\"\n      func_show_eval_locale \"$command\" \\\n        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'\n\n      if test warn = \"$need_locks\" &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support '-c' and '-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$obj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$obj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n    fi\n\n    $opt_dry_run || {\n      func_write_libtool_object \"$libobj\" \"$objdir/$objname\" \"$objname\"\n\n      # Unlock the critical section if it was locked\n      if test no != \"$need_locks\"; then\n\tremovelist=$lockfile\n        $RM \"$lockfile\"\n      fi\n    }\n\n    exit $EXIT_SUCCESS\n}\n\n$opt_help || {\n  test compile = \"$opt_mode\" && func_mode_compile ${1+\"$@\"}\n}\n\nfunc_mode_help ()\n{\n    # We need to display help for each of the modes.\n    case $opt_mode in\n      \"\")\n        # Generic help is extracted from the usage comments\n        # at the start of this file.\n        func_help\n        ;;\n\n      clean)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...\n\nRemove files from the build directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically '/bin/rm').  RM-OPTIONS are options (such as '-f') to be passed\nto RM.\n\nIf FILE is a libtool library, object or program, all the files associated\nwith it are deleted. Otherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      compile)\n      $ECHO \\\n\"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE\n\nCompile a source file into a libtool library object.\n\nThis mode accepts the following additional options:\n\n  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE\n  -no-suppress      do not suppress compiler output for multiple passes\n  -prefer-pic       try to build PIC objects only\n  -prefer-non-pic   try to build non-PIC objects only\n  -shared           do not build a '.o' file suitable for static linking\n  -static           only build a '.o' file suitable for static linking\n  -Wc,FLAG          pass FLAG directly to the compiler\n\nCOMPILE-COMMAND is a command to be used in creating a 'standard' object file\nfrom the given SOURCEFILE.\n\nThe output file name is determined by removing the directory component from\nSOURCEFILE, then substituting the C source code suffix '.c' with the\nlibrary object suffix, '.lo'.\"\n        ;;\n\n      execute)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...\n\nAutomatically set library path, then run a program.\n\nThis mode accepts the following additional options:\n\n  -dlopen FILE      add the directory containing FILE to the library path\n\nThis mode sets the library path environment variable according to '-dlopen'\nflags.\n\nIf any of the ARGS are libtool executable wrappers, then they are translated\ninto their corresponding uninstalled binary, and any of their required library\ndirectories are added to the library path.\n\nThen, COMMAND is executed, with ARGS as arguments.\"\n        ;;\n\n      finish)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...\n\nComplete the installation of libtool libraries.\n\nEach LIBDIR is a directory that contains libtool libraries.\n\nThe commands that this mode executes may require superuser privileges.  Use\nthe '--dry-run' option if you just want to see what would be executed.\"\n        ;;\n\n      install)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...\n\nInstall executables or libraries.\n\nINSTALL-COMMAND is the installation command.  The first component should be\neither the 'install' or 'cp' program.\n\nThe following components of INSTALL-COMMAND are treated specially:\n\n  -inst-prefix-dir PREFIX-DIR  Use PREFIX-DIR as a staging area for installation\n\nThe rest of the components are interpreted as arguments to that command (only\nBSD-compatible install options are recognized).\"\n        ;;\n\n      link)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...\n\nLink object files or libraries together to form another library, or to\ncreate an executable program.\n\nLINK-COMMAND is a command using the C compiler that you would use to create\na program from several object files.\n\nThe following components of LINK-COMMAND are treated specially:\n\n  -all-static       do not do any dynamic linking at all\n  -avoid-version    do not add a version suffix if possible\n  -bindir BINDIR    specify path to binaries directory (for systems where\n                    libraries must be found in the PATH setting at runtime)\n  -dlopen FILE      '-dlpreopen' FILE if it cannot be dlopened at runtime\n  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols\n  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)\n  -export-symbols SYMFILE\n                    try to export only the symbols listed in SYMFILE\n  -export-symbols-regex REGEX\n                    try to export only the symbols matching REGEX\n  -LLIBDIR          search LIBDIR for required installed libraries\n  -lNAME            OUTPUT-FILE requires the installed library libNAME\n  -module           build a library that can dlopened\n  -no-fast-install  disable the fast-install mode\n  -no-install       link a not-installable executable\n  -no-undefined     declare that a library does not refer to external symbols\n  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects\n  -objectlist FILE  use a list of object files found in FILE to specify objects\n  -os2dllname NAME  force a short DLL name on OS/2 (no effect on other OSes)\n  -precious-files-regex REGEX\n                    don't remove output files matching REGEX\n  -release RELEASE  specify package release information\n  -rpath LIBDIR     the created library will eventually be installed in LIBDIR\n  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries\n  -shared           only do dynamic linking of libtool libraries\n  -shrext SUFFIX    override the standard shared library file extension\n  -static           do not do any dynamic linking of uninstalled libtool libraries\n  -static-libtool-libs\n                    do not do any dynamic linking of libtool libraries\n  -version-info CURRENT[:REVISION[:AGE]]\n                    specify library version info [each variable defaults to 0]\n  -weak LIBNAME     declare that the target provides the LIBNAME interface\n  -Wc,FLAG\n  -Xcompiler FLAG   pass linker-specific FLAG directly to the compiler\n  -Wl,FLAG\n  -Xlinker FLAG     pass linker-specific FLAG directly to the linker\n  -XCClinker FLAG   pass link-specific FLAG to the compiler driver (CC)\n\nAll other options (arguments beginning with '-') are ignored.\n\nEvery other argument is treated as a filename.  Files ending in '.la' are\ntreated as uninstalled libtool libraries, other files are standard or library\nobject files.\n\nIf the OUTPUT-FILE ends in '.la', then a libtool library is created,\nonly library objects ('.lo' files) may be specified, and '-rpath' is\nrequired, except when creating a convenience library.\n\nIf OUTPUT-FILE ends in '.a' or '.lib', then a standard library is created\nusing 'ar' and 'ranlib', or on Windows using 'lib'.\n\nIf OUTPUT-FILE ends in '.lo' or '.$objext', then a reloadable object file\nis created, otherwise an executable program is created.\"\n        ;;\n\n      uninstall)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...\n\nRemove libraries from an installation directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically '/bin/rm').  RM-OPTIONS are options (such as '-f') to be passed\nto RM.\n\nIf FILE is a libtool library, all the files associated with it are deleted.\nOtherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      *)\n        func_fatal_help \"invalid operation mode '$opt_mode'\"\n        ;;\n    esac\n\n    echo\n    $ECHO \"Try '$progname --help' for more information about other modes.\"\n}\n\n# Now that we've collected a possible --mode arg, show help if necessary\nif $opt_help; then\n  if test : = \"$opt_help\"; then\n    func_mode_help\n  else\n    {\n      func_help noexit\n      for opt_mode in compile link execute install finish uninstall clean; do\n\tfunc_mode_help\n      done\n    } | $SED -n '1p; 2,$s/^Usage:/  or: /p'\n    {\n      func_help noexit\n      for opt_mode in compile link execute install finish uninstall clean; do\n\techo\n\tfunc_mode_help\n      done\n    } |\n    $SED '1d\n      /^When reporting/,/^Report/{\n\tH\n\td\n      }\n      $x\n      /information about other modes/d\n      /more detailed .*MODE/d\n      s/^Usage:.*--mode=\\([^ ]*\\) .*/Description of \\1 mode:/'\n  fi\n  exit $?\nfi\n\n\n# func_mode_execute arg...\nfunc_mode_execute ()\n{\n    $debug_cmd\n\n    # The first argument is the command name.\n    cmd=$nonopt\n    test -z \"$cmd\" && \\\n      func_fatal_help \"you must specify a COMMAND\"\n\n    # Handle -dlopen flags immediately.\n    for file in $opt_dlopen; do\n      test -f \"$file\" \\\n\t|| func_fatal_help \"'$file' is not a file\"\n\n      dir=\n      case $file in\n      *.la)\n\tfunc_resolve_sysroot \"$file\"\n\tfile=$func_resolve_sysroot_result\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"'$lib' is not a valid libtool archive\"\n\n\t# Read the libtool library.\n\tdlname=\n\tlibrary_names=\n\tfunc_source \"$file\"\n\n\t# Skip this library if it cannot be dlopened.\n\tif test -z \"$dlname\"; then\n\t  # Warn if it was a shared library.\n\t  test -n \"$library_names\" && \\\n\t    func_warning \"'$file' was not linked with '-export-dynamic'\"\n\t  continue\n\tfi\n\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=$func_dirname_result\n\n\tif test -f \"$dir/$objdir/$dlname\"; then\n\t  func_append dir \"/$objdir\"\n\telse\n\t  if test ! -f \"$dir/$dlname\"; then\n\t    func_fatal_error \"cannot find '$dlname' in '$dir' or '$dir/$objdir'\"\n\t  fi\n\tfi\n\t;;\n\n      *.lo)\n\t# Just add the directory containing the .lo file.\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=$func_dirname_result\n\t;;\n\n      *)\n\tfunc_warning \"'-dlopen' is ignored for non-libtool libraries and objects\"\n\tcontinue\n\t;;\n      esac\n\n      # Get the absolute pathname.\n      absdir=`cd \"$dir\" && pwd`\n      test -n \"$absdir\" && dir=$absdir\n\n      # Now add the directory to shlibpath_var.\n      if eval \"test -z \\\"\\$$shlibpath_var\\\"\"; then\n\teval \"$shlibpath_var=\\\"\\$dir\\\"\"\n      else\n\teval \"$shlibpath_var=\\\"\\$dir:\\$$shlibpath_var\\\"\"\n      fi\n    done\n\n    # This variable tells wrapper scripts just to set shlibpath_var\n    # rather than running their programs.\n    libtool_execute_magic=$magic\n\n    # Check if any of the arguments is a wrapper script.\n    args=\n    for file\n    do\n      case $file in\n      -* | *.la | *.lo ) ;;\n      *)\n\t# Do a test to see if this is really a libtool program.\n\tif func_ltwrapper_script_p \"$file\"; then\n\t  func_source \"$file\"\n\t  # Transform arg to wrapped name.\n\t  file=$progdir/$program\n\telif func_ltwrapper_executable_p \"$file\"; then\n\t  func_ltwrapper_scriptname \"$file\"\n\t  func_source \"$func_ltwrapper_scriptname_result\"\n\t  # Transform arg to wrapped name.\n\t  file=$progdir/$program\n\tfi\n\t;;\n      esac\n      # Quote arguments (to preserve shell metacharacters).\n      func_append_quoted args \"$file\"\n    done\n\n    if $opt_dry_run; then\n      # Display what would be done.\n      if test -n \"$shlibpath_var\"; then\n\teval \"\\$ECHO \\\"\\$shlibpath_var=\\$$shlibpath_var\\\"\"\n\techo \"export $shlibpath_var\"\n      fi\n      $ECHO \"$cmd$args\"\n      exit $EXIT_SUCCESS\n    else\n      if test -n \"$shlibpath_var\"; then\n\t# Export the shlibpath_var.\n\teval \"export $shlibpath_var\"\n      fi\n\n      # Restore saved environment variables\n      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\n      do\n\teval \"if test \\\"\\${save_$lt_var+set}\\\" = set; then\n                $lt_var=\\$save_$lt_var; export $lt_var\n\t      else\n\t\t$lt_unset $lt_var\n\t      fi\"\n      done\n\n      # Now prepare to actually exec the command.\n      exec_cmd=\\$cmd$args\n    fi\n}\n\ntest execute = \"$opt_mode\" && func_mode_execute ${1+\"$@\"}\n\n\n# func_mode_finish arg...\nfunc_mode_finish ()\n{\n    $debug_cmd\n\n    libs=\n    libdirs=\n    admincmds=\n\n    for opt in \"$nonopt\" ${1+\"$@\"}\n    do\n      if test -d \"$opt\"; then\n\tfunc_append libdirs \" $opt\"\n\n      elif test -f \"$opt\"; then\n\tif func_lalib_unsafe_p \"$opt\"; then\n\t  func_append libs \" $opt\"\n\telse\n\t  func_warning \"'$opt' is not a valid libtool archive\"\n\tfi\n\n      else\n\tfunc_fatal_error \"invalid argument '$opt'\"\n      fi\n    done\n\n    if test -n \"$libs\"; then\n      if test -n \"$lt_sysroot\"; then\n        sysroot_regex=`$ECHO \"$lt_sysroot\" | $SED \"$sed_make_literal_regex\"`\n        sysroot_cmd=\"s/\\([ ']\\)$sysroot_regex/\\1/g;\"\n      else\n        sysroot_cmd=\n      fi\n\n      # Remove sysroot references\n      if $opt_dry_run; then\n        for lib in $libs; do\n          echo \"removing references to $lt_sysroot and '=' prefixes from $lib\"\n        done\n      else\n        tmpdir=`func_mktempdir`\n        for lib in $libs; do\n\t  $SED -e \"$sysroot_cmd s/\\([ ']-[LR]\\)=/\\1/g; s/\\([ ']\\)=/\\1/g\" $lib \\\n\t    > $tmpdir/tmp-la\n\t  mv -f $tmpdir/tmp-la $lib\n\tdone\n        ${RM}r \"$tmpdir\"\n      fi\n    fi\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      for libdir in $libdirs; do\n\tif test -n \"$finish_cmds\"; then\n\t  # Do each command in the finish commands.\n\t  func_execute_cmds \"$finish_cmds\" 'admincmds=\"$admincmds\n'\"$cmd\"'\"'\n\tfi\n\tif test -n \"$finish_eval\"; then\n\t  # Do the single finish_eval.\n\t  eval cmds=\\\"$finish_eval\\\"\n\t  $opt_dry_run || eval \"$cmds\" || func_append admincmds \"\n       $cmds\"\n\tfi\n      done\n    fi\n\n    # Exit here if they wanted silent mode.\n    $opt_quiet && exit $EXIT_SUCCESS\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      echo \"----------------------------------------------------------------------\"\n      echo \"Libraries have been installed in:\"\n      for libdir in $libdirs; do\n\t$ECHO \"   $libdir\"\n      done\n      echo\n      echo \"If you ever happen to want to link against installed libraries\"\n      echo \"in a given directory, LIBDIR, you must either use libtool, and\"\n      echo \"specify the full pathname of the library, or use the '-LLIBDIR'\"\n      echo \"flag during linking and do at least one of the following:\"\n      if test -n \"$shlibpath_var\"; then\n\techo \"   - add LIBDIR to the '$shlibpath_var' environment variable\"\n\techo \"     during execution\"\n      fi\n      if test -n \"$runpath_var\"; then\n\techo \"   - add LIBDIR to the '$runpath_var' environment variable\"\n\techo \"     during linking\"\n      fi\n      if test -n \"$hardcode_libdir_flag_spec\"; then\n\tlibdir=LIBDIR\n\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\n\t$ECHO \"   - use the '$flag' linker flag\"\n      fi\n      if test -n \"$admincmds\"; then\n\t$ECHO \"   - have your system administrator run these commands:$admincmds\"\n      fi\n      if test -f /etc/ld.so.conf; then\n\techo \"   - have your system administrator add LIBDIR to '/etc/ld.so.conf'\"\n      fi\n      echo\n\n      echo \"See any operating system documentation about shared libraries for\"\n      case $host in\n\tsolaris2.[6789]|solaris2.1[0-9])\n\t  echo \"more information, such as the ld(1), crle(1) and ld.so(8) manual\"\n\t  echo \"pages.\"\n\t  ;;\n\t*)\n\t  echo \"more information, such as the ld(1) and ld.so(8) manual pages.\"\n\t  ;;\n      esac\n      echo \"----------------------------------------------------------------------\"\n    fi\n    exit $EXIT_SUCCESS\n}\n\ntest finish = \"$opt_mode\" && func_mode_finish ${1+\"$@\"}\n\n\n# func_mode_install arg...\nfunc_mode_install ()\n{\n    $debug_cmd\n\n    # There may be an optional sh(1) argument at the beginning of\n    # install_prog (especially on Windows NT).\n    if test \"$SHELL\" = \"$nonopt\" || test /bin/sh = \"$nonopt\" ||\n       # Allow the use of GNU shtool's install command.\n       case $nonopt in *shtool*) :;; *) false;; esac\n    then\n      # Aesthetically quote it.\n      func_quote_for_eval \"$nonopt\"\n      install_prog=\"$func_quote_for_eval_result \"\n      arg=$1\n      shift\n    else\n      install_prog=\n      arg=$nonopt\n    fi\n\n    # The real first argument should be the name of the installation program.\n    # Aesthetically quote it.\n    func_quote_for_eval \"$arg\"\n    func_append install_prog \"$func_quote_for_eval_result\"\n    install_shared_prog=$install_prog\n    case \" $install_prog \" in\n      *[\\\\\\ /]cp\\ *) install_cp=: ;;\n      *) install_cp=false ;;\n    esac\n\n    # We need to accept at least all the BSD install flags.\n    dest=\n    files=\n    opts=\n    prev=\n    install_type=\n    isdir=false\n    stripme=\n    no_mode=:\n    for arg\n    do\n      arg2=\n      if test -n \"$dest\"; then\n\tfunc_append files \" $dest\"\n\tdest=$arg\n\tcontinue\n      fi\n\n      case $arg in\n      -d) isdir=: ;;\n      -f)\n\tif $install_cp; then :; else\n\t  prev=$arg\n\tfi\n\t;;\n      -g | -m | -o)\n\tprev=$arg\n\t;;\n      -s)\n\tstripme=\" -s\"\n\tcontinue\n\t;;\n      -*)\n\t;;\n      *)\n\t# If the previous option needed an argument, then skip it.\n\tif test -n \"$prev\"; then\n\t  if test X-m = \"X$prev\" && test -n \"$install_override_mode\"; then\n\t    arg2=$install_override_mode\n\t    no_mode=false\n\t  fi\n\t  prev=\n\telse\n\t  dest=$arg\n\t  continue\n\tfi\n\t;;\n      esac\n\n      # Aesthetically quote the argument.\n      func_quote_for_eval \"$arg\"\n      func_append install_prog \" $func_quote_for_eval_result\"\n      if test -n \"$arg2\"; then\n\tfunc_quote_for_eval \"$arg2\"\n      fi\n      func_append install_shared_prog \" $func_quote_for_eval_result\"\n    done\n\n    test -z \"$install_prog\" && \\\n      func_fatal_help \"you must specify an install program\"\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the '$prev' option requires an argument\"\n\n    if test -n \"$install_override_mode\" && $no_mode; then\n      if $install_cp; then :; else\n\tfunc_quote_for_eval \"$install_override_mode\"\n\tfunc_append install_shared_prog \" -m $func_quote_for_eval_result\"\n      fi\n    fi\n\n    if test -z \"$files\"; then\n      if test -z \"$dest\"; then\n\tfunc_fatal_help \"no file or destination specified\"\n      else\n\tfunc_fatal_help \"you must specify a destination\"\n      fi\n    fi\n\n    # Strip any trailing slash from the destination.\n    func_stripname '' '/' \"$dest\"\n    dest=$func_stripname_result\n\n    # Check to see that the destination is a directory.\n    test -d \"$dest\" && isdir=:\n    if $isdir; then\n      destdir=$dest\n      destname=\n    else\n      func_dirname_and_basename \"$dest\" \"\" \".\"\n      destdir=$func_dirname_result\n      destname=$func_basename_result\n\n      # Not a directory, so check to see that there is only one file specified.\n      set dummy $files; shift\n      test \"$#\" -gt 1 && \\\n\tfunc_fatal_help \"'$dest' is not a directory\"\n    fi\n    case $destdir in\n    [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n    *)\n      for file in $files; do\n\tcase $file in\n\t*.lo) ;;\n\t*)\n\t  func_fatal_help \"'$destdir' must be an absolute directory name\"\n\t  ;;\n\tesac\n      done\n      ;;\n    esac\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=$magic\n\n    staticlibs=\n    future_libdirs=\n    current_libdirs=\n    for file in $files; do\n\n      # Do each installation.\n      case $file in\n      *.$libext)\n\t# Do the static libraries later.\n\tfunc_append staticlibs \" $file\"\n\t;;\n\n      *.la)\n\tfunc_resolve_sysroot \"$file\"\n\tfile=$func_resolve_sysroot_result\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"'$file' is not a valid libtool archive\"\n\n\tlibrary_names=\n\told_library=\n\trelink_command=\n\tfunc_source \"$file\"\n\n\t# Add the libdir to current_libdirs if it is the destination.\n\tif test \"X$destdir\" = \"X$libdir\"; then\n\t  case \"$current_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append current_libdirs \" $libdir\" ;;\n\t  esac\n\telse\n\t  # Note the libdir as a future libdir.\n\t  case \"$future_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append future_libdirs \" $libdir\" ;;\n\t  esac\n\tfi\n\n\tfunc_dirname \"$file\" \"/\" \"\"\n\tdir=$func_dirname_result\n\tfunc_append dir \"$objdir\"\n\n\tif test -n \"$relink_command\"; then\n\t  # Determine the prefix the user has applied to our future dir.\n\t  inst_prefix_dir=`$ECHO \"$destdir\" | $SED -e \"s%$libdir\\$%%\"`\n\n\t  # Don't allow the user to place us outside of our expected\n\t  # location b/c this prevents finding dependent libraries that\n\t  # are installed to the same prefix.\n\t  # At present, this check doesn't affect windows .dll's that\n\t  # are installed into $libdir/../bin (currently, that works fine)\n\t  # but it's something to keep an eye on.\n\t  test \"$inst_prefix_dir\" = \"$destdir\" && \\\n\t    func_fatal_error \"error: cannot install '$file' to a directory not ending in $libdir\"\n\n\t  if test -n \"$inst_prefix_dir\"; then\n\t    # Stick the inst_prefix_dir data into the link command.\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%\"`\n\t  else\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%%\"`\n\t  fi\n\n\t  func_warning \"relinking '$file'\"\n\t  func_show_eval \"$relink_command\" \\\n\t    'func_fatal_error \"error: relink '\\''$file'\\'' with the above command before installing it\"'\n\tfi\n\n\t# See the names of the shared library.\n\tset dummy $library_names; shift\n\tif test -n \"$1\"; then\n\t  realname=$1\n\t  shift\n\n\t  srcname=$realname\n\t  test -n \"$relink_command\" && srcname=${realname}T\n\n\t  # Install the shared library and build the symlinks.\n\t  func_show_eval \"$install_shared_prog $dir/$srcname $destdir/$realname\" \\\n\t      'exit $?'\n\t  tstripme=$stripme\n\t  case $host_os in\n\t  cygwin* | mingw* | pw32* | cegcc*)\n\t    case $realname in\n\t    *.dll.a)\n\t      tstripme=\n\t      ;;\n\t    esac\n\t    ;;\n\t  os2*)\n\t    case $realname in\n\t    *_dll.a)\n\t      tstripme=\n\t      ;;\n\t    esac\n\t    ;;\n\t  esac\n\t  if test -n \"$tstripme\" && test -n \"$striplib\"; then\n\t    func_show_eval \"$striplib $destdir/$realname\" 'exit $?'\n\t  fi\n\n\t  if test \"$#\" -gt 0; then\n\t    # Delete the old symlinks, and create new ones.\n\t    # Try 'ln -sf' first, because the 'ln' binary might depend on\n\t    # the symlink we replace!  Solaris /bin/ln does not understand -f,\n\t    # so we also need to try rm && ln -s.\n\t    for linkname\n\t    do\n\t      test \"$linkname\" != \"$realname\" \\\n\t\t&& func_show_eval \"(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })\"\n\t    done\n\t  fi\n\n\t  # Do each command in the postinstall commands.\n\t  lib=$destdir/$realname\n\t  func_execute_cmds \"$postinstall_cmds\" 'exit $?'\n\tfi\n\n\t# Install the pseudo-library for information purposes.\n\tfunc_basename \"$file\"\n\tname=$func_basename_result\n\tinstname=$dir/${name}i\n\tfunc_show_eval \"$install_prog $instname $destdir/$name\" 'exit $?'\n\n\t# Maybe install the static library, too.\n\ttest -n \"$old_library\" && func_append staticlibs \" $dir/$old_library\"\n\t;;\n\n      *.lo)\n\t# Install (i.e. copy) a libtool object.\n\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=$destdir/$destname\n\telse\n\t  func_basename \"$file\"\n\t  destfile=$func_basename_result\n\t  destfile=$destdir/$destfile\n\tfi\n\n\t# Deduce the name of the destination old-style object file.\n\tcase $destfile in\n\t*.lo)\n\t  func_lo2o \"$destfile\"\n\t  staticdest=$func_lo2o_result\n\t  ;;\n\t*.$objext)\n\t  staticdest=$destfile\n\t  destfile=\n\t  ;;\n\t*)\n\t  func_fatal_help \"cannot copy a libtool object to '$destfile'\"\n\t  ;;\n\tesac\n\n\t# Install the libtool object if requested.\n\ttest -n \"$destfile\" && \\\n\t  func_show_eval \"$install_prog $file $destfile\" 'exit $?'\n\n\t# Install the old object if enabled.\n\tif test yes = \"$build_old_libs\"; then\n\t  # Deduce the name of the old-style object file.\n\t  func_lo2o \"$file\"\n\t  staticobj=$func_lo2o_result\n\t  func_show_eval \"$install_prog \\$staticobj \\$staticdest\" 'exit $?'\n\tfi\n\texit $EXIT_SUCCESS\n\t;;\n\n      *)\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=$destdir/$destname\n\telse\n\t  func_basename \"$file\"\n\t  destfile=$func_basename_result\n\t  destfile=$destdir/$destfile\n\tfi\n\n\t# If the file is missing, and there is a .exe on the end, strip it\n\t# because it is most likely a libtool script we actually want to\n\t# install\n\tstripped_ext=\n\tcase $file in\n\t  *.exe)\n\t    if test ! -f \"$file\"; then\n\t      func_stripname '' '.exe' \"$file\"\n\t      file=$func_stripname_result\n\t      stripped_ext=.exe\n\t    fi\n\t    ;;\n\tesac\n\n\t# Do a test to see if this is really a libtool program.\n\tcase $host in\n\t*cygwin* | *mingw*)\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      wrapper=$func_ltwrapper_scriptname_result\n\t    else\n\t      func_stripname '' '.exe' \"$file\"\n\t      wrapper=$func_stripname_result\n\t    fi\n\t    ;;\n\t*)\n\t    wrapper=$file\n\t    ;;\n\tesac\n\tif func_ltwrapper_script_p \"$wrapper\"; then\n\t  notinst_deplibs=\n\t  relink_command=\n\n\t  func_source \"$wrapper\"\n\n\t  # Check the variables that should have been set.\n\t  test -z \"$generated_by_libtool_version\" && \\\n\t    func_fatal_error \"invalid libtool wrapper script '$wrapper'\"\n\n\t  finalize=:\n\t  for lib in $notinst_deplibs; do\n\t    # Check to see that each library is installed.\n\t    libdir=\n\t    if test -f \"$lib\"; then\n\t      func_source \"$lib\"\n\t    fi\n\t    libfile=$libdir/`$ECHO \"$lib\" | $SED 's%^.*/%%g'`\n\t    if test -n \"$libdir\" && test ! -f \"$libfile\"; then\n\t      func_warning \"'$lib' has not been installed in '$libdir'\"\n\t      finalize=false\n\t    fi\n\t  done\n\n\t  relink_command=\n\t  func_source \"$wrapper\"\n\n\t  outputname=\n\t  if test no = \"$fast_install\" && test -n \"$relink_command\"; then\n\t    $opt_dry_run || {\n\t      if $finalize; then\n\t        tmpdir=`func_mktempdir`\n\t\tfunc_basename \"$file$stripped_ext\"\n\t\tfile=$func_basename_result\n\t        outputname=$tmpdir/$file\n\t        # Replace the output file specification.\n\t        relink_command=`$ECHO \"$relink_command\" | $SED 's%@OUTPUT@%'\"$outputname\"'%g'`\n\n\t        $opt_quiet || {\n\t          func_quote_for_expand \"$relink_command\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t        }\n\t        if eval \"$relink_command\"; then :\n\t          else\n\t\t  func_error \"error: relink '$file' with the above command before installing it\"\n\t\t  $opt_dry_run || ${RM}r \"$tmpdir\"\n\t\t  continue\n\t        fi\n\t        file=$outputname\n\t      else\n\t        func_warning \"cannot relink '$file'\"\n\t      fi\n\t    }\n\t  else\n\t    # Install the binary that we compiled earlier.\n\t    file=`$ECHO \"$file$stripped_ext\" | $SED \"s%\\([^/]*\\)$%$objdir/\\1%\"`\n\t  fi\n\tfi\n\n\t# remove .exe since cygwin /usr/bin/install will append another\n\t# one anyway\n\tcase $install_prog,$host in\n\t*/usr/bin/install*,*cygwin*)\n\t  case $file:$destfile in\n\t  *.exe:*.exe)\n\t    # this is ok\n\t    ;;\n\t  *.exe:*)\n\t    destfile=$destfile.exe\n\t    ;;\n\t  *:*.exe)\n\t    func_stripname '' '.exe' \"$destfile\"\n\t    destfile=$func_stripname_result\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tfunc_show_eval \"$install_prog\\$stripme \\$file \\$destfile\" 'exit $?'\n\t$opt_dry_run || if test -n \"$outputname\"; then\n\t  ${RM}r \"$tmpdir\"\n\tfi\n\t;;\n      esac\n    done\n\n    for file in $staticlibs; do\n      func_basename \"$file\"\n      name=$func_basename_result\n\n      # Set up the ranlib parameters.\n      oldlib=$destdir/$name\n      func_to_tool_file \"$oldlib\" func_convert_file_msys_to_w32\n      tool_oldlib=$func_to_tool_file_result\n\n      func_show_eval \"$install_prog \\$file \\$oldlib\" 'exit $?'\n\n      if test -n \"$stripme\" && test -n \"$old_striplib\"; then\n\tfunc_show_eval \"$old_striplib $tool_oldlib\" 'exit $?'\n      fi\n\n      # Do each command in the postinstall commands.\n      func_execute_cmds \"$old_postinstall_cmds\" 'exit $?'\n    done\n\n    test -n \"$future_libdirs\" && \\\n      func_warning \"remember to run '$progname --finish$future_libdirs'\"\n\n    if test -n \"$current_libdirs\"; then\n      # Maybe just do a dry run.\n      $opt_dry_run && current_libdirs=\" -n$current_libdirs\"\n      exec_cmd='$SHELL \"$progpath\" $preserve_args --finish$current_libdirs'\n    else\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest install = \"$opt_mode\" && func_mode_install ${1+\"$@\"}\n\n\n# func_generate_dlsyms outputname originator pic_p\n# Extract symbols from dlprefiles and create ${outputname}S.o with\n# a dlpreopen symbol table.\nfunc_generate_dlsyms ()\n{\n    $debug_cmd\n\n    my_outputname=$1\n    my_originator=$2\n    my_pic_p=${3-false}\n    my_prefix=`$ECHO \"$my_originator\" | $SED 's%[^a-zA-Z0-9]%_%g'`\n    my_dlsyms=\n\n    if test -n \"$dlfiles$dlprefiles\" || test no != \"$dlself\"; then\n      if test -n \"$NM\" && test -n \"$global_symbol_pipe\"; then\n\tmy_dlsyms=${my_outputname}S.c\n      else\n\tfunc_error \"not configured to extract global symbols from dlpreopened files\"\n      fi\n    fi\n\n    if test -n \"$my_dlsyms\"; then\n      case $my_dlsyms in\n      \"\") ;;\n      *.c)\n\t# Discover the nlist of each of the dlfiles.\n\tnlist=$output_objdir/$my_outputname.nm\n\n\tfunc_show_eval \"$RM $nlist ${nlist}S ${nlist}T\"\n\n\t# Parse the name list into a source file.\n\tfunc_verbose \"creating $output_objdir/$my_dlsyms\"\n\n\t$opt_dry_run || $ECHO > \"$output_objdir/$my_dlsyms\" \"\\\n/* $my_dlsyms - symbol resolution table for '$my_outputname' dlsym emulation. */\n/* Generated by $PROGRAM (GNU $PACKAGE) $VERSION */\n\n#ifdef __cplusplus\nextern \\\"C\\\" {\n#endif\n\n#if defined __GNUC__ && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 4)) || (__GNUC__ > 4))\n#pragma GCC diagnostic ignored \\\"-Wstrict-prototypes\\\"\n#endif\n\n/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */\n#if defined _WIN32 || defined __CYGWIN__ || defined _WIN32_WCE\n/* DATA imports from DLLs on WIN32 can't be const, because runtime\n   relocations are performed -- see ld's documentation on pseudo-relocs.  */\n# define LT_DLSYM_CONST\n#elif defined __osf__\n/* This system does not cope well with relocations in const data.  */\n# define LT_DLSYM_CONST\n#else\n# define LT_DLSYM_CONST const\n#endif\n\n#define STREQ(s1, s2) (strcmp ((s1), (s2)) == 0)\n\n/* External symbol declarations for the compiler. */\\\n\"\n\n\tif test yes = \"$dlself\"; then\n\t  func_verbose \"generating symbol list for '$output'\"\n\n\t  $opt_dry_run || echo ': @PROGRAM@ ' > \"$nlist\"\n\n\t  # Add our own program objects to the symbol list.\n\t  progfiles=`$ECHO \"$objs$old_deplibs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\t  for progfile in $progfiles; do\n\t    func_to_tool_file \"$progfile\" func_convert_file_msys_to_w32\n\t    func_verbose \"extracting global C symbols from '$func_to_tool_file_result'\"\n\t    $opt_dry_run || eval \"$NM $func_to_tool_file_result | $global_symbol_pipe >> '$nlist'\"\n\t  done\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  if test -n \"$export_symbols_regex\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -e \"$export_symbols_regex\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  # Prepare the list of exported symbols\n\t  if test -z \"$export_symbols\"; then\n\t    export_symbols=$output_objdir/$outputname.exp\n\t    $opt_dry_run || {\n\t      $RM $export_symbols\n\t      eval \"$SED -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \\(.*\\)$/\\1/p' \"'< \"$nlist\" > \"$export_symbols\"'\n\t      case $host in\n\t      *cygwin* | *mingw* | *cegcc* )\n                eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n                eval 'cat \"$export_symbols\" >> \"$output_objdir/$outputname.def\"'\n\t        ;;\n\t      esac\n\t    }\n\t  else\n\t    $opt_dry_run || {\n\t      eval \"$SED -e 's/\\([].[*^$]\\)/\\\\\\\\\\1/g' -e 's/^/ /' -e 's/$/$/'\"' < \"$export_symbols\" > \"$output_objdir/$outputname.exp\"'\n\t      eval '$GREP -f \"$output_objdir/$outputname.exp\" < \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t      case $host in\n\t        *cygwin* | *mingw* | *cegcc* )\n\t          eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n\t          eval 'cat \"$nlist\" >> \"$output_objdir/$outputname.def\"'\n\t          ;;\n\t      esac\n\t    }\n\t  fi\n\tfi\n\n\tfor dlprefile in $dlprefiles; do\n\t  func_verbose \"extracting global C symbols from '$dlprefile'\"\n\t  func_basename \"$dlprefile\"\n\t  name=$func_basename_result\n          case $host in\n\t    *cygwin* | *mingw* | *cegcc* )\n\t      # if an import library, we need to obtain dlname\n\t      if func_win32_import_lib_p \"$dlprefile\"; then\n\t        func_tr_sh \"$dlprefile\"\n\t        eval \"curr_lafile=\\$libfile_$func_tr_sh_result\"\n\t        dlprefile_dlbasename=\n\t        if test -n \"$curr_lafile\" && func_lalib_p \"$curr_lafile\"; then\n\t          # Use subshell, to avoid clobbering current variable values\n\t          dlprefile_dlname=`source \"$curr_lafile\" && echo \"$dlname\"`\n\t          if test -n \"$dlprefile_dlname\"; then\n\t            func_basename \"$dlprefile_dlname\"\n\t            dlprefile_dlbasename=$func_basename_result\n\t          else\n\t            # no lafile. user explicitly requested -dlpreopen <import library>.\n\t            $sharedlib_from_linklib_cmd \"$dlprefile\"\n\t            dlprefile_dlbasename=$sharedlib_from_linklib_result\n\t          fi\n\t        fi\n\t        $opt_dry_run || {\n\t          if test -n \"$dlprefile_dlbasename\"; then\n\t            eval '$ECHO \": $dlprefile_dlbasename\" >> \"$nlist\"'\n\t          else\n\t            func_warning \"Could not compute DLL name from $name\"\n\t            eval '$ECHO \": $name \" >> \"$nlist\"'\n\t          fi\n\t          func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t          eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe |\n\t            $SED -e '/I __imp/d' -e 's/I __nm_/D /;s/_nm__//' >> '$nlist'\"\n\t        }\n\t      else # not an import lib\n\t        $opt_dry_run || {\n\t          eval '$ECHO \": $name \" >> \"$nlist\"'\n\t          func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t          eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t        }\n\t      fi\n\t    ;;\n\t    *)\n\t      $opt_dry_run || {\n\t        eval '$ECHO \": $name \" >> \"$nlist\"'\n\t        func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t        eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t      }\n\t    ;;\n          esac\n\tdone\n\n\t$opt_dry_run || {\n\t  # Make sure we have at least an empty file.\n\t  test -f \"$nlist\" || : > \"$nlist\"\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T\n\t    $MV \"$nlist\"T \"$nlist\"\n\t  fi\n\n\t  # Try sorting and uniquifying the output.\n\t  if $GREP -v \"^: \" < \"$nlist\" |\n\t      if sort -k 3 </dev/null >/dev/null 2>&1; then\n\t\tsort -k 3\n\t      else\n\t\tsort +2\n\t      fi |\n\t      uniq > \"$nlist\"S; then\n\t    :\n\t  else\n\t    $GREP -v \"^: \" < \"$nlist\" > \"$nlist\"S\n\t  fi\n\n\t  if test -f \"$nlist\"S; then\n\t    eval \"$global_symbol_to_cdecl\"' < \"$nlist\"S >> \"$output_objdir/$my_dlsyms\"'\n\t  else\n\t    echo '/* NONE */' >> \"$output_objdir/$my_dlsyms\"\n\t  fi\n\n\t  func_show_eval '$RM \"${nlist}I\"'\n\t  if test -n \"$global_symbol_to_import\"; then\n\t    eval \"$global_symbol_to_import\"' < \"$nlist\"S > \"$nlist\"I'\n\t  fi\n\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n\n/* The mapping between symbol names and symbols.  */\ntypedef struct {\n  const char *name;\n  void *address;\n} lt_dlsymlist;\nextern LT_DLSYM_CONST lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[];\\\n\"\n\n\t  if test -s \"$nlist\"I; then\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\nstatic void lt_syminit(void)\n{\n  LT_DLSYM_CONST lt_dlsymlist *symbol = lt_${my_prefix}_LTX_preloaded_symbols;\n  for (; symbol->name; ++symbol)\n    {\"\n\t    $SED 's/.*/      if (STREQ (symbol->name, \\\"&\\\")) symbol->address = (void *) \\&&;/' < \"$nlist\"I >> \"$output_objdir/$my_dlsyms\"\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\n    }\n}\"\n\t  fi\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\nLT_DLSYM_CONST lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[] =\n{ {\\\"$my_originator\\\", (void *) 0},\"\n\n\t  if test -s \"$nlist\"I; then\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\n  {\\\"@INIT@\\\", (void *) &lt_syminit},\"\n\t  fi\n\n\t  case $need_lib_prefix in\n\t  no)\n\t    eval \"$global_symbol_to_c_name_address\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  *)\n\t    eval \"$global_symbol_to_c_name_address_lib_prefix\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  esac\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt_${my_prefix}_LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\\\n\"\n\t} # !$opt_dry_run\n\n\tpic_flag_for_symtable=\n\tcase \"$compile_command \" in\n\t*\" -static \"*) ;;\n\t*)\n\t  case $host in\n\t  # compiling the symbol table file with pic_flag works around\n\t  # a FreeBSD bug that causes programs to crash when -lm is\n\t  # linked before any other PIC object.  But we must not use\n\t  # pic_flag when linking with -static.  The problem exists in\n\t  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.\n\t  *-*-freebsd2.*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)\n\t    pic_flag_for_symtable=\" $pic_flag -DFREEBSD_WORKAROUND\" ;;\n\t  *-*-hpux*)\n\t    pic_flag_for_symtable=\" $pic_flag\"  ;;\n\t  *)\n\t    $my_pic_p && pic_flag_for_symtable=\" $pic_flag\"\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tsymtab_cflags=\n\tfor arg in $LTCFLAGS; do\n\t  case $arg in\n\t  -pie | -fpie | -fPIE) ;;\n\t  *) func_append symtab_cflags \" $arg\" ;;\n\t  esac\n\tdone\n\n\t# Now compile the dynamic symbol file.\n\tfunc_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable \"$my_dlsyms\")' 'exit $?'\n\n\t# Clean up the generated files.\n\tfunc_show_eval '$RM \"$output_objdir/$my_dlsyms\" \"$nlist\" \"${nlist}S\" \"${nlist}T\" \"${nlist}I\"'\n\n\t# Transform the symbol file into the correct name.\n\tsymfileobj=$output_objdir/${my_outputname}S.$objext\n\tcase $host in\n\t*cygwin* | *mingw* | *cegcc* )\n\t  if test -f \"$output_objdir/$my_outputname.def\"; then\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t  else\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  fi\n\t  ;;\n\t*)\n\t  compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  ;;\n\tesac\n\t;;\n      *)\n\tfunc_fatal_error \"unknown suffix for '$my_dlsyms'\"\n\t;;\n      esac\n    else\n      # We keep going just in case the user didn't refer to\n      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe\n      # really was required.\n\n      # Nullify the symbol file.\n      compile_command=`$ECHO \"$compile_command\" | $SED \"s% @SYMFILE@%%\"`\n      finalize_command=`$ECHO \"$finalize_command\" | $SED \"s% @SYMFILE@%%\"`\n    fi\n}\n\n# func_cygming_gnu_implib_p ARG\n# This predicate returns with zero status (TRUE) if\n# ARG is a GNU/binutils-style import library. Returns\n# with nonzero status (FALSE) otherwise.\nfunc_cygming_gnu_implib_p ()\n{\n  $debug_cmd\n\n  func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n  func_cygming_gnu_implib_tmp=`$NM \"$func_to_tool_file_result\" | eval \"$global_symbol_pipe\" | $EGREP ' (_head_[A-Za-z0-9_]+_[ad]l*|[A-Za-z0-9_]+_[ad]l*_iname)$'`\n  test -n \"$func_cygming_gnu_implib_tmp\"\n}\n\n# func_cygming_ms_implib_p ARG\n# This predicate returns with zero status (TRUE) if\n# ARG is an MS-style import library. Returns\n# with nonzero status (FALSE) otherwise.\nfunc_cygming_ms_implib_p ()\n{\n  $debug_cmd\n\n  func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n  func_cygming_ms_implib_tmp=`$NM \"$func_to_tool_file_result\" | eval \"$global_symbol_pipe\" | $GREP '_NULL_IMPORT_DESCRIPTOR'`\n  test -n \"$func_cygming_ms_implib_tmp\"\n}\n\n# func_win32_libid arg\n# return the library type of file 'arg'\n#\n# Need a lot of goo to handle *both* DLLs and import libs\n# Has to be a shell function in order to 'eat' the argument\n# that is supplied when $file_magic_command is called.\n# Despite the name, also deal with 64 bit binaries.\nfunc_win32_libid ()\n{\n  $debug_cmd\n\n  win32_libid_type=unknown\n  win32_fileres=`file -L $1 2>/dev/null`\n  case $win32_fileres in\n  *ar\\ archive\\ import\\ library*) # definitely import\n    win32_libid_type=\"x86 archive import\"\n    ;;\n  *ar\\ archive*) # could be an import, or static\n    # Keep the egrep pattern in sync with the one in _LT_CHECK_MAGIC_METHOD.\n    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |\n       $EGREP 'file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)' >/dev/null; then\n      case $nm_interface in\n      \"MS dumpbin\")\n\tif func_cygming_ms_implib_p \"$1\" ||\n\t   func_cygming_gnu_implib_p \"$1\"\n\tthen\n\t  win32_nmres=import\n\telse\n\t  win32_nmres=\n\tfi\n\t;;\n      *)\n\tfunc_to_tool_file \"$1\" func_convert_file_msys_to_w32\n\twin32_nmres=`eval $NM -f posix -A \\\"$func_to_tool_file_result\\\" |\n\t  $SED -n -e '\n\t    1,100{\n\t\t/ I /{\n\t\t    s|.*|import|\n\t\t    p\n\t\t    q\n\t\t}\n\t    }'`\n\t;;\n      esac\n      case $win32_nmres in\n      import*)  win32_libid_type=\"x86 archive import\";;\n      *)        win32_libid_type=\"x86 archive static\";;\n      esac\n    fi\n    ;;\n  *DLL*)\n    win32_libid_type=\"x86 DLL\"\n    ;;\n  *executable*) # but shell scripts are \"executable\" too...\n    case $win32_fileres in\n    *MS\\ Windows\\ PE\\ Intel*)\n      win32_libid_type=\"x86 DLL\"\n      ;;\n    esac\n    ;;\n  esac\n  $ECHO \"$win32_libid_type\"\n}\n\n# func_cygming_dll_for_implib ARG\n#\n# Platform-specific function to extract the\n# name of the DLL associated with the specified\n# import library ARG.\n# Invoked by eval'ing the libtool variable\n#    $sharedlib_from_linklib_cmd\n# Result is available in the variable\n#    $sharedlib_from_linklib_result\nfunc_cygming_dll_for_implib ()\n{\n  $debug_cmd\n\n  sharedlib_from_linklib_result=`$DLLTOOL --identify-strict --identify \"$1\"`\n}\n\n# func_cygming_dll_for_implib_fallback_core SECTION_NAME LIBNAMEs\n#\n# The is the core of a fallback implementation of a\n# platform-specific function to extract the name of the\n# DLL associated with the specified import library LIBNAME.\n#\n# SECTION_NAME is either .idata$6 or .idata$7, depending\n# on the platform and compiler that created the implib.\n#\n# Echos the name of the DLL associated with the\n# specified import library.\nfunc_cygming_dll_for_implib_fallback_core ()\n{\n  $debug_cmd\n\n  match_literal=`$ECHO \"$1\" | $SED \"$sed_make_literal_regex\"`\n  $OBJDUMP -s --section \"$1\" \"$2\" 2>/dev/null |\n    $SED '/^Contents of section '\"$match_literal\"':/{\n      # Place marker at beginning of archive member dllname section\n      s/.*/====MARK====/\n      p\n      d\n    }\n    # These lines can sometimes be longer than 43 characters, but\n    # are always uninteresting\n    /:[\t ]*file format pe[i]\\{,1\\}-/d\n    /^In archive [^:]*:/d\n    # Ensure marker is printed\n    /^====MARK====/p\n    # Remove all lines with less than 43 characters\n    /^.\\{43\\}/!d\n    # From remaining lines, remove first 43 characters\n    s/^.\\{43\\}//' |\n    $SED -n '\n      # Join marker and all lines until next marker into a single line\n      /^====MARK====/ b para\n      H\n      $ b para\n      b\n      :para\n      x\n      s/\\n//g\n      # Remove the marker\n      s/^====MARK====//\n      # Remove trailing dots and whitespace\n      s/[\\. \\t]*$//\n      # Print\n      /./p' |\n    # we now have a list, one entry per line, of the stringified\n    # contents of the appropriate section of all members of the\n    # archive that possess that section. Heuristic: eliminate\n    # all those that have a first or second character that is\n    # a '.' (that is, objdump's representation of an unprintable\n    # character.) This should work for all archives with less than\n    # 0x302f exports -- but will fail for DLLs whose name actually\n    # begins with a literal '.' or a single character followed by\n    # a '.'.\n    #\n    # Of those that remain, print the first one.\n    $SED -e '/^\\./d;/^.\\./d;q'\n}\n\n# func_cygming_dll_for_implib_fallback ARG\n# Platform-specific function to extract the\n# name of the DLL associated with the specified\n# import library ARG.\n#\n# This fallback implementation is for use when $DLLTOOL\n# does not support the --identify-strict option.\n# Invoked by eval'ing the libtool variable\n#    $sharedlib_from_linklib_cmd\n# Result is available in the variable\n#    $sharedlib_from_linklib_result\nfunc_cygming_dll_for_implib_fallback ()\n{\n  $debug_cmd\n\n  if func_cygming_gnu_implib_p \"$1\"; then\n    # binutils import library\n    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$7' \"$1\"`\n  elif func_cygming_ms_implib_p \"$1\"; then\n    # ms-generated import library\n    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$6' \"$1\"`\n  else\n    # unknown\n    sharedlib_from_linklib_result=\n  fi\n}\n\n\n# func_extract_an_archive dir oldlib\nfunc_extract_an_archive ()\n{\n    $debug_cmd\n\n    f_ex_an_ar_dir=$1; shift\n    f_ex_an_ar_oldlib=$1\n    if test yes = \"$lock_old_archive_extraction\"; then\n      lockfile=$f_ex_an_ar_oldlib.lock\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    fi\n    func_show_eval \"(cd \\$f_ex_an_ar_dir && $AR x \\\"\\$f_ex_an_ar_oldlib\\\")\" \\\n\t\t   'stat=$?; rm -f \"$lockfile\"; exit $stat'\n    if test yes = \"$lock_old_archive_extraction\"; then\n      $opt_dry_run || rm -f \"$lockfile\"\n    fi\n    if ($AR t \"$f_ex_an_ar_oldlib\" | sort | sort -uc >/dev/null 2>&1); then\n     :\n    else\n      func_fatal_error \"object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib\"\n    fi\n}\n\n\n# func_extract_archives gentop oldlib ...\nfunc_extract_archives ()\n{\n    $debug_cmd\n\n    my_gentop=$1; shift\n    my_oldlibs=${1+\"$@\"}\n    my_oldobjs=\n    my_xlib=\n    my_xabs=\n    my_xdir=\n\n    for my_xlib in $my_oldlibs; do\n      # Extract the objects.\n      case $my_xlib in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) my_xabs=$my_xlib ;;\n\t*) my_xabs=`pwd`\"/$my_xlib\" ;;\n      esac\n      func_basename \"$my_xlib\"\n      my_xlib=$func_basename_result\n      my_xlib_u=$my_xlib\n      while :; do\n        case \" $extracted_archives \" in\n\t*\" $my_xlib_u \"*)\n\t  func_arith $extracted_serial + 1\n\t  extracted_serial=$func_arith_result\n\t  my_xlib_u=lt$extracted_serial-$my_xlib ;;\n\t*) break ;;\n\tesac\n      done\n      extracted_archives=\"$extracted_archives $my_xlib_u\"\n      my_xdir=$my_gentop/$my_xlib_u\n\n      func_mkdir_p \"$my_xdir\"\n\n      case $host in\n      *-darwin*)\n\tfunc_verbose \"Extracting $my_xabs\"\n\t# Do not bother doing anything if just a dry run\n\t$opt_dry_run || {\n\t  darwin_orig_dir=`pwd`\n\t  cd $my_xdir || exit $?\n\t  darwin_archive=$my_xabs\n\t  darwin_curdir=`pwd`\n\t  func_basename \"$darwin_archive\"\n\t  darwin_base_archive=$func_basename_result\n\t  darwin_arches=`$LIPO -info \"$darwin_archive\" 2>/dev/null | $GREP Architectures 2>/dev/null || true`\n\t  if test -n \"$darwin_arches\"; then\n\t    darwin_arches=`$ECHO \"$darwin_arches\" | $SED -e 's/.*are://'`\n\t    darwin_arch=\n\t    func_verbose \"$darwin_base_archive has multiple architectures $darwin_arches\"\n\t    for darwin_arch in  $darwin_arches; do\n\t      func_mkdir_p \"unfat-$$/$darwin_base_archive-$darwin_arch\"\n\t      $LIPO -thin $darwin_arch -output \"unfat-$$/$darwin_base_archive-$darwin_arch/$darwin_base_archive\" \"$darwin_archive\"\n\t      cd \"unfat-$$/$darwin_base_archive-$darwin_arch\"\n\t      func_extract_an_archive \"`pwd`\" \"$darwin_base_archive\"\n\t      cd \"$darwin_curdir\"\n\t      $RM \"unfat-$$/$darwin_base_archive-$darwin_arch/$darwin_base_archive\"\n\t    done # $darwin_arches\n            ## Okay now we've a bunch of thin objects, gotta fatten them up :)\n\t    darwin_filelist=`find unfat-$$ -type f -name \\*.o -print -o -name \\*.lo -print | $SED -e \"$sed_basename\" | sort -u`\n\t    darwin_file=\n\t    darwin_files=\n\t    for darwin_file in $darwin_filelist; do\n\t      darwin_files=`find unfat-$$ -name $darwin_file -print | sort | $NL2SP`\n\t      $LIPO -create -output \"$darwin_file\" $darwin_files\n\t    done # $darwin_filelist\n\t    $RM -rf unfat-$$\n\t    cd \"$darwin_orig_dir\"\n\t  else\n\t    cd $darwin_orig_dir\n\t    func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t  fi # $darwin_arches\n\t} # !$opt_dry_run\n\t;;\n      *)\n        func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t;;\n      esac\n      my_oldobjs=\"$my_oldobjs \"`find $my_xdir -name \\*.$objext -print -o -name \\*.lo -print | sort | $NL2SP`\n    done\n\n    func_extract_archives_result=$my_oldobjs\n}\n\n\n# func_emit_wrapper [arg=no]\n#\n# Emit a libtool wrapper script on stdout.\n# Don't directly open a file because we may want to\n# incorporate the script contents within a cygwin/mingw\n# wrapper executable.  Must ONLY be called from within\n# func_mode_link because it depends on a number of variables\n# set therein.\n#\n# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\n# variable will take.  If 'yes', then the emitted script\n# will assume that the directory where it is stored is\n# the $objdir directory.  This is a cygwin/mingw-specific\n# behavior.\nfunc_emit_wrapper ()\n{\n\tfunc_emit_wrapper_arg1=${1-no}\n\n\t$ECHO \"\\\n#! $SHELL\n\n# $output - temporary wrapper script for $objdir/$outputname\n# Generated by $PROGRAM (GNU $PACKAGE) $VERSION\n#\n# The $output program cannot be directly executed until all the libtool\n# libraries that it depends on are installed.\n#\n# This wrapper script should never be moved out of the build directory.\n# If it is, it will not operate correctly.\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nsed_quote_subst='$sed_quote_subst'\n\n# Be Bourne compatible\nif test -n \\\"\\${ZSH_VERSION+set}\\\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse\n  case \\`(set -o) 2>/dev/null\\` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nrelink_command=\\\"$relink_command\\\"\n\n# This environment variable determines our operation mode.\nif test \\\"\\$libtool_install_magic\\\" = \\\"$magic\\\"; then\n  # install mode needs the following variables:\n  generated_by_libtool_version='$macro_version'\n  notinst_deplibs='$notinst_deplibs'\nelse\n  # When we are sourced in execute mode, \\$file and \\$ECHO are already set.\n  if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n    file=\\\"\\$0\\\"\"\n\n    qECHO=`$ECHO \"$ECHO\" | $SED \"$sed_quote_subst\"`\n    $ECHO \"\\\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$1\n_LTECHO_EOF'\n}\n    ECHO=\\\"$qECHO\\\"\n  fi\n\n# Very basic option parsing. These options are (a) specific to\n# the libtool wrapper, (b) are identical between the wrapper\n# /script/ and the wrapper /executable/ that is used only on\n# windows platforms, and (c) all begin with the string \"--lt-\"\n# (application programs are unlikely to have options that match\n# this pattern).\n#\n# There are only two supported options: --lt-debug and\n# --lt-dump-script. There is, deliberately, no --lt-help.\n#\n# The first argument to this parsing function should be the\n# script's $0 value, followed by \"$@\".\nlt_option_debug=\nfunc_parse_lt_options ()\n{\n  lt_script_arg0=\\$0\n  shift\n  for lt_opt\n  do\n    case \\\"\\$lt_opt\\\" in\n    --lt-debug) lt_option_debug=1 ;;\n    --lt-dump-script)\n        lt_dump_D=\\`\\$ECHO \\\"X\\$lt_script_arg0\\\" | $SED -e 's/^X//' -e 's%/[^/]*$%%'\\`\n        test \\\"X\\$lt_dump_D\\\" = \\\"X\\$lt_script_arg0\\\" && lt_dump_D=.\n        lt_dump_F=\\`\\$ECHO \\\"X\\$lt_script_arg0\\\" | $SED -e 's/^X//' -e 's%^.*/%%'\\`\n        cat \\\"\\$lt_dump_D/\\$lt_dump_F\\\"\n        exit 0\n      ;;\n    --lt-*)\n        \\$ECHO \\\"Unrecognized --lt- option: '\\$lt_opt'\\\" 1>&2\n        exit 1\n      ;;\n    esac\n  done\n\n  # Print the debug banner immediately:\n  if test -n \\\"\\$lt_option_debug\\\"; then\n    echo \\\"$outputname:$output:\\$LINENO: libtool wrapper (GNU $PACKAGE) $VERSION\\\" 1>&2\n  fi\n}\n\n# Used when --lt-debug. Prints its arguments to stdout\n# (redirection is the responsibility of the caller)\nfunc_lt_dump_args ()\n{\n  lt_dump_args_N=1;\n  for lt_arg\n  do\n    \\$ECHO \\\"$outputname:$output:\\$LINENO: newargv[\\$lt_dump_args_N]: \\$lt_arg\\\"\n    lt_dump_args_N=\\`expr \\$lt_dump_args_N + 1\\`\n  done\n}\n\n# Core function for launching the target application\nfunc_exec_program_core ()\n{\n\"\n  case $host in\n  # Backslashes separate directories on plain windows\n  *-*-mingw | *-*-os2* | *-cegcc*)\n    $ECHO \"\\\n      if test -n \\\"\\$lt_option_debug\\\"; then\n        \\$ECHO \\\"$outputname:$output:\\$LINENO: newargv[0]: \\$progdir\\\\\\\\\\$program\\\" 1>&2\n        func_lt_dump_args \\${1+\\\"\\$@\\\"} 1>&2\n      fi\n      exec \\\"\\$progdir\\\\\\\\\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n    ;;\n\n  *)\n    $ECHO \"\\\n      if test -n \\\"\\$lt_option_debug\\\"; then\n        \\$ECHO \\\"$outputname:$output:\\$LINENO: newargv[0]: \\$progdir/\\$program\\\" 1>&2\n        func_lt_dump_args \\${1+\\\"\\$@\\\"} 1>&2\n      fi\n      exec \\\"\\$progdir/\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n    ;;\n  esac\n  $ECHO \"\\\n      \\$ECHO \\\"\\$0: cannot exec \\$program \\$*\\\" 1>&2\n      exit 1\n}\n\n# A function to encapsulate launching the target application\n# Strips options in the --lt-* namespace from \\$@ and\n# launches target application with the remaining arguments.\nfunc_exec_program ()\n{\n  case \\\" \\$* \\\" in\n  *\\\\ --lt-*)\n    for lt_wr_arg\n    do\n      case \\$lt_wr_arg in\n      --lt-*) ;;\n      *) set x \\\"\\$@\\\" \\\"\\$lt_wr_arg\\\"; shift;;\n      esac\n      shift\n    done ;;\n  esac\n  func_exec_program_core \\${1+\\\"\\$@\\\"}\n}\n\n  # Parse options\n  func_parse_lt_options \\\"\\$0\\\" \\${1+\\\"\\$@\\\"}\n\n  # Find the directory that this script lives in.\n  thisdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*$%%'\\`\n  test \\\"x\\$thisdir\\\" = \\\"x\\$file\\\" && thisdir=.\n\n  # Follow symbolic links until we get to the real thisdir.\n  file=\\`ls -ld \\\"\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  while test -n \\\"\\$file\\\"; do\n    destdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*\\$%%'\\`\n\n    # If there was a directory component, then change thisdir.\n    if test \\\"x\\$destdir\\\" != \\\"x\\$file\\\"; then\n      case \\\"\\$destdir\\\" in\n      [\\\\\\\\/]* | [A-Za-z]:[\\\\\\\\/]*) thisdir=\\\"\\$destdir\\\" ;;\n      *) thisdir=\\\"\\$thisdir/\\$destdir\\\" ;;\n      esac\n    fi\n\n    file=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%^.*/%%'\\`\n    file=\\`ls -ld \\\"\\$thisdir/\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  done\n\n  # Usually 'no', except on cygwin/mingw when embedded into\n  # the cwrapper.\n  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_arg1\n  if test \\\"\\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\\\" = \\\"yes\\\"; then\n    # special case for '.'\n    if test \\\"\\$thisdir\\\" = \\\".\\\"; then\n      thisdir=\\`pwd\\`\n    fi\n    # remove .libs from thisdir\n    case \\\"\\$thisdir\\\" in\n    *[\\\\\\\\/]$objdir ) thisdir=\\`\\$ECHO \\\"\\$thisdir\\\" | $SED 's%[\\\\\\\\/][^\\\\\\\\/]*$%%'\\` ;;\n    $objdir )   thisdir=. ;;\n    esac\n  fi\n\n  # Try to get the absolute directory name.\n  absdir=\\`cd \\\"\\$thisdir\\\" && pwd\\`\n  test -n \\\"\\$absdir\\\" && thisdir=\\\"\\$absdir\\\"\n\"\n\n\tif test yes = \"$fast_install\"; then\n\t  $ECHO \"\\\n  program=lt-'$outputname'$exeext\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\n  if test ! -f \\\"\\$progdir/\\$program\\\" ||\n     { file=\\`ls -1dt \\\"\\$progdir/\\$program\\\" \\\"\\$progdir/../\\$program\\\" 2>/dev/null | $SED 1q\\`; \\\\\n       test \\\"X\\$file\\\" != \\\"X\\$progdir/\\$program\\\"; }; then\n\n    file=\\\"\\$\\$-\\$program\\\"\n\n    if test ! -d \\\"\\$progdir\\\"; then\n      $MKDIR \\\"\\$progdir\\\"\n    else\n      $RM \\\"\\$progdir/\\$file\\\"\n    fi\"\n\n\t  $ECHO \"\\\n\n    # relink executable if necessary\n    if test -n \\\"\\$relink_command\\\"; then\n      if relink_command_output=\\`eval \\$relink_command 2>&1\\`; then :\n      else\n\t\\$ECHO \\\"\\$relink_command_output\\\" >&2\n\t$RM \\\"\\$progdir/\\$file\\\"\n\texit 1\n      fi\n    fi\n\n    $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\" 2>/dev/null ||\n    { $RM \\\"\\$progdir/\\$program\\\";\n      $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\"; }\n    $RM \\\"\\$progdir/\\$file\\\"\n  fi\"\n\telse\n\t  $ECHO \"\\\n  program='$outputname'\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\"\n\tfi\n\n\t$ECHO \"\\\n\n  if test -f \\\"\\$progdir/\\$program\\\"; then\"\n\n\t# fixup the dll searchpath if we need to.\n\t#\n\t# Fix the DLL searchpath if we need to.  Do this before prepending\n\t# to shlibpath, because on Windows, both are PATH and uninstalled\n\t# libraries must come first.\n\tif test -n \"$dllsearchpath\"; then\n\t  $ECHO \"\\\n    # Add the dll search path components to the executable PATH\n    PATH=$dllsearchpath:\\$PATH\n\"\n\tfi\n\n\t# Export our shlibpath_var if we have one.\n\tif test yes = \"$shlibpath_overrides_runpath\" && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n\t  $ECHO \"\\\n    # Add our own library path to $shlibpath_var\n    $shlibpath_var=\\\"$temp_rpath\\$$shlibpath_var\\\"\n\n    # Some systems cannot cope with colon-terminated $shlibpath_var\n    # The second colon is a workaround for a bug in BeOS R4 sed\n    $shlibpath_var=\\`\\$ECHO \\\"\\$$shlibpath_var\\\" | $SED 's/::*\\$//'\\`\n\n    export $shlibpath_var\n\"\n\tfi\n\n\t$ECHO \"\\\n    if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n      # Run the actual program with our arguments.\n      func_exec_program \\${1+\\\"\\$@\\\"}\n    fi\n  else\n    # The program doesn't exist.\n    \\$ECHO \\\"\\$0: error: '\\$progdir/\\$program' does not exist\\\" 1>&2\n    \\$ECHO \\\"This script is just a wrapper for \\$program.\\\" 1>&2\n    \\$ECHO \\\"See the $PACKAGE documentation for more information.\\\" 1>&2\n    exit 1\n  fi\nfi\\\n\"\n}\n\n\n# func_emit_cwrapperexe_src\n# emit the source code for a wrapper executable on stdout\n# Must ONLY be called from within func_mode_link because\n# it depends on a number of variable set therein.\nfunc_emit_cwrapperexe_src ()\n{\n\tcat <<EOF\n\n/* $cwrappersource - temporary wrapper executable for $objdir/$outputname\n   Generated by $PROGRAM (GNU $PACKAGE) $VERSION\n\n   The $output program cannot be directly executed until all the libtool\n   libraries that it depends on are installed.\n\n   This wrapper executable should never be moved out of the build directory.\n   If it is, it will not operate correctly.\n*/\nEOF\n\t    cat <<\"EOF\"\n#ifdef _MSC_VER\n# define _CRT_SECURE_NO_DEPRECATE 1\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef _MSC_VER\n# include <direct.h>\n# include <process.h>\n# include <io.h>\n#else\n# include <unistd.h>\n# include <stdint.h>\n# ifdef __CYGWIN__\n#  include <io.h>\n# endif\n#endif\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n#define STREQ(s1, s2) (strcmp ((s1), (s2)) == 0)\n\n/* declarations of non-ANSI functions */\n#if defined __MINGW32__\n# ifdef __STRICT_ANSI__\nint _putenv (const char *);\n# endif\n#elif defined __CYGWIN__\n# ifdef __STRICT_ANSI__\nchar *realpath (const char *, char *);\nint putenv (char *);\nint setenv (const char *, const char *, int);\n# endif\n/* #elif defined other_platform || defined ... */\n#endif\n\n/* portability defines, excluding path handling macros */\n#if defined _MSC_VER\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n# define S_IXUSR _S_IEXEC\n#elif defined __MINGW32__\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n#elif defined __CYGWIN__\n# define HAVE_SETENV\n# define FOPEN_WB \"wb\"\n/* #elif defined other platforms ... */\n#endif\n\n#if defined PATH_MAX\n# define LT_PATHMAX PATH_MAX\n#elif defined MAXPATHLEN\n# define LT_PATHMAX MAXPATHLEN\n#else\n# define LT_PATHMAX 1024\n#endif\n\n#ifndef S_IXOTH\n# define S_IXOTH 0\n#endif\n#ifndef S_IXGRP\n# define S_IXGRP 0\n#endif\n\n/* path handling portability macros */\n#ifndef DIR_SEPARATOR\n# define DIR_SEPARATOR '/'\n# define PATH_SEPARATOR ':'\n#endif\n\n#if defined _WIN32 || defined __MSDOS__ || defined __DJGPP__ || \\\n  defined __OS2__\n# define HAVE_DOS_BASED_FILE_SYSTEM\n# define FOPEN_WB \"wb\"\n# ifndef DIR_SEPARATOR_2\n#  define DIR_SEPARATOR_2 '\\\\'\n# endif\n# ifndef PATH_SEPARATOR_2\n#  define PATH_SEPARATOR_2 ';'\n# endif\n#endif\n\n#ifndef DIR_SEPARATOR_2\n# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)\n#else /* DIR_SEPARATOR_2 */\n# define IS_DIR_SEPARATOR(ch) \\\n\t(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))\n#endif /* DIR_SEPARATOR_2 */\n\n#ifndef PATH_SEPARATOR_2\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)\n#else /* PATH_SEPARATOR_2 */\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)\n#endif /* PATH_SEPARATOR_2 */\n\n#ifndef FOPEN_WB\n# define FOPEN_WB \"w\"\n#endif\n#ifndef _O_BINARY\n# define _O_BINARY 0\n#endif\n\n#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))\n#define XFREE(stale) do { \\\n  if (stale) { free (stale); stale = 0; } \\\n} while (0)\n\n#if defined LT_DEBUGWRAPPER\nstatic int lt_debug = 1;\n#else\nstatic int lt_debug = 0;\n#endif\n\nconst char *program_name = \"libtool-wrapper\"; /* in case xstrdup fails */\n\nvoid *xmalloc (size_t num);\nchar *xstrdup (const char *string);\nconst char *base_name (const char *name);\nchar *find_executable (const char *wrapper);\nchar *chase_symlinks (const char *pathspec);\nint make_executable (const char *path);\nint check_executable (const char *path);\nchar *strendzap (char *str, const char *pat);\nvoid lt_debugprintf (const char *file, int line, const char *fmt, ...);\nvoid lt_fatal (const char *file, int line, const char *message, ...);\nstatic const char *nonnull (const char *s);\nstatic const char *nonempty (const char *s);\nvoid lt_setenv (const char *name, const char *value);\nchar *lt_extend_str (const char *orig_value, const char *add, int to_end);\nvoid lt_update_exe_path (const char *name, const char *value);\nvoid lt_update_lib_path (const char *name, const char *value);\nchar **prepare_spawn (char **argv);\nvoid lt_dump_script (FILE *f);\nEOF\n\n\t    cat <<EOF\n#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 5)\n# define externally_visible volatile\n#else\n# define externally_visible __attribute__((externally_visible)) volatile\n#endif\nexternally_visible const char * MAGIC_EXE = \"$magic_exe\";\nconst char * LIB_PATH_VARNAME = \"$shlibpath_var\";\nEOF\n\n\t    if test yes = \"$shlibpath_overrides_runpath\" && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n              func_to_host_path \"$temp_rpath\"\n\t      cat <<EOF\nconst char * LIB_PATH_VALUE   = \"$func_to_host_path_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * LIB_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test -n \"$dllsearchpath\"; then\n              func_to_host_path \"$dllsearchpath:\"\n\t      cat <<EOF\nconst char * EXE_PATH_VARNAME = \"PATH\";\nconst char * EXE_PATH_VALUE   = \"$func_to_host_path_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * EXE_PATH_VARNAME = \"\";\nconst char * EXE_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test yes = \"$fast_install\"; then\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"lt-$outputname\"; /* hopefully, no .exe */\nEOF\n\t    else\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"$outputname\"; /* hopefully, no .exe */\nEOF\n\t    fi\n\n\n\t    cat <<\"EOF\"\n\n#define LTWRAPPER_OPTION_PREFIX         \"--lt-\"\n\nstatic const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;\nstatic const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX \"dump-script\";\nstatic const char *debug_opt            = LTWRAPPER_OPTION_PREFIX \"debug\";\n\nint\nmain (int argc, char *argv[])\n{\n  char **newargz;\n  int  newargc;\n  char *tmp_pathspec;\n  char *actual_cwrapper_path;\n  char *actual_cwrapper_name;\n  char *target_name;\n  char *lt_argv_zero;\n  int rval = 127;\n\n  int i;\n\n  program_name = (char *) xstrdup (base_name (argv[0]));\n  newargz = XMALLOC (char *, (size_t) argc + 1);\n\n  /* very simple arg parsing; don't want to rely on getopt\n   * also, copy all non cwrapper options to newargz, except\n   * argz[0], which is handled differently\n   */\n  newargc=0;\n  for (i = 1; i < argc; i++)\n    {\n      if (STREQ (argv[i], dumpscript_opt))\n\t{\nEOF\n\t    case $host in\n\t      *mingw* | *cygwin* )\n\t\t# make stdout use \"unix\" line endings\n\t\techo \"          setmode(1,_O_BINARY);\"\n\t\t;;\n\t      esac\n\n\t    cat <<\"EOF\"\n\t  lt_dump_script (stdout);\n\t  return 0;\n\t}\n      if (STREQ (argv[i], debug_opt))\n\t{\n          lt_debug = 1;\n          continue;\n\t}\n      if (STREQ (argv[i], ltwrapper_option_prefix))\n        {\n          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX\n             namespace, but it is not one of the ones we know about and\n             have already dealt with, above (inluding dump-script), then\n             report an error. Otherwise, targets might begin to believe\n             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX\n             namespace. The first time any user complains about this, we'll\n             need to make LTWRAPPER_OPTION_PREFIX a configure-time option\n             or a configure.ac-settable value.\n           */\n          lt_fatal (__FILE__, __LINE__,\n\t\t    \"unrecognized %s option: '%s'\",\n                    ltwrapper_option_prefix, argv[i]);\n        }\n      /* otherwise ... */\n      newargz[++newargc] = xstrdup (argv[i]);\n    }\n  newargz[++newargc] = NULL;\n\nEOF\n\t    cat <<EOF\n  /* The GNU banner must be the first non-error debug message */\n  lt_debugprintf (__FILE__, __LINE__, \"libtool wrapper (GNU $PACKAGE) $VERSION\\n\");\nEOF\n\t    cat <<\"EOF\"\n  lt_debugprintf (__FILE__, __LINE__, \"(main) argv[0]: %s\\n\", argv[0]);\n  lt_debugprintf (__FILE__, __LINE__, \"(main) program_name: %s\\n\", program_name);\n\n  tmp_pathspec = find_executable (argv[0]);\n  if (tmp_pathspec == NULL)\n    lt_fatal (__FILE__, __LINE__, \"couldn't find %s\", argv[0]);\n  lt_debugprintf (__FILE__, __LINE__,\n                  \"(main) found exe (before symlink chase) at: %s\\n\",\n\t\t  tmp_pathspec);\n\n  actual_cwrapper_path = chase_symlinks (tmp_pathspec);\n  lt_debugprintf (__FILE__, __LINE__,\n                  \"(main) found exe (after symlink chase) at: %s\\n\",\n\t\t  actual_cwrapper_path);\n  XFREE (tmp_pathspec);\n\n  actual_cwrapper_name = xstrdup (base_name (actual_cwrapper_path));\n  strendzap (actual_cwrapper_path, actual_cwrapper_name);\n\n  /* wrapper name transforms */\n  strendzap (actual_cwrapper_name, \".exe\");\n  tmp_pathspec = lt_extend_str (actual_cwrapper_name, \".exe\", 1);\n  XFREE (actual_cwrapper_name);\n  actual_cwrapper_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  /* target_name transforms -- use actual target program name; might have lt- prefix */\n  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));\n  strendzap (target_name, \".exe\");\n  tmp_pathspec = lt_extend_str (target_name, \".exe\", 1);\n  XFREE (target_name);\n  target_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(main) libtool target name: %s\\n\",\n\t\t  target_name);\nEOF\n\n\t    cat <<EOF\n  newargz[0] =\n    XMALLOC (char, (strlen (actual_cwrapper_path) +\n\t\t    strlen (\"$objdir\") + 1 + strlen (actual_cwrapper_name) + 1));\n  strcpy (newargz[0], actual_cwrapper_path);\n  strcat (newargz[0], \"$objdir\");\n  strcat (newargz[0], \"/\");\nEOF\n\n\t    cat <<\"EOF\"\n  /* stop here, and copy so we don't have to do this twice */\n  tmp_pathspec = xstrdup (newargz[0]);\n\n  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */\n  strcat (newargz[0], actual_cwrapper_name);\n\n  /* DO want the lt- prefix here if it exists, so use target_name */\n  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);\n  XFREE (tmp_pathspec);\n  tmp_pathspec = NULL;\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t    cat <<\"EOF\"\n  {\n    char* p;\n    while ((p = strchr (newargz[0], '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n    while ((p = strchr (lt_argv_zero, '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n  }\nEOF\n\t    ;;\n\t    esac\n\n\t    cat <<\"EOF\"\n  XFREE (target_name);\n  XFREE (actual_cwrapper_path);\n  XFREE (actual_cwrapper_name);\n\n  lt_setenv (\"BIN_SH\", \"xpg4\"); /* for Tru64 */\n  lt_setenv (\"DUALCASE\", \"1\");  /* for MSK sh */\n  /* Update the DLL searchpath.  EXE_PATH_VALUE ($dllsearchpath) must\n     be prepended before (that is, appear after) LIB_PATH_VALUE ($temp_rpath)\n     because on Windows, both *_VARNAMEs are PATH but uninstalled\n     libraries must come first. */\n  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);\n  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);\n\n  lt_debugprintf (__FILE__, __LINE__, \"(main) lt_argv_zero: %s\\n\",\n\t\t  nonnull (lt_argv_zero));\n  for (i = 0; i < newargc; i++)\n    {\n      lt_debugprintf (__FILE__, __LINE__, \"(main) newargz[%d]: %s\\n\",\n\t\t      i, nonnull (newargz[i]));\n    }\n\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n  /* execv doesn't actually work on mingw as expected on unix */\n  newargz = prepare_spawn (newargz);\n  rval = (int) _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);\n  if (rval == -1)\n    {\n      /* failed to start process */\n      lt_debugprintf (__FILE__, __LINE__,\n\t\t      \"(main) failed to launch target \\\"%s\\\": %s\\n\",\n\t\t      lt_argv_zero, nonnull (strerror (errno)));\n      return 127;\n    }\n  return rval;\nEOF\n\t\t;;\n\t      *)\n\t\tcat <<\"EOF\"\n  execv (lt_argv_zero, newargz);\n  return rval; /* =127, but avoids unused variable warning */\nEOF\n\t\t;;\n\t    esac\n\n\t    cat <<\"EOF\"\n}\n\nvoid *\nxmalloc (size_t num)\n{\n  void *p = (void *) malloc (num);\n  if (!p)\n    lt_fatal (__FILE__, __LINE__, \"memory exhausted\");\n\n  return p;\n}\n\nchar *\nxstrdup (const char *string)\n{\n  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),\n\t\t\t  string) : NULL;\n}\n\nconst char *\nbase_name (const char *name)\n{\n  const char *base;\n\n#if defined HAVE_DOS_BASED_FILE_SYSTEM\n  /* Skip over the disk name in MSDOS pathnames. */\n  if (isalpha ((unsigned char) name[0]) && name[1] == ':')\n    name += 2;\n#endif\n\n  for (base = name; *name; name++)\n    if (IS_DIR_SEPARATOR (*name))\n      base = name + 1;\n  return base;\n}\n\nint\ncheck_executable (const char *path)\n{\n  struct stat st;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(check_executable): %s\\n\",\n                  nonempty (path));\n  if ((!path) || (!*path))\n    return 0;\n\n  if ((stat (path, &st) >= 0)\n      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n    return 1;\n  else\n    return 0;\n}\n\nint\nmake_executable (const char *path)\n{\n  int rval = 0;\n  struct stat st;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(make_executable): %s\\n\",\n                  nonempty (path));\n  if ((!path) || (!*path))\n    return 0;\n\n  if (stat (path, &st) >= 0)\n    {\n      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);\n    }\n  return rval;\n}\n\n/* Searches for the full path of the wrapper.  Returns\n   newly allocated full path name if found, NULL otherwise\n   Does not chase symlinks, even on platforms that support them.\n*/\nchar *\nfind_executable (const char *wrapper)\n{\n  int has_slash = 0;\n  const char *p;\n  const char *p_next;\n  /* static buffer for getcwd */\n  char tmp[LT_PATHMAX + 1];\n  size_t tmp_len;\n  char *concat_name;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(find_executable): %s\\n\",\n                  nonempty (wrapper));\n\n  if ((wrapper == NULL) || (*wrapper == '\\0'))\n    return NULL;\n\n  /* Absolute path? */\n#if defined HAVE_DOS_BASED_FILE_SYSTEM\n  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')\n    {\n      concat_name = xstrdup (wrapper);\n      if (check_executable (concat_name))\n\treturn concat_name;\n      XFREE (concat_name);\n    }\n  else\n    {\n#endif\n      if (IS_DIR_SEPARATOR (wrapper[0]))\n\t{\n\t  concat_name = xstrdup (wrapper);\n\t  if (check_executable (concat_name))\n\t    return concat_name;\n\t  XFREE (concat_name);\n\t}\n#if defined HAVE_DOS_BASED_FILE_SYSTEM\n    }\n#endif\n\n  for (p = wrapper; *p; p++)\n    if (*p == '/')\n      {\n\thas_slash = 1;\n\tbreak;\n      }\n  if (!has_slash)\n    {\n      /* no slashes; search PATH */\n      const char *path = getenv (\"PATH\");\n      if (path != NULL)\n\t{\n\t  for (p = path; *p; p = p_next)\n\t    {\n\t      const char *q;\n\t      size_t p_len;\n\t      for (q = p; *q; q++)\n\t\tif (IS_PATH_SEPARATOR (*q))\n\t\t  break;\n\t      p_len = (size_t) (q - p);\n\t      p_next = (*q == '\\0' ? q : q + 1);\n\t      if (p_len == 0)\n\t\t{\n\t\t  /* empty path: current directory */\n\t\t  if (getcwd (tmp, LT_PATHMAX) == NULL)\n\t\t    lt_fatal (__FILE__, __LINE__, \"getcwd failed: %s\",\n                              nonnull (strerror (errno)));\n\t\t  tmp_len = strlen (tmp);\n\t\t  concat_name =\n\t\t    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, tmp, tmp_len);\n\t\t  concat_name[tmp_len] = '/';\n\t\t  strcpy (concat_name + tmp_len + 1, wrapper);\n\t\t}\n\t      else\n\t\t{\n\t\t  concat_name =\n\t\t    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, p, p_len);\n\t\t  concat_name[p_len] = '/';\n\t\t  strcpy (concat_name + p_len + 1, wrapper);\n\t\t}\n\t      if (check_executable (concat_name))\n\t\treturn concat_name;\n\t      XFREE (concat_name);\n\t    }\n\t}\n      /* not found in PATH; assume curdir */\n    }\n  /* Relative path | not found in path: prepend cwd */\n  if (getcwd (tmp, LT_PATHMAX) == NULL)\n    lt_fatal (__FILE__, __LINE__, \"getcwd failed: %s\",\n              nonnull (strerror (errno)));\n  tmp_len = strlen (tmp);\n  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n  memcpy (concat_name, tmp, tmp_len);\n  concat_name[tmp_len] = '/';\n  strcpy (concat_name + tmp_len + 1, wrapper);\n\n  if (check_executable (concat_name))\n    return concat_name;\n  XFREE (concat_name);\n  return NULL;\n}\n\nchar *\nchase_symlinks (const char *pathspec)\n{\n#ifndef S_ISLNK\n  return xstrdup (pathspec);\n#else\n  char buf[LT_PATHMAX];\n  struct stat s;\n  char *tmp_pathspec = xstrdup (pathspec);\n  char *p;\n  int has_symlinks = 0;\n  while (strlen (tmp_pathspec) && !has_symlinks)\n    {\n      lt_debugprintf (__FILE__, __LINE__,\n\t\t      \"checking path component for symlinks: %s\\n\",\n\t\t      tmp_pathspec);\n      if (lstat (tmp_pathspec, &s) == 0)\n\t{\n\t  if (S_ISLNK (s.st_mode) != 0)\n\t    {\n\t      has_symlinks = 1;\n\t      break;\n\t    }\n\n\t  /* search backwards for last DIR_SEPARATOR */\n\t  p = tmp_pathspec + strlen (tmp_pathspec) - 1;\n\t  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    p--;\n\t  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    {\n\t      /* no more DIR_SEPARATORS left */\n\t      break;\n\t    }\n\t  *p = '\\0';\n\t}\n      else\n\t{\n\t  lt_fatal (__FILE__, __LINE__,\n\t\t    \"error accessing file \\\"%s\\\": %s\",\n\t\t    tmp_pathspec, nonnull (strerror (errno)));\n\t}\n    }\n  XFREE (tmp_pathspec);\n\n  if (!has_symlinks)\n    {\n      return xstrdup (pathspec);\n    }\n\n  tmp_pathspec = realpath (pathspec, buf);\n  if (tmp_pathspec == 0)\n    {\n      lt_fatal (__FILE__, __LINE__,\n\t\t\"could not follow symlinks for %s\", pathspec);\n    }\n  return xstrdup (tmp_pathspec);\n#endif\n}\n\nchar *\nstrendzap (char *str, const char *pat)\n{\n  size_t len, patlen;\n\n  assert (str != NULL);\n  assert (pat != NULL);\n\n  len = strlen (str);\n  patlen = strlen (pat);\n\n  if (patlen <= len)\n    {\n      str += len - patlen;\n      if (STREQ (str, pat))\n\t*str = '\\0';\n    }\n  return str;\n}\n\nvoid\nlt_debugprintf (const char *file, int line, const char *fmt, ...)\n{\n  va_list args;\n  if (lt_debug)\n    {\n      (void) fprintf (stderr, \"%s:%s:%d: \", program_name, file, line);\n      va_start (args, fmt);\n      (void) vfprintf (stderr, fmt, args);\n      va_end (args);\n    }\n}\n\nstatic void\nlt_error_core (int exit_status, const char *file,\n\t       int line, const char *mode,\n\t       const char *message, va_list ap)\n{\n  fprintf (stderr, \"%s:%s:%d: %s: \", program_name, file, line, mode);\n  vfprintf (stderr, message, ap);\n  fprintf (stderr, \".\\n\");\n\n  if (exit_status >= 0)\n    exit (exit_status);\n}\n\nvoid\nlt_fatal (const char *file, int line, const char *message, ...)\n{\n  va_list ap;\n  va_start (ap, message);\n  lt_error_core (EXIT_FAILURE, file, line, \"FATAL\", message, ap);\n  va_end (ap);\n}\n\nstatic const char *\nnonnull (const char *s)\n{\n  return s ? s : \"(null)\";\n}\n\nstatic const char *\nnonempty (const char *s)\n{\n  return (s && !*s) ? \"(empty)\" : nonnull (s);\n}\n\nvoid\nlt_setenv (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_setenv) setting '%s' to '%s'\\n\",\n                  nonnull (name), nonnull (value));\n  {\n#ifdef HAVE_SETENV\n    /* always make a copy, for consistency with !HAVE_SETENV */\n    char *str = xstrdup (value);\n    setenv (name, str, 1);\n#else\n    size_t len = strlen (name) + 1 + strlen (value) + 1;\n    char *str = XMALLOC (char, len);\n    sprintf (str, \"%s=%s\", name, value);\n    if (putenv (str) != EXIT_SUCCESS)\n      {\n        XFREE (str);\n      }\n#endif\n  }\n}\n\nchar *\nlt_extend_str (const char *orig_value, const char *add, int to_end)\n{\n  char *new_value;\n  if (orig_value && *orig_value)\n    {\n      size_t orig_value_len = strlen (orig_value);\n      size_t add_len = strlen (add);\n      new_value = XMALLOC (char, add_len + orig_value_len + 1);\n      if (to_end)\n        {\n          strcpy (new_value, orig_value);\n          strcpy (new_value + orig_value_len, add);\n        }\n      else\n        {\n          strcpy (new_value, add);\n          strcpy (new_value + add_len, orig_value);\n        }\n    }\n  else\n    {\n      new_value = xstrdup (add);\n    }\n  return new_value;\n}\n\nvoid\nlt_update_exe_path (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_update_exe_path) modifying '%s' by prepending '%s'\\n\",\n                  nonnull (name), nonnull (value));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      /* some systems can't cope with a ':'-terminated path #' */\n      size_t len = strlen (new_value);\n      while ((len > 0) && IS_PATH_SEPARATOR (new_value[len-1]))\n        {\n          new_value[--len] = '\\0';\n        }\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nvoid\nlt_update_lib_path (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_update_lib_path) modifying '%s' by prepending '%s'\\n\",\n                  nonnull (name), nonnull (value));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nEOF\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n\n/* Prepares an argument vector before calling spawn().\n   Note that spawn() does not by itself call the command interpreter\n     (getenv (\"COMSPEC\") != NULL ? getenv (\"COMSPEC\") :\n      ({ OSVERSIONINFO v; v.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n         GetVersionEx(&v);\n         v.dwPlatformId == VER_PLATFORM_WIN32_NT;\n      }) ? \"cmd.exe\" : \"command.com\").\n   Instead it simply concatenates the arguments, separated by ' ', and calls\n   CreateProcess().  We must quote the arguments since Win32 CreateProcess()\n   interprets characters like ' ', '\\t', '\\\\', '\"' (but not '<' and '>') in a\n   special way:\n   - Space and tab are interpreted as delimiters. They are not treated as\n     delimiters if they are surrounded by double quotes: \"...\".\n   - Unescaped double quotes are removed from the input. Their only effect is\n     that within double quotes, space and tab are treated like normal\n     characters.\n   - Backslashes not followed by double quotes are not special.\n   - But 2*n+1 backslashes followed by a double quote become\n     n backslashes followed by a double quote (n >= 0):\n       \\\" -> \"\n       \\\\\\\" -> \\\"\n       \\\\\\\\\\\" -> \\\\\"\n */\n#define SHELL_SPECIAL_CHARS \"\\\"\\\\ \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\n#define SHELL_SPACE_CHARS \" \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\nchar **\nprepare_spawn (char **argv)\n{\n  size_t argc;\n  char **new_argv;\n  size_t i;\n\n  /* Count number of arguments.  */\n  for (argc = 0; argv[argc] != NULL; argc++)\n    ;\n\n  /* Allocate new argument vector.  */\n  new_argv = XMALLOC (char *, argc + 1);\n\n  /* Put quoted arguments into the new argument vector.  */\n  for (i = 0; i < argc; i++)\n    {\n      const char *string = argv[i];\n\n      if (string[0] == '\\0')\n\tnew_argv[i] = xstrdup (\"\\\"\\\"\");\n      else if (strpbrk (string, SHELL_SPECIAL_CHARS) != NULL)\n\t{\n\t  int quote_around = (strpbrk (string, SHELL_SPACE_CHARS) != NULL);\n\t  size_t length;\n\t  unsigned int backslashes;\n\t  const char *s;\n\t  char *quoted_string;\n\t  char *p;\n\n\t  length = 0;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    length++;\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\tlength += backslashes + 1;\n\t      length++;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    length += backslashes + 1;\n\n\t  quoted_string = XMALLOC (char, length + 1);\n\n\t  p = quoted_string;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    *p++ = '\"';\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\t{\n\t\t  unsigned int j;\n\t\t  for (j = backslashes + 1; j > 0; j--)\n\t\t    *p++ = '\\\\';\n\t\t}\n\t      *p++ = c;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    {\n\t      unsigned int j;\n\t      for (j = backslashes; j > 0; j--)\n\t\t*p++ = '\\\\';\n\t      *p++ = '\"';\n\t    }\n\t  *p = '\\0';\n\n\t  new_argv[i] = quoted_string;\n\t}\n      else\n\tnew_argv[i] = (char *) string;\n    }\n  new_argv[argc] = NULL;\n\n  return new_argv;\n}\nEOF\n\t\t;;\n\t    esac\n\n            cat <<\"EOF\"\nvoid lt_dump_script (FILE* f)\n{\nEOF\n\t    func_emit_wrapper yes |\n\t      $SED -n -e '\ns/^\\(.\\{79\\}\\)\\(..*\\)/\\1\\\n\\2/\nh\ns/\\([\\\\\"]\\)/\\\\\\1/g\ns/$/\\\\n/\ns/\\([^\\n]*\\).*/  fputs (\"\\1\", f);/p\ng\nD'\n            cat <<\"EOF\"\n}\nEOF\n}\n# end: func_emit_cwrapperexe_src\n\n# func_win32_import_lib_p ARG\n# True if ARG is an import lib, as indicated by $file_magic_cmd\nfunc_win32_import_lib_p ()\n{\n    $debug_cmd\n\n    case `eval $file_magic_cmd \\\"\\$1\\\" 2>/dev/null | $SED -e 10q` in\n    *import*) : ;;\n    *) false ;;\n    esac\n}\n\n# func_suncc_cstd_abi\n# !!ONLY CALL THIS FOR SUN CC AFTER $compile_command IS FULLY EXPANDED!!\n# Several compiler flags select an ABI that is incompatible with the\n# Cstd library. Avoid specifying it if any are in CXXFLAGS.\nfunc_suncc_cstd_abi ()\n{\n    $debug_cmd\n\n    case \" $compile_command \" in\n    *\" -compat=g \"*|*\\ -std=c++[0-9][0-9]\\ *|*\" -library=stdcxx4 \"*|*\" -library=stlport4 \"*)\n      suncc_use_cstd_abi=no\n      ;;\n    *)\n      suncc_use_cstd_abi=yes\n      ;;\n    esac\n}\n\n# func_mode_link arg...\nfunc_mode_link ()\n{\n    $debug_cmd\n\n    case $host in\n    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n      # It is impossible to link a dll without this setting, and\n      # we shouldn't force the makefile maintainer to figure out\n      # what system we are compiling for in order to pass an extra\n      # flag for every libtool invocation.\n      # allow_undefined=no\n\n      # FIXME: Unfortunately, there are problems with the above when trying\n      # to make a dll that has undefined symbols, in which case not\n      # even a static library is built.  For now, we need to specify\n      # -no-undefined on the libtool link line when we can be certain\n      # that all symbols are satisfied, otherwise we get a static library.\n      allow_undefined=yes\n      ;;\n    *)\n      allow_undefined=yes\n      ;;\n    esac\n    libtool_args=$nonopt\n    base_compile=\"$nonopt $@\"\n    compile_command=$nonopt\n    finalize_command=$nonopt\n\n    compile_rpath=\n    finalize_rpath=\n    compile_shlibpath=\n    finalize_shlibpath=\n    convenience=\n    old_convenience=\n    deplibs=\n    old_deplibs=\n    compiler_flags=\n    linker_flags=\n    dllsearchpath=\n    lib_search_path=`pwd`\n    inst_prefix_dir=\n    new_inherited_linker_flags=\n\n    avoid_version=no\n    bindir=\n    dlfiles=\n    dlprefiles=\n    dlself=no\n    export_dynamic=no\n    export_symbols=\n    export_symbols_regex=\n    generated=\n    libobjs=\n    ltlibs=\n    module=no\n    no_install=no\n    objs=\n    os2dllname=\n    non_pic_objects=\n    precious_files_regex=\n    prefer_static_libs=no\n    preload=false\n    prev=\n    prevarg=\n    release=\n    rpath=\n    xrpath=\n    perm_rpath=\n    temp_rpath=\n    thread_safe=no\n    vinfo=\n    vinfo_number=no\n    weak_libs=\n    single_module=$wl-single_module\n    func_infer_tag $base_compile\n\n    # We need to know -static, to get the right output filenames.\n    for arg\n    do\n      case $arg in\n      -shared)\n\ttest yes != \"$build_libtool_libs\" \\\n\t  && func_fatal_configuration \"cannot build a shared library\"\n\tbuild_old_libs=no\n\tbreak\n\t;;\n      -all-static | -static | -static-libtool-libs)\n\tcase $arg in\n\t-all-static)\n\t  if test yes = \"$build_libtool_libs\" && test -z \"$link_static_flag\"; then\n\t    func_warning \"complete static linking is impossible in this configuration\"\n\t  fi\n\t  if test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\t-static)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=built\n\t  ;;\n\t-static-libtool-libs)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\tesac\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tbreak\n\t;;\n      esac\n    done\n\n    # See if our shared archives depend on static archives.\n    test -n \"$old_archive_from_new_cmds\" && build_old_libs=yes\n\n    # Go through the arguments, transforming them on the way.\n    while test \"$#\" -gt 0; do\n      arg=$1\n      shift\n      func_quote_for_eval \"$arg\"\n      qarg=$func_quote_for_eval_unquoted_result\n      func_append libtool_args \" $func_quote_for_eval_result\"\n\n      # If the previous option needs an argument, assign it.\n      if test -n \"$prev\"; then\n\tcase $prev in\n\toutput)\n\t  func_append compile_command \" @OUTPUT@\"\n\t  func_append finalize_command \" @OUTPUT@\"\n\t  ;;\n\tesac\n\n\tcase $prev in\n\tbindir)\n\t  bindir=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\tdlfiles|dlprefiles)\n\t  $preload || {\n\t    # Add the symbol object into the linking commands.\n\t    func_append compile_command \" @SYMFILE@\"\n\t    func_append finalize_command \" @SYMFILE@\"\n\t    preload=:\n\t  }\n\t  case $arg in\n\t  *.la | *.lo) ;;  # We handle these cases below.\n\t  force)\n\t    if test no = \"$dlself\"; then\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  self)\n\t    if test dlprefiles = \"$prev\"; then\n\t      dlself=yes\n\t    elif test dlfiles = \"$prev\" && test yes != \"$dlopen_self\"; then\n\t      dlself=yes\n\t    else\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  *)\n\t    if test dlfiles = \"$prev\"; then\n\t      func_append dlfiles \" $arg\"\n\t    else\n\t      func_append dlprefiles \" $arg\"\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  esac\n\t  ;;\n\texpsyms)\n\t  export_symbols=$arg\n\t  test -f \"$arg\" \\\n\t    || func_fatal_error \"symbol file '$arg' does not exist\"\n\t  prev=\n\t  continue\n\t  ;;\n\texpsyms_regex)\n\t  export_symbols_regex=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\tframework)\n\t  case $host in\n\t    *-*-darwin*)\n\t      case \"$deplibs \" in\n\t\t*\" $qarg.ltframework \"*) ;;\n\t\t*) func_append deplibs \" $qarg.ltframework\" # this is fixed later\n\t\t   ;;\n\t      esac\n\t      ;;\n\t  esac\n\t  prev=\n\t  continue\n\t  ;;\n\tinst_prefix)\n\t  inst_prefix_dir=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\tmllvm)\n\t  # Clang does not use LLVM to link, so we can simply discard any\n\t  # '-mllvm $arg' options when doing the link step.\n\t  prev=\n\t  continue\n\t  ;;\n\tobjectlist)\n\t  if test -f \"$arg\"; then\n\t    save_arg=$arg\n\t    moreargs=\n\t    for fil in `cat \"$save_arg\"`\n\t    do\n#\t      func_append moreargs \" $fil\"\n\t      arg=$fil\n\t      # A libtool-controlled object.\n\n\t      # Check to see that this really is a libtool object.\n\t      if func_lalib_unsafe_p \"$arg\"; then\n\t\tpic_object=\n\t\tnon_pic_object=\n\n\t\t# Read the .lo file\n\t\tfunc_source \"$arg\"\n\n\t\tif test -z \"$pic_object\" ||\n\t\t   test -z \"$non_pic_object\" ||\n\t\t   test none = \"$pic_object\" &&\n\t\t   test none = \"$non_pic_object\"; then\n\t\t  func_fatal_error \"cannot find name of object for '$arg'\"\n\t\tfi\n\n\t\t# Extract subdirectory from the argument.\n\t\tfunc_dirname \"$arg\" \"/\" \"\"\n\t\txdir=$func_dirname_result\n\n\t\tif test none != \"$pic_object\"; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  pic_object=$xdir$pic_object\n\n\t\t  if test dlfiles = \"$prev\"; then\n\t\t    if test yes = \"$build_libtool_libs\" && test yes = \"$dlopen_support\"; then\n\t\t      func_append dlfiles \" $pic_object\"\n\t\t      prev=\n\t\t      continue\n\t\t    else\n\t\t      # If libtool objects are unsupported, then we need to preload.\n\t\t      prev=dlprefiles\n\t\t    fi\n\t\t  fi\n\n\t\t  # CHECK ME:  I think I busted this.  -Ossama\n\t\t  if test dlprefiles = \"$prev\"; then\n\t\t    # Preload the old-style object.\n\t\t    func_append dlprefiles \" $pic_object\"\n\t\t    prev=\n\t\t  fi\n\n\t\t  # A PIC object.\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  arg=$pic_object\n\t\tfi\n\n\t\t# Non-PIC object.\n\t\tif test none != \"$non_pic_object\"; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  non_pic_object=$xdir$non_pic_object\n\n\t\t  # A standard non-PIC object\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\t  if test -z \"$pic_object\" || test none = \"$pic_object\"; then\n\t\t    arg=$non_pic_object\n\t\t  fi\n\t\telse\n\t\t  # If the PIC object exists, use it instead.\n\t\t  # $xdir was prepended to $pic_object above.\n\t\t  non_pic_object=$pic_object\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\tfi\n\t      else\n\t\t# Only an error if not doing a dry-run.\n\t\tif $opt_dry_run; then\n\t\t  # Extract subdirectory from the argument.\n\t\t  func_dirname \"$arg\" \"/\" \"\"\n\t\t  xdir=$func_dirname_result\n\n\t\t  func_lo2o \"$arg\"\n\t\t  pic_object=$xdir$objdir/$func_lo2o_result\n\t\t  non_pic_object=$xdir$func_lo2o_result\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t        else\n\t\t  func_fatal_error \"'$arg' is not a valid libtool object\"\n\t\tfi\n\t      fi\n\t    done\n\t  else\n\t    func_fatal_error \"link input file '$arg' does not exist\"\n\t  fi\n\t  arg=$save_arg\n\t  prev=\n\t  continue\n\t  ;;\n\tos2dllname)\n\t  os2dllname=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\tprecious_regex)\n\t  precious_files_regex=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\trelease)\n\t  release=-$arg\n\t  prev=\n\t  continue\n\t  ;;\n\trpath | xrpath)\n\t  # We need an absolute path.\n\t  case $arg in\n\t  [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t  *)\n\t    func_fatal_error \"only absolute run-paths are allowed\"\n\t    ;;\n\t  esac\n\t  if test rpath = \"$prev\"; then\n\t    case \"$rpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) func_append rpath \" $arg\" ;;\n\t    esac\n\t  else\n\t    case \"$xrpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) func_append xrpath \" $arg\" ;;\n\t    esac\n\t  fi\n\t  prev=\n\t  continue\n\t  ;;\n\tshrext)\n\t  shrext_cmds=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\tweak)\n\t  func_append weak_libs \" $arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\txcclinker)\n\t  func_append linker_flags \" $qarg\"\n\t  func_append compiler_flags \" $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txcompiler)\n\t  func_append compiler_flags \" $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txlinker)\n\t  func_append linker_flags \" $qarg\"\n\t  func_append compiler_flags \" $wl$qarg\"\n\t  prev=\n\t  func_append compile_command \" $wl$qarg\"\n\t  func_append finalize_command \" $wl$qarg\"\n\t  continue\n\t  ;;\n\t*)\n\t  eval \"$prev=\\\"\\$arg\\\"\"\n\t  prev=\n\t  continue\n\t  ;;\n\tesac\n      fi # test -n \"$prev\"\n\n      prevarg=$arg\n\n      case $arg in\n      -all-static)\n\tif test -n \"$link_static_flag\"; then\n\t  # See comment for -static flag below, for more details.\n\t  func_append compile_command \" $link_static_flag\"\n\t  func_append finalize_command \" $link_static_flag\"\n\tfi\n\tcontinue\n\t;;\n\n      -allow-undefined)\n\t# FIXME: remove this flag sometime in the future.\n\tfunc_fatal_error \"'-allow-undefined' must not be used because it is the default\"\n\t;;\n\n      -avoid-version)\n\tavoid_version=yes\n\tcontinue\n\t;;\n\n      -bindir)\n\tprev=bindir\n\tcontinue\n\t;;\n\n      -dlopen)\n\tprev=dlfiles\n\tcontinue\n\t;;\n\n      -dlpreopen)\n\tprev=dlprefiles\n\tcontinue\n\t;;\n\n      -export-dynamic)\n\texport_dynamic=yes\n\tcontinue\n\t;;\n\n      -export-symbols | -export-symbols-regex)\n\tif test -n \"$export_symbols\" || test -n \"$export_symbols_regex\"; then\n\t  func_fatal_error \"more than one -exported-symbols argument is not allowed\"\n\tfi\n\tif test X-export-symbols = \"X$arg\"; then\n\t  prev=expsyms\n\telse\n\t  prev=expsyms_regex\n\tfi\n\tcontinue\n\t;;\n\n      -framework)\n\tprev=framework\n\tcontinue\n\t;;\n\n      -inst-prefix-dir)\n\tprev=inst_prefix\n\tcontinue\n\t;;\n\n      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*\n      # so, if we see these flags be careful not to treat them like -L\n      -L[A-Z][A-Z]*:*)\n\tcase $with_gcc/$host in\n\tno/*-*-irix* | /*-*-irix*)\n\t  func_append compile_command \" $arg\"\n\t  func_append finalize_command \" $arg\"\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -L*)\n\tfunc_stripname \"-L\" '' \"$arg\"\n\tif test -z \"$func_stripname_result\"; then\n\t  if test \"$#\" -gt 0; then\n\t    func_fatal_error \"require no space between '-L' and '$1'\"\n\t  else\n\t    func_fatal_error \"need path for '-L' option\"\n\t  fi\n\tfi\n\tfunc_resolve_sysroot \"$func_stripname_result\"\n\tdir=$func_resolve_sysroot_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  absdir=`cd \"$dir\" && pwd`\n\t  test -z \"$absdir\" && \\\n\t    func_fatal_error \"cannot determine absolute directory name of '$dir'\"\n\t  dir=$absdir\n\t  ;;\n\tesac\n\tcase \"$deplibs \" in\n\t*\" -L$dir \"* | *\" $arg \"*)\n\t  # Will only happen for absolute or sysroot arguments\n\t  ;;\n\t*)\n\t  # Preserve sysroot, but never include relative directories\n\t  case $dir in\n\t    [\\\\/]* | [A-Za-z]:[\\\\/]* | =*) func_append deplibs \" $arg\" ;;\n\t    *) func_append deplibs \" -L$dir\" ;;\n\t  esac\n\t  func_append lib_search_path \" $dir\"\n\t  ;;\n\tesac\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`$ECHO \"$dir\" | $SED 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$dir:\"*) ;;\n\t  ::) dllsearchpath=$dir;;\n\t  *) func_append dllsearchpath \":$dir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) func_append dllsearchpath \":$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -l*)\n\tif test X-lc = \"X$arg\" || test X-lm = \"X$arg\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # These systems don't actually have a C or math library (as such)\n\t    continue\n\t    ;;\n\t  *-*-os2*)\n\t    # These systems don't actually have a C library (as such)\n\t    test X-lc = \"X$arg\" && continue\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly* | *-*-bitrig*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    test X-lc = \"X$arg\" && continue\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C and math libraries are in the System framework\n\t    func_append deplibs \" System.ltframework\"\n\t    continue\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    test X-lc = \"X$arg\" && continue\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    test X-lc = \"X$arg\" && continue\n\t    ;;\n\t  esac\n\telif test X-lc_r = \"X$arg\"; then\n\t case $host in\n\t *-*-openbsd* | *-*-freebsd* | *-*-dragonfly* | *-*-bitrig*)\n\t   # Do not include libc_r directly, use -pthread flag.\n\t   continue\n\t   ;;\n\t esac\n\tfi\n\tfunc_append deplibs \" $arg\"\n\tcontinue\n\t;;\n\n      -mllvm)\n\tprev=mllvm\n\tcontinue\n\t;;\n\n      -module)\n\tmodule=yes\n\tcontinue\n\t;;\n\n      # Tru64 UNIX uses -model [arg] to determine the layout of C++\n      # classes, name mangling, and exception handling.\n      # Darwin uses the -arch flag to determine output architecture.\n      -model|-arch|-isysroot|--sysroot)\n\tfunc_append compiler_flags \" $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \\\n      |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)\n\tfunc_append compiler_flags \" $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tcase \"$new_inherited_linker_flags \" in\n\t    *\" $arg \"*) ;;\n\t    * ) func_append new_inherited_linker_flags \" $arg\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -multi_module)\n\tsingle_module=$wl-multi_module\n\tcontinue\n\t;;\n\n      -no-fast-install)\n\tfast_install=no\n\tcontinue\n\t;;\n\n      -no-install)\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)\n\t  # The PATH hackery in wrapper scripts is required on Windows\n\t  # and Darwin in order for the loader to find any dlls it needs.\n\t  func_warning \"'-no-install' is ignored for $host\"\n\t  func_warning \"assuming '-no-fast-install' instead\"\n\t  fast_install=no\n\t  ;;\n\t*) no_install=yes ;;\n\tesac\n\tcontinue\n\t;;\n\n      -no-undefined)\n\tallow_undefined=no\n\tcontinue\n\t;;\n\n      -objectlist)\n\tprev=objectlist\n\tcontinue\n\t;;\n\n      -os2dllname)\n\tprev=os2dllname\n\tcontinue\n\t;;\n\n      -o) prev=output ;;\n\n      -precious-files-regex)\n\tprev=precious_regex\n\tcontinue\n\t;;\n\n      -release)\n\tprev=release\n\tcontinue\n\t;;\n\n      -rpath)\n\tprev=rpath\n\tcontinue\n\t;;\n\n      -R)\n\tprev=xrpath\n\tcontinue\n\t;;\n\n      -R*)\n\tfunc_stripname '-R' '' \"$arg\"\n\tdir=$func_stripname_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t=*)\n\t  func_stripname '=' '' \"$dir\"\n\t  dir=$lt_sysroot$func_stripname_result\n\t  ;;\n\t*)\n\t  func_fatal_error \"only absolute run-paths are allowed\"\n\t  ;;\n\tesac\n\tcase \"$xrpath \" in\n\t*\" $dir \"*) ;;\n\t*) func_append xrpath \" $dir\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -shared)\n\t# The effects of -shared are defined in a previous loop.\n\tcontinue\n\t;;\n\n      -shrext)\n\tprev=shrext\n\tcontinue\n\t;;\n\n      -static | -static-libtool-libs)\n\t# The effects of -static are defined in a previous loop.\n\t# We used to do the same as -all-static on platforms that\n\t# didn't have a PIC flag, but the assumption that the effects\n\t# would be equivalent was wrong.  It would break on at least\n\t# Digital Unix and AIX.\n\tcontinue\n\t;;\n\n      -thread-safe)\n\tthread_safe=yes\n\tcontinue\n\t;;\n\n      -version-info)\n\tprev=vinfo\n\tcontinue\n\t;;\n\n      -version-number)\n\tprev=vinfo\n\tvinfo_number=yes\n\tcontinue\n\t;;\n\n      -weak)\n        prev=weak\n\tcontinue\n\t;;\n\n      -Wc,*)\n\tfunc_stripname '-Wc,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=$IFS; IFS=,\n\tfor flag in $args; do\n\t  IFS=$save_ifs\n          func_quote_for_eval \"$flag\"\n\t  func_append arg \" $func_quote_for_eval_result\"\n\t  func_append compiler_flags \" $func_quote_for_eval_result\"\n\tdone\n\tIFS=$save_ifs\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Wl,*)\n\tfunc_stripname '-Wl,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=$IFS; IFS=,\n\tfor flag in $args; do\n\t  IFS=$save_ifs\n          func_quote_for_eval \"$flag\"\n\t  func_append arg \" $wl$func_quote_for_eval_result\"\n\t  func_append compiler_flags \" $wl$func_quote_for_eval_result\"\n\t  func_append linker_flags \" $func_quote_for_eval_result\"\n\tdone\n\tIFS=$save_ifs\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Xcompiler)\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -Xlinker)\n\tprev=xlinker\n\tcontinue\n\t;;\n\n      -XCClinker)\n\tprev=xcclinker\n\tcontinue\n\t;;\n\n      # -msg_* for osf cc\n      -msg_*)\n\tfunc_quote_for_eval \"$arg\"\n\targ=$func_quote_for_eval_result\n\t;;\n\n      # Flags to be passed through unchanged, with rationale:\n      # -64, -mips[0-9]      enable 64-bit mode for the SGI compiler\n      # -r[0-9][0-9]*        specify processor for the SGI compiler\n      # -xarch=*, -xtarget=* enable 64-bit mode for the Sun compiler\n      # +DA*, +DD*           enable 64-bit mode for the HP compiler\n      # -q*                  compiler args for the IBM compiler\n      # -m*, -t[45]*, -txscale* architecture-specific flags for GCC\n      # -F/path              path to uninstalled frameworks, gcc on darwin\n      # -p, -pg, --coverage, -fprofile-*  profiling flags for GCC\n      # -fstack-protector*   stack protector flags for GCC\n      # @file                GCC response files\n      # -tp=*                Portland pgcc target processor selection\n      # --sysroot=*          for sysroot support\n      # -O*, -g*, -flto*, -fwhopr*, -fuse-linker-plugin GCC link-time optimization\n      # -specs=*             GCC specs files\n      # -stdlib=*            select c++ std lib with clang\n      # -fsanitize=*         Clang/GCC memory and address sanitizer\n      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \\\n      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*|-tp=*|--sysroot=*| \\\n      -O*|-g*|-flto*|-fwhopr*|-fuse-linker-plugin|-fstack-protector*|-stdlib=*| \\\n      -specs=*|-fsanitize=*)\n        func_quote_for_eval \"$arg\"\n\targ=$func_quote_for_eval_result\n        func_append compile_command \" $arg\"\n        func_append finalize_command \" $arg\"\n        func_append compiler_flags \" $arg\"\n        continue\n        ;;\n\n      -Z*)\n        if test os2 = \"`expr $host : '.*\\(os2\\)'`\"; then\n          # OS/2 uses -Zxxx to specify OS/2-specific options\n\t  compiler_flags=\"$compiler_flags $arg\"\n\t  func_append compile_command \" $arg\"\n\t  func_append finalize_command \" $arg\"\n\t  case $arg in\n\t  -Zlinker | -Zstack)\n\t    prev=xcompiler\n\t    ;;\n\t  esac\n\t  continue\n        else\n\t  # Otherwise treat like 'Some other compiler flag' below\n\t  func_quote_for_eval \"$arg\"\n\t  arg=$func_quote_for_eval_result\n        fi\n\t;;\n\n      # Some other compiler flag.\n      -* | +*)\n        func_quote_for_eval \"$arg\"\n\targ=$func_quote_for_eval_result\n\t;;\n\n      *.$objext)\n\t# A standard object.\n\tfunc_append objs \" $arg\"\n\t;;\n\n      *.lo)\n\t# A libtool-controlled object.\n\n\t# Check to see that this really is a libtool object.\n\tif func_lalib_unsafe_p \"$arg\"; then\n\t  pic_object=\n\t  non_pic_object=\n\n\t  # Read the .lo file\n\t  func_source \"$arg\"\n\n\t  if test -z \"$pic_object\" ||\n\t     test -z \"$non_pic_object\" ||\n\t     test none = \"$pic_object\" &&\n\t     test none = \"$non_pic_object\"; then\n\t    func_fatal_error \"cannot find name of object for '$arg'\"\n\t  fi\n\n\t  # Extract subdirectory from the argument.\n\t  func_dirname \"$arg\" \"/\" \"\"\n\t  xdir=$func_dirname_result\n\n\t  test none = \"$pic_object\" || {\n\t    # Prepend the subdirectory the object is found in.\n\t    pic_object=$xdir$pic_object\n\n\t    if test dlfiles = \"$prev\"; then\n\t      if test yes = \"$build_libtool_libs\" && test yes = \"$dlopen_support\"; then\n\t\tfunc_append dlfiles \" $pic_object\"\n\t\tprev=\n\t\tcontinue\n\t      else\n\t\t# If libtool objects are unsupported, then we need to preload.\n\t\tprev=dlprefiles\n\t      fi\n\t    fi\n\n\t    # CHECK ME:  I think I busted this.  -Ossama\n\t    if test dlprefiles = \"$prev\"; then\n\t      # Preload the old-style object.\n\t      func_append dlprefiles \" $pic_object\"\n\t      prev=\n\t    fi\n\n\t    # A PIC object.\n\t    func_append libobjs \" $pic_object\"\n\t    arg=$pic_object\n\t  }\n\n\t  # Non-PIC object.\n\t  if test none != \"$non_pic_object\"; then\n\t    # Prepend the subdirectory the object is found in.\n\t    non_pic_object=$xdir$non_pic_object\n\n\t    # A standard non-PIC object\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t    if test -z \"$pic_object\" || test none = \"$pic_object\"; then\n\t      arg=$non_pic_object\n\t    fi\n\t  else\n\t    # If the PIC object exists, use it instead.\n\t    # $xdir was prepended to $pic_object above.\n\t    non_pic_object=$pic_object\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  fi\n\telse\n\t  # Only an error if not doing a dry-run.\n\t  if $opt_dry_run; then\n\t    # Extract subdirectory from the argument.\n\t    func_dirname \"$arg\" \"/\" \"\"\n\t    xdir=$func_dirname_result\n\n\t    func_lo2o \"$arg\"\n\t    pic_object=$xdir$objdir/$func_lo2o_result\n\t    non_pic_object=$xdir$func_lo2o_result\n\t    func_append libobjs \" $pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  else\n\t    func_fatal_error \"'$arg' is not a valid libtool object\"\n\t  fi\n\tfi\n\t;;\n\n      *.$libext)\n\t# An archive.\n\tfunc_append deplibs \" $arg\"\n\tfunc_append old_deplibs \" $arg\"\n\tcontinue\n\t;;\n\n      *.la)\n\t# A libtool-controlled library.\n\n\tfunc_resolve_sysroot \"$arg\"\n\tif test dlfiles = \"$prev\"; then\n\t  # This library was specified with -dlopen.\n\t  func_append dlfiles \" $func_resolve_sysroot_result\"\n\t  prev=\n\telif test dlprefiles = \"$prev\"; then\n\t  # The library was specified with -dlpreopen.\n\t  func_append dlprefiles \" $func_resolve_sysroot_result\"\n\t  prev=\n\telse\n\t  func_append deplibs \" $func_resolve_sysroot_result\"\n\tfi\n\tcontinue\n\t;;\n\n      # Some other compiler argument.\n      *)\n\t# Unknown arguments in both finalize_command and compile_command need\n\t# to be aesthetically quoted because they are evaled later.\n\tfunc_quote_for_eval \"$arg\"\n\targ=$func_quote_for_eval_result\n\t;;\n      esac # arg\n\n      # Now actually substitute the argument into the commands.\n      if test -n \"$arg\"; then\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n      fi\n    done # argument parsing loop\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the '$prevarg' option requires an argument\"\n\n    if test yes = \"$export_dynamic\" && test -n \"$export_dynamic_flag_spec\"; then\n      eval arg=\\\"$export_dynamic_flag_spec\\\"\n      func_append compile_command \" $arg\"\n      func_append finalize_command \" $arg\"\n    fi\n\n    oldlibs=\n    # calculate the name of the file, without its directory\n    func_basename \"$output\"\n    outputname=$func_basename_result\n    libobjs_save=$libobjs\n\n    if test -n \"$shlibpath_var\"; then\n      # get the directories listed in $shlibpath_var\n      eval shlib_search_path=\\`\\$ECHO \\\"\\$$shlibpath_var\\\" \\| \\$SED \\'s/:/ /g\\'\\`\n    else\n      shlib_search_path=\n    fi\n    eval sys_lib_search_path=\\\"$sys_lib_search_path_spec\\\"\n    eval sys_lib_dlsearch_path=\\\"$sys_lib_dlsearch_path_spec\\\"\n\n    # Definition is injected by LT_CONFIG during libtool generation.\n    func_munge_path_list sys_lib_dlsearch_path \"$LT_SYS_LIBRARY_PATH\"\n\n    func_dirname \"$output\" \"/\" \"\"\n    output_objdir=$func_dirname_result$objdir\n    func_to_tool_file \"$output_objdir/\"\n    tool_output_objdir=$func_to_tool_file_result\n    # Create the object directory.\n    func_mkdir_p \"$output_objdir\"\n\n    # Determine the type of output\n    case $output in\n    \"\")\n      func_fatal_help \"you must specify an output file\"\n      ;;\n    *.$libext) linkmode=oldlib ;;\n    *.lo | *.$objext) linkmode=obj ;;\n    *.la) linkmode=lib ;;\n    *) linkmode=prog ;; # Anything else should be a program.\n    esac\n\n    specialdeplibs=\n\n    libs=\n    # Find all interdependent deplibs by searching for libraries\n    # that are linked more than once (e.g. -la -lb -la)\n    for deplib in $deplibs; do\n      if $opt_preserve_dup_deps; then\n\tcase \"$libs \" in\n\t*\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\tesac\n      fi\n      func_append libs \" $deplib\"\n    done\n\n    if test lib = \"$linkmode\"; then\n      libs=\"$predeps $libs $compiler_lib_search_path $postdeps\"\n\n      # Compute libraries that are listed more than once in $predeps\n      # $postdeps and mark them as special (i.e., whose duplicates are\n      # not to be eliminated).\n      pre_post_deps=\n      if $opt_duplicate_compiler_generated_deps; then\n\tfor pre_post_dep in $predeps $postdeps; do\n\t  case \"$pre_post_deps \" in\n\t  *\" $pre_post_dep \"*) func_append specialdeplibs \" $pre_post_deps\" ;;\n\t  esac\n\t  func_append pre_post_deps \" $pre_post_dep\"\n\tdone\n      fi\n      pre_post_deps=\n    fi\n\n    deplibs=\n    newdependency_libs=\n    newlib_search_path=\n    need_relink=no # whether we're linking any uninstalled libtool libraries\n    notinst_deplibs= # not-installed libtool libraries\n    notinst_path= # paths that contain not-installed libtool libraries\n\n    case $linkmode in\n    lib)\n\tpasses=\"conv dlpreopen link\"\n\tfor file in $dlfiles $dlprefiles; do\n\t  case $file in\n\t  *.la) ;;\n\t  *)\n\t    func_fatal_help \"libraries can '-dlopen' only libtool libraries: $file\"\n\t    ;;\n\t  esac\n\tdone\n\t;;\n    prog)\n\tcompile_deplibs=\n\tfinalize_deplibs=\n\talldeplibs=false\n\tnewdlfiles=\n\tnewdlprefiles=\n\tpasses=\"conv scan dlopen dlpreopen link\"\n\t;;\n    *)  passes=\"conv\"\n\t;;\n    esac\n\n    for pass in $passes; do\n      # The preopen pass in lib mode reverses $deplibs; put it back here\n      # so that -L comes before libs that need it for instance...\n      if test lib,link = \"$linkmode,$pass\"; then\n\t## FIXME: Find the place where the list is rebuilt in the wrong\n\t##        order, and fix it there properly\n        tmp_deplibs=\n\tfor deplib in $deplibs; do\n\t  tmp_deplibs=\"$deplib $tmp_deplibs\"\n\tdone\n\tdeplibs=$tmp_deplibs\n      fi\n\n      if test lib,link = \"$linkmode,$pass\" ||\n\t test prog,scan = \"$linkmode,$pass\"; then\n\tlibs=$deplibs\n\tdeplibs=\n      fi\n      if test prog = \"$linkmode\"; then\n\tcase $pass in\n\tdlopen) libs=$dlfiles ;;\n\tdlpreopen) libs=$dlprefiles ;;\n\tlink)\n\t  libs=\"$deplibs %DEPLIBS%\"\n\t  test \"X$link_all_deplibs\" != Xno && libs=\"$libs $dependency_libs\"\n\t  ;;\n\tesac\n      fi\n      if test lib,dlpreopen = \"$linkmode,$pass\"; then\n\t# Collect and forward deplibs of preopened libtool libs\n\tfor lib in $dlprefiles; do\n\t  # Ignore non-libtool-libs\n\t  dependency_libs=\n\t  func_resolve_sysroot \"$lib\"\n\t  case $lib in\n\t  *.la)\tfunc_source \"$func_resolve_sysroot_result\" ;;\n\t  esac\n\n\t  # Collect preopened libtool deplibs, except any this library\n\t  # has declared as weak libs\n\t  for deplib in $dependency_libs; do\n\t    func_basename \"$deplib\"\n            deplib_base=$func_basename_result\n\t    case \" $weak_libs \" in\n\t    *\" $deplib_base \"*) ;;\n\t    *) func_append deplibs \" $deplib\" ;;\n\t    esac\n\t  done\n\tdone\n\tlibs=$dlprefiles\n      fi\n      if test dlopen = \"$pass\"; then\n\t# Collect dlpreopened libraries\n\tsave_deplibs=$deplibs\n\tdeplibs=\n      fi\n\n      for deplib in $libs; do\n\tlib=\n\tfound=false\n\tcase $deplib in\n\t-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \\\n        |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)\n\t  if test prog,link = \"$linkmode,$pass\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    func_append compiler_flags \" $deplib\"\n\t    if test lib = \"$linkmode\"; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) func_append new_inherited_linker_flags \" $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-l*)\n\t  if test lib != \"$linkmode\" && test prog != \"$linkmode\"; then\n\t    func_warning \"'-l' is ignored for archives/objects\"\n\t    continue\n\t  fi\n\t  func_stripname '-l' '' \"$deplib\"\n\t  name=$func_stripname_result\n\t  if test lib = \"$linkmode\"; then\n\t    searchdirs=\"$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path\"\n\t  else\n\t    searchdirs=\"$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path\"\n\t  fi\n\t  for searchdir in $searchdirs; do\n\t    for search_ext in .la $std_shrext .so .a; do\n\t      # Search the libtool library\n\t      lib=$searchdir/lib$name$search_ext\n\t      if test -f \"$lib\"; then\n\t\tif test .la = \"$search_ext\"; then\n\t\t  found=:\n\t\telse\n\t\t  found=false\n\t\tfi\n\t\tbreak 2\n\t      fi\n\t    done\n\t  done\n\t  if $found; then\n\t    # deplib is a libtool library\n\t    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,\n\t    # We need to do some special things here, and not later.\n\t    if test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t      case \" $predeps $postdeps \" in\n\t      *\" $deplib \"*)\n\t\tif func_lalib_p \"$lib\"; then\n\t\t  library_names=\n\t\t  old_library=\n\t\t  func_source \"$lib\"\n\t\t  for l in $old_library $library_names; do\n\t\t    ll=$l\n\t\t  done\n\t\t  if test \"X$ll\" = \"X$old_library\"; then # only static version available\n\t\t    found=false\n\t\t    func_dirname \"$lib\" \"\" \".\"\n\t\t    ladir=$func_dirname_result\n\t\t    lib=$ladir/$old_library\n\t\t    if test prog,link = \"$linkmode,$pass\"; then\n\t\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t\t    else\n\t\t      deplibs=\"$deplib $deplibs\"\n\t\t      test lib = \"$linkmode\" && newdependency_libs=\"$deplib $newdependency_libs\"\n\t\t    fi\n\t\t    continue\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *) ;;\n\t      esac\n\t    fi\n\t  else\n\t    # deplib doesn't seem to be a libtool library\n\t    if test prog,link = \"$linkmode,$pass\"; then\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      deplibs=\"$deplib $deplibs\"\n\t      test lib = \"$linkmode\" && newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    continue\n\t  fi\n\t  ;; # -l\n\t*.ltframework)\n\t  if test prog,link = \"$linkmode,$pass\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$deplib $deplibs\"\n\t    if test lib = \"$linkmode\"; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) func_append new_inherited_linker_flags \" $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-L*)\n\t  case $linkmode in\n\t  lib)\n\t    deplibs=\"$deplib $deplibs\"\n\t    test conv = \"$pass\" && continue\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    func_stripname '-L' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t    ;;\n\t  prog)\n\t    if test conv = \"$pass\"; then\n\t      deplibs=\"$deplib $deplibs\"\n\t      continue\n\t    fi\n\t    if test scan = \"$pass\"; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    func_stripname '-L' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t    ;;\n\t  *)\n\t    func_warning \"'-L' is ignored for archives/objects\"\n\t    ;;\n\t  esac # linkmode\n\t  continue\n\t  ;; # -L\n\t-R*)\n\t  if test link = \"$pass\"; then\n\t    func_stripname '-R' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    dir=$func_resolve_sysroot_result\n\t    # Make sure the xrpath contains only unique directories.\n\t    case \"$xrpath \" in\n\t    *\" $dir \"*) ;;\n\t    *) func_append xrpath \" $dir\" ;;\n\t    esac\n\t  fi\n\t  deplibs=\"$deplib $deplibs\"\n\t  continue\n\t  ;;\n\t*.la)\n\t  func_resolve_sysroot \"$deplib\"\n\t  lib=$func_resolve_sysroot_result\n\t  ;;\n\t*.$libext)\n\t  if test conv = \"$pass\"; then\n\t    deplibs=\"$deplib $deplibs\"\n\t    continue\n\t  fi\n\t  case $linkmode in\n\t  lib)\n\t    # Linking convenience modules into shared libraries is allowed,\n\t    # but linking other static libraries is non-portable.\n\t    case \" $dlpreconveniencelibs \" in\n\t    *\" $deplib \"*) ;;\n\t    *)\n\t      valid_a_lib=false\n\t      case $deplibs_check_method in\n\t\tmatch_pattern*)\n\t\t  set dummy $deplibs_check_method; shift\n\t\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t\t  if eval \"\\$ECHO \\\"$deplib\\\"\" 2>/dev/null | $SED 10q \\\n\t\t    | $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t    valid_a_lib=:\n\t\t  fi\n\t\t;;\n\t\tpass_all)\n\t\t  valid_a_lib=:\n\t\t;;\n\t      esac\n\t      if $valid_a_lib; then\n\t\techo\n\t\t$ECHO \"*** Warning: Linking the shared library $output against the\"\n\t\t$ECHO \"*** static library $deplib is not portable!\"\n\t\tdeplibs=\"$deplib $deplibs\"\n\t      else\n\t\techo\n\t\t$ECHO \"*** Warning: Trying to link with static lib archive $deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because the file extensions .$libext of this argument makes me believe\"\n\t\techo \"*** that it is just a static archive that I should not use here.\"\n\t      fi\n\t      ;;\n\t    esac\n\t    continue\n\t    ;;\n\t  prog)\n\t    if test link != \"$pass\"; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    continue\n\t    ;;\n\t  esac # linkmode\n\t  ;; # *.$libext\n\t*.lo | *.$objext)\n\t  if test conv = \"$pass\"; then\n\t    deplibs=\"$deplib $deplibs\"\n\t  elif test prog = \"$linkmode\"; then\n\t    if test dlpreopen = \"$pass\" || test yes != \"$dlopen_support\" || test no = \"$build_libtool_libs\"; then\n\t      # If there is no dlopen support or we're linking statically,\n\t      # we need to preload.\n\t      func_append newdlprefiles \" $deplib\"\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      func_append newdlfiles \" $deplib\"\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t%DEPLIBS%)\n\t  alldeplibs=:\n\t  continue\n\t  ;;\n\tesac # case $deplib\n\n\t$found || test -f \"$lib\" \\\n\t  || func_fatal_error \"cannot find the library '$lib' or unhandled argument '$deplib'\"\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$lib\" \\\n\t  || func_fatal_error \"'$lib' is not a valid libtool archive\"\n\n\tfunc_dirname \"$lib\" \"\" \".\"\n\tladir=$func_dirname_result\n\n\tdlname=\n\tdlopen=\n\tdlpreopen=\n\tlibdir=\n\tlibrary_names=\n\told_library=\n\tinherited_linker_flags=\n\t# If the library was installed with an old release of libtool,\n\t# it will not redefine variables installed, or shouldnotlink\n\tinstalled=yes\n\tshouldnotlink=no\n\tavoidtemprpath=\n\n\n\t# Read the .la file\n\tfunc_source \"$lib\"\n\n\t# Convert \"-framework foo\" to \"foo.ltframework\"\n\tif test -n \"$inherited_linker_flags\"; then\n\t  tmp_inherited_linker_flags=`$ECHO \"$inherited_linker_flags\" | $SED 's/-framework \\([^ $]*\\)/\\1.ltframework/g'`\n\t  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do\n\t    case \" $new_inherited_linker_flags \" in\n\t      *\" $tmp_inherited_linker_flag \"*) ;;\n\t      *) func_append new_inherited_linker_flags \" $tmp_inherited_linker_flag\";;\n\t    esac\n\t  done\n\tfi\n\tdependency_libs=`$ECHO \" $dependency_libs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tif test lib,link = \"$linkmode,$pass\" ||\n\t   test prog,scan = \"$linkmode,$pass\" ||\n\t   { test prog != \"$linkmode\" && test lib != \"$linkmode\"; }; then\n\t  test -n \"$dlopen\" && func_append dlfiles \" $dlopen\"\n\t  test -n \"$dlpreopen\" && func_append dlprefiles \" $dlpreopen\"\n\tfi\n\n\tif test conv = \"$pass\"; then\n\t  # Only check for convenience libraries\n\t  deplibs=\"$lib $deplibs\"\n\t  if test -z \"$libdir\"; then\n\t    if test -z \"$old_library\"; then\n\t      func_fatal_error \"cannot find name of link library for '$lib'\"\n\t    fi\n\t    # It is a libtool convenience library, so add in its objects.\n\t    func_append convenience \" $ladir/$objdir/$old_library\"\n\t    func_append old_convenience \" $ladir/$objdir/$old_library\"\n\t    tmp_libs=\n\t    for deplib in $dependency_libs; do\n\t      deplibs=\"$deplib $deplibs\"\n\t      if $opt_preserve_dup_deps; then\n\t\tcase \"$tmp_libs \" in\n\t\t*\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\t\tesac\n\t      fi\n\t      func_append tmp_libs \" $deplib\"\n\t    done\n\t  elif test prog != \"$linkmode\" && test lib != \"$linkmode\"; then\n\t    func_fatal_error \"'$lib' is not a convenience library\"\n\t  fi\n\t  continue\n\tfi # $pass = conv\n\n\n\t# Get the name of the library we link against.\n\tlinklib=\n\tif test -n \"$old_library\" &&\n\t   { test yes = \"$prefer_static_libs\" ||\n\t     test built,no = \"$prefer_static_libs,$installed\"; }; then\n\t  linklib=$old_library\n\telse\n\t  for l in $old_library $library_names; do\n\t    linklib=$l\n\t  done\n\tfi\n\tif test -z \"$linklib\"; then\n\t  func_fatal_error \"cannot find name of link library for '$lib'\"\n\tfi\n\n\t# This library was specified with -dlopen.\n\tif test dlopen = \"$pass\"; then\n\t  test -z \"$libdir\" \\\n\t    && func_fatal_error \"cannot -dlopen a convenience library: '$lib'\"\n\t  if test -z \"$dlname\" ||\n\t     test yes != \"$dlopen_support\" ||\n\t     test no = \"$build_libtool_libs\"\n\t  then\n\t    # If there is no dlname, no dlopen support or we're linking\n\t    # statically, we need to preload.  We also need to preload any\n\t    # dependent libraries so libltdl's deplib preloader doesn't\n\t    # bomb out in the load deplibs phase.\n\t    func_append dlprefiles \" $lib $dependency_libs\"\n\t  else\n\t    func_append newdlfiles \" $lib\"\n\t  fi\n\t  continue\n\tfi # $pass = dlopen\n\n\t# We need an absolute path.\n\tcase $ladir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs_ladir=$ladir ;;\n\t*)\n\t  abs_ladir=`cd \"$ladir\" && pwd`\n\t  if test -z \"$abs_ladir\"; then\n\t    func_warning \"cannot determine absolute directory name of '$ladir'\"\n\t    func_warning \"passing it literally to the linker, although it might fail\"\n\t    abs_ladir=$ladir\n\t  fi\n\t  ;;\n\tesac\n\tfunc_basename \"$lib\"\n\tlaname=$func_basename_result\n\n\t# Find the relevant object directory and library name.\n\tif test yes = \"$installed\"; then\n\t  if test ! -f \"$lt_sysroot$libdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    func_warning \"library '$lib' was moved.\"\n\t    dir=$ladir\n\t    absdir=$abs_ladir\n\t    libdir=$abs_ladir\n\t  else\n\t    dir=$lt_sysroot$libdir\n\t    absdir=$lt_sysroot$libdir\n\t  fi\n\t  test yes = \"$hardcode_automatic\" && avoidtemprpath=yes\n\telse\n\t  if test ! -f \"$ladir/$objdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    dir=$ladir\n\t    absdir=$abs_ladir\n\t    # Remove this search path later\n\t    func_append notinst_path \" $abs_ladir\"\n\t  else\n\t    dir=$ladir/$objdir\n\t    absdir=$abs_ladir/$objdir\n\t    # Remove this search path later\n\t    func_append notinst_path \" $abs_ladir\"\n\t  fi\n\tfi # $installed = yes\n\tfunc_stripname 'lib' '.la' \"$laname\"\n\tname=$func_stripname_result\n\n\t# This library was specified with -dlpreopen.\n\tif test dlpreopen = \"$pass\"; then\n\t  if test -z \"$libdir\" && test prog = \"$linkmode\"; then\n\t    func_fatal_error \"only libraries may -dlpreopen a convenience library: '$lib'\"\n\t  fi\n\t  case $host in\n\t    # special handling for platforms with PE-DLLs.\n\t    *cygwin* | *mingw* | *cegcc* )\n\t      # Linker will automatically link against shared library if both\n\t      # static and shared are present.  Therefore, ensure we extract\n\t      # symbols from the import library if a shared library is present\n\t      # (otherwise, the dlopen module name will be incorrect).  We do\n\t      # this by putting the import library name into $newdlprefiles.\n\t      # We recover the dlopen module name by 'saving' the la file\n\t      # name in a special purpose variable, and (later) extracting the\n\t      # dlname from the la file.\n\t      if test -n \"$dlname\"; then\n\t        func_tr_sh \"$dir/$linklib\"\n\t        eval \"libfile_$func_tr_sh_result=\\$abs_ladir/\\$laname\"\n\t        func_append newdlprefiles \" $dir/$linklib\"\n\t      else\n\t        func_append newdlprefiles \" $dir/$old_library\"\n\t        # Keep a list of preopened convenience libraries to check\n\t        # that they are being used correctly in the link pass.\n\t        test -z \"$libdir\" && \\\n\t          func_append dlpreconveniencelibs \" $dir/$old_library\"\n\t      fi\n\t    ;;\n\t    * )\n\t      # Prefer using a static library (so that no silly _DYNAMIC symbols\n\t      # are required to link).\n\t      if test -n \"$old_library\"; then\n\t        func_append newdlprefiles \" $dir/$old_library\"\n\t        # Keep a list of preopened convenience libraries to check\n\t        # that they are being used correctly in the link pass.\n\t        test -z \"$libdir\" && \\\n\t          func_append dlpreconveniencelibs \" $dir/$old_library\"\n\t      # Otherwise, use the dlname, so that lt_dlopen finds it.\n\t      elif test -n \"$dlname\"; then\n\t        func_append newdlprefiles \" $dir/$dlname\"\n\t      else\n\t        func_append newdlprefiles \" $dir/$linklib\"\n\t      fi\n\t    ;;\n\t  esac\n\tfi # $pass = dlpreopen\n\n\tif test -z \"$libdir\"; then\n\t  # Link the convenience library\n\t  if test lib = \"$linkmode\"; then\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t  elif test prog,link = \"$linkmode,$pass\"; then\n\t    compile_deplibs=\"$dir/$old_library $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$old_library $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$lib $deplibs\" # used for prog,scan pass\n\t  fi\n\t  continue\n\tfi\n\n\n\tif test prog = \"$linkmode\" && test link != \"$pass\"; then\n\t  func_append newlib_search_path \" $ladir\"\n\t  deplibs=\"$lib $deplibs\"\n\n\t  linkalldeplibs=false\n\t  if test no != \"$link_all_deplibs\" || test -z \"$library_names\" ||\n\t     test no = \"$build_libtool_libs\"; then\n\t    linkalldeplibs=:\n\t  fi\n\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    case $deplib in\n\t    -L*) func_stripname '-L' '' \"$deplib\"\n\t         func_resolve_sysroot \"$func_stripname_result\"\n\t         func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t\t ;;\n\t    esac\n\t    # Need to link against all dependency_libs?\n\t    if $linkalldeplibs; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      # Need to hardcode shared library paths\n\t      # or/and link against static libraries\n\t      newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    if $opt_preserve_dup_deps; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\t      esac\n\t    fi\n\t    func_append tmp_libs \" $deplib\"\n\t  done # for deplib\n\t  continue\n\tfi # $linkmode = prog...\n\n\tif test prog,link = \"$linkmode,$pass\"; then\n\t  if test -n \"$library_names\" &&\n\t     { { test no = \"$prefer_static_libs\" ||\n\t         test built,yes = \"$prefer_static_libs,$installed\"; } ||\n\t       test -z \"$old_library\"; }; then\n\t    # We need to hardcode the library path\n\t    if test -n \"$shlibpath_var\" && test -z \"$avoidtemprpath\"; then\n\t      # Make sure the rpath contains only unique directories.\n\t      case $temp_rpath: in\n\t      *\"$absdir:\"*) ;;\n\t      *) func_append temp_rpath \"$absdir:\" ;;\n\t      esac\n\t    fi\n\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) func_append compile_rpath \" $absdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append finalize_rpath \" $libdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t  fi # $linkmode,$pass = prog,link...\n\n\t  if $alldeplibs &&\n\t     { test pass_all = \"$deplibs_check_method\" ||\n\t       { test yes = \"$build_libtool_libs\" &&\n\t\t test -n \"$library_names\"; }; }; then\n\t    # We only need to search for static libraries\n\t    continue\n\t  fi\n\tfi\n\n\tlink_static=no # Whether the deplib will be linked statically\n\tuse_static_libs=$prefer_static_libs\n\tif test built = \"$use_static_libs\" && test yes = \"$installed\"; then\n\t  use_static_libs=no\n\tfi\n\tif test -n \"$library_names\" &&\n\t   { test no = \"$use_static_libs\" || test -z \"$old_library\"; }; then\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc* | *os2*)\n\t      # No point in relinking DLLs because paths are not encoded\n\t      func_append notinst_deplibs \" $lib\"\n\t      need_relink=no\n\t    ;;\n\t  *)\n\t    if test no = \"$installed\"; then\n\t      func_append notinst_deplibs \" $lib\"\n\t      need_relink=yes\n\t    fi\n\t    ;;\n\t  esac\n\t  # This is a shared library\n\n\t  # Warn about portability, can't link against -module's on some\n\t  # systems (darwin).  Don't bleat about dlopened modules though!\n\t  dlopenmodule=\n\t  for dlpremoduletest in $dlprefiles; do\n\t    if test \"X$dlpremoduletest\" = \"X$lib\"; then\n\t      dlopenmodule=$dlpremoduletest\n\t      break\n\t    fi\n\t  done\n\t  if test -z \"$dlopenmodule\" && test yes = \"$shouldnotlink\" && test link = \"$pass\"; then\n\t    echo\n\t    if test prog = \"$linkmode\"; then\n\t      $ECHO \"*** Warning: Linking the executable $output against the loadable module\"\n\t    else\n\t      $ECHO \"*** Warning: Linking the shared library $output against the loadable module\"\n\t    fi\n\t    $ECHO \"*** $linklib is not portable!\"\n\t  fi\n\t  if test lib = \"$linkmode\" &&\n\t     test yes = \"$hardcode_into_libs\"; then\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) func_append compile_rpath \" $absdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append finalize_rpath \" $libdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t  fi\n\n\t  if test -n \"$old_archive_from_expsyms_cmds\"; then\n\t    # figure out the soname\n\t    set dummy $library_names\n\t    shift\n\t    realname=$1\n\t    shift\n\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t    # use dlname if we got it. it's perfectly good, no?\n\t    if test -n \"$dlname\"; then\n\t      soname=$dlname\n\t    elif test -n \"$soname_spec\"; then\n\t      # bleh windows\n\t      case $host in\n\t      *cygwin* | mingw* | *cegcc* | *os2*)\n\t        func_arith $current - $age\n\t\tmajor=$func_arith_result\n\t\tversuffix=-$major\n\t\t;;\n\t      esac\n\t      eval soname=\\\"$soname_spec\\\"\n\t    else\n\t      soname=$realname\n\t    fi\n\n\t    # Make a new name for the extract_expsyms_cmds to use\n\t    soroot=$soname\n\t    func_basename \"$soroot\"\n\t    soname=$func_basename_result\n\t    func_stripname 'lib' '.dll' \"$soname\"\n\t    newlib=libimp-$func_stripname_result.a\n\n\t    # If the library has no export list, then create one now\n\t    if test -f \"$output_objdir/$soname-def\"; then :\n\t    else\n\t      func_verbose \"extracting exported symbol list from '$soname'\"\n\t      func_execute_cmds \"$extract_expsyms_cmds\" 'exit $?'\n\t    fi\n\n\t    # Create $newlib\n\t    if test -f \"$output_objdir/$newlib\"; then :; else\n\t      func_verbose \"generating import library for '$soname'\"\n\t      func_execute_cmds \"$old_archive_from_expsyms_cmds\" 'exit $?'\n\t    fi\n\t    # make sure the library variables are pointing to the new library\n\t    dir=$output_objdir\n\t    linklib=$newlib\n\t  fi # test -n \"$old_archive_from_expsyms_cmds\"\n\n\t  if test prog = \"$linkmode\" || test relink != \"$opt_mode\"; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    lib_linked=yes\n\t    case $hardcode_action in\n\t    immediate | unsupported)\n\t      if test no = \"$hardcode_direct\"; then\n\t\tadd=$dir/$linklib\n\t\tcase $host in\n\t\t  *-*-sco3.2v5.0.[024]*) add_dir=-L$dir ;;\n\t\t  *-*-sysv4*uw2*) add_dir=-L$dir ;;\n\t\t  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \\\n\t\t    *-*-unixware7*) add_dir=-L$dir ;;\n\t\t  *-*-darwin* )\n\t\t    # if the lib is a (non-dlopened) module then we cannot\n\t\t    # link against it, someone is ignoring the earlier warnings\n\t\t    if /usr/bin/file -L $add 2> /dev/null |\n\t\t\t $GREP \": [^:]* bundle\" >/dev/null; then\n\t\t      if test \"X$dlopenmodule\" != \"X$lib\"; then\n\t\t\t$ECHO \"*** Warning: lib $linklib is a module, not a shared library\"\n\t\t\tif test -z \"$old_library\"; then\n\t\t\t  echo\n\t\t\t  echo \"*** And there doesn't seem to be a static archive available\"\n\t\t\t  echo \"*** The link will probably fail, sorry\"\n\t\t\telse\n\t\t\t  add=$dir/$old_library\n\t\t\tfi\n\t\t      elif test -n \"$old_library\"; then\n\t\t\tadd=$dir/$old_library\n\t\t      fi\n\t\t    fi\n\t\tesac\n\t      elif test no = \"$hardcode_minus_L\"; then\n\t\tcase $host in\n\t\t*-*-sunos*) add_shlibpath=$dir ;;\n\t\tesac\n\t\tadd_dir=-L$dir\n\t\tadd=-l$name\n\t      elif test no = \"$hardcode_shlibpath_var\"; then\n\t\tadd_shlibpath=$dir\n\t\tadd=-l$name\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    relink)\n\t      if test yes = \"$hardcode_direct\" &&\n\t         test no = \"$hardcode_direct_absolute\"; then\n\t\tadd=$dir/$linklib\n\t      elif test yes = \"$hardcode_minus_L\"; then\n\t\tadd_dir=-L$absdir\n\t\t# Try looking first in the location we're being installed to.\n\t\tif test -n \"$inst_prefix_dir\"; then\n\t\t  case $libdir in\n\t\t    [\\\\/]*)\n\t\t      func_append add_dir \" -L$inst_prefix_dir$libdir\"\n\t\t      ;;\n\t\t  esac\n\t\tfi\n\t\tadd=-l$name\n\t      elif test yes = \"$hardcode_shlibpath_var\"; then\n\t\tadd_shlibpath=$dir\n\t\tadd=-l$name\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    *) lib_linked=no ;;\n\t    esac\n\n\t    if test yes != \"$lib_linked\"; then\n\t      func_fatal_configuration \"unsupported hardcode properties\"\n\t    fi\n\n\t    if test -n \"$add_shlibpath\"; then\n\t      case :$compile_shlibpath: in\n\t      *\":$add_shlibpath:\"*) ;;\n\t      *) func_append compile_shlibpath \"$add_shlibpath:\" ;;\n\t      esac\n\t    fi\n\t    if test prog = \"$linkmode\"; then\n\t      test -n \"$add_dir\" && compile_deplibs=\"$add_dir $compile_deplibs\"\n\t      test -n \"$add\" && compile_deplibs=\"$add $compile_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t      if test yes != \"$hardcode_direct\" &&\n\t\t test yes != \"$hardcode_minus_L\" &&\n\t\t test yes = \"$hardcode_shlibpath_var\"; then\n\t\tcase :$finalize_shlibpath: in\n\t\t*\":$libdir:\"*) ;;\n\t\t*) func_append finalize_shlibpath \"$libdir:\" ;;\n\t\tesac\n\t      fi\n\t    fi\n\t  fi\n\n\t  if test prog = \"$linkmode\" || test relink = \"$opt_mode\"; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    # Finalize command for both is simple: just hardcode it.\n\t    if test yes = \"$hardcode_direct\" &&\n\t       test no = \"$hardcode_direct_absolute\"; then\n\t      add=$libdir/$linklib\n\t    elif test yes = \"$hardcode_minus_L\"; then\n\t      add_dir=-L$libdir\n\t      add=-l$name\n\t    elif test yes = \"$hardcode_shlibpath_var\"; then\n\t      case :$finalize_shlibpath: in\n\t      *\":$libdir:\"*) ;;\n\t      *) func_append finalize_shlibpath \"$libdir:\" ;;\n\t      esac\n\t      add=-l$name\n\t    elif test yes = \"$hardcode_automatic\"; then\n\t      if test -n \"$inst_prefix_dir\" &&\n\t\t test -f \"$inst_prefix_dir$libdir/$linklib\"; then\n\t\tadd=$inst_prefix_dir$libdir/$linklib\n\t      else\n\t\tadd=$libdir/$linklib\n\t      fi\n\t    else\n\t      # We cannot seem to hardcode it, guess we'll fake it.\n\t      add_dir=-L$libdir\n\t      # Try looking first in the location we're being installed to.\n\t      if test -n \"$inst_prefix_dir\"; then\n\t\tcase $libdir in\n\t\t  [\\\\/]*)\n\t\t    func_append add_dir \" -L$inst_prefix_dir$libdir\"\n\t\t    ;;\n\t\tesac\n\t      fi\n\t      add=-l$name\n\t    fi\n\n\t    if test prog = \"$linkmode\"; then\n\t      test -n \"$add_dir\" && finalize_deplibs=\"$add_dir $finalize_deplibs\"\n\t      test -n \"$add\" && finalize_deplibs=\"$add $finalize_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t    fi\n\t  fi\n\telif test prog = \"$linkmode\"; then\n\t  # Here we assume that one of hardcode_direct or hardcode_minus_L\n\t  # is not unsupported.  This is valid on all known static and\n\t  # shared platforms.\n\t  if test unsupported != \"$hardcode_direct\"; then\n\t    test -n \"$old_library\" && linklib=$old_library\n\t    compile_deplibs=\"$dir/$linklib $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$linklib $finalize_deplibs\"\n\t  else\n\t    compile_deplibs=\"-l$name -L$dir $compile_deplibs\"\n\t    finalize_deplibs=\"-l$name -L$dir $finalize_deplibs\"\n\t  fi\n\telif test yes = \"$build_libtool_libs\"; then\n\t  # Not a shared library\n\t  if test pass_all != \"$deplibs_check_method\"; then\n\t    # We're trying link a shared library against a static one\n\t    # but the system doesn't support it.\n\n\t    # Just print a warning and add the library to dependency_libs so\n\t    # that the program can be linked against the static library.\n\t    echo\n\t    $ECHO \"*** Warning: This system cannot link to static lib archive $lib.\"\n\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t    echo \"*** shared version of the library, which you do not appear to have.\"\n\t    if test yes = \"$module\"; then\n\t      echo \"*** But as you try to build a module library, libtool will still create \"\n\t      echo \"*** a static module, that should work as long as the dlopening application\"\n\t      echo \"*** is linked with the -dlopen flag to resolve symbols at runtime.\"\n\t      if test -z \"$global_symbol_pipe\"; then\n\t\techo\n\t\techo \"*** However, this would only work if libtool was able to extract symbol\"\n\t\techo \"*** lists from a program, using 'nm' or equivalent, but libtool could\"\n\t\techo \"*** not find such a program.  So, this module is probably useless.\"\n\t\techo \"*** 'nm' from GNU binutils and a full rebuild may help.\"\n\t      fi\n\t      if test no = \"$build_old_libs\"; then\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  else\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t    link_static=yes\n\t  fi\n\tfi # link shared/static library?\n\n\tif test lib = \"$linkmode\"; then\n\t  if test -n \"$dependency_libs\" &&\n\t     { test yes != \"$hardcode_into_libs\" ||\n\t       test yes = \"$build_old_libs\" ||\n\t       test yes = \"$link_static\"; }; then\n\t    # Extract -R from dependency_libs\n\t    temp_deplibs=\n\t    for libdir in $dependency_libs; do\n\t      case $libdir in\n\t      -R*) func_stripname '-R' '' \"$libdir\"\n\t           temp_xrpath=$func_stripname_result\n\t\t   case \" $xrpath \" in\n\t\t   *\" $temp_xrpath \"*) ;;\n\t\t   *) func_append xrpath \" $temp_xrpath\";;\n\t\t   esac;;\n\t      *) func_append temp_deplibs \" $libdir\";;\n\t      esac\n\t    done\n\t    dependency_libs=$temp_deplibs\n\t  fi\n\n\t  func_append newlib_search_path \" $absdir\"\n\t  # Link against this library\n\t  test no = \"$link_static\" && newdependency_libs=\"$abs_ladir/$laname $newdependency_libs\"\n\t  # ... and its dependency_libs\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    case $deplib in\n              -L*) func_stripname '-L' '' \"$deplib\"\n                   func_resolve_sysroot \"$func_stripname_result\";;\n              *) func_resolve_sysroot \"$deplib\" ;;\n            esac\n\t    if $opt_preserve_dup_deps; then\n\t      case \"$tmp_libs \" in\n\t      *\" $func_resolve_sysroot_result \"*)\n                func_append specialdeplibs \" $func_resolve_sysroot_result\" ;;\n\t      esac\n\t    fi\n\t    func_append tmp_libs \" $func_resolve_sysroot_result\"\n\t  done\n\n\t  if test no != \"$link_all_deplibs\"; then\n\t    # Add the search paths of all dependency libraries\n\t    for deplib in $dependency_libs; do\n\t      path=\n\t      case $deplib in\n\t      -L*) path=$deplib ;;\n\t      *.la)\n\t        func_resolve_sysroot \"$deplib\"\n\t        deplib=$func_resolve_sysroot_result\n\t        func_dirname \"$deplib\" \"\" \".\"\n\t\tdir=$func_dirname_result\n\t\t# We need an absolute path.\n\t\tcase $dir in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) absdir=$dir ;;\n\t\t*)\n\t\t  absdir=`cd \"$dir\" && pwd`\n\t\t  if test -z \"$absdir\"; then\n\t\t    func_warning \"cannot determine absolute directory name of '$dir'\"\n\t\t    absdir=$dir\n\t\t  fi\n\t\t  ;;\n\t\tesac\n\t\tif $GREP \"^installed=no\" $deplib > /dev/null; then\n\t\tcase $host in\n\t\t*-*-darwin*)\n\t\t  depdepl=\n\t\t  eval deplibrary_names=`$SED -n -e 's/^library_names=\\(.*\\)$/\\1/p' $deplib`\n\t\t  if test -n \"$deplibrary_names\"; then\n\t\t    for tmp in $deplibrary_names; do\n\t\t      depdepl=$tmp\n\t\t    done\n\t\t    if test -f \"$absdir/$objdir/$depdepl\"; then\n\t\t      depdepl=$absdir/$objdir/$depdepl\n\t\t      darwin_install_name=`$OTOOL -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`\n                      if test -z \"$darwin_install_name\"; then\n                          darwin_install_name=`$OTOOL64 -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`\n                      fi\n\t\t      func_append compiler_flags \" $wl-dylib_file $wl$darwin_install_name:$depdepl\"\n\t\t      func_append linker_flags \" -dylib_file $darwin_install_name:$depdepl\"\n\t\t      path=\n\t\t    fi\n\t\t  fi\n\t\t  ;;\n\t\t*)\n\t\t  path=-L$absdir/$objdir\n\t\t  ;;\n\t\tesac\n\t\telse\n\t\t  eval libdir=`$SED -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\t  test -z \"$libdir\" && \\\n\t\t    func_fatal_error \"'$deplib' is not a valid libtool archive\"\n\t\t  test \"$absdir\" != \"$libdir\" && \\\n\t\t    func_warning \"'$deplib' seems to be moved\"\n\n\t\t  path=-L$absdir\n\t\tfi\n\t\t;;\n\t      esac\n\t      case \" $deplibs \" in\n\t      *\" $path \"*) ;;\n\t      *) deplibs=\"$path $deplibs\" ;;\n\t      esac\n\t    done\n\t  fi # link_all_deplibs != no\n\tfi # linkmode = lib\n      done # for deplib in $libs\n      if test link = \"$pass\"; then\n\tif test prog = \"$linkmode\"; then\n\t  compile_deplibs=\"$new_inherited_linker_flags $compile_deplibs\"\n\t  finalize_deplibs=\"$new_inherited_linker_flags $finalize_deplibs\"\n\telse\n\t  compiler_flags=\"$compiler_flags \"`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfi\n      fi\n      dependency_libs=$newdependency_libs\n      if test dlpreopen = \"$pass\"; then\n\t# Link the dlpreopened libraries before other libraries\n\tfor deplib in $save_deplibs; do\n\t  deplibs=\"$deplib $deplibs\"\n\tdone\n      fi\n      if test dlopen != \"$pass\"; then\n\ttest conv = \"$pass\" || {\n\t  # Make sure lib_search_path contains only unique directories.\n\t  lib_search_path=\n\t  for dir in $newlib_search_path; do\n\t    case \"$lib_search_path \" in\n\t    *\" $dir \"*) ;;\n\t    *) func_append lib_search_path \" $dir\" ;;\n\t    esac\n\t  done\n\t  newlib_search_path=\n\t}\n\n\tif test prog,link = \"$linkmode,$pass\"; then\n\t  vars=\"compile_deplibs finalize_deplibs\"\n\telse\n\t  vars=deplibs\n\tfi\n\tfor var in $vars dependency_libs; do\n\t  # Add libraries to $var in reverse order\n\t  eval tmp_libs=\\\"\\$$var\\\"\n\t  new_libs=\n\t  for deplib in $tmp_libs; do\n\t    # FIXME: Pedantically, this is the right thing to do, so\n\t    #        that some nasty dependency loop isn't accidentally\n\t    #        broken:\n\t    #new_libs=\"$deplib $new_libs\"\n\t    # Pragmatically, this seems to cause very few problems in\n\t    # practice:\n\t    case $deplib in\n\t    -L*) new_libs=\"$deplib $new_libs\" ;;\n\t    -R*) ;;\n\t    *)\n\t      # And here is the reason: when a library appears more\n\t      # than once as an explicit dependence of a library, or\n\t      # is implicitly linked in more than once by the\n\t      # compiler, it is considered special, and multiple\n\t      # occurrences thereof are not removed.  Compare this\n\t      # with having the same library being listed as a\n\t      # dependency of multiple other libraries: in this case,\n\t      # we know (pedantically, we assume) the library does not\n\t      # need to be listed more than once, so we keep only the\n\t      # last copy.  This is not always right, but it is rare\n\t      # enough that we require users that really mean to play\n\t      # such unportable linking tricks to link the library\n\t      # using -Wl,-lname, so that libtool does not consider it\n\t      # for duplicate removal.\n\t      case \" $specialdeplibs \" in\n\t      *\" $deplib \"*) new_libs=\"$deplib $new_libs\" ;;\n\t      *)\n\t\tcase \" $new_libs \" in\n\t\t*\" $deplib \"*) ;;\n\t\t*) new_libs=\"$deplib $new_libs\" ;;\n\t\tesac\n\t\t;;\n\t      esac\n\t      ;;\n\t    esac\n\t  done\n\t  tmp_libs=\n\t  for deplib in $new_libs; do\n\t    case $deplib in\n\t    -L*)\n\t      case \" $tmp_libs \" in\n\t      *\" $deplib \"*) ;;\n\t      *) func_append tmp_libs \" $deplib\" ;;\n\t      esac\n\t      ;;\n\t    *) func_append tmp_libs \" $deplib\" ;;\n\t    esac\n\t  done\n\t  eval $var=\\\"$tmp_libs\\\"\n\tdone # for var\n      fi\n\n      # Add Sun CC postdeps if required:\n      test CXX = \"$tagname\" && {\n        case $host_os in\n        linux*)\n          case `$CC -V 2>&1 | sed 5q` in\n          *Sun\\ C*) # Sun C++ 5.9\n            func_suncc_cstd_abi\n\n            if test no != \"$suncc_use_cstd_abi\"; then\n              func_append postdeps ' -library=Cstd -library=Crun'\n            fi\n            ;;\n          esac\n          ;;\n\n        solaris*)\n          func_cc_basename \"$CC\"\n          case $func_cc_basename_result in\n          CC* | sunCC*)\n            func_suncc_cstd_abi\n\n            if test no != \"$suncc_use_cstd_abi\"; then\n              func_append postdeps ' -library=Cstd -library=Crun'\n            fi\n            ;;\n          esac\n          ;;\n        esac\n      }\n\n      # Last step: remove runtime libs from dependency_libs\n      # (they stay in deplibs)\n      tmp_libs=\n      for i in $dependency_libs; do\n\tcase \" $predeps $postdeps $compiler_lib_search_path \" in\n\t*\" $i \"*)\n\t  i=\n\t  ;;\n\tesac\n\tif test -n \"$i\"; then\n\t  func_append tmp_libs \" $i\"\n\tfi\n      done\n      dependency_libs=$tmp_libs\n    done # for pass\n    if test prog = \"$linkmode\"; then\n      dlfiles=$newdlfiles\n    fi\n    if test prog = \"$linkmode\" || test lib = \"$linkmode\"; then\n      dlprefiles=$newdlprefiles\n    fi\n\n    case $linkmode in\n    oldlib)\n      if test -n \"$dlfiles$dlprefiles\" || test no != \"$dlself\"; then\n\tfunc_warning \"'-dlopen' is ignored for archives\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"'-l' and '-L' are ignored for archives\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"'-rpath' is ignored for archives\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"'-R' is ignored for archives\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"'-version-info/-version-number' is ignored for archives\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"'-release' is ignored for archives\"\n\n      test -n \"$export_symbols$export_symbols_regex\" && \\\n\tfunc_warning \"'-export-symbols' is ignored for archives\"\n\n      # Now set the variables for building old libraries.\n      build_libtool_libs=no\n      oldlibs=$output\n      func_append objs \"$old_deplibs\"\n      ;;\n\n    lib)\n      # Make sure we only generate libraries of the form 'libNAME.la'.\n      case $outputname in\n      lib*)\n\tfunc_stripname 'lib' '.la' \"$outputname\"\n\tname=$func_stripname_result\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval libname=\\\"$libname_spec\\\"\n\t;;\n      *)\n\ttest no = \"$module\" \\\n\t  && func_fatal_help \"libtool library '$output' must begin with 'lib'\"\n\n\tif test no != \"$need_lib_prefix\"; then\n\t  # Add the \"lib\" prefix for modules if required\n\t  func_stripname '' '.la' \"$outputname\"\n\t  name=$func_stripname_result\n\t  eval shared_ext=\\\"$shrext_cmds\\\"\n\t  eval libname=\\\"$libname_spec\\\"\n\telse\n\t  func_stripname '' '.la' \"$outputname\"\n\t  libname=$func_stripname_result\n\tfi\n\t;;\n      esac\n\n      if test -n \"$objs\"; then\n\tif test pass_all != \"$deplibs_check_method\"; then\n\t  func_fatal_error \"cannot build libtool library '$output' from non-libtool objects on this host:$objs\"\n\telse\n\t  echo\n\t  $ECHO \"*** Warning: Linking the shared library $output against the non-libtool\"\n\t  $ECHO \"*** objects $objs is not portable!\"\n\t  func_append libobjs \" $objs\"\n\tfi\n      fi\n\n      test no = \"$dlself\" \\\n\t|| func_warning \"'-dlopen self' is ignored for libtool libraries\"\n\n      set dummy $rpath\n      shift\n      test 1 -lt \"$#\" \\\n\t&& func_warning \"ignoring multiple '-rpath's for a libtool library\"\n\n      install_libdir=$1\n\n      oldlibs=\n      if test -z \"$rpath\"; then\n\tif test yes = \"$build_libtool_libs\"; then\n\t  # Building a libtool convenience library.\n\t  # Some compilers have problems with a '.al' extension so\n\t  # convenience libraries should have the same extension an\n\t  # archive normally would.\n\t  oldlibs=\"$output_objdir/$libname.$libext $oldlibs\"\n\t  build_libtool_libs=convenience\n\t  build_old_libs=yes\n\tfi\n\n\ttest -n \"$vinfo\" && \\\n\t  func_warning \"'-version-info/-version-number' is ignored for convenience libraries\"\n\n\ttest -n \"$release\" && \\\n\t  func_warning \"'-release' is ignored for convenience libraries\"\n      else\n\n\t# Parse the version information argument.\n\tsave_ifs=$IFS; IFS=:\n\tset dummy $vinfo 0 0 0\n\tshift\n\tIFS=$save_ifs\n\n\ttest -n \"$7\" && \\\n\t  func_fatal_help \"too many parameters to '-version-info'\"\n\n\t# convert absolute version numbers to libtool ages\n\t# this retains compatibility with .la files and attempts\n\t# to make the code below a bit more comprehensible\n\n\tcase $vinfo_number in\n\tyes)\n\t  number_major=$1\n\t  number_minor=$2\n\t  number_revision=$3\n\t  #\n\t  # There are really only two kinds -- those that\n\t  # use the current revision as the major version\n\t  # and those that subtract age and use age as\n\t  # a minor version.  But, then there is irix\n\t  # that has an extra 1 added just for fun\n\t  #\n\t  case $version_type in\n\t  # correct linux to gnu/linux during the next big refactor\n\t  darwin|freebsd-elf|linux|osf|windows|none)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=$number_minor\n\t    revision=$number_revision\n\t    ;;\n\t  freebsd-aout|qnx|sunos)\n\t    current=$number_major\n\t    revision=$number_minor\n\t    age=0\n\t    ;;\n\t  irix|nonstopux)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=$number_minor\n\t    revision=$number_minor\n\t    lt_irix_increment=no\n\t    ;;\n\t  *)\n\t    func_fatal_configuration \"$modename: unknown library version type '$version_type'\"\n\t    ;;\n\t  esac\n\t  ;;\n\tno)\n\t  current=$1\n\t  revision=$2\n\t  age=$3\n\t  ;;\n\tesac\n\n\t# Check that each of the things are valid numbers.\n\tcase $current in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"CURRENT '$current' must be a nonnegative integer\"\n\t  func_fatal_error \"'$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $revision in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"REVISION '$revision' must be a nonnegative integer\"\n\t  func_fatal_error \"'$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $age in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"AGE '$age' must be a nonnegative integer\"\n\t  func_fatal_error \"'$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tif test \"$age\" -gt \"$current\"; then\n\t  func_error \"AGE '$age' is greater than the current interface number '$current'\"\n\t  func_fatal_error \"'$vinfo' is not valid version information\"\n\tfi\n\n\t# Calculate the version variables.\n\tmajor=\n\tversuffix=\n\tverstring=\n\tcase $version_type in\n\tnone) ;;\n\n\tdarwin)\n\t  # Like Linux, but with the current version available in\n\t  # verstring for coding it into the library header\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=$major.$age.$revision\n\t  # Darwin ld doesn't like 0 for these options...\n\t  func_arith $current + 1\n\t  minor_current=$func_arith_result\n\t  xlcverstring=\"$wl-compatibility_version $wl$minor_current $wl-current_version $wl$minor_current.$revision\"\n\t  verstring=\"-compatibility_version $minor_current -current_version $minor_current.$revision\"\n          # On Darwin other compilers\n          case $CC in\n              nagfor*)\n                  verstring=\"$wl-compatibility_version $wl$minor_current $wl-current_version $wl$minor_current.$revision\"\n                  ;;\n              *)\n                  verstring=\"-compatibility_version $minor_current -current_version $minor_current.$revision\"\n                  ;;\n          esac\n\t  ;;\n\n\tfreebsd-aout)\n\t  major=.$current\n\t  versuffix=.$current.$revision\n\t  ;;\n\n\tfreebsd-elf)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=$major.$age.$revision\n\t  ;;\n\n\tirix | nonstopux)\n\t  if test no = \"$lt_irix_increment\"; then\n\t    func_arith $current - $age\n\t  else\n\t    func_arith $current - $age + 1\n\t  fi\n\t  major=$func_arith_result\n\n\t  case $version_type in\n\t    nonstopux) verstring_prefix=nonstopux ;;\n\t    *)         verstring_prefix=sgi ;;\n\t  esac\n\t  verstring=$verstring_prefix$major.$revision\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$revision\n\t  while test 0 -ne \"$loop\"; do\n\t    func_arith $revision - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=$verstring_prefix$major.$iface:$verstring\n\t  done\n\n\t  # Before this point, $major must not contain '.'.\n\t  major=.$major\n\t  versuffix=$major.$revision\n\t  ;;\n\n\tlinux) # correct to gnu/linux during the next big refactor\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=$major.$age.$revision\n\t  ;;\n\n\tosf)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=.$current.$age.$revision\n\t  verstring=$current.$age.$revision\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$age\n\t  while test 0 -ne \"$loop\"; do\n\t    func_arith $current - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=$verstring:$iface.0\n\t  done\n\n\t  # Make executables depend on our current version.\n\t  func_append verstring \":$current.0\"\n\t  ;;\n\n\tqnx)\n\t  major=.$current\n\t  versuffix=.$current\n\t  ;;\n\n\tsco)\n\t  major=.$current\n\t  versuffix=.$current\n\t  ;;\n\n\tsunos)\n\t  major=.$current\n\t  versuffix=.$current.$revision\n\t  ;;\n\n\twindows)\n\t  # Use '-' rather than '.', since we only want one\n\t  # extension on DOS 8.3 file systems.\n\t  func_arith $current - $age\n\t  major=$func_arith_result\n\t  versuffix=-$major\n\t  ;;\n\n\t*)\n\t  func_fatal_configuration \"unknown library version type '$version_type'\"\n\t  ;;\n\tesac\n\n\t# Clear the version info if we defaulted, and they specified a release.\n\tif test -z \"$vinfo\" && test -n \"$release\"; then\n\t  major=\n\t  case $version_type in\n\t  darwin)\n\t    # we can't check for \"0.0\" in archive_cmds due to quoting\n\t    # problems, so we reset it completely\n\t    verstring=\n\t    ;;\n\t  *)\n\t    verstring=0.0\n\t    ;;\n\t  esac\n\t  if test no = \"$need_version\"; then\n\t    versuffix=\n\t  else\n\t    versuffix=.0.0\n\t  fi\n\tfi\n\n\t# Remove version info from name if versioning should be avoided\n\tif test yes,no = \"$avoid_version,$need_version\"; then\n\t  major=\n\t  versuffix=\n\t  verstring=\n\tfi\n\n\t# Check to see if the archive will have undefined symbols.\n\tif test yes = \"$allow_undefined\"; then\n\t  if test unsupported = \"$allow_undefined_flag\"; then\n\t    if test yes = \"$build_old_libs\"; then\n\t      func_warning \"undefined symbols not allowed in $host shared libraries; building static only\"\n\t      build_libtool_libs=no\n\t    else\n\t      func_fatal_error \"can't build $host shared library unless -no-undefined is specified\"\n\t    fi\n\t  fi\n\telse\n\t  # Don't allow undefined symbols.\n\t  allow_undefined_flag=$no_undefined_flag\n\tfi\n\n      fi\n\n      func_generate_dlsyms \"$libname\" \"$libname\" :\n      func_append libobjs \" $symfileobj\"\n      test \" \" = \"$libobjs\" && libobjs=\n\n      if test relink != \"$opt_mode\"; then\n\t# Remove our outputs, but don't remove object files since they\n\t# may have been created when compiling PIC objects.\n\tremovelist=\n\ttempremovelist=`$ECHO \"$output_objdir/*\"`\n\tfor p in $tempremovelist; do\n\t  case $p in\n\t    *.$objext | *.gcno)\n\t       ;;\n\t    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/$libname$release.*)\n\t       if test -n \"$precious_files_regex\"; then\n\t\t if $ECHO \"$p\" | $EGREP -e \"$precious_files_regex\" >/dev/null 2>&1\n\t\t then\n\t\t   continue\n\t\t fi\n\t       fi\n\t       func_append removelist \" $p\"\n\t       ;;\n\t    *) ;;\n\t  esac\n\tdone\n\ttest -n \"$removelist\" && \\\n\t  func_show_eval \"${RM}r \\$removelist\"\n      fi\n\n      # Now set the variables for building old libraries.\n      if test yes = \"$build_old_libs\" && test convenience != \"$build_libtool_libs\"; then\n\tfunc_append oldlibs \" $output_objdir/$libname.$libext\"\n\n\t# Transform .lo files to .o files.\n\toldobjs=\"$objs \"`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.$libext$/d; $lo2o\" | $NL2SP`\n      fi\n\n      # Eliminate all temporary directories.\n      #for path in $notinst_path; do\n      #\tlib_search_path=`$ECHO \"$lib_search_path \" | $SED \"s% $path % %g\"`\n      #\tdeplibs=`$ECHO \"$deplibs \" | $SED \"s% -L$path % %g\"`\n      #\tdependency_libs=`$ECHO \"$dependency_libs \" | $SED \"s% -L$path % %g\"`\n      #done\n\n      if test -n \"$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\ttemp_xrpath=\n\tfor libdir in $xrpath; do\n\t  func_replace_sysroot \"$libdir\"\n\t  func_append temp_xrpath \" -R$func_replace_sysroot_result\"\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_rpath \" $libdir\" ;;\n\t  esac\n\tdone\n\tif test yes != \"$hardcode_into_libs\" || test yes = \"$build_old_libs\"; then\n\t  dependency_libs=\"$temp_xrpath $dependency_libs\"\n\tfi\n      fi\n\n      # Make sure dlfiles contains only unique files that won't be dlpreopened\n      old_dlfiles=$dlfiles\n      dlfiles=\n      for lib in $old_dlfiles; do\n\tcase \" $dlprefiles $dlfiles \" in\n\t*\" $lib \"*) ;;\n\t*) func_append dlfiles \" $lib\" ;;\n\tesac\n      done\n\n      # Make sure dlprefiles contains only unique files\n      old_dlprefiles=$dlprefiles\n      dlprefiles=\n      for lib in $old_dlprefiles; do\n\tcase \"$dlprefiles \" in\n\t*\" $lib \"*) ;;\n\t*) func_append dlprefiles \" $lib\" ;;\n\tesac\n      done\n\n      if test yes = \"$build_libtool_libs\"; then\n\tif test -n \"$rpath\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # these systems don't actually have a c library (as such)!\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C library is in the System framework\n\t    func_append deplibs \" System.ltframework\"\n\t    ;;\n\t  *-*-netbsd*)\n\t    # Don't link with libc until the a.out ld.so is fixed.\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    ;;\n\t  *)\n\t    # Add libc to deplibs on all other systems if necessary.\n\t    if test yes = \"$build_libtool_need_lc\"; then\n\t      func_append deplibs \" -lc\"\n\t    fi\n\t    ;;\n\t  esac\n\tfi\n\n\t# Transform deplibs into only deplibs that can be linked in shared.\n\tname_save=$name\n\tlibname_save=$libname\n\trelease_save=$release\n\tversuffix_save=$versuffix\n\tmajor_save=$major\n\t# I'm not sure if I'm treating the release correctly.  I think\n\t# release should show up in the -l (ie -lgmp5) so we don't want to\n\t# add it in twice.  Is that correct?\n\trelease=\n\tversuffix=\n\tmajor=\n\tnewdeplibs=\n\tdroppeddeps=no\n\tcase $deplibs_check_method in\n\tpass_all)\n\t  # Don't check for shared/static.  Everything works.\n\t  # This might be a little naive.  We might want to check\n\t  # whether the library exists or not.  But this is on\n\t  # osf3 & osf4 and I'm not really sure... Just\n\t  # implementing what was already the behavior.\n\t  newdeplibs=$deplibs\n\t  ;;\n\ttest_compile)\n\t  # This code stresses the \"libraries are programs\" paradigm to its\n\t  # limits. Maybe even breaks it.  We compile a program, linking it\n\t  # against the deplibs as a proxy for the library.  Then we can check\n\t  # whether they linked in statically or dynamically with ldd.\n\t  $opt_dry_run || $RM conftest.c\n\t  cat > conftest.c <<EOF\n\t  int main() { return 0; }\nEOF\n\t  $opt_dry_run || $RM conftest\n\t  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then\n\t    ldd_output=`ldd conftest`\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\tif test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t\t  case \" $predeps $postdeps \" in\n\t\t  *\" $i \"*)\n\t\t    func_append newdeplibs \" $i\"\n\t\t    i=\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t\tif test -n \"$i\"; then\n\t\t  libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t  deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t  set dummy $deplib_matches; shift\n\t\t  deplib_match=$1\n\t\t  if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0; then\n\t\t    func_append newdeplibs \" $i\"\n\t\t  else\n\t\t    droppeddeps=yes\n\t\t    echo\n\t\t    $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t    echo \"*** shared version of the library, which I believe you do not have\"\n\t\t    echo \"*** because a test_compile did reveal that the linker did not use it for\"\n\t\t    echo \"*** its dynamic dependency list that programs get resolved with at runtime.\"\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *)\n\t\tfunc_append newdeplibs \" $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  else\n\t    # Error occurred in the first compile.  Let's try to salvage\n\t    # the situation: Compile a separate program for each library.\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\t$opt_dry_run || $RM conftest\n\t\tif $LTCC $LTCFLAGS -o conftest conftest.c $i; then\n\t\t  ldd_output=`ldd conftest`\n\t\t  if test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t\t    case \" $predeps $postdeps \" in\n\t\t    *\" $i \"*)\n\t\t      func_append newdeplibs \" $i\"\n\t\t      i=\n\t\t      ;;\n\t\t    esac\n\t\t  fi\n\t\t  if test -n \"$i\"; then\n\t\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t    deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t    set dummy $deplib_matches; shift\n\t\t    deplib_match=$1\n\t\t    if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0; then\n\t\t      func_append newdeplibs \" $i\"\n\t\t    else\n\t\t      droppeddeps=yes\n\t\t      echo\n\t\t      $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t      echo \"*** I have the capability to make that library automatically link in when\"\n\t\t      echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t      echo \"*** shared version of the library, which you do not appear to have\"\n\t\t      echo \"*** because a test_compile did reveal that the linker did not use this one\"\n\t\t      echo \"*** as a dynamic dependency that programs can get resolved with at runtime.\"\n\t\t    fi\n\t\t  fi\n\t\telse\n\t\t  droppeddeps=yes\n\t\t  echo\n\t\t  $ECHO \"*** Warning!  Library $i is needed by this library but I was not able to\"\n\t\t  echo \"*** make it link in!  You will probably need to install it or some\"\n\t\t  echo \"*** library that it depends on before this library will be fully\"\n\t\t  echo \"*** functional.  Installing it before continuing would be even better.\"\n\t\tfi\n\t\t;;\n\t      *)\n\t\tfunc_append newdeplibs \" $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  fi\n\t  ;;\n\tfile_magic*)\n\t  set dummy $deplibs_check_method; shift\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  func_append newdeplibs \" $a_deplib\"\n\t\t  a_deplib=\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\"; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tif test -n \"$file_magic_glob\"; then\n\t\t  libnameglob=`func_echo_all \"$libname\" | $SED -e $file_magic_glob`\n\t\telse\n\t\t  libnameglob=$libname\n\t\tfi\n\t\ttest yes = \"$want_nocaseglob\" && nocaseglob=`shopt -p nocaseglob`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  if test yes = \"$want_nocaseglob\"; then\n\t\t    shopt -s nocaseglob\n\t\t    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`\n\t\t    $nocaseglob\n\t\t  else\n\t\t    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`\n\t\t  fi\n\t\t  for potent_lib in $potential_libs; do\n\t\t      # Follow soft links.\n\t\t      if ls -lLd \"$potent_lib\" 2>/dev/null |\n\t\t\t $GREP \" -> \" >/dev/null; then\n\t\t\tcontinue\n\t\t      fi\n\t\t      # The statement above tries to avoid entering an\n\t\t      # endless loop below, in case of cyclic links.\n\t\t      # We might still enter an endless loop, since a link\n\t\t      # loop can be closed while we follow links,\n\t\t      # but so what?\n\t\t      potlib=$potent_lib\n\t\t      while test -h \"$potlib\" 2>/dev/null; do\n\t\t\tpotliblink=`ls -ld $potlib | $SED 's/.* -> //'`\n\t\t\tcase $potliblink in\n\t\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) potlib=$potliblink;;\n\t\t\t*) potlib=`$ECHO \"$potlib\" | $SED 's|[^/]*$||'`\"$potliblink\";;\n\t\t\tesac\n\t\t      done\n\t\t      if eval $file_magic_cmd \\\"\\$potlib\\\" 2>/dev/null |\n\t\t\t $SED -e 10q |\n\t\t\t $EGREP \"$file_magic_regex\" > /dev/null; then\n\t\t\tfunc_append newdeplibs \" $a_deplib\"\n\t\t\ta_deplib=\n\t\t\tbreak 2\n\t\t      fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\"; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\"; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for file magic test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a file magic. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      func_append newdeplibs \" $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tmatch_pattern*)\n\t  set dummy $deplibs_check_method; shift\n\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  func_append newdeplibs \" $a_deplib\"\n\t\t  a_deplib=\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\"; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t    potlib=$potent_lib # see symlink-check above in file_magic test\n\t\t    if eval \"\\$ECHO \\\"$potent_lib\\\"\" 2>/dev/null | $SED 10q | \\\n\t\t       $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t      func_append newdeplibs \" $a_deplib\"\n\t\t      a_deplib=\n\t\t      break 2\n\t\t    fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\"; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\"; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for regex pattern test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a regex pattern. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      func_append newdeplibs \" $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tnone | unknown | *)\n\t  newdeplibs=\n\t  tmp_deplibs=`$ECHO \" $deplibs\" | $SED 's/ -lc$//; s/ -[LR][^ ]*//g'`\n\t  if test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t    for i in $predeps $postdeps; do\n\t      # can't use Xsed below, because $i might contain '/'\n\t      tmp_deplibs=`$ECHO \" $tmp_deplibs\" | $SED \"s|$i||\"`\n\t    done\n\t  fi\n\t  case $tmp_deplibs in\n\t  *[!\\\t\\ ]*)\n\t    echo\n\t    if test none = \"$deplibs_check_method\"; then\n\t      echo \"*** Warning: inter-library dependencies are not supported in this platform.\"\n\t    else\n\t      echo \"*** Warning: inter-library dependencies are not known to be supported.\"\n\t    fi\n\t    echo \"*** All declared inter-library dependencies are being dropped.\"\n\t    droppeddeps=yes\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tversuffix=$versuffix_save\n\tmajor=$major_save\n\trelease=$release_save\n\tlibname=$libname_save\n\tname=$name_save\n\n\tcase $host in\n\t*-*-rhapsody* | *-*-darwin1.[012])\n\t  # On Rhapsody replace the C library with the System framework\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t  ;;\n\tesac\n\n\tif test yes = \"$droppeddeps\"; then\n\t  if test yes = \"$module\"; then\n\t    echo\n\t    echo \"*** Warning: libtool could not satisfy all declared inter-library\"\n\t    $ECHO \"*** dependencies of module $libname.  Therefore, libtool will create\"\n\t    echo \"*** a static module, that should work as long as the dlopening\"\n\t    echo \"*** application is linked with the -dlopen flag.\"\n\t    if test -z \"$global_symbol_pipe\"; then\n\t      echo\n\t      echo \"*** However, this would only work if libtool was able to extract symbol\"\n\t      echo \"*** lists from a program, using 'nm' or equivalent, but libtool could\"\n\t      echo \"*** not find such a program.  So, this module is probably useless.\"\n\t      echo \"*** 'nm' from GNU binutils and a full rebuild may help.\"\n\t    fi\n\t    if test no = \"$build_old_libs\"; then\n\t      oldlibs=$output_objdir/$libname.$libext\n\t      build_libtool_libs=module\n\t      build_old_libs=yes\n\t    else\n\t      build_libtool_libs=no\n\t    fi\n\t  else\n\t    echo \"*** The inter-library dependencies that have been dropped here will be\"\n\t    echo \"*** automatically added whenever a program is linked with this library\"\n\t    echo \"*** or is declared to -dlopen it.\"\n\n\t    if test no = \"$allow_undefined\"; then\n\t      echo\n\t      echo \"*** Since this library must not contain undefined symbols,\"\n\t      echo \"*** because either the platform does not support them or\"\n\t      echo \"*** it was explicitly requested with -no-undefined,\"\n\t      echo \"*** libtool will only create a static version of it.\"\n\t      if test no = \"$build_old_libs\"; then\n\t\toldlibs=$output_objdir/$libname.$libext\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  fi\n\tfi\n\t# Done checking deplibs!\n\tdeplibs=$newdeplibs\n      fi\n      # Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n      case $host in\n\t*-*-darwin*)\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  new_inherited_linker_flags=`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  deplibs=`$ECHO \" $deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  ;;\n      esac\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    func_append new_libs \" -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) func_append new_libs \" $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) func_append new_libs \" $deplib\" ;;\n\tesac\n      done\n      deplibs=$new_libs\n\n      # All the library-specific variables (install_libdir is set above).\n      library_names=\n      old_library=\n      dlname=\n\n      # Test again, we may have decided not to build it any more\n      if test yes = \"$build_libtool_libs\"; then\n\t# Remove $wl instances when linking with ld.\n\t# FIXME: should test the right _cmds variable.\n\tcase $archive_cmds in\n\t  *\\$LD\\ *) wl= ;;\n        esac\n\tif test yes = \"$hardcode_into_libs\"; then\n\t  # Hardcode the library paths\n\t  hardcode_libdirs=\n\t  dep_rpath=\n\t  rpath=$finalize_rpath\n\t  test relink = \"$opt_mode\" || rpath=$compile_rpath$rpath\n\t  for libdir in $rpath; do\n\t    if test -n \"$hardcode_libdir_flag_spec\"; then\n\t      if test -n \"$hardcode_libdir_separator\"; then\n\t\tfunc_replace_sysroot \"$libdir\"\n\t\tlibdir=$func_replace_sysroot_result\n\t\tif test -z \"$hardcode_libdirs\"; then\n\t\t  hardcode_libdirs=$libdir\n\t\telse\n\t\t  # Just accumulate the unique libdirs.\n\t\t  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t\t  *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t    ;;\n\t\t  *)\n\t\t    func_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t      else\n\t\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t\tfunc_append dep_rpath \" $flag\"\n\t      fi\n\t    elif test -n \"$runpath_var\"; then\n\t      case \"$perm_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append perm_rpath \" $libdir\" ;;\n\t      esac\n\t    fi\n\t  done\n\t  # Substitute the hardcoded libdirs into the rpath.\n\t  if test -n \"$hardcode_libdir_separator\" &&\n\t     test -n \"$hardcode_libdirs\"; then\n\t    libdir=$hardcode_libdirs\n\t    eval \"dep_rpath=\\\"$hardcode_libdir_flag_spec\\\"\"\n\t  fi\n\t  if test -n \"$runpath_var\" && test -n \"$perm_rpath\"; then\n\t    # We should set the runpath_var.\n\t    rpath=\n\t    for dir in $perm_rpath; do\n\t      func_append rpath \"$dir:\"\n\t    done\n\t    eval \"$runpath_var='$rpath\\$$runpath_var'; export $runpath_var\"\n\t  fi\n\t  test -n \"$dep_rpath\" && deplibs=\"$dep_rpath $deplibs\"\n\tfi\n\n\tshlibpath=$finalize_shlibpath\n\ttest relink = \"$opt_mode\" || shlibpath=$compile_shlibpath$shlibpath\n\tif test -n \"$shlibpath\"; then\n\t  eval \"$shlibpath_var='$shlibpath\\$$shlibpath_var'; export $shlibpath_var\"\n\tfi\n\n\t# Get the real and link names of the library.\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval library_names=\\\"$library_names_spec\\\"\n\tset dummy $library_names\n\tshift\n\trealname=$1\n\tshift\n\n\tif test -n \"$soname_spec\"; then\n\t  eval soname=\\\"$soname_spec\\\"\n\telse\n\t  soname=$realname\n\tfi\n\tif test -z \"$dlname\"; then\n\t  dlname=$soname\n\tfi\n\n\tlib=$output_objdir/$realname\n\tlinknames=\n\tfor link\n\tdo\n\t  func_append linknames \" $link\"\n\tdone\n\n\t# Use standard objects if they are pic\n\ttest -z \"$pic_flag\" && libobjs=`$ECHO \"$libobjs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\ttest \"X$libobjs\" = \"X \" && libobjs=\n\n\tdelfiles=\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  $opt_dry_run || cp \"$export_symbols\" \"$output_objdir/$libname.uexp\"\n\t  export_symbols=$output_objdir/$libname.uexp\n\t  func_append delfiles \" $export_symbols\"\n\tfi\n\n\torig_export_symbols=\n\tcase $host_os in\n\tcygwin* | mingw* | cegcc*)\n\t  if test -n \"$export_symbols\" && test -z \"$export_symbols_regex\"; then\n\t    # exporting using user supplied symfile\n\t    func_dll_def_p \"$export_symbols\" || {\n\t      # and it's NOT already a .def file. Must figure out\n\t      # which of the given symbols are data symbols and tag\n\t      # them as such. So, trigger use of export_symbols_cmds.\n\t      # export_symbols gets reassigned inside the \"prepare\n\t      # the list of exported symbols\" if statement, so the\n\t      # include_expsyms logic still works.\n\t      orig_export_symbols=$export_symbols\n\t      export_symbols=\n\t      always_export_symbols=yes\n\t    }\n\t  fi\n\t  ;;\n\tesac\n\n\t# Prepare the list of exported symbols\n\tif test -z \"$export_symbols\"; then\n\t  if test yes = \"$always_export_symbols\" || test -n \"$export_symbols_regex\"; then\n\t    func_verbose \"generating symbol list for '$libname.la'\"\n\t    export_symbols=$output_objdir/$libname.exp\n\t    $opt_dry_run || $RM $export_symbols\n\t    cmds=$export_symbols_cmds\n\t    save_ifs=$IFS; IFS='~'\n\t    for cmd1 in $cmds; do\n\t      IFS=$save_ifs\n\t      # Take the normal branch if the nm_file_list_spec branch\n\t      # doesn't work or if tool conversion is not needed.\n\t      case $nm_file_list_spec~$to_tool_file_cmd in\n\t\t*~func_convert_file_noop | *~func_convert_file_msys_to_w32 | ~*)\n\t\t  try_normal_branch=yes\n\t\t  eval cmd=\\\"$cmd1\\\"\n\t\t  func_len \" $cmd\"\n\t\t  len=$func_len_result\n\t\t  ;;\n\t\t*)\n\t\t  try_normal_branch=no\n\t\t  ;;\n\t      esac\n\t      if test yes = \"$try_normal_branch\" \\\n\t\t && { test \"$len\" -lt \"$max_cmd_len\" \\\n\t\t      || test \"$max_cmd_len\" -le -1; }\n\t      then\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\tskipped_export=false\n\t      elif test -n \"$nm_file_list_spec\"; then\n\t\tfunc_basename \"$output\"\n\t\toutput_la=$func_basename_result\n\t\tsave_libobjs=$libobjs\n\t\tsave_output=$output\n\t\toutput=$output_objdir/$output_la.nm\n\t\tfunc_to_tool_file \"$output\"\n\t\tlibobjs=$nm_file_list_spec$func_to_tool_file_result\n\t\tfunc_append delfiles \" $output\"\n\t\tfunc_verbose \"creating $NM input file list: $output\"\n\t\tfor obj in $save_libobjs; do\n\t\t  func_to_tool_file \"$obj\"\n\t\t  $ECHO \"$func_to_tool_file_result\"\n\t\tdone > \"$output\"\n\t\teval cmd=\\\"$cmd1\\\"\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\toutput=$save_output\n\t\tlibobjs=$save_libobjs\n\t\tskipped_export=false\n\t      else\n\t\t# The command line is too long to execute in one step.\n\t\tfunc_verbose \"using reloadable object file for export list...\"\n\t\tskipped_export=:\n\t\t# Break out early, otherwise skipped_export may be\n\t\t# set to false by a later but shorter cmd.\n\t\tbreak\n\t      fi\n\t    done\n\t    IFS=$save_ifs\n\t    if test -n \"$export_symbols_regex\" && test : != \"$skipped_export\"; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  tmp_export_symbols=$export_symbols\n\t  test -n \"$orig_export_symbols\" && tmp_export_symbols=$orig_export_symbols\n\t  $opt_dry_run || eval '$ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"'\n\tfi\n\n\tif test : != \"$skipped_export\" && test -n \"$orig_export_symbols\"; then\n\t  # The given exports_symbols file has to be filtered, so filter it.\n\t  func_verbose \"filter symbol list for '$libname.la' to tag DATA exports\"\n\t  # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t  # 's' commands, which not all seds can handle. GNU sed should be fine\n\t  # though. Also, the filter scales superlinearly with the number of\n\t  # global variables. join(1) would be nice here, but unfortunately\n\t  # isn't a blessed tool.\n\t  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t  func_append delfiles \" $export_symbols $output_objdir/$libname.filter\"\n\t  export_symbols=$output_objdir/$libname.def\n\t  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\tfi\n\n\ttmp_deplibs=\n\tfor test_deplib in $deplibs; do\n\t  case \" $convenience \" in\n\t  *\" $test_deplib \"*) ;;\n\t  *)\n\t    func_append tmp_deplibs \" $test_deplib\"\n\t    ;;\n\t  esac\n\tdone\n\tdeplibs=$tmp_deplibs\n\n\tif test -n \"$convenience\"; then\n\t  if test -n \"$whole_archive_flag_spec\" &&\n\t    test yes = \"$compiler_needs_object\" &&\n\t    test -z \"$libobjs\"; then\n\t    # extract the archives, so we have objects to list.\n\t    # TODO: could optimize this to just extract one archive.\n\t    whole_archive_flag_spec=\n\t  fi\n\t  if test -n \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  else\n\t    gentop=$output_objdir/${outputname}x\n\t    func_append generated \" $gentop\"\n\n\t    func_extract_archives $gentop $convenience\n\t    func_append libobjs \" $func_extract_archives_result\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\tfi\n\n\tif test yes = \"$thread_safe\" && test -n \"$thread_safe_flag_spec\"; then\n\t  eval flag=\\\"$thread_safe_flag_spec\\\"\n\t  func_append linker_flags \" $flag\"\n\tfi\n\n\t# Make a backup of the uninstalled library when relinking\n\tif test relink = \"$opt_mode\"; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?\n\tfi\n\n\t# Do each of the archive commands.\n\tif test yes = \"$module\" && test -n \"$module_cmds\"; then\n\t  if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$module_expsym_cmds\\\"\n\t    cmds=$module_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$module_cmds\\\"\n\t    cmds=$module_cmds\n\t  fi\n\telse\n\t  if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$archive_expsym_cmds\\\"\n\t    cmds=$archive_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$archive_cmds\\\"\n\t    cmds=$archive_cmds\n\t  fi\n\tfi\n\n\tif test : != \"$skipped_export\" &&\n\t   func_len \" $test_cmds\" &&\n\t   len=$func_len_result &&\n\t   test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  :\n\telse\n\t  # The command line is too long to link in one step, link piecewise\n\t  # or, if using GNU ld and skipped_export is not :, use a linker\n\t  # script.\n\n\t  # Save the value of $output and $libobjs because we want to\n\t  # use them later.  If we have whole_archive_flag_spec, we\n\t  # want to use save_libobjs as it was before\n\t  # whole_archive_flag_spec was expanded, because we can't\n\t  # assume the linker understands whole_archive_flag_spec.\n\t  # This may have to be revisited, in case too many\n\t  # convenience libraries get linked in and end up exceeding\n\t  # the spec.\n\t  if test -z \"$convenience\" || test -z \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t  fi\n\t  save_output=$output\n\t  func_basename \"$output\"\n\t  output_la=$func_basename_result\n\n\t  # Clear the reloadable object creation command queue and\n\t  # initialize k to one.\n\t  test_cmds=\n\t  concat_cmds=\n\t  objlist=\n\t  last_robj=\n\t  k=1\n\n\t  if test -n \"$save_libobjs\" && test : != \"$skipped_export\" && test yes = \"$with_gnu_ld\"; then\n\t    output=$output_objdir/$output_la.lnkscript\n\t    func_verbose \"creating GNU ld script: $output\"\n\t    echo 'INPUT (' > $output\n\t    for obj in $save_libobjs\n\t    do\n\t      func_to_tool_file \"$obj\"\n\t      $ECHO \"$func_to_tool_file_result\" >> $output\n\t    done\n\t    echo ')' >> $output\n\t    func_append delfiles \" $output\"\n\t    func_to_tool_file \"$output\"\n\t    output=$func_to_tool_file_result\n\t  elif test -n \"$save_libobjs\" && test : != \"$skipped_export\" && test -n \"$file_list_spec\"; then\n\t    output=$output_objdir/$output_la.lnk\n\t    func_verbose \"creating linker input file list: $output\"\n\t    : > $output\n\t    set x $save_libobjs\n\t    shift\n\t    firstobj=\n\t    if test yes = \"$compiler_needs_object\"; then\n\t      firstobj=\"$1 \"\n\t      shift\n\t    fi\n\t    for obj\n\t    do\n\t      func_to_tool_file \"$obj\"\n\t      $ECHO \"$func_to_tool_file_result\" >> $output\n\t    done\n\t    func_append delfiles \" $output\"\n\t    func_to_tool_file \"$output\"\n\t    output=$firstobj\\\"$file_list_spec$func_to_tool_file_result\\\"\n\t  else\n\t    if test -n \"$save_libobjs\"; then\n\t      func_verbose \"creating reloadable object files...\"\n\t      output=$output_objdir/$output_la-$k.$objext\n\t      eval test_cmds=\\\"$reload_cmds\\\"\n\t      func_len \" $test_cmds\"\n\t      len0=$func_len_result\n\t      len=$len0\n\n\t      # Loop over the list of objects to be linked.\n\t      for obj in $save_libobjs\n\t      do\n\t\tfunc_len \" $obj\"\n\t\tfunc_arith $len + $func_len_result\n\t\tlen=$func_arith_result\n\t\tif test -z \"$objlist\" ||\n\t\t   test \"$len\" -lt \"$max_cmd_len\"; then\n\t\t  func_append objlist \" $obj\"\n\t\telse\n\t\t  # The command $test_cmds is almost too long, add a\n\t\t  # command to the queue.\n\t\t  if test 1 -eq \"$k\"; then\n\t\t    # The first file doesn't have a previous command to add.\n\t\t    reload_objs=$objlist\n\t\t    eval concat_cmds=\\\"$reload_cmds\\\"\n\t\t  else\n\t\t    # All subsequent reloadable object files will link in\n\t\t    # the last one created.\n\t\t    reload_objs=\"$objlist $last_robj\"\n\t\t    eval concat_cmds=\\\"\\$concat_cmds~$reload_cmds~\\$RM $last_robj\\\"\n\t\t  fi\n\t\t  last_robj=$output_objdir/$output_la-$k.$objext\n\t\t  func_arith $k + 1\n\t\t  k=$func_arith_result\n\t\t  output=$output_objdir/$output_la-$k.$objext\n\t\t  objlist=\" $obj\"\n\t\t  func_len \" $last_robj\"\n\t\t  func_arith $len0 + $func_len_result\n\t\t  len=$func_arith_result\n\t\tfi\n\t      done\n\t      # Handle the remaining objects by creating one last\n\t      # reloadable object file.  All subsequent reloadable object\n\t      # files will link in the last one created.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      reload_objs=\"$objlist $last_robj\"\n\t      eval concat_cmds=\\\"\\$concat_cmds$reload_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t        eval concat_cmds=\\\"\\$concat_cmds~\\$RM $last_robj\\\"\n\t      fi\n\t      func_append delfiles \" $output\"\n\n\t    else\n\t      output=\n\t    fi\n\n\t    ${skipped_export-false} && {\n\t      func_verbose \"generating symbol list for '$libname.la'\"\n\t      export_symbols=$output_objdir/$libname.exp\n\t      $opt_dry_run || $RM $export_symbols\n\t      libobjs=$output\n\t      # Append the command to create the export file.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\$concat_cmds$export_symbols_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t\teval concat_cmds=\\\"\\$concat_cmds~\\$RM $last_robj\\\"\n\t      fi\n\t    }\n\n\t    test -n \"$save_libobjs\" &&\n\t      func_verbose \"creating a temporary reloadable object file: $output\"\n\n\t    # Loop through the commands generated above and execute them.\n\t    save_ifs=$IFS; IFS='~'\n\t    for cmd in $concat_cmds; do\n\t      IFS=$save_ifs\n\t      $opt_quiet || {\n\t\t  func_quote_for_expand \"$cmd\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t      }\n\t      $opt_dry_run || eval \"$cmd\" || {\n\t\tlt_exit=$?\n\n\t\t# Restore the uninstalled library and exit\n\t\tif test relink = \"$opt_mode\"; then\n\t\t  ( cd \"$output_objdir\" && \\\n\t\t    $RM \"${realname}T\" && \\\n\t\t    $MV \"${realname}U\" \"$realname\" )\n\t\tfi\n\n\t\texit $lt_exit\n\t      }\n\t    done\n\t    IFS=$save_ifs\n\n\t    if test -n \"$export_symbols_regex\" && ${skipped_export-false}; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\n          ${skipped_export-false} && {\n\t    if test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t      tmp_export_symbols=$export_symbols\n\t      test -n \"$orig_export_symbols\" && tmp_export_symbols=$orig_export_symbols\n\t      $opt_dry_run || eval '$ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"'\n\t    fi\n\n\t    if test -n \"$orig_export_symbols\"; then\n\t      # The given exports_symbols file has to be filtered, so filter it.\n\t      func_verbose \"filter symbol list for '$libname.la' to tag DATA exports\"\n\t      # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t      # 's' commands, which not all seds can handle. GNU sed should be fine\n\t      # though. Also, the filter scales superlinearly with the number of\n\t      # global variables. join(1) would be nice here, but unfortunately\n\t      # isn't a blessed tool.\n\t      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t      func_append delfiles \" $export_symbols $output_objdir/$libname.filter\"\n\t      export_symbols=$output_objdir/$libname.def\n\t      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\t    fi\n\t  }\n\n\t  libobjs=$output\n\t  # Restore the value of output.\n\t  output=$save_output\n\n\t  if test -n \"$convenience\" && test -n \"$whole_archive_flag_spec\"; then\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\t  # Expand the library linking commands again to reset the\n\t  # value of $libobjs for piecewise linking.\n\n\t  # Do each of the archive commands.\n\t  if test yes = \"$module\" && test -n \"$module_cmds\"; then\n\t    if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t      cmds=$module_expsym_cmds\n\t    else\n\t      cmds=$module_cmds\n\t    fi\n\t  else\n\t    if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t      cmds=$archive_expsym_cmds\n\t    else\n\t      cmds=$archive_cmds\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$delfiles\"; then\n\t  # Append the command to remove temporary files to $cmds.\n\t  eval cmds=\\\"\\$cmds~\\$RM $delfiles\\\"\n\tfi\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=$output_objdir/${outputname}x\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  func_append libobjs \" $func_extract_archives_result\"\n\t  test \"X$libobjs\" = \"X \" && libobjs=\n\tfi\n\n\tsave_ifs=$IFS; IFS='~'\n\tfor cmd in $cmds; do\n\t  IFS=$sp$nl\n\t  eval cmd=\\\"$cmd\\\"\n\t  IFS=$save_ifs\n\t  $opt_quiet || {\n\t    func_quote_for_expand \"$cmd\"\n\t    eval \"func_echo $func_quote_for_expand_result\"\n\t  }\n\t  $opt_dry_run || eval \"$cmd\" || {\n\t    lt_exit=$?\n\n\t    # Restore the uninstalled library and exit\n\t    if test relink = \"$opt_mode\"; then\n\t      ( cd \"$output_objdir\" && \\\n\t        $RM \"${realname}T\" && \\\n\t\t$MV \"${realname}U\" \"$realname\" )\n\t    fi\n\n\t    exit $lt_exit\n\t  }\n\tdone\n\tIFS=$save_ifs\n\n\t# Restore the uninstalled library and exit\n\tif test relink = \"$opt_mode\"; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?\n\n\t  if test -n \"$convenience\"; then\n\t    if test -z \"$whole_archive_flag_spec\"; then\n\t      func_show_eval '${RM}r \"$gentop\"'\n\t    fi\n\t  fi\n\n\t  exit $EXIT_SUCCESS\n\tfi\n\n\t# Create links to the real library.\n\tfor linkname in $linknames; do\n\t  if test \"$realname\" != \"$linkname\"; then\n\t    func_show_eval '(cd \"$output_objdir\" && $RM \"$linkname\" && $LN_S \"$realname\" \"$linkname\")' 'exit $?'\n\t  fi\n\tdone\n\n\t# If -module or -export-dynamic was specified, set the dlname.\n\tif test yes = \"$module\" || test yes = \"$export_dynamic\"; then\n\t  # On all known operating systems, these are identical.\n\t  dlname=$soname\n\tfi\n      fi\n      ;;\n\n    obj)\n      if test -n \"$dlfiles$dlprefiles\" || test no != \"$dlself\"; then\n\tfunc_warning \"'-dlopen' is ignored for objects\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"'-l' and '-L' are ignored for objects\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"'-rpath' is ignored for objects\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"'-R' is ignored for objects\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"'-version-info' is ignored for objects\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"'-release' is ignored for objects\"\n\n      case $output in\n      *.lo)\n\ttest -n \"$objs$old_deplibs\" && \\\n\t  func_fatal_error \"cannot build library object '$output' from non-libtool objects\"\n\n\tlibobj=$output\n\tfunc_lo2o \"$libobj\"\n\tobj=$func_lo2o_result\n\t;;\n      *)\n\tlibobj=\n\tobj=$output\n\t;;\n      esac\n\n      # Delete the old objects.\n      $opt_dry_run || $RM $obj $libobj\n\n      # Objects from convenience libraries.  This assumes\n      # single-version convenience libraries.  Whenever we create\n      # different ones for PIC/non-PIC, this we'll have to duplicate\n      # the extraction.\n      reload_conv_objs=\n      gentop=\n      # if reload_cmds runs $LD directly, get rid of -Wl from\n      # whole_archive_flag_spec and hope we can get by with turning comma\n      # into space.\n      case $reload_cmds in\n        *\\$LD[\\ \\$]*) wl= ;;\n      esac\n      if test -n \"$convenience\"; then\n\tif test -n \"$whole_archive_flag_spec\"; then\n\t  eval tmp_whole_archive_flags=\\\"$whole_archive_flag_spec\\\"\n\t  test -n \"$wl\" || tmp_whole_archive_flags=`$ECHO \"$tmp_whole_archive_flags\" | $SED 's|,| |g'`\n\t  reload_conv_objs=$reload_objs\\ $tmp_whole_archive_flags\n\telse\n\t  gentop=$output_objdir/${obj}x\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $convenience\n\t  reload_conv_objs=\"$reload_objs $func_extract_archives_result\"\n\tfi\n      fi\n\n      # If we're not building shared, we need to use non_pic_objs\n      test yes = \"$build_libtool_libs\" || libobjs=$non_pic_objects\n\n      # Create the old-style object.\n      reload_objs=$objs$old_deplibs' '`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.$libext$/d; /\\.lib$/d; $lo2o\" | $NL2SP`' '$reload_conv_objs\n\n      output=$obj\n      func_execute_cmds \"$reload_cmds\" 'exit $?'\n\n      # Exit if we aren't doing a library object file.\n      if test -z \"$libobj\"; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      test yes = \"$build_libtool_libs\" || {\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\t# Create an invalid libtool object if no PIC, so that we don't\n\t# accidentally link it into a program.\n\t# $show \"echo timestamp > $libobj\"\n\t# $opt_dry_run || eval \"echo timestamp > $libobj\" || exit $?\n\texit $EXIT_SUCCESS\n      }\n\n      if test -n \"$pic_flag\" || test default != \"$pic_mode\"; then\n\t# Only do commands if we really have different PIC objects.\n\treload_objs=\"$libobjs $reload_conv_objs\"\n\toutput=$libobj\n\tfunc_execute_cmds \"$reload_cmds\" 'exit $?'\n      fi\n\n      if test -n \"$gentop\"; then\n\tfunc_show_eval '${RM}r \"$gentop\"'\n      fi\n\n      exit $EXIT_SUCCESS\n      ;;\n\n    prog)\n      case $host in\n\t*cygwin*) func_stripname '' '.exe' \"$output\"\n\t          output=$func_stripname_result.exe;;\n      esac\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"'-version-info' is ignored for programs\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"'-release' is ignored for programs\"\n\n      $preload \\\n\t&& test unknown,unknown,unknown = \"$dlopen_support,$dlopen_self,$dlopen_self_static\" \\\n\t&& func_warning \"'LT_INIT([dlopen])' not used. Assuming no dlopen support.\"\n\n      case $host in\n      *-*-rhapsody* | *-*-darwin1.[012])\n\t# On Rhapsody replace the C library is the System framework\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t;;\n      esac\n\n      case $host in\n      *-*-darwin*)\n\t# Don't allow lazy linking, it breaks C++ global constructors\n\t# But is supposedly fixed on 10.4 or later (yay!).\n\tif test CXX = \"$tagname\"; then\n\t  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in\n\t    10.[0123])\n\t      func_append compile_command \" $wl-bind_at_load\"\n\t      func_append finalize_command \" $wl-bind_at_load\"\n\t    ;;\n\t  esac\n\tfi\n\t# Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t;;\n      esac\n\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $compile_deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    func_append new_libs \" -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $compile_deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) func_append new_libs \" $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) func_append new_libs \" $deplib\" ;;\n\tesac\n      done\n      compile_deplibs=$new_libs\n\n\n      func_append compile_command \" $compile_deplibs\"\n      func_append finalize_command \" $finalize_deplibs\"\n\n      if test -n \"$rpath$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\tfor libdir in $rpath $xrpath; do\n\t  # This is the magic to use -rpath.\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_rpath \" $libdir\" ;;\n\t  esac\n\tdone\n      fi\n\n      # Now hardcode the library paths\n      rpath=\n      hardcode_libdirs=\n      for libdir in $compile_rpath $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=$libdir\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\tfunc_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    func_append rpath \" $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append perm_rpath \" $libdir\" ;;\n\t  esac\n\tfi\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`$ECHO \"$libdir\" | $SED -e 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$libdir:\"*) ;;\n\t  ::) dllsearchpath=$libdir;;\n\t  *) func_append dllsearchpath \":$libdir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) func_append dllsearchpath \":$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=$hardcode_libdirs\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      compile_rpath=$rpath\n\n      rpath=\n      hardcode_libdirs=\n      for libdir in $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=$libdir\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\tfunc_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    func_append rpath \" $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$finalize_perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_perm_rpath \" $libdir\" ;;\n\t  esac\n\tfi\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=$hardcode_libdirs\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      finalize_rpath=$rpath\n\n      if test -n \"$libobjs\" && test yes = \"$build_old_libs\"; then\n\t# Transform all the library objects into standard objects.\n\tcompile_command=`$ECHO \"$compile_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\tfinalize_command=`$ECHO \"$finalize_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n      fi\n\n      func_generate_dlsyms \"$outputname\" \"@PROGRAM@\" false\n\n      # template prelinking step\n      if test -n \"$prelink_cmds\"; then\n\tfunc_execute_cmds \"$prelink_cmds\" 'exit $?'\n      fi\n\n      wrappers_required=:\n      case $host in\n      *cegcc* | *mingw32ce*)\n        # Disable wrappers for cegcc and mingw32ce hosts, we are cross compiling anyway.\n        wrappers_required=false\n        ;;\n      *cygwin* | *mingw* )\n        test yes = \"$build_libtool_libs\" || wrappers_required=false\n        ;;\n      *)\n        if test no = \"$need_relink\" || test yes != \"$build_libtool_libs\"; then\n          wrappers_required=false\n        fi\n        ;;\n      esac\n      $wrappers_required || {\n\t# Replace the output file specification.\n\tcompile_command=`$ECHO \"$compile_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\tlink_command=$compile_command$compile_rpath\n\n\t# We have no uninstalled library dependencies, so finalize right now.\n\texit_status=0\n\tfunc_show_eval \"$link_command\" 'exit_status=$?'\n\n\tif test -n \"$postlink_cmds\"; then\n\t  func_to_tool_file \"$output\"\n\t  postlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\t  func_execute_cmds \"$postlink_cmds\" 'exit $?'\n\tfi\n\n\t# Delete the generated files.\n\tif test -f \"$output_objdir/${outputname}S.$objext\"; then\n\t  func_show_eval '$RM \"$output_objdir/${outputname}S.$objext\"'\n\tfi\n\n\texit $exit_status\n      }\n\n      if test -n \"$compile_shlibpath$finalize_shlibpath\"; then\n\tcompile_command=\"$shlibpath_var=\\\"$compile_shlibpath$finalize_shlibpath\\$$shlibpath_var\\\" $compile_command\"\n      fi\n      if test -n \"$finalize_shlibpath\"; then\n\tfinalize_command=\"$shlibpath_var=\\\"$finalize_shlibpath\\$$shlibpath_var\\\" $finalize_command\"\n      fi\n\n      compile_var=\n      finalize_var=\n      if test -n \"$runpath_var\"; then\n\tif test -n \"$perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $perm_rpath; do\n\t    func_append rpath \"$dir:\"\n\t  done\n\t  compile_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n\tif test -n \"$finalize_perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $finalize_perm_rpath; do\n\t    func_append rpath \"$dir:\"\n\t  done\n\t  finalize_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n      fi\n\n      if test yes = \"$no_install\"; then\n\t# We don't need to create a wrapper script.\n\tlink_command=$compile_var$compile_command$compile_rpath\n\t# Replace the output file specification.\n\tlink_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\t# Delete the old output file.\n\t$opt_dry_run || $RM $output\n\t# Link the executable and exit\n\tfunc_show_eval \"$link_command\" 'exit $?'\n\n\tif test -n \"$postlink_cmds\"; then\n\t  func_to_tool_file \"$output\"\n\t  postlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\t  func_execute_cmds \"$postlink_cmds\" 'exit $?'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      case $hardcode_action,$fast_install in\n        relink,*)\n\t  # Fast installation is not supported\n\t  link_command=$compile_var$compile_command$compile_rpath\n\t  relink_command=$finalize_var$finalize_command$finalize_rpath\n\n\t  func_warning \"this platform does not like uninstalled shared libraries\"\n\t  func_warning \"'$output' will be relinked during installation\"\n\t  ;;\n        *,yes)\n\t  link_command=$finalize_var$compile_command$finalize_rpath\n\t  relink_command=`$ECHO \"$compile_var$compile_command$compile_rpath\" | $SED 's%@OUTPUT@%\\$progdir/\\$file%g'`\n          ;;\n\t*,no)\n\t  link_command=$compile_var$compile_command$compile_rpath\n\t  relink_command=$finalize_var$finalize_command$finalize_rpath\n          ;;\n\t*,needless)\n\t  link_command=$finalize_var$compile_command$finalize_rpath\n\t  relink_command=\n          ;;\n      esac\n\n      # Replace the output file specification.\n      link_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g'`\n\n      # Delete the old output files.\n      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname\n\n      func_show_eval \"$link_command\" 'exit $?'\n\n      if test -n \"$postlink_cmds\"; then\n\tfunc_to_tool_file \"$output_objdir/$outputname\"\n\tpostlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\tfunc_execute_cmds \"$postlink_cmds\" 'exit $?'\n      fi\n\n      # Now create the wrapper script.\n      func_verbose \"creating $output\"\n\n      # Quote the relink command for shipping.\n      if test -n \"$relink_command\"; then\n\t# Preserve any variables that may affect compiler behavior\n\tfor var in $variables_saved_for_relink; do\n\t  if eval test -z \\\"\\${$var+set}\\\"; then\n\t    relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\t  elif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t    relink_command=\"$var=; export $var; $relink_command\"\n\t  else\n\t    func_quote_for_eval \"$var_value\"\n\t    relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\t  fi\n\tdone\n\trelink_command=\"(cd `pwd`; $relink_command)\"\n\trelink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      fi\n\n      # Only actually do things if not in dry run mode.\n      $opt_dry_run || {\n\t# win32 will think the script is a binary if it has\n\t# a .exe suffix, so we strip it off here.\n\tcase $output in\n\t  *.exe) func_stripname '' '.exe' \"$output\"\n\t         output=$func_stripname_result ;;\n\tesac\n\t# test for cygwin because mv fails w/o .exe extensions\n\tcase $host in\n\t  *cygwin*)\n\t    exeext=.exe\n\t    func_stripname '' '.exe' \"$outputname\"\n\t    outputname=$func_stripname_result ;;\n\t  *) exeext= ;;\n\tesac\n\tcase $host in\n\t  *cygwin* | *mingw* )\n\t    func_dirname_and_basename \"$output\" \"\" \".\"\n\t    output_name=$func_basename_result\n\t    output_path=$func_dirname_result\n\t    cwrappersource=$output_path/$objdir/lt-$output_name.c\n\t    cwrapper=$output_path/$output_name.exe\n\t    $RM $cwrappersource $cwrapper\n\t    trap \"$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_cwrapperexe_src > $cwrappersource\n\n\t    # The wrapper executable is built using the $host compiler,\n\t    # because it contains $host paths and files. If cross-\n\t    # compiling, it, like the target executable, must be\n\t    # executed on the $host or under an emulation environment.\n\t    $opt_dry_run || {\n\t      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource\n\t      $STRIP $cwrapper\n\t    }\n\n\t    # Now, create the wrapper script for func_source use:\n\t    func_ltwrapper_scriptname $cwrapper\n\t    $RM $func_ltwrapper_scriptname_result\n\t    trap \"$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE\" 1 2 15\n\t    $opt_dry_run || {\n\t      # note: this script will not be executed, so do not chmod.\n\t      if test \"x$build\" = \"x$host\"; then\n\t\t$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result\n\t      else\n\t\tfunc_emit_wrapper no > $func_ltwrapper_scriptname_result\n\t      fi\n\t    }\n\t  ;;\n\t  * )\n\t    $RM $output\n\t    trap \"$RM $output; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_wrapper no > $output\n\t    chmod +x $output\n\t  ;;\n\tesac\n      }\n      exit $EXIT_SUCCESS\n      ;;\n    esac\n\n    # See if we need to build an old-fashioned archive.\n    for oldlib in $oldlibs; do\n\n      case $build_libtool_libs in\n        convenience)\n\t  oldobjs=\"$libobjs_save $symfileobj\"\n\t  addlibs=$convenience\n\t  build_libtool_libs=no\n\t  ;;\n\tmodule)\n\t  oldobjs=$libobjs_save\n\t  addlibs=$old_convenience\n\t  build_libtool_libs=no\n          ;;\n\t*)\n\t  oldobjs=\"$old_deplibs $non_pic_objects\"\n\t  $preload && test -f \"$symfileobj\" \\\n\t    && func_append oldobjs \" $symfileobj\"\n\t  addlibs=$old_convenience\n\t  ;;\n      esac\n\n      if test -n \"$addlibs\"; then\n\tgentop=$output_objdir/${outputname}x\n\tfunc_append generated \" $gentop\"\n\n\tfunc_extract_archives $gentop $addlibs\n\tfunc_append oldobjs \" $func_extract_archives_result\"\n      fi\n\n      # Do each command in the archive commands.\n      if test -n \"$old_archive_from_new_cmds\" && test yes = \"$build_libtool_libs\"; then\n\tcmds=$old_archive_from_new_cmds\n      else\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=$output_objdir/${outputname}x\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  func_append oldobjs \" $func_extract_archives_result\"\n\tfi\n\n\t# POSIX demands no paths to be encoded in archives.  We have\n\t# to avoid creating archives with duplicate basenames if we\n\t# might have to extract them afterwards, e.g., when creating a\n\t# static archive out of a convenience library, or when linking\n\t# the entirety of a libtool archive into another (currently\n\t# not supported by libtool).\n\tif (for obj in $oldobjs\n\t    do\n\t      func_basename \"$obj\"\n\t      $ECHO \"$func_basename_result\"\n\t    done | sort | sort -uc >/dev/null 2>&1); then\n\t  :\n\telse\n\t  echo \"copying selected object files to avoid basename conflicts...\"\n\t  gentop=$output_objdir/${outputname}x\n\t  func_append generated \" $gentop\"\n\t  func_mkdir_p \"$gentop\"\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  counter=1\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_basename \"$obj\"\n\t    objbase=$func_basename_result\n\t    case \" $oldobjs \" in\n\t    \" \") oldobjs=$obj ;;\n\t    *[\\ /]\"$objbase \"*)\n\t      while :; do\n\t\t# Make sure we don't pick an alternate name that also\n\t\t# overlaps.\n\t\tnewobj=lt$counter-$objbase\n\t\tfunc_arith $counter + 1\n\t\tcounter=$func_arith_result\n\t\tcase \" $oldobjs \" in\n\t\t*[\\ /]\"$newobj \"*) ;;\n\t\t*) if test ! -f \"$gentop/$newobj\"; then break; fi ;;\n\t\tesac\n\t      done\n\t      func_show_eval \"ln $obj $gentop/$newobj || cp $obj $gentop/$newobj\"\n\t      func_append oldobjs \" $gentop/$newobj\"\n\t      ;;\n\t    *) func_append oldobjs \" $obj\" ;;\n\t    esac\n\t  done\n\tfi\n\tfunc_to_tool_file \"$oldlib\" func_convert_file_msys_to_w32\n\ttool_oldlib=$func_to_tool_file_result\n\teval cmds=\\\"$old_archive_cmds\\\"\n\n\tfunc_len \" $cmds\"\n\tlen=$func_len_result\n\tif test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  cmds=$old_archive_cmds\n\telif test -n \"$archiver_list_spec\"; then\n\t  func_verbose \"using command file archive linking...\"\n\t  for obj in $oldobjs\n\t  do\n\t    func_to_tool_file \"$obj\"\n\t    $ECHO \"$func_to_tool_file_result\"\n\t  done > $output_objdir/$libname.libcmd\n\t  func_to_tool_file \"$output_objdir/$libname.libcmd\"\n\t  oldobjs=\" $archiver_list_spec$func_to_tool_file_result\"\n\t  cmds=$old_archive_cmds\n\telse\n\t  # the command line is too long to link in one step, link in parts\n\t  func_verbose \"using piecewise archive linking...\"\n\t  save_RANLIB=$RANLIB\n\t  RANLIB=:\n\t  objlist=\n\t  concat_cmds=\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  # Is there a better way of finding the last object in the list?\n\t  for obj in $save_oldobjs\n\t  do\n\t    last_oldobj=$obj\n\t  done\n\t  eval test_cmds=\\\"$old_archive_cmds\\\"\n\t  func_len \" $test_cmds\"\n\t  len0=$func_len_result\n\t  len=$len0\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_len \" $obj\"\n\t    func_arith $len + $func_len_result\n\t    len=$func_arith_result\n\t    func_append objlist \" $obj\"\n\t    if test \"$len\" -lt \"$max_cmd_len\"; then\n\t      :\n\t    else\n\t      # the above command should be used before it gets too long\n\t      oldobjs=$objlist\n\t      if test \"$obj\" = \"$last_oldobj\"; then\n\t\tRANLIB=$save_RANLIB\n\t      fi\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\$concat_cmds$old_archive_cmds\\\"\n\t      objlist=\n\t      len=$len0\n\t    fi\n\t  done\n\t  RANLIB=$save_RANLIB\n\t  oldobjs=$objlist\n\t  if test -z \"$oldobjs\"; then\n\t    eval cmds=\\\"\\$concat_cmds\\\"\n\t  else\n\t    eval cmds=\\\"\\$concat_cmds~\\$old_archive_cmds\\\"\n\t  fi\n\tfi\n      fi\n      func_execute_cmds \"$cmds\" 'exit $?'\n    done\n\n    test -n \"$generated\" && \\\n      func_show_eval \"${RM}r$generated\"\n\n    # Now create the libtool archive.\n    case $output in\n    *.la)\n      old_library=\n      test yes = \"$build_old_libs\" && old_library=$libname.$libext\n      func_verbose \"creating $output\"\n\n      # Preserve any variables that may affect compiler behavior\n      for var in $variables_saved_for_relink; do\n\tif eval test -z \\\"\\${$var+set}\\\"; then\n\t  relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\telif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t  relink_command=\"$var=; export $var; $relink_command\"\n\telse\n\t  func_quote_for_eval \"$var_value\"\n\t  relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\tfi\n      done\n      # Quote the link command for shipping.\n      relink_command=\"(cd `pwd`; $SHELL \\\"$progpath\\\" $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)\"\n      relink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      if test yes = \"$hardcode_automatic\"; then\n\trelink_command=\n      fi\n\n      # Only create the output if not a dry run.\n      $opt_dry_run || {\n\tfor installed in no yes; do\n\t  if test yes = \"$installed\"; then\n\t    if test -z \"$install_libdir\"; then\n\t      break\n\t    fi\n\t    output=$output_objdir/${outputname}i\n\t    # Replace all uninstalled libtool libraries with the installed ones\n\t    newdependency_libs=\n\t    for deplib in $dependency_libs; do\n\t      case $deplib in\n\t      *.la)\n\t\tfunc_basename \"$deplib\"\n\t\tname=$func_basename_result\n\t\tfunc_resolve_sysroot \"$deplib\"\n\t\teval libdir=`$SED -n -e 's/^libdir=\\(.*\\)$/\\1/p' $func_resolve_sysroot_result`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"'$deplib' is not a valid libtool archive\"\n\t\tfunc_append newdependency_libs \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      -L*)\n\t\tfunc_stripname -L '' \"$deplib\"\n\t\tfunc_replace_sysroot \"$func_stripname_result\"\n\t\tfunc_append newdependency_libs \" -L$func_replace_sysroot_result\"\n\t\t;;\n\t      -R*)\n\t\tfunc_stripname -R '' \"$deplib\"\n\t\tfunc_replace_sysroot \"$func_stripname_result\"\n\t\tfunc_append newdependency_libs \" -R$func_replace_sysroot_result\"\n\t\t;;\n\t      *) func_append newdependency_libs \" $deplib\" ;;\n\t      esac\n\t    done\n\t    dependency_libs=$newdependency_libs\n\t    newdlfiles=\n\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t      *.la)\n\t        func_basename \"$lib\"\n\t\tname=$func_basename_result\n\t\teval libdir=`$SED -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"'$lib' is not a valid libtool archive\"\n\t\tfunc_append newdlfiles \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      *) func_append newdlfiles \" $lib\" ;;\n\t      esac\n\t    done\n\t    dlfiles=$newdlfiles\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t      *.la)\n\t\t# Only pass preopened files to the pseudo-archive (for\n\t\t# eventual linking with the app. that links it) if we\n\t\t# didn't already link the preopened objects directly into\n\t\t# the library:\n\t\tfunc_basename \"$lib\"\n\t\tname=$func_basename_result\n\t\teval libdir=`$SED -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"'$lib' is not a valid libtool archive\"\n\t\tfunc_append newdlprefiles \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      esac\n\t    done\n\t    dlprefiles=$newdlprefiles\n\t  else\n\t    newdlfiles=\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=$lib ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      func_append newdlfiles \" $abs\"\n\t    done\n\t    dlfiles=$newdlfiles\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=$lib ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      func_append newdlprefiles \" $abs\"\n\t    done\n\t    dlprefiles=$newdlprefiles\n\t  fi\n\t  $RM $output\n\t  # place dlname in correct position for cygwin\n\t  # In fact, it would be nice if we could use this code for all target\n\t  # systems that can't hard-code library paths into their executables\n\t  # and that have no shared library path variable independent of PATH,\n\t  # but it turns out we can't easily determine that from inspecting\n\t  # libtool variables, so we have to hard-code the OSs to which it\n\t  # applies here; at the moment, that means platforms that use the PE\n\t  # object format with DLL files.  See the long comment at the top of\n\t  # tests/bindir.at for full details.\n\t  tdlname=$dlname\n\t  case $host,$output,$installed,$module,$dlname in\n\t    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll)\n\t      # If a -bindir argument was supplied, place the dll there.\n\t      if test -n \"$bindir\"; then\n\t\tfunc_relative_path \"$install_libdir\" \"$bindir\"\n\t\ttdlname=$func_relative_path_result/$dlname\n\t      else\n\t\t# Otherwise fall back on heuristic.\n\t\ttdlname=../bin/$dlname\n\t      fi\n\t      ;;\n\t  esac\n\t  $ECHO > $output \"\\\n# $outputname - a libtool library file\n# Generated by $PROGRAM (GNU $PACKAGE) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# The name that we can dlopen(3).\ndlname='$tdlname'\n\n# Names of this library.\nlibrary_names='$library_names'\n\n# The name of the static archive.\nold_library='$old_library'\n\n# Linker flags that cannot go in dependency_libs.\ninherited_linker_flags='$new_inherited_linker_flags'\n\n# Libraries that this one depends upon.\ndependency_libs='$dependency_libs'\n\n# Names of additional weak libraries provided by this library\nweak_library_names='$weak_libs'\n\n# Version information for $libname.\ncurrent=$current\nage=$age\nrevision=$revision\n\n# Is this an already installed library?\ninstalled=$installed\n\n# Should we warn about portability when linking against -modules?\nshouldnotlink=$module\n\n# Files to dlopen/dlpreopen\ndlopen='$dlfiles'\ndlpreopen='$dlprefiles'\n\n# Directory that this library needs to be installed in:\nlibdir='$install_libdir'\"\n\t  if test no,yes = \"$installed,$need_relink\"; then\n\t    $ECHO >> $output \"\\\nrelink_command=\\\"$relink_command\\\"\"\n\t  fi\n\tdone\n      }\n\n      # Do a symbolic link so that the libtool archive can be found in\n      # LD_LIBRARY_PATH before the program is installed.\n      func_show_eval '( cd \"$output_objdir\" && $RM \"$outputname\" && $LN_S \"../$outputname\" \"$outputname\" )' 'exit $?'\n      ;;\n    esac\n    exit $EXIT_SUCCESS\n}\n\nif test link = \"$opt_mode\" || test relink = \"$opt_mode\"; then\n  func_mode_link ${1+\"$@\"}\nfi\n\n\n# func_mode_uninstall arg...\nfunc_mode_uninstall ()\n{\n    $debug_cmd\n\n    RM=$nonopt\n    files=\n    rmforce=false\n    exit_status=0\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=$magic\n\n    for arg\n    do\n      case $arg in\n      -f) func_append RM \" $arg\"; rmforce=: ;;\n      -*) func_append RM \" $arg\" ;;\n      *) func_append files \" $arg\" ;;\n      esac\n    done\n\n    test -z \"$RM\" && \\\n      func_fatal_help \"you must specify an RM program\"\n\n    rmdirs=\n\n    for file in $files; do\n      func_dirname \"$file\" \"\" \".\"\n      dir=$func_dirname_result\n      if test . = \"$dir\"; then\n\todir=$objdir\n      else\n\todir=$dir/$objdir\n      fi\n      func_basename \"$file\"\n      name=$func_basename_result\n      test uninstall = \"$opt_mode\" && odir=$dir\n\n      # Remember odir for removal later, being careful to avoid duplicates\n      if test clean = \"$opt_mode\"; then\n\tcase \" $rmdirs \" in\n\t  *\" $odir \"*) ;;\n\t  *) func_append rmdirs \" $odir\" ;;\n\tesac\n      fi\n\n      # Don't error if the file doesn't exist and rm -f was used.\n      if { test -L \"$file\"; } >/dev/null 2>&1 ||\n\t { test -h \"$file\"; } >/dev/null 2>&1 ||\n\t test -f \"$file\"; then\n\t:\n      elif test -d \"$file\"; then\n\texit_status=1\n\tcontinue\n      elif $rmforce; then\n\tcontinue\n      fi\n\n      rmfiles=$file\n\n      case $name in\n      *.la)\n\t# Possibly a libtool archive, so verify it.\n\tif func_lalib_p \"$file\"; then\n\t  func_source $dir/$name\n\n\t  # Delete the libtool libraries and symlinks.\n\t  for n in $library_names; do\n\t    func_append rmfiles \" $odir/$n\"\n\t  done\n\t  test -n \"$old_library\" && func_append rmfiles \" $odir/$old_library\"\n\n\t  case $opt_mode in\n\t  clean)\n\t    case \" $library_names \" in\n\t    *\" $dlname \"*) ;;\n\t    *) test -n \"$dlname\" && func_append rmfiles \" $odir/$dlname\" ;;\n\t    esac\n\t    test -n \"$libdir\" && func_append rmfiles \" $odir/$name $odir/${name}i\"\n\t    ;;\n\t  uninstall)\n\t    if test -n \"$library_names\"; then\n\t      # Do each command in the postuninstall commands.\n\t      func_execute_cmds \"$postuninstall_cmds\" '$rmforce || exit_status=1'\n\t    fi\n\n\t    if test -n \"$old_library\"; then\n\t      # Do each command in the old_postuninstall commands.\n\t      func_execute_cmds \"$old_postuninstall_cmds\" '$rmforce || exit_status=1'\n\t    fi\n\t    # FIXME: should reinstall the best remaining shared library.\n\t    ;;\n\t  esac\n\tfi\n\t;;\n\n      *.lo)\n\t# Possibly a libtool object, so verify it.\n\tif func_lalib_p \"$file\"; then\n\n\t  # Read the .lo file\n\t  func_source $dir/$name\n\n\t  # Add PIC object to the list of files to remove.\n\t  if test -n \"$pic_object\" && test none != \"$pic_object\"; then\n\t    func_append rmfiles \" $dir/$pic_object\"\n\t  fi\n\n\t  # Add non-PIC object to the list of files to remove.\n\t  if test -n \"$non_pic_object\" && test none != \"$non_pic_object\"; then\n\t    func_append rmfiles \" $dir/$non_pic_object\"\n\t  fi\n\tfi\n\t;;\n\n      *)\n\tif test clean = \"$opt_mode\"; then\n\t  noexename=$name\n\t  case $file in\n\t  *.exe)\n\t    func_stripname '' '.exe' \"$file\"\n\t    file=$func_stripname_result\n\t    func_stripname '' '.exe' \"$name\"\n\t    noexename=$func_stripname_result\n\t    # $file with .exe has already been added to rmfiles,\n\t    # add $file without .exe\n\t    func_append rmfiles \" $file\"\n\t    ;;\n\t  esac\n\t  # Do a test to see if this is a libtool program.\n\t  if func_ltwrapper_p \"$file\"; then\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      relink_command=\n\t      func_source $func_ltwrapper_scriptname_result\n\t      func_append rmfiles \" $func_ltwrapper_scriptname_result\"\n\t    else\n\t      relink_command=\n\t      func_source $dir/$noexename\n\t    fi\n\n\t    # note $name still contains .exe if it was in $file originally\n\t    # as does the version of $file that was added into $rmfiles\n\t    func_append rmfiles \" $odir/$name $odir/${name}S.$objext\"\n\t    if test yes = \"$fast_install\" && test -n \"$relink_command\"; then\n\t      func_append rmfiles \" $odir/lt-$name\"\n\t    fi\n\t    if test \"X$noexename\" != \"X$name\"; then\n\t      func_append rmfiles \" $odir/lt-$noexename.c\"\n\t    fi\n\t  fi\n\tfi\n\t;;\n      esac\n      func_show_eval \"$RM $rmfiles\" 'exit_status=1'\n    done\n\n    # Try to remove the $objdir's in the directories where we deleted files\n    for dir in $rmdirs; do\n      if test -d \"$dir\"; then\n\tfunc_show_eval \"rmdir $dir >/dev/null 2>&1\"\n      fi\n    done\n\n    exit $exit_status\n}\n\nif test uninstall = \"$opt_mode\" || test clean = \"$opt_mode\"; then\n  func_mode_uninstall ${1+\"$@\"}\nfi\n\ntest -z \"$opt_mode\" && {\n  help=$generic_help\n  func_fatal_help \"you must specify a MODE\"\n}\n\ntest -z \"$exec_cmd\" && \\\n  func_fatal_help \"invalid operation mode '$opt_mode'\"\n\nif test -n \"$exec_cmd\"; then\n  eval exec \"$exec_cmd\"\n  exit $EXIT_FAILURE\nfi\n\nexit $exit_status\n\n\n# The TAGs below are defined such that we never get into a situation\n# where we disable both kinds of libraries.  Given conflicting\n# choices, we go for a static library, that is the most portable,\n# since we can't tell whether shared libraries were disabled because\n# the user asked for that or because the platform doesn't support\n# them.  This is particularly important on AIX, because we don't\n# support having both static and shared libraries enabled at the same\n# time on that platform, so we default to a shared-only configuration.\n# If a disable-shared tag is given, we'll fallback to a static-only\n# configuration.  But we'll never go from static-only to shared-only.\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-shared\nbuild_libtool_libs=no\nbuild_old_libs=yes\n# ### END LIBTOOL TAG CONFIG: disable-shared\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-static\nbuild_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`\n# ### END LIBTOOL TAG CONFIG: disable-static\n\n# Local Variables:\n# mode:shell-script\n# sh-indentation:2\n# End:\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mono/metadata/loader.c": "/**\n * \\file\n * Image Loader\n *\n * Authors:\n *   Paolo Molaro (lupus@ximian.com)\n *   Miguel de Icaza (miguel@ximian.com)\n *   Patrik Torstensson (patrik.torstensson@labs2.com)\n *\n * Copyright 2001-2003 Ximian, Inc (http://www.ximian.com)\n * Copyright 2004-2009 Novell, Inc (http://www.novell.com)\n * Copyright 2011 Xamarin, Inc (http://www.xamarin.com)\n *\n * This file is used by the interpreter and the JIT engine to locate\n * assemblies.  Used to load AssemblyRef and later to resolve various\n * kinds of `Refs'.\n *\n * TODO:\n *   This should keep track of the assembly versions that we are loading.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for full license information.\n */\n#include <config.h>\n#include <glib.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <mono/metadata/metadata.h>\n#include <mono/metadata/image.h>\n#include <mono/metadata/assembly.h>\n#include <mono/metadata/tokentype.h>\n#include <mono/metadata/tabledefs.h>\n#include <mono/metadata/metadata-internals.h>\n#include <mono/metadata/loader.h>\n#include <mono/metadata/loader-internals.h>\n#include <mono/metadata/class-init.h>\n#include <mono/metadata/class-internals.h>\n#include <mono/metadata/debug-helpers.h>\n#include <mono/metadata/reflection.h>\n#include <mono/metadata/profiler-private.h>\n#include <mono/metadata/exception.h>\n#include <mono/metadata/marshal.h>\n#include <mono/metadata/lock-tracer.h>\n#include <mono/metadata/verify-internals.h>\n#include <mono/metadata/exception-internals.h>\n#include <mono/utils/mono-logger-internals.h>\n#include <mono/utils/mono-dl.h>\n#include <mono/utils/mono-membar.h>\n#include <mono/utils/mono-counters.h>\n#include <mono/utils/mono-error-internals.h>\n#include <mono/utils/mono-tls.h>\n#include <mono/utils/mono-path.h>\n\nMonoDefaults mono_defaults;\n\n/*\n * This lock protects the hash tables inside MonoImage used by the metadata \n * loading functions in class.c and loader.c.\n *\n * See domain-internals.h for locking policy in combination with the\n * domain lock.\n */\nstatic MonoCoopMutex loader_mutex;\nstatic mono_mutex_t global_loader_data_mutex;\nstatic gboolean loader_lock_inited;\n\n/* Statistics */\nstatic gint32 inflated_signatures_size;\nstatic gint32 memberref_sig_cache_size;\nstatic gint32 methods_size;\nstatic gint32 signatures_size;\n\n/*\n * This TLS variable holds how many times the current thread has acquired the loader \n * lock.\n */\nstatic MonoNativeTlsKey loader_lock_nest_id;\n\n#if ENABLE_NETCORE\nstatic int pinvoke_search_directories_count;\nstatic char **pinvoke_search_directories;\n#endif\n\nstatic void dllmap_cleanup (void);\nstatic void cached_module_cleanup(void);\n\nstatic void dllmap_insert_global (const char *dll, const char *func, const char *tdll, const char *tfunc);\nstatic void dllmap_insert_image (MonoImage *assembly, const char *dll, const char *func, const char *tdll, const char *tfun);\n\n\n/* Class lazy loading functions */\nGENERATE_GET_CLASS_WITH_CACHE (appdomain_unloaded_exception, \"System\", \"AppDomainUnloadedException\")\nGENERATE_TRY_GET_CLASS_WITH_CACHE (appdomain_unloaded_exception, \"System\", \"AppDomainUnloadedException\")\n\nstatic void\nglobal_loader_data_lock (void)\n{\n\tmono_locks_os_acquire (&global_loader_data_mutex, LoaderGlobalDataLock);\n}\n\nstatic void\nglobal_loader_data_unlock (void)\n{\n\tmono_locks_os_release (&global_loader_data_mutex, LoaderGlobalDataLock);\n}\n\nvoid\nmono_loader_init ()\n{\n\tstatic gboolean inited;\n\n\tif (!inited) {\n\t\tmono_coop_mutex_init_recursive (&loader_mutex);\n\t\tmono_os_mutex_init_recursive (&global_loader_data_mutex);\n\t\tloader_lock_inited = TRUE;\n\n\t\tmono_native_tls_alloc (&loader_lock_nest_id, NULL);\n\n\t\tmono_counters_init ();\n\t\tmono_counters_register (\"Inflated signatures size\",\n\t\t\t\t\t\t\t\tMONO_COUNTER_GENERICS | MONO_COUNTER_INT, &inflated_signatures_size);\n\t\tmono_counters_register (\"Memberref signature cache size\",\n\t\t\t\t\t\t\t\tMONO_COUNTER_METADATA | MONO_COUNTER_INT, &memberref_sig_cache_size);\n\t\tmono_counters_register (\"MonoMethod size\",\n\t\t\t\t\t\t\t\tMONO_COUNTER_METADATA | MONO_COUNTER_INT, &methods_size);\n\t\tmono_counters_register (\"MonoMethodSignature size\",\n\t\t\t\t\t\t\t\tMONO_COUNTER_METADATA | MONO_COUNTER_INT, &signatures_size);\n\n\t\tinited = TRUE;\n\t}\n}\n\nvoid\nmono_loader_cleanup (void)\n{\n\tdllmap_cleanup ();\n\tcached_module_cleanup ();\n\n\tmono_native_tls_free (loader_lock_nest_id);\n\n\tmono_coop_mutex_destroy (&loader_mutex);\n\tmono_os_mutex_destroy (&global_loader_data_mutex);\n\tloader_lock_inited = FALSE;\t\n}\n\n/*\n * find_cached_memberref_sig:\n *\n *   Return a cached copy of the memberref signature identified by SIG_IDX.\n * We use a gpointer since the cache stores both MonoTypes and MonoMethodSignatures.\n * A cache is needed since the type/signature parsing routines allocate everything \n * from a mempool, so without a cache, multiple requests for the same signature would \n * lead to unbounded memory growth. For normal methods/fields this is not a problem \n * since the resulting methods/fields are cached, but inflated methods/fields cannot\n * be cached.\n * LOCKING: Acquires the loader lock.\n */\nstatic gpointer\nfind_cached_memberref_sig (MonoImage *image, guint32 sig_idx)\n{\n\tgpointer res;\n\n\tmono_image_lock (image);\n\tres = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));\n\tmono_image_unlock (image);\n\n\treturn res;\n}\n\nstatic gpointer\ncache_memberref_sig (MonoImage *image, guint32 sig_idx, gpointer sig)\n{\n\tgpointer prev_sig;\n\n\tmono_image_lock (image);\n\tprev_sig = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));\n\tif (prev_sig) {\n\t\t/* Somebody got in before us */\n\t\tsig = prev_sig;\n\t}\n\telse {\n\t\tg_hash_table_insert (image->memberref_signatures, GUINT_TO_POINTER (sig_idx), sig);\n\t\t/* An approximation based on glib 2.18 */\n\t\tmono_atomic_fetch_add_i32 (&memberref_sig_cache_size, sizeof (gpointer) * 4);\n\t}\n\tmono_image_unlock (image);\n\n\treturn sig;\n}\n\nstatic MonoClassField*\nfield_from_memberref (MonoImage *image, guint32 token, MonoClass **retklass,\n\t\t      MonoGenericContext *context, MonoError *error)\n{\n\tMonoClass *klass = NULL;\n\tMonoClassField *field;\n\tMonoTableInfo *tables = image->tables;\n\tMonoType *sig_type;\n\tguint32 cols[6];\n\tguint32 nindex, class_index;\n\tconst char *fname;\n\tconst char *ptr;\n\tguint32 idx = mono_metadata_token_index (token);\n\n\terror_init (error);\n\n\tmono_metadata_decode_row (&tables [MONO_TABLE_MEMBERREF], idx-1, cols, MONO_MEMBERREF_SIZE);\n\tnindex = cols [MONO_MEMBERREF_CLASS] >> MONO_MEMBERREF_PARENT_BITS;\n\tclass_index = cols [MONO_MEMBERREF_CLASS] & MONO_MEMBERREF_PARENT_MASK;\n\n\tfname = mono_metadata_string_heap (image, cols [MONO_MEMBERREF_NAME]);\n\n\tif (!mono_verifier_verify_memberref_field_signature (image, cols [MONO_MEMBERREF_SIGNATURE], error))\n\t\treturn NULL;\n\n\tswitch (class_index) {\n\tcase MONO_MEMBERREF_PARENT_TYPEDEF:\n\t\tklass = mono_class_get_checked (image, MONO_TOKEN_TYPE_DEF | nindex, error);\n\t\tbreak;\n\tcase MONO_MEMBERREF_PARENT_TYPEREF:\n\t\tklass = mono_class_from_typeref_checked (image, MONO_TOKEN_TYPE_REF | nindex, error);\n\t\tbreak;\n\tcase MONO_MEMBERREF_PARENT_TYPESPEC:\n\t\tklass = mono_class_get_and_inflate_typespec_checked (image, MONO_TOKEN_TYPE_SPEC | nindex, context, error);\n\t\tbreak;\n\tdefault:\n\t\tmono_error_set_bad_image (error, image, \"Bad field field '%u' signature 0x%08x\", class_index, token);\n\t}\n\n\tif (!klass)\n\t\treturn NULL;\n\n\tptr = mono_metadata_blob_heap (image, cols [MONO_MEMBERREF_SIGNATURE]);\n\tmono_metadata_decode_blob_size (ptr, &ptr);\n\t/* we may want to check the signature here... */\n\n\tif (*ptr++ != 0x6) {\n\t\tmono_error_set_field_missing (error, klass, fname, NULL, \"Bad field signature class token %08x field token %08x\", class_index, token);\n\t\treturn NULL;\n\t}\n\n\t/* FIXME: This needs a cache, especially for generic instances, since\n\t * we ask mono_metadata_parse_type_checked () to allocates everything from a mempool.\n\t * FIXME part2, mono_metadata_parse_type_checked actually allows for a transient type instead.\n\t * FIXME part3, transient types are not 100% transient, so we need to take care of that first.\n\t */\n\tsig_type = (MonoType *)find_cached_memberref_sig (image, cols [MONO_MEMBERREF_SIGNATURE]);\n\tif (!sig_type) {\n\t\tERROR_DECL (inner_error);\n\t\tsig_type = mono_metadata_parse_type_checked (image, NULL, 0, FALSE, ptr, &ptr, inner_error);\n\t\tif (sig_type == NULL) {\n\t\t\tmono_error_set_field_missing (error, klass, fname, NULL, \"Could not parse field signature %08x due to: %s\", token, mono_error_get_message (inner_error));\n\t\t\tmono_error_cleanup (inner_error);\n\t\t\treturn NULL;\n\t\t}\n\t\tsig_type = (MonoType *)cache_memberref_sig (image, cols [MONO_MEMBERREF_SIGNATURE], sig_type);\n\t}\n\n\tmono_class_init_internal (klass); /*FIXME is this really necessary?*/\n\tif (retklass)\n\t\t*retklass = klass;\n\tfield = mono_class_get_field_from_name_full (klass, fname, sig_type);\n\n\tif (!field) {\n\t\tmono_error_set_field_missing (error, klass, fname, sig_type, \"Could not find field in class\");\n\t}\n\n\treturn field;\n}\n\n/**\n * mono_field_from_token:\n * \\deprecated use the \\c _checked variant\n * Notes: runtime code MUST not use this function\n */\nMonoClassField*\nmono_field_from_token (MonoImage *image, guint32 token, MonoClass **retklass, MonoGenericContext *context)\n{\n\tERROR_DECL (error);\n\tMonoClassField *res = mono_field_from_token_checked (image, token, retklass, context, error);\n\tmono_error_assert_ok (error);\n\treturn res;\n}\n\nMonoClassField*\nmono_field_from_token_checked (MonoImage *image, guint32 token, MonoClass **retklass, MonoGenericContext *context, MonoError *error)\n{\n\tMonoClass *k;\n\tguint32 type;\n\tMonoClassField *field;\n\n\terror_init (error);\n\n\tif (image_is_dynamic (image)) {\n\t\tMonoClassField *result;\n\t\tMonoClass *handle_class;\n\n\t\t*retklass = NULL;\n\t\tERROR_DECL (inner_error);\n\t\tresult = (MonoClassField *)mono_lookup_dynamic_token_class (image, token, TRUE, &handle_class, context, inner_error);\n\t\tmono_error_cleanup (inner_error);\n\t\t// This checks the memberref type as well\n\t\tif (!result || handle_class != mono_defaults.fieldhandle_class) {\n\t\t\tmono_error_set_bad_image (error, image, \"Bad field token 0x%08x\", token);\n\t\t\treturn NULL;\n\t\t}\n\t\t*retklass = result->parent;\n\t\treturn result;\n\t}\n\n\tif ((field = (MonoClassField *)mono_conc_hashtable_lookup (image->field_cache, GUINT_TO_POINTER (token)))) {\n\t\t*retklass = field->parent;\n\t\treturn field;\n\t}\n\n\tif (mono_metadata_token_table (token) == MONO_TABLE_MEMBERREF) {\n\t\tfield = field_from_memberref (image, token, retklass, context, error);\n\t} else {\n\t\ttype = mono_metadata_typedef_from_field (image, mono_metadata_token_index (token));\n\t\tif (!type) {\n\t\t\tmono_error_set_bad_image (error, image, \"Invalid field token 0x%08x\", token);\n\t\t\treturn NULL;\n\t\t}\n\t\tk = mono_class_get_checked (image, MONO_TOKEN_TYPE_DEF | type, error);\n\t\tif (!k)\n\t\t\treturn NULL;\n\n\t\tmono_class_init_internal (k);\n\t\tif (retklass)\n\t\t\t*retklass = k;\n\t\tif (mono_class_has_failure (k)) {\n\t\t\tERROR_DECL (causedby_error);\n\t\t\tmono_error_set_for_class_failure (causedby_error, k);\n\t\t\tmono_error_set_bad_image (error, image, \"Could not resolve field token 0x%08x, due to: %s\", token, mono_error_get_message (causedby_error));\n\t\t\tmono_error_cleanup (causedby_error);\n\t\t} else {\n\t\t\tfield = mono_class_get_field (k, token);\n\t\t\tif (!field) {\n\t\t\t\tmono_error_set_bad_image (error, image, \"Could not resolve field token 0x%08x\", token);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (field && field->parent && !mono_class_is_ginst (field->parent) && !mono_class_is_gtd (field->parent)) {\n\t\tmono_image_lock (image);\n\t\tmono_conc_hashtable_insert (image->field_cache, GUINT_TO_POINTER (token), field);\n\t\tmono_image_unlock (image);\n\t}\n\n\treturn field;\n}\n\nstatic gboolean\nmono_metadata_signature_vararg_match (MonoMethodSignature *sig1, MonoMethodSignature *sig2)\n{\n\tint i;\n\n\tif (sig1->hasthis != sig2->hasthis ||\n\t    sig1->sentinelpos != sig2->sentinelpos)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < sig1->sentinelpos; i++) { \n\t\tMonoType *p1 = sig1->params[i];\n\t\tMonoType *p2 = sig2->params[i];\n\n\t\t/*if (p1->attrs != p2->attrs)\n\t\t\treturn FALSE;\n\t\t*/\n\t\tif (!mono_metadata_type_equal (p1, p2))\n\t\t\treturn FALSE;\n\t}\n\n\tif (!mono_metadata_type_equal (sig1->ret, sig2->ret))\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\nstatic MonoMethod *\nfind_method_in_class (MonoClass *klass, const char *name, const char *qname, const char *fqname,\n\t\t      MonoMethodSignature *sig, MonoClass *from_class, MonoError *error)\n{\n \tint i;\n\n\t/* Search directly in the metadata to avoid calling setup_methods () */\n\terror_init (error);\n\n\tMonoImage *klass_image = m_class_get_image (klass);\n\t/* FIXME: !mono_class_is_ginst (from_class) condition causes test failures. */\n\tif (m_class_get_type_token (klass) && !image_is_dynamic (klass_image) && !m_class_get_methods (klass) && !m_class_get_rank (klass) && klass == from_class && !mono_class_is_ginst (from_class)) {\n\t\tint first_idx = mono_class_get_first_method_idx (klass);\n\t\tint mcount = mono_class_get_method_count (klass);\n\t\tfor (i = 0; i < mcount; ++i) {\n\t\t\tguint32 cols [MONO_METHOD_SIZE];\n\t\t\tMonoMethod *method;\n\t\t\tconst char *m_name;\n\t\t\tMonoMethodSignature *other_sig;\n\n\t\t\tmono_metadata_decode_table_row (klass_image, MONO_TABLE_METHOD, first_idx + i, cols, MONO_METHOD_SIZE);\n\n\t\t\tm_name = mono_metadata_string_heap (klass_image, cols [MONO_METHOD_NAME]);\n\n\t\t\tif (!((fqname && !strcmp (m_name, fqname)) ||\n\t\t\t\t  (qname && !strcmp (m_name, qname)) ||\n\t\t\t\t  (name && !strcmp (m_name, name))))\n\t\t\t\tcontinue;\n\n\t\t\tmethod = mono_get_method_checked (klass_image, MONO_TOKEN_METHOD_DEF | (first_idx + i + 1), klass, NULL, error);\n\t\t\tif (!is_ok (error)) //bail out if we hit a loader error\n\t\t\t\treturn NULL;\n\t\t\tif (method) {\n\t\t\t\tother_sig = mono_method_signature_checked (method, error);\n\t\t\t\tif (!is_ok (error)) //bail out if we hit a loader error\n\t\t\t\t\treturn NULL;\t\t\t\t\n\t\t\t\tif (other_sig && (sig->call_convention != MONO_CALL_VARARG) && mono_metadata_signature_equal (sig, other_sig))\n\t\t\t\t\treturn method;\n\t\t\t}\n\t\t}\n\t}\n\n\tmono_class_setup_methods (klass); /* FIXME don't swallow the error here. */\n\t/*\n\tWe can't fail lookup of methods otherwise the runtime will fail with MissingMethodException instead of TypeLoadException.\n\tSee mono/tests/generic-type-load-exception.2.il\n\tFIXME we should better report this error to the caller\n\t */\n\tif (!m_class_get_methods (klass) || mono_class_has_failure (klass)) {\n\t\tERROR_DECL (cause_error);\n\t\tmono_error_set_for_class_failure (cause_error, klass);\n\t\tmono_error_set_type_load_class (error, klass, \"Could not find method '%s' due to a type load error: %s\", name, mono_error_get_message (cause_error));\n\t\tmono_error_cleanup (cause_error);\n\t\treturn NULL;\n\t}\n\tint mcount = mono_class_get_method_count (klass);\n\tMonoMethod **klass_methods = m_class_get_methods (klass);\n\tfor (i = 0; i < mcount; ++i) {\n\t\tMonoMethod *m = klass_methods [i];\n\t\tMonoMethodSignature *msig;\n\n\t\t/* We must cope with failing to load some of the types. */\n\t\tif (!m)\n\t\t\tcontinue;\n\n\t\tif (!((fqname && !strcmp (m->name, fqname)) ||\n\t\t      (qname && !strcmp (m->name, qname)) ||\n\t\t      (name && !strcmp (m->name, name))))\n\t\t\tcontinue;\n\t\tmsig = mono_method_signature_checked (m, error);\n\t\tif (!is_ok (error)) //bail out if we hit a loader error \n\t\t\treturn NULL;\n\n\t\tif (!msig)\n\t\t\tcontinue;\n\n\t\tif (sig->call_convention == MONO_CALL_VARARG) {\n\t\t\tif (mono_metadata_signature_vararg_match (sig, msig))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (mono_metadata_signature_equal (sig, msig))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i < mcount)\n\t\treturn mono_class_get_method_by_index (from_class, i);\n\treturn NULL;\n}\n\nstatic MonoMethod *\nfind_method (MonoClass *in_class, MonoClass *ic, const char* name, MonoMethodSignature *sig, MonoClass *from_class, MonoError *error)\n{\n\tint i;\n\tchar *qname, *fqname, *class_name;\n\tgboolean is_interface;\n\tMonoMethod *result = NULL;\n\tMonoClass *initial_class = in_class;\n\n\terror_init (error);\n\tis_interface = MONO_CLASS_IS_INTERFACE_INTERNAL (in_class);\n\n\tif (ic) {\n\t\tclass_name = mono_type_get_name_full (m_class_get_byval_arg (ic), MONO_TYPE_NAME_FORMAT_IL);\n\n\t\tqname = g_strconcat (class_name, \".\", name, (const char*)NULL);\n\t\tconst char *ic_name_space = m_class_get_name_space (ic);\n\t\tif (ic_name_space && ic_name_space [0])\n\t\t\tfqname = g_strconcat (ic_name_space, \".\", class_name, \".\", name, (const char*)NULL);\n\t\telse\n\t\t\tfqname = NULL;\n\t} else\n\t\tclass_name = qname = fqname = NULL;\n\n\twhile (in_class) {\n\t\tg_assert (from_class);\n\t\tresult = find_method_in_class (in_class, name, qname, fqname, sig, from_class, error);\n\t\tif (result || !is_ok (error))\n\t\t\tgoto out;\n\n\t\tif (name [0] == '.' && (!strcmp (name, \".ctor\") || !strcmp (name, \".cctor\")))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This happens when we fail to lazily load the interfaces of one of the types.\n\t\t * On such case we can't just bail out since user code depends on us trying harder.\n\t\t */\n\t\tif (m_class_get_interface_offsets_count (from_class) != m_class_get_interface_offsets_count (in_class)) {\n\t\t\tin_class = m_class_get_parent (in_class);\n\t\t\tfrom_class = m_class_get_parent (from_class);\n\t\t\tcontinue;\n\t\t}\n\n\t\tint in_class_interface_offsets_count = m_class_get_interface_offsets_count (in_class);\n\t\tMonoClass **in_class_interfaces_packed = m_class_get_interfaces_packed (in_class);\n\t\tMonoClass **from_class_interfaces_packed = m_class_get_interfaces_packed (from_class);\n\t\tfor (i = 0; i < in_class_interface_offsets_count; i++) {\n\t\t\tMonoClass *in_ic = in_class_interfaces_packed [i];\n\t\t\tMonoClass *from_ic = from_class_interfaces_packed [i];\n\t\t\tchar *ic_qname, *ic_fqname, *ic_class_name;\n\t\t\t\n\t\t\tic_class_name = mono_type_get_name_full (m_class_get_byval_arg (in_ic), MONO_TYPE_NAME_FORMAT_IL);\n\t\t\tic_qname = g_strconcat (ic_class_name, \".\", name, (const char*)NULL);\n\t\t\tconst char *in_ic_name_space = m_class_get_name_space (in_ic);\n\t\t\tif (in_ic_name_space && in_ic_name_space [0])\n\t\t\t\tic_fqname = g_strconcat (in_ic_name_space, \".\", ic_class_name, \".\", name, (const char*)NULL);\n\t\t\telse\n\t\t\t\tic_fqname = NULL;\n\n\t\t\tresult = find_method_in_class (in_ic, ic ? name : NULL, ic_qname, ic_fqname, sig, from_ic, error);\n\t\t\tg_free (ic_class_name);\n\t\t\tg_free (ic_fqname);\n\t\t\tg_free (ic_qname);\n\t\t\tif (result || !is_ok (error))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tin_class = m_class_get_parent (in_class);\n\t\tfrom_class = m_class_get_parent (from_class);\n\t}\n\tg_assert (!in_class == !from_class);\n\n\tif (is_interface)\n\t\tresult = find_method_in_class (mono_defaults.object_class, name, qname, fqname, sig, mono_defaults.object_class, error);\n\n\t//we did not find the method\n\tif (!result && is_ok (error))\n\t\tmono_error_set_method_missing (error, initial_class, name, sig, NULL);\n\t\t\n out:\n\tg_free (class_name);\n\tg_free (fqname);\n\tg_free (qname);\n\treturn result;\n}\n\nstatic MonoMethodSignature*\ninflate_generic_signature_checked (MonoImage *image, MonoMethodSignature *sig, MonoGenericContext *context, MonoError *error)\n{\n\tMonoMethodSignature *res;\n\tgboolean is_open;\n\tint i;\n\n\terror_init (error);\n\tif (!context)\n\t\treturn sig;\n\n\tres = (MonoMethodSignature *)g_malloc0 (MONO_SIZEOF_METHOD_SIGNATURE + ((gint32)sig->param_count) * sizeof (MonoType*));\n\tres->param_count = sig->param_count;\n\tres->sentinelpos = -1;\n\tres->ret = mono_class_inflate_generic_type_checked (sig->ret, context, error);\n\tif (!is_ok (error))\n\t\tgoto fail;\n\tis_open = mono_class_is_open_constructed_type (res->ret);\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tres->params [i] = mono_class_inflate_generic_type_checked (sig->params [i], context, error);\n\t\tif (!is_ok (error))\n\t\t\tgoto fail;\n\n\t\tif (!is_open)\n\t\t\tis_open = mono_class_is_open_constructed_type (res->params [i]);\n\t}\n\tres->hasthis = sig->hasthis;\n\tres->explicit_this = sig->explicit_this;\n\tres->call_convention = sig->call_convention;\n\tres->pinvoke = sig->pinvoke;\n\tres->generic_param_count = sig->generic_param_count;\n\tres->sentinelpos = sig->sentinelpos;\n\tres->has_type_parameters = is_open;\n\tres->is_inflated = 1;\n\treturn res;\n\nfail:\n\tif (res->ret)\n\t\tmono_metadata_free_type (res->ret);\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tif (res->params [i])\n\t\t\tmono_metadata_free_type (res->params [i]);\n\t}\n\tg_free (res);\n\treturn NULL;\n}\n\n/**\n * mono_inflate_generic_signature:\n *\n * Inflate \\p sig with \\p context, and return a canonical copy. On error, set \\p error, and return NULL.\n */\nMonoMethodSignature*\nmono_inflate_generic_signature (MonoMethodSignature *sig, MonoGenericContext *context, MonoError *error)\n{\n\tMonoMethodSignature *res, *cached;\n\n\tres = inflate_generic_signature_checked (NULL, sig, context, error);\n\tif (!is_ok (error))\n\t\treturn NULL;\n\tcached = mono_metadata_get_inflated_signature (res, context);\n\tif (cached != res)\n\t\tmono_metadata_free_inflated_signature (res);\n\treturn cached;\n}\n\nstatic MonoMethodHeader*\ninflate_generic_header (MonoMethodHeader *header, MonoGenericContext *context, MonoError *error)\n{\n\tsize_t locals_size = sizeof (gpointer) * header->num_locals;\n\tsize_t clauses_size = header->num_clauses * sizeof (MonoExceptionClause);\n\tsize_t header_size = MONO_SIZEOF_METHOD_HEADER + locals_size + clauses_size; \n\tMonoMethodHeader *res = (MonoMethodHeader *)g_malloc0 (header_size);\n\tres->num_locals = header->num_locals;\n\tres->clauses = (MonoExceptionClause *) &res->locals [res->num_locals] ;\n\tmemcpy (res->clauses, header->clauses, clauses_size);\n\n\tres->code = header->code;\n\tres->code_size = header->code_size;\n\tres->max_stack = header->max_stack;\n\tres->num_clauses = header->num_clauses;\n\tres->init_locals = header->init_locals;\n\n\tres->is_transient = TRUE;\n\n\terror_init (error);\n\n\tfor (int i = 0; i < header->num_locals; ++i) {\n\t\tres->locals [i] = mono_class_inflate_generic_type_checked (header->locals [i], context, error);\n\t\tgoto_if_nok (error, fail);\n\t}\n\tif (res->num_clauses) {\n\t\tfor (int i = 0; i < header->num_clauses; ++i) {\n\t\t\tMonoExceptionClause *clause = &res->clauses [i];\n\t\t\tif (clause->flags != MONO_EXCEPTION_CLAUSE_NONE)\n\t\t\t\tcontinue;\n\t\t\tclause->data.catch_class = mono_class_inflate_generic_class_checked (clause->data.catch_class, context, error);\n\t\t\tgoto_if_nok (error, fail);\n\t\t}\n\t}\n\treturn res;\nfail:\n\tg_free (res);\n\treturn NULL;\n}\n\n/**\n * mono_method_get_signature_full:\n * \\p token is the method ref/def/spec token used in a \\c call IL instruction.\n * \\deprecated use the \\c _checked variant\n * Notes: runtime code MUST not use this function\n */\nMonoMethodSignature*\nmono_method_get_signature_full (MonoMethod *method, MonoImage *image, guint32 token, MonoGenericContext *context)\n{\n\tERROR_DECL (error);\n\tMonoMethodSignature *res = mono_method_get_signature_checked (method, image, token, context, error);\n\tmono_error_cleanup (error);\n\treturn res;\n}\n\nMonoMethodSignature*\nmono_method_get_signature_checked (MonoMethod *method, MonoImage *image, guint32 token, MonoGenericContext *context, MonoError *error)\n{\n\tint table = mono_metadata_token_table (token);\n\tint idx = mono_metadata_token_index (token);\n\tint sig_idx;\n\tguint32 cols [MONO_MEMBERREF_SIZE];\n\tMonoMethodSignature *sig;\n\tconst char *ptr;\n\n\terror_init (error);\n\n\t/* !table is for wrappers: we should really assign their own token to them */\n\tif (!table || table == MONO_TABLE_METHOD)\n\t\treturn mono_method_signature_checked (method, error);\n\n\tif (table == MONO_TABLE_METHODSPEC) {\n\t\t/* the verifier (do_invoke_method) will turn the NULL into a verifier error */\n\t\tif ((method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) || !method->is_inflated) {\n\t\t\tmono_error_set_bad_image (error, image, \"Method is a pinvoke or open generic\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn mono_method_signature_checked (method, error);\n\t}\n\n\tif (mono_class_is_ginst (method->klass))\n\t\treturn mono_method_signature_checked (method, error);\n\n\tif (image_is_dynamic (image)) {\n\t\tsig = mono_reflection_lookup_signature (image, method, token, error);\n\t\tif (!sig)\n\t\t\treturn NULL;\n\t} else {\n\t\tmono_metadata_decode_row (&image->tables [MONO_TABLE_MEMBERREF], idx-1, cols, MONO_MEMBERREF_SIZE);\n\t\tsig_idx = cols [MONO_MEMBERREF_SIGNATURE];\n\n\t\tsig = (MonoMethodSignature *)find_cached_memberref_sig (image, sig_idx);\n\t\tif (!sig) {\n\t\t\tif (!mono_verifier_verify_memberref_method_signature (image, sig_idx, error))\n\t\t\t\treturn NULL;\n\n\t\t\tptr = mono_metadata_blob_heap (image, sig_idx);\n\t\t\tmono_metadata_decode_blob_size (ptr, &ptr);\n\n\t\t\tsig = mono_metadata_parse_method_signature_full (image, NULL, 0, ptr, NULL, error);\n\t\t\tif (!sig)\n\t\t\t\treturn NULL;\n\n\t\t\tsig = (MonoMethodSignature *)cache_memberref_sig (image, sig_idx, sig);\n\t\t}\n\t\t/* FIXME: we probably should verify signature compat in the dynamic case too*/\n\t\tif (!mono_verifier_is_sig_compatible (image, method, sig)) {\n\t\t\tguint32 klass = cols [MONO_MEMBERREF_CLASS] & MONO_MEMBERREF_PARENT_MASK;\n\t\t\tconst char *fname = mono_metadata_string_heap (image, cols [MONO_MEMBERREF_NAME]);\n\n\t\t\tmono_error_set_bad_image (error, image, \"Incompatible method signature class token 0x%08x field name %s token 0x%08x\", klass, fname, token);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (context) {\n\t\tMonoMethodSignature *cached;\n\n\t\t/* This signature is not owned by a MonoMethod, so need to cache */\n\t\tsig = inflate_generic_signature_checked (image, sig, context, error);\n\t\tif (!is_ok (error))\n\t\t\treturn NULL;\n\n\t\tcached = mono_metadata_get_inflated_signature (sig, context);\n\t\tif (cached != sig)\n\t\t\tmono_metadata_free_inflated_signature (sig);\n\t\telse\n\t\t\tmono_atomic_fetch_add_i32 (&inflated_signatures_size, mono_metadata_signature_size (cached));\n\t\tsig = cached;\n\t}\n\n\tg_assert (is_ok (error));\n\treturn sig;\n}\n\n/**\n * mono_method_get_signature:\n * \\p token is the method_ref/def/spec token used in a call IL instruction.\n * \\deprecated use the \\c _checked variant\n * Notes: runtime code MUST not use this function\n */\nMonoMethodSignature*\nmono_method_get_signature (MonoMethod *method, MonoImage *image, guint32 token)\n{\n\tERROR_DECL (error);\n\tMonoMethodSignature *res = mono_method_get_signature_checked (method, image, token, NULL, error);\n\tmono_error_cleanup (error);\n\treturn res;\n}\n\n/* this is only for the typespec array methods */\nMonoMethod*\nmono_method_search_in_array_class (MonoClass *klass, const char *name, MonoMethodSignature *sig)\n{\n\tint i;\n\n\tmono_class_setup_methods (klass);\n\tg_assert (!mono_class_has_failure (klass)); /*FIXME this should not fail, right?*/\n\tint mcount = mono_class_get_method_count (klass);\n\tMonoMethod **klass_methods = m_class_get_methods (klass);\n\tfor (i = 0; i < mcount; ++i) {\n\t\tMonoMethod *method = klass_methods [i];\n\t\tif (strcmp (method->name, name) == 0 && sig->param_count == method->signature->param_count)\n\t\t\treturn method;\n\t}\n\treturn NULL;\n}\n\nstatic MonoMethod *\nmethod_from_memberref (MonoImage *image, guint32 idx, MonoGenericContext *typespec_context,\n\t\t       gboolean *used_context, MonoError *error)\n{\n\tMonoClass *klass = NULL;\n\tMonoMethod *method = NULL;\n\tMonoTableInfo *tables = image->tables;\n\tguint32 cols[6];\n\tguint32 nindex, class_index, sig_idx;\n\tconst char *mname;\n\tMonoMethodSignature *sig;\n\tconst char *ptr;\n\n\terror_init (error);\n\n\tmono_metadata_decode_row (&tables [MONO_TABLE_MEMBERREF], idx-1, cols, 3);\n\tnindex = cols [MONO_MEMBERREF_CLASS] >> MONO_MEMBERREF_PARENT_BITS;\n\tclass_index = cols [MONO_MEMBERREF_CLASS] & MONO_MEMBERREF_PARENT_MASK;\n\t/*g_print (\"methodref: 0x%x 0x%x %s\\n\", class, nindex,\n\t\tmono_metadata_string_heap (m, cols [MONO_MEMBERREF_NAME]));*/\n\n\tmname = mono_metadata_string_heap (image, cols [MONO_MEMBERREF_NAME]);\n\n\t/*\n\t * Whether we actually used the `typespec_context' or not.\n\t * This is used to tell our caller whether or not it's safe to insert the returned\n\t * method into a cache.\n\t */\n\tif (used_context)\n\t\t*used_context = class_index == MONO_MEMBERREF_PARENT_TYPESPEC;\n\n\tswitch (class_index) {\n\tcase MONO_MEMBERREF_PARENT_TYPEREF:\n\t\tklass = mono_class_from_typeref_checked (image, MONO_TOKEN_TYPE_REF | nindex, error);\n\t\tif (!klass)\n\t\t\tgoto fail;\n\t\tbreak;\n\tcase MONO_MEMBERREF_PARENT_TYPESPEC:\n\t\t/*\n\t\t * Parse the TYPESPEC in the parent's context.\n\t\t */\n\t\tklass = mono_class_get_and_inflate_typespec_checked (image, MONO_TOKEN_TYPE_SPEC | nindex, typespec_context, error);\n\t\tif (!klass)\n\t\t\tgoto fail;\n\t\tbreak;\n\tcase MONO_MEMBERREF_PARENT_TYPEDEF:\n\t\tklass = mono_class_get_checked (image, MONO_TOKEN_TYPE_DEF | nindex, error);\n\t\tif (!klass)\n\t\t\tgoto fail;\n\t\tbreak;\n\tcase MONO_MEMBERREF_PARENT_METHODDEF: {\n\t\tmethod = mono_get_method_checked (image, MONO_TOKEN_METHOD_DEF | nindex, NULL, NULL, error);\n\t\tif (!method)\n\t\t\tgoto fail;\n\t\treturn method;\n\t}\n\tdefault:\n\t\tmono_error_set_bad_image (error, image, \"Memberref parent unknown: class: %d, index %d\", class_index, nindex);\n\t\tgoto fail;\n\t}\n\n\tg_assert (klass);\n\tmono_class_init_internal (klass);\n\n\tsig_idx = cols [MONO_MEMBERREF_SIGNATURE];\n\n\tif (!mono_verifier_verify_memberref_method_signature (image, sig_idx, error))\n\t\tgoto fail;\n\n\tptr = mono_metadata_blob_heap (image, sig_idx);\n\tmono_metadata_decode_blob_size (ptr, &ptr);\n\n\tsig = (MonoMethodSignature *)find_cached_memberref_sig (image, sig_idx);\n\tif (!sig) {\n\t\tsig = mono_metadata_parse_method_signature_full (image, NULL, 0, ptr, NULL, error);\n\t\tif (sig == NULL)\n\t\t\tgoto fail;\n\n\t\tsig = (MonoMethodSignature *)cache_memberref_sig (image, sig_idx, sig);\n\t}\n\n\tswitch (class_index) {\n\tcase MONO_MEMBERREF_PARENT_TYPEREF:\n\tcase MONO_MEMBERREF_PARENT_TYPEDEF:\n\t\tmethod = find_method (klass, NULL, mname, sig, klass, error);\n\t\tbreak;\n\n\tcase MONO_MEMBERREF_PARENT_TYPESPEC: {\n\t\tMonoType *type;\n\n\t\ttype = m_class_get_byval_arg (klass);\n\n\t\tif (type->type != MONO_TYPE_ARRAY && type->type != MONO_TYPE_SZARRAY) {\n\t\t\tMonoClass *in_class = mono_class_is_ginst (klass) ? mono_class_get_generic_class (klass)->container_class : klass;\n\t\t\tmethod = find_method (in_class, NULL, mname, sig, klass, error);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* we're an array and we created these methods already in klass in mono_class_init_internal () */\n\t\tmethod = mono_method_search_in_array_class (klass, mname, sig);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tmono_error_set_bad_image (error, image,\"Memberref parent unknown: class: %d, index %d\", class_index, nindex);\n\t\tgoto fail;\n\t}\n\n\tif (!method && is_ok (error))\n\t\tmono_error_set_method_missing (error, klass, mname, sig, \"Failed to load due to unknown reasons\");\n\n\treturn method;\n\nfail:\n\tg_assert (!is_ok (error));\n\treturn NULL;\n}\n\nstatic MonoMethod *\nmethod_from_methodspec (MonoImage *image, MonoGenericContext *context, guint32 idx, MonoError *error)\n{\n\tMonoMethod *method;\n\tMonoClass *klass;\n\tMonoTableInfo *tables = image->tables;\n\tMonoGenericContext new_context;\n\tMonoGenericInst *inst;\n\tconst char *ptr;\n\tguint32 cols [MONO_METHODSPEC_SIZE];\n\tguint32 token, nindex, param_count;\n\n\terror_init (error);\n\n\tmono_metadata_decode_row (&tables [MONO_TABLE_METHODSPEC], idx - 1, cols, MONO_METHODSPEC_SIZE);\n\ttoken = cols [MONO_METHODSPEC_METHOD];\n\tnindex = token >> MONO_METHODDEFORREF_BITS;\n\n\tif (!mono_verifier_verify_methodspec_signature (image, cols [MONO_METHODSPEC_SIGNATURE], error))\n\t\treturn NULL;\n\n\tptr = mono_metadata_blob_heap (image, cols [MONO_METHODSPEC_SIGNATURE]);\n\n\tmono_metadata_decode_value (ptr, &ptr);\n\tptr++;\n\tparam_count = mono_metadata_decode_value (ptr, &ptr);\n\n\tinst = mono_metadata_parse_generic_inst (image, NULL, param_count, ptr, &ptr, error);\n\tif (!inst)\n\t\treturn NULL;\n\n\tif (context && inst->is_open) {\n\t\tinst = mono_metadata_inflate_generic_inst (inst, context, error);\n\t\tif (!is_ok (error))\n\t\t\treturn NULL;\n\t}\n\n\tif ((token & MONO_METHODDEFORREF_MASK) == MONO_METHODDEFORREF_METHODDEF) {\n\t\tmethod = mono_get_method_checked (image, MONO_TOKEN_METHOD_DEF | nindex, NULL, context, error);\n\t\tif (!method)\n\t\t\treturn NULL;\n\t} else {\n\t\tmethod = method_from_memberref (image, nindex, context, NULL, error);\n\t}\n\n\tif (!method)\n\t\treturn NULL;\n\n\tklass = method->klass;\n\n\tif (mono_class_is_ginst (klass)) {\n\t\tg_assert (method->is_inflated);\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\t}\n\n\tnew_context.class_inst = mono_class_is_ginst (klass) ? mono_class_get_generic_class (klass)->context.class_inst : NULL;\n\tnew_context.method_inst = inst;\n\n\tmethod = mono_class_inflate_generic_method_full_checked (method, klass, &new_context, error);\n\treturn method;\n}\n\nstruct _MonoDllMap {\n\tchar *dll;\n\tchar *target;\n\tchar *func;\n\tchar *target_func;\n\tMonoDllMap *next;\n};\n\nstatic MonoDllMap *global_dll_map;\n\nstatic int \nmono_dllmap_lookup_list (MonoDllMap *dll_map, const char *dll, const char* func, const char **rdll, const char **rfunc) {\n\tint found = 0;\n\n\t*rdll = dll;\n\n\tif (!dll_map)\n\t\treturn 0;\n\n\tglobal_loader_data_lock ();\n\n\t/* \n\t * we use the first entry we find that matches, since entries from\n\t * the config file are prepended to the list and we document that the\n\t * later entries win.\n\t */\n\tfor (; dll_map; dll_map = dll_map->next) {\n\t\tif (dll_map->dll [0] == 'i' && dll_map->dll [1] == ':') {\n\t\t\tif (g_ascii_strcasecmp (dll_map->dll + 2, dll))\n\t\t\t\tcontinue;\n\t\t} else if (strcmp (dll_map->dll, dll)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!found && dll_map->target) {\n\t\t\t*rdll = dll_map->target;\n\t\t\tfound = 1;\n\t\t\t/* we don't quit here, because we could find a full\n\t\t\t * entry that matches also function and that has priority.\n\t\t\t */\n\t\t}\n\t\tif (dll_map->func && strcmp (dll_map->func, func) == 0) {\n\t\t\t*rdll = dll_map->target;\n\t\t\t*rfunc = dll_map->target_func;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tglobal_loader_data_unlock ();\n\treturn found;\n}\n\nstatic int \nmono_dllmap_lookup (MonoImage *assembly, const char *dll, const char* func, const char **rdll, const char **rfunc)\n{\n\tint res;\n\tif (assembly && assembly->dll_map) {\n\t\tres = mono_dllmap_lookup_list (assembly->dll_map, dll, func, rdll, rfunc);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\treturn mono_dllmap_lookup_list (global_dll_map, dll, func, rdll, rfunc);\n}\n\n/**\n * mono_dllmap_insert:\n * \\param assembly if NULL, this is a global mapping, otherwise the remapping of the dynamic library will only apply to the specified assembly\n * \\param dll The name of the external library, as it would be found in the \\c DllImport declaration.  If prefixed with <code>i:</code> the matching of the library name is done without case sensitivity\n * \\param func if not null, the mapping will only applied to the named function (the value of <code>EntryPoint</code>)\n * \\param tdll The name of the library to map the specified \\p dll if it matches.\n * \\param tfunc The name of the function that replaces the invocation.  If NULL, it is replaced with a copy of \\p func.\n *\n * LOCKING: Acquires the loader lock.\n *\n * This function is used to programatically add \\c DllImport remapping in either\n * a specific assembly, or as a global remapping.   This is done by remapping\n * references in a \\c DllImport attribute from the \\p dll library name into the \\p tdll\n * name. If the \\p dll name contains the prefix <code>i:</code>, the comparison of the \n * library name is done without case sensitivity.\n *\n * If you pass \\p func, this is the name of the \\c EntryPoint in a \\c DllImport if specified\n * or the name of the function as determined by \\c DllImport. If you pass \\p func, you\n * must also pass \\p tfunc which is the name of the target function to invoke on a match.\n *\n * Example:\n *\n * <code>mono_dllmap_insert (NULL, \"i:libdemo.dll\", NULL, relocated_demo_path, NULL);</code>\n *\n * The above will remap \\c DllImport statements for \\c libdemo.dll and \\c LIBDEMO.DLL to\n * the contents of \\c relocated_demo_path for all assemblies in the Mono process.\n *\n * NOTE: This can be called before the runtime is initialized, for example from\n * \\c mono_config_parse.\n */\nvoid\nmono_dllmap_insert (MonoImage *assembly, const char *dll, const char *func, const char *tdll, const char *tfunc)\n{\n\tif (!assembly)\n\t\tdllmap_insert_global (dll, func, tdll, tfunc);\n\telse {\n\t\tMONO_ENTER_GC_UNSAFE;\n\t\tdllmap_insert_image (assembly, dll, func, tdll, tfunc);\n\t\tMONO_EXIT_GC_UNSAFE;\n\t}\n}\n\nvoid\ndllmap_insert_global (const char *dll, const char *func, const char *tdll, const char *tfunc)\n{\n\tMonoDllMap *entry;\n\n\t\tmono_loader_init ();\n\n\t\tentry = (MonoDllMap *)g_malloc0 (sizeof (MonoDllMap));\n\t\tentry->dll = dll? g_strdup (dll): NULL;\n\t\tentry->target = tdll? g_strdup (tdll): NULL;\n\t\tentry->func = func? g_strdup (func): NULL;\n\t\tentry->target_func = tfunc? g_strdup (tfunc): (func? g_strdup (func): NULL);\n\n\t\tglobal_loader_data_lock ();\n\t\tentry->next = global_dll_map;\n\t\tglobal_dll_map = entry;\n\t\tglobal_loader_data_unlock ();\n}\n\nvoid\ndllmap_insert_image (MonoImage *assembly, const char *dll, const char *func, const char *tdll, const char *tfunc)\n{\n\tMonoDllMap *entry;\n\tg_assert (assembly != NULL);\n\n\t\tmono_loader_init ();\n\n\t\tentry = (MonoDllMap *)mono_image_alloc0 (assembly, sizeof (MonoDllMap));\n\t\tentry->dll = dll? mono_image_strdup (assembly, dll): NULL;\n\t\tentry->target = tdll? mono_image_strdup (assembly, tdll): NULL;\n\t\tentry->func = func? mono_image_strdup (assembly, func): NULL;\n\t\tentry->target_func = tfunc? mono_image_strdup (assembly, tfunc): (func? mono_image_strdup (assembly, func): NULL);\n\n\t\tmono_image_lock (assembly);\n\t\tentry->next = assembly->dll_map;\n\t\tassembly->dll_map = entry;\n\t\tmono_image_unlock (assembly);\n}\n\nstatic void\nfree_dllmap (MonoDllMap *map)\n{\n\twhile (map) {\n\t\tMonoDllMap *next = map->next;\n\n\t\tg_free (map->dll);\n\t\tg_free (map->target);\n\t\tg_free (map->func);\n\t\tg_free (map->target_func);\n\t\tg_free (map);\n\t\tmap = next;\n\t}\n}\n\nstatic void\ndllmap_cleanup (void)\n{\n\tfree_dllmap (global_dll_map);\n\tglobal_dll_map = NULL;\n}\n\nstatic GHashTable *global_module_map;\n\nstatic MonoDl*\ncached_module_load (const char *name, int flags, char **err)\n{\n\tMonoDl *res;\n\n\tif (err)\n\t\t*err = NULL;\n\tglobal_loader_data_lock ();\n\tif (!global_module_map)\n\t\tglobal_module_map = g_hash_table_new (g_str_hash, g_str_equal);\n\tres = (MonoDl *)g_hash_table_lookup (global_module_map, name);\n\tif (res) {\n\t\tglobal_loader_data_unlock ();\n\t\treturn res;\n\t}\n\tres = mono_dl_open (name, flags, err);\n\tif (res)\n\t\tg_hash_table_insert (global_module_map, g_strdup (name), res);\n\tglobal_loader_data_unlock ();\n\treturn res;\n}\n\nvoid\nmono_loader_register_module (const char *name, MonoDl *module)\n{\n\tif (!global_module_map)\n\t\tglobal_module_map = g_hash_table_new (g_str_hash, g_str_equal);\n\tg_hash_table_insert (global_module_map, g_strdup (name), module);\n}\n\nstatic void\nremove_cached_module(gpointer key, gpointer value, gpointer user_data)\n{\n\tmono_dl_close((MonoDl*)value);\n}\n\nstatic void\ncached_module_cleanup(void)\n{\n\tif (global_module_map != NULL) {\n\t\tg_hash_table_foreach(global_module_map, remove_cached_module, NULL);\n\n\t\tg_hash_table_destroy(global_module_map);\n\t\tglobal_module_map = NULL;\n\t}\n}\n\nstatic MonoDl *internal_module;\n\nstatic gboolean\nis_absolute_path (const char *path)\n{\n#ifdef HOST_DARWIN\n\tif (!strncmp (path, \"@executable_path/\", 17) || !strncmp (path, \"@loader_path/\", 13) ||\n\t    !strncmp (path, \"@rpath/\", 7))\n\t    return TRUE;\n#endif\n\treturn g_path_is_absolute (path);\n}\n\ntypedef enum {\n\tLOOKUP_PINVOKE_ERR_OK = 0, /* No error */\n\tLOOKUP_PINVOKE_ERR_NO_LIB, /* DllNotFoundException */\n\tLOOKUP_PINVOKE_ERR_NO_SYM, /* EntryPointNotFoundException */\n} MonoLookupPInvokeErr;\n\n/* We should just use a MonoError, but mono_lookup_pinvoke_call has this legacy\n * error reporting mechanism where it returns an exception class and a string\n * message.  So instead we return an error code and message, and for internal\n * callers convert it to a MonoError.\n *\n * Don't expose this type to the runtime.  It's just an implementation\n * detail for backward compatability.\n */\ntypedef struct MonoLookupPInvokeStatus {\n\tMonoLookupPInvokeErr err_code;\n\tchar *err_arg;\n} MonoLookupPInvokeStatus;\n\nstatic gpointer\nlookup_pinvoke_call_impl (MonoMethod *method, MonoLookupPInvokeStatus *status_out);\n\nstatic void\npinvoke_probe_convert_status_for_api (MonoLookupPInvokeStatus *status, const char **exc_class, const char **exc_arg)\n{\n\tif (!exc_class)\n\t\treturn;\n\tswitch (status->err_code) {\n\tcase LOOKUP_PINVOKE_ERR_OK:\n\t\t*exc_class = NULL;\n\t\t*exc_arg = NULL;\n\t\tbreak;\n\tcase LOOKUP_PINVOKE_ERR_NO_LIB:\n\t\t*exc_class = \"DllNotFoundException\";\n\t\t*exc_arg = status->err_arg;\n\t\tstatus->err_arg = NULL;\n\t\tbreak;\n\tcase LOOKUP_PINVOKE_ERR_NO_SYM:\n\t\t*exc_class = \"EntryPointNotFoundException\";\n\t\t*exc_arg = status->err_arg;\n\t\tstatus->err_arg = NULL;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n}\n\nstatic void\npinvoke_probe_convert_status_to_error (MonoLookupPInvokeStatus *status, MonoError *error)\n{\n\t/* Note: this has to return a MONO_ERROR_GENERIC because mono_mb_emit_exception_for_error only knows how to decode generic errors. */\n\tswitch (status->err_code) {\n\tcase LOOKUP_PINVOKE_ERR_OK:\n\t\treturn;\n\tcase LOOKUP_PINVOKE_ERR_NO_LIB:\n\t\tmono_error_set_generic_error (error, \"System\", \"DllNotFoundException\", \"%s\", status->err_arg);\n\t\tg_free (status->err_arg);\n\t\tstatus->err_arg = NULL;\n\t\tbreak;\n\tcase LOOKUP_PINVOKE_ERR_NO_SYM:\n\t\tmono_error_set_generic_error (error, \"System\", \"EntryPointNotFoundException\", \"%s\", status->err_arg);\n\t\tg_free (status->err_arg);\n\t\tstatus->err_arg = NULL;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n}\n\n/**\n * mono_lookup_pinvoke_call:\n */\ngpointer\nmono_lookup_pinvoke_call (MonoMethod *method, const char **exc_class, const char **exc_arg)\n{\n\tgpointer result;\n\tMONO_ENTER_GC_UNSAFE;\n\tMonoLookupPInvokeStatus status;\n\tmemset (&status, 0, sizeof (status));\n\tresult = lookup_pinvoke_call_impl (method, &status);\n\tpinvoke_probe_convert_status_for_api (&status, exc_class, exc_arg);\n\tMONO_EXIT_GC_UNSAFE;\n\treturn result;\n}\n\nstatic MonoDl*\npinvoke_probe_for_module (MonoImage *image, const char*new_scope, const char *import, char **found_name_out, char **error_msg_out);\n\nstatic MonoDl*\npinvoke_probe_for_module_relative_directories (MonoImage *image, const char *file_name, char **found_name_out);\n\nstatic gpointer\npinvoke_probe_for_symbol (MonoDl *module, MonoMethodPInvoke *piinfo, const char *import, char **error_msg_out);\n\ngpointer\nmono_lookup_pinvoke_call_internal (MonoMethod *method, MonoError *error)\n{\n\tgpointer result;\n\tMonoLookupPInvokeStatus status;\n\tmemset (&status, 0, sizeof (status));\n\tresult = lookup_pinvoke_call_impl (method, &status);\n\tif (status.err_code)\n\t\tpinvoke_probe_convert_status_to_error (&status, error);\n\treturn result;\n}\n\ngpointer\nlookup_pinvoke_call_impl (MonoMethod *method, MonoLookupPInvokeStatus *status_out)\n{\n\tMonoImage *image = m_class_get_image (method->klass);\n\tMonoMethodPInvoke *piinfo = (MonoMethodPInvoke *)method;\n\tMonoTableInfo *tables = image->tables;\n\tMonoTableInfo *im = &tables [MONO_TABLE_IMPLMAP];\n\tMonoTableInfo *mr = &tables [MONO_TABLE_MODULEREF];\n\tguint32 im_cols [MONO_IMPLMAP_SIZE];\n\tguint32 scope_token;\n\tconst char *import = NULL;\n\tconst char *orig_scope;\n\tconst char *new_scope;\n\tchar *error_msg;\n\tchar *found_name = NULL;\n\tMonoDl *module = NULL;\n\tgboolean cached = FALSE;\n\tgpointer addr = NULL;\n\n\tg_assert (method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL);\n\n\tg_assert (status_out);\n\n\tif (piinfo->addr)\n\t\treturn piinfo->addr;\n\n\tif (image_is_dynamic (m_class_get_image (method->klass))) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\t(MonoReflectionMethodAux *)g_hash_table_lookup (\n\t\t\t\t((MonoDynamicImage*)m_class_get_image (method->klass))->method_aux_hash, method);\n\t\tif (!method_aux)\n\t\t\treturn NULL;\n\n\t\timport = method_aux->dllentry;\n\t\torig_scope = method_aux->dll;\n\t}\n\telse {\n\t\tif (!piinfo->implmap_idx || piinfo->implmap_idx > im->rows)\n\t\t\treturn NULL;\n\n\t\tmono_metadata_decode_row (im, piinfo->implmap_idx - 1, im_cols, MONO_IMPLMAP_SIZE);\n\n\t\tif (!im_cols [MONO_IMPLMAP_SCOPE] || im_cols [MONO_IMPLMAP_SCOPE] > mr->rows)\n\t\t\treturn NULL;\n\n\t\tpiinfo->piflags = im_cols [MONO_IMPLMAP_FLAGS];\n\t\timport = mono_metadata_string_heap (image, im_cols [MONO_IMPLMAP_NAME]);\n\t\tscope_token = mono_metadata_decode_row_col (mr, im_cols [MONO_IMPLMAP_SCOPE] - 1, MONO_MODULEREF_NAME);\n\t\torig_scope = mono_metadata_string_heap (image, scope_token);\n\t}\n\n#ifndef ENABLE_NETCORE\n\t// FIXME: The dllmap remaps System.Native to mono-native\n\tmono_dllmap_lookup (image, orig_scope, import, &new_scope, &import);\n#else\n\t/* AK: FIXME: dllmap, above doesn't strdup the results, so these leak\n\t * since there's no free() */\n\tnew_scope = g_strdup (orig_scope);\n\timport = g_strdup (import);\n#endif\n\n\tif (!module) {\n\t\tmono_image_lock (image);\n\t\tif (!image->pinvoke_scopes) {\n\t\t\timage->pinvoke_scopes = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n\t\t\timage->pinvoke_scope_filenames = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);\n\t\t}\n\t\tmodule = (MonoDl *)g_hash_table_lookup (image->pinvoke_scopes, new_scope);\n\t\tfound_name = (char *)g_hash_table_lookup (image->pinvoke_scope_filenames, new_scope);\n\t\tmono_image_unlock (image);\n\t\tif (module)\n\t\t\tcached = TRUE;\n\t\tif (found_name)\n\t\t\tfound_name = g_strdup (found_name);\n\t}\n\n\tif (!module)\n\t\tmodule = pinvoke_probe_for_module (image, new_scope, import, &found_name, &error_msg);\n\n\tif (!module) {\n\t\tmono_trace (G_LOG_LEVEL_WARNING, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\"DllImport unable to load library '%s'.\",\n\t\t\t\terror_msg);\n\t\tg_free (error_msg);\n\n\t\tstatus_out->err_code = LOOKUP_PINVOKE_ERR_NO_LIB;\n\t\tstatus_out->err_arg = g_strdup (new_scope);\n\t\treturn NULL;\n\t}\n\n\tif (!cached) {\n\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\"DllImport loaded library '%s'.\", found_name);\n\t\tmono_image_lock (image);\n\t\tif (!g_hash_table_lookup (image->pinvoke_scopes, new_scope)) {\n\t\t\tg_hash_table_insert (image->pinvoke_scopes, g_strdup (new_scope), module);\n\t\t\tg_hash_table_insert (image->pinvoke_scope_filenames, g_strdup (new_scope), g_strdup (found_name));\n\t\t}\n\t\tmono_image_unlock (image);\n\t}\n\n\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\"DllImport searching in: '%s' ('%s').\", new_scope, found_name);\n\tg_free (found_name);\n\n\taddr = pinvoke_probe_for_symbol (module, piinfo, import, &error_msg);\n\n\tif (!addr) {\n\t\tg_free (error_msg);\n\t\tstatus_out->err_code = LOOKUP_PINVOKE_ERR_NO_SYM;\n\t\tstatus_out->err_arg = g_strdup (import);\n\t\treturn NULL;\n\t}\n\tpiinfo->addr = addr;\n\treturn addr;\n}\n\n/**\n * pinvoke_probe_transform_path:\n *\n * Try transforming the library path given in \\p new_scope in different ways\n * depending on \\p phase\n *\n * \\returns \\c TRUE if a transformation was applied and the transformed path\n * components are written to the out arguments, or \\c FALSE if a transformation\n * did not apply.\n */\nstatic gboolean\npinvoke_probe_transform_path (const char *new_scope, int phase, char **file_name_out, char **base_name_out, char **dir_name_out, gboolean *is_absolute_out)\n{\n\tchar *file_name = NULL, *base_name = NULL, *dir_name = NULL;\n\tgboolean changed = FALSE;\n\tgboolean is_absolute = is_absolute_path (new_scope);\n\tswitch (phase) {\n\tcase 0:\n\t\t/* Try the original name */\n\t\tfile_name = g_strdup (new_scope);\n\t\tchanged = TRUE;\n\t\tbreak;\n\tcase 1:\n\t\t/* Try trimming the .dll extension */\n\t\tif (strstr (new_scope, \".dll\") == (new_scope + strlen (new_scope) - 4)) {\n\t\t\tfile_name = g_strdup (new_scope);\n\t\t\tfile_name [strlen (new_scope) - 4] = '\\0';\n\t\t\tchanged = TRUE;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (is_absolute) {\n\t\t\tdir_name = g_path_get_dirname (new_scope);\n\t\t\tbase_name = g_path_get_basename (new_scope);\n\t\t\tif (strstr (base_name, \"lib\") != base_name) {\n\t\t\t\tchar *tmp = g_strdup_printf (\"lib%s\", base_name);       \n\t\t\t\tg_free (base_name);\n\t\t\t\tbase_name = tmp;\n\t\t\t\tfile_name = g_strdup_printf (\"%s%s%s\", dir_name, G_DIR_SEPARATOR_S, base_name);\n\t\t\t\tchanged = TRUE;\n\t\t\t}\n\t\t} else if (strstr (new_scope, \"lib\") != new_scope) {\n\t\t\tfile_name = g_strdup_printf (\"lib%s\", new_scope);\n\t\t\tchanged = TRUE;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tif (!is_absolute && mono_dl_get_system_dir ()) {\n\t\t\tdir_name = (char*)mono_dl_get_system_dir ();\n\t\t\tfile_name = g_path_get_basename (new_scope);\n\t\t\tbase_name = NULL;\n\t\t\tchanged = TRUE;\n\t\t}\n\t\tbreak;\n\tdefault:\n#ifndef TARGET_WIN32\n\t\tif (!g_ascii_strcasecmp (\"user32.dll\", new_scope) ||\n\t\t    !g_ascii_strcasecmp (\"kernel32.dll\", new_scope) ||\n\t\t    !g_ascii_strcasecmp (\"user32\", new_scope) ||\n\t\t    !g_ascii_strcasecmp (\"kernel\", new_scope)) {\n\t\t\tfile_name = g_strdup (\"libMonoSupportW.so\");\n\t\t\tchanged = TRUE;\n\t\t}\n#endif\n\t\tbreak;\n\t}\n\tif (changed && is_absolute) {\n\t\tif (!dir_name)\n\t\t\tdir_name = g_path_get_dirname (file_name);\n\t\tif (!base_name)\n\t\t\tbase_name = g_path_get_basename (file_name);\n\t}\n\t*file_name_out = file_name;\n\t*base_name_out = base_name;\n\t*dir_name_out = dir_name;\n\t*is_absolute_out = is_absolute;\n\treturn changed;\n}\n\nstatic MonoDl*\npinvoke_probe_for_module (MonoImage *image, const char*new_scope, const char *import, char **found_name_out, char **error_msg_out)\n{\n\tchar *full_name, *file_name;\n\tchar *error_msg = NULL;\n\tchar *found_name = NULL;\n\tint i;\n\tMonoDl *module = NULL;\n\n\tg_assert (found_name_out);\n\tg_assert (error_msg_out);\n\n\tif (!module) {\n\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\"DllImport attempting to load: '%s'.\", new_scope);\n\n\t\t/* we allow a special name to dlopen from the running process namespace */\n\t\tif (strcmp (new_scope, \"__Internal\") == 0){\n\t\t\tif (internal_module == NULL)\n\t\t\t\tinternal_module = mono_dl_open (NULL, MONO_DL_LAZY, &error_msg);\n\t\t\tmodule = internal_module;\n\t\t}\n\t}\n\n\t/*\n\t * Try loading the module using a variety of names\n\t */\n\tfor (i = 0; i < 5; ++i) {\n\t\tchar *base_name = NULL, *dir_name = NULL;\n\t\tgboolean is_absolute;\n\n\t\tgboolean changed = pinvoke_probe_transform_path (new_scope, i, &file_name, &base_name, &dir_name, &is_absolute);\n\t\tif (!changed)\n\t\t\tcontinue;\n\t\t\n\t\tif (!module && is_absolute) {\n\t\t\tmodule = cached_module_load (file_name, MONO_DL_LAZY, &error_msg);\n\t\t\tif (!module) {\n\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\"DllImport error loading library '%s': '%s'.\",\n\t\t\t\t\t\t\tfile_name, error_msg);\n\t\t\t\tg_free (error_msg);\n\t\t\t} else {\n\t\t\t\tfound_name = g_strdup (file_name);\n\t\t\t}\n\t\t}\n\n\t\tif (!module && !is_absolute) {\n\t\t\tmodule = pinvoke_probe_for_module_relative_directories (image, file_name, &found_name);\n\t\t}\n\n\t\tif (!module) {\n\t\t\tvoid *iter = NULL;\n\t\t\tchar *file_or_base = is_absolute ? base_name : file_name;\n\t\t\twhile ((full_name = mono_dl_build_path (dir_name, file_or_base, &iter))) {\n\t\t\t\tmodule = cached_module_load (full_name, MONO_DL_LAZY, &error_msg);\n\t\t\t\tif (!module) {\n\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\"DllImport error loading library '%s': '%s'.\",\n\t\t\t\t\t\t\t\tfull_name, error_msg);\n\t\t\t\t\tg_free (error_msg);\n\t\t\t\t} else {\n\t\t\t\t\tfound_name = g_strdup (full_name);\n\t\t\t\t}\n\t\t\t\tg_free (full_name);\n\t\t\t\tif (module)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!module) {\n\t\t\tmodule = cached_module_load (file_name, MONO_DL_LAZY, &error_msg);\n\t\t\tif (!module) {\n\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\"DllImport error loading library '%s': '%s'.\",\n\t\t\t\t\t\t\tfile_name, error_msg);\n\t\t\t} else {\n\t\t\t\tfound_name = g_strdup (file_name);\n\t\t\t}\n\t\t}\n\n\t\tg_free (file_name);\n\t\tif (is_absolute) {\n\t\t\tg_free (base_name);\n\t\t\tg_free (dir_name);\n\t\t}\n\n\t\tif (module)\n\t\t\tbreak;\n\t}\n\n\t*found_name_out = found_name;\n\t*error_msg_out = error_msg;\n\treturn module;\n}\n\n#if ENABLE_NETCORE\nvoid\nmono_set_pinvoke_search_directories (int dir_count, char **dirs)\n{\n\tpinvoke_search_directories_count = dir_count;\n\tpinvoke_search_directories = dirs;\n}\n#endif\n\nstatic MonoDl*\npinvoke_probe_for_module_in_directory (const char *mdirname, const char *file_name, char **found_name_out)\n{\n\tvoid *iter = NULL;\n\tchar *full_name;\n\tMonoDl* module = NULL;\n\n\twhile ((full_name = mono_dl_build_path (mdirname, file_name, &iter)) && module == NULL) {\n\t\tchar *error_msg;\n\t\tmodule = cached_module_load (full_name, MONO_DL_LAZY, &error_msg);\n\t\tif (!module) {\n\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT, \"DllImport error loading library '%s': '%s'.\", full_name, error_msg);\n\t\t\tg_free (error_msg);\n\t\t} else {\n\t\t\t*found_name_out = g_strdup (full_name);\n\t\t}\n\t\tg_free (full_name);\n\t}\n\tg_free (full_name);\n\n\treturn module;\n}\n\nstatic MonoDl*\npinvoke_probe_for_module_relative_directories (MonoImage *image, const char *file_name, char **found_name_out)\n{\n\tchar *found_name = NULL;\n\tMonoDl* module = NULL;\n\n\tg_assert (found_name_out);\n\n#if ENABLE_NETCORE\n\tmono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_DLLIMPORT, \"netcore DllImport handler: wanted '%s'\", file_name);\n\n\t// Search in predefined directories first\n\tfor (int j = 0; j < pinvoke_search_directories_count && module == NULL; ++j) {\n\t\tmodule = pinvoke_probe_for_module_in_directory (pinvoke_search_directories[j], file_name, &found_name);\n\t}\n\n\t// Fallback to image directory\n\tif (module == NULL) {\n\t\t// TODO: Check DefaultDllImportSearchPathsAttribute, NativeLibrary callback\n\t\tchar *mdirname = g_path_get_dirname (image->name);\n\t\tif (mdirname)\n\t\t\tmodule = pinvoke_probe_for_module_in_directory (mdirname, file_name, &found_name);\n\t\tg_free (mdirname);\n\t}\n#else\n\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\tchar *mdirname = NULL;\n\t\t\t\tswitch (j) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tmdirname = g_path_get_dirname (image->name);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1: /* @executable_path@/../lib */\n\t\t\t\t\t{\n\t\t\t\t\t\tchar buf [4096];\n\t\t\t\t\t\tint binl;\n\t\t\t\t\t\tbinl = mono_dl_get_executable_path (buf, sizeof (buf));\n\t\t\t\t\t\tif (binl != -1) {\n\t\t\t\t\t\t\tchar *base, *newbase;\n\t\t\t\t\t\t\tchar *resolvedname;\n\t\t\t\t\t\t\tbuf [binl] = 0;\n\t\t\t\t\t\t\tresolvedname = mono_path_resolve_symlinks (buf);\n\n\t\t\t\t\t\t\tbase = g_path_get_dirname (resolvedname);\n\t\t\t\t\t\t\tnewbase = g_path_get_dirname(base);\n\n\t\t\t\t\t\t\t// On Android the executable for the application is going to be /system/bin/app_process{32,64} depending on\n\t\t\t\t\t\t\t// the application's architecture. However, libraries for the different architectures live in different\n\t\t\t\t\t\t\t// subdirectories of `/system`: `lib` for 32-bit apps and `lib64` for 64-bit ones. Thus appending `/lib` below\n\t\t\t\t\t\t\t// will fail to load the DSO for a 64-bit app, even if it exists there, because it will have a different\n\t\t\t\t\t\t\t// architecture. This is the cause of https://github.com/xamarin/xamarin-android/issues/2780 and the ifdef\n\t\t\t\t\t\t\t// below is the fix.\n\t\t\t\t\t\t\tmdirname = g_strdup_printf (\n#if defined(TARGET_ANDROID) && (defined(TARGET_ARM64) || defined(TARGET_AMD64))\n\t\t\t\t\t\t\t\t\t\"%s/lib64\",\n#else\n\t\t\t\t\t\t\t\t\t\"%s/lib\",\n#endif\n\t\t\t\t\t\t\t\t\tnewbase);\n\t\t\t\t\t\t\tg_free (resolvedname);\n\t\t\t\t\t\t\tg_free (base);\n\t\t\t\t\t\t\tg_free (newbase);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#ifdef __MACH__\n\t\t\t\t\tcase 2: /* @executable_path@/../Libraries */\n\t\t\t\t\t{\n\t\t\t\t\t\tchar buf [4096];\n\t\t\t\t\t\tint binl;\n\t\t\t\t\t\tbinl = mono_dl_get_executable_path (buf, sizeof (buf));\n\t\t\t\t\t\tif (binl != -1) {\n\t\t\t\t\t\t\tchar *base, *newbase;\n\t\t\t\t\t\t\tchar *resolvedname;\n\t\t\t\t\t\t\tbuf [binl] = 0;\n\t\t\t\t\t\t\tresolvedname = mono_path_resolve_symlinks (buf);\n\n\t\t\t\t\t\t\tbase = g_path_get_dirname (resolvedname);\n\t\t\t\t\t\t\tnewbase = g_path_get_dirname(base);\n\t\t\t\t\t\t\tmdirname = g_strdup_printf (\"%s/Libraries\", newbase);\n\n\t\t\t\t\t\t\tg_free (resolvedname);\n\t\t\t\t\t\t\tg_free (base);\n\t\t\t\t\t\t\tg_free (newbase);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tif (!mdirname)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmodule = pinvoke_probe_for_module_in_directory (mdirname, file_name, &found_name);\n\t\t\t\tg_free (mdirname);\n\t\t\t\tif (module)\n\t\t\t\t\tbreak;\n\t\t\t}\n#endif\n\n\t*found_name_out = found_name;\n\treturn module;\n}\n\n\nstatic gpointer\npinvoke_probe_for_symbol (MonoDl *module, MonoMethodPInvoke *piinfo, const char *import, char **error_msg_out)\n{\n\tchar *error_msg = NULL;\n\tgpointer addr = NULL;\n\n\tg_assert (error_msg_out);\n\n#ifdef HOST_WIN32\n\tif (import && import [0] == '#' && isdigit (import [1])) {\n\t\tchar *end;\n\t\tlong id;\n\n\t\tid = strtol (import + 1, &end, 10);\n\t\tif (id > 0 && *end == '\\0')\n\t\t\timport++;\n\t}\n#endif\n\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\"Searching for '%s'.\", import);\n\n\tif (piinfo->piflags & PINVOKE_ATTRIBUTE_NO_MANGLE) {\n\t\terror_msg = mono_dl_symbol (module, import, &addr); \n\t} else {\n\t\t/*\n\t\t * Search using a variety of mangled names\n\t\t */\n\t\tfor (int mangle_stdcall = 0; mangle_stdcall <= 1 && addr == NULL; mangle_stdcall++) {\n#if HOST_WIN32 && HOST_X86\n\t\t\tconst int max_managle_param_count = (mangle_stdcall == 0) ? 0 : 256;\n#else\n\t\t\tconst int max_managle_param_count = 0;\n#endif\n\t\t\tfor (int mangle_charset = 0; mangle_charset <= 1 && addr == NULL; mangle_charset ++) {\n\t\t\t\tfor (int mangle_param_count = 0; mangle_param_count <= max_managle_param_count && addr == NULL; mangle_param_count += 4) {\n\n\t\t\t\t\tchar *mangled_name = (char*)import;\n\t\t\t\t\tswitch (piinfo->piflags & PINVOKE_ATTRIBUTE_CHAR_SET_MASK) {\n\t\t\t\t\tcase PINVOKE_ATTRIBUTE_CHAR_SET_UNICODE:\n\t\t\t\t\t\t/* Try the mangled name first */\n\t\t\t\t\t\tif (mangle_charset == 0)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"W\", (const char*)NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PINVOKE_ATTRIBUTE_CHAR_SET_AUTO:\n#ifdef HOST_WIN32\n\t\t\t\t\t\tif (mangle_charset == 0)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"W\", (const char*)NULL);\n#else\n\t\t\t\t\t\t/* Try the mangled name last */\n\t\t\t\t\t\tif (mangle_charset == 1)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"A\", (const char*)NULL);\n#endif\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PINVOKE_ATTRIBUTE_CHAR_SET_ANSI:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Try the mangled name last */\n\t\t\t\t\t\tif (mangle_charset == 1)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"A\", (const char*)NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n#if HOST_WIN32 && HOST_X86\n\t\t\t\t\t/* Try the stdcall mangled name */\n\t\t\t\t\t/* \n\t\t\t\t\t * gcc under windows creates mangled names without the underscore, but MS.NET\n\t\t\t\t\t * doesn't support it, so we doesn't support it either.\n\t\t\t\t\t */\n\t\t\t\t\tif (mangle_stdcall == 1) {\n\t\t\t\t\t\tMonoMethod *method = &piinfo->method;\n\t\t\t\t\t\tint param_count;\n\t\t\t\t\t\tif (mangle_param_count == 0)\n\t\t\t\t\t\t\tparam_count = mono_method_signature_internal (method)->param_count * sizeof (gpointer);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t/* Try brute force, since it would be very hard to compute the stack usage correctly */\n\t\t\t\t\t\t\tparam_count = mangle_param_count;\n\n\t\t\t\t\t\tchar *mangled_stdcall_name = g_strdup_printf (\"_%s@%d\", mangled_name, param_count);\n\n\t\t\t\t\t\tif (mangled_name != import)\n\t\t\t\t\t\t\tg_free (mangled_name);\n\n\t\t\t\t\t\tmangled_name = mangled_stdcall_name;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\t\"Probing '%s'.\", mangled_name);\n\n\t\t\t\t\terror_msg = mono_dl_symbol (module, mangled_name, &addr);\n\n\t\t\t\t\tif (addr)\n\t\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\t\t\"Found as '%s'.\", mangled_name);\n\t\t\t\t\telse\n\t\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\t\t\"Could not find '%s' due to '%s'.\", mangled_name, error_msg);\n\n\t\t\t\t\tg_free (error_msg);\n\t\t\t\t\terror_msg = NULL;\n\n\t\t\t\t\tif (mangled_name != import)\n\t\t\t\t\t\tg_free (mangled_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t*error_msg_out = error_msg;\n\treturn addr;\n}\n\n/*\n * LOCKING: assumes the loader lock to be taken.\n */\nstatic MonoMethod *\nmono_get_method_from_token (MonoImage *image, guint32 token, MonoClass *klass,\n\t\t\t    MonoGenericContext *context, gboolean *used_context, MonoError *error)\n{\n\tMonoMethod *result;\n\tint table = mono_metadata_token_table (token);\n\tint idx = mono_metadata_token_index (token);\n\tMonoTableInfo *tables = image->tables;\n\tMonoGenericContainer *generic_container = NULL, *container = NULL;\n\tconst char *sig = NULL;\n\tguint32 cols [MONO_TYPEDEF_SIZE];\n\n\terror_init (error);\n\n\tif (image_is_dynamic (image)) {\n\t\tMonoClass *handle_class;\n\n\t\tresult = (MonoMethod *)mono_lookup_dynamic_token_class (image, token, TRUE, &handle_class, context, error);\n\t\treturn_val_if_nok (error, NULL);\n\n\t\t// This checks the memberref type as well\n\t\tif (result && handle_class != mono_defaults.methodhandle_class) {\n\t\t\tmono_error_set_bad_image (error, image, \"Bad method token 0x%08x on dynamic image\", token);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn result;\n\t}\n\n\tif (table != MONO_TABLE_METHOD) {\n\t\tif (table == MONO_TABLE_METHODSPEC) {\n\t\t\tif (used_context) *used_context = TRUE;\n\t\t\treturn method_from_methodspec (image, context, idx, error);\n\t\t}\n\t\tif (table != MONO_TABLE_MEMBERREF) {\n\t\t\tmono_error_set_bad_image (error, image, \"Bad method token 0x%08x.\", token);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn method_from_memberref (image, idx, context, used_context, error);\n\t}\n\n\tif (used_context) *used_context = FALSE;\n\n\tif (idx > image->tables [MONO_TABLE_METHOD].rows) {\n\t\tmono_error_set_bad_image (error, image, \"Bad method token 0x%08x (out of bounds).\", token);\n\t\treturn NULL;\n\t}\n\n\tif (!klass) {\n\t\tguint32 type = mono_metadata_typedef_from_method (image, token);\n\t\tif (!type) {\n\t\t\tmono_error_set_bad_image (error, image, \"Bad method token 0x%08x (could not find corresponding typedef).\", token);\n\t\t\treturn NULL;\n\t\t}\n\t\tklass = mono_class_get_checked (image, MONO_TOKEN_TYPE_DEF | type, error);\n\t\tif (klass == NULL)\n\t\t\treturn NULL;\n\t}\n\n\tmono_metadata_decode_row (&image->tables [MONO_TABLE_METHOD], idx - 1, cols, 6);\n\n\tif ((cols [2] & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t    (cols [1] & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL)) {\n\t\tresult = (MonoMethod *)mono_image_alloc0 (image, sizeof (MonoMethodPInvoke));\n\t} else {\n\t\tresult = (MonoMethod *)mono_image_alloc0 (image, sizeof (MonoMethod));\n\t\tmono_atomic_fetch_add_i32 (&methods_size, sizeof (MonoMethod));\n\t}\n\n\tmono_atomic_inc_i32 (&mono_stats.method_count);\n\n\tresult->slot = -1;\n\tresult->klass = klass;\n\tresult->flags = cols [2];\n\tresult->iflags = cols [1];\n\tresult->token = token;\n\tresult->name = mono_metadata_string_heap (image, cols [3]);\n\n\t/* If a method is abstract and marked as an icall, silently ignore the\n\t * icall attribute so that we don't later emit a warning that the icall\n\t * can't be found.\n\t */\n\tif ((result->flags & METHOD_ATTRIBUTE_ABSTRACT) &&\n\t    (result->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL))\n\t\tresult->iflags &= ~METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL;\n\n\tif (!sig) /* already taken from the methodref */\n\t\tsig = mono_metadata_blob_heap (image, cols [4]);\n\t/* size = */ mono_metadata_decode_blob_size (sig, &sig);\n\n\tcontainer = mono_class_try_get_generic_container (klass);\n\n\t/* \n\t * load_generic_params does a binary search so only call it if the method \n\t * is generic.\n\t */\n\tif (*sig & 0x10) {\n\t\tgeneric_container = mono_metadata_load_generic_params (image, token, container, result);\n\t}\n\tif (generic_container) {\n\t\tresult->is_generic = TRUE;\n\t\t/*FIXME put this before the image alloc*/\n\t\tif (!mono_metadata_load_generic_param_constraints_checked (image, token, generic_container, error))\n\t\t\treturn NULL;\n\n\t\tcontainer = generic_container;\n\t}\n\n\tif (cols [1] & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) {\n\t\tif (result->klass == mono_defaults.string_class && !strcmp (result->name, \".ctor\"))\n\t\t\tresult->string_ctor = 1;\n\t} else if (cols [2] & METHOD_ATTRIBUTE_PINVOKE_IMPL) {\n\t\tMonoMethodPInvoke *piinfo = (MonoMethodPInvoke *)result;\n\n#ifdef TARGET_WIN32\n\t\t/* IJW is P/Invoke with a predefined function pointer. */\n\t\tif (m_image_is_module_handle (image) && (cols [1] & METHOD_IMPL_ATTRIBUTE_NATIVE)) {\n\t\t\tpiinfo->addr = mono_image_rva_map (image, cols [0]);\n\t\t\tg_assert (piinfo->addr);\n\t\t}\n#endif\n\t\tpiinfo->implmap_idx = mono_metadata_implmap_from_method (image, idx - 1);\n\t\t/* Native methods can have no map. */\n\t\tif (piinfo->implmap_idx)\n\t\t\tpiinfo->piflags = mono_metadata_decode_row_col (&tables [MONO_TABLE_IMPLMAP], piinfo->implmap_idx - 1, MONO_IMPLMAP_FLAGS);\n\t}\n\n \tif (generic_container)\n \t\tmono_method_set_generic_container (result, generic_container);\n\n\treturn result;\n}\n\n/**\n * mono_get_method:\n */\nMonoMethod *\nmono_get_method (MonoImage *image, guint32 token, MonoClass *klass)\n{\n\tERROR_DECL (error);\n\tMonoMethod *result = mono_get_method_checked (image, token, klass, NULL, error);\n\tmono_error_cleanup (error);\n\treturn result;\n}\n\n/**\n * mono_get_method_full:\n */\nMonoMethod *\nmono_get_method_full (MonoImage *image, guint32 token, MonoClass *klass,\n\t\t      MonoGenericContext *context)\n{\n\tERROR_DECL (error);\n\tMonoMethod *result = mono_get_method_checked (image, token, klass, context, error);\n\tmono_error_cleanup (error);\n\treturn result;\n}\n\nMonoMethod *\nmono_get_method_checked (MonoImage *image, guint32 token, MonoClass *klass, MonoGenericContext *context, MonoError *error)\n{\n\tMonoMethod *result = NULL;\n\tgboolean used_context = FALSE;\n\n\t/* We do everything inside the lock to prevent creation races */\n\n\terror_init (error);\n\n\tmono_image_lock (image);\n\n\tif (mono_metadata_token_table (token) == MONO_TABLE_METHOD) {\n\t\tif (!image->method_cache)\n\t\t\timage->method_cache = g_hash_table_new (NULL, NULL);\n\t\tresult = (MonoMethod *)g_hash_table_lookup (image->method_cache, GINT_TO_POINTER (mono_metadata_token_index (token)));\n\t} else if (!image_is_dynamic (image)) {\n\t\tif (!image->methodref_cache)\n\t\t\timage->methodref_cache = g_hash_table_new (NULL, NULL);\n\t\tresult = (MonoMethod *)g_hash_table_lookup (image->methodref_cache, GINT_TO_POINTER (token));\n\t}\n\tmono_image_unlock (image);\n\n\tif (result)\n\t\treturn result;\n\n\n\tresult = mono_get_method_from_token (image, token, klass, context, &used_context, error);\n\tif (!result)\n\t\treturn NULL;\n\n\tmono_image_lock (image);\n\tif (!used_context && !result->is_inflated) {\n\t\tMonoMethod *result2 = NULL;\n\n\t\tif (mono_metadata_token_table (token) == MONO_TABLE_METHOD)\n\t\t\tresult2 = (MonoMethod *)g_hash_table_lookup (image->method_cache, GINT_TO_POINTER (mono_metadata_token_index (token)));\n\t\telse if (!image_is_dynamic (image))\n\t\t\tresult2 = (MonoMethod *)g_hash_table_lookup (image->methodref_cache, GINT_TO_POINTER (token));\n\n\t\tif (result2) {\n\t\t\tmono_image_unlock (image);\n\t\t\treturn result2;\n\t\t}\n\n\t\tif (mono_metadata_token_table (token) == MONO_TABLE_METHOD)\n\t\t\tg_hash_table_insert (image->method_cache, GINT_TO_POINTER (mono_metadata_token_index (token)), result);\n\t\telse if (!image_is_dynamic (image))\n\t\t\tg_hash_table_insert (image->methodref_cache, GINT_TO_POINTER (token), result);\n\t}\n\n\tmono_image_unlock (image);\n\n\treturn result;\n}\n\nstatic MonoMethod*\nget_method_constrained (MonoImage *image, MonoMethod *method, MonoClass *constrained_class, MonoGenericContext *context, MonoError *error)\n{\n\tMonoClass *base_class = method->klass;\n\n\terror_init (error);\n\n\tif (!mono_class_is_assignable_from_internal (base_class, constrained_class)) {\n\t\tchar *base_class_name = mono_type_get_full_name (base_class);\n\t\tchar *constrained_class_name = mono_type_get_full_name (constrained_class);\n\t\tmono_error_set_invalid_operation (error, \"constrained call: %s is not assignable from %s\", base_class_name, constrained_class_name);\n\t\tg_free (base_class_name);\n\t\tg_free (constrained_class_name);\n\t\treturn NULL;\n\t}\n\n\t/* If the constraining class is actually an interface, we don't learn\n\t * anything new by constraining.\n\t */\n\tif (MONO_CLASS_IS_INTERFACE_INTERNAL (constrained_class))\n\t\treturn method;\n\n\tmono_class_setup_vtable (base_class);\n\tif (mono_class_has_failure (base_class)) {\n\t\tmono_error_set_for_class_failure (error, base_class);\n\t\treturn NULL;\n\t}\n\n\tMonoGenericContext inflated_method_ctx;\n\tmemset (&inflated_method_ctx, 0, sizeof (inflated_method_ctx));\n\tinflated_method_ctx.class_inst = NULL;\n\tinflated_method_ctx.method_inst = NULL;\n\tgboolean inflated_generic_method = FALSE;\n\tif (method->is_inflated) {\n\t\tMonoGenericContext *method_ctx = mono_method_get_context (method);\n\t\t/* If method is an instantiation of a generic method definition, ie\n\t\t *   class H<T>  { void M<U> (...) { ... } }\n\t\t * and method is H<C>.M<D>\n\t\t * we will get at the end a refined HSubclass<...>.M<U> and we will need to re-instantiate it with D.\n\t\t * to get HSubclass<...>.M<D>\n\t\t *\n\t\t */\n\t\tif (method_ctx->method_inst != NULL) {\n\t\t\tinflated_generic_method = TRUE;\n\t\t\tinflated_method_ctx.method_inst = method_ctx->method_inst;\n\t\t}\n\t}\n\tint vtable_slot = 0;\n\tif (!MONO_CLASS_IS_INTERFACE_INTERNAL (base_class)) {\n\t\t/*if the base class isn't an interface and the method isn't\n\t\t * virtual, there's nothing to do, we're already on the method\n\t\t * we want to call. */\n\t\tif ((method->flags & METHOD_ATTRIBUTE_VIRTUAL) == 0)\n\t\t\treturn method;\n\t\t/* if this isn't an interface method, get the vtable slot and\n\t\t * find the corresponding method in the constrained class,\n\t\t * which is a subclass of the base class. */\n\t\tvtable_slot = mono_method_get_vtable_index (method);\n\n\t\tmono_class_setup_vtable (constrained_class);\n\t\tif (mono_class_has_failure (constrained_class)) {\n\t\t\tmono_error_set_for_class_failure (error, constrained_class);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tif ((method->flags & METHOD_ATTRIBUTE_VIRTUAL) == 0)\n\t\t\treturn method;\n\t\tmono_class_setup_vtable (constrained_class);\n\t\tif (mono_class_has_failure (constrained_class)) {\n\t\t\tmono_error_set_for_class_failure (error, constrained_class);\n\t\t\treturn NULL;\n\t\t}\n\t\t\t\n\t\t/* Get the slot of the method in the interface.  Then get the\n\t\t * interface base in constrained_class */\n\t\tint itf_slot = mono_method_get_vtable_index (method);\n\t\tg_assert (itf_slot >= 0);\n\t\tgboolean variant = FALSE;\n\t\tint itf_base = mono_class_interface_offset_with_variance (constrained_class, base_class, &variant);\n\t\tvtable_slot = itf_slot + itf_base;\n\t}\n\tg_assert (vtable_slot >= 0);\n\n\tMonoMethod *res = mono_class_get_vtable_entry (constrained_class, vtable_slot);\n\tif (res == NULL && mono_class_is_abstract (constrained_class) ) {\n\t\t/* Constraining class is abstract, there may not be a refined method. */\n\t\treturn method;\n\t}\n\tg_assert (res != NULL);\n\tif (inflated_generic_method) {\n\t\tg_assert (res->is_generic || res->is_inflated);\n\t\tres = mono_class_inflate_generic_method_checked (res, &inflated_method_ctx, error);\n\t\treturn_val_if_nok (error, NULL);\n\t}\n\treturn res;\n}\n\nMonoMethod *\nmono_get_method_constrained_with_method (MonoImage *image, MonoMethod *method, MonoClass *constrained_class,\n\t\t\t     MonoGenericContext *context, MonoError *error)\n{\n\tg_assert (method);\n\n\treturn get_method_constrained (image, method, constrained_class, context, error);\n}\n\n/**\n * mono_get_method_constrained:\n * This is used when JITing the <code>constrained.</code> opcode.\n * \\returns The contrained method, which has been inflated\n * as the function return value; and the original CIL-stream method as\n * declared in \\p cil_method. The latter is used for verification.\n */\nMonoMethod *\nmono_get_method_constrained (MonoImage *image, guint32 token, MonoClass *constrained_class,\n\t\t\t     MonoGenericContext *context, MonoMethod **cil_method)\n{\n\tERROR_DECL (error);\n\tMonoMethod *result = mono_get_method_constrained_checked (image, token, constrained_class, context, cil_method, error);\n\tmono_error_cleanup (error);\n\treturn result;\n}\n\nMonoMethod *\nmono_get_method_constrained_checked (MonoImage *image, guint32 token, MonoClass *constrained_class, MonoGenericContext *context, MonoMethod **cil_method, MonoError *error)\n{\n\terror_init (error);\n\n\t*cil_method = mono_get_method_checked (image, token, NULL, context, error);\n\tif (!*cil_method)\n\t\treturn NULL;\n\n\treturn get_method_constrained (image, *cil_method, constrained_class, context, error);\n}\n\n/**\n * mono_free_method:\n */\nvoid\nmono_free_method  (MonoMethod *method)\n{\n\tif (!method)\n\t\treturn;\n\n\tMONO_PROFILER_RAISE (method_free, (method));\n\t\n\t/* FIXME: This hack will go away when the profiler will support freeing methods */\n\tif (G_UNLIKELY (mono_profiler_installed ()))\n\t\treturn;\n\t\n\tif (method->signature) {\n\t\t/* \n\t\t * FIXME: This causes crashes because the types inside signatures and\n\t\t * locals are shared.\n\t\t */\n\t\t/* mono_metadata_free_method_signature (method->signature); */\n\t\t/* g_free (method->signature); */\n\t}\n\t\n\tif (method_is_dynamic (method)) {\n\t\tMonoMethodWrapper *mw = (MonoMethodWrapper*)method;\n\t\tint i;\n\n\t\tmono_marshal_free_dynamic_wrappers (method);\n\n\t\tmono_image_property_remove (m_class_get_image (method->klass), method);\n\n\t\tg_free ((char*)method->name);\n\t\tif (mw->header) {\n\t\t\tg_free ((char*)mw->header->code);\n\t\t\tfor (i = 0; i < mw->header->num_locals; ++i)\n\t\t\t\tg_free (mw->header->locals [i]);\n\t\t\tg_free (mw->header->clauses);\n\t\t\tg_free (mw->header);\n\t\t}\n\t\tg_free (mw->method_data);\n\t\tg_free (method->signature);\n\t\tg_free (method);\n\t}\n}\n\n/**\n * mono_method_get_param_names:\n */\nvoid\nmono_method_get_param_names (MonoMethod *method, const char **names)\n{\n\tint i, lastp;\n\tMonoClass *klass;\n\tMonoTableInfo *methodt;\n\tMonoTableInfo *paramt;\n\tMonoMethodSignature *signature;\n\tguint32 idx;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tsignature = mono_method_signature_internal (method);\n\t/*FIXME this check is somewhat redundant since the caller usally will have to get the signature to figure out the\n\t  number of arguments and allocate a properly sized array. */\n\tif (signature == NULL)\n\t\treturn;\n\n\tif (!signature->param_count)\n\t\treturn;\n\n\tfor (i = 0; i < signature->param_count; ++i)\n\t\tnames [i] = \"\";\n\n\tklass = method->klass;\n\tif (m_class_get_rank (klass))\n\t\treturn;\n\n\tmono_class_init_internal (klass);\n\n\tMonoImage *klass_image = m_class_get_image (klass);\n\tif (image_is_dynamic (klass_image)) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\t(MonoReflectionMethodAux *)g_hash_table_lookup (\n\t\t\t\t((MonoDynamicImage*)m_class_get_image (method->klass))->method_aux_hash, method);\n\t\tif (method_aux && method_aux->param_names) {\n\t\t\tfor (i = 0; i < mono_method_signature_internal (method)->param_count; ++i)\n\t\t\t\tif (method_aux->param_names [i + 1])\n\t\t\t\t\tnames [i] = method_aux->param_names [i + 1];\n\t\t}\n\t\treturn;\n\t}\n\n\tif (method->wrapper_type) {\n\t\tchar **pnames = NULL;\n\n\t\tmono_image_lock (klass_image);\n\t\tif (klass_image->wrapper_param_names)\n\t\t\tpnames = (char **)g_hash_table_lookup (klass_image->wrapper_param_names, method);\n\t\tmono_image_unlock (klass_image);\n\n\t\tif (pnames) {\n\t\t\tfor (i = 0; i < signature->param_count; ++i)\n\t\t\t\tnames [i] = pnames [i];\n\t\t}\n\t\treturn;\n\t}\n\n\tmethodt = &klass_image->tables [MONO_TABLE_METHOD];\n\tparamt = &klass_image->tables [MONO_TABLE_PARAM];\n\tidx = mono_method_get_index (method);\n\tif (idx > 0) {\n\t\tguint32 cols [MONO_PARAM_SIZE];\n\t\tguint param_index;\n\n\t\tparam_index = mono_metadata_decode_row_col (methodt, idx - 1, MONO_METHOD_PARAMLIST);\n\n\t\tif (idx < methodt->rows)\n\t\t\tlastp = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);\n\t\telse\n\t\t\tlastp = paramt->rows + 1;\n\t\tfor (i = param_index; i < lastp; ++i) {\n\t\t\tmono_metadata_decode_row (paramt, i -1, cols, MONO_PARAM_SIZE);\n\t\t\tif (cols [MONO_PARAM_SEQUENCE] && cols [MONO_PARAM_SEQUENCE] <= signature->param_count) /* skip return param spec and bounds check*/\n\t\t\t\tnames [cols [MONO_PARAM_SEQUENCE] - 1] = mono_metadata_string_heap (klass_image, cols [MONO_PARAM_NAME]);\n\t\t}\n\t}\n}\n\n/**\n * mono_method_get_param_token:\n */\nguint32\nmono_method_get_param_token (MonoMethod *method, int index)\n{\n\tMonoClass *klass = method->klass;\n\tMonoTableInfo *methodt;\n\tguint32 idx;\n\n\tmono_class_init_internal (klass);\n\n\tMonoImage *klass_image = m_class_get_image (klass);\n\tg_assert (!image_is_dynamic (klass_image));\n\n\tmethodt = &klass_image->tables [MONO_TABLE_METHOD];\n\tidx = mono_method_get_index (method);\n\tif (idx > 0) {\n\t\tguint param_index = mono_metadata_decode_row_col (methodt, idx - 1, MONO_METHOD_PARAMLIST);\n\n\t\tif (index == -1)\n\t\t\t/* Return value */\n\t\t\treturn mono_metadata_make_token (MONO_TABLE_PARAM, 0);\n\t\telse\n\t\t\treturn mono_metadata_make_token (MONO_TABLE_PARAM, param_index + index);\n\t}\n\n\treturn 0;\n}\n\n/**\n * mono_method_get_marshal_info:\n */\nvoid\nmono_method_get_marshal_info (MonoMethod *method, MonoMarshalSpec **mspecs)\n{\n\tint i, lastp;\n\tMonoClass *klass = method->klass;\n\tMonoTableInfo *methodt;\n\tMonoTableInfo *paramt;\n\tMonoMethodSignature *signature;\n\tguint32 idx;\n\n\tsignature = mono_method_signature_internal (method);\n\tg_assert (signature); /*FIXME there is no way to signal error from this function*/\n\n\tfor (i = 0; i < signature->param_count + 1; ++i)\n\t\tmspecs [i] = NULL;\n\n\tif (image_is_dynamic (m_class_get_image (method->klass))) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\t(MonoReflectionMethodAux *)g_hash_table_lookup (\n\t\t\t\t((MonoDynamicImage*)m_class_get_image (method->klass))->method_aux_hash, method);\n\t\tif (method_aux && method_aux->param_marshall) {\n\t\t\tMonoMarshalSpec **dyn_specs = method_aux->param_marshall;\n\t\t\tfor (i = 0; i < signature->param_count + 1; ++i) {\n\t\t\t\tif (dyn_specs [i]) {\n\t\t\t\t\tmspecs [i] = g_new0 (MonoMarshalSpec, 1);\n\t\t\t\t\tmemcpy (mspecs [i], dyn_specs [i], sizeof (MonoMarshalSpec));\n\t\t\t\t\tif (mspecs [i]->native == MONO_NATIVE_CUSTOM) {\n\t\t\t\t\t\tmspecs [i]->data.custom_data.custom_name = g_strdup (dyn_specs [i]->data.custom_data.custom_name);\n\t\t\t\t\t\tmspecs [i]->data.custom_data.cookie = g_strdup (dyn_specs [i]->data.custom_data.cookie);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t/* dynamic method added to non-dynamic image */\n\tif (method->dynamic)\n\t\treturn;\n\n\tmono_class_init_internal (klass);\n\n\tMonoImage *klass_image = m_class_get_image (klass);\n\tmethodt = &klass_image->tables [MONO_TABLE_METHOD];\n\tparamt = &klass_image->tables [MONO_TABLE_PARAM];\n\tidx = mono_method_get_index (method);\n\tif (idx > 0) {\n\t\tguint32 cols [MONO_PARAM_SIZE];\n\t\tguint param_index = mono_metadata_decode_row_col (methodt, idx - 1, MONO_METHOD_PARAMLIST);\n\n\t\tif (idx < methodt->rows)\n\t\t\tlastp = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);\n\t\telse\n\t\t\tlastp = paramt->rows + 1;\n\n\t\tfor (i = param_index; i < lastp; ++i) {\n\t\t\tmono_metadata_decode_row (paramt, i -1, cols, MONO_PARAM_SIZE);\n\n\t\t\tif (cols [MONO_PARAM_FLAGS] & PARAM_ATTRIBUTE_HAS_FIELD_MARSHAL && cols [MONO_PARAM_SEQUENCE] <= signature->param_count) {\n\t\t\t\tconst char *tp;\n\t\t\t\ttp = mono_metadata_get_marshal_info (klass_image, i - 1, FALSE);\n\t\t\t\tg_assert (tp);\n\t\t\t\tmspecs [cols [MONO_PARAM_SEQUENCE]]= mono_metadata_parse_marshal_spec (klass_image, tp);\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n}\n\n/**\n * mono_method_has_marshal_info:\n */\ngboolean\nmono_method_has_marshal_info (MonoMethod *method)\n{\n\tint i, lastp;\n\tMonoClass *klass = method->klass;\n\tMonoTableInfo *methodt;\n\tMonoTableInfo *paramt;\n\tguint32 idx;\n\n\tif (image_is_dynamic (m_class_get_image (method->klass))) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\t(MonoReflectionMethodAux *)g_hash_table_lookup (\n\t\t\t\t((MonoDynamicImage*)m_class_get_image (method->klass))->method_aux_hash, method);\n\t\tMonoMarshalSpec **dyn_specs = method_aux->param_marshall;\n\t\tif (dyn_specs) {\n\t\t\tfor (i = 0; i < mono_method_signature_internal (method)->param_count + 1; ++i)\n\t\t\t\tif (dyn_specs [i])\n\t\t\t\t\treturn TRUE;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\tmono_class_init_internal (klass);\n\n\tmethodt = &m_class_get_image (klass)->tables [MONO_TABLE_METHOD];\n\tparamt = &m_class_get_image (klass)->tables [MONO_TABLE_PARAM];\n\tidx = mono_method_get_index (method);\n\tif (idx > 0) {\n\t\tguint32 cols [MONO_PARAM_SIZE];\n\t\tguint param_index = mono_metadata_decode_row_col (methodt, idx - 1, MONO_METHOD_PARAMLIST);\n\n\t\tif (idx + 1 < methodt->rows)\n\t\t\tlastp = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);\n\t\telse\n\t\t\tlastp = paramt->rows + 1;\n\n\t\tfor (i = param_index; i < lastp; ++i) {\n\t\t\tmono_metadata_decode_row (paramt, i -1, cols, MONO_PARAM_SIZE);\n\n\t\t\tif (cols [MONO_PARAM_FLAGS] & PARAM_ATTRIBUTE_HAS_FIELD_MARSHAL)\n\t\t\t\treturn TRUE;\n\t\t}\n\t\treturn FALSE;\n\t}\n\treturn FALSE;\n}\n\ngpointer\nmono_method_get_wrapper_data (MonoMethod *method, guint32 id)\n{\n\tvoid **data;\n\tg_assert (method != NULL);\n\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\n\tdata = (void **)((MonoMethodWrapper *)method)->method_data;\n\tg_assert (data != NULL);\n\tg_assert (id <= GPOINTER_TO_UINT (*data));\n\treturn data [id];\n}\n\ntypedef struct {\n\tMonoStackWalk func;\n\tgpointer user_data;\n} StackWalkUserData;\n\nstatic gboolean\nstack_walk_adapter (MonoStackFrameInfo *frame, MonoContext *ctx, gpointer data)\n{\n\tStackWalkUserData *d = (StackWalkUserData *)data;\n\n\tswitch (frame->type) {\n\tcase FRAME_TYPE_DEBUGGER_INVOKE:\n\tcase FRAME_TYPE_MANAGED_TO_NATIVE:\n\tcase FRAME_TYPE_TRAMPOLINE:\n\tcase FRAME_TYPE_INTERP_TO_MANAGED:\n\tcase FRAME_TYPE_INTERP_TO_MANAGED_WITH_CTX:\n\t\treturn FALSE;\n\tcase FRAME_TYPE_MANAGED:\n\tcase FRAME_TYPE_INTERP:\n\t\tg_assert (frame->ji);\n\t\treturn d->func (frame->actual_method, frame->native_offset, frame->il_offset, frame->managed, d->user_data);\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t\treturn FALSE;\n\t}\n}\n\nvoid\nmono_stack_walk (MonoStackWalk func, gpointer user_data)\n{\n\tStackWalkUserData ud = { func, user_data };\n\tmono_get_eh_callbacks ()->mono_walk_stack_with_ctx (stack_walk_adapter, NULL, MONO_UNWIND_LOOKUP_ALL, &ud);\n}\n\n/**\n * mono_stack_walk_no_il:\n */\nvoid\nmono_stack_walk_no_il (MonoStackWalk func, gpointer user_data)\n{\n\tStackWalkUserData ud = { func, user_data };\n\tmono_get_eh_callbacks ()->mono_walk_stack_with_ctx (stack_walk_adapter, NULL, MONO_UNWIND_DEFAULT, &ud);\n}\n\ntypedef struct {\n\tMonoStackWalkAsyncSafe func;\n\tgpointer user_data;\n} AsyncStackWalkUserData;\n\n\nstatic gboolean\nasync_stack_walk_adapter (MonoStackFrameInfo *frame, MonoContext *ctx, gpointer data)\n{\n\tAsyncStackWalkUserData *d = (AsyncStackWalkUserData *)data;\n\n\tswitch (frame->type) {\n\tcase FRAME_TYPE_DEBUGGER_INVOKE:\n\tcase FRAME_TYPE_MANAGED_TO_NATIVE:\n\tcase FRAME_TYPE_TRAMPOLINE:\n\tcase FRAME_TYPE_INTERP_TO_MANAGED:\n\tcase FRAME_TYPE_INTERP_TO_MANAGED_WITH_CTX:\n\t\treturn FALSE;\n\tcase FRAME_TYPE_MANAGED:\n\tcase FRAME_TYPE_INTERP:\n\t\tif (!frame->ji)\n\t\t\treturn FALSE;\n\n\t\tMonoMethod *method;\n\t\tmethod = frame->ji->async ? NULL : frame->actual_method;\n\n\t\treturn d->func (method, frame->domain, frame->ji->code_start, frame->native_offset, d->user_data);\n\tdefault:\n\t\tg_assert_not_reached ();\n\t\treturn FALSE;\n\t}\n}\n\n\n/**\n * mono_stack_walk_async_safe:\n * Async safe version callable from signal handlers.\n */\nvoid\nmono_stack_walk_async_safe (MonoStackWalkAsyncSafe func, void *initial_sig_context, void *user_data)\n{\n\tMonoContext ctx;\n\tAsyncStackWalkUserData ud = { func, user_data };\n\n\tmono_sigctx_to_monoctx (initial_sig_context, &ctx);\n\tmono_get_eh_callbacks ()->mono_walk_stack_with_ctx (async_stack_walk_adapter, &ctx, MONO_UNWIND_SIGNAL_SAFE, &ud);\n}\n\nstatic gboolean\nlast_managed (MonoMethod *m, gint no, gint ilo, gboolean managed, gpointer data)\n{\n\tMonoMethod **dest = (MonoMethod **)data;\n\t*dest = m;\n\t/*g_print (\"In %s::%s [%d] [%d]\\n\", m->klass->name, m->name, no, ilo);*/\n\n\treturn managed;\n}\n\n/**\n * mono_method_get_last_managed:\n */\nMonoMethod*\nmono_method_get_last_managed (void)\n{\n\tMonoMethod *m = NULL;\n\tmono_stack_walk_no_il (last_managed, &m);\n\treturn m;\n}\n\nstatic gboolean loader_lock_track_ownership = FALSE;\n\n/**\n * mono_loader_lock:\n *\n * See \\c docs/thread-safety.txt for the locking strategy.\n */\nvoid\nmono_loader_lock (void)\n{\n\tmono_locks_coop_acquire (&loader_mutex, LoaderLock);\n\tif (G_UNLIKELY (loader_lock_track_ownership)) {\n\t\tmono_native_tls_set_value (loader_lock_nest_id, GUINT_TO_POINTER (GPOINTER_TO_UINT (mono_native_tls_get_value (loader_lock_nest_id)) + 1));\n\t}\n}\n\n/**\n * mono_loader_unlock:\n */\nvoid\nmono_loader_unlock (void)\n{\n\tmono_locks_coop_release (&loader_mutex, LoaderLock);\n\tif (G_UNLIKELY (loader_lock_track_ownership)) {\n\t\tmono_native_tls_set_value (loader_lock_nest_id, GUINT_TO_POINTER (GPOINTER_TO_UINT (mono_native_tls_get_value (loader_lock_nest_id)) - 1));\n\t}\n}\n\n/*\n * mono_loader_lock_track_ownership:\n *\n *   Set whenever the runtime should track ownership of the loader lock. If set to TRUE,\n * the mono_loader_lock_is_owned_by_self () can be called to query whenever the current\n * thread owns the loader lock. \n */\nvoid\nmono_loader_lock_track_ownership (gboolean track)\n{\n\tloader_lock_track_ownership = track;\n}\n\n/*\n * mono_loader_lock_is_owned_by_self:\n *\n *   Return whenever the current thread owns the loader lock.\n * This is useful to avoid blocking operations while holding the loader lock.\n */\ngboolean\nmono_loader_lock_is_owned_by_self (void)\n{\n\tg_assert (loader_lock_track_ownership);\n\n\treturn GPOINTER_TO_UINT (mono_native_tls_get_value (loader_lock_nest_id)) > 0;\n}\n\n/*\n * mono_loader_lock_if_inited:\n *\n *   Acquire the loader lock if it has been initialized, no-op otherwise. This can\n * be used in runtime initialization code which can be executed before mono_loader_init ().\n */\nvoid\nmono_loader_lock_if_inited (void)\n{\n\tif (loader_lock_inited)\n\t\tmono_loader_lock ();\n}\n\nvoid\nmono_loader_unlock_if_inited (void)\n{\n\tif (loader_lock_inited)\n\t\tmono_loader_unlock ();\n}\n\n/**\n * mono_method_signature_checked_slow:\n *\n * Return the signature of the method M. On failure, returns NULL, and ERR is set.\n * Call mono_method_signature_checked instead.\n */\nMonoMethodSignature*\nmono_method_signature_checked_slow (MonoMethod *m, MonoError *error)\n{\n\tint idx;\n\tMonoImage* img;\n\tconst char *sig;\n\tgboolean can_cache_signature;\n\tMonoGenericContainer *container;\n\tMonoMethodSignature *signature = NULL, *sig2;\n\tguint32 sig_offset;\n\n\t/* We need memory barriers below because of the double-checked locking pattern */ \n\n\terror_init (error);\n\n\tif (m->signature)\n\t\treturn m->signature;\n\n\timg = m_class_get_image (m->klass);\n\n\tif (m->is_inflated) {\n\t\tMonoMethodInflated *imethod = (MonoMethodInflated *) m;\n\t\t/* the lock is recursive */\n\t\tsignature = mono_method_signature_internal (imethod->declaring);\n\t\tsignature = inflate_generic_signature_checked (m_class_get_image (imethod->declaring->klass), signature, mono_method_get_context (m), error);\n\t\tif (!is_ok (error))\n\t\t\treturn NULL;\n\n\t\tmono_atomic_fetch_add_i32 (&inflated_signatures_size, mono_metadata_signature_size (signature));\n\n\t\tmono_image_lock (img);\n\n\t\tmono_memory_barrier ();\n\t\tif (!m->signature)\n\t\t\tm->signature = signature;\n\n\t\tmono_image_unlock (img);\n\n\t\treturn m->signature;\n\t}\n\n\tg_assert (mono_metadata_token_table (m->token) == MONO_TABLE_METHOD);\n\tidx = mono_metadata_token_index (m->token);\n\n\tsig = mono_metadata_blob_heap (img, sig_offset = mono_metadata_decode_row_col (&img->tables [MONO_TABLE_METHOD], idx - 1, MONO_METHOD_SIGNATURE));\n\n\tg_assert (!mono_class_is_ginst (m->klass));\n\tcontainer = mono_method_get_generic_container (m);\n\tif (!container)\n\t\tcontainer = mono_class_try_get_generic_container (m->klass);\n\n\t/* Generic signatures depend on the container so they cannot be cached */\n\t/* icall/pinvoke signatures cannot be cached cause we modify them below */\n\tcan_cache_signature = !(m->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) && !(m->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) && !container;\n\n\t/* If the method has parameter attributes, that can modify the signature */\n\tif (mono_metadata_method_has_param_attrs (img, idx))\n\t\tcan_cache_signature = FALSE;\n\n\tif (can_cache_signature) {\n\t\tmono_image_lock (img);\n\t\tsignature = (MonoMethodSignature *)g_hash_table_lookup (img->method_signatures, sig);\n\t\tmono_image_unlock (img);\n\t}\n\n\tif (!signature) {\n\t\tconst char *sig_body;\n\t\t/*TODO we should cache the failure result somewhere*/\n\t\tif (!mono_verifier_verify_method_signature (img, sig_offset, error))\n\t\t\treturn NULL;\n\n\t\t/* size = */ mono_metadata_decode_blob_size (sig, &sig_body);\n\n\t\tsignature = mono_metadata_parse_method_signature_full (img, container, idx, sig_body, NULL, error);\n\t\tif (!signature)\n\t\t\treturn NULL;\n\n\t\tif (can_cache_signature) {\n\t\t\tmono_image_lock (img);\n\t\t\tsig2 = (MonoMethodSignature *)g_hash_table_lookup (img->method_signatures, sig);\n\t\t\tif (!sig2)\n\t\t\t\tg_hash_table_insert (img->method_signatures, (gpointer)sig, signature);\n\t\t\tmono_image_unlock (img);\n\t\t}\n\n\t\tmono_atomic_fetch_add_i32 (&signatures_size, mono_metadata_signature_size (signature));\n\t}\n\n\t/* Verify metadata consistency */\n\tif (signature->generic_param_count) {\n\t\tif (!container || !container->is_method) {\n\t\t\tmono_error_set_method_missing (error, m->klass, m->name, signature, \"Signature claims method has generic parameters, but generic_params table says it doesn't for method 0x%08x from image %s\", idx, img->name);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (container->type_argc != signature->generic_param_count) {\n\t\t\tmono_error_set_method_missing (error, m->klass, m->name, signature, \"Inconsistent generic parameter count.  Signature says %d, generic_params table says %d for method 0x%08x from image %s\", signature->generic_param_count, container->type_argc, idx, img->name);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (container && container->is_method && container->type_argc) {\n\t\tmono_error_set_method_missing (error, m->klass, m->name, signature, \"generic_params table claims method has generic parameters, but signature says it doesn't for method 0x%08x from image %s\", idx, img->name);\n\t\treturn NULL;\n\t}\n\tif (m->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) {\n\t\tsignature->pinvoke = 1;\n#ifdef TARGET_WIN32\n\t\t/*\n\t\t * On Windows the default pinvoke calling convention is STDCALL but\n\t\t * we need CDECL since this is actually an icall.\n\t\t */\n\t\tsignature->call_convention = MONO_CALL_C;\n#endif\n\t} else if (m->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) {\n\t\tMonoCallConvention conv = (MonoCallConvention)0;\n\t\tMonoMethodPInvoke *piinfo = (MonoMethodPInvoke *)m;\n\t\tsignature->pinvoke = 1;\n\n\t\tswitch (piinfo->piflags & PINVOKE_ATTRIBUTE_CALL_CONV_MASK) {\n\t\tcase 0: /* no call conv, so using default */\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_WINAPI:\n\t\t\tconv = MONO_CALL_DEFAULT;\n\t\t\tbreak;\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_CDECL:\n\t\t\tconv = MONO_CALL_C;\n\t\t\tbreak;\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_STDCALL:\n\t\t\tconv = MONO_CALL_STDCALL;\n\t\t\tbreak;\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_THISCALL:\n\t\t\tconv = MONO_CALL_THISCALL;\n\t\t\tbreak;\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_FASTCALL:\n\t\t\tconv = MONO_CALL_FASTCALL;\n\t\t\tbreak;\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_GENERIC:\n\t\tcase PINVOKE_ATTRIBUTE_CALL_CONV_GENERICINST:\n\t\tdefault: {\n\t\t\tmono_error_set_method_missing (error, m->klass, m->name, signature, \"Unsupported calling convention : 0x%04x for method 0x%08x from image %s\", piinfo->piflags, idx, img->name);\n\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\tsignature->call_convention = conv;\n\t}\n\n\tmono_image_lock (img);\n\n\tmono_memory_barrier ();\n\tif (!m->signature)\n\t\tm->signature = signature;\n\n\tmono_image_unlock (img);\n\n\treturn m->signature;\n}\n\n/**\n * mono_method_signature_internal_slow:\n * \\returns the signature of the method \\p m. On failure, returns NULL.\n * Call mono_method_signature_internal instead.\n */\nMonoMethodSignature*\nmono_method_signature_internal_slow (MonoMethod *m)\n{\n\tERROR_DECL (error);\n\tMonoMethodSignature *sig = mono_method_signature_checked (m, error);\n\tif (sig)\n\t\treturn sig;\n\tchar *type_name = mono_type_get_full_name (m->klass);\n\tg_warning (\"Could not load signature of %s:%s due to: %s\", type_name, m->name, mono_error_get_message (error));\n\tg_free (type_name);\n\tmono_error_cleanup (error);\n\treturn NULL;\n}\n\n/**\n * mono_method_signature:\n * \\returns the signature of the method \\p m. On failure, returns NULL.\n */\nMonoMethodSignature*\nmono_method_signature (MonoMethod *m)\n{\n\tMonoMethodSignature *sig;\n\tMONO_ENTER_GC_UNSAFE;\n\tsig = mono_method_signature_internal (m);\n\tMONO_EXIT_GC_UNSAFE;\n\treturn sig;\n}\n\n/**\n * mono_method_get_name:\n */\nconst char*\nmono_method_get_name (MonoMethod *method)\n{\n\treturn method->name;\n}\n\n/**\n * mono_method_get_class:\n */\nMonoClass*\nmono_method_get_class (MonoMethod *method)\n{\n\treturn method->klass;\n}\n\n/**\n * mono_method_get_token:\n */\nguint32\nmono_method_get_token (MonoMethod *method)\n{\n\treturn method->token;\n}\n\ngboolean\nmono_method_has_no_body (MonoMethod *method)\n{\n\treturn ((method->flags & METHOD_ATTRIBUTE_ABSTRACT) ||\n\t\t(method->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME) ||\n\t\t(method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) ||\n\t\t(method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL));\n}\n\n// FIXME Replace all internal callers of mono_method_get_header_checked with\n// mono_method_get_header_internal; the difference is in error initialization.\nMonoMethodHeader*\nmono_method_get_header_internal (MonoMethod *method, MonoError *error)\n{\n\tint idx;\n\tguint32 rva;\n\tMonoImage* img;\n\tgpointer loc;\n\tMonoGenericContainer *container;\n\n\terror_init (error);\n\timg = m_class_get_image (method->klass);\n\n\t// FIXME: for internal callers maybe it makes sense to do this check at the call site, not\n\t// here?\n\tif (mono_method_has_no_body (method)) {\n\t\tif (method->is_reabstracted == 1)\n\t\t\tmono_error_set_generic_error (error, \"System\", \"EntryPointNotFoundException\", \"%s\", method->name);\n\t\telse\n\t\t\tmono_error_set_bad_image (error, img, \"Method has no body\");\n\t\treturn NULL;\n\t}\n\n\tif (method->is_inflated) {\n\t\tMonoMethodInflated *imethod = (MonoMethodInflated *) method;\n\t\tMonoMethodHeader *header, *iheader;\n\n\t\theader = mono_method_get_header_checked (imethod->declaring, error);\n\t\tif (!header)\n\t\t\treturn NULL;\n\n\t\tiheader = inflate_generic_header (header, mono_method_get_context (method), error);\n\t\tmono_metadata_free_mh (header);\n\t\tif (!iheader) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn iheader;\n\t}\n\n\tif (method->wrapper_type != MONO_WRAPPER_NONE || method->sre_method) {\n\t\tMonoMethodWrapper *mw = (MonoMethodWrapper *)method;\n\t\tg_assert (mw->header);\n\t\treturn mw->header;\n\t}\n\n\t/* \n\t * We don't need locks here: the new header is allocated from malloc memory\n\t * and is not stored anywhere in the runtime, the user needs to free it.\n\t */\n\tg_assert (mono_metadata_token_table (method->token) == MONO_TABLE_METHOD);\n\tidx = mono_metadata_token_index (method->token);\n\trva = mono_metadata_decode_row_col (&img->tables [MONO_TABLE_METHOD], idx - 1, MONO_METHOD_RVA);\n\n\tif (!mono_verifier_verify_method_header (img, rva, error))\n\t\treturn NULL;\n\n\tloc = mono_image_rva_map (img, rva);\n\tif (!loc) {\n\t\tmono_error_set_bad_image (error, img, \"Method has zero rva\");\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * When parsing the types of local variables, we must pass any container available\n\t * to ensure that both VAR and MVAR will get the right owner.\n\t */\n\tcontainer = mono_method_get_generic_container (method);\n\tif (!container)\n\t\tcontainer = mono_class_try_get_generic_container (method->klass);\n\treturn mono_metadata_parse_mh_full (img, container, (const char *)loc, error);\n}\n\nMonoMethodHeader*\nmono_method_get_header_checked (MonoMethod *method, MonoError *error)\n// Public function that must initialize MonoError for compatibility.\n{\n\tMONO_API_ERROR_INIT (error);\n\treturn mono_method_get_header_internal (method, error);\n}\n/**\n * mono_method_get_header:\n */\nMonoMethodHeader*\nmono_method_get_header (MonoMethod *method)\n{\n\tERROR_DECL (error);\n\tMonoMethodHeader *header = mono_method_get_header_checked (method, error);\n\tmono_error_cleanup (error);\n\treturn header;\n}\n\n\n/**\n * mono_method_get_flags:\n */\nguint32\nmono_method_get_flags (MonoMethod *method, guint32 *iflags)\n{\n\tif (iflags)\n\t\t*iflags = method->iflags;\n\treturn method->flags;\n}\n\n/**\n * mono_method_get_index:\n * Find the method index in the metadata \\c MethodDef table.\n */\nguint32\nmono_method_get_index (MonoMethod *method)\n{\n\tMonoClass *klass = method->klass;\n\tint i;\n\n\tif (m_class_get_rank (klass))\n\t\t/* constructed array methods are not in the MethodDef table */\n\t\treturn 0;\n\n\tif (method->token)\n\t\treturn mono_metadata_token_index (method->token);\n\n\tmono_class_setup_methods (klass);\n\tif (mono_class_has_failure (klass))\n\t\treturn 0;\n\tint first_idx = mono_class_get_first_method_idx (klass);\n\tint mcount = mono_class_get_method_count (klass);\n\tMonoMethod **klass_methods = m_class_get_methods (klass);\n\tfor (i = 0; i < mcount; ++i) {\n\t\tif (method == klass_methods [i]) {\n\t\t\tif (m_class_get_image (klass)->uncompressed_metadata)\n\t\t\t\treturn mono_metadata_translate_token_index (m_class_get_image (klass), MONO_TABLE_METHOD, first_idx + i + 1);\n\t\t\telse\n\t\t\t\treturn first_idx + i + 1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mono/utils/mono-dl-posix.c": "/**\n * \\file\n * Interface to the dynamic linker\n *\n * Author:\n *    Mono Team (http://www.mono-project.com)\n *\n * Copyright 2001-2004 Ximian, Inc.\n * Copyright 2004-2009 Novell, Inc.\n * Licensed under the MIT license. See LICENSE file in the project root for full license information.\n */\n#include <config.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#if defined(_POSIX_VERSION) && !defined (HOST_WASM)\n\n#include \"mono/utils/mono-dl.h\"\n#include \"mono/utils/mono-embed.h\"\n#include \"mono/utils/mono-path.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <glib.h>\n#include <dlfcn.h>\n\n#if !defined (TARGET_MACH)\nconst char *\nmono_dl_get_so_prefix (void)\n{\n\treturn \"lib\";\n}\nconst char **\nmono_dl_get_so_suffixes (void)\n{\n\tstatic const char *suffixes[] = {\n\t\t\".so\",\n#if defined (_AIX)\n/*\n * libtool generating sysv style names (.so) still results in an .a archive,\n * (AIX prefers to put shared objects inside the same ar archive used for\n * static members, likely as a fat library system) so try common member names\n * when no suffix is given. The same path with member names can be tried, then\n * .a and .so extensions with member names. (The suffixless member names are\n * for when .so names are specified, but the archive is a member - the runtime\n * should just keep trying with one of these suffixes then.)\n *\n * Unfortunately, this strategy won't work for \"aix\" style libtool sonames -\n * it tries something awful like like \"libfoo.a(libfoo.so.9)\" which requires\n * you to hardcode a version in the member name.\n */\n\t\t\"(shr.o)\",\n\t\t\"(shr_64.o)\",\n\t\t\".a(shr.o)\",\n\t\t\".a(shr_64.o)\",\n\t\t\".so(shr.o)\",\n\t\t\".so(shr_64.o)\",\n#endif\n\t\t\"\",\n\t};\n\treturn suffixes;\n}\n\nint\nmono_dl_get_executable_path (char *buf, int buflen)\n{\n#if defined(HAVE_READLINK)\n\treturn readlink (\"/proc/self/exe\", buf, buflen - 1);\n#else\n\treturn -1;\n#endif\n}\n\nconst char*\nmono_dl_get_system_dir (void)\n{\n\treturn NULL;\n}\n\n#endif\n\nvoid *\nmono_dl_open_file (const char *file, int flags)\n{\n#ifdef HOST_ANDROID\n\t/* Bionic doesn't support NULL filenames */\n\tif (!file)\n\t\treturn NULL;\n\t/* The intention of calling `g_file_test (file, G_FILE_TEST_EXISTS)` is\n\t * to speed up probing for non-existent libraries.  The problem is that\n\t * if file is just a simple \"libdl.so\" then `dlopen (file)` doesn't just\n\t * look for it in the current working directory, it will probe some\n\t * other paths too.  (For example on desktop linux you'd also look in\n\t * all the directories in LD_LIBRARY_PATH).  So the g_file_test() call\n\t * is not a robust way to avoid calling dlopen if the filename is\n\t * relative.\n\t */\n\tif (g_path_is_absolute (file) && !g_file_test (file, G_FILE_TEST_EXISTS))\n\t\treturn NULL;\n#endif\n#if defined(_AIX)\n\t/*\n\t * dlopen is /weird/ on AIX \n\t * shared libraries (really, all oobjects are, since PPC is PIC)\n\t * can cohabitate with not just SOs of the other arch, but also\n\t * with regular objects in an archive used for static linking\n\t * \n\t * we have to pass RTLD_MEMBER, otherwise lib.a(lib.o) doesn't work\n\t */\n\treturn dlopen (file, flags | RTLD_MEMBER);\n#else\n\treturn dlopen (file, flags);\n#endif\n}\n\nvoid\nmono_dl_close_handle (MonoDl *module)\n{\n\tdlclose (module->handle);\n}\n\nvoid*\nmono_dl_lookup_symbol (MonoDl *module, const char *name)\n{\n\treturn dlsym (module->handle, name);\n}\n\nint\nmono_dl_convert_flags (int flags)\n{\n\tint lflags = flags & MONO_DL_LOCAL? 0: RTLD_GLOBAL;\n\n\tif (flags & MONO_DL_LAZY)\n\t\tlflags |= RTLD_LAZY;\n\telse\n\t\tlflags |= RTLD_NOW;\n\treturn lflags;\n}\n\nchar*\nmono_dl_current_error_string (void)\n{\n\treturn g_strdup (dlerror ());\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mono/utils/mono-dl-wasm.c": "#include <config.h>\n\n#if defined (HOST_WASM)\n\n#include \"mono/utils/mono-dl.h\"\n#include \"mono/utils/mono-embed.h\"\n#include \"mono/utils/mono-path.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <glib.h>\n#include <dlfcn.h>\n\nconst char *\nmono_dl_get_so_prefix (void)\n{\n\treturn \"\";\n}\n\nconst char **\nmono_dl_get_so_suffixes (void)\n{\n\tstatic const char *suffixes[] = {\n\t\t\".wasm\", //we only recognize .wasm files for DSOs.\n\t\t\"\",\n\t};\n\treturn suffixes;\n}\n\nint\nmono_dl_get_executable_path (char *buf, int buflen)\n{\n\tstrncpy (buf, \"/managed\", buflen); //This is a packaging convertion that our tooling should enforce\n\treturn 0;\n}\n\nconst char*\nmono_dl_get_system_dir (void)\n{\n\treturn NULL;\n}\n\n\nvoid*\nmono_dl_lookup_symbol (MonoDl *module, const char *name)\n{\n\treturn NULL;\n}\n\nchar*\nmono_dl_current_error_string (void)\n{\n\treturn g_strdup (\"\");\n}\n\n\nint\nmono_dl_convert_flags (int flags)\n{\n\tint lflags = flags & MONO_DL_LOCAL ? 0 : RTLD_GLOBAL;\n\n\tif (flags & MONO_DL_LAZY)\n\t\tlflags |= RTLD_LAZY;\n\telse\n\t\tlflags |= RTLD_NOW;\n\treturn lflags;\n}\n\nvoid *\nmono_dl_open_file (const char *file, int flags)\n{\n\t// Actual dlopen is done in driver.c:wasm_dl_load()\n\treturn NULL;\n}\n\nvoid\nmono_dl_close_handle (MonoDl *module)\n{\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mono/utils/mono-dl.c": "/**\n * \\file\n * Interface to the dynamic linker\n *\n * Author:\n *    Mono Team (http://www.mono-project.com)\n *\n * Copyright 2001-2004 Ximian, Inc.\n * Copyright 2004-2009 Novell, Inc.\n * Licensed under the MIT license. See LICENSE file in the project root for full license information.\n */\n#include \"config.h\"\n#include \"mono/utils/mono-compiler.h\"\n#include \"mono/utils/mono-dl.h\"\n#include \"mono/utils/mono-embed.h\"\n#include \"mono/utils/mono-path.h\"\n#include \"mono/utils/mono-threads-api.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <glib.h>\n\nstruct MonoDlFallbackHandler {\n\tMonoDlFallbackLoad load_func;\n\tMonoDlFallbackSymbol symbol_func;\n\tMonoDlFallbackClose close_func;\n\tvoid *user_data;\n};\n\nstatic GSList *fallback_handlers;\n\n#if defined (_AIX)\n#include <ar.h>\n#include <fcntl.h>\n\n/**\n * On AIX/PASE, a shared library can be contained inside of an ar format\n * archive. Determine if the file is an ar archive or not.\n */\nstatic gboolean\nis_library_ar_archive (char *path)\n{\n\tint lfd, readret;\n\tchar magic [SAIAMAG];\n\tlfd = open (path, O_RDONLY);\n\n\t/* don't assume it's an archive on error */\n\tif (lfd == -1)\n\t\treturn FALSE;\n\n\treadret = read (lfd, magic, SAIAMAG);\n\tclose (lfd);\n\t/* check for equality with either version of header */\n\treturn readret == SAIAMAG &&\n\t\t(memcmp (magic, AIAMAG, SAIAMAG) == 0 ||\n\t\t memcmp (magic, AIAMAGBIG, SAIAMAG) == 0);\n}\n#endif\n\n/*\n * read a value string from line with any of the following formats:\n * \\s*=\\s*'string'\n * \\s*=\\s*\"string\"\n * \\s*=\\s*non_white_space_string\n */\nstatic char*\nread_string (char *p, FILE *file)\n{\n\tchar *endp;\n\tchar *startp;\n\twhile (*p && isspace (*p))\n\t\t++p;\n\tif (*p == 0)\n\t\treturn NULL;\n\tif (*p == '=')\n\t\tp++;\n\twhile (*p && isspace (*p))\n\t\t++p;\n\tif (*p == '\\'' || *p == '\"') {\n\t\tchar t = *p;\n\t\tp++;\n\t\tstartp = p;\n\t\tendp = strchr (p, t);\n\t\t/* FIXME: may need to read more from file... */\n\t\tif (!endp)\n\t\t\treturn NULL;\n\t\t*endp = 0;\n\t\treturn (char *) g_memdup (startp, (endp - startp) + 1);\n\t}\n\tif (*p == 0)\n\t\treturn NULL;\n\tstartp = p;\n\twhile (*p && !isspace (*p))\n\t\t++p;\n\t*p = 0;\n\treturn (char *) g_memdup (startp, (p - startp) + 1);\n}\n\n/*\n * parse a libtool .la file and return the path of the file to dlopen ()\n * handling both the installed and uninstalled cases\n */\nstatic char*\nget_dl_name_from_libtool (const char *libtool_file)\n{\n\tFILE* file;\n\tchar buf [512];\n\tchar *line, *dlname = NULL, *libdir = NULL, *installed = NULL;\n\tif (!(file = fopen (libtool_file, \"r\")))\n\t\treturn NULL;\n\twhile ((line = fgets (buf, 512, file))) {\n\t\twhile (*line && isspace (*line))\n\t\t\t++line;\n\t\tif (*line == '#' || *line == 0)\n\t\t\tcontinue;\n\t\tif (strncmp (\"dlname\", line, 6) == 0) {\n\t\t\tg_free (dlname);\n\t\t\tdlname = read_string (line + 6, file);\n\t\t} else if (strncmp (\"libdir\", line, 6) == 0) {\n\t\t\tg_free (libdir);\n\t\t\tlibdir = read_string (line + 6, file);\n\t\t} else if (strncmp (\"installed\", line, 9) == 0) {\n\t\t\tg_free (installed);\n\t\t\tinstalled = read_string (line + 9, file);\n\t\t}\n\t}\n\tfclose (file);\n\tline = NULL;\n\tif (installed && strcmp (installed, \"no\") == 0) {\n\t\tchar *dir = g_path_get_dirname (libtool_file);\n\t\tif (dlname)\n\t\t\tline = g_strconcat (dir, G_DIR_SEPARATOR_S \".libs\" G_DIR_SEPARATOR_S, dlname, (const char*)NULL);\n\t\tg_free (dir);\n\t} else {\n\t\tif (libdir && dlname)\n\t\t\tline = g_strconcat (libdir, G_DIR_SEPARATOR_S, dlname, (const char*)NULL);\n\t}\n\tg_free (dlname);\n\tg_free (libdir);\n\tg_free (installed);\n\treturn line;\n}\n\n/**\n * mono_dl_open:\n * \\param name name of file containing shared module\n * \\param flags flags\n * \\param error_msg pointer for error message on failure\n *\n * Load the given file \\p name as a shared library or dynamically loadable\n * module. \\p name can be NULL to indicate loading the currently executing\n * binary image.\n * \\p flags can have the \\c MONO_DL_LOCAL bit set to avoid exporting symbols\n * from the module to the shared namespace. The \\c MONO_DL_LAZY bit can be set\n * to lazily load the symbols instead of resolving everithing at load time.\n * \\p error_msg points to a string where an error message will be stored in\n * case of failure.   The error must be released with \\c g_free.\n * \\returns a \\c MonoDl pointer on success, NULL on failure.\n */\nMonoDl*\nmono_dl_open (const char *name, int flags, char **error_msg)\n{\n\tMonoDl *module;\n\tvoid *lib;\n\tMonoDlFallbackHandler *dl_fallback = NULL;\n\tint lflags = mono_dl_convert_flags (flags);\n\n\tif (error_msg)\n\t\t*error_msg = NULL;\n\n\tmodule = (MonoDl *) g_malloc (sizeof (MonoDl));\n\tif (!module) {\n\t\tif (error_msg)\n\t\t\t*error_msg = g_strdup (\"Out of memory\");\n\t\treturn NULL;\n\t}\n\tmodule->main_module = name == NULL? TRUE: FALSE;\n\n\t// No GC safe transition because this is called early in main.c\n\tlib = mono_dl_open_file (name, lflags);\n\n\tif (!lib) {\n\t\tGSList *node;\n\t\tfor (node = fallback_handlers; node != NULL; node = node->next){\n\t\t\tMonoDlFallbackHandler *handler = (MonoDlFallbackHandler *) node->data;\n\t\t\tif (error_msg)\n\t\t\t\t*error_msg = NULL;\n\t\t\t\n\t\t\tlib = handler->load_func (name, lflags, error_msg, handler->user_data);\n\t\t\tif (error_msg && *error_msg != NULL)\n\t\t\t\tg_free (*error_msg);\n\t\t\t\n\t\t\tif (lib != NULL){\n\t\t\t\tdl_fallback = handler;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!lib && !dl_fallback) {\n\t\tchar *lname;\n\t\tchar *llname;\n\t\tconst char *suff;\n\t\tconst char *ext;\n\t\t/* This platform does not support dlopen */\n\t\tif (name == NULL) {\n\t\t\tg_free (module);\n\t\t\treturn NULL;\n\t\t}\n\t\t\n\t\tsuff = \".la\";\n\t\text = strrchr (name, '.');\n\t\tif (ext && strcmp (ext, \".la\") == 0)\n\t\t\tsuff = \"\";\n\t\tlname = g_strconcat (name, suff, (const char*)NULL);\n\t\tllname = get_dl_name_from_libtool (lname);\n\t\tg_free (lname);\n\t\tif (llname) {\n\t\t\tlib = mono_dl_open_file (llname, lflags);\n#if defined (_AIX)\n\t\t\t/*\n\t\t\t * HACK: deal with AIX archive members because libtool\n\t\t\t * underspecifies when using --with-aix-soname=svr4 -\n\t\t\t * without this check, Mono can't find System.Native\n\t\t\t * at build time.\n\t\t\t * XXX: Does this also need to be in other places?\n\t\t\t */\n\t\t\tif (!lib && is_library_ar_archive (llname)) {\n\t\t\t\t/* try common suffix */\n\t\t\t\tchar *llaixname;\n\t\t\t\tllaixname = g_strconcat (llname, \"(shr_64.o)\", (const char*)NULL);\n\t\t\t\tlib = mono_dl_open_file (llaixname, lflags);\n\t\t\t\t/* XXX: try another suffix like (shr.o)? */\n\t\t\t\tg_free (llaixname);\n\t\t\t}\n#endif\n\t\t\tg_free (llname);\n\t\t}\n\t\tif (!lib) {\n\t\t\tif (error_msg) {\n\t\t\t\t*error_msg = mono_dl_current_error_string ();\n\t\t\t}\n\t\t\tg_free (module);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tmodule->handle = lib;\n\tmodule->dl_fallback = dl_fallback;\n\treturn module;\n}\n\n/**\n * mono_dl_symbol:\n * \\param module a MonoDl pointer\n * \\param name symbol name\n * \\param symbol pointer for the result value\n * Load the address of symbol \\p name from the given \\p module.\n * The address is stored in the pointer pointed to by \\p symbol.\n * \\returns NULL on success, an error message on failure\n */\nchar*\nmono_dl_symbol (MonoDl *module, const char *name, void **symbol)\n{\n\tvoid *sym;\n\tchar *err = NULL;\n\n\tif (module->dl_fallback) {\n\t\tsym = module->dl_fallback->symbol_func (module->handle, name, &err, module->dl_fallback->user_data);\n\t} else {\n#if MONO_DL_NEED_USCORE\n\t\t{\n\t\t\tconst size_t length = strlen (name);\n\t\t\tchar *usname = g_new (char, length + 2);\n\t\t\t*usname = '_';\n\t\t\tmemcpy (usname + 1, name, length + 1);\n\t\t\tsym = mono_dl_lookup_symbol (module, usname);\n\t\t\tg_free (usname);\n\t\t}\n#else\n\t\tsym = mono_dl_lookup_symbol (module, name);\n#endif\n\t}\n\n\tif (sym) {\n\t\tif (symbol)\n\t\t\t*symbol = sym;\n\t\treturn NULL;\n\t}\n\tif (symbol)\n\t\t*symbol = NULL;\n\treturn (module->dl_fallback != NULL) ? err :  mono_dl_current_error_string ();\n}\n\n/**\n * mono_dl_close:\n * \\param module a \\c MonoDl pointer\n * Unload the given module and free the module memory.\n * \\returns \\c 0 on success.\n */\nvoid\nmono_dl_close (MonoDl *module)\n{\n\tMonoDlFallbackHandler *dl_fallback = module->dl_fallback;\n\t\n\tif (dl_fallback){\n\t\tif (dl_fallback->close_func != NULL)\n\t\t\tdl_fallback->close_func (module->handle, dl_fallback->user_data);\n\t} else\n\t\tmono_dl_close_handle (module);\n\t\n\tg_free (module);\n}\n\n/**\n * mono_dl_build_path:\n * \\param directory optional directory\n * \\param name base name of the library\n * \\param iter iterator token\n * Given a directory name and the base name of a library, iterate\n * over the possible file names of the library, taking into account\n * the possible different suffixes and prefixes on the host platform.\n *\n * The returned file name must be freed by the caller.\n * \\p iter must point to a NULL pointer the first time the function is called\n * and then passed unchanged to the following calls.\n * \\returns the filename or NULL at the end of the iteration\n */\nchar*\nmono_dl_build_path (const char *directory, const char *name, void **iter)\n{\n\tint idx;\n\tconst char *prefix;\n\tconst char *suffix;\n\tgboolean need_prefix = TRUE, need_suffix = TRUE;\n\tint prlen;\n\tint suffixlen;\n\tchar *res;\n\tint iteration;\n\n\tif (!iter)\n\t\treturn NULL;\n\n\t/*\n\t  The first time we are called, idx = 0 (as *iter is initialized to NULL). This is our\n\t  \"bootstrap\" phase in which we check the passed name verbatim and only if we fail to find\n\t  the dll thus named, we start appending suffixes, each time increasing idx twice (since now\n\t  the 0 value became special and we need to offset idx to a 0-based array index). This is\n\t  done to handle situations when mapped dll name is specified as libsomething.so.1 or\n\t  libsomething.so.1.1 or libsomething.so - testing it algorithmically would be an overkill\n\t  here.\n\t */\n\titeration = GPOINTER_TO_UINT (*iter);\n\tidx = iteration;\n\tif (idx == 0) {\n\t\t/* Name */\n\t\tneed_prefix = FALSE;\n\t\tneed_suffix = FALSE;\n\t\tsuffix = \"\";\n\t} else if (idx == 1) {\n#ifdef ENABLE_NETCORE\n\t\t/* netcore system libs have a suffix but no prefix */\n\t\tneed_prefix = FALSE;\n\t\tneed_suffix = TRUE;\n\t\tsuffix = mono_dl_get_so_suffixes () [0];\n\t\tsuffixlen = strlen (suffix);\n#else\n\t\tsuffix = mono_dl_get_so_suffixes () [idx - 1];\n\t\tif (suffix [0] == '\\0')\n\t\t\treturn NULL;\n#endif\n\t} else {\n\t\t/* Prefix.Name.suffix */\n\t\tsuffix = mono_dl_get_so_suffixes () [idx - 2];\n\t\tif (suffix [0] == '\\0')\n\t\t\treturn NULL;\n\t}\n\n\tif (need_prefix) {\n\t\tprlen = strlen (mono_dl_get_so_prefix ());\n\t\tif (prlen && strncmp (name, mono_dl_get_so_prefix (), prlen) != 0)\n\t\t\tprefix = mono_dl_get_so_prefix ();\n\t\telse\n\t\t\tprefix = \"\";\n\t} else {\n\t\tprefix = \"\";\n\t}\n\n\tsuffixlen = strlen (suffix);\n\tif (need_suffix && (suffixlen && strstr (name, suffix) == (name + strlen (name) - suffixlen)))\n\t\tsuffix = \"\";\n\n\tif (directory && *directory)\n\t\tres = g_strconcat (directory, G_DIR_SEPARATOR_S, prefix, name, suffix, (const char*)NULL);\n\telse\n\t\tres = g_strconcat (prefix, name, suffix, (const char*)NULL);\n\t++iteration;\n\t*iter = GUINT_TO_POINTER (iteration);\n\treturn res;\n}\n\nMonoDlFallbackHandler *\nmono_dl_fallback_register (MonoDlFallbackLoad load_func, MonoDlFallbackSymbol symbol_func, MonoDlFallbackClose close_func, void *user_data)\n{\n\tMonoDlFallbackHandler *handler = NULL;\n\tif (load_func == NULL || symbol_func == NULL)\n\t\tgoto leave;\n\n\thandler = g_new (MonoDlFallbackHandler, 1);\n\thandler->load_func = load_func;\n\thandler->symbol_func = symbol_func;\n\thandler->close_func = close_func;\n\thandler->user_data = user_data;\n\n\tfallback_handlers = g_slist_prepend (fallback_handlers, handler);\n\t\nleave:\n\treturn handler;\n}\n\nvoid\nmono_dl_fallback_unregister (MonoDlFallbackHandler *handler)\n{\n\tGSList *found;\n\n\tfound = g_slist_find (fallback_handlers, handler);\n\tif (found == NULL)\n\t\treturn;\n\n\tg_slist_remove (fallback_handlers, handler);\n\tg_free (handler);\n}\n\nstatic MonoDl*\ntry_load (const char *lib_name, char *dir, int flags, char **err)\n{\n\tgpointer iter;\n\tMonoDl *runtime_lib;\n\tchar *path;\n\titer = NULL;\n\t*err = NULL;\n\twhile ((path = mono_dl_build_path (dir, lib_name, &iter))) {\n\t\tg_free (*err);\n\t\truntime_lib = mono_dl_open (path, flags, err);\n\t\tg_free (path);\n\t\tif (runtime_lib)\n\t\t\treturn runtime_lib;\n\t}\n\treturn NULL;\n}\n\nMonoDl*\nmono_dl_open_runtime_lib (const char* lib_name, int flags, char **error_msg)\n{\n\tMonoDl *runtime_lib = NULL;\n\tchar buf [4096];\n\tint binl;\n\t*error_msg = NULL;\n\n\tbinl = mono_dl_get_executable_path (buf, sizeof (buf));\n\n\tif (binl != -1) {\n\t\tchar *base;\n\t\tchar *resolvedname, *name;\n\t\tchar *baseparent = NULL;\n\t\tbuf [binl] = 0;\n\t\tresolvedname = mono_path_resolve_symlinks (buf);\n\t\tbase = g_path_get_dirname (resolvedname);\n\t\tname = g_strdup_printf (\"%s/.libs\", base);\n\t\truntime_lib = try_load (lib_name, name, flags, error_msg);\n\t\tg_free (name);\n\t\tif (!runtime_lib)\n\t\t\tbaseparent = g_path_get_dirname (base);\n\t\tif (!runtime_lib) {\n\t\t\tname = g_strdup_printf (\"%s/lib\", baseparent);\n\t\t\truntime_lib = try_load (lib_name, name, flags, error_msg);\n\t\t\tg_free (name);\n\t\t}\n#ifdef __MACH__\n\t\tif (!runtime_lib) {\n\t\t\tname = g_strdup_printf (\"%s/Libraries\", baseparent);\n\t\t\truntime_lib = try_load (lib_name, name, flags, error_msg);\n\t\t\tg_free (name);\n\t\t}\n#endif\n\t\tif (!runtime_lib) {\n\t\t\tname = g_strdup_printf (\"%s/profiler/.libs\", baseparent);\n\t\t\truntime_lib = try_load (lib_name, name, flags, error_msg);\n\t\t\tg_free (name);\n\t\t}\n\t\tg_free (base);\n\t\tg_free (resolvedname);\n\t\tg_free (baseparent);\n\t}\n\tif (!runtime_lib)\n\t\truntime_lib = try_load (lib_name, NULL, flags, error_msg);\n\n\treturn runtime_lib;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mono/tests/libtest.c": "#include <config.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n#include <gmodule.h>\n#include <errno.h>\n#include <time.h>\n#include <math.h>\n#include <setjmp.h>\n#include \"../utils/mono-errno.h\"\n#include \"../utils/mono-compiler.h\"\n\n#ifndef HOST_WIN32\n#include <dlfcn.h>\n#endif\n\n#ifdef WIN32\n#include <windows.h>\n#include \"initguid.h\"\n#else\n#include <pthread.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef WIN32\n#define STDCALL __stdcall\n#else\n#define STDCALL\n#define __thiscall /* nothing */\n#endif\n\n#ifdef __GNUC__\n#pragma GCC diagnostic ignored \"-Wmissing-prototypes\"\n#endif\n\n#ifdef WIN32\nextern __declspec(dllimport) void __stdcall CoTaskMemFree(void *ptr);\n#endif\n\ntypedef int (STDCALL *SimpleDelegate) (int a);\n\n#if defined(WIN32) && defined (_MSC_VER)\n#define LIBTEST_API __declspec(dllexport)\n#elif defined(__GNUC__)\n#define LIBTEST_API  __attribute__ ((__visibility__ (\"default\")))\n#else\n#define LIBTEST_API\n#endif\n\nstatic void marshal_free (void *ptr)\n{\n#ifdef WIN32\n\tCoTaskMemFree (ptr);\n#else\n\tg_free (ptr);\n#endif\n}\n\nstatic void* marshal_alloc (gsize size)\n{\n#ifdef WIN32\n\treturn CoTaskMemAlloc (size);\n#else\n\treturn g_malloc (size);\n#endif\n}\n\nstatic void* marshal_alloc0 (gsize size)\n{\n#ifdef WIN32\n\tvoid* ptr = CoTaskMemAlloc (size);\n\tmemset(ptr, 0, size);\n\treturn ptr;\n#else\n\treturn g_malloc0 (size);\n#endif\n}\n\nstatic char* marshal_strdup (const char *str)\n{\n#ifdef WIN32\n\tif (!str)\n\t\treturn NULL;\n\n\tchar *buf = (char *) CoTaskMemAlloc (strlen (str) + 1);\n\treturn strcpy (buf, str);\n#else\n\treturn g_strdup (str);\n#endif\n}\n\nstatic gunichar2* marshal_bstr_alloc(const gchar* str)\n{\n#ifdef WIN32\n\tgunichar2* temp = g_utf8_to_utf16 (str, -1, NULL, NULL, NULL);\n\tgunichar2* ret = SysAllocString (temp);\n\tg_free (temp);\n\treturn ret;\n#else\n\tgchar* ret = NULL;\n\tint slen = strlen (str);\n\tgunichar2* temp;\n\t/* allocate len + 1 utf16 characters plus 4 byte integer for length*/\n\tret = (gchar *)g_malloc ((slen + 1) * sizeof(gunichar2) + sizeof(guint32));\n\tif (ret == NULL)\n\t\treturn NULL;\n\ttemp = g_utf8_to_utf16 (str, -1, NULL, NULL, NULL);\n\tmemcpy (ret + sizeof(guint32), temp, slen * sizeof(gunichar2));\n\t* ((guint32 *) ret) = slen * sizeof(gunichar2);\n\tret [4 + slen * sizeof(gunichar2)] = 0;\n\tret [5 + slen * sizeof(gunichar2)] = 0;\n\n\treturn (gunichar2*)(ret + 4);\n#endif\n}\n\n#define marshal_new0(type,size)       ((type *) marshal_alloc0 (sizeof (type)* (size)))\n\nLIBTEST_API int STDCALL\nmono_cominterop_is_supported (void)\n{\n#if defined(TARGET_X86) || defined(TARGET_AMD64)\n\treturn 1;\n#endif\n\treturn 0;\n}\n\nLIBTEST_API unsigned short* STDCALL\ntest_lpwstr_marshal (unsigned short* chars, int length)\n{\n\tint i = 0;\n\tunsigned short *res;\n\n\tres = (unsigned short *)marshal_alloc (2 * (length + 1));\n\n\t// printf(\"test_lpwstr_marshal()\\n\");\n\t\n\twhile ( i < length ) {\n\t\t// printf(\"X|%u|\\n\", chars[i]);\n\t\tres [i] = chars[i];\n\t\ti++;\n\t}\n\n\tres [i] = 0;\n\n\treturn res;\n}\n\n\nLIBTEST_API void STDCALL\ntest_lpwstr_marshal_out (unsigned short** chars)\n{\n\tint i = 0;\n\tconst char abc[] = \"ABC\";\n\tglong len = strlen(abc);\n\n\t*chars = (unsigned short *)marshal_alloc (2 * (len + 1));\n\t\n\twhile ( i < len ) {\n\t\t(*chars) [i] = abc[i];\n\t\ti++;\n\t}\n\n\t(*chars) [i] = 0;\n}\n\ntypedef struct {\n\tint b;\n\tint a;\n\tint c;\n} union_test_1_type;\n\nLIBTEST_API int STDCALL  \nmono_union_test_1 (union_test_1_type u1) {\n\t// printf (\"Got values %d %d %d\\n\", u1.b, u1.a, u1.c);\n\treturn u1.a + u1.b + u1.c;\n}\n\nLIBTEST_API int STDCALL  \nmono_return_int (int a) {\n\t// printf (\"Got value %d\\n\", a);\n\treturn a;\n}\n\nLIBTEST_API float STDCALL  \nmono_test_marshal_pass_return_float (float f) {\n\treturn f + 1.0;\n}\n\nstruct ss\n{\n\tint i;\n};\n\nLIBTEST_API int STDCALL \nmono_return_int_ss (struct ss a) {\n\t// printf (\"Got value %d\\n\", a.i);\n\treturn a.i;\n}\n\nLIBTEST_API struct ss STDCALL\nmono_return_ss (struct ss a) {\n\t// printf (\"Got value %d\\n\", a.i);\n\ta.i++;\n\treturn a;\n}\n\nstruct sc1\n{\n\tchar c[1];\n};\n\nLIBTEST_API struct sc1 STDCALL\nmono_return_sc1 (struct sc1 a) {\n\t// printf (\"Got value %d\\n\", a.c[0]);\n\ta.c[0]++;\n\treturn a;\n}\n\n\nstruct sc3\n{\n\tchar c[3];\n};\n\nLIBTEST_API struct sc3 STDCALL \nmono_return_sc3 (struct sc3 a) {\n\t// printf (\"Got values %d %d %d\\n\", a.c[0], a.c[1], a.c[2]);\n\ta.c[0]++;\n\ta.c[1] += 2;\n\ta.c[2] += 3;\n\treturn a;\n}\n\nstruct sc5\n{\n\tchar c[5];\n};\n\nLIBTEST_API struct sc5 STDCALL \nmono_return_sc5 (struct sc5 a) {\n\t// printf (\"Got values %d %d %d %d %d\\n\", a.c[0], a.c[1], a.c[2], a.c[3], a.c[4]);\n\ta.c[0]++;\n\ta.c[1] += 2;\n\ta.c[2] += 3;\n\ta.c[3] += 4;\n\ta.c[4] += 5;\n\treturn a;\n}\n\nunion su\n{\n\tint i1;\n\tint i2;\n};\n\nLIBTEST_API int STDCALL  \nmono_return_int_su (union su a) {\n\t// printf (\"Got value %d\\n\", a.i1);\n\treturn a.i1;\n}\n\nstruct FI {\n\tfloat f1;\n\tfloat f2;\n\tfloat f3;\n};\n\nstruct NestedFloat {\n\tstruct FI fi;\n\tfloat f4;\n};\n\nLIBTEST_API struct NestedFloat STDCALL\nmono_return_nested_float (void)\n{\n\tstruct NestedFloat f;\n\tf.fi.f1 = 1.0;\n\tf.fi.f2 = 2.0;\n\tf.fi.f3 = 3.0;\n\tf.f4 = 4.0;\n\treturn f;\n}\n\nstruct Scalar4 {\n\tdouble val[4];\n};\n\nstruct Rect {\n\tint x;\n\tint y;\n\tint width;\n\tint height;\n};\n\nLIBTEST_API char * STDCALL\nmono_return_struct_4_double (void *ptr, struct Rect rect, struct Scalar4 sc4, int a, int b, int c)\n{\n\tchar *buffer = (char *)marshal_alloc (1024 * sizeof (char));\n\tsprintf (buffer, \"sc4 = {%.1f, %.1f, %.1f, %.1f }, a=%x, b=%x, c=%x\\n\", (float) sc4.val [0], (float) sc4.val [1], (float) sc4.val [2], (float) sc4.val [3], a, b, c);\n\treturn buffer;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_many_int_arguments (int a, int b, int c, int d, int e,\n\t\t\t\t\t\t\t  int f, int g, int h, int i, int j);\nLIBTEST_API short STDCALL \nmono_test_many_short_arguments (short a, short b, short c, short d, short e,\n\t\t\t\t\t\t\t\tshort f, short g, short h, short i, short j);\nLIBTEST_API char STDCALL \nmono_test_many_char_arguments (char a, char b, char c, char d, char e,\n\t\t\t\t\t\t\t   char f, char g, char h, char i, char j);\n\nLIBTEST_API int STDCALL \nmono_test_many_int_arguments (int a, int b, int c, int d, int e, int f, int g, int h, int i, int j)\n{\n\treturn a + b + c + d + e + f + g + h + i + j;\n}\n\nLIBTEST_API short STDCALL \nmono_test_many_short_arguments (short a, short b, short c, short d, short e, short f, short g, short h, short i, short j)\n{\n\treturn a + b + c + d + e + f + g + h + i + j;\n}\n\nLIBTEST_API char STDCALL \nmono_test_many_byte_arguments (char a, char b, char c, char d, char e, char f, char g, char h, char i, char j)\n{\n\treturn a + b + c + d + e + f + g + h + i + j;\n}\n\nLIBTEST_API float STDCALL \nmono_test_many_float_arguments (float a, float b, float c, float d, float e, float f, float g, float h, float i, float j)\n{\n\treturn a + b + c + d + e + f + g + h + i + j;\n}\n\nLIBTEST_API double STDCALL \nmono_test_many_double_arguments (double a, double b, double c, double d, double e, double f, double g, double h, double i, double j)\n{\n\treturn a + b + c + d + e + f + g + h + i + j;\n}\n\nLIBTEST_API double STDCALL \nmono_test_split_double_arguments (double a, double b, float c, double d, double e)\n{\n\treturn a + b + c + d + e;\n}\n\nLIBTEST_API int STDCALL \nmono_test_puts_static (char *s)\n{\n\t// printf (\"TEST %s\\n\", s);\n\treturn 1;\n}\n\ntypedef int (STDCALL *SimpleDelegate3) (int a, int b);\n\nLIBTEST_API int STDCALL \nmono_invoke_delegate (SimpleDelegate3 delegate)\n{\n\tint res;\n\n\t// printf (\"start invoke %p\\n\", delegate);\n\n\tres = delegate (2, 3);\n\n\t// printf (\"end invoke\\n\");\n\n\treturn res;\n}\n\nLIBTEST_API int STDCALL\nmono_invoke_simple_delegate (SimpleDelegate d)\n{\n\treturn d (4);\n}\n\nLIBTEST_API int STDCALL  \nmono_test_marshal_char (short a1)\n{\n\tif (a1 == 'a')\n\t\treturn 0;\n\t\n\treturn 1;\n}\n\nLIBTEST_API void STDCALL\nmono_test_marshal_char_array (gunichar2 *s)\n{\n\tconst char m[] = \"abcdef\";\n\tgunichar2* s2;\n\tglong len;\n\n\ts2 = g_utf8_to_utf16 (m, -1, NULL, &len, NULL);\n\t\n\tlen = (len * 2) + 2;\n\tmemcpy (s, s2, len);\n\n\tg_free (s2);\n}\n\nLIBTEST_API int STDCALL\nmono_test_marshal_ansi_char_array (char *s)\n{\n\tconst char m[] = \"abcdef\";\n\n\tif (strncmp (\"qwer\", s, 4))\n\t\treturn 1;\n\n\tmemcpy (s, m, sizeof (m));\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL\nmono_test_marshal_unicode_char_array (gunichar2 *s)\n{\n\tconst char m[] = \"abcdef\";\n\tconst char expected[] = \"qwer\";\n\tgunichar2 *s1, *s2;\n\tglong len1, len2;\n\n\ts1 = g_utf8_to_utf16 (m, -1, NULL, &len1, NULL);\n\ts2 = g_utf8_to_utf16 (expected, -1, NULL, &len2, NULL);\n\tlen1 = (len1 * 2);\n\tlen2 = (len2 * 2);\n\n\tif (memcmp (s, s2, len2))\n\t\treturn 1;\n\n\tmemcpy (s, s1, len1);\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_empty_pinvoke (int i)\n{\n\treturn i;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_marshal_bool_byref (int a, int *b, int c)\n{\n    int res = *b;\n\n\t*b = 1;\n\n\treturn res;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_bool_in_as_I1_U1 (char bTrue, char bFalse)\n{\n\tif (!bTrue)\n                return 1;\n\tif (bFalse)\n                return 2;\n        return 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_bool_out_as_I1_U1 (char* bTrue, char* bFalse)\n{\n        if (!bTrue || !bFalse)\n\t\treturn 3;\n\n\t*bTrue = 1;\n\t*bFalse = 0;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_bool_ref_as_I1_U1 (char* bTrue, char* bFalse)\n{\n\tif (!bTrue || !bFalse)\n                return 4;\n\n\tif (!(*bTrue))\n                return 5;\n        if (*bFalse)\n                return 6;\n\n\t*bFalse = 1;\n        *bTrue = 0;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_marshal_array (int *a1)\n{\n\tint i, sum = 0;\n\n\tfor (i = 0; i < 50; i++)\n\t\tsum += a1 [i];\n\t\n\treturn sum;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_marshal_inout_array (int *a1)\n{\n\tint i, sum = 0;\n\n\tfor (i = 0; i < 50; i++) {\n\t\tsum += a1 [i];\n\t\ta1 [i] = 50 - a1 [i];\n\t}\n\t\n\treturn sum;\n}\n\nLIBTEST_API int /* cdecl */\nmono_test_marshal_inout_array_cdecl (int *a1)\n{\n\treturn mono_test_marshal_inout_array (a1);\n}\n\nLIBTEST_API int STDCALL  \nmono_test_marshal_out_array (int *a1)\n{\n\tint i;\n\n\tfor (i = 0; i < 50; i++) {\n\t\ta1 [i] = i;\n\t}\n\t\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL\nmono_test_marshal_out_byref_array_out_size_param (int **out_arr, int *out_len)\n{\n\tint *arr;\n\tint i, len;\n\n\tlen = 4;\n\tarr = (gint32 *)marshal_alloc (sizeof (gint32) * len);\n\tfor (i = 0; i < len; ++i)\n\t\tarr [i] = i;\n\t*out_arr = arr;\n\t*out_len = len;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL\nmono_test_marshal_out_lparray_out_size_param (int *arr, int *out_len)\n{\n\tint i, len;\n\n\tlen = 4;\n\tfor (i = 0; i < len; ++i)\n\t\tarr [i] = i;\n\t*out_len = len;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_marshal_inout_nonblittable_array (gunichar2 *a1)\n{\n\tint i, sum = 0;\n\n\tfor (i = 0; i < 10; i++) {\n\t\ta1 [i] = 'F';\n\t}\n\t\n\treturn sum;\n}\n\ntypedef struct {\n\tint a;\n\tint b;\n\tint c;\n\tconst char *d;\n\tgunichar2 *d2;\n} simplestruct;\n\ntypedef struct {\n\tdouble x;\n\tdouble y;\n} point;\n\nLIBTEST_API simplestruct STDCALL \nmono_test_return_vtype (int i)\n{\n\tsimplestruct res;\n\tstatic gunichar2 test2 [] = { 'T', 'E', 'S', 'T', '2', 0 };\n\n\tres.a = 0;\n\tres.b = 1;\n\tres.c = 0;\n\tres.d = \"TEST\";\n\tres.d2 = test2;\n\n\treturn res;\n}\n\nLIBTEST_API void STDCALL\nmono_test_delegate_struct (void)\n{\n\t// printf (\"TEST\\n\");\n}\n\ntypedef char* (STDCALL *ReturnStringDelegate) (const char *s);\n\nLIBTEST_API char * STDCALL \nmono_test_return_string (ReturnStringDelegate func)\n{\n\tchar *res;\n\n\t// printf (\"mono_test_return_string\\n\");\n\n\tres = func (\"TEST\");\n\tmarshal_free (res);\n\n\t// printf (\"got string: %s\\n\", res);\n\treturn marshal_strdup (\"12345\");\n}\n\ntypedef int (STDCALL *RefVTypeDelegate) (int a, simplestruct *ss, int b);\n\nLIBTEST_API int STDCALL \nmono_test_ref_vtype (int a, simplestruct *ss, int b, RefVTypeDelegate func)\n{\n\tif (a == 1 && b == 2 && ss->a == 0 && ss->b == 1 && ss->c == 0 &&\n\t    !strcmp (ss->d, \"TEST1\")) {\n\t\tss->a = 1;\n\t\tss->b = 0;\n\t\tss->c = 1;\n\t\tss->d = \"TEST2\";\n\n\t\treturn func (a, ss, b);\n\t}\n\n\treturn 1;\n}\n\ntypedef int (STDCALL *OutVTypeDelegate) (int a, simplestruct *ss, int b);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_out_struct (int a, simplestruct *ss, int b, OutVTypeDelegate func)\n{\n\t/* Check that the input pointer is ignored */\n\tss->d = (const char *)0x12345678;\n\n\tfunc (a, ss, b);\n\n\tif (ss->a && ss->b && ss->c && !strcmp (ss->d, \"TEST3\"))\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\ntypedef int (STDCALL *InVTypeDelegate) (int a, simplestruct *ss, int b);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_in_struct (int a, simplestruct *ss, int b, InVTypeDelegate func)\n{\n\tsimplestruct ss2;\n\tint res;\n\n\tmemcpy (&ss2, ss, sizeof (simplestruct));\n\n\tres = func (a, ss, b);\n\tif (res) {\n\t\tprintf (\"mono_test_marshal_in_struct () failed: %d\\n\", res);\n\t\treturn 1;\n\t}\n\n\t/* Check that no modifications is made to the struct */\n\tif (ss2.a == ss->a && ss2.b == ss->b && ss2.c == ss->c && ss2.d == ss->d)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\ntypedef struct {\n\tint a;\n\tSimpleDelegate func, func2, func3;\n} DelegateStruct;\n\nLIBTEST_API DelegateStruct STDCALL \nmono_test_marshal_delegate_struct (DelegateStruct ds)\n{\n\tDelegateStruct res;\n\n\tres.a = ds.func (ds.a) + ds.func2 (ds.a) + (ds.func3 == NULL ? 0 : 1);\n\tres.func = ds.func;\n\tres.func2 = ds.func2;\n\tres.func3 = NULL;\n\n\treturn res;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_marshal_struct (simplestruct ss)\n{\n\tif (ss.a == 0 && ss.b == 1 && ss.c == 0 &&\n\t    !strcmp (ss.d, \"TEST\"))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_byref_struct (simplestruct *ss, int a, int b, int c, char *d)\n{\n\tgboolean res = (ss->a == a && ss->b == b && ss->c == c && strcmp (ss->d, d) == 0);\n\n\tmarshal_free ((char*)ss->d);\n\n\tss->a = !ss->a;\n\tss->b = !ss->b;\n\tss->c = !ss->c;\n\tss->d = marshal_strdup (\"DEF\");\n\n\treturn res ? 0 : 1;\n}\n\ntypedef struct {\n\tint a;\n\tint b;\n\tint c;\n\tchar *d;\n\tunsigned char e;\n\tdouble f;\n\tunsigned char g;\n\tguint64 h;\n} simplestruct2;\n\nLIBTEST_API int STDCALL \nmono_test_marshal_struct2 (simplestruct2 ss)\n{\n\tif (ss.a == 0 && ss.b == 1 && ss.c == 0 &&\n\t    !strcmp (ss.d, \"TEST\") && \n\t    ss.e == 99 && ss.f == 1.5 && ss.g == 42 && ss.h == (guint64)123)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/* on HP some of the struct should be on the stack and not in registers */\nLIBTEST_API int STDCALL \nmono_test_marshal_struct2_2 (int i, int j, int k, simplestruct2 ss)\n{\n\tif (i != 10 || j != 11 || k != 12)\n\t\treturn 1;\n\tif (ss.a == 0 && ss.b == 1 && ss.c == 0 &&\n\t    !strcmp (ss.d, \"TEST\") && \n\t    ss.e == 99 && ss.f == 1.5 && ss.g == 42 && ss.h == (guint64)123)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_marshal_lpstruct (simplestruct *ss)\n{\n\tif (ss->a == 0 && ss->b == 1 && ss->c == 0 &&\n\t    !strcmp (ss->d, \"TEST\"))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_marshal_lpstruct_blittable (point *p)\n{\n\tif (p->x == 1.0 && p->y == 2.0)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_struct_array (simplestruct2 *ss)\n{\n\tif (! (ss[0].a == 0 && ss[0].b == 1 && ss[0].c == 0 &&\n\t\t   !strcmp (ss[0].d, \"TEST\") && \n\t\t   ss[0].e == 99 && ss[0].f == 1.5 && ss[0].g == 42 && ss[0].h == (guint64)123))\n\t\treturn 1;\n\n\tif (! (ss[1].a == 0 && ss[1].b == 0 && ss[1].c == 0 &&\n\t\t   !strcmp (ss[1].d, \"TEST2\") && \n\t\t   ss[1].e == 100 && ss[1].f == 2.5 && ss[1].g == 43 && ss[1].h == (guint64)124))\n\t\treturn 1;\n\n\treturn 0;\n}\n\ntypedef struct long_align_struct {\n\tgint32 a;\n\tgint64 b;\n\tgint64 c;\n} long_align_struct;\n\nLIBTEST_API int STDCALL \nmono_test_marshal_long_align_struct_array (long_align_struct *ss)\n{\n\treturn ss[0].a + ss[0].b + ss[0].c + ss[1].a + ss[1].b + ss[1].c;\n}\n\nLIBTEST_API simplestruct2 * STDCALL \nmono_test_marshal_class (int i, int j, int k, simplestruct2 *ss, int l)\n{\n\tsimplestruct2 *res;\n\n\tif (!ss)\n\t\treturn NULL;\n\n\tif (i != 10 || j != 11 || k != 12 || l != 14)\n\t\treturn NULL;\n\tif (! (ss->a == 0 && ss->b == 1 && ss->c == 0 &&\n\t\t   !strcmp (ss->d, \"TEST\") && \n\t\t   ss->e == 99 && ss->f == 1.5 && ss->g == 42 && ss->h == (guint64)123))\n\t\treturn NULL;\n\n\tres = marshal_new0 (simplestruct2, 1);\n\tmemcpy (res, ss, sizeof (simplestruct2));\n\tres->d = marshal_strdup (\"TEST\");\n\treturn res;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_byref_class (simplestruct2 **ssp)\n{\n\tsimplestruct2 *ss = *ssp;\n\tsimplestruct2 *res;\n\t\n\tif (! (ss->a == 0 && ss->b == 1 && ss->c == 0 &&\n\t\t   !strcmp (ss->d, \"TEST\") && \n\t\t   ss->e == 99 && ss->f == 1.5 && ss->g == 42 && ss->h == (guint64)123))\n\t\treturn 1;\n\n\tres = marshal_new0 (simplestruct2, 1);\n\tmemcpy (res, ss, sizeof (simplestruct2));\n\tres->d = marshal_strdup (\"TEST-RES\");\n\n\t*ssp = res;\n\treturn 0;\n}\n\nstatic void *\nget_sp (void)\n{\n\tint i;\n\tvoid *p;\n\n\t/* Yes, this is correct, we are only trying to determine the value of the stack here */\n\tp = &i;\n\treturn p;\n}\n\nLIBTEST_API int STDCALL \nreliable_delegate (int a)\n{\n\treturn a;\n}\n\n/*\n * Checks whether get_sp() works as expected. It doesn't work with gcc-2.95.3 on linux.\n */\nstatic gboolean\nis_get_sp_reliable (void)\n{\n\tvoid *sp1, *sp2;\n\n\treliable_delegate(1);\n\tsp1 = get_sp();\n\treliable_delegate(1);\n\tsp2 = get_sp();\n\treturn sp1 == sp2;\n} \n\nLIBTEST_API int STDCALL \nmono_test_marshal_delegate (SimpleDelegate delegate)\n{\n\tvoid *sp1, *sp2;\n\n\t/* Check that the delegate wrapper is stdcall */\n\tdelegate (2);\n\tsp1 = get_sp ();\n\tdelegate (2);\n\tsp2 = get_sp ();\n\tif (is_get_sp_reliable())\n\t\tg_assert (sp1 == sp2);\n\n\treturn delegate (2);\n}\n\nstatic int STDCALL inc_cb (int i)\n{\n\treturn i + 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_out_delegate (SimpleDelegate *delegate)\n{\n\t*delegate = inc_cb;\n\n\treturn 0;\n}\n\nLIBTEST_API SimpleDelegate STDCALL \nmono_test_marshal_return_delegate (SimpleDelegate delegate)\n{\n\treturn delegate;\n}\n\ntypedef int (STDCALL *DelegateByrefDelegate) (void *);\n\nLIBTEST_API int STDCALL\nmono_test_marshal_delegate_ref_delegate (DelegateByrefDelegate del)\n{\n\tint (STDCALL *ptr) (int i);\n\n\tdel (&ptr);\n\n\treturn ptr (54);\n}\n\nstatic int STDCALL\nreturn_plus_one (int i)\n{\n\treturn i + 1;\n}\n\nLIBTEST_API SimpleDelegate STDCALL \nmono_test_marshal_return_delegate_2 (void)\n{\n\treturn return_plus_one;\n}\n\ntypedef simplestruct (STDCALL *SimpleDelegate2) (simplestruct ss);\n\nstatic gboolean\nis_utf16_equals (gunichar2 *s1, const char *s2)\n{\n\tchar *s;\n\tint res;\n\n\ts = g_utf16_to_utf8 (s1, -1, NULL, NULL, NULL);\n\tres = strcmp (s, s2);\n\tg_free (s);\n\n\treturn res == 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_delegate2 (SimpleDelegate2 delegate)\n{\n\tsimplestruct ss, res;\n\n\tss.a = 0;\n\tss.b = 1;\n\tss.c = 0;\n\tss.d = \"TEST\";\n\tss.d2 = g_utf8_to_utf16 (\"TEST2\", -1, NULL, NULL, NULL); \n\n\tres = delegate (ss);\n\tif (! (res.a && !res.b && res.c && !strcmp (res.d, \"TEST-RES\") && is_utf16_equals (res.d2, \"TEST2-RES\")))\n\t\treturn 1;\n\n\treturn 0;\n}\n\ntypedef simplestruct* (STDCALL *SimpleDelegate4) (simplestruct *ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_delegate4 (SimpleDelegate4 delegate)\n{\n\tsimplestruct ss;\n\tsimplestruct *res;\n\n\tss.a = 0;\n\tss.b = 1;\n\tss.c = 0;\n\tss.d = \"TEST\";\n\n\t/* Check argument */\n\tres = delegate (&ss);\n\tif (!res)\n\t\treturn 1;\n\n\t/* Check return value */\n\tif (! (!res->a && res->b && !res->c && !strcmp (res->d, \"TEST\")))\n\t\treturn 2;\n\n\t/* Check NULL argument and NULL result */\n\tres = delegate (NULL);\n\tif (res)\n\t\treturn 3;\n\n\treturn 0;\n}\n\ntypedef int (STDCALL *SimpleDelegate5) (simplestruct **ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_delegate5 (SimpleDelegate5 delegate)\n{\n\tsimplestruct ss;\n\tint res;\n\tsimplestruct *ptr;\n\n\tss.a = 0;\n\tss.b = 1;\n\tss.c = 0;\n\tss.d = \"TEST\";\n\n\tptr = &ss;\n\n\tres = delegate (&ptr);\n\tif (res != 0)\n\t\treturn 1;\n\n\tif (!(ptr->a && !ptr->b && ptr->c && !strcmp (ptr->d, \"RES\")))\n\t\treturn 2;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_delegate6 (SimpleDelegate5 delegate)\n{\n\tdelegate (NULL);\n\treturn 0;\n}\n\ntypedef int (STDCALL *SimpleDelegate7) (simplestruct **ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_delegate7 (SimpleDelegate7 delegate)\n{\n\tint res;\n\tsimplestruct *ptr;\n\n\t/* Check that the input pointer is ignored */\n\tptr = (simplestruct *)0x12345678;\n\n\tres = delegate (&ptr);\n\tif (res != 0)\n\t\treturn 1;\n\n\tif (!(ptr->a && !ptr->b && ptr->c && !strcmp (ptr->d, \"RES\")))\n\t\treturn 2;\n\n\treturn 0;\n}\n\ntypedef int (STDCALL *InOutByvalClassDelegate) (simplestruct *ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_inout_byval_class_delegate (InOutByvalClassDelegate delegate)\n{\n\tint res;\n\tsimplestruct ss;\n\n\tss.a = FALSE;\n\tss.b = TRUE;\n\tss.c = FALSE;\n\tss.d = g_strdup_printf (\"%s\", \"FOO\");\n\n\tres = delegate (&ss);\n\tif (res != 0)\n\t\treturn 1;\n\n\tif (!(ss.a && !ss.b && ss.c && !strcmp (ss.d, \"RES\")))\n\t\treturn 2;\n\n\treturn 0;\n}\n\ntypedef int (STDCALL *SimpleDelegate8) (gunichar2 *s);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_delegate8 (SimpleDelegate8 delegate, gunichar2 *s)\n{\n\treturn delegate (s);\n}\n\ntypedef int (STDCALL *return_int_fnt) (int i);\ntypedef int (STDCALL *SimpleDelegate9) (return_int_fnt d);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_delegate9 (SimpleDelegate9 delegate, gpointer ftn)\n{\n\treturn delegate ((return_int_fnt)ftn);\n}\n\nstatic int STDCALL \nreturn_self (int i)\n{\n\treturn i;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_delegate10 (SimpleDelegate9 delegate)\n{\n\treturn delegate (return_self);\n}\n\ntypedef int (STDCALL *PrimitiveByrefDelegate) (int *i);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_primitive_byref_delegate (PrimitiveByrefDelegate delegate)\n{\n\tint i = 1;\n\n\tint res = delegate (&i);\n\tif (res != 0)\n\t\treturn res;\n\n\tif (i != 2)\n\t\treturn 2;\n\n\treturn 0;\n}\n\ntypedef int (STDCALL *return_int_delegate) (int i);\n\ntypedef return_int_delegate (STDCALL *ReturnDelegateDelegate) (void);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_return_delegate_delegate (ReturnDelegateDelegate d)\n{\n\treturn (d ()) (55);\n}\n\ntypedef int (STDCALL *VirtualDelegate) (int);\n\nLIBTEST_API int STDCALL\nmono_test_marshal_virtual_delegate (VirtualDelegate del)\n{\n\treturn del (42);\n}\n\ntypedef char* (STDCALL *IcallDelegate) (const char *);\nLIBTEST_API int STDCALL\nmono_test_marshal_icall_delegate (IcallDelegate del)\n{\n\tchar *res = del (\"ABC\");\n\treturn strcmp (res, \"ABC\") == 0 ? 0 : 1;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_marshal_stringbuilder (char *s, int n)\n{\n\tconst char m[] = \"This is my message.  Isn't it nice?\";\n\n\tif (strcmp (s, \"ABCD\") != 0)\n\t\treturn 1;\n\tmemcpy(s, m, n);\n\ts [n] = '\\0';\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_marshal_stringbuilder_append (char *s, int length)\n{\n\tconst char out_sentinel[] = \"CSHARP_\";\n\tconst char out_len = strlen (out_sentinel);\n\n\tfor (int i=0; i < length; i++) {\n\t\ts [i] = out_sentinel [i % out_len];\n\t}\n\n\ts [length] = '\\0';\n\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_marshal_stringbuilder_default (char *s, int n)\n{\n\tconst char m[] = \"This is my message.  Isn't it nice?\";\n\n\tmemcpy(s, m, n);\n\ts [n] = '\\0';\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_marshal_stringbuilder_unicode (gunichar2 *s, int n)\n{\n\tconst char m[] = \"This is my message.  Isn't it nice?\";\n\tgunichar2* s2;\n\tglong len;\n\n\ts2 = g_utf8_to_utf16 (m, -1, NULL, &len, NULL);\n\t\n\tlen = (len * 2) + 2;\n\tif (len > (n * 2))\n\t\tlen = n * 2;\n\tmemcpy (s, s2, len);\n\n\tg_free (s2);\n\n\treturn 0;\n}\n\nLIBTEST_API void STDCALL\nmono_test_marshal_stringbuilder_out (char **s)\n{\n\tconst char m[] = \"This is my message.  Isn't it nice?\";\n\tchar *str;\n\n\tstr = (char *)marshal_alloc (strlen (m) + 1);\n\tmemcpy (str, m, strlen (m) + 1);\n\t\n\t*s = str;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_marshal_stringbuilder_out_unicode (gunichar2 **s)\n{\n\tconst char m[] = \"This is my message.  Isn't it nice?\";\n\tgunichar2 *s2;\n\tglong len;\n\n\ts2 = g_utf8_to_utf16 (m, -1, NULL, &len, NULL);\n\t\n\tlen = (len * 2) + 2;\n\t*s = (gunichar2 *)marshal_alloc (len);\n\tmemcpy (*s, s2, len);\n\n\tg_free (s2);\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL\nmono_test_marshal_stringbuilder_ref (char **s)\n{\n\tconst char m[] = \"This is my message.  Isn't it nice?\";\n\tchar *str;\n\n\tif (strcmp (*s, \"ABC\"))\n\t\treturn 1;\n\n\tstr = (char *)marshal_alloc (strlen (m) + 1);\n\tmemcpy (str, m, strlen (m) + 1);\n\t\n\t*s = str;\n\treturn 0;\n}\n\nLIBTEST_API void STDCALL  \nmono_test_marshal_stringbuilder_utf16_tolower (short *s, int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\ts[i] = tolower(s[i]);\n}\n\n\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wc++-compat\"\n#endif\n\n/*\n* Standard C and C++ doesn't allow empty structs, empty structs will always have a size of 1 byte.\n* GCC have an extension to allow empty structs, https://gcc.gnu.org/onlinedocs/gcc/Empty-Structures.html.\n* This cause a little dilemma since runtime build using none GCC compiler will not be compatible with\n* GCC build C libraries and the other way around. On platforms where empty structs has size of 1 byte\n* it must be represented in call and cannot be dropped. On Windows x64 structs will always be represented in the call\n* meaning that an empty struct must have a representation in the callee in order to correctly follow the ABI used by the\n* C/C++ standard and the runtime.\n*/\ntypedef struct {\n#if !defined(__GNUC__) || defined(TARGET_WIN32)\n    char a;\n#endif\n} EmptyStruct;\n\n#ifdef __GNUC__\n#pragma GCC diagnostic pop\n#endif\n\nLIBTEST_API int STDCALL \nmono_test_marshal_empty_string_array (char **array)\n{\n\treturn (array == NULL) ? 0 : 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_string_array (char **array)\n{\n\tif (strcmp (array [0], \"ABC\"))\n\t\treturn 1;\n\tif (strcmp (array [1], \"DEF\"))\n\t\treturn 2;\n\n\tif (array [2] != NULL)\n\t\treturn 3;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_byref_string_array (char ***array)\n{\n\tif (*array == NULL)\n\t\treturn 0;\n\n\tif (strcmp ((*array) [0], \"Alpha\"))\n\t\treturn 2;\n\tif (strcmp ((*array) [1], \"Beta\"))\n\t\treturn 2;\n\tif (strcmp ((*array) [2], \"Gamma\"))\n\t\treturn 2;\n\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_stringbuilder_array (char **array)\n{\n\tif (strcmp (array [0], \"ABC\"))\n\t\treturn 1;\n\tif (strcmp (array [1], \"DEF\"))\n\t\treturn 2;\n\n\tstrcpy (array [0], \"DEF\");\n\tstrcpy (array [1], \"ABC\");\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_unicode_string_array (gunichar2 **array, char **array2)\n{\n\tGError *gerror = NULL;\n\tchar *s;\n\t\n\ts = g_utf16_to_utf8 (array [0], -1, NULL, NULL, &gerror);\n\tif (strcmp (s, \"ABC\")) {\n\t\tg_free (s);\n\t\treturn 1;\n\t}\n\telse\n\t\tg_free (s);\n\n\ts = g_utf16_to_utf8 (array [1], -1, NULL, NULL, &gerror);\n\tif (strcmp (s, \"DEF\")) {\n\t\tg_free (s);\n\t\treturn 2;\n\t}\n\telse\n\t\tg_free (s);\n\n\tif (strcmp (array2 [0], \"ABC\"))\n\t\treturn 3;\n\n\tif (strcmp (array2 [1], \"DEF\")) \n\t\treturn 4;\n\n\treturn 0;\n}\n\n/* this does not work on Redhat gcc 2.96 */\nLIBTEST_API int STDCALL  \nmono_test_empty_struct (int a, EmptyStruct es, int b)\n{\n\t// printf (\"mono_test_empty_struct %d %d\\n\", a, b);\n\n\t// Intel icc on ia64 passes 'es' in 2 registers\n#if defined(__ia64) && defined(__INTEL_COMPILER)\n\treturn 0;\n#else\n\tif (a == 1 && b == 2)\n\t\treturn 0;\n\treturn 1;\n#endif\n}\n\nLIBTEST_API EmptyStruct STDCALL\nmono_test_return_empty_struct (int a)\n{\n\tEmptyStruct s;\n\n\tmemset (&s, 0, sizeof (s));\n\n#if !(defined(__i386__) && defined(__clang__))\n\t/* https://bugzilla.xamarin.com/show_bug.cgi?id=58901 */\n\tg_assert (a == 42);\n#endif\n\n\treturn s;\n}\n\ntypedef struct {\n       char a[100];\n} ByValStrStruct;\n\nLIBTEST_API ByValStrStruct * STDCALL \nmono_test_byvalstr_gen (void)\n{\n\tByValStrStruct *ret;\n       \n\tret = (ByValStrStruct *)malloc (sizeof (ByValStrStruct));\n\tmemset(ret, 'a', sizeof(ByValStrStruct)-1);\n\tret->a[sizeof(ByValStrStruct)-1] = 0;\n\n\treturn ret;\n}\n\nLIBTEST_API int STDCALL \nmono_test_byvalstr_check (ByValStrStruct* data, char* correctString)\n{\n\tint ret;\n\n\tret = strcmp(data->a, correctString);\n\t// printf (\"T1: %s\\n\", data->a);\n\t// printf (\"T2: %s\\n\", correctString);\n\n\t/* we need g_free because the allocation was performed by mono_test_byvalstr_gen */\n\tg_free (data);\n\treturn (ret != 0);\n}\n\ntypedef struct {\n\tguint16 a[4];\n\tint  flag;\n} ByValStrStruct_Unicode;\n\nLIBTEST_API int STDCALL \nmono_test_byvalstr_check_unicode (ByValStrStruct_Unicode *ref, int test)\n{\n\tif (ref->flag != 0x1234abcd){\n\t\tprintf (\"overwritten data\");\n\t\treturn 1;\n\t}\n\t    \n\tif (test == 1 || test == 3){\n\t\tif (ref->a [0] != '1' ||\n\t\t    ref->a [1] != '2'   ||\n\t\t    ref->a [2] != '3')\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif (test == 2){\n\t\tif (ref->a [0] != '1' ||\n\t\t    ref->a [1] != '2')\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\treturn 10;\n}\n\nLIBTEST_API int STDCALL \nNameManglingAnsi (char *data)\n{\n\treturn data [0] + data [1] + data [2];\n}\n\nLIBTEST_API int STDCALL \nNameManglingAnsiA (char *data)\n{\n\tg_assert_not_reached ();\n}\n\nLIBTEST_API int STDCALL \nNameManglingAnsiW (char *data)\n{\n\tg_assert_not_reached ();\n}\n\nLIBTEST_API int STDCALL \nNameManglingAnsi2A (char *data)\n{\n\treturn data [0] + data [1] + data [2];\n}\n\nLIBTEST_API int STDCALL \nNameManglingAnsi2W (char *data)\n{\n\tg_assert_not_reached ();\n}\n\nLIBTEST_API int STDCALL \nNameManglingUnicode (char *data)\n{\n\tg_assert_not_reached ();\n}\n\nLIBTEST_API int STDCALL \nNameManglingUnicodeW (gunichar2 *data)\n{\n\treturn data [0] + data [1] + data [2];\n}\n\nLIBTEST_API int STDCALL \nNameManglingUnicode2 (gunichar2 *data)\n{\n\treturn data [0] + data [1] + data [2];\n}\n\nLIBTEST_API int STDCALL \nNameManglingAutoW (char *data)\n{\n#ifdef WIN32\n\treturn (data [0] + data [1] + data [2]) == 131 ? 0 : 1;\n#else\n\tg_assert_not_reached ();\n#endif\n}\n\nLIBTEST_API int STDCALL \nNameManglingAuto (char *data)\n{\n#ifndef WIN32\n\treturn (data [0] + data [1] + data [2]) == 198 ? 0 : 1;\n#else\n\tg_assert_not_reached ();\n#endif\n}\n\ntypedef int (STDCALL *intcharFunc)(const char*);\n\nLIBTEST_API void STDCALL \ncallFunction (intcharFunc f)\n{\n\tf (\"ABC\");\n}\n\ntypedef struct {\n        const char* str;\n        int i;\n} SimpleObj;\n\nLIBTEST_API int STDCALL \nclass_marshal_test0 (SimpleObj *obj1)\n{\n\t// printf (\"class_marshal_test0 %s %d\\n\", obj1->str, obj1->i);\n\n\tif (strcmp(obj1->str, \"T1\"))\n\t\treturn -1;\n\tif (obj1->i != 4)\n\t\treturn -2;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nclass_marshal_test4 (SimpleObj *obj1)\n{\n\tif (obj1)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nLIBTEST_API void STDCALL\nclass_marshal_test1 (SimpleObj **obj1)\n{\n\tSimpleObj *res = (SimpleObj *)malloc (sizeof (SimpleObj));\n\n\tres->str = marshal_strdup (\"ABC\");\n\tres->i = 5;\n\n\t*obj1 = res;\n}\n\nLIBTEST_API int STDCALL \nclass_marshal_test2 (SimpleObj **obj1)\n{\n\t// printf (\"class_marshal_test2 %s %d\\n\", (*obj1)->str, (*obj1)->i);\n\n\tif (strcmp((*obj1)->str, \"ABC\"))\n\t\treturn -1;\n\tif ((*obj1)->i != 5)\n\t\treturn -2;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nstring_marshal_test0 (char *str)\n{\n\tif (strcmp (str, \"TEST0\"))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nLIBTEST_API void STDCALL\nstring_marshal_test1 (const char **str)\n{\n\t*str = marshal_strdup (\"TEST1\");\n}\n\nLIBTEST_API int STDCALL \nstring_marshal_test2 (char **str)\n{\n\t// printf (\"string_marshal_test2 %s\\n\", *str);\n\n\tif (strcmp (*str, \"TEST1\"))\n\t\treturn -1;\n\n\t*str = marshal_strdup (\"TEST2\");\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nstring_marshal_test3 (char *str)\n{\n\tif (str)\n\t\treturn -1;\n\n\treturn 0;\n}\n\ntypedef struct {\n\tint a;\n\tint b;\n} BlittableClass;\n\nLIBTEST_API BlittableClass* STDCALL \nTestBlittableClass (BlittableClass *vl)\n{\n\tBlittableClass *res;\n\n\t// printf (\"TestBlittableClass %d %d\\n\", vl->a, vl->b);\n\n\tif (vl) {\n\t\tvl->a++;\n\t\tvl->b++;\n\n\t\tres = marshal_new0 (BlittableClass, 1);\n\t\tmemcpy (res, vl, sizeof (BlittableClass));\n\t} else {\n\t\tres = marshal_new0 (BlittableClass, 1);\n\t\tres->a = 42;\n\t\tres->b = 43;\n\t}\n\n\treturn res;\n}\n\ntypedef struct OSVERSIONINFO_STRUCT\n{ \n\tint a; \n\tint b; \n} OSVERSIONINFO_STRUCT;\n\nLIBTEST_API int STDCALL  \nMyGetVersionEx (OSVERSIONINFO_STRUCT *osvi)\n{\n\n\t// printf (\"GOT %d %d\\n\", osvi->a, osvi->b);\n\n\tosvi->a += 1;\n\tosvi->b += 1;\n\n\treturn osvi->a + osvi->b;\n}\n\nLIBTEST_API int STDCALL  \nBugGetVersionEx (int a, int b, int c, int d, int e, int f, int g, int h, OSVERSIONINFO_STRUCT *osvi)\n{\n\n\t// printf (\"GOT %d %d\\n\", osvi->a, osvi->b);\n\n\tosvi->a += 1;\n\tosvi->b += 1;\n\n\treturn osvi->a + osvi->b;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_point (point pt)\n{\n\t// printf(\"point %g %g\\n\", pt.x, pt.y);\n\tif (pt.x == 1.25 && pt.y == 3.5)\n\t\treturn 0;\n\n\treturn 1;\n}\n\ntypedef struct {\n\tint x;\n\tdouble y;\n} mixed_point;\n\nLIBTEST_API int STDCALL \nmono_test_marshal_mixed_point (mixed_point pt)\n{\n\t// printf(\"mixed point %d %g\\n\", pt.x, pt.y);\n\tif (pt.x == 5 && pt.y == 6.75)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_mixed_point_2 (mixed_point *pt)\n{\n\tif (pt->x != 5 || pt->y != 6.75)\n\t\treturn 1;\n\n\tpt->x = 10;\n\tpt->y = 12.35;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL  \nmarshal_test_ref_bool(int i, char *b1, short *b2, int *b3)\n{\n    int res = 1;\n    if (*b1 != 0 && *b1 != 1)\n        return 1;\n    if (*b2 != 0 && *b2 != -1) /* variant_bool */\n        return 1;\n    if (*b3 != 0 && *b3 != 1)\n        return 1;\n    if (i == ((*b1 << 2) | (-*b2 << 1) | *b3))\n        res = 0;\n    *b1 = !*b1;\n    *b2 = ~*b2;\n    *b3 = !*b3;\n    return res;\n}\n\nstruct BoolStruct\n{\n    int i;\n    char b1;\n    short b2; /* variant_bool */\n    int b3;\n};\n\nLIBTEST_API int STDCALL  \nmarshal_test_bool_struct(struct BoolStruct *s)\n{\n    int res = 1;\n    if (s->b1 != 0 && s->b1 != 1)\n        return 1;\n    if (s->b2 != 0 && s->b2 != -1)\n        return 1;\n    if (s->b3 != 0 && s->b3 != 1)\n        return 1;\n    if (s->i == ((s->b1 << 2) | (-s->b2 << 1) | s->b3))\n        res = 0;\n    s->b1 = !s->b1;\n    s->b2 = ~s->b2;\n    s->b3 = !s->b3;\n    return res;\n}\n\ntypedef struct {\n\tgint64 l;\n} LongStruct2;\n\ntypedef struct {\n\tint i;\n\tLongStruct2 l;\n} LongStruct;\n\nLIBTEST_API int STDCALL\nmono_test_marshal_long_struct (LongStruct *s)\n{\n\treturn s->i + s->l.l;\n}\n\nLIBTEST_API void STDCALL\nmono_test_last_error (int err)\n{\n#ifdef WIN32\n\tSetLastError (err);\n\n\t/*\n\t* Make sure argument register used calling SetLastError\n\t* get's cleaned before returning back to caller. This is done to ensure\n\t* we don't get a undetected failure if error is preserved in register\n\t* on return since we read back value directly when doing p/invoke with SetLastError = true\n\t* into first argument register and then pass it to Mono function setting value in TLS.\n\t* If there is a codegen bug reading last error or the code has been incorrectly eliminated\n\t* this test could still succeed since expected error code could be left in argument register.\n\t* Below code just do something that shouldn't touch last error and won't be optimized away\n\t* but will change the argument registers to something different than err.\n\t*/\n\tchar buffer[256] = { 0 };\n\tchar value[] = \"Dummy\";\n\tstrncpy (buffer, value, G_N_ELEMENTS (value) - 1);\n#else\n\tmono_set_errno (err);\n#endif\n}\n\nLIBTEST_API int STDCALL \nmono_test_asany (void *ptr, int what)\n{\n\tswitch (what) {\n\tcase 1:\n\t\treturn (*(int*)ptr == 5) ? 0 : 1;\n\tcase 2:\n\t\treturn strcmp ((const char*)ptr, \"ABC\") == 0 ? 0 : 1;\n\tcase 3: {\n\t\tsimplestruct2 ss = *(simplestruct2*)ptr;\n\n\t\tif (ss.a == 0 && ss.b == 1 && ss.c == 0 &&\n\t    !strcmp (ss.d, \"TEST\") && \n\t    ss.e == 99 && ss.f == 1.5 && ss.g == 42 && ss.h == (guint64)123)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1;\n\t}\n\tcase 4: {\n\t\tGError *gerror = NULL;\n\t\tchar *s;\n\n\t\ts = g_utf16_to_utf8 ((const gunichar2 *)ptr, -1, NULL, NULL, &gerror);\n\n\t\tif (!s)\n\t\t\treturn 1;\n\n\t\tif (!strcmp (s, \"ABC\")) {\n\t\t\tg_free (s);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tg_free (s);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\treturn 1;\n}\n\ntypedef struct\n{\n\tint i;\n\tint j;\n\tint k;\n\tchar *s;\n} AsAnyStruct;\n\nLIBTEST_API int STDCALL \nmono_test_marshal_asany_in (void* ptr)\n{\n\tAsAnyStruct *asAny = (AsAnyStruct *)ptr;\n\tint res = asAny->i + asAny->j + asAny->k;\n\n\treturn res;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_asany_inout (void* ptr)\n{\n\tAsAnyStruct *asAny = (AsAnyStruct *)ptr;\n\tint res = asAny->i + asAny->j + asAny->k;\n\n\tmarshal_free (asAny->s);\n\n\tasAny->i = 10;\n\tasAny->j = 20;\n\tasAny->k = 30;\n\tasAny->s = 0;\n\n\treturn res;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_asany_out (void* ptr)\n{\n\tAsAnyStruct *asAny = (AsAnyStruct *)ptr;\n\tint res = asAny->i + asAny->j + asAny->k;\n\n\tasAny->i = 10;\n\tasAny->j = 20;\n\tasAny->k = 30;\n\tasAny->s = 0;\n\n\treturn res;\n}\n\n/*\n * AMD64 marshalling tests.\n */\n\ntypedef struct amd64_struct1 {\n\tint i;\n\tint j;\n\tint k;\n\tint l;\n} amd64_struct1;\n\nLIBTEST_API amd64_struct1 STDCALL \nmono_test_marshal_amd64_pass_return_struct1 (amd64_struct1 s)\n{\n\ts.i ++;\n\ts.j ++;\n\ts.k ++;\n\ts.l ++;\n\n\treturn s;\n}\n\nLIBTEST_API amd64_struct1 STDCALL \nmono_test_marshal_amd64_pass_return_struct1_many_args (amd64_struct1 s, int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8)\n{\n\ts.i ++;\n\ts.j ++;\n\ts.k ++;\n\ts.l += 1 + i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8;\n\n\treturn s;\n}\n\ntypedef struct amd64_struct2 {\n\tint i;\n\tint j;\n} amd64_struct2;\n\nLIBTEST_API amd64_struct2 STDCALL \nmono_test_marshal_amd64_pass_return_struct2 (amd64_struct2 s)\n{\n\ts.i ++;\n\ts.j ++;\n\n\treturn s;\n}\n\ntypedef struct amd64_struct3 {\n\tint i;\n} amd64_struct3;\n\nLIBTEST_API amd64_struct3 STDCALL \nmono_test_marshal_amd64_pass_return_struct3 (amd64_struct3 s)\n{\n\ts.i ++;\n\n\treturn s;\n}\n\ntypedef struct amd64_struct4 {\n\tdouble d1, d2;\n} amd64_struct4;\n\nLIBTEST_API amd64_struct4 STDCALL \nmono_test_marshal_amd64_pass_return_struct4 (amd64_struct4 s)\n{\n\ts.d1 ++;\n\ts.d2 ++;\n\n\treturn s;\n}\n\n/*\n * IA64 marshalling tests.\n */\ntypedef struct test_struct5 {\n\tfloat d1, d2;\n} test_struct5;\n\nLIBTEST_API test_struct5 STDCALL \nmono_test_marshal_ia64_pass_return_struct5 (double d1, double d2, test_struct5 s, int i, double d3, double d4)\n{\n\ts.d1 += d1 + d2 + i;\n\ts.d2 += d3 + d4 + i;\n\n\treturn s;\n}\n\ntypedef struct test_struct6 {\n\tdouble d1, d2;\n} test_struct6;\n\nLIBTEST_API test_struct6 STDCALL \nmono_test_marshal_ia64_pass_return_struct6 (double d1, double d2, test_struct6 s, int i, double d3, double d4)\n{\n\ts.d1 += d1 + d2 + i;\n\ts.d2 += d3 + d4;\n\n\treturn s;\n}\n\nstatic guint32 custom_res [2];\n\nLIBTEST_API void* STDCALL\nmono_test_marshal_pass_return_custom (int i, guint32 *ptr, int j)\n{\n\t/* ptr will be freed by CleanupNative, so make a copy */\n\tcustom_res [0] = 0; /* not allocated by AllocHGlobal */\n\tcustom_res [1] = ptr [1];\n\n\treturn &custom_res;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_pass_out_custom (int i, guint32 **ptr, int j)\n{\n\tcustom_res [0] = 0;\n\tcustom_res [1] = i + j + 10;\n\n\t*ptr = custom_res;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_pass_inout_custom (int i, guint32 *ptr, int j)\n{\n\tptr [0] = 0;\n\tptr [1] = i + ptr [1] + j;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_pass_out_byval_custom (int i, guint32 *ptr, int j)\n{\n\treturn ptr == NULL ? 0 : 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_pass_byref_custom (int i, guint32 **ptr, int j)\n{\n\t(*ptr)[1] += i + j;\n\n\treturn 0;\n}\n\nLIBTEST_API void* STDCALL\nmono_test_marshal_pass_return_custom2 (int i, guint32 *ptr, int j)\n{\n\tg_assert_not_reached ();\n\n\treturn NULL;\n}\n\nLIBTEST_API void* STDCALL\nmono_test_marshal_pass_return_custom_null (int i, guint32 *ptr, int j)\n{\n\tg_assert (ptr == NULL);\n\n\treturn NULL;\n}\n\ntypedef void *(STDCALL *PassReturnPtrDelegate) (void *ptr);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_pass_return_custom_in_delegate (PassReturnPtrDelegate del)\n{\n\tguint32 buf [2];\n\tguint32 res;\n\tguint32 *ptr;\n\n\tbuf [0] = 0;\n\tbuf [1] = 10;\n\n\tptr = (guint32 *)del (&buf);\n\n\tres = ptr [1];\n\n#ifdef WIN32\n\t/* FIXME: Freed with FreeHGlobal */\n#else\n\tg_free (ptr);\n#endif\n\n\treturn res;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_pass_return_custom_null_in_delegate (PassReturnPtrDelegate del)\n{\n\tvoid *ptr = del (NULL);\n\n\treturn (ptr == NULL) ? 15 : 0;\n}\n\ntypedef void (STDCALL *CustomOutParamDelegate) (void **pptr);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_custom_out_param_delegate (CustomOutParamDelegate del)\n{\n\tvoid* pptr = (void*)del;\n\n\tdel (&pptr);\n\n\tif(pptr != NULL)\n\t\treturn 1;\n\n\treturn 0;\n}\n\ntypedef int (STDCALL *ReturnEnumDelegate) (int e);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_return_enum_delegate (ReturnEnumDelegate func)\n{\n\treturn func (1);\n}\n\ntypedef struct {\n\tint a, b, c;\n\tgint64 d;\n} BlittableStruct;\n\t\ntypedef BlittableStruct (STDCALL *SimpleDelegate10) (BlittableStruct ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_blittable_struct_delegate (SimpleDelegate10 delegate)\n{\n\tBlittableStruct ss, res;\n\n\tss.a = 1;\n\tss.b = 2;\n\tss.c = 3;\n\tss.d = 55;\n\n\tres = delegate (ss);\n\tif (! ((res.a == -1) && (res.b == -2) && (res.c == -3) && (res.d == -55)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_stdcall_name_mangling (int a, int b, int c)\n{\n        return a + b + c;\n}\n\nLIBTEST_API int\nmono_test_stdcall_mismatch_1 (int a, int b, int c)\n{\n        return a + b + c;\n}\n\nLIBTEST_API int STDCALL\nmono_test_stdcall_mismatch_2 (int a, int b, int c)\n{\n        return a + b + c;\n}\n\n/*\n * PASSING AND RETURNING SMALL STRUCTURES FROM DELEGATES TESTS\n */\n\ntypedef struct {\n\tint i;\n} SmallStruct1;\n\t\ntypedef SmallStruct1 (STDCALL *SmallStructDelegate1) (SmallStruct1 ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_small_struct_delegate1 (SmallStructDelegate1 delegate)\n{\n\tSmallStruct1 ss, res;\n\n\tss.i = 1;\n\n\tres = delegate (ss);\n\tif (! (res.i == -1))\n\t\treturn 1;\n\n\treturn 0;\n}\n\ntypedef struct {\n\tgint16 i, j;\n} SmallStruct2;\n\t\ntypedef SmallStruct2 (STDCALL *SmallStructDelegate2) (SmallStruct2 ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_small_struct_delegate2 (SmallStructDelegate2 delegate)\n{\n\tSmallStruct2 ss, res;\n\n\tss.i = 2;\n\tss.j = 3;\n\n\tres = delegate (ss);\n\tif (! ((res.i == -2) && (res.j == -3)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\ntypedef struct {\n\tgint16 i;\n\tgint8 j;\n} SmallStruct3;\n\t\ntypedef SmallStruct3 (STDCALL *SmallStructDelegate3) (SmallStruct3 ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_small_struct_delegate3 (SmallStructDelegate3 delegate)\n{\n\tSmallStruct3 ss, res;\n\n\tss.i = 1;\n\tss.j = 2;\n\n\tres = delegate (ss);\n\tif (! ((res.i == -1) && (res.j == -2)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\ntypedef struct {\n\tgint16 i;\n} SmallStruct4;\n\t\ntypedef SmallStruct4 (STDCALL *SmallStructDelegate4) (SmallStruct4 ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_small_struct_delegate4 (SmallStructDelegate4 delegate)\n{\n\tSmallStruct4 ss, res;\n\n\tss.i = 1;\n\n\tres = delegate (ss);\n\tif (! (res.i == -1))\n\t\treturn 1;\n\n\treturn 0;\n}\n\ntypedef struct {\n\tgint64 i;\n} SmallStruct5;\n\t\ntypedef SmallStruct5 (STDCALL *SmallStructDelegate5) (SmallStruct5 ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_small_struct_delegate5 (SmallStructDelegate5 delegate)\n{\n\tSmallStruct5 ss, res;\n\n\tss.i = 5;\n\n\tres = delegate (ss);\n\tif (! (res.i == -5))\n\t\treturn 1;\n\n\treturn 0;\n}\n\ntypedef struct {\n\tint i, j;\n} SmallStruct6;\n\t\ntypedef SmallStruct6 (STDCALL *SmallStructDelegate6) (SmallStruct6 ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_small_struct_delegate6 (SmallStructDelegate6 delegate)\n{\n\tSmallStruct6 ss, res;\n\n\tss.i = 1;\n\tss.j = 2;\n\n\tres = delegate (ss);\n\tif (! ((res.i == -1) && (res.j == -2)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\ntypedef struct {\n\tint i;\n\tgint16 j;\n} SmallStruct7;\n\t\ntypedef SmallStruct7 (STDCALL *SmallStructDelegate7) (SmallStruct7 ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_small_struct_delegate7 (SmallStructDelegate7 delegate)\n{\n\tSmallStruct7 ss, res;\n\n\tss.i = 1;\n\tss.j = 2;\n\n\tres = delegate (ss);\n\tif (! ((res.i == -1) && (res.j == -2)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\ntypedef struct {\n\tfloat i;\n} SmallStruct8;\n\t\ntypedef SmallStruct8 (STDCALL *SmallStructDelegate8) (SmallStruct8 ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_small_struct_delegate8 (SmallStructDelegate8 delegate)\n{\n\tSmallStruct8 ss, res;\n\n\tss.i = 1.0;\n\n\tres = delegate (ss);\n\tif (! ((res.i == -1.0)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\ntypedef struct {\n\tdouble i;\n} SmallStruct9;\n\t\ntypedef SmallStruct9 (STDCALL *SmallStructDelegate9) (SmallStruct9 ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_small_struct_delegate9 (SmallStructDelegate9 delegate)\n{\n\tSmallStruct9 ss, res;\n\n\tss.i = 1.0;\n\n\tres = delegate (ss);\n\tif (! ((res.i == -1.0)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\ntypedef struct {\n\tfloat i, j;\n} SmallStruct10;\n\t\ntypedef SmallStruct10 (STDCALL *SmallStructDelegate10) (SmallStruct10 ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_small_struct_delegate10 (SmallStructDelegate10 delegate)\n{\n\tSmallStruct10 ss, res;\n\n\tss.i = 1.0;\n\tss.j = 2.0;\n\n\tres = delegate (ss);\n\tif (! ((res.i == -1.0) && (res.j == -2.0)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\ntypedef struct {\n\tfloat i;\n\tint j;\n} SmallStruct11;\n\t\ntypedef SmallStruct11 (STDCALL *SmallStructDelegate11) (SmallStruct11 ss);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_small_struct_delegate11 (SmallStructDelegate11 delegate)\n{\n\tSmallStruct11 ss, res;\n\n\tss.i = 1.0;\n\tss.j = 2;\n\n\tres = delegate (ss);\n\tif (! ((res.i == -1.0) && (res.j == -2)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\ntypedef int (STDCALL *ArrayDelegate) (int i, char *j, void *arr);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_array_delegate (void *arr, int len, ArrayDelegate del)\n{\n\treturn del (len, NULL, arr);\n}\n\ntypedef int (STDCALL *ArrayDelegateLong) (gint64 i, char *j, void *arr);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_array_delegate_long (void *arr, gint64 len, ArrayDelegateLong del)\n{\n\treturn del (len, NULL, arr);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_out_array_delegate (int *arr, int len, ArrayDelegate del)\n{\n\tdel (len, NULL, arr);\n\n\tif ((arr [0] != 1) || (arr [1] != 2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\ntypedef gunichar2* (STDCALL *UnicodeStringDelegate) (gunichar2 *message);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_return_unicode_string_delegate (UnicodeStringDelegate del)\n{\n\tconst char m[] = \"abcdef\";\n\tgunichar2 *s2, *res;\n\tglong len;\n\n\ts2 = g_utf8_to_utf16 (m, -1, NULL, &len, NULL);\n\n\tres = del (s2);\n\n\tmarshal_free (res);\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_out_string_array_delegate (char **arr, int len, ArrayDelegate del)\n{\n\tdel (len, NULL, arr);\n\n\tif (!strcmp (arr [0], \"ABC\") && !strcmp (arr [1], \"DEF\"))\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\ntypedef int (*CdeclDelegate) (int i, int j);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_cdecl_delegate (CdeclDelegate del)\n{\n\tint i;\n\n\tfor (i = 0; i < 1000; ++i)\n\t\tdel (1, 2);\n\n\treturn 0;\n}\n\ntypedef char** (STDCALL *ReturnStringArrayDelegate) (int i);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_return_string_array_delegate (ReturnStringArrayDelegate d)\n{\n\tchar **arr = d (2);\n\tint res;\n\n\tif (arr == NULL)\n\t\treturn 3;\n\n\tif (strcmp (arr [0], \"ABC\") || strcmp (arr [1], \"DEF\"))\n\t\tres = 1;\n\telse\n\t\tres = 0;\n\n\tmarshal_free (arr);\n\n\treturn res;\n}\n\ntypedef int (STDCALL *ByrefStringDelegate) (char **s);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_byref_string_delegate (ByrefStringDelegate d)\n{\n\tchar *s = (char*)\"ABC\";\n\tint res;\n\n\tres = d (&s);\n\tif (res != 0)\n\t\treturn res;\n\n\tif (!strcmp (s, \"DEF\"))\n\t\tres = 0;\n\telse\n\t\tres = 2;\n\n\tmarshal_free (s);\n\n\treturn res;\n}\n\nLIBTEST_API int STDCALL \nadd_delegate (int i, int j)\n{\n\treturn i + j;\n}\n\nLIBTEST_API gpointer STDCALL \nmono_test_marshal_return_fnptr (void)\n{\n\treturn (gpointer)&add_delegate;\n}\n\nLIBTEST_API int STDCALL \nmono_xr (int code)\n{\n\tprintf (\"codigo %x\\n\", code);\n\treturn code + 1234;\n}\n\ntypedef struct {\n\tint handle;\n} HandleRef;\n\nLIBTEST_API HandleRef STDCALL \nmono_xr_as_handle (int code)\n{\n\tHandleRef ref;\n\n\tmemset (&ref, 0, sizeof (ref));\n\n\treturn ref;\n}\n \ntypedef struct {\n\tint   a;\n\tvoid *handle1;\n\tvoid *handle2;\n\tint   b;\n} HandleStructs;\n\nLIBTEST_API int STDCALL \nmono_safe_handle_struct_ref (HandleStructs *x)\n{\n\tprintf (\"Dingus Ref! \\n\");\n\tprintf (\"Values: %d %d %p %p\\n\", x->a, x->b, x->handle1, x->handle2);\n\tif (x->a != 1234)\n\t\treturn 1;\n\tif (x->b != 8743)\n\t\treturn 2;\n\n\tif (x->handle1 != (void*) 0x7080feed)\n\t\treturn 3;\n\n\tif (x->handle2 != (void*) 0x1234abcd)\n\t\treturn 4;\n\n\treturn 0xf00d;\n}\n\nLIBTEST_API int STDCALL \nmono_safe_handle_struct (HandleStructs x)\n{\n\tprintf (\"Dingus Standard! \\n\");\n\tprintf (\"Values: %d %d %p %p\\n\", x.a, x.b, x.handle1, x.handle2);\n\tif (x.a != 1234)\n\t\treturn 1;\n\tif (x.b != 8743)\n\t\treturn 2;\n\n\tif (x.handle1 != (void*) 0x7080feed)\n\t\treturn 3;\n\n\tif (x.handle2 != (void*) 0x1234abcd)\n\t\treturn 4;\n\t\n\treturn 0xf00f;\n}\n\ntypedef struct {\n\tvoid *a;\n} TrivialHandle;\n\nLIBTEST_API int STDCALL \nmono_safe_handle_struct_simple (TrivialHandle x)\n{\n\tprintf (\"The value is %p\\n\", x.a);\n\treturn ((int)(gsize)x.a) * 2;\n}\n\nLIBTEST_API int STDCALL \nmono_safe_handle_return (void)\n{\n\treturn 0x1000f00d;\n}\n\nLIBTEST_API void STDCALL\nmono_safe_handle_ref (void **handle)\n{\n\tif (*handle != 0){\n\t\t*handle = (void *) 0x800d;\n\t\treturn;\n\t}\n\n\t*handle = (void *) 0xbad;\n}\n\nLIBTEST_API void* STDCALL\nmono_safe_handle_ref_nomod (void **handle)\n{\n\treturn *handle;\n}\n\nLIBTEST_API double STDCALL\nmono_test_marshal_date_time (double d, double *d2)\n{\n\t*d2 = d;\n\treturn d;\n}\n\n/*\n * COM INTEROP TESTS\n */\n\n#ifndef WIN32\n\ntypedef struct {\n\tguint16 vt;\n\tguint16 wReserved1;\n\tguint16 wReserved2;\n\tguint16 wReserved3;\n\tunion {\n\t\tgint64 llVal;\n\t\tgint32 lVal;\n\t\tguint8  bVal;\n\t\tgint16 iVal;\n\t\tfloat  fltVal;\n\t\tdouble dblVal;\n\t\tgint16 boolVal;\n\t\tgunichar2* bstrVal;\n\t\tgint8 cVal;\n\t\tguint16 uiVal;\n\t\tguint32 ulVal;\n\t\tguint64 ullVal;\n\t\tgpointer byref;\n\t\tstruct {\n\t\t\tgpointer pvRecord;\n\t\t\tgpointer pRecInfo;\n\t\t};\n\t};\n} VARIANT;\n\ntypedef enum {\n\tVARIANT_TRUE = -1,\n\tVARIANT_FALSE = 0\n} VariantBool;\n\ntypedef enum {\n\tVT_EMPTY = 0,\n\tVT_NULL = 1,\n\tVT_I2 = 2,\n\tVT_I4 = 3,\n\tVT_R4 = 4,\n\tVT_R8 = 5,\n\tVT_CY = 6,\n\tVT_DATE = 7,\n\tVT_BSTR = 8,\n\tVT_DISPATCH = 9,\n\tVT_ERROR = 10,\n\tVT_BOOL = 11,\n\tVT_VARIANT = 12,\n\tVT_UNKNOWN = 13,\n\tVT_DECIMAL = 14,\n\tVT_I1 = 16,\n\tVT_UI1 = 17,\n\tVT_UI2 = 18,\n\tVT_UI4 = 19,\n\tVT_I8 = 20,\n\tVT_UI8 = 21,\n\tVT_INT = 22,\n\tVT_UINT = 23,\n\tVT_VOID = 24,\n\tVT_HRESULT = 25,\n\tVT_PTR = 26,\n\tVT_SAFEARRAY = 27,\n\tVT_CARRAY = 28,\n\tVT_USERDEFINED = 29,\n\tVT_LPSTR = 30,\n\tVT_LPWSTR = 31,\n\tVT_RECORD = 36,\n\tVT_FILETIME = 64,\n\tVT_BLOB = 65,\n\tVT_STREAM = 66,\n\tVT_STORAGE = 67,\n\tVT_STREAMED_OBJECT = 68,\n\tVT_STORED_OBJECT = 69,\n\tVT_BLOB_OBJECT = 70,\n\tVT_CF = 71,\n\tVT_CLSID = 72,\n\tVT_VECTOR = 4096,\n\tVT_ARRAY = 8192,\n\tVT_BYREF = 16384\n} VarEnum;\n\nvoid VariantInit(VARIANT* vt)\n{\n\tvt->vt = VT_EMPTY;\n}\n\ntypedef struct\n{\n\tguint32 a;\n\tguint16 b;\n\tguint16 c;\n\tguint8 d[8];\n} GUID;\n\n#define S_OK 0\n\n#endif\n\nLIBTEST_API int STDCALL \nmono_test_marshal_bstr_in(gunichar2* bstr)\n{\n\tgint32 result = 0;\n\tgchar* bstr_utf8 = g_utf16_to_utf8 (bstr, -1, NULL, NULL, NULL);\n\tresult = strcmp(\"mono_test_marshal_bstr_in\", bstr_utf8);\n\tg_free(bstr_utf8);\n\tif (result == 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_bstr_out(gunichar2** bstr)\n{\n\t*bstr = marshal_bstr_alloc (\"mono_test_marshal_bstr_out\");\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_bstr_in_null(gunichar2* bstr)\n{\n\tif (!bstr)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_bstr_out_null(gunichar2** bstr)\n{\n\t*bstr = NULL;\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_sbyte(VARIANT variant)\n{\n\tif (variant.vt == VT_I1 && variant.cVal == 100)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_byte(VARIANT variant)\n{\n\tif (variant.vt == VT_UI1 && variant.bVal == 100)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_short(VARIANT variant)\n{\n\tif (variant.vt == VT_I2 && variant.iVal == 314)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_ushort(VARIANT variant)\n{\n\tif (variant.vt == VT_UI2 && variant.uiVal == 314)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_int(VARIANT variant)\n{\n\tif (variant.vt == VT_I4 && variant.lVal == 314)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_uint(VARIANT variant)\n{\n\tif (variant.vt == VT_UI4 && variant.ulVal == 314)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_long(VARIANT variant)\n{\n\tif (variant.vt == VT_I8 && variant.llVal == 314)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_ulong(VARIANT variant)\n{\n\tif (variant.vt == VT_UI8 && variant.ullVal == 314)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_float(VARIANT variant)\n{\n\tif (variant.vt == VT_R4 && (variant.fltVal - 3.14)/3.14 < .001)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_double(VARIANT variant)\n{\n\tif (variant.vt == VT_R8 && (variant.dblVal - 3.14)/3.14 < .001)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_bstr(VARIANT variant)\n{\n\tgint32 result = 0;\n        gchar* bstr_utf8 = g_utf16_to_utf8 (variant.bstrVal, -1, NULL, NULL, NULL);\n        result = strcmp(\"PI\", bstr_utf8);\n        g_free(bstr_utf8);\n\n\tif (variant.vt == VT_BSTR && !result)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_bool_true (VARIANT variant)\n{\n\tif (variant.vt == VT_BOOL && variant.boolVal == VARIANT_TRUE)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_bool_false (VARIANT variant)\n{\n\tif (variant.vt == VT_BOOL && variant.boolVal == VARIANT_FALSE)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_sbyte(VARIANT* variant)\n{\n\tvariant->vt = VT_I1;\n\tvariant->cVal = 100;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_sbyte_byref(VARIANT* variant)\n{\n\tvariant->vt = VT_I1|VT_BYREF;\n\tvariant->byref = marshal_alloc(1);\n\t*((gint8*)variant->byref) = 100;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_byte(VARIANT* variant)\n{\t\n\tvariant->vt = VT_UI1;\n\tvariant->bVal = 100;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_byte_byref(VARIANT* variant)\n{\t\n\tvariant->vt = VT_UI1|VT_BYREF;\n\tvariant->byref = marshal_alloc(1);\n\t*((gint8*)variant->byref) = 100;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_short(VARIANT* variant)\n{\n\tvariant->vt = VT_I2;\n\tvariant->iVal = 314;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_short_byref(VARIANT* variant)\n{\n\tvariant->vt = VT_I2|VT_BYREF;\n\tvariant->byref = marshal_alloc(2);\n\t*((gint16*)variant->byref) = 314;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_ushort(VARIANT* variant)\n{\n\tvariant->vt = VT_UI2;\n\tvariant->uiVal = 314;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_ushort_byref(VARIANT* variant)\n{\n\tvariant->vt = VT_UI2|VT_BYREF;\n\tvariant->byref = marshal_alloc(2);\n\t*((guint16*)variant->byref) = 314;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_int(VARIANT* variant)\n{\n\tvariant->vt = VT_I4;\n\tvariant->lVal = 314;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_int_byref(VARIANT* variant)\n{\n\tvariant->vt = VT_I4|VT_BYREF;\n\tvariant->byref = marshal_alloc(4);\n\t*((gint32*)variant->byref) = 314;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_uint(VARIANT* variant)\n{\n\tvariant->vt = VT_UI4;\n\tvariant->ulVal = 314;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_uint_byref(VARIANT* variant)\n{\n\tvariant->vt = VT_UI4|VT_BYREF;\n\tvariant->byref = marshal_alloc(4);\n\t*((guint32*)variant->byref) = 314;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_long(VARIANT* variant)\n{\n\tvariant->vt = VT_I8;\n\tvariant->llVal = 314;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_long_byref(VARIANT* variant)\n{\n\tvariant->vt = VT_I8|VT_BYREF;\n\tvariant->byref = marshal_alloc(8);\n\t*((gint64*)variant->byref) = 314;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_ulong(VARIANT* variant)\n{\n\tvariant->vt = VT_UI8;\n\tvariant->ullVal = 314;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_ulong_byref(VARIANT* variant)\n{\n\tvariant->vt = VT_UI8|VT_BYREF;\n\tvariant->byref = marshal_alloc(8);\n\t*((guint64*)variant->byref) = 314;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_float(VARIANT* variant)\n{\n\tvariant->vt = VT_R4;\n\tvariant->fltVal = 3.14;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_float_byref(VARIANT* variant)\n{\n\tvariant->vt = VT_R4|VT_BYREF;\n\tvariant->byref = marshal_alloc(4);\n\t*((float*)variant->byref) = 3.14;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_double(VARIANT* variant)\n{\n\tvariant->vt = VT_R8;\n\tvariant->dblVal = 3.14;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_double_byref(VARIANT* variant)\n{\n\tvariant->vt = VT_R8|VT_BYREF;\n\tvariant->byref = marshal_alloc(8);\n\t*((double*)variant->byref) = 3.14;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_bstr(VARIANT* variant)\n{\n\tvariant->vt = VT_BSTR;\n\tvariant->bstrVal = marshal_bstr_alloc(\"PI\");\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_bstr_byref(VARIANT* variant)\n{\n\tvariant->vt = VT_BSTR|VT_BYREF;\n\tvariant->byref = marshal_alloc(sizeof(gpointer));\n\t*((gunichar**)variant->byref) = (gunichar*)marshal_bstr_alloc(\"PI\");\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_bool_true (VARIANT* variant)\n{\n\tvariant->vt = VT_BOOL;\n\tvariant->boolVal = VARIANT_TRUE;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_bool_true_byref (VARIANT* variant)\n{\n\tvariant->vt = VT_BOOL|VT_BYREF;\n\tvariant->byref = marshal_alloc(2);\n\t*((gint16*)variant->byref) = VARIANT_TRUE;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_bool_false (VARIANT* variant)\n{\n\tvariant->vt = VT_BOOL;\n\tvariant->boolVal = VARIANT_FALSE;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_bool_false_byref (VARIANT* variant)\n{\n\tvariant->vt = VT_BOOL|VT_BYREF;\n\tvariant->byref = marshal_alloc(2);\n\t*((gint16*)variant->byref) = VARIANT_FALSE;\n\n\treturn 0;\n}\n\ntypedef int (STDCALL *VarFunc) (int vt, VARIANT variant);\ntypedef int (STDCALL *VarRefFunc) (int vt, VARIANT* variant);\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_sbyte_unmanaged(VarFunc func)\n{\n\tVARIANT vt;\n\tvt.vt = VT_I1;\n\tvt.cVal = -100;\n\treturn func (VT_I1, vt);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_byte_unmanaged(VarFunc func)\n{\n\tVARIANT vt;\n\tvt.vt = VT_UI1;\n\tvt.bVal = 100;\n\treturn func (VT_UI1, vt);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_short_unmanaged(VarFunc func)\n{\n\tVARIANT vt;\n\tvt.vt = VT_I2;\n\tvt.iVal = -100;\n\treturn func (VT_I2, vt);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_ushort_unmanaged(VarFunc func)\n{\n\tVARIANT vt;\n\tvt.vt = VT_UI2;\n\tvt.uiVal = 100;\n\treturn func (VT_UI2, vt);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_int_unmanaged(VarFunc func)\n{\n\tVARIANT vt;\n\tvt.vt = VT_I4;\n\tvt.lVal = -100;\n\treturn func (VT_I4, vt);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_uint_unmanaged(VarFunc func)\n{\n\tVARIANT vt;\n\tvt.vt = VT_UI4;\n\tvt.ulVal = 100;\n\treturn func (VT_UI4, vt);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_long_unmanaged(VarFunc func)\n{\n\tVARIANT vt;\n\tvt.vt = VT_I8;\n\tvt.llVal = -100;\n\treturn func (VT_I8, vt);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_ulong_unmanaged(VarFunc func)\n{\n\tVARIANT vt;\n\tvt.vt = VT_UI8;\n\tvt.ullVal = 100;\n\treturn func (VT_UI8, vt);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_float_unmanaged(VarFunc func)\n{\n\tVARIANT vt;\n\tvt.vt = VT_R4;\n\tvt.fltVal = 3.14;\n\treturn func (VT_R4, vt);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_double_unmanaged(VarFunc func)\n{\n\tVARIANT vt;\n\tvt.vt = VT_R8;\n\tvt.dblVal = 3.14;\n\treturn func (VT_R8, vt);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_bstr_unmanaged(VarFunc func)\n{\n\tVARIANT vt;\n\tvt.vt = VT_BSTR;\n\tvt.bstrVal = marshal_bstr_alloc(\"PI\");\n\treturn func (VT_BSTR, vt);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_bool_true_unmanaged(VarFunc func)\n{\n\tVARIANT vt;\n\tvt.vt = VT_BOOL;\n\tvt.boolVal = VARIANT_TRUE;\n\treturn func (VT_BOOL, vt);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_in_bool_false_unmanaged(VarFunc func)\n{\n\tVARIANT vt;\n\tvt.vt = VT_BOOL;\n\tvt.boolVal = VARIANT_FALSE;\n\treturn func (VT_BOOL, vt);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_sbyte_unmanaged(VarRefFunc func)\n{\n\tVARIANT vt;\n\tVariantInit (&vt);\n\tfunc (VT_I1, &vt);\n\tif (vt.vt == VT_I1 && vt.cVal == -100)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_byte_unmanaged(VarRefFunc func)\n{\n\tVARIANT vt;\n\tVariantInit (&vt);\n\tfunc (VT_UI1, &vt);\n\tif (vt.vt == VT_UI1 && vt.bVal == 100)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_short_unmanaged(VarRefFunc func)\n{\n\tVARIANT vt;\n\tVariantInit (&vt);\n\tfunc (VT_I2, &vt);\n\tif (vt.vt == VT_I2 && vt.iVal == -100)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_ushort_unmanaged(VarRefFunc func)\n{\n\tVARIANT vt;\n\tVariantInit (&vt);\n\tfunc (VT_UI2, &vt);\n\tif (vt.vt == VT_UI2 && vt.uiVal == 100)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_int_unmanaged(VarRefFunc func)\n{\n\tVARIANT vt;\n\tVariantInit (&vt);\n\tfunc (VT_I4, &vt);\n\tif (vt.vt == VT_I4 && vt.lVal == -100)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_uint_unmanaged(VarRefFunc func)\n{\n\tVARIANT vt;\n\tVariantInit (&vt);\n\tfunc (VT_UI4, &vt);\n\tif (vt.vt == VT_UI4 && vt.ulVal == 100)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_long_unmanaged(VarRefFunc func)\n{\n\tVARIANT vt;\n\tVariantInit (&vt);\n\tfunc (VT_I8, &vt);\n\tif (vt.vt == VT_I8 && vt.llVal == -100)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_ulong_unmanaged(VarRefFunc func)\n{\n\tVARIANT vt;\n\tVariantInit (&vt);\n\tfunc (VT_UI8, &vt);\n\tif (vt.vt == VT_UI8 && vt.ullVal == 100)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_float_unmanaged(VarRefFunc func)\n{\n\tVARIANT vt;\n\tVariantInit (&vt);\n\tfunc (VT_R4, &vt);\n\tif (vt.vt == VT_R4 && fabs (vt.fltVal - 3.14f) < 1e-10)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_double_unmanaged(VarRefFunc func)\n{\n\tVARIANT vt;\n\tVariantInit (&vt);\n\tfunc (VT_R8, &vt);\n\tif (vt.vt == VT_R8 && fabs (vt.dblVal - 3.14) < 1e-10)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_bstr_unmanaged(VarRefFunc func)\n{\n\tVARIANT vt;\n\tgchar* bstr_utf8;\n \tgint32 result = 0;\n\n\n\tVariantInit (&vt);\n\tfunc (VT_BSTR, &vt);\n        bstr_utf8 = g_utf16_to_utf8 (vt.bstrVal, -1, NULL, NULL, NULL);\n        result = strcmp(\"PI\", bstr_utf8);\n        g_free(bstr_utf8);\n\tif (vt.vt == VT_BSTR && !result)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_bool_true_unmanaged(VarRefFunc func)\n{\n\tVARIANT vt;\n\tVariantInit (&vt);\n\tfunc (VT_BOOL, &vt);\n\tif (vt.vt == VT_BOOL && vt.boolVal == VARIANT_TRUE)\n\t\treturn 0;\n\treturn 1;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_variant_out_bool_false_unmanaged(VarRefFunc func)\n{\n\tVARIANT vt;\n\tVariantInit (&vt);\n\tfunc (VT_BOOL, &vt);\n\tif (vt.vt == VT_BOOL && vt.boolVal == VARIANT_TRUE)\n\t\treturn 0;\n\treturn 1;\n}\n\ntypedef struct MonoComObject MonoComObject;\ntypedef struct MonoDefItfObject MonoDefItfObject;\n\ntypedef struct\n{\n\tint (STDCALL *QueryInterface)(MonoDefItfObject* pUnk, gpointer riid, gpointer* ppv);\n\tint (STDCALL *AddRef)(MonoDefItfObject* pUnk);\n\tint (STDCALL *Release)(MonoDefItfObject* pUnk);\n\tint (STDCALL *Method)(MonoDefItfObject* pUnk, int *value);\n} MonoDefItf;\n\ntypedef struct\n{\n\tint (STDCALL *QueryInterface)(MonoComObject* pUnk, gpointer riid, gpointer* ppv);\n\tint (STDCALL *AddRef)(MonoComObject* pUnk);\n\tint (STDCALL *Release)(MonoComObject* pUnk);\n\tint (STDCALL *get_ITest)(MonoComObject* pUnk, MonoComObject* *ppUnk);\n\tint (STDCALL *SByteIn)(MonoComObject* pUnk, char a);\n\tint (STDCALL *ByteIn)(MonoComObject* pUnk, unsigned char a);\n\tint (STDCALL *ShortIn)(MonoComObject* pUnk, short a);\n\tint (STDCALL *UShortIn)(MonoComObject* pUnk, unsigned short a);\n\tint (STDCALL *IntIn)(MonoComObject* pUnk, int a);\n\tint (STDCALL *UIntIn)(MonoComObject* pUnk, unsigned int a);\n\tint (STDCALL *LongIn)(MonoComObject* pUnk, gint64 a);\n\tint (STDCALL *ULongIn)(MonoComObject* pUnk, guint64 a);\n\tint (STDCALL *FloatIn)(MonoComObject* pUnk, float a);\n\tint (STDCALL *DoubleIn)(MonoComObject* pUnk, double a);\n\tint (STDCALL *ITestIn)(MonoComObject* pUnk, MonoComObject* pUnk2);\n\tint (STDCALL *ITestOut)(MonoComObject* pUnk, MonoComObject* *ppUnk);\n\tint (STDCALL *Return22NoICall)(MonoComObject* pUnk);\n\tint (STDCALL *IntOut)(MonoComObject* pUnk, int *a);\n\tint (STDCALL *ArrayIn)(MonoComObject* pUnk, void *array);\n\tint (STDCALL *ArrayIn2)(MonoComObject* pUnk, void *array);\n\tint (STDCALL *ArrayIn3)(MonoComObject* pUnk, void *array);\n\tint (STDCALL *GetDefInterface1)(MonoComObject* pUnk, MonoDefItfObject **iface);\n\tint (STDCALL *GetDefInterface2)(MonoComObject* pUnk, MonoDefItfObject **iface);\n} MonoIUnknown;\n\nstruct MonoComObject\n{\n\tMonoIUnknown* vtbl;\n\tint m_ref;\n};\n\nstruct MonoDefItfObject\n{\n\tMonoDefItf* vtbl;\n};\n\nstatic GUID IID_ITest = {0, 0, 0, {0,0,0,0,0,0,0,1}};\nstatic GUID IID_IMonoUnknown = {0, 0, 0, {0xc0,0,0,0,0,0,0,0x46}};\nstatic GUID IID_IMonoDispatch = {0x00020400, 0, 0, {0xc0,0,0,0,0,0,0,0x46}};\nstatic GUID IID_INotImplemented = {0x12345678, 0, 0, {0x9a, 0xbc, 0xde, 0xf0, 0, 0, 0, 0}};\n\nLIBTEST_API int STDCALL\nMonoQueryInterface(MonoComObject* pUnk, gpointer riid, gpointer* ppv)\n{\n\n\t*ppv = NULL;\n\tif (!memcmp(riid, &IID_IMonoUnknown, sizeof(GUID))) {\n\t\t*ppv = pUnk;\n\t\treturn S_OK;\n\t}\n\telse if (!memcmp(riid, &IID_ITest, sizeof(GUID))) {\n\t\t*ppv = pUnk;\n\t\treturn S_OK;\n\t}\n\telse if (!memcmp(riid, &IID_IMonoDispatch, sizeof(GUID))) {\n\t\t*ppv = pUnk;\n\t\treturn S_OK;\n\t}\n\treturn 0x80004002; //E_NOINTERFACE;\n}\n\nLIBTEST_API int STDCALL \nMonoAddRef(MonoComObject* pUnk)\n{\n\treturn ++(pUnk->m_ref);\n}\n\nLIBTEST_API int STDCALL \nMonoRelease(MonoComObject* pUnk)\n{\n\treturn --(pUnk->m_ref);\n}\n\nLIBTEST_API int STDCALL \nSByteIn(MonoComObject* pUnk, char a)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL \nByteIn(MonoComObject* pUnk, unsigned char a)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL \nShortIn(MonoComObject* pUnk, short a)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL \nUShortIn(MonoComObject* pUnk, unsigned short a)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL \nIntIn(MonoComObject* pUnk, int a)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL \nUIntIn(MonoComObject* pUnk, unsigned int a)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL \nLongIn(MonoComObject* pUnk, gint64 a)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL \nULongIn(MonoComObject* pUnk, guint64 a)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL \nFloatIn(MonoComObject* pUnk, float a)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL \nDoubleIn(MonoComObject* pUnk, double a)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL \nITestIn(MonoComObject* pUnk, MonoComObject *pUnk2)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL \nITestOut(MonoComObject* pUnk, MonoComObject* *ppUnk)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL\nReturn22NoICall(MonoComObject* pUnk)\n{\n\treturn 22;\n}\n\nLIBTEST_API int STDCALL\nIntOut(MonoComObject* pUnk, int *a)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL\nArrayIn(MonoComObject* pUnk, void *array)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL\nArrayIn2(MonoComObject* pUnk, void *array)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL\nArrayIn3(MonoComObject* pUnk, void *array)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL\nGetDefInterface1(MonoComObject* pUnk, MonoDefItfObject **obj)\n{\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL\nGetDefInterface2(MonoComObject* pUnk, MonoDefItfObject **obj)\n{\n\treturn S_OK;\n}\n\nstatic void create_com_object (MonoComObject** pOut);\n\nLIBTEST_API int STDCALL \nget_ITest(MonoComObject* pUnk, MonoComObject* *ppUnk)\n{\n\tcreate_com_object (ppUnk);\n\treturn S_OK;\n}\n\nstatic void create_com_object (MonoComObject** pOut)\n{\n\t*pOut = marshal_new0 (MonoComObject, 1);\n\t(*pOut)->vtbl = marshal_new0 (MonoIUnknown, 1);\n\n\t(*pOut)->m_ref = 1;\n\t(*pOut)->vtbl->QueryInterface = MonoQueryInterface;\n\t(*pOut)->vtbl->AddRef = MonoAddRef;\n\t(*pOut)->vtbl->Release = MonoRelease;\n\t(*pOut)->vtbl->SByteIn = SByteIn;\n\t(*pOut)->vtbl->ByteIn = ByteIn;\n\t(*pOut)->vtbl->ShortIn = ShortIn;\n\t(*pOut)->vtbl->UShortIn = UShortIn;\n\t(*pOut)->vtbl->IntIn = IntIn;\n\t(*pOut)->vtbl->UIntIn = UIntIn;\n\t(*pOut)->vtbl->LongIn = LongIn;\n\t(*pOut)->vtbl->ULongIn = ULongIn;\n\t(*pOut)->vtbl->FloatIn = FloatIn;\n\t(*pOut)->vtbl->DoubleIn = DoubleIn;\n\t(*pOut)->vtbl->ITestIn = ITestIn;\n\t(*pOut)->vtbl->ITestOut = ITestOut;\n\t(*pOut)->vtbl->get_ITest = get_ITest;\n\t(*pOut)->vtbl->Return22NoICall = Return22NoICall;\n\t(*pOut)->vtbl->IntOut = IntOut;\n\t(*pOut)->vtbl->ArrayIn = ArrayIn;\n\t(*pOut)->vtbl->ArrayIn2 = ArrayIn2;\n\t(*pOut)->vtbl->ArrayIn3 = ArrayIn3;\n\t(*pOut)->vtbl->GetDefInterface1 = GetDefInterface1;\n\t(*pOut)->vtbl->GetDefInterface2 = GetDefInterface2;\n}\n\nstatic MonoComObject* same_object = NULL;\n\nLIBTEST_API int STDCALL \nmono_test_marshal_com_object_create(MonoComObject* *pUnk)\n{\n\tcreate_com_object (pUnk);\n\n\tif (!same_object)\n\t\tsame_object = *pUnk;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_com_object_same(MonoComObject* *pUnk)\n{\n\t*pUnk = same_object;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_com_object_destroy(MonoComObject *pUnk)\n{\n\tint ref = --(pUnk->m_ref);\n\tg_free(pUnk->vtbl);\n\tg_free(pUnk);\n\n\treturn ref;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_com_object_ref_count(MonoComObject *pUnk)\n{\n\treturn pUnk->m_ref;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_ccw_itest (MonoComObject *pUnk)\n{\n\tint hr = 0;\n\tMonoComObject* pTest;\n\n\tif (!pUnk)\n\t\treturn 1;\n\n\thr = pUnk->vtbl->SByteIn (pUnk, -100);\n\tif (hr != 0)\n\t\treturn 2;\n\thr = pUnk->vtbl->ByteIn (pUnk, 100);\n\tif (hr != 0)\n\t\treturn 3;\n\thr = pUnk->vtbl->ShortIn (pUnk, -100);\n\tif (hr != 0)\n\t\treturn 4;\n\thr = pUnk->vtbl->UShortIn (pUnk, 100);\n\tif (hr != 0)\n\t\treturn 5;\n\thr = pUnk->vtbl->IntIn (pUnk, -100);\n\tif (hr != 0)\n\t\treturn 6;\n\thr = pUnk->vtbl->UIntIn (pUnk, 100);\n\tif (hr != 0)\n\t\treturn 7;\n\thr = pUnk->vtbl->LongIn (pUnk, -100);\n\tif (hr != 0)\n\t\treturn 8;\n\thr = pUnk->vtbl->ULongIn (pUnk, 100);\n\tif (hr != 0)\n\t\treturn 9;\n\thr = pUnk->vtbl->FloatIn (pUnk, 3.14f);\n\tif (hr != 0)\n\t\treturn 10;\n\thr = pUnk->vtbl->DoubleIn (pUnk, 3.14);\n\tif (hr != 0)\n\t\treturn 11;\n\thr = pUnk->vtbl->ITestIn (pUnk, pUnk);\n\tif (hr != 0)\n\t\treturn 12;\n\thr = pUnk->vtbl->ITestOut (pUnk, &pTest);\n\tif (hr != 0)\n\t\treturn 13;\n\n\treturn 0;\n}\n\n// Xamarin-47560\nLIBTEST_API int STDCALL\nmono_test_marshal_array_ccw_itest (int count, MonoComObject ** ppUnk)\n{\n\tint hr = 0;\n\n\tif (!ppUnk)\n\t\treturn 1;\n\n\tif (count < 1)\n\t\treturn 2;\n\n\tif (!ppUnk[0])\n\t\treturn 3;\n\n\thr = ppUnk[0]->vtbl->SByteIn (ppUnk[0], -100);\n\tif (hr != 0)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL\nmono_test_marshal_retval_ccw_itest (MonoComObject *pUnk, int test_null)\n{\n\tint hr = 0, i = 0;\n\n\tif (!pUnk)\n\t\treturn 1;\n\n\thr = pUnk->vtbl->IntOut (pUnk, &i);\n\tif (hr != 0)\n\t\treturn 2;\n\tif (i != 33)\n\t\treturn 3;\n\tif (test_null)\n\t{\n\t\thr = pUnk->vtbl->IntOut (pUnk, NULL);\n\t\tif (hr != 0)\n\t\t\treturn 4;\n\t}\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL\nmono_test_default_interface_ccw (MonoComObject *pUnk)\n{\n\tMonoDefItfObject *obj;\n\tint ret, value;\n\n\tret = pUnk->vtbl->GetDefInterface1(pUnk, &obj);\n\tif (ret)\n\t\treturn 1;\n\tvalue = 0;\n\n\tret = obj->vtbl->Method(obj, &value);\n\tobj->vtbl->Release(obj);\n\tif (ret)\n\t\treturn 2;\n\tif (value != 1)\n\t\treturn 3;\n\n\tret = pUnk->vtbl->GetDefInterface2(pUnk, &obj);\n\tif (ret)\n\t\treturn 4;\n\tret = obj->vtbl->Method(obj, &value);\n\tobj->vtbl->Release(obj);\n\tif (ret)\n\t\treturn 5;\n\tif (value != 2)\n\t\treturn 6;\n\n\treturn 0;\n}\n\n/*\n * mono_method_get_unmanaged_thunk tests\n */\n\n#if defined(__GNUC__) && ((defined(__i386__) && (defined(__linux__) || defined (__APPLE__)) || defined (__FreeBSD__) || defined(__OpenBSD__)) || (defined(__ppc__) && defined(__APPLE__)))\n#define ALIGN(size) __attribute__ ((__aligned__(size)))\n#else\n#define ALIGN(size)\n#endif\n\n\n/* thunks.cs:TestStruct */\ntypedef struct _TestStruct {\n\tint A;\n\tdouble B;\n} TestStruct;\n\n/* Searches for mono symbols in all loaded modules */\nstatic gpointer\nlookup_mono_symbol (const char *symbol_name)\n{\n\tgpointer symbol = NULL;\n\tconst gboolean success = g_module_symbol (g_module_open (NULL, G_MODULE_BIND_LAZY), symbol_name, &symbol);\n\tg_assertf (success, \"%s\", symbol_name);\n\treturn success ? symbol : NULL;\n}\n\nLIBTEST_API gpointer STDCALL\nmono_test_marshal_lookup_symbol (const char *symbol_name)\n{\n\treturn lookup_mono_symbol (symbol_name);\n}\n\n\n// FIXME use runtime headers\n#define MONO_BEGIN_EFRAME { void *__dummy; void *__region_cookie = mono_threads_enter_gc_unsafe_region ? mono_threads_enter_gc_unsafe_region (&__dummy) : NULL;\n#define MONO_END_EFRAME if (mono_threads_exit_gc_unsafe_region) mono_threads_exit_gc_unsafe_region (__region_cookie, &__dummy); }\n\n/**\n * test_method_thunk:\n *\n * @test_id: the test number\n * @test_method_handle: MonoMethod* of the C# test method\n * @create_object_method_handle: MonoMethod* of thunks.cs:Test.CreateObject\n */\nLIBTEST_API int STDCALL  \ntest_method_thunk (int test_id, gpointer test_method_handle, gpointer create_object_method_handle)\n{\n\tint ret = 0;\n\n\t// FIXME use runtime headers\n\tgpointer (*mono_method_get_unmanaged_thunk)(gpointer)\n\t\t= (gpointer (*)(gpointer))lookup_mono_symbol (\"mono_method_get_unmanaged_thunk\");\n\n\t// FIXME use runtime headers\n\tgpointer (*mono_string_new_wrapper)(const char *)\n\t\t= (gpointer (*)(const char *))lookup_mono_symbol (\"mono_string_new_wrapper\");\n\n\t// FIXME use runtime headers\n\tchar *(*mono_string_to_utf8)(gpointer)\n\t\t= (char *(*)(gpointer))lookup_mono_symbol (\"mono_string_to_utf8\");\n\n\t// FIXME use runtime headers\n\tgpointer (*mono_object_unbox)(gpointer)\n\t\t= (gpointer (*)(gpointer))lookup_mono_symbol (\"mono_object_unbox\");\n\n\t// FIXME use runtime headers\n\tgpointer (*mono_threads_enter_gc_unsafe_region) (gpointer)\n\t\t= (gpointer (*)(gpointer))lookup_mono_symbol (\"mono_threads_enter_gc_unsafe_region\");\n\n\t// FIXME use runtime headers\n\tvoid (*mono_threads_exit_gc_unsafe_region) (gpointer, gpointer)\n\t\t= (void (*)(gpointer, gpointer))lookup_mono_symbol (\"mono_threads_exit_gc_unsafe_region\");\n\n\t\n\n\tgpointer test_method, ex = NULL;\n\tgpointer (STDCALL *CreateObject)(gpointer*);\n\n\tMONO_BEGIN_EFRAME;\n\n\tif (!mono_method_get_unmanaged_thunk) {\n\t\tret = 1;\n\t\tgoto done;\n\t}\n\n\ttest_method =  mono_method_get_unmanaged_thunk (test_method_handle);\n\tif (!test_method) {\n\t\tret = 2;\n\t\tgoto done;\n\t}\n\n\tCreateObject = (gpointer (STDCALL *)(gpointer *))mono_method_get_unmanaged_thunk (create_object_method_handle);\n\tif (!CreateObject) {\n\t\tret = 3;\n\t\tgoto done;\n\t}\n\t\n\n\tswitch (test_id) {\n\n\tcase 0: {\n\t\t/* thunks.cs:Test.Test0 */\n\t\tvoid (STDCALL *F)(gpointer *) = (void (STDCALL *)(gpointer *))test_method;\n\t\tF (&ex);\n\t\tbreak;\n\t}\n\n\tcase 1: {\n\t\t/* thunks.cs:Test.Test1 */\n\t\tint (STDCALL *F)(gpointer *) = (int (STDCALL *)(gpointer *))test_method;\n\t\tif (F (&ex) != 42) {\n\t\t\tret = 4;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase 2: {\n\t\t/* thunks.cs:Test.Test2 */\n\t\tgpointer (STDCALL *F)(gpointer, gpointer*) = (gpointer (STDCALL *)(gpointer, gpointer *))test_method;\n\t\tgpointer str = mono_string_new_wrapper (\"foo\");\n\t\tif (str != F (str, &ex)) {\n\t\t\tret = 4;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase 3: {\n\t\t/* thunks.cs:Test.Test3 */\n\t\tgpointer (STDCALL *F)(gpointer, gpointer, gpointer*);\n\t\tgpointer obj;\n\t\tgpointer str;\n\n\t\tF = (gpointer (STDCALL *)(gpointer, gpointer, gpointer *))test_method;\n\t\tobj = CreateObject (&ex);\n\t\tstr = mono_string_new_wrapper (\"bar\");\n\n\t\tif (str != F (obj, str, &ex)) {\n\t\t\tret = 4;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase 4: {\n\t\t/* thunks.cs:Test.Test4 */\n\t\tint (STDCALL *F)(gpointer, gpointer, int, gpointer*);\n\t\tgpointer obj;\n\t\tgpointer str;\n\n\t\tF = (int (STDCALL *)(gpointer, gpointer, int, gpointer *))test_method;\n\t\tobj = CreateObject (&ex);\n\t\tstr = mono_string_new_wrapper (\"bar\");\n\n\t\tif (42 != F (obj, str, 42, &ex)) {\n\t\t\tret = 4;\n\t\t\tgoto done;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase 5: {\n\t\t/* thunks.cs:Test.Test5 */\n\t\tint (STDCALL *F)(gpointer, gpointer, int, gpointer*);\n\t\tgpointer obj;\n\t\tgpointer str;\n\n\t\tF = (int (STDCALL *)(gpointer, gpointer, int, gpointer *))test_method;\n\t\tobj = CreateObject (&ex);\n\t\tstr = mono_string_new_wrapper (\"bar\");\n\n\t\tF (obj, str, 42, &ex);\n\t\tif (!ex) {\n\t\t\tret = 4;\n\t\t\tgoto done;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase 6: {\n\t\t/* thunks.cs:Test.Test6 */\n\t\tint (STDCALL *F)(gpointer, guint8, gint16, gint32, gint64, float, double,\n\t\t\t\t gpointer, gpointer*);\n\t\tgpointer obj;\n\t\tgpointer str = mono_string_new_wrapper (\"Test6\");\n\t\tint res;\n\n\t\tF = (int (STDCALL *)(gpointer, guint8, gint16, gint32, gint64, float, double, gpointer, gpointer *))test_method;\n\t\tobj = CreateObject (&ex);\n\n\t\tres = F (obj, 254, 32700, -245378, 6789600, 3.1415, 3.1415, str, &ex);\n\t\tif (ex) {\n\t\t\tret = 4;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!res) {\n\t\t\tret = 5;\n\t\t\tgoto done;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase 7: {\n\t\t/* thunks.cs:Test.Test7 */\n\t\tgint64 (STDCALL *F)(gpointer*) = (gint64 (STDCALL *)(gpointer *))test_method;\n\t\tif (F (&ex) != G_MAXINT64) {\n\t\t\tret = 4;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase 8: {\n\t\t/* thunks.cs:Test.Test8 */\n\t\tvoid (STDCALL *F)(guint8*, gint16*, gint32*, gint64*, float*, double*,\n\t\t\t\t gpointer*, gpointer*);\n\n\t\tguint8 a1;\n\t\tgint16 a2;\n\t\tgint32 a3;\n\t\tgint64 a4;\n\t\tfloat a5;\n\t\tdouble a6;\n\t\tgpointer a7;\n\n\t\tF = (void (STDCALL *)(guint8 *, gint16 *, gint32 *, gint64 *, float *, double *,\n\t\t\tgpointer *, gpointer *))test_method;\n\n\t\tF (&a1, &a2, &a3, &a4, &a5, &a6, &a7, &ex);\n\t\tif (ex) {\n\t\t\tret = 4;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!(a1 == 254 &&\n\t\t      a2 == 32700 &&\n\t\t      a3 == -245378 &&\n\t\t      a4 == 6789600 &&\n\t\t      (fabs (a5 - 3.1415) < 0.001) &&\n\t\t      (fabs (a6 - 3.1415) < 0.001) &&\n\t\t      strcmp (mono_string_to_utf8 (a7), \"Test8\") == 0)){\n\t\t\t\tret = 5;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase 9: {\n\t\t/* thunks.cs:Test.Test9 */\n\t\tvoid (STDCALL *F)(guint8*, gint16*, gint32*, gint64*, float*, double*,\n\t\t\tgpointer*, gpointer*);\n\n\t\tguint8 a1;\n\t\tgint16 a2;\n\t\tgint32 a3;\n\t\tgint64 a4;\n\t\tfloat a5;\n\t\tdouble a6;\n\t\tgpointer a7;\n\n\t\tF = (void (STDCALL *)(guint8 *, gint16 *, gint32 *, gint64 *, float *, double *,\n\t\t\tgpointer *, gpointer *))test_method;\n\n\t\tF (&a1, &a2, &a3, &a4, &a5, &a6, &a7, &ex);\n\t\tif (!ex) {\n\t\t\tret = 4;\n\t\t\tgoto done;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase 10: {\n\t\t/* thunks.cs:Test.Test10 */\n\t\tvoid (STDCALL *F)(gpointer*, gpointer*);\n\n\t\tgpointer obj1, obj2;\n\n\t\tobj1 = obj2 = CreateObject (&ex);\n\t\tif (ex) {\n\t\t\tret = 4;\n\t\t\tgoto done;\n\t\t}\n\n\t\tF = (void (STDCALL *)(gpointer *, gpointer *))test_method;\n\n\t\tF (&obj1, &ex);\n\t\tif (ex) {\n\t\t\tret = 5;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (obj1 == obj2) {\n\t\t\tret = 6;\n\t\t\tgoto done;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase 100: {\n\t\t/* thunks.cs:TestStruct.Test0 */\n\t\tint (STDCALL *F)(gpointer*, gpointer*);\n\n\t\tgpointer obj;\n\t\tTestStruct *a1;\n\t\tint res;\n\n\t\tobj = CreateObject (&ex);\n\t\tif (ex) {\n\t\t\tret = 4;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!obj) {\n\t\t\tret = 5;\n\t\t\tgoto done;\n\t\t}\n\n\t\ta1 = (TestStruct *)mono_object_unbox (obj);\n\t\tif (!a1) {\n\t\t\tret = 6;\n\t\t\tgoto done;\n\t\t}\n\n\t\ta1->A = 42;\n\t\ta1->B = 3.1415;\n\n\t\tF = (int (STDCALL *)(gpointer *, gpointer *))test_method;\n\n\t\tres = F ((gpointer *)obj, &ex);\n\t\tif (ex) {\n\t\t\tret = 7;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!res) {\n\t\t\tret = 8;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* check whether the call was really by value */\n\t\tif (a1->A != 42 || a1->B != 3.1415) {\n\t\t\tret = 9;\n\t\t\tgoto done;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase 101: {\n\t\t/* thunks.cs:TestStruct.Test1 */\n\t\tvoid (STDCALL *F)(gpointer, gpointer*);\n\n\t\tTestStruct *a1;\n\t\tgpointer obj;\n\n\t\tobj = CreateObject (&ex);\n\t\tif (ex) {\n\t\t\tret = 4;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!obj) {\n\t\t\tret = 5;\n\t\t\tgoto done;\n\t\t}\n\n\t\ta1 = (TestStruct *)mono_object_unbox (obj);\n\t\tif (!a1) {\n\t\t\tret = 6;\n\t\t\tgoto done;\n\t\t}\n\n\t\tF = (void (STDCALL *)(gpointer, gpointer *))test_method;\n\n\t\tF (obj, &ex);\n\t\tif (ex) {\n\t\t\tret = 7;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (a1->A != 42) {\n\t\t\tret = 8;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!(fabs (a1->B - 3.1415) < 0.001)) {\n\t\t\tret = 9;\n\t\t\tgoto done;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase 102: {\n\t\t/* thunks.cs:TestStruct.Test2 */\n\t\tgpointer (STDCALL *F)(gpointer*);\n\n\t\tTestStruct *a1;\n\t\tgpointer obj;\n\n\t\tF = (gpointer (STDCALL *)(gpointer *))test_method;\n\n\t\tobj = F (&ex);\n\t\tif (ex) {\n\t\t\tret = 4;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!obj) {\n\t\t\tret = 5;\n\t\t\tgoto done;\n\t\t}\n\n\t\ta1 = (TestStruct *)mono_object_unbox (obj);\n\n\t\tif (a1->A != 42) {\n\t\t\tret = 5;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!(fabs (a1->B - 3.1415) < 0.001)) {\n\t\t\tret = 6;\n\t\t\tgoto done;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase 103: {\n\t\t/* thunks.cs:TestStruct.Test3 */\n\t\tvoid (STDCALL *F)(gpointer, gpointer*);\n\n\t\tTestStruct *a1;\n\t\tgpointer obj;\n\n\t\tobj = CreateObject (&ex);\n\t\tif (ex) {\n\t\t\tret = 4;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!obj) {\n\t\t\tret = 5;\n\t\t\tgoto done;\n\t\t}\n\t\t\n\t\ta1 = (TestStruct *)mono_object_unbox (obj);\n\n\t\tif (!a1) {\n\t\t\tret = 6;\n\t\t\tgoto done;\n\t\t}\n\n\t\ta1->A = 42;\n\t\ta1->B = 3.1415;\n\n\t\tF = (void (STDCALL *)(gpointer, gpointer *))test_method;\n\n\t\tF (obj, &ex);\n\t\tif (ex) {\n\t\t\tret = 4;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (a1->A != 1) {\n\t\t\tret = 5;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (a1->B != 17) {\n\t\t\tret = 6;\n\t\t\tgoto done;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tret = 9;\n\n\t}\ndone:\n\tMONO_END_EFRAME;\n\n\treturn ret;\n}\n\ntypedef struct \n{\n\tchar a;\n} winx64_struct1;\n\nLIBTEST_API int STDCALL  \nmono_test_Winx64_struct1_in (winx64_struct1 var)\n{\n\tif (var.a != 123)\n\t\treturn 1;\n\treturn 0;\n}\n\ntypedef struct\n{\n\tchar a;\n\tchar b;\n} winx64_struct2;\n\nLIBTEST_API int STDCALL  \nmono_test_Winx64_struct2_in (winx64_struct2 var)\n{\n\tif (var.a != 4)\n\t\treturn 1;\n\tif (var.b != 5)\n\t\treturn 2;\n\treturn 0;\n}\n\n\ntypedef struct\n{\n\tchar a;\n\tchar b;\n\tshort c;\n} winx64_struct3;\n\nLIBTEST_API int STDCALL  \nmono_test_Winx64_struct3_in (winx64_struct3 var)\n{\n\tif (var.a != 4)\n\t\treturn 1;\n\tif (var.b != 5)\n\t\treturn 2;\n\tif (var.c != 0x1234)\n\t\treturn 3;\n\treturn 0;\n}\n\ntypedef struct\n{\n\tchar a;\n\tchar b;\n\tshort c;\n\tunsigned int d;\n} winx64_struct4;\n\nLIBTEST_API int STDCALL  \nmono_test_Winx64_struct4_in (winx64_struct4 var)\n{\n\tif (var.a != 4)\n\t\treturn 1;\n\tif (var.b != 5)\n\t\treturn 2;\n\tif (var.c != 0x1234)\n\t\treturn 3;\n\tif (var.d != 0x87654321)\n\t\treturn 4;\n\treturn 0;\n}\n\ntypedef struct\n{\n\tchar a;\n\tchar b;\n\tchar c;\n} winx64_struct5;\n\nLIBTEST_API int STDCALL  \nmono_test_Winx64_struct5_in (winx64_struct5 var)\n{\n\tif (var.a != 4)\n\t\treturn 1;\n\tif (var.b != 5)\n\t\treturn 2;\n\tif (var.c != 6)\n\t\treturn 3;\n\treturn 0;\n}\n\ntypedef struct\n{\n\twinx64_struct1 a;\n\tshort b;\n\tchar c;\n} winx64_struct6;\n\nLIBTEST_API int STDCALL  \nmono_test_Winx64_struct6_in (winx64_struct6 var)\n{\n\tif (var.a.a != 4)\n\t\treturn 1;\n\tif (var.b != 5)\n\t\treturn 2;\n\tif (var.c != 6)\n\t\treturn 3;\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_Winx64_structs_in1 (winx64_struct1 var1,\n\t\t\t winx64_struct2 var2,\n\t\t\t winx64_struct3 var3,\n\t\t\t winx64_struct4 var4)\n{\n\tif (var1.a != 123)\n\t\treturn 1;\n\t\n\tif (var2.a != 4)\n\t\treturn 2;\n\tif (var2.b != 5)\n\t\treturn 3;\n\t\n\tif (var3.a != 4)\n\t\treturn 4;\n\tif (var3.b != 5)\n\t\treturn 2;\n\tif (var3.c != 0x1234)\n\t\treturn 5;\n\t\n\tif (var4.a != 4)\n\t\treturn 6;\n\tif (var4.b != 5)\n\t\treturn 7;\n\tif (var4.c != 0x1234)\n\t\treturn 8;\n\tif (var4.d != 0x87654321)\n\t\treturn 9;\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_Winx64_structs_in2 (winx64_struct1 var1,\n\t\t\t winx64_struct1 var2,\n\t\t\t winx64_struct1 var3,\n\t\t\t winx64_struct1 var4,\n\t\t\t winx64_struct1 var5)\n{\n\tif (var1.a != 1)\n\t\treturn 1;\n\tif (var2.a != 2)\n\t\treturn 2;\n\tif (var3.a != 3)\n\t\treturn 3;\n\tif (var4.a != 4)\n\t\treturn 4;\n\tif (var5.a != 5)\n\t\treturn 5;\n\t\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL  \nmono_test_Winx64_structs_in3 (winx64_struct1 var1,\n\t\t\t winx64_struct5 var2,\n\t\t\t winx64_struct1 var3,\n\t\t\t winx64_struct5 var4,\n\t\t\t winx64_struct1 var5,\n\t\t\t winx64_struct5 var6)\n{\n\tif (var1.a != 1)\n\t\treturn 1;\n\t\n\tif (var2.a != 2)\n\t\treturn 2;\n\tif (var2.b != 3)\n\t\treturn 2;\n\tif (var2.c != 4)\n\t\treturn 4;\n\t\n\tif (var3.a != 5)\n\t\treturn 5;\n\t\n\tif (var4.a != 6)\n\t\treturn 6;\n\tif (var4.b != 7)\n\t\treturn 7;\n\tif (var4.c != 8)\n\t\treturn 8;\n\t\n\tif (var5.a != 9)\n\t\treturn 9;\n\n\tif (var6.a != 10)\n\t\treturn 10;\n\tif (var6.b != 11)\n\t\treturn 11;\n\tif (var6.c != 12)\n\t\treturn 12;\n\t\n\treturn 0;\n}\n\nLIBTEST_API winx64_struct1 STDCALL  \nmono_test_Winx64_struct1_ret (void)\n{\n\twinx64_struct1 ret;\n\tret.a = 123;\n\treturn ret;\n}\n\nLIBTEST_API winx64_struct2 STDCALL  \nmono_test_Winx64_struct2_ret (void)\n{\n\twinx64_struct2 ret;\n\tret.a = 4;\n\tret.b = 5;\n\treturn ret;\n}\n\nLIBTEST_API winx64_struct3 STDCALL  \nmono_test_Winx64_struct3_ret (void)\n{\n\twinx64_struct3 ret;\n\tret.a = 4;\n\tret.b = 5;\n\tret.c = 0x1234;\n\treturn ret;\n}\n\nLIBTEST_API winx64_struct4 STDCALL  \nmono_test_Winx64_struct4_ret (void)\n{\n\twinx64_struct4 ret;\n\tret.a = 4;\n\tret.b = 5;\n\tret.c = 0x1234;\n\tret.d = 0x87654321;\n\treturn ret;\n}\n\nLIBTEST_API winx64_struct5 STDCALL  \nmono_test_Winx64_struct5_ret (void)\n{\n\twinx64_struct5 ret;\n\tret.a = 4;\n\tret.b = 5;\n\tret.c = 6;\n\treturn ret;\n}\n\nLIBTEST_API winx64_struct1 STDCALL  \nmono_test_Winx64_struct1_ret_5_args (char a, char b, char c, char d, char e)\n{\n\twinx64_struct1 ret;\n\tret.a = a + b + c + d + e;\n\treturn ret;\n}\n\nLIBTEST_API winx64_struct5 STDCALL\nmono_test_Winx64_struct5_ret6_args (char a, char b, char c, char d, char e)\n{\n\twinx64_struct5 ret;\n\tret.a = a + b;\n\tret.b = c + d;\n\tret.c = e;\n\treturn ret;\n}\n\ntypedef struct\n{\n\tfloat a;\n\tfloat b;\n} winx64_floatStruct;\n\nLIBTEST_API int STDCALL  \nmono_test_Winx64_floatStruct (winx64_floatStruct a)\n{\n\tif (a.a > 5.6 || a.a < 5.4)\n\t\treturn 1;\n\n\tif (a.b > 9.6 || a.b < 9.4)\n\t\treturn 2;\n\t\n\treturn 0;\n}\n\ntypedef struct\n{\n\tdouble a;\n} winx64_doubleStruct;\n\nLIBTEST_API int STDCALL  \nmono_test_Winx64_doubleStruct (winx64_doubleStruct a)\n{\n\tif (a.a > 5.6 || a.a < 5.4)\n\t\treturn 1;\n\t\n\treturn 0;\n}\n\ntypedef int (STDCALL *managed_struct1_delegate) (winx64_struct1 a);\n\nLIBTEST_API int STDCALL \nmono_test_managed_Winx64_struct1_in(managed_struct1_delegate func)\n{\n\twinx64_struct1 val;\n\tval.a = 5;\n\treturn func (val);\n}\n\ntypedef int (STDCALL *managed_struct5_delegate) (winx64_struct5 a);\n\nLIBTEST_API int STDCALL \nmono_test_managed_Winx64_struct5_in(managed_struct5_delegate func)\n{\n\twinx64_struct5 val;\n\tval.a = 5;\n\tval.b = 0x10;\n\tval.c = 0x99;\n\treturn func (val);\n}\n\ntypedef int (STDCALL *managed_struct1_struct5_delegate) (winx64_struct1 a, winx64_struct5 b,\n\t\t\t\t\t\t\t winx64_struct1 c, winx64_struct5 d,\n\t\t\t\t\t\t\t winx64_struct1 e, winx64_struct5 f);\n\nLIBTEST_API int STDCALL \nmono_test_managed_Winx64_struct1_struct5_in(managed_struct1_struct5_delegate func)\n{\n\twinx64_struct1 a, c, e;\n\twinx64_struct5 b, d, f;\n\ta.a = 1;\n\tb.a = 2; b.b = 3; b.c = 4;\n\tc.a = 5;\n\td.a = 6; d.b = 7; d.c = 8;\n\te.a = 9;\n\tf.a = 10; f.b = 11; f.c = 12;\n\n\treturn func (a, b, c, d, e, f);\n}\n\ntypedef winx64_struct1 (STDCALL *managed_struct1_ret_delegate) (void);\n\nLIBTEST_API int STDCALL \nmono_test_Winx64_struct1_ret_managed (managed_struct1_ret_delegate func)\n{\n\twinx64_struct1 ret;\n\n\tret = func ();\n\n\tif (ret.a != 0x45)\n\t\treturn 1;\n\t\n\treturn 0;\n}\n\ntypedef winx64_struct5 (STDCALL *managed_struct5_ret_delegate) (void);\n\nLIBTEST_API int STDCALL \nmono_test_Winx64_struct5_ret_managed (managed_struct5_ret_delegate func)\n{\n\twinx64_struct5 ret;\n\n\tret = func ();\n\n\tif (ret.a != 0x12)\n\t\treturn 1;\n\tif (ret.b != 0x34)\n\t\treturn 2;\n\tif (ret.c != 0x56)\n\t\treturn 3;\n\t\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_bool_in (int arg, unsigned int expected, unsigned int bDefaultMarsh, unsigned int bBoolCustMarsh,\n\t\t\t   char bI1CustMarsh, unsigned char bU1CustMarsh, short bVBCustMarsh)\n{\n\tswitch (arg) {\n\tcase 1:\t\n\t\tif (bDefaultMarsh != expected)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 2:\t\n\t\tif (bBoolCustMarsh != expected)\n\t\t\treturn 2;\n\t\tbreak;\n\tcase 3:\t\n\t\tif (bI1CustMarsh != expected)\n\t\t\treturn 3;\n\t\tbreak;\n\tcase 4:\t\n\t\tif (bU1CustMarsh != expected)\n\t\t\treturn 4;\n\t\tbreak;\n\tcase 5:\t\n\t\tif (bVBCustMarsh != expected)\n\t\t\treturn 5;\n\t\tbreak;\n\tdefault:\n\t\treturn 999;\t\t\n\t}\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_bool_out (int arg, unsigned int testVal, unsigned int* bDefaultMarsh, unsigned int* bBoolCustMarsh,\n\t\t\t   char* bI1CustMarsh, unsigned char* bU1CustMarsh, unsigned short* bVBCustMarsh)\n{\n\tswitch (arg) {\n\tcase 1:\t\n\t\tif (!bDefaultMarsh)\n\t\t\treturn 1;\n\t\t*bDefaultMarsh = testVal;\n\t\tbreak;\t\n\tcase 2:\t\n\t\tif (!bBoolCustMarsh)\n\t\t\treturn 2;\n\t\t*bBoolCustMarsh = testVal;\n\t\tbreak;\t\n\tcase 3:\t\n\t\tif (!bI1CustMarsh)\n\t\t\treturn 3;\n\t\t*bI1CustMarsh = (char)testVal;\n\t\tbreak;\t\n\tcase 4:\t\n\t\tif (!bU1CustMarsh)\n\t\t\treturn 4;\n\t\t*bU1CustMarsh = (unsigned char)testVal;\n\t\tbreak;\t\n\tcase 5:\t\n\t\tif (!bVBCustMarsh)\n\t\t\treturn 5;\n\t\t*bVBCustMarsh = (unsigned short)testVal;\n\t\tbreak;\t\n\tdefault:\n\t\treturn 999;\n\t}\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_bool_ref (int arg, unsigned int expected, unsigned int testVal, unsigned int* bDefaultMarsh,\n\t\t\t    unsigned int* bBoolCustMarsh, char* bI1CustMarsh, unsigned char* bU1CustMarsh, \n\t\t\t    unsigned short* bVBCustMarsh)\n{\n\tswitch (arg) {\n\tcase 1:\t\n\t\tif (!bDefaultMarsh)\n\t\t\treturn 1;\n\t\tif (*bDefaultMarsh != expected)\n\t\t\treturn 2;\n\t\t*bDefaultMarsh = testVal;\n\t\tbreak;\n\tcase 2:\t\n\t\tif (!bBoolCustMarsh)\n\t\t\treturn 3;\n\t\tif (*bBoolCustMarsh != expected)\n\t\t\treturn 4;\n\t\t*bBoolCustMarsh = testVal;\n\t\tbreak;\n\tcase 3:\t\n\t\tif (!bI1CustMarsh)\n\t\t\treturn 5;\n\t\tif (*bI1CustMarsh != expected)\n\t\t\treturn 6;\n\t\t*bI1CustMarsh = (char)testVal;\n\t\tbreak;\n\tcase 4:\t\n\t\tif (!bU1CustMarsh)\n\t\t\treturn 7;\n\t\tif (*bU1CustMarsh != expected)\n\t\t\treturn 8;\n\t\t*bU1CustMarsh = (unsigned char)testVal;\n\t\tbreak;\n\tcase 5:\t\n\t\tif (!bVBCustMarsh)\n\t\t\treturn 9;\n\t\tif (*bVBCustMarsh != expected)\n\t\t\treturn 10;\n\t\t*bVBCustMarsh = (unsigned short)testVal;\n\t\tbreak;\n\tdefault:\n\t\treturn 999;\t\t\n\t}\n\treturn 0;\n}\n\n\ntypedef int (STDCALL *MarshalBoolInDelegate) (int arg, unsigned int expected, unsigned int bDefaultMarsh,\n\tunsigned int bBoolCustMarsh, char bI1CustMarsh, unsigned char bU1CustMarsh, unsigned short bVBCustMarsh);\n\nLIBTEST_API int STDCALL \nmono_test_managed_marshal_bool_in (int arg, unsigned int expected, unsigned int testVal, MarshalBoolInDelegate pfcn)\n{\n\tif (!pfcn)\n\t\treturn 0x9900;\n\n\tswitch (arg) {\n\tcase 1:\n\t\treturn pfcn (arg, expected, testVal, 0, 0, 0, 0);\n\tcase 2:\n\t\treturn pfcn (arg, expected, 0, testVal,  0, 0, 0);\n\tcase 3:\n\t\treturn pfcn (arg, expected, 0, 0, testVal, 0, 0);\n\tcase 4:\n\t\treturn pfcn (arg, expected, 0, 0, 0, testVal, 0);\n\tcase 5:\n\t\treturn pfcn (arg, expected, 0, 0, 0, 0, testVal);\n\tdefault:\n\t\treturn 0x9800;\n\t}\n\n\treturn 0;\n}\n\ntypedef int (STDCALL *MarshalBoolOutDelegate) (int arg, unsigned int expected, unsigned int* bDefaultMarsh,\n\tunsigned int* bBoolCustMarsh, char* bI1CustMarsh, unsigned char* bU1CustMarsh, unsigned short* bVBCustMarsh);\n\nLIBTEST_API int STDCALL \nmono_test_managed_marshal_bool_out (int arg, unsigned int expected, unsigned int testVal, MarshalBoolOutDelegate pfcn)\n{\n\tint ret;\n\tunsigned int lDefaultMarsh, lBoolCustMarsh;\n\tchar lI1CustMarsh = 0;\n\tunsigned char lU1CustMarsh = 0;\n\tunsigned short lVBCustMarsh = 0;\n\tlDefaultMarsh = lBoolCustMarsh = 0;\n\n\tif (!pfcn)\n\t\treturn 0x9900;\n\n\tswitch (arg) {\n\tcase 1: {\n\t\tunsigned int ltVal = 0;\n\t\tret = pfcn (arg, testVal, &ltVal, &lBoolCustMarsh, &lI1CustMarsh, &lU1CustMarsh, &lVBCustMarsh);\n\t\tif (ret)\n\t\t\treturn 0x0100 + ret;\n\t\tif (expected != ltVal)\n\t\t\treturn 0x0200;\n\t\tbreak;\n\t}\n\tcase 2: {\n\t\tunsigned int ltVal = 0;\n\t\tret = pfcn (arg, testVal, &lDefaultMarsh, &ltVal, &lI1CustMarsh, &lU1CustMarsh, &lVBCustMarsh);\n\t\tif (ret)\n\t\t\treturn 0x0300 + ret;\n\t\tif (expected != ltVal)\n\t\t\treturn 0x0400;\n\t\tbreak;\n\t}\n\tcase 3: {\n\t\tchar ltVal = 0;\n\t\tret = pfcn (arg, testVal, &lDefaultMarsh, &lBoolCustMarsh, &ltVal, &lU1CustMarsh, &lVBCustMarsh);\n\t\tif (ret)\n\t\t\treturn 0x0500 + ret;\n\t\tif (expected != ltVal)\n\t\t\treturn 0x0600;\n\t\tbreak;\n\t}\n\tcase 4: {\n\t\tunsigned char ltVal = 0;\n\t\tret = pfcn (arg, testVal, &lDefaultMarsh, &lBoolCustMarsh, &lI1CustMarsh, &ltVal, &lVBCustMarsh);\n\t\tif (ret)\n\t\t\treturn 0x0700 + ret;\n\t\tif (expected != ltVal)\n\t\t\treturn 0x0800;\n\t\tbreak;\n\t}\n\tcase 5: {\n\t\tunsigned short ltVal = 0;\n\t\tret = pfcn (arg, testVal, &lDefaultMarsh, &lBoolCustMarsh, &lI1CustMarsh, &lU1CustMarsh, &ltVal);\n\t\tif (ret)\n\t\t\treturn 0x0900 + ret;\n\t\tif (expected != ltVal)\n\t\t\treturn 0x1000;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn 0x9800;\n\t}\n\n\treturn 0;\n}\n\ntypedef int (STDCALL *MarshalBoolRefDelegate) (int arg, unsigned int expected, unsigned int testVal, unsigned int* bDefaultMarsh,\n\tunsigned int* bBoolCustMarsh, char* bI1CustMarsh, unsigned char* bU1CustMarsh, unsigned short* bVBCustMarsh);\n\nLIBTEST_API int STDCALL \nmono_test_managed_marshal_bool_ref (int arg, unsigned int expected, unsigned int testVal, unsigned int outExpected,\n\t\t\t\t    unsigned int outTestVal, MarshalBoolRefDelegate pfcn)\n{\n\tint ret;\n\tunsigned int lDefaultMarsh, lBoolCustMarsh;\n\tchar lI1CustMarsh = 0;\n\tunsigned char lU1CustMarsh = 0;\n\tunsigned short lVBCustMarsh = 0;\n\tlDefaultMarsh = lBoolCustMarsh = 0;\n\n\tif (!pfcn)\n\t\treturn 0x9900;\n\n\tswitch (arg) {\n\tcase 1:\n\t{\n\t\tunsigned int ltestVal = testVal;\n\t\tret = pfcn (arg, expected, outTestVal, &ltestVal, &lBoolCustMarsh, &lI1CustMarsh, &lU1CustMarsh, &lVBCustMarsh);\n\t\tif (ret)\n\t\t\treturn 0x0100 + ret;\n\t\tif (outExpected != ltestVal)\n\t\t\treturn 0x0200;\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\tunsigned int ltestVal = testVal;\n\t\tret = pfcn (arg, expected, outTestVal, &lDefaultMarsh, &ltestVal, &lI1CustMarsh, &lU1CustMarsh, &lVBCustMarsh);\n\t\tif (ret)\n\t\t\treturn 0x0300 + ret;\n\t\tif (outExpected != ltestVal)\n\t\t\treturn 0x0400;\n\t\tbreak;\n\t}\n\tcase 3:\n\t{\n\t\tchar ltestVal = testVal;\n\t\tret = pfcn (arg, expected, outTestVal, &lDefaultMarsh, &lBoolCustMarsh, &ltestVal, &lU1CustMarsh, &lVBCustMarsh);\n\t\tif (ret)\n\t\t\treturn 0x0500 + ret;\n\t\tif (outExpected != ltestVal)\n\t\t\treturn 0x0600;\n\t\tbreak;\n\t}\n\tcase 4:\n\t{\n\t\tunsigned char ltestVal = testVal;\n\t\tret = pfcn (arg, expected, outTestVal, &lDefaultMarsh, &lBoolCustMarsh, &lI1CustMarsh, &ltestVal, &lVBCustMarsh);\n\t\tif (ret)\n\t\t\treturn 0x0700 + ret;\n\t\tif (outExpected != ltestVal)\n\t\t\treturn 0x0800;\n\t\tbreak;\n\t}\n\tcase 5:\n\t{\n\t\tunsigned short ltestVal = testVal;\n\t\tret = pfcn (arg, expected, outTestVal, &lDefaultMarsh, &lBoolCustMarsh, &lI1CustMarsh, &lU1CustMarsh, &ltestVal);\n\t\tif (ret)\n\t\t\treturn 0x0900 + ret;\n\t\tif (outExpected != ltestVal)\n\t\t\treturn 0x1000;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn 0x9800;\n\t}\n\n\treturn 0;\n}\n\n#ifdef WIN32\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_out_1dim_vt_bstr_empty (SAFEARRAY** safearray)\n{\n\t/* Create an empty one-dimensional array of variants */\n\tSAFEARRAY *pSA;\n\tSAFEARRAYBOUND dimensions [1];\n\n\tdimensions [0].lLbound = 0;\n\tdimensions [0].cElements = 0;\n\n\tpSA = SafeArrayCreate (VT_VARIANT, 1, dimensions);\n\t*safearray = pSA;\n\treturn S_OK;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_out_1dim_vt_bstr (SAFEARRAY** safearray)\n{\n\t/* Create a one-dimensional array of 10 variants filled with \"0\" to \"9\" */\n\tSAFEARRAY *pSA;\n\tSAFEARRAYBOUND dimensions [1];\n\tlong i;\n\tgchar buffer [20];\n\tHRESULT hr = S_OK;\n\tlong indices [1];\n\n\tdimensions [0].lLbound = 0;\n\tdimensions [0].cElements = 10;\n\n\tpSA= SafeArrayCreate (VT_VARIANT, 1, dimensions);\n\tfor (i= dimensions [0].lLbound; i< (dimensions [0].cElements + dimensions [0].lLbound); i++) {\n\t\tVARIANT vOut;\n\t\tVariantInit (&vOut);\n\t\tvOut.vt = VT_BSTR;\n\t\t_ltoa (i,buffer,10);\n\t\tvOut.bstrVal= marshal_bstr_alloc (buffer);\n\t\tindices [0] = i;\n\t\tif ((hr = SafeArrayPutElement (pSA, indices, &vOut)) != S_OK) {\n\t\t\tVariantClear (&vOut);\n\t\t\tSafeArrayDestroy (pSA);\n\t\t\treturn hr;\n\t\t}\n\t\tVariantClear (&vOut);\n\t}\n\t*safearray = pSA;\n\treturn hr;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_out_2dim_vt_i4 (SAFEARRAY** safearray)\n{\n\t/* Create a two-dimensional array of 4x3 variants filled with 11, 12, 13, etc. */\n\tSAFEARRAY *pSA;\n\tSAFEARRAYBOUND dimensions [2];\n\tlong i, j;\n\tHRESULT hr = S_OK;\n\tlong indices [2];\n\n\tdimensions [0].lLbound = 0;\n\tdimensions [0].cElements = 4;\n\tdimensions [1].lLbound = 0;\n\tdimensions [1].cElements = 3;\n\n\tpSA= SafeArrayCreate(VT_VARIANT, 2, dimensions);\n\tfor (i= dimensions [0].lLbound; i< (dimensions [0].cElements + dimensions [0].lLbound); i++) {\n\t\tfor (j= dimensions [1].lLbound; j< (dimensions [1].cElements + dimensions [1].lLbound); j++) {\n\t\t\tVARIANT vOut;\n\t\t\tVariantInit (&vOut);\n\t\t\tvOut.vt = VT_I4;\n\t\t\tvOut.lVal = (i+1)*10+(j+1);\n\t\t\tindices [0] = i;\n\t\t\tindices [1] = j;\n\t\t\tif ((hr = SafeArrayPutElement (pSA, indices, &vOut)) != S_OK) {\n\t\t\t\tVariantClear (&vOut);\n\t\t\t\tSafeArrayDestroy (pSA);\n\t\t\t\treturn hr;\n\t\t\t}\n\t\t\tVariantClear (&vOut);  // does a deep destroy of source VARIANT\t\n\t\t}\n\t}\n\t*safearray = pSA;\n\treturn hr;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_out_4dim_vt_i4 (SAFEARRAY** safearray)\n{\n\t/* Create a four-dimensional array of 10x3x6x7 variants filled with their indices */\n\t/* Also use non zero lower bounds                                                 */\n\tSAFEARRAY *pSA;\n\tSAFEARRAYBOUND dimensions [4];\n\tlong i;\n\tHRESULT hr = S_OK;\n\tVARIANT *pData;\n\n\tdimensions [0].lLbound = 15;\n\tdimensions [0].cElements = 10;\n\tdimensions [1].lLbound = 20;\n\tdimensions [1].cElements = 3;\n\tdimensions [2].lLbound = 5;\n\tdimensions [2].cElements = 6;\n\tdimensions [3].lLbound = 12;\n\tdimensions [3].cElements = 7;\n\n\tpSA= SafeArrayCreate (VT_VARIANT, 4, dimensions);\n\n\tSafeArrayAccessData (pSA, (void **)&pData);\n\n\tfor (i= 0; i< 10*3*6*7; i++) {\n\t\tVariantInit(&pData [i]);\n\t\tpData [i].vt = VT_I4;\n\t\tpData [i].lVal = i;\n\t}\n\tSafeArrayUnaccessData (pSA);\n\t*safearray = pSA;\n\treturn hr;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_in_byval_1dim_empty (SAFEARRAY* safearray)\n{\n\t/* Check that array is one dimensional and empty */\n\n\tUINT dim;\n\tlong lbound, ubound;\n\t\n\tdim = SafeArrayGetDim (safearray);\n\tif (dim != 1)\n\t\treturn 1;\n\n\tSafeArrayGetLBound (safearray, 1, &lbound);\n\tSafeArrayGetUBound (safearray, 1, &ubound);\n\n\tif ((lbound > 0) || (ubound > 0))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_in_byval_1dim_vt_i4 (SAFEARRAY* safearray)\n{\n\t/* Check that array is one dimensional containing integers from 1 to 10 */\n\n\tUINT dim;\n\tlong lbound, ubound;\n\tVARIANT *pData;\t\n\tlong i;\n\tint result=0;\n\n\tdim = SafeArrayGetDim (safearray);\n\tif (dim != 1)\n\t\treturn 1;\n\n\tSafeArrayGetLBound (safearray, 1, &lbound);\n\tSafeArrayGetUBound (safearray, 1, &ubound);\n\n\tif ((lbound != 0) || (ubound != 9))\n\t\treturn 1;\n\n\tSafeArrayAccessData (safearray, (void **)&pData);\n\tfor (i= lbound; i <= ubound; i++) {\n\t\tif ((VariantChangeType (&pData [i], &pData [i], VARIANT_NOUSEROVERRIDE, VT_I4) != S_OK) || (pData [i].lVal != i + 1))\n\t\t\tresult = 1;\n\t}\n\tSafeArrayUnaccessData (safearray);\n\n\treturn result;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_in_byval_1dim_vt_mixed (SAFEARRAY* safearray)\n{\n\t/* Check that array is one dimensional containing integers mixed with strings from 0 to 12 */\n\n\tUINT dim;\n\tlong lbound, ubound;\n\tVARIANT *pData;\t\n\tlong i;\n\tlong indices [1];\n\tVARIANT element;\n\tint result=0;\n\n\tVariantInit (&element);\n\n\tdim = SafeArrayGetDim (safearray);\n\tif (dim != 1)\n\t\treturn 1;\n\n\tSafeArrayGetLBound (safearray, 1, &lbound);\n\tSafeArrayGetUBound (safearray, 1, &ubound);\n\t\t\n\tif ((lbound != 0) || (ubound != 12))\n\t\treturn 1;\n\n\tSafeArrayAccessData (safearray, (void **)&pData);\n\tfor (i= lbound; i <= ubound; i++) {\n\t\tif ((i%2 == 0) && (pData [i].vt != VT_I4))\n\t\t\tresult = 1;\n\t\tif ((i%2 == 1) && (pData [i].vt != VT_BSTR))\n\t\t\tresult = 1;\n\t\tif ((VariantChangeType (&pData [i], &pData [i], VARIANT_NOUSEROVERRIDE, VT_I4) != S_OK) || (pData [i].lVal != i))\n\t\t\tresult = 1;\n\t}\n\tSafeArrayUnaccessData (safearray);\n\n\t/* Change the first element of the array to verify that [in] parameters are not marshalled back to the managed side */\n\n\tindices [0] = 0;\n\telement.vt = VT_I4;\n\telement.lVal = 333;\n\tSafeArrayPutElement (safearray, indices, &element);\n\tVariantClear (&element);\n\n\treturn result;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_in_byval_2dim_vt_i4 (SAFEARRAY* safearray)\n{\n\t/* Check that array is one dimensional containing integers mixed with strings from 0 to 12 */\n\n\tUINT dim;\n\tlong lbound1, ubound1, lbound2, ubound2;\n\tlong i, j, failed;\n\tlong indices [2];\n\tVARIANT element;\n\n\tVariantInit (&element);\n\n\tdim = SafeArrayGetDim (safearray);\n\tif (dim != 2)\n\t\treturn 1;\n\n\tSafeArrayGetLBound (safearray, 1, &lbound1);\n\tSafeArrayGetUBound (safearray, 1, &ubound1);\n\n\tif ((lbound1 != 0) || (ubound1 != 1))\n\t\treturn 1;\n\n\tSafeArrayGetLBound (safearray, 2, &lbound2);\n\tSafeArrayGetUBound (safearray, 2, &ubound2);\n\n\tif ((lbound2 != 0) || (ubound2 != 3)) {\n\t\treturn 1;\n\t}\n\n\tfor (i= lbound1; i <= ubound1; i++) {\n\t\tindices [0] = i;\n\t\tfor (j= lbound2; j <= ubound2; j++) {\n\t\t\tindices [1] = j;\n\t\t\tif (SafeArrayGetElement (safearray, indices, &element) != S_OK)\n\t\t\t\treturn 1;\n\t\t\tfailed = ((element.vt != VT_I4) || (element.lVal != 10*(i+1)+(j+1)));\n\t\t\tVariantClear (&element);\n\t\t\tif (failed)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Change the first element of the array to verify that [in] parameters are not marshalled back to the managed side */\n\n\tindices [0] = 0;\n\tindices [1] = 0;\n\telement.vt = VT_I4;\n\telement.lVal = 333;\n\tSafeArrayPutElement (safearray, indices, &element);\n\tVariantClear (&element);\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_in_byval_3dim_vt_bstr (SAFEARRAY* safearray)\n{\n\t/* Check that array is one dimensional containing integers mixed with strings from 0 to 12 */\n\n\tUINT dim;\n\tlong lbound1, ubound1, lbound2, ubound2, lbound3, ubound3;\n\tlong i, j, k, failed;\n\tlong indices [3];\n\tVARIANT element;\n\n\tVariantInit (&element);\n\n\tdim = SafeArrayGetDim (safearray);\n\tif (dim != 3)\n\t\treturn 1;\n\n\tSafeArrayGetLBound (safearray, 1, &lbound1);\n\tSafeArrayGetUBound (safearray, 1, &ubound1);\n\n\tif ((lbound1 != 0) || (ubound1 != 1))\n\t\treturn 1;\n\n\tSafeArrayGetLBound (safearray, 2, &lbound2);\n\tSafeArrayGetUBound (safearray, 2, &ubound2);\n\n\tif ((lbound2 != 0) || (ubound2 != 1))\n\t\treturn 1;\n\n\tSafeArrayGetLBound (safearray, 3, &lbound3);\n\tSafeArrayGetUBound (safearray, 3, &ubound3);\n\n\tif ((lbound3 != 0) || (ubound3 != 2))\n\t\treturn 1;\n\n\tfor (i= lbound1; i <= ubound1; i++) {\n\t\tindices [0] = i;\n\t\tfor (j= lbound2; j <= ubound2; j++) {\n\t\t\tindices [1] = j;\n\t\tfor (k= lbound3; k <= ubound3; k++) {\n\t\t\t\tindices [2] = k;\n\t\t\t\tif (SafeArrayGetElement (safearray, indices, &element) != S_OK)\n\t\t\t\t\treturn 1;\n\t\t\t\tfailed = ((element.vt != VT_BSTR) \n\t\t\t\t\t|| (VariantChangeType (&element, &element, VARIANT_NOUSEROVERRIDE, VT_I4) != S_OK) \n\t\t\t\t\t|| (element.lVal != 100*(i+1)+10*(j+1)+(k+1)));\n\t\t\t\tVariantClear (&element);\n\t\t\t\tif (failed)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Change the first element of the array to verify that [in] parameters are not marshalled back to the managed side */\n\n\tindices [0] = 0;\n\tindices [1] = 0;\n\tindices [2] = 0;\n\telement.vt = VT_BSTR;\n\telement.bstrVal = SysAllocString(L\"Should not be copied\");\n\tSafeArrayPutElement (safearray, indices, &element);\n\tVariantClear (&element);\n\n\treturn 0;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_in_byref_3dim_vt_bstr (SAFEARRAY** safearray)\n{\n\treturn mono_test_marshal_safearray_in_byval_3dim_vt_bstr (*safearray);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_in_out_byref_1dim_empty (SAFEARRAY** safearray)\n{\n\t/* Check that the input array is what is expected and change it so the caller can check */\n\t/* correct marshalling back to managed code                                             */\n\n\tUINT dim;\n\tlong lbound, ubound;\n\tSAFEARRAYBOUND dimensions [1];\n\tlong i;\n\twchar_t buffer [20];\n\tHRESULT hr = S_OK;\n\tlong indices [1];\n\n\t/* Check that in array is one dimensional and empty */\n\n\tdim = SafeArrayGetDim (*safearray);\n\tif (dim != 1) {\n\t\treturn 1;\n\t}\n\n\tSafeArrayGetLBound (*safearray, 1, &lbound);\n\tSafeArrayGetUBound (*safearray, 1, &ubound);\n\t\t\n\tif ((lbound > 0) || (ubound > 0)) {\n\t\treturn 1;\n\t}\n\n\t/* Re-dimension the array and return a one-dimensional array of 8 variants filled with \"0\" to \"7\" */\n\n\tdimensions [0].lLbound = 0;\n\tdimensions [0].cElements = 8;\n\n\thr = SafeArrayRedim (*safearray, dimensions);\n\tif (hr != S_OK)\n\t\treturn 1;\n\n\tfor (i= dimensions [0].lLbound; i< (dimensions [0].lLbound + dimensions [0].cElements); i++) {\n\t\tVARIANT vOut;\n\t\tVariantInit (&vOut);\n\t\tvOut.vt = VT_BSTR;\n\t\t_ltow (i,buffer,10);\n\t\tvOut.bstrVal = SysAllocString (buffer);\n\t\tindices [0] = i;\n\t\tif ((hr = SafeArrayPutElement (*safearray, indices, &vOut)) != S_OK) {\n\t\t\tVariantClear (&vOut);\n\t\t\tSafeArrayDestroy (*safearray);\n\t\t\treturn hr;\n\t\t}\n\t\tVariantClear (&vOut);\n\t}\n\treturn hr;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_in_out_byref_3dim_vt_bstr (SAFEARRAY** safearray)\n{\n\t/* Check that the input array is what is expected and change it so the caller can check */\n\t/* correct marshalling back to managed code                                             */\n\n\tUINT dim;\n\tlong lbound1, ubound1, lbound2, ubound2, lbound3, ubound3;\n\tSAFEARRAYBOUND dimensions [1];\n\tlong i, j, k, failed;\n\twchar_t buffer [20];\n\tHRESULT hr = S_OK;\n\tlong indices [3];\n\tVARIANT element;\n\n\tVariantInit (&element);\n\n\t/* Check that in array is three dimensional and contains the expected values */\n\n\tdim = SafeArrayGetDim (*safearray);\n\tif (dim != 3)\n\t\treturn 1;\n\n\tSafeArrayGetLBound (*safearray, 1, &lbound1);\n\tSafeArrayGetUBound (*safearray, 1, &ubound1);\n\n\tif ((lbound1 != 0) || (ubound1 != 1))\n\t\treturn 1;\n\n\tSafeArrayGetLBound (*safearray, 2, &lbound2);\n\tSafeArrayGetUBound (*safearray, 2, &ubound2);\n\n\tif ((lbound2 != 0) || (ubound2 != 1))\n\t\treturn 1;\n\n\tSafeArrayGetLBound (*safearray, 3, &lbound3);\n\tSafeArrayGetUBound (*safearray, 3, &ubound3);\n\n\tif ((lbound3 != 0) || (ubound3 != 2))\n\t\treturn 1;\n\n\tfor (i= lbound1; i <= ubound1; i++) {\n\t\tindices [0] = i;\n\t\tfor (j= lbound2; j <= ubound2; j++) {\n\t\t\tindices [1] = j;\n\t\t\tfor (k= lbound3; k <= ubound3; k++) {\n\t\t\t\tindices [2] = k;\n\t\t\t\tif (SafeArrayGetElement (*safearray, indices, &element) != S_OK)\n\t\t\t\t\treturn 1;\n\t\t\t\tfailed = ((element.vt != VT_BSTR) \n\t\t\t\t\t|| (VariantChangeType (&element, &element, VARIANT_NOUSEROVERRIDE, VT_I4) != S_OK) \n\t\t\t\t\t|| (element.lVal != 100*(i+1)+10*(j+1)+(k+1)));\n\t\t\t\tVariantClear (&element);\n\t\t\t\tif (failed)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\thr = SafeArrayDestroy (*safearray);\n\tif (hr != S_OK)\n\t\treturn 1;\n\n\t/* Return a new one-dimensional array of 8 variants filled with \"0\" to \"7\" */\n\n\tdimensions [0].lLbound = 0;\n\tdimensions [0].cElements = 8;\n\n\t*safearray = SafeArrayCreate (VT_VARIANT, 1, dimensions);\n\n\tfor (i= dimensions [0].lLbound; i< (dimensions [0].lLbound + dimensions [0].cElements); i++) {\n\t\tVARIANT vOut;\n\t\tVariantInit (&vOut);\n\t\tvOut.vt = VT_BSTR;\n\t\t_ltow (i,buffer,10);\n\t\tvOut.bstrVal = SysAllocString (buffer);\n\t\tindices [0] = i;\n\t\tif ((hr = SafeArrayPutElement (*safearray, indices, &vOut)) != S_OK) {\n\t\t\tVariantClear (&vOut);\n\t\t\tSafeArrayDestroy (*safearray);\n\t\t\treturn hr;\n\t\t}\n\t\tVariantClear (&vOut);\n\t}\n\treturn hr;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_in_out_byref_1dim_vt_i4 (SAFEARRAY** safearray)\n{\n\t/* Check that the input array is what is expected and change it so the caller can check */\n\t/* correct marshalling back to managed code                                             */\n\n\tUINT dim;\n\tlong lbound1, ubound1;\n\tlong i, failed;\n\tHRESULT hr = S_OK;\n\tlong indices [1];\n\tVARIANT element;\n\t\n\tVariantInit (&element);\n\n\t/* Check that in array is one dimensional and contains the expected value */\n\n\tdim = SafeArrayGetDim (*safearray);\n\tif (dim != 1)\n\t\treturn 1;\n\n\tSafeArrayGetLBound (*safearray, 1, &lbound1);\n\tSafeArrayGetUBound (*safearray, 1, &ubound1);\n\n\tubound1 = 1;\n\tif ((lbound1 != 0) || (ubound1 != 1))\n\t\treturn 1;\n\tubound1 = 0;\n\n\tfor (i= lbound1; i <= ubound1; i++) {\n\t\tindices [0] = i;\n\t\tif (SafeArrayGetElement (*safearray, indices, &element) != S_OK)\n\t\t\treturn 1;\n\t\tfailed = (element.vt != VT_I4) || (element.lVal != i+1);\n\t\tVariantClear (&element);\n\t\tif (failed)\n\t\t\treturn 1;\n\t}\n\n\t/* Change one of the elements of the array to verify that [out] parameter is marshalled back to the managed side */\n\n\tindices [0] = 0;\n\telement.vt = VT_I4;\n\telement.lVal = -1;\n\tSafeArrayPutElement (*safearray, indices, &element);\n\tVariantClear (&element);\n\n\treturn hr;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_in_out_byval_1dim_vt_i4 (SAFEARRAY* safearray)\n{\n\t/* Check that the input array is what is expected and change it so the caller can check */\n\t/* correct marshalling back to managed code                                             */\n\n\tUINT dim;\n\tlong lbound1, ubound1;\n\tSAFEARRAYBOUND dimensions [1];\n\tlong i, failed;\n\tHRESULT hr = S_OK;\n\tlong indices [1];\n\tVARIANT element;\n\n\tVariantInit (&element);\n\n\t/* Check that in array is one dimensional and contains the expected value */\n\n\tdim = SafeArrayGetDim (safearray);\n\tif (dim != 1)\n\t\treturn 1;\n\n\tSafeArrayGetLBound (safearray, 1, &lbound1);\n\tSafeArrayGetUBound (safearray, 1, &ubound1);\n\t\t\n\tif ((lbound1 != 0) || (ubound1 != 0))\n\t\treturn 1;\n\n\tfor (i= lbound1; i <= ubound1; i++) {\n\t\tindices [0] = i;\n\t\tif (SafeArrayGetElement (safearray, indices, &element) != S_OK)\n\t\t\treturn 1;\n\t\tfailed = (element.vt != VT_I4) || (element.lVal != i+1);\n\t\tVariantClear (&element);\n\t\tif (failed)\n\t\t\treturn 1;\n\t}\n\n\t/* Change the array to verify how [out] parameter is marshalled back to the managed side */\n\n\t/* Redimension the array */\n\tdimensions [0].lLbound = lbound1;\n\tdimensions [0].cElements = 2;\n\thr = SafeArrayRedim(safearray, dimensions);\n\n\tindices [0] = 0;\n\telement.vt = VT_I4;\n\telement.lVal = 12345;\n\tSafeArrayPutElement (safearray, indices, &element);\n\tVariantClear (&element);\n\n\tindices [0] = 1;\n\telement.vt = VT_I4;\n\telement.lVal = -12345;\n\tSafeArrayPutElement (safearray, indices, &element);\n\tVariantClear (&element);\n\n\treturn hr;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_in_out_byval_3dim_vt_bstr (SAFEARRAY* safearray)\n{\n\t/* Check that the input array is what is expected and change it so the caller can check */\n\t/* correct marshalling back to managed code                                             */\n\n\tUINT dim;\n\tlong lbound1, ubound1, lbound2, ubound2, lbound3, ubound3;\n\tlong i, j, k, failed;\n\tHRESULT hr = S_OK;\n\tlong indices [3];\n\tVARIANT element;\n\n\tVariantInit (&element);\n\n\t/* Check that in array is three dimensional and contains the expected values */\n\n\tdim = SafeArrayGetDim (safearray);\n\tif (dim != 3)\n\t\treturn 1;\n\n\tSafeArrayGetLBound (safearray, 1, &lbound1);\n\tSafeArrayGetUBound (safearray, 1, &ubound1);\n\n\tif ((lbound1 != 0) || (ubound1 != 1))\n\t\treturn 1;\n\n\tSafeArrayGetLBound (safearray, 2, &lbound2);\n\tSafeArrayGetUBound (safearray, 2, &ubound2);\n\n\tif ((lbound2 != 0) || (ubound2 != 1))\n\t\treturn 1;\n\n\tSafeArrayGetLBound (safearray, 3, &lbound3);\n\tSafeArrayGetUBound (safearray, 3, &ubound3);\n\n\tif ((lbound3 != 0) || (ubound3 != 2))\n\t\treturn 1;\n\n\tfor (i= lbound1; i <= ubound1; i++) {\n\t\tindices [0] = i;\n\t\tfor (j= lbound2; j <= ubound2; j++) {\n\t\t\tindices [1] = j;\n\t\t\tfor (k= lbound3; k <= ubound3; k++) {\n\t\t\t\tindices [2] = k;\n\t\t\t\tif (SafeArrayGetElement (safearray, indices, &element) != S_OK)\n\t\t\t\t\treturn 1;\n\t\t\t\tfailed = ((element.vt != VT_BSTR) \n\t\t\t\t\t|| (VariantChangeType (&element, &element, VARIANT_NOUSEROVERRIDE, VT_I4) != S_OK) \n\t\t\t\t\t|| (element.lVal != 100*(i+1)+10*(j+1)+(k+1)));\n\t\t\t\tVariantClear (&element);\n\t\t\t\tif (failed)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Change the elements of the array to verify that [out] parameter is marshalled back to the managed side */\n\n\tindices [0] = 1;\n\tindices [1] = 1;\n\tindices [2] = 2;\n\telement.vt = VT_I4;\n\telement.lVal = 333;\n\tSafeArrayPutElement (safearray, indices, &element);\n\tVariantClear (&element);\n\n\tindices [0] = 1;\n\tindices [1] = 1;\n\tindices [2] = 1;\n\telement.vt = VT_I4;\n\telement.lVal = 111;\n\tSafeArrayPutElement (safearray, indices, &element);\n\tVariantClear (&element);\n\n\tindices [0] = 0;\n\tindices [1] = 1;\n\tindices [2] = 0;\n\telement.vt = VT_BSTR;\n\telement.bstrVal = marshal_bstr_alloc(\"ABCDEFG\");\n\tSafeArrayPutElement (safearray, indices, &element);\n\tVariantClear (&element);\n\n\treturn hr;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_safearray_mixed(\n\t\tSAFEARRAY  *safearray1,\n\t\tSAFEARRAY **safearray2,\n\t\tSAFEARRAY  *safearray3,\n\t\tSAFEARRAY **safearray4\n\t\t)\n{\n\tHRESULT hr = S_OK;\n\n\t/* Initialize out parameters */\n\t*safearray2 = NULL;\n\n\t/* array1: Check that in array is one dimensional and contains the expected value */\n\thr = mono_test_marshal_safearray_in_out_byval_1dim_vt_i4 (safearray1);\n\n\t/* array2: Fill in with some values to check on the managed side */\n\tif (hr == S_OK)\n\t\thr = mono_test_marshal_safearray_out_1dim_vt_bstr (safearray2);\n\n\t/* array3: Check that in array is one dimensional and contains the expected value */\n\tif (hr == S_OK)\n\t\thr = mono_test_marshal_safearray_in_byval_1dim_vt_mixed(safearray3);\n\n\t/* array4: Check input values and fill in with some values to check on the managed side */\n\tif (hr == S_OK)\n\t\thr = mono_test_marshal_safearray_in_out_byref_3dim_vt_bstr(safearray4);\n\n\treturn hr;\n}\n\nLIBTEST_API int STDCALL\nmono_test_marshal_safearray_in_ccw(MonoComObject *pUnk)\n{\n\tSAFEARRAY *array;\n\tVARIANT var;\n\tlong index;\n\tint ret;\n\n\tarray = SafeArrayCreateVector(VT_VARIANT, 0, 2);\n\n\tvar.vt = VT_BSTR;\n\tvar.bstrVal = marshal_bstr_alloc(\"Test\");\n\tindex = 0;\n\tSafeArrayPutElement(array, &index, &var);\n\n\tvar.vt = VT_I4;\n\tvar.intVal = 2345;\n\tindex = 1;\n\tSafeArrayPutElement(array, &index, &var);\n\n\tret = pUnk->vtbl->ArrayIn (pUnk, (void *)array);\n\tif (!ret)\n\t\tret = pUnk->vtbl->ArrayIn2 (pUnk, (void *)array);\n\tif (!ret)\n\t\tret = pUnk->vtbl->ArrayIn3 (pUnk, (void *)array);\n\n\tSafeArrayDestroy(array);\n\n\treturn ret;\n}\n\n#endif\n\nstatic int call_managed_res;\n\nstatic void\ncall_managed (gpointer arg)\n{\n\tSimpleDelegate del = (SimpleDelegate)arg;\n\n\tcall_managed_res = del (42);\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_thread_attach (SimpleDelegate del)\n{\n#ifdef WIN32\n\treturn 43;\n#else\n\tint res;\n\tpthread_t t;\n\n\tres = pthread_create (&t, NULL, (gpointer (*)(gpointer))call_managed, (gpointer)del);\n\tg_assert (res == 0);\n\tpthread_join (t, NULL);\n\n\treturn call_managed_res;\n#endif\n}\n\ntypedef struct {\n\tchar arr [4 * 1024];\n} LargeStruct;\n\ntypedef int (STDCALL *LargeStructDelegate) (LargeStruct *s);\n\nstatic void\ncall_managed_large_vt (gpointer arg)\n{\n\tLargeStructDelegate del = (LargeStructDelegate)arg;\n\tLargeStruct s;\n\n\tcall_managed_res = del (&s);\n}\n\nLIBTEST_API int STDCALL\nmono_test_marshal_thread_attach_large_vt (SimpleDelegate del)\n{\n#ifdef WIN32\n\treturn 43;\n#else\n\tint res;\n\tpthread_t t;\n\n\tres = pthread_create (&t, NULL, (gpointer (*)(gpointer))call_managed_large_vt, (gpointer)del);\n\tg_assert (res == 0);\n\tpthread_join (t, NULL);\n\n\treturn call_managed_res;\n#endif\n}\n\ntypedef int (STDCALL *Callback) (void);\n\nstatic Callback callback;\n\nLIBTEST_API void STDCALL \nmono_test_marshal_set_callback (Callback cb)\n{\n\tcallback = cb;\n}\n\nLIBTEST_API int STDCALL \nmono_test_marshal_call_callback (void)\n{\n\treturn callback ();\n}\n\nLIBTEST_API int STDCALL\nmono_test_marshal_lpstr (char *str)\n{\n\treturn strcmp (\"ABC\", str);\n}\n\nLIBTEST_API int STDCALL\nmono_test_marshal_lpwstr (gunichar2 *str)\n{\n\tchar *s;\n\tint res;\n\n\ts = g_utf16_to_utf8 (str, -1, NULL, NULL, NULL);\n\tres = strcmp (\"ABC\", s);\n\tg_free (s);\n\n\treturn res;\n}\n\nLIBTEST_API char* STDCALL\nmono_test_marshal_return_lpstr (void)\n{\n\tchar *res = (char *)marshal_alloc (4);\n\tstrcpy (res, \"XYZ\");\n\treturn res;\n}\n\nLIBTEST_API gunichar2* STDCALL\nmono_test_marshal_return_lpwstr (void)\n{\n\tgunichar2 *res = (gunichar2 *)marshal_alloc (8);\n\tgunichar2* tmp = g_utf8_to_utf16 (\"XYZ\", -1, NULL, NULL, NULL);\n\n\tmemcpy (res, tmp, 8);\n\tg_free (tmp);\n\n\treturn res;\n}\n\ntypedef\n#if defined (HOST_WIN32) && defined (HOST_X86) && defined (__GNUC__)\n// Workaround gcc ABI bug. It returns the struct in ST0 instead of edx:eax.\n// Mono and Visual C++ agree.\nunion\n#else\nstruct\n#endif\n{\n\tdouble d;\n} SingleDoubleStruct;\n\nLIBTEST_API SingleDoubleStruct STDCALL\nmono_test_marshal_return_single_double_struct (void)\n{\n\tSingleDoubleStruct res = {3.0};\n\treturn res;\n}\n\nLIBTEST_API int STDCALL\nmono_test_has_thiscall_globals (void)\n{\n// Visual C++ does not accept __thiscall on global functions, only\n// member function and function pointers. Gcc accepts it also on global functions.\n#if defined (HOST_X86) && defined (HOST_WIN32) && !defined (_MSC_VER)\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\nLIBTEST_API int STDCALL\nmono_test_has_thiscall_pointers (void)\n{\n#if defined (HOST_X86) && defined (HOST_WIN32)\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\nLIBTEST_API int\n#ifndef _MSC_VER\n__thiscall\n#endif\n_mono_test_native_thiscall1 (int arg)\n{\n\treturn arg;\n}\n\nLIBTEST_API int\n#ifndef _MSC_VER\n__thiscall\n#endif\n_mono_test_native_thiscall2 (int arg, int arg2)\n{\n\treturn arg + (arg2^1);\n}\n\nLIBTEST_API int\n#ifndef _MSC_VER\n__thiscall\n#endif\n_mono_test_native_thiscall3 (int arg, int arg2, int arg3)\n{\n\treturn arg + (arg2^1) + (arg3^2);\n}\n\ntypedef int (\n#ifndef _MSC_VER\n__thiscall\n#endif\n*ThiscallFunction)(int arg, int arg2);\n\nLIBTEST_API ThiscallFunction STDCALL\nmono_test_get_native_thiscall2 (void)\n{\n\treturn _mono_test_native_thiscall2;\n}\n\nLIBTEST_API int STDCALL\n_mono_test_managed_thiscall1 (int (__thiscall*fn)(int), int arg)\n{\n\treturn fn(arg);\n}\n\nLIBTEST_API int STDCALL\n_mono_test_managed_thiscall2 (int (__thiscall*fn)(int,int), int arg, int arg2)\n{\n\treturn fn(arg, arg2);\n}\n\nLIBTEST_API int STDCALL\n_mono_test_managed_thiscall3 (int (__thiscall*fn)(int,int,int), int arg, int arg2, int arg3)\n{\n\treturn fn(arg, arg2, arg3);\n}\n\ntypedef struct {\n\tchar f1;\n} sbyte1;\n\nLIBTEST_API sbyte1 STDCALL\nmono_return_sbyte1 (sbyte1 s1, int addend) {\n\tif (s1.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte1 s1.f1: got %d but expected %d\\n\", s1.f1, 1);\n\t}\n\ts1.f1+=addend; \n\treturn s1;\n}\n\ntypedef struct {\n\tchar f1,f2;\n} sbyte2;\n\nLIBTEST_API sbyte2 STDCALL\nmono_return_sbyte2 (sbyte2 s2, int addend) {\n\tif (s2.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte2 s2.f1: got %d but expected %d\\n\", s2.f1, 1);\n\t}\n\tif (s2.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte2 s2.f2: got %d but expected %d\\n\", s2.f2, 2);\n\t}\n\ts2.f1+=addend; s2.f2+=addend; \n\treturn s2;\n}\n\ntypedef struct {\n\tchar f1,f2,f3;\n} sbyte3;\n\nLIBTEST_API sbyte3 STDCALL\nmono_return_sbyte3 (sbyte3 s3, int addend) {\n\tif (s3.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte3 s3.f1: got %d but expected %d\\n\", s3.f1, 1);\n\t}\n\tif (s3.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte3 s3.f2: got %d but expected %d\\n\", s3.f2, 2);\n\t}\n\tif (s3.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte3 s3.f3: got %d but expected %d\\n\", s3.f3, 3);\n\t}\n\ts3.f1+=addend; s3.f2+=addend; s3.f3+=addend; \n\treturn s3;\n}\n\ntypedef struct {\n\tchar f1,f2,f3,f4;\n} sbyte4;\n\nLIBTEST_API sbyte4 STDCALL\nmono_return_sbyte4 (sbyte4 s4, int addend) {\n\tif (s4.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte4 s4.f1: got %d but expected %d\\n\", s4.f1, 1);\n\t}\n\tif (s4.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte4 s4.f2: got %d but expected %d\\n\", s4.f2, 2);\n\t}\n\tif (s4.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte4 s4.f3: got %d but expected %d\\n\", s4.f3, 3);\n\t}\n\tif (s4.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_sbyte4 s4.f4: got %d but expected %d\\n\", s4.f4, 4);\n\t}\n\ts4.f1+=addend; s4.f2+=addend; s4.f3+=addend; s4.f4+=addend; \n\treturn s4;\n}\n\ntypedef struct {\n\tchar f1,f2,f3,f4,f5;\n} sbyte5;\n\nLIBTEST_API sbyte5 STDCALL\nmono_return_sbyte5 (sbyte5 s5, int addend) {\n\tif (s5.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte5 s5.f1: got %d but expected %d\\n\", s5.f1, 1);\n\t}\n\tif (s5.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte5 s5.f2: got %d but expected %d\\n\", s5.f2, 2);\n\t}\n\tif (s5.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte5 s5.f3: got %d but expected %d\\n\", s5.f3, 3);\n\t}\n\tif (s5.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_sbyte5 s5.f4: got %d but expected %d\\n\", s5.f4, 4);\n\t}\n\tif (s5.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_sbyte5 s5.f5: got %d but expected %d\\n\", s5.f5, 5);\n\t}\n\ts5.f1+=addend; s5.f2+=addend; s5.f3+=addend; s5.f4+=addend; s5.f5+=addend; \n\treturn s5;\n}\n\ntypedef struct {\n\tchar f1,f2,f3,f4,f5,f6;\n} sbyte6;\n\nLIBTEST_API sbyte6 STDCALL\nmono_return_sbyte6 (sbyte6 s6, int addend) {\n\tif (s6.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte6 s6.f1: got %d but expected %d\\n\", s6.f1, 1);\n\t}\n\tif (s6.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte6 s6.f2: got %d but expected %d\\n\", s6.f2, 2);\n\t}\n\tif (s6.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte6 s6.f3: got %d but expected %d\\n\", s6.f3, 3);\n\t}\n\tif (s6.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_sbyte6 s6.f4: got %d but expected %d\\n\", s6.f4, 4);\n\t}\n\tif (s6.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_sbyte6 s6.f5: got %d but expected %d\\n\", s6.f5, 5);\n\t}\n\tif (s6.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_sbyte6 s6.f6: got %d but expected %d\\n\", s6.f6, 6);\n\t}\n\ts6.f1+=addend; s6.f2+=addend; s6.f3+=addend; s6.f4+=addend; s6.f5+=addend; s6.f6+=addend; \n\treturn s6;\n}\n\ntypedef struct {\n\tchar f1,f2,f3,f4,f5,f6,f7;\n} sbyte7;\n\nLIBTEST_API sbyte7 STDCALL\nmono_return_sbyte7 (sbyte7 s7, int addend) {\n\tif (s7.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte7 s7.f1: got %d but expected %d\\n\", s7.f1, 1);\n\t}\n\tif (s7.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte7 s7.f2: got %d but expected %d\\n\", s7.f2, 2);\n\t}\n\tif (s7.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte7 s7.f3: got %d but expected %d\\n\", s7.f3, 3);\n\t}\n\tif (s7.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_sbyte7 s7.f4: got %d but expected %d\\n\", s7.f4, 4);\n\t}\n\tif (s7.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_sbyte7 s7.f5: got %d but expected %d\\n\", s7.f5, 5);\n\t}\n\tif (s7.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_sbyte7 s7.f6: got %d but expected %d\\n\", s7.f6, 6);\n\t}\n\tif (s7.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_sbyte7 s7.f7: got %d but expected %d\\n\", s7.f7, 7);\n\t}\n\ts7.f1+=addend; s7.f2+=addend; s7.f3+=addend; s7.f4+=addend; s7.f5+=addend; s7.f6+=addend; s7.f7+=addend; \n\treturn s7;\n}\n\ntypedef struct {\n\tchar f1,f2,f3,f4,f5,f6,f7,f8;\n} sbyte8;\n\nLIBTEST_API sbyte8 STDCALL\nmono_return_sbyte8 (sbyte8 s8, int addend) {\n\tif (s8.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte8 s8.f1: got %d but expected %d\\n\", s8.f1, 1);\n\t}\n\tif (s8.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte8 s8.f2: got %d but expected %d\\n\", s8.f2, 2);\n\t}\n\tif (s8.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte8 s8.f3: got %d but expected %d\\n\", s8.f3, 3);\n\t}\n\tif (s8.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_sbyte8 s8.f4: got %d but expected %d\\n\", s8.f4, 4);\n\t}\n\tif (s8.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_sbyte8 s8.f5: got %d but expected %d\\n\", s8.f5, 5);\n\t}\n\tif (s8.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_sbyte8 s8.f6: got %d but expected %d\\n\", s8.f6, 6);\n\t}\n\tif (s8.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_sbyte8 s8.f7: got %d but expected %d\\n\", s8.f7, 7);\n\t}\n\tif (s8.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_sbyte8 s8.f8: got %d but expected %d\\n\", s8.f8, 8);\n\t}\n\ts8.f1+=addend; s8.f2+=addend; s8.f3+=addend; s8.f4+=addend; s8.f5+=addend; s8.f6+=addend; s8.f7+=addend; s8.f8+=addend; \n\treturn s8;\n}\n\ntypedef struct {\n\tchar f1,f2,f3,f4,f5,f6,f7,f8,f9;\n} sbyte9;\n\nLIBTEST_API sbyte9 STDCALL\nmono_return_sbyte9 (sbyte9 s9, int addend) {\n\tif (s9.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte9 s9.f1: got %d but expected %d\\n\", s9.f1, 1);\n\t}\n\tif (s9.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte9 s9.f2: got %d but expected %d\\n\", s9.f2, 2);\n\t}\n\tif (s9.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte9 s9.f3: got %d but expected %d\\n\", s9.f3, 3);\n\t}\n\tif (s9.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_sbyte9 s9.f4: got %d but expected %d\\n\", s9.f4, 4);\n\t}\n\tif (s9.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_sbyte9 s9.f5: got %d but expected %d\\n\", s9.f5, 5);\n\t}\n\tif (s9.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_sbyte9 s9.f6: got %d but expected %d\\n\", s9.f6, 6);\n\t}\n\tif (s9.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_sbyte9 s9.f7: got %d but expected %d\\n\", s9.f7, 7);\n\t}\n\tif (s9.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_sbyte9 s9.f8: got %d but expected %d\\n\", s9.f8, 8);\n\t}\n\tif (s9.f9 != 9) {\n\t\tfprintf(stderr, \"mono_return_sbyte9 s9.f9: got %d but expected %d\\n\", s9.f9, 9);\n\t}\n\ts9.f1+=addend; s9.f2+=addend; s9.f3+=addend; s9.f4+=addend; s9.f5+=addend; s9.f6+=addend; s9.f7+=addend; s9.f8+=addend; s9.f9+=addend; \n\treturn s9;\n}\n\ntypedef struct {\n\tchar f1,f2,f3,f4,f5,f6,f7,f8,f9,f10;\n} sbyte10;\n\nLIBTEST_API sbyte10 STDCALL\nmono_return_sbyte10 (sbyte10 s10, int addend) {\n\tif (s10.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte10 s10.f1: got %d but expected %d\\n\", s10.f1, 1);\n\t}\n\tif (s10.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte10 s10.f2: got %d but expected %d\\n\", s10.f2, 2);\n\t}\n\tif (s10.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte10 s10.f3: got %d but expected %d\\n\", s10.f3, 3);\n\t}\n\tif (s10.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_sbyte10 s10.f4: got %d but expected %d\\n\", s10.f4, 4);\n\t}\n\tif (s10.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_sbyte10 s10.f5: got %d but expected %d\\n\", s10.f5, 5);\n\t}\n\tif (s10.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_sbyte10 s10.f6: got %d but expected %d\\n\", s10.f6, 6);\n\t}\n\tif (s10.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_sbyte10 s10.f7: got %d but expected %d\\n\", s10.f7, 7);\n\t}\n\tif (s10.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_sbyte10 s10.f8: got %d but expected %d\\n\", s10.f8, 8);\n\t}\n\tif (s10.f9 != 9) {\n\t\tfprintf(stderr, \"mono_return_sbyte10 s10.f9: got %d but expected %d\\n\", s10.f9, 9);\n\t}\n\tif (s10.f10 != 10) {\n\t\tfprintf(stderr, \"mono_return_sbyte10 s10.f10: got %d but expected %d\\n\", s10.f10, 10);\n\t}\n\ts10.f1+=addend; s10.f2+=addend; s10.f3+=addend; s10.f4+=addend; s10.f5+=addend; s10.f6+=addend; s10.f7+=addend; s10.f8+=addend; s10.f9+=addend; s10.f10+=addend; \n\treturn s10;\n}\n\ntypedef struct {\n\tchar f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11;\n} sbyte11;\n\nLIBTEST_API sbyte11 STDCALL\nmono_return_sbyte11 (sbyte11 s11, int addend) {\n\tif (s11.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte11 s11.f1: got %d but expected %d\\n\", s11.f1, 1);\n\t}\n\tif (s11.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte11 s11.f2: got %d but expected %d\\n\", s11.f2, 2);\n\t}\n\tif (s11.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte11 s11.f3: got %d but expected %d\\n\", s11.f3, 3);\n\t}\n\tif (s11.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_sbyte11 s11.f4: got %d but expected %d\\n\", s11.f4, 4);\n\t}\n\tif (s11.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_sbyte11 s11.f5: got %d but expected %d\\n\", s11.f5, 5);\n\t}\n\tif (s11.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_sbyte11 s11.f6: got %d but expected %d\\n\", s11.f6, 6);\n\t}\n\tif (s11.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_sbyte11 s11.f7: got %d but expected %d\\n\", s11.f7, 7);\n\t}\n\tif (s11.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_sbyte11 s11.f8: got %d but expected %d\\n\", s11.f8, 8);\n\t}\n\tif (s11.f9 != 9) {\n\t\tfprintf(stderr, \"mono_return_sbyte11 s11.f9: got %d but expected %d\\n\", s11.f9, 9);\n\t}\n\tif (s11.f10 != 10) {\n\t\tfprintf(stderr, \"mono_return_sbyte11 s11.f10: got %d but expected %d\\n\", s11.f10, 10);\n\t}\n\tif (s11.f11 != 11) {\n\t\tfprintf(stderr, \"mono_return_sbyte11 s11.f11: got %d but expected %d\\n\", s11.f11, 11);\n\t}\n\ts11.f1+=addend; s11.f2+=addend; s11.f3+=addend; s11.f4+=addend; s11.f5+=addend; s11.f6+=addend; s11.f7+=addend; s11.f8+=addend; s11.f9+=addend; s11.f10+=addend; s11.f11+=addend; \n\treturn s11;\n}\n\ntypedef struct {\n\tchar f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12;\n} sbyte12;\n\nLIBTEST_API sbyte12 STDCALL\nmono_return_sbyte12 (sbyte12 s12, int addend) {\n\tif (s12.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte12 s12.f1: got %d but expected %d\\n\", s12.f1, 1);\n\t}\n\tif (s12.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte12 s12.f2: got %d but expected %d\\n\", s12.f2, 2);\n\t}\n\tif (s12.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte12 s12.f3: got %d but expected %d\\n\", s12.f3, 3);\n\t}\n\tif (s12.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_sbyte12 s12.f4: got %d but expected %d\\n\", s12.f4, 4);\n\t}\n\tif (s12.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_sbyte12 s12.f5: got %d but expected %d\\n\", s12.f5, 5);\n\t}\n\tif (s12.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_sbyte12 s12.f6: got %d but expected %d\\n\", s12.f6, 6);\n\t}\n\tif (s12.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_sbyte12 s12.f7: got %d but expected %d\\n\", s12.f7, 7);\n\t}\n\tif (s12.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_sbyte12 s12.f8: got %d but expected %d\\n\", s12.f8, 8);\n\t}\n\tif (s12.f9 != 9) {\n\t\tfprintf(stderr, \"mono_return_sbyte12 s12.f9: got %d but expected %d\\n\", s12.f9, 9);\n\t}\n\tif (s12.f10 != 10) {\n\t\tfprintf(stderr, \"mono_return_sbyte12 s12.f10: got %d but expected %d\\n\", s12.f10, 10);\n\t}\n\tif (s12.f11 != 11) {\n\t\tfprintf(stderr, \"mono_return_sbyte12 s12.f11: got %d but expected %d\\n\", s12.f11, 11);\n\t}\n\tif (s12.f12 != 12) {\n\t\tfprintf(stderr, \"mono_return_sbyte12 s12.f12: got %d but expected %d\\n\", s12.f12, 12);\n\t}\n\ts12.f1+=addend; s12.f2+=addend; s12.f3+=addend; s12.f4+=addend; s12.f5+=addend; s12.f6+=addend; s12.f7+=addend; s12.f8+=addend; s12.f9+=addend; s12.f10+=addend; s12.f11+=addend; s12.f12+=addend; \n\treturn s12;\n}\n\ntypedef struct {\n\tchar f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13;\n} sbyte13;\n\nLIBTEST_API sbyte13 STDCALL\nmono_return_sbyte13 (sbyte13 s13, int addend) {\n\tif (s13.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte13 s13.f1: got %d but expected %d\\n\", s13.f1, 1);\n\t}\n\tif (s13.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte13 s13.f2: got %d but expected %d\\n\", s13.f2, 2);\n\t}\n\tif (s13.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte13 s13.f3: got %d but expected %d\\n\", s13.f3, 3);\n\t}\n\tif (s13.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_sbyte13 s13.f4: got %d but expected %d\\n\", s13.f4, 4);\n\t}\n\tif (s13.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_sbyte13 s13.f5: got %d but expected %d\\n\", s13.f5, 5);\n\t}\n\tif (s13.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_sbyte13 s13.f6: got %d but expected %d\\n\", s13.f6, 6);\n\t}\n\tif (s13.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_sbyte13 s13.f7: got %d but expected %d\\n\", s13.f7, 7);\n\t}\n\tif (s13.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_sbyte13 s13.f8: got %d but expected %d\\n\", s13.f8, 8);\n\t}\n\tif (s13.f9 != 9) {\n\t\tfprintf(stderr, \"mono_return_sbyte13 s13.f9: got %d but expected %d\\n\", s13.f9, 9);\n\t}\n\tif (s13.f10 != 10) {\n\t\tfprintf(stderr, \"mono_return_sbyte13 s13.f10: got %d but expected %d\\n\", s13.f10, 10);\n\t}\n\tif (s13.f11 != 11) {\n\t\tfprintf(stderr, \"mono_return_sbyte13 s13.f11: got %d but expected %d\\n\", s13.f11, 11);\n\t}\n\tif (s13.f12 != 12) {\n\t\tfprintf(stderr, \"mono_return_sbyte13 s13.f12: got %d but expected %d\\n\", s13.f12, 12);\n\t}\n\tif (s13.f13 != 13) {\n\t\tfprintf(stderr, \"mono_return_sbyte13 s13.f13: got %d but expected %d\\n\", s13.f13, 13);\n\t}\n\ts13.f1+=addend; s13.f2+=addend; s13.f3+=addend; s13.f4+=addend; s13.f5+=addend; s13.f6+=addend; s13.f7+=addend; s13.f8+=addend; s13.f9+=addend; s13.f10+=addend; s13.f11+=addend; s13.f12+=addend; s13.f13+=addend; \n\treturn s13;\n}\n\ntypedef struct {\n\tchar f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14;\n} sbyte14;\n\nLIBTEST_API sbyte14 STDCALL\nmono_return_sbyte14 (sbyte14 s14, int addend) {\n\tif (s14.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte14 s14.f1: got %d but expected %d\\n\", s14.f1, 1);\n\t}\n\tif (s14.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte14 s14.f2: got %d but expected %d\\n\", s14.f2, 2);\n\t}\n\tif (s14.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte14 s14.f3: got %d but expected %d\\n\", s14.f3, 3);\n\t}\n\tif (s14.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_sbyte14 s14.f4: got %d but expected %d\\n\", s14.f4, 4);\n\t}\n\tif (s14.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_sbyte14 s14.f5: got %d but expected %d\\n\", s14.f5, 5);\n\t}\n\tif (s14.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_sbyte14 s14.f6: got %d but expected %d\\n\", s14.f6, 6);\n\t}\n\tif (s14.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_sbyte14 s14.f7: got %d but expected %d\\n\", s14.f7, 7);\n\t}\n\tif (s14.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_sbyte14 s14.f8: got %d but expected %d\\n\", s14.f8, 8);\n\t}\n\tif (s14.f9 != 9) {\n\t\tfprintf(stderr, \"mono_return_sbyte14 s14.f9: got %d but expected %d\\n\", s14.f9, 9);\n\t}\n\tif (s14.f10 != 10) {\n\t\tfprintf(stderr, \"mono_return_sbyte14 s14.f10: got %d but expected %d\\n\", s14.f10, 10);\n\t}\n\tif (s14.f11 != 11) {\n\t\tfprintf(stderr, \"mono_return_sbyte14 s14.f11: got %d but expected %d\\n\", s14.f11, 11);\n\t}\n\tif (s14.f12 != 12) {\n\t\tfprintf(stderr, \"mono_return_sbyte14 s14.f12: got %d but expected %d\\n\", s14.f12, 12);\n\t}\n\tif (s14.f13 != 13) {\n\t\tfprintf(stderr, \"mono_return_sbyte14 s14.f13: got %d but expected %d\\n\", s14.f13, 13);\n\t}\n\tif (s14.f14 != 14) {\n\t\tfprintf(stderr, \"mono_return_sbyte14 s14.f14: got %d but expected %d\\n\", s14.f14, 14);\n\t}\n\ts14.f1+=addend; s14.f2+=addend; s14.f3+=addend; s14.f4+=addend; s14.f5+=addend; s14.f6+=addend; s14.f7+=addend; s14.f8+=addend; s14.f9+=addend; s14.f10+=addend; s14.f11+=addend; s14.f12+=addend; s14.f13+=addend; s14.f14+=addend; \n\treturn s14;\n}\n\ntypedef struct {\n\tchar f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15;\n} sbyte15;\n\nLIBTEST_API sbyte15 STDCALL\nmono_return_sbyte15 (sbyte15 s15, int addend) {\n\tif (s15.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte15 s15.f1: got %d but expected %d\\n\", s15.f1, 1);\n\t}\n\tif (s15.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte15 s15.f2: got %d but expected %d\\n\", s15.f2, 2);\n\t}\n\tif (s15.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte15 s15.f3: got %d but expected %d\\n\", s15.f3, 3);\n\t}\n\tif (s15.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_sbyte15 s15.f4: got %d but expected %d\\n\", s15.f4, 4);\n\t}\n\tif (s15.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_sbyte15 s15.f5: got %d but expected %d\\n\", s15.f5, 5);\n\t}\n\tif (s15.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_sbyte15 s15.f6: got %d but expected %d\\n\", s15.f6, 6);\n\t}\n\tif (s15.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_sbyte15 s15.f7: got %d but expected %d\\n\", s15.f7, 7);\n\t}\n\tif (s15.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_sbyte15 s15.f8: got %d but expected %d\\n\", s15.f8, 8);\n\t}\n\tif (s15.f9 != 9) {\n\t\tfprintf(stderr, \"mono_return_sbyte15 s15.f9: got %d but expected %d\\n\", s15.f9, 9);\n\t}\n\tif (s15.f10 != 10) {\n\t\tfprintf(stderr, \"mono_return_sbyte15 s15.f10: got %d but expected %d\\n\", s15.f10, 10);\n\t}\n\tif (s15.f11 != 11) {\n\t\tfprintf(stderr, \"mono_return_sbyte15 s15.f11: got %d but expected %d\\n\", s15.f11, 11);\n\t}\n\tif (s15.f12 != 12) {\n\t\tfprintf(stderr, \"mono_return_sbyte15 s15.f12: got %d but expected %d\\n\", s15.f12, 12);\n\t}\n\tif (s15.f13 != 13) {\n\t\tfprintf(stderr, \"mono_return_sbyte15 s15.f13: got %d but expected %d\\n\", s15.f13, 13);\n\t}\n\tif (s15.f14 != 14) {\n\t\tfprintf(stderr, \"mono_return_sbyte15 s15.f14: got %d but expected %d\\n\", s15.f14, 14);\n\t}\n\tif (s15.f15 != 15) {\n\t\tfprintf(stderr, \"mono_return_sbyte15 s15.f15: got %d but expected %d\\n\", s15.f15, 15);\n\t}\n\ts15.f1+=addend; s15.f2+=addend; s15.f3+=addend; s15.f4+=addend; s15.f5+=addend; s15.f6+=addend; s15.f7+=addend; s15.f8+=addend; s15.f9+=addend; s15.f10+=addend; s15.f11+=addend; s15.f12+=addend; s15.f13+=addend; s15.f14+=addend; s15.f15+=addend; \n\treturn s15;\n}\n\ntypedef struct {\n\tchar f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16;\n} sbyte16;\n\nLIBTEST_API sbyte16 STDCALL\nmono_return_sbyte16 (sbyte16 s16, int addend) {\n\tif (s16.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f1: got %d but expected %d\\n\", s16.f1, 1);\n\t}\n\tif (s16.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f2: got %d but expected %d\\n\", s16.f2, 2);\n\t}\n\tif (s16.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f3: got %d but expected %d\\n\", s16.f3, 3);\n\t}\n\tif (s16.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f4: got %d but expected %d\\n\", s16.f4, 4);\n\t}\n\tif (s16.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f5: got %d but expected %d\\n\", s16.f5, 5);\n\t}\n\tif (s16.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f6: got %d but expected %d\\n\", s16.f6, 6);\n\t}\n\tif (s16.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f7: got %d but expected %d\\n\", s16.f7, 7);\n\t}\n\tif (s16.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f8: got %d but expected %d\\n\", s16.f8, 8);\n\t}\n\tif (s16.f9 != 9) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f9: got %d but expected %d\\n\", s16.f9, 9);\n\t}\n\tif (s16.f10 != 10) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f10: got %d but expected %d\\n\", s16.f10, 10);\n\t}\n\tif (s16.f11 != 11) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f11: got %d but expected %d\\n\", s16.f11, 11);\n\t}\n\tif (s16.f12 != 12) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f12: got %d but expected %d\\n\", s16.f12, 12);\n\t}\n\tif (s16.f13 != 13) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f13: got %d but expected %d\\n\", s16.f13, 13);\n\t}\n\tif (s16.f14 != 14) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f14: got %d but expected %d\\n\", s16.f14, 14);\n\t}\n\tif (s16.f15 != 15) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f15: got %d but expected %d\\n\", s16.f15, 15);\n\t}\n\tif (s16.f16 != 16) {\n\t\tfprintf(stderr, \"mono_return_sbyte16 s16.f16: got %d but expected %d\\n\", s16.f16, 16);\n\t}\n\ts16.f1+=addend; s16.f2+=addend; s16.f3+=addend; s16.f4+=addend; s16.f5+=addend; s16.f6+=addend; s16.f7+=addend; s16.f8+=addend; s16.f9+=addend; s16.f10+=addend; s16.f11+=addend; s16.f12+=addend; s16.f13+=addend; s16.f14+=addend; s16.f15+=addend; s16.f16+=addend; \n\treturn s16;\n}\n\ntypedef struct {\n\tchar f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16,f17;\n} sbyte17;\n\nLIBTEST_API sbyte17 STDCALL\nmono_return_sbyte17 (sbyte17 s17, int addend) {\n\tif (s17.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f1: got %d but expected %d\\n\", s17.f1, 1);\n\t}\n\tif (s17.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f2: got %d but expected %d\\n\", s17.f2, 2);\n\t}\n\tif (s17.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f3: got %d but expected %d\\n\", s17.f3, 3);\n\t}\n\tif (s17.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f4: got %d but expected %d\\n\", s17.f4, 4);\n\t}\n\tif (s17.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f5: got %d but expected %d\\n\", s17.f5, 5);\n\t}\n\tif (s17.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f6: got %d but expected %d\\n\", s17.f6, 6);\n\t}\n\tif (s17.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f7: got %d but expected %d\\n\", s17.f7, 7);\n\t}\n\tif (s17.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f8: got %d but expected %d\\n\", s17.f8, 8);\n\t}\n\tif (s17.f9 != 9) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f9: got %d but expected %d\\n\", s17.f9, 9);\n\t}\n\tif (s17.f10 != 10) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f10: got %d but expected %d\\n\", s17.f10, 10);\n\t}\n\tif (s17.f11 != 11) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f11: got %d but expected %d\\n\", s17.f11, 11);\n\t}\n\tif (s17.f12 != 12) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f12: got %d but expected %d\\n\", s17.f12, 12);\n\t}\n\tif (s17.f13 != 13) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f13: got %d but expected %d\\n\", s17.f13, 13);\n\t}\n\tif (s17.f14 != 14) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f14: got %d but expected %d\\n\", s17.f14, 14);\n\t}\n\tif (s17.f15 != 15) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f15: got %d but expected %d\\n\", s17.f15, 15);\n\t}\n\tif (s17.f16 != 16) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f16: got %d but expected %d\\n\", s17.f16, 16);\n\t}\n\tif (s17.f17 != 17) {\n\t\tfprintf(stderr, \"mono_return_sbyte17 s17.f17: got %d but expected %d\\n\", s17.f17, 17);\n\t}\n\ts17.f1+=addend; s17.f2+=addend; s17.f3+=addend; s17.f4+=addend; s17.f5+=addend; s17.f6+=addend; s17.f7+=addend; s17.f8+=addend; s17.f9+=addend; s17.f10+=addend; s17.f11+=addend; s17.f12+=addend; s17.f13+=addend; s17.f14+=addend; s17.f15+=addend; s17.f16+=addend; s17.f17+=addend; \n\treturn s17;\n}\n\ntypedef struct {\n\tstruct {\n\t\tchar f1;\n\t} nested1;\n\tchar f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15;\n\tstruct {\n\t\tchar f16;\n\t} nested2;\n} sbyte16_nested;\n\nLIBTEST_API sbyte16_nested STDCALL\nmono_return_sbyte16_nested (sbyte16_nested sn16, int addend) {\n\tif (sn16.nested1.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.nested1.f1: got %d but expected %d\\n\", sn16.nested1.f1, 1);\n\t}\n\tif (sn16.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.f2: got %d but expected %d\\n\", sn16.f2, 2);\n\t}\n\tif (sn16.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.f3: got %d but expected %d\\n\", sn16.f3, 3);\n\t}\n\tif (sn16.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.f4: got %d but expected %d\\n\", sn16.f4, 4);\n\t}\n\tif (sn16.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.f5: got %d but expected %d\\n\", sn16.f5, 5);\n\t}\n\tif (sn16.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.f6: got %d but expected %d\\n\", sn16.f6, 6);\n\t}\n\tif (sn16.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.f7: got %d but expected %d\\n\", sn16.f7, 7);\n\t}\n\tif (sn16.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.f8: got %d but expected %d\\n\", sn16.f8, 8);\n\t}\n\tif (sn16.f9 != 9) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.f9: got %d but expected %d\\n\", sn16.f9, 9);\n\t}\n\tif (sn16.f10 != 10) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.f10: got %d but expected %d\\n\", sn16.f10, 10);\n\t}\n\tif (sn16.f11 != 11) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.f11: got %d but expected %d\\n\", sn16.f11, 11);\n\t}\n\tif (sn16.f12 != 12) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.f12: got %d but expected %d\\n\", sn16.f12, 12);\n\t}\n\tif (sn16.f13 != 13) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.f13: got %d but expected %d\\n\", sn16.f13, 13);\n\t}\n\tif (sn16.f14 != 14) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.f14: got %d but expected %d\\n\", sn16.f14, 14);\n\t}\n\tif (sn16.f15 != 15) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.f15: got %d but expected %d\\n\", sn16.f15, 15);\n\t}\n\tif (sn16.nested2.f16 != 16) {\n\t\tfprintf(stderr, \"mono_return_sbyte16_nested sn16.nested2.f16: got %d but expected %d\\n\", sn16.nested2.f16, 16);\n\t}\n\tsn16.nested1.f1+=addend; sn16.f2+=addend; sn16.f3+=addend; sn16.f4+=addend; sn16.f5+=addend; sn16.f6+=addend; sn16.f7+=addend; sn16.f8+=addend; sn16.f9+=addend; sn16.f10+=addend; sn16.f11+=addend; sn16.f12+=addend; sn16.f13+=addend; sn16.f14+=addend; sn16.f15+=addend; sn16.nested2.f16+=addend; \n\treturn sn16;\n}\n\n\ntypedef struct {\n\tshort f1;\n} short1;\n\nLIBTEST_API short1 STDCALL\nmono_return_short1 (short1 s1, int addend) {\n\tif (s1.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_short1 s1.f1: got %d but expected %d\\n\", s1.f1, 1);\n\t}\n\ts1.f1+=addend; \n\treturn s1;\n}\n\ntypedef struct {\n\tshort f1,f2;\n} short2;\n\nLIBTEST_API short2 STDCALL\nmono_return_short2 (short2 s2, int addend) {\n\tif (s2.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_short2 s2.f1: got %d but expected %d\\n\", s2.f1, 1);\n\t}\n\tif (s2.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_short2 s2.f2: got %d but expected %d\\n\", s2.f2, 2);\n\t}\n\ts2.f1+=addend; s2.f2+=addend; \n\treturn s2;\n}\n\ntypedef struct {\n\tshort f1,f2,f3;\n} short3;\n\nLIBTEST_API short3 STDCALL\nmono_return_short3 (short3 s3, int addend) {\n\tif (s3.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_short3 s3.f1: got %d but expected %d\\n\", s3.f1, 1);\n\t}\n\tif (s3.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_short3 s3.f2: got %d but expected %d\\n\", s3.f2, 2);\n\t}\n\tif (s3.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_short3 s3.f3: got %d but expected %d\\n\", s3.f3, 3);\n\t}\n\ts3.f1+=addend; s3.f2+=addend; s3.f3+=addend; \n\treturn s3;\n}\n\ntypedef struct {\n\tshort f1,f2,f3,f4;\n} short4;\n\nLIBTEST_API short4 STDCALL\nmono_return_short4 (short4 s4, int addend) {\n\tif (s4.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_short4 s4.f1: got %d but expected %d\\n\", s4.f1, 1);\n\t}\n\tif (s4.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_short4 s4.f2: got %d but expected %d\\n\", s4.f2, 2);\n\t}\n\tif (s4.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_short4 s4.f3: got %d but expected %d\\n\", s4.f3, 3);\n\t}\n\tif (s4.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_short4 s4.f4: got %d but expected %d\\n\", s4.f4, 4);\n\t}\n\ts4.f1+=addend; s4.f2+=addend; s4.f3+=addend; s4.f4+=addend; \n\treturn s4;\n}\n\ntypedef struct {\n\tshort f1,f2,f3,f4,f5;\n} short5;\n\nLIBTEST_API short5 STDCALL\nmono_return_short5 (short5 s5, int addend) {\n\tif (s5.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_short5 s5.f1: got %d but expected %d\\n\", s5.f1, 1);\n\t}\n\tif (s5.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_short5 s5.f2: got %d but expected %d\\n\", s5.f2, 2);\n\t}\n\tif (s5.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_short5 s5.f3: got %d but expected %d\\n\", s5.f3, 3);\n\t}\n\tif (s5.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_short5 s5.f4: got %d but expected %d\\n\", s5.f4, 4);\n\t}\n\tif (s5.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_short5 s5.f5: got %d but expected %d\\n\", s5.f5, 5);\n\t}\n\ts5.f1+=addend; s5.f2+=addend; s5.f3+=addend; s5.f4+=addend; s5.f5+=addend; \n\treturn s5;\n}\n\ntypedef struct {\n\tshort f1,f2,f3,f4,f5,f6;\n} short6;\n\nLIBTEST_API short6 STDCALL\nmono_return_short6 (short6 s6, int addend) {\n\tif (s6.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_short6 s6.f1: got %d but expected %d\\n\", s6.f1, 1);\n\t}\n\tif (s6.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_short6 s6.f2: got %d but expected %d\\n\", s6.f2, 2);\n\t}\n\tif (s6.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_short6 s6.f3: got %d but expected %d\\n\", s6.f3, 3);\n\t}\n\tif (s6.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_short6 s6.f4: got %d but expected %d\\n\", s6.f4, 4);\n\t}\n\tif (s6.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_short6 s6.f5: got %d but expected %d\\n\", s6.f5, 5);\n\t}\n\tif (s6.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_short6 s6.f6: got %d but expected %d\\n\", s6.f6, 6);\n\t}\n\ts6.f1+=addend; s6.f2+=addend; s6.f3+=addend; s6.f4+=addend; s6.f5+=addend; s6.f6+=addend; \n\treturn s6;\n}\n\ntypedef struct {\n\tshort f1,f2,f3,f4,f5,f6,f7;\n} short7;\n\nLIBTEST_API short7 STDCALL\nmono_return_short7 (short7 s7, int addend) {\n\tif (s7.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_short7 s7.f1: got %d but expected %d\\n\", s7.f1, 1);\n\t}\n\tif (s7.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_short7 s7.f2: got %d but expected %d\\n\", s7.f2, 2);\n\t}\n\tif (s7.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_short7 s7.f3: got %d but expected %d\\n\", s7.f3, 3);\n\t}\n\tif (s7.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_short7 s7.f4: got %d but expected %d\\n\", s7.f4, 4);\n\t}\n\tif (s7.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_short7 s7.f5: got %d but expected %d\\n\", s7.f5, 5);\n\t}\n\tif (s7.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_short7 s7.f6: got %d but expected %d\\n\", s7.f6, 6);\n\t}\n\tif (s7.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_short7 s7.f7: got %d but expected %d\\n\", s7.f7, 7);\n\t}\n\ts7.f1+=addend; s7.f2+=addend; s7.f3+=addend; s7.f4+=addend; s7.f5+=addend; s7.f6+=addend; s7.f7+=addend; \n\treturn s7;\n}\n\ntypedef struct {\n\tshort f1,f2,f3,f4,f5,f6,f7,f8;\n} short8;\n\nLIBTEST_API short8 STDCALL\nmono_return_short8 (short8 s8, int addend) {\n\tif (s8.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_short8 s8.f1: got %d but expected %d\\n\", s8.f1, 1);\n\t}\n\tif (s8.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_short8 s8.f2: got %d but expected %d\\n\", s8.f2, 2);\n\t}\n\tif (s8.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_short8 s8.f3: got %d but expected %d\\n\", s8.f3, 3);\n\t}\n\tif (s8.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_short8 s8.f4: got %d but expected %d\\n\", s8.f4, 4);\n\t}\n\tif (s8.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_short8 s8.f5: got %d but expected %d\\n\", s8.f5, 5);\n\t}\n\tif (s8.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_short8 s8.f6: got %d but expected %d\\n\", s8.f6, 6);\n\t}\n\tif (s8.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_short8 s8.f7: got %d but expected %d\\n\", s8.f7, 7);\n\t}\n\tif (s8.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_short8 s8.f8: got %d but expected %d\\n\", s8.f8, 8);\n\t}\n\ts8.f1+=addend; s8.f2+=addend; s8.f3+=addend; s8.f4+=addend; s8.f5+=addend; s8.f6+=addend; s8.f7+=addend; s8.f8+=addend; \n\treturn s8;\n}\n\ntypedef struct {\n\tshort f1,f2,f3,f4,f5,f6,f7,f8,f9;\n} short9;\n\nLIBTEST_API short9 STDCALL\nmono_return_short9 (short9 s9, int addend) {\n\tif (s9.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_short9 s9.f1: got %d but expected %d\\n\", s9.f1, 1);\n\t}\n\tif (s9.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_short9 s9.f2: got %d but expected %d\\n\", s9.f2, 2);\n\t}\n\tif (s9.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_short9 s9.f3: got %d but expected %d\\n\", s9.f3, 3);\n\t}\n\tif (s9.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_short9 s9.f4: got %d but expected %d\\n\", s9.f4, 4);\n\t}\n\tif (s9.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_short9 s9.f5: got %d but expected %d\\n\", s9.f5, 5);\n\t}\n\tif (s9.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_short9 s9.f6: got %d but expected %d\\n\", s9.f6, 6);\n\t}\n\tif (s9.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_short9 s9.f7: got %d but expected %d\\n\", s9.f7, 7);\n\t}\n\tif (s9.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_short9 s9.f8: got %d but expected %d\\n\", s9.f8, 8);\n\t}\n\tif (s9.f9 != 9) {\n\t\tfprintf(stderr, \"mono_return_short9 s9.f9: got %d but expected %d\\n\", s9.f9, 9);\n\t}\n\ts9.f1+=addend; s9.f2+=addend; s9.f3+=addend; s9.f4+=addend; s9.f5+=addend; s9.f6+=addend; s9.f7+=addend; s9.f8+=addend; s9.f9+=addend; \n\treturn s9;\n}\n\ntypedef struct {\n\tstruct {\n\t\tshort f1;\n\t} nested1;\n\tshort f2,f3,f4,f5,f6,f7;\n\tstruct {\n\t\tshort f8;\n\t} nested2;\n} short8_nested;\n\nLIBTEST_API short8_nested STDCALL\nmono_return_short8_nested (short8_nested sn8, int addend) {\n\tif (sn8.nested1.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_short8_nested sn8.nested1.f1: got %d but expected %d\\n\", sn8.nested1.f1, 1);\n\t}\n\tif (sn8.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_short8_nested sn8.f2: got %d but expected %d\\n\", sn8.f2, 2);\n\t}\n\tif (sn8.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_short8_nested sn8.f3: got %d but expected %d\\n\", sn8.f3, 3);\n\t}\n\tif (sn8.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_short8_nested sn8.f4: got %d but expected %d\\n\", sn8.f4, 4);\n\t}\n\tif (sn8.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_short8_nested sn8.f5: got %d but expected %d\\n\", sn8.f5, 5);\n\t}\n\tif (sn8.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_short8_nested sn8.f6: got %d but expected %d\\n\", sn8.f6, 6);\n\t}\n\tif (sn8.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_short8_nested sn8.f7: got %d but expected %d\\n\", sn8.f7, 7);\n\t}\n\tif (sn8.nested2.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_short8_nested sn8.nested2.f8: got %d but expected %d\\n\", sn8.nested2.f8, 8);\n\t}\n\tsn8.nested1.f1+=addend; sn8.f2+=addend; sn8.f3+=addend; sn8.f4+=addend; sn8.f5+=addend; sn8.f6+=addend; sn8.f7+=addend; sn8.nested2.f8+=addend; \n\treturn sn8;\n}\n\n\ntypedef struct {\n\tint f1;\n} int1;\n\nLIBTEST_API int1 STDCALL\nmono_return_int1 (int1 s1, int addend) {\n\tif (s1.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_int1 s1.f1: got %d but expected %d\\n\", s1.f1, 1);\n\t}\n\ts1.f1+=addend; \n\treturn s1;\n}\n\ntypedef struct {\n\tint f1,f2;\n} int2;\n\nLIBTEST_API int2 STDCALL\nmono_return_int2 (int2 s2, int addend) {\n\tif (s2.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_int2 s2.f1: got %d but expected %d\\n\", s2.f1, 1);\n\t}\n\tif (s2.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_int2 s2.f2: got %d but expected %d\\n\", s2.f2, 2);\n\t}\n\ts2.f1+=addend; s2.f2+=addend; \n\treturn s2;\n}\n\ntypedef struct {\n\tint f1,f2,f3;\n} int3;\n\nLIBTEST_API int3 STDCALL\nmono_return_int3 (int3 s3, int addend) {\n\tif (s3.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_int3 s3.f1: got %d but expected %d\\n\", s3.f1, 1);\n\t}\n\tif (s3.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_int3 s3.f2: got %d but expected %d\\n\", s3.f2, 2);\n\t}\n\tif (s3.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_int3 s3.f3: got %d but expected %d\\n\", s3.f3, 3);\n\t}\n\ts3.f1+=addend; s3.f2+=addend; s3.f3+=addend; \n\treturn s3;\n}\n\ntypedef struct {\n\tint f1,f2,f3,f4;\n} int4;\n\nLIBTEST_API int4 STDCALL\nmono_return_int4 (int4 s4, int addend) {\n\tif (s4.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_int4 s4.f1: got %d but expected %d\\n\", s4.f1, 1);\n\t}\n\tif (s4.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_int4 s4.f2: got %d but expected %d\\n\", s4.f2, 2);\n\t}\n\tif (s4.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_int4 s4.f3: got %d but expected %d\\n\", s4.f3, 3);\n\t}\n\tif (s4.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_int4 s4.f4: got %d but expected %d\\n\", s4.f4, 4);\n\t}\n\ts4.f1+=addend; s4.f2+=addend; s4.f3+=addend; s4.f4+=addend; \n\treturn s4;\n}\n\ntypedef struct {\n\tint f1,f2,f3,f4,f5;\n} int5;\n\nLIBTEST_API int5 STDCALL\nmono_return_int5 (int5 s5, int addend) {\n\tif (s5.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_int5 s5.f1: got %d but expected %d\\n\", s5.f1, 1);\n\t}\n\tif (s5.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_int5 s5.f2: got %d but expected %d\\n\", s5.f2, 2);\n\t}\n\tif (s5.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_int5 s5.f3: got %d but expected %d\\n\", s5.f3, 3);\n\t}\n\tif (s5.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_int5 s5.f4: got %d but expected %d\\n\", s5.f4, 4);\n\t}\n\tif (s5.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_int5 s5.f5: got %d but expected %d\\n\", s5.f5, 5);\n\t}\n\ts5.f1+=addend; s5.f2+=addend; s5.f3+=addend; s5.f4+=addend; s5.f5+=addend; \n\treturn s5;\n}\n\ntypedef struct {\n\tstruct {\n\t\tint f1;\n\t} nested1;\n\tint f2,f3;\n\tstruct {\n\t\tint f4;\n\t} nested2;\n} int4_nested;\n\nLIBTEST_API int4_nested STDCALL\nmono_return_int4_nested (int4_nested sn4, int addend) {\n\tif (sn4.nested1.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_int4_nested sn4.nested1.f1: got %d but expected %d\\n\", sn4.nested1.f1, 1);\n\t}\n\tif (sn4.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_int4_nested sn4.f2: got %d but expected %d\\n\", sn4.f2, 2);\n\t}\n\tif (sn4.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_int4_nested sn4.f3: got %d but expected %d\\n\", sn4.f3, 3);\n\t}\n\tif (sn4.nested2.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_int4_nested sn4.nested2.f4: got %d but expected %d\\n\", sn4.nested2.f4, 4);\n\t}\n\tsn4.nested1.f1+=addend; sn4.f2+=addend; sn4.f3+=addend; sn4.nested2.f4+=addend; \n\treturn sn4;\n}\n\ntypedef struct {\n\tfloat f1;\n} float1;\n\nLIBTEST_API float1 STDCALL\nmono_return_float1 (float1 s1, int addend) {\n\tif (s1.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_float1 s1.f1: got %f but expected %d\\n\", s1.f1, 1);\n\t}\n\ts1.f1+=addend; \n\treturn s1;\n}\n\ntypedef struct {\n\tfloat f1,f2;\n} float2;\n\nLIBTEST_API float2 STDCALL\nmono_return_float2 (float2 s2, int addend) {\n\tif (s2.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_float2 s2.f1: got %f but expected %d\\n\", s2.f1, 1);\n\t}\n\tif (s2.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_float2 s2.f2: got %f but expected %d\\n\", s2.f2, 2);\n\t}\n\ts2.f1+=addend; s2.f2+=addend; \n\treturn s2;\n}\n\ntypedef struct {\n\tfloat f1,f2,f3;\n} float3;\n\nLIBTEST_API float3 STDCALL\nmono_return_float3 (float3 s3, int addend) {\n\tif (s3.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_float3 s3.f1: got %f but expected %d\\n\", s3.f1, 1);\n\t}\n\tif (s3.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_float3 s3.f2: got %f but expected %d\\n\", s3.f2, 2);\n\t}\n\tif (s3.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_float3 s3.f3: got %f but expected %d\\n\", s3.f3, 3);\n\t}\n\ts3.f1+=addend; s3.f2+=addend; s3.f3+=addend; \n\treturn s3;\n}\n\ntypedef struct {\n\tfloat f1,f2,f3,f4;\n} float4;\n\nLIBTEST_API float4 STDCALL\nmono_return_float4 (float4 s4, int addend) {\n\tif (s4.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_float4 s4.f1: got %f but expected %d\\n\", s4.f1, 1);\n\t}\n\tif (s4.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_float4 s4.f2: got %f but expected %d\\n\", s4.f2, 2);\n\t}\n\tif (s4.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_float4 s4.f3: got %f but expected %d\\n\", s4.f3, 3);\n\t}\n\tif (s4.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_float4 s4.f4: got %f but expected %d\\n\", s4.f4, 4);\n\t}\n\ts4.f1+=addend; s4.f2+=addend; s4.f3+=addend; s4.f4+=addend; \n\treturn s4;\n}\n\ntypedef struct {\n\tfloat f1,f2,f3,f4,f5;\n} float5;\n\nLIBTEST_API float5 STDCALL\nmono_return_float5 (float5 s5, int addend) {\n\tif (s5.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_float5 s5.f1: got %f but expected %d\\n\", s5.f1, 1);\n\t}\n\tif (s5.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_float5 s5.f2: got %f but expected %d\\n\", s5.f2, 2);\n\t}\n\tif (s5.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_float5 s5.f3: got %f but expected %d\\n\", s5.f3, 3);\n\t}\n\tif (s5.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_float5 s5.f4: got %f but expected %d\\n\", s5.f4, 4);\n\t}\n\tif (s5.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_float5 s5.f5: got %f but expected %d\\n\", s5.f5, 5);\n\t}\n\ts5.f1+=addend; s5.f2+=addend; s5.f3+=addend; s5.f4+=addend; s5.f5+=addend; \n\treturn s5;\n}\n\ntypedef struct {\n\tfloat f1,f2,f3,f4,f5,f6;\n} float6;\n\nLIBTEST_API float6 STDCALL\nmono_return_float6 (float6 s6, int addend) {\n\tif (s6.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_float6 s6.f1: got %f but expected %d\\n\", s6.f1, 1);\n\t}\n\tif (s6.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_float6 s6.f2: got %f but expected %d\\n\", s6.f2, 2);\n\t}\n\tif (s6.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_float6 s6.f3: got %f but expected %d\\n\", s6.f3, 3);\n\t}\n\tif (s6.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_float6 s6.f4: got %f but expected %d\\n\", s6.f4, 4);\n\t}\n\tif (s6.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_float6 s6.f5: got %f but expected %d\\n\", s6.f5, 5);\n\t}\n\tif (s6.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_float6 s6.f6: got %f but expected %d\\n\", s6.f6, 6);\n\t}\n\ts6.f1+=addend; s6.f2+=addend; s6.f3+=addend; s6.f4+=addend; s6.f5+=addend; s6.f6+=addend; \n\treturn s6;\n}\n\ntypedef struct {\n\tfloat f1,f2,f3,f4,f5,f6,f7;\n} float7;\n\nLIBTEST_API float7 STDCALL\nmono_return_float7 (float7 s7, int addend) {\n\tif (s7.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_float7 s7.f1: got %f but expected %d\\n\", s7.f1, 1);\n\t}\n\tif (s7.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_float7 s7.f2: got %f but expected %d\\n\", s7.f2, 2);\n\t}\n\tif (s7.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_float7 s7.f3: got %f but expected %d\\n\", s7.f3, 3);\n\t}\n\tif (s7.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_float7 s7.f4: got %f but expected %d\\n\", s7.f4, 4);\n\t}\n\tif (s7.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_float7 s7.f5: got %f but expected %d\\n\", s7.f5, 5);\n\t}\n\tif (s7.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_float7 s7.f6: got %f but expected %d\\n\", s7.f6, 6);\n\t}\n\tif (s7.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_float7 s7.f7: got %f but expected %d\\n\", s7.f7, 7);\n\t}\n\ts7.f1+=addend; s7.f2+=addend; s7.f3+=addend; s7.f4+=addend; s7.f5+=addend; s7.f6+=addend; s7.f7+=addend; \n\treturn s7;\n}\n\ntypedef struct {\n\tfloat f1,f2,f3,f4,f5,f6,f7,f8;\n} float8;\n\nLIBTEST_API float8 STDCALL\nmono_return_float8 (float8 s8, int addend) {\n\tif (s8.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_float8 s8.f1: got %f but expected %d\\n\", s8.f1, 1);\n\t}\n\tif (s8.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_float8 s8.f2: got %f but expected %d\\n\", s8.f2, 2);\n\t}\n\tif (s8.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_float8 s8.f3: got %f but expected %d\\n\", s8.f3, 3);\n\t}\n\tif (s8.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_float8 s8.f4: got %f but expected %d\\n\", s8.f4, 4);\n\t}\n\tif (s8.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_float8 s8.f5: got %f but expected %d\\n\", s8.f5, 5);\n\t}\n\tif (s8.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_float8 s8.f6: got %f but expected %d\\n\", s8.f6, 6);\n\t}\n\tif (s8.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_float8 s8.f7: got %f but expected %d\\n\", s8.f7, 7);\n\t}\n\tif (s8.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_float8 s8.f8: got %f but expected %d\\n\", s8.f8, 8);\n\t}\n\ts8.f1+=addend; s8.f2+=addend; s8.f3+=addend; s8.f4+=addend; s8.f5+=addend; s8.f6+=addend; s8.f7+=addend; s8.f8+=addend; \n\treturn s8;\n}\n\ntypedef struct {\n\tfloat f1,f2,f3,f4,f5,f6,f7,f8,f9;\n} float9;\n\nLIBTEST_API float9 STDCALL\nmono_return_float9 (float9 s9, int addend) {\n\tif (s9.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_float9 s9.f1: got %f but expected %d\\n\", s9.f1, 1);\n\t}\n\tif (s9.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_float9 s9.f2: got %f but expected %d\\n\", s9.f2, 2);\n\t}\n\tif (s9.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_float9 s9.f3: got %f but expected %d\\n\", s9.f3, 3);\n\t}\n\tif (s9.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_float9 s9.f4: got %f but expected %d\\n\", s9.f4, 4);\n\t}\n\tif (s9.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_float9 s9.f5: got %f but expected %d\\n\", s9.f5, 5);\n\t}\n\tif (s9.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_float9 s9.f6: got %f but expected %d\\n\", s9.f6, 6);\n\t}\n\tif (s9.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_float9 s9.f7: got %f but expected %d\\n\", s9.f7, 7);\n\t}\n\tif (s9.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_float9 s9.f8: got %f but expected %d\\n\", s9.f8, 8);\n\t}\n\tif (s9.f9 != 9) {\n\t\tfprintf(stderr, \"mono_return_float9 s9.f9: got %f but expected %d\\n\", s9.f9, 9);\n\t}\n\ts9.f1+=addend; s9.f2+=addend; s9.f3+=addend; s9.f4+=addend; s9.f5+=addend; s9.f6+=addend; s9.f7+=addend; s9.f8+=addend; s9.f9+=addend; \n\treturn s9;\n}\n\ntypedef struct {\n\tstruct {\n\t\tfloat f1;\n\t} nested1;\n\tfloat f2,f3;\n\tstruct {\n\t\tfloat f4;\n\t} nested2;\n} float4_nested;\n\nLIBTEST_API float4_nested STDCALL\nmono_return_float4_nested (float4_nested sn4, int addend) {\n\tif (sn4.nested1.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_float4_nested sn4.nested1.f1: got %f but expected %d\\n\", sn4.nested1.f1, 1);\n\t}\n\tif (sn4.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_float4_nested sn4.f2: got %f but expected %d\\n\", sn4.f2, 2);\n\t}\n\tif (sn4.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_float4_nested sn4.f3: got %f but expected %d\\n\", sn4.f3, 3);\n\t}\n\tif (sn4.nested2.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_float4_nested sn4.nested2.f4: got %f but expected %d\\n\", sn4.nested2.f4, 4);\n\t}\n\tsn4.nested1.f1+=addend; sn4.f2+=addend; sn4.f3+=addend; sn4.nested2.f4+=addend; \n\treturn sn4;\n}\n\ntypedef struct {\n\tdouble f1;\n} double1;\n\nLIBTEST_API double1 STDCALL\nmono_return_double1 (double1 s1, int addend) {\n\tif (s1.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_double1 s1.f1: got %f but expected %d\\n\", s1.f1, 1);\n\t}\n\ts1.f1+=addend; \n\treturn s1;\n}\n\ntypedef struct {\n\tdouble f1,f2;\n} double2;\n\nLIBTEST_API double2 STDCALL\nmono_return_double2 (double2 s2, int addend) {\n\tif (s2.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_double2 s2.f1: got %f but expected %d\\n\", s2.f1, 1);\n\t}\n\tif (s2.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_double2 s2.f2: got %f but expected %d\\n\", s2.f2, 2);\n\t}\n\ts2.f1+=addend; s2.f2+=addend; \n\treturn s2;\n}\n\ntypedef struct {\n\tdouble f1,f2,f3;\n} double3;\n\nLIBTEST_API double3 STDCALL\nmono_return_double3 (double3 s3, int addend) {\n\tif (s3.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_double3 s3.f1: got %f but expected %d\\n\", s3.f1, 1);\n\t}\n\tif (s3.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_double3 s3.f2: got %f but expected %d\\n\", s3.f2, 2);\n\t}\n\tif (s3.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_double3 s3.f3: got %f but expected %d\\n\", s3.f3, 3);\n\t}\n\ts3.f1+=addend; s3.f2+=addend; s3.f3+=addend; \n\treturn s3;\n}\n\ntypedef struct {\n\tdouble f1,f2,f3,f4;\n} double4;\n\nLIBTEST_API double4 STDCALL\nmono_return_double4 (double4 s4, int addend) {\n\tif (s4.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_double4 s4.f1: got %f but expected %d\\n\", s4.f1, 1);\n\t}\n\tif (s4.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_double4 s4.f2: got %f but expected %d\\n\", s4.f2, 2);\n\t}\n\tif (s4.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_double4 s4.f3: got %f but expected %d\\n\", s4.f3, 3);\n\t}\n\tif (s4.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_double4 s4.f4: got %f but expected %d\\n\", s4.f4, 4);\n\t}\n\ts4.f1+=addend; s4.f2+=addend; s4.f3+=addend; s4.f4+=addend; \n\treturn s4;\n}\n\ntypedef struct {\n\tdouble f1,f2,f3,f4,f5;\n} double5;\n\nLIBTEST_API double5 STDCALL\nmono_return_double5 (double5 s5, int addend) {\n\tif (s5.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_double5 s5.f1: got %f but expected %d\\n\", s5.f1, 1);\n\t}\n\tif (s5.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_double5 s5.f2: got %f but expected %d\\n\", s5.f2, 2);\n\t}\n\tif (s5.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_double5 s5.f3: got %f but expected %d\\n\", s5.f3, 3);\n\t}\n\tif (s5.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_double5 s5.f4: got %f but expected %d\\n\", s5.f4, 4);\n\t}\n\tif (s5.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_double5 s5.f5: got %f but expected %d\\n\", s5.f5, 5);\n\t}\n\ts5.f1+=addend; s5.f2+=addend; s5.f3+=addend; s5.f4+=addend; s5.f5+=addend; \n\treturn s5;\n}\n\ntypedef struct {\n\tdouble f1,f2,f3,f4,f5,f6;\n} double6;\n\nLIBTEST_API double6 STDCALL\nmono_return_double6 (double6 s6, int addend) {\n\tif (s6.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_double6 s6.f1: got %f but expected %d\\n\", s6.f1, 1);\n\t}\n\tif (s6.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_double6 s6.f2: got %f but expected %d\\n\", s6.f2, 2);\n\t}\n\tif (s6.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_double6 s6.f3: got %f but expected %d\\n\", s6.f3, 3);\n\t}\n\tif (s6.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_double6 s6.f4: got %f but expected %d\\n\", s6.f4, 4);\n\t}\n\tif (s6.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_double6 s6.f5: got %f but expected %d\\n\", s6.f5, 5);\n\t}\n\tif (s6.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_double6 s6.f6: got %f but expected %d\\n\", s6.f6, 6);\n\t}\n\ts6.f1+=addend; s6.f2+=addend; s6.f3+=addend; s6.f4+=addend; s6.f5+=addend; s6.f6+=addend; \n\treturn s6;\n}\n\ntypedef struct {\n\tdouble f1,f2,f3,f4,f5,f6,f7;\n} double7;\n\nLIBTEST_API double7 STDCALL\nmono_return_double7 (double7 s7, int addend) {\n\tif (s7.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_double7 s7.f1: got %f but expected %d\\n\", s7.f1, 1);\n\t}\n\tif (s7.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_double7 s7.f2: got %f but expected %d\\n\", s7.f2, 2);\n\t}\n\tif (s7.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_double7 s7.f3: got %f but expected %d\\n\", s7.f3, 3);\n\t}\n\tif (s7.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_double7 s7.f4: got %f but expected %d\\n\", s7.f4, 4);\n\t}\n\tif (s7.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_double7 s7.f5: got %f but expected %d\\n\", s7.f5, 5);\n\t}\n\tif (s7.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_double7 s7.f6: got %f but expected %d\\n\", s7.f6, 6);\n\t}\n\tif (s7.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_double7 s7.f7: got %f but expected %d\\n\", s7.f7, 7);\n\t}\n\ts7.f1+=addend; s7.f2+=addend; s7.f3+=addend; s7.f4+=addend; s7.f5+=addend; s7.f6+=addend; s7.f7+=addend; \n\treturn s7;\n}\n\ntypedef struct {\n\tdouble f1,f2,f3,f4,f5,f6,f7,f8;\n} double8;\n\nLIBTEST_API double8 STDCALL\nmono_return_double8 (double8 s8, int addend) {\n\tif (s8.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_double8 s8.f1: got %f but expected %d\\n\", s8.f1, 1);\n\t}\n\tif (s8.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_double8 s8.f2: got %f but expected %d\\n\", s8.f2, 2);\n\t}\n\tif (s8.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_double8 s8.f3: got %f but expected %d\\n\", s8.f3, 3);\n\t}\n\tif (s8.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_double8 s8.f4: got %f but expected %d\\n\", s8.f4, 4);\n\t}\n\tif (s8.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_double8 s8.f5: got %f but expected %d\\n\", s8.f5, 5);\n\t}\n\tif (s8.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_double8 s8.f6: got %f but expected %d\\n\", s8.f6, 6);\n\t}\n\tif (s8.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_double8 s8.f7: got %f but expected %d\\n\", s8.f7, 7);\n\t}\n\tif (s8.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_double8 s8.f8: got %f but expected %d\\n\", s8.f8, 8);\n\t}\n\ts8.f1+=addend; s8.f2+=addend; s8.f3+=addend; s8.f4+=addend; s8.f5+=addend; s8.f6+=addend; s8.f7+=addend; s8.f8+=addend; \n\treturn s8;\n}\n\ntypedef struct {\n\tdouble f1,f2,f3,f4,f5,f6,f7,f8,f9;\n} double9;\n\nLIBTEST_API double9 STDCALL\nmono_return_double9 (double9 s9, int addend) {\n\tif (s9.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_double9 s9.f1: got %f but expected %d\\n\", s9.f1, 1);\n\t}\n\tif (s9.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_double9 s9.f2: got %f but expected %d\\n\", s9.f2, 2);\n\t}\n\tif (s9.f3 != 3) {\n\t\tfprintf(stderr, \"mono_return_double9 s9.f3: got %f but expected %d\\n\", s9.f3, 3);\n\t}\n\tif (s9.f4 != 4) {\n\t\tfprintf(stderr, \"mono_return_double9 s9.f4: got %f but expected %d\\n\", s9.f4, 4);\n\t}\n\tif (s9.f5 != 5) {\n\t\tfprintf(stderr, \"mono_return_double9 s9.f5: got %f but expected %d\\n\", s9.f5, 5);\n\t}\n\tif (s9.f6 != 6) {\n\t\tfprintf(stderr, \"mono_return_double9 s9.f6: got %f but expected %d\\n\", s9.f6, 6);\n\t}\n\tif (s9.f7 != 7) {\n\t\tfprintf(stderr, \"mono_return_double9 s9.f7: got %f but expected %d\\n\", s9.f7, 7);\n\t}\n\tif (s9.f8 != 8) {\n\t\tfprintf(stderr, \"mono_return_double9 s9.f8: got %f but expected %d\\n\", s9.f8, 8);\n\t}\n\tif (s9.f9 != 9) {\n\t\tfprintf(stderr, \"mono_return_double9 s9.f9: got %f but expected %d\\n\", s9.f9, 9);\n\t}\n\ts9.f1+=addend; s9.f2+=addend; s9.f3+=addend; s9.f4+=addend; s9.f5+=addend; s9.f6+=addend; s9.f7+=addend; s9.f8+=addend; s9.f9+=addend; \n\treturn s9;\n}\n\ntypedef struct {\n\tstruct {\n\t\tdouble f1;\n\t} nested1;\n\tstruct {\n\t\tdouble f2;\n\t} nested2;\n} double2_nested;\n\nLIBTEST_API double2_nested STDCALL\nmono_return_double2_nested (double2_nested sn2, int addend) {\n\tif (sn2.nested1.f1 != 1) {\n\t\tfprintf(stderr, \"mono_return_double2_nested sn2.nested1.f1: got %f but expected %d\\n\", sn2.nested1.f1, 1);\n\t}\n\tif (sn2.nested2.f2 != 2) {\n\t\tfprintf(stderr, \"mono_return_double2_nested sn2.nested2.f2: got %f but expected %d\\n\", sn2.nested2.f2, 2);\n\t}\n\tsn2.nested1.f1+=addend; sn2.nested2.f2+=addend; \n\treturn sn2;\n}\n\n\n\ntypedef struct {\n\tdouble f1[4];\n} double_array4;\n\nLIBTEST_API double_array4 STDCALL\nmono_return_double_array4 (double_array4 sa4, int addend) {\n\tif (sa4.f1[0] != 1) {\n\t\tfprintf(stderr, \"mono_return_double_array4 sa4.f1[0]: got %f but expected %d\\n\", sa4.f1[0], 1);\n\t}\n\tif (sa4.f1[1] != 2) {\n\t\tfprintf(stderr, \"mono_return_double_array4 sa4.f1[1]: got %f but expected %d\\n\", sa4.f1[1], 2);\n\t}\n\tif (sa4.f1[2] != 3) {\n\t\tfprintf(stderr, \"mono_return_double_array4 sa4.f1[2]: got %f but expected %d\\n\", sa4.f1[2], 3);\n\t}\n\tif (sa4.f1[3] != 4) {\n\t\tfprintf(stderr, \"mono_return_double_array4 sa4.f1[3]: got %f but expected %d\\n\", sa4.f1[3], 4);\n\t}\n\tsa4.f1[0]+=addend; sa4.f1[1]+=addend; sa4.f1[2]+=addend; sa4.f1[3]+=addend; \n\treturn sa4;\n}\n\ntypedef struct {\n\tint array [3];\n} FixedArrayStruct;\n\nLIBTEST_API int STDCALL\nmono_test_marshal_fixed_array (FixedArrayStruct s)\n{\n\treturn s.array [0] + s.array [1] + s.array [2];\n}\n\ntypedef struct {\n\tchar array [16];\n\tchar c;\n} FixedBufferChar;\n\nLIBTEST_API int STDCALL\nmono_test_marshal_fixed_buffer_char (FixedBufferChar *s)\n{\n\tif (!(s->array [0] == 'A' && s->array [1] == 'B' && s->array [2] == 'C' && s->c == 'D'))\n\t\treturn 1;\n\ts->array [0] = 'E';\n\ts->array [1] = 'F';\n\ts->c = 'G';\n\treturn 0;\n}\n\ntypedef struct {\n\tshort array [16];\n\tshort c;\n} FixedBufferUnicode;\n\nLIBTEST_API int STDCALL\nmono_test_marshal_fixed_buffer_unicode (FixedBufferUnicode *s)\n{\n\tif (!(s->array [0] == 'A' && s->array [1] == 'B' && s->array [2] == 'C' && s->c == 'D'))\n\t\treturn 1;\n\ts->array [0] = 'E';\n\ts->array [1] = 'F';\n\ts->c = 'G';\n\treturn 0;\n}\n\nconst int NSTRINGS = 6;\n//test strings\nconst char  *utf8Strings[] = {  \n                                \"Managed\",\n                                 \"S\u00eene kl\u00e2wen durh die wolken sint geslagen\" ,\n                                 \"\u0915\u093e\u091a\u0902 \u0936\u0915\u094d\u0928\u094b\u092e\u094d\u092f\u0924\u094d\u0924\u0941\u092e\u094d \u0964 \u0928\u094b\u092a\u0939\u093f\u0928\u0938\u094d\u0924\u093f \u092e\u093e\u092e\u094d\",\n                                 \"\u6211\u80fd\u541e\u4e0b\u73bb\u7483\u800c\u4e0d\u4f24\u8eab\u4f53\",\n                                 \"\u10e6\u10db\u10d4\u10e0\u10d7\u10e1\u10d8 \u10e8\u10d4\u10db\u10d5\u10d4\u10d3\u10e0\u10d4,\u10e8\u10d4\u10db\u10d5\u10d4\u10d3\u10e0\u10d4, \u10dc\u10e3\u10d7\u10e3 \u10d9\u10d5\u10da\u10d0 \u10d3\u10d0\u10db\u10ee\u10e1\u10dc\u10d0\u10e1 \u10e8\u10d4\u10db\u10d5\u10d4\u10d3\u10e0\u10d4,\u10e1\u10dd\u10e4\u10da\u10d8\u10e1\u10d0 \u10e8\u10d4\u10db\u10d5\u10d4\u10d3\u10e0\u10d4, \u10e8\u10d4\u10db\u10d5\u10d4\u10d3\u10e0\u10d4,\u10e8\u10d4\u10db\u10d5\u10d4\u10d3\u10e0\u10d4,\u10e8\u10d4\u10db\u10d5\u10d4\u10d3\u10e0\u10d4,\u10e8\u10e0\u10dd\u10db\u10d0\u10e1\u10d0, \u10ea\u10d4\u10ea\u10ee\u10da\u10e1, \u10ec\u10e7\u10d0\u10da\u10e1\u10d0 \u10d3\u10d0 \u10db\u10d8\u10ec\u10d0\u10e1\u10d0, \u10f0\u10d0\u10d4\u10e0\u10d7\u10d0 \u10d7\u10d0\u10dc\u10d0 \u10db\u10e0\u10dd\u10db\u10d0\u10e1\u10d0; \u10db\u10dd\u10db\u10ea\u10dc\u10d4\u10e1 \u10e4\u10e0\u10d7\u10d4\u10dc\u10d8 \u10d3\u10d0 \u10d0\u10e6\u10d5\u10e4\u10e0\u10d8\u10dc\u10d3\u10d4, \u10db\u10d8\u10d5\u10f0\u10ee\u10d5\u10d3\u10d4 \u10db\u10d0\u10e1 \u10e9\u10d4\u10db\u10e1\u10d0 \u10dc\u10d3\u10dd\u10db\u10d0\u10e1\u10d0, \u10d3\u10e6\u10d8\u10e1\u10d8\u10d7 \u10d3\u10d0 \u10e6\u10d0\u10db\u10d8\u10d7 \u10d5\u10f0\u10ee\u10d4\u10d3\u10d5\u10d8\u10d3\u10d4 \u10db\u10d6\u10d8\u10e1\u10d0 \u10d4\u10da\u10d5\u10d0\u10d7\u10d0 \u10d9\u10e0\u10d7\u10dd\u10db\u10d0\u10d0\u10e1\u10d0\u10e8\u10d4\u10db\u10d5\u10d4\u10d3\u10e0\u10d4,\u10e8\u10d4\u10db\u10d5\u10d4\u10d3\u10e0\u10d4,\",\n                                 \"\u03a4\u03b7 \u03b3\u03bb\u03ce\u03c3\u03c3\u03b1 \u03bc\u03bf\u03c5 \u03ad\u03b4\u03c9\u03c3\u03b1\u03bd \u03b5\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ae\",\n\"\\0\"\n};\n\nLIBTEST_API char *\nbuild_return_string(const char* pReturn)\n{\n\tchar *ret = 0;\n\tif (pReturn == 0 || *pReturn == 0)\n\t\treturn ret;\n\n\tsize_t strLength = strlen(pReturn);\n\tret = (char *)(marshal_alloc (sizeof(char)* (strLength + 1)));\n\tmemcpy(ret, pReturn, strLength);\n\tret [strLength] = '\\0';\n\treturn ret;\n}\n\nLIBTEST_API char *\nStringParameterInOut(/*[In,Out]*/ char *s, int index)\n{\n\t// return a copy\n\treturn build_return_string(s);\n}\n\nLIBTEST_API void\nStringParameterRefOut(/*out*/ char **s, int index)\n{\n\tchar *pszTextutf8 = (char*)utf8Strings[index];\n\tsize_t strLength = strlen(pszTextutf8);\n\t*s = (char *)(marshal_alloc (sizeof(char)* (strLength + 1)));\n\tmemcpy(*s, pszTextutf8, strLength);\n\t(*s)[strLength] = '\\0';\n}\n\nLIBTEST_API void\nStringParameterRef(/*ref*/ char **s, int index)\n{\n    char *pszTextutf8 = (char*)utf8Strings[index];\n    size_t strLength = strlen(pszTextutf8);\n    // do byte by byte validation of in string\n    size_t szLen = strlen(*s);\n    for (size_t i = 0; i < szLen; i++)\n    {\n        if ((*s)[i] != pszTextutf8[i])\n        {\n            printf(\"[in] managed string do not match native string\\n\");\n\t    abort ();\n        }\n    }\n\n    if (*s)\n    {\n       marshal_free (*s);\n    }\n    // overwrite the orginal \n    *s = (char *)(marshal_alloc (sizeof(char)* (strLength + 1)));\n    memcpy(*s, pszTextutf8, strLength);\n    (*s)[strLength] = '\\0';\n}\n\nLIBTEST_API void\nStringBuilderParameterInOut(/*[In,Out] StringBuilder*/ char *s, int index)\n{\n    // if string.empty \n    if (s == 0 || *s == 0)\n        return;\n\n    char *pszTextutf8 = (char*)utf8Strings[index];\n\n    // do byte by byte validation of in string\n    size_t szLen = strlen(s);\n    for (size_t i = 0; i < szLen; i++) \n    {\n        if (s[i] != pszTextutf8[i])\n        {\n            printf(\"[in] managed string do not match native string\\n\");\n\t    abort ();\n        }\n    }  \n\n    // modify the string inplace \n    size_t outLen = strlen(pszTextutf8);\n    for (size_t i = 0; i < outLen; i++) {\n        s[i] = pszTextutf8[i];\n    }\n    s[outLen] = '\\0';\n}\n\n//out string builder\nLIBTEST_API void\nStringBuilderParameterOut(/*[Out] StringBuilder*/ char *s, int index)\n{\n    char *pszTextutf8 = (char*)utf8Strings[index];\n\n    printf (\"SBPO: Receiving %s\\n\", s);\n    // modify the string inplace \n    size_t outLen = strlen(pszTextutf8);\n    for (size_t i = 0; i < outLen; i++) {\n        s[i] = pszTextutf8[i];\n    }\n    s[outLen] = '\\0';\n}\n\nLIBTEST_API char *\nStringParameterOut(/*[Out]*/ char *s, int index)\n{\n    // return a copy\n    return build_return_string(s);\n}\n\n// Utf8 field\ntypedef struct FieldWithUtf8\n{\n    char *pFirst;\n    int index;\n}FieldWithUtf8;\n\n//utf8 struct field\nLIBTEST_API void\nTestStructWithUtf8Field(struct FieldWithUtf8 fieldStruct)\n{\n    char *pszManagedutf8 = fieldStruct.pFirst;\n    int stringIndex = fieldStruct.index;\n    char *pszNative = 0;\n    size_t outLen = 0;\n\n    if (pszManagedutf8 == 0 || *pszManagedutf8 == 0)\n        return;\n\n    pszNative = (char*)utf8Strings[stringIndex];\n\n    outLen = strlen(pszNative);\n    // do byte by byte comparision\n    for (size_t i = 0; i < outLen; i++) \n    {\n        if (pszNative[i] != pszManagedutf8[i]) \n        {\n            printf(\"Native and managed string do not match.\\n\");\n\t    abort ();\n        }\n    }\n}\n\ntypedef void (* Callback2)(char *text, int index);\n\nLIBTEST_API void\nUtf8DelegateAsParameter(Callback2 managedCallback)\n{\n    for (int i = 0; i < NSTRINGS; ++i) \n    {\n        char *pszNative = 0;\n        pszNative = (char*)utf8Strings[i];\n        managedCallback(pszNative, i);\n    }\n}\n\n\nLIBTEST_API char*\nStringBuilderParameterReturn(int index)\n{\n    char *pszTextutf8 = (char*)utf8Strings[index];\n    size_t strLength = strlen(pszTextutf8);\n    char * ret = (char *)(marshal_alloc (sizeof(char)* (strLength + 1)));\n    memcpy(ret, pszTextutf8, strLength);\n    ret[strLength] = '\\0';\n\n    return  ret;\n}\n\nLIBTEST_API int STDCALL\nmono_test_marshal_pointer_array (int *arr[])\n{\n\tint i;\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tif (*arr [i] != -1)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#ifndef WIN32\n\ntypedef void (*NativeToManagedExceptionRethrowFunc) (void);\n\nvoid *mono_test_native_to_managed_exception_rethrow_thread (void *arg)\n{\n\tNativeToManagedExceptionRethrowFunc func = (NativeToManagedExceptionRethrowFunc) arg;\n\tfunc ();\n\treturn NULL;\n}\n\nLIBTEST_API void STDCALL\nmono_test_native_to_managed_exception_rethrow (NativeToManagedExceptionRethrowFunc func)\n{\n\tpthread_t t;\n\tpthread_create (&t, NULL, mono_test_native_to_managed_exception_rethrow_thread, (gpointer)func);\n\tpthread_join (t, NULL);\n}\n#endif\n\ntypedef void (*VoidVoidCallback) (void);\ntypedef void (*MonoFtnPtrEHCallback) (guint32 gchandle);\n\nstatic jmp_buf test_jmp_buf;\nstatic guint32 test_gchandle;\n\ntypedef long long MonoObject;\ntypedef MonoObject MonoException;\ntypedef int32_t mono_bool;\n\nstatic int sym_inited = 0;\nstatic void (*sym_mono_install_ftnptr_eh_callback) (MonoFtnPtrEHCallback);\nstatic MonoObject* (*sym_mono_gchandle_get_target) (guint32 gchandle);\nstatic guint32 (*sym_mono_gchandle_new) (MonoObject *, mono_bool pinned);\nstatic void (*sym_mono_gchandle_free) (guint32 gchandle);\nstatic void (*sym_mono_raise_exception) (MonoException *ex);\nstatic void (*sym_mono_domain_unload) (gpointer);\nstatic void (*sym_mono_threads_exit_gc_safe_region_unbalanced) (gpointer, gpointer *);\nstatic void (*null_function_ptr) (void);\n\nstatic void\nmono_test_init_symbols (void)\n{\n\tif (sym_inited)\n\t\treturn;\n\n\tsym_mono_install_ftnptr_eh_callback = (void (*) (MonoFtnPtrEHCallback)) (lookup_mono_symbol (\"mono_install_ftnptr_eh_callback\"));\n\n\tsym_mono_gchandle_get_target = (MonoObject* (*) (guint32 gchandle)) (lookup_mono_symbol (\"mono_gchandle_get_target\"));\n\n\tsym_mono_gchandle_new = (guint32 (*) (MonoObject *, mono_bool)) (lookup_mono_symbol (\"mono_gchandle_new\"));\n\n\tsym_mono_gchandle_free = (void (*) (guint32 gchandle)) (lookup_mono_symbol (\"mono_gchandle_free\"));\n\n\tsym_mono_raise_exception = (void (*) (MonoException *)) (lookup_mono_symbol (\"mono_raise_exception\"));\n\n\tsym_mono_domain_unload = (void (*) (gpointer)) (lookup_mono_symbol (\"mono_domain_unload\"));\n\n\tsym_mono_threads_exit_gc_safe_region_unbalanced = (void (*) (gpointer, gpointer *)) (lookup_mono_symbol (\"mono_threads_exit_gc_safe_region_unbalanced\"));\n\n\tsym_inited = 1;\n}\n\n\nstatic void\nmono_test_longjmp_callback (guint32 gchandle)\n{\n\ttest_gchandle = gchandle;\n\tlongjmp (test_jmp_buf, 1);\n}\n\nLIBTEST_API void STDCALL\nmono_test_setjmp_and_call (VoidVoidCallback managedCallback, intptr_t *out_handle)\n{\n\tmono_test_init_symbols ();\n\tif (setjmp (test_jmp_buf) == 0) {\n\t\t*out_handle = 0;\n\t\tsym_mono_install_ftnptr_eh_callback (mono_test_longjmp_callback);\n\t\tmanagedCallback ();\n\t\t*out_handle = 0; /* Do not expect to return here */\n\t} else {\n\t\tsym_mono_install_ftnptr_eh_callback (NULL);\n\t\t*out_handle = test_gchandle;\n\t}\n}\n\nLIBTEST_API void STDCALL\nmono_test_marshal_bstr (void *ptr)\n{\n}\n\nstatic void (*mono_test_capture_throw_callback) (guint32 gchandle, guint32 *exception_out);\n\nstatic void\nmono_test_ftnptr_eh_callback (guint32 gchandle)\n{\n\tguint32 exception_handle = 0;\n\n\tg_assert (gchandle != 0);\n\tMonoObject *exc = sym_mono_gchandle_get_target (gchandle);\n\tsym_mono_gchandle_free (gchandle);\n\n\tguint32 handle = sym_mono_gchandle_new (exc, FALSE);\n\tmono_test_capture_throw_callback (handle, &exception_handle);\n\tsym_mono_gchandle_free (handle);\n\n\tg_assert (exception_handle != 0);\n\texc = sym_mono_gchandle_get_target (exception_handle);\n\tsym_mono_gchandle_free (exception_handle);\n\n\tsym_mono_raise_exception (exc);\n\tg_error (\"mono_raise_exception should not return\");\n}\n\nLIBTEST_API void STDCALL\nmono_test_setup_ftnptr_eh_callback (VoidVoidCallback managed_entry, void (*capture_throw_callback) (guint32, guint32 *))\n{\n\tmono_test_init_symbols ();\n\tmono_test_capture_throw_callback = capture_throw_callback;\n\tsym_mono_install_ftnptr_eh_callback (mono_test_ftnptr_eh_callback);\n\tmanaged_entry ();\n}\n\nLIBTEST_API void STDCALL\nmono_test_cleanup_ftptr_eh_callback (void)\n{\n\tmono_test_init_symbols ();\n\tsym_mono_install_ftnptr_eh_callback (NULL);\n}\n\nLIBTEST_API int STDCALL\nmono_test_cominterop_ccw_queryinterface (MonoComObject *pUnk)\n{\n\tvoid *pp;\n\tint hr = pUnk->vtbl->QueryInterface (pUnk, &IID_INotImplemented, &pp);\n\n\t// Return true if we can't get INotImplemented\n\treturn pUnk == NULL && hr == S_OK;\n}\n\ntypedef struct ccw_qi_shared_data {\n\tMonoComObject *pUnk;\n\tint i;\n} ccw_qi_shared_data;\n\nstatic void*\nccw_qi_foreign_thread (void *arg)\n{\n\tccw_qi_shared_data *shared = (ccw_qi_shared_data *)arg;\n\tvoid *pp;\n\tMonoComObject *pUnk = shared->pUnk;\n\tint hr = pUnk->vtbl->QueryInterface (pUnk, &IID_ITest, &pp);\n\n\tshared->i = (hr == S_OK) ? 0 : 43;\n\treturn NULL;\n}\n\nLIBTEST_API int STDCALL\nmono_test_cominterop_ccw_queryinterface_foreign_thread (MonoComObject *pUnk)\n{\n#ifdef WIN32\n\treturn 0;\n#else\n\tpthread_t t;\n\tccw_qi_shared_data *shared = (ccw_qi_shared_data *)malloc (sizeof (ccw_qi_shared_data));\n\tif (!shared)\n\t\tabort ();\n\tshared->pUnk = pUnk;\n\tshared->i = 1;\n\tint res = pthread_create (&t, NULL, ccw_qi_foreign_thread, (void*)shared);\n\tg_assert (res == 0);\n\tpthread_join (t, NULL);\n\tint result = shared->i;\n\tfree (shared);\n\treturn result;\n#endif\n}\n\nstatic void*\nccw_itest_foreign_thread (void *arg)\n{\n\tccw_qi_shared_data *shared = (ccw_qi_shared_data *)arg;\n\tMonoComObject *pUnk = shared->pUnk;\n\tint hr = pUnk->vtbl->SByteIn (pUnk, -100);\n\tshared->i = (hr == S_OK) ? 0 : 12;\n\treturn NULL;\n}\n\nLIBTEST_API int STDCALL\nmono_test_cominterop_ccw_itest_foreign_thread (MonoComObject *pUnk)\n{\n#ifdef WIN32\n\treturn 0;\n#else\n\tpthread_t t;\n\tccw_qi_shared_data *shared = (ccw_qi_shared_data *)malloc (sizeof (ccw_qi_shared_data));\n\tif (!shared)\n\t\tabort ();\n\tshared->pUnk = pUnk;\n\tshared->i = 1;\n\tint res = pthread_create (&t, NULL, ccw_itest_foreign_thread, (void*)shared);\n\tg_assert (res == 0);\n\tpthread_join (t, NULL);\n\tint result = shared->i;\n\tfree (shared);\n\treturn result;\n#endif\n}\n\n\nLIBTEST_API void STDCALL\nmono_test_MerpCrashSnprintf (void)\n{\n\tfprintf (stderr, \"Before overwrite\\n\");\n\n\tchar buff [1] = { '\\0' };\n\tchar overflow [1] = { 'a' }; // Not null-terminated\n\tg_snprintf (buff, sizeof(buff) * 10, \"THISSHOULDOVERRUNTERRIBLY%s\", overflow);\n\tg_snprintf ((char *) GINT_TO_POINTER(-1), sizeof(buff) * 10, \"THISSHOULDOVERRUNTERRIBLY%s\", overflow);\n}\n\nLIBTEST_API void STDCALL\nmono_test_MerpCrashDladdr (void)\n{\n#ifndef HOST_WIN32\n\tdlopen (GINT_TO_POINTER(-1), -1);\n#endif\n}\n\nLIBTEST_API void STDCALL\nmono_test_MerpCrashMalloc (void)\n{\n\tgpointer x = g_malloc (sizeof(gpointer));\n\tg_free (x);\n\n\t// Double free\n\tg_free (x);\n}\n\nLIBTEST_API void STDCALL\nmono_test_MerpCrashNullFp (void)\n{\n\tnull_function_ptr ();\n}\n\nLIBTEST_API void STDCALL\nmono_test_MerpCrashDomainUnload (void)\n{\n\tmono_test_init_symbols ();\n\tsym_mono_domain_unload (GINT_TO_POINTER (-1));\n}\n\nLIBTEST_API void STDCALL\nmono_test_MerpCrashUnbalancedGCSafe (void)\n{\n\tmono_test_init_symbols ();\n\tgpointer foo = GINT_TO_POINTER (-1);\n\tgpointer bar = GINT_TO_POINTER (-2);\n\tsym_mono_threads_exit_gc_safe_region_unbalanced (foo, &bar);\n}\n\nLIBTEST_API void STDCALL\nmono_test_MerpCrashUnhandledExceptionHook (void)\n{\n\tg_assert_not_reached ();\n}\n\n#ifdef __cplusplus\n} // extern C\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mono/mini/method-to-ir.c": "/**\n * \\file\n * Convert CIL to the JIT internal representation\n *\n * Author:\n *   Paolo Molaro (lupus@ximian.com)\n *   Dietmar Maurer (dietmar@ximian.com)\n *\n * (C) 2002 Ximian, Inc.\n * Copyright 2003-2010 Novell, Inc (http://www.novell.com)\n * Copyright 2011 Xamarin, Inc (http://www.xamarin.com)\n * Licensed under the MIT license. See LICENSE file in the project root for full license information.\n */\n\n#include <config.h>\n#include <glib.h>\n#include <mono/utils/mono-compiler.h>\n#include \"mini.h\"\n\n#ifndef DISABLE_JIT\n\n#include <signal.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include <math.h>\n#include <string.h>\n#include <ctype.h>\n\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n\n#ifdef HAVE_ALLOCA_H\n#include <alloca.h>\n#endif\n\n#include <mono/utils/memcheck.h>\n#include <mono/metadata/abi-details.h>\n#include <mono/metadata/assembly.h>\n#include <mono/metadata/attrdefs.h>\n#include <mono/metadata/loader.h>\n#include <mono/metadata/tabledefs.h>\n#include <mono/metadata/class.h>\n#include <mono/metadata/class-abi-details.h>\n#include <mono/metadata/object.h>\n#include <mono/metadata/exception.h>\n#include <mono/metadata/exception-internals.h>\n#include <mono/metadata/opcodes.h>\n#include <mono/metadata/mono-endian.h>\n#include <mono/metadata/tokentype.h>\n#include <mono/metadata/tabledefs.h>\n#include <mono/metadata/marshal.h>\n#include <mono/metadata/debug-helpers.h>\n#include <mono/metadata/debug-internals.h>\n#include <mono/metadata/gc-internals.h>\n#include <mono/metadata/security-manager.h>\n#include <mono/metadata/threads-types.h>\n#include <mono/metadata/security-core-clr.h>\n#include <mono/metadata/profiler-private.h>\n#include <mono/metadata/profiler.h>\n#include <mono/metadata/monitor.h>\n#include <mono/utils/mono-memory-model.h>\n#include <mono/utils/mono-error-internals.h>\n#include <mono/metadata/mono-basic-block.h>\n#include <mono/metadata/reflection-internals.h>\n#include <mono/utils/mono-threads-coop.h>\n#include <mono/utils/mono-utils-debug.h>\n#include <mono/utils/mono-logger-internals.h>\n#include <mono/metadata/verify-internals.h>\n#include <mono/metadata/icall-decl.h>\n#include \"mono/metadata/icall-signatures.h\"\n\n#include \"trace.h\"\n\n#include \"ir-emit.h\"\n\n#include \"jit-icalls.h\"\n#include \"jit.h\"\n#include \"debugger-agent.h\"\n#include \"seq-points.h\"\n#include \"aot-compiler.h\"\n#include \"mini-llvm.h\"\n#include \"mini-runtime.h\"\n#include \"llvmonly-runtime.h\"\n\n#define BRANCH_COST 10\n#define CALL_COST 10\n/* Used for the JIT */\n#define INLINE_LENGTH_LIMIT 20\n/*\n * The aot and jit inline limits should be different,\n * since aot sees the whole program so we can let opt inline methods for us,\n * while the jit only sees one method, so we have to inline things ourselves.\n */\n/* Used by LLVM AOT */\n#define LLVM_AOT_INLINE_LENGTH_LIMIT 30\n/* Used to LLVM JIT */\n#define LLVM_JIT_INLINE_LENGTH_LIMIT 100\n\nstatic const gboolean debug_tailcall = FALSE;               // logging\nstatic const gboolean debug_tailcall_try_all = FALSE;       // consider any call followed by ret\n\ngboolean\nmono_tailcall_print_enabled (void)\n{\n\treturn debug_tailcall || MONO_TRACE_IS_TRACED (G_LOG_LEVEL_DEBUG, MONO_TRACE_TAILCALL);\n}\n\nvoid\nmono_tailcall_print (const char *format, ...)\n{\n\tif (!mono_tailcall_print_enabled ())\n\t\treturn;\n\tva_list args;\n\tva_start (args, format);\n\tg_printv (format, args);\n\tva_end (args);\n}\n\n/* These have 'cfg' as an implicit argument */\n#define INLINE_FAILURE(msg) do {\t\t\t\t\t\t\t\t\t\\\n\tif ((cfg->method != cfg->current_method) && (cfg->current_method->wrapper_type == MONO_WRAPPER_NONE)) { \\\n\t\tinline_failure (cfg, msg);\t\t\t\t\t\t\t\t\t\t\\\n\t\tgoto exception_exit;\t\t\t\t\t\t\t\t\t\t\t\\\n\t} \\\n\t} while (0)\n#define CHECK_CFG_EXCEPTION do {\\\n\t\tif (cfg->exception_type != MONO_EXCEPTION_NONE)\t\\\n\t\t\tgoto exception_exit;\t\t\t\t\t\t\\\n\t} while (0)\n#define FIELD_ACCESS_FAILURE(method, field) do {\t\t\t\t\t\\\n\t\tfield_access_failure ((cfg), (method), (field));\t\t\t\\\n\t\tgoto exception_exit;\t\\\n\t} while (0)\n#define GENERIC_SHARING_FAILURE(opcode) do {\t\t\\\n\t\tif (cfg->gshared) {\t\t\t\t\t\t\t\t\t\\\n\t\t\tgshared_failure (cfg, opcode, __FILE__, __LINE__);\t\\\n\t\t\tgoto exception_exit;\t\\\n\t\t}\t\t\t\\\n\t} while (0)\n#define GSHAREDVT_FAILURE(opcode) do {\t\t\\\n\tif (cfg->gsharedvt) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tgsharedvt_failure (cfg, opcode, __FILE__, __LINE__);\t\t\t\\\n\t\tgoto exception_exit;\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n#define OUT_OF_MEMORY_FAILURE do {\t\\\n\t\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_MONO_ERROR);\t\t\\\n\t\tmono_error_set_out_of_memory (cfg->error, \"\");\t\t\t\t\t\\\n\t\tgoto exception_exit;\t\\\n\t} while (0)\n#define DISABLE_AOT(cfg) do { \\\n\t\tif ((cfg)->verbose_level >= 2)\t\t\t\t\t\t  \\\n\t\t\tprintf (\"AOT disabled: %s:%d\\n\", __FILE__, __LINE__);\t\\\n\t\t(cfg)->disable_aot = TRUE;\t\t\t\t\t\t\t  \\\n\t} while (0)\n#define LOAD_ERROR do { \\\n\t\tbreak_on_unverified ();\t\t\t\t\t\t\t\t\\\n\t\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_TYPE_LOAD); \\\n\t\tgoto exception_exit;\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define TYPE_LOAD_ERROR(klass) do { \\\n\t\tcfg->exception_ptr = klass; \\\n\t\tLOAD_ERROR;\t\t\t\t\t\\\n\t} while (0)\n\n#define CHECK_CFG_ERROR do {\\\n\t\tif (!is_ok (cfg->error)) { \\\n\t\t\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_MONO_ERROR);\t\\\n\t\t\tgoto mono_error_exit; \\\n\t\t} \\\n\t} while (0)\n\nstatic int stind_to_store_membase (int opcode);\n\nint mono_op_to_op_imm (int opcode);\nint mono_op_to_op_imm_noemul (int opcode);\n\nstatic int inline_method (MonoCompile *cfg, MonoMethod *cmethod, MonoMethodSignature *fsig, MonoInst **sp,\n\t\t\t\t\t\t  guchar *ip, guint real_offset, gboolean inline_always);\nstatic MonoInst*\nconvert_value (MonoCompile *cfg, MonoType *type, MonoInst *ins);\n\n/* helper methods signatures */\n\n/* type loading helpers */\nstatic GENERATE_TRY_GET_CLASS_WITH_CACHE (debuggable_attribute, \"System.Diagnostics\", \"DebuggableAttribute\")\nstatic GENERATE_GET_CLASS_WITH_CACHE (iequatable, \"System\", \"IEquatable`1\")\nstatic GENERATE_GET_CLASS_WITH_CACHE (geqcomparer, \"System.Collections.Generic\", \"GenericEqualityComparer`1\");\n\n/*\n * Instruction metadata\n */\n#ifdef MINI_OP\n#undef MINI_OP\n#endif\n#ifdef MINI_OP3\n#undef MINI_OP3\n#endif\n#define MINI_OP(a,b,dest,src1,src2) dest, src1, src2, ' ',\n#define MINI_OP3(a,b,dest,src1,src2,src3) dest, src1, src2, src3,\n#define NONE ' '\n#define IREG 'i'\n#define FREG 'f'\n#define VREG 'v'\n#define XREG 'x'\n#if SIZEOF_REGISTER == 8 && SIZEOF_REGISTER == TARGET_SIZEOF_VOID_P\n#define LREG IREG\n#else\n#define LREG 'l'\n#endif\n/* keep in sync with the enum in mini.h */\nconst char\nmini_ins_info[] = {\n#include \"mini-ops.h\"\n};\n#undef MINI_OP\n#undef MINI_OP3\n\n#define MINI_OP(a,b,dest,src1,src2) ((src2) != NONE ? 2 : ((src1) != NONE ? 1 : 0)),\n#define MINI_OP3(a,b,dest,src1,src2,src3) ((src3) != NONE ? 3 : ((src2) != NONE ? 2 : ((src1) != NONE ? 1 : 0))),\n/* \n * This should contain the index of the last sreg + 1. This is not the same\n * as the number of sregs for opcodes like IA64_CMP_EQ_IMM.\n */\nconst gint8 mini_ins_sreg_counts[] = {\n#include \"mini-ops.h\"\n};\n#undef MINI_OP\n#undef MINI_OP3\n\nguint32\nmono_alloc_ireg (MonoCompile *cfg)\n{\n\treturn alloc_ireg (cfg);\n}\n\nguint32\nmono_alloc_lreg (MonoCompile *cfg)\n{\n\treturn alloc_lreg (cfg);\n}\n\nguint32\nmono_alloc_freg (MonoCompile *cfg)\n{\n\treturn alloc_freg (cfg);\n}\n\nguint32\nmono_alloc_preg (MonoCompile *cfg)\n{\n\treturn alloc_preg (cfg);\n}\n\nguint32\nmono_alloc_dreg (MonoCompile *cfg, MonoStackType stack_type)\n{\n\treturn alloc_dreg (cfg, stack_type);\n}\n\n/*\n * mono_alloc_ireg_ref:\n *\n *   Allocate an IREG, and mark it as holding a GC ref.\n */\nguint32\nmono_alloc_ireg_ref (MonoCompile *cfg)\n{\n\treturn alloc_ireg_ref (cfg);\n}\n\n/*\n * mono_alloc_ireg_mp:\n *\n *   Allocate an IREG, and mark it as holding a managed pointer.\n */\nguint32\nmono_alloc_ireg_mp (MonoCompile *cfg)\n{\n\treturn alloc_ireg_mp (cfg);\n}\n\n/*\n * mono_alloc_ireg_copy:\n *\n *   Allocate an IREG with the same GC type as VREG.\n */\nguint32\nmono_alloc_ireg_copy (MonoCompile *cfg, guint32 vreg)\n{\n\tif (vreg_is_ref (cfg, vreg))\n\t\treturn alloc_ireg_ref (cfg);\n\telse if (vreg_is_mp (cfg, vreg))\n\t\treturn alloc_ireg_mp (cfg);\n\telse\n\t\treturn alloc_ireg (cfg);\n}\n\nguint\nmono_type_to_regmove (MonoCompile *cfg, MonoType *type)\n{\n\tif (type->byref)\n\t\treturn OP_MOVE;\n\n\ttype = mini_get_underlying_type (type);\nhandle_enum:\n\tswitch (type->type) {\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\t\treturn OP_MOVE;\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\t\treturn OP_MOVE;\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\t\treturn OP_MOVE;\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_FNPTR:\n\t\treturn OP_MOVE;\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_SZARRAY:\n\tcase MONO_TYPE_ARRAY:    \n\t\treturn OP_MOVE;\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n#if SIZEOF_REGISTER == 8\n\t\treturn OP_MOVE;\n#else\n\t\treturn OP_LMOVE;\n#endif\n\tcase MONO_TYPE_R4:\n\t\treturn cfg->r4fp ? OP_RMOVE : OP_FMOVE;\n\tcase MONO_TYPE_R8:\n\t\treturn OP_FMOVE;\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (m_class_is_enumtype (type->data.klass)) {\n\t\t\ttype = mono_class_enum_basetype_internal (type->data.klass);\n\t\t\tgoto handle_enum;\n\t\t}\n\t\tif (MONO_CLASS_IS_SIMD (cfg, mono_class_from_mono_type_internal (type)))\n\t\t\treturn OP_XMOVE;\n\t\treturn OP_VMOVE;\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\treturn OP_VMOVE;\n\tcase MONO_TYPE_GENERICINST:\n\t\tif (MONO_CLASS_IS_SIMD (cfg, mono_class_from_mono_type_internal (type)))\n\t\t\treturn OP_XMOVE;\n\t\ttype = m_class_get_byval_arg (type->data.generic_class->container_class);\n\t\tgoto handle_enum;\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\tg_assert (cfg->gshared);\n\t\tif (mini_type_var_is_vt (type))\n\t\t\treturn OP_VMOVE;\n\t\telse\n\t\t\treturn mono_type_to_regmove (cfg, mini_get_underlying_type (type));\n\tdefault:\n\t\tg_error (\"unknown type 0x%02x in type_to_regstore\", type->type);\n\t}\n\treturn -1;\n}\n\nvoid\nmono_print_bb (MonoBasicBlock *bb, const char *msg)\n{\n\tint i;\n\tMonoInst *tree;\n\tGString *str = g_string_new (\"\");\n\n\tg_string_append_printf (str, \"%s %d: [IN: \", msg, bb->block_num);\n\tfor (i = 0; i < bb->in_count; ++i)\n\t\tg_string_append_printf (str, \" BB%d(%d)\", bb->in_bb [i]->block_num, bb->in_bb [i]->dfn);\n\tg_string_append_printf (str, \", OUT: \");\n\tfor (i = 0; i < bb->out_count; ++i)\n\t\tg_string_append_printf (str, \" BB%d(%d)\", bb->out_bb [i]->block_num, bb->out_bb [i]->dfn);\n\tg_string_append_printf (str, \" ]\\n\");\n\n\tg_print (\"%s\", str->str);\n\tg_string_free (str, TRUE);\n\n\tfor (tree = bb->code; tree; tree = tree->next)\n\t\tmono_print_ins_index (-1, tree);\n}\n\nstatic MONO_NEVER_INLINE gboolean\nbreak_on_unverified (void)\n{\n\tif (mini_debug_options.break_on_unverified) {\n\t\tG_BREAKPOINT ();\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic void\nclear_cfg_error (MonoCompile *cfg)\n{\n\tmono_error_cleanup (cfg->error);\n\terror_init (cfg->error);\n}\n\nstatic MONO_NEVER_INLINE void\nfield_access_failure (MonoCompile *cfg, MonoMethod *method, MonoClassField *field)\n{\n\tchar *method_fname = mono_method_full_name (method, TRUE);\n\tchar *field_fname = mono_field_full_name (field);\n\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_MONO_ERROR);\n\tmono_error_set_generic_error (cfg->error, \"System\", \"FieldAccessException\", \"Field `%s' is inaccessible from method `%s'\\n\", field_fname, method_fname);\n\tg_free (method_fname);\n\tg_free (field_fname);\n}\n\nstatic MONO_NEVER_INLINE void\ninline_failure (MonoCompile *cfg, const char *msg)\n{\n\tif (cfg->verbose_level >= 2)\n\t\tprintf (\"inline failed: %s\\n\", msg);\n\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_INLINE_FAILED);\n}\n\nstatic MONO_NEVER_INLINE void\ngshared_failure (MonoCompile *cfg, int opcode, const char *file, int line)\n{\n\tif (cfg->verbose_level > 2)\n\t\tprintf (\"sharing failed for method %s.%s.%s/%d opcode %s line %d\\n\", m_class_get_name_space (cfg->current_method->klass), m_class_get_name (cfg->current_method->klass), cfg->current_method->name, cfg->current_method->signature->param_count, mono_opcode_name (opcode), line);\n\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_GENERIC_SHARING_FAILED);\n}\n\nstatic MONO_NEVER_INLINE void\ngsharedvt_failure (MonoCompile *cfg, int opcode, const char *file, int line)\n{\n\tcfg->exception_message = g_strdup_printf (\"gsharedvt failed for method %s.%s.%s/%d opcode %s %s:%d\", m_class_get_name_space (cfg->current_method->klass), m_class_get_name (cfg->current_method->klass), cfg->current_method->name, cfg->current_method->signature->param_count, mono_opcode_name ((opcode)), file, line);\n\tif (cfg->verbose_level >= 2)\n\t\tprintf (\"%s\\n\", cfg->exception_message);\n\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_GENERIC_SHARING_FAILED);\n}\n\nvoid\nmini_set_inline_failure (MonoCompile *cfg, const char *msg)\n{\n\tif (cfg->verbose_level >= 2)\n\t\tprintf (\"inline failed: %s\\n\", msg);\n\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_INLINE_FAILED);\n}\n\n/*\n * When using gsharedvt, some instatiations might be verifiable, and some might be not. i.e. \n * foo<T> (int i) { ldarg.0; box T; }\n */\n#define UNVERIFIED do { \\\n\tif (cfg->gsharedvt) { \\\n\t\tif (cfg->verbose_level > 2)\t\t\t\t\t\t\t\t\t\\\n\t\t\tprintf (\"gsharedvt method failed to verify, falling back to instantiation.\\n\"); \\\n\t\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_GENERIC_SHARING_FAILED); \\\n\t\tgoto exception_exit;\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbreak_on_unverified ();\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tgoto unverified;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define GET_BBLOCK(cfg,tblock,ip) do {\t\\\n\t\t(tblock) = cfg->cil_offset_to_bb [(ip) - cfg->cil_start]; \\\n\t\tif (!(tblock)) {\t\\\n\t\t\tif ((ip) >= end || (ip) < header->code) UNVERIFIED; \\\n\t\t\tNEW_BBLOCK (cfg, (tblock)); \\\n\t\t\t(tblock)->cil_code = (ip);\t\\\n\t\t\tADD_BBLOCK (cfg, (tblock));\t\\\n\t\t} \\\n\t} while (0)\n\n/* Emit conversions so both operands of a binary opcode are of the same type */\nstatic void\nadd_widen_op (MonoCompile *cfg, MonoInst *ins, MonoInst **arg1_ref, MonoInst **arg2_ref)\n{\n\tMonoInst *arg1 = *arg1_ref;\n\tMonoInst *arg2 = *arg2_ref;\n\n\tif (cfg->r4fp &&\n\t\t((arg1->type == STACK_R4 && arg2->type == STACK_R8) ||\n\t\t (arg1->type == STACK_R8 && arg2->type == STACK_R4))) {\n\t\tMonoInst *conv;\n\n\t\t/* Mixing r4/r8 is allowed by the spec */\n\t\tif (arg1->type == STACK_R4) {\n\t\t\tint dreg = alloc_freg (cfg);\n\n\t\t\tEMIT_NEW_UNALU (cfg, conv, OP_RCONV_TO_R8, dreg, arg1->dreg);\n\t\t\tconv->type = STACK_R8;\n\t\t\tins->sreg1 = dreg;\n\t\t\t*arg1_ref = conv;\n\t\t}\n\t\tif (arg2->type == STACK_R4) {\n\t\t\tint dreg = alloc_freg (cfg);\n\n\t\t\tEMIT_NEW_UNALU (cfg, conv, OP_RCONV_TO_R8, dreg, arg2->dreg);\n\t\t\tconv->type = STACK_R8;\n\t\t\tins->sreg2 = dreg;\n\t\t\t*arg2_ref = conv;\n\t\t}\n\t}\n\n#if SIZEOF_REGISTER == 8\n\t/* FIXME: Need to add many more cases */\n\tif ((arg1)->type == STACK_PTR && (arg2)->type == STACK_I4) {\n\t\tMonoInst *widen;\n\n\t\tint dr = alloc_preg (cfg);\n\t\tEMIT_NEW_UNALU (cfg, widen, OP_SEXT_I4, dr, (arg2)->dreg);\n\t\t(ins)->sreg2 = widen->dreg;\n\t}\n#endif\n}\n\n#define ADD_BINOP(op) do {\t\\\n\t\tMONO_INST_NEW (cfg, ins, (op));\t\\\n\t\tsp -= 2;\t\\\n\t\tins->sreg1 = sp [0]->dreg;\t\\\n\t\tins->sreg2 = sp [1]->dreg;\t\\\n\t\ttype_from_op (cfg, ins, sp [0], sp [1]);\t\\\n\t\tCHECK_TYPE (ins);\t\\\n\t\t/* Have to insert a widening op */\t\t \\\n        add_widen_op (cfg, ins, &sp [0], &sp [1]);\t\t \\\n        ins->dreg = alloc_dreg ((cfg), (MonoStackType)(ins)->type); \\\n        MONO_ADD_INS ((cfg)->cbb, (ins)); \\\n        *sp++ = mono_decompose_opcode ((cfg), (ins));\t\\\n\t} while (0)\n\n#define ADD_UNOP(op) do {\t\\\n\t\tMONO_INST_NEW (cfg, ins, (op));\t\\\n\t\tsp--;\t\\\n\t\tins->sreg1 = sp [0]->dreg;\t\\\n\t\ttype_from_op (cfg, ins, sp [0], NULL);\t\\\n\t\tCHECK_TYPE (ins);\t\\\n        (ins)->dreg = alloc_dreg ((cfg), (MonoStackType)(ins)->type); \\\n        MONO_ADD_INS ((cfg)->cbb, (ins)); \\\n\t\t*sp++ = mono_decompose_opcode (cfg, ins);\t\\\n\t} while (0)\n\n#define ADD_BINCOND(next_block) do {\t\\\n\t\tMonoInst *cmp;\t\\\n\t\tsp -= 2; \\\n\t\tMONO_INST_NEW(cfg, cmp, OP_COMPARE);\t\\\n\t\tcmp->sreg1 = sp [0]->dreg;\t\\\n\t\tcmp->sreg2 = sp [1]->dreg;\t\\\n\t\tadd_widen_op (cfg, cmp, &sp [0], &sp [1]);\t\t\t\t\t\t\\\n\t\ttype_from_op (cfg, cmp, sp [0], sp [1]);\t\\\n\t\tCHECK_TYPE (cmp);\t\\\n\t\ttype_from_op (cfg, ins, sp [0], sp [1]);\t\t\t\t\t\t\t\\\n\t\tins->inst_many_bb = (MonoBasicBlock **)mono_mempool_alloc (cfg->mempool, sizeof(gpointer)*2);\t\\\n\t\tGET_BBLOCK (cfg, tblock, target);\t\t\\\n\t\tlink_bblock (cfg, cfg->cbb, tblock);\t\\\n\t\tins->inst_true_bb = tblock;\t\\\n\t\tif ((next_block)) {\t\\\n\t\t\tlink_bblock (cfg, cfg->cbb, (next_block));\t\\\n\t\t\tins->inst_false_bb = (next_block);\t\\\n\t\t\tstart_new_bblock = 1;\t\\\n\t\t} else {\t\\\n\t\t\tGET_BBLOCK (cfg, tblock, next_ip);\t\\\n\t\t\tlink_bblock (cfg, cfg->cbb, tblock);\t\\\n\t\t\tins->inst_false_bb = tblock;\t\\\n\t\t\tstart_new_bblock = 2;\t\\\n\t\t}\t\\\n\t\tif (sp != stack_start) {\t\t\t\t\t\t\t\t\t\\\n\t\t    handle_stack_args (cfg, stack_start, sp - stack_start); \\\n\t\t\tCHECK_UNVERIFIABLE (cfg); \\\n\t\t} \\\n        MONO_ADD_INS (cfg->cbb, cmp); \\\n\t\tMONO_ADD_INS (cfg->cbb, ins);\t\\\n\t} while (0)\n\n/* *\n * link_bblock: Links two basic blocks\n *\n * links two basic blocks in the control flow graph, the 'from'\n * argument is the starting block and the 'to' argument is the block\n * the control flow ends to after 'from'.\n */\nstatic void\nlink_bblock (MonoCompile *cfg, MonoBasicBlock *from, MonoBasicBlock* to)\n{\n\tMonoBasicBlock **newa;\n\tint i, found;\n\n#if 0\n\tif (from->cil_code) {\n\t\tif (to->cil_code)\n\t\t\tprintf (\"edge from IL%04x to IL_%04x\\n\", from->cil_code - cfg->cil_code, to->cil_code - cfg->cil_code);\n\t\telse\n\t\t\tprintf (\"edge from IL%04x to exit\\n\", from->cil_code - cfg->cil_code);\n\t} else {\n\t\tif (to->cil_code)\n\t\t\tprintf (\"edge from entry to IL_%04x\\n\", to->cil_code - cfg->cil_code);\n\t\telse\n\t\t\tprintf (\"edge from entry to exit\\n\");\n\t}\n#endif\n\n\tfound = FALSE;\n\tfor (i = 0; i < from->out_count; ++i) {\n\t\tif (to == from->out_bb [i]) {\n\t\t\tfound = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tnewa = (MonoBasicBlock **)mono_mempool_alloc (cfg->mempool, sizeof (gpointer) * (from->out_count + 1));\n\t\tfor (i = 0; i < from->out_count; ++i) {\n\t\t\tnewa [i] = from->out_bb [i];\n\t\t}\n\t\tnewa [i] = to;\n\t\tfrom->out_count++;\n\t\tfrom->out_bb = newa;\n\t}\n\n\tfound = FALSE;\n\tfor (i = 0; i < to->in_count; ++i) {\n\t\tif (from == to->in_bb [i]) {\n\t\t\tfound = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tnewa = (MonoBasicBlock **)mono_mempool_alloc (cfg->mempool, sizeof (gpointer) * (to->in_count + 1));\n\t\tfor (i = 0; i < to->in_count; ++i) {\n\t\t\tnewa [i] = to->in_bb [i];\n\t\t}\n\t\tnewa [i] = from;\n\t\tto->in_count++;\n\t\tto->in_bb = newa;\n\t}\n}\n\nvoid\nmono_link_bblock (MonoCompile *cfg, MonoBasicBlock *from, MonoBasicBlock* to)\n{\n\tlink_bblock (cfg, from, to);\n}\n\nstatic void\nmono_create_spvar_for_region (MonoCompile *cfg, int region);\n\nstatic void\nmark_bb_in_region (MonoCompile *cfg, guint region, uint32_t start, uint32_t end)\n{\n\tMonoBasicBlock *bb = cfg->cil_offset_to_bb [start];\n\n\t//start must exist in cil_offset_to_bb as those are il offsets used by EH which should have GET_BBLOCK early.\n\tg_assert (bb);\n\n\tif (cfg->verbose_level > 1)\n\t\tg_print (\"FIRST BB for %d is BB_%d\\n\", start, bb->block_num);\n\tfor (; bb && bb->real_offset < end; bb = bb->next_bb) {\n\t\t//no one claimed this bb, take it.\n\t\tif (bb->region == -1) {\n\t\t\tbb->region = region;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//current region is an early handler, bail\n\t\tif ((bb->region & (0xf << 4)) != MONO_REGION_TRY) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t//current region is a try, only overwrite if new region is a handler\n\t\tif ((region & (0xf << 4)) != MONO_REGION_TRY) {\n\t\t\tbb->region = region;\n\t\t}\n\t}\n\n\tif (cfg->spvars)\n\t\tmono_create_spvar_for_region (cfg, region);\n}\n\nstatic void\ncompute_bb_regions (MonoCompile *cfg)\n{\n\tMonoBasicBlock *bb;\n\tMonoMethodHeader *header = cfg->header;\n\tint i;\n\n\tfor (bb = cfg->bb_entry; bb; bb = bb->next_bb)\n\t\tbb->region = -1;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tMonoExceptionClause *clause = &header->clauses [i];\n\n\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\tmark_bb_in_region (cfg, ((i + 1) << 8) | MONO_REGION_FILTER | clause->flags, clause->data.filter_offset, clause->handler_offset);\n\n\t\tguint handler_region;\n\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FINALLY)\n\t\t\thandler_region = ((i + 1) << 8) | MONO_REGION_FINALLY | clause->flags;\n\t\telse if (clause->flags == MONO_EXCEPTION_CLAUSE_FAULT)\n\t\t\thandler_region = ((i + 1) << 8) | MONO_REGION_FAULT | clause->flags;\n\t\telse\n\t\t\thandler_region = ((i + 1) << 8) | MONO_REGION_CATCH | clause->flags;\n\n\t\tmark_bb_in_region (cfg, handler_region, clause->handler_offset, clause->handler_offset + clause->handler_len);\n\t\tmark_bb_in_region (cfg, ((i + 1) << 8) | clause->flags, clause->try_offset, clause->try_offset + clause->try_len);\n\t}\n\n\tif (cfg->verbose_level > 2) {\n\t\tMonoBasicBlock *bb;\n\t\tfor (bb = cfg->bb_entry; bb; bb = bb->next_bb)\n\t\t\tg_print (\"REGION BB%d IL_%04x ID_%08X\\n\", bb->block_num, bb->real_offset, bb->region);\n\t}\n\n}\n\n\nstatic gboolean\nip_in_finally_clause (MonoCompile *cfg, int offset)\n{\n\tMonoMethodHeader *header = cfg->header;\n\tMonoExceptionClause *clause;\n\tint i;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\tif (clause->flags != MONO_EXCEPTION_CLAUSE_FINALLY && clause->flags != MONO_EXCEPTION_CLAUSE_FAULT)\n\t\t\tcontinue;\n\n\t\tif (MONO_OFFSET_IN_HANDLER (clause, offset))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\n/* Find clauses between ip and target, from inner to outer */\nstatic GList*\nmono_find_leave_clauses (MonoCompile *cfg, guchar *ip, guchar *target)\n{\n\tMonoMethodHeader *header = cfg->header;\n\tMonoExceptionClause *clause;\n\tint i;\n\tGList *res = NULL;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\tif (MONO_OFFSET_IN_CLAUSE (clause, (ip - header->code)) && \n\t\t    (!MONO_OFFSET_IN_CLAUSE (clause, (target - header->code)))) {\n\t\t\tMonoLeaveClause *leave = mono_mempool_alloc0 (cfg->mempool, sizeof (MonoLeaveClause));\n\t\t\tleave->index = i;\n\t\t\tleave->clause = clause;\n\n\t\t\tres = g_list_append_mempool (cfg->mempool, res, leave);\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic void\nmono_create_spvar_for_region (MonoCompile *cfg, int region)\n{\n\tMonoInst *var;\n\n\tvar = (MonoInst *)g_hash_table_lookup (cfg->spvars, GINT_TO_POINTER (region));\n\tif (var)\n\t\treturn;\n\n\tvar = mono_compile_create_var (cfg, mono_get_int_type (), OP_LOCAL);\n\t/* prevent it from being register allocated */\n\tvar->flags |= MONO_INST_VOLATILE;\n\n\tg_hash_table_insert (cfg->spvars, GINT_TO_POINTER (region), var);\n}\n\nMonoInst *\nmono_find_exvar_for_offset (MonoCompile *cfg, int offset)\n{\n\treturn (MonoInst *)g_hash_table_lookup (cfg->exvars, GINT_TO_POINTER (offset));\n}\n\nstatic MonoInst*\nmono_create_exvar_for_offset (MonoCompile *cfg, int offset)\n{\n\tMonoInst *var;\n\n\tvar = (MonoInst *)g_hash_table_lookup (cfg->exvars, GINT_TO_POINTER (offset));\n\tif (var)\n\t\treturn var;\n\n\tvar = mono_compile_create_var (cfg, mono_get_object_type (), OP_LOCAL);\n\t/* prevent it from being register allocated */\n\tvar->flags |= MONO_INST_VOLATILE;\n\n\tg_hash_table_insert (cfg->exvars, GINT_TO_POINTER (offset), var);\n\n\treturn var;\n}\n\n/*\n * Returns the type used in the eval stack when @type is loaded.\n * FIXME: return a MonoType/MonoClass for the byref and VALUETYPE cases.\n */\nvoid\nmini_type_to_eval_stack_type (MonoCompile *cfg, MonoType *type, MonoInst *inst)\n{\n\tMonoClass *klass;\n\n\ttype = mini_get_underlying_type (type);\n\tinst->klass = klass = mono_class_from_mono_type_internal (type);\n\tif (type->byref) {\n\t\tinst->type = STACK_MP;\n\t\treturn;\n\t}\n\nhandle_enum:\n\tswitch (type->type) {\n\tcase MONO_TYPE_VOID:\n\t\tinst->type = STACK_INV;\n\t\treturn;\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\t\tinst->type = STACK_I4;\n\t\treturn;\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_FNPTR:\n\t\tinst->type = STACK_PTR;\n\t\treturn;\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_SZARRAY:\n\tcase MONO_TYPE_ARRAY:    \n\t\tinst->type = STACK_OBJ;\n\t\treturn;\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\t\tinst->type = STACK_I8;\n\t\treturn;\n\tcase MONO_TYPE_R4:\n\t\tinst->type = cfg->r4_stack_type;\n\t\tbreak;\n\tcase MONO_TYPE_R8:\n\t\tinst->type = STACK_R8;\n\t\treturn;\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (m_class_is_enumtype (type->data.klass)) {\n\t\t\ttype = mono_class_enum_basetype_internal (type->data.klass);\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tinst->klass = klass;\n\t\t\tinst->type = STACK_VTYPE;\n\t\t\treturn;\n\t\t}\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\tinst->klass = mono_defaults.typed_reference_class;\n\t\tinst->type = STACK_VTYPE;\n\t\treturn;\n\tcase MONO_TYPE_GENERICINST:\n\t\ttype = m_class_get_byval_arg (type->data.generic_class->container_class);\n\t\tgoto handle_enum;\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\tg_assert (cfg->gshared);\n\t\tif (mini_is_gsharedvt_type (type)) {\n\t\t\tg_assert (cfg->gsharedvt);\n\t\t\tinst->type = STACK_VTYPE;\n\t\t} else {\n\t\t\tmini_type_to_eval_stack_type (cfg, mini_get_underlying_type (type), inst);\n\t\t}\n\t\treturn;\n\tdefault:\n\t\tg_error (\"unknown type 0x%02x in eval stack type\", type->type);\n\t}\n}\n\n/*\n * The following tables are used to quickly validate the IL code in type_from_op ().\n */\n#define IF_P8(v) (SIZEOF_VOID_P == 8 ? v : STACK_INV)\n#define IF_P8_I8 IF_P8(STACK_I8)\n#define IF_P8_PTR IF_P8(STACK_PTR)\n\nstatic const char\nbin_num_table [STACK_MAX] [STACK_MAX] = {\n\t{STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_I4,  IF_P8_I8,  STACK_PTR, STACK_INV, STACK_MP,  STACK_INV, STACK_INV},\n\t{STACK_INV, IF_P8_I8,  STACK_I8,  IF_P8_PTR, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_PTR, IF_P8_PTR, STACK_PTR, STACK_INV, STACK_MP,  STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_R8,  STACK_INV, STACK_INV, STACK_INV, STACK_R8},\n\t{STACK_INV, STACK_MP,  STACK_INV, STACK_MP,  STACK_INV, STACK_PTR, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_R8, STACK_INV, STACK_INV, STACK_INV, STACK_R4}\n};\n\nstatic const char \nneg_table [] = {\n\tSTACK_INV, STACK_I4, STACK_I8, STACK_PTR, STACK_R8, STACK_INV, STACK_INV, STACK_INV, STACK_R4\n};\n\n/* reduce the size of this table */\nstatic const char\nbin_int_table [STACK_MAX] [STACK_MAX] = {\n\t{STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_I4,  IF_P8_I8,  STACK_PTR, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, IF_P8_I8,  STACK_I8,  IF_P8_PTR, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_PTR, IF_P8_PTR, STACK_PTR, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV}\n};\n\n#define P1 (SIZEOF_VOID_P == 8)\nstatic const char\nbin_comp_table [STACK_MAX] [STACK_MAX] = {\n/*\tInv i  L  p  F  &  O  vt r4 */\n\t{0},\n\t{0, 1, 0, 1, 0, 0, 0, 0}, /* i, int32 */\n\t{0, 0, 1,P1, 0, 0, 0, 0}, /* L, int64 */\n\t{0, 1,P1, 1, 0, 2, 4, 0}, /* p, ptr */\n\t{0, 0, 0, 0, 1, 0, 0, 0, 1}, /* F, R8 */\n\t{0, 0, 0, 2, 0, 1, 0, 0}, /* &, managed pointer */\n\t{0, 0, 0, 4, 0, 0, 3, 0}, /* O, reference */\n\t{0, 0, 0, 0, 0, 0, 0, 0}, /* vt value type */\n\t{0, 0, 0, 0, 1, 0, 0, 0, 1}, /* r, r4 */\n};\n#undef P1\n\n/* reduce the size of this table */\nstatic const char\nshift_table [STACK_MAX] [STACK_MAX] = {\n\t{STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_I4,  STACK_INV, STACK_I4,  STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_I8,  STACK_INV, STACK_I8,  STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_PTR, STACK_INV, STACK_PTR, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV},\n\t{STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV, STACK_INV}\n};\n\n/*\n * Tables to map from the non-specific opcode to the matching\n * type-specific opcode.\n */\n/* handles from CEE_ADD to CEE_SHR_UN (CEE_REM_UN for floats) */\nstatic const guint16\nbinops_op_map [STACK_MAX] = {\n\t0, OP_IADD-CEE_ADD, OP_LADD-CEE_ADD, OP_PADD-CEE_ADD, OP_FADD-CEE_ADD, OP_PADD-CEE_ADD, 0, 0, OP_RADD-CEE_ADD\n};\n\n/* handles from CEE_NEG to CEE_CONV_U8 */\nstatic const guint16\nunops_op_map [STACK_MAX] = {\n\t0, OP_INEG-CEE_NEG, OP_LNEG-CEE_NEG, OP_PNEG-CEE_NEG, OP_FNEG-CEE_NEG, OP_PNEG-CEE_NEG, 0, 0, OP_RNEG-CEE_NEG\n};\n\n/* handles from CEE_CONV_U2 to CEE_SUB_OVF_UN */\nstatic const guint16\novfops_op_map [STACK_MAX] = {\n\t0, OP_ICONV_TO_U2-CEE_CONV_U2, OP_LCONV_TO_U2-CEE_CONV_U2, OP_PCONV_TO_U2-CEE_CONV_U2, OP_FCONV_TO_U2-CEE_CONV_U2, OP_PCONV_TO_U2-CEE_CONV_U2, OP_PCONV_TO_U2-CEE_CONV_U2, 0, OP_RCONV_TO_U2-CEE_CONV_U2\n};\n\n/* handles from CEE_CONV_OVF_I1_UN to CEE_CONV_OVF_U_UN */\nstatic const guint16\novf2ops_op_map [STACK_MAX] = {\n\t0, OP_ICONV_TO_OVF_I1_UN-CEE_CONV_OVF_I1_UN, OP_LCONV_TO_OVF_I1_UN-CEE_CONV_OVF_I1_UN, OP_PCONV_TO_OVF_I1_UN-CEE_CONV_OVF_I1_UN, OP_FCONV_TO_OVF_I1_UN-CEE_CONV_OVF_I1_UN, OP_PCONV_TO_OVF_I1_UN-CEE_CONV_OVF_I1_UN, 0, 0, OP_RCONV_TO_OVF_I1_UN-CEE_CONV_OVF_I1_UN\n};\n\n/* handles from CEE_CONV_OVF_I1 to CEE_CONV_OVF_U8 */\nstatic const guint16\novf3ops_op_map [STACK_MAX] = {\n\t0, OP_ICONV_TO_OVF_I1-CEE_CONV_OVF_I1, OP_LCONV_TO_OVF_I1-CEE_CONV_OVF_I1, OP_PCONV_TO_OVF_I1-CEE_CONV_OVF_I1, OP_FCONV_TO_OVF_I1-CEE_CONV_OVF_I1, OP_PCONV_TO_OVF_I1-CEE_CONV_OVF_I1, 0, 0, OP_RCONV_TO_OVF_I1-CEE_CONV_OVF_I1\n};\n\n/* handles from CEE_BEQ to CEE_BLT_UN */\nstatic const guint16\nbeqops_op_map [STACK_MAX] = {\n\t0, OP_IBEQ-CEE_BEQ, OP_LBEQ-CEE_BEQ, OP_PBEQ-CEE_BEQ, OP_FBEQ-CEE_BEQ, OP_PBEQ-CEE_BEQ, OP_PBEQ-CEE_BEQ, 0, OP_FBEQ-CEE_BEQ\n};\n\n/* handles from CEE_CEQ to CEE_CLT_UN */\nstatic const guint16\nceqops_op_map [STACK_MAX] = {\n\t0, OP_ICEQ-OP_CEQ, OP_LCEQ-OP_CEQ, OP_PCEQ-OP_CEQ, OP_FCEQ-OP_CEQ, OP_PCEQ-OP_CEQ, OP_PCEQ-OP_CEQ, 0, OP_RCEQ-OP_CEQ\n};\n\n/*\n * Sets ins->type (the type on the eval stack) according to the\n * type of the opcode and the arguments to it.\n * Invalid IL code is marked by setting ins->type to the invalid value STACK_INV.\n *\n * FIXME: this function sets ins->type unconditionally in some cases, but\n * it should set it to invalid for some types (a conv.x on an object)\n */\nstatic void\ntype_from_op (MonoCompile *cfg, MonoInst *ins, MonoInst *src1, MonoInst *src2)\n{\n\tswitch (ins->opcode) {\n\t/* binops */\n\tcase MONO_CEE_ADD:\n\tcase MONO_CEE_SUB:\n\tcase MONO_CEE_MUL:\n\tcase MONO_CEE_DIV:\n\tcase MONO_CEE_REM:\n\t\t/* FIXME: check unverifiable args for STACK_MP */\n\t\tins->type = bin_num_table [src1->type] [src2->type];\n\t\tins->opcode += binops_op_map [ins->type];\n\t\tbreak;\n\tcase MONO_CEE_DIV_UN:\n\tcase MONO_CEE_REM_UN:\n\tcase MONO_CEE_AND:\n\tcase MONO_CEE_OR:\n\tcase MONO_CEE_XOR:\n\t\tins->type = bin_int_table [src1->type] [src2->type];\n\t\tins->opcode += binops_op_map [ins->type];\n\t\tbreak;\n\tcase MONO_CEE_SHL:\n\tcase MONO_CEE_SHR:\n\tcase MONO_CEE_SHR_UN:\n\t\tins->type = shift_table [src1->type] [src2->type];\n\t\tins->opcode += binops_op_map [ins->type];\n\t\tbreak;\n\tcase OP_COMPARE:\n\tcase OP_LCOMPARE:\n\tcase OP_ICOMPARE:\n\t\tins->type = bin_comp_table [src1->type] [src2->type] ? STACK_I4: STACK_INV;\n\t\tif ((src1->type == STACK_I8) || ((TARGET_SIZEOF_VOID_P == 8) && ((src1->type == STACK_PTR) || (src1->type == STACK_OBJ) || (src1->type == STACK_MP))))\n\t\t\tins->opcode = OP_LCOMPARE;\n\t\telse if (src1->type == STACK_R4)\n\t\t\tins->opcode = OP_RCOMPARE;\n\t\telse if (src1->type == STACK_R8)\n\t\t\tins->opcode = OP_FCOMPARE;\n\t\telse\n\t\t\tins->opcode = OP_ICOMPARE;\n\t\tbreak;\n\tcase OP_ICOMPARE_IMM:\n\t\tins->type = bin_comp_table [src1->type] [src1->type] ? STACK_I4 : STACK_INV;\n\t\tif ((src1->type == STACK_I8) || ((TARGET_SIZEOF_VOID_P == 8) && ((src1->type == STACK_PTR) || (src1->type == STACK_OBJ) || (src1->type == STACK_MP))))\n\t\t\tins->opcode = OP_LCOMPARE_IMM;\t\t\n\t\tbreak;\n\tcase MONO_CEE_BEQ:\n\tcase MONO_CEE_BGE:\n\tcase MONO_CEE_BGT:\n\tcase MONO_CEE_BLE:\n\tcase MONO_CEE_BLT:\n\tcase MONO_CEE_BNE_UN:\n\tcase MONO_CEE_BGE_UN:\n\tcase MONO_CEE_BGT_UN:\n\tcase MONO_CEE_BLE_UN:\n\tcase MONO_CEE_BLT_UN:\n\t\tins->opcode += beqops_op_map [src1->type];\n\t\tbreak;\n\tcase OP_CEQ:\n\t\tins->type = bin_comp_table [src1->type] [src2->type] ? STACK_I4: STACK_INV;\n\t\tins->opcode += ceqops_op_map [src1->type];\n\t\tbreak;\n\tcase OP_CGT:\n\tcase OP_CGT_UN:\n\tcase OP_CLT:\n\tcase OP_CLT_UN:\n\t\tins->type = (bin_comp_table [src1->type] [src2->type] & 1) ? STACK_I4: STACK_INV;\n\t\tins->opcode += ceqops_op_map [src1->type];\n\t\tbreak;\n\t/* unops */\n\tcase MONO_CEE_NEG:\n\t\tins->type = neg_table [src1->type];\n\t\tins->opcode += unops_op_map [ins->type];\n\t\tbreak;\n\tcase MONO_CEE_NOT:\n\t\tif (src1->type >= STACK_I4 && src1->type <= STACK_PTR)\n\t\t\tins->type = src1->type;\n\t\telse\n\t\t\tins->type = STACK_INV;\n\t\tins->opcode += unops_op_map [ins->type];\n\t\tbreak;\n\tcase MONO_CEE_CONV_I1:\n\tcase MONO_CEE_CONV_I2:\n\tcase MONO_CEE_CONV_I4:\n\tcase MONO_CEE_CONV_U4:\n\t\tins->type = STACK_I4;\n\t\tins->opcode += unops_op_map [src1->type];\n\t\tbreak;\n\tcase MONO_CEE_CONV_R_UN:\n\t\tins->type = STACK_R8;\n\t\tswitch (src1->type) {\n\t\tcase STACK_I4:\n\t\tcase STACK_PTR:\n\t\t\tins->opcode = OP_ICONV_TO_R_UN;\n\t\t\tbreak;\n\t\tcase STACK_I8:\n\t\t\tins->opcode = OP_LCONV_TO_R_UN; \n\t\t\tbreak;\n\t\tcase STACK_R8:\n\t\t\tins->opcode = OP_FMOVE;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MONO_CEE_CONV_OVF_I1:\n\tcase MONO_CEE_CONV_OVF_U1:\n\tcase MONO_CEE_CONV_OVF_I2:\n\tcase MONO_CEE_CONV_OVF_U2:\n\tcase MONO_CEE_CONV_OVF_I4:\n\tcase MONO_CEE_CONV_OVF_U4:\n\t\tins->type = STACK_I4;\n\t\tins->opcode += ovf3ops_op_map [src1->type];\n\t\tbreak;\n\tcase MONO_CEE_CONV_OVF_I_UN:\n\tcase MONO_CEE_CONV_OVF_U_UN:\n\t\tins->type = STACK_PTR;\n\t\tins->opcode += ovf2ops_op_map [src1->type];\n\t\tbreak;\n\tcase MONO_CEE_CONV_OVF_I1_UN:\n\tcase MONO_CEE_CONV_OVF_I2_UN:\n\tcase MONO_CEE_CONV_OVF_I4_UN:\n\tcase MONO_CEE_CONV_OVF_U1_UN:\n\tcase MONO_CEE_CONV_OVF_U2_UN:\n\tcase MONO_CEE_CONV_OVF_U4_UN:\n\t\tins->type = STACK_I4;\n\t\tins->opcode += ovf2ops_op_map [src1->type];\n\t\tbreak;\n\tcase MONO_CEE_CONV_U:\n\t\tins->type = STACK_PTR;\n\t\tswitch (src1->type) {\n\t\tcase STACK_I4:\n\t\t\tins->opcode = OP_ICONV_TO_U;\n\t\t\tbreak;\n\t\tcase STACK_PTR:\n\t\tcase STACK_MP:\n\t\tcase STACK_OBJ:\n#if TARGET_SIZEOF_VOID_P == 8\n\t\t\tins->opcode = OP_LCONV_TO_U;\n#else\n\t\t\tins->opcode = OP_MOVE;\n#endif\n\t\t\tbreak;\n\t\tcase STACK_I8:\n\t\t\tins->opcode = OP_LCONV_TO_U;\n\t\t\tbreak;\n\t\tcase STACK_R8:\n\t\t\tins->opcode = OP_FCONV_TO_U;\n\t\t\tbreak;\n\t\tcase STACK_R4:\n\t\t\tif (TARGET_SIZEOF_VOID_P == 8)\n\t\t\t\tins->opcode = OP_RCONV_TO_U8;\n\t\t\telse\n\t\t\t\tins->opcode = OP_RCONV_TO_U4;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MONO_CEE_CONV_I8:\n\tcase MONO_CEE_CONV_U8:\n\t\tins->type = STACK_I8;\n\t\tins->opcode += unops_op_map [src1->type];\n\t\tbreak;\n\tcase MONO_CEE_CONV_OVF_I8:\n\tcase MONO_CEE_CONV_OVF_U8:\n\t\tins->type = STACK_I8;\n\t\tins->opcode += ovf3ops_op_map [src1->type];\n\t\tbreak;\n\tcase MONO_CEE_CONV_OVF_U8_UN:\n\tcase MONO_CEE_CONV_OVF_I8_UN:\n\t\tins->type = STACK_I8;\n\t\tins->opcode += ovf2ops_op_map [src1->type];\n\t\tbreak;\n\tcase MONO_CEE_CONV_R4:\n\t\tins->type = cfg->r4_stack_type;\n\t\tins->opcode += unops_op_map [src1->type];\n\t\tbreak;\n\tcase MONO_CEE_CONV_R8:\n\t\tins->type = STACK_R8;\n\t\tins->opcode += unops_op_map [src1->type];\n\t\tbreak;\n\tcase OP_CKFINITE:\n\t\tins->type = STACK_R8;\t\t\n\t\tbreak;\n\tcase MONO_CEE_CONV_U2:\n\tcase MONO_CEE_CONV_U1:\n\t\tins->type = STACK_I4;\n\t\tins->opcode += ovfops_op_map [src1->type];\n\t\tbreak;\n\tcase MONO_CEE_CONV_I:\n\tcase MONO_CEE_CONV_OVF_I:\n\tcase MONO_CEE_CONV_OVF_U:\n\t\tins->type = STACK_PTR;\n\t\tins->opcode += ovfops_op_map [src1->type];\n\t\tbreak;\n\tcase MONO_CEE_ADD_OVF:\n\tcase MONO_CEE_ADD_OVF_UN:\n\tcase MONO_CEE_MUL_OVF:\n\tcase MONO_CEE_MUL_OVF_UN:\n\tcase MONO_CEE_SUB_OVF:\n\tcase MONO_CEE_SUB_OVF_UN:\n\t\tins->type = bin_num_table [src1->type] [src2->type];\n\t\tins->opcode += ovfops_op_map [src1->type];\n\t\tif (ins->type == STACK_R8)\n\t\t\tins->type = STACK_INV;\n\t\tbreak;\n\tcase OP_LOAD_MEMBASE:\n\t\tins->type = STACK_PTR;\n\t\tbreak;\n\tcase OP_LOADI1_MEMBASE:\n\tcase OP_LOADU1_MEMBASE:\n\tcase OP_LOADI2_MEMBASE:\n\tcase OP_LOADU2_MEMBASE:\n\tcase OP_LOADI4_MEMBASE:\n\tcase OP_LOADU4_MEMBASE:\n\t\tins->type = STACK_PTR;\n\t\tbreak;\n\tcase OP_LOADI8_MEMBASE:\n\t\tins->type = STACK_I8;\n\t\tbreak;\n\tcase OP_LOADR4_MEMBASE:\n\t\tins->type = cfg->r4_stack_type;\n\t\tbreak;\n\tcase OP_LOADR8_MEMBASE:\n\t\tins->type = STACK_R8;\n\t\tbreak;\n\tdefault:\n\t\tg_error (\"opcode 0x%04x not handled in type from op\", ins->opcode);\n\t\tbreak;\n\t}\n\n\tif (ins->type == STACK_MP) {\n\t\tif (src1->type == STACK_MP)\n\t\t\tins->klass = src1->klass;\n\t\telse\n\t\t\tins->klass = mono_defaults.object_class;\n\t}\n}\n\nvoid\nmini_type_from_op (MonoCompile *cfg, MonoInst *ins, MonoInst *src1, MonoInst *src2)\n{\n\ttype_from_op (cfg, ins, src1, src2);\n}\n\nstatic MonoClass*\nldind_to_type (int op)\n{\n\tswitch (op) {\n\tcase MONO_CEE_LDIND_I1: return mono_defaults.sbyte_class;\n\tcase MONO_CEE_LDIND_U1: return mono_defaults.byte_class;\n\tcase MONO_CEE_LDIND_I2: return mono_defaults.int16_class;\n\tcase MONO_CEE_LDIND_U2: return mono_defaults.uint16_class;\n\tcase MONO_CEE_LDIND_I4: return mono_defaults.int32_class;\n\tcase MONO_CEE_LDIND_U4: return mono_defaults.uint32_class;\n\tcase MONO_CEE_LDIND_I8: return mono_defaults.int64_class;\n\tcase MONO_CEE_LDIND_I: return mono_defaults.int_class;\n\tcase MONO_CEE_LDIND_R4: return mono_defaults.single_class;\n\tcase MONO_CEE_LDIND_R8: return mono_defaults.double_class;\n\tcase MONO_CEE_LDIND_REF:return mono_defaults.object_class; //FIXME we should try to return a more specific type\n\tdefault: g_error (\"Unknown ldind type %d\", op);\n\t}\n}\n\n#if 0\n\nstatic const char\nparam_table [STACK_MAX] [STACK_MAX] = {\n\t{0},\n};\n\nstatic int\ncheck_values_to_signature (MonoInst *args, MonoType *this_ins, MonoMethodSignature *sig)\n{\n\tint i;\n\n\tif (sig->hasthis) {\n\t\tswitch (args->type) {\n\t\tcase STACK_I4:\n\t\tcase STACK_I8:\n\t\tcase STACK_R8:\n\t\tcase STACK_VTYPE:\n\t\tcase STACK_INV:\n\t\t\treturn 0;\n\t\t}\n\t\targs++;\n\t}\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tswitch (args [i].type) {\n\t\tcase STACK_INV:\n\t\t\treturn 0;\n\t\tcase STACK_MP:\n\t\t\tif (!sig->params [i]->byref)\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\tcase STACK_OBJ:\n\t\t\tif (sig->params [i]->byref)\n\t\t\t\treturn 0;\n\t\t\tswitch (sig->params [i]->type) {\n\t\t\tcase MONO_TYPE_CLASS:\n\t\t\tcase MONO_TYPE_STRING:\n\t\t\tcase MONO_TYPE_OBJECT:\n\t\t\tcase MONO_TYPE_SZARRAY:\n\t\t\tcase MONO_TYPE_ARRAY:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase STACK_R8:\n\t\t\tif (sig->params [i]->byref)\n\t\t\t\treturn 0;\n\t\t\tif (sig->params [i]->type != MONO_TYPE_R4 && sig->params [i]->type != MONO_TYPE_R8)\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\tcase STACK_PTR:\n\t\tcase STACK_I4:\n\t\tcase STACK_I8:\n\t\tcase STACK_VTYPE:\n\t\t\tbreak;\n\t\t}\n\t\t/*if (!param_table [args [i].type] [sig->params [i]->type])\n\t\t\treturn 0;*/\n\t}\n\treturn 1;\n}\n#endif\n\n/*\n * When we need a pointer to the current domain many times in a method, we\n * call mono_domain_get() once and we store the result in a local variable.\n * This function returns the variable that represents the MonoDomain*.\n */\ninline static MonoInst *\nmono_get_domainvar (MonoCompile *cfg)\n{\n\tif (!cfg->domainvar) {\n\t\t/* Make sure we don't generate references after checking whenever to init this */\n\t\tg_assert (!cfg->domainvar_inited);\n\t\tcfg->domainvar = mono_compile_create_var (cfg, mono_get_int_type (), OP_LOCAL);\n\t\t/* Avoid optimizing it away */\n\t\tcfg->domainvar->flags |= MONO_INST_VOLATILE;\n\t}\n\treturn cfg->domainvar;\n}\n\n/*\n * The got_var contains the address of the Global Offset Table when AOT \n * compiling.\n */\nMonoInst *\nmono_get_got_var (MonoCompile *cfg)\n{\n\tif (!cfg->compile_aot || !cfg->backend->need_got_var || cfg->llvm_only)\n\t\treturn NULL;\n\tif (!cfg->got_var) {\n\t\tcfg->got_var = mono_compile_create_var (cfg, mono_get_int_type (), OP_LOCAL);\n\t}\n\treturn cfg->got_var;\n}\n\nstatic void\nmono_create_rgctx_var (MonoCompile *cfg)\n{\n\tif (!cfg->rgctx_var) {\n\t\tcfg->rgctx_var = mono_compile_create_var (cfg, mono_get_int_type (), OP_LOCAL);\n\t\t/* force the var to be stack allocated */\n\t\tcfg->rgctx_var->flags |= MONO_INST_VOLATILE;\n\t}\n}\n\nstatic MonoInst *\nmono_get_vtable_var (MonoCompile *cfg)\n{\n\tg_assert (cfg->gshared);\n\n\tmono_create_rgctx_var (cfg);\n\n\treturn cfg->rgctx_var;\n}\n\nstatic MonoType*\ntype_from_stack_type (MonoInst *ins) {\n\tswitch (ins->type) {\n\tcase STACK_I4: return mono_get_int32_type ();\n\tcase STACK_I8: return m_class_get_byval_arg (mono_defaults.int64_class);\n\tcase STACK_PTR: return mono_get_int_type ();\n\tcase STACK_R4: return m_class_get_byval_arg (mono_defaults.single_class);\n\tcase STACK_R8: return m_class_get_byval_arg (mono_defaults.double_class);\n\tcase STACK_MP:\n\t\treturn m_class_get_this_arg (ins->klass);\n\tcase STACK_OBJ: return mono_get_object_type ();\n\tcase STACK_VTYPE: return m_class_get_byval_arg (ins->klass);\n\tdefault:\n\t\tg_error (\"stack type %d to monotype not handled\\n\", ins->type);\n\t}\n\treturn NULL;\n}\n\nstatic G_GNUC_UNUSED int\ntype_to_stack_type (MonoCompile *cfg, MonoType *t)\n{\n\tt = mono_type_get_underlying_type (t);\n\tswitch (t->type) {\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\t\treturn STACK_I4;\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_FNPTR:\n\t\treturn STACK_PTR;\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_SZARRAY:\n\tcase MONO_TYPE_ARRAY:    \n\t\treturn STACK_OBJ;\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\t\treturn STACK_I8;\n\tcase MONO_TYPE_R4:\n\t\treturn cfg->r4_stack_type;\n\tcase MONO_TYPE_R8:\n\t\treturn STACK_R8;\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\treturn STACK_VTYPE;\n\tcase MONO_TYPE_GENERICINST:\n\t\tif (mono_type_generic_inst_is_valuetype (t))\n\t\t\treturn STACK_VTYPE;\n\t\telse\n\t\t\treturn STACK_OBJ;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\treturn -1;\n}\n\nstatic MonoClass*\narray_access_to_klass (int opcode)\n{\n\tswitch (opcode) {\n\tcase MONO_CEE_LDELEM_U1:\n\t\treturn mono_defaults.byte_class;\n\tcase MONO_CEE_LDELEM_U2:\n\t\treturn mono_defaults.uint16_class;\n\tcase MONO_CEE_LDELEM_I:\n\tcase MONO_CEE_STELEM_I:\n\t\treturn mono_defaults.int_class;\n\tcase MONO_CEE_LDELEM_I1:\n\tcase MONO_CEE_STELEM_I1:\n\t\treturn mono_defaults.sbyte_class;\n\tcase MONO_CEE_LDELEM_I2:\n\tcase MONO_CEE_STELEM_I2:\n\t\treturn mono_defaults.int16_class;\n\tcase MONO_CEE_LDELEM_I4:\n\tcase MONO_CEE_STELEM_I4:\n\t\treturn mono_defaults.int32_class;\n\tcase MONO_CEE_LDELEM_U4:\n\t\treturn mono_defaults.uint32_class;\n\tcase MONO_CEE_LDELEM_I8:\n\tcase MONO_CEE_STELEM_I8:\n\t\treturn mono_defaults.int64_class;\n\tcase MONO_CEE_LDELEM_R4:\n\tcase MONO_CEE_STELEM_R4:\n\t\treturn mono_defaults.single_class;\n\tcase MONO_CEE_LDELEM_R8:\n\tcase MONO_CEE_STELEM_R8:\n\t\treturn mono_defaults.double_class;\n\tcase MONO_CEE_LDELEM_REF:\n\tcase MONO_CEE_STELEM_REF:\n\t\treturn mono_defaults.object_class;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\treturn NULL;\n}\n\n/*\n * We try to share variables when possible\n */\nstatic MonoInst *\nmono_compile_get_interface_var (MonoCompile *cfg, int slot, MonoInst *ins)\n{\n\tMonoInst *res;\n\tint pos, vnum;\n\tMonoType *type;\n\n\ttype = type_from_stack_type (ins);\n\n\t/* inlining can result in deeper stacks */ \n\tif (cfg->inline_depth || slot >= cfg->header->max_stack)\n\t\treturn mono_compile_create_var (cfg, type, OP_LOCAL);\n\n\tpos = ins->type - 1 + slot * STACK_MAX;\n\n\tswitch (ins->type) {\n\tcase STACK_I4:\n\tcase STACK_I8:\n\tcase STACK_R8:\n\tcase STACK_PTR:\n\tcase STACK_MP:\n\tcase STACK_OBJ:\n\t\tif ((vnum = cfg->intvars [pos]))\n\t\t\treturn cfg->varinfo [vnum];\n\t\tres = mono_compile_create_var (cfg, type, OP_LOCAL);\n\t\tcfg->intvars [pos] = res->inst_c0;\n\t\tbreak;\n\tdefault:\n\t\tres = mono_compile_create_var (cfg, type, OP_LOCAL);\n\t}\n\treturn res;\n}\n\nstatic void\nmono_save_token_info (MonoCompile *cfg, MonoImage *image, guint32 token, gpointer key)\n{\n\t/* \n\t * Don't use this if a generic_context is set, since that means AOT can't\n\t * look up the method using just the image+token.\n\t * table == 0 means this is a reference made from a wrapper.\n\t */\n\tif (cfg->compile_aot && !cfg->generic_context && (mono_metadata_token_table (token) > 0)) {\n\t\tMonoJumpInfoToken *jump_info_token = (MonoJumpInfoToken *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoJumpInfoToken));\n\t\tjump_info_token->image = image;\n\t\tjump_info_token->token = token;\n\t\tg_hash_table_insert (cfg->token_info_hash, key, jump_info_token);\n\t}\n}\n\n/*\n * This function is called to handle items that are left on the evaluation stack\n * at basic block boundaries. What happens is that we save the values to local variables\n * and we reload them later when first entering the target basic block (with the\n * handle_loaded_temps () function).\n * A single joint point will use the same variables (stored in the array bb->out_stack or\n * bb->in_stack, if the basic block is before or after the joint point).\n *\n * This function needs to be called _before_ emitting the last instruction of\n * the bb (i.e. before emitting a branch).\n * If the stack merge fails at a join point, cfg->unverifiable is set.\n */\nstatic void\nhandle_stack_args (MonoCompile *cfg, MonoInst **sp, int count)\n{\n\tint i, bindex;\n\tMonoBasicBlock *bb = cfg->cbb;\n\tMonoBasicBlock *outb;\n\tMonoInst *inst, **locals;\n\tgboolean found;\n\n\tif (!count)\n\t\treturn;\n\tif (cfg->verbose_level > 3)\n\t\tprintf (\"%d item(s) on exit from B%d\\n\", count, bb->block_num);\n\tif (!bb->out_scount) {\n\t\tbb->out_scount = count;\n\t\t//printf (\"bblock %d has out:\", bb->block_num);\n\t\tfound = FALSE;\n\t\tfor (i = 0; i < bb->out_count; ++i) {\n\t\t\toutb = bb->out_bb [i];\n\t\t\t/* exception handlers are linked, but they should not be considered for stack args */\n\t\t\tif (outb->flags & BB_EXCEPTION_HANDLER)\n\t\t\t\tcontinue;\n\t\t\t//printf (\" %d\", outb->block_num);\n\t\t\tif (outb->in_stack) {\n\t\t\t\tfound = TRUE;\n\t\t\t\tbb->out_stack = outb->in_stack;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//printf (\"\\n\");\n\t\tif (!found) {\n\t\t\tbb->out_stack = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*) * count);\n\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\t/* \n\t\t\t\t * try to reuse temps already allocated for this purpouse, if they occupy the same\n\t\t\t\t * stack slot and if they are of the same type.\n\t\t\t\t * This won't cause conflicts since if 'local' is used to \n\t\t\t\t * store one of the values in the in_stack of a bblock, then\n\t\t\t\t * the same variable will be used for the same outgoing stack \n\t\t\t\t * slot as well. \n\t\t\t\t * This doesn't work when inlining methods, since the bblocks\n\t\t\t\t * in the inlined methods do not inherit their in_stack from\n\t\t\t\t * the bblock they are inlined to. See bug #58863 for an\n\t\t\t\t * example.\n\t\t\t\t */\n\t\t\t\tbb->out_stack [i] = mono_compile_get_interface_var (cfg, i, sp [i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < bb->out_count; ++i) {\n\t\toutb = bb->out_bb [i];\n\t\t/* exception handlers are linked, but they should not be considered for stack args */\n\t\tif (outb->flags & BB_EXCEPTION_HANDLER)\n\t\t\tcontinue;\n\t\tif (outb->in_scount) {\n\t\t\tif (outb->in_scount != bb->out_scount) {\n\t\t\t\tcfg->unverifiable = TRUE;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcontinue; /* check they are the same locals */\n\t\t}\n\t\toutb->in_scount = count;\n\t\toutb->in_stack = bb->out_stack;\n\t}\n\n\tlocals = bb->out_stack;\n\tcfg->cbb = bb;\n\tfor (i = 0; i < count; ++i) {\n\t\tsp [i] = convert_value (cfg, locals [i]->inst_vtype, sp [i]);\n\t\tEMIT_NEW_TEMPSTORE (cfg, inst, locals [i]->inst_c0, sp [i]);\n\t\tinst->cil_code = sp [i]->cil_code;\n\t\tsp [i] = locals [i];\n\t\tif (cfg->verbose_level > 3)\n\t\t\tprintf (\"storing %d to temp %d\\n\", i, (int)locals [i]->inst_c0);\n\t}\n\n\t/*\n\t * It is possible that the out bblocks already have in_stack assigned, and\n\t * the in_stacks differ. In this case, we will store to all the different \n\t * in_stacks.\n\t */\n\n\tfound = TRUE;\n\tbindex = 0;\n\twhile (found) {\n\t\t/* Find a bblock which has a different in_stack */\n\t\tfound = FALSE;\n\t\twhile (bindex < bb->out_count) {\n\t\t\toutb = bb->out_bb [bindex];\n\t\t\t/* exception handlers are linked, but they should not be considered for stack args */\n\t\t\tif (outb->flags & BB_EXCEPTION_HANDLER) {\n\t\t\t\tbindex++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (outb->in_stack != locals) {\n\t\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\t\tsp [i] = convert_value (cfg, outb->in_stack [i]->inst_vtype, sp [i]);\n\t\t\t\t\tEMIT_NEW_TEMPSTORE (cfg, inst, outb->in_stack [i]->inst_c0, sp [i]);\n\t\t\t\t\tinst->cil_code = sp [i]->cil_code;\n\t\t\t\t\tsp [i] = locals [i];\n\t\t\t\t\tif (cfg->verbose_level > 3)\n\t\t\t\t\t\tprintf (\"storing %d to temp %d\\n\", i, (int)outb->in_stack [i]->inst_c0);\n\t\t\t\t}\n\t\t\t\tlocals = outb->in_stack;\n\t\t\t\tfound = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbindex ++;\n\t\t}\n\t}\n}\n\nMonoInst*\nmini_emit_runtime_constant (MonoCompile *cfg, MonoJumpInfoType patch_type, gpointer data)\n{\n\tMonoInst *ins;\n\n\tif (cfg->compile_aot) {\nMONO_DISABLE_WARNING (4306) // 'type cast': conversion from 'MonoJumpInfoType' to 'MonoInst *' of greater size\n\t\tEMIT_NEW_AOTCONST (cfg, ins, patch_type, data);\nMONO_RESTORE_WARNING\n\t} else {\n\t\tMonoJumpInfo ji;\n\t\tgpointer target;\n\t\tERROR_DECL (error);\n\n\t\tji.type = patch_type;\n\t\tji.data.target = data;\n\t\ttarget = mono_resolve_patch_target (NULL, cfg->domain, NULL, &ji, FALSE, error);\n\t\tmono_error_assert_ok (error);\n\n\t\tEMIT_NEW_PCONST (cfg, ins, target);\n\t}\n\treturn ins;\n}\n\nstatic MonoInst*\nmono_create_fast_tls_getter (MonoCompile *cfg, MonoTlsKey key)\n{\n\tint tls_offset = mono_tls_get_tls_offset (key);\n\n\tif (cfg->compile_aot)\n\t\treturn NULL;\n\n\tif (tls_offset != -1 && mono_arch_have_fast_tls ()) {\n\t\tMonoInst *ins;\n\t\tMONO_INST_NEW (cfg, ins, OP_TLS_GET);\n\t\tins->dreg = mono_alloc_preg (cfg);\n\t\tins->inst_offset = tls_offset;\n\t\treturn ins;\n\t}\n\treturn NULL;\n}\n\nstatic MonoInst*\nmono_create_tls_get (MonoCompile *cfg, MonoTlsKey key)\n{\n\tMonoInst *fast_tls = NULL;\n\n\tif (!mini_debug_options.use_fallback_tls)\n\t\tfast_tls = mono_create_fast_tls_getter (cfg, key);\n\n\tif (fast_tls) {\n\t\tMONO_ADD_INS (cfg->cbb, fast_tls);\n\t\treturn fast_tls;\n\t}\n\n\tconst MonoJitICallId jit_icall_id = mono_get_tls_key_to_jit_icall_id (key);\n\n\tif (cfg->compile_aot) {\n\t\tMonoInst *addr;\n\t\t/*\n\t\t * tls getters are critical pieces of code and we don't want to resolve them\n\t\t * through the standard plt/tramp mechanism since we might expose ourselves\n\t\t * to crashes and infinite recursions.\n\t\t * Therefore the NOCALL part of MONO_PATCH_INFO_JIT_ICALL_ADDR_NOCALL, FALSE in is_plt_patch.\n\t\t */\n\t\tEMIT_NEW_AOTCONST (cfg, addr, MONO_PATCH_INFO_JIT_ICALL_ADDR_NOCALL, GUINT_TO_POINTER (jit_icall_id));\n\t\treturn mini_emit_calli (cfg, mono_icall_sig_ptr, NULL, addr, NULL, NULL);\n\t} else {\n\t\treturn mono_emit_jit_icall_id (cfg, jit_icall_id, NULL);\n\t}\n}\n\n/*\n * emit_push_lmf:\n *\n *   Emit IR to push the current LMF onto the LMF stack.\n */\nstatic void\nemit_push_lmf (MonoCompile *cfg)\n{\n\t/*\n\t * Emit IR to push the LMF:\n\t * lmf_addr = <lmf_addr from tls>\n\t * lmf->lmf_addr = lmf_addr\n\t * lmf->prev_lmf = *lmf_addr\n\t * *lmf_addr = lmf\n\t */\n\tMonoInst *ins, *lmf_ins;\n\n\tif (!cfg->lmf_ir)\n\t\treturn;\n\n\tint lmf_reg, prev_lmf_reg;\n\t/*\n\t * Store lmf_addr in a variable, so it can be allocated to a global register.\n\t */\n\tif (!cfg->lmf_addr_var)\n\t\tcfg->lmf_addr_var = mono_compile_create_var (cfg, mono_get_int_type (), OP_LOCAL);\n\n\tlmf_ins = mono_create_tls_get (cfg, TLS_KEY_LMF_ADDR);\n\tg_assert (lmf_ins);\n\n\tlmf_ins->dreg = cfg->lmf_addr_var->dreg;\n\n\tEMIT_NEW_VARLOADA (cfg, ins, cfg->lmf_var, NULL);\n\tlmf_reg = ins->dreg;\n\n\tprev_lmf_reg = alloc_preg (cfg);\n\t/* Save previous_lmf */\n\tEMIT_NEW_LOAD_MEMBASE (cfg, ins, OP_LOAD_MEMBASE, prev_lmf_reg, cfg->lmf_addr_var->dreg, 0);\n\tEMIT_NEW_STORE_MEMBASE (cfg, ins, OP_STORE_MEMBASE_REG, lmf_reg, MONO_STRUCT_OFFSET (MonoLMF, previous_lmf), prev_lmf_reg);\n\t/* Set new lmf */\n\tEMIT_NEW_STORE_MEMBASE (cfg, ins, OP_STORE_MEMBASE_REG, cfg->lmf_addr_var->dreg, 0, lmf_reg);\n}\n\n/*\n * emit_pop_lmf:\n *\n *   Emit IR to pop the current LMF from the LMF stack.\n */\nstatic void\nemit_pop_lmf (MonoCompile *cfg)\n{\n\tint lmf_reg, lmf_addr_reg;\n\tMonoInst *ins;\n\n\tif (!cfg->lmf_ir)\n\t\treturn;\n\n \tEMIT_NEW_VARLOADA (cfg, ins, cfg->lmf_var, NULL);\n \tlmf_reg = ins->dreg;\n\n\tint prev_lmf_reg;\n\t/*\n\t * Emit IR to pop the LMF:\n\t * *(lmf->lmf_addr) = lmf->prev_lmf\n\t */\n\t/* This could be called before emit_push_lmf () */\n\tif (!cfg->lmf_addr_var)\n\t\tcfg->lmf_addr_var = mono_compile_create_var (cfg, mono_get_int_type (), OP_LOCAL);\n\tlmf_addr_reg = cfg->lmf_addr_var->dreg;\n\n\tprev_lmf_reg = alloc_preg (cfg);\n\tEMIT_NEW_LOAD_MEMBASE (cfg, ins, OP_LOAD_MEMBASE, prev_lmf_reg, lmf_reg, MONO_STRUCT_OFFSET (MonoLMF, previous_lmf));\n\tEMIT_NEW_STORE_MEMBASE (cfg, ins, OP_STORE_MEMBASE_REG, lmf_addr_reg, 0, prev_lmf_reg);\n}\n\n/*\n * target_type_is_incompatible:\n * @cfg: MonoCompile context\n *\n * Check that the item @arg on the evaluation stack can be stored\n * in the target type (can be a local, or field, etc).\n * The cfg arg can be used to check if we need verification or just\n * validity checks.\n *\n * Returns: non-0 value if arg can't be stored on a target.\n */\nstatic int\ntarget_type_is_incompatible (MonoCompile *cfg, MonoType *target, MonoInst *arg)\n{\n\tMonoType *simple_type;\n\tMonoClass *klass;\n\n\tif (target->byref) {\n\t\t/* FIXME: check that the pointed to types match */\n\t\tif (arg->type == STACK_MP) {\n\t\t\t/* This is needed to handle gshared types + ldaddr. We lower the types so we can handle enums and other typedef-like types. */\n\t\t\tMonoClass *target_class_lowered = mono_class_from_mono_type_internal (mini_get_underlying_type (m_class_get_byval_arg (mono_class_from_mono_type_internal (target))));\n\t\t\tMonoClass *source_class_lowered = mono_class_from_mono_type_internal (mini_get_underlying_type (m_class_get_byval_arg (arg->klass)));\n\n\t\t\t/* if the target is native int& or X* or same type */\n\t\t\tif (target->type == MONO_TYPE_I || target->type == MONO_TYPE_PTR || target_class_lowered == source_class_lowered)\n\t\t\t\treturn 0;\n\n\t\t\t/* Both are primitive type byrefs and the source points to a larger type that the destination */\n\t\t\tif (MONO_TYPE_IS_PRIMITIVE_SCALAR (m_class_get_byval_arg (target_class_lowered)) && MONO_TYPE_IS_PRIMITIVE_SCALAR (m_class_get_byval_arg (source_class_lowered)) &&\n\t\t\t\tmono_class_instance_size (target_class_lowered) <= mono_class_instance_size (source_class_lowered))\n\t\t\t\treturn 0;\n\t\t\treturn 1;\n\t\t}\n\t\tif (arg->type == STACK_PTR)\n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\n\tsimple_type = mini_get_underlying_type (target);\n\tswitch (simple_type->type) {\n\tcase MONO_TYPE_VOID:\n\t\treturn 1;\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\t\tif (arg->type != STACK_I4 && arg->type != STACK_PTR)\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase MONO_TYPE_PTR:\n\t\t/* STACK_MP is needed when setting pinned locals */\n\t\tif (arg->type != STACK_I4 && arg->type != STACK_PTR && arg->type != STACK_MP)\n#if SIZEOF_VOID_P == 8\n\t\t\tif (arg->type != STACK_I8)\n#endif\n\t\t\t\treturn 1;\n\t\treturn 0;\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_FNPTR:\n\t\t/* \n\t\t * Some opcodes like ldloca returns 'transient pointers' which can be stored in\n\t\t * in native int. (#688008).\n\t\t */\n\t\tif (arg->type != STACK_I4 && arg->type != STACK_PTR && arg->type != STACK_MP)\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_SZARRAY:\n\tcase MONO_TYPE_ARRAY:    \n\t\tif (arg->type != STACK_OBJ)\n\t\t\treturn 1;\n\t\t/* FIXME: check type compatibility */\n\t\treturn 0;\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\t\tif (arg->type != STACK_I8)\n#if SIZEOF_VOID_P == 8\n\t\t\tif (arg->type != STACK_PTR)\n#endif\n\t\t\t\treturn 1;\n\t\treturn 0;\n\tcase MONO_TYPE_R4:\n\t\tif (arg->type != cfg->r4_stack_type)\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase MONO_TYPE_R8:\n\t\tif (arg->type != STACK_R8)\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (arg->type != STACK_VTYPE)\n\t\t\treturn 1;\n\t\tklass = mono_class_from_mono_type_internal (simple_type);\n\t\tif (klass != arg->klass)\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\tif (arg->type != STACK_VTYPE)\n\t\t\treturn 1;\n\t\tklass = mono_class_from_mono_type_internal (simple_type);\n\t\tif (klass != arg->klass)\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase MONO_TYPE_GENERICINST:\n\t\tif (mono_type_generic_inst_is_valuetype (simple_type)) {\n\t\t\tMonoClass *target_class;\n\t\t\tif (arg->type != STACK_VTYPE)\n\t\t\t\treturn 1;\n\t\t\tklass = mono_class_from_mono_type_internal (simple_type);\n\t\t\ttarget_class = mono_class_from_mono_type_internal (target);\n\t\t\t/* The second cases is needed when doing partial sharing */\n\t\t\tif (klass != arg->klass && target_class != arg->klass && target_class != mono_class_from_mono_type_internal (mini_get_underlying_type (m_class_get_byval_arg (arg->klass))))\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (arg->type != STACK_OBJ)\n\t\t\t\treturn 1;\n\t\t\t/* FIXME: check type compatibility */\n\t\t\treturn 0;\n\t\t}\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\tg_assert (cfg->gshared);\n\t\tif (mini_type_var_is_vt (simple_type)) {\n\t\t\tif (arg->type != STACK_VTYPE)\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (arg->type != STACK_OBJ)\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\tg_error (\"unknown type 0x%02x in target_type_is_incompatible\", simple_type->type);\n\t}\n\treturn 1;\n}\n\n/*\n * convert_value:\n *\n *   Emit some implicit conversions which are not part of the .net spec, but are allowed by MS.NET.\n */\nstatic MonoInst*\nconvert_value (MonoCompile *cfg, MonoType *type, MonoInst *ins)\n{\n\tif (!cfg->r4fp)\n\t\treturn ins;\n\ttype = mini_get_underlying_type (type);\n\tswitch (type->type) {\n\tcase MONO_TYPE_R4:\n\t\tif (ins->type == STACK_R8) {\n\t\t\tint dreg = alloc_freg (cfg);\n\t\t\tMonoInst *conv;\n\t\t\tEMIT_NEW_UNALU (cfg, conv, OP_FCONV_TO_R4, dreg, ins->dreg);\n\t\t\tconv->type = STACK_R4;\n\t\t\treturn conv;\n\t\t}\n\t\tbreak;\n\tcase MONO_TYPE_R8:\n\t\tif (ins->type == STACK_R4) {\n\t\t\tint dreg = alloc_freg (cfg);\n\t\t\tMonoInst *conv;\n\t\t\tEMIT_NEW_UNALU (cfg, conv, OP_RCONV_TO_R8, dreg, ins->dreg);\n\t\t\tconv->type = STACK_R8;\n\t\t\treturn conv;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ins;\n}\n\n/*\n * Prepare arguments for passing to a function call.\n * Return a non-zero value if the arguments can't be passed to the given\n * signature.\n * The type checks are not yet complete and some conversions may need\n * casts on 32 or 64 bit architectures.\n *\n * FIXME: implement this using target_type_is_incompatible ()\n */\nstatic gboolean\ncheck_call_signature (MonoCompile *cfg, MonoMethodSignature *sig, MonoInst **args)\n{\n\tMonoType *simple_type;\n\tint i;\n\n\tif (sig->hasthis) {\n\t\tif (args [0]->type != STACK_OBJ && args [0]->type != STACK_MP && args [0]->type != STACK_PTR)\n\t\t\treturn TRUE;\n\t\targs++;\n\t}\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tif (sig->params [i]->byref) {\n\t\t\tif (args [i]->type != STACK_MP && args [i]->type != STACK_PTR)\n\t\t\t\treturn TRUE;\n\t\t\tcontinue;\n\t\t}\n\t\tsimple_type = mini_get_underlying_type (sig->params [i]);\nhandle_enum:\n\t\tswitch (simple_type->type) {\n\t\tcase MONO_TYPE_VOID:\n\t\t\treturn TRUE;\n\t\tcase MONO_TYPE_I1:\n\t\tcase MONO_TYPE_U1:\n\t\tcase MONO_TYPE_I2:\n\t\tcase MONO_TYPE_U2:\n\t\tcase MONO_TYPE_I4:\n\t\tcase MONO_TYPE_U4:\n\t\t\tif (args [i]->type != STACK_I4 && args [i]->type != STACK_PTR)\n\t\t\t\treturn TRUE;\n\t\t\tcontinue;\n\t\tcase MONO_TYPE_I:\n\t\tcase MONO_TYPE_U:\n\t\t\tif (args [i]->type != STACK_I4 && args [i]->type != STACK_PTR && args [i]->type != STACK_MP && args [i]->type != STACK_OBJ)\n\t\t\t\treturn TRUE;\n\t\t\tcontinue;\n\t\tcase MONO_TYPE_PTR:\n\t\tcase MONO_TYPE_FNPTR:\n\t\t\tif (args [i]->type != STACK_I4 && !(SIZEOF_VOID_P == 8 && args [i]->type == STACK_I8) &&\n\t\t\t\targs [i]->type != STACK_PTR && args [i]->type != STACK_MP && args [i]->type != STACK_OBJ)\n\t\t\t\treturn TRUE;\n\t\t\tcontinue;\n\t\tcase MONO_TYPE_CLASS:\n\t\tcase MONO_TYPE_STRING:\n\t\tcase MONO_TYPE_OBJECT:\n\t\tcase MONO_TYPE_SZARRAY:\n\t\tcase MONO_TYPE_ARRAY:    \n\t\t\tif (args [i]->type != STACK_OBJ)\n\t\t\t\treturn TRUE;\n\t\t\tcontinue;\n\t\tcase MONO_TYPE_I8:\n\t\tcase MONO_TYPE_U8:\n\t\t\tif (args [i]->type != STACK_I8 &&\n\t\t\t\t!(SIZEOF_VOID_P == 8 && (args [i]->type == STACK_I4 || args [i]->type == STACK_PTR)))\n\t\t\t\treturn TRUE;\n\t\t\tcontinue;\n\t\tcase MONO_TYPE_R4:\n\t\t\tif (args [i]->type != cfg->r4_stack_type)\n\t\t\t\treturn TRUE;\n\t\t\tcontinue;\n\t\tcase MONO_TYPE_R8:\n\t\t\tif (args [i]->type != STACK_R8)\n\t\t\t\treturn TRUE;\n\t\t\tcontinue;\n\t\tcase MONO_TYPE_VALUETYPE:\n\t\t\tif (m_class_is_enumtype (simple_type->data.klass)) {\n\t\t\t\tsimple_type = mono_class_enum_basetype_internal (simple_type->data.klass);\n\t\t\t\tgoto handle_enum;\n\t\t\t}\n\t\t\tif (args [i]->type != STACK_VTYPE)\n\t\t\t\treturn TRUE;\n\t\t\tcontinue;\n\t\tcase MONO_TYPE_TYPEDBYREF:\n\t\t\tif (args [i]->type != STACK_VTYPE)\n\t\t\t\treturn TRUE;\n\t\t\tcontinue;\n\t\tcase MONO_TYPE_GENERICINST:\n\t\t\tsimple_type = m_class_get_byval_arg (simple_type->data.generic_class->container_class);\n\t\t\tgoto handle_enum;\n\t\tcase MONO_TYPE_VAR:\n\t\tcase MONO_TYPE_MVAR:\n\t\t\t/* gsharedvt */\n\t\t\tif (args [i]->type != STACK_VTYPE)\n\t\t\t\treturn TRUE;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tg_error (\"unknown type 0x%02x in check_call_signature\",\n\t\t\t\t simple_type->type);\n\t\t}\n\t}\n\treturn FALSE;\n}\n\nMonoJumpInfo *\nmono_patch_info_new (MonoMemPool *mp, int ip, MonoJumpInfoType type, gconstpointer target)\n{\n\tMonoJumpInfo *ji = (MonoJumpInfo *)mono_mempool_alloc (mp, sizeof (MonoJumpInfo));\n\n\tji->ip.i = ip;\n\tji->type = type;\n\tji->data.target = target;\n\n\treturn ji;\n}\n\nint\nmini_class_check_context_used (MonoCompile *cfg, MonoClass *klass)\n{\n\tif (cfg->gshared)\n\t\treturn mono_class_check_context_used (klass);\n\telse\n\t\treturn 0;\n}\n\nint\nmini_method_check_context_used (MonoCompile *cfg, MonoMethod *method)\n{\n\tif (cfg->gshared)\n\t\treturn mono_method_check_context_used (method);\n\telse\n\t\treturn 0;\n}\n\n/*\n * check_method_sharing:\n *\n *   Check whenever the vtable or an mrgctx needs to be passed when calling CMETHOD.\n */\nstatic void\ncheck_method_sharing (MonoCompile *cfg, MonoMethod *cmethod, gboolean *out_pass_vtable, gboolean *out_pass_mrgctx)\n{\n\tgboolean pass_vtable = FALSE;\n\tgboolean pass_mrgctx = FALSE;\n\n\tif (((cmethod->flags & METHOD_ATTRIBUTE_STATIC) || m_class_is_valuetype (cmethod->klass)) &&\n\t\t(mono_class_is_ginst (cmethod->klass) || mono_class_is_gtd (cmethod->klass))) {\n\t\tgboolean sharable = FALSE;\n\n\t\tif (mono_method_is_generic_sharable_full (cmethod, TRUE, TRUE, TRUE))\n\t\t\tsharable = TRUE;\n\n\t\t/*\n\t\t * Pass vtable iff target method might\n\t\t * be shared, which means that sharing\n\t\t * is enabled for its class and its\n\t\t * context is sharable (and it's not a\n\t\t * generic method).\n\t\t */\n\t\tif (sharable && !(mini_method_get_context (cmethod) && mini_method_get_context (cmethod)->method_inst))\n\t\t\tpass_vtable = TRUE;\n\t}\n\n\tif (mini_method_needs_mrgctx (cmethod)) {\n\t\tif (mini_method_is_default_method (cmethod))\n\t\t\tpass_vtable = FALSE;\n\t\telse\n\t\t\tg_assert (!pass_vtable);\n\n\t\tif (mono_method_is_generic_sharable_full (cmethod, TRUE, TRUE, TRUE)) {\n\t\t\tpass_mrgctx = TRUE;\n\t\t} else {\n\t\t\tif (cfg->gsharedvt && mini_is_gsharedvt_signature (mono_method_signature_internal (cmethod)))\n\t\t\t\tpass_mrgctx = TRUE;\n\t\t}\n\t}\n\n\tif (out_pass_vtable)\n\t\t*out_pass_vtable = pass_vtable;\n\tif (out_pass_mrgctx)\n\t\t*out_pass_mrgctx = pass_mrgctx;\n}\n\nstatic gboolean\ndirect_icalls_enabled (MonoCompile *cfg, MonoMethod *method)\n{\n\tif (cfg->gen_sdb_seq_points || cfg->disable_direct_icalls)\n\t\treturn FALSE;\n\n\tif (method && mono_aot_direct_icalls_enabled_for_method (cfg, method))\n\t\treturn TRUE;\n\n\t/* LLVM on amd64 can't handle calls to non-32 bit addresses */\n#ifdef TARGET_AMD64\n\tif (cfg->compile_llvm && !cfg->llvm_only)\n\t\treturn FALSE;\n#endif\n\n\treturn FALSE;\n}\n\nMonoInst*\nmono_emit_jit_icall_by_info (MonoCompile *cfg, int il_offset, MonoJitICallInfo *info, MonoInst **args)\n{\n\t/*\n\t * Call the jit icall without a wrapper if possible.\n\t * The wrapper is needed to be able to do stack walks for asynchronously suspended\n\t * threads when debugging.\n\t */\n\tif (direct_icalls_enabled (cfg, NULL)) {\n\t\tint costs;\n\n\t\tif (!info->wrapper_method) {\n\t\t\tinfo->wrapper_method = mono_marshal_get_icall_wrapper (info, TRUE);\n\t\t\tmono_memory_barrier ();\n\t\t}\n\n\t\t/*\n\t\t * Inline the wrapper method, which is basically a call to the C icall, and\n\t\t * an exception check.\n\t\t */\n\t\tcosts = inline_method (cfg, info->wrapper_method, NULL,\n\t\t\t\t\t\t\t   args, NULL, il_offset, TRUE);\n\t\tg_assert (costs > 0);\n\t\tg_assert (!MONO_TYPE_IS_VOID (info->sig->ret));\n\n\t\treturn args [0];\n\t}\n\treturn mono_emit_jit_icall_id (cfg, mono_jit_icall_info_id (info), args);\n}\n \nstatic MonoInst*\nmono_emit_widen_call_res (MonoCompile *cfg, MonoInst *ins, MonoMethodSignature *fsig)\n{\n\tif (!MONO_TYPE_IS_VOID (fsig->ret)) {\n\t\tif ((fsig->pinvoke || LLVM_ENABLED) && !fsig->ret->byref) {\n\t\t\tint widen_op = -1;\n\n\t\t\t/* \n\t\t\t * Native code might return non register sized integers \n\t\t\t * without initializing the upper bits.\n\t\t\t */\n\t\t\tswitch (mono_type_to_load_membase (cfg, fsig->ret)) {\n\t\t\tcase OP_LOADI1_MEMBASE:\n\t\t\t\twiden_op = OP_ICONV_TO_I1;\n\t\t\t\tbreak;\n\t\t\tcase OP_LOADU1_MEMBASE:\n\t\t\t\twiden_op = OP_ICONV_TO_U1;\n\t\t\t\tbreak;\n\t\t\tcase OP_LOADI2_MEMBASE:\n\t\t\t\twiden_op = OP_ICONV_TO_I2;\n\t\t\t\tbreak;\n\t\t\tcase OP_LOADU2_MEMBASE:\n\t\t\t\twiden_op = OP_ICONV_TO_U2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (widen_op != -1) {\n\t\t\t\tint dreg = alloc_preg (cfg);\n\t\t\t\tMonoInst *widen;\n\n\t\t\t\tEMIT_NEW_UNALU (cfg, widen, widen_op, dreg, ins->dreg);\n\t\t\t\twiden->type = ins->type;\n\t\t\t\tins = widen;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ins;\n}\n\nstatic MonoInst*\nemit_get_rgctx_method (MonoCompile *cfg, int context_used,\n\t\t\t\t\t   MonoMethod *cmethod, MonoRgctxInfoType rgctx_type);\n\nstatic void\nemit_method_access_failure (MonoCompile *cfg, MonoMethod *caller, MonoMethod *callee)\n{\n\tMonoInst *args [2];\n\targs [0] = emit_get_rgctx_method (cfg, mono_method_check_context_used (caller), caller, MONO_RGCTX_INFO_METHOD);\n\targs [1] = emit_get_rgctx_method (cfg, mono_method_check_context_used (callee), callee, MONO_RGCTX_INFO_METHOD);\n\tmono_emit_jit_icall (cfg, mono_throw_method_access, args);\n}\n\nstatic void\nemit_bad_image_failure (MonoCompile *cfg, MonoMethod *caller, MonoMethod *callee)\n{\n\tmono_emit_jit_icall (cfg, mono_throw_bad_image, NULL);\n}\n\nstatic MonoMethod*\nget_method_nofail (MonoClass *klass, const char *method_name, int num_params, int flags)\n{\n\tMonoMethod *method;\n\tERROR_DECL (error);\n\tmethod = mono_class_get_method_from_name_checked (klass, method_name, num_params, flags, error);\n\tmono_error_assert_ok (error);\n\tg_assertf (method, \"Could not lookup method %s in %s\", method_name, m_class_get_name (klass));\n\treturn method;\n}\n\nMonoMethod*\nmini_get_memcpy_method (void)\n{\n\tstatic MonoMethod *memcpy_method = NULL;\n\tif (!memcpy_method) {\n\t\tmemcpy_method = get_method_nofail (mono_defaults.string_class, \"memcpy\", 3, 0);\n\t\tif (!memcpy_method)\n\t\t\tg_error (\"Old corlib found. Install a new one\");\n\t}\n\treturn memcpy_method;\n}\n\nMonoInst*\nmini_emit_storing_write_barrier (MonoCompile *cfg, MonoInst *ptr, MonoInst *value)\n{\n\tMonoInst *store;\n\n\t/*\n\t * Add a release memory barrier so the object contents are flushed\n\t * to memory before storing the reference into another object.\n\t */\n\tif (!mini_debug_options.weak_memory_model)\n\t\tmini_emit_memory_barrier (cfg, MONO_MEMORY_BARRIER_REL);\n\n\tEMIT_NEW_STORE_MEMBASE (cfg, store, OP_STORE_MEMBASE_REG, ptr->dreg, 0, value->dreg);\n\n\tmini_emit_write_barrier (cfg, ptr, value);\n\treturn store;\n}\n\nvoid\nmini_emit_write_barrier (MonoCompile *cfg, MonoInst *ptr, MonoInst *value)\n{\n\tint card_table_shift_bits;\n\ttarget_mgreg_t card_table_mask;\n\tguint8 *card_table;\n\tMonoInst *dummy_use;\n\tint nursery_shift_bits;\n\tsize_t nursery_size;\n\n\tif (!cfg->gen_write_barriers)\n\t\treturn;\n\n\t//method->wrapper_type != MONO_WRAPPER_WRITE_BARRIER && !MONO_INS_IS_PCONST_NULL (sp [1])\n\n\tcard_table = mono_gc_get_target_card_table (&card_table_shift_bits, &card_table_mask);\n\n\tmono_gc_get_nursery (&nursery_shift_bits, &nursery_size);\n\n\tif (cfg->backend->have_card_table_wb && !cfg->compile_aot && card_table && nursery_shift_bits > 0 && !COMPILE_LLVM (cfg)) {\n\t\tMonoInst *wbarrier;\n\n\t\tMONO_INST_NEW (cfg, wbarrier, OP_CARD_TABLE_WBARRIER);\n\t\twbarrier->sreg1 = ptr->dreg;\n\t\twbarrier->sreg2 = value->dreg;\n\t\tMONO_ADD_INS (cfg->cbb, wbarrier);\n\t} else if (card_table) {\n\t\tint offset_reg = alloc_preg (cfg);\n\t\tint card_reg;\n\t\tMonoInst *ins;\n\n\t\t/*\n\t\t * We emit a fast light weight write barrier. This always marks cards as in the concurrent\n\t\t * collector case, so, for the serial collector, it might slightly slow down nursery\n\t\t * collections. We also expect that the host system and the target system have the same card\n\t\t * table configuration, which is the case if they have the same pointer size.\n\t\t */\n\n\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_SHR_UN_IMM, offset_reg, ptr->dreg, card_table_shift_bits);\n\t\tif (card_table_mask)\n\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_PAND_IMM, offset_reg, offset_reg, card_table_mask);\n\n\t\t/*We can't use PADD_IMM since the cardtable might end up in high addresses and amd64 doesn't support\n\t\t * IMM's larger than 32bits.\n\t\t */\n\t\tins = mini_emit_runtime_constant (cfg, MONO_PATCH_INFO_GC_CARD_TABLE_ADDR, NULL);\n\t\tcard_reg = ins->dreg;\n\n\t\tMONO_EMIT_NEW_BIALU (cfg, OP_PADD, offset_reg, offset_reg, card_reg);\n\t\tMONO_EMIT_NEW_STORE_MEMBASE_IMM (cfg, OP_STOREI1_MEMBASE_IMM, offset_reg, 0, 1);\n\t} else {\n\t\tMonoMethod *write_barrier = mono_gc_get_write_barrier ();\n\t\tmono_emit_method_call (cfg, write_barrier, &ptr, NULL);\n\t}\n\n\tEMIT_NEW_DUMMY_USE (cfg, dummy_use, value);\n}\n\nMonoMethod*\nmini_get_memset_method (void)\n{\n\tstatic MonoMethod *memset_method = NULL;\n\tif (!memset_method) {\n\t\tmemset_method = get_method_nofail (mono_defaults.string_class, \"memset\", 3, 0);\n\t\tif (!memset_method)\n\t\t\tg_error (\"Old corlib found. Install a new one\");\n\t}\n\treturn memset_method;\n}\n\nvoid\nmini_emit_initobj (MonoCompile *cfg, MonoInst *dest, const guchar *ip, MonoClass *klass)\n{\n\tMonoInst *iargs [3];\n\tint n;\n\tguint32 align;\n\tMonoMethod *memset_method;\n\tMonoInst *size_ins = NULL;\n\tMonoInst *bzero_ins = NULL;\n\tstatic MonoMethod *bzero_method;\n\n\t/* FIXME: Optimize this for the case when dest is an LDADDR */\n\tmono_class_init_internal (klass);\n\tif (mini_is_gsharedvt_klass (klass)) {\n\t\tsize_ins = mini_emit_get_gsharedvt_info_klass (cfg, klass, MONO_RGCTX_INFO_VALUE_SIZE);\n\t\tbzero_ins = mini_emit_get_gsharedvt_info_klass (cfg, klass, MONO_RGCTX_INFO_BZERO);\n\t\tif (!bzero_method)\n\t\t\tbzero_method = get_method_nofail (mono_defaults.string_class, \"bzero_aligned_1\", 2, 0);\n\t\tg_assert (bzero_method);\n\t\tiargs [0] = dest;\n\t\tiargs [1] = size_ins;\n\t\tmini_emit_calli (cfg, mono_method_signature_internal (bzero_method), iargs, bzero_ins, NULL, NULL);\n\t\treturn;\n\t}\n\n\tklass = mono_class_from_mono_type_internal (mini_get_underlying_type (m_class_get_byval_arg (klass)));\n\n\tn = mono_class_value_size (klass, &align);\n\n\tif (n <= TARGET_SIZEOF_VOID_P * 8) {\n\t\tmini_emit_memset (cfg, dest->dreg, 0, n, 0, align);\n\t}\n\telse {\n\t\tmemset_method = mini_get_memset_method ();\n\t\tiargs [0] = dest;\n\t\tEMIT_NEW_ICONST (cfg, iargs [1], 0);\n\t\tEMIT_NEW_ICONST (cfg, iargs [2], n);\n\t\tmono_emit_method_call (cfg, memset_method, iargs, NULL);\n\t}\n}\n\nstatic gboolean\ncontext_used_is_mrgctx (MonoCompile *cfg, int context_used)\n{\n\t/* gshared dim methods use an mrgctx */\n\tif (mini_method_is_default_method (cfg->method))\n\t\treturn context_used != 0;\n\treturn context_used & MONO_GENERIC_CONTEXT_USED_METHOD;\n}\n\n/*\n * emit_get_rgctx:\n *\n *   Emit IR to return either the this pointer for instance method,\n * or the mrgctx for static methods.\n */\nstatic MonoInst*\nemit_get_rgctx (MonoCompile *cfg, int context_used)\n{\n\tMonoInst *this_ins = NULL;\n\tMonoMethod *method = cfg->method;\n\n\tg_assert (cfg->gshared);\n\n\tif (!(method->flags & METHOD_ATTRIBUTE_STATIC) &&\n\t\t\t!(context_used & MONO_GENERIC_CONTEXT_USED_METHOD) &&\n\t\t\t!m_class_is_valuetype (method->klass))\n\t\tEMIT_NEW_VARLOAD (cfg, this_ins, cfg->this_arg, mono_get_object_type ());\n\n\tif (context_used_is_mrgctx (cfg, context_used)) {\n\t\tMonoInst *mrgctx_loc, *mrgctx_var;\n\n\t\tif (!mini_method_is_default_method (method)) {\n\t\t\tg_assert (!this_ins);\n\t\t\tg_assert (method->is_inflated && mono_method_get_context (method)->method_inst);\n\t\t}\n\n\t\tmrgctx_loc = mono_get_vtable_var (cfg);\n\t\tEMIT_NEW_TEMPLOAD (cfg, mrgctx_var, mrgctx_loc->inst_c0);\n\n\t\treturn mrgctx_var;\n\t} else if (method->flags & METHOD_ATTRIBUTE_STATIC || m_class_is_valuetype (method->klass)) {\n\t\tMonoInst *vtable_loc, *vtable_var;\n\n\t\tg_assert (!this_ins);\n\n\t\tvtable_loc = mono_get_vtable_var (cfg);\n\t\tEMIT_NEW_TEMPLOAD (cfg, vtable_var, vtable_loc->inst_c0);\n\n\t\tif (method->is_inflated && mono_method_get_context (method)->method_inst) {\n\t\t\tMonoInst *mrgctx_var = vtable_var;\n\t\t\tint vtable_reg;\n\n\t\t\tvtable_reg = alloc_preg (cfg);\n\t\t\tEMIT_NEW_LOAD_MEMBASE (cfg, vtable_var, OP_LOAD_MEMBASE, vtable_reg, mrgctx_var->dreg, MONO_STRUCT_OFFSET (MonoMethodRuntimeGenericContext, class_vtable));\n\t\t\tvtable_var->type = STACK_PTR;\n\t\t}\n\n\t\treturn vtable_var;\n\t} else {\n\t\tMonoInst *ins;\n\t\tint vtable_reg;\n\t\n\t\tvtable_reg = alloc_preg (cfg);\n\t\tEMIT_NEW_LOAD_MEMBASE (cfg, ins, OP_LOAD_MEMBASE, vtable_reg, this_ins->dreg, MONO_STRUCT_OFFSET (MonoObject, vtable));\n\t\treturn ins;\n\t}\n}\n\nstatic MonoJumpInfoRgctxEntry *\nmono_patch_info_rgctx_entry_new (MonoMemPool *mp, MonoMethod *method, gboolean in_mrgctx, MonoJumpInfoType patch_type, gconstpointer patch_data, MonoRgctxInfoType info_type)\n{\n\tMonoJumpInfoRgctxEntry *res = (MonoJumpInfoRgctxEntry *)mono_mempool_alloc0 (mp, sizeof (MonoJumpInfoRgctxEntry));\n\tif (in_mrgctx)\n\t\tres->d.method = method;\n\telse\n\t\tres->d.klass = method->klass;\n\tres->in_mrgctx = in_mrgctx;\n\tres->data = (MonoJumpInfo *)mono_mempool_alloc0 (mp, sizeof (MonoJumpInfo));\n\tres->data->type = patch_type;\n\tres->data->data.target = patch_data;\n\tres->info_type = info_type;\n\n\treturn res;\n}\n\nstatic MonoInst*\nemit_rgctx_fetch_inline (MonoCompile *cfg, MonoInst *rgctx, MonoJumpInfoRgctxEntry *entry)\n{\n\tMonoInst *args [16];\n\tMonoInst *call;\n\n\t// FIXME: No fastpath since the slot is not a compile time constant\n\targs [0] = rgctx;\n\tEMIT_NEW_AOTCONST (cfg, args [1], MONO_PATCH_INFO_RGCTX_SLOT_INDEX, entry);\n\tif (entry->in_mrgctx)\n\t\tcall = mono_emit_jit_icall (cfg, mono_fill_method_rgctx, args);\n\telse\n\t\tcall = mono_emit_jit_icall (cfg, mono_fill_class_rgctx, args);\n\treturn call;\n#if 0\n\t/*\n\t * FIXME: This can be called during decompose, which is a problem since it creates\n\t * new bblocks.\n\t * Also, the fastpath doesn't work since the slot number is dynamically allocated.\n\t */\n\tint i, slot, depth, index, rgctx_reg, val_reg, res_reg;\n\tgboolean mrgctx;\n\tMonoBasicBlock *is_null_bb, *end_bb;\n\tMonoInst *res, *ins, *call;\n\tMonoInst *args[16];\n\n\tslot = mini_get_rgctx_entry_slot (entry);\n\n\tmrgctx = MONO_RGCTX_SLOT_IS_MRGCTX (slot);\n\tindex = MONO_RGCTX_SLOT_INDEX (slot);\n\tif (mrgctx)\n\t\tindex += MONO_SIZEOF_METHOD_RUNTIME_GENERIC_CONTEXT / TARGET_SIZEOF_VOID_P;\n\tfor (depth = 0; ; ++depth) {\n\t\tint size = mono_class_rgctx_get_array_size (depth, mrgctx);\n\n\t\tif (index < size - 1)\n\t\t\tbreak;\n\t\tindex -= size - 1;\n\t}\n\n\tNEW_BBLOCK (cfg, end_bb);\n\tNEW_BBLOCK (cfg, is_null_bb);\n\n\tif (mrgctx) {\n\t\trgctx_reg = rgctx->dreg;\n\t} else {\n\t\trgctx_reg = alloc_preg (cfg);\n\n\t\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, rgctx_reg, rgctx->dreg, MONO_STRUCT_OFFSET (MonoVTable, runtime_generic_context));\n\t\t// FIXME: Avoid this check by allocating the table when the vtable is created etc.\n\t\tNEW_BBLOCK (cfg, is_null_bb);\n\n\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, rgctx_reg, 0);\n\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_PBEQ, is_null_bb);\n\t}\n\n\tfor (i = 0; i < depth; ++i) {\n\t\tint array_reg = alloc_preg (cfg);\n\n\t\t/* load ptr to next array */\n\t\tif (mrgctx && i == 0)\n\t\t\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, array_reg, rgctx_reg, MONO_SIZEOF_METHOD_RUNTIME_GENERIC_CONTEXT);\n\t\telse\n\t\t\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, array_reg, rgctx_reg, 0);\n\t\trgctx_reg = array_reg;\n\t\t/* is the ptr null? */\n\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, rgctx_reg, 0);\n\t\t/* if yes, jump to actual trampoline */\n\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_PBEQ, is_null_bb);\n\t}\n\n\t/* fetch slot */\n\tval_reg = alloc_preg (cfg);\n\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, val_reg, rgctx_reg, (index + 1) * TARGET_SIZEOF_VOID_P);\n\t/* is the slot null? */\n\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, val_reg, 0);\n\t/* if yes, jump to actual trampoline */\n\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_PBEQ, is_null_bb);\n\n\t/* Fastpath */\n\tres_reg = alloc_preg (cfg);\n\tMONO_INST_NEW (cfg, ins, OP_MOVE);\n\tins->dreg = res_reg;\n\tins->sreg1 = val_reg;\n\tMONO_ADD_INS (cfg->cbb, ins);\n\tres = ins;\n\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_BR, end_bb);\n\n\t/* Slowpath */\n\tMONO_START_BB (cfg, is_null_bb);\n\targs [0] = rgctx;\n\tEMIT_NEW_ICONST (cfg, args [1], index);\n\tif (mrgctx)\n\t\tcall = mono_emit_jit_icall (cfg, mono_fill_method_rgctx, args);\n\telse\n\t\tcall = mono_emit_jit_icall (cfg, mono_fill_class_rgctx, args);\n\tMONO_INST_NEW (cfg, ins, OP_MOVE);\n\tins->dreg = res_reg;\n\tins->sreg1 = call->dreg;\n\tMONO_ADD_INS (cfg->cbb, ins);\n\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_BR, end_bb);\n\n\tMONO_START_BB (cfg, end_bb);\n\n\treturn res;\n#endif\n}\n\n/*\n * emit_rgctx_fetch:\n *\n *   Emit IR to load the value of the rgctx entry ENTRY from the rgctx\n * given by RGCTX.\n */\nstatic MonoInst*\nemit_rgctx_fetch (MonoCompile *cfg, MonoInst *rgctx, MonoJumpInfoRgctxEntry *entry)\n{\n\tif (cfg->llvm_only)\n\t\treturn emit_rgctx_fetch_inline (cfg, rgctx, entry);\n\telse\n\t\treturn mini_emit_abs_call (cfg, MONO_PATCH_INFO_RGCTX_FETCH, entry, mono_icall_sig_ptr_ptr, &rgctx);\n}\n\n/*\n * mini_emit_get_rgctx_klass:\n *\n *   Emit IR to load the property RGCTX_TYPE of KLASS. If context_used is 0, emit\n * normal constants, else emit a load from the rgctx.\n */\nMonoInst*\nmini_emit_get_rgctx_klass (MonoCompile *cfg, int context_used,\n\t\t\t\t\t\t   MonoClass *klass, MonoRgctxInfoType rgctx_type)\n{\n\tif (!context_used) {\n\t\tMonoInst *ins;\n\n\t\tswitch (rgctx_type) {\n\t\tcase MONO_RGCTX_INFO_KLASS:\n\t\t\tEMIT_NEW_CLASSCONST (cfg, ins, klass);\n\t\t\treturn ins;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t}\n\n\tMonoJumpInfoRgctxEntry *entry = mono_patch_info_rgctx_entry_new (cfg->mempool, cfg->method, context_used_is_mrgctx (cfg, context_used), MONO_PATCH_INFO_CLASS, klass, rgctx_type);\n\tMonoInst *rgctx = emit_get_rgctx (cfg, context_used);\n\n\treturn emit_rgctx_fetch (cfg, rgctx, entry);\n}\n\nstatic MonoInst*\nemit_get_rgctx_sig (MonoCompile *cfg, int context_used,\n\t\t\t\t\tMonoMethodSignature *sig, MonoRgctxInfoType rgctx_type)\n{\n\tMonoJumpInfoRgctxEntry *entry = mono_patch_info_rgctx_entry_new (cfg->mempool, cfg->method, context_used_is_mrgctx (cfg, context_used), MONO_PATCH_INFO_SIGNATURE, sig, rgctx_type);\n\tMonoInst *rgctx = emit_get_rgctx (cfg, context_used);\n\n\treturn emit_rgctx_fetch (cfg, rgctx, entry);\n}\n\nstatic MonoInst*\nemit_get_rgctx_gsharedvt_call (MonoCompile *cfg, int context_used,\n\t\t\t\t\t\t\t   MonoMethodSignature *sig, MonoMethod *cmethod, MonoRgctxInfoType rgctx_type)\n{\n\tMonoJumpInfoGSharedVtCall *call_info;\n\tMonoJumpInfoRgctxEntry *entry;\n\tMonoInst *rgctx;\n\n\tcall_info = (MonoJumpInfoGSharedVtCall *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoJumpInfoGSharedVtCall));\n\tcall_info->sig = sig;\n\tcall_info->method = cmethod;\n\n\tentry = mono_patch_info_rgctx_entry_new (cfg->mempool, cfg->method, context_used_is_mrgctx (cfg, context_used), MONO_PATCH_INFO_GSHAREDVT_CALL, call_info, rgctx_type);\n\trgctx = emit_get_rgctx (cfg, context_used);\n\n\treturn emit_rgctx_fetch (cfg, rgctx, entry);\n}\n\n/*\n * emit_get_rgctx_virt_method:\n *\n *   Return data for method VIRT_METHOD for a receiver of type KLASS.\n */\nstatic MonoInst*\nemit_get_rgctx_virt_method (MonoCompile *cfg, int context_used,\n\t\t\t\t\t\t\tMonoClass *klass, MonoMethod *virt_method, MonoRgctxInfoType rgctx_type)\n{\n\tMonoJumpInfoVirtMethod *info;\n\tMonoJumpInfoRgctxEntry *entry;\n\tMonoInst *rgctx;\n\n\tinfo = (MonoJumpInfoVirtMethod *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoJumpInfoVirtMethod));\n\tinfo->klass = klass;\n\tinfo->method = virt_method;\n\n\tentry = mono_patch_info_rgctx_entry_new (cfg->mempool, cfg->method, context_used_is_mrgctx (cfg, context_used), MONO_PATCH_INFO_VIRT_METHOD, info, rgctx_type);\n\trgctx = emit_get_rgctx (cfg, context_used);\n\n\treturn emit_rgctx_fetch (cfg, rgctx, entry);\n}\n\nstatic MonoInst*\nemit_get_rgctx_gsharedvt_method (MonoCompile *cfg, int context_used,\n\t\t\t\t\t\t\t\t MonoMethod *cmethod, MonoGSharedVtMethodInfo *info)\n{\n\tMonoJumpInfoRgctxEntry *entry;\n\tMonoInst *rgctx;\n\n\tentry = mono_patch_info_rgctx_entry_new (cfg->mempool, cfg->method, context_used_is_mrgctx (cfg, context_used), MONO_PATCH_INFO_GSHAREDVT_METHOD, info, MONO_RGCTX_INFO_METHOD_GSHAREDVT_INFO);\n\trgctx = emit_get_rgctx (cfg, context_used);\n\n\treturn emit_rgctx_fetch (cfg, rgctx, entry);\n}\n\n/*\n * emit_get_rgctx_method:\n *\n *   Emit IR to load the property RGCTX_TYPE of CMETHOD. If context_used is 0, emit\n * normal constants, else emit a load from the rgctx.\n */\nstatic MonoInst*\nemit_get_rgctx_method (MonoCompile *cfg, int context_used,\n\t\t\t\t\t   MonoMethod *cmethod, MonoRgctxInfoType rgctx_type)\n{\n\tif (context_used == -1)\n\t\tcontext_used = mono_method_check_context_used (cmethod);\n\n\tif (!context_used) {\n\t\tMonoInst *ins;\n\n\t\tswitch (rgctx_type) {\n\t\tcase MONO_RGCTX_INFO_METHOD:\n\t\t\tEMIT_NEW_METHODCONST (cfg, ins, cmethod);\n\t\t\treturn ins;\n\t\tcase MONO_RGCTX_INFO_METHOD_RGCTX:\n\t\t\tEMIT_NEW_METHOD_RGCTX_CONST (cfg, ins, cmethod);\n\t\t\treturn ins;\n\t\tcase MONO_RGCTX_INFO_METHOD_FTNDESC:\n\t\t\tEMIT_NEW_AOTCONST (cfg, ins, MONO_PATCH_INFO_METHOD_FTNDESC, cmethod);\n\t\t\treturn ins;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t} else {\n\t\tMonoJumpInfoRgctxEntry *entry = mono_patch_info_rgctx_entry_new (cfg->mempool, cfg->method, context_used_is_mrgctx (cfg, context_used), MONO_PATCH_INFO_METHODCONST, cmethod, rgctx_type);\n\t\tMonoInst *rgctx = emit_get_rgctx (cfg, context_used);\n\n\t\treturn emit_rgctx_fetch (cfg, rgctx, entry);\n\t}\n}\n\nstatic MonoInst*\nemit_get_rgctx_field (MonoCompile *cfg, int context_used,\n\t\t\t\t\t  MonoClassField *field, MonoRgctxInfoType rgctx_type)\n{\n\tMonoJumpInfoRgctxEntry *entry = mono_patch_info_rgctx_entry_new (cfg->mempool, cfg->method, context_used_is_mrgctx (cfg, context_used), MONO_PATCH_INFO_FIELD, field, rgctx_type);\n\tMonoInst *rgctx = emit_get_rgctx (cfg, context_used);\n\n\treturn emit_rgctx_fetch (cfg, rgctx, entry);\n}\n\nMonoInst*\nmini_emit_get_rgctx_method (MonoCompile *cfg, int context_used,\n\t\t\t\t\t\t\tMonoMethod *cmethod, MonoRgctxInfoType rgctx_type)\n{\n\treturn emit_get_rgctx_method (cfg, context_used, cmethod, rgctx_type);\n}\n\nstatic int\nget_gsharedvt_info_slot (MonoCompile *cfg, gpointer data, MonoRgctxInfoType rgctx_type)\n{\n\tMonoGSharedVtMethodInfo *info = cfg->gsharedvt_info;\n\tMonoRuntimeGenericContextInfoTemplate *template_;\n\tint i, idx;\n\n\tg_assert (info);\n\n\tfor (i = 0; i < info->num_entries; ++i) {\n\t\tMonoRuntimeGenericContextInfoTemplate *otemplate = &info->entries [i];\n\n\t\tif (otemplate->info_type == rgctx_type && otemplate->data == data && rgctx_type != MONO_RGCTX_INFO_LOCAL_OFFSET)\n\t\t\treturn i;\n\t}\n\n\tif (info->num_entries == info->count_entries) {\n\t\tMonoRuntimeGenericContextInfoTemplate *new_entries;\n\t\tint new_count_entries = info->count_entries ? info->count_entries * 2 : 16;\n\n\t\tnew_entries = (MonoRuntimeGenericContextInfoTemplate *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoRuntimeGenericContextInfoTemplate) * new_count_entries);\n\n\t\tmemcpy (new_entries, info->entries, sizeof (MonoRuntimeGenericContextInfoTemplate) * info->count_entries);\n\t\tinfo->entries = new_entries;\n\t\tinfo->count_entries = new_count_entries;\n\t}\n\n\tidx = info->num_entries;\n\ttemplate_ = &info->entries [idx];\n\ttemplate_->info_type = rgctx_type;\n\ttemplate_->data = data;\n\n\tinfo->num_entries ++;\n\n\treturn idx;\n}\n\n/*\n * emit_get_gsharedvt_info:\n *\n *   This is similar to emit_get_rgctx_.., but loads the data from the gsharedvt info var instead of calling an rgctx fetch trampoline.\n */\nstatic MonoInst*\nemit_get_gsharedvt_info (MonoCompile *cfg, gpointer data, MonoRgctxInfoType rgctx_type)\n{\n\tMonoInst *ins;\n\tint idx, dreg;\n\n\tidx = get_gsharedvt_info_slot (cfg, data, rgctx_type);\n\t/* Load info->entries [idx] */\n\tdreg = alloc_preg (cfg);\n\tEMIT_NEW_LOAD_MEMBASE (cfg, ins, OP_LOAD_MEMBASE, dreg, cfg->gsharedvt_info_var->dreg, MONO_STRUCT_OFFSET (MonoGSharedVtMethodRuntimeInfo, entries) + (idx * TARGET_SIZEOF_VOID_P));\n\n\treturn ins;\n}\n\nMonoInst*\nmini_emit_get_gsharedvt_info_klass (MonoCompile *cfg, MonoClass *klass, MonoRgctxInfoType rgctx_type)\n{\n\treturn emit_get_gsharedvt_info (cfg, m_class_get_byval_arg (klass), rgctx_type);\n}\n\n/*\n * On return the caller must check @klass for load errors.\n */\nstatic void\nemit_class_init (MonoCompile *cfg, MonoClass *klass)\n{\n\tMonoInst *vtable_arg;\n\tint context_used;\n\n\tcontext_used = mini_class_check_context_used (cfg, klass);\n\n\tif (context_used) {\n\t\tvtable_arg = mini_emit_get_rgctx_klass (cfg, context_used,\n\t\t\t\t\t\t\t\t\t\t   klass, MONO_RGCTX_INFO_VTABLE);\n\t} else {\n\t\tMonoVTable *vtable = mono_class_vtable_checked (cfg->domain, klass, cfg->error);\n\t\tif (!is_ok (cfg->error)) {\n\t\t\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_MONO_ERROR);\n\t\t\treturn;\n\t\t}\n\n\t\tEMIT_NEW_VTABLECONST (cfg, vtable_arg, vtable);\n\t}\n\n\tif (!COMPILE_LLVM (cfg) && cfg->backend->have_op_generic_class_init) {\n\t\tMonoInst *ins;\n\n\t\t/*\n\t\t * Using an opcode instead of emitting IR here allows the hiding of the call inside the opcode,\n\t\t * so this doesn't have to clobber any regs and it doesn't break basic blocks.\n\t\t */\n\t\tMONO_INST_NEW (cfg, ins, OP_GENERIC_CLASS_INIT);\n\t\tins->sreg1 = vtable_arg->dreg;\n\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t} else {\n\t\tint inited_reg;\n\t\tMonoBasicBlock *inited_bb;\n\n\t\tinited_reg = alloc_ireg (cfg);\n\n\t\tMONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADU1_MEMBASE, inited_reg, vtable_arg->dreg, MONO_STRUCT_OFFSET (MonoVTable, initialized));\n\n\t\tNEW_BBLOCK (cfg, inited_bb);\n\n\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, inited_reg, 0);\n\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_IBNE_UN, inited_bb);\n\n\t\tmono_emit_jit_icall (cfg, mono_generic_class_init, &vtable_arg);\n\n\t\tMONO_START_BB (cfg, inited_bb);\n\t}\n}\n\nstatic void\nemit_seq_point (MonoCompile *cfg, MonoMethod *method, guint8* ip, gboolean intr_loc, gboolean nonempty_stack)\n{\n\tMonoInst *ins;\n\n\tif (cfg->gen_seq_points && cfg->method == method) {\n\t\tNEW_SEQ_POINT (cfg, ins, ip - cfg->header->code, intr_loc);\n\t\tif (nonempty_stack)\n\t\t\tins->flags |= MONO_INST_NONEMPTY_STACK;\n\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\tcfg->last_seq_point = ins;\n\t}\n}\n\nvoid\nmini_save_cast_details (MonoCompile *cfg, MonoClass *klass, int obj_reg, gboolean null_check)\n{\n\tif (mini_debug_options.better_cast_details) {\n\t\tint vtable_reg = alloc_preg (cfg);\n\t\tint klass_reg = alloc_preg (cfg);\n\t\tMonoBasicBlock *is_null_bb = NULL;\n\t\tMonoInst *tls_get;\n\n\t\tif (null_check) {\n\t\t\tNEW_BBLOCK (cfg, is_null_bb);\n\n\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, obj_reg, 0);\n\t\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_PBEQ, is_null_bb);\n\t\t}\n\n\t\ttls_get = mono_create_tls_get (cfg, TLS_KEY_JIT_TLS);\n\t\tif (!tls_get) {\n\t\t\tfprintf (stderr, \"error: --debug=casts not supported on this platform.\\n.\");\n\t\t\texit (1);\n\t\t}\n\n\t\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, vtable_reg, obj_reg, MONO_STRUCT_OFFSET (MonoObject, vtable));\n\t\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, klass_reg, vtable_reg, MONO_STRUCT_OFFSET (MonoVTable, klass));\n\n\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, tls_get->dreg, MONO_STRUCT_OFFSET (MonoJitTlsData, class_cast_from), klass_reg);\n\n\t\tMonoInst *class_ins = mini_emit_get_rgctx_klass (cfg, mini_class_check_context_used (cfg, klass), klass, MONO_RGCTX_INFO_KLASS);\n\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, tls_get->dreg, MONO_STRUCT_OFFSET (MonoJitTlsData, class_cast_to), class_ins->dreg);\n\n\t\tif (null_check)\n\t\t\tMONO_START_BB (cfg, is_null_bb);\n\t}\n}\n\nvoid\nmini_reset_cast_details (MonoCompile *cfg)\n{\n\t/* Reset the variables holding the cast details */\n\tif (mini_debug_options.better_cast_details) {\n\t\tMonoInst *tls_get = mono_create_tls_get (cfg, TLS_KEY_JIT_TLS);\n\t\t/* It is enough to reset the from field */\n\t\tMONO_EMIT_NEW_STORE_MEMBASE_IMM (cfg, OP_STORE_MEMBASE_IMM, tls_get->dreg, MONO_STRUCT_OFFSET (MonoJitTlsData, class_cast_from), 0);\n\t}\n}\n\n/*\n * On return the caller must check @array_class for load errors\n */\nstatic void\nmini_emit_check_array_type (MonoCompile *cfg, MonoInst *obj, MonoClass *array_class)\n{\n\tint vtable_reg = alloc_preg (cfg);\n\tint context_used;\n\n\tcontext_used = mini_class_check_context_used (cfg, array_class);\n\n\tmini_save_cast_details (cfg, array_class, obj->dreg, FALSE);\n\n\tMONO_EMIT_NEW_LOAD_MEMBASE_FAULT (cfg, vtable_reg, obj->dreg, MONO_STRUCT_OFFSET (MonoObject, vtable));\n\n\tif (cfg->opt & MONO_OPT_SHARED) {\n\t\tint class_reg = alloc_preg (cfg);\n\t\tMonoInst *ins;\n\n\t\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, class_reg, vtable_reg, MONO_STRUCT_OFFSET (MonoVTable, klass));\n\t\tins = mini_emit_runtime_constant (cfg, MONO_PATCH_INFO_CLASS, array_class);\n\t\tMONO_EMIT_NEW_BIALU (cfg, OP_COMPARE, -1, class_reg, ins->dreg);\n\t} else if (context_used) {\n\t\tMonoInst *vtable_ins;\n\n\t\tvtable_ins = mini_emit_get_rgctx_klass (cfg, context_used, array_class, MONO_RGCTX_INFO_VTABLE);\n\t\tMONO_EMIT_NEW_BIALU (cfg, OP_COMPARE, -1, vtable_reg, vtable_ins->dreg);\n\t} else {\n\t\tif (cfg->compile_aot) {\n\t\t\tint vt_reg;\n\t\t\tMonoVTable *vtable;\n\n\t\t\tif (!(vtable = mono_class_vtable_checked (cfg->domain, array_class, cfg->error))) {\n\t\t\t\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_MONO_ERROR);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvt_reg = alloc_preg (cfg);\n\t\t\tMONO_EMIT_NEW_VTABLECONST (cfg, vt_reg, vtable);\n\t\t\tMONO_EMIT_NEW_BIALU (cfg, OP_COMPARE, -1, vtable_reg, vt_reg);\n\t\t} else {\n\t\t\tMonoVTable *vtable;\n\t\t\tif (!(vtable = mono_class_vtable_checked (cfg->domain, array_class, cfg->error))) {\n\t\t\t\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_MONO_ERROR);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, vtable_reg, (gssize)vtable);\n\t\t}\n\t}\n\t\n\tMONO_EMIT_NEW_COND_EXC (cfg, NE_UN, \"ArrayTypeMismatchException\");\n\n\tmini_reset_cast_details (cfg);\n}\n\n/**\n * Handles unbox of a Nullable<T>. If context_used is non zero, then shared \n * generic code is generated.\n */\nstatic MonoInst*\nhandle_unbox_nullable (MonoCompile* cfg, MonoInst* val, MonoClass* klass, int context_used)\n{\n\tMonoMethod* method;\n\n\tif (m_class_is_enumtype (mono_class_get_nullable_param_internal (klass)))\n\t\tmethod = get_method_nofail (klass, \"UnboxExact\", 1, 0);\n\telse\n\t\tmethod = get_method_nofail (klass, \"Unbox\", 1, 0);\n\tg_assert (method);\n\n\tif (context_used) {\n\t\tMonoInst *rgctx, *addr;\n\n\t\t/* FIXME: What if the class is shared?  We might not\n\t\t   have to get the address of the method from the\n\t\t   RGCTX. */\n\t\tif (cfg->llvm_only) {\n\t\t\taddr = emit_get_rgctx_method (cfg, context_used, method,\n\t\t\t\t\t\t\t\t\t\t  MONO_RGCTX_INFO_METHOD_FTNDESC);\n\t\t\tcfg->signatures = g_slist_prepend_mempool (cfg->mempool, cfg->signatures, mono_method_signature_internal (method));\n\t\t\treturn mini_emit_llvmonly_calli (cfg, mono_method_signature_internal (method), &val, addr);\n\t\t} else {\n\t\t\taddr = emit_get_rgctx_method (cfg, context_used, method,\n\t\t\t\t\t\t\t\t\t\t  MONO_RGCTX_INFO_GENERIC_METHOD_CODE);\n\t\t\trgctx = emit_get_rgctx (cfg, context_used);\n\n\t\t\treturn mini_emit_calli (cfg, mono_method_signature_internal (method), &val, addr, NULL, rgctx);\n\t\t}\n\t} else {\n\t\tgboolean pass_vtable, pass_mrgctx;\n\t\tMonoInst *rgctx_arg = NULL;\n\n\t\tcheck_method_sharing (cfg, method, &pass_vtable, &pass_mrgctx);\n\t\tg_assert (!pass_mrgctx);\n\n\t\tif (pass_vtable) {\n\t\t\tMonoVTable *vtable = mono_class_vtable_checked (cfg->domain, method->klass, cfg->error);\n\n\t\t\tmono_error_assert_ok (cfg->error);\n\t\t\tEMIT_NEW_VTABLECONST (cfg, rgctx_arg, vtable);\n\t\t}\n\n\t\treturn mini_emit_method_call_full (cfg, method, NULL, FALSE, &val, NULL, NULL, rgctx_arg);\n\t}\n}\n\nstatic MonoInst*\nhandle_unbox (MonoCompile *cfg, MonoClass *klass, MonoInst **sp, int context_used)\n{\n\tMonoInst *add;\n\tint obj_reg;\n\tint vtable_reg = alloc_dreg (cfg ,STACK_PTR);\n\tint klass_reg = alloc_dreg (cfg ,STACK_PTR);\n\tint eclass_reg = alloc_dreg (cfg ,STACK_PTR);\n\tint rank_reg = alloc_dreg (cfg ,STACK_I4);\n\n\tobj_reg = sp [0]->dreg;\n\tMONO_EMIT_NEW_LOAD_MEMBASE_FAULT (cfg, vtable_reg, obj_reg, MONO_STRUCT_OFFSET (MonoObject, vtable));\n\tMONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADU1_MEMBASE, rank_reg, vtable_reg, MONO_STRUCT_OFFSET (MonoVTable, rank));\n\n\t/* FIXME: generics */\n\tg_assert (m_class_get_rank (klass) == 0);\n\t\t\t\n\t// Check rank == 0\n\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, rank_reg, 0);\n\tMONO_EMIT_NEW_COND_EXC (cfg, NE_UN, \"InvalidCastException\");\n\n\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, klass_reg, vtable_reg, MONO_STRUCT_OFFSET (MonoVTable, klass));\n\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, eclass_reg, klass_reg, m_class_offsetof_element_class ());\n\n\tif (context_used) {\n\t\tMonoInst *element_class;\n\n\t\t/* This assertion is from the unboxcast insn */\n\t\tg_assert (m_class_get_rank (klass) == 0);\n\n\t\telement_class = mini_emit_get_rgctx_klass (cfg, context_used,\n\t\t\t\tklass, MONO_RGCTX_INFO_ELEMENT_KLASS);\n\n\t\tMONO_EMIT_NEW_BIALU (cfg, OP_COMPARE, -1, eclass_reg, element_class->dreg);\n\t\tMONO_EMIT_NEW_COND_EXC (cfg, NE_UN, \"InvalidCastException\");\n\t} else {\n\t\tmini_save_cast_details (cfg, m_class_get_element_class (klass), obj_reg, FALSE);\n\t\tmini_emit_class_check (cfg, eclass_reg, m_class_get_element_class (klass));\n\t\tmini_reset_cast_details (cfg);\n\t}\n\n\tNEW_BIALU_IMM (cfg, add, OP_ADD_IMM, alloc_dreg (cfg, STACK_MP), obj_reg, MONO_ABI_SIZEOF (MonoObject));\n\tMONO_ADD_INS (cfg->cbb, add);\n\tadd->type = STACK_MP;\n\tadd->klass = klass;\n\n\treturn add;\n}\n\nstatic MonoInst*\nhandle_unbox_gsharedvt (MonoCompile *cfg, MonoClass *klass, MonoInst *obj)\n{\n\tMonoInst *addr, *klass_inst, *is_ref, *args[16];\n\tMonoBasicBlock *is_ref_bb, *is_nullable_bb, *end_bb;\n\tMonoInst *ins;\n\tint dreg, addr_reg;\n\n\tklass_inst = mini_emit_get_gsharedvt_info_klass (cfg, klass, MONO_RGCTX_INFO_KLASS);\n\n\t/* obj */\n\targs [0] = obj;\n\n\t/* klass */\n\targs [1] = klass_inst;\n\n\t/* CASTCLASS */\n\tobj = mono_emit_jit_icall (cfg, mono_object_castclass_unbox, args);\n\n\tNEW_BBLOCK (cfg, is_ref_bb);\n\tNEW_BBLOCK (cfg, is_nullable_bb);\n\tNEW_BBLOCK (cfg, end_bb);\n\tis_ref = mini_emit_get_gsharedvt_info_klass (cfg, klass, MONO_RGCTX_INFO_CLASS_BOX_TYPE);\n\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, is_ref->dreg, MONO_GSHAREDVT_BOX_TYPE_REF);\n\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_IBEQ, is_ref_bb);\n\n\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, is_ref->dreg, MONO_GSHAREDVT_BOX_TYPE_NULLABLE);\n\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_IBEQ, is_nullable_bb);\n\n\t/* This will contain either the address of the unboxed vtype, or an address of the temporary where the ref is stored */\n\taddr_reg = alloc_dreg (cfg, STACK_MP);\n\n\t/* Non-ref case */\n\t/* UNBOX */\n\tNEW_BIALU_IMM (cfg, addr, OP_ADD_IMM, addr_reg, obj->dreg, MONO_ABI_SIZEOF (MonoObject));\n\tMONO_ADD_INS (cfg->cbb, addr);\n\n\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_BR, end_bb);\n\n\t/* Ref case */\n\tMONO_START_BB (cfg, is_ref_bb);\n\n\t/* Save the ref to a temporary */\n\tdreg = alloc_ireg (cfg);\n\tEMIT_NEW_VARLOADA_VREG (cfg, addr, dreg, m_class_get_byval_arg (klass));\n\taddr->dreg = addr_reg;\n\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, addr->dreg, 0, obj->dreg);\n\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_BR, end_bb);\n\n\t/* Nullable case */\n\tMONO_START_BB (cfg, is_nullable_bb);\n\n\t{\n\t\tMonoInst *addr = mini_emit_get_gsharedvt_info_klass (cfg, klass, MONO_RGCTX_INFO_NULLABLE_CLASS_UNBOX);\n\t\tMonoInst *unbox_call;\n\t\tMonoMethodSignature *unbox_sig;\n\n\t\tunbox_sig = (MonoMethodSignature *)mono_mempool_alloc0 (cfg->mempool, MONO_SIZEOF_METHOD_SIGNATURE + (1 * sizeof (MonoType *)));\n\t\tunbox_sig->ret = m_class_get_byval_arg (klass);\n\t\tunbox_sig->param_count = 1;\n\t\tunbox_sig->params [0] = mono_get_object_type ();\n\n\t\tif (cfg->llvm_only)\n\t\t\tunbox_call = mini_emit_llvmonly_calli (cfg, unbox_sig, &obj, addr);\n\t\telse\n\t\t\tunbox_call = mini_emit_calli (cfg, unbox_sig, &obj, addr, NULL, NULL);\n\n\t\tEMIT_NEW_VARLOADA_VREG (cfg, addr, unbox_call->dreg, m_class_get_byval_arg (klass));\n\t\taddr->dreg = addr_reg;\n\t}\n\n\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_BR, end_bb);\n\n\t/* End */\n\tMONO_START_BB (cfg, end_bb);\n\n\t/* LDOBJ */\n\tEMIT_NEW_LOAD_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (klass), addr_reg, 0);\n\n\treturn ins;\n}\n\n/*\n * Returns NULL and set the cfg exception on error.\n */\nstatic MonoInst*\nhandle_alloc (MonoCompile *cfg, MonoClass *klass, gboolean for_box, int context_used)\n{\n\tMonoInst *iargs [2];\n\tMonoJitICallId alloc_ftn;\n\n\tif (mono_class_get_flags (klass) & TYPE_ATTRIBUTE_ABSTRACT) {\n\t\tchar* full_name = mono_type_get_full_name (klass);\n\t\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_MONO_ERROR);\n\t\tmono_error_set_member_access (cfg->error, \"Cannot create an abstract class: %s\", full_name);\n\t\tg_free (full_name);\n\t\treturn NULL;\n\t}\n\n\tif (context_used) {\n\t\tMonoInst *data;\n\t\tMonoRgctxInfoType rgctx_info;\n\t\tMonoInst *iargs [2];\n\t\tgboolean known_instance_size = !mini_is_gsharedvt_klass (klass);\n\n\t\tMonoMethod *managed_alloc = mono_gc_get_managed_allocator (klass, for_box, known_instance_size);\n\n\t\tif (cfg->opt & MONO_OPT_SHARED)\n\t\t\trgctx_info = MONO_RGCTX_INFO_KLASS;\n\t\telse\n\t\t\trgctx_info = MONO_RGCTX_INFO_VTABLE;\n\t\tdata = mini_emit_get_rgctx_klass (cfg, context_used, klass, rgctx_info);\n\n\t\tif (cfg->opt & MONO_OPT_SHARED) {\n\t\t\tEMIT_NEW_DOMAINCONST (cfg, iargs [0]);\n\t\t\tiargs [1] = data;\n\t\t\talloc_ftn = MONO_JIT_ICALL_ves_icall_object_new;\n\t\t} else {\n\t\t\tiargs [0] = data;\n\t\t\talloc_ftn = MONO_JIT_ICALL_ves_icall_object_new_specific;\n\t\t}\n\n\t\tif (managed_alloc && !(cfg->opt & MONO_OPT_SHARED)) {\n\t\t\tif (known_instance_size) {\n\t\t\t\tint size = mono_class_instance_size (klass);\n\t\t\t\tif (size < MONO_ABI_SIZEOF (MonoObject))\n\t\t\t\t\tg_error (\"Invalid size %d for class %s\", size, mono_type_get_full_name (klass));\n\n\t\t\t\tEMIT_NEW_ICONST (cfg, iargs [1], size);\n\t\t\t}\n\t\t\treturn mono_emit_method_call (cfg, managed_alloc, iargs, NULL);\n\t\t}\n\n\t\treturn mono_emit_jit_icall_id (cfg, alloc_ftn, iargs);\n\t}\n\n\tif (cfg->opt & MONO_OPT_SHARED) {\n\t\tEMIT_NEW_DOMAINCONST (cfg, iargs [0]);\n\t\tEMIT_NEW_CLASSCONST (cfg, iargs [1], klass);\n\n\t\talloc_ftn = MONO_JIT_ICALL_ves_icall_object_new;\n\t} else if (cfg->compile_aot && cfg->cbb->out_of_line && m_class_get_type_token (klass) && m_class_get_image (klass) == mono_defaults.corlib && !mono_class_is_ginst (klass)) {\n\t\t/* This happens often in argument checking code, eg. throw new FooException... */\n\t\t/* Avoid relocations and save some space by calling a helper function specialized to mscorlib */\n\t\tEMIT_NEW_ICONST (cfg, iargs [0], mono_metadata_token_index (m_class_get_type_token (klass)));\n\t\talloc_ftn = MONO_JIT_ICALL_mono_helper_newobj_mscorlib;\n\t} else {\n\t\tMonoVTable *vtable = mono_class_vtable_checked (cfg->domain, klass, cfg->error);\n\n\t\tif (!is_ok (cfg->error)) {\n\t\t\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_MONO_ERROR);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tMonoMethod *managed_alloc = mono_gc_get_managed_allocator (klass, for_box, TRUE);\n\n\t\tif (managed_alloc) {\n\t\t\tint size = mono_class_instance_size (klass);\n\t\t\tif (size < MONO_ABI_SIZEOF (MonoObject))\n\t\t\t\tg_error (\"Invalid size %d for class %s\", size, mono_type_get_full_name (klass));\n\n\t\t\tEMIT_NEW_VTABLECONST (cfg, iargs [0], vtable);\n\t\t\tEMIT_NEW_ICONST (cfg, iargs [1], size);\n\t\t\treturn mono_emit_method_call (cfg, managed_alloc, iargs, NULL);\n\t\t}\n\t\talloc_ftn = MONO_JIT_ICALL_ves_icall_object_new_specific;\n\t\tEMIT_NEW_VTABLECONST (cfg, iargs [0], vtable);\n\t}\n\n\treturn mono_emit_jit_icall_id (cfg, alloc_ftn, iargs);\n}\n\t\n/*\n * Returns NULL and set the cfg exception on error.\n */\t\nMonoInst*\nmini_emit_box (MonoCompile *cfg, MonoInst *val, MonoClass *klass, int context_used)\n{\n\tMonoInst *alloc, *ins;\n\n\tif (G_UNLIKELY (m_class_is_byreflike (klass))) {\n\t\tmono_error_set_bad_image (cfg->error, m_class_get_image (cfg->method->klass), \"Cannot box IsByRefLike type '%s.%s'\", m_class_get_name_space (klass), m_class_get_name (klass));\n\t\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_MONO_ERROR);\n\t\treturn NULL;\n\t}\n\n\tif (mono_class_is_nullable (klass)) {\n\t\tMonoMethod* method = get_method_nofail (klass, \"Box\", 1, 0);\n\n\t\tif (context_used) {\n\t\t\tif (cfg->llvm_only && cfg->gsharedvt) {\n\t\t\t\tMonoInst *addr = emit_get_rgctx_method (cfg, context_used, method,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tMONO_RGCTX_INFO_METHOD_FTNDESC);\n\t\t\t\treturn mini_emit_llvmonly_calli (cfg, mono_method_signature_internal (method), &val, addr);\n\t\t\t} else {\n\t\t\t\t/* FIXME: What if the class is shared?  We might not\n\t\t\t\t   have to get the method address from the RGCTX. */\n\t\t\t\tMonoInst *addr = emit_get_rgctx_method (cfg, context_used, method,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tMONO_RGCTX_INFO_GENERIC_METHOD_CODE);\n\t\t\t\tMonoInst *rgctx = emit_get_rgctx (cfg, context_used);\n\n\t\t\t\treturn mini_emit_calli (cfg, mono_method_signature_internal (method), &val, addr, NULL, rgctx);\n\t\t\t}\n\t\t} else {\n\t\t\tgboolean pass_vtable, pass_mrgctx;\n\t\t\tMonoInst *rgctx_arg = NULL;\n\n\t\t\tcheck_method_sharing (cfg, method, &pass_vtable, &pass_mrgctx);\n\t\t\tg_assert (!pass_mrgctx);\n\n\t\t\tif (pass_vtable) {\n\t\t\t\tMonoVTable *vtable = mono_class_vtable_checked (cfg->domain, method->klass, cfg->error);\n\n\t\t\t\tmono_error_assert_ok (cfg->error);\n\t\t\t\tEMIT_NEW_VTABLECONST (cfg, rgctx_arg, vtable);\n\t\t\t}\n\n\t\t\treturn mini_emit_method_call_full (cfg, method, NULL, FALSE, &val, NULL, NULL, rgctx_arg);\n\t\t}\n\t}\n\n\tif (mini_is_gsharedvt_klass (klass)) {\n\t\tMonoBasicBlock *is_ref_bb, *is_nullable_bb, *end_bb;\n\t\tMonoInst *res, *is_ref, *src_var, *addr;\n\t\tint dreg;\n\n\t\tdreg = alloc_ireg (cfg);\n\n\t\tNEW_BBLOCK (cfg, is_ref_bb);\n\t\tNEW_BBLOCK (cfg, is_nullable_bb);\n\t\tNEW_BBLOCK (cfg, end_bb);\n\t\tis_ref = mini_emit_get_gsharedvt_info_klass (cfg, klass, MONO_RGCTX_INFO_CLASS_BOX_TYPE);\n\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, is_ref->dreg, MONO_GSHAREDVT_BOX_TYPE_REF);\n\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_IBEQ, is_ref_bb);\n\n\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, is_ref->dreg, MONO_GSHAREDVT_BOX_TYPE_NULLABLE);\n\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_IBEQ, is_nullable_bb);\n\n\t\t/* Non-ref case */\n\t\talloc = handle_alloc (cfg, klass, TRUE, context_used);\n\t\tif (!alloc)\n\t\t\treturn NULL;\n\t\tEMIT_NEW_STORE_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (klass), alloc->dreg, MONO_ABI_SIZEOF (MonoObject), val->dreg);\n\t\tins->opcode = OP_STOREV_MEMBASE;\n\n\t\tEMIT_NEW_UNALU (cfg, res, OP_MOVE, dreg, alloc->dreg);\n\t\tres->type = STACK_OBJ;\n\t\tres->klass = klass;\n\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_BR, end_bb);\n\t\t\n\t\t/* Ref case */\n\t\tMONO_START_BB (cfg, is_ref_bb);\n\n\t\t/* val is a vtype, so has to load the value manually */\n\t\tsrc_var = get_vreg_to_inst (cfg, val->dreg);\n\t\tif (!src_var)\n\t\t\tsrc_var = mono_compile_create_var_for_vreg (cfg, m_class_get_byval_arg (klass), OP_LOCAL, val->dreg);\n\t\tEMIT_NEW_VARLOADA (cfg, addr, src_var, src_var->inst_vtype);\n\t\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, dreg, addr->dreg, 0);\n\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_BR, end_bb);\n\n\t\t/* Nullable case */\n\t\tMONO_START_BB (cfg, is_nullable_bb);\n\n\t\t{\n\t\t\tMonoInst *addr = mini_emit_get_gsharedvt_info_klass (cfg, klass,\n\t\t\t\t\t\t\t\t\t\t\t\t\tMONO_RGCTX_INFO_NULLABLE_CLASS_BOX);\n\t\t\tMonoInst *box_call;\n\t\t\tMonoMethodSignature *box_sig;\n\n\t\t\t/*\n\t\t\t * klass is Nullable<T>, need to call Nullable<T>.Box () using a gsharedvt signature, but we cannot\n\t\t\t * construct that method at JIT time, so have to do things by hand.\n\t\t\t */\n\t\t\tbox_sig = (MonoMethodSignature *)mono_mempool_alloc0 (cfg->mempool, MONO_SIZEOF_METHOD_SIGNATURE + (1 * sizeof (MonoType *)));\n\t\t\tbox_sig->ret = mono_get_object_type ();\n\t\t\tbox_sig->param_count = 1;\n\t\t\tbox_sig->params [0] = m_class_get_byval_arg (klass);\n\n\t\t\tif (cfg->llvm_only)\n\t\t\t\tbox_call = mini_emit_llvmonly_calli (cfg, box_sig, &val, addr);\n\t\t\telse\n\t\t\t\tbox_call = mini_emit_calli (cfg, box_sig, &val, addr, NULL, NULL);\n\t\t\tEMIT_NEW_UNALU (cfg, res, OP_MOVE, dreg, box_call->dreg);\n\t\t\tres->type = STACK_OBJ;\n\t\t\tres->klass = klass;\n\t\t}\n\n\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_BR, end_bb);\n\n\t\tMONO_START_BB (cfg, end_bb);\n\n\t\treturn res;\n\t}\n\n\talloc = handle_alloc (cfg, klass, TRUE, context_used);\n\tif (!alloc)\n\t\treturn NULL;\n\n\tEMIT_NEW_STORE_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (klass), alloc->dreg, MONO_ABI_SIZEOF (MonoObject), val->dreg);\n\treturn alloc;\n}\n\nstatic gboolean\nmethod_needs_stack_walk (MonoCompile *cfg, MonoMethod *cmethod)\n{\n\tif (cmethod->klass == mono_defaults.systemtype_class) {\n\t\tif (!strcmp (cmethod->name, \"GetType\"))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nG_GNUC_UNUSED MonoInst*\nmini_handle_enum_has_flag (MonoCompile *cfg, MonoClass *klass, MonoInst *enum_this, int enum_val_reg, MonoInst *enum_flag)\n{\n\tMonoType *enum_type = mono_type_get_underlying_type (m_class_get_byval_arg (klass));\n\tguint32 load_opc = mono_type_to_load_membase (cfg, enum_type);\n\tgboolean is_i4;\n\n\tswitch (enum_type->type) {\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n#if SIZEOF_REGISTER == 8\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n#endif\n\t\tis_i4 = FALSE;\n\t\tbreak;\n\tdefault:\n\t\tis_i4 = TRUE;\n\t\tbreak;\n\t}\n\n\t{\n\t\tMonoInst *load = NULL, *and_, *cmp, *ceq;\n\t\tint enum_reg = is_i4 ? alloc_ireg (cfg) : alloc_lreg (cfg);\n\t\tint and_reg = is_i4 ? alloc_ireg (cfg) : alloc_lreg (cfg);\n\t\tint dest_reg = alloc_ireg (cfg);\n\n\t\tif (enum_this) {\n\t\t\tEMIT_NEW_LOAD_MEMBASE (cfg, load, load_opc, enum_reg, enum_this->dreg, 0);\n\t\t} else {\n\t\t\tg_assert (enum_val_reg != -1);\n\t\t\tenum_reg = enum_val_reg;\n\t\t}\n\t\tEMIT_NEW_BIALU (cfg, and_, is_i4 ? OP_IAND : OP_LAND, and_reg, enum_reg, enum_flag->dreg);\n\t\tEMIT_NEW_BIALU (cfg, cmp, is_i4 ? OP_ICOMPARE : OP_LCOMPARE, -1, and_reg, enum_flag->dreg);\n\t\tEMIT_NEW_UNALU (cfg, ceq, is_i4 ? OP_ICEQ : OP_LCEQ, dest_reg, -1);\n\n\t\tceq->type = STACK_I4;\n\n\t\tif (!is_i4) {\n\t\t\tload = load ? mono_decompose_opcode (cfg, load) : NULL;\n\t\t\tand_ = mono_decompose_opcode (cfg, and_);\n\t\t\tcmp = mono_decompose_opcode (cfg, cmp);\n\t\t\tceq = mono_decompose_opcode (cfg, ceq);\n\t\t}\n\n\t\treturn ceq;\n\t}\n}\n\nstatic MonoInst*\nemit_get_rgctx_dele_tramp (MonoCompile *cfg, int context_used,\n\t\t\t\t\t\t\tMonoClass *klass, MonoMethod *virt_method, gboolean _virtual, MonoRgctxInfoType rgctx_type)\n{\n\tMonoDelegateClassMethodPair *info;\n\tMonoJumpInfoRgctxEntry *entry;\n\tMonoInst *rgctx;\n\n\tinfo = (MonoDelegateClassMethodPair *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoDelegateClassMethodPair));\n\tinfo->klass = klass;\n\tinfo->method = virt_method;\n\tinfo->is_virtual = _virtual;\n\n\tentry = mono_patch_info_rgctx_entry_new (cfg->mempool, cfg->method, context_used_is_mrgctx (cfg, context_used), MONO_PATCH_INFO_DELEGATE_TRAMPOLINE, info, rgctx_type);\n\trgctx = emit_get_rgctx (cfg, context_used);\n\n\treturn emit_rgctx_fetch (cfg, rgctx, entry);\n}\n\n\n/*\n * Returns NULL and set the cfg exception on error.\n */\nstatic G_GNUC_UNUSED MonoInst*\nhandle_delegate_ctor (MonoCompile *cfg, MonoClass *klass, MonoInst *target, MonoMethod *method, int target_method_context_used, int invoke_context_used, gboolean virtual_)\n{\n\tMonoInst *ptr;\n\tint dreg;\n\tgpointer trampoline;\n\tMonoInst *obj, *tramp_ins;\n\tMonoDomain *domain;\n\tguint8 **code_slot;\n\n\tif (virtual_ && !cfg->llvm_only) {\n\t\tMonoMethod *invoke = mono_get_delegate_invoke_internal (klass);\n\t\tg_assert (invoke);\n\n\t\t//FIXME verify & fix any issue with removing invoke_context_used restriction\n\t\tif (invoke_context_used || !mono_get_delegate_virtual_invoke_impl (mono_method_signature_internal (invoke), target_method_context_used ? NULL : method))\n\t\t\treturn NULL;\n\t}\n\n\tobj = handle_alloc (cfg, klass, FALSE, invoke_context_used);\n\tif (!obj)\n\t\treturn NULL;\n\n\t/* Inline the contents of mono_delegate_ctor */\n\n\t/* Set target field */\n\t/* Optimize away setting of NULL target */\n\tif (!MONO_INS_IS_PCONST_NULL (target)) {\n\t\tif (!(method->flags & METHOD_ATTRIBUTE_STATIC)) {\n\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, target->dreg, 0);\n\t\t\tMONO_EMIT_NEW_COND_EXC (cfg, EQ, \"NullReferenceException\");\n\t\t}\n\t\tif (!mini_debug_options.weak_memory_model)\n\t\t\tmini_emit_memory_barrier (cfg, MONO_MEMORY_BARRIER_REL);\n\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, obj->dreg, MONO_STRUCT_OFFSET (MonoDelegate, target), target->dreg);\n\t\tif (cfg->gen_write_barriers) {\n\t\t\tdreg = alloc_preg (cfg);\n\t\t\tEMIT_NEW_BIALU_IMM (cfg, ptr, OP_PADD_IMM, dreg, obj->dreg, MONO_STRUCT_OFFSET (MonoDelegate, target));\n\t\t\tmini_emit_write_barrier (cfg, ptr, target);\n\t\t}\n\t}\n\n\t/* Set method field */\n\tif (!(target_method_context_used || invoke_context_used) || cfg->llvm_only) {\n\t\t//If compiling with gsharing enabled, it's faster to load method the delegate trampoline info than to use a rgctx slot\n\t\tMonoInst *method_ins = emit_get_rgctx_method (cfg, target_method_context_used, method, MONO_RGCTX_INFO_METHOD);\n\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, obj->dreg, MONO_STRUCT_OFFSET (MonoDelegate, method), method_ins->dreg);\n\t}\n\n\t/* \n\t * To avoid looking up the compiled code belonging to the target method\n\t * in mono_delegate_trampoline (), we allocate a per-domain memory slot to\n\t * store it, and we fill it after the method has been compiled.\n\t */\n\tif (!method->dynamic && !(cfg->opt & MONO_OPT_SHARED)) {\n\t\tMonoInst *code_slot_ins;\n\n\t\tif (target_method_context_used) {\n\t\t\tcode_slot_ins = emit_get_rgctx_method (cfg, target_method_context_used, method, MONO_RGCTX_INFO_METHOD_DELEGATE_CODE);\n\t\t} else {\n\t\t\tdomain = mono_domain_get ();\n\t\t\tmono_domain_lock (domain);\n\t\t\tif (!domain_jit_info (domain)->method_code_hash)\n\t\t\t\tdomain_jit_info (domain)->method_code_hash = g_hash_table_new (NULL, NULL);\n\t\t\tcode_slot = (guint8 **)g_hash_table_lookup (domain_jit_info (domain)->method_code_hash, method);\n\t\t\tif (!code_slot) {\n\t\t\t\tcode_slot = (guint8 **)mono_domain_alloc0 (domain, sizeof (gpointer));\n\t\t\t\tg_hash_table_insert (domain_jit_info (domain)->method_code_hash, method, code_slot);\n\t\t\t}\n\t\t\tmono_domain_unlock (domain);\n\n\t\t\tcode_slot_ins = mini_emit_runtime_constant (cfg, MONO_PATCH_INFO_METHOD_CODE_SLOT, method);\n\t\t}\n\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, obj->dreg, MONO_STRUCT_OFFSET (MonoDelegate, method_code), code_slot_ins->dreg);\t\t\n\t}\n\n \tif (cfg->llvm_only) {\n\t\tif (virtual_) {\n\t\t\tMonoInst *args [ ] = {\n\t\t\t\tobj,\n\t\t\t\ttarget,\n\t\t\t\temit_get_rgctx_method (cfg, target_method_context_used, method, MONO_RGCTX_INFO_METHOD)\n\t\t\t};\n\t\t\tmono_emit_jit_icall (cfg, mini_llvmonly_init_delegate_virtual, args);\n\t\t} else {\n\t\t\tmono_emit_jit_icall (cfg, mini_llvmonly_init_delegate, &obj);\n\t\t}\n\n\t\treturn obj;\n\t}\n\tif (target_method_context_used || invoke_context_used) {\n\t\ttramp_ins = emit_get_rgctx_dele_tramp (cfg, target_method_context_used | invoke_context_used, klass, method, virtual_, MONO_RGCTX_INFO_DELEGATE_TRAMP_INFO);\n\n\t\t//This is emited as a contant store for the non-shared case.\n\t\t//We copy from the delegate trampoline info as it's faster than a rgctx fetch\n\t\tdreg = alloc_preg (cfg);\n\t\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, dreg, tramp_ins->dreg, MONO_STRUCT_OFFSET (MonoDelegateTrampInfo, method));\n\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, obj->dreg, MONO_STRUCT_OFFSET (MonoDelegate, method), dreg);\n\t} else if (cfg->compile_aot) {\n\t\tMonoDelegateClassMethodPair *del_tramp;\n\n\t\tdel_tramp = (MonoDelegateClassMethodPair *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoDelegateClassMethodPair));\n\t\tdel_tramp->klass = klass;\n\t\tdel_tramp->method = method;\n\t\tdel_tramp->is_virtual = virtual_;\n\t\tEMIT_NEW_AOTCONST (cfg, tramp_ins, MONO_PATCH_INFO_DELEGATE_TRAMPOLINE, del_tramp);\n\t} else {\n\t\tif (virtual_)\n\t\t\ttrampoline = mono_create_delegate_virtual_trampoline (cfg->domain, klass, method);\n\t\telse\n\t\t\ttrampoline = mono_create_delegate_trampoline_info (cfg->domain, klass, method);\n\t\tEMIT_NEW_PCONST (cfg, tramp_ins, trampoline);\n\t}\n\n\t/* Set invoke_impl field */\n\tif (virtual_) {\n\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, obj->dreg, MONO_STRUCT_OFFSET (MonoDelegate, invoke_impl), tramp_ins->dreg);\n\t} else {\n\t\tdreg = alloc_preg (cfg);\n\t\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, dreg, tramp_ins->dreg, MONO_STRUCT_OFFSET (MonoDelegateTrampInfo, invoke_impl));\n\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, obj->dreg, MONO_STRUCT_OFFSET (MonoDelegate, invoke_impl), dreg);\n\n\t\tdreg = alloc_preg (cfg);\n\t\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, dreg, tramp_ins->dreg, MONO_STRUCT_OFFSET (MonoDelegateTrampInfo, method_ptr));\n\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, obj->dreg, MONO_STRUCT_OFFSET (MonoDelegate, method_ptr), dreg);\n\t}\n\n\tdreg = alloc_preg (cfg);\n\tMONO_EMIT_NEW_ICONST (cfg, dreg, virtual_ ? 1 : 0);\n\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI1_MEMBASE_REG, obj->dreg, MONO_STRUCT_OFFSET (MonoDelegate, method_is_virtual), dreg);\n\n\t/* All the checks which are in mono_delegate_ctor () are done by the delegate trampoline */\n\n\treturn obj;\n}\n\n/*\n * handle_constrained_gsharedvt_call:\n *\n *   Handle constrained calls where the receiver is a gsharedvt type.\n * Return the instruction representing the call. Set the cfg exception on failure.\n */\nstatic MonoInst*\nhandle_constrained_gsharedvt_call (MonoCompile *cfg, MonoMethod *cmethod, MonoMethodSignature *fsig, MonoInst **sp, MonoClass *constrained_class,\n\t\t\t\t\t\t\t\t   gboolean *ref_emit_widen)\n{\n\tMonoInst *ins = NULL;\n\tgboolean emit_widen = *ref_emit_widen;\n\tgboolean supported;\n\n\t/*\n\t * Constrained calls need to behave differently at runtime dependending on whenever the receiver is instantiated as ref type or as a vtype.\n\t * This is hard to do with the current call code, since we would have to emit a branch and two different calls. So instead, we\n\t * pack the arguments into an array, and do the rest of the work in in an icall.\n\t */\n\tsupported = ((cmethod->klass == mono_defaults.object_class) || mono_class_is_interface (cmethod->klass) || (!m_class_is_valuetype (cmethod->klass) && m_class_get_image (cmethod->klass) != mono_defaults.corlib));\n\tif (supported)\n\t\tsupported = (MONO_TYPE_IS_VOID (fsig->ret) || MONO_TYPE_IS_PRIMITIVE (fsig->ret) || MONO_TYPE_IS_REFERENCE (fsig->ret) || MONO_TYPE_ISSTRUCT (fsig->ret) || m_class_is_enumtype (mono_class_from_mono_type_internal (fsig->ret)) || mini_is_gsharedvt_type (fsig->ret));\n\tif (supported) {\n\t\tif (fsig->param_count == 0 || (!fsig->hasthis && fsig->param_count == 1)) {\n\t\t\tsupported = TRUE;\n\t\t} else {\n\t\t\t/* Allow scalar parameters and a gsharedvt first parameter */\n\t\t\tsupported = MONO_TYPE_IS_PRIMITIVE (fsig->params [0]) || MONO_TYPE_IS_REFERENCE (fsig->params [0]) || fsig->params [0]->byref || mini_is_gsharedvt_type (fsig->params [0]);\n\t\t\tif (supported) {\n\t\t\t\tfor (int i = 1; i < fsig->param_count; ++i) {\n\t\t\t\t\tif (!(fsig->params [i]->byref || MONO_TYPE_IS_PRIMITIVE (fsig->params [i]) || MONO_TYPE_IS_REFERENCE (fsig->params [i]) || MONO_TYPE_ISSTRUCT (fsig->params [i])))\n\t\t\t\t\t\tsupported = FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (supported) {\n\t\tMonoInst *args [16];\n\n\t\t/*\n\t\t * This case handles calls to\n\t\t * - object:ToString()/Equals()/GetHashCode(),\n\t\t * - System.IComparable<T>:CompareTo()\n\t\t * - System.IEquatable<T>:Equals ()\n\t\t * plus some simple interface calls enough to support AsyncTaskMethodBuilder.\n\t\t */\n\n\t\targs [0] = sp [0];\n\t\targs [1] = emit_get_rgctx_method (cfg, mono_method_check_context_used (cmethod), cmethod, MONO_RGCTX_INFO_METHOD);\n\t\targs [2] = mini_emit_get_rgctx_klass (cfg, mono_class_check_context_used (constrained_class), constrained_class, MONO_RGCTX_INFO_KLASS);\n\n\t\t/* !fsig->hasthis is for the wrapper for the Object.GetType () icall */\n\t\tif (fsig->hasthis && fsig->param_count) {\n\t\t\t/* Call mono_gsharedvt_constrained_call (gpointer mp, MonoMethod *cmethod, MonoClass *klass, gboolean deref_arg, gpointer *args) */\n\t\t\t/* Pass the arguments using a localloc-ed array using the format expected by runtime_invoke () */\n\t\t\tMONO_INST_NEW (cfg, ins, OP_LOCALLOC_IMM);\n\t\t\tins->dreg = alloc_preg (cfg);\n\t\t\tins->inst_imm = fsig->param_count * sizeof (target_mgreg_t);\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\targs [4] = ins;\n\n\t\t\t/* Only the first argument is allowed to be gsharedvt */\n\t\t\t/* args [3] = deref_arg */\n\t\t\tif (mini_is_gsharedvt_type (fsig->params [0])) {\n\t\t\t\tint deref_arg_reg;\n\t\t\t\tins = mini_emit_get_gsharedvt_info_klass (cfg, mono_class_from_mono_type_internal (fsig->params [0]), MONO_RGCTX_INFO_CLASS_BOX_TYPE);\n\t\t\t\tderef_arg_reg = alloc_preg (cfg);\n\t\t\t\t/* deref_arg = BOX_TYPE != MONO_GSHAREDVT_BOX_TYPE_VTYPE */\n\t\t\t\tEMIT_NEW_BIALU_IMM (cfg, args [3], OP_ISUB_IMM, deref_arg_reg, ins->dreg, 1);\n\t\t\t} else {\n\t\t\t\tEMIT_NEW_ICONST (cfg, args [3], 0);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < fsig->param_count; ++i) {\n\t\t\t\tint addr_reg;\n\n\t\t\t\tif (mini_is_gsharedvt_type (fsig->params [i]) || MONO_TYPE_IS_PRIMITIVE (fsig->params [i]) || MONO_TYPE_ISSTRUCT (fsig->params [i])) {\n\t\t\t\t\tEMIT_NEW_VARLOADA_VREG (cfg, ins, sp [i + 1]->dreg, fsig->params [i]);\n\t\t\t\t\taddr_reg = ins->dreg;\n\t\t\t\t\tEMIT_NEW_STORE_MEMBASE (cfg, ins, OP_STORE_MEMBASE_REG, args [4]->dreg, i * sizeof (target_mgreg_t), addr_reg);\n\t\t\t\t} else {\n\t\t\t\t\tEMIT_NEW_STORE_MEMBASE (cfg, ins, OP_STORE_MEMBASE_REG, args [4]->dreg, i * sizeof (target_mgreg_t), sp [i + 1]->dreg);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tEMIT_NEW_ICONST (cfg, args [3], 0);\n\t\t\tEMIT_NEW_ICONST (cfg, args [4], 0);\n\t\t}\n\t\tins = mono_emit_jit_icall (cfg, mono_gsharedvt_constrained_call, args);\n\t\temit_widen = FALSE;\n\n\t\tif (mini_is_gsharedvt_type (fsig->ret)) {\n\t\t\tins = handle_unbox_gsharedvt (cfg, mono_class_from_mono_type_internal (fsig->ret), ins);\n\t\t} else if (MONO_TYPE_IS_PRIMITIVE (fsig->ret) || MONO_TYPE_ISSTRUCT (fsig->ret) || m_class_is_enumtype (mono_class_from_mono_type_internal (fsig->ret))) {\n\t\t\tMonoInst *add;\n\n\t\t\t/* Unbox */\n\t\t\tNEW_BIALU_IMM (cfg, add, OP_ADD_IMM, alloc_dreg (cfg, STACK_MP), ins->dreg, MONO_ABI_SIZEOF (MonoObject));\n\t\t\tMONO_ADD_INS (cfg->cbb, add);\n\t\t\t/* Load value */\n\t\t\tNEW_LOAD_MEMBASE_TYPE (cfg, ins, fsig->ret, add->dreg, 0);\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t/* ins represents the call result */\n\t\t}\n\t} else {\n\t\tGSHAREDVT_FAILURE (CEE_CALLVIRT);\n\t}\n\n\t*ref_emit_widen = emit_widen;\n\n\treturn ins;\n\n exception_exit:\n\treturn NULL;\n}\n\nstatic void\nmono_emit_load_got_addr (MonoCompile *cfg)\n{\n\tMonoInst *getaddr, *dummy_use;\n\n\tif (!cfg->got_var || cfg->got_var_allocated)\n\t\treturn;\n\n\tMONO_INST_NEW (cfg, getaddr, OP_LOAD_GOTADDR);\n\tgetaddr->cil_code = cfg->header->code;\n\tgetaddr->dreg = cfg->got_var->dreg;\n\n\t/* Add it to the start of the first bblock */\n\tif (cfg->bb_entry->code) {\n\t\tgetaddr->next = cfg->bb_entry->code;\n\t\tcfg->bb_entry->code = getaddr;\n\t}\n\telse\n\t\tMONO_ADD_INS (cfg->bb_entry, getaddr);\n\n\tcfg->got_var_allocated = TRUE;\n\n\t/* \n\t * Add a dummy use to keep the got_var alive, since real uses might\n\t * only be generated by the back ends.\n\t * Add it to end_bblock, so the variable's lifetime covers the whole\n\t * method.\n\t * It would be better to make the usage of the got var explicit in all\n\t * cases when the backend needs it (i.e. calls, throw etc.), so this\n\t * wouldn't be needed.\n\t */\n\tNEW_DUMMY_USE (cfg, dummy_use, cfg->got_var);\n\tMONO_ADD_INS (cfg->bb_exit, dummy_use);\n}\n\nstatic gboolean\nmethod_does_not_return (MonoMethod *method)\n{\n\t// FIXME: Under netcore, these are decorated with the [DoesNotReturn] attribute\n\treturn m_class_get_image (method->klass) == mono_defaults.corlib &&\n\t\t!strcmp (m_class_get_name (method->klass), \"ThrowHelper\") &&\n\t\tstrstr (method->name, \"Throw\") == method->name &&\n\t\t!method->is_inflated;\n}\n\nstatic int inline_limit, llvm_jit_inline_limit, llvm_aot_inline_limit;\nstatic gboolean inline_limit_inited;\n\nstatic gboolean\nmono_method_check_inlining (MonoCompile *cfg, MonoMethod *method)\n{\n\tMonoMethodHeaderSummary header;\n\tMonoVTable *vtable;\n\tint limit;\n#ifdef MONO_ARCH_SOFT_FLOAT_FALLBACK\n\tMonoMethodSignature *sig = mono_method_signature_internal (method);\n\tint i;\n#endif\n\n\tif (cfg->disable_inline)\n\t\treturn FALSE;\n\tif (cfg->gsharedvt)\n\t\treturn FALSE;\n\n\tif (cfg->inline_depth > 10)\n\t\treturn FALSE;\n\n\tif (!mono_method_get_header_summary (method, &header))\n\t\treturn FALSE;\n\n\t/*runtime, icall and pinvoke are checked by summary call*/\n\tif ((method->iflags & METHOD_IMPL_ATTRIBUTE_NOINLINING) ||\n\t    (method->iflags & METHOD_IMPL_ATTRIBUTE_SYNCHRONIZED) ||\n\t    (mono_class_is_marshalbyref (method->klass)) ||\n\t    header.has_clauses)\n\t\treturn FALSE;\n\n\tif (method->flags & METHOD_ATTRIBUTE_REQSECOBJ)\n\t\t/* Used to mark methods containing StackCrawlMark locals */\n\t\treturn FALSE;\n\n\t/* also consider num_locals? */\n\t/* Do the size check early to avoid creating vtables */\n\tif (!inline_limit_inited) {\n\t\tchar *inlinelimit;\n\t\tif ((inlinelimit = g_getenv (\"MONO_INLINELIMIT\"))) {\n\t\t\tinline_limit = atoi (inlinelimit);\n\t\t\tllvm_jit_inline_limit = inline_limit;\n\t\t\tllvm_aot_inline_limit = inline_limit;\n\t\t\tg_free (inlinelimit);\n\t\t} else {\n\t\t\tinline_limit = INLINE_LENGTH_LIMIT;\n\t\t\tllvm_jit_inline_limit = LLVM_JIT_INLINE_LENGTH_LIMIT;\n\t\t\tllvm_aot_inline_limit = LLVM_AOT_INLINE_LENGTH_LIMIT;\n\t\t}\n\t\tinline_limit_inited = TRUE;\n\t}\n\n#ifdef ENABLE_NETCORE\n\tif (COMPILE_LLVM (cfg)) {\n\t\tif (cfg->compile_aot)\n\t\t\tlimit = llvm_aot_inline_limit;\n\t\telse\n\t\t\tlimit = llvm_jit_inline_limit;\n\t} else {\n\t\tlimit = inline_limit;\n\t}\n#else\n\tif (COMPILE_LLVM (cfg) && !cfg->compile_aot)\n\t\tlimit = llvm_jit_inline_limit;\n\telse\n\t\tlimit = inline_limit;\n#endif\n\tif (header.code_size >= limit && !(method->iflags & METHOD_IMPL_ATTRIBUTE_AGGRESSIVE_INLINING))\n\t\treturn FALSE;\n\n\t/*\n\t * if we can initialize the class of the method right away, we do,\n\t * otherwise we don't allow inlining if the class needs initialization,\n\t * since it would mean inserting a call to mono_runtime_class_init()\n\t * inside the inlined code\n\t */\n\tif (cfg->gshared && m_class_has_cctor (method->klass) && mini_class_check_context_used (cfg, method->klass))\n\t\treturn FALSE;\n\n\tif (!(cfg->opt & MONO_OPT_SHARED)) {\n\t\t/* The AggressiveInlining hint is a good excuse to force that cctor to run. */\n\t\tif (method->iflags & METHOD_IMPL_ATTRIBUTE_AGGRESSIVE_INLINING) {\n\t\t\tif (m_class_has_cctor (method->klass)) {\n\t\t\t\tERROR_DECL (error);\n\t\t\t\tvtable = mono_class_vtable_checked (cfg->domain, method->klass, error);\n\t\t\t\tif (!is_ok (error)) {\n\t\t\t\t\tmono_error_cleanup (error);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t\tif (!cfg->compile_aot) {\n\t\t\t\t\tif (!mono_runtime_class_init_full (vtable, error)) {\n\t\t\t\t\t\tmono_error_cleanup (error);\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (mono_class_is_before_field_init (method->klass)) {\n\t\t\tif (cfg->run_cctors && m_class_has_cctor (method->klass)) {\n\t\t\t\tERROR_DECL (error);\n\t\t\t\t/*FIXME it would easier and lazier to just use mono_class_try_get_vtable */\n\t\t\t\tif (!m_class_get_runtime_info (method->klass))\n\t\t\t\t\t/* No vtable created yet */\n\t\t\t\t\treturn FALSE;\n\t\t\t\tvtable = mono_class_vtable_checked (cfg->domain, method->klass, error);\n\t\t\t\tif (!is_ok (error)) {\n\t\t\t\t\tmono_error_cleanup (error);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t\t/* This makes so that inline cannot trigger */\n\t\t\t\t/* .cctors: too many apps depend on them */\n\t\t\t\t/* running with a specific order... */\n\t\t\t\tif (! vtable->initialized)\n\t\t\t\t\treturn FALSE;\n\t\t\t\tif (!mono_runtime_class_init_full (vtable, error)) {\n\t\t\t\t\tmono_error_cleanup (error);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (mono_class_needs_cctor_run (method->klass, NULL)) {\n\t\t\tERROR_DECL (error);\n\t\t\tif (!m_class_get_runtime_info (method->klass))\n\t\t\t\t/* No vtable created yet */\n\t\t\t\treturn FALSE;\n\t\t\tvtable = mono_class_vtable_checked (cfg->domain, method->klass, error);\n\t\t\tif (!is_ok (error)) {\n\t\t\t\tmono_error_cleanup (error);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tif (!vtable->initialized)\n\t\t\t\treturn FALSE;\n\t\t}\n\t} else {\n\t\t/* \n\t\t * If we're compiling for shared code\n\t\t * the cctor will need to be run at aot method load time, for example,\n\t\t * or at the end of the compilation of the inlining method.\n\t\t */\n\t\tif (mono_class_needs_cctor_run (method->klass, NULL) && !mono_class_is_before_field_init (method->klass))\n\t\t\treturn FALSE;\n\t}\n\n#ifdef MONO_ARCH_SOFT_FLOAT_FALLBACK\n\tif (mono_arch_is_soft_float ()) {\n\t\t/* FIXME: */\n\t\tif (sig->ret && sig->ret->type == MONO_TYPE_R4)\n\t\t\treturn FALSE;\n\t\tfor (i = 0; i < sig->param_count; ++i)\n\t\t\tif (!sig->params [i]->byref && sig->params [i]->type == MONO_TYPE_R4)\n\t\t\t\treturn FALSE;\n\t}\n#endif\n\n\tif (g_list_find (cfg->dont_inline, method))\n\t\treturn FALSE;\n\n\tif (mono_profiler_get_call_instrumentation_flags (method))\n\t\treturn FALSE;\n\n\tif (mono_profiler_coverage_instrumentation_enabled (method))\n\t\treturn FALSE;\n\n\tif (method_does_not_return (method))\n\t\treturn FALSE;\n\t\t\n\treturn TRUE;\n}\n\nstatic gboolean\nmini_field_access_needs_cctor_run (MonoCompile *cfg, MonoMethod *method, MonoClass *klass, MonoVTable *vtable)\n{\n\tif (!cfg->compile_aot) {\n\t\tg_assert (vtable);\n\t\tif (vtable->initialized)\n\t\t\treturn FALSE;\n\t}\n\n\tif (mono_class_is_before_field_init (klass)) {\n\t\tif (cfg->method == method)\n\t\t\treturn FALSE;\n\t}\n\n\tif (!mono_class_needs_cctor_run (klass, method))\n\t\treturn FALSE;\n\n\tif (! (method->flags & METHOD_ATTRIBUTE_STATIC) && (klass == method->klass))\n\t\t/* The initialization is already done before the method is called */\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nint\nmini_emit_sext_index_reg (MonoCompile *cfg, MonoInst *index)\n{\n\tint index_reg = index->dreg;\n\tint index2_reg;\n\n#if SIZEOF_REGISTER == 8\n\t/* The array reg is 64 bits but the index reg is only 32 */\n\tif (COMPILE_LLVM (cfg)) {\n\t\t/*\n\t\t * abcrem can't handle the OP_SEXT_I4, so add this after abcrem,\n\t\t * during OP_BOUNDS_CHECK decomposition, and in the implementation\n\t\t * of OP_X86_LEA for llvm.\n\t\t */\n\t\tindex2_reg = index_reg;\n\t} else {\n\t\tindex2_reg = alloc_preg (cfg);\n\t\tMONO_EMIT_NEW_UNALU (cfg, OP_SEXT_I4, index2_reg, index_reg);\n\t}\n#else\n\tif (index->type == STACK_I8) {\n\t\tindex2_reg = alloc_preg (cfg);\n\t\tMONO_EMIT_NEW_UNALU (cfg, OP_LCONV_TO_I4, index2_reg, index_reg);\n\t} else {\n\t\tindex2_reg = index_reg;\n\t}\n#endif\n\n\treturn index2_reg;\n}\n\nMonoInst*\nmini_emit_ldelema_1_ins (MonoCompile *cfg, MonoClass *klass, MonoInst *arr, MonoInst *index, gboolean bcheck)\n{\n\tMonoInst *ins;\n\tguint32 size;\n\tint mult_reg, add_reg, array_reg, index2_reg;\n\tint context_used;\n\n\tif (mini_is_gsharedvt_variable_klass (klass)) {\n\t\tsize = -1;\n\t} else {\n\t\tmono_class_init_internal (klass);\n\t\tsize = mono_class_array_element_size (klass);\n\t}\n\n\tmult_reg = alloc_preg (cfg);\n\tarray_reg = arr->dreg;\n\n\tindex2_reg = mini_emit_sext_index_reg (cfg, index);\n\n\tif (bcheck)\n\t\tMONO_EMIT_BOUNDS_CHECK (cfg, array_reg, MonoArray, max_length, index2_reg);\n\n#if defined(TARGET_X86) || defined(TARGET_AMD64)\n\tif (size == 1 || size == 2 || size == 4 || size == 8) {\n\t\tstatic const int fast_log2 [] = { 1, 0, 1, -1, 2, -1, -1, -1, 3 };\n\n\t\tEMIT_NEW_X86_LEA (cfg, ins, array_reg, index2_reg, fast_log2 [size], MONO_STRUCT_OFFSET (MonoArray, vector));\n\t\tins->klass = klass;\n\t\tins->type = STACK_MP;\n\n\t\treturn ins;\n\t}\n#endif\t\t\n\n\tadd_reg = alloc_ireg_mp (cfg);\n\n\tif (size == -1) {\n\t\tMonoInst *rgctx_ins;\n\n\t\t/* gsharedvt */\n\t\tg_assert (cfg->gshared);\n\t\tcontext_used = mini_class_check_context_used (cfg, klass);\n\t\tg_assert (context_used);\n\t\trgctx_ins = mini_emit_get_gsharedvt_info_klass (cfg, klass, MONO_RGCTX_INFO_ARRAY_ELEMENT_SIZE);\n\t\tMONO_EMIT_NEW_BIALU (cfg, OP_IMUL, mult_reg, index2_reg, rgctx_ins->dreg);\n\t} else {\n\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_MUL_IMM, mult_reg, index2_reg, size);\n\t}\n\tMONO_EMIT_NEW_BIALU (cfg, OP_PADD, add_reg, array_reg, mult_reg);\n\tNEW_BIALU_IMM (cfg, ins, OP_PADD_IMM, add_reg, add_reg, MONO_STRUCT_OFFSET (MonoArray, vector));\n\tins->klass = klass;\n\tins->type = STACK_MP;\n\tMONO_ADD_INS (cfg->cbb, ins);\n\n\treturn ins;\n}\n\nstatic MonoInst*\nmini_emit_ldelema_2_ins (MonoCompile *cfg, MonoClass *klass, MonoInst *arr, MonoInst *index_ins1, MonoInst *index_ins2)\n{\n\tint bounds_reg = alloc_preg (cfg);\n\tint add_reg = alloc_ireg_mp (cfg);\n\tint mult_reg = alloc_preg (cfg);\n\tint mult2_reg = alloc_preg (cfg);\n\tint low1_reg = alloc_preg (cfg);\n\tint low2_reg = alloc_preg (cfg);\n\tint high1_reg = alloc_preg (cfg);\n\tint high2_reg = alloc_preg (cfg);\n\tint realidx1_reg = alloc_preg (cfg);\n\tint realidx2_reg = alloc_preg (cfg);\n\tint sum_reg = alloc_preg (cfg);\n\tint index1, index2;\n\tMonoInst *ins;\n\tguint32 size;\n\n\tmono_class_init_internal (klass);\n\tsize = mono_class_array_element_size (klass);\n\n\tindex1 = index_ins1->dreg;\n\tindex2 = index_ins2->dreg;\n\n#if SIZEOF_REGISTER == 8\n\t/* The array reg is 64 bits but the index reg is only 32 */\n\tif (COMPILE_LLVM (cfg)) {\n\t\t/* Not needed */\n\t} else {\n\t\tint tmpreg = alloc_preg (cfg);\n\t\tMONO_EMIT_NEW_UNALU (cfg, OP_SEXT_I4, tmpreg, index1);\n\t\tindex1 = tmpreg;\n\t\ttmpreg = alloc_preg (cfg);\n\t\tMONO_EMIT_NEW_UNALU (cfg, OP_SEXT_I4, tmpreg, index2);\n\t\tindex2 = tmpreg;\n\t}\n#else\n\t// FIXME: Do we need to do something here for i8 indexes, like in ldelema_1_ins ?\n#endif\n\n\t/* range checking */\n\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, bounds_reg, \n\t\t\t\t       arr->dreg, MONO_STRUCT_OFFSET (MonoArray, bounds));\n\n\tMONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADI4_MEMBASE, low1_reg, \n\t\t\t\t       bounds_reg, MONO_STRUCT_OFFSET (MonoArrayBounds, lower_bound));\n\tMONO_EMIT_NEW_BIALU (cfg, OP_PSUB, realidx1_reg, index1, low1_reg);\n\tMONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADI4_MEMBASE, high1_reg, \n\t\t\t\t       bounds_reg, MONO_STRUCT_OFFSET (MonoArrayBounds, length));\n\tMONO_EMIT_NEW_BIALU (cfg, OP_COMPARE, -1, high1_reg, realidx1_reg);\n\tMONO_EMIT_NEW_COND_EXC (cfg, LE_UN, \"IndexOutOfRangeException\");\n\n\tMONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADI4_MEMBASE, low2_reg, \n\t\t\t\t       bounds_reg, sizeof (MonoArrayBounds) + MONO_STRUCT_OFFSET (MonoArrayBounds, lower_bound));\n\tMONO_EMIT_NEW_BIALU (cfg, OP_PSUB, realidx2_reg, index2, low2_reg);\n\tMONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADI4_MEMBASE, high2_reg, \n\t\t\t\t       bounds_reg, sizeof (MonoArrayBounds) + MONO_STRUCT_OFFSET (MonoArrayBounds, length));\n\tMONO_EMIT_NEW_BIALU (cfg, OP_COMPARE, -1, high2_reg, realidx2_reg);\n\tMONO_EMIT_NEW_COND_EXC (cfg, LE_UN, \"IndexOutOfRangeException\");\n\n\tMONO_EMIT_NEW_BIALU (cfg, OP_PMUL, mult_reg, high2_reg, realidx1_reg);\n\tMONO_EMIT_NEW_BIALU (cfg, OP_PADD, sum_reg, mult_reg, realidx2_reg);\n\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_PMUL_IMM, mult2_reg, sum_reg, size);\n\tMONO_EMIT_NEW_BIALU (cfg, OP_PADD, add_reg, mult2_reg, arr->dreg);\n\tNEW_BIALU_IMM (cfg, ins, OP_PADD_IMM, add_reg, add_reg, MONO_STRUCT_OFFSET (MonoArray, vector));\n\n\tins->type = STACK_MP;\n\tins->klass = klass;\n\tMONO_ADD_INS (cfg->cbb, ins);\n\n\treturn ins;\n}\n\nstatic MonoInst*\nmini_emit_ldelema_ins (MonoCompile *cfg, MonoMethod *cmethod, MonoInst **sp, guchar *ip, gboolean is_set)\n{\n\tint rank;\n\tMonoInst *addr;\n\tMonoMethod *addr_method;\n\tint element_size;\n\tMonoClass *eclass = m_class_get_element_class (cmethod->klass);\n\n\trank = mono_method_signature_internal (cmethod)->param_count - (is_set? 1: 0);\n\n\tif (rank == 1)\n\t\treturn mini_emit_ldelema_1_ins (cfg, eclass, sp [0], sp [1], TRUE);\n\n\t/* emit_ldelema_2 depends on OP_LMUL */\n\tif (!cfg->backend->emulate_mul_div && rank == 2 && (cfg->opt & MONO_OPT_INTRINS) && !mini_is_gsharedvt_variable_klass (eclass)) {\n\t\treturn mini_emit_ldelema_2_ins (cfg, eclass, sp [0], sp [1], sp [2]);\n\t}\n\n\tif (mini_is_gsharedvt_variable_klass (eclass))\n\t\telement_size = 0;\n\telse\n\t\telement_size = mono_class_array_element_size (eclass);\n\taddr_method = mono_marshal_get_array_address (rank, element_size);\n\taddr = mono_emit_method_call (cfg, addr_method, sp, NULL);\n\n\treturn addr;\n}\n\nstatic gboolean\nmini_class_is_reference (MonoClass *klass)\n{\n\treturn mini_type_is_reference (m_class_get_byval_arg (klass));\n}\n\nMonoInst*\nmini_emit_array_store (MonoCompile *cfg, MonoClass *klass, MonoInst **sp, gboolean safety_checks)\n{\n\tif (safety_checks && mini_class_is_reference (klass) &&\n\t\t!(MONO_INS_IS_PCONST_NULL (sp [2]))) {\n\t\tMonoClass *obj_array = mono_array_class_get_cached (mono_defaults.object_class, 1);\n\t\tMonoMethod *helper = mono_marshal_get_virtual_stelemref (obj_array);\n\t\tMonoInst *iargs [3];\n\n\t\tif (!helper->slot)\n\t\t\tmono_class_setup_vtable (obj_array);\n\t\tg_assert (helper->slot);\n\n\t\tif (sp [0]->type != STACK_OBJ)\n\t\t\treturn NULL;\n\t\tif (sp [2]->type != STACK_OBJ)\n\t\t\treturn NULL;\n\n\t\tiargs [2] = sp [2];\n\t\tiargs [1] = sp [1];\n\t\tiargs [0] = sp [0];\n\n\t\treturn mono_emit_method_call (cfg, helper, iargs, sp [0]);\n\t} else {\n\t\tMonoInst *ins;\n\n\t\tif (mini_is_gsharedvt_variable_klass (klass)) {\n\t\t\tMonoInst *addr;\n\n\t\t\t// FIXME-VT: OP_ICONST optimization\n\t\t\taddr = mini_emit_ldelema_1_ins (cfg, klass, sp [0], sp [1], TRUE);\n\t\t\tEMIT_NEW_STORE_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (klass), addr->dreg, 0, sp [2]->dreg);\n\t\t\tins->opcode = OP_STOREV_MEMBASE;\n\t\t} else if (sp [1]->opcode == OP_ICONST) {\n\t\t\tint array_reg = sp [0]->dreg;\n\t\t\tint index_reg = sp [1]->dreg;\n\t\t\tint offset = (mono_class_array_element_size (klass) * sp [1]->inst_c0) + MONO_STRUCT_OFFSET (MonoArray, vector);\n\n\t\t\tif (SIZEOF_REGISTER == 8 && COMPILE_LLVM (cfg) && sp [1]->inst_c0 < 0)\n\t\t\t\tMONO_EMIT_NEW_UNALU (cfg, OP_ZEXT_I4, index_reg, index_reg);\n\n\t\t\tif (safety_checks)\n\t\t\t\tMONO_EMIT_BOUNDS_CHECK (cfg, array_reg, MonoArray, max_length, index_reg);\n\t\t\tEMIT_NEW_STORE_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (klass), array_reg, offset, sp [2]->dreg);\n\t\t} else {\n\t\t\tMonoInst *addr = mini_emit_ldelema_1_ins (cfg, klass, sp [0], sp [1], safety_checks);\n\t\t\tif (!mini_debug_options.weak_memory_model && mini_class_is_reference (klass))\n\t\t\t\tmini_emit_memory_barrier (cfg, MONO_MEMORY_BARRIER_REL);\n\t\t\tEMIT_NEW_STORE_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (klass), addr->dreg, 0, sp [2]->dreg);\n\t\t\tif (mini_class_is_reference (klass))\n\t\t\t\tmini_emit_write_barrier (cfg, addr, sp [2]);\n\t\t}\n\t\treturn ins;\n\t}\n}\n\nMonoInst*\nmini_emit_memory_barrier (MonoCompile *cfg, int kind)\n{\n\tMonoInst *ins = NULL;\n\tMONO_INST_NEW (cfg, ins, OP_MEMORY_BARRIER);\n\tMONO_ADD_INS (cfg->cbb, ins);\n\tins->backend.memory_barrier_kind = kind;\n\n\treturn ins;\n}\n\n/*\n * This entry point could be used later for arbitrary method\n * redirection.\n */\ninline static MonoInst*\nmini_redirect_call (MonoCompile *cfg, MonoMethod *method,  \n\t\t\t\t\tMonoMethodSignature *signature, MonoInst **args, MonoInst *this_ins)\n{\n\tif (method->klass == mono_defaults.string_class) {\n\t\t/* managed string allocation support */\n\t\tif (strcmp (method->name, \"InternalAllocateStr\") == 0 && !(cfg->opt & MONO_OPT_SHARED)) {\n\t\t\tMonoInst *iargs [2];\n\t\t\tMonoVTable *vtable = mono_class_vtable_checked (cfg->domain, method->klass, cfg->error);\n\t\t\tMonoMethod *managed_alloc = NULL;\n\n\t\t\tmono_error_assert_ok (cfg->error); /*Should not fail since it System.String*/\n#ifndef MONO_CROSS_COMPILE\n\t\t\tmanaged_alloc = mono_gc_get_managed_allocator (method->klass, FALSE, FALSE);\n#endif\n\t\t\tif (!managed_alloc)\n\t\t\t\treturn NULL;\n\t\t\tEMIT_NEW_VTABLECONST (cfg, iargs [0], vtable);\n\t\t\tiargs [1] = args [0];\n\t\t\treturn mono_emit_method_call (cfg, managed_alloc, iargs, this_ins);\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void\nmono_save_args (MonoCompile *cfg, MonoMethodSignature *sig, MonoInst **sp)\n{\n\tMonoInst *store, *temp;\n\tint i;\n\n\tfor (i = 0; i < sig->param_count + sig->hasthis; ++i) {\n\t\tMonoType *argtype = (sig->hasthis && (i == 0)) ? type_from_stack_type (*sp) : sig->params [i - sig->hasthis];\n\n\t\t/*\n\t\t * FIXME: We should use *args++ = sp [0], but that would mean the arg\n\t\t * would be different than the MonoInst's used to represent arguments, and\n\t\t * the ldelema implementation can't deal with that.\n\t\t * Solution: When ldelema is used on an inline argument, create a var for \n\t\t * it, emit ldelema on that var, and emit the saving code below in\n\t\t * inline_method () if needed.\n\t\t */\n\t\ttemp = mono_compile_create_var (cfg, argtype, OP_LOCAL);\n\t\tcfg->args [i] = temp;\n\t\t/* This uses cfg->args [i] which is set by the preceeding line */\n\t\tEMIT_NEW_ARGSTORE (cfg, store, i, *sp);\n\t\tstore->cil_code = sp [0]->cil_code;\n\t\tsp++;\n\t}\n}\n\n#define MONO_INLINE_CALLED_LIMITED_METHODS 1\n#define MONO_INLINE_CALLER_LIMITED_METHODS 1\n\n#if (MONO_INLINE_CALLED_LIMITED_METHODS)\nstatic gboolean\ncheck_inline_called_method_name_limit (MonoMethod *called_method)\n{\n\tint strncmp_result;\n\tstatic const char *limit = NULL;\n\t\n\tif (limit == NULL) {\n\t\tconst char *limit_string = g_getenv (\"MONO_INLINE_CALLED_METHOD_NAME_LIMIT\");\n\n\t\tif (limit_string != NULL)\n\t\t\tlimit = limit_string;\n\t\telse\n\t\t\tlimit = \"\";\n\t}\n\n\tif (limit [0] != '\\0') {\n\t\tchar *called_method_name = mono_method_full_name (called_method, TRUE);\n\n\t\tstrncmp_result = strncmp (called_method_name, limit, strlen (limit));\n\t\tg_free (called_method_name);\n\t\n\t\t//return (strncmp_result <= 0);\n\t\treturn (strncmp_result == 0);\n\t} else {\n\t\treturn TRUE;\n\t}\n}\n#endif\n\n#if (MONO_INLINE_CALLER_LIMITED_METHODS)\nstatic gboolean\ncheck_inline_caller_method_name_limit (MonoMethod *caller_method)\n{\n\tint strncmp_result;\n\tstatic const char *limit = NULL;\n\t\n\tif (limit == NULL) {\n\t\tconst char *limit_string = g_getenv (\"MONO_INLINE_CALLER_METHOD_NAME_LIMIT\");\n\t\tif (limit_string != NULL) {\n\t\t\tlimit = limit_string;\n\t\t} else {\n\t\t\tlimit = \"\";\n\t\t}\n\t}\n\n\tif (limit [0] != '\\0') {\n\t\tchar *caller_method_name = mono_method_full_name (caller_method, TRUE);\n\n\t\tstrncmp_result = strncmp (caller_method_name, limit, strlen (limit));\n\t\tg_free (caller_method_name);\n\t\n\t\t//return (strncmp_result <= 0);\n\t\treturn (strncmp_result == 0);\n\t} else {\n\t\treturn TRUE;\n\t}\n}\n#endif\n\nstatic void\nemit_init_rvar (MonoCompile *cfg, int dreg, MonoType *rtype)\n{\n\tstatic double r8_0 = 0.0;\n\tstatic float r4_0 = 0.0;\n\tMonoInst *ins;\n\tint t;\n\n\trtype = mini_get_underlying_type (rtype);\n\tt = rtype->type;\n\n\tif (rtype->byref) {\n\t\tMONO_EMIT_NEW_PCONST (cfg, dreg, NULL);\n\t} else if (t >= MONO_TYPE_BOOLEAN && t <= MONO_TYPE_U4) {\n\t\tMONO_EMIT_NEW_ICONST (cfg, dreg, 0);\n\t} else if (t == MONO_TYPE_I8 || t == MONO_TYPE_U8) {\n\t\tMONO_EMIT_NEW_I8CONST (cfg, dreg, 0);\n\t} else if (cfg->r4fp && t == MONO_TYPE_R4) {\n\t\tMONO_INST_NEW (cfg, ins, OP_R4CONST);\n\t\tins->type = STACK_R4;\n\t\tins->inst_p0 = (void*)&r4_0;\n\t\tins->dreg = dreg;\n\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t} else if (t == MONO_TYPE_R4 || t == MONO_TYPE_R8) {\n\t\tMONO_INST_NEW (cfg, ins, OP_R8CONST);\n\t\tins->type = STACK_R8;\n\t\tins->inst_p0 = (void*)&r8_0;\n\t\tins->dreg = dreg;\n\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t} else if ((t == MONO_TYPE_VALUETYPE) || (t == MONO_TYPE_TYPEDBYREF) ||\n\t\t   ((t == MONO_TYPE_GENERICINST) && mono_type_generic_inst_is_valuetype (rtype))) {\n\t\tMONO_EMIT_NEW_VZERO (cfg, dreg, mono_class_from_mono_type_internal (rtype));\n\t} else if (((t == MONO_TYPE_VAR) || (t == MONO_TYPE_MVAR)) && mini_type_var_is_vt (rtype)) {\n\t\tMONO_EMIT_NEW_VZERO (cfg, dreg, mono_class_from_mono_type_internal (rtype));\n\t} else {\n\t\tMONO_EMIT_NEW_PCONST (cfg, dreg, NULL);\n\t}\n}\n\nstatic void\nemit_dummy_init_rvar (MonoCompile *cfg, int dreg, MonoType *rtype)\n{\n\tint t;\n\n\trtype = mini_get_underlying_type (rtype);\n\tt = rtype->type;\n\n\tif (rtype->byref) {\n\t\tMONO_EMIT_NEW_DUMMY_INIT (cfg, dreg, OP_DUMMY_PCONST);\n\t} else if (t >= MONO_TYPE_BOOLEAN && t <= MONO_TYPE_U4) {\n\t\tMONO_EMIT_NEW_DUMMY_INIT (cfg, dreg, OP_DUMMY_ICONST);\n\t} else if (t == MONO_TYPE_I8 || t == MONO_TYPE_U8) {\n\t\tMONO_EMIT_NEW_DUMMY_INIT (cfg, dreg, OP_DUMMY_I8CONST);\n\t} else if (cfg->r4fp && t == MONO_TYPE_R4) {\n\t\tMONO_EMIT_NEW_DUMMY_INIT (cfg, dreg, OP_DUMMY_R4CONST);\n\t} else if (t == MONO_TYPE_R4 || t == MONO_TYPE_R8) {\n\t\tMONO_EMIT_NEW_DUMMY_INIT (cfg, dreg, OP_DUMMY_R8CONST);\n\t} else if ((t == MONO_TYPE_VALUETYPE) || (t == MONO_TYPE_TYPEDBYREF) ||\n\t\t   ((t == MONO_TYPE_GENERICINST) && mono_type_generic_inst_is_valuetype (rtype))) {\n\t\tMONO_EMIT_NEW_DUMMY_INIT (cfg, dreg, OP_DUMMY_VZERO);\n\t} else if (((t == MONO_TYPE_VAR) || (t == MONO_TYPE_MVAR)) && mini_type_var_is_vt (rtype)) {\n\t\tMONO_EMIT_NEW_DUMMY_INIT (cfg, dreg, OP_DUMMY_VZERO);\n\t} else {\n\t\temit_init_rvar (cfg, dreg, rtype);\n\t}\n}\n\n/* If INIT is FALSE, emit dummy initialization statements to keep the IR valid */\nstatic void\nemit_init_local (MonoCompile *cfg, int local, MonoType *type, gboolean init)\n{\n\tMonoInst *var = cfg->locals [local];\n\tif (COMPILE_SOFT_FLOAT (cfg)) {\n\t\tMonoInst *store;\n\t\tint reg = alloc_dreg (cfg, (MonoStackType)var->type);\n\t\temit_init_rvar (cfg, reg, type);\n\t\tEMIT_NEW_LOCSTORE (cfg, store, local, cfg->cbb->last_ins);\n\t} else {\n\t\tif (init)\n\t\t\temit_init_rvar (cfg, var->dreg, type);\n\t\telse\n\t\t\temit_dummy_init_rvar (cfg, var->dreg, type);\n\t}\n}\n\nint\nmini_inline_method (MonoCompile *cfg, MonoMethod *cmethod, MonoMethodSignature *fsig, MonoInst **sp, guchar *ip, guint real_offset, gboolean inline_always)\n{\n\treturn inline_method (cfg, cmethod, fsig, sp, ip, real_offset, inline_always);\n}\n\n/*\n * inline_method:\n *\n * Return the cost of inlining CMETHOD, or zero if it should not be inlined.\n */\nstatic int\ninline_method (MonoCompile *cfg, MonoMethod *cmethod, MonoMethodSignature *fsig, MonoInst **sp,\n\t       guchar *ip, guint real_offset, gboolean inline_always)\n{\n\tERROR_DECL (error);\n\tMonoInst *ins, *rvar = NULL;\n\tMonoMethodHeader *cheader;\n\tMonoBasicBlock *ebblock, *sbblock;\n\tint i, costs;\n\tMonoInst **prev_locals, **prev_args;\n\tMonoType **prev_arg_types;\n\tguint prev_real_offset;\n\tGHashTable *prev_cbb_hash;\n\tMonoBasicBlock **prev_cil_offset_to_bb;\n\tMonoBasicBlock *prev_cbb;\n\tconst guchar *prev_ip;\n\tguchar *prev_cil_start;\n\tguint32 prev_cil_offset_to_bb_len;\n\tMonoMethod *prev_current_method;\n\tMonoGenericContext *prev_generic_context;\n\tgboolean ret_var_set, prev_ret_var_set, prev_disable_inline, virtual_ = FALSE;\n\n\tg_assert (cfg->exception_type == MONO_EXCEPTION_NONE);\n\n#if (MONO_INLINE_CALLED_LIMITED_METHODS)\n\tif ((! inline_always) && ! check_inline_called_method_name_limit (cmethod))\n\t\treturn 0;\n#endif\n#if (MONO_INLINE_CALLER_LIMITED_METHODS)\n\tif ((! inline_always) && ! check_inline_caller_method_name_limit (cfg->method))\n\t\treturn 0;\n#endif\n\n\tif (!fsig)\n\t\tfsig = mono_method_signature_internal (cmethod);\n\n\tif (cfg->verbose_level > 2)\n\t\tprintf (\"INLINE START %p %s -> %s\\n\", cmethod,  mono_method_full_name (cfg->method, TRUE), mono_method_full_name (cmethod, TRUE));\n\n\tif (!cmethod->inline_info) {\n\t\tcfg->stat_inlineable_methods++;\n\t\tcmethod->inline_info = 1;\n\t}\n\n\t/* allocate local variables */\n\tcheader = mono_method_get_header_checked (cmethod, error);\n\tif (!cheader) {\n\t\tif (inline_always) {\n\t\t\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_MONO_ERROR);\n\t\t\tmono_error_move (cfg->error, error);\n\t\t} else {\n\t\t\tmono_error_cleanup (error);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*Must verify before creating locals as it can cause the JIT to assert.*/\n\tif (mono_compile_is_broken (cfg, cmethod, FALSE)) {\n\t\tmono_metadata_free_mh (cheader);\n\t\treturn 0;\n\t}\n\n\t/* allocate space to store the return value */\n\tif (!MONO_TYPE_IS_VOID (fsig->ret)) {\n\t\trvar = mono_compile_create_var (cfg, fsig->ret, OP_LOCAL);\n\t}\n\n\tprev_locals = cfg->locals;\n\tcfg->locals = (MonoInst **)mono_mempool_alloc0 (cfg->mempool, cheader->num_locals * sizeof (MonoInst*));\n\tfor (i = 0; i < cheader->num_locals; ++i)\n\t\tcfg->locals [i] = mono_compile_create_var (cfg, cheader->locals [i], OP_LOCAL);\n\n\t/* allocate start and end blocks */\n\t/* This is needed so if the inline is aborted, we can clean up */\n\tNEW_BBLOCK (cfg, sbblock);\n\tsbblock->real_offset = real_offset;\n\n\tNEW_BBLOCK (cfg, ebblock);\n\tebblock->block_num = cfg->num_bblocks++;\n\tebblock->real_offset = real_offset;\n\n\tprev_args = cfg->args;\n\tprev_arg_types = cfg->arg_types;\n\tprev_ret_var_set = cfg->ret_var_set;\n\tprev_real_offset = cfg->real_offset;\n\tprev_cbb_hash = cfg->cbb_hash;\n\tprev_cil_offset_to_bb = cfg->cil_offset_to_bb;\n\tprev_cil_offset_to_bb_len = cfg->cil_offset_to_bb_len;\n\tprev_cil_start = cfg->cil_start;\n\tprev_ip = cfg->ip;\n\tprev_cbb = cfg->cbb;\n\tprev_current_method = cfg->current_method;\n\tprev_generic_context = cfg->generic_context;\n\tprev_disable_inline = cfg->disable_inline;\n\n\tcfg->ret_var_set = FALSE;\n\tcfg->inline_depth ++;\n\n\tif (ip && *ip == CEE_CALLVIRT && !(cmethod->flags & METHOD_ATTRIBUTE_STATIC))\n\t\tvirtual_ = TRUE;\n\n\tcosts = mono_method_to_ir (cfg, cmethod, sbblock, ebblock, rvar, sp, real_offset, virtual_);\n\n\tret_var_set = cfg->ret_var_set;\n\n\tcfg->real_offset = prev_real_offset;\n\tcfg->cbb_hash = prev_cbb_hash;\n\tcfg->cil_offset_to_bb = prev_cil_offset_to_bb;\n\tcfg->cil_offset_to_bb_len = prev_cil_offset_to_bb_len;\n\tcfg->cil_start = prev_cil_start;\n\tcfg->ip = prev_ip;\n\tcfg->locals = prev_locals;\n\tcfg->args = prev_args;\n\tcfg->arg_types = prev_arg_types;\n\tcfg->current_method = prev_current_method;\n\tcfg->generic_context = prev_generic_context;\n\tcfg->ret_var_set = prev_ret_var_set;\n\tcfg->disable_inline = prev_disable_inline;\n\tcfg->inline_depth --;\n\n\tif ((costs >= 0 && costs < 60) || inline_always || (costs >= 0 && (cmethod->iflags & METHOD_IMPL_ATTRIBUTE_AGGRESSIVE_INLINING))) {\n\t\tif (cfg->verbose_level > 2)\n\t\t\tprintf (\"INLINE END %s -> %s\\n\", mono_method_full_name (cfg->method, TRUE), mono_method_full_name (cmethod, TRUE));\n\n\t\tmono_error_assert_ok (cfg->error);\n\n\t\tcfg->stat_inlined_methods++;\n\n\t\t/* always add some code to avoid block split failures */\n\t\tMONO_INST_NEW (cfg, ins, OP_NOP);\n\t\tMONO_ADD_INS (prev_cbb, ins);\n\n\t\tprev_cbb->next_bb = sbblock;\n\t\tlink_bblock (cfg, prev_cbb, sbblock);\n\n\t\t/* \n\t\t * Get rid of the begin and end bblocks if possible to aid local\n\t\t * optimizations.\n\t\t */\n\t\tif (prev_cbb->out_count == 1)\n\t\t\tmono_merge_basic_blocks (cfg, prev_cbb, sbblock);\n\n\t\tif ((prev_cbb->out_count == 1) && (prev_cbb->out_bb [0]->in_count == 1) && (prev_cbb->out_bb [0] != ebblock))\n\t\t\tmono_merge_basic_blocks (cfg, prev_cbb, prev_cbb->out_bb [0]);\n\n\t\tif ((ebblock->in_count == 1) && ebblock->in_bb [0]->out_count == 1) {\n\t\t\tMonoBasicBlock *prev = ebblock->in_bb [0];\n\n\t\t\tif (prev->next_bb == ebblock) {\n\t\t\t\tmono_merge_basic_blocks (cfg, prev, ebblock);\n\t\t\t\tcfg->cbb = prev;\n\t\t\t\tif ((prev_cbb->out_count == 1) && (prev_cbb->out_bb [0]->in_count == 1) && (prev_cbb->out_bb [0] == prev)) {\n\t\t\t\t\tmono_merge_basic_blocks (cfg, prev_cbb, prev);\n\t\t\t\t\tcfg->cbb = prev_cbb;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* There could be a bblock after 'prev', and making 'prev' the current bb could cause problems */\n\t\t\t\tcfg->cbb = ebblock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* \n\t\t\t * Its possible that the rvar is set in some prev bblock, but not in others.\n\t\t\t * (#1835).\n\t\t\t */\n\t\t\tif (rvar) {\n\t\t\t\tMonoBasicBlock *bb;\n\n\t\t\t\tfor (i = 0; i < ebblock->in_count; ++i) {\n\t\t\t\t\tbb = ebblock->in_bb [i];\n\n\t\t\t\t\tif (bb->last_ins && bb->last_ins->opcode == OP_NOT_REACHED) {\n\t\t\t\t\t\tcfg->cbb = bb;\n\n\t\t\t\t\t\temit_init_rvar (cfg, rvar->dreg, fsig->ret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcfg->cbb = ebblock;\n\t\t}\n\n\t\tif (rvar) {\n\t\t\t/*\n\t\t\t * If the inlined method contains only a throw, then the ret var is not \n\t\t\t * set, so set it to a dummy value.\n\t\t\t */\n\t\t\tif (!ret_var_set)\n\t\t\t\temit_init_rvar (cfg, rvar->dreg, fsig->ret);\n\n\t\t\tEMIT_NEW_TEMPLOAD (cfg, ins, rvar->inst_c0);\n\t\t\t*sp++ = ins;\n\t\t}\n\t\tcfg->headers_to_free = g_slist_prepend_mempool (cfg->mempool, cfg->headers_to_free, cheader);\n\t\treturn costs + 1;\n\t} else {\n\t\tif (cfg->verbose_level > 2) {\n\t\t\tconst char *msg = mono_error_get_message (cfg->error);\n\t\t\tprintf (\"INLINE ABORTED %s (cost %d) %s\\n\", mono_method_full_name (cmethod, TRUE), costs, msg ? msg : \"\");\n\t\t}\n\t\tcfg->exception_type = MONO_EXCEPTION_NONE;\n\n\t\tclear_cfg_error (cfg);\n\n\t\t/* This gets rid of the newly added bblocks */\n\t\tcfg->cbb = prev_cbb;\n\t}\n\tcfg->headers_to_free = g_slist_prepend_mempool (cfg->mempool, cfg->headers_to_free, cheader);\n\treturn 0;\n}\n\n/*\n * Some of these comments may well be out-of-date.\n * Design decisions: we do a single pass over the IL code (and we do bblock \n * splitting/merging in the few cases when it's required: a back jump to an IL\n * address that was not already seen as bblock starting point).\n * Code is validated as we go (full verification is still better left to metadata/verify.c).\n * Complex operations are decomposed in simpler ones right away. We need to let the \n * arch-specific code peek and poke inside this process somehow (except when the \n * optimizations can take advantage of the full semantic info of coarse opcodes).\n * All the opcodes of the form opcode.s are 'normalized' to opcode.\n * MonoInst->opcode initially is the IL opcode or some simplification of that \n * (OP_LOAD, OP_STORE). The arch-specific code may rearrange it to an arch-specific \n * opcode with value bigger than OP_LAST.\n * At this point the IR can be handed over to an interpreter, a dumb code generator\n * or to the optimizing code generator that will translate it to SSA form.\n *\n * Profiling directed optimizations.\n * We may compile by default with few or no optimizations and instrument the code\n * or the user may indicate what methods to optimize the most either in a config file\n * or through repeated runs where the compiler applies offline the optimizations to \n * each method and then decides if it was worth it.\n */\n\n#define CHECK_TYPE(ins) if (!(ins)->type) UNVERIFIED\n#define CHECK_STACK(num) if ((sp - stack_start) < (num)) UNVERIFIED\n#define CHECK_STACK_OVF() if (((sp - stack_start) + 1) > header->max_stack) UNVERIFIED\n#define CHECK_ARG(num) if ((unsigned)(num) >= (unsigned)num_args) UNVERIFIED\n#define CHECK_LOCAL(num) if ((unsigned)(num) >= (unsigned)header->num_locals) UNVERIFIED\n#define CHECK_OPSIZE(size) if ((size) < 1 || ip + (size) > end) UNVERIFIED\n#define CHECK_UNVERIFIABLE(cfg) if (cfg->unverifiable) UNVERIFIED\n#define CHECK_TYPELOAD(klass) if (!(klass) || mono_class_has_failure (klass)) TYPE_LOAD_ERROR ((klass))\n\n/* offset from br.s -> br like opcodes */\n#define BIG_BRANCH_OFFSET 13\n\nstatic gboolean\nip_in_bb (MonoCompile *cfg, MonoBasicBlock *bb, const guint8* ip)\n{\n\tMonoBasicBlock *b = cfg->cil_offset_to_bb [ip - cfg->cil_start];\n\n\treturn b == NULL || b == bb;\n}\n\nstatic int\nget_basic_blocks (MonoCompile *cfg, MonoMethodHeader* header, guint real_offset, guchar *start, guchar *end, guchar **pos)\n{\n\tguchar *ip = start;\n\tguchar *target;\n\tint i;\n\tguint cli_addr;\n\tMonoBasicBlock *bblock;\n\tconst MonoOpcode *opcode;\n\n\twhile (ip < end) {\n\t\tcli_addr = ip - start;\n\t\ti = mono_opcode_value ((const guint8 **)&ip, end);\n\t\tif (i < 0)\n\t\t\tUNVERIFIED;\n\t\topcode = &mono_opcodes [i];\n\t\tswitch (opcode->argument) {\n\t\tcase MonoInlineNone:\n\t\t\tip++; \n\t\t\tbreak;\n\t\tcase MonoInlineString:\n\t\tcase MonoInlineType:\n\t\tcase MonoInlineField:\n\t\tcase MonoInlineMethod:\n\t\tcase MonoInlineTok:\n\t\tcase MonoInlineSig:\n\t\tcase MonoShortInlineR:\n\t\tcase MonoInlineI:\n\t\t\tip += 5;\n\t\t\tbreak;\n\t\tcase MonoInlineVar:\n\t\t\tip += 3;\n\t\t\tbreak;\n\t\tcase MonoShortInlineVar:\n\t\tcase MonoShortInlineI:\n\t\t\tip += 2;\n\t\t\tbreak;\n\t\tcase MonoShortInlineBrTarget:\n\t\t\ttarget = start + cli_addr + 2 + (signed char)ip [1];\n\t\t\tGET_BBLOCK (cfg, bblock, target);\n\t\t\tip += 2;\n\t\t\tif (ip < end)\n\t\t\t\tGET_BBLOCK (cfg, bblock, ip);\n\t\t\tbreak;\n\t\tcase MonoInlineBrTarget:\n\t\t\ttarget = start + cli_addr + 5 + (gint32)read32 (ip + 1);\n\t\t\tGET_BBLOCK (cfg, bblock, target);\n\t\t\tip += 5;\n\t\t\tif (ip < end)\n\t\t\t\tGET_BBLOCK (cfg, bblock, ip);\n\t\t\tbreak;\n\t\tcase MonoInlineSwitch: {\n\t\t\tguint32 n = read32 (ip + 1);\n\t\t\tguint32 j;\n\t\t\tip += 5;\n\t\t\tcli_addr += 5 + 4 * n;\n\t\t\ttarget = start + cli_addr;\n\t\t\tGET_BBLOCK (cfg, bblock, target);\n\t\t\t\n\t\t\tfor (j = 0; j < n; ++j) {\n\t\t\t\ttarget = start + cli_addr + (gint32)read32 (ip);\n\t\t\t\tGET_BBLOCK (cfg, bblock, target);\n\t\t\t\tip += 4;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase MonoInlineR:\n\t\tcase MonoInlineI8:\n\t\t\tip += 9;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tif (i == CEE_THROW) {\n\t\t\tguchar *bb_start = ip - 1;\n\t\t\t\n\t\t\t/* Find the start of the bblock containing the throw */\n\t\t\tbblock = NULL;\n\t\t\twhile ((bb_start >= start) && !bblock) {\n\t\t\t\tbblock = cfg->cil_offset_to_bb [(bb_start) - start];\n\t\t\t\tbb_start --;\n\t\t\t}\n\t\t\tif (bblock)\n\t\t\t\tbblock->out_of_line = 1;\n\t\t}\n\t}\n\treturn 0;\nunverified:\nexception_exit:\n\t*pos = ip;\n\treturn 1;\n}\n\nstatic MonoMethod *\nmini_get_method_allow_open (MonoMethod *m, guint32 token, MonoClass *klass, MonoGenericContext *context, MonoError *error)\n{\n\tMonoMethod *method;\n\n\terror_init (error);\n\n\tif (m->wrapper_type != MONO_WRAPPER_NONE) {\n\t\tmethod = (MonoMethod *)mono_method_get_wrapper_data (m, token);\n\t\tif (context) {\n\t\t\tmethod = mono_class_inflate_generic_method_checked (method, context, error);\n\t\t}\n\t} else {\n\t\tmethod = mono_get_method_checked (m_class_get_image (m->klass), token, klass, context, error);\n\t}\n\n\treturn method;\n}\n\nstatic MonoMethod *\nmini_get_method (MonoCompile *cfg, MonoMethod *m, guint32 token, MonoClass *klass, MonoGenericContext *context)\n{\n\tERROR_DECL (error);\n\tMonoMethod *method = mini_get_method_allow_open (m, token, klass, context, cfg ? cfg->error : error);\n\n\tif (method && cfg && !cfg->gshared && mono_class_is_open_constructed_type (m_class_get_byval_arg (method->klass))) {\n\t\tmono_error_set_bad_image (cfg->error, m_class_get_image (cfg->method->klass), \"Method with open type while not compiling gshared\");\n\t\tmethod = NULL;\n\t}\n\n\tif (!method && !cfg)\n\t\tmono_error_cleanup (error); /* FIXME don't swallow the error */\n\n\treturn method;\n}\n\nstatic MonoMethodSignature*\nmini_get_signature (MonoMethod *method, guint32 token, MonoGenericContext *context, MonoError *error)\n{\n\tMonoMethodSignature *fsig;\n\n\terror_init (error);\n\tif (method->wrapper_type != MONO_WRAPPER_NONE) {\n\t\tfsig = (MonoMethodSignature *)mono_method_get_wrapper_data (method, token);\n\t} else {\n\t\tfsig = mono_metadata_parse_signature_checked (m_class_get_image (method->klass), token, error);\n\t\treturn_val_if_nok (error, NULL);\n\t}\n\tif (context) {\n\t\tfsig = mono_inflate_generic_signature(fsig, context, error);\n\t}\n\treturn fsig;\n}\n\nstatic MonoMethod*\nthrow_exception (void)\n{\n\tstatic MonoMethod *method = NULL;\n\n\tif (!method) {\n\t\tMonoSecurityManager *secman = mono_security_manager_get_methods ();\n\t\tmethod = get_method_nofail (secman->securitymanager, \"ThrowException\", 1, 0);\n\t}\n\tg_assert (method);\n\treturn method;\n}\n\nstatic void\nemit_throw_exception (MonoCompile *cfg, MonoException *ex)\n{\n\tMonoMethod *thrower = throw_exception ();\n\tMonoInst *args [1];\n\n\tEMIT_NEW_PCONST (cfg, args [0], ex);\n\tmono_emit_method_call (cfg, thrower, args, NULL);\n}\n\n/*\n * Return the original method is a wrapper is specified. We can only access \n * the custom attributes from the original method.\n */\nstatic MonoMethod*\nget_original_method (MonoMethod *method)\n{\n\tif (method->wrapper_type == MONO_WRAPPER_NONE)\n\t\treturn method;\n\n\t/* native code (which is like Critical) can call any managed method XXX FIXME XXX to validate all usages */\n\tif (method->wrapper_type == MONO_WRAPPER_NATIVE_TO_MANAGED)\n\t\treturn NULL;\n\n\t/* in other cases we need to find the original method */\n\treturn mono_marshal_method_from_wrapper (method);\n}\n\nstatic void\nensure_method_is_allowed_to_access_field (MonoCompile *cfg, MonoMethod *caller, MonoClassField *field)\n{\n\t/* we can't get the coreclr security level on wrappers since they don't have the attributes */\n\tMonoException *ex = mono_security_core_clr_is_field_access_allowed (get_original_method (caller), field);\n\tif (ex)\n\t\temit_throw_exception (cfg, ex);\n}\n\nstatic void\nensure_method_is_allowed_to_call_method (MonoCompile *cfg, MonoMethod *caller, MonoMethod *callee)\n{\n\t/* we can't get the coreclr security level on wrappers since they don't have the attributes */\n\tMonoException *ex = mono_security_core_clr_is_call_allowed (get_original_method (caller), callee);\n\tif (ex)\n\t\temit_throw_exception (cfg, ex);\n}\n\nstatic guchar*\nil_read_op (guchar *ip, guchar *end, guchar first_byte, MonoOpcodeEnum desired_il_op)\n// If ip is desired_il_op, return the next ip, else NULL.\n{\n\tif (G_LIKELY (ip < end) && G_UNLIKELY (*ip == first_byte)) {\n\t\tMonoOpcodeEnum il_op = MonoOpcodeEnum_Invalid;\n\t\t// mono_opcode_value_and_size updates ip, but not in the expected way.\n\t\tconst guchar *temp_ip = ip;\n\t\tconst int size = mono_opcode_value_and_size (&temp_ip, end, &il_op);\n\t\treturn (G_LIKELY (size > 0) && G_UNLIKELY (il_op == desired_il_op)) ? (ip + size) : NULL;\n\t}\n\treturn NULL;\n}\n\nstatic guchar*\nil_read_op_and_token (guchar *ip, guchar *end, guchar first_byte, MonoOpcodeEnum desired_il_op, guint32 *token)\n{\n\tip = il_read_op (ip, end, first_byte, desired_il_op);\n\tif (ip)\n\t\t*token = read32 (ip - 4); // could be +1 or +2 from start\n\treturn ip;\n}\n\nstatic guchar*\nil_read_branch_and_target (guchar *ip, guchar *end, guchar first_byte, MonoOpcodeEnum desired_il_op, int size, guchar **target)\n{\n\tip = il_read_op (ip, end, first_byte, desired_il_op);\n\tif (ip) {\n\t\tgint32 delta = 0;\n\t\tswitch (size) {\n\t\tcase  1:\n\t\t\tdelta = (signed char)ip [-1];\n\t\t\tbreak;\n\t\tcase  4:\n\t\t\tdelta = (gint32)read32 (ip - 4);\n\t\t\tbreak;\n\t\t}\n\t\t// FIXME verify it is within the function and start of an instruction.\n\t\t*target = ip + delta;\n\t\treturn ip;\n\t}\n\treturn NULL;\n}\n\n#define il_read_brtrue(ip, end, target) \t(il_read_branch_and_target (ip, end, CEE_BRTRUE,    MONO_CEE_BRTRUE,    4, target))\n#define il_read_brtrue_s(ip, end, target) \t(il_read_branch_and_target (ip, end, CEE_BRTRUE_S,  MONO_CEE_BRTRUE_S,  1, target))\n#define il_read_brfalse(ip, end, target) \t(il_read_branch_and_target (ip, end, CEE_BRFALSE,   MONO_CEE_BRFALSE,   4, target))\n#define il_read_brfalse_s(ip, end, target) \t(il_read_branch_and_target (ip, end, CEE_BRFALSE_S, MONO_CEE_BRFALSE_S, 1, target))\n#define il_read_dup(ip, end) \t\t\t(il_read_op \t\t   (ip, end, CEE_DUP, MONO_CEE_DUP))\n#define il_read_newobj(ip, end, token) \t\t(il_read_op_and_token \t   (ip, end, CEE_NEW_OBJ, MONO_CEE_NEWOBJ, token))\n#define il_read_ldtoken(ip, end, token) \t(il_read_op_and_token \t   (ip, end, CEE_LDTOKEN, MONO_CEE_LDTOKEN, token))\n#define il_read_call(ip, end, token) \t\t(il_read_op_and_token      (ip, end, CEE_CALL, MONO_CEE_CALL, token))\n#define il_read_callvirt(ip, end, token)\t(il_read_op_and_token \t   (ip, end, CEE_CALLVIRT, MONO_CEE_CALLVIRT, token))\n#define il_read_initobj(ip, end, token)         (il_read_op_and_token \t   (ip, end, CEE_PREFIX1, MONO_CEE_INITOBJ, token))\n#define il_read_constrained(ip, end, token)     (il_read_op_and_token      (ip, end, CEE_PREFIX1, MONO_CEE_CONSTRAINED_, token))\n#define il_read_unbox_any(ip, end, token)     (il_read_op_and_token      (ip, end, CEE_UNBOX_ANY, MONO_CEE_UNBOX_ANY, token))\n\n/*\n * Check that the IL instructions at ip are the array initialization\n * sequence and return the pointer to the data and the size.\n */\nstatic const char*\ninitialize_array_data (MonoCompile *cfg, MonoMethod *method, gboolean aot, guchar *ip,\n\t\tguchar *end, MonoClass *klass, guint32 len, int *out_size,\n\t\tguint32 *out_field_token, MonoOpcodeEnum *il_op, guchar **next_ip)\n{\n\t/*\n\t * newarr[System.Int32]\n\t * dup\n\t * ldtoken field valuetype ...\n\t * call void class [mscorlib]System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(class [mscorlib]System.Array, valuetype [mscorlib]System.RuntimeFieldHandle)\n\t */\n\n\tguint32 token;\n\tguint32 field_token;\n\n\tif  ((ip = il_read_dup (ip, end))\n\t\t\t&& ip_in_bb (cfg, cfg->cbb, ip)\n\t\t\t&& (ip = il_read_ldtoken (ip, end, &field_token))\n\t\t\t&& IS_FIELD_DEF (field_token)\n\t\t\t&& ip_in_bb (cfg, cfg->cbb, ip)\n\t\t\t&& (ip = il_read_call (ip, end, &token))) {\n\t\tERROR_DECL (error);\n\t\tguint32 rva;\n\t\tconst char *data_ptr;\n\t\tint size = 0;\n\t\tMonoMethod *cmethod;\n\t\tMonoClass *dummy_class;\n\t\tMonoClassField *field = mono_field_from_token_checked (m_class_get_image (method->klass), field_token, &dummy_class, NULL, error);\n\t\tint dummy_align;\n\n\t\tif (!field) {\n\t\t\tmono_error_cleanup (error); /* FIXME don't swallow the error */\n\t\t\treturn NULL;\n\t\t}\n\n\t\t*out_field_token = field_token;\n\n\t\tcmethod = mini_get_method (NULL, method, token, NULL, NULL);\n\t\tif (!cmethod)\n\t\t\treturn NULL;\n\t\tif (strcmp (cmethod->name, \"InitializeArray\") || strcmp (m_class_get_name (cmethod->klass), \"RuntimeHelpers\") || m_class_get_image (cmethod->klass) != mono_defaults.corlib)\n\t\t\treturn NULL;\n\t\tswitch (mini_get_underlying_type (m_class_get_byval_arg (klass))->type) {\n\t\tcase MONO_TYPE_I1:\n\t\tcase MONO_TYPE_U1:\n\t\t\tsize = 1; break;\n\t\t/* we need to swap on big endian, so punt. Should we handle R4 and R8 as well? */\n#if TARGET_BYTE_ORDER == G_LITTLE_ENDIAN\n\t\tcase MONO_TYPE_I2:\n\t\tcase MONO_TYPE_U2:\n\t\t\tsize = 2; break;\n\t\tcase MONO_TYPE_I4:\n\t\tcase MONO_TYPE_U4:\n\t\tcase MONO_TYPE_R4:\n\t\t\tsize = 4; break;\n\t\tcase MONO_TYPE_R8:\n\t\tcase MONO_TYPE_I8:\n\t\tcase MONO_TYPE_U8:\n\t\t\tsize = 8; break;\n#endif\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\t\tsize *= len;\n\t\tif (size > mono_type_size (field->type, &dummy_align))\n\t\t    return NULL;\n\t\t*out_size = size;\n\t\t/*g_print (\"optimized in %s: size: %d, numelems: %d\\n\", method->name, size, newarr->inst_newa_len->inst_c0);*/\n\t\tMonoImage *method_klass_image = m_class_get_image (method->klass);\n\t\tif (!image_is_dynamic (method_klass_image)) {\n\t\t\tguint32 field_index = mono_metadata_token_index (field_token);\n\t\t\tmono_metadata_field_info (method_klass_image, field_index - 1, NULL, &rva, NULL);\n\t\t\tdata_ptr = mono_image_rva_map (method_klass_image, rva);\n\t\t\t/*g_print (\"field: 0x%08x, rva: %d, rva_ptr: %p\\n\", read32 (ip + 2), rva, data_ptr);*/\n\t\t\t/* for aot code we do the lookup on load */\n\t\t\tif (aot && data_ptr)\n\t\t\t\tdata_ptr = (const char *)GUINT_TO_POINTER (rva);\n\t\t} else {\n\t\t\t/*FIXME is it possible to AOT a SRE assembly not meant to be saved? */ \n\t\t\tg_assert (!aot);\n\t\t\tdata_ptr = mono_field_get_data (field);\n\t\t}\n\t\tif (!data_ptr)\n\t\t\treturn NULL;\n\t\t*il_op = MONO_CEE_CALL;\n\t\t*next_ip = ip;\n\t\treturn data_ptr;\n\t}\n\treturn NULL;\n}\n\nstatic void\nset_exception_type_from_invalid_il (MonoCompile *cfg, MonoMethod *method, guchar *ip)\n{\n\tERROR_DECL (error);\n\tchar *method_fname = mono_method_full_name (method, TRUE);\n\tchar *method_code;\n\tMonoMethodHeader *header = mono_method_get_header_checked (method, error);\n\n\tif (!header) {\n\t\tmethod_code = g_strdup_printf (\"could not parse method body due to %s\", mono_error_get_message (error));\n\t\tmono_error_cleanup (error);\n\t} else if (header->code_size == 0)\n\t\tmethod_code = g_strdup (\"method body is empty.\");\n\telse\n\t\tmethod_code = mono_disasm_code_one (NULL, method, ip, NULL);\n\tmono_cfg_set_exception_invalid_program (cfg, g_strdup_printf (\"Invalid IL code in %s: %s\\n\", method_fname, method_code));\n \tg_free (method_fname);\n \tg_free (method_code);\n\tcfg->headers_to_free = g_slist_prepend_mempool (cfg->mempool, cfg->headers_to_free, header);\n}\n\nguint32\nmono_type_to_stloc_coerce (MonoType *type)\n{\n\tif (type->byref)\n\t\treturn 0;\n\n\ttype = mini_get_underlying_type (type);\nhandle_enum:\n\tswitch (type->type) {\n\tcase MONO_TYPE_I1:\n\t\treturn OP_ICONV_TO_I1;\n\tcase MONO_TYPE_U1:\n\t\treturn OP_ICONV_TO_U1;\n\tcase MONO_TYPE_I2:\n\t\treturn OP_ICONV_TO_I2;\n\tcase MONO_TYPE_U2:\n\t\treturn OP_ICONV_TO_U2;\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_FNPTR:\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_SZARRAY:\n\tcase MONO_TYPE_ARRAY:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_TYPEDBYREF:\n\tcase MONO_TYPE_GENERICINST:\n\t\treturn 0;\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (m_class_is_enumtype (type->data.klass)) {\n\t\t\ttype = mono_class_enum_basetype_internal (type->data.klass);\n\t\t\tgoto handle_enum;\n\t\t}\n\t\treturn 0;\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR: //TODO I believe we don't need to handle gsharedvt as there won't be match and, for example, u1 is not covariant to u32\n\t\treturn 0;\n\tdefault:\n\t\tg_error (\"unknown type 0x%02x in mono_type_to_stloc_coerce\", type->type);\n\t}\n\treturn -1;\n}\n\nstatic void\nemit_stloc_ir (MonoCompile *cfg, MonoInst **sp, MonoMethodHeader *header, int n)\n{\n\tMonoInst *ins;\n\tguint32 coerce_op = mono_type_to_stloc_coerce (header->locals [n]);\n\n\tif (coerce_op) {\n\t\tif (cfg->cbb->last_ins == sp [0] && sp [0]->opcode == coerce_op) {\n\t\t\tif (cfg->verbose_level > 2)\n\t\t\t\tprintf (\"Found existing coercing is enough for stloc\\n\");\n\t\t} else {\n\t\t\tMONO_INST_NEW (cfg, ins, coerce_op);\n\t\t\tins->dreg = alloc_ireg (cfg);\n\t\t\tins->sreg1 = sp [0]->dreg;\n\t\t\tins->type = STACK_I4;\n\t\t\tins->klass = mono_class_from_mono_type_internal (header->locals [n]);\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t*sp = mono_decompose_opcode (cfg, ins);\n\t\t}\n\t}\n\n\n\tguint32 opcode = mono_type_to_regmove (cfg, header->locals [n]);\n\tif ((opcode == OP_MOVE) && cfg->cbb->last_ins == sp [0]  &&\n\t\t\t((sp [0]->opcode == OP_ICONST) || (sp [0]->opcode == OP_I8CONST))) {\n\t\t/* Optimize reg-reg moves away */\n\t\t/* \n\t\t * Can't optimize other opcodes, since sp[0] might point to\n\t\t * the last ins of a decomposed opcode.\n\t\t */\n\t\tsp [0]->dreg = (cfg)->locals [n]->dreg;\n\t} else {\n\t\tEMIT_NEW_LOCSTORE (cfg, ins, n, *sp);\n\t}\n}\n\nstatic void\nemit_starg_ir (MonoCompile *cfg, MonoInst **sp, int n)\n{\n\tMonoInst *ins;\n\tguint32 coerce_op = mono_type_to_stloc_coerce (cfg->arg_types [n]);\n\n\tif (coerce_op) {\n\t\tif (cfg->cbb->last_ins == sp [0] && sp [0]->opcode == coerce_op) {\n\t\t\tif (cfg->verbose_level > 2)\n\t\t\t\tprintf (\"Found existing coercing is enough for starg\\n\");\n\t\t} else {\n\t\t\tMONO_INST_NEW (cfg, ins, coerce_op);\n\t\t\tins->dreg = alloc_ireg (cfg);\n\t\t\tins->sreg1 = sp [0]->dreg;\n\t\t\tins->type = STACK_I4;\n\t\t\tins->klass = mono_class_from_mono_type_internal (cfg->arg_types [n]);\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t*sp = mono_decompose_opcode (cfg, ins);\n\t\t}\n\t}\n\n\tEMIT_NEW_ARGSTORE (cfg, ins, n, *sp);\n}\n\n/*\n * ldloca inhibits many optimizations so try to get rid of it in common\n * cases.\n */\nstatic guchar *\nemit_optimized_ldloca_ir (MonoCompile *cfg, guchar *ip, guchar *end, int local)\n{\n\tguint32 token;\n\tMonoClass *klass;\n\tMonoType *type;\n\n\tguchar *start = ip;\n\n\tif  ((ip = il_read_initobj (ip, end, &token)) && ip_in_bb (cfg, cfg->cbb, start + 1)) {\n\t\t/* From the INITOBJ case */\n\t\tklass = mini_get_class (cfg->current_method, token, cfg->generic_context);\n\t\tCHECK_TYPELOAD (klass);\n\t\ttype = mini_get_underlying_type (m_class_get_byval_arg (klass));\n\t\temit_init_local (cfg, local, type, TRUE);\n\t\treturn ip;\n\t}\n exception_exit:\n\treturn NULL;\n}\n\nstatic MonoInst*\nhandle_call_res_devirt (MonoCompile *cfg, MonoMethod *cmethod, MonoInst *call_res)\n{\n\t/*\n\t * Devirt EqualityComparer.Default.Equals () calls for some types.\n\t * The corefx code excepts these calls to be devirtualized.\n\t * This depends on the implementation of EqualityComparer.Default, which is\n\t * in mcs/class/referencesource/mscorlib/system/collections/generic/equalitycomparer.cs\n\t */\n\tif (m_class_get_image (cmethod->klass) == mono_defaults.corlib &&\n\t\t!strcmp (m_class_get_name (cmethod->klass), \"EqualityComparer`1\") &&\n\t\t!strcmp (cmethod->name, \"get_Default\")) {\n\t\tMonoType *param_type = mono_class_get_generic_class (cmethod->klass)->context.class_inst->type_argv [0];\n\t\tMonoClass *inst;\n\t\tMonoGenericContext ctx;\n\t\tMonoType *args [16];\n\t\tERROR_DECL (error);\n\n\t\tmemset (&ctx, 0, sizeof (ctx));\n\n\t\targs [0] = param_type;\n\t\tctx.class_inst = mono_metadata_get_generic_inst (1, args);\n\n\t\tinst = mono_class_inflate_generic_class_checked (mono_class_get_iequatable_class (), &ctx, error);\n\t\tmono_error_assert_ok (error);\n\n\t\t/* EqualityComparer<T>.Default returns specific types depending on T */\n\t\t// FIXME: Add more\n\t\t/* 1. Implements IEquatable<T> */\n\t\t/*\n\t\t * Can't use this for string/byte as it might use a different comparer:\n\t\t *\n         * // Specialize type byte for performance reasons\n         * if (t == typeof(byte)) {\n         *     return (EqualityComparer<T>)(object)(new ByteEqualityComparer());\n         * }\n\t\t * #if MOBILE\n\t\t *   // Breaks .net serialization compatibility\n\t\t *   if (t == typeof (string))\n\t\t *       return (EqualityComparer<T>)(object)new InternalStringComparer ();\n\t\t * #endif\n\t\t */\n\t\tif (mono_class_is_assignable_from_internal (inst, mono_class_from_mono_type_internal (param_type)) && param_type->type != MONO_TYPE_U1 && param_type->type != MONO_TYPE_STRING) {\n\t\t\tMonoInst *typed_objref;\n\t\t\tMonoClass *gcomparer_inst;\n\n\t\t\tmemset (&ctx, 0, sizeof (ctx));\n\n\t\t\targs [0] = param_type;\n\t\t\tctx.class_inst = mono_metadata_get_generic_inst (1, args);\n\n\t\t\tMonoClass *gcomparer = mono_class_get_geqcomparer_class ();\n\t\t\tg_assert (gcomparer);\n\t\t\tgcomparer_inst = mono_class_inflate_generic_class_checked (gcomparer, &ctx, error);\n\t\t\tmono_error_assert_ok (error);\n\n\t\t\tMONO_INST_NEW (cfg, typed_objref, OP_TYPED_OBJREF);\n\t\t\ttyped_objref->type = STACK_OBJ;\n\t\t\ttyped_objref->dreg = alloc_ireg_ref (cfg);\n\t\t\ttyped_objref->sreg1 = call_res->dreg;\n\t\t\ttyped_objref->klass = gcomparer_inst;\n\t\t\tMONO_ADD_INS (cfg->cbb, typed_objref);\n\n\t\t\tcall_res = typed_objref;\n\n\t\t\t/* Force decompose */\n\t\t\tcfg->flags |= MONO_CFG_NEEDS_DECOMPOSE;\n\t\t\tcfg->cbb->needs_decompose = TRUE;\n\t\t}\n\t}\n\n\treturn call_res;\n}\n\nstatic gboolean\nis_exception_class (MonoClass *klass)\n{\n\tif (G_LIKELY (m_class_get_supertypes (klass)))\n\t\treturn mono_class_has_parent_fast (klass, mono_defaults.exception_class);\n\twhile (klass) {\n\t\tif (klass == mono_defaults.exception_class)\n\t\t\treturn TRUE;\n\t\tklass = m_class_get_parent (klass);\n\t}\n\treturn FALSE;\n}\n\n/*\n * is_jit_optimizer_disabled:\n *\n *   Determine whenever M's assembly has a DebuggableAttribute with the\n * IsJITOptimizerDisabled flag set.\n */\nstatic gboolean\nis_jit_optimizer_disabled (MonoMethod *m)\n{\n\tERROR_DECL (error);\n\tMonoAssembly *ass = m_class_get_image (m->klass)->assembly;\n\tMonoCustomAttrInfo* attrs;\n\tMonoClass *klass;\n\tint i;\n\tgboolean val = FALSE;\n\n\tg_assert (ass);\n\tif (ass->jit_optimizer_disabled_inited)\n\t\treturn ass->jit_optimizer_disabled;\n\n\tklass = mono_class_try_get_debuggable_attribute_class ();\n\n\tif (!klass) {\n\t\t/* Linked away */\n\t\tass->jit_optimizer_disabled = FALSE;\n\t\tmono_memory_barrier ();\n\t\tass->jit_optimizer_disabled_inited = TRUE;\n\t\treturn FALSE;\n\t}\n\n\tattrs = mono_custom_attrs_from_assembly_checked (ass, FALSE, error);\n\tmono_error_cleanup (error); /* FIXME don't swallow the error */\n\tif (attrs) {\n\t\tfor (i = 0; i < attrs->num_attrs; ++i) {\n\t\t\tMonoCustomAttrEntry *attr = &attrs->attrs [i];\n\t\t\tconst gchar *p;\n\t\t\tMonoMethodSignature *sig;\n\n\t\t\tif (!attr->ctor || attr->ctor->klass != klass)\n\t\t\t\tcontinue;\n\t\t\t/* Decode the attribute. See reflection.c */\n\t\t\tp = (const char*)attr->data;\n\t\t\tg_assert (read16 (p) == 0x0001);\n\t\t\tp += 2;\n\n\t\t\t// FIXME: Support named parameters\n\t\t\tsig = mono_method_signature_internal (attr->ctor);\n\t\t\tif (sig->param_count != 2 || sig->params [0]->type != MONO_TYPE_BOOLEAN || sig->params [1]->type != MONO_TYPE_BOOLEAN)\n\t\t\t\tcontinue;\n\t\t\t/* Two boolean arguments */\n\t\t\tp ++;\n\t\t\tval = *p;\n\t\t}\n\t\tmono_custom_attrs_free (attrs);\n\t}\n\n\tass->jit_optimizer_disabled = val;\n\tmono_memory_barrier ();\n\tass->jit_optimizer_disabled_inited = TRUE;\n\n\treturn val;\n}\n\ngboolean\nmono_is_supported_tailcall_helper (gboolean value, const char *svalue)\n{\n\tif (!value)\n\t\tmono_tailcall_print (\"%s %s\\n\", __func__, svalue);\n\treturn value;\n}\n\nstatic gboolean\nmono_is_not_supported_tailcall_helper (gboolean value, const char *svalue, MonoMethod *method, MonoMethod *cmethod)\n{\n\t// Return value, printing if it inhibits tailcall.\n\n\tif (value && mono_tailcall_print_enabled ()) {\n\t\tconst char *lparen = strchr (svalue, ' ') ? \"(\" : \"\";\n\t\tconst char *rparen = *lparen ? \")\" : \"\";\n\t\tmono_tailcall_print (\"%s %s -> %s %s%s%s:%d\\n\", __func__, method->name, cmethod->name, lparen, svalue, rparen, value);\n\t}\n\treturn value;\n}\n\n#define IS_NOT_SUPPORTED_TAILCALL(x) (mono_is_not_supported_tailcall_helper((x), #x, method, cmethod))\n\nstatic gboolean\nis_supported_tailcall (MonoCompile *cfg, const guint8 *ip, MonoMethod *method, MonoMethod *cmethod, MonoMethodSignature *fsig,\n\tgboolean virtual_, gboolean extra_arg, gboolean *ptailcall_calli)\n{\n\t// Some checks apply to \"regular\", some to \"calli\", some to both.\n\t// To ease burden on caller, always compute regular and calli.\n\n\tgboolean tailcall = TRUE;\n\tgboolean tailcall_calli = TRUE;\n\n\tif (IS_NOT_SUPPORTED_TAILCALL (virtual_ && !cfg->backend->have_op_tailcall_membase))\n\t\ttailcall = FALSE;\n\n\tif (IS_NOT_SUPPORTED_TAILCALL (!cfg->backend->have_op_tailcall_reg))\n\t\ttailcall_calli = FALSE;\n\n\tif (!tailcall && !tailcall_calli)\n\t\tgoto exit;\n\n\t// FIXME in calli, there is no type for for the this parameter,\n\t// so we assume it might be valuetype; in future we should issue a range\n\t// check, so rule out pointing to frame (for other reference parameters also)\n\n\tif (       IS_NOT_SUPPORTED_TAILCALL (cmethod && fsig->hasthis && m_class_is_valuetype (cmethod->klass)) // This might point to the current method's stack. Emit range check?\n\t\t|| IS_NOT_SUPPORTED_TAILCALL (cmethod && (cmethod->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL))\n\t\t|| IS_NOT_SUPPORTED_TAILCALL (fsig->pinvoke) // i.e. if !cmethod (calli)\n\t\t|| IS_NOT_SUPPORTED_TAILCALL (cfg->method->save_lmf)\n\t\t|| IS_NOT_SUPPORTED_TAILCALL (!cmethod && fsig->hasthis) // FIXME could be valuetype to current frame; range check\n\t\t|| IS_NOT_SUPPORTED_TAILCALL (cmethod && cmethod->wrapper_type && cmethod->wrapper_type != MONO_WRAPPER_DYNAMIC_METHOD)\n\n\t\t// http://www.mono-project.com/docs/advanced/runtime/docs/generic-sharing/\n\t\t//\n\t\t// 1. Non-generic non-static methods of reference types have access to the\n\t\t//    RGCTX via the \u201cthis\u201d argument (this->vtable->rgctx).\n\t\t// 2. a Non-generic static methods of reference types and b. non-generic methods\n\t\t//    of value types need to be passed a pointer to the caller\u2019s class\u2019s VTable in the MONO_ARCH_RGCTX_REG register.\n\t\t// 3. Generic methods need to be passed a pointer to the MRGCTX in the MONO_ARCH_RGCTX_REG register\n\t\t//\n\t\t// That is what vtable_arg is here (always?).\n\t\t//\n\t\t// Passing vtable_arg uses (requires?) a volatile non-parameter register,\n\t\t// such as AMD64 rax, r10, r11, or the return register on many architectures.\n\t\t// ARM32 does not always clearly have such a register. ARM32's return register\n\t\t// is a parameter register.\n\t\t// iPhone could use r9 except on old systems. iPhone/ARM32 is not particularly\n\t\t// important. Linux/arm32 is less clear.\n\t\t// ARM32's scratch r12 might work but only with much collateral change.\n\t\t//\n\t\t// Imagine F1 calls F2, and F2 tailcalls F3.\n\t\t// F2 and F3 are managed. F1 is native.\n\t\t// Without a tailcall, F2 can save and restore everything needed for F1.\n\t\t// However if the extra parameter were in a non-volatile, such as ARM32 V5/R8,\n\t\t// F3 cannot easily restore it for F1, in the current scheme. The current\n\t\t// scheme where the extra parameter is not merely an extra parameter, but\n\t\t// passed \"outside of the ABI\".\n\t\t//\n\t\t// If all native to managed transitions are intercepted and wrapped (w/o tailcall),\n\t\t// then they can preserve this register and the rest of the managed callgraph\n\t\t// treat it as volatile.\n\t\t//\n\t\t// Interface method dispatch has the same problem (imt_arg).\n\n\t\t|| IS_NOT_SUPPORTED_TAILCALL (extra_arg && !cfg->backend->have_volatile_non_param_register)\n\t\t|| IS_NOT_SUPPORTED_TAILCALL (cfg->gsharedvt)\n\t\t) {\n\t\ttailcall_calli = FALSE;\n\t\ttailcall = FALSE;\n\t\tgoto exit;\n\t}\n\n\tfor (int i = 0; i < fsig->param_count; ++i) {\n\t\tif (IS_NOT_SUPPORTED_TAILCALL (fsig->params [i]->byref || fsig->params [i]->type == MONO_TYPE_PTR || fsig->params [i]->type == MONO_TYPE_FNPTR)) {\n\t\t\ttailcall_calli = FALSE;\n\t\t\ttailcall = FALSE; // These can point to the current method's stack. Emit range check?\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tMonoMethodSignature *caller_signature;\n\tMonoMethodSignature *callee_signature;\n\tcaller_signature = mono_method_signature_internal (method);\n\tcallee_signature = cmethod ? mono_method_signature_internal (cmethod) : fsig;\n\n\tg_assert (caller_signature);\n\tg_assert (callee_signature);\n\n\t// Require an exact match on return type due to various conversions in emit_move_return_value that would be skipped.\n\t// The main troublesome conversions are double <=> float.\n\t// CoreCLR allows some conversions here, such as integer truncation.\n\t// As well I <=> I[48] and U <=> U[48] would be ok, for matching size.\n\tif (IS_NOT_SUPPORTED_TAILCALL (mini_get_underlying_type (caller_signature->ret)->type != mini_get_underlying_type (callee_signature->ret)->type)\n\t\t|| IS_NOT_SUPPORTED_TAILCALL (!mono_arch_tailcall_supported (cfg, caller_signature, callee_signature, virtual_))) {\n\t\ttailcall_calli = FALSE;\n\t\ttailcall = FALSE;\n\t\tgoto exit;\n\t}\n\n\t/* Debugging support */\n#if 0\n\tif (!mono_debug_count ()) {\n\t\ttailcall_calli = FALSE;\n\t\ttailcall = FALSE;\n\t\tgoto exit;\n\t}\n#endif\n\t// See check_sp in mini_emit_calli_full.\n\tif (tailcall_calli && IS_NOT_SUPPORTED_TAILCALL (mini_should_check_stack_pointer (cfg)))\n\t\ttailcall_calli = FALSE;\nexit:\n\tmono_tailcall_print (\"tail.%s %s -> %s tailcall:%d tailcall_calli:%d gshared:%d extra_arg:%d virtual_:%d\\n\",\n\t\t\tmono_opcode_name (*ip), method->name, cmethod ? cmethod->name : \"calli\", tailcall, tailcall_calli,\n\t\t\tcfg->gshared, extra_arg, virtual_);\n\n\t*ptailcall_calli = tailcall_calli;\n\treturn tailcall;\n}\n\n/*\n * is_addressable_valuetype_load\n *\n *    Returns true if a previous load can be done without doing an extra copy, given the new instruction ip and the type of the object being loaded ldtype\n */\nstatic gboolean\nis_addressable_valuetype_load (MonoCompile* cfg, guint8* ip, MonoType* ldtype)\n{\n\t/* Avoid loading a struct just to load one of its fields */\n\tgboolean is_load_instruction = (*ip == CEE_LDFLD);\n\tgboolean is_in_previous_bb = ip_in_bb(cfg, cfg->cbb, ip);\n\tgboolean is_struct = MONO_TYPE_ISSTRUCT(ldtype);\n\treturn is_load_instruction && is_in_previous_bb && is_struct;\n}\n\n/*\n * handle_ctor_call:\n *\n *   Handle calls made to ctors from NEWOBJ opcodes.\n */\nstatic void\nhandle_ctor_call (MonoCompile *cfg, MonoMethod *cmethod, MonoMethodSignature *fsig, int context_used,\n\t\t\t\t  MonoInst **sp, guint8 *ip, int *inline_costs)\n{\n\tMonoInst *vtable_arg = NULL, *callvirt_this_arg = NULL, *ins;\n\n\tif (m_class_is_valuetype (cmethod->klass) && mono_class_generic_sharing_enabled (cmethod->klass) &&\n\t\t\t\t\tmono_method_is_generic_sharable (cmethod, TRUE)) {\n\t\tif (cmethod->is_inflated && mono_method_get_context (cmethod)->method_inst) {\n\t\t\tmono_class_vtable_checked (cfg->domain, cmethod->klass, cfg->error);\n\t\t\tCHECK_CFG_ERROR;\n\t\t\tCHECK_TYPELOAD (cmethod->klass);\n\n\t\t\tvtable_arg = emit_get_rgctx_method (cfg, context_used,\n\t\t\t\t\t\t\t\t\t\t\t\tcmethod, MONO_RGCTX_INFO_METHOD_RGCTX);\n\t\t} else {\n\t\t\tif (context_used) {\n\t\t\t\tvtable_arg = mini_emit_get_rgctx_klass (cfg, context_used,\n\t\t\t\t\t\t\t\t\t\t\t\t   cmethod->klass, MONO_RGCTX_INFO_VTABLE);\n\t\t\t} else {\n\t\t\t\tMonoVTable *vtable = mono_class_vtable_checked (cfg->domain, cmethod->klass, cfg->error);\n\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t\tCHECK_TYPELOAD (cmethod->klass);\n\t\t\t\tEMIT_NEW_VTABLECONST (cfg, vtable_arg, vtable);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid virtual calls to ctors if possible */\n\tif (mono_class_is_marshalbyref (cmethod->klass))\n\t\tcallvirt_this_arg = sp [0];\n\n\tif (cmethod && (ins = mini_emit_inst_for_ctor (cfg, cmethod, fsig, sp))) {\n\t\tg_assert (MONO_TYPE_IS_VOID (fsig->ret));\n\t\tCHECK_CFG_EXCEPTION;\n\t} else if ((cfg->opt & MONO_OPT_INLINE) && cmethod && !context_used && !vtable_arg &&\n\t\t\t   mono_method_check_inlining (cfg, cmethod) &&\n\t\t\t   !mono_class_is_subclass_of_internal (cmethod->klass, mono_defaults.exception_class, FALSE)) {\n\t\tint costs;\n\n\t\tif ((costs = inline_method (cfg, cmethod, fsig, sp, ip, cfg->real_offset, FALSE))) {\n\t\t\tcfg->real_offset += 5;\n\n\t\t\t*inline_costs += costs - 5;\n\t\t} else {\n\t\t\tINLINE_FAILURE (\"inline failure\");\n\t\t\t// FIXME-VT: Clean this up\n\t\t\tif (cfg->gsharedvt && mini_is_gsharedvt_signature (fsig))\n\t\t\t\tGSHAREDVT_FAILURE(*ip);\n\t\t\tmini_emit_method_call_full (cfg, cmethod, fsig, FALSE, sp, callvirt_this_arg, NULL, NULL);\n\t\t}\n\t} else if (cfg->gsharedvt && mini_is_gsharedvt_signature (fsig)) {\n\t\tMonoInst *addr;\n\n\t\taddr = emit_get_rgctx_gsharedvt_call (cfg, context_used, fsig, cmethod, MONO_RGCTX_INFO_METHOD_GSHAREDVT_OUT_TRAMPOLINE);\n\n\t\tif (cfg->llvm_only) {\n\t\t\t// FIXME: Avoid initializing vtable_arg\n\t\t\tmini_emit_llvmonly_calli (cfg, fsig, sp, addr);\n\t\t} else {\n\t\t\tmini_emit_calli (cfg, fsig, sp, addr, NULL, vtable_arg);\n\t\t}\n\t} else if (context_used &&\n\t\t\t   ((!mono_method_is_generic_sharable_full (cmethod, TRUE, FALSE, FALSE) ||\n\t\t\t\t !mono_class_generic_sharing_enabled (cmethod->klass)) || cfg->gsharedvt)) {\n\t\tMonoInst *cmethod_addr;\n\n\t\t/* Generic calls made out of gsharedvt methods cannot be patched, so use an indirect call */\n\n\t\tif (cfg->llvm_only) {\n\t\t\tMonoInst *addr = emit_get_rgctx_method (cfg, context_used, cmethod,\n\t\t\t\t\t\t\t\t\t\t\t\t\tMONO_RGCTX_INFO_METHOD_FTNDESC);\n\t\t\tmini_emit_llvmonly_calli (cfg, fsig, sp, addr);\n\t\t} else {\n\t\t\tcmethod_addr = emit_get_rgctx_method (cfg, context_used,\n\t\t\t\t\t\t\t\t\t\t\t\t  cmethod, MONO_RGCTX_INFO_GENERIC_METHOD_CODE);\n\n\t\t\tmini_emit_calli (cfg, fsig, sp, cmethod_addr, NULL, vtable_arg);\n\t\t}\n\t} else {\n\t\tINLINE_FAILURE (\"ctor call\");\n\t\tins = mini_emit_method_call_full (cfg, cmethod, fsig, FALSE, sp,\n\t\t\t\t\t\t  callvirt_this_arg, NULL, vtable_arg);\n\t}\n exception_exit:\n mono_error_exit:\n\treturn;\n}\n\ntypedef struct {\n\tMonoMethod *method;\n\tgboolean inst_tailcall;\n} HandleCallData;\n\n/*\n * handle_constrained_call:\n *\n *   Handle constrained calls. Return a MonoInst* representing the call or NULL.\n * May overwrite sp [0] and modify the ref_... parameters.\n */\nstatic MonoInst*\nhandle_constrained_call (MonoCompile *cfg, MonoMethod *cmethod, MonoMethodSignature *fsig, MonoClass *constrained_class, MonoInst **sp,\n\t\t\t\t\t\t HandleCallData *cdata, MonoMethod **ref_cmethod, gboolean *ref_virtual, gboolean *ref_emit_widen)\n{\n\tMonoInst *ins, *addr;\n\tMonoMethod *method = cdata->method;\n\tgboolean constrained_partial_call = FALSE;\n\tgboolean constrained_is_generic_param =\n\t\tm_class_get_byval_arg (constrained_class)->type == MONO_TYPE_VAR ||\n\t\tm_class_get_byval_arg (constrained_class)->type == MONO_TYPE_MVAR;\n\n\tif (constrained_is_generic_param && cfg->gshared) {\n\t\tif (!mini_is_gsharedvt_klass (constrained_class)) {\n\t\t\tg_assert (!m_class_is_valuetype (cmethod->klass));\n\t\t\tif (!mini_type_is_reference (m_class_get_byval_arg (constrained_class)))\n\t\t\t\tconstrained_partial_call = TRUE;\n\t\t}\n\t}\n\n\tif (mini_is_gsharedvt_klass (constrained_class)) {\n\t\tif ((cmethod->klass != mono_defaults.object_class) && m_class_is_valuetype (constrained_class) && m_class_is_valuetype (cmethod->klass)) {\n\t\t\t/* The 'Own method' case below */\n\t\t} else if (m_class_get_image (cmethod->klass) != mono_defaults.corlib && !mono_class_is_interface (cmethod->klass) && !m_class_is_valuetype (cmethod->klass)) {\n\t\t\t/* 'The type parameter is instantiated as a reference type' case below. */\n\t\t} else {\n\t\t\tins = handle_constrained_gsharedvt_call (cfg, cmethod, fsig, sp, constrained_class, ref_emit_widen);\n\t\t\tCHECK_CFG_EXCEPTION;\n\t\t\tg_assert (ins);\n\t\t\tif (cdata->inst_tailcall) // FIXME\n\t\t\t\tmono_tailcall_print (\"missed tailcall constrained_class %s -> %s\\n\", method->name, cmethod->name);\n\t\t\treturn ins;\n\t\t}\n\t}\n\n\tif (constrained_partial_call) {\n\t\tgboolean need_box = TRUE;\n\n\t\t/*\n\t\t * The receiver is a valuetype, but the exact type is not known at compile time. This means the\n\t\t * called method is not known at compile time either. The called method could end up being\n\t\t * one of the methods on the parent classes (object/valuetype/enum), in which case we need\n\t\t * to box the receiver.\n\t\t * A simple solution would be to box always and make a normal virtual call, but that would\n\t\t * be bad performance wise.\n\t\t */\n\t\tif (mono_class_is_interface (cmethod->klass) && mono_class_is_ginst (cmethod->klass) &&\n\t\t    (cmethod->flags & METHOD_ATTRIBUTE_ABSTRACT)) {\n\t\t\t/*\n\t\t\t * The parent classes implement no generic interfaces, so the called method will be a vtype method, so no boxing neccessary.\n\t\t\t */\n\t\t\t/* If the method is not abstract, it's a default interface method, and we need to box */\n\t\t\tneed_box = FALSE;\n\t\t}\n\n\t\tif (!(cmethod->flags & METHOD_ATTRIBUTE_VIRTUAL) && (cmethod->klass == mono_defaults.object_class || cmethod->klass == m_class_get_parent (mono_defaults.enum_class) || cmethod->klass == mono_defaults.enum_class)) {\n\t\t\t/* The called method is not virtual, i.e. Object:GetType (), the receiver is a vtype, has to box */\n\t\t\tEMIT_NEW_LOAD_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (constrained_class), sp [0]->dreg, 0);\n\t\t\tins->klass = constrained_class;\n\t\t\tsp [0] = mini_emit_box (cfg, ins, constrained_class, mono_class_check_context_used (constrained_class));\n\t\t\tCHECK_CFG_EXCEPTION;\n\t\t} else if (need_box) {\n\t\t\tMonoInst *box_type;\n\t\t\tMonoBasicBlock *is_ref_bb, *end_bb;\n\t\t\tMonoInst *nonbox_call, *addr;\n\n\t\t\t/*\n\t\t\t * Determine at runtime whenever the called method is defined on object/valuetype/enum, and emit a boxing call\n\t\t\t * if needed.\n\t\t\t * FIXME: It is possible to inline the called method in a lot of cases, i.e. for T_INT,\n\t\t\t * the no-box case goes to a method in Int32, while the box case goes to a method in Enum.\n\t\t\t */\n\t\t\taddr = emit_get_rgctx_virt_method (cfg, mono_class_check_context_used (constrained_class), constrained_class, cmethod, MONO_RGCTX_INFO_VIRT_METHOD_CODE);\n\n\t\t\tNEW_BBLOCK (cfg, is_ref_bb);\n\t\t\tNEW_BBLOCK (cfg, end_bb);\n\n\t\t\tbox_type = emit_get_rgctx_virt_method (cfg, mono_class_check_context_used (constrained_class), constrained_class, cmethod, MONO_RGCTX_INFO_VIRT_METHOD_BOX_TYPE);\n\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, box_type->dreg, MONO_GSHAREDVT_BOX_TYPE_REF);\n\t\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_IBEQ, is_ref_bb);\n\n\t\t\t/* Non-ref case */\n\t\t\tif (cfg->llvm_only)\n\t\t\t\t/* addr is an ftndesc in this case */\n\t\t\t\tnonbox_call = mini_emit_llvmonly_calli (cfg, fsig, sp, addr);\n\t\t\telse\n\t\t\t\tnonbox_call = (MonoInst*)mini_emit_calli (cfg, fsig, sp, addr, NULL, NULL);\n\n\t\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_BR, end_bb);\n\n\t\t\t/* Ref case */\n\t\t\tMONO_START_BB (cfg, is_ref_bb);\n\t\t\tEMIT_NEW_LOAD_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (constrained_class), sp [0]->dreg, 0);\n\t\t\tins->klass = constrained_class;\n\t\t\tsp [0] = mini_emit_box (cfg, ins, constrained_class, mono_class_check_context_used (constrained_class));\n\t\t\tCHECK_CFG_EXCEPTION;\n\t\t\tif (cfg->llvm_only)\n\t\t\t\tins = mini_emit_llvmonly_calli (cfg, fsig, sp, addr);\n\t\t\telse\n\t\t\t\tins = (MonoInst*)mini_emit_calli (cfg, fsig, sp, addr, NULL, NULL);\n\n\t\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_BR, end_bb);\n\n\t\t\tMONO_START_BB (cfg, end_bb);\n\t\t\tcfg->cbb = end_bb;\n\n\t\t\tnonbox_call->dreg = ins->dreg;\n\t\t\tif (cdata->inst_tailcall) // FIXME\n\t\t\t\tmono_tailcall_print (\"missed tailcall constrained_partial_need_box %s -> %s\\n\", method->name, cmethod->name);\n\t\t\treturn ins;\n\t\t} else {\n\t\t\tg_assert (mono_class_is_interface (cmethod->klass));\n\t\t\taddr = emit_get_rgctx_virt_method (cfg, mono_class_check_context_used (constrained_class), constrained_class, cmethod, MONO_RGCTX_INFO_VIRT_METHOD_CODE);\n\t\t\tif (cfg->llvm_only)\n\t\t\t\tins = mini_emit_llvmonly_calli (cfg, fsig, sp, addr);\n\t\t\telse\n\t\t\t\tins = (MonoInst*)mini_emit_calli (cfg, fsig, sp, addr, NULL, NULL);\n\t\t\tif (cdata->inst_tailcall) // FIXME\n\t\t\t\tmono_tailcall_print (\"missed tailcall constrained_partial %s -> %s\\n\", method->name, cmethod->name);\n\t\t\treturn ins;\n\t\t}\n\t} else if (!m_class_is_valuetype (constrained_class)) {\n\t\tint dreg = alloc_ireg_ref (cfg);\n\n\t\t/*\n\t\t * The type parameter is instantiated as a reference\n\t\t * type.  We have a managed pointer on the stack, so\n\t\t * we need to dereference it here.\n\t\t */\n\t\tEMIT_NEW_LOAD_MEMBASE (cfg, ins, OP_LOAD_MEMBASE, dreg, sp [0]->dreg, 0);\n\t\tins->type = STACK_OBJ;\n\t\tsp [0] = ins;\n\t} else if (cmethod->klass == mono_defaults.object_class || cmethod->klass == m_class_get_parent (mono_defaults.enum_class) || cmethod->klass == mono_defaults.enum_class) {\n\t\t/*\n\t\t * The type parameter is instantiated as a valuetype,\n\t\t * but that type doesn't override the method we're\n\t\t * calling, so we need to box `this'.\n\t\t */\n\t\tEMIT_NEW_LOAD_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (constrained_class), sp [0]->dreg, 0);\n\t\tins->klass = constrained_class;\n\t\tsp [0] = mini_emit_box (cfg, ins, constrained_class, mono_class_check_context_used (constrained_class));\n\t\tCHECK_CFG_EXCEPTION;\n\t} else {\n\t\tif (cmethod->klass != constrained_class) {\n\t\t\t/* Enums/default interface methods */\n\t\t\tEMIT_NEW_LOAD_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (constrained_class), sp [0]->dreg, 0);\n\t\t\tins->klass = constrained_class;\n\t\t\tsp [0] = mini_emit_box (cfg, ins, constrained_class, mono_class_check_context_used (constrained_class));\n\t\t\tCHECK_CFG_EXCEPTION;\n\t\t}\n\t\t*ref_virtual = FALSE;\n\t}\n\n exception_exit:\n\treturn NULL;\n}\n\nstatic void\nemit_setret (MonoCompile *cfg, MonoInst *val)\n{\n\tMonoType *ret_type = mini_get_underlying_type (mono_method_signature_internal (cfg->method)->ret);\n\tMonoInst *ins;\n\n\tif (mini_type_to_stind (cfg, ret_type) == CEE_STOBJ) {\n\t\tMonoInst *ret_addr;\n\n\t\tif (!cfg->vret_addr) {\n\t\t\tEMIT_NEW_VARSTORE (cfg, ins, cfg->ret, ret_type, val);\n\t\t} else {\n\t\t\tEMIT_NEW_RETLOADA (cfg, ret_addr);\n\n\t\t\tMonoClass *ret_class = mono_class_from_mono_type_internal (ret_type);\n\t\t\tif (MONO_CLASS_IS_SIMD (cfg, ret_class))\n\t\t\t\tEMIT_NEW_STORE_MEMBASE (cfg, ins, OP_STOREX_MEMBASE, ret_addr->dreg, 0, val->dreg);\n\t\t\telse\n\t\t\t\tEMIT_NEW_STORE_MEMBASE (cfg, ins, OP_STOREV_MEMBASE, ret_addr->dreg, 0, val->dreg);\n\t\t\tins->klass = ret_class;\n\t\t}\n\t} else {\n#ifdef MONO_ARCH_SOFT_FLOAT_FALLBACK\n\t\tif (COMPILE_SOFT_FLOAT (cfg) && !ret_type->byref && ret_type->type == MONO_TYPE_R4) {\n\t\t\tMonoInst *iargs [1];\n\t\t\tMonoInst *conv;\n\n\t\t\tiargs [0] = val;\n\t\t\tconv = mono_emit_jit_icall (cfg, mono_fload_r4_arg, iargs);\n\t\t\tmono_arch_emit_setret (cfg, cfg->method, conv);\n\t\t} else {\n\t\t\tmono_arch_emit_setret (cfg, cfg->method, val);\n\t\t}\n#else\n\t\tmono_arch_emit_setret (cfg, cfg->method, val);\n#endif\n\t}\n}\n\ntypedef union _MonoOpcodeParameter {\n\tgint32 i32;\n\tgint64 i64;\n\tfloat f;\n\tdouble d;\n\tguchar *branch_target;\n} MonoOpcodeParameter;\n\ntypedef struct _MonoOpcodeInfo {\n\tguint constant : 4; // private\n\tgint  pops     : 3; // public -1 means variable\n\tgint  pushes   : 3; // public -1 means variable\n} MonoOpcodeInfo;\n\nstatic const MonoOpcodeInfo*\nmono_opcode_decode (guchar *ip, guint op_size, MonoOpcodeEnum il_op, MonoOpcodeParameter *parameter)\n{\n#define Push0 (0)\n#define Pop0 (0)\n#define Push1 (1)\n#define Pop1 (1)\n#define PushI (1)\n#define PopI (1)\n#define PushI8 (1)\n#define PopI8 (1)\n#define PushRef (1)\n#define PopRef (1)\n#define PushR4 (1)\n#define PopR4 (1)\n#define PushR8 (1)\n#define PopR8 (1)\n#define VarPush (-1)\n#define VarPop (-1)\n\n\tstatic const MonoOpcodeInfo mono_opcode_info [ ] = {\n#define OPDEF(name, str, pops, pushes, param, param_constant, a, b, c, flow) {param_constant + 1, pops, pushes },\n#include \"mono/cil/opcode.def\"\n#undef OPDEF\n\t};\n\n#undef Push0\n#undef Pop0\n#undef Push1\n#undef Pop1\n#undef PushI\n#undef PopI\n#undef PushI8\n#undef PopI8\n#undef PushRef\n#undef PopRef\n#undef PushR4\n#undef PopR4\n#undef PushR8\n#undef PopR8\n#undef VarPush\n#undef VarPop\n\n\tgint32 delta;\n\tguchar *next_ip = ip + op_size;\n\n\tconst MonoOpcodeInfo *info = &mono_opcode_info [il_op];\n\n\tswitch (mono_opcodes [il_op].argument) {\n\tcase MonoInlineNone:\n\t\tparameter->i32 = (int)info->constant - 1;\n\t\tbreak;\n\tcase MonoInlineString:\n\tcase MonoInlineType:\n\tcase MonoInlineField:\n\tcase MonoInlineMethod:\n\tcase MonoInlineTok:\n\tcase MonoInlineSig:\n\tcase MonoShortInlineR:\n\tcase MonoInlineI:\n\t\tparameter->i32 = read32 (next_ip - 4);\n\t\t// FIXME check token type?\n\t\tbreak;\n\tcase MonoShortInlineI:\n\t\tparameter->i32 = (signed char)next_ip [-1];\n\t\tbreak;\n\tcase MonoInlineVar:\n\t\tparameter->i32 = read16 (next_ip - 2);\n\t\tbreak;\n\tcase MonoShortInlineVar:\n\t\tparameter->i32 = next_ip [-1];\n\t\tbreak;\n\tcase MonoInlineR:\n\tcase MonoInlineI8:\n\t\tparameter->i64 = read64 (next_ip - 8);\n\t\tbreak;\n\tcase MonoShortInlineBrTarget:\n\t\tdelta = (signed char)next_ip [-1];\n\t\tgoto branch_target;\n\tcase MonoInlineBrTarget:\n\t\tdelta = (gint32)read32 (next_ip - 4);\nbranch_target:\n\t\tparameter->branch_target = delta + next_ip;\n\t\tbreak;\n\tcase MonoInlineSwitch: // complicated\n\t\tbreak;\n\tdefault:\n\t\tg_error (\"%s %d %d\\n\", __func__, il_op, mono_opcodes [il_op].argument);\n\t}\n\treturn info;\n}\n\n/*\n * mono_method_to_ir:\n *\n * Translate the .net IL into linear IR.\n *\n * @start_bblock: if not NULL, the starting basic block, used during inlining.\n * @end_bblock: if not NULL, the ending basic block, used during inlining.\n * @return_var: if not NULL, the place where the return value is stored, used during inlining.   \n * @inline_args: if not NULL, contains the arguments to the inline call\n * @inline_offset: if not zero, the real offset from the inline call, or zero otherwise.\n * @is_virtual_call: whether this method is being called as a result of a call to callvirt\n *\n * This method is used to turn ECMA IL into Mono's internal Linear IR\n * reprensetation.  It is used both for entire methods, as well as\n * inlining existing methods.  In the former case, the @start_bblock,\n * @end_bblock, @return_var, @inline_args are all set to NULL, and the\n * inline_offset is set to zero.\n * \n * Returns: the inline cost, or -1 if there was an error processing this method.\n */\nint\nmono_method_to_ir (MonoCompile *cfg, MonoMethod *method, MonoBasicBlock *start_bblock, MonoBasicBlock *end_bblock, \n\t\t   MonoInst *return_var, MonoInst **inline_args, \n\t\t   guint inline_offset, gboolean is_virtual_call)\n{\n\tERROR_DECL (error);\n\t// Buffer to hold parameters to mono_new_array, instead of varargs.\n\tMonoInst *array_new_localalloc_ins = NULL;\n\tMonoInst *ins, **sp, **stack_start;\n\tMonoBasicBlock *tblock = NULL;\n\tMonoBasicBlock *init_localsbb = NULL, *init_localsbb2 = NULL;\n\tMonoSimpleBasicBlock *bb = NULL, *original_bb = NULL;\n\tMonoMethod *method_definition;\n\tMonoInst **arg_array;\n\tMonoMethodHeader *header;\n\tMonoImage *image;\n\tguint32 token, ins_flag;\n\tMonoClass *klass;\n\tMonoClass *constrained_class = NULL;\n\tgboolean save_last_error = FALSE;\n\tguchar *ip, *end, *target, *err_pos;\n\tMonoMethodSignature *sig;\n\tMonoGenericContext *generic_context = NULL;\n\tMonoGenericContainer *generic_container = NULL;\n\tMonoType **param_types;\n\tint i, n, start_new_bblock, dreg;\n\tint num_calls = 0, inline_costs = 0;\n\tint breakpoint_id = 0;\n\tguint num_args;\n\tGSList *class_inits = NULL;\n\tgboolean dont_verify, dont_verify_stloc, readonly = FALSE;\n\tint context_used;\n\tgboolean init_locals, seq_points, skip_dead_blocks;\n\tgboolean sym_seq_points = FALSE;\n\tMonoDebugMethodInfo *minfo;\n\tMonoBitSet *seq_point_locs = NULL;\n\tMonoBitSet *seq_point_set_locs = NULL;\n\tgboolean emitted_funccall_seq_point = FALSE;\n\n\tcfg->disable_inline = is_jit_optimizer_disabled (method);\n\tcfg->current_method = method;\n\n\timage = m_class_get_image (method->klass);\n\n\t/* serialization and xdomain stuff may need access to private fields and methods */\n\tdont_verify = image->assembly->corlib_internal? TRUE: FALSE;\n\tdont_verify |= method->wrapper_type == MONO_WRAPPER_XDOMAIN_INVOKE;\n\tdont_verify |= method->wrapper_type == MONO_WRAPPER_XDOMAIN_DISPATCH;\n \tdont_verify |= method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE; /* bug #77896 */\n\tdont_verify |= method->wrapper_type == MONO_WRAPPER_COMINTEROP;\n\tdont_verify |= method->wrapper_type == MONO_WRAPPER_COMINTEROP_INVOKE;\n\n\t/* still some type unsafety issues in marshal wrappers... (unknown is PtrToStructure) */\n\tdont_verify_stloc = method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE;\n\tdont_verify_stloc |= method->wrapper_type == MONO_WRAPPER_OTHER;\n\tdont_verify_stloc |= method->wrapper_type == MONO_WRAPPER_NATIVE_TO_MANAGED;\n\tdont_verify_stloc |= method->wrapper_type == MONO_WRAPPER_STELEMREF;\n\n\theader = mono_method_get_header_checked (method, cfg->error);\n\tif (!header) {\n\t\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_MONO_ERROR);\n\t\tgoto exception_exit;\n\t} else {\n\t\tcfg->headers_to_free = g_slist_prepend_mempool (cfg->mempool, cfg->headers_to_free, header);\n\t}\n\n\tgeneric_container = mono_method_get_generic_container (method);\n\tsig = mono_method_signature_internal (method);\n\tnum_args = sig->hasthis + sig->param_count;\n\tip = (guchar*)header->code;\n\tcfg->cil_start = ip;\n\tend = ip + header->code_size;\n\tcfg->stat_cil_code_size += header->code_size;\n\n\tseq_points = cfg->gen_seq_points && cfg->method == method;\n\n\tif (method->wrapper_type == MONO_WRAPPER_NATIVE_TO_MANAGED) {\n\t\t/* We could hit a seq point before attaching to the JIT (#8338) */\n\t\tseq_points = FALSE;\n\t}\n\n\tif (cfg->prof_coverage) {\n\t\tif (cfg->compile_aot)\n\t\t\tg_error (\"Coverage profiling is not supported with AOT.\");\n\n\t\tINLINE_FAILURE (\"coverage profiling\");\n\n\t\tcfg->coverage_info = mono_profiler_coverage_alloc (cfg->method, header->code_size);\n\t}\n\n\tif ((cfg->gen_sdb_seq_points && cfg->method == method) || cfg->prof_coverage) {\n\t\tminfo = mono_debug_lookup_method (method);\n\t\tif (minfo) {\n\t\t\tMonoSymSeqPoint *sps;\n\t\t\tint i, n_il_offsets;\n\n\t\t\tmono_debug_get_seq_points (minfo, NULL, NULL, NULL, &sps, &n_il_offsets);\n\t\t\tseq_point_locs = mono_bitset_mem_new (mono_mempool_alloc0 (cfg->mempool, mono_bitset_alloc_size (header->code_size, 0)), header->code_size, 0);\n\t\t\tseq_point_set_locs = mono_bitset_mem_new (mono_mempool_alloc0 (cfg->mempool, mono_bitset_alloc_size (header->code_size, 0)), header->code_size, 0);\n\t\t\tsym_seq_points = TRUE;\n\t\t\tfor (i = 0; i < n_il_offsets; ++i) {\n\t\t\t\tif (sps [i].il_offset < header->code_size)\n\t\t\t\t\tmono_bitset_set_fast (seq_point_locs, sps [i].il_offset);\n\t\t\t}\n\t\t\tg_free (sps);\n\n\t\t\tMonoDebugMethodAsyncInfo* asyncMethod = mono_debug_lookup_method_async_debug_info (method);\n\t\t\tif (asyncMethod) {\n\t\t\t\tfor (i = 0; asyncMethod != NULL && i < asyncMethod->num_awaits; i++)\n\t\t\t\t{\n\t\t\t\t\tmono_bitset_set_fast (seq_point_locs, asyncMethod->resume_offsets[i]);\n\t\t\t\t\tmono_bitset_set_fast (seq_point_locs, asyncMethod->yield_offsets[i]);\n\t\t\t\t}\n\t\t\t\tmono_debug_free_method_async_debug_info (asyncMethod);\n\t\t\t}\n\t\t} else if (!method->wrapper_type && !method->dynamic && mono_debug_image_has_debug_info (m_class_get_image (method->klass))) {\n\t\t\t/* Methods without line number info like auto-generated property accessors */\n\t\t\tseq_point_locs = mono_bitset_mem_new (mono_mempool_alloc0 (cfg->mempool, mono_bitset_alloc_size (header->code_size, 0)), header->code_size, 0);\n\t\t\tseq_point_set_locs = mono_bitset_mem_new (mono_mempool_alloc0 (cfg->mempool, mono_bitset_alloc_size (header->code_size, 0)), header->code_size, 0);\n\t\t\tsym_seq_points = TRUE;\n\t\t}\n\t}\n\n\t/* \n\t * Methods without init_locals set could cause asserts in various passes\n\t * (#497220). To work around this, we emit dummy initialization opcodes\n\t * (OP_DUMMY_ICONST etc.) which generate no code. These are only supported\n\t * on some platforms.\n\t */\n\tif (cfg->opt & MONO_OPT_UNSAFE)\n\t\tinit_locals = header->init_locals;\n\telse\n\t\tinit_locals = TRUE;\n\n\tmethod_definition = method;\n\twhile (method_definition->is_inflated) {\n\t\tMonoMethodInflated *imethod = (MonoMethodInflated *) method_definition;\n\t\tmethod_definition = imethod->declaring;\n\t}\n\n\t/* SkipVerification is not allowed if core-clr is enabled */\n\tif (!dont_verify && mini_assembly_can_skip_verification (cfg->domain, method)) {\n\t\tdont_verify = TRUE;\n\t\tdont_verify_stloc = TRUE;\n\t}\n\n\tif (sig->is_inflated)\n\t\tgeneric_context = mono_method_get_context (method);\n\telse if (generic_container)\n\t\tgeneric_context = &generic_container->context;\n\tcfg->generic_context = generic_context;\n\n\tif (!cfg->gshared)\n\t\tg_assert (!sig->has_type_parameters);\n\n\tif (sig->generic_param_count && method->wrapper_type == MONO_WRAPPER_NONE) {\n\t\tg_assert (method->is_inflated);\n\t\tg_assert (mono_method_get_context (method)->method_inst);\n\t}\n\tif (method->is_inflated && mono_method_get_context (method)->method_inst)\n\t\tg_assert (sig->generic_param_count);\n\n\tif (cfg->method == method) {\n\t\tcfg->real_offset = 0;\n\t} else {\n\t\tcfg->real_offset = inline_offset;\n\t}\n\n\tcfg->cil_offset_to_bb = (MonoBasicBlock **)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoBasicBlock*) * header->code_size);\n\tcfg->cil_offset_to_bb_len = header->code_size;\n\n\tif (cfg->verbose_level > 2)\n\t\tprintf (\"method to IR %s\\n\", mono_method_full_name (method, TRUE));\n\n\tparam_types = (MonoType **)mono_mempool_alloc (cfg->mempool, sizeof (MonoType*) * num_args);\n\tif (sig->hasthis)\n\t\tparam_types [0] = m_class_is_valuetype (method->klass) ? m_class_get_this_arg (method->klass) : m_class_get_byval_arg (method->klass);\n\tfor (n = 0; n < sig->param_count; ++n)\n\t\tparam_types [n + sig->hasthis] = sig->params [n];\n\tcfg->arg_types = param_types;\n\n\tcfg->dont_inline = g_list_prepend (cfg->dont_inline, method);\n\tif (cfg->method == method) {\n\t\t/* ENTRY BLOCK */\n\t\tNEW_BBLOCK (cfg, start_bblock);\n\t\tcfg->bb_entry = start_bblock;\n\t\tstart_bblock->cil_code = NULL;\n\t\tstart_bblock->cil_length = 0;\n\n\t\t/* EXIT BLOCK */\n\t\tNEW_BBLOCK (cfg, end_bblock);\n\t\tcfg->bb_exit = end_bblock;\n\t\tend_bblock->cil_code = NULL;\n\t\tend_bblock->cil_length = 0;\n\t\tend_bblock->flags |= BB_INDIRECT_JUMP_TARGET;\n\t\tg_assert (cfg->num_bblocks == 2);\n\n\t\targ_array = cfg->args;\n\n\t\tif (header->num_clauses) {\n\t\t\tcfg->spvars = g_hash_table_new (NULL, NULL);\n\t\t\tcfg->exvars = g_hash_table_new (NULL, NULL);\n\t\t}\n\t\t/* handle exception clauses */\n\t\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\t\tMonoBasicBlock *try_bb;\n\t\t\tMonoExceptionClause *clause = &header->clauses [i];\n\t\t\tGET_BBLOCK (cfg, try_bb, ip + clause->try_offset);\n\n\t\t\ttry_bb->real_offset = clause->try_offset;\n\t\t\ttry_bb->try_start = TRUE;\n\t\t\tGET_BBLOCK (cfg, tblock, ip + clause->handler_offset);\n\t\t\ttblock->real_offset = clause->handler_offset;\n\t\t\ttblock->flags |= BB_EXCEPTION_HANDLER;\n\n\t\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FINALLY)\n\t\t\t\tmono_create_exvar_for_offset (cfg, clause->handler_offset);\n\t\t\t/*\n\t\t\t * Linking the try block with the EH block hinders inlining as we won't be able to \n\t\t\t * merge the bblocks from inlining and produce an artificial hole for no good reason.\n\t\t\t */\n\t\t\tif (COMPILE_LLVM (cfg))\n\t\t\t\tlink_bblock (cfg, try_bb, tblock);\n\n\t\t\tif (*(ip + clause->handler_offset) == CEE_POP)\n\t\t\t\ttblock->flags |= BB_EXCEPTION_DEAD_OBJ;\n\n\t\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FINALLY ||\n\t\t\t    clause->flags == MONO_EXCEPTION_CLAUSE_FILTER ||\n\t\t\t    clause->flags == MONO_EXCEPTION_CLAUSE_FAULT) {\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_START_HANDLER);\n\t\t\t\tMONO_ADD_INS (tblock, ins);\n\n\t\t\t\tif (seq_points && clause->flags != MONO_EXCEPTION_CLAUSE_FINALLY && clause->flags != MONO_EXCEPTION_CLAUSE_FILTER) {\n\t\t\t\t\t/* finally clauses already have a seq point */\n\t\t\t\t\t/* seq points for filter clauses are emitted below */\n\t\t\t\t\tNEW_SEQ_POINT (cfg, ins, clause->handler_offset, TRUE);\n\t\t\t\t\tMONO_ADD_INS (tblock, ins);\n\t\t\t\t}\n\n\t\t\t\t/* todo: is a fault block unsafe to optimize? */\n\t\t\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FAULT)\n\t\t\t\t\ttblock->flags |= BB_EXCEPTION_UNSAFE;\n\t\t\t}\n\n\t\t\t/*printf (\"clause try IL_%04x to IL_%04x handler %d at IL_%04x to IL_%04x\\n\", clause->try_offset, clause->try_offset + clause->try_len, clause->flags, clause->handler_offset, clause->handler_offset + clause->handler_len);\n\t\t\t  while (p < end) {\n\t\t\t  printf (\"%s\", mono_disasm_code_one (NULL, method, p, &p));\n\t\t\t  }*/\n\t\t\t/* catch and filter blocks get the exception object on the stack */\n\t\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_NONE ||\n\t\t\t    clause->flags == MONO_EXCEPTION_CLAUSE_FILTER) {\n\n\t\t\t\t/* mostly like handle_stack_args (), but just sets the input args */\n\t\t\t\t/* printf (\"handling clause at IL_%04x\\n\", clause->handler_offset); */\n\t\t\t\ttblock->in_scount = 1;\n\t\t\t\ttblock->in_stack = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*));\n\t\t\t\ttblock->in_stack [0] = mono_create_exvar_for_offset (cfg, clause->handler_offset);\n\n\t\t\t\tcfg->cbb = tblock;\n\n#ifdef MONO_CONTEXT_SET_LLVM_EXC_REG\n\t\t\t\t/* The EH code passes in the exception in a register to both JITted and LLVM compiled code */\n\t\t\t\tif (!cfg->compile_llvm) {\n\t\t\t\t\tMONO_INST_NEW (cfg, ins, OP_GET_EX_OBJ);\n\t\t\t\t\tins->dreg = tblock->in_stack [0]->dreg;\n\t\t\t\t\tMONO_ADD_INS (tblock, ins);\n\t\t\t\t}\n#else\n\t\t\t\tMonoInst *dummy_use;\n\n\t\t\t\t/* \n\t\t\t\t * Add a dummy use for the exvar so its liveness info will be\n\t\t\t\t * correct.\n\t\t\t\t */\n\t\t\t\tEMIT_NEW_DUMMY_USE (cfg, dummy_use, tblock->in_stack [0]);\n#endif\n\n\t\t\t\tif (seq_points && clause->flags == MONO_EXCEPTION_CLAUSE_FILTER) {\n\t\t\t\t\tNEW_SEQ_POINT (cfg, ins, clause->handler_offset, TRUE);\n\t\t\t\t\tMONO_ADD_INS (tblock, ins);\n\t\t\t\t}\n\n\t\t\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER) {\n\t\t\t\t\tGET_BBLOCK (cfg, tblock, ip + clause->data.filter_offset);\n\t\t\t\t\ttblock->flags |= BB_EXCEPTION_HANDLER;\n\t\t\t\t\ttblock->real_offset = clause->data.filter_offset;\n\t\t\t\t\ttblock->in_scount = 1;\n\t\t\t\t\ttblock->in_stack = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*));\n\t\t\t\t\t/* The filter block shares the exvar with the handler block */\n\t\t\t\t\ttblock->in_stack [0] = mono_create_exvar_for_offset (cfg, clause->handler_offset);\n\t\t\t\t\tMONO_INST_NEW (cfg, ins, OP_START_HANDLER);\n\t\t\t\t\tMONO_ADD_INS (tblock, ins);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (clause->flags != MONO_EXCEPTION_CLAUSE_FILTER &&\n\t\t\t\t\tclause->data.catch_class &&\n\t\t\t\t\tcfg->gshared &&\n\t\t\t\t\tmono_class_check_context_used (clause->data.catch_class)) {\n\t\t\t\t/*\n\t\t\t\t * In shared generic code with catch\n\t\t\t\t * clauses containing type variables\n\t\t\t\t * the exception handling code has to\n\t\t\t\t * be able to get to the rgctx.\n\t\t\t\t * Therefore we have to make sure that\n\t\t\t\t * the vtable/mrgctx argument (for\n\t\t\t\t * static or generic methods) or the\n\t\t\t\t * \"this\" argument (for non-static\n\t\t\t\t * methods) are live.\n\t\t\t\t */\n\t\t\t\tif ((method->flags & METHOD_ATTRIBUTE_STATIC) ||\n\t\t\t\t\t\tmini_method_get_context (method)->method_inst ||\n\t\t\t\t\t\tm_class_is_valuetype (method->klass)) {\n\t\t\t\t\tmono_get_vtable_var (cfg);\n\t\t\t\t} else {\n\t\t\t\t\tMonoInst *dummy_use;\n\n\t\t\t\t\tEMIT_NEW_DUMMY_USE (cfg, dummy_use, arg_array [0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\targ_array = g_newa (MonoInst*, num_args);\n\t\tcfg->cbb = start_bblock;\n\t\tcfg->args = arg_array;\n\t\tmono_save_args (cfg, sig, inline_args);\n\t}\n\n\t/* FIRST CODE BLOCK */\n\tNEW_BBLOCK (cfg, tblock);\n\ttblock->cil_code = ip;\n\tcfg->cbb = tblock;\n\tcfg->ip = ip;\n\n\tADD_BBLOCK (cfg, tblock);\n\n\tif (cfg->method == method) {\n\t\tbreakpoint_id = mono_debugger_method_has_breakpoint (method);\n\t\tif (breakpoint_id) {\n\t\t\tMONO_INST_NEW (cfg, ins, OP_BREAK);\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t}\n\t}\n\n\t/* we use a separate basic block for the initialization code */\n\tNEW_BBLOCK (cfg, init_localsbb);\n\tif (cfg->method == method)\n\t\tcfg->bb_init = init_localsbb;\n\tinit_localsbb->real_offset = cfg->real_offset;\n\tstart_bblock->next_bb = init_localsbb;\n\tinit_localsbb->next_bb = cfg->cbb;\n\tlink_bblock (cfg, start_bblock, init_localsbb);\n\tlink_bblock (cfg, init_localsbb, cfg->cbb);\n\tinit_localsbb2 = init_localsbb;\n\tcfg->cbb = init_localsbb;\n\n\tif (cfg->gsharedvt && cfg->method == method) {\n\t\tMonoGSharedVtMethodInfo *info;\n\t\tMonoInst *var, *locals_var;\n\t\tint dreg;\n\n\t\tinfo = (MonoGSharedVtMethodInfo *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoGSharedVtMethodInfo));\n\t\tinfo->method = cfg->method;\n\t\tinfo->count_entries = 16;\n\t\tinfo->entries = (MonoRuntimeGenericContextInfoTemplate *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoRuntimeGenericContextInfoTemplate) * info->count_entries);\n\t\tcfg->gsharedvt_info = info;\n\n\t\tvar = mono_compile_create_var (cfg, mono_get_int_type (), OP_LOCAL);\n\t\t/* prevent it from being register allocated */\n\t\t//var->flags |= MONO_INST_VOLATILE;\n\t\tcfg->gsharedvt_info_var = var;\n\n\t\tins = emit_get_rgctx_gsharedvt_method (cfg, mini_method_check_context_used (cfg, method), method, info);\n\t\tMONO_EMIT_NEW_UNALU (cfg, OP_MOVE, var->dreg, ins->dreg);\n\n\t\t/* Allocate locals */\n\t\tlocals_var = mono_compile_create_var (cfg, mono_get_int_type (), OP_LOCAL);\n\t\t/* prevent it from being register allocated */\n\t\t//locals_var->flags |= MONO_INST_VOLATILE;\n\t\tcfg->gsharedvt_locals_var = locals_var;\n\n\t\tdreg = alloc_ireg (cfg);\n\t\tMONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADI4_MEMBASE, dreg, var->dreg, MONO_STRUCT_OFFSET (MonoGSharedVtMethodRuntimeInfo, locals_size));\n\n\t\tMONO_INST_NEW (cfg, ins, OP_LOCALLOC);\n\t\tins->dreg = locals_var->dreg;\n\t\tins->sreg1 = dreg;\n\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\tcfg->gsharedvt_locals_var_ins = ins;\n\t\t\n\t\tcfg->flags |= MONO_CFG_HAS_ALLOCA;\n\t\t/*\n\t\tif (init_locals)\n\t\t\tins->flags |= MONO_INST_INIT;\n\t\t*/\n\t}\n\n\tif (mono_security_core_clr_enabled ()) {\n\t\t/* check if this is native code, e.g. an icall or a p/invoke */\n\t\tif (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE) {\n\t\t\tMonoMethod *wrapped = mono_marshal_method_from_wrapper (method);\n\t\t\tif (wrapped) {\n\t\t\t\tgboolean pinvk = (wrapped->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL);\n\t\t\t\tgboolean icall = (wrapped->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL);\n\n\t\t\t\t/* if this ia a native call then it can only be JITted from platform code */\n\t\t\t\tif ((icall || pinvk) && method->klass && m_class_get_image (method->klass)) {\n\t\t\t\t\tif (!mono_security_core_clr_is_platform_image (m_class_get_image (method->klass))) {\n\t\t\t\t\t\tMonoException *ex = icall ? mono_get_exception_security () : \n\t\t\t\t\t\t\tmono_get_exception_method_access ();\n\t\t\t\t\t\temit_throw_exception (cfg, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tCHECK_CFG_EXCEPTION;\n\n\tif (header->code_size == 0)\n\t\tUNVERIFIED;\n\n\tif (get_basic_blocks (cfg, header, cfg->real_offset, ip, end, &err_pos)) {\n\t\tip = err_pos;\n\t\tUNVERIFIED;\n\t}\n\n\tif (cfg->method == method)\n\t\tmono_debug_init_method (cfg, cfg->cbb, breakpoint_id);\n\n\tfor (n = 0; n < header->num_locals; ++n) {\n\t\tif (header->locals [n]->type == MONO_TYPE_VOID && !header->locals [n]->byref)\n\t\t\tUNVERIFIED;\n\t}\n\tclass_inits = NULL;\n\n\t/* We force the vtable variable here for all shared methods\n\t   for the possibility that they might show up in a stack\n\t   trace where their exact instantiation is needed. */\n\tif (cfg->gshared && method == cfg->method) {\n\t\tif ((method->flags & METHOD_ATTRIBUTE_STATIC) ||\n\t\t\t\tmini_method_get_context (method)->method_inst ||\n\t\t\t\tm_class_is_valuetype (method->klass)) {\n\t\t\tmono_get_vtable_var (cfg);\n\t\t} else {\n\t\t\t/* FIXME: Is there a better way to do this?\n\t\t\t   We need the variable live for the duration\n\t\t\t   of the whole method. */\n\t\t\tcfg->args [0]->flags |= MONO_INST_VOLATILE;\n\t\t}\n\t}\n\n\t/* add a check for this != NULL to inlined methods */\n\tif (is_virtual_call) {\n\t\tMonoInst *arg_ins;\n\n\t\tNEW_ARGLOAD (cfg, arg_ins, 0);\n\t\tMONO_ADD_INS (cfg->cbb, arg_ins);\n\t\tMONO_EMIT_NEW_CHECK_THIS (cfg, arg_ins->dreg);\n\t}\n\n\tskip_dead_blocks = !dont_verify;\n\tif (skip_dead_blocks) {\n\t\toriginal_bb = bb = mono_basic_block_split (method, cfg->error, header);\n\t\tCHECK_CFG_ERROR;\n\t\tg_assert (bb);\n\t}\n\n\t/* we use a spare stack slot in SWITCH and NEWOBJ and others */\n\tstack_start = sp = (MonoInst **)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoInst*) * (header->max_stack + 1));\n\n\tins_flag = 0;\n\tstart_new_bblock = 0;\n\tMonoOpcodeEnum il_op; il_op = MonoOpcodeEnum_Invalid;\n\n\tfor (guchar *next_ip = ip; ip < end; ip = next_ip) {\n\t\tMonoOpcodeEnum previous_il_op = il_op;\n\t\tconst guchar *tmp_ip = ip;\n\t\tconst int op_size = mono_opcode_value_and_size (&tmp_ip, end, &il_op);\n\t\tCHECK_OPSIZE (op_size);\n\t\tnext_ip += op_size;\n\n\t\tif (cfg->method == method)\n\t\t\tcfg->real_offset = ip - header->code;\n\t\telse\n\t\t\tcfg->real_offset = inline_offset;\n\t\tcfg->ip = ip;\n\n\t\tcontext_used = 0;\n\n\t\tif (start_new_bblock) {\n\t\t\tcfg->cbb->cil_length = ip - cfg->cbb->cil_code;\n\t\t\tif (start_new_bblock == 2) {\n\t\t\t\tg_assert (ip == tblock->cil_code);\n\t\t\t} else {\n\t\t\t\tGET_BBLOCK (cfg, tblock, ip);\n\t\t\t}\n\t\t\tcfg->cbb->next_bb = tblock;\n\t\t\tcfg->cbb = tblock;\n\t\t\tstart_new_bblock = 0;\n\t\t\tfor (i = 0; i < cfg->cbb->in_scount; ++i) {\n\t\t\t\tif (cfg->verbose_level > 3)\n\t\t\t\t\tprintf (\"loading %d from temp %d\\n\", i, (int)cfg->cbb->in_stack [i]->inst_c0);\n\t\t\t\tEMIT_NEW_TEMPLOAD (cfg, ins, cfg->cbb->in_stack [i]->inst_c0);\n\t\t\t\t*sp++ = ins;\n\t\t\t}\n\t\t\tif (class_inits)\n\t\t\t\tg_slist_free (class_inits);\n\t\t\tclass_inits = NULL;\n\t\t} else {\n\t\t\tif ((tblock = cfg->cil_offset_to_bb [ip - cfg->cil_start]) && (tblock != cfg->cbb)) {\n\t\t\t\tlink_bblock (cfg, cfg->cbb, tblock);\n\t\t\t\tif (sp != stack_start) {\n\t\t\t\t\thandle_stack_args (cfg, stack_start, sp - stack_start);\n\t\t\t\t\tsp = stack_start;\n\t\t\t\t\tCHECK_UNVERIFIABLE (cfg);\n\t\t\t\t}\n\t\t\t\tcfg->cbb->next_bb = tblock;\n\t\t\t\tcfg->cbb = tblock;\n\t\t\t\tfor (i = 0; i < cfg->cbb->in_scount; ++i) {\n\t\t\t\t\tif (cfg->verbose_level > 3)\n\t\t\t\t\t\tprintf (\"loading %d from temp %d\\n\", i, (int)cfg->cbb->in_stack [i]->inst_c0);\n\t\t\t\t\tEMIT_NEW_TEMPLOAD (cfg, ins, cfg->cbb->in_stack [i]->inst_c0);\n\t\t\t\t\t*sp++ = ins;\n\t\t\t\t}\n\t\t\t\tg_slist_free (class_inits);\n\t\t\t\tclass_inits = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_dead_blocks) {\n\t\t\tint ip_offset = ip - header->code;\n\n\t\t\tif (ip_offset == bb->end)\n\t\t\t\tbb = bb->next;\n\n\t\t\tif (bb->dead) {\n\t\t\t\tg_assert (op_size > 0); /*The BB formation pass must catch all bad ops*/\n\n\t\t\t\tif (cfg->verbose_level > 3) printf (\"SKIPPING DEAD OP at %x\\n\", ip_offset);\n\n\t\t\t\tif (ip_offset + op_size == bb->end) {\n\t\t\t\t\tMONO_INST_NEW (cfg, ins, OP_NOP);\n\t\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\t\tstart_new_bblock = 1;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Sequence points are points where the debugger can place a breakpoint.\n\t\t * Currently, we generate these automatically at points where the IL\n\t\t * stack is empty.\n\t\t */\n\t\tif (seq_points && ((!sym_seq_points && (sp == stack_start)) || (sym_seq_points && mono_bitset_test_fast (seq_point_locs, ip - header->code)))) {\n\t\t\t/*\n\t\t\t * Make methods interruptable at the beginning, and at the targets of\n\t\t\t * backward branches.\n\t\t\t * Also, do this at the start of every bblock in methods with clauses too,\n\t\t\t * to be able to handle instructions with inprecise control flow like\n\t\t\t * throw/endfinally.\n\t\t\t * Backward branches are handled at the end of method-to-ir ().\n\t\t\t */\n\t\t\tgboolean intr_loc = ip == header->code || (!cfg->cbb->last_ins && cfg->header->num_clauses);\n\t\t\tgboolean sym_seq_point = sym_seq_points && mono_bitset_test_fast (seq_point_locs, ip - header->code);\n\n\t\t\t/* Avoid sequence points on empty IL like .volatile */\n\t\t\t// FIXME: Enable this\n\t\t\t//if (!(cfg->cbb->last_ins && cfg->cbb->last_ins->opcode == OP_SEQ_POINT)) {\n\t\t\tNEW_SEQ_POINT (cfg, ins, ip - header->code, intr_loc);\n\t\t\tif ((sp != stack_start) && !sym_seq_point)\n\t\t\t\tins->flags |= MONO_INST_NONEMPTY_STACK;\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\n\t\t\tif (sym_seq_points)\n\t\t\t\tmono_bitset_set_fast (seq_point_set_locs, ip - header->code);\n\n\t\t\tif (cfg->prof_coverage) {\n\t\t\t\tguint32 cil_offset = ip - header->code;\n\t\t\t\tgpointer counter = &cfg->coverage_info->data [cil_offset].count;\n\t\t\t\tcfg->coverage_info->data [cil_offset].cil_code = ip;\n\n\t\t\t\tif (mono_arch_opcode_supported (OP_ATOMIC_ADD_I4)) {\n\t\t\t\t\tMonoInst *one_ins, *load_ins;\n\n\t\t\t\t\tEMIT_NEW_PCONST (cfg, load_ins, counter);\n\t\t\t\t\tEMIT_NEW_ICONST (cfg, one_ins, 1);\n\t\t\t\t\tMONO_INST_NEW (cfg, ins, OP_ATOMIC_ADD_I4);\n\t\t\t\t\tins->dreg = mono_alloc_ireg (cfg);\n\t\t\t\t\tins->inst_basereg = load_ins->dreg;\n\t\t\t\t\tins->inst_offset = 0;\n\t\t\t\t\tins->sreg2 = one_ins->dreg;\n\t\t\t\t\tins->type = STACK_I4;\n\t\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\t} else {\n\t\t\t\t\tEMIT_NEW_PCONST (cfg, ins, counter);\n\t\t\t\t\tMONO_EMIT_NEW_STORE_MEMBASE_IMM (cfg, OP_STORE_MEMBASE_IMM, ins->dreg, 0, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcfg->cbb->real_offset = cfg->real_offset;\n\n\t\tif (cfg->verbose_level > 3)\n\t\t\tprintf (\"converting (in B%d: stack: %d) %s\", cfg->cbb->block_num, (int)(sp - stack_start), mono_disasm_code_one (NULL, method, ip, NULL));\n\n\t\t// Variables shared by CEE_CALLI CEE_CALL CEE_CALLVIRT CEE_JMP.\n\t\t// Initialize to either what they all need or zero.\n\t\tgboolean emit_widen = TRUE;\n\t\tgboolean tailcall = FALSE;\n\t\tgboolean common_call = FALSE;\n\t\tMonoInst *keep_this_alive = NULL;\n\t\tMonoMethod *cmethod = NULL;\n\t\tMonoMethodSignature *fsig = NULL;\n\n\t\t// These are used only in CALL/CALLVIRT but must be initialized also for CALLI,\n\t\t// since it jumps into CALL/CALLVIRT.\n\t\tgboolean need_seq_point = FALSE;\n\t\tgboolean push_res = TRUE;\n\t\tgboolean skip_ret = FALSE;\n\t\tgboolean tailcall_remove_ret = FALSE;\n\n\t\t// FIXME split 500 lines load/store field into separate file/function.\n\n\t\tMonoOpcodeParameter parameter;\n\t\tconst MonoOpcodeInfo* info = mono_opcode_decode (ip, op_size, il_op, &parameter);\n\t\tg_assert (info);\n\t\tn = parameter.i32;\n\t\ttoken = parameter.i32;\n\t\ttarget = parameter.branch_target;\n\n\t\t// Check stack size for push/pop except variable cases -- -1 like call/ret/newobj.\n\t\tconst int pushes = info->pushes;\n\t\tconst int pops = info->pops;\n\t\tif (pushes >= 0 && pops >= 0) {\n\t\t\tg_assert (pushes - pops <= 1);\n\t\t\tif (pushes - pops == 1)\n\t\t\t\tCHECK_STACK_OVF ();\n\t\t}\n\t\tif (pops >= 0)\n\t\t\tCHECK_STACK (pops);\n\n\t\tswitch (il_op) {\n\t\tcase MONO_CEE_NOP:\n\t\t\tif (seq_points && !sym_seq_points && sp != stack_start) {\n\t\t\t\t/*\n\t\t\t\t * The C# compiler uses these nops to notify the JIT that it should\n\t\t\t\t * insert seq points.\n\t\t\t\t */\n\t\t\t\tNEW_SEQ_POINT (cfg, ins, ip - header->code, FALSE);\n\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t}\n\t\t\tif (cfg->keep_cil_nops)\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_HARD_NOP);\n\t\t\telse\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_NOP);\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\temitted_funccall_seq_point = FALSE;\n\t\t\tbreak;\n\t\tcase MONO_CEE_BREAK:\n\t\t\tif (mini_should_insert_breakpoint (cfg->method)) {\n\t\t\t\tins = mono_emit_jit_icall (cfg, mono_debugger_agent_user_break, NULL);\n\t\t\t} else {\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_NOP);\n\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_CEE_LDARG_0:\n\t\tcase MONO_CEE_LDARG_1:\n\t\tcase MONO_CEE_LDARG_2:\n\t\tcase MONO_CEE_LDARG_3:\n\t\tcase MONO_CEE_LDARG_S:\n\t\tcase MONO_CEE_LDARG:\n\t\t\tCHECK_ARG (n);\n\t\t\tif (next_ip < end && is_addressable_valuetype_load (cfg, next_ip, cfg->arg_types[n])) {\n\t\t\t\tEMIT_NEW_ARGLOADA (cfg, ins, n);\n\t\t\t} else {\n\t\t\t\tEMIT_NEW_ARGLOAD (cfg, ins, n);\n\t\t\t}\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\n\t\tcase MONO_CEE_LDLOC_0:\n\t\tcase MONO_CEE_LDLOC_1:\n\t\tcase MONO_CEE_LDLOC_2:\n\t\tcase MONO_CEE_LDLOC_3:\n\t\tcase MONO_CEE_LDLOC_S:\n\t\tcase MONO_CEE_LDLOC:\n\t\t\tCHECK_LOCAL (n);\n\t\t\tif (next_ip < end && is_addressable_valuetype_load (cfg, next_ip, header->locals[n])) {\n\t\t\t\tEMIT_NEW_LOCLOADA (cfg, ins, n);\n\t\t\t} else {\n\t\t\t\tEMIT_NEW_LOCLOAD (cfg, ins, n);\n\t\t\t}\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\n\t\tcase MONO_CEE_STLOC_0:\n\t\tcase MONO_CEE_STLOC_1:\n\t\tcase MONO_CEE_STLOC_2:\n\t\tcase MONO_CEE_STLOC_3:\n\t\tcase MONO_CEE_STLOC_S:\n\t\tcase MONO_CEE_STLOC:\n\t\t\tCHECK_LOCAL (n);\n\t\t\t--sp;\n\t\t\t*sp = convert_value (cfg, header->locals [n], *sp);\n\t\t\tif (!dont_verify_stloc && target_type_is_incompatible (cfg, header->locals [n], *sp))\n\t\t\t\tUNVERIFIED;\n\t\t\temit_stloc_ir (cfg, sp, header, n);\n\t\t\tinline_costs += 1;\n\t\t\tbreak;\n\t\tcase MONO_CEE_LDARGA_S:\n\t\tcase MONO_CEE_LDARGA:\n\t\t\tCHECK_ARG (n);\n\t\t\tNEW_ARGLOADA (cfg, ins, n);\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\tcase MONO_CEE_STARG_S:\n\t\tcase MONO_CEE_STARG:\n\t\t\t--sp;\n\t\t\tCHECK_ARG (n);\n\t\t\t*sp = convert_value (cfg, param_types [n], *sp);\n\t\t\tif (!dont_verify_stloc && target_type_is_incompatible (cfg, param_types [n], *sp))\n\t\t\t\tUNVERIFIED;\n\t\t\temit_starg_ir (cfg, sp, n);\n\t\t\tbreak;\n\t\tcase MONO_CEE_LDLOCA:\n\t\tcase MONO_CEE_LDLOCA_S: {\n\t\t\tguchar *tmp_ip;\n\t\t\tCHECK_LOCAL (n);\n\n\t\t\tif ((tmp_ip = emit_optimized_ldloca_ir (cfg, next_ip, end, n))) {\n\t\t\t\tnext_ip = tmp_ip;\n\t\t\t\til_op = MONO_CEE_INITOBJ;\n\t\t\t\tinline_costs += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tEMIT_NEW_LOCLOADA (cfg, ins, n);\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_LDNULL:\n\t\t\tEMIT_NEW_PCONST (cfg, ins, NULL);\n\t\t\tins->type = STACK_OBJ;\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\tcase MONO_CEE_LDC_I4_M1:\n\t\tcase MONO_CEE_LDC_I4_0:\n\t\tcase MONO_CEE_LDC_I4_1:\n\t\tcase MONO_CEE_LDC_I4_2:\n\t\tcase MONO_CEE_LDC_I4_3:\n\t\tcase MONO_CEE_LDC_I4_4:\n\t\tcase MONO_CEE_LDC_I4_5:\n\t\tcase MONO_CEE_LDC_I4_6:\n\t\tcase MONO_CEE_LDC_I4_7:\n\t\tcase MONO_CEE_LDC_I4_8:\n\t\tcase MONO_CEE_LDC_I4_S:\n\t\tcase MONO_CEE_LDC_I4:\n\t\t\tEMIT_NEW_ICONST (cfg, ins, n);\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\tcase MONO_CEE_LDC_I8:\n\t\t\tMONO_INST_NEW (cfg, ins, OP_I8CONST);\n\t\t\tins->type = STACK_I8;\n\t\t\tins->dreg = alloc_dreg (cfg, STACK_I8);\n\t\t\tins->inst_l = parameter.i64;\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\tcase MONO_CEE_LDC_R4: {\n\t\t\tfloat *f;\n\t\t\tgboolean use_aotconst = FALSE;\n\n#ifdef TARGET_POWERPC\n\t\t\t/* FIXME: Clean this up */\n\t\t\tif (cfg->compile_aot)\n\t\t\t\tuse_aotconst = TRUE;\n#endif\n\t\t\t/* FIXME: we should really allocate this only late in the compilation process */\n\t\t\tf = (float *)mono_domain_alloc (cfg->domain, sizeof (float));\n\n\t\t\tif (use_aotconst) {\n\t\t\t\tMonoInst *cons;\n\t\t\t\tint dreg;\n\n\t\t\t\tEMIT_NEW_AOTCONST (cfg, cons, MONO_PATCH_INFO_R4, f);\n\n\t\t\t\tdreg = alloc_freg (cfg);\n\t\t\t\tEMIT_NEW_LOAD_MEMBASE (cfg, ins, OP_LOADR4_MEMBASE, dreg, cons->dreg, 0);\n\t\t\t\tins->type = cfg->r4_stack_type;\n\t\t\t} else {\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_R4CONST);\n\t\t\t\tins->type = cfg->r4_stack_type;\n\t\t\t\tins->dreg = alloc_dreg (cfg, STACK_R8);\n\t\t\t\tins->inst_p0 = f;\n\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t}\n\t\t\t*f = parameter.f;\n\t\t\t*sp++ = ins;\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_LDC_R8: {\n\t\t\tdouble *d;\n\t\t\tgboolean use_aotconst = FALSE;\n\n#ifdef TARGET_POWERPC\n\t\t\t/* FIXME: Clean this up */\n\t\t\tif (cfg->compile_aot)\n\t\t\t\tuse_aotconst = TRUE;\n#endif\n\n\t\t\t/* FIXME: we should really allocate this only late in the compilation process */\n\t\t\td = (double *)mono_domain_alloc (cfg->domain, sizeof (double));\n\n\t\t\tif (use_aotconst) {\n\t\t\t\tMonoInst *cons;\n\t\t\t\tint dreg;\n\n\t\t\t\tEMIT_NEW_AOTCONST (cfg, cons, MONO_PATCH_INFO_R8, d);\n\n\t\t\t\tdreg = alloc_freg (cfg);\n\t\t\t\tEMIT_NEW_LOAD_MEMBASE (cfg, ins, OP_LOADR8_MEMBASE, dreg, cons->dreg, 0);\n\t\t\t\tins->type = STACK_R8;\n\t\t\t} else {\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_R8CONST);\n\t\t\t\tins->type = STACK_R8;\n\t\t\t\tins->dreg = alloc_dreg (cfg, STACK_R8);\n\t\t\t\tins->inst_p0 = d;\n\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t}\n\t\t\t*d = parameter.d;\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_DUP: {\n\t\t\tMonoInst *temp, *store;\n\t\t\tsp--;\n\t\t\tins = *sp;\n\n\t\t\ttemp = mono_compile_create_var (cfg, type_from_stack_type (ins), OP_LOCAL);\n\t\t\tEMIT_NEW_TEMPSTORE (cfg, store, temp->inst_c0, ins);\n\n\t\t\tEMIT_NEW_TEMPLOAD (cfg, ins, temp->inst_c0);\n\t\t\t*sp++ = ins;\n\n\t\t\tEMIT_NEW_TEMPLOAD (cfg, ins, temp->inst_c0);\n\t\t\t*sp++ = ins;\n\n\t\t\tinline_costs += 2;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_POP:\n\t\t\t--sp;\n\n#ifdef TARGET_X86\n\t\t\tif (sp [0]->type == STACK_R8)\n\t\t\t\t/* we need to pop the value from the x86 FP stack */\n\t\t\t\tMONO_EMIT_NEW_UNALU (cfg, OP_X86_FPOP, -1, sp [0]->dreg);\n#endif\n\t\t\tbreak;\n\t\tcase MONO_CEE_JMP: {\n\t\t\tMonoCallInst *call;\n\t\t\tint i, n;\n\n\t\t\tINLINE_FAILURE (\"jmp\");\n\t\t\tGSHAREDVT_FAILURE (il_op);\n\n\t\t\tif (stack_start != sp)\n\t\t\t\tUNVERIFIED;\n\t\t\t/* FIXME: check the signature matches */\n\t\t\tcmethod = mini_get_method (cfg, method, token, NULL, generic_context);\n\t\t\tCHECK_CFG_ERROR;\n \n\t\t\tif (cfg->gshared && mono_method_check_context_used (cmethod))\n\t\t\t\tGENERIC_SHARING_FAILURE (CEE_JMP);\n\n\t\t\tmini_profiler_emit_tail_call (cfg, cmethod);\n\n\t\t\tfsig = mono_method_signature_internal (cmethod);\n\t\t\tn = fsig->param_count + fsig->hasthis;\n\t\t\tif (cfg->llvm_only) {\n\t\t\t\tMonoInst **args;\n\n\t\t\t\targs = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*) * n);\n\t\t\t\tfor (i = 0; i < n; ++i)\n\t\t\t\t\tEMIT_NEW_ARGLOAD (cfg, args [i], i);\n\t\t\t\tins = mini_emit_method_call_full (cfg, cmethod, fsig, TRUE, args, NULL, NULL, NULL);\n\t\t\t\t/*\n\t\t\t\t * The code in mono-basic-block.c treats the rest of the code as dead, but we\n\t\t\t\t * have to emit a normal return since llvm expects it.\n\t\t\t\t */\n\t\t\t\tif (cfg->ret)\n\t\t\t\t\temit_setret (cfg, ins);\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_BR);\n\t\t\t\tins->inst_target_bb = end_bblock;\n\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\tlink_bblock (cfg, cfg->cbb, end_bblock);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* Handle tailcalls similarly to calls */\n\t\t\t\tDISABLE_AOT (cfg);\n\n\t\t\t\tmini_emit_tailcall_parameters (cfg, fsig);\n\t\t\t\tMONO_INST_NEW_CALL (cfg, call, OP_TAILCALL);\n\t\t\t\tcall->method = cmethod;\n\t\t\t\t// FIXME Other initialization of the tailcall field occurs after\n\t\t\t\t// it is used. So this is the only \"real\" use and needs more attention.\n\t\t\t\tcall->tailcall = TRUE;\n\t\t\t\tcall->signature = fsig;\n\t\t\t\tcall->args = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*) * n);\n\t\t\t\tcall->inst.inst_p0 = cmethod;\n\t\t\t\tfor (i = 0; i < n; ++i)\n\t\t\t\t\tEMIT_NEW_ARGLOAD (cfg, call->args [i], i);\n\n\t\t\t\tif (mini_type_is_vtype (mini_get_underlying_type (call->signature->ret)))\n\t\t\t\t\tcall->vret_var = cfg->vret_addr;\n\n\t\t\t\tmono_arch_emit_call (cfg, call);\n\t\t\t\tcfg->param_area = MAX(cfg->param_area, call->stack_usage);\n\t\t\t\tMONO_ADD_INS (cfg->cbb, (MonoInst*)call);\n\t\t\t}\n\n\t\t\tstart_new_bblock = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_CALLI: {\n\t\t\t// FIXME tail.calli is problemetic because the this pointer's type\n\t\t\t// is not in the signature, and we cannot check for a byref valuetype.\n\t\t\tMonoInst *addr;\n\t\t\tMonoInst *callee = NULL;\n\n\t\t\t// Variables shared by CEE_CALLI and CEE_CALL/CEE_CALLVIRT.\n\t\t\tcommon_call = TRUE; // i.e. skip_ret/push_res/seq_point logic\n\t\t\tcmethod = NULL;\n\n\t\t\tgboolean const inst_tailcall = G_UNLIKELY (debug_tailcall_try_all\n\t\t\t\t\t\t\t? (next_ip < end && next_ip [0] == CEE_RET)\n\t\t\t\t\t\t\t: ((ins_flag & MONO_INST_TAILCALL) != 0));\n\t\t\tins = NULL;\n\n\t\t\t//GSHAREDVT_FAILURE (il_op);\n\t\t\tCHECK_STACK (1);\n\t\t\t--sp;\n\t\t\taddr = *sp;\n\t\t\tg_assert (addr);\n\t\t\tfsig = mini_get_signature (method, token, generic_context, cfg->error);\n\t\t\tCHECK_CFG_ERROR;\n\n\t\t\tif (method->dynamic && fsig->pinvoke) {\n\t\t\t\tMonoInst *args [3];\n\n\t\t\t\t/*\n\t\t\t\t * This is a call through a function pointer using a pinvoke\n\t\t\t\t * signature. Have to create a wrapper and call that instead.\n\t\t\t\t * FIXME: This is very slow, need to create a wrapper at JIT time\n\t\t\t\t * instead based on the signature.\n\t\t\t\t */\n\t\t\t\tEMIT_NEW_IMAGECONST (cfg, args [0], m_class_get_image (method->klass));\n\t\t\t\tEMIT_NEW_PCONST (cfg, args [1], fsig);\n\t\t\t\targs [2] = addr;\n\t\t\t\t// FIXME tailcall?\n\t\t\t\taddr = mono_emit_jit_icall (cfg, mono_get_native_calli_wrapper, args);\n\t\t\t}\n\n\t\t\tn = fsig->param_count + fsig->hasthis;\n\n\t\t\tCHECK_STACK (n);\n\n\t\t\t//g_assert (!virtual_ || fsig->hasthis);\n\n\t\t\tsp -= n;\n\n\t\t\tif (!(cfg->method->wrapper_type && cfg->method->wrapper_type != MONO_WRAPPER_DYNAMIC_METHOD) && check_call_signature (cfg, fsig, sp)) {\n\t\t\t\tif (break_on_unverified ())\n\t\t\t\t\tcheck_call_signature (cfg, fsig, sp); // Again, step through it.\n\t\t\t\tUNVERIFIED;\n\t\t\t}\n\n\t\t\tinline_costs += CALL_COST * MIN(10, num_calls++);\n\n\t\t\t/*\n\t\t\t * Making generic calls out of gsharedvt methods.\n\t\t\t * This needs to be used for all generic calls, not just ones with a gsharedvt signature, to avoid\n\t\t\t * patching gshared method addresses into a gsharedvt method.\n\t\t\t */\n\t\t\tif (cfg->gsharedvt && mini_is_gsharedvt_signature (fsig)) {\n\t\t\t\t/*\n\t\t\t\t * We pass the address to the gsharedvt trampoline in the rgctx reg\n\t\t\t\t */\n\t\t\t\tcallee = addr;\n\t\t\t\tg_assert (addr); // Doubles as boolean after tailcall check.\n\t\t\t}\n\n\t\t\tinst_tailcall && is_supported_tailcall (cfg, ip, method, NULL, fsig,\n\t\t\t\t\t\tFALSE/*virtual irrelevant*/, addr != NULL, &tailcall);\n\n\t\t\tif (callee) {\n\t\t\t\tif (method->wrapper_type != MONO_WRAPPER_DELEGATE_INVOKE)\n\t\t\t\t\t/* Not tested */\n\t\t\t\t\tGSHAREDVT_FAILURE (il_op);\n\n\t\t\t\tif (cfg->llvm_only)\n\t\t\t\t\t// FIXME:\n\t\t\t\t\tGSHAREDVT_FAILURE (il_op);\n\n\t\t\t\taddr = emit_get_rgctx_sig (cfg, context_used, fsig, MONO_RGCTX_INFO_SIG_GSHAREDVT_OUT_TRAMPOLINE_CALLI);\n\t\t\t\tins = (MonoInst*)mini_emit_calli_full (cfg, fsig, sp, addr, NULL, callee, tailcall);\n\t\t\t\tgoto calli_end;\n\t\t\t}\n\n\t\t\t/* Prevent inlining of methods with indirect calls */\n\t\t\tINLINE_FAILURE (\"indirect call\");\n\n\t\t\tif (addr->opcode == OP_PCONST || addr->opcode == OP_AOTCONST || addr->opcode == OP_GOT_ENTRY) {\n\t\t\t\tMonoJumpInfoType info_type;\n\t\t\t\tgpointer info_data;\n\n\t\t\t\t/*\n\t\t\t\t * Instead of emitting an indirect call, emit a direct call\n\t\t\t\t * with the contents of the aotconst as the patch info.\n\t\t\t\t */\n\t\t\t\tif (addr->opcode == OP_PCONST || addr->opcode == OP_AOTCONST) {\n\t\t\t\t\tinfo_type = (MonoJumpInfoType)addr->inst_c1;\n\t\t\t\t\tinfo_data = addr->inst_p0;\n\t\t\t\t} else {\n\t\t\t\t\tinfo_type = (MonoJumpInfoType)addr->inst_right->inst_c1;\n\t\t\t\t\tinfo_data = addr->inst_right->inst_left;\n\t\t\t\t}\n\n\t\t\t\tif (info_type == MONO_PATCH_INFO_ICALL_ADDR) {\n\t\t\t\t\t// non-JIT icall, mostly builtin, but also user-extensible\n\t\t\t\t\ttailcall = FALSE;\n\t\t\t\t\tins = (MonoInst*)mini_emit_abs_call (cfg, MONO_PATCH_INFO_ICALL_ADDR_CALL, info_data, fsig, sp);\n\t\t\t\t\tNULLIFY_INS (addr);\n\t\t\t\t\tgoto calli_end;\n\t\t\t\t} else if (info_type == MONO_PATCH_INFO_JIT_ICALL_ADDR\n\t\t\t\t\t\t|| info_type == MONO_PATCH_INFO_SPECIFIC_TRAMPOLINE_LAZY_FETCH_ADDR) {\n\t\t\t\t\ttailcall = FALSE;\n\t\t\t\t\tins = (MonoInst*)mini_emit_abs_call (cfg, info_type, info_data, fsig, sp);\n\t\t\t\t\tNULLIFY_INS (addr);\n\t\t\t\t\tgoto calli_end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tins = (MonoInst*)mini_emit_calli_full (cfg, fsig, sp, addr, NULL, NULL, tailcall);\n\t\t\tgoto calli_end;\n\t\t}\n\t\tcase MONO_CEE_CALL:\n\t\tcase MONO_CEE_CALLVIRT: {\n\t\t\tMonoInst *addr; addr = NULL;\n\t\t\tint array_rank; array_rank = 0;\n\t\t\tgboolean virtual_; virtual_ = il_op == MONO_CEE_CALLVIRT;\n\t\t\tgboolean pass_imt_from_rgctx; pass_imt_from_rgctx = FALSE;\n\t\t\tMonoInst *imt_arg; imt_arg = NULL;\n\t\t\tgboolean pass_vtable; pass_vtable = FALSE;\n\t\t\tgboolean pass_mrgctx; pass_mrgctx = FALSE;\n\t\t\tMonoInst *vtable_arg; vtable_arg = NULL;\n\t\t\tgboolean check_this; check_this = FALSE;\n\t\t\tgboolean delegate_invoke; delegate_invoke = FALSE;\n\t\t\tgboolean direct_icall; direct_icall = FALSE;\n\t\t\tgboolean tailcall_calli; tailcall_calli = FALSE;\n\t\t\tgboolean noreturn; noreturn = FALSE;\n\n\t\t\t// Variables shared by CEE_CALLI and CEE_CALL/CEE_CALLVIRT.\n\t\t\tcommon_call = FALSE;\n\n\t\t\t// variables to help in assertions\n\t\t\tgboolean called_is_supported_tailcall; called_is_supported_tailcall = FALSE;\n\t\t\tMonoMethod *tailcall_method; tailcall_method = NULL;\n\t\t\tMonoMethod *tailcall_cmethod; tailcall_cmethod = NULL;\n\t\t\tMonoMethodSignature *tailcall_fsig; tailcall_fsig = NULL;\n\t\t\tgboolean tailcall_virtual; tailcall_virtual = FALSE;\n\t\t\tgboolean tailcall_extra_arg; tailcall_extra_arg = FALSE;\n\n\t\t\tgboolean inst_tailcall; inst_tailcall = G_UNLIKELY (debug_tailcall_try_all\n\t\t\t\t\t\t\t? (next_ip < end && next_ip [0] == CEE_RET)\n\t\t\t\t\t\t\t: ((ins_flag & MONO_INST_TAILCALL) != 0));\n\t\t\tins = NULL;\n\n\t\t\t/* Used to pass arguments to called functions */\n\t\t\tHandleCallData cdata;\n\t\t\tmemset (&cdata, 0, sizeof (HandleCallData));\n\n\t\t\tcmethod = mini_get_method (cfg, method, token, NULL, generic_context);\n\t\t\tCHECK_CFG_ERROR;\n\n\t\t\tif (cfg->verbose_level > 3)\n\t\t\t\tprintf (\"cmethod = %s\\n\", mono_method_get_full_name (cmethod));\n\n\t\t\tMonoMethod *cil_method; cil_method = cmethod;\n\t\t\t\t\n\t\t\tif (constrained_class) {\n\t\t\t\tgboolean constrained_is_generic_param =\n\t\t\t\t\tm_class_get_byval_arg (constrained_class)->type == MONO_TYPE_VAR ||\n\t\t\t\t\tm_class_get_byval_arg (constrained_class)->type == MONO_TYPE_MVAR;\n\n\t\t\t\tif (method->wrapper_type != MONO_WRAPPER_NONE) {\n\t\t\t\t\tif (cfg->verbose_level > 2)\n\t\t\t\t\t\tprintf (\"DM Constrained call to %s\\n\", mono_type_get_full_name (constrained_class));\n\t\t\t\t\tif (!(constrained_is_generic_param &&\n\t\t\t\t\t\t  cfg->gshared)) {\n\t\t\t\t\t\tcmethod = mono_get_method_constrained_with_method (image, cil_method, constrained_class, generic_context, cfg->error);\n\t\t\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (cfg->verbose_level > 2)\n\t\t\t\t\t\tprintf (\"Constrained call to %s\\n\", mono_type_get_full_name (constrained_class));\n\n\t\t\t\t\tif (constrained_is_generic_param && cfg->gshared) {\n\t\t\t\t\t\t/* \n\t\t\t\t\t\t * This is needed since get_method_constrained can't find \n\t\t\t\t\t\t * the method in klass representing a type var.\n\t\t\t\t\t\t * The type var is guaranteed to be a reference type in this\n\t\t\t\t\t\t * case.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!mini_is_gsharedvt_klass (constrained_class))\n\t\t\t\t\t\t\tg_assert (!m_class_is_valuetype (cmethod->klass));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcmethod = mono_get_method_constrained_checked (image, token, constrained_class, generic_context, &cil_method, cfg->error);\n\t\t\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (m_class_is_enumtype (constrained_class) && !strcmp (cmethod->name, \"GetHashCode\")) {\n\t\t\t\t\t/* Use the corresponding method from the base type to avoid boxing */\n\t\t\t\t\tMonoType *base_type = mono_class_enum_basetype_internal (constrained_class);\n\t\t\t\t\tg_assert (base_type);\n\t\t\t\t\tconstrained_class = mono_class_from_mono_type_internal (base_type);\n\t\t\t\t\tcmethod = get_method_nofail (constrained_class, cmethod->name, 0, 0);\n\t\t\t\t\tg_assert (cmethod);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\n\t\t\tif (!dont_verify && !cfg->skip_visibility) {\n\t\t\t\tMonoMethod *target_method = cil_method;\n\t\t\t\tif (method->is_inflated) {\n\t\t\t\t\ttarget_method = mini_get_method_allow_open (method, token, NULL, &(mono_method_get_generic_container (method_definition)->context), cfg->error);\n\t\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t\t}\n\t\t\t\tif (!mono_method_can_access_method (method_definition, target_method) &&\n\t\t\t\t\t!mono_method_can_access_method (method, cil_method))\n\t\t\t\t\temit_method_access_failure (cfg, method, cil_method);\n\t\t\t}\n\n\t\t\tif (mono_security_core_clr_enabled ())\n\t\t\t\tensure_method_is_allowed_to_call_method (cfg, method, cil_method);\n\n\t\t\tif (!virtual_ && (cmethod->flags & METHOD_ATTRIBUTE_ABSTRACT)) {\n\t\t\t\tif (!mono_class_is_interface (method->klass))\n\t\t\t\t\temit_bad_image_failure (cfg, method, cil_method);\n\t\t\t\telse\n\t\t\t\t\tvirtual_ = TRUE;\n\t\t\t}\n\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * MS.NET accepts non virtual calls to virtual final methods of transparent proxy classes and\n\t\t\t\t * converts to a callvirt.\n\t\t\t\t *\n\t\t\t\t * tests/bug-515884.il is an example of this behavior\n\t\t\t\t */\n\t\t\t\tconst int test_flags = METHOD_ATTRIBUTE_VIRTUAL | METHOD_ATTRIBUTE_FINAL | METHOD_ATTRIBUTE_STATIC;\n\t\t\t\tconst int expected_flags = METHOD_ATTRIBUTE_VIRTUAL | METHOD_ATTRIBUTE_FINAL;\n\t\t\t\tif (!virtual_ && mono_class_is_marshalbyref (cmethod->klass) && (cmethod->flags & test_flags) == expected_flags && cfg->method->wrapper_type == MONO_WRAPPER_NONE)\n\t\t\t\t\tvirtual_ = TRUE;\n\t\t\t}\n\n\t\t\tif (!m_class_is_inited (cmethod->klass))\n\t\t\t\tif (!mono_class_init_internal (cmethod->klass))\n\t\t\t\t\tTYPE_LOAD_ERROR (cmethod->klass);\n\n\t\t\tfsig = mono_method_signature_internal (cmethod);\n\t\t\tif (!fsig)\n\t\t\t\tLOAD_ERROR;\n\t\t\tif (cmethod->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL &&\n\t\t\t\tmini_class_is_system_array (cmethod->klass)) {\n\t\t\t\tarray_rank = m_class_get_rank (cmethod->klass);\n\t\t\t} else if ((cmethod->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) && direct_icalls_enabled (cfg, cmethod)) {\n\t\t\t\tdirect_icall = TRUE;\n\t\t\t} else if (fsig->pinvoke) {\n\t\t\t\tMonoMethod *wrapper = mono_marshal_get_native_wrapper (cmethod, TRUE, cfg->compile_aot);\n\t\t\t\tfsig = mono_method_signature_internal (wrapper);\n\t\t\t} else if (constrained_class) {\n\t\t\t} else {\n\t\t\t\tfsig = mono_method_get_signature_checked (cmethod, image, token, generic_context, cfg->error);\n\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t}\n\n\t\t\tif (cfg->llvm_only && !cfg->method->wrapper_type && (!cmethod || cmethod->is_inflated))\n\t\t\t\tcfg->signatures = g_slist_prepend_mempool (cfg->mempool, cfg->signatures, fsig);\n\n\t\t\t/* See code below */\n\t\t\tif (cmethod->klass == mono_defaults.monitor_class && !strcmp (cmethod->name, \"Enter\") && mono_method_signature_internal (cmethod)->param_count == 1) {\n\t\t\t\tMonoBasicBlock *tbb;\n\n\t\t\t\tGET_BBLOCK (cfg, tbb, next_ip);\n\t\t\t\tif (tbb->try_start && MONO_REGION_FLAGS(tbb->region) == MONO_EXCEPTION_CLAUSE_FINALLY) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We want to extend the try block to cover the call, but we can't do it if the\n\t\t\t\t\t * call is made directly since its followed by an exception check.\n\t\t\t\t\t */\n\t\t\t\t\tdirect_icall = FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmono_save_token_info (cfg, image, token, cil_method);\n\n\t\t\tif (!(seq_point_locs && mono_bitset_test_fast (seq_point_locs, next_ip - header->code)))\n\t\t\t\tneed_seq_point = TRUE;\n\n\t\t\t/* Don't support calls made using type arguments for now */\n\t\t\t/*\n\t\t\t  if (cfg->gsharedvt) {\n\t\t\t  if (mini_is_gsharedvt_signature (fsig))\n\t\t\t  GSHAREDVT_FAILURE (il_op);\n\t\t\t  }\n\t\t\t*/\n\n\t\t\tif (cmethod->string_ctor && method->wrapper_type != MONO_WRAPPER_RUNTIME_INVOKE)\n\t\t\t\tg_assert_not_reached ();\n\n\t\t\tn = fsig->param_count + fsig->hasthis;\n\n\t\t\tif (!cfg->gshared && mono_class_is_gtd (cmethod->klass))\n\t\t\t\tUNVERIFIED;\n\n\t\t\tif (!cfg->gshared)\n\t\t\t\tg_assert (!mono_method_check_context_used (cmethod));\n\n\t\t\tCHECK_STACK (n);\n\n\t\t\t//g_assert (!virtual_ || fsig->hasthis);\n\n\t\t\tsp -= n;\n\n\t\t\tif (virtual_ && cmethod && sp [0]->opcode == OP_TYPED_OBJREF) {\n\t\t\t\tERROR_DECL (error);\n\n\t\t\t\tMonoMethod *new_cmethod = mono_class_get_virtual_method (sp [0]->klass, cmethod, FALSE, error);\n\t\t\t\tmono_error_assert_ok (error);\n\t\t\t\tcmethod = new_cmethod;\n\t\t\t\tvirtual_ = FALSE;\n\t\t\t}\n\n\t\t\tif (cmethod && method_does_not_return (cmethod)) {\n\t\t\t\tcfg->cbb->out_of_line = TRUE;\n\t\t\t\tnoreturn = TRUE;\n\t\t\t}\n\n\t\t\tcdata.method = method;\n\t\t\tcdata.inst_tailcall = inst_tailcall;\n\n\t\t\t/*\n\t\t\t * We have the `constrained.' prefix opcode.\n\t\t\t */\n\t\t\tif (constrained_class) {\n\t\t\t\tins = handle_constrained_call (cfg, cmethod, fsig, constrained_class, sp, &cdata, &cmethod, &virtual_, &emit_widen);\n\t\t\t\tCHECK_CFG_EXCEPTION;\n\t\t\t\tconstrained_class = NULL;\n\t\t\t\tif (ins)\n\t\t\t\t\tgoto call_end;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < fsig->param_count; ++i)\n\t\t\t\tsp [i + fsig->hasthis] = convert_value (cfg, fsig->params [i], sp [i + fsig->hasthis]);\n\n\t\t\tif (check_call_signature (cfg, fsig, sp)) {\n\t\t\t\tif (break_on_unverified ())\n\t\t\t\t\tcheck_call_signature (cfg, fsig, sp); // Again, step through it.\n\t\t\t\tUNVERIFIED;\n\t\t\t}\n\n\t\t\tif ((m_class_get_parent (cmethod->klass) == mono_defaults.multicastdelegate_class) && !strcmp (cmethod->name, \"Invoke\"))\n\t\t\t\tdelegate_invoke = TRUE;\n\n\t\t\tif ((cfg->opt & MONO_OPT_INTRINS) && (ins = mini_emit_inst_for_sharable_method (cfg, cmethod, fsig, sp))) {\n\t\t\t\tif (!MONO_TYPE_IS_VOID (fsig->ret)) {\n\t\t\t\t\tmini_type_to_eval_stack_type ((cfg), fsig->ret, ins);\n\t\t\t\t\temit_widen = FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (inst_tailcall) // FIXME\n\t\t\t\t\tmono_tailcall_print (\"missed tailcall intrins_sharable %s -> %s\\n\", method->name, cmethod->name);\n\t\t\t\tgoto call_end;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Implement a workaround for the inherent races involved in locking:\n\t\t\t * Monitor.Enter ()\n\t\t\t * try {\n\t\t\t * } finally {\n\t\t\t *    Monitor.Exit ()\n\t\t\t * }\n\t\t\t * If a thread abort happens between the call to Monitor.Enter () and the start of the\n\t\t\t * try block, the Exit () won't be executed, see:\n\t\t\t * http://www.bluebytesoftware.com/blog/2007/01/30/MonitorEnterThreadAbortsAndOrphanedLocks.aspx\n\t\t\t * To work around this, we extend such try blocks to include the last x bytes\n\t\t\t * of the Monitor.Enter () call.\n\t\t\t */\n\t\t\tif (cmethod->klass == mono_defaults.monitor_class && !strcmp (cmethod->name, \"Enter\") && mono_method_signature_internal (cmethod)->param_count == 1) {\n\t\t\t\tMonoBasicBlock *tbb;\n\n\t\t\t\tGET_BBLOCK (cfg, tbb, next_ip);\n\t\t\t\t/* \n\t\t\t\t * Only extend try blocks with a finally, to avoid catching exceptions thrown\n\t\t\t\t * from Monitor.Enter like ArgumentNullException.\n\t\t\t\t */\n\t\t\t\tif (tbb->try_start && MONO_REGION_FLAGS(tbb->region) == MONO_EXCEPTION_CLAUSE_FINALLY) {\n\t\t\t\t\t/* Mark this bblock as needing to be extended */\n\t\t\t\t\ttbb->extend_try_block = TRUE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Conversion to a JIT intrinsic */\n\t\t\tif ((ins = mini_emit_inst_for_method (cfg, cmethod, fsig, sp))) {\n\t\t\t\tif (!MONO_TYPE_IS_VOID (fsig->ret)) {\n\t\t\t\t\tmini_type_to_eval_stack_type ((cfg), fsig->ret, ins);\n\t\t\t\t\temit_widen = FALSE;\n\t\t\t\t}\n\t\t\t\t// FIXME This is only missed if in fact the intrinsic involves a call.\n\t\t\t\tif (inst_tailcall) // FIXME\n\t\t\t\t\tmono_tailcall_print (\"missed tailcall intrins %s -> %s\\n\", method->name, cmethod->name);\n\t\t\t\tgoto call_end;\n\t\t\t}\n\t\t\tCHECK_CFG_ERROR;\n\n\t\t\t/* \n\t\t\t * If the callee is a shared method, then its static cctor\n\t\t\t * might not get called after the call was patched.\n\t\t\t */\n\t\t\tif (cfg->gshared && cmethod->klass != method->klass && mono_class_is_ginst (cmethod->klass) && mono_method_is_generic_sharable (cmethod, TRUE) && mono_class_needs_cctor_run (cmethod->klass, method)) {\n\t\t\t\temit_class_init (cfg, cmethod->klass);\n\t\t\t\tCHECK_TYPELOAD (cmethod->klass);\n\t\t\t}\n\n\t\t\tcheck_method_sharing (cfg, cmethod, &pass_vtable, &pass_mrgctx);\n\n\t\t\tif (cfg->gshared) {\n\t\t\t\tMonoGenericContext *cmethod_context = mono_method_get_context (cmethod);\n\n\t\t\t\tcontext_used = mini_method_check_context_used (cfg, cmethod);\n\n\t\t\t\tif (context_used && mono_class_is_interface (cmethod->klass)) {\n\t\t\t\t\t/* Generic method interface\n\t\t\t\t\t   calls are resolved via a\n\t\t\t\t\t   helper function and don't\n\t\t\t\t\t   need an imt. */\n\t\t\t\t\tif (!cmethod_context || !cmethod_context->method_inst)\n\t\t\t\t\t\tpass_imt_from_rgctx = TRUE;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * If a shared method calls another\n\t\t\t\t * shared method then the caller must\n\t\t\t\t * have a generic sharing context\n\t\t\t\t * because the magic trampoline\n\t\t\t\t * requires it.  FIXME: We shouldn't\n\t\t\t\t * have to force the vtable/mrgctx\n\t\t\t\t * variable here.  Instead there\n\t\t\t\t * should be a flag in the cfg to\n\t\t\t\t * request a generic sharing context.\n\t\t\t\t */\n\t\t\t\tif (context_used &&\n\t\t\t\t    ((cfg->method->flags & METHOD_ATTRIBUTE_STATIC) || m_class_is_valuetype (cfg->method->klass)))\n\t\t\t\t\tmono_get_vtable_var (cfg);\n\t\t\t}\n\n\t\t\tif (pass_vtable) {\n\t\t\t\tif (context_used) {\n\t\t\t\t\tvtable_arg = mini_emit_get_rgctx_klass (cfg, context_used, cmethod->klass, MONO_RGCTX_INFO_VTABLE);\n\t\t\t\t} else {\n\t\t\t\t\tMonoVTable *vtable = mono_class_vtable_checked (cfg->domain, cmethod->klass, cfg->error);\n\t\t\t\t\tCHECK_CFG_ERROR;\n\n\t\t\t\t\tCHECK_TYPELOAD (cmethod->klass);\n\t\t\t\t\tEMIT_NEW_VTABLECONST (cfg, vtable_arg, vtable);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pass_mrgctx) {\n\t\t\t\tg_assert (!vtable_arg);\n\n\t\t\t\tif (!cfg->compile_aot) {\n\t\t\t\t\t/* \n\t\t\t\t\t * emit_get_rgctx_method () calls mono_class_vtable () so check \n\t\t\t\t\t * for type load errors before.\n\t\t\t\t\t */\n\t\t\t\t\tmono_class_setup_vtable (cmethod->klass);\n\t\t\t\t\tCHECK_TYPELOAD (cmethod->klass);\n\t\t\t\t}\n\n\t\t\t\tvtable_arg = emit_get_rgctx_method (cfg, context_used, cmethod, MONO_RGCTX_INFO_METHOD_RGCTX);\n\n\t\t\t\t/* !marshalbyref is needed to properly handle generic methods + remoting */\n\t\t\t\tif ((!(cmethod->flags & METHOD_ATTRIBUTE_VIRTUAL) ||\n\t\t\t\t\t MONO_METHOD_IS_FINAL (cmethod)) &&\n\t\t\t\t\t!mono_class_is_marshalbyref (cmethod->klass)) {\n\t\t\t\t\tif (virtual_)\n\t\t\t\t\t\tcheck_this = TRUE;\n\t\t\t\t\tvirtual_ = FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pass_imt_from_rgctx) {\n\t\t\t\tg_assert (!pass_vtable);\n\n\t\t\t\timt_arg = emit_get_rgctx_method (cfg, context_used,\n\t\t\t\t\tcmethod, MONO_RGCTX_INFO_METHOD);\n\t\t\t\tg_assert (imt_arg);\n\t\t\t}\n\n\t\t\tif (check_this)\n\t\t\t\tMONO_EMIT_NEW_CHECK_THIS (cfg, sp [0]->dreg);\n\n\t\t\t/* Calling virtual generic methods */\n\n\t\t\t// These temporaries help detangle \"pure\" computation of\n\t\t\t// inputs to is_supported_tailcall from side effects, so that\n\t\t\t// is_supported_tailcall can be computed just once.\n\t\t\tgboolean virtual_generic; virtual_generic = FALSE;\n\t\t\tgboolean virtual_generic_imt; virtual_generic_imt = FALSE;\n\n\t\t\tif (virtual_ && (cmethod->flags & METHOD_ATTRIBUTE_VIRTUAL) &&\n\t\t\t    !(MONO_METHOD_IS_FINAL (cmethod) &&\n\t\t\t      cmethod->wrapper_type != MONO_WRAPPER_REMOTING_INVOKE_WITH_CHECK) &&\n\t\t\t    fsig->generic_param_count &&\n\t\t\t\t!(cfg->gsharedvt && mini_is_gsharedvt_signature (fsig)) &&\n\t\t\t\t!cfg->llvm_only) {\n\n\t\t\t\tg_assert (fsig->is_inflated);\n\n\t\t\t\tvirtual_generic = TRUE;\n\n\t\t\t\t/* Prevent inlining of methods that contain indirect calls */\n\t\t\t\tINLINE_FAILURE (\"virtual generic call\");\n\n\t\t\t\tif (cfg->gsharedvt && mini_is_gsharedvt_signature (fsig))\n\t\t\t\t\tGSHAREDVT_FAILURE (il_op);\n\n\t\t\t\tif (cfg->backend->have_generalized_imt_trampoline && cfg->backend->gshared_supported && cmethod->wrapper_type == MONO_WRAPPER_NONE) {\n\t\t\t\t\tvirtual_generic_imt = TRUE;\n\t\t\t\t\tg_assert (!imt_arg);\n\t\t\t\t\tif (!context_used)\n\t\t\t\t\t\tg_assert (cmethod->is_inflated);\n\n\t\t\t\t\timt_arg = emit_get_rgctx_method (cfg, context_used, cmethod, MONO_RGCTX_INFO_METHOD);\n\t\t\t\t\tg_assert (imt_arg);\n\n\t\t\t\t\tvirtual_ = TRUE;\n\t\t\t\t\tvtable_arg = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Capture some intent before computing tailcall.\n\n\t\t\tgboolean make_generic_call_out_of_gsharedvt_method;\n\t\t\tgboolean will_have_imt_arg;\n\n\t\t\tmake_generic_call_out_of_gsharedvt_method = FALSE;\n\t\t\twill_have_imt_arg = FALSE;\n\n\t\t\t/*\n\t\t\t * Making generic calls out of gsharedvt methods.\n\t\t\t * This needs to be used for all generic calls, not just ones with a gsharedvt signature, to avoid\n\t\t\t * patching gshared method addresses into a gsharedvt method.\n\t\t\t */\n\t\t\tif (cfg->gsharedvt && (mini_is_gsharedvt_signature (fsig) || cmethod->is_inflated || mono_class_is_ginst (cmethod->klass)) &&\n\t\t\t\t!(m_class_get_rank (cmethod->klass) && m_class_get_byval_arg (cmethod->klass)->type != MONO_TYPE_SZARRAY) &&\n\t\t\t\t(!(cfg->llvm_only && virtual_ && (cmethod->flags & METHOD_ATTRIBUTE_VIRTUAL)))) {\n\n\t\t\t\tmake_generic_call_out_of_gsharedvt_method = TRUE;\n\n\t\t\t\tif (virtual_) {\n\t\t\t\t\tif (fsig->generic_param_count) {\n\t\t\t\t\t\twill_have_imt_arg = TRUE;\n\t\t\t\t\t} else if (mono_class_is_interface (cmethod->klass) && !imt_arg) {\n\t\t\t\t\t\twill_have_imt_arg = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n#ifdef ENABLE_NETCORE\n\t\t\tif (save_last_error) {\n\t\t\t\tmono_emit_jit_icall (cfg, mono_marshal_clear_last_error, NULL);\n\t\t\t}\n#endif\n\n\t\t\t/* Tail prefix / tailcall optimization */\n\n\t\t\t/* FIXME: Enabling TAILC breaks some inlining/stack trace/etc tests.\n\t\t\t\t  Inlining and stack traces are not guaranteed however. */\n\t\t\t/* FIXME: runtime generic context pointer for jumps? */\n\t\t\t/* FIXME: handle this for generic sharing eventually */\n\n\t\t\t// tailcall means \"the backend can and will handle it\".\n\t\t\t// inst_tailcall means the tail. prefix is present.\n\t\t\ttailcall_extra_arg = vtable_arg || imt_arg || will_have_imt_arg || mono_class_is_interface (cmethod->klass);\n\t\t\ttailcall = inst_tailcall && is_supported_tailcall (cfg, ip, method, cmethod, fsig,\n\t\t\t\t\t\tvirtual_, tailcall_extra_arg, &tailcall_calli);\n\t\t\t// Writes to imt_arg, vtable_arg, virtual_, cmethod, must not occur from here (inputs to is_supported_tailcall).\n\t\t\t// Capture values to later assert they don't change.\n\t\t\tcalled_is_supported_tailcall = TRUE;\n\t\t\ttailcall_method = method;\n\t\t\ttailcall_cmethod = cmethod;\n\t\t\ttailcall_fsig = fsig;\n\t\t\ttailcall_virtual = virtual_;\n\n\t\t\tif (virtual_generic) {\n\t\t\t\tif (virtual_generic_imt) {\n\t\t\t\t\tif (tailcall) {\n\t\t\t\t\t\t/* Prevent inlining of methods with tailcalls (the call stack would be altered) */\n\t\t\t\t\t\tINLINE_FAILURE (\"tailcall\");\n\t\t\t\t\t}\n\t\t\t\t\tcommon_call = TRUE;\n\t\t\t\t\tgoto call_end;\n\t\t\t\t}\n\n\t\t\t\tMonoInst *this_temp, *this_arg_temp, *store;\n\t\t\t\tMonoInst *iargs [4];\n\n\t\t\t\tthis_temp = mono_compile_create_var (cfg, type_from_stack_type (sp [0]), OP_LOCAL);\n\t\t\t\tNEW_TEMPSTORE (cfg, store, this_temp->inst_c0, sp [0]);\n\t\t\t\tMONO_ADD_INS (cfg->cbb, store);\n\n\t\t\t\t/* FIXME: This should be a managed pointer */\n\t\t\t\tthis_arg_temp = mono_compile_create_var (cfg, mono_get_int_type (), OP_LOCAL);\n\n\t\t\t\tEMIT_NEW_TEMPLOAD (cfg, iargs [0], this_temp->inst_c0);\n\t\t\t\tiargs [1] = emit_get_rgctx_method (cfg, context_used, cmethod, MONO_RGCTX_INFO_METHOD);\n\n\t\t\t\tEMIT_NEW_TEMPLOADA (cfg, iargs [2], this_arg_temp->inst_c0);\n\t\t\t\taddr = mono_emit_jit_icall (cfg, mono_helper_compile_generic_method, iargs);\n\n\t\t\t\tEMIT_NEW_TEMPLOAD (cfg, sp [0], this_arg_temp->inst_c0);\n\n\t\t\t\tins = (MonoInst*)mini_emit_calli (cfg, fsig, sp, addr, NULL, NULL);\n\n\t\t\t\tif (inst_tailcall) // FIXME\n\t\t\t\t\tmono_tailcall_print (\"missed tailcall virtual generic %s -> %s\\n\", method->name, cmethod->name);\n\t\t\t\tgoto call_end;\n\t\t\t}\n\t\t\tCHECK_CFG_ERROR;\n\t\t\t\n\t\t\t/* Inlining */\n\t\t\tif ((cfg->opt & MONO_OPT_INLINE) &&\n\t\t\t\t(!virtual_ || !(cmethod->flags & METHOD_ATTRIBUTE_VIRTUAL) || MONO_METHOD_IS_FINAL (cmethod)) &&\n\t\t\t    mono_method_check_inlining (cfg, cmethod)) {\n\t\t\t\tint costs;\n\t\t\t\tgboolean always = FALSE;\n\n\t\t\t\tif ((cmethod->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) ||\n\t\t\t\t\t(cmethod->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL)) {\n\t\t\t\t\t/* Prevent inlining of methods that call wrappers */\n\t\t\t\t\tINLINE_FAILURE (\"wrapper call\");\n\t\t\t\t\t// FIXME? Does this write to cmethod impact tailcall_supported? Probably not.\n\t\t\t\t\t// Neither pinvoke or icall are likely to be tailcalled.\n\t\t\t\t\tcmethod = mono_marshal_get_native_wrapper (cmethod, TRUE, FALSE);\n\t\t\t\t\talways = TRUE;\n\t\t\t\t}\n\n\t\t\t\tcosts = inline_method (cfg, cmethod, fsig, sp, ip, cfg->real_offset, always);\n\t\t\t\tif (costs) {\n\t\t\t\t\tcfg->real_offset += 5;\n\n\t\t\t\t\tif (!MONO_TYPE_IS_VOID (fsig->ret))\n\t\t\t\t\t\t/* *sp is already set by inline_method */\n\t\t\t\t\t\tins = *sp;\n\n\t\t\t\t\tinline_costs += costs;\n\t\t\t\t\t// FIXME This is missed if the inlinee contains tail calls that\n\t\t\t\t\t// would work, but not once inlined into caller.\n\t\t\t\t\t// This matchingness could be a factor in inlining.\n\t\t\t\t\t// i.e. Do not inline if it hurts tailcall, do inline\n\t\t\t\t\t// if it helps and/or or is neutral, and helps performance\n\t\t\t\t\t// using usual heuristics.\n\t\t\t\t\t// Note that inlining will expose multiple tailcall opportunities\n\t\t\t\t\t// so the tradeoff is not obvious. If we can tailcall anything\n\t\t\t\t\t// like desktop, then this factor mostly falls away, except\n\t\t\t\t\t// that inlining can affect tailcall performance due to\n\t\t\t\t\t// signature match/mismatch.\n\t\t\t\t\tif (inst_tailcall) // FIXME\n\t\t\t\t\t\tmono_tailcall_print (\"missed tailcall inline %s -> %s\\n\", method->name, cmethod->name);\n\t\t\t\t\tgoto call_end;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Tail recursion elimination */\n\t\t\tif (((cfg->opt & MONO_OPT_TAILCALL) || inst_tailcall) && il_op == MONO_CEE_CALL && cmethod == method && next_ip < end && next_ip [0] == CEE_RET && !vtable_arg) {\n\t\t\t\tgboolean has_vtargs = FALSE;\n\t\t\t\tint i;\n\n\t\t\t\t/* Prevent inlining of methods with tailcalls (the call stack would be altered) */\n\t\t\t\tINLINE_FAILURE (\"tailcall\");\n\n\t\t\t\t/* keep it simple */\n\t\t\t\tfor (i = fsig->param_count - 1; !has_vtargs && i >= 0; i--)\n\t\t\t\t\thas_vtargs = MONO_TYPE_ISSTRUCT (mono_method_signature_internal (cmethod)->params [i]);\n\n\t\t\t\tif (!has_vtargs) {\n\t\t\t\t\tif (need_seq_point) {\n\t\t\t\t\t\temit_seq_point (cfg, method, ip, FALSE, TRUE);\n\t\t\t\t\t\tneed_seq_point = FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < n; ++i)\n\t\t\t\t\t\tEMIT_NEW_ARGSTORE (cfg, ins, i, sp [i]);\n\n\t\t\t\t\tmini_profiler_emit_tail_call (cfg, cmethod);\n\n\t\t\t\t\tMONO_INST_NEW (cfg, ins, OP_BR);\n\t\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\t\ttblock = start_bblock->out_bb [0];\n\t\t\t\t\tlink_bblock (cfg, cfg->cbb, tblock);\n\t\t\t\t\tins->inst_target_bb = tblock;\n\t\t\t\t\tstart_new_bblock = 1;\n\n\t\t\t\t\t/* skip the CEE_RET, too */\n\t\t\t\t\tif (ip_in_bb (cfg, cfg->cbb, next_ip))\n\t\t\t\t\t\tskip_ret = TRUE;\n\t\t\t\t\tpush_res = FALSE;\n\t\t\t\t\tneed_seq_point = FALSE;\n\t\t\t\t\tgoto call_end;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinline_costs += CALL_COST * MIN(10, num_calls++);\n\n\t\t\t/*\n\t\t\t * Synchronized wrappers.\n\t\t\t * Its hard to determine where to replace a method with its synchronized\n\t\t\t * wrapper without causing an infinite recursion. The current solution is\n\t\t\t * to add the synchronized wrapper in the trampolines, and to\n\t\t\t * change the called method to a dummy wrapper, and resolve that wrapper\n\t\t\t * to the real method in mono_jit_compile_method ().\n\t\t\t */\n\t\t\tif (cfg->method->wrapper_type == MONO_WRAPPER_SYNCHRONIZED) {\n\t\t\t\tMonoMethod *orig = mono_marshal_method_from_wrapper (cfg->method);\n\t\t\t\tif (cmethod == orig || (cmethod->is_inflated && mono_method_get_declaring_generic_method (cmethod) == orig)) {\n\t\t\t\t\t// FIXME? Does this write to cmethod impact tailcall_supported? Probably not.\n\t\t\t\t\tcmethod = mono_marshal_get_synchronized_inner_wrapper (cmethod);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Making generic calls out of gsharedvt methods.\n\t\t\t * This needs to be used for all generic calls, not just ones with a gsharedvt signature, to avoid\n\t\t\t * patching gshared method addresses into a gsharedvt method.\n\t\t\t */\n\t\t\tif (make_generic_call_out_of_gsharedvt_method) {\n\t\t\t\tif (virtual_) {\n\t\t\t\t\t//if (mono_class_is_interface (cmethod->klass))\n\t\t\t\t\t\t//GSHAREDVT_FAILURE (il_op);\n\t\t\t\t\t// disable for possible remoting calls\n\t\t\t\t\tif (fsig->hasthis && (mono_class_is_marshalbyref (method->klass) || method->klass == mono_defaults.object_class))\n\t\t\t\t\t\tGSHAREDVT_FAILURE (il_op);\n\t\t\t\t\tif (fsig->generic_param_count) {\n\t\t\t\t\t\t/* virtual generic call */\n\t\t\t\t\t\tg_assert (!imt_arg);\n\t\t\t\t\t\tg_assert (will_have_imt_arg);\n\t\t\t\t\t\t/* Same as the virtual generic case above */\n\t\t\t\t\t\timt_arg = emit_get_rgctx_method (cfg, context_used,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t cmethod, MONO_RGCTX_INFO_METHOD);\n\t\t\t\t\t\tg_assert (imt_arg);\n\t\t\t\t\t} else if (mono_class_is_interface (cmethod->klass) && !imt_arg) {\n\t\t\t\t\t\t/* This can happen when we call a fully instantiated iface method */\n\t\t\t\t\t\tg_assert (will_have_imt_arg);\n\t\t\t\t\t\timt_arg = emit_get_rgctx_method (cfg, context_used,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t cmethod, MONO_RGCTX_INFO_METHOD);\n\t\t\t\t\t\tg_assert (imt_arg);\n\t\t\t\t\t}\n\t\t\t\t\t/* This is not needed, as the trampoline code will pass one, and it might be passed in the same reg as the imt arg */\n\t\t\t\t\tvtable_arg = NULL;\n\t\t\t\t}\n\n\t\t\t\tif ((m_class_get_parent (cmethod->klass) == mono_defaults.multicastdelegate_class) && (!strcmp (cmethod->name, \"Invoke\")))\n\t\t\t\t\tkeep_this_alive = sp [0];\n\n\t\t\t\tMonoRgctxInfoType info_type;\n\n\t\t\t\tif (virtual_ && (cmethod->flags & METHOD_ATTRIBUTE_VIRTUAL))\n\t\t\t\t\tinfo_type = MONO_RGCTX_INFO_METHOD_GSHAREDVT_OUT_TRAMPOLINE_VIRT;\n\t\t\t\telse\n\t\t\t\t\tinfo_type = MONO_RGCTX_INFO_METHOD_GSHAREDVT_OUT_TRAMPOLINE;\n\t\t\t\taddr = emit_get_rgctx_gsharedvt_call (cfg, context_used, fsig, cmethod, info_type);\n\n\t\t\t\tif (cfg->llvm_only) {\n\t\t\t\t\t// FIXME: Avoid initializing vtable_arg\n\t\t\t\t\tins = mini_emit_llvmonly_calli (cfg, fsig, sp, addr);\n\t\t\t\t\tif (inst_tailcall) // FIXME\n\t\t\t\t\t\tmono_tailcall_print (\"missed tailcall llvmonly gsharedvt %s -> %s\\n\", method->name, cmethod->name);\n\t\t\t\t} else {\n\t\t\t\t\ttailcall = tailcall_calli;\n\t\t\t\t\tins = (MonoInst*)mini_emit_calli_full (cfg, fsig, sp, addr, imt_arg, vtable_arg, tailcall);\n\t\t\t\t\ttailcall_remove_ret |= tailcall;\n\t\t\t\t}\n\t\t\t\tgoto call_end;\n\t\t\t}\n\n\t\t\t/* Generic sharing */\n\n\t\t\t/*\n\t\t\t * Use this if the callee is gsharedvt sharable too, since\n\t\t\t * at runtime we might find an instantiation so the call cannot\n\t\t\t * be patched (the 'no_patch' code path in mini-trampolines.c).\n\t\t\t */\n\t\t\tif (context_used && !imt_arg && !array_rank && !delegate_invoke &&\n\t\t\t\t(!mono_method_is_generic_sharable_full (cmethod, TRUE, FALSE, FALSE) ||\n\t\t\t\t !mono_class_generic_sharing_enabled (cmethod->klass)) &&\n\t\t\t\t(!virtual_ || MONO_METHOD_IS_FINAL (cmethod) ||\n\t\t\t\t !(cmethod->flags & METHOD_ATTRIBUTE_VIRTUAL))) {\n\t\t\t\tINLINE_FAILURE (\"gshared\");\n\n\t\t\t\tg_assert (cfg->gshared && cmethod);\n\t\t\t\tg_assert (!addr);\n\n\t\t\t\t/*\n\t\t\t\t * We are compiling a call to a\n\t\t\t\t * generic method from shared code,\n\t\t\t\t * which means that we have to look up\n\t\t\t\t * the method in the rgctx and do an\n\t\t\t\t * indirect call.\n\t\t\t\t */\n\t\t\t\tif (fsig->hasthis)\n\t\t\t\t\tMONO_EMIT_NEW_CHECK_THIS (cfg, sp [0]->dreg);\n\n\t\t\t\tif (cfg->llvm_only) {\n\t\t\t\t\tif (cfg->gsharedvt && mini_is_gsharedvt_variable_signature (fsig))\n\t\t\t\t\t\taddr = emit_get_rgctx_method (cfg, context_used, cmethod, MONO_RGCTX_INFO_GSHAREDVT_OUT_WRAPPER);\n\t\t\t\t\telse\n\t\t\t\t\t\taddr = emit_get_rgctx_method (cfg, context_used, cmethod, MONO_RGCTX_INFO_METHOD_FTNDESC);\n\t\t\t\t\t// FIXME: Avoid initializing imt_arg/vtable_arg\n\t\t\t\t\tins = mini_emit_llvmonly_calli (cfg, fsig, sp, addr);\n\t\t\t\t\tif (inst_tailcall) // FIXME\n\t\t\t\t\t\tmono_tailcall_print (\"missed tailcall context_used_llvmonly %s -> %s\\n\", method->name, cmethod->name);\n\t\t\t\t} else {\n\t\t\t\t\taddr = emit_get_rgctx_method (cfg, context_used, cmethod, MONO_RGCTX_INFO_GENERIC_METHOD_CODE);\n\t\t\t\t\tif (inst_tailcall)\n\t\t\t\t\t\tmono_tailcall_print (\"%s tailcall_calli#2 %s -> %s\\n\", tailcall_calli ? \"making\" : \"missed\", method->name, cmethod->name);\n\t\t\t\t\ttailcall = tailcall_calli;\n\t\t\t\t\tins = (MonoInst*)mini_emit_calli_full (cfg, fsig, sp, addr, imt_arg, vtable_arg, tailcall);\n\t\t\t\t\ttailcall_remove_ret |= tailcall;\n\t\t\t\t}\n\t\t\t\tgoto call_end;\n\t\t\t}\n\n\t\t\t/* Direct calls to icalls */\n\t\t\tif (direct_icall) {\n\t\t\t\tMonoMethod *wrapper;\n\t\t\t\tint costs;\n\n\t\t\t\t/* Inline the wrapper */\n\t\t\t\twrapper = mono_marshal_get_native_wrapper (cmethod, TRUE, cfg->compile_aot);\n\n\t\t\t\tcosts = inline_method (cfg, wrapper, fsig, sp, ip, cfg->real_offset, TRUE);\n\t\t\t\tg_assert (costs > 0);\n\t\t\t\tcfg->real_offset += 5;\n\n\t\t\t\tif (!MONO_TYPE_IS_VOID (fsig->ret))\n\t\t\t\t\t/* *sp is already set by inline_method */\n\t\t\t\t\tins = *sp;\n\n\t\t\t\tinline_costs += costs;\n\n\t\t\t\tif (inst_tailcall) // FIXME\n\t\t\t\t\tmono_tailcall_print (\"missed tailcall direct_icall %s -> %s\\n\", method->name, cmethod->name);\n\t\t\t\tgoto call_end;\n\t\t\t}\n\n\t\t\t/* Array methods */\n\t\t\tif (array_rank) {\n\t\t\t\tMonoInst *addr;\n\n\t\t\t\tif (strcmp (cmethod->name, \"Set\") == 0) { /* array Set */ \n\t\t\t\t\tMonoInst *val = sp [fsig->param_count];\n\n\t\t\t\t\tif (val->type == STACK_OBJ) {\n\t\t\t\t\t\tMonoInst *iargs [2];\n\n\t\t\t\t\t\tiargs [0] = sp [0];\n\t\t\t\t\t\tiargs [1] = val;\n\n\t\t\t\t\t\tmono_emit_jit_icall (cfg, mono_helper_stelem_ref_check, iargs);\n\t\t\t\t\t}\n\n\t\t\t\t\taddr = mini_emit_ldelema_ins (cfg, cmethod, sp, ip, TRUE);\n\t\t\t\t\tif (!mini_debug_options.weak_memory_model && val->type == STACK_OBJ)\n\t\t\t\t\t\tmini_emit_memory_barrier (cfg, MONO_MEMORY_BARRIER_REL);\n\t\t\t\t\tEMIT_NEW_STORE_MEMBASE_TYPE (cfg, ins, fsig->params [fsig->param_count - 1], addr->dreg, 0, val->dreg);\n\t\t\t\t\tif (cfg->gen_write_barriers && val->type == STACK_OBJ && !MONO_INS_IS_PCONST_NULL (val))\n\t\t\t\t\t\tmini_emit_write_barrier (cfg, addr, val);\n\t\t\t\t\tif (cfg->gen_write_barriers && mini_is_gsharedvt_klass (cmethod->klass))\n\t\t\t\t\t\tGSHAREDVT_FAILURE (il_op);\n\t\t\t\t} else if (strcmp (cmethod->name, \"Get\") == 0) { /* array Get */\n\t\t\t\t\taddr = mini_emit_ldelema_ins (cfg, cmethod, sp, ip, FALSE);\n\n\t\t\t\t\tEMIT_NEW_LOAD_MEMBASE_TYPE (cfg, ins, fsig->ret, addr->dreg, 0);\n\t\t\t\t} else if (strcmp (cmethod->name, \"Address\") == 0) { /* array Address */\n\t\t\t\t\tif (!m_class_is_valuetype (m_class_get_element_class (cmethod->klass)) && !readonly)\n\t\t\t\t\t\tmini_emit_check_array_type (cfg, sp [0], cmethod->klass);\n\t\t\t\t\tCHECK_TYPELOAD (cmethod->klass);\n\n\t\t\t\t\treadonly = FALSE;\n\t\t\t\t\taddr = mini_emit_ldelema_ins (cfg, cmethod, sp, ip, FALSE);\n\t\t\t\t\tins = addr;\n\t\t\t\t} else {\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n\n\t\t\t\temit_widen = FALSE;\n\t\t\t\tif (inst_tailcall) // FIXME\n\t\t\t\t\tmono_tailcall_print (\"missed tailcall array_rank %s -> %s\\n\", method->name, cmethod->name);\n\t\t\t\tgoto call_end;\n\t\t\t}\n\n\t\t\tins = mini_redirect_call (cfg, cmethod, fsig, sp, virtual_ ? sp [0] : NULL);\n\t\t\tif (ins) {\n\t\t\t\tif (inst_tailcall) // FIXME\n\t\t\t\t\tmono_tailcall_print (\"missed tailcall redirect %s -> %s\\n\", method->name, cmethod->name);\n\t\t\t\tgoto call_end;\n\t\t\t}\n\n\t\t\t/* Tail prefix / tailcall optimization */\n\n\t\t\tif (tailcall) {\n\t\t\t\t/* Prevent inlining of methods with tailcalls (the call stack would be altered) */\n\t\t\t\tINLINE_FAILURE (\"tailcall\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Virtual calls in llvm-only mode.\n\t\t\t */\n\t\t\tif (cfg->llvm_only && virtual_ && cmethod && (cmethod->flags & METHOD_ATTRIBUTE_VIRTUAL)) {\n\t\t\t\tins = mini_emit_llvmonly_virtual_call (cfg, cmethod, fsig, context_used, sp);\n\t\t\t\tgoto call_end;\n\t\t\t}\n\n\t\t\t/* Common call */\n\t\t\tif (!(method->iflags & METHOD_IMPL_ATTRIBUTE_AGGRESSIVE_INLINING) && !(cmethod->iflags & METHOD_IMPL_ATTRIBUTE_AGGRESSIVE_INLINING))\n\t\t\t\tINLINE_FAILURE (\"call\");\n\t\t\tcommon_call = TRUE;\n\ncall_end:\n\t\t\t// Check that the decision to tailcall would not have changed.\n\t\t\tg_assert (!called_is_supported_tailcall || tailcall_method == method);\n\t\t\t// FIXME? cmethod does change, weaken the assert if we weren't tailcalling anyway.\n\t\t\t// If this still fails, restructure the code, or call tailcall_supported again and assert no change.\n\t\t\tg_assert (!called_is_supported_tailcall || !tailcall || tailcall_cmethod == cmethod);\n\t\t\tg_assert (!called_is_supported_tailcall || tailcall_fsig == fsig);\n\t\t\tg_assert (!called_is_supported_tailcall || tailcall_virtual == virtual_);\n\t\t\tg_assert (!called_is_supported_tailcall || tailcall_extra_arg == (vtable_arg || imt_arg || will_have_imt_arg || mono_class_is_interface (cmethod->klass)));\n\n\t\t\tif (common_call) // FIXME goto call_end && !common_call often skips tailcall processing.\n\t\t\t\tins = mini_emit_method_call_full (cfg, cmethod, fsig, tailcall, sp, virtual_ ? sp [0] : NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t  imt_arg, vtable_arg);\n\n\t\t\t/*\n\t\t\t * Handle devirt of some A.B.C calls by replacing the result of A.B with a OP_TYPED_OBJREF instruction, so the .C\n\t\t\t * call can be devirtualized above.\n\t\t\t */\n\t\t\tif (cmethod)\n\t\t\t\tins = handle_call_res_devirt (cfg, cmethod, ins);\n\n\t\t\tif (noreturn) {\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_NOT_REACHED);\n\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t}\ncalli_end:\n\t\t\tif ((tailcall_remove_ret || (common_call && tailcall)) && !cfg->llvm_only) {\n\t\t\t\tlink_bblock (cfg, cfg->cbb, end_bblock);\n\t\t\t\tstart_new_bblock = 1;\n\n\t\t\t\t// FIXME: Eliminate unreachable epilogs\n\n\t\t\t\t/*\n\t\t\t\t * OP_TAILCALL has no return value, so skip the CEE_RET if it is\n\t\t\t\t * only reachable from this call.\n\t\t\t\t */\n\t\t\t\tGET_BBLOCK (cfg, tblock, next_ip);\n\t\t\t\tif (tblock == cfg->cbb || tblock->in_count == 0)\n\t\t\t\t\tskip_ret = TRUE;\n\t\t\t\tpush_res = FALSE;\n\t\t\t\tneed_seq_point = FALSE;\n\t\t\t}\n\n\t\t\tif (ins_flag & MONO_INST_TAILCALL)\n\t\t\t\tmini_test_tailcall (cfg, tailcall);\n\n\t\t\t/* End of call, INS should contain the result of the call, if any */\n\n\t\t\tif (push_res && !MONO_TYPE_IS_VOID (fsig->ret)) {\n\t\t\t\tg_assert (ins);\n\t\t\t\tif (emit_widen)\n\t\t\t\t\t*sp++ = mono_emit_widen_call_res (cfg, ins, fsig);\n\t\t\t\telse\n\t\t\t\t\t*sp++ = ins;\n\t\t\t}\n\n\t\t\tif (save_last_error) {\n\t\t\t\tsave_last_error = FALSE;\n#ifdef TARGET_WIN32\n\t\t\t\t// Making icalls etc could clobber the value so emit inline code\n\t\t\t\t// to read last error on Windows.\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_GET_LAST_ERROR);\n\t\t\t\tins->dreg = alloc_dreg (cfg, STACK_I4);\n\t\t\t\tins->type = STACK_I4;\n\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\tmono_emit_jit_icall (cfg, mono_marshal_set_last_error_windows, &ins);\n#else\n\t\t\t\tmono_emit_jit_icall (cfg, mono_marshal_set_last_error, NULL);\n#endif\n\t\t\t}\n\n\t\t\tif (keep_this_alive) {\n\t\t\t\tMonoInst *dummy_use;\n\n\t\t\t\t/* See mini_emit_method_call_full () */\n\t\t\t\tEMIT_NEW_DUMMY_USE (cfg, dummy_use, keep_this_alive);\n\t\t\t}\n\n\t\t\tif (cfg->llvm_only && cmethod && method_needs_stack_walk (cfg, cmethod)) {\n\t\t\t\t/*\n\t\t\t\t * Clang can convert these calls to tailcalls which screw up the stack\n\t\t\t\t * walk. This happens even when the -fno-optimize-sibling-calls\n\t\t\t\t * option is passed to clang.\n\t\t\t\t * Work around this by emitting a dummy call.\n\t\t\t\t */\n\t\t\t\tmono_emit_jit_icall (cfg, mono_dummy_jit_icall, NULL);\n\t\t\t}\n\n\t\t\tCHECK_CFG_EXCEPTION;\n\n\t\t\tif (skip_ret) {\n\t\t\t\t// FIXME When not followed by CEE_RET, correct behavior is to raise an exception.\n\t\t\t\tg_assert (next_ip [0] == CEE_RET);\n\t\t\t\tnext_ip += 1;\n\t\t\t\til_op = MonoOpcodeEnum_Invalid; // Call or ret? Unclear.\n\t\t\t}\n\t\t\tins_flag = 0;\n\t\t\tconstrained_class = NULL;\n\t\t\t\n\t\t\tif (need_seq_point) {\n\t\t\t\t//check is is a nested call and remove the non_empty_stack of the last call, only for non native methods\n\t\t\t\tif (!(method->flags & METHOD_IMPL_ATTRIBUTE_NATIVE)) {\n\t\t\t\t\tif (emitted_funccall_seq_point) {\n\t\t\t\t\t\tif (cfg->last_seq_point)\n\t\t\t\t\t\t\tcfg->last_seq_point->flags |= MONO_INST_NESTED_CALL;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\temitted_funccall_seq_point = TRUE;\n\t\t\t\t}\n\t\t\t\temit_seq_point (cfg, method, next_ip, FALSE, TRUE);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_RET:\n\t\t\tmini_profiler_emit_leave (cfg, sig->ret->type != MONO_TYPE_VOID ? sp [-1] : NULL);\n\n\t\t\tg_assert (!method_does_not_return (method));\n\n\t\t\tif (cfg->method != method) {\n\t\t\t\t/* return from inlined method */\n\t\t\t\t/* \n\t\t\t\t * If in_count == 0, that means the ret is unreachable due to\n\t\t\t\t * being preceeded by a throw. In that case, inline_method () will\n\t\t\t\t * handle setting the return value \n\t\t\t\t * (test case: test_0_inline_throw ()).\n\t\t\t\t */\n\t\t\t\tif (return_var && cfg->cbb->in_count) {\n\t\t\t\t\tMonoType *ret_type = mono_method_signature_internal (method)->ret;\n\n\t\t\t\t\tMonoInst *store;\n\t\t\t\t\tCHECK_STACK (1);\n\t\t\t\t\t--sp;\n\t\t\t\t\t*sp = convert_value (cfg, ret_type, *sp);\n\n\t\t\t\t\tif ((method->wrapper_type == MONO_WRAPPER_DYNAMIC_METHOD || method->wrapper_type == MONO_WRAPPER_NONE) && target_type_is_incompatible (cfg, ret_type, *sp))\n\t\t\t\t\t\tUNVERIFIED;\n\n\t\t\t\t\t//g_assert (returnvar != -1);\n\t\t\t\t\tEMIT_NEW_TEMPSTORE (cfg, store, return_var->inst_c0, *sp);\n\t\t\t\t\tcfg->ret_var_set = TRUE;\n\t\t\t\t} \n\t\t\t} else {\n\t\t\t\tif (cfg->lmf_var && cfg->cbb->in_count && !cfg->llvm_only)\n\t\t\t\t\temit_pop_lmf (cfg);\n\n\t\t\t\tif (cfg->ret) {\n\t\t\t\t\tMonoType *ret_type = mini_get_underlying_type (mono_method_signature_internal (method)->ret);\n\n\t\t\t\t\tif (seq_points && !sym_seq_points) {\n\t\t\t\t\t\t/* \n\t\t\t\t\t\t * Place a seq point here too even through the IL stack is not\n\t\t\t\t\t\t * empty, so a step over on\n\t\t\t\t\t\t * call <FOO>\n\t\t\t\t\t\t * ret\n\t\t\t\t\t\t * will work correctly.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tNEW_SEQ_POINT (cfg, ins, ip - header->code, TRUE);\n\t\t\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\t\t}\n\n\t\t\t\t\tg_assert (!return_var);\n\t\t\t\t\tCHECK_STACK (1);\n\t\t\t\t\t--sp;\n\t\t\t\t\t*sp = convert_value (cfg, ret_type, *sp);\n\n\t\t\t\t\tif ((method->wrapper_type == MONO_WRAPPER_DYNAMIC_METHOD || method->wrapper_type == MONO_WRAPPER_NONE) && target_type_is_incompatible (cfg, ret_type, *sp))\n\t\t\t\t\t\tUNVERIFIED;\n\n\t\t\t\t\temit_setret (cfg, *sp);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sp != stack_start)\n\t\t\t\tUNVERIFIED;\n\t\t\tMONO_INST_NEW (cfg, ins, OP_BR);\n\t\t\tins->inst_target_bb = end_bblock;\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\tlink_bblock (cfg, cfg->cbb, end_bblock);\n\t\t\tstart_new_bblock = 1;\n\t\t\tbreak;\n\t\tcase MONO_CEE_BR_S:\n\t\t\tMONO_INST_NEW (cfg, ins, OP_BR);\n\t\t\tGET_BBLOCK (cfg, tblock, target);\n\t\t\tlink_bblock (cfg, cfg->cbb, tblock);\n\t\t\tins->inst_target_bb = tblock;\n\t\t\tif (sp != stack_start) {\n\t\t\t\thandle_stack_args (cfg, stack_start, sp - stack_start);\n\t\t\t\tsp = stack_start;\n\t\t\t\tCHECK_UNVERIFIABLE (cfg);\n\t\t\t}\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\tstart_new_bblock = 1;\n\t\t\tinline_costs += BRANCH_COST;\n\t\t\tbreak;\n\t\tcase MONO_CEE_BEQ_S:\n\t\tcase MONO_CEE_BGE_S:\n\t\tcase MONO_CEE_BGT_S:\n\t\tcase MONO_CEE_BLE_S:\n\t\tcase MONO_CEE_BLT_S:\n\t\tcase MONO_CEE_BNE_UN_S:\n\t\tcase MONO_CEE_BGE_UN_S:\n\t\tcase MONO_CEE_BGT_UN_S:\n\t\tcase MONO_CEE_BLE_UN_S:\n\t\tcase MONO_CEE_BLT_UN_S:\n\t\t\tMONO_INST_NEW (cfg, ins, il_op + BIG_BRANCH_OFFSET);\n\n\t\t\tADD_BINCOND (NULL);\n\n\t\t\tsp = stack_start;\n\t\t\tinline_costs += BRANCH_COST;\n\t\t\tbreak;\n\t\tcase MONO_CEE_BR:\n\t\t\tMONO_INST_NEW (cfg, ins, OP_BR);\n\n\t\t\tGET_BBLOCK (cfg, tblock, target);\n\t\t\tlink_bblock (cfg, cfg->cbb, tblock);\n\t\t\tins->inst_target_bb = tblock;\n\t\t\tif (sp != stack_start) {\n\t\t\t\thandle_stack_args (cfg, stack_start, sp - stack_start);\n\t\t\t\tsp = stack_start;\n\t\t\t\tCHECK_UNVERIFIABLE (cfg);\n\t\t\t}\n\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\n\t\t\tstart_new_bblock = 1;\n\t\t\tinline_costs += BRANCH_COST;\n\t\t\tbreak;\n\t\tcase MONO_CEE_BRFALSE_S:\n\t\tcase MONO_CEE_BRTRUE_S:\n\t\tcase MONO_CEE_BRFALSE:\n\t\tcase MONO_CEE_BRTRUE: {\n\t\t\tMonoInst *cmp;\n\t\t\tgboolean is_true = il_op == MONO_CEE_BRTRUE_S || il_op == MONO_CEE_BRTRUE;\n\n\t\t\tif (sp [-1]->type == STACK_VTYPE || sp [-1]->type == STACK_R8)\n\t\t\t\tUNVERIFIED;\n\n\t\t\tsp--;\n\n\t\t\tGET_BBLOCK (cfg, tblock, target);\n\t\t\tlink_bblock (cfg, cfg->cbb, tblock);\n\t\t\tGET_BBLOCK (cfg, tblock, next_ip);\n\t\t\tlink_bblock (cfg, cfg->cbb, tblock);\n\n\t\t\tif (sp != stack_start) {\n\t\t\t\thandle_stack_args (cfg, stack_start, sp - stack_start);\n\t\t\t\tCHECK_UNVERIFIABLE (cfg);\n\t\t\t}\n\n\t\t\tMONO_INST_NEW(cfg, cmp, OP_ICOMPARE_IMM);\n\t\t\tcmp->sreg1 = sp [0]->dreg;\n\t\t\ttype_from_op (cfg, cmp, sp [0], NULL);\n\t\t\tCHECK_TYPE (cmp);\n\n#if SIZEOF_REGISTER == 4\n\t\t\tif (cmp->opcode == OP_LCOMPARE_IMM) {\n\t\t\t\t/* Convert it to OP_LCOMPARE */\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_I8CONST);\n\t\t\t\tins->type = STACK_I8;\n\t\t\t\tins->dreg = alloc_dreg (cfg, STACK_I8);\n\t\t\t\tins->inst_l = 0;\n\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\tcmp->opcode = OP_LCOMPARE;\n\t\t\t\tcmp->sreg2 = ins->dreg;\n\t\t\t}\n#endif\n\t\t\tMONO_ADD_INS (cfg->cbb, cmp);\n\n\t\t\tMONO_INST_NEW (cfg, ins, is_true ? CEE_BNE_UN : CEE_BEQ);\n\t\t\ttype_from_op (cfg, ins, sp [0], NULL);\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\tins->inst_many_bb = (MonoBasicBlock **)mono_mempool_alloc (cfg->mempool, sizeof (gpointer) * 2);\n\t\t\tGET_BBLOCK (cfg, tblock, target);\n\t\t\tins->inst_true_bb = tblock;\n\t\t\tGET_BBLOCK (cfg, tblock, next_ip);\n\t\t\tins->inst_false_bb = tblock;\n\t\t\tstart_new_bblock = 2;\n\n\t\t\tsp = stack_start;\n\t\t\tinline_costs += BRANCH_COST;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_BEQ:\n\t\tcase MONO_CEE_BGE:\n\t\tcase MONO_CEE_BGT:\n\t\tcase MONO_CEE_BLE:\n\t\tcase MONO_CEE_BLT:\n\t\tcase MONO_CEE_BNE_UN:\n\t\tcase MONO_CEE_BGE_UN:\n\t\tcase MONO_CEE_BGT_UN:\n\t\tcase MONO_CEE_BLE_UN:\n\t\tcase MONO_CEE_BLT_UN:\n\t\t\tMONO_INST_NEW (cfg, ins, il_op);\n\n\t\t\tADD_BINCOND (NULL);\n\n\t\t\tsp = stack_start;\n\t\t\tinline_costs += BRANCH_COST;\n\t\t\tbreak;\n\t\tcase MONO_CEE_SWITCH: {\n\t\t\tMonoInst *src1;\n\t\t\tMonoBasicBlock **targets;\n\t\t\tMonoBasicBlock *default_bblock;\n\t\t\tMonoJumpInfoBBTable *table;\n\t\t\tint offset_reg = alloc_preg (cfg);\n\t\t\tint target_reg = alloc_preg (cfg);\n\t\t\tint table_reg = alloc_preg (cfg);\n\t\t\tint sum_reg = alloc_preg (cfg);\n\t\t\tgboolean use_op_switch;\n\n\t\t\tn = read32 (ip + 1);\n\t\t\t--sp;\n\t\t\tsrc1 = sp [0];\n\t\t\tif ((src1->type != STACK_I4) && (src1->type != STACK_PTR)) \n\t\t\t\tUNVERIFIED;\n\n\t\t\tip += 5;\n\n\t\t\tGET_BBLOCK (cfg, default_bblock, next_ip);\n\t\t\tdefault_bblock->flags |= BB_INDIRECT_JUMP_TARGET;\n\n\t\t\ttargets = (MonoBasicBlock **)mono_mempool_alloc (cfg->mempool, sizeof (MonoBasicBlock*) * n);\n\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\tGET_BBLOCK (cfg, tblock, next_ip + (gint32)read32 (ip));\n\t\t\t\ttargets [i] = tblock;\n\t\t\t\ttargets [i]->flags |= BB_INDIRECT_JUMP_TARGET;\n\t\t\t\tip += 4;\n\t\t\t}\n\n\t\t\tif (sp != stack_start) {\n\t\t\t\t/* \n\t\t\t\t * Link the current bb with the targets as well, so handle_stack_args\n\t\t\t\t * will set their in_stack correctly.\n\t\t\t\t */\n\t\t\t\tlink_bblock (cfg, cfg->cbb, default_bblock);\n\t\t\t\tfor (i = 0; i < n; ++i)\n\t\t\t\t\tlink_bblock (cfg, cfg->cbb, targets [i]);\n\n\t\t\t\thandle_stack_args (cfg, stack_start, sp - stack_start);\n\t\t\t\tsp = stack_start;\n\t\t\t\tCHECK_UNVERIFIABLE (cfg);\n\n\t\t\t\t/* Undo the links */\n\t\t\t\tmono_unlink_bblock (cfg, cfg->cbb, default_bblock);\n\t\t\t\tfor (i = 0; i < n; ++i)\n\t\t\t\t\tmono_unlink_bblock (cfg, cfg->cbb, targets [i]);\n\t\t\t}\n\n\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_ICOMPARE_IMM, -1, src1->dreg, n);\n\t\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_IBGE_UN, default_bblock);\n\n\t\t\tfor (i = 0; i < n; ++i)\n\t\t\t\tlink_bblock (cfg, cfg->cbb, targets [i]);\n\n\t\t\ttable = (MonoJumpInfoBBTable *)mono_mempool_alloc (cfg->mempool, sizeof (MonoJumpInfoBBTable));\n\t\t\ttable->table = targets;\n\t\t\ttable->table_size = n;\n\n\t\t\tuse_op_switch = FALSE;\n#ifdef TARGET_ARM\n\t\t\t/* ARM implements SWITCH statements differently */\n\t\t\t/* FIXME: Make it use the generic implementation */\n\t\t\tif (!cfg->compile_aot)\n\t\t\t\tuse_op_switch = TRUE;\n#endif\n\n\t\t\tif (COMPILE_LLVM (cfg))\n\t\t\t\tuse_op_switch = TRUE;\n\n\t\t\tcfg->cbb->has_jump_table = 1;\n\n\t\t\tif (use_op_switch) {\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_SWITCH);\n\t\t\t\tins->sreg1 = src1->dreg;\n\t\t\t\tins->inst_p0 = table;\n\t\t\t\tins->inst_many_bb = targets;\n\t\t\t\tins->klass = (MonoClass *)GUINT_TO_POINTER (n);\n\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t} else {\n\t\t\t\tif (TARGET_SIZEOF_VOID_P == 8)\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_SHL_IMM, offset_reg, src1->dreg, 3);\n\t\t\t\telse\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_SHL_IMM, offset_reg, src1->dreg, 2);\n\n#if SIZEOF_REGISTER == 8\n\t\t\t\t/* The upper word might not be zero, and we add it to a 64 bit address later */\n\t\t\t\tMONO_EMIT_NEW_UNALU (cfg, OP_ZEXT_I4, offset_reg, offset_reg);\n#endif\n\n\t\t\t\tif (cfg->compile_aot) {\n\t\t\t\t\tMONO_EMIT_NEW_AOTCONST (cfg, table_reg, table, MONO_PATCH_INFO_SWITCH);\n\t\t\t\t} else {\n\t\t\t\t\tMONO_INST_NEW (cfg, ins, OP_JUMP_TABLE);\n\t\t\t\t\tins->inst_c1 = MONO_PATCH_INFO_SWITCH;\n\t\t\t\t\tins->inst_p0 = table;\n\t\t\t\t\tins->dreg = table_reg;\n\t\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\t}\n\n\t\t\t\t/* FIXME: Use load_memindex */\n\t\t\t\tMONO_EMIT_NEW_BIALU (cfg, OP_PADD, sum_reg, table_reg, offset_reg);\n\t\t\t\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, target_reg, sum_reg, 0);\n\t\t\t\tMONO_EMIT_NEW_UNALU (cfg, OP_BR_REG, -1, target_reg);\n\t\t\t}\n\t\t\tstart_new_bblock = 1;\n\t\t\tinline_costs += BRANCH_COST * 2;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_LDIND_I1:\n\t\tcase MONO_CEE_LDIND_U1:\n\t\tcase MONO_CEE_LDIND_I2:\n\t\tcase MONO_CEE_LDIND_U2:\n\t\tcase MONO_CEE_LDIND_I4:\n\t\tcase MONO_CEE_LDIND_U4:\n\t\tcase MONO_CEE_LDIND_I8:\n\t\tcase MONO_CEE_LDIND_I:\n\t\tcase MONO_CEE_LDIND_R4:\n\t\tcase MONO_CEE_LDIND_R8:\n\t\tcase MONO_CEE_LDIND_REF:\n\t\t\t--sp;\n\n\t\t\tins = mini_emit_memory_load (cfg, m_class_get_byval_arg (ldind_to_type (il_op)), sp [0], 0, ins_flag);\n\t\t\t*sp++ = ins;\n\t\t\tins_flag = 0;\n\t\t\tbreak;\n\t\tcase MONO_CEE_STIND_REF:\n\t\tcase MONO_CEE_STIND_I1:\n\t\tcase MONO_CEE_STIND_I2:\n\t\tcase MONO_CEE_STIND_I4:\n\t\tcase MONO_CEE_STIND_I8:\n\t\tcase MONO_CEE_STIND_R4:\n\t\tcase MONO_CEE_STIND_R8:\n\t\tcase MONO_CEE_STIND_I: {\n\t\t\tsp -= 2;\n\n\t\t\tif (ins_flag & MONO_INST_VOLATILE) {\n\t\t\t\t/* Volatile stores have release semantics, see 12.6.7 in Ecma 335 */\n\t\t\t\tmini_emit_memory_barrier (cfg, MONO_MEMORY_BARRIER_REL);\n\t\t\t}\n\n\t\t\tif (il_op == MONO_CEE_STIND_R4 && sp [1]->type == STACK_R8)\n\t\t\t\tsp [1] = convert_value (cfg, m_class_get_byval_arg (mono_defaults.single_class), sp [1]);\n\t\t\tif (!mini_debug_options.weak_memory_model && il_op == MONO_CEE_STIND_REF && method->wrapper_type != MONO_WRAPPER_WRITE_BARRIER)\n\t\t\t\tmini_emit_memory_barrier (cfg, MONO_MEMORY_BARRIER_REL);\n\t\t\tNEW_STORE_MEMBASE (cfg, ins, stind_to_store_membase (il_op), sp [0]->dreg, 0, sp [1]->dreg);\n\t\t\tins->flags |= ins_flag;\n\t\t\tins_flag = 0;\n\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\n\t\t\tif (il_op == MONO_CEE_STIND_REF) {\n\t\t\t\t/* stind.ref must only be used with object references. */\n\t\t\t\tif (sp [1]->type != STACK_OBJ)\n\t\t\t\t\tUNVERIFIED;\n\t\t\t\tif (cfg->gen_write_barriers && method->wrapper_type != MONO_WRAPPER_WRITE_BARRIER && !MONO_INS_IS_PCONST_NULL (sp [1]))\n\t\t\t\t\tmini_emit_write_barrier (cfg, sp [0], sp [1]);\n\t\t\t}\n\n\t\t\tinline_costs += 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_MUL:\n\t\t\tMONO_INST_NEW (cfg, ins, il_op);\n\t\t\tsp -= 2;\n\t\t\tins->sreg1 = sp [0]->dreg;\n\t\t\tins->sreg2 = sp [1]->dreg;\n\t\t\ttype_from_op (cfg, ins, sp [0], sp [1]);\n\t\t\tCHECK_TYPE (ins);\n\t\t\tins->dreg = alloc_dreg ((cfg), (MonoStackType)(ins)->type);\n\n\t\t\t/* Use the immediate opcodes if possible */\n\t\t\tint imm_opcode; imm_opcode = mono_op_to_op_imm_noemul (ins->opcode);\n\n\t\t\tif ((sp [1]->opcode == OP_ICONST) && mono_arch_is_inst_imm (ins->opcode, imm_opcode, sp [1]->inst_c0)) {\n\t\t\t\tif (imm_opcode != -1) {\n\t\t\t\t\tins->opcode = imm_opcode;\n\t\t\t\t\tins->inst_p1 = (gpointer)(gssize)(sp [1]->inst_c0);\n\t\t\t\t\tins->sreg2 = -1;\n\n\t\t\t\t\tNULLIFY_INS (sp [1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tMONO_ADD_INS ((cfg)->cbb, (ins));\n\n\t\t\t*sp++ = mono_decompose_opcode (cfg, ins);\n\t\t\tbreak;\n\t\tcase MONO_CEE_ADD:\n\t\tcase MONO_CEE_SUB:\n\t\tcase MONO_CEE_DIV:\n\t\tcase MONO_CEE_DIV_UN:\n\t\tcase MONO_CEE_REM:\n\t\tcase MONO_CEE_REM_UN:\n\t\tcase MONO_CEE_AND:\n\t\tcase MONO_CEE_OR:\n\t\tcase MONO_CEE_XOR:\n\t\tcase MONO_CEE_SHL:\n\t\tcase MONO_CEE_SHR:\n\t\tcase MONO_CEE_SHR_UN: {\n\t\t\tMONO_INST_NEW (cfg, ins, il_op);\n\t\t\tsp -= 2;\n\t\t\tins->sreg1 = sp [0]->dreg;\n\t\t\tins->sreg2 = sp [1]->dreg;\n\t\t\ttype_from_op (cfg, ins, sp [0], sp [1]);\n\t\t\tCHECK_TYPE (ins);\n\t\t\tadd_widen_op (cfg, ins, &sp [0], &sp [1]);\n\t\t\tins->dreg = alloc_dreg ((cfg), (MonoStackType)(ins)->type);\n\n\t\t\t/* Use the immediate opcodes if possible */\n\t\t\tint imm_opcode; imm_opcode = mono_op_to_op_imm_noemul (ins->opcode);\n\n\t\t\tif (((sp [1]->opcode == OP_ICONST) || (sp [1]->opcode == OP_I8CONST)) &&\n\t\t\t    mono_arch_is_inst_imm (ins->opcode, imm_opcode, sp [1]->opcode == OP_ICONST ? sp [1]->inst_c0 : sp [1]->inst_l)) {\n\t\t\t\tif (imm_opcode != -1) {\n\t\t\t\t\tins->opcode = imm_opcode;\n\t\t\t\t\tif (sp [1]->opcode == OP_I8CONST) {\n#if SIZEOF_REGISTER == 8\n\t\t\t\t\t\tins->inst_imm = sp [1]->inst_l;\n#else\n\t\t\t\t\t\tins->inst_l = sp [1]->inst_l;\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tins->inst_imm = (gssize)(sp [1]->inst_c0);\n\t\t\t\t\t}\n\t\t\t\t\tins->sreg2 = -1;\n\n\t\t\t\t\t/* Might be followed by an instruction added by add_widen_op */\n\t\t\t\t\tif (sp [1]->next == NULL)\n\t\t\t\t\t\tNULLIFY_INS (sp [1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMONO_ADD_INS ((cfg)->cbb, (ins));\n\n\t\t\t*sp++ = mono_decompose_opcode (cfg, ins);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_NEG:\n\t\tcase MONO_CEE_NOT:\n\t\tcase MONO_CEE_CONV_I1:\n\t\tcase MONO_CEE_CONV_I2:\n\t\tcase MONO_CEE_CONV_I4:\n\t\tcase MONO_CEE_CONV_R4:\n\t\tcase MONO_CEE_CONV_R8:\n\t\tcase MONO_CEE_CONV_U4:\n\t\tcase MONO_CEE_CONV_I8:\n\t\tcase MONO_CEE_CONV_U8:\n\t\tcase MONO_CEE_CONV_OVF_I8:\n\t\tcase MONO_CEE_CONV_OVF_U8:\n\t\tcase MONO_CEE_CONV_R_UN:\n\t\t\t/* Special case this earlier so we have long constants in the IR */\n\t\t\tif ((il_op == MONO_CEE_CONV_I8 || il_op == MONO_CEE_CONV_U8) && (sp [-1]->opcode == OP_ICONST)) {\n\t\t\t\tint data = sp [-1]->inst_c0;\n\t\t\t\tsp [-1]->opcode = OP_I8CONST;\n\t\t\t\tsp [-1]->type = STACK_I8;\n#if SIZEOF_REGISTER == 8\n\t\t\t\tif (il_op == MONO_CEE_CONV_U8)\n\t\t\t\t\tsp [-1]->inst_c0 = (guint32)data;\n\t\t\t\telse\n\t\t\t\t\tsp [-1]->inst_c0 = data;\n#else\n\t\t\t\tif (il_op == MONO_CEE_CONV_U8)\n\t\t\t\t\tsp [-1]->inst_l = (guint32)data;\n\t\t\t\telse\n\t\t\t\t\tsp [-1]->inst_l = data;\n#endif\n\t\t\t\tsp [-1]->dreg = alloc_dreg (cfg, STACK_I8);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tADD_UNOP (il_op);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_CEE_CONV_OVF_I4:\n\t\tcase MONO_CEE_CONV_OVF_I1:\n\t\tcase MONO_CEE_CONV_OVF_I2:\n\t\tcase MONO_CEE_CONV_OVF_I:\n\t\tcase MONO_CEE_CONV_OVF_U:\n\t\t\tif (sp [-1]->type == STACK_R8 || sp [-1]->type == STACK_R4) {\n\t\t\t\tADD_UNOP (CEE_CONV_OVF_I8);\n\t\t\t\tADD_UNOP (il_op);\n\t\t\t} else {\n\t\t\t\tADD_UNOP (il_op);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_CEE_CONV_OVF_U1:\n\t\tcase MONO_CEE_CONV_OVF_U2:\n\t\tcase MONO_CEE_CONV_OVF_U4:\n\t\t\tif (sp [-1]->type == STACK_R8 || sp [-1]->type == STACK_R4) {\n\t\t\t\tADD_UNOP (CEE_CONV_OVF_U8);\n\t\t\t\tADD_UNOP (il_op);\n\t\t\t} else {\n\t\t\t\tADD_UNOP (il_op);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_CEE_CONV_OVF_I1_UN:\n\t\tcase MONO_CEE_CONV_OVF_I2_UN:\n\t\tcase MONO_CEE_CONV_OVF_I4_UN:\n\t\tcase MONO_CEE_CONV_OVF_I8_UN:\n\t\tcase MONO_CEE_CONV_OVF_U1_UN:\n\t\tcase MONO_CEE_CONV_OVF_U2_UN:\n\t\tcase MONO_CEE_CONV_OVF_U4_UN:\n\t\tcase MONO_CEE_CONV_OVF_U8_UN:\n\t\tcase MONO_CEE_CONV_OVF_I_UN:\n\t\tcase MONO_CEE_CONV_OVF_U_UN:\n\t\tcase MONO_CEE_CONV_U2:\n\t\tcase MONO_CEE_CONV_U1:\n\t\tcase MONO_CEE_CONV_I:\n\t\tcase MONO_CEE_CONV_U:\n\t\t\tADD_UNOP (il_op);\n\t\t\tCHECK_CFG_EXCEPTION;\n\t\t\tbreak;\n\t\tcase MONO_CEE_ADD_OVF:\n\t\tcase MONO_CEE_ADD_OVF_UN:\n\t\tcase MONO_CEE_MUL_OVF:\n\t\tcase MONO_CEE_MUL_OVF_UN:\n\t\tcase MONO_CEE_SUB_OVF:\n\t\tcase MONO_CEE_SUB_OVF_UN:\n\t\t\tADD_BINOP (il_op);\n\t\t\tbreak;\n\t\tcase MONO_CEE_CPOBJ:\n\t\t\tGSHAREDVT_FAILURE (il_op);\n\t\t\tGSHAREDVT_FAILURE (*ip);\n\t\t\tklass = mini_get_class (method, token, generic_context);\n\t\t\tCHECK_TYPELOAD (klass);\n\t\t\tsp -= 2;\n\t\t\tmini_emit_memory_copy (cfg, sp [0], sp [1], klass, FALSE, ins_flag);\n\t\t\tins_flag = 0;\n\t\t\tbreak;\n\t\tcase MONO_CEE_LDOBJ: {\n\t\t\tint loc_index = -1;\n\t\t\tint stloc_len = 0;\n\n\t\t\t--sp;\n\t\t\tklass = mini_get_class (method, token, generic_context);\n\t\t\tCHECK_TYPELOAD (klass);\n\n\t\t\t/* Optimize the common ldobj+stloc combination */\n\t\t\tif (next_ip < end) {\n\t\t\t\tswitch (next_ip [0]) {\n\t\t\t\tcase MONO_CEE_STLOC_S:\n\t\t\t\t\tCHECK_OPSIZE (7);\n\t\t\t\t\tloc_index = next_ip [1];\n\t\t\t\t\tstloc_len = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MONO_CEE_STLOC_0:\n\t\t\t\tcase MONO_CEE_STLOC_1:\n\t\t\t\tcase MONO_CEE_STLOC_2:\n\t\t\t\tcase MONO_CEE_STLOC_3:\n\t\t\t\t\tloc_index = next_ip [0] - CEE_STLOC_0;\n\t\t\t\t\tstloc_len = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((loc_index != -1) && ip_in_bb (cfg, cfg->cbb, next_ip)) {\n\t\t\t\tCHECK_LOCAL (loc_index);\n\n\t\t\t\tEMIT_NEW_LOAD_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (klass), sp [0]->dreg, 0);\n\t\t\t\tins->dreg = cfg->locals [loc_index]->dreg;\n\t\t\t\tins->flags |= ins_flag;\n\t\t\t\til_op = (MonoOpcodeEnum)next_ip [0];\n\t\t\t\tnext_ip += stloc_len;\n\t\t\t\tif (ins_flag & MONO_INST_VOLATILE) {\n\t\t\t\t\t/* Volatile loads have acquire semantics, see 12.6.7 in Ecma 335 */\n\t\t\t\t\tmini_emit_memory_barrier (cfg, MONO_MEMORY_BARRIER_ACQ);\n\t\t\t\t}\n\t\t\t\tins_flag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Optimize the ldobj+stobj combination */\n\t\t\tif (next_ip + 4 < end && next_ip [0] == CEE_STOBJ && ip_in_bb (cfg, cfg->cbb, next_ip) && read32 (next_ip + 1) == token) {\n\t\t\t\tCHECK_STACK (1);\n\n\t\t\t\tsp --;\n\n\t\t\t\tmini_emit_memory_copy (cfg, sp [0], sp [1], klass, FALSE, ins_flag);\n\n\t\t\t\til_op = (MonoOpcodeEnum)next_ip [0];\n\t\t\t\tnext_ip += 5;\n\t\t\t\tins_flag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tins = mini_emit_memory_load (cfg, m_class_get_byval_arg (klass), sp [0], 0, ins_flag);\n\t\t\t*sp++ = ins;\n\n\t\t\tins_flag = 0;\n\t\t\tinline_costs += 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_LDSTR:\n\t\t\tif (method->wrapper_type == MONO_WRAPPER_DYNAMIC_METHOD) {\n\t\t\t\tEMIT_NEW_PCONST (cfg, ins, mono_method_get_wrapper_data (method, n));\n\t\t\t\tins->type = STACK_OBJ;\n\t\t\t\t*sp = ins;\n\t\t\t}\n\t\t\telse if (method->wrapper_type != MONO_WRAPPER_NONE) {\n\t\t\t\tMonoInst *iargs [1];\n\t\t\t\tchar *str = (char *)mono_method_get_wrapper_data (method, n);\n\n\t\t\t\tif (cfg->compile_aot)\n\t\t\t\t\tEMIT_NEW_LDSTRLITCONST (cfg, iargs [0], str);\n\t\t\t\telse\n\t\t\t\t\tEMIT_NEW_PCONST (cfg, iargs [0], str);\n\t\t\t\t*sp = mono_emit_jit_icall (cfg, mono_string_new_wrapper_internal, iargs);\n\t\t\t} else {\n\t\t\t\tif (cfg->opt & MONO_OPT_SHARED) {\n\t\t\t\t\tMonoInst *iargs [3];\n\n\t\t\t\t\tif (cfg->compile_aot) {\n\t\t\t\t\t\tcfg->ldstr_list = g_list_prepend (cfg->ldstr_list, GINT_TO_POINTER (n));\n\t\t\t\t\t}\n\t\t\t\t\tEMIT_NEW_DOMAINCONST (cfg, iargs [0]);\n\t\t\t\t\tEMIT_NEW_IMAGECONST (cfg, iargs [1], image);\n\t\t\t\t\tEMIT_NEW_ICONST (cfg, iargs [2], mono_metadata_token_index (n));\n\t\t\t\t\t*sp = mono_emit_jit_icall (cfg, ves_icall_mono_ldstr, iargs);\n\t\t\t\t\tmono_ldstr_checked (cfg->domain, image, mono_metadata_token_index (n), cfg->error);\n\t\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t\t} else {\n\t\t\t\t\tif (cfg->cbb->out_of_line) {\n\t\t\t\t\t\tMonoInst *iargs [2];\n\n\t\t\t\t\t\tif (image == mono_defaults.corlib) {\n\t\t\t\t\t\t\t/* \n\t\t\t\t\t\t\t * Avoid relocations in AOT and save some space by using a \n\t\t\t\t\t\t\t * version of helper_ldstr specialized to mscorlib.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tEMIT_NEW_ICONST (cfg, iargs [0], mono_metadata_token_index (n));\n\t\t\t\t\t\t\t*sp = mono_emit_jit_icall (cfg, mono_helper_ldstr_mscorlib, iargs);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Avoid creating the string object */\n\t\t\t\t\t\t\tEMIT_NEW_IMAGECONST (cfg, iargs [0], image);\n\t\t\t\t\t\t\tEMIT_NEW_ICONST (cfg, iargs [1], mono_metadata_token_index (n));\n\t\t\t\t\t\t\t*sp = mono_emit_jit_icall (cfg, mono_helper_ldstr, iargs);\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t\telse\n\t\t\t\t\tif (cfg->compile_aot) {\n\t\t\t\t\t\tNEW_LDSTRCONST (cfg, ins, image, n);\n\t\t\t\t\t\t*sp = ins;\n\t\t\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\t\t} \n\t\t\t\t\telse {\n\t\t\t\t\t\tNEW_PCONST (cfg, ins, NULL);\n\t\t\t\t\t\tins->type = STACK_OBJ;\n\t\t\t\t\t\tins->inst_p0 = mono_ldstr_checked (cfg->domain, image, mono_metadata_token_index (n), cfg->error);\n\t\t\t\t\t\tCHECK_CFG_ERROR;\n\n\t\t\t\t\t\tif (!ins->inst_p0)\n\t\t\t\t\t\t\tOUT_OF_MEMORY_FAILURE;\n\n\t\t\t\t\t\t*sp = ins;\n\t\t\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsp++;\n\t\t\tbreak;\n\t\tcase MONO_CEE_NEWOBJ: {\n\t\t\tMonoInst *iargs [2];\n\t\t\tMonoMethodSignature *fsig;\n\t\t\tMonoInst this_ins;\n\t\t\tMonoInst *alloc;\n\t\t\tMonoInst *vtable_arg = NULL;\n\n\t\t\tcmethod = mini_get_method (cfg, method, token, NULL, generic_context);\n\t\t\tCHECK_CFG_ERROR;\n\n\t\t\tfsig = mono_method_get_signature_checked (cmethod, image, token, generic_context, cfg->error);\n\t\t\tCHECK_CFG_ERROR;\n\n\t\t\tmono_save_token_info (cfg, image, token, cmethod);\n\n\t\t\tif (!mono_class_init_internal (cmethod->klass))\n\t\t\t\tTYPE_LOAD_ERROR (cmethod->klass);\n\n\t\t\tcontext_used = mini_method_check_context_used (cfg, cmethod);\n\n\t\t\tif (!dont_verify && !cfg->skip_visibility) {\n\t\t\t\tMonoMethod *cil_method = cmethod;\n\t\t\t\tMonoMethod *target_method = cil_method;\n\n\t\t\t\tif (method->is_inflated) {\n\t\t\t\t\ttarget_method = mini_get_method_allow_open (method, token, NULL, &(mono_method_get_generic_container (method_definition)->context), cfg->error);\n\t\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t\t}\n\n\t\t\t\tif (!mono_method_can_access_method (method_definition, target_method) &&\n\t\t\t\t\t!mono_method_can_access_method (method, cil_method))\n\t\t\t\t\temit_method_access_failure (cfg, method, cil_method);\n\t\t\t}\n\n\t\t\tif (mono_security_core_clr_enabled ())\n\t\t\t\tensure_method_is_allowed_to_call_method (cfg, method, cmethod);\n\n\t\t\tif (cfg->gshared && cmethod && cmethod->klass != method->klass && mono_class_is_ginst (cmethod->klass) && mono_method_is_generic_sharable (cmethod, TRUE) && mono_class_needs_cctor_run (cmethod->klass, method)) {\n\t\t\t\temit_class_init (cfg, cmethod->klass);\n\t\t\t\tCHECK_TYPELOAD (cmethod->klass);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (cfg->gsharedvt) {\n\t\t\t\tif (mini_is_gsharedvt_variable_signature (sig))\n\t\t\t\t\tGSHAREDVT_FAILURE (il_op);\n\t\t\t}\n\t\t\t*/\n\n\t\t\tn = fsig->param_count;\n\t\t\tCHECK_STACK (n);\n\n\t\t\t/* \n\t\t\t * Generate smaller code for the common newobj <exception> instruction in\n\t\t\t * argument checking code.\n\t\t\t */\n\t\t\tif (cfg->cbb->out_of_line && m_class_get_image (cmethod->klass) == mono_defaults.corlib &&\n\t\t\t\tis_exception_class (cmethod->klass) && n <= 2 &&\n\t\t\t\t((n < 1) || (!fsig->params [0]->byref && fsig->params [0]->type == MONO_TYPE_STRING)) && \n\t\t\t\t((n < 2) || (!fsig->params [1]->byref && fsig->params [1]->type == MONO_TYPE_STRING))) {\n\t\t\t\tMonoInst *iargs [3];\n\n\t\t\t\tsp -= n;\n\n\t\t\t\tEMIT_NEW_ICONST (cfg, iargs [0], m_class_get_type_token (cmethod->klass));\n\t\t\t\tswitch (n) {\n\t\t\t\tcase 0:\n\t\t\t\t\t*sp ++ = mono_emit_jit_icall (cfg, mono_create_corlib_exception_0, iargs);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tiargs [1] = sp [0];\n\t\t\t\t\t*sp ++ = mono_emit_jit_icall (cfg, mono_create_corlib_exception_1, iargs);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tiargs [1] = sp [0];\n\t\t\t\t\tiargs [2] = sp [1];\n\t\t\t\t\t*sp ++ = mono_emit_jit_icall (cfg, mono_create_corlib_exception_2, iargs);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n\n\t\t\t\tinline_costs += 5;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* move the args to allow room for 'this' in the first position */\n\t\t\twhile (n--) {\n\t\t\t\t--sp;\n\t\t\t\tsp [1] = sp [0];\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < fsig->param_count; ++i)\n\t\t\t\tsp [i + fsig->hasthis] = convert_value (cfg, fsig->params [i], sp [i + fsig->hasthis]);\n\n\t\t\t/* check_call_signature () requires sp[0] to be set */\n\t\t\tthis_ins.type = STACK_OBJ;\n\t\t\tsp [0] = &this_ins;\n\t\t\tif (check_call_signature (cfg, fsig, sp))\n\t\t\t\tUNVERIFIED;\n\n\t\t\tiargs [0] = NULL;\n\n\t\t\tif (mini_class_is_system_array (cmethod->klass)) {\n\t\t\t\t*sp = emit_get_rgctx_method (cfg, context_used,\n\t\t\t\t\t\t\t\t\t\t\t cmethod, MONO_RGCTX_INFO_METHOD);\n\t\t\t\t/* Optimize the common cases */\n\t\t\t\tMonoJitICallId function = MONO_JIT_ICALL_ZeroIsReserved;;\n\t\t\t\tint n = fsig->param_count;\n\t\t\t\tswitch (n) {\n\t\t\t\tcase 1: function = MONO_JIT_ICALL_mono_array_new_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2: function = MONO_JIT_ICALL_mono_array_new_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3: function = MONO_JIT_ICALL_mono_array_new_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4: function = MONO_JIT_ICALL_mono_array_new_4;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// FIXME Maximum value of param_count? Realistically 64. Fits in imm?\n\t\t\t\t\tif  (!array_new_localalloc_ins) {\n\t\t\t\t\t\tMONO_INST_NEW (cfg, array_new_localalloc_ins, OP_LOCALLOC_IMM);\n\t\t\t\t\t\tarray_new_localalloc_ins->dreg = alloc_preg (cfg);\n\t\t\t\t\t\tcfg->flags |= MONO_CFG_HAS_ALLOCA;\n\t\t\t\t\t\tMONO_ADD_INS (init_localsbb, array_new_localalloc_ins);\n\t\t\t\t\t}\n\t\t\t\t\tarray_new_localalloc_ins->inst_imm = MAX (array_new_localalloc_ins->inst_imm, n * sizeof (target_mgreg_t));\n\t\t\t\t\tint dreg = array_new_localalloc_ins->dreg;\n\t\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\t\tNEW_STORE_MEMBASE (cfg, ins, OP_STORE_MEMBASE_REG, dreg, i * sizeof (target_mgreg_t), sp [i + 1]->dreg);\n\t\t\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\t\t}\n\t\t\t\t\tEMIT_NEW_ICONST (cfg, ins, n);\n\t\t\t\t\tsp [1] = ins;\n\t\t\t\t\tEMIT_NEW_UNALU (cfg, ins, OP_MOVE, alloc_preg (cfg), dreg);\n\t\t\t\t\tins->type = STACK_PTR;\n\t\t\t\t\tsp [2] = ins;\n\t\t\t\t\t// FIXME Adjust sp by n - 3? Attempts failed.\n\t\t\t\t\tfunction = MONO_JIT_ICALL_mono_array_new_n_icall;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\talloc = mono_emit_jit_icall_id (cfg, function, sp);\n\t\t\t} else if (cmethod->string_ctor) {\n\t\t\t\tg_assert (!context_used);\n\t\t\t\tg_assert (!vtable_arg);\n\t\t\t\t/* we simply pass a null pointer */\n\t\t\t\tEMIT_NEW_PCONST (cfg, *sp, NULL); \n\t\t\t\t/* now call the string ctor */\n\t\t\t\talloc = mini_emit_method_call_full (cfg, cmethod, fsig, FALSE, sp, NULL, NULL, NULL);\n\t\t\t} else {\n\t\t\t\tif (m_class_is_valuetype (cmethod->klass)) {\n\t\t\t\t\tiargs [0] = mono_compile_create_var (cfg, m_class_get_byval_arg (cmethod->klass), OP_LOCAL);\n\t\t\t\t\temit_init_rvar (cfg, iargs [0]->dreg, m_class_get_byval_arg (cmethod->klass));\n\t\t\t\t\tEMIT_NEW_TEMPLOADA (cfg, *sp, iargs [0]->inst_c0);\n\n\t\t\t\t\talloc = NULL;\n\n\t\t\t\t\t/* \n\t\t\t\t\t * The code generated by mini_emit_virtual_call () expects\n\t\t\t\t\t * iargs [0] to be a boxed instance, but luckily the vcall\n\t\t\t\t\t * will be transformed into a normal call there.\n\t\t\t\t\t */\n\t\t\t\t} else if (context_used) {\n\t\t\t\t\talloc = handle_alloc (cfg, cmethod->klass, FALSE, context_used);\n\t\t\t\t\t*sp = alloc;\n\t\t\t\t} else {\n\t\t\t\t\tMonoVTable *vtable = NULL;\n\n\t\t\t\t\tif (!cfg->compile_aot)\n\t\t\t\t\t\tvtable = mono_class_vtable_checked (cfg->domain, cmethod->klass, cfg->error);\n\t\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t\t\tCHECK_TYPELOAD (cmethod->klass);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * TypeInitializationExceptions thrown from the mono_runtime_class_init\n\t\t\t\t\t * call in mono_jit_runtime_invoke () can abort the finalizer thread.\n\t\t\t\t\t * As a workaround, we call class cctors before allocating objects.\n\t\t\t\t\t */\n\t\t\t\t\tif (mini_field_access_needs_cctor_run (cfg, method, cmethod->klass, vtable) && !(g_slist_find (class_inits, cmethod->klass))) {\n\t\t\t\t\t\temit_class_init (cfg, cmethod->klass);\n\t\t\t\t\t\tif (cfg->verbose_level > 2)\n\t\t\t\t\t\t\tprintf (\"class %s.%s needs init call for ctor\\n\", m_class_get_name_space (cmethod->klass), m_class_get_name (cmethod->klass));\n\t\t\t\t\t\tclass_inits = g_slist_prepend (class_inits, cmethod->klass);\n\t\t\t\t\t}\n\n\t\t\t\t\talloc = handle_alloc (cfg, cmethod->klass, FALSE, 0);\n\t\t\t\t\t*sp = alloc;\n\t\t\t\t}\n\t\t\t\tCHECK_CFG_EXCEPTION; /*for handle_alloc*/\n\n\t\t\t\tif (alloc)\n\t\t\t\t\tMONO_EMIT_NEW_UNALU (cfg, OP_NOT_NULL, -1, alloc->dreg);\n\n\t\t\t\t/* Now call the actual ctor */\n\t\t\t\thandle_ctor_call (cfg, cmethod, fsig, context_used, sp, ip, &inline_costs);\n\t\t\t\tCHECK_CFG_EXCEPTION;\n\t\t\t}\n\n\t\t\tif (alloc == NULL) {\n\t\t\t\t/* Valuetype */\n\t\t\t\tEMIT_NEW_TEMPLOAD (cfg, ins, iargs [0]->inst_c0);\n\t\t\t\tmini_type_to_eval_stack_type (cfg, m_class_get_byval_arg (ins->klass), ins);\n\t\t\t\t*sp++= ins;\n\t\t\t} else {\n\t\t\t\t*sp++ = alloc;\n\t\t\t}\n\t\t\t\n\t\t\tinline_costs += 5;\n\t\t\tif (!(seq_point_locs && mono_bitset_test_fast (seq_point_locs, next_ip - header->code)))\n\t\t\t\temit_seq_point (cfg, method, next_ip, FALSE, TRUE);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_CASTCLASS:\n\t\tcase MONO_CEE_ISINST: {\n\t\t\t--sp;\n\t\t\tklass = mini_get_class (method, token, generic_context);\n\t\t\tCHECK_TYPELOAD (klass);\n\t\t\tif (sp [0]->type != STACK_OBJ)\n\t\t\t\tUNVERIFIED;\n\n\t\t\tMONO_INST_NEW (cfg, ins, (il_op == MONO_CEE_ISINST) ? OP_ISINST : OP_CASTCLASS);\n\t\t\tins->dreg = alloc_preg (cfg);\n\t\t\tins->sreg1 = (*sp)->dreg;\n\t\t\tins->klass = klass;\n\t\t\tins->type = STACK_OBJ;\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\n\t\t\tCHECK_CFG_EXCEPTION;\n\t\t\t*sp++ = ins;\n\n\t\t\tcfg->flags |= MONO_CFG_HAS_TYPE_CHECK;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_UNBOX_ANY: {\n\t\t\tMonoInst *res, *addr;\n\n\t\t\t--sp;\n\t\t\tklass = mini_get_class (method, token, generic_context);\n\t\t\tCHECK_TYPELOAD (klass);\n\n\t\t\tmono_save_token_info (cfg, image, token, klass);\n\n\t\t\tcontext_used = mini_class_check_context_used (cfg, klass);\n\n\t\t\tif (mini_is_gsharedvt_klass (klass)) {\n\t\t\t\tres = handle_unbox_gsharedvt (cfg, klass, *sp);\n\t\t\t\tinline_costs += 2;\n\t\t\t} else if (mini_class_is_reference (klass)) {\n\t\t\t\tif (MONO_INS_IS_PCONST_NULL (*sp)) {\n\t\t\t\t\tEMIT_NEW_PCONST (cfg, res, NULL);\n\t\t\t\t\tres->type = STACK_OBJ;\n\t\t\t\t} else {\n\t\t\t\t\tMONO_INST_NEW (cfg, res, OP_CASTCLASS);\n\t\t\t\t\tres->dreg = alloc_preg (cfg);\n\t\t\t\t\tres->sreg1 = (*sp)->dreg;\n\t\t\t\t\tres->klass = klass;\n\t\t\t\t\tres->type = STACK_OBJ;\n\t\t\t\t\tMONO_ADD_INS (cfg->cbb, res);\n\t\t\t\t\tcfg->flags |= MONO_CFG_HAS_TYPE_CHECK;\n\t\t\t\t}\n\t\t\t} else if (mono_class_is_nullable (klass)) {\n\t\t\t\tres = handle_unbox_nullable (cfg, *sp, klass, context_used);\n\t\t\t} else {\n\t\t\t\taddr = handle_unbox (cfg, klass, sp, context_used);\n\t\t\t\t/* LDOBJ */\n\t\t\t\tEMIT_NEW_LOAD_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (klass), addr->dreg, 0);\n\t\t\t\tres = ins;\n\t\t\t\tinline_costs += 2;\n\t\t\t}\n\n\t\t\t*sp ++ = res;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_BOX: {\n\t\t\tMonoInst *val;\n\t\t\tMonoClass *enum_class;\n\t\t\tMonoMethod *has_flag;\n\n\t\t\t--sp;\n\t\t\tval = *sp;\n\t\t\tklass = mini_get_class (method, token, generic_context);\n\t\t\tCHECK_TYPELOAD (klass);\n\n\t\t\tmono_save_token_info (cfg, image, token, klass);\n\n\t\t\tcontext_used = mini_class_check_context_used (cfg, klass);\n\n\t\t\tif (mini_class_is_reference (klass)) {\n\t\t\t\t*sp++ = val;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tval = convert_value (cfg, m_class_get_byval_arg (klass), val);\n\n\t\t\tif (klass == mono_defaults.void_class)\n\t\t\t\tUNVERIFIED;\n\t\t\tif (target_type_is_incompatible (cfg, m_class_get_byval_arg (klass), val))\n\t\t\t\tUNVERIFIED;\n\t\t\t/* frequent check in generic code: box (struct), brtrue */\n\n\t\t\t/*\n\t\t\t * Look for:\n\t\t\t *\n\t\t\t *   <push int/long ptr>\n\t\t\t *   <push int/long>\n\t\t\t *   box MyFlags\n\t\t\t *   constrained. MyFlags\n\t\t\t *   callvirt instace bool class [mscorlib] System.Enum::HasFlag (class [mscorlib] System.Enum)\n\t\t\t *\n\t\t\t * If we find this sequence and the operand types on box and constrained\n\t\t\t * are equal, we can emit a specialized instruction sequence instead of\n\t\t\t * the very slow HasFlag () call.\n\t\t\t * This code sequence is generated by older mcs/csc, the newer one is handled in\n\t\t\t * emit_inst_for_method ().\n\t\t\t */\n\t\t\tguint32 constrained_token;\n\t\t\tguint32 callvirt_token;\n\n\t\t\tif ((cfg->opt & MONO_OPT_INTRINS) &&\n\t\t\t    //  FIXME ip_in_bb as we go?\n\t\t\t    next_ip < end && ip_in_bb (cfg, cfg->cbb, next_ip) &&\n\t\t\t    (ip = il_read_constrained (next_ip, end, &constrained_token)) &&\n\t\t\t    ip_in_bb (cfg, cfg->cbb, ip) &&\n\t\t\t    (ip = il_read_callvirt (ip, end, &callvirt_token)) &&\n\t\t\t    ip_in_bb (cfg, cfg->cbb, ip) &&\n\t\t\t    m_class_is_enumtype (klass) &&\n\t\t\t    (enum_class = mini_get_class (method, constrained_token, generic_context)) &&\n\t\t\t    (has_flag = mini_get_method (cfg, method, callvirt_token, NULL, generic_context)) &&\n\t\t\t    has_flag->klass == mono_defaults.enum_class &&\n\t\t\t    !strcmp (has_flag->name, \"HasFlag\") &&\n\t\t\t    has_flag->signature->hasthis &&\n\t\t\t    has_flag->signature->param_count == 1) {\n\t\t\t\tCHECK_TYPELOAD (enum_class);\n\n\t\t\t\tif (enum_class == klass) {\n\t\t\t\t\tMonoInst *enum_this, *enum_flag;\n\n\t\t\t\t\tnext_ip = ip;\n\t\t\t\t\til_op = MONO_CEE_CALLVIRT;\n\t\t\t\t\t--sp;\n\n\t\t\t\t\tenum_this = sp [0];\n\t\t\t\t\tenum_flag = sp [1];\n\n\t\t\t\t\t*sp++ = mini_handle_enum_has_flag (cfg, klass, enum_this, -1, enum_flag);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tguint32 unbox_any_token;\n\n\t\t\t/*\n\t\t\t * Common in generic code:\n\t\t\t * box T1, unbox.any T2.\n\t\t\t */\n\t\t\tif ((cfg->opt & MONO_OPT_INTRINS) &&\n\t\t\t    next_ip < end && ip_in_bb (cfg, cfg->cbb, next_ip) &&\n\t\t\t    (ip = il_read_unbox_any (next_ip, end, &unbox_any_token))) {\n\t\t\t\tMonoClass *unbox_klass = mini_get_class (method, unbox_any_token, generic_context);\n\t\t\t\tCHECK_TYPELOAD (unbox_klass);\n\n\t\t\t\tif (klass == unbox_klass) {\n\t\t\t\t\tnext_ip = ip;\n\t\t\t\t\t*sp++ = val;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgboolean is_true;\n\n\t\t\t// FIXME: LLVM can't handle the inconsistent bb linking\n\t\t\tif (!mono_class_is_nullable (klass) &&\n\t\t\t\t!mini_is_gsharedvt_klass (klass) &&\n\t\t\t\tnext_ip < end && ip_in_bb (cfg, cfg->cbb, next_ip) &&\n\t\t\t\t( (is_true = !!(ip = il_read_brtrue   (next_ip, end, &target))) ||\n\t\t\t\t  (is_true = !!(ip = il_read_brtrue_s (next_ip, end, &target))) ||\n\t\t\t\t\t       (ip = il_read_brfalse  (next_ip, end, &target))  ||\n\t\t\t\t\t       (ip = il_read_brfalse_s (next_ip, end, &target)))) {\n\n\t\t\t\tint dreg;\n\t\t\t\tMonoBasicBlock *true_bb, *false_bb;\n\n\t\t\t\til_op = (MonoOpcodeEnum)next_ip [0];\n\t\t\t\tnext_ip = ip;\n\n\t\t\t\tif (cfg->verbose_level > 3) {\n\t\t\t\t\tprintf (\"converting (in B%d: stack: %d) %s\", cfg->cbb->block_num, (int)(sp - stack_start), mono_disasm_code_one (NULL, method, ip, NULL));\n\t\t\t\t\tprintf (\"<box+brtrue opt>\\n\");\n\t\t\t\t}\n\n\t\t\t\t/* \n\t\t\t\t * We need to link both bblocks, since it is needed for handling stack\n\t\t\t\t * arguments correctly (See test_0_box_brtrue_opt_regress_81102).\n\t\t\t\t * Branching to only one of them would lead to inconsistencies, so\n\t\t\t\t * generate an ICONST+BRTRUE, the branch opts will get rid of them.\n\t\t\t\t */\n\t\t\t\tGET_BBLOCK (cfg, true_bb, target);\n\t\t\t\tGET_BBLOCK (cfg, false_bb, next_ip);\n\n\t\t\t\tmono_link_bblock (cfg, cfg->cbb, true_bb);\n\t\t\t\tmono_link_bblock (cfg, cfg->cbb, false_bb);\n\n\t\t\t\tif (sp != stack_start) {\n\t\t\t\t\thandle_stack_args (cfg, stack_start, sp - stack_start);\n\t\t\t\t\tsp = stack_start;\n\t\t\t\t\tCHECK_UNVERIFIABLE (cfg);\n\t\t\t\t}\n\n\t\t\t\tif (COMPILE_LLVM (cfg)) {\n\t\t\t\t\tdreg = alloc_ireg (cfg);\n\t\t\t\t\tMONO_EMIT_NEW_ICONST (cfg, dreg, 0);\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, dreg, is_true ? 0 : 1);\n\n\t\t\t\t\tMONO_EMIT_NEW_BRANCH_BLOCK2 (cfg, OP_IBEQ, true_bb, false_bb);\n\t\t\t\t} else {\n\t\t\t\t\t/* The JIT can't eliminate the iconst+compare */\n\t\t\t\t\tMONO_INST_NEW (cfg, ins, OP_BR);\n\t\t\t\t\tins->inst_target_bb = is_true ? true_bb : false_bb;\n\t\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\t}\n\n\t\t\t\tstart_new_bblock = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (m_class_is_enumtype (klass) && !mini_is_gsharedvt_klass (klass) && !(val->type == STACK_I8 && TARGET_SIZEOF_VOID_P == 4)) {\n\t\t\t\t/* Can't do this with 64 bit enums on 32 bit since the vtype decomp pass is ran after the long decomp pass */\n\t\t\t\tif (val->opcode == OP_ICONST) {\n\t\t\t\t\tMONO_INST_NEW (cfg, ins, OP_BOX_ICONST);\n\t\t\t\t\tins->type = STACK_OBJ;\n\t\t\t\t\tins->klass = klass;\n\t\t\t\t\tins->inst_c0 = val->inst_c0;\n\t\t\t\t\tins->dreg = alloc_dreg (cfg, (MonoStackType)val->type);\n\t\t\t\t} else {\n\t\t\t\t\tMONO_INST_NEW (cfg, ins, OP_BOX);\n\t\t\t\t\tins->type = STACK_OBJ;\n\t\t\t\t\tins->klass = klass;\n\t\t\t\t\tins->sreg1 = val->dreg;\n\t\t\t\t\tins->dreg = alloc_dreg (cfg, (MonoStackType)val->type);\n\t\t\t\t}\n\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\t*sp++ = ins;\n\t\t\t\t/* Create domainvar early so it gets initialized earlier than this code */\n\t\t\t\tif (cfg->opt & MONO_OPT_SHARED)\n\t\t\t\t\tmono_get_domainvar (cfg);\n\t\t\t} else {\n\t\t\t\t*sp++ = mini_emit_box (cfg, val, klass, context_used);\n\t\t\t}\n\t\t\tCHECK_CFG_EXCEPTION;\n\t\t\tinline_costs += 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_UNBOX: {\n\t\t\t--sp;\n\t\t\tklass = mini_get_class (method, token, generic_context);\n\t\t\tCHECK_TYPELOAD (klass);\n\n\t\t\tmono_save_token_info (cfg, image, token, klass);\n\n\t\t\tcontext_used = mini_class_check_context_used (cfg, klass);\n\n\t\t\tif (mono_class_is_nullable (klass)) {\n\t\t\t\tMonoInst *val;\n\n\t\t\t\tval = handle_unbox_nullable (cfg, *sp, klass, context_used);\n\t\t\t\tEMIT_NEW_VARLOADA (cfg, ins, get_vreg_to_inst (cfg, val->dreg), m_class_get_byval_arg (val->klass));\n\n\t\t\t\t*sp++= ins;\n\t\t\t} else {\n\t\t\t\tins = handle_unbox (cfg, klass, sp, context_used);\n\t\t\t\t*sp++ = ins;\n\t\t\t}\n\t\t\tinline_costs += 2;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_LDFLD:\n\t\tcase MONO_CEE_LDFLDA:\n\t\tcase MONO_CEE_STFLD:\n\t\tcase MONO_CEE_LDSFLD:\n\t\tcase MONO_CEE_LDSFLDA:\n\t\tcase MONO_CEE_STSFLD: {\n\t\t\tMonoClassField *field;\n#ifndef DISABLE_REMOTING\n\t\t\tint costs;\n#endif\n\t\t\tguint foffset;\n\t\t\tgboolean is_instance;\n\t\t\tgpointer addr = NULL;\n\t\t\tgboolean is_special_static;\n\t\t\tMonoType *ftype;\n\t\t\tMonoInst *store_val = NULL;\n\t\t\tMonoInst *thread_ins;\n\n\t\t\tis_instance = (il_op == MONO_CEE_LDFLD || il_op == MONO_CEE_LDFLDA || il_op == MONO_CEE_STFLD);\n\t\t\tif (is_instance) {\n\t\t\t\tif (il_op == MONO_CEE_STFLD) {\n\t\t\t\t\tsp -= 2;\n\t\t\t\t\tstore_val = sp [1];\n\t\t\t\t} else {\n\t\t\t\t\t--sp;\n\t\t\t\t}\n\t\t\t\tif (sp [0]->type == STACK_I4 || sp [0]->type == STACK_I8 || sp [0]->type == STACK_R8)\n\t\t\t\t\tUNVERIFIED;\n\t\t\t\tif (il_op != MONO_CEE_LDFLD && sp [0]->type == STACK_VTYPE)\n\t\t\t\t\tUNVERIFIED;\n\t\t\t} else {\n\t\t\t\tif (il_op == MONO_CEE_STSFLD) {\n\t\t\t\t\tsp--;\n\t\t\t\t\tstore_val = sp [0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (method->wrapper_type != MONO_WRAPPER_NONE) {\n\t\t\t\tfield = (MonoClassField *)mono_method_get_wrapper_data (method, token);\n\t\t\t\tklass = field->parent;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield = mono_field_from_token_checked (image, token, &klass, generic_context, cfg->error);\n\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t}\n\t\t\tif (!dont_verify && !cfg->skip_visibility && !mono_method_can_access_field (method, field))\n\t\t\t\tFIELD_ACCESS_FAILURE (method, field);\n\t\t\tmono_class_init_internal (klass);\n\t\t\tmono_class_setup_fields (klass);\n\n\t\t\t/* if the class is Critical then transparent code cannot access it's fields */\n\t\t\tif (!is_instance && mono_security_core_clr_enabled ())\n\t\t\t\tensure_method_is_allowed_to_access_field (cfg, method, field);\n\n\t\t\t/* XXX this is technically required but, so far (SL2), no [SecurityCritical] types (not many exists) have\n\t\t\t   any visible *instance* field  (in fact there's a single case for a static field in Marshal) XXX\n\t\t\tif (mono_security_core_clr_enabled ())\n\t\t\t\tensure_method_is_allowed_to_access_field (cfg, method, field);\n\t\t\t*/\n\n\t\t\tftype = mono_field_get_type_internal (field);\n\n\t\t\t/*\n\t\t\t * LDFLD etc. is usable on static fields as well, so convert those cases to\n\t\t\t * the static case.\n\t\t\t */\n\t\t\tif (is_instance && ftype->attrs & FIELD_ATTRIBUTE_STATIC) {\n\t\t\t\tswitch (il_op) {\n\t\t\t\tcase MONO_CEE_LDFLD:\n\t\t\t\t\til_op = MONO_CEE_LDSFLD;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MONO_CEE_STFLD:\n\t\t\t\t\til_op = MONO_CEE_STSFLD;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MONO_CEE_LDFLDA:\n\t\t\t\t\til_op = MONO_CEE_LDSFLDA;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n\t\t\t\tis_instance = FALSE;\n\t\t\t}\n\n\t\t\tcontext_used = mini_class_check_context_used (cfg, klass);\n\n\t\t\tif (il_op == MONO_CEE_LDSFLD) {\n\t\t\t\tins = mini_emit_inst_for_field_load (cfg, field);\n\t\t\t\tif (ins) {\n\t\t\t\t\t*sp++ = ins;\n\t\t\t\t\tgoto field_access_end;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* INSTANCE CASE */\n\n\t\t\tif (is_instance)\n\t\t\t\tg_assert (field->offset);\n\t\t\tfoffset = m_class_is_valuetype (klass) ? field->offset - MONO_ABI_SIZEOF (MonoObject): field->offset;\n\t\t\tif (il_op == MONO_CEE_STFLD) {\n\t\t\t\tsp [1] = convert_value (cfg, field->type, sp [1]);\n\t\t\t\tif (target_type_is_incompatible (cfg, field->type, sp [1]))\n\t\t\t\t\tUNVERIFIED;\n#ifndef DISABLE_REMOTING\n\t\t\t\tif ((mono_class_is_marshalbyref (klass) && !MONO_CHECK_THIS (sp [0])) || mono_class_is_contextbound (klass) || klass == mono_defaults.marshalbyrefobject_class) {\n\t\t\t\t\tMonoMethod *stfld_wrapper = mono_marshal_get_stfld_wrapper (field->type); \n\t\t\t\t\tMonoInst *iargs [5];\n\n\t\t\t\t\tGSHAREDVT_FAILURE (il_op);\n\n\t\t\t\t\tiargs [0] = sp [0];\n\t\t\t\t\tEMIT_NEW_CLASSCONST (cfg, iargs [1], klass);\n\t\t\t\t\tEMIT_NEW_FIELDCONST (cfg, iargs [2], field);\n\t\t\t\t\tEMIT_NEW_ICONST (cfg, iargs [3], m_class_is_valuetype (klass) ? field->offset - MONO_ABI_SIZEOF (MonoObject) : \n\t\t\t\t\t\t    field->offset);\n\t\t\t\t\tiargs [4] = sp [1];\n\n\t\t\t\t\tif (cfg->opt & MONO_OPT_INLINE || cfg->compile_aot) {\n\t\t\t\t\t\tcosts = inline_method (cfg, stfld_wrapper, mono_method_signature_internal (stfld_wrapper), \n\t\t\t\t\t\t\t\t\t\t\t   iargs, ip, cfg->real_offset, TRUE);\n\t\t\t\t\t\tCHECK_CFG_EXCEPTION;\n\t\t\t\t\t\tg_assert (costs > 0);\n\n\t\t\t\t\t\tcfg->real_offset += 5;\n\n\t\t\t\t\t\tinline_costs += costs;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmono_emit_method_call (cfg, stfld_wrapper, iargs, NULL);\n\t\t\t\t\t}\n\t\t\t\t} else\n#endif\n\t\t\t\t{\n\t\t\t\t\tMonoInst *store;\n\n\t\t\t\t\tMONO_EMIT_NULL_CHECK (cfg, sp [0]->dreg, foffset > mono_target_pagesize ());\n\n\t\t\t\t\tif (ins_flag & MONO_INST_VOLATILE) {\n\t\t\t\t\t\t/* Volatile stores have release semantics, see 12.6.7 in Ecma 335 */\n\t\t\t\t\t\tmini_emit_memory_barrier (cfg, MONO_MEMORY_BARRIER_REL);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mini_is_gsharedvt_klass (klass)) {\n\t\t\t\t\t\tMonoInst *offset_ins;\n\n\t\t\t\t\t\tcontext_used = mini_class_check_context_used (cfg, klass);\n\n\t\t\t\t\t\toffset_ins = emit_get_gsharedvt_info (cfg, field, MONO_RGCTX_INFO_FIELD_OFFSET);\n\t\t\t\t\t\t/* The value is offset by 1 */\n\t\t\t\t\t\tEMIT_NEW_BIALU_IMM (cfg, ins, OP_PSUB_IMM, offset_ins->dreg, offset_ins->dreg, 1);\n\t\t\t\t\t\tdreg = alloc_ireg_mp (cfg);\n\t\t\t\t\t\tEMIT_NEW_BIALU (cfg, ins, OP_PADD, dreg, sp [0]->dreg, offset_ins->dreg);\n\t\t\t\t\t\tif (cfg->gen_write_barriers && mini_type_to_stind (cfg, field->type) == CEE_STIND_REF && !MONO_INS_IS_PCONST_NULL (sp [1])) {\n\t\t\t\t\t\t\tstore = mini_emit_storing_write_barrier (cfg, ins, sp [1]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* The decomposition will call mini_emit_memory_copy () which will emit a wbarrier if needed */\n\t\t\t\t\t\t\tEMIT_NEW_STORE_MEMBASE_TYPE (cfg, store, field->type, dreg, 0, sp [1]->dreg);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cfg->gen_write_barriers && mini_type_to_stind (cfg, field->type) == CEE_STIND_REF && !MONO_INS_IS_PCONST_NULL (sp [1])) {\n\t\t\t\t\t\t\t/* insert call to write barrier */\n\t\t\t\t\t\t\tMonoInst *ptr;\n\t\t\t\t\t\t\tint dreg;\n\n\t\t\t\t\t\t\tdreg = alloc_ireg_mp (cfg);\n\t\t\t\t\t\t\tEMIT_NEW_BIALU_IMM (cfg, ptr, OP_PADD_IMM, dreg, sp [0]->dreg, foffset);\n\t\t\t\t\t\t\tstore = mini_emit_storing_write_barrier (cfg, ptr, sp [1]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tEMIT_NEW_STORE_MEMBASE_TYPE (cfg, store, field->type, sp [0]->dreg, foffset, sp [1]->dreg);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sp [0]->opcode != OP_LDADDR)\n\t\t\t\t\t\tstore->flags |= MONO_INST_FAULT;\n\n\t\t\t\t\tstore->flags |= ins_flag;\n\t\t\t\t}\n\t\t\t\tgoto field_access_end;\n\t\t\t}\n\n#ifndef DISABLE_REMOTING\n\t\t\tif (is_instance && ((mono_class_is_marshalbyref (klass) && !MONO_CHECK_THIS (sp [0])) || mono_class_is_contextbound (klass) || klass == mono_defaults.marshalbyrefobject_class)) {\n\t\t\t\tMonoMethod *wrapper = (il_op == MONO_CEE_LDFLDA) ? mono_marshal_get_ldflda_wrapper (field->type) : mono_marshal_get_ldfld_wrapper (field->type); \n\t\t\t\tMonoInst *iargs [4];\n\n\t\t\t\tGSHAREDVT_FAILURE (il_op);\n\n\t\t\t\tiargs [0] = sp [0];\n\t\t\t\tEMIT_NEW_CLASSCONST (cfg, iargs [1], klass);\n\t\t\t\tEMIT_NEW_FIELDCONST (cfg, iargs [2], field);\n\t\t\t\tEMIT_NEW_ICONST (cfg, iargs [3], m_class_is_valuetype (klass) ? field->offset - MONO_ABI_SIZEOF (MonoObject) : field->offset);\n\t\t\t\tif (cfg->opt & MONO_OPT_INLINE || cfg->compile_aot) {\n\t\t\t\t\tcosts = inline_method (cfg, wrapper, mono_method_signature_internal (wrapper), \n\t\t\t\t\t\t\t\t\t\t   iargs, ip, cfg->real_offset, TRUE);\n\t\t\t\t\tCHECK_CFG_EXCEPTION;\n\t\t\t\t\tg_assert (costs > 0);\n\n\t\t\t\t\tcfg->real_offset += 5;\n\n\t\t\t\t\t*sp++ = iargs [0];\n\n\t\t\t\t\tinline_costs += costs;\n\t\t\t\t} else {\n\t\t\t\t\tins = mono_emit_method_call (cfg, wrapper, iargs, NULL);\n\t\t\t\t\t*sp++ = ins;\n\t\t\t\t}\n\t\t\t} else \n#endif\n\t\t\tif (is_instance) {\n\t\t\t\tif (sp [0]->type == STACK_VTYPE) {\n\t\t\t\t\tMonoInst *var;\n\n\t\t\t\t\t/* Have to compute the address of the variable */\n\n\t\t\t\t\tvar = get_vreg_to_inst (cfg, sp [0]->dreg);\n\t\t\t\t\tif (!var)\n\t\t\t\t\t\tvar = mono_compile_create_var_for_vreg (cfg, m_class_get_byval_arg (klass), OP_LOCAL, sp [0]->dreg);\n\t\t\t\t\telse\n\t\t\t\t\t\tg_assert (var->klass == klass);\n\n\t\t\t\t\tEMIT_NEW_VARLOADA (cfg, ins, var, m_class_get_byval_arg (var->klass));\n\t\t\t\t\tsp [0] = ins;\n\t\t\t\t}\n\n\t\t\t\tif (il_op == MONO_CEE_LDFLDA) {\n\t\t\t\t\tif (sp [0]->type == STACK_OBJ) {\n\t\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, sp [0]->dreg, 0);\n\t\t\t\t\t\tMONO_EMIT_NEW_COND_EXC (cfg, EQ, \"NullReferenceException\");\n\t\t\t\t\t}\n\n\t\t\t\t\tdreg = alloc_ireg_mp (cfg);\n\n\t\t\t\t\tif (mini_is_gsharedvt_klass (klass)) {\n\t\t\t\t\t\tMonoInst *offset_ins;\n\n\t\t\t\t\t\toffset_ins = emit_get_gsharedvt_info (cfg, field, MONO_RGCTX_INFO_FIELD_OFFSET);\n\t\t\t\t\t\t/* The value is offset by 1 */\n\t\t\t\t\t\tEMIT_NEW_BIALU_IMM (cfg, ins, OP_PSUB_IMM, offset_ins->dreg, offset_ins->dreg, 1);\n\t\t\t\t\t\tEMIT_NEW_BIALU (cfg, ins, OP_PADD, dreg, sp [0]->dreg, offset_ins->dreg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tEMIT_NEW_BIALU_IMM (cfg, ins, OP_PADD_IMM, dreg, sp [0]->dreg, foffset);\n\t\t\t\t\t}\n\t\t\t\t\tins->klass = mono_class_from_mono_type_internal (field->type);\n\t\t\t\t\tins->type = STACK_MP;\n\t\t\t\t\t*sp++ = ins;\n\t\t\t\t} else {\n\t\t\t\t\tMonoInst *load;\n\n\t\t\t\t\tMONO_EMIT_NULL_CHECK (cfg, sp [0]->dreg, foffset > mono_target_pagesize ());\n\n#ifdef MONO_ARCH_SIMD_INTRINSICS\n\t\t\t\t\tif (sp [0]->opcode == OP_LDADDR && m_class_is_simd_type (klass) && cfg->opt & MONO_OPT_SIMD) {\n\t\t\t\t\t\tins = mono_emit_simd_field_load (cfg, field, sp [0]);\n\t\t\t\t\t\tif (ins) {\n\t\t\t\t\t\t\t*sp++ = ins;\n\t\t\t\t\t\t\tgoto field_access_end;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\n\t\t\t\t\tMonoInst *field_add_inst = sp [0];\n\t\t\t\t\tif (mini_is_gsharedvt_klass (klass)) {\n\t\t\t\t\t\tMonoInst *offset_ins;\n\n\t\t\t\t\t\toffset_ins = emit_get_gsharedvt_info (cfg, field, MONO_RGCTX_INFO_FIELD_OFFSET);\n\t\t\t\t\t\t/* The value is offset by 1 */\n\t\t\t\t\t\tEMIT_NEW_BIALU_IMM (cfg, ins, OP_PSUB_IMM, offset_ins->dreg, offset_ins->dreg, 1);\n\t\t\t\t\t\tEMIT_NEW_BIALU (cfg, field_add_inst, OP_PADD, alloc_ireg_mp (cfg), sp [0]->dreg, offset_ins->dreg);\n\t\t\t\t\t\tfoffset = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tload = mini_emit_memory_load (cfg, field->type, field_add_inst, foffset, ins_flag);\n\n\t\t\t\t\tif (sp [0]->opcode != OP_LDADDR)\n\t\t\t\t\t\tload->flags |= MONO_INST_FAULT;\n\t\t\t\t\t*sp++ = load;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (is_instance)\n\t\t\t\tgoto field_access_end;\n\n\t\t\t/* STATIC CASE */\n\t\t\tcontext_used = mini_class_check_context_used (cfg, klass);\n\n\t\t\tif (ftype->attrs & FIELD_ATTRIBUTE_LITERAL) {\n\t\t\t\tmono_error_set_field_missing (cfg->error, field->parent, field->name, NULL, \"Using static instructions with literal field\");\n\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t}\n\n\t\t\t/* The special_static_fields field is init'd in mono_class_vtable, so it needs\n\t\t\t * to be called here.\n\t\t\t */\n\t\t\tif (!context_used && !(cfg->opt & MONO_OPT_SHARED)) {\n\t\t\t\tmono_class_vtable_checked (cfg->domain, klass, cfg->error);\n\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t\tCHECK_TYPELOAD (klass);\n\t\t\t}\n\t\t\tmono_domain_lock (cfg->domain);\n\t\t\tif (cfg->domain->special_static_fields)\n\t\t\t\taddr = g_hash_table_lookup (cfg->domain->special_static_fields, field);\n\t\t\tmono_domain_unlock (cfg->domain);\n\n\t\t\tis_special_static = mono_class_field_is_special_static (field);\n\n\t\t\tif (is_special_static && ((gsize)addr & 0x80000000) == 0)\n\t\t\t\tthread_ins = mono_create_tls_get (cfg, TLS_KEY_THREAD);\n\t\t\telse\n\t\t\t\tthread_ins = NULL;\n\n\t\t\t/* Generate IR to compute the field address */\n\t\t\tif (is_special_static && ((gsize)addr & 0x80000000) == 0 && thread_ins && !(cfg->opt & MONO_OPT_SHARED) && !context_used) {\n\t\t\t\t/*\n\t\t\t\t * Fast access to TLS data\n\t\t\t\t * Inline version of get_thread_static_data () in\n\t\t\t\t * threads.c.\n\t\t\t\t */\n\t\t\t\tguint32 offset;\n\t\t\t\tint idx, static_data_reg, array_reg, dreg;\n\n\t\t\t\tif (context_used && cfg->gsharedvt && mini_is_gsharedvt_klass (klass))\n\t\t\t\t\tGSHAREDVT_FAILURE (il_op);\n\n\t\t\t\tstatic_data_reg = alloc_ireg (cfg);\n\t\t\t\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, static_data_reg, thread_ins->dreg, MONO_STRUCT_OFFSET (MonoInternalThread, static_data));\n\n\t\t\t\tif (cfg->compile_aot) {\n\t\t\t\t\tint offset_reg, offset2_reg, idx_reg;\n\n\t\t\t\t\t/* For TLS variables, this will return the TLS offset */\n\t\t\t\t\tEMIT_NEW_SFLDACONST (cfg, ins, field);\n\t\t\t\t\toffset_reg = ins->dreg;\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_IAND_IMM, offset_reg, offset_reg, 0x7fffffff);\n\t\t\t\t\tidx_reg = alloc_ireg (cfg);\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_IAND_IMM, idx_reg, offset_reg, 0x3f);\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_ISHL_IMM, idx_reg, idx_reg, TARGET_SIZEOF_VOID_P == 8 ? 3 : 2);\n\t\t\t\t\tMONO_EMIT_NEW_BIALU (cfg, OP_PADD, static_data_reg, static_data_reg, idx_reg);\n\t\t\t\t\tarray_reg = alloc_ireg (cfg);\n\t\t\t\t\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, array_reg, static_data_reg, 0);\n\t\t\t\t\toffset2_reg = alloc_ireg (cfg);\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_ISHR_UN_IMM, offset2_reg, offset_reg, 6);\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_IAND_IMM, offset2_reg, offset2_reg, 0x1ffffff);\n\t\t\t\t\tdreg = alloc_ireg (cfg);\n\t\t\t\t\tEMIT_NEW_BIALU (cfg, ins, OP_PADD, dreg, array_reg, offset2_reg);\n\t\t\t\t} else {\n\t\t\t\t\toffset = (gsize)addr & 0x7fffffff;\n\t\t\t\t\tidx = offset & 0x3f;\n\n\t\t\t\t\tarray_reg = alloc_ireg (cfg);\n\t\t\t\t\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, array_reg, static_data_reg, idx * TARGET_SIZEOF_VOID_P);\n\t\t\t\t\tdreg = alloc_ireg (cfg);\n\t\t\t\t\tEMIT_NEW_BIALU_IMM (cfg, ins, OP_ADD_IMM, dreg, array_reg, ((offset >> 6) & 0x1ffffff));\n\t\t\t\t}\n\t\t\t} else if ((cfg->opt & MONO_OPT_SHARED) ||\n\t\t\t\t\t(cfg->compile_aot && is_special_static) ||\n\t\t\t\t\t(context_used && is_special_static)) {\n\t\t\t\tMonoInst *iargs [2];\n\n\t\t\t\tg_assert (field->parent);\n\t\t\t\tEMIT_NEW_DOMAINCONST (cfg, iargs [0]);\n\t\t\t\tif (context_used) {\n\t\t\t\t\tiargs [1] = emit_get_rgctx_field (cfg, context_used,\n\t\t\t\t\t\tfield, MONO_RGCTX_INFO_CLASS_FIELD);\n\t\t\t\t} else {\n\t\t\t\t\tEMIT_NEW_FIELDCONST (cfg, iargs [1], field);\n\t\t\t\t}\n\t\t\t\tins = mono_emit_jit_icall (cfg, mono_class_static_field_address, iargs);\n\t\t\t} else if (context_used) {\n\t\t\t\tMonoInst *static_data;\n\n\t\t\t\t/*\n\t\t\t\tg_print (\"sharing static field access in %s.%s.%s - depth %d offset %d\\n\",\n\t\t\t\t\tmethod->klass->name_space, method->klass->name, method->name,\n\t\t\t\t\tdepth, field->offset);\n\t\t\t\t*/\n\n\t\t\t\tif (mono_class_needs_cctor_run (klass, method))\n\t\t\t\t\temit_class_init (cfg, klass);\n\n\t\t\t\t/*\n\t\t\t\t * The pointer we're computing here is\n\t\t\t\t *\n\t\t\t\t *   super_info.static_data + field->offset\n\t\t\t\t */\n\t\t\t\tstatic_data = mini_emit_get_rgctx_klass (cfg, context_used,\n\t\t\t\t\tklass, MONO_RGCTX_INFO_STATIC_DATA);\n\n\t\t\t\tif (mini_is_gsharedvt_klass (klass)) {\n\t\t\t\t\tMonoInst *offset_ins;\n\n\t\t\t\t\toffset_ins = emit_get_rgctx_field (cfg, context_used, field, MONO_RGCTX_INFO_FIELD_OFFSET);\n\t\t\t\t\t/* The value is offset by 1 */\n\t\t\t\t\tEMIT_NEW_BIALU_IMM (cfg, ins, OP_PSUB_IMM, offset_ins->dreg, offset_ins->dreg, 1);\n\t\t\t\t\tdreg = alloc_ireg_mp (cfg);\n\t\t\t\t\tEMIT_NEW_BIALU (cfg, ins, OP_PADD, dreg, static_data->dreg, offset_ins->dreg);\n\t\t\t\t} else if (field->offset == 0) {\n\t\t\t\t\tins = static_data;\n\t\t\t\t} else {\n\t\t\t\t\tint addr_reg = mono_alloc_preg (cfg);\n\t\t\t\t\tEMIT_NEW_BIALU_IMM (cfg, ins, OP_PADD_IMM, addr_reg, static_data->dreg, field->offset);\n\t\t\t\t}\n\t\t\t} else if ((cfg->opt & MONO_OPT_SHARED) || (cfg->compile_aot && addr)) {\n\t\t\t\tMonoInst *iargs [2];\n\n\t\t\t\tg_assert (field->parent);\n\t\t\t\tEMIT_NEW_DOMAINCONST (cfg, iargs [0]);\n\t\t\t\tEMIT_NEW_FIELDCONST (cfg, iargs [1], field);\n\t\t\t\tins = mono_emit_jit_icall (cfg, mono_class_static_field_address, iargs);\n\t\t\t} else {\n\t\t\t\tMonoVTable *vtable = NULL;\n\n\t\t\t\tif (!cfg->compile_aot)\n\t\t\t\t\tvtable = mono_class_vtable_checked (cfg->domain, klass, cfg->error);\n\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t\tCHECK_TYPELOAD (klass);\n\n\t\t\t\tif (!addr) {\n\t\t\t\t\tif (mini_field_access_needs_cctor_run (cfg, method, klass, vtable)) {\n\t\t\t\t\t\tif (!(g_slist_find (class_inits, klass))) {\n\t\t\t\t\t\t\temit_class_init (cfg, klass);\n\t\t\t\t\t\t\tif (cfg->verbose_level > 2)\n\t\t\t\t\t\t\t\tprintf (\"class %s.%s needs init call for %s\\n\", m_class_get_name_space (klass), m_class_get_name (klass), mono_field_get_name (field));\n\t\t\t\t\t\t\tclass_inits = g_slist_prepend (class_inits, klass);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cfg->run_cctors) {\n\t\t\t\t\t\t\t/* This makes so that inline cannot trigger */\n\t\t\t\t\t\t\t/* .cctors: too many apps depend on them */\n\t\t\t\t\t\t\t/* running with a specific order... */\n\t\t\t\t\t\t\tg_assert (vtable);\n\t\t\t\t\t\t\tif (!vtable->initialized && m_class_has_cctor (vtable->klass))\n\t\t\t\t\t\t\t\tINLINE_FAILURE (\"class init\");\n\t\t\t\t\t\t\tif (!mono_runtime_class_init_full (vtable, cfg->error)) {\n\t\t\t\t\t\t\t\tmono_cfg_set_exception (cfg, MONO_EXCEPTION_MONO_ERROR);\n\t\t\t\t\t\t\t\tgoto exception_exit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cfg->compile_aot)\n\t\t\t\t\t\tEMIT_NEW_SFLDACONST (cfg, ins, field);\n\t\t\t\t\telse {\n\t\t\t\t\t\tg_assert (vtable);\n\t\t\t\t\t\taddr = (char*)mono_vtable_get_static_field_data (vtable) + field->offset;\n\t\t\t\t\t\tg_assert (addr);\n\t\t\t\t\t\tEMIT_NEW_PCONST (cfg, ins, addr);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tMonoInst *iargs [1];\n\t\t\t\t\tEMIT_NEW_ICONST (cfg, iargs [0], GPOINTER_TO_UINT (addr));\n\t\t\t\t\tins = mono_emit_jit_icall (cfg, mono_get_special_static_data, iargs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Generate IR to do the actual load/store operation */\n\n\t\t\tif ((il_op == MONO_CEE_STFLD || il_op == MONO_CEE_STSFLD)) {\n\t\t\t\tif (ins_flag & MONO_INST_VOLATILE) {\n\t\t\t\t\t/* Volatile stores have release semantics, see 12.6.7 in Ecma 335 */\n\t\t\t\t\tmini_emit_memory_barrier (cfg, MONO_MEMORY_BARRIER_REL);\n\t\t\t\t} else if (!mini_debug_options.weak_memory_model && mini_type_is_reference (ftype)) {\n\t\t\t\t\tmini_emit_memory_barrier (cfg, MONO_MEMORY_BARRIER_REL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (il_op == MONO_CEE_LDSFLDA) {\n\t\t\t\tins->klass = mono_class_from_mono_type_internal (ftype);\n\t\t\t\tins->type = STACK_PTR;\n\t\t\t\t*sp++ = ins;\n\t\t\t} else if (il_op == MONO_CEE_STSFLD) {\n\t\t\t\tMonoInst *store;\n\n\t\t\t\tEMIT_NEW_STORE_MEMBASE_TYPE (cfg, store, ftype, ins->dreg, 0, store_val->dreg);\n\t\t\t\tstore->flags |= ins_flag;\n\t\t\t} else {\n\t\t\t\tgboolean is_const = FALSE;\n\t\t\t\tMonoVTable *vtable = NULL;\n\t\t\t\tgpointer addr = NULL;\n\n\t\t\t\tif (!context_used) {\n\t\t\t\t\tvtable = mono_class_vtable_checked (cfg->domain, klass, cfg->error);\n\t\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t\t\tCHECK_TYPELOAD (klass);\n\t\t\t\t}\n\t\t\t\tif ((ftype->attrs & FIELD_ATTRIBUTE_INIT_ONLY) && (((addr = mono_aot_readonly_field_override (field)) != NULL) ||\n\t\t\t\t\t\t(!context_used && !((cfg->opt & MONO_OPT_SHARED) || cfg->compile_aot) && vtable->initialized))) {\n\t\t\t\t\tint ro_type = ftype->type;\n\t\t\t\t\tif (!addr)\n\t\t\t\t\t\taddr = (char*)mono_vtable_get_static_field_data (vtable) + field->offset;\n\t\t\t\t\tif (ro_type == MONO_TYPE_VALUETYPE && m_class_is_enumtype (ftype->data.klass)) {\n\t\t\t\t\t\tro_type = mono_class_enum_basetype_internal (ftype->data.klass)->type;\n\t\t\t\t\t}\n\n\t\t\t\t\tGSHAREDVT_FAILURE (il_op);\n\n\t\t\t\t\t/* printf (\"RO-FIELD %s.%s:%s\\n\", klass->name_space, klass->name, mono_field_get_name (field));*/\n\t\t\t\t\tis_const = TRUE;\n\t\t\t\t\tswitch (ro_type) {\n\t\t\t\t\tcase MONO_TYPE_BOOLEAN:\n\t\t\t\t\tcase MONO_TYPE_U1:\n\t\t\t\t\t\tEMIT_NEW_ICONST (cfg, *sp, *((guint8 *)addr));\n\t\t\t\t\t\tsp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MONO_TYPE_I1:\n\t\t\t\t\t\tEMIT_NEW_ICONST (cfg, *sp, *((gint8 *)addr));\n\t\t\t\t\t\tsp++;\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\n\t\t\t\t\tcase MONO_TYPE_CHAR:\n\t\t\t\t\tcase MONO_TYPE_U2:\n\t\t\t\t\t\tEMIT_NEW_ICONST (cfg, *sp, *((guint16 *)addr));\n\t\t\t\t\t\tsp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MONO_TYPE_I2:\n\t\t\t\t\t\tEMIT_NEW_ICONST (cfg, *sp, *((gint16 *)addr));\n\t\t\t\t\t\tsp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MONO_TYPE_I4:\n\t\t\t\t\t\tEMIT_NEW_ICONST (cfg, *sp, *((gint32 *)addr));\n\t\t\t\t\t\tsp++;\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\n\t\t\t\t\tcase MONO_TYPE_U4:\n\t\t\t\t\t\tEMIT_NEW_ICONST (cfg, *sp, *((guint32 *)addr));\n\t\t\t\t\t\tsp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MONO_TYPE_I:\n\t\t\t\t\tcase MONO_TYPE_U:\n\t\t\t\t\tcase MONO_TYPE_PTR:\n\t\t\t\t\tcase MONO_TYPE_FNPTR:\n\t\t\t\t\t\tEMIT_NEW_PCONST (cfg, *sp, *((gpointer *)addr));\n\t\t\t\t\t\tmini_type_to_eval_stack_type ((cfg), field->type, *sp);\n\t\t\t\t\t\tsp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MONO_TYPE_STRING:\n\t\t\t\t\tcase MONO_TYPE_OBJECT:\n\t\t\t\t\tcase MONO_TYPE_CLASS:\n\t\t\t\t\tcase MONO_TYPE_SZARRAY:\n\t\t\t\t\tcase MONO_TYPE_ARRAY:\n\t\t\t\t\t\tif (!mono_gc_is_moving ()) {\n\t\t\t\t\t\t\tEMIT_NEW_PCONST (cfg, *sp, *((gpointer *)addr));\n\t\t\t\t\t\t\tmini_type_to_eval_stack_type ((cfg), field->type, *sp);\n\t\t\t\t\t\t\tsp++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tis_const = FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MONO_TYPE_I8:\n\t\t\t\t\tcase MONO_TYPE_U8:\n\t\t\t\t\t\tEMIT_NEW_I8CONST (cfg, *sp, *((gint64 *)addr));\n\t\t\t\t\t\tsp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MONO_TYPE_R4:\n\t\t\t\t\tcase MONO_TYPE_R8:\n\t\t\t\t\tcase MONO_TYPE_VALUETYPE:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tis_const = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!is_const) {\n\t\t\t\t\tMonoInst *load;\n\n\t\t\t\t\tEMIT_NEW_LOAD_MEMBASE_TYPE (cfg, load, field->type, ins->dreg, 0);\n\t\t\t\t\tload->flags |= ins_flag;\n\t\t\t\t\t*sp++ = load;\n\t\t\t\t}\n\t\t\t}\n\nfield_access_end:\n\t\t\tif ((il_op == MONO_CEE_LDFLD || il_op == MONO_CEE_LDSFLD) && (ins_flag & MONO_INST_VOLATILE)) {\n\t\t\t\t/* Volatile loads have acquire semantics, see 12.6.7 in Ecma 335 */\n\t\t\t\tmini_emit_memory_barrier (cfg, MONO_MEMORY_BARRIER_ACQ);\n\t\t\t}\n\n\t\t\tins_flag = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_STOBJ:\n\t\t\tsp -= 2;\n\t\t\tklass = mini_get_class (method, token, generic_context);\n\t\t\tCHECK_TYPELOAD (klass);\n\n\t\t\t/* FIXME: should check item at sp [1] is compatible with the type of the store. */\n\t\t\tmini_emit_memory_store (cfg, m_class_get_byval_arg (klass), sp [0], sp [1], ins_flag);\n\t\t\tins_flag = 0;\n\t\t\tinline_costs += 1;\n\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Array opcodes\n\t\t\t */\n\t\tcase MONO_CEE_NEWARR: {\n\t\t\tMonoInst *len_ins;\n\t\t\tconst char *data_ptr;\n\t\t\tint data_size = 0;\n\t\t\tguint32 field_token;\n\n\t\t\t--sp;\n\n\t\t\tklass = mini_get_class (method, token, generic_context);\n\t\t\tCHECK_TYPELOAD (klass);\n\t\t\tif (m_class_get_byval_arg (klass)->type == MONO_TYPE_VOID)\n\t\t\t\tUNVERIFIED;\n\n\t\t\tcontext_used = mini_class_check_context_used (cfg, klass);\n\n\t\t\tif (sp [0]->type == STACK_I8 || (TARGET_SIZEOF_VOID_P == 8 && sp [0]->type == STACK_PTR)) {\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_LCONV_TO_OVF_U4);\n\t\t\t\tins->sreg1 = sp [0]->dreg;\n\t\t\t\tins->type = STACK_I4;\n\t\t\t\tins->dreg = alloc_ireg (cfg);\n\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\t*sp = mono_decompose_opcode (cfg, ins);\n\t\t\t}\n\n\t\t\tif (context_used) {\n\t\t\t\tMonoInst *args [3];\n\t\t\t\tMonoClass *array_class = mono_class_create_array (klass, 1);\n\t\t\t\tMonoMethod *managed_alloc = mono_gc_get_managed_array_allocator (array_class);\n\n\t\t\t\t/* FIXME: Use OP_NEWARR and decompose later to help abcrem */\n\n\t\t\t\t/* vtable */\n\t\t\t\targs [0] = mini_emit_get_rgctx_klass (cfg, context_used,\n\t\t\t\t\tarray_class, MONO_RGCTX_INFO_VTABLE);\n\t\t\t\t/* array len */\n\t\t\t\targs [1] = sp [0];\n\n\t\t\t\tif (managed_alloc)\n\t\t\t\t\tins = mono_emit_method_call (cfg, managed_alloc, args, NULL);\n\t\t\t\telse\n\t\t\t\t\tins = mono_emit_jit_icall (cfg, ves_icall_array_new_specific, args);\n\t\t\t} else {\n\t\t\t\tif (cfg->opt & MONO_OPT_SHARED) {\n\t\t\t\t\t/* Decompose now to avoid problems with references to the domainvar */\n\t\t\t\t\tMonoInst *iargs [3];\n\n\t\t\t\t\tEMIT_NEW_DOMAINCONST (cfg, iargs [0]);\n\t\t\t\t\tEMIT_NEW_CLASSCONST (cfg, iargs [1], klass);\n\t\t\t\t\tiargs [2] = sp [0];\n\n\t\t\t\t\tins = mono_emit_jit_icall (cfg, ves_icall_array_new, iargs);\n\t\t\t\t} else {\n\t\t\t\t\t/* Decompose later since it is needed by abcrem */\n\t\t\t\t\tMonoClass *array_type = mono_class_create_array (klass, 1);\n\t\t\t\t\tmono_class_vtable_checked (cfg->domain, array_type, cfg->error);\n\t\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t\t\tCHECK_TYPELOAD (array_type);\n\n\t\t\t\t\tMONO_INST_NEW (cfg, ins, OP_NEWARR);\n\t\t\t\t\tins->dreg = alloc_ireg_ref (cfg);\n\t\t\t\t\tins->sreg1 = sp [0]->dreg;\n\t\t\t\t\tins->inst_newa_class = klass;\n\t\t\t\t\tins->type = STACK_OBJ;\n\t\t\t\t\tins->klass = array_type;\n\t\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\t\tcfg->flags |= MONO_CFG_NEEDS_DECOMPOSE;\n\t\t\t\t\tcfg->cbb->needs_decompose = TRUE;\n\n\t\t\t\t\t/* Needed so mono_emit_load_get_addr () gets called */\n\t\t\t\t\tmono_get_got_var (cfg);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlen_ins = sp [0];\n\t\t\tip += 5;\n\t\t\t*sp++ = ins;\n\t\t\tinline_costs += 1;\n\n\t\t\t/* \n\t\t\t * we inline/optimize the initialization sequence if possible.\n\t\t\t * we should also allocate the array as not cleared, since we spend as much time clearing to 0 as initializing\n\t\t\t * for small sizes open code the memcpy\n\t\t\t * ensure the rva field is big enough\n\t\t\t */\n\t\t\tif ((cfg->opt & MONO_OPT_INTRINS) && next_ip < end\n\t\t\t\t\t&& ip_in_bb (cfg, cfg->cbb, next_ip)\n\t\t\t\t\t&& (len_ins->opcode == OP_ICONST)\n\t\t\t\t\t&& (data_ptr = initialize_array_data (cfg, method,\n\t\t\t\t\t\tcfg->compile_aot, next_ip, end, klass,\n\t\t\t\t\t\tlen_ins->inst_c0, &data_size, &field_token,\n\t\t\t\t\t\t&il_op, &next_ip))) {\n\t\t\t\tMonoMethod *memcpy_method = mini_get_memcpy_method ();\n\t\t\t\tMonoInst *iargs [3];\n\t\t\t\tint add_reg = alloc_ireg_mp (cfg);\n\n\t\t\t\tEMIT_NEW_BIALU_IMM (cfg, iargs [0], OP_PADD_IMM, add_reg, ins->dreg, MONO_STRUCT_OFFSET (MonoArray, vector));\n\t\t\t\tif (cfg->compile_aot) {\n\t\t\t\t\tEMIT_NEW_AOTCONST_TOKEN (cfg, iargs [1], MONO_PATCH_INFO_RVA, m_class_get_image (method->klass), GPOINTER_TO_UINT(field_token), STACK_PTR, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tEMIT_NEW_PCONST (cfg, iargs [1], (char*)data_ptr);\n\t\t\t\t}\n\t\t\t\tEMIT_NEW_ICONST (cfg, iargs [2], data_size);\n\t\t\t\tmono_emit_method_call (cfg, memcpy_method, iargs, NULL);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_LDLEN:\n\t\t\t--sp;\n\t\t\tif (sp [0]->type != STACK_OBJ)\n\t\t\t\tUNVERIFIED;\n\n\t\t\tMONO_INST_NEW (cfg, ins, OP_LDLEN);\n\t\t\tins->dreg = alloc_preg (cfg);\n\t\t\tins->sreg1 = sp [0]->dreg;\n\t\t\tins->inst_imm = MONO_STRUCT_OFFSET (MonoArray, max_length);\n\t\t\tins->type = STACK_I4;\n\t\t\t/* This flag will be inherited by the decomposition */\n\t\t\tins->flags |= MONO_INST_FAULT | MONO_INST_INVARIANT_LOAD;\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\tcfg->flags |= MONO_CFG_NEEDS_DECOMPOSE;\n\t\t\tcfg->cbb->needs_decompose = TRUE;\n\t\t\tMONO_EMIT_NEW_UNALU (cfg, OP_NOT_NULL, -1, sp [0]->dreg);\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\tcase MONO_CEE_LDELEMA:\n\t\t\tsp -= 2;\n\t\t\tif (sp [0]->type != STACK_OBJ)\n\t\t\t\tUNVERIFIED;\n\n\t\t\tcfg->flags |= MONO_CFG_HAS_LDELEMA;\n\n\t\t\tklass = mini_get_class (method, token, generic_context);\n\t\t\tCHECK_TYPELOAD (klass);\n\t\t\t/* we need to make sure that this array is exactly the type it needs\n\t\t\t * to be for correctness. the wrappers are lax with their usage\n\t\t\t * so we need to ignore them here\n\t\t\t */\n\t\t\tif (!m_class_is_valuetype (klass) && method->wrapper_type == MONO_WRAPPER_NONE && !readonly) {\n\t\t\t\tMonoClass *array_class = mono_class_create_array (klass, 1);\n\t\t\t\tmini_emit_check_array_type (cfg, sp [0], array_class);\n\t\t\t\tCHECK_TYPELOAD (array_class);\n\t\t\t}\n\n\t\t\treadonly = FALSE;\n\t\t\tins = mini_emit_ldelema_1_ins (cfg, klass, sp [0], sp [1], TRUE);\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\tcase MONO_CEE_LDELEM:\n\t\tcase MONO_CEE_LDELEM_I1:\n\t\tcase MONO_CEE_LDELEM_U1:\n\t\tcase MONO_CEE_LDELEM_I2:\n\t\tcase MONO_CEE_LDELEM_U2:\n\t\tcase MONO_CEE_LDELEM_I4:\n\t\tcase MONO_CEE_LDELEM_U4:\n\t\tcase MONO_CEE_LDELEM_I8:\n\t\tcase MONO_CEE_LDELEM_I:\n\t\tcase MONO_CEE_LDELEM_R4:\n\t\tcase MONO_CEE_LDELEM_R8:\n\t\tcase MONO_CEE_LDELEM_REF: {\n\t\t\tMonoInst *addr;\n\n\t\t\tsp -= 2;\n\n\t\t\tif (il_op == MONO_CEE_LDELEM) {\n\t\t\t\tklass = mini_get_class (method, token, generic_context);\n\t\t\t\tCHECK_TYPELOAD (klass);\n\t\t\t\tmono_class_init_internal (klass);\n\t\t\t}\n\t\t\telse\n\t\t\t\tklass = array_access_to_klass (il_op);\n\n\t\t\tif (sp [0]->type != STACK_OBJ)\n\t\t\t\tUNVERIFIED;\n\n\t\t\tcfg->flags |= MONO_CFG_HAS_LDELEMA;\n\n\t\t\tif (mini_is_gsharedvt_variable_klass (klass)) {\n\t\t\t\t// FIXME-VT: OP_ICONST optimization\n\t\t\t\taddr = mini_emit_ldelema_1_ins (cfg, klass, sp [0], sp [1], TRUE);\n\t\t\t\tEMIT_NEW_LOAD_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (klass), addr->dreg, 0);\n\t\t\t\tins->opcode = OP_LOADV_MEMBASE;\n\t\t\t} else if (sp [1]->opcode == OP_ICONST) {\n\t\t\t\tint array_reg = sp [0]->dreg;\n\t\t\t\tint index_reg = sp [1]->dreg;\n\t\t\t\tint offset = (mono_class_array_element_size (klass) * sp [1]->inst_c0) + MONO_STRUCT_OFFSET (MonoArray, vector);\n\n\t\t\t\tif (SIZEOF_REGISTER == 8 && COMPILE_LLVM (cfg))\n\t\t\t\t\tMONO_EMIT_NEW_UNALU (cfg, OP_ZEXT_I4, index_reg, index_reg);\n\n\t\t\t\tMONO_EMIT_BOUNDS_CHECK (cfg, array_reg, MonoArray, max_length, index_reg);\n\t\t\t\tEMIT_NEW_LOAD_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (klass), array_reg, offset);\n\t\t\t} else {\n\t\t\t\taddr = mini_emit_ldelema_1_ins (cfg, klass, sp [0], sp [1], TRUE);\n\t\t\t\tEMIT_NEW_LOAD_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (klass), addr->dreg, 0);\n\t\t\t}\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_STELEM_I:\n\t\tcase MONO_CEE_STELEM_I1:\n\t\tcase MONO_CEE_STELEM_I2:\n\t\tcase MONO_CEE_STELEM_I4:\n\t\tcase MONO_CEE_STELEM_I8:\n\t\tcase MONO_CEE_STELEM_R4:\n\t\tcase MONO_CEE_STELEM_R8:\n\t\tcase MONO_CEE_STELEM_REF:\n\t\tcase MONO_CEE_STELEM: {\n\t\t\tsp -= 3;\n\n\t\t\tcfg->flags |= MONO_CFG_HAS_LDELEMA;\n\n\t\t\tif (il_op == MONO_CEE_STELEM) {\n\t\t\t\tklass = mini_get_class (method, token, generic_context);\n\t\t\t\tCHECK_TYPELOAD (klass);\n\t\t\t\tmono_class_init_internal (klass);\n\t\t\t}\n\t\t\telse\n\t\t\t\tklass = array_access_to_klass (il_op);\n\n\t\t\tif (sp [0]->type != STACK_OBJ)\n\t\t\t\tUNVERIFIED;\n\n\t\t\tsp [2] = convert_value (cfg, m_class_get_byval_arg (klass), sp [2]);\n\t\t\tmini_emit_array_store (cfg, klass, sp, TRUE);\n\n\t\t\tinline_costs += 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_CKFINITE: {\n\t\t\t--sp;\n\n\t\t\tif (cfg->llvm_only) {\n\t\t\t\tMonoInst *iargs [1];\n\n\t\t\t\tiargs [0] = sp [0];\n\t\t\t\t*sp++ = mono_emit_jit_icall (cfg, mono_ckfinite, iargs);\n\t\t\t} else  {\n\t\t\t\tsp [0] = convert_value (cfg, m_class_get_byval_arg (mono_defaults.double_class), sp [0]);\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_CKFINITE);\n\t\t\t\tins->sreg1 = sp [0]->dreg;\n\t\t\t\tins->dreg = alloc_freg (cfg);\n\t\t\t\tins->type = STACK_R8;\n\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\n\t\t\t\t*sp++ = mono_decompose_opcode (cfg, ins);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_REFANYVAL: {\n\t\t\tMonoInst *src_var, *src;\n\n\t\t\tint klass_reg = alloc_preg (cfg);\n\t\t\tint dreg = alloc_preg (cfg);\n\n\t\t\tGSHAREDVT_FAILURE (il_op);\n\n\t\t\tMONO_INST_NEW (cfg, ins, il_op);\n\t\t\t--sp;\n\t\t\tklass = mini_get_class (method, token, generic_context);\n\t\t\tCHECK_TYPELOAD (klass);\n\n\t\t\tcontext_used = mini_class_check_context_used (cfg, klass);\n\n\t\t\t// FIXME:\n\t\t\tsrc_var = get_vreg_to_inst (cfg, sp [0]->dreg);\n\t\t\tif (!src_var)\n\t\t\t\tsrc_var = mono_compile_create_var_for_vreg (cfg, m_class_get_byval_arg (mono_defaults.typed_reference_class), OP_LOCAL, sp [0]->dreg);\n\t\t\tEMIT_NEW_VARLOADA (cfg, src, src_var, src_var->inst_vtype);\n\t\t\tMONO_EMIT_NEW_LOAD_MEMBASE (cfg, klass_reg, src->dreg, MONO_STRUCT_OFFSET (MonoTypedRef, klass));\n\n\t\t\tif (context_used) {\n\t\t\t\tMonoInst *klass_ins;\n\n\t\t\t\tklass_ins = mini_emit_get_rgctx_klass (cfg, context_used,\n\t\t\t\t\t\tklass, MONO_RGCTX_INFO_KLASS);\n\n\t\t\t\t// FIXME:\n\t\t\t\tMONO_EMIT_NEW_BIALU (cfg, OP_COMPARE, -1, klass_reg, klass_ins->dreg);\n\t\t\t\tMONO_EMIT_NEW_COND_EXC (cfg, NE_UN, \"InvalidCastException\");\n\t\t\t} else {\n\t\t\t\tmini_emit_class_check (cfg, klass_reg, klass);\n\t\t\t}\n\t\t\tEMIT_NEW_LOAD_MEMBASE (cfg, ins, OP_LOAD_MEMBASE, dreg, src->dreg, MONO_STRUCT_OFFSET (MonoTypedRef, value));\n\t\t\tins->type = STACK_MP;\n\t\t\tins->klass = klass;\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_MKREFANY: {\n\t\t\tMonoInst *loc, *addr;\n\n\t\t\tGSHAREDVT_FAILURE (il_op);\n\n\t\t\tMONO_INST_NEW (cfg, ins, il_op);\n\t\t\t--sp;\n\t\t\tklass = mini_get_class (method, token, generic_context);\n\t\t\tCHECK_TYPELOAD (klass);\n\n\t\t\tcontext_used = mini_class_check_context_used (cfg, klass);\n\n\t\t\tloc = mono_compile_create_var (cfg, m_class_get_byval_arg (mono_defaults.typed_reference_class), OP_LOCAL);\n\t\t\tEMIT_NEW_TEMPLOADA (cfg, addr, loc->inst_c0);\n\n\t\t\tMonoInst *const_ins = mini_emit_get_rgctx_klass (cfg, context_used, klass, MONO_RGCTX_INFO_KLASS);\n\t\t\tint type_reg = alloc_preg (cfg);\n\n\t\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREP_MEMBASE_REG, addr->dreg, MONO_STRUCT_OFFSET (MonoTypedRef, klass), const_ins->dreg);\n\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_ADD_IMM, type_reg, const_ins->dreg, m_class_offsetof_byval_arg ());\n\t\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREP_MEMBASE_REG, addr->dreg, MONO_STRUCT_OFFSET (MonoTypedRef, type), type_reg);\n\n\t\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREP_MEMBASE_REG, addr->dreg, MONO_STRUCT_OFFSET (MonoTypedRef, value), sp [0]->dreg);\n\n\t\t\tEMIT_NEW_TEMPLOAD (cfg, ins, loc->inst_c0);\n\t\t\tins->type = STACK_VTYPE;\n\t\t\tins->klass = mono_defaults.typed_reference_class;\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_LDTOKEN: {\n\t\t\tgpointer handle;\n\t\t\tMonoClass *handle_class;\n\n\t\t\tif (method->wrapper_type == MONO_WRAPPER_DYNAMIC_METHOD ||\n\t\t\t\t\tmethod->wrapper_type == MONO_WRAPPER_SYNCHRONIZED) {\n\t\t\t\thandle = mono_method_get_wrapper_data (method, n);\n\t\t\t\thandle_class = (MonoClass *)mono_method_get_wrapper_data (method, n + 1);\n\t\t\t\tif (handle_class == mono_defaults.typehandle_class)\n\t\t\t\t\thandle = m_class_get_byval_arg ((MonoClass*)handle);\n\t\t\t}\n\t\t\telse {\n\t\t\t\thandle = mono_ldtoken_checked (image, n, &handle_class, generic_context, cfg->error);\n\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t}\n\t\t\tif (!handle)\n\t\t\t\tLOAD_ERROR;\n\t\t\tmono_class_init_internal (handle_class);\n\t\t\tif (cfg->gshared) {\n\t\t\t\tif (mono_metadata_token_table (n) == MONO_TABLE_TYPEDEF ||\n\t\t\t\t\t\tmono_metadata_token_table (n) == MONO_TABLE_TYPEREF) {\n\t\t\t\t\t/* This case handles ldtoken\n\t\t\t\t\t   of an open type, like for\n\t\t\t\t\t   typeof(Gen<>). */\n\t\t\t\t\tcontext_used = 0;\n\t\t\t\t} else if (handle_class == mono_defaults.typehandle_class) {\n\t\t\t\t\tcontext_used = mini_class_check_context_used (cfg, mono_class_from_mono_type_internal ((MonoType *)handle));\n\t\t\t\t} else if (handle_class == mono_defaults.fieldhandle_class)\n\t\t\t\t\tcontext_used = mini_class_check_context_used (cfg, ((MonoClassField*)handle)->parent);\n\t\t\t\telse if (handle_class == mono_defaults.methodhandle_class)\n\t\t\t\t\tcontext_used = mini_method_check_context_used (cfg, (MonoMethod *)handle);\n\t\t\t\telse\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\n\t\t\tif ((cfg->opt & MONO_OPT_SHARED) &&\n\t\t\t\t\tmethod->wrapper_type != MONO_WRAPPER_DYNAMIC_METHOD &&\n\t\t\t\t\tmethod->wrapper_type != MONO_WRAPPER_SYNCHRONIZED) {\n\t\t\t\tMonoInst *addr, *vtvar, *iargs [3];\n\t\t\t\tint method_context_used;\n\n\t\t\t\tmethod_context_used = mini_method_check_context_used (cfg, method);\n\n\t\t\t\tvtvar = mono_compile_create_var (cfg, m_class_get_byval_arg (handle_class), OP_LOCAL); \n\n\t\t\t\tEMIT_NEW_IMAGECONST (cfg, iargs [0], image);\n\t\t\t\tEMIT_NEW_ICONST (cfg, iargs [1], n);\n\t\t\t\tif (method_context_used) {\n\t\t\t\t\tiargs [2] = emit_get_rgctx_method (cfg, method_context_used,\n\t\t\t\t\t\tmethod, MONO_RGCTX_INFO_METHOD);\n\t\t\t\t\tins = mono_emit_jit_icall (cfg, mono_ldtoken_wrapper_generic_shared, iargs);\n\t\t\t\t} else {\n\t\t\t\t\tEMIT_NEW_PCONST (cfg, iargs [2], generic_context);\n\t\t\t\t\tins = mono_emit_jit_icall (cfg, mono_ldtoken_wrapper, iargs);\n\t\t\t\t}\n\t\t\t\tEMIT_NEW_TEMPLOADA (cfg, addr, vtvar->inst_c0);\n\n\t\t\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, addr->dreg, 0, ins->dreg);\n\n\t\t\t\tEMIT_NEW_TEMPLOAD (cfg, ins, vtvar->inst_c0);\n\t\t\t} else {\n\t\t\t\tif ((next_ip + 4 < end) && ip_in_bb (cfg, cfg->cbb, next_ip) &&\n\t\t\t\t\t((next_ip [0] == CEE_CALL) || (next_ip [0] == CEE_CALLVIRT)) &&\n\t\t\t\t\t(cmethod = mini_get_method (cfg, method, read32 (next_ip + 1), NULL, generic_context)) &&\n\t\t\t\t\t(cmethod->klass == mono_defaults.systemtype_class) &&\n\t\t\t\t\t(strcmp (cmethod->name, \"GetTypeFromHandle\") == 0)) {\n\t\t\t\t\tMonoClass *tclass = mono_class_from_mono_type_internal ((MonoType *)handle);\n\n\t\t\t\t\tmono_class_init_internal (tclass);\n\t\t\t\t\tif (context_used) {\n\t\t\t\t\t\tins = mini_emit_get_rgctx_klass (cfg, context_used,\n\t\t\t\t\t\t\ttclass, MONO_RGCTX_INFO_REFLECTION_TYPE);\n\t\t\t\t\t} else if (cfg->compile_aot) {\n\t\t\t\t\t\tif (method->wrapper_type) {\n\t\t\t\t\t\t\terror_init (error); //got to do it since there are multiple conditionals below\n\t\t\t\t\t\t\tif (mono_class_get_checked (m_class_get_image (tclass), m_class_get_type_token (tclass), error) == tclass && !generic_context) {\n\t\t\t\t\t\t\t\t/* Special case for static synchronized wrappers */\n\t\t\t\t\t\t\t\tEMIT_NEW_TYPE_FROM_HANDLE_CONST (cfg, ins, m_class_get_image (tclass), m_class_get_type_token (tclass), generic_context);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmono_error_cleanup (error); /* FIXME don't swallow the error */\n\t\t\t\t\t\t\t\t/* FIXME: n is not a normal token */\n\t\t\t\t\t\t\t\tDISABLE_AOT (cfg);\n\t\t\t\t\t\t\t\tEMIT_NEW_PCONST (cfg, ins, NULL);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tEMIT_NEW_TYPE_FROM_HANDLE_CONST (cfg, ins, image, n, generic_context);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tMonoReflectionType *rt = mono_type_get_object_checked (cfg->domain, (MonoType *)handle, cfg->error);\n\t\t\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t\t\t\tEMIT_NEW_PCONST (cfg, ins, rt);\n\t\t\t\t\t}\n\t\t\t\t\tins->type = STACK_OBJ;\n\t\t\t\t\tins->klass = cmethod->klass;\n\t\t\t\t\til_op = (MonoOpcodeEnum)next_ip [0];\n\t\t\t\t\tnext_ip += 5;\n\t\t\t\t} else {\n\t\t\t\t\tMonoInst *addr, *vtvar;\n\n\t\t\t\t\tvtvar = mono_compile_create_var (cfg, m_class_get_byval_arg (handle_class), OP_LOCAL);\n\n\t\t\t\t\tif (context_used) {\n\t\t\t\t\t\tif (handle_class == mono_defaults.typehandle_class) {\n\t\t\t\t\t\t\tins = mini_emit_get_rgctx_klass (cfg, context_used,\n\t\t\t\t\t\t\t\t\tmono_class_from_mono_type_internal ((MonoType *)handle),\n\t\t\t\t\t\t\t\t\tMONO_RGCTX_INFO_TYPE);\n\t\t\t\t\t\t} else if (handle_class == mono_defaults.methodhandle_class) {\n\t\t\t\t\t\t\tins = emit_get_rgctx_method (cfg, context_used,\n\t\t\t\t\t\t\t\t\t(MonoMethod *)handle, MONO_RGCTX_INFO_METHOD);\n\t\t\t\t\t\t} else if (handle_class == mono_defaults.fieldhandle_class) {\n\t\t\t\t\t\t\tins = emit_get_rgctx_field (cfg, context_used,\n\t\t\t\t\t\t\t\t\t(MonoClassField *)handle, MONO_RGCTX_INFO_CLASS_FIELD);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (cfg->compile_aot) {\n\t\t\t\t\t\tEMIT_NEW_LDTOKENCONST (cfg, ins, image, n, generic_context);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tEMIT_NEW_PCONST (cfg, ins, handle);\n\t\t\t\t\t}\n\t\t\t\t\tEMIT_NEW_TEMPLOADA (cfg, addr, vtvar->inst_c0);\n\t\t\t\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, addr->dreg, 0, ins->dreg);\n\t\t\t\t\tEMIT_NEW_TEMPLOAD (cfg, ins, vtvar->inst_c0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_THROW:\n\t\t\tif (sp [-1]->type != STACK_OBJ)\n\t\t\t\tUNVERIFIED;\n\n\t\t\tMONO_INST_NEW (cfg, ins, OP_THROW);\n\t\t\t--sp;\n\t\t\tins->sreg1 = sp [0]->dreg;\n\t\t\tcfg->cbb->out_of_line = TRUE;\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\tMONO_INST_NEW (cfg, ins, OP_NOT_REACHED);\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\tsp = stack_start;\n\t\t\t\n\t\t\tlink_bblock (cfg, cfg->cbb, end_bblock);\n\t\t\tstart_new_bblock = 1;\n\t\t\t/* This can complicate code generation for llvm since the return value might not be defined */\n\t\t\tif (COMPILE_LLVM (cfg))\n\t\t\t\tINLINE_FAILURE (\"throw\");\n\t\t\tbreak;\n\t\tcase MONO_CEE_ENDFINALLY:\n\t\t\tif (!ip_in_finally_clause (cfg, ip - header->code))\n\t\t\t\tUNVERIFIED;\n\t\t\t/* mono_save_seq_point_info () depends on this */\n\t\t\tif (sp != stack_start)\n\t\t\t\temit_seq_point (cfg, method, ip, FALSE, FALSE);\n\t\t\tMONO_INST_NEW (cfg, ins, OP_ENDFINALLY);\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\tstart_new_bblock = 1;\n\n\t\t\t/*\n\t\t\t * Control will leave the method so empty the stack, otherwise\n\t\t\t * the next basic block will start with a nonempty stack.\n\t\t\t */\n\t\t\twhile (sp != stack_start) {\n\t\t\t\tsp--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_CEE_LEAVE:\n\t\tcase MONO_CEE_LEAVE_S: {\n\t\t\tGList *handlers;\n\n\t\t\t/* empty the stack */\n\t\t\tg_assert (sp >= stack_start);\n\t\t\tsp = stack_start;\n\n\t\t\t/* \n\t\t\t * If this leave statement is in a catch block, check for a\n\t\t\t * pending exception, and rethrow it if necessary.\n\t\t\t * We avoid doing this in runtime invoke wrappers, since those are called\n\t\t\t * by native code which excepts the wrapper to catch all exceptions.\n\t\t\t */\n\t\t\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\t\t\tMonoExceptionClause *clause = &header->clauses [i];\n\n\t\t\t\t/* \n\t\t\t\t * Use <= in the final comparison to handle clauses with multiple\n\t\t\t\t * leave statements, like in bug #78024.\n\t\t\t\t * The ordering of the exception clauses guarantees that we find the\n\t\t\t\t * innermost clause.\n\t\t\t\t */\n\t\t\t\tif (MONO_OFFSET_IN_HANDLER (clause, ip - header->code) && (clause->flags == MONO_EXCEPTION_CLAUSE_NONE) && (ip - header->code + ((il_op == MONO_CEE_LEAVE) ? 5 : 2)) <= (clause->handler_offset + clause->handler_len) && method->wrapper_type != MONO_WRAPPER_RUNTIME_INVOKE) {\n\t\t\t\t\tMonoInst *exc_ins;\n\t\t\t\t\tMonoBasicBlock *dont_throw;\n\n\t\t\t\t\t/*\n\t\t\t\t\t  MonoInst *load;\n\n\t\t\t\t\t  NEW_TEMPLOAD (cfg, load, mono_find_exvar_for_offset (cfg, clause->handler_offset)->inst_c0);\n\t\t\t\t\t*/\n\n\t\t\t\t\texc_ins = mono_emit_jit_icall (cfg, mono_thread_get_undeniable_exception, NULL);\n\n\t\t\t\t\tNEW_BBLOCK (cfg, dont_throw);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Currently, we always rethrow the abort exception, despite the \n\t\t\t\t\t * fact that this is not correct. See thread6.cs for an example. \n\t\t\t\t\t * But propagating the abort exception is more important than \n\t\t\t\t\t * getting the semantics right.\n\t\t\t\t\t */\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, exc_ins->dreg, 0);\n\t\t\t\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_PBEQ, dont_throw);\n\t\t\t\t\tMONO_EMIT_NEW_UNALU (cfg, OP_THROW, -1, exc_ins->dreg);\n\n\t\t\t\t\tMONO_START_BB (cfg, dont_throw);\n\t\t\t\t}\n\t\t\t}\n\n#ifdef ENABLE_LLVM\n\t\t\tcfg->cbb->try_end = (intptr_t)(ip - header->code);\n#endif\n\n\t\t\tif ((handlers = mono_find_leave_clauses (cfg, ip, target))) {\n\t\t\t\tGList *tmp;\n\t\t\t\t/*\n\t\t\t\t * For each finally clause that we exit we need to invoke the finally block.\n\t\t\t\t * After each invocation we need to add try holes for all the clauses that\n\t\t\t\t * we already exited.\n\t\t\t\t */\n\t\t\t\tfor (tmp = handlers; tmp; tmp = tmp->next) {\n\t\t\t\t\tMonoLeaveClause *leave = (MonoLeaveClause *) tmp->data;\n\t\t\t\t\tMonoExceptionClause *clause = leave->clause;\n\n\t\t\t\t\tif (clause->flags != MONO_EXCEPTION_CLAUSE_FINALLY)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tMonoInst *abort_exc = (MonoInst *)mono_find_exvar_for_offset (cfg, clause->handler_offset);\n\t\t\t\t\tMonoBasicBlock *dont_throw;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Emit instrumentation code before linking the basic blocks below as this\n\t\t\t\t\t * will alter cfg->cbb.\n\t\t\t\t\t */\n\t\t\t\t\tmini_profiler_emit_call_finally (cfg, header, ip, leave->index, clause);\n\n\t\t\t\t\ttblock = cfg->cil_offset_to_bb [clause->handler_offset];\n\t\t\t\t\tg_assert (tblock);\n\t\t\t\t\tlink_bblock (cfg, cfg->cbb, tblock);\n\n\t\t\t\t\tMONO_EMIT_NEW_PCONST (cfg, abort_exc->dreg, 0);\n\n\t\t\t\t\tMONO_INST_NEW (cfg, ins, OP_CALL_HANDLER);\n\t\t\t\t\tins->inst_target_bb = tblock;\n\t\t\t\t\tins->inst_eh_blocks = tmp;\n\t\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\t\tcfg->cbb->has_call_handler = 1;\n\n\t\t\t\t\t/* Throw exception if exvar is set */\n\t\t\t\t\t/* FIXME Do we need this for calls from catch/filter ? */\n\t\t\t\t\tNEW_BBLOCK (cfg, dont_throw);\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, abort_exc->dreg, 0);\n\t\t\t\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_PBEQ, dont_throw);\n\t\t\t\t\tmono_emit_jit_icall (cfg, ves_icall_thread_finish_async_abort, NULL);\n\t\t\t\t\tcfg->cbb->clause_holes = tmp;\n\n\t\t\t\t\tMONO_START_BB (cfg, dont_throw);\n\t\t\t\t\tcfg->cbb->clause_holes = tmp;\n\n\t\t\t\t\tif (COMPILE_LLVM (cfg)) {\n\t\t\t\t\t\tMonoBasicBlock *target_bb;\n\n\t\t\t\t\t\t/* \n\t\t\t\t\t\t * Link the finally bblock with the target, since it will\n\t\t\t\t\t\t * conceptually branch there.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tGET_BBLOCK (cfg, tblock, cfg->cil_start + clause->handler_offset + clause->handler_len - 1);\n\t\t\t\t\t\tGET_BBLOCK (cfg, target_bb, target);\n\t\t\t\t\t\tlink_bblock (cfg, tblock, target_bb);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} \n\n\t\t\tMONO_INST_NEW (cfg, ins, OP_BR);\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\tGET_BBLOCK (cfg, tblock, target);\n\t\t\tlink_bblock (cfg, cfg->cbb, tblock);\n\t\t\tins->inst_target_bb = tblock;\n\n\t\t\tstart_new_bblock = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Mono specific opcodes\n\t\t */\n\n\t\tcase MONO_CEE_MONO_ICALL: {\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\tconst MonoJitICallId jit_icall_id = (MonoJitICallId)token;\n\t\t\tMonoJitICallInfo * const info = mono_find_jit_icall_info (jit_icall_id);\n\n\t\t\tCHECK_STACK (info->sig->param_count);\n\t\t\tsp -= info->sig->param_count;\n\n\t\t\tif (token == MONO_JIT_ICALL_mono_threads_attach_coop) {\n\t\t\t\tMonoInst *addr;\n\t\t\t\tMonoBasicBlock *next_bb;\n\n\t\t\t\tif (cfg->compile_aot) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This is called on unattached threads, so it cannot go through the trampoline\n\t\t\t\t\t * infrastructure. Use an indirect call through a got slot initialized at load time\n\t\t\t\t\t * instead.\n\t\t\t\t\t */\n\t\t\t\t\tEMIT_NEW_AOTCONST (cfg, addr, MONO_PATCH_INFO_JIT_ICALL_ADDR_NOCALL, GUINT_TO_POINTER (jit_icall_id));\n\t\t\t\t\tins = mini_emit_calli (cfg, info->sig, sp, addr, NULL, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tins = mono_emit_jit_icall_id (cfg, jit_icall_id, sp);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Parts of the initlocals code needs to come after this, since it might call methods like memset.\n\t\t\t\t */\n\t\t\t\tinit_localsbb2 = cfg->cbb;\n\t\t\t\tNEW_BBLOCK (cfg, next_bb);\n\t\t\t\tMONO_START_BB (cfg, next_bb);\n\t\t\t} else {\n\t\t\t\tins = mono_emit_jit_icall_id (cfg, jit_icall_id, sp);\n\t\t\t}\n\n\t\t\tif (!MONO_TYPE_IS_VOID (info->sig->ret))\n\t\t\t\t*sp++ = ins;\n\n\t\t\tinline_costs += CALL_COST * MIN(10, num_calls++);\n\t\t\tbreak;\n\t\t}\n\n\t\tMonoJumpInfoType ldptr_type;\n\n\t\tcase MONO_CEE_MONO_LDPTR_CARD_TABLE:\n\t\t\tldptr_type = MONO_PATCH_INFO_GC_CARD_TABLE_ADDR;\n\t\t\tgoto mono_ldptr;\n\t\tcase MONO_CEE_MONO_LDPTR_NURSERY_START:\n\t\t\tldptr_type = MONO_PATCH_INFO_GC_NURSERY_START;\n\t\t\tgoto mono_ldptr;\n\t\tcase MONO_CEE_MONO_LDPTR_NURSERY_BITS:\n\t\t\tldptr_type = MONO_PATCH_INFO_GC_NURSERY_BITS;\n\t\t\tgoto mono_ldptr;\n\t\tcase MONO_CEE_MONO_LDPTR_INT_REQ_FLAG:\n\t\t\tldptr_type = MONO_PATCH_INFO_INTERRUPTION_REQUEST_FLAG;\n\t\t\tgoto mono_ldptr;\n\t\tcase MONO_CEE_MONO_LDPTR_PROFILER_ALLOCATION_COUNT:\n\t\t\tldptr_type = MONO_PATCH_INFO_PROFILER_ALLOCATION_COUNT;\nmono_ldptr:\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\tins = mini_emit_runtime_constant (cfg, ldptr_type, NULL);\n\t\t\t*sp++ = ins;\n\t\t\tinline_costs += CALL_COST * MIN(10, num_calls++);\n\t\t\tbreak;\n\n\t\tcase MONO_CEE_MONO_LDPTR: {\n\t\t\tgpointer ptr;\n\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\tptr = mono_method_get_wrapper_data (method, token);\n\t\t\tEMIT_NEW_PCONST (cfg, ins, ptr);\n\t\t\t*sp++ = ins;\n\t\t\tinline_costs += CALL_COST * MIN(10, num_calls++);\n\t\t\t/* Can't embed random pointers into AOT code */\n\t\t\tDISABLE_AOT (cfg);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_MONO_JIT_ICALL_ADDR:\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\tEMIT_NEW_JIT_ICALL_ADDRCONST (cfg, ins, GUINT_TO_POINTER (token));\n\t\t\t*sp++ = ins;\n\t\t\tinline_costs += CALL_COST * MIN(10, num_calls++);\n\t\t\tbreak;\n\n\t\tcase MONO_CEE_MONO_ICALL_ADDR: {\n\t\t\tMonoMethod *cmethod;\n\t\t\tgpointer ptr;\n\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\n\t\t\tcmethod = (MonoMethod *)mono_method_get_wrapper_data (method, token);\n\n\t\t\tif (cfg->compile_aot) {\n\t\t\t\tif (cfg->direct_pinvoke && ip + 6 < end && (ip [6] == CEE_POP)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This is generated by emit_native_wrapper () to resolve the pinvoke address\n\t\t\t\t\t * before the call, its not needed when using direct pinvoke.\n\t\t\t\t\t * This is not an optimization, but its used to avoid looking up pinvokes\n\t\t\t\t\t * on platforms which don't support dlopen ().\n\t\t\t\t\t */\n\t\t\t\t\tEMIT_NEW_PCONST (cfg, ins, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tEMIT_NEW_AOTCONST (cfg, ins, MONO_PATCH_INFO_ICALL_ADDR, cmethod);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tptr = mono_lookup_internal_call (cmethod);\n\t\t\t\tg_assert (ptr);\n\t\t\t\tEMIT_NEW_PCONST (cfg, ins, ptr);\n\t\t\t}\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_MONO_VTADDR: {\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\tMonoInst *src_var, *src;\n\n\t\t\t--sp;\n\n\t\t\t// FIXME:\n\t\t\tsrc_var = get_vreg_to_inst (cfg, sp [0]->dreg);\n\t\t\tEMIT_NEW_VARLOADA ((cfg), (src), src_var, src_var->inst_vtype);\n\t\t\t*sp++ = src;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_MONO_NEWOBJ: {\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\tMonoInst *iargs [2];\n\n\t\t\tklass = (MonoClass *)mono_method_get_wrapper_data (method, token);\n\t\t\tmono_class_init_internal (klass);\n\t\t\tNEW_DOMAINCONST (cfg, iargs [0]);\n\t\t\tMONO_ADD_INS (cfg->cbb, iargs [0]);\n\t\t\tNEW_CLASSCONST (cfg, iargs [1], klass);\n\t\t\tMONO_ADD_INS (cfg->cbb, iargs [1]);\n\t\t\t*sp++ = mono_emit_jit_icall (cfg, ves_icall_object_new, iargs);\n\t\t\tinline_costs += CALL_COST * MIN(10, num_calls++);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_MONO_OBJADDR:\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\t--sp;\n\t\t\tMONO_INST_NEW (cfg, ins, OP_MOVE);\n\t\t\tins->dreg = alloc_ireg_mp (cfg);\n\t\t\tins->sreg1 = sp [0]->dreg;\n\t\t\tins->type = STACK_MP;\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\tcase MONO_CEE_MONO_LDNATIVEOBJ:\n\t\t\t/*\n\t\t\t * Similar to LDOBJ, but instead load the unmanaged\n\t\t\t * representation of the vtype to the stack.\n\t\t\t */\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\t--sp;\n\t\t\tklass = (MonoClass *)mono_method_get_wrapper_data (method, token);\n\t\t\tg_assert (m_class_is_valuetype (klass));\n\t\t\tmono_class_init_internal (klass);\n\n\t\t\t{\n\t\t\t\tMonoInst *src, *dest, *temp;\n\n\t\t\t\tsrc = sp [0];\n\t\t\t\ttemp = mono_compile_create_var (cfg, m_class_get_byval_arg (klass), OP_LOCAL);\n\t\t\t\ttemp->backend.is_pinvoke = 1;\n\t\t\t\tEMIT_NEW_TEMPLOADA (cfg, dest, temp->inst_c0);\n\t\t\t\tmini_emit_memory_copy (cfg, dest, src, klass, TRUE, 0);\n\n\t\t\t\tEMIT_NEW_TEMPLOAD (cfg, dest, temp->inst_c0);\n\t\t\t\tdest->type = STACK_VTYPE;\n\t\t\t\tdest->klass = klass;\n\n\t\t\t\t*sp ++ = dest;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_CEE_MONO_RETOBJ: {\n\t\t\t/*\n\t\t\t * Same as RET, but return the native representation of a vtype\n\t\t\t * to the caller.\n\t\t\t */\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\tg_assert (cfg->ret);\n\t\t\tg_assert (mono_method_signature_internal (method)->pinvoke);\n\t\t\t--sp;\n\n\t\t\tklass = (MonoClass *)mono_method_get_wrapper_data (method, token);\n\n\t\t\tif (!cfg->vret_addr) {\n\t\t\t\tg_assert (cfg->ret_var_is_local);\n\n\t\t\t\tEMIT_NEW_VARLOADA (cfg, ins, cfg->ret, cfg->ret->inst_vtype);\n\t\t\t} else {\n\t\t\t\tEMIT_NEW_RETLOADA (cfg, ins);\n\t\t\t}\n\t\t\tmini_emit_memory_copy (cfg, ins, sp [0], klass, TRUE, 0);\n\n\t\t\tif (sp != stack_start)\n\t\t\t\tUNVERIFIED;\n\n\t\t\tmini_profiler_emit_leave (cfg, sp [0]);\n\n\t\t\tMONO_INST_NEW (cfg, ins, OP_BR);\n\t\t\tins->inst_target_bb = end_bblock;\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\tlink_bblock (cfg, cfg->cbb, end_bblock);\n\t\t\tstart_new_bblock = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_MONO_SAVE_LMF:\n\t\tcase MONO_CEE_MONO_RESTORE_LMF:\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\tbreak;\n\t\tcase MONO_CEE_MONO_CLASSCONST:\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\tEMIT_NEW_CLASSCONST (cfg, ins, mono_method_get_wrapper_data (method, token));\n\t\t\t*sp++ = ins;\n\t\t\tinline_costs += CALL_COST * MIN(10, num_calls++);\n\t\t\tbreak;\n\t\tcase MONO_CEE_MONO_NOT_TAKEN:\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\tcfg->cbb->out_of_line = TRUE;\n\t\t\tbreak;\n\t\tcase MONO_CEE_MONO_TLS: {\n\t\t\tMonoTlsKey key;\n\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\tkey = (MonoTlsKey)n;\n\t\t\tg_assert (key < TLS_KEY_NUM);\n\n\t\t\tins = mono_create_tls_get (cfg, key);\n\t\t\tg_assert (ins);\n\t\t\tins->type = STACK_PTR;\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_MONO_DYN_CALL: {\n\t\t\tMonoCallInst *call;\n\n\t\t\t/* It would be easier to call a trampoline, but that would put an\n\t\t\t * extra frame on the stack, confusing exception handling. So\n\t\t\t * implement it inline using an opcode for now.\n\t\t\t */\n\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\tif (!cfg->dyn_call_var) {\n\t\t\t\tcfg->dyn_call_var = mono_compile_create_var (cfg, mono_get_int_type (), OP_LOCAL);\n\t\t\t\t/* prevent it from being register allocated */\n\t\t\t\tcfg->dyn_call_var->flags |= MONO_INST_VOLATILE;\n\t\t\t}\n\n\t\t\t/* Has to use a call inst since local regalloc expects it */\n\t\t\tMONO_INST_NEW_CALL (cfg, call, OP_DYN_CALL);\n\t\t\tins = (MonoInst*)call;\n\t\t\tsp -= 2;\n\t\t\tins->sreg1 = sp [0]->dreg;\n\t\t\tins->sreg2 = sp [1]->dreg;\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\n\t\t\tcfg->param_area = MAX (cfg->param_area, cfg->backend->dyn_call_param_area);\n\t\t\t/* OP_DYN_CALL might need to allocate a dynamically sized param area */\n\t\t\tcfg->flags |= MONO_CFG_HAS_ALLOCA;\n\n\t\t\tinline_costs += CALL_COST * MIN(10, num_calls++);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_MONO_MEMORY_BARRIER: {\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\tmini_emit_memory_barrier (cfg, (int)n);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_MONO_ATOMIC_STORE_I4: {\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\tg_assert (mono_arch_opcode_supported (OP_ATOMIC_STORE_I4));\n\n\t\t\tsp -= 2;\n\n\t\t\tMONO_INST_NEW (cfg, ins, OP_ATOMIC_STORE_I4);\n\t\t\tins->dreg = sp [0]->dreg;\n\t\t\tins->sreg1 = sp [1]->dreg;\n\t\t\tins->backend.memory_barrier_kind = (int)n;\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_MONO_LD_DELEGATE_METHOD_PTR: {\n\t\t\tCHECK_STACK (1);\n\t\t\t--sp;\n\n\t\t\tdreg = alloc_preg (cfg);\n\t\t\tEMIT_NEW_LOAD_MEMBASE (cfg, ins, OP_LOAD_MEMBASE, dreg, sp [0]->dreg, MONO_STRUCT_OFFSET (MonoDelegate, method_ptr));\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_MONO_CALLI_EXTRA_ARG: {\n\t\t\tMonoInst *addr;\n\t\t\tMonoMethodSignature *fsig;\n\t\t\tMonoInst *arg;\n\n\t\t\t/*\n\t\t\t * This is the same as CEE_CALLI, but passes an additional argument\n\t\t\t * to the called method in llvmonly mode.\n\t\t\t * This is only used by delegate invoke wrappers to call the\n\t\t\t * actual delegate method.\n\t\t\t */\n\t\t\tg_assert (method->wrapper_type == MONO_WRAPPER_DELEGATE_INVOKE);\n\n\t\t\tins = NULL;\n\n\t\t\tcmethod = NULL;\n\t\t\tCHECK_STACK (1);\n\t\t\t--sp;\n\t\t\taddr = *sp;\n\t\t\tfsig = mini_get_signature (method, token, generic_context, cfg->error);\n\t\t\tCHECK_CFG_ERROR;\n\n\t\t\tif (cfg->llvm_only)\n\t\t\t\tcfg->signatures = g_slist_prepend_mempool (cfg->mempool, cfg->signatures, fsig);\n\n\t\t\tn = fsig->param_count + fsig->hasthis + 1;\n\n\t\t\tCHECK_STACK (n);\n\n\t\t\tsp -= n;\n\t\t\targ = sp [n - 1];\n\n\t\t\tif (cfg->llvm_only) {\n\t\t\t\t/*\n\t\t\t\t * The lowest bit of 'arg' determines whenever the callee uses the gsharedvt\n\t\t\t\t * cconv. This is set by mono_init_delegate ().\n\t\t\t\t */\n\t\t\t\tif (cfg->gsharedvt && mini_is_gsharedvt_variable_signature (fsig)) {\n\t\t\t\t\tMonoInst *callee = addr;\n\t\t\t\t\tMonoInst *call, *localloc_ins;\n\t\t\t\t\tMonoBasicBlock *is_gsharedvt_bb, *end_bb;\n\t\t\t\t\tint low_bit_reg = alloc_preg (cfg);\n\n\t\t\t\t\tNEW_BBLOCK (cfg, is_gsharedvt_bb);\n\t\t\t\t\tNEW_BBLOCK (cfg, end_bb);\n\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_PAND_IMM, low_bit_reg, arg->dreg, 1);\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, low_bit_reg, 0);\n\t\t\t\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_PBNE_UN, is_gsharedvt_bb);\n\n\t\t\t\t\t/* Normal case: callee uses a normal cconv, have to add an out wrapper */\n\t\t\t\t\taddr = emit_get_rgctx_sig (cfg, context_used,\n\t\t\t\t\t\t\t\t\t\t\t   fsig, MONO_RGCTX_INFO_SIG_GSHAREDVT_OUT_TRAMPOLINE_CALLI);\n\t\t\t\t\t/*\n\t\t\t\t\t * ADDR points to a gsharedvt-out wrapper, have to pass <callee, arg> as an extra arg.\n\t\t\t\t\t */\n\t\t\t\t\tMONO_INST_NEW (cfg, ins, OP_LOCALLOC_IMM);\n\t\t\t\t\tins->dreg = alloc_preg (cfg);\n\t\t\t\t\tins->inst_imm = 2 * TARGET_SIZEOF_VOID_P;\n\t\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\t\tlocalloc_ins = ins;\n\t\t\t\t\tcfg->flags |= MONO_CFG_HAS_ALLOCA;\n\t\t\t\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, localloc_ins->dreg, 0, callee->dreg);\n\t\t\t\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, localloc_ins->dreg, TARGET_SIZEOF_VOID_P, arg->dreg);\n\n\t\t\t\t\tcall = mini_emit_extra_arg_calli (cfg, fsig, sp, localloc_ins->dreg, addr);\n\t\t\t\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_BR, end_bb);\n\n\t\t\t\t\t/* Gsharedvt case: callee uses a gsharedvt cconv, no conversion is needed */\n\t\t\t\t\tMONO_START_BB (cfg, is_gsharedvt_bb);\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_PXOR_IMM, arg->dreg, arg->dreg, 1);\n\t\t\t\t\tins = mini_emit_extra_arg_calli (cfg, fsig, sp, arg->dreg, callee);\n\t\t\t\t\tins->dreg = call->dreg;\n\n\t\t\t\t\tMONO_START_BB (cfg, end_bb);\n\t\t\t\t} else {\n\t\t\t\t\t/* Caller uses a normal calling conv */\n\n\t\t\t\t\tMonoInst *callee = addr;\n\t\t\t\t\tMonoInst *call, *localloc_ins;\n\t\t\t\t\tMonoBasicBlock *is_gsharedvt_bb, *end_bb;\n\t\t\t\t\tint low_bit_reg = alloc_preg (cfg);\n\n\t\t\t\t\tNEW_BBLOCK (cfg, is_gsharedvt_bb);\n\t\t\t\t\tNEW_BBLOCK (cfg, end_bb);\n\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_PAND_IMM, low_bit_reg, arg->dreg, 1);\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, low_bit_reg, 0);\n\t\t\t\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_PBNE_UN, is_gsharedvt_bb);\n\n\t\t\t\t\t/* Normal case: callee uses a normal cconv, no conversion is needed */\n\t\t\t\t\tcall = mini_emit_extra_arg_calli (cfg, fsig, sp, arg->dreg, callee);\n\t\t\t\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_BR, end_bb);\n\t\t\t\t\t/* Gsharedvt case: callee uses a gsharedvt cconv, have to add an in wrapper */\n\t\t\t\t\tMONO_START_BB (cfg, is_gsharedvt_bb);\n\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_PXOR_IMM, arg->dreg, arg->dreg, 1);\n\t\t\t\t\tNEW_AOTCONST (cfg, addr, MONO_PATCH_INFO_GSHAREDVT_IN_WRAPPER, fsig);\n\t\t\t\t\tMONO_ADD_INS (cfg->cbb, addr);\n\t\t\t\t\t/*\n\t\t\t\t\t * ADDR points to a gsharedvt-in wrapper, have to pass <callee, arg> as an extra arg.\n\t\t\t\t\t */\n\t\t\t\t\tMONO_INST_NEW (cfg, ins, OP_LOCALLOC_IMM);\n\t\t\t\t\tins->dreg = alloc_preg (cfg);\n\t\t\t\t\tins->inst_imm = 2 * TARGET_SIZEOF_VOID_P;\n\t\t\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t\t\tlocalloc_ins = ins;\n\t\t\t\t\tcfg->flags |= MONO_CFG_HAS_ALLOCA;\n\t\t\t\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, localloc_ins->dreg, 0, callee->dreg);\n\t\t\t\t\tMONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, localloc_ins->dreg, TARGET_SIZEOF_VOID_P, arg->dreg);\n\n\t\t\t\t\tins = mini_emit_extra_arg_calli (cfg, fsig, sp, localloc_ins->dreg, addr);\n\t\t\t\t\tins->dreg = call->dreg;\n\t\t\t\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_BR, end_bb);\n\n\t\t\t\t\tMONO_START_BB (cfg, end_bb);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Same as CEE_CALLI */\n\t\t\t\tif (cfg->gsharedvt && mini_is_gsharedvt_signature (fsig)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We pass the address to the gsharedvt trampoline in the rgctx reg\n\t\t\t\t\t */\n\t\t\t\t\tMonoInst *callee = addr;\n\n\t\t\t\t\taddr = emit_get_rgctx_sig (cfg, context_used,\n\t\t\t\t\t\t\t\t\t\t\t   fsig, MONO_RGCTX_INFO_SIG_GSHAREDVT_OUT_TRAMPOLINE_CALLI);\n\t\t\t\t\tins = (MonoInst*)mini_emit_calli (cfg, fsig, sp, addr, NULL, callee);\n\t\t\t\t} else {\n\t\t\t\t\tins = (MonoInst*)mini_emit_calli (cfg, fsig, sp, addr, NULL, NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!MONO_TYPE_IS_VOID (fsig->ret))\n\t\t\t\t*sp++ = mono_emit_widen_call_res (cfg, ins, fsig);\n\n\t\t\tCHECK_CFG_EXCEPTION;\n\n\t\t\tins_flag = 0;\n\t\t\tconstrained_class = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_MONO_LDDOMAIN:\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\t\t\tEMIT_NEW_PCONST (cfg, ins, cfg->compile_aot ? NULL : cfg->domain);\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\tcase MONO_CEE_MONO_SAVE_LAST_ERROR:\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\n\t\t\t// Just an IL prefix, setting this flag, picked up by call instructions.\n\t\t\tsave_last_error = TRUE;\n\t\t\tbreak;\n\t\tcase MONO_CEE_MONO_GET_RGCTX_ARG:\n\t\t\tg_assert (method->wrapper_type != MONO_WRAPPER_NONE);\n\n\t\t\tmono_create_rgctx_var (cfg);\n\n\t\t\tMONO_INST_NEW (cfg, ins, OP_MOVE);\n\t\t\tins->dreg = alloc_dreg (cfg, STACK_PTR);\n\t\t\tins->sreg1 = cfg->rgctx_var->dreg;\n\t\t\tins->type = STACK_PTR;\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\n\t\tcase MONO_CEE_ARGLIST: {\n\t\t\t/* somewhat similar to LDTOKEN */\n\t\t\tMonoInst *addr, *vtvar;\n\t\t\tvtvar = mono_compile_create_var (cfg, m_class_get_byval_arg (mono_defaults.argumenthandle_class), OP_LOCAL); \n\n\t\t\tEMIT_NEW_TEMPLOADA (cfg, addr, vtvar->inst_c0);\n\t\t\tEMIT_NEW_UNALU (cfg, ins, OP_ARGLIST, -1, addr->dreg);\n\n\t\t\tEMIT_NEW_TEMPLOAD (cfg, ins, vtvar->inst_c0);\n\t\t\tins->type = STACK_VTYPE;\n\t\t\tins->klass = mono_defaults.argumenthandle_class;\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_CEQ:\n\t\tcase MONO_CEE_CGT:\n\t\tcase MONO_CEE_CGT_UN:\n\t\tcase MONO_CEE_CLT:\n\t\tcase MONO_CEE_CLT_UN: {\n\t\t\tMonoInst *cmp, *arg1, *arg2;\n\n\t\t\tsp -= 2;\n\t\t\targ1 = sp [0];\n\t\t\targ2 = sp [1];\n\n\t\t\t/*\n\t\t\t * The following transforms:\n\t\t\t *    CEE_CEQ    into OP_CEQ\n\t\t\t *    CEE_CGT    into OP_CGT\n\t\t\t *    CEE_CGT_UN into OP_CGT_UN\n\t\t\t *    CEE_CLT    into OP_CLT\n\t\t\t *    CEE_CLT_UN into OP_CLT_UN\n\t\t\t */\n\t\t\tMONO_INST_NEW (cfg, cmp, (OP_CEQ - CEE_CEQ) + ip [1]);\n\n\t\t\tMONO_INST_NEW (cfg, ins, cmp->opcode);\n\t\t\tcmp->sreg1 = arg1->dreg;\n\t\t\tcmp->sreg2 = arg2->dreg;\n\t\t\ttype_from_op (cfg, cmp, arg1, arg2);\n\t\t\tCHECK_TYPE (cmp);\n\t\t\tadd_widen_op (cfg, cmp, &arg1, &arg2);\n\t\t\tif ((arg1->type == STACK_I8) || ((TARGET_SIZEOF_VOID_P == 8) && ((arg1->type == STACK_PTR) || (arg1->type == STACK_OBJ) || (arg1->type == STACK_MP))))\n\t\t\t\tcmp->opcode = OP_LCOMPARE;\n\t\t\telse if (arg1->type == STACK_R4)\n\t\t\t\tcmp->opcode = OP_RCOMPARE;\n\t\t\telse if (arg1->type == STACK_R8)\n\t\t\t\tcmp->opcode = OP_FCOMPARE;\n\t\t\telse\n\t\t\t\tcmp->opcode = OP_ICOMPARE;\n\t\t\tMONO_ADD_INS (cfg->cbb, cmp);\n\t\t\tins->type = STACK_I4;\n\t\t\tins->dreg = alloc_dreg (cfg, (MonoStackType)ins->type);\n\t\t\ttype_from_op (cfg, ins, arg1, arg2);\n\n\t\t\tif (cmp->opcode == OP_FCOMPARE || cmp->opcode == OP_RCOMPARE) {\n\t\t\t\t/*\n\t\t\t\t * The backends expect the fceq opcodes to do the\n\t\t\t\t * comparison too.\n\t\t\t\t */\n\t\t\t\tins->sreg1 = cmp->sreg1;\n\t\t\t\tins->sreg2 = cmp->sreg2;\n\t\t\t\tNULLIFY_INS (cmp);\n\t\t\t}\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_LDFTN: {\n\t\t\tMonoInst *argconst;\n\t\t\tMonoMethod *cil_method;\n\n\t\t\tcmethod = mini_get_method (cfg, method, n, NULL, generic_context);\n\t\t\tCHECK_CFG_ERROR;\n\n\t\t\tmono_class_init_internal (cmethod->klass);\n\n\t\t\tmono_save_token_info (cfg, image, n, cmethod);\n\n\t\t\tcontext_used = mini_method_check_context_used (cfg, cmethod);\n\n\t\t\tcil_method = cmethod;\n\t\t\tif (!dont_verify && !cfg->skip_visibility && !mono_method_can_access_method (method, cmethod))\n\t\t\t\temit_method_access_failure (cfg, method, cil_method);\n\n\t\t\tif (mono_security_core_clr_enabled ())\n\t\t\t\tensure_method_is_allowed_to_call_method (cfg, method, cmethod);\n\n\t\t\t/*\n\t\t\t * Optimize the common case of ldftn+delegate creation\n\t\t\t */\n\t\t\tif ((sp > stack_start) && (next_ip + 4 < end) && ip_in_bb (cfg, cfg->cbb, next_ip) && (next_ip [0] == CEE_NEWOBJ)) {\n\t\t\t\tMonoMethod *ctor_method = mini_get_method (cfg, method, read32 (next_ip + 1), NULL, generic_context);\n\t\t\t\tif (ctor_method && (m_class_get_parent (ctor_method->klass) == mono_defaults.multicastdelegate_class)) {\n\t\t\t\t\tMonoInst *target_ins, *handle_ins;\n\t\t\t\t\tMonoMethod *invoke;\n\t\t\t\t\tint invoke_context_used;\n\n\t\t\t\t\tinvoke = mono_get_delegate_invoke_internal (ctor_method->klass);\n\t\t\t\t\tif (!invoke || !mono_method_signature_internal (invoke))\n\t\t\t\t\t\tLOAD_ERROR;\n\n\t\t\t\t\tinvoke_context_used = mini_method_check_context_used (cfg, invoke);\n\n\t\t\t\t\ttarget_ins = sp [-1];\n\n\t\t\t\t\tif (mono_security_core_clr_enabled ())\n\t\t\t\t\t\tensure_method_is_allowed_to_call_method (cfg, method, ctor_method);\n\n\t\t\t\t\tif (!(cmethod->flags & METHOD_ATTRIBUTE_STATIC)) {\n\t\t\t\t\t\t/*LAME IMPL: We must not add a null check for virtual invoke delegates.*/\n\t\t\t\t\t\tif (mono_method_signature_internal (invoke)->param_count == mono_method_signature_internal (cmethod)->param_count) {\n\t\t\t\t\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, target_ins->dreg, 0);\n\t\t\t\t\t\t\tMONO_EMIT_NEW_COND_EXC (cfg, EQ, \"ArgumentException\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((invoke_context_used == 0 || !cfg->gsharedvt) || cfg->llvm_only) {\n\t\t\t\t\t\tif (cfg->verbose_level > 3)\n\t\t\t\t\t\t\tg_print (\"converting (in B%d: stack: %d) %s\", cfg->cbb->block_num, (int)(sp - stack_start), mono_disasm_code_one (NULL, method, ip + 6, NULL));\n\t\t\t\t\t\tif ((handle_ins = handle_delegate_ctor (cfg, ctor_method->klass, target_ins, cmethod, context_used, invoke_context_used, FALSE))) {\n\t\t\t\t\t\t\tsp --;\n\t\t\t\t\t\t\t*sp = handle_ins;\n\t\t\t\t\t\t\tCHECK_CFG_EXCEPTION;\n\t\t\t\t\t\t\tsp ++;\n\t\t\t\t\t\t\tnext_ip += 5;\n\t\t\t\t\t\t\til_op = MONO_CEE_NEWOBJ;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\targconst = emit_get_rgctx_method (cfg, context_used, cmethod, MONO_RGCTX_INFO_METHOD);\n\t\t\tins = mono_emit_jit_icall (cfg, mono_ldftn, &argconst);\n\t\t\t*sp++ = ins;\n\n\t\t\tinline_costs += CALL_COST * MIN(10, num_calls++);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_LDVIRTFTN: {\n\t\t\tMonoInst *args [2];\n\n\t\t\tcmethod = mini_get_method (cfg, method, n, NULL, generic_context);\n\t\t\tCHECK_CFG_ERROR;\n\n\t\t\tmono_class_init_internal (cmethod->klass);\n\n\t\t\tcontext_used = mini_method_check_context_used (cfg, cmethod);\n\n\t\t\tif (mono_security_core_clr_enabled ())\n\t\t\t\tensure_method_is_allowed_to_call_method (cfg, method, cmethod);\n\n\t\t\t/*\n\t\t\t * Optimize the common case of ldvirtftn+delegate creation\n\t\t\t */\n\t\t\tif (previous_il_op == MONO_CEE_DUP && (sp > stack_start) && (next_ip + 4 < end) && ip_in_bb (cfg, cfg->cbb, next_ip) && (next_ip [0] == CEE_NEWOBJ)) {\n\t\t\t\tMonoMethod *ctor_method = mini_get_method (cfg, method, read32 (next_ip + 1), NULL, generic_context);\n\t\t\t\tif (ctor_method && (m_class_get_parent (ctor_method->klass) == mono_defaults.multicastdelegate_class)) {\n\t\t\t\t\tMonoInst *target_ins, *handle_ins;\n\t\t\t\t\tMonoMethod *invoke;\n\t\t\t\t\tint invoke_context_used;\n\t\t\t\t\tconst gboolean is_virtual = (cmethod->flags & METHOD_ATTRIBUTE_VIRTUAL) != 0;\n\n\t\t\t\t\tinvoke = mono_get_delegate_invoke_internal (ctor_method->klass);\n\t\t\t\t\tif (!invoke || !mono_method_signature_internal (invoke))\n\t\t\t\t\t\tLOAD_ERROR;\n\n\t\t\t\t\tinvoke_context_used = mini_method_check_context_used (cfg, invoke);\n\n\t\t\t\t\ttarget_ins = sp [-1];\n\n\t\t\t\t\tif (mono_security_core_clr_enabled ())\n\t\t\t\t\t\tensure_method_is_allowed_to_call_method (cfg, method, ctor_method);\n\n\t\t\t\t\tif (invoke_context_used == 0 || !cfg->gsharedvt || cfg->llvm_only) {\n\t\t\t\t\t\tif (cfg->verbose_level > 3)\n\t\t\t\t\t\t\tg_print (\"converting (in B%d: stack: %d) %s\", cfg->cbb->block_num, (int)(sp - stack_start), mono_disasm_code_one (NULL, method, ip + 6, NULL));\n\t\t\t\t\t\tif ((handle_ins = handle_delegate_ctor (cfg, ctor_method->klass, target_ins, cmethod, context_used, invoke_context_used, is_virtual))) {\n\t\t\t\t\t\t\tsp -= 2;\n\t\t\t\t\t\t\t*sp = handle_ins;\n\t\t\t\t\t\t\tCHECK_CFG_EXCEPTION;\n\t\t\t\t\t\t\tnext_ip += 5;\n\t\t\t\t\t\t\tprevious_il_op = MONO_CEE_NEWOBJ;\n\t\t\t\t\t\t\tsp ++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tCHECK_CFG_ERROR;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t--sp;\n\t\t\targs [0] = *sp;\n\n\t\t\targs [1] = emit_get_rgctx_method (cfg, context_used,\n\t\t\t\t\t\t\t\t\t\t\t  cmethod, MONO_RGCTX_INFO_METHOD);\n\n\t\t\tif (context_used)\n\t\t\t\t*sp++ = mono_emit_jit_icall (cfg, mono_ldvirtfn_gshared, args);\n\t\t\telse\n\t\t\t\t*sp++ = mono_emit_jit_icall (cfg, mono_ldvirtfn, args);\n\n\t\t\tinline_costs += CALL_COST * MIN(10, num_calls++);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_LOCALLOC: {\n\t\t\tMonoBasicBlock *non_zero_bb, *end_bb;\n\t\t\tint alloc_ptr = alloc_preg (cfg);\n\t\t\t--sp;\n\t\t\tif (sp != stack_start)\n\t\t\t\tUNVERIFIED;\n\t\t\tif (cfg->method != method)\n\t\t\t\t/*\n\t\t\t\t * Inlining this into a loop in a parent could lead to\n\t\t\t\t * stack overflows which is different behavior than the\n\t\t\t\t * non-inlined case, thus disable inlining in this case.\n\t\t\t\t */\n\t\t\t\tINLINE_FAILURE(\"localloc\");\n\n\t\t\tNEW_BBLOCK (cfg, non_zero_bb);\n\t\t\tNEW_BBLOCK (cfg, end_bb);\n\n\t\t\t/* if size != zero */\n\t\t\tMONO_EMIT_NEW_BIALU_IMM (cfg, OP_COMPARE_IMM, -1, sp [0]->dreg, 0);\n\t\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_PBNE_UN, non_zero_bb);\n\n\t\t\t//size is zero, so result is NULL\n\t\t\tMONO_EMIT_NEW_PCONST (cfg, alloc_ptr, NULL);\n\t\t\tMONO_EMIT_NEW_BRANCH_BLOCK (cfg, OP_BR, end_bb);\n\n\t\t\tMONO_START_BB (cfg, non_zero_bb);\n\t\t\tMONO_INST_NEW (cfg, ins, OP_LOCALLOC);\n\t\t\tins->dreg = alloc_ptr;\n\t\t\tins->sreg1 = sp [0]->dreg;\n\t\t\tins->type = STACK_PTR;\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\n\t\t\tcfg->flags |= MONO_CFG_HAS_ALLOCA;\n\t\t\tif (init_locals)\n\t\t\t\tins->flags |= MONO_INST_INIT;\n\n\t\t\tMONO_START_BB (cfg, end_bb);\n\t\t\tEMIT_NEW_UNALU (cfg, ins, OP_MOVE, alloc_preg (cfg), alloc_ptr);\n\t\t\tins->type = STACK_PTR;\n\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_ENDFILTER: {\n\t\t\tMonoExceptionClause *clause, *nearest;\n\t\t\tint cc;\n\n\t\t\t--sp;\n\t\t\tif ((sp != stack_start) || (sp [0]->type != STACK_I4))\n\t\t\t\tUNVERIFIED;\n\t\t\tMONO_INST_NEW (cfg, ins, OP_ENDFILTER);\n\t\t\tins->sreg1 = (*sp)->dreg;\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\tstart_new_bblock = 1;\n\n\t\t\tnearest = NULL;\n\t\t\tfor (cc = 0; cc < header->num_clauses; ++cc) {\n\t\t\t\tclause = &header->clauses [cc];\n\t\t\t\tif ((clause->flags & MONO_EXCEPTION_CLAUSE_FILTER) &&\n\t\t\t\t\t((next_ip - header->code) > clause->data.filter_offset && (next_ip - header->code) <= clause->handler_offset) &&\n\t\t\t\t    (!nearest || (clause->data.filter_offset < nearest->data.filter_offset)))\n\t\t\t\t\tnearest = clause;\n\t\t\t}\n\t\t\tg_assert (nearest);\n\t\t\tif ((next_ip - header->code) != nearest->handler_offset)\n\t\t\t\tUNVERIFIED;\n\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_UNALIGNED_:\n\t\t\tins_flag |= MONO_INST_UNALIGNED;\n\t\t\t/* FIXME: record alignment? we can assume 1 for now */\n\t\t\tbreak;\n\t\tcase MONO_CEE_VOLATILE_:\n\t\t\tins_flag |= MONO_INST_VOLATILE;\n\t\t\tbreak;\n\t\tcase MONO_CEE_TAIL_:\n\t\t\tins_flag   |= MONO_INST_TAILCALL;\n\t\t\tcfg->flags |= MONO_CFG_HAS_TAILCALL;\n\t\t\t/* Can't inline tailcalls at this time */\n\t\t\tinline_costs += 100000;\n\t\t\tbreak;\n\t\tcase MONO_CEE_INITOBJ:\n\t\t\t--sp;\n\t\t\tklass = mini_get_class (method, token, generic_context);\n\t\t\tCHECK_TYPELOAD (klass);\n\t\t\tif (mini_class_is_reference (klass))\n\t\t\t\tMONO_EMIT_NEW_STORE_MEMBASE_IMM (cfg, OP_STORE_MEMBASE_IMM, sp [0]->dreg, 0, 0);\n\t\t\telse\n\t\t\t\tmini_emit_initobj (cfg, *sp, NULL, klass);\n\t\t\tinline_costs += 1;\n\t\t\tbreak;\n\t\tcase MONO_CEE_CONSTRAINED_:\n\t\t\tconstrained_class = mini_get_class (method, token, generic_context);\n\t\t\tCHECK_TYPELOAD (constrained_class);\n\t\t\tbreak;\n\t\tcase MONO_CEE_CPBLK:\n\t\t\tsp -= 3;\n\t\t\tmini_emit_memory_copy_bytes (cfg, sp [0], sp [1], sp [2], ins_flag);\n\t\t\tins_flag = 0;\n\t\t\tinline_costs += 1;\n\t\t\tbreak;\n\t\tcase MONO_CEE_INITBLK:\n\t\t\tsp -= 3;\n\t\t\tmini_emit_memory_init_bytes (cfg, sp [0], sp [1], sp [2], ins_flag);\n\t\t\tins_flag = 0;\n\t\t\tinline_costs += 1;\n\t\t\tbreak;\n\t\tcase MONO_CEE_NO_:\n\t\t\tif (ip [2] & 1)\n\t\t\t\tins_flag |= MONO_INST_NOTYPECHECK;\n\t\t\tif (ip [2] & 2)\n\t\t\t\tins_flag |= MONO_INST_NORANGECHECK;\n\t\t\t/* we ignore the no-nullcheck for now since we\n\t\t\t * really do it explicitly only when doing callvirt->call\n\t\t\t */\n\t\t\tbreak;\n\t\tcase MONO_CEE_RETHROW: {\n\t\t\tMonoInst *load;\n\t\t\tint handler_offset = -1;\n\n\t\t\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\t\t\tMonoExceptionClause *clause = &header->clauses [i];\n\t\t\t\tif (MONO_OFFSET_IN_HANDLER (clause, ip - header->code) && !(clause->flags & MONO_EXCEPTION_CLAUSE_FINALLY)) {\n\t\t\t\t\thandler_offset = clause->handler_offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcfg->cbb->flags |= BB_EXCEPTION_UNSAFE;\n\n\t\t\tif (handler_offset == -1)\n\t\t\t\tUNVERIFIED;\n\n\t\t\tEMIT_NEW_TEMPLOAD (cfg, load, mono_find_exvar_for_offset (cfg, handler_offset)->inst_c0);\n\t\t\tMONO_INST_NEW (cfg, ins, OP_RETHROW);\n\t\t\tins->sreg1 = load->dreg;\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\n\t\t\tMONO_INST_NEW (cfg, ins, OP_NOT_REACHED);\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\n\t\t\tsp = stack_start;\n\t\t\tlink_bblock (cfg, cfg->cbb, end_bblock);\n\t\t\tstart_new_bblock = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_MONO_RETHROW: {\n\t\t\tif (sp [-1]->type != STACK_OBJ)\n\t\t\t\tUNVERIFIED;\n\n\t\t\tMONO_INST_NEW (cfg, ins, OP_RETHROW);\n\t\t\t--sp;\n\t\t\tins->sreg1 = sp [0]->dreg;\n\t\t\tcfg->cbb->out_of_line = TRUE;\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\tMONO_INST_NEW (cfg, ins, OP_NOT_REACHED);\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\tsp = stack_start;\n\n\t\t\tlink_bblock (cfg, cfg->cbb, end_bblock);\n\t\t\tstart_new_bblock = 1;\n\t\t\t/* This can complicate code generation for llvm since the return value might not be defined */\n\t\t\tif (COMPILE_LLVM (cfg))\n\t\t\t\tINLINE_FAILURE (\"mono_rethrow\");\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_SIZEOF: {\n\t\t\tguint32 val;\n\t\t\tint ialign;\n\n\t\t\tif (mono_metadata_token_table (token) == MONO_TABLE_TYPESPEC && !image_is_dynamic (m_class_get_image (method->klass)) && !generic_context) {\n\t\t\t\tMonoType *type = mono_type_create_from_typespec_checked (image, token, cfg->error);\n\t\t\t\tCHECK_CFG_ERROR;\n\n\t\t\t\tval = mono_type_size (type, &ialign);\n\t\t\t\tEMIT_NEW_ICONST (cfg, ins, val);\n\t\t\t} else {\n\t\t\t\tMonoClass *klass = mini_get_class (method, token, generic_context);\n\t\t\t\tCHECK_TYPELOAD (klass);\n\n\t\t\t\tif (mini_is_gsharedvt_klass (klass)) {\n\t\t\t\t\tins = mini_emit_get_gsharedvt_info_klass (cfg, klass, MONO_RGCTX_INFO_CLASS_SIZEOF);\n\t\t\t\t\tins->type = STACK_I4;\n\t\t\t\t} else {\n\t\t\t\t\tval = mono_type_size (m_class_get_byval_arg (klass), &ialign);\n\t\t\t\t\tEMIT_NEW_ICONST (cfg, ins, val);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_REFANYTYPE: {\n\t\t\tMonoInst *src_var, *src;\n\n\t\t\tGSHAREDVT_FAILURE (il_op);\n\n\t\t\t--sp;\n\n\t\t\t// FIXME:\n\t\t\tsrc_var = get_vreg_to_inst (cfg, sp [0]->dreg);\n\t\t\tif (!src_var)\n\t\t\t\tsrc_var = mono_compile_create_var_for_vreg (cfg, m_class_get_byval_arg (mono_defaults.typed_reference_class), OP_LOCAL, sp [0]->dreg);\n\t\t\tEMIT_NEW_VARLOADA (cfg, src, src_var, src_var->inst_vtype);\n\t\t\tEMIT_NEW_LOAD_MEMBASE_TYPE (cfg, ins, m_class_get_byval_arg (mono_defaults.typehandle_class), src->dreg, MONO_STRUCT_OFFSET (MonoTypedRef, type));\n\t\t\t*sp++ = ins;\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_CEE_READONLY_:\n\t\t\treadonly = TRUE;\n\t\t\tbreak;\n\n\t\tcase MONO_CEE_UNUSED56:\n\t\tcase MONO_CEE_UNUSED57:\n\t\tcase MONO_CEE_UNUSED70:\n\t\tcase MONO_CEE_UNUSED:\n\t\tcase MONO_CEE_UNUSED99:\n\t\tcase MONO_CEE_UNUSED58:\n\t\tcase MONO_CEE_UNUSED1:\n\t\t\tUNVERIFIED;\n\n\t\tdefault:\n\t\t\tg_warning (\"opcode 0x%02x not handled\", il_op);\n\t\t\tUNVERIFIED;\n\t\t}\n\t}\n\tif (start_new_bblock != 1)\n\t\tUNVERIFIED;\n\n\tcfg->cbb->cil_length = ip - cfg->cbb->cil_code;\n\tif (cfg->cbb->next_bb) {\n\t\t/* This could already be set because of inlining, #693905 */\n\t\tMonoBasicBlock *bb = cfg->cbb;\n\n\t\twhile (bb->next_bb)\n\t\t\tbb = bb->next_bb;\n\t\tbb->next_bb = end_bblock;\n\t} else {\n\t\tcfg->cbb->next_bb = end_bblock;\n\t}\n\n\tif (cfg->method == method && cfg->domainvar) {\n\t\tMonoInst *store;\n\t\tMonoInst *get_domain;\n\n\t\tcfg->cbb = init_localsbb;\n\n\t\tget_domain = mono_create_tls_get (cfg, TLS_KEY_DOMAIN);\n\t\tNEW_TEMPSTORE (cfg, store, cfg->domainvar->inst_c0, get_domain);\n\t\tMONO_ADD_INS (cfg->cbb, store);\n\t\tcfg->domainvar_inited = TRUE;\n\t}\n\n#if defined(TARGET_POWERPC) || defined(TARGET_X86)\n\tif (cfg->compile_aot)\n\t\t/* FIXME: The plt slots require a GOT var even if the method doesn't use it */\n\t\tmono_get_got_var (cfg);\n#endif\n\n\tif (cfg->method == method && cfg->got_var)\n\t\tmono_emit_load_got_addr (cfg);\n\n\tif (init_localsbb) {\n\t\tcfg->cbb = init_localsbb;\n\t\tcfg->ip = NULL;\n\t\tfor (i = 0; i < header->num_locals; ++i) {\n\t\t\t/*\n\t\t\t * Vtype initialization might need to be done after CEE_JIT_ATTACH, since it can make calls to memset (),\n\t\t\t * which need the trampoline code to work.\n\t\t\t */\n\t\t\tif (MONO_TYPE_ISSTRUCT (header->locals [i]))\n\t\t\t\tcfg->cbb = init_localsbb2;\n\t\t\telse\n\t\t\t\tcfg->cbb = init_localsbb;\n\t\t\temit_init_local (cfg, i, header->locals [i], init_locals);\n\t\t}\n\t}\n\n\tif (cfg->init_ref_vars && cfg->method == method) {\n\t\t/* Emit initialization for ref vars */\n\t\t// FIXME: Avoid duplication initialization for IL locals.\n\t\tfor (i = 0; i < cfg->num_varinfo; ++i) {\n\t\t\tMonoInst *ins = cfg->varinfo [i];\n\n\t\t\tif (ins->opcode == OP_LOCAL && ins->type == STACK_OBJ)\n\t\t\t\tMONO_EMIT_NEW_PCONST (cfg, ins->dreg, NULL);\n\t\t}\n\t}\n\n\tif (cfg->lmf_var && cfg->method == method && !cfg->llvm_only) {\n\t\tcfg->cbb = init_localsbb;\n\t\temit_push_lmf (cfg);\n\t}\n\n\tcfg->cbb = init_localsbb;\n\tmini_profiler_emit_enter (cfg);\n\n\tif (seq_points) {\n\t\tMonoBasicBlock *bb;\n\n\t\t/*\n\t\t * Make seq points at backward branch targets interruptable.\n\t\t */\n\t\tfor (bb = cfg->bb_entry; bb; bb = bb->next_bb)\n\t\t\tif (bb->code && bb->in_count > 1 && bb->code->opcode == OP_SEQ_POINT)\n\t\t\t\tbb->code->flags |= MONO_INST_SINGLE_STEP_LOC;\n\t}\n\n\t/* Add a sequence point for method entry/exit events */\n\tif (seq_points && cfg->gen_sdb_seq_points) {\n\t\tNEW_SEQ_POINT (cfg, ins, METHOD_ENTRY_IL_OFFSET, FALSE);\n\t\tMONO_ADD_INS (init_localsbb, ins);\n\t\tNEW_SEQ_POINT (cfg, ins, METHOD_EXIT_IL_OFFSET, FALSE);\n\t\tMONO_ADD_INS (cfg->bb_exit, ins);\n\t}\n\n\t/*\n\t * Add seq points for IL offsets which have line number info, but wasn't generated a seq point during JITting because\n\t * the code they refer to was dead (#11880).\n\t */\n\tif (sym_seq_points) {\n\t\tfor (i = 0; i < header->code_size; ++i) {\n\t\t\tif (mono_bitset_test_fast (seq_point_locs, i) && !mono_bitset_test_fast (seq_point_set_locs, i)) {\n\t\t\t\tMonoInst *ins;\n\n\t\t\t\tNEW_SEQ_POINT (cfg, ins, i, FALSE);\n\t\t\t\tmono_add_seq_point (cfg, NULL, ins, SEQ_POINT_NATIVE_OFFSET_DEAD_CODE);\n\t\t\t}\n\t\t}\n\t}\n\n\tcfg->ip = NULL;\n\n\tif (cfg->method == method) {\n\t\tcompute_bb_regions (cfg);\n\t} else {\n\t\tMonoBasicBlock *bb;\n\t\t/* get_most_deep_clause () in mini-llvm.c depends on this for inlined bblocks */\n\t\tfor (bb = start_bblock; bb != end_bblock; bb  = bb->next_bb) {\n\t\t\tbb->real_offset = inline_offset;\n\t\t}\n\t}\n\n\tif (inline_costs < 0) {\n\t\tchar *mname;\n\n\t\t/* Method is too large */\n\t\tmname = mono_method_full_name (method, TRUE);\n\t\tmono_cfg_set_exception_invalid_program (cfg, g_strdup_printf (\"Method %s is too complex.\", mname));\n\t\tg_free (mname);\n\t}\n\n\tif ((cfg->verbose_level > 2) && (cfg->method == method)) \n\t\tmono_print_code (cfg, \"AFTER METHOD-TO-IR\");\n\n\tgoto cleanup;\n\nmono_error_exit:\n\tif (cfg->verbose_level > 3)\n\t\tg_print (\"exiting due to error\");\n\n\tg_assert (!is_ok (cfg->error));\n\tgoto cleanup;\n \n exception_exit:\n\tif (cfg->verbose_level > 3)\n\t\tg_print (\"exiting due to exception\");\n\n\tg_assert (cfg->exception_type != MONO_EXCEPTION_NONE);\n\tgoto cleanup;\n\n unverified:\n\tif (cfg->verbose_level > 3)\n\t\tg_print (\"exiting due to invalid il\");\n\n\tset_exception_type_from_invalid_il (cfg, method, ip);\n\tgoto cleanup;\n\n cleanup:\n\tg_slist_free (class_inits);\n\tmono_basic_block_free (original_bb);\n\tcfg->dont_inline = g_list_remove (cfg->dont_inline, method);\n\tif (cfg->exception_type)\n\t\treturn -1;\n\telse\n\t\treturn inline_costs;\n}\n\nstatic int\nstore_membase_reg_to_store_membase_imm (int opcode)\n{\n\tswitch (opcode) {\n\tcase OP_STORE_MEMBASE_REG:\n\t\treturn OP_STORE_MEMBASE_IMM;\n\tcase OP_STOREI1_MEMBASE_REG:\n\t\treturn OP_STOREI1_MEMBASE_IMM;\n\tcase OP_STOREI2_MEMBASE_REG:\n\t\treturn OP_STOREI2_MEMBASE_IMM;\n\tcase OP_STOREI4_MEMBASE_REG:\n\t\treturn OP_STOREI4_MEMBASE_IMM;\n\tcase OP_STOREI8_MEMBASE_REG:\n\t\treturn OP_STOREI8_MEMBASE_IMM;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\treturn -1;\n}\t\t\n\nint\nmono_op_to_op_imm (int opcode)\n{\n\tswitch (opcode) {\n\tcase OP_IADD:\n\t\treturn OP_IADD_IMM;\n\tcase OP_ISUB:\n\t\treturn OP_ISUB_IMM;\n\tcase OP_IDIV:\n\t\treturn OP_IDIV_IMM;\n\tcase OP_IDIV_UN:\n\t\treturn OP_IDIV_UN_IMM;\n\tcase OP_IREM:\n\t\treturn OP_IREM_IMM;\n\tcase OP_IREM_UN:\n\t\treturn OP_IREM_UN_IMM;\n\tcase OP_IMUL:\n\t\treturn OP_IMUL_IMM;\n\tcase OP_IAND:\n\t\treturn OP_IAND_IMM;\n\tcase OP_IOR:\n\t\treturn OP_IOR_IMM;\n\tcase OP_IXOR:\n\t\treturn OP_IXOR_IMM;\n\tcase OP_ISHL:\n\t\treturn OP_ISHL_IMM;\n\tcase OP_ISHR:\n\t\treturn OP_ISHR_IMM;\n\tcase OP_ISHR_UN:\n\t\treturn OP_ISHR_UN_IMM;\n\n\tcase OP_LADD:\n\t\treturn OP_LADD_IMM;\n\tcase OP_LSUB:\n\t\treturn OP_LSUB_IMM;\n\tcase OP_LAND:\n\t\treturn OP_LAND_IMM;\n\tcase OP_LOR:\n\t\treturn OP_LOR_IMM;\n\tcase OP_LXOR:\n\t\treturn OP_LXOR_IMM;\n\tcase OP_LSHL:\n\t\treturn OP_LSHL_IMM;\n\tcase OP_LSHR:\n\t\treturn OP_LSHR_IMM;\n\tcase OP_LSHR_UN:\n\t\treturn OP_LSHR_UN_IMM;\n#if SIZEOF_REGISTER == 8\n\tcase OP_LMUL:\n\t\treturn OP_LMUL_IMM;\n\tcase OP_LREM:\n\t\treturn OP_LREM_IMM;\n#endif\n\n\tcase OP_COMPARE:\n\t\treturn OP_COMPARE_IMM;\n\tcase OP_ICOMPARE:\n\t\treturn OP_ICOMPARE_IMM;\n\tcase OP_LCOMPARE:\n\t\treturn OP_LCOMPARE_IMM;\n\n\tcase OP_STORE_MEMBASE_REG:\n\t\treturn OP_STORE_MEMBASE_IMM;\n\tcase OP_STOREI1_MEMBASE_REG:\n\t\treturn OP_STOREI1_MEMBASE_IMM;\n\tcase OP_STOREI2_MEMBASE_REG:\n\t\treturn OP_STOREI2_MEMBASE_IMM;\n\tcase OP_STOREI4_MEMBASE_REG:\n\t\treturn OP_STOREI4_MEMBASE_IMM;\n\n#if defined(TARGET_X86) || defined (TARGET_AMD64)\n\tcase OP_X86_PUSH:\n\t\treturn OP_X86_PUSH_IMM;\n\tcase OP_X86_COMPARE_MEMBASE_REG:\n\t\treturn OP_X86_COMPARE_MEMBASE_IMM;\n#endif\n#if defined(TARGET_AMD64)\n\tcase OP_AMD64_ICOMPARE_MEMBASE_REG:\n\t\treturn OP_AMD64_ICOMPARE_MEMBASE_IMM;\n#endif\n\tcase OP_VOIDCALL_REG:\n\t\treturn OP_VOIDCALL;\n\tcase OP_CALL_REG:\n\t\treturn OP_CALL;\n\tcase OP_LCALL_REG:\n\t\treturn OP_LCALL;\n\tcase OP_FCALL_REG:\n\t\treturn OP_FCALL;\n\tcase OP_LOCALLOC:\n\t\treturn OP_LOCALLOC_IMM;\n\t}\n\n\treturn -1;\n}\n\nstatic int\nstind_to_store_membase (int opcode)\n{\n\tswitch (opcode) {\n\tcase MONO_CEE_STIND_I1:\n\t\treturn OP_STOREI1_MEMBASE_REG;\n\tcase MONO_CEE_STIND_I2:\n\t\treturn OP_STOREI2_MEMBASE_REG;\n\tcase MONO_CEE_STIND_I4:\n\t\treturn OP_STOREI4_MEMBASE_REG;\n\tcase MONO_CEE_STIND_I:\n\tcase MONO_CEE_STIND_REF:\n\t\treturn OP_STORE_MEMBASE_REG;\n\tcase MONO_CEE_STIND_I8:\n\t\treturn OP_STOREI8_MEMBASE_REG;\n\tcase MONO_CEE_STIND_R4:\n\t\treturn OP_STORER4_MEMBASE_REG;\n\tcase MONO_CEE_STIND_R8:\n\t\treturn OP_STORER8_MEMBASE_REG;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\treturn -1;\n}\n\nint\nmono_load_membase_to_load_mem (int opcode)\n{\n\t// FIXME: Add a MONO_ARCH_HAVE_LOAD_MEM macro\n#if defined(TARGET_X86) || defined(TARGET_AMD64)\n\tswitch (opcode) {\n\tcase OP_LOAD_MEMBASE:\n\t\treturn OP_LOAD_MEM;\n\tcase OP_LOADU1_MEMBASE:\n\t\treturn OP_LOADU1_MEM;\n\tcase OP_LOADU2_MEMBASE:\n\t\treturn OP_LOADU2_MEM;\n\tcase OP_LOADI4_MEMBASE:\n\t\treturn OP_LOADI4_MEM;\n\tcase OP_LOADU4_MEMBASE:\n\t\treturn OP_LOADU4_MEM;\n#if SIZEOF_REGISTER == 8\n\tcase OP_LOADI8_MEMBASE:\n\t\treturn OP_LOADI8_MEM;\n#endif\n\t}\n#endif\n\n\treturn -1;\n}\n\nstatic int\nop_to_op_dest_membase (int store_opcode, int opcode)\n{\n#if defined(TARGET_X86)\n\tif (!((store_opcode == OP_STORE_MEMBASE_REG) || (store_opcode == OP_STOREI4_MEMBASE_REG)))\n\t\treturn -1;\n\n\tswitch (opcode) {\n\tcase OP_IADD:\n\t\treturn OP_X86_ADD_MEMBASE_REG;\n\tcase OP_ISUB:\n\t\treturn OP_X86_SUB_MEMBASE_REG;\n\tcase OP_IAND:\n\t\treturn OP_X86_AND_MEMBASE_REG;\n\tcase OP_IOR:\n\t\treturn OP_X86_OR_MEMBASE_REG;\n\tcase OP_IXOR:\n\t\treturn OP_X86_XOR_MEMBASE_REG;\n\tcase OP_ADD_IMM:\n\tcase OP_IADD_IMM:\n\t\treturn OP_X86_ADD_MEMBASE_IMM;\n\tcase OP_SUB_IMM:\n\tcase OP_ISUB_IMM:\n\t\treturn OP_X86_SUB_MEMBASE_IMM;\n\tcase OP_AND_IMM:\n\tcase OP_IAND_IMM:\n\t\treturn OP_X86_AND_MEMBASE_IMM;\n\tcase OP_OR_IMM:\n\tcase OP_IOR_IMM:\n\t\treturn OP_X86_OR_MEMBASE_IMM;\n\tcase OP_XOR_IMM:\n\tcase OP_IXOR_IMM:\n\t\treturn OP_X86_XOR_MEMBASE_IMM;\n\tcase OP_MOVE:\n\t\treturn OP_NOP;\n\t}\n#endif\n\n#if defined(TARGET_AMD64)\n\tif (!((store_opcode == OP_STORE_MEMBASE_REG) || (store_opcode == OP_STOREI4_MEMBASE_REG) || (store_opcode == OP_STOREI8_MEMBASE_REG)))\n\t\treturn -1;\n\n\tswitch (opcode) {\n\tcase OP_IADD:\n\t\treturn OP_X86_ADD_MEMBASE_REG;\n\tcase OP_ISUB:\n\t\treturn OP_X86_SUB_MEMBASE_REG;\n\tcase OP_IAND:\n\t\treturn OP_X86_AND_MEMBASE_REG;\n\tcase OP_IOR:\n\t\treturn OP_X86_OR_MEMBASE_REG;\n\tcase OP_IXOR:\n\t\treturn OP_X86_XOR_MEMBASE_REG;\n\tcase OP_IADD_IMM:\n\t\treturn OP_X86_ADD_MEMBASE_IMM;\n\tcase OP_ISUB_IMM:\n\t\treturn OP_X86_SUB_MEMBASE_IMM;\n\tcase OP_IAND_IMM:\n\t\treturn OP_X86_AND_MEMBASE_IMM;\n\tcase OP_IOR_IMM:\n\t\treturn OP_X86_OR_MEMBASE_IMM;\n\tcase OP_IXOR_IMM:\n\t\treturn OP_X86_XOR_MEMBASE_IMM;\n\tcase OP_LADD:\n\t\treturn OP_AMD64_ADD_MEMBASE_REG;\n\tcase OP_LSUB:\n\t\treturn OP_AMD64_SUB_MEMBASE_REG;\n\tcase OP_LAND:\n\t\treturn OP_AMD64_AND_MEMBASE_REG;\n\tcase OP_LOR:\n\t\treturn OP_AMD64_OR_MEMBASE_REG;\n\tcase OP_LXOR:\n\t\treturn OP_AMD64_XOR_MEMBASE_REG;\n\tcase OP_ADD_IMM:\n\tcase OP_LADD_IMM:\n\t\treturn OP_AMD64_ADD_MEMBASE_IMM;\n\tcase OP_SUB_IMM:\n\tcase OP_LSUB_IMM:\n\t\treturn OP_AMD64_SUB_MEMBASE_IMM;\n\tcase OP_AND_IMM:\n\tcase OP_LAND_IMM:\n\t\treturn OP_AMD64_AND_MEMBASE_IMM;\n\tcase OP_OR_IMM:\n\tcase OP_LOR_IMM:\n\t\treturn OP_AMD64_OR_MEMBASE_IMM;\n\tcase OP_XOR_IMM:\n\tcase OP_LXOR_IMM:\n\t\treturn OP_AMD64_XOR_MEMBASE_IMM;\n\tcase OP_MOVE:\n\t\treturn OP_NOP;\n\t}\n#endif\n\n\treturn -1;\n}\n\nstatic int\nop_to_op_store_membase (int store_opcode, int opcode)\n{\n#if defined(TARGET_X86) || defined(TARGET_AMD64)\n\tswitch (opcode) {\n\tcase OP_ICEQ:\n\t\tif (store_opcode == OP_STOREI1_MEMBASE_REG)\n\t\t\treturn OP_X86_SETEQ_MEMBASE;\n\tcase OP_CNE:\n\t\tif (store_opcode == OP_STOREI1_MEMBASE_REG)\n\t\t\treturn OP_X86_SETNE_MEMBASE;\n\t}\n#endif\n\n\treturn -1;\n}\n\nstatic int\nop_to_op_src1_membase (MonoCompile *cfg, int load_opcode, int opcode)\n{\n#ifdef TARGET_X86\n\t/* FIXME: This has sign extension issues */\n\t/*\n\tif ((opcode == OP_ICOMPARE_IMM) && (load_opcode == OP_LOADU1_MEMBASE))\n\t\treturn OP_X86_COMPARE_MEMBASE8_IMM;\n\t*/\n\n\tif (!((load_opcode == OP_LOAD_MEMBASE) || (load_opcode == OP_LOADI4_MEMBASE) || (load_opcode == OP_LOADU4_MEMBASE)))\n\t\treturn -1;\n\n\tswitch (opcode) {\n\tcase OP_X86_PUSH:\n\t\treturn OP_X86_PUSH_MEMBASE;\n\tcase OP_COMPARE_IMM:\n\tcase OP_ICOMPARE_IMM:\n\t\treturn OP_X86_COMPARE_MEMBASE_IMM;\n\tcase OP_COMPARE:\n\tcase OP_ICOMPARE:\n\t\treturn OP_X86_COMPARE_MEMBASE_REG;\n\t}\n#endif\n\n#ifdef TARGET_AMD64\n\t/* FIXME: This has sign extension issues */\n\t/*\n\tif ((opcode == OP_ICOMPARE_IMM) && (load_opcode == OP_LOADU1_MEMBASE))\n\t\treturn OP_X86_COMPARE_MEMBASE8_IMM;\n\t*/\n\n\tswitch (opcode) {\n\tcase OP_X86_PUSH:\n\t\tif ((load_opcode == OP_LOAD_MEMBASE && !cfg->backend->ilp32) || (load_opcode == OP_LOADI8_MEMBASE))\n\t\t\treturn OP_X86_PUSH_MEMBASE;\n\t\tbreak;\n\t\t/* FIXME: This only works for 32 bit immediates\n\tcase OP_COMPARE_IMM:\n\tcase OP_LCOMPARE_IMM:\n\t\tif ((load_opcode == OP_LOAD_MEMBASE) || (load_opcode == OP_LOADI8_MEMBASE))\n\t\t\treturn OP_AMD64_COMPARE_MEMBASE_IMM;\n\t\t*/\n\tcase OP_ICOMPARE_IMM:\n\t\tif ((load_opcode == OP_LOADI4_MEMBASE) || (load_opcode == OP_LOADU4_MEMBASE))\n\t\t\treturn OP_AMD64_ICOMPARE_MEMBASE_IMM;\n\t\tbreak;\n\tcase OP_COMPARE:\n\tcase OP_LCOMPARE:\n\t\tif (cfg->backend->ilp32 && load_opcode == OP_LOAD_MEMBASE)\n\t\t\treturn OP_AMD64_ICOMPARE_MEMBASE_REG;\n\t\tif ((load_opcode == OP_LOAD_MEMBASE && !cfg->backend->ilp32) || (load_opcode == OP_LOADI8_MEMBASE))\n\t\t\treturn OP_AMD64_COMPARE_MEMBASE_REG;\n\t\tbreak;\n\tcase OP_ICOMPARE:\n\t\tif ((load_opcode == OP_LOADI4_MEMBASE) || (load_opcode == OP_LOADU4_MEMBASE))\n\t\t\treturn OP_AMD64_ICOMPARE_MEMBASE_REG;\n\t\tbreak;\n\t}\n#endif\n\n\treturn -1;\n}\n\nstatic int\nop_to_op_src2_membase (MonoCompile *cfg, int load_opcode, int opcode)\n{\n#ifdef TARGET_X86\n\tif (!((load_opcode == OP_LOAD_MEMBASE) || (load_opcode == OP_LOADI4_MEMBASE) || (load_opcode == OP_LOADU4_MEMBASE)))\n\t\treturn -1;\n\t\n\tswitch (opcode) {\n\tcase OP_COMPARE:\n\tcase OP_ICOMPARE:\n\t\treturn OP_X86_COMPARE_REG_MEMBASE;\n\tcase OP_IADD:\n\t\treturn OP_X86_ADD_REG_MEMBASE;\n\tcase OP_ISUB:\n\t\treturn OP_X86_SUB_REG_MEMBASE;\n\tcase OP_IAND:\n\t\treturn OP_X86_AND_REG_MEMBASE;\n\tcase OP_IOR:\n\t\treturn OP_X86_OR_REG_MEMBASE;\n\tcase OP_IXOR:\n\t\treturn OP_X86_XOR_REG_MEMBASE;\n\t}\n#endif\n\n#ifdef TARGET_AMD64\n\tif ((load_opcode == OP_LOADI4_MEMBASE) || (load_opcode == OP_LOADU4_MEMBASE) || (load_opcode == OP_LOAD_MEMBASE && cfg->backend->ilp32)) {\n\t\tswitch (opcode) {\n\t\tcase OP_ICOMPARE:\n\t\t\treturn OP_AMD64_ICOMPARE_REG_MEMBASE;\n\t\tcase OP_IADD:\n\t\t\treturn OP_X86_ADD_REG_MEMBASE;\n\t\tcase OP_ISUB:\n\t\t\treturn OP_X86_SUB_REG_MEMBASE;\n\t\tcase OP_IAND:\n\t\t\treturn OP_X86_AND_REG_MEMBASE;\n\t\tcase OP_IOR:\n\t\t\treturn OP_X86_OR_REG_MEMBASE;\n\t\tcase OP_IXOR:\n\t\t\treturn OP_X86_XOR_REG_MEMBASE;\n\t\t}\n\t} else if ((load_opcode == OP_LOADI8_MEMBASE) || (load_opcode == OP_LOAD_MEMBASE && !cfg->backend->ilp32)) {\n\t\tswitch (opcode) {\n\t\tcase OP_COMPARE:\n\t\tcase OP_LCOMPARE:\n\t\t\treturn OP_AMD64_COMPARE_REG_MEMBASE;\n\t\tcase OP_LADD:\n\t\t\treturn OP_AMD64_ADD_REG_MEMBASE;\n\t\tcase OP_LSUB:\n\t\t\treturn OP_AMD64_SUB_REG_MEMBASE;\n\t\tcase OP_LAND:\n\t\t\treturn OP_AMD64_AND_REG_MEMBASE;\n\t\tcase OP_LOR:\n\t\t\treturn OP_AMD64_OR_REG_MEMBASE;\n\t\tcase OP_LXOR:\n\t\t\treturn OP_AMD64_XOR_REG_MEMBASE;\n\t\t}\n\t}\n#endif\n\n\treturn -1;\n}\n\nint\nmono_op_to_op_imm_noemul (int opcode)\n{\n\tswitch (opcode) {\n#if SIZEOF_REGISTER == 4 && !defined(MONO_ARCH_NO_EMULATE_LONG_SHIFT_OPS)\n\tcase OP_LSHR:\n\tcase OP_LSHL:\n\tcase OP_LSHR_UN:\n\t\treturn -1;\n#endif\n#if defined(MONO_ARCH_EMULATE_MUL_DIV) || defined(MONO_ARCH_EMULATE_DIV)\n\tcase OP_IDIV:\n\tcase OP_IDIV_UN:\n\tcase OP_IREM:\n\tcase OP_IREM_UN:\n\t\treturn -1;\n#endif\n#if defined(MONO_ARCH_EMULATE_MUL_DIV)\n\tcase OP_IMUL:\n\t\treturn -1;\n#endif\n\tdefault:\n\t\treturn mono_op_to_op_imm (opcode);\n\t}\n}\n\n/**\n * mono_handle_global_vregs:\n *\n *   Make vregs used in more than one bblock 'global', i.e. allocate a variable\n * for them.\n */\nvoid\nmono_handle_global_vregs (MonoCompile *cfg)\n{\n\tgint32 *vreg_to_bb;\n\tMonoBasicBlock *bb;\n\tint i, pos;\n\n\tvreg_to_bb = (gint32 *)mono_mempool_alloc0 (cfg->mempool, sizeof (gint32*) * cfg->next_vreg + 1);\n\n#ifdef MONO_ARCH_SIMD_INTRINSICS\n\tif (cfg->uses_simd_intrinsics & MONO_CFG_USES_SIMD_INTRINSICS_SIMPLIFY_INDIRECTION)\n\t\tmono_simd_simplify_indirection (cfg);\n#endif\n\n\t/* Find local vregs used in more than one bb */\n\tfor (bb = cfg->bb_entry; bb; bb = bb->next_bb) {\n\t\tMonoInst *ins = bb->code;\t\n\t\tint block_num = bb->block_num;\n\n\t\tif (cfg->verbose_level > 2)\n\t\t\tprintf (\"\\nHANDLE-GLOBAL-VREGS BLOCK %d:\\n\", bb->block_num);\n\n\t\tcfg->cbb = bb;\n\t\tfor (; ins; ins = ins->next) {\n\t\t\tconst char *spec = INS_INFO (ins->opcode);\n\t\t\tint regtype = 0, regindex;\n\t\t\tgint32 prev_bb;\n\n\t\t\tif (G_UNLIKELY (cfg->verbose_level > 2))\n\t\t\t\tmono_print_ins (ins);\n\n\t\t\tg_assert (ins->opcode >= MONO_CEE_LAST);\n\n\t\t\tfor (regindex = 0; regindex < 4; regindex ++) {\n\t\t\t\tint vreg = 0;\n\n\t\t\t\tif (regindex == 0) {\n\t\t\t\t\tregtype = spec [MONO_INST_DEST];\n\t\t\t\t\tif (regtype == ' ')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvreg = ins->dreg;\n\t\t\t\t} else if (regindex == 1) {\n\t\t\t\t\tregtype = spec [MONO_INST_SRC1];\n\t\t\t\t\tif (regtype == ' ')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvreg = ins->sreg1;\n\t\t\t\t} else if (regindex == 2) {\n\t\t\t\t\tregtype = spec [MONO_INST_SRC2];\n\t\t\t\t\tif (regtype == ' ')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvreg = ins->sreg2;\n\t\t\t\t} else if (regindex == 3) {\n\t\t\t\t\tregtype = spec [MONO_INST_SRC3];\n\t\t\t\t\tif (regtype == ' ')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvreg = ins->sreg3;\n\t\t\t\t}\n\n#if SIZEOF_REGISTER == 4\n\t\t\t\t/* In the LLVM case, the long opcodes are not decomposed */\n\t\t\t\tif (regtype == 'l' && !COMPILE_LLVM (cfg)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Since some instructions reference the original long vreg,\n\t\t\t\t\t * and some reference the two component vregs, it is quite hard\n\t\t\t\t\t * to determine when it needs to be global. So be conservative.\n\t\t\t\t\t */\n\t\t\t\t\tif (!get_vreg_to_inst (cfg, vreg)) {\n\t\t\t\t\t\tmono_compile_create_var_for_vreg (cfg, m_class_get_byval_arg (mono_defaults.int64_class), OP_LOCAL, vreg);\n\n\t\t\t\t\t\tif (cfg->verbose_level > 2)\n\t\t\t\t\t\t\tprintf (\"LONG VREG R%d made global.\\n\", vreg);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Make the component vregs volatile since the optimizations can\n\t\t\t\t\t * get confused otherwise.\n\t\t\t\t\t */\n\t\t\t\t\tget_vreg_to_inst (cfg, MONO_LVREG_LS (vreg))->flags |= MONO_INST_VOLATILE;\n\t\t\t\t\tget_vreg_to_inst (cfg, MONO_LVREG_MS (vreg))->flags |= MONO_INST_VOLATILE;\n\t\t\t\t}\n#endif\n\n\t\t\t\tg_assert (vreg != -1);\n\n\t\t\t\tprev_bb = vreg_to_bb [vreg];\n\t\t\t\tif (prev_bb == 0) {\n\t\t\t\t\t/* 0 is a valid block num */\n\t\t\t\t\tvreg_to_bb [vreg] = block_num + 1;\n\t\t\t\t} else if ((prev_bb != block_num + 1) && (prev_bb != -1)) {\n\t\t\t\t\tif (((regtype == 'i' && (vreg < MONO_MAX_IREGS))) || (regtype == 'f' && (vreg < MONO_MAX_FREGS)))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (!get_vreg_to_inst (cfg, vreg)) {\n\t\t\t\t\t\tif (G_UNLIKELY (cfg->verbose_level > 2))\n\t\t\t\t\t\t\tprintf (\"VREG R%d used in BB%d and BB%d made global.\\n\", vreg, vreg_to_bb [vreg], block_num);\n\n\t\t\t\t\t\tswitch (regtype) {\n\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\tif (vreg_is_ref (cfg, vreg))\n\t\t\t\t\t\t\t\tmono_compile_create_var_for_vreg (cfg, mono_get_object_type (), OP_LOCAL, vreg);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tmono_compile_create_var_for_vreg (cfg, mono_get_int_type (), OP_LOCAL, vreg);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\tmono_compile_create_var_for_vreg (cfg, m_class_get_byval_arg (mono_defaults.int64_class), OP_LOCAL, vreg);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\tmono_compile_create_var_for_vreg (cfg, m_class_get_byval_arg (mono_defaults.double_class), OP_LOCAL, vreg);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tcase 'x':\n\t\t\t\t\t\t\tmono_compile_create_var_for_vreg (cfg, m_class_get_byval_arg (ins->klass), OP_LOCAL, vreg);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Flag as having been used in more than one bb */\n\t\t\t\t\tvreg_to_bb [vreg] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If a variable is used in only one bblock, convert it into a local vreg */\n\tfor (i = 0; i < cfg->num_varinfo; i++) {\n\t\tMonoInst *var = cfg->varinfo [i];\n\t\tMonoMethodVar *vmv = MONO_VARINFO (cfg, i);\n\n\t\tswitch (var->type) {\n\t\tcase STACK_I4:\n\t\tcase STACK_OBJ:\n\t\tcase STACK_PTR:\n\t\tcase STACK_MP:\n\t\tcase STACK_VTYPE:\n#if SIZEOF_REGISTER == 8\n\t\tcase STACK_I8:\n#endif\n#if !defined(TARGET_X86)\n\t\t/* Enabling this screws up the fp stack on x86 */\n\t\tcase STACK_R8:\n#endif\n\t\t\tif (mono_arch_is_soft_float ())\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\tif (var->type == STACK_VTYPE && cfg->gsharedvt && mini_is_gsharedvt_variable_type (var->inst_vtype))\n\t\t\t\tbreak;\n\t\t\t*/\n\n\t\t\t/* Arguments are implicitly global */\n\t\t\t/* Putting R4 vars into registers doesn't work currently */\n\t\t\t/* The gsharedvt vars are implicitly referenced by ldaddr opcodes, but those opcodes are only generated later */\n\t\t\tif ((var->opcode != OP_ARG) && (var != cfg->ret) && !(var->flags & (MONO_INST_VOLATILE|MONO_INST_INDIRECT)) && (vreg_to_bb [var->dreg] != -1) && (m_class_get_byval_arg (var->klass)->type != MONO_TYPE_R4) && !cfg->disable_vreg_to_lvreg && var != cfg->gsharedvt_info_var && var != cfg->gsharedvt_locals_var && var != cfg->lmf_addr_var) {\n\t\t\t\t/* \n\t\t\t\t * Make that the variable's liveness interval doesn't contain a call, since\n\t\t\t\t * that would cause the lvreg to be spilled, making the whole optimization\n\t\t\t\t * useless.\n\t\t\t\t */\n\t\t\t\t/* This is too slow for JIT compilation */\n#if 0\n\t\t\t\tif (cfg->compile_aot && vreg_to_bb [var->dreg]) {\n\t\t\t\t\tMonoInst *ins;\n\t\t\t\t\tint def_index, call_index, ins_index;\n\t\t\t\t\tgboolean spilled = FALSE;\n\n\t\t\t\t\tdef_index = -1;\n\t\t\t\t\tcall_index = -1;\n\t\t\t\t\tins_index = 0;\n\t\t\t\t\tfor (ins = vreg_to_bb [var->dreg]->code; ins; ins = ins->next) {\n\t\t\t\t\t\tconst char *spec = INS_INFO (ins->opcode);\n\n\t\t\t\t\t\tif ((spec [MONO_INST_DEST] != ' ') && (ins->dreg == var->dreg))\n\t\t\t\t\t\t\tdef_index = ins_index;\n\n\t\t\t\t\t\tif (((spec [MONO_INST_SRC1] != ' ') && (ins->sreg1 == var->dreg)) ||\n\t\t\t\t\t\t\t((spec [MONO_INST_SRC1] != ' ') && (ins->sreg1 == var->dreg))) {\n\t\t\t\t\t\t\tif (call_index > def_index) {\n\t\t\t\t\t\t\t\tspilled = TRUE;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (MONO_IS_CALL (ins))\n\t\t\t\t\t\t\tcall_index = ins_index;\n\n\t\t\t\t\t\tins_index ++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (spilled)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\n\t\t\t\tif (G_UNLIKELY (cfg->verbose_level > 2))\n\t\t\t\t\tprintf (\"CONVERTED R%d(%d) TO VREG.\\n\", var->dreg, vmv->idx);\n\t\t\t\tvar->flags |= MONO_INST_IS_DEAD;\n\t\t\t\tcfg->vreg_to_inst [var->dreg] = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* \n\t * Compress the varinfo and vars tables so the liveness computation is faster and\n\t * takes up less space.\n\t */\n\tpos = 0;\n\tfor (i = 0; i < cfg->num_varinfo; ++i) {\n\t\tMonoInst *var = cfg->varinfo [i];\n\t\tif (pos < i && cfg->locals_start == i)\n\t\t\tcfg->locals_start = pos;\n\t\tif (!(var->flags & MONO_INST_IS_DEAD)) {\n\t\t\tif (pos < i) {\n\t\t\t\tcfg->varinfo [pos] = cfg->varinfo [i];\n\t\t\t\tcfg->varinfo [pos]->inst_c0 = pos;\n\t\t\t\tmemcpy (&cfg->vars [pos], &cfg->vars [i], sizeof (MonoMethodVar));\n\t\t\t\tcfg->vars [pos].idx = pos;\n#if SIZEOF_REGISTER == 4\n\t\t\t\tif (cfg->varinfo [pos]->type == STACK_I8) {\n\t\t\t\t\t/* Modify the two component vars too */\n\t\t\t\t\tMonoInst *var1;\n\n\t\t\t\t\tvar1 = get_vreg_to_inst (cfg, MONO_LVREG_LS (cfg->varinfo [pos]->dreg));\n\t\t\t\t\tvar1->inst_c0 = pos;\n\t\t\t\t\tvar1 = get_vreg_to_inst (cfg, MONO_LVREG_MS (cfg->varinfo [pos]->dreg));\n\t\t\t\t\tvar1->inst_c0 = pos;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tpos ++;\n\t\t}\n\t}\n\tcfg->num_varinfo = pos;\n\tif (cfg->locals_start > cfg->num_varinfo)\n\t\tcfg->locals_start = cfg->num_varinfo;\n}\n\n/*\n * mono_allocate_gsharedvt_vars:\n *\n *   Allocate variables with gsharedvt types to entries in the MonoGSharedVtMethodRuntimeInfo.entries array.\n * Initialize cfg->gsharedvt_vreg_to_idx with the mapping between vregs and indexes.\n */\nvoid\nmono_allocate_gsharedvt_vars (MonoCompile *cfg)\n{\n\tint i;\n\n\tcfg->gsharedvt_vreg_to_idx = (int *)mono_mempool_alloc0 (cfg->mempool, sizeof (int) * cfg->next_vreg);\n\n\tfor (i = 0; i < cfg->num_varinfo; ++i) {\n\t\tMonoInst *ins = cfg->varinfo [i];\n\t\tint idx;\n\n\t\tif (mini_is_gsharedvt_variable_type (ins->inst_vtype)) {\n\t\t\tif (i >= cfg->locals_start) {\n\t\t\t\t/* Local */\n\t\t\t\tidx = get_gsharedvt_info_slot (cfg, ins->inst_vtype, MONO_RGCTX_INFO_LOCAL_OFFSET);\n\t\t\t\tcfg->gsharedvt_vreg_to_idx [ins->dreg] = idx + 1;\n\t\t\t\tins->opcode = OP_GSHAREDVT_LOCAL;\n\t\t\t\tins->inst_imm = idx;\n\t\t\t} else {\n\t\t\t\t/* Arg */\n\t\t\t\tcfg->gsharedvt_vreg_to_idx [ins->dreg] = -1;\n\t\t\t\tins->opcode = OP_GSHAREDVT_ARG_REGOFFSET;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * mono_spill_global_vars:\n *\n *   Generate spill code for variables which are not allocated to registers, \n * and replace vregs with their allocated hregs. *need_local_opts is set to TRUE if\n * code is generated which could be optimized by the local optimization passes.\n */\nvoid\nmono_spill_global_vars (MonoCompile *cfg, gboolean *need_local_opts)\n{\n\tMonoBasicBlock *bb;\n\tchar spec2 [16];\n\tint orig_next_vreg;\n\tguint32 *vreg_to_lvreg;\n\tguint32 *lvregs;\n\tguint32 i, lvregs_len, lvregs_size;\n\tgboolean dest_has_lvreg = FALSE;\n\tMonoStackType stacktypes [128];\n\tMonoInst **live_range_start, **live_range_end;\n\tMonoBasicBlock **live_range_start_bb, **live_range_end_bb;\n\n\t*need_local_opts = FALSE;\n\n\tmemset (spec2, 0, sizeof (spec2));\n\n\t/* FIXME: Move this function to mini.c */\n\tstacktypes [(int)'i'] = STACK_PTR;\n\tstacktypes [(int)'l'] = STACK_I8;\n\tstacktypes [(int)'f'] = STACK_R8;\n#ifdef MONO_ARCH_SIMD_INTRINSICS\n\tstacktypes [(int)'x'] = STACK_VTYPE;\n#endif\n\n#if SIZEOF_REGISTER == 4\n\t/* Create MonoInsts for longs */\n\tfor (i = 0; i < cfg->num_varinfo; i++) {\n\t\tMonoInst *ins = cfg->varinfo [i];\n\n\t\tif ((ins->opcode != OP_REGVAR) && !(ins->flags & MONO_INST_IS_DEAD)) {\n\t\t\tswitch (ins->type) {\n\t\t\tcase STACK_R8:\n\t\t\tcase STACK_I8: {\n\t\t\t\tMonoInst *tree;\n\n\t\t\t\tif (ins->type == STACK_R8 && !COMPILE_SOFT_FLOAT (cfg))\n\t\t\t\t\tbreak;\n\n\t\t\t\tg_assert (ins->opcode == OP_REGOFFSET);\n\n\t\t\t\ttree = get_vreg_to_inst (cfg, MONO_LVREG_LS (ins->dreg));\n\t\t\t\tg_assert (tree);\n\t\t\t\ttree->opcode = OP_REGOFFSET;\n\t\t\t\ttree->inst_basereg = ins->inst_basereg;\n\t\t\t\ttree->inst_offset = ins->inst_offset + MINI_LS_WORD_OFFSET;\n\n\t\t\t\ttree = get_vreg_to_inst (cfg, MONO_LVREG_MS (ins->dreg));\n\t\t\t\tg_assert (tree);\n\t\t\t\ttree->opcode = OP_REGOFFSET;\n\t\t\t\ttree->inst_basereg = ins->inst_basereg;\n\t\t\t\ttree->inst_offset = ins->inst_offset + MINI_MS_WORD_OFFSET;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (cfg->compute_gc_maps) {\n\t\t/* registers need liveness info even for !non refs */\n\t\tfor (i = 0; i < cfg->num_varinfo; i++) {\n\t\t\tMonoInst *ins = cfg->varinfo [i];\n\n\t\t\tif (ins->opcode == OP_REGVAR)\n\t\t\t\tins->flags |= MONO_INST_GC_TRACK;\n\t\t}\n\t}\n\t\t\n\t/* FIXME: widening and truncation */\n\n\t/*\n\t * As an optimization, when a variable allocated to the stack is first loaded into \n\t * an lvreg, we will remember the lvreg and use it the next time instead of loading\n\t * the variable again.\n\t */\n\torig_next_vreg = cfg->next_vreg;\n\tvreg_to_lvreg = (guint32 *)mono_mempool_alloc0 (cfg->mempool, sizeof (guint32) * cfg->next_vreg);\n\tlvregs_size = 1024;\n\tlvregs = (guint32 *)mono_mempool_alloc (cfg->mempool, sizeof (guint32) * lvregs_size);\n\tlvregs_len = 0;\n\n\t/* \n\t * These arrays contain the first and last instructions accessing a given\n\t * variable.\n\t * Since we emit bblocks in the same order we process them here, and we\n\t * don't split live ranges, these will precisely describe the live range of\n\t * the variable, i.e. the instruction range where a valid value can be found\n\t * in the variables location.\n\t * The live range is computed using the liveness info computed by the liveness pass.\n\t * We can't use vmv->range, since that is an abstract live range, and we need\n\t * one which is instruction precise.\n\t * FIXME: Variables used in out-of-line bblocks have a hole in their live range.\n\t */\n\t/* FIXME: Only do this if debugging info is requested */\n\tlive_range_start = g_new0 (MonoInst*, cfg->next_vreg);\n\tlive_range_end = g_new0 (MonoInst*, cfg->next_vreg);\n\tlive_range_start_bb = g_new (MonoBasicBlock*, cfg->next_vreg);\n\tlive_range_end_bb = g_new (MonoBasicBlock*, cfg->next_vreg);\n\t\n\t/* Add spill loads/stores */\n\tfor (bb = cfg->bb_entry; bb; bb = bb->next_bb) {\n\t\tMonoInst *ins;\n\n\t\tif (cfg->verbose_level > 2)\n\t\t\tprintf (\"\\nSPILL BLOCK %d:\\n\", bb->block_num);\n\n\t\t/* Clear vreg_to_lvreg array */\n\t\tfor (i = 0; i < lvregs_len; i++)\n\t\t\tvreg_to_lvreg [lvregs [i]] = 0;\n\t\tlvregs_len = 0;\n\n\t\tcfg->cbb = bb;\n\t\tMONO_BB_FOR_EACH_INS (bb, ins) {\n\t\t\tconst char *spec = INS_INFO (ins->opcode);\n\t\t\tint regtype, srcindex, sreg, tmp_reg, prev_dreg, num_sregs;\n\t\t\tgboolean store, no_lvreg;\n\t\t\tint sregs [MONO_MAX_SRC_REGS];\n\n\t\t\tif (G_UNLIKELY (cfg->verbose_level > 2))\n\t\t\t\tmono_print_ins (ins);\n\n\t\t\tif (ins->opcode == OP_NOP)\n\t\t\t\tcontinue;\n\n\t\t\t/* \n\t\t\t * We handle LDADDR here as well, since it can only be decomposed\n\t\t\t * when variable addresses are known.\n\t\t\t */\n\t\t\tif (ins->opcode == OP_LDADDR) {\n\t\t\t\tMonoInst *var = (MonoInst *)ins->inst_p0;\n\n\t\t\t\tif (var->opcode == OP_VTARG_ADDR) {\n\t\t\t\t\t/* Happens on SPARC/S390 where vtypes are passed by reference */\n\t\t\t\t\tMonoInst *vtaddr = var->inst_left;\n\t\t\t\t\tif (vtaddr->opcode == OP_REGVAR) {\n\t\t\t\t\t\tins->opcode = OP_MOVE;\n\t\t\t\t\t\tins->sreg1 = vtaddr->dreg;\n\t\t\t\t\t}\n\t\t\t\t\telse if (var->inst_left->opcode == OP_REGOFFSET) {\n\t\t\t\t\t\tins->opcode = OP_LOAD_MEMBASE;\n\t\t\t\t\t\tins->inst_basereg = vtaddr->inst_basereg;\n\t\t\t\t\t\tins->inst_offset = vtaddr->inst_offset;\n\t\t\t\t\t} else\n\t\t\t\t\t\tNOT_IMPLEMENTED;\n\t\t\t\t} else if (cfg->gsharedvt && cfg->gsharedvt_vreg_to_idx [var->dreg] < 0) {\n\t\t\t\t\t/* gsharedvt arg passed by ref */\n\t\t\t\t\tg_assert (var->opcode == OP_GSHAREDVT_ARG_REGOFFSET);\n\n\t\t\t\t\tins->opcode = OP_LOAD_MEMBASE;\n\t\t\t\t\tins->inst_basereg = var->inst_basereg;\n\t\t\t\t\tins->inst_offset = var->inst_offset;\n\t\t\t\t} else if (cfg->gsharedvt && cfg->gsharedvt_vreg_to_idx [var->dreg]) {\n\t\t\t\t\tMonoInst *load, *load2, *load3;\n\t\t\t\t\tint idx = cfg->gsharedvt_vreg_to_idx [var->dreg] - 1;\n\t\t\t\t\tint reg1, reg2, reg3;\n\t\t\t\t\tMonoInst *info_var = cfg->gsharedvt_info_var;\n\t\t\t\t\tMonoInst *locals_var = cfg->gsharedvt_locals_var;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * gsharedvt local.\n\t\t\t\t\t * Compute the address of the local as gsharedvt_locals_var + gsharedvt_info_var->locals_offsets [idx].\n\t\t\t\t\t */\n\n\t\t\t\t\tg_assert (var->opcode == OP_GSHAREDVT_LOCAL);\n\n\t\t\t\t\tg_assert (info_var);\n\t\t\t\t\tg_assert (locals_var);\n\n\t\t\t\t\t/* Mark the instruction used to compute the locals var as used */\n\t\t\t\t\tcfg->gsharedvt_locals_var_ins = NULL;\n\n\t\t\t\t\t/* Load the offset */\n\t\t\t\t\tif (info_var->opcode == OP_REGOFFSET) {\n\t\t\t\t\t\treg1 = alloc_ireg (cfg);\n\t\t\t\t\t\tNEW_LOAD_MEMBASE (cfg, load, OP_LOAD_MEMBASE, reg1, info_var->inst_basereg, info_var->inst_offset);\n\t\t\t\t\t} else if (info_var->opcode == OP_REGVAR) {\n\t\t\t\t\t\tload = NULL;\n\t\t\t\t\t\treg1 = info_var->dreg;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t\t}\n\t\t\t\t\treg2 = alloc_ireg (cfg);\n\t\t\t\t\tNEW_LOAD_MEMBASE (cfg, load2, OP_LOADI4_MEMBASE, reg2, reg1, MONO_STRUCT_OFFSET (MonoGSharedVtMethodRuntimeInfo, entries) + (idx * TARGET_SIZEOF_VOID_P));\n\t\t\t\t\t/* Load the locals area address */\n\t\t\t\t\treg3 = alloc_ireg (cfg);\n\t\t\t\t\tif (locals_var->opcode == OP_REGOFFSET) {\n\t\t\t\t\t\tNEW_LOAD_MEMBASE (cfg, load3, OP_LOAD_MEMBASE, reg3, locals_var->inst_basereg, locals_var->inst_offset);\n\t\t\t\t\t} else if (locals_var->opcode == OP_REGVAR) {\n\t\t\t\t\t\tNEW_UNALU (cfg, load3, OP_MOVE, reg3, locals_var->dreg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t\t}\n\t\t\t\t\t/* Compute the address */\n\t\t\t\t\tins->opcode = OP_PADD;\n\t\t\t\t\tins->sreg1 = reg3;\n\t\t\t\t\tins->sreg2 = reg2;\n\n\t\t\t\t\tmono_bblock_insert_before_ins (bb, ins, load3);\n\t\t\t\t\tmono_bblock_insert_before_ins (bb, load3, load2);\n\t\t\t\t\tif (load)\n\t\t\t\t\t\tmono_bblock_insert_before_ins (bb, load2, load);\n\t\t\t\t} else {\n\t\t\t\t\tg_assert (var->opcode == OP_REGOFFSET);\n\n\t\t\t\t\tins->opcode = OP_ADD_IMM;\n\t\t\t\t\tins->sreg1 = var->inst_basereg;\n\t\t\t\t\tins->inst_imm = var->inst_offset;\n\t\t\t\t}\n\n\t\t\t\t*need_local_opts = TRUE;\n\t\t\t\tspec = INS_INFO (ins->opcode);\n\t\t\t}\n\n\t\t\tif (ins->opcode < MONO_CEE_LAST) {\n\t\t\t\tmono_print_ins (ins);\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Store opcodes have destbasereg in the dreg, but in reality, it is an\n\t\t\t * src register.\n\t\t\t * FIXME:\n\t\t\t */\n\t\t\tif (MONO_IS_STORE_MEMBASE (ins)) {\n\t\t\t\ttmp_reg = ins->dreg;\n\t\t\t\tins->dreg = ins->sreg2;\n\t\t\t\tins->sreg2 = tmp_reg;\n\t\t\t\tstore = TRUE;\n\n\t\t\t\tspec2 [MONO_INST_DEST] = ' ';\n\t\t\t\tspec2 [MONO_INST_SRC1] = spec [MONO_INST_SRC1];\n\t\t\t\tspec2 [MONO_INST_SRC2] = spec [MONO_INST_DEST];\n\t\t\t\tspec2 [MONO_INST_SRC3] = ' ';\n\t\t\t\tspec = spec2;\n\t\t\t} else if (MONO_IS_STORE_MEMINDEX (ins))\n\t\t\t\tg_assert_not_reached ();\n\t\t\telse\n\t\t\t\tstore = FALSE;\n\t\t\tno_lvreg = FALSE;\n\n\t\t\tif (G_UNLIKELY (cfg->verbose_level > 2)) {\n\t\t\t\tprintf (\"\\t %.3s %d\", spec, ins->dreg);\n\t\t\t\tnum_sregs = mono_inst_get_src_registers (ins, sregs);\n\t\t\t\tfor (srcindex = 0; srcindex < num_sregs; ++srcindex)\n\t\t\t\t\tprintf (\" %d\", sregs [srcindex]);\n\t\t\t\tprintf (\"\\n\");\n\t\t\t}\n\n\t\t\t/***************/\n\t\t\t/*    DREG     */\n\t\t\t/***************/\n\t\t\tregtype = spec [MONO_INST_DEST];\n\t\t\tg_assert (((ins->dreg == -1) && (regtype == ' ')) || ((ins->dreg != -1) && (regtype != ' ')));\n\t\t\tprev_dreg = -1;\n\t\t\tint dreg_using_dest_to_membase_op = -1;\n\n\t\t\tif ((ins->dreg != -1) && get_vreg_to_inst (cfg, ins->dreg)) {\n\t\t\t\tMonoInst *var = get_vreg_to_inst (cfg, ins->dreg);\n\t\t\t\tMonoInst *store_ins;\n\t\t\t\tint store_opcode;\n\t\t\t\tMonoInst *def_ins = ins;\n\t\t\t\tint dreg = ins->dreg; /* The original vreg */\n\n\t\t\t\tstore_opcode = mono_type_to_store_membase (cfg, var->inst_vtype);\n\n\t\t\t\tif (var->opcode == OP_REGVAR) {\n\t\t\t\t\tins->dreg = var->dreg;\n\t\t\t\t} else if ((ins->dreg == ins->sreg1) && (spec [MONO_INST_DEST] == 'i') && (spec [MONO_INST_SRC1] == 'i') && !vreg_to_lvreg [ins->dreg] && (op_to_op_dest_membase (store_opcode, ins->opcode) != -1)) {\n\t\t\t\t\t/* \n\t\t\t\t\t * Instead of emitting a load+store, use a _membase opcode.\n\t\t\t\t\t */\n\t\t\t\t\tg_assert (var->opcode == OP_REGOFFSET);\n\t\t\t\t\tif (ins->opcode == OP_MOVE) {\n\t\t\t\t\t\tNULLIFY_INS (ins);\n\t\t\t\t\t\tdef_ins = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdreg_using_dest_to_membase_op = ins->dreg;\n\t\t\t\t\t\tins->opcode = op_to_op_dest_membase (store_opcode, ins->opcode);\n\t\t\t\t\t\tins->inst_basereg = var->inst_basereg;\n\t\t\t\t\t\tins->inst_offset = var->inst_offset;\n\t\t\t\t\t\tins->dreg = -1;\n\t\t\t\t\t}\n\t\t\t\t\tspec = INS_INFO (ins->opcode);\n\t\t\t\t} else {\n\t\t\t\t\tguint32 lvreg;\n\n\t\t\t\t\tg_assert (var->opcode == OP_REGOFFSET);\n\n\t\t\t\t\tprev_dreg = ins->dreg;\n\n\t\t\t\t\t/* Invalidate any previous lvreg for this vreg */\n\t\t\t\t\tvreg_to_lvreg [ins->dreg] = 0;\n\n\t\t\t\t\tlvreg = 0;\n\n\t\t\t\t\tif (COMPILE_SOFT_FLOAT (cfg) && store_opcode == OP_STORER8_MEMBASE_REG) {\n\t\t\t\t\t\tregtype = 'l';\n\t\t\t\t\t\tstore_opcode = OP_STOREI8_MEMBASE_REG;\n\t\t\t\t\t}\n\n\t\t\t\t\tins->dreg = alloc_dreg (cfg, stacktypes [regtype]);\n\n#if SIZEOF_REGISTER != 8\n\t\t\t\t\tif (regtype == 'l') {\n\t\t\t\t\t\tNEW_STORE_MEMBASE (cfg, store_ins, OP_STOREI4_MEMBASE_REG, var->inst_basereg, var->inst_offset + MINI_LS_WORD_OFFSET, MONO_LVREG_LS (ins->dreg));\n\t\t\t\t\t\tmono_bblock_insert_after_ins (bb, ins, store_ins);\n\t\t\t\t\t\tNEW_STORE_MEMBASE (cfg, store_ins, OP_STOREI4_MEMBASE_REG, var->inst_basereg, var->inst_offset + MINI_MS_WORD_OFFSET, MONO_LVREG_MS (ins->dreg));\n\t\t\t\t\t\tmono_bblock_insert_after_ins (bb, ins, store_ins);\n\t\t\t\t\t\tdef_ins = store_ins;\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tg_assert (store_opcode != OP_STOREV_MEMBASE);\n\n\t\t\t\t\t\t/* Try to fuse the store into the instruction itself */\n\t\t\t\t\t\t/* FIXME: Add more instructions */\n\t\t\t\t\t\tif (!lvreg && ((ins->opcode == OP_ICONST) || ((ins->opcode == OP_I8CONST) && (ins->inst_c0 == 0)))) {\n\t\t\t\t\t\t\tins->opcode = store_membase_reg_to_store_membase_imm (store_opcode);\n\t\t\t\t\t\t\tins->inst_imm = ins->inst_c0;\n\t\t\t\t\t\t\tins->inst_destbasereg = var->inst_basereg;\n\t\t\t\t\t\t\tins->inst_offset = var->inst_offset;\n\t\t\t\t\t\t\tspec = INS_INFO (ins->opcode);\n\t\t\t\t\t\t} else if (!lvreg && ((ins->opcode == OP_MOVE) || (ins->opcode == OP_FMOVE) || (ins->opcode == OP_LMOVE) || (ins->opcode == OP_RMOVE))) {\n\t\t\t\t\t\t\tins->opcode = store_opcode;\n\t\t\t\t\t\t\tins->inst_destbasereg = var->inst_basereg;\n\t\t\t\t\t\t\tins->inst_offset = var->inst_offset;\n\n\t\t\t\t\t\t\tno_lvreg = TRUE;\n\n\t\t\t\t\t\t\ttmp_reg = ins->dreg;\n\t\t\t\t\t\t\tins->dreg = ins->sreg2;\n\t\t\t\t\t\t\tins->sreg2 = tmp_reg;\n\t\t\t\t\t\t\tstore = TRUE;\n\n\t\t\t\t\t\t\tspec2 [MONO_INST_DEST] = ' ';\n\t\t\t\t\t\t\tspec2 [MONO_INST_SRC1] = spec [MONO_INST_SRC1];\n\t\t\t\t\t\t\tspec2 [MONO_INST_SRC2] = spec [MONO_INST_DEST];\n\t\t\t\t\t\t\tspec2 [MONO_INST_SRC3] = ' ';\n\t\t\t\t\t\t\tspec = spec2;\n\t\t\t\t\t\t} else if (!lvreg && (op_to_op_store_membase (store_opcode, ins->opcode) != -1)) {\n\t\t\t\t\t\t\t// FIXME: The backends expect the base reg to be in inst_basereg\n\t\t\t\t\t\t\tins->opcode = op_to_op_store_membase (store_opcode, ins->opcode);\n\t\t\t\t\t\t\tins->dreg = -1;\n\t\t\t\t\t\t\tins->inst_basereg = var->inst_basereg;\n\t\t\t\t\t\t\tins->inst_offset = var->inst_offset;\n\t\t\t\t\t\t\tspec = INS_INFO (ins->opcode);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* printf (\"INS: \"); mono_print_ins (ins); */\n\t\t\t\t\t\t\t/* Create a store instruction */\n\t\t\t\t\t\t\tNEW_STORE_MEMBASE (cfg, store_ins, store_opcode, var->inst_basereg, var->inst_offset, ins->dreg);\n\n\t\t\t\t\t\t\t/* Insert it after the instruction */\n\t\t\t\t\t\t\tmono_bblock_insert_after_ins (bb, ins, store_ins);\n\n\t\t\t\t\t\t\tdef_ins = store_ins;\n\n\t\t\t\t\t\t\t/* \n\t\t\t\t\t\t\t * We can't assign ins->dreg to var->dreg here, since the\n\t\t\t\t\t\t\t * sregs could use it. So set a flag, and do it after\n\t\t\t\t\t\t\t * the sregs.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((!cfg->backend->use_fpstack || ((store_opcode != OP_STORER8_MEMBASE_REG) && (store_opcode != OP_STORER4_MEMBASE_REG))) && !((var)->flags & (MONO_INST_VOLATILE|MONO_INST_INDIRECT)))\n\t\t\t\t\t\t\t\tdest_has_lvreg = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (def_ins && !live_range_start [dreg]) {\n\t\t\t\t\tlive_range_start [dreg] = def_ins;\n\t\t\t\t\tlive_range_start_bb [dreg] = bb;\n\t\t\t\t}\n\n\t\t\t\tif (cfg->compute_gc_maps && def_ins && (var->flags & MONO_INST_GC_TRACK)) {\n\t\t\t\t\tMonoInst *tmp;\n\n\t\t\t\t\tMONO_INST_NEW (cfg, tmp, OP_GC_LIVENESS_DEF);\n\t\t\t\t\ttmp->inst_c1 = dreg;\n\t\t\t\t\tmono_bblock_insert_after_ins (bb, def_ins, tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/************/\n\t\t\t/*  SREGS   */\n\t\t\t/************/\n\t\t\tnum_sregs = mono_inst_get_src_registers (ins, sregs);\n\t\t\tfor (srcindex = 0; srcindex < 3; ++srcindex) {\n\t\t\t\tregtype = spec [MONO_INST_SRC1 + srcindex];\n\t\t\t\tsreg = sregs [srcindex];\n\n\t\t\t\tg_assert (((sreg == -1) && (regtype == ' ')) || ((sreg != -1) && (regtype != ' ')));\n\t\t\t\tif ((sreg != -1) && get_vreg_to_inst (cfg, sreg)) {\n\t\t\t\t\tMonoInst *var = get_vreg_to_inst (cfg, sreg);\n\t\t\t\t\tMonoInst *use_ins = ins;\n\t\t\t\t\tMonoInst *load_ins;\n\t\t\t\t\tguint32 load_opcode;\n\n\t\t\t\t\tif (var->opcode == OP_REGVAR) {\n\t\t\t\t\t\tsregs [srcindex] = var->dreg;\n\t\t\t\t\t\t//mono_inst_set_src_registers (ins, sregs);\n\t\t\t\t\t\tlive_range_end [sreg] = use_ins;\n\t\t\t\t\t\tlive_range_end_bb [sreg] = bb;\n\n\t\t\t\t\t\tif (cfg->compute_gc_maps && var->dreg < orig_next_vreg && (var->flags & MONO_INST_GC_TRACK)) {\n\t\t\t\t\t\t\tMonoInst *tmp;\n\n\t\t\t\t\t\t\tMONO_INST_NEW (cfg, tmp, OP_GC_LIVENESS_USE);\n\t\t\t\t\t\t\t/* var->dreg is a hreg */\n\t\t\t\t\t\t\ttmp->inst_c1 = sreg;\n\t\t\t\t\t\t\tmono_bblock_insert_after_ins (bb, ins, tmp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tg_assert (var->opcode == OP_REGOFFSET);\n\n\t\t\t\t\tload_opcode = mono_type_to_load_membase (cfg, var->inst_vtype);\n\n\t\t\t\t\tg_assert (load_opcode != OP_LOADV_MEMBASE);\n\n\t\t\t\t\tif (vreg_to_lvreg [sreg]) {\n\t\t\t\t\t\tg_assert (vreg_to_lvreg [sreg] != -1);\n\n\t\t\t\t\t\t/* The variable is already loaded to an lvreg */\n\t\t\t\t\t\tif (G_UNLIKELY (cfg->verbose_level > 2))\n\t\t\t\t\t\t\tprintf (\"\\t\\tUse lvreg R%d for R%d.\\n\", vreg_to_lvreg [sreg], sreg);\n\t\t\t\t\t\tsregs [srcindex] = vreg_to_lvreg [sreg];\n\t\t\t\t\t\t//mono_inst_set_src_registers (ins, sregs);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Try to fuse the load into the instruction */\n\t\t\t\t\tif ((srcindex == 0) && (op_to_op_src1_membase (cfg, load_opcode, ins->opcode) != -1)) {\n\t\t\t\t\t\tins->opcode = op_to_op_src1_membase (cfg, load_opcode, ins->opcode);\n\t\t\t\t\t\tsregs [0] = var->inst_basereg;\n\t\t\t\t\t\t//mono_inst_set_src_registers (ins, sregs);\n\t\t\t\t\t\tins->inst_offset = var->inst_offset;\n\t\t\t\t\t} else if ((srcindex == 1) && (op_to_op_src2_membase (cfg, load_opcode, ins->opcode) != -1)) {\n\t\t\t\t\t\tins->opcode = op_to_op_src2_membase (cfg, load_opcode, ins->opcode);\n\t\t\t\t\t\tsregs [1] = var->inst_basereg;\n\t\t\t\t\t\t//mono_inst_set_src_registers (ins, sregs);\n\t\t\t\t\t\tins->inst_offset = var->inst_offset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (MONO_IS_REAL_MOVE (ins)) {\n\t\t\t\t\t\t\tins->opcode = OP_NOP;\n\t\t\t\t\t\t\tsreg = ins->dreg;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//printf (\"%d \", srcindex); mono_print_ins (ins);\n\n\t\t\t\t\t\t\tsreg = alloc_dreg (cfg, stacktypes [regtype]);\n\n\t\t\t\t\t\t\tif ((!cfg->backend->use_fpstack || ((load_opcode != OP_LOADR8_MEMBASE) && (load_opcode != OP_LOADR4_MEMBASE))) && !((var)->flags & (MONO_INST_VOLATILE|MONO_INST_INDIRECT)) && !no_lvreg) {\n\t\t\t\t\t\t\t\tif (var->dreg == prev_dreg) {\n\t\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t\t * sreg refers to the value loaded by the load\n\t\t\t\t\t\t\t\t\t * emitted below, but we need to use ins->dreg\n\t\t\t\t\t\t\t\t\t * since it refers to the store emitted earlier.\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\tsreg = ins->dreg;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tg_assert (sreg != -1);\n\t\t\t\t\t\t\t\tif (var->dreg == dreg_using_dest_to_membase_op) {\n\t\t\t\t\t\t\t\t\tif (cfg->verbose_level > 2)\n\t\t\t\t\t\t\t\t\t\tprintf (\"\\tCan't cache R%d because it's part of a dreg dest_membase optimization\\n\", var->dreg);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tvreg_to_lvreg [var->dreg] = sreg;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (lvregs_len >= lvregs_size) {\n\t\t\t\t\t\t\t\t\tguint32 *new_lvregs = mono_mempool_alloc0 (cfg->mempool, sizeof (guint32) * lvregs_size * 2);\n\t\t\t\t\t\t\t\t\tmemcpy (new_lvregs, lvregs, sizeof (guint32) * lvregs_size);\n\t\t\t\t\t\t\t\t\tlvregs = new_lvregs;\n\t\t\t\t\t\t\t\t\tlvregs_size *= 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlvregs [lvregs_len ++] = var->dreg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsregs [srcindex] = sreg;\n\t\t\t\t\t\t//mono_inst_set_src_registers (ins, sregs);\n\n#if SIZEOF_REGISTER != 8\n\t\t\t\t\t\tif (regtype == 'l') {\n\t\t\t\t\t\t\tNEW_LOAD_MEMBASE (cfg, load_ins, OP_LOADI4_MEMBASE, MONO_LVREG_MS (sreg), var->inst_basereg, var->inst_offset + MINI_MS_WORD_OFFSET);\n\t\t\t\t\t\t\tmono_bblock_insert_before_ins (bb, ins, load_ins);\n\t\t\t\t\t\t\tNEW_LOAD_MEMBASE (cfg, load_ins, OP_LOADI4_MEMBASE, MONO_LVREG_LS (sreg), var->inst_basereg, var->inst_offset + MINI_LS_WORD_OFFSET);\n\t\t\t\t\t\t\tmono_bblock_insert_before_ins (bb, ins, load_ins);\n\t\t\t\t\t\t\tuse_ins = load_ins;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n#endif\n\t\t\t\t\t\t{\n#if SIZEOF_REGISTER == 4\n\t\t\t\t\t\t\tg_assert (load_opcode != OP_LOADI8_MEMBASE);\n#endif\n\t\t\t\t\t\t\tNEW_LOAD_MEMBASE (cfg, load_ins, load_opcode, sreg, var->inst_basereg, var->inst_offset);\n\t\t\t\t\t\t\tmono_bblock_insert_before_ins (bb, ins, load_ins);\n\t\t\t\t\t\t\tuse_ins = load_ins;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (var->dreg < orig_next_vreg) {\n\t\t\t\t\t\tlive_range_end [var->dreg] = use_ins;\n\t\t\t\t\t\tlive_range_end_bb [var->dreg] = bb;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cfg->compute_gc_maps && var->dreg < orig_next_vreg && (var->flags & MONO_INST_GC_TRACK)) {\n\t\t\t\t\t\tMonoInst *tmp;\n\n\t\t\t\t\t\tMONO_INST_NEW (cfg, tmp, OP_GC_LIVENESS_USE);\n\t\t\t\t\t\ttmp->inst_c1 = var->dreg;\n\t\t\t\t\t\tmono_bblock_insert_after_ins (bb, ins, tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmono_inst_set_src_registers (ins, sregs);\n\n\t\t\tif (dest_has_lvreg) {\n\t\t\t\tg_assert (ins->dreg != -1);\n\t\t\t\tvreg_to_lvreg [prev_dreg] = ins->dreg;\n\t\t\t\tif (lvregs_len >= lvregs_size) {\n\t\t\t\t\tguint32 *new_lvregs = mono_mempool_alloc0 (cfg->mempool, sizeof (guint32) * lvregs_size * 2);\n\t\t\t\t\tmemcpy (new_lvregs, lvregs, sizeof (guint32) * lvregs_size);\n\t\t\t\t\tlvregs = new_lvregs;\n\t\t\t\t\tlvregs_size *= 2;\n\t\t\t\t}\n\t\t\t\tlvregs [lvregs_len ++] = prev_dreg;\n\t\t\t\tdest_has_lvreg = FALSE;\n\t\t\t}\n\n\t\t\tif (store) {\n\t\t\t\ttmp_reg = ins->dreg;\n\t\t\t\tins->dreg = ins->sreg2;\n\t\t\t\tins->sreg2 = tmp_reg;\n\t\t\t}\n\n\t\t\tif (MONO_IS_CALL (ins)) {\n\t\t\t\t/* Clear vreg_to_lvreg array */\n\t\t\t\tfor (i = 0; i < lvregs_len; i++)\n\t\t\t\t\tvreg_to_lvreg [lvregs [i]] = 0;\n\t\t\t\tlvregs_len = 0;\n\t\t\t} else if (ins->opcode == OP_NOP) {\n\t\t\t\tins->dreg = -1;\n\t\t\t\tMONO_INST_NULLIFY_SREGS (ins);\n\t\t\t}\n\n\t\t\tif (cfg->verbose_level > 2)\n\t\t\t\tmono_print_ins_index (1, ins);\n\t\t}\n\n\t\t/* Extend the live range based on the liveness info */\n\t\tif (cfg->compute_precise_live_ranges && bb->live_out_set && bb->code) {\n\t\t\tfor (i = 0; i < cfg->num_varinfo; i ++) {\n\t\t\t\tMonoMethodVar *vi = MONO_VARINFO (cfg, i);\n\n\t\t\t\tif (vreg_is_volatile (cfg, vi->vreg))\n\t\t\t\t\t/* The liveness info is incomplete */\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (mono_bitset_test_fast (bb->live_in_set, i) && !live_range_start [vi->vreg]) {\n\t\t\t\t\t/* Live from at least the first ins of this bb */\n\t\t\t\t\tlive_range_start [vi->vreg] = bb->code;\n\t\t\t\t\tlive_range_start_bb [vi->vreg] = bb;\n\t\t\t\t}\n\n\t\t\t\tif (mono_bitset_test_fast (bb->live_out_set, i)) {\n\t\t\t\t\t/* Live at least until the last ins of this bb */\n\t\t\t\t\tlive_range_end [vi->vreg] = bb->last_ins;\n\t\t\t\t\tlive_range_end_bb [vi->vreg] = bb;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * Emit LIVERANGE_START/LIVERANGE_END opcodes, the backend will implement them\n\t * by storing the current native offset into MonoMethodVar->live_range_start/end.\n\t */\n\tif (cfg->compute_precise_live_ranges && cfg->comp_done & MONO_COMP_LIVENESS) {\n\t\tfor (i = 0; i < cfg->num_varinfo; ++i) {\n\t\t\tint vreg = MONO_VARINFO (cfg, i)->vreg;\n\t\t\tMonoInst *ins;\n\n\t\t\tif (live_range_start [vreg]) {\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_LIVERANGE_START);\n\t\t\t\tins->inst_c0 = i;\n\t\t\t\tins->inst_c1 = vreg;\n\t\t\t\tmono_bblock_insert_after_ins (live_range_start_bb [vreg], live_range_start [vreg], ins);\n\t\t\t}\n\t\t\tif (live_range_end [vreg]) {\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_LIVERANGE_END);\n\t\t\t\tins->inst_c0 = i;\n\t\t\t\tins->inst_c1 = vreg;\n\t\t\t\tif (live_range_end [vreg] == live_range_end_bb [vreg]->last_ins)\n\t\t\t\t\tmono_add_ins_to_end (live_range_end_bb [vreg], ins);\n\t\t\t\telse\n\t\t\t\t\tmono_bblock_insert_after_ins (live_range_end_bb [vreg], live_range_end [vreg], ins);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cfg->gsharedvt_locals_var_ins) {\n\t\t/* Nullify if unused */\n\t\tcfg->gsharedvt_locals_var_ins->opcode = OP_PCONST;\n\t\tcfg->gsharedvt_locals_var_ins->inst_imm = 0;\n\t}\n\n\tg_free (live_range_start);\n\tg_free (live_range_end);\n\tg_free (live_range_start_bb);\n\tg_free (live_range_end_bb);\n}\n\n/**\n * FIXME:\n * - use 'iadd' instead of 'int_add'\n * - handling ovf opcodes: decompose in method_to_ir.\n * - unify iregs/fregs\n *   -> partly done, the missing parts are:\n *   - a more complete unification would involve unifying the hregs as well, so\n *     code wouldn't need if (fp) all over the place. but that would mean the hregs\n *     would no longer map to the machine hregs, so the code generators would need to\n *     be modified. Also, on ia64 for example, niregs + nfregs > 256 -> bitmasks\n *     wouldn't work any more. Duplicating the code in mono_local_regalloc () into\n *     fp/non-fp branches speeds it up by about 15%.\n * - use sext/zext opcodes instead of shifts\n * - add OP_ICALL\n * - get rid of TEMPLOADs if possible and use vregs instead\n * - clean up usage of OP_P/OP_ opcodes\n * - cleanup usage of DUMMY_USE\n * - cleanup the setting of ins->type for MonoInst's which are pushed on the \n *   stack\n * - set the stack type and allocate a dreg in the EMIT_NEW macros\n * - get rid of all the <foo>2 stuff when the new JIT is ready.\n * - make sure handle_stack_args () is called before the branch is emitted\n * - when the new IR is done, get rid of all unused stuff\n * - COMPARE/BEQ as separate instructions or unify them ?\n *   - keeping them separate allows specialized compare instructions like\n *     compare_imm, compare_membase\n *   - most back ends unify fp compare+branch, fp compare+ceq\n * - integrate mono_save_args into inline_method\n * - get rid of the empty bblocks created by MONO_EMIT_NEW_BRACH_BLOCK2\n * - handle long shift opts on 32 bit platforms somehow: they require \n *   3 sregs (2 for arg1 and 1 for arg2)\n * - make byref a 'normal' type.\n * - use vregs for bb->out_stacks if possible, handle_global_vreg will make them a\n *   variable if needed.\n * - do not start a new IL level bblock when cfg->cbb is changed by a function call\n *   like inline_method.\n * - remove inlining restrictions\n * - fix LNEG and enable cfold of INEG\n * - generalize x86 optimizations like ldelema as a peephole optimization\n * - add store_mem_imm for amd64\n * - optimize the loading of the interruption flag in the managed->native wrappers\n * - avoid special handling of OP_NOP in passes\n * - move code inserting instructions into one function/macro.\n * - try a coalescing phase after liveness analysis\n * - add float -> vreg conversion + local optimizations on !x86\n * - figure out how to handle decomposed branches during optimizations, ie.\n *   compare+branch, op_jump_table+op_br etc.\n * - promote RuntimeXHandles to vregs\n * - vtype cleanups:\n *   - add a NEW_VARLOADA_VREG macro\n * - the vtype optimizations are blocked by the LDADDR opcodes generated for \n *   accessing vtype fields.\n * - get rid of I8CONST on 64 bit platforms\n * - dealing with the increase in code size due to branches created during opcode\n *   decomposition:\n *   - use extended basic blocks\n *     - all parts of the JIT\n *     - handle_global_vregs () && local regalloc\n *   - avoid introducing global vregs during decomposition, like 'vtable' in isinst\n * - sources of increase in code size:\n *   - vtypes\n *   - long compares\n *   - isinst and castclass\n *   - lvregs not allocated to global registers even if used multiple times\n * - call cctors outside the JIT, to make -v output more readable and JIT timings more\n *   meaningful.\n * - check for fp stack leakage in other opcodes too. (-> 'exceptions' optimization)\n * - add all micro optimizations from the old JIT\n * - put tree optimizations into the deadce pass\n * - decompose op_start_handler/op_endfilter/op_endfinally earlier using an arch\n *   specific function.\n * - unify the float comparison opcodes with the other comparison opcodes, i.e.\n *   fcompare + branchCC.\n * - create a helper function for allocating a stack slot, taking into account \n *   MONO_CFG_HAS_SPILLUP.\n * - merge r68207.\n * - optimize mono_regstate2_alloc_int/float.\n * - fix the pessimistic handling of variables accessed in exception handler blocks.\n * - need to write a tree optimization pass, but the creation of trees is difficult, i.e.\n *   parts of the tree could be separated by other instructions, killing the tree\n *   arguments, or stores killing loads etc. Also, should we fold loads into other\n *   instructions if the result of the load is used multiple times ?\n * - make the REM_IMM optimization in mini-x86.c arch-independent.\n * - LAST MERGE: 108395.\n * - when returning vtypes in registers, generate IR and append it to the end of the\n *   last bb instead of doing it in the epilog.\n * - change the store opcodes so they use sreg1 instead of dreg to store the base register.\n */\n\n/*\n\nNOTES\n-----\n\n- When to decompose opcodes:\n  - earlier: this makes some optimizations hard to implement, since the low level IR\n  no longer contains the neccessary information. But it is easier to do.\n  - later: harder to implement, enables more optimizations.\n- Branches inside bblocks:\n  - created when decomposing complex opcodes. \n    - branches to another bblock: harmless, but not tracked by the branch \n      optimizations, so need to branch to a label at the start of the bblock.\n    - branches to inside the same bblock: very problematic, trips up the local\n      reg allocator. Can be fixed by spitting the current bblock, but that is a\n      complex operation, since some local vregs can become global vregs etc.\n- Local/global vregs:\n  - local vregs: temporary vregs used inside one bblock. Assigned to hregs by the\n    local register allocator.\n  - global vregs: used in more than one bblock. Have an associated MonoMethodVar\n    structure, created by mono_create_var (). Assigned to hregs or the stack by\n    the global register allocator.\n- When to do optimizations like alu->alu_imm:\n  - earlier -> saves work later on since the IR will be smaller/simpler\n  - later -> can work on more instructions\n- Handling of valuetypes:\n  - When a vtype is pushed on the stack, a new temporary is created, an \n    instruction computing its address (LDADDR) is emitted and pushed on\n    the stack. Need to optimize cases when the vtype is used immediately as in\n    argument passing, stloc etc.\n- Instead of the to_end stuff in the old JIT, simply call the function handling\n  the values on the stack before emitting the last instruction of the bb.\n*/\n#else /* !DISABLE_JIT */\n\nMONO_EMPTY_SOURCE_FILE (method_to_ir);\n#endif /* !DISABLE_JIT */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mono/mini/mini-darwin.c": "/**\n * \\file\n * Darwin/MacOS support for Mono.\n *\n * Authors:\n *   Mono Team (mono-list@lists.ximian.com)\n *\n * Copyright 2001-2003 Ximian, Inc.\n * Copyright 2003-2011 Novell, Inc (http://www.novell.com)\n * Copyright 2011 Xamarin, Inc (http://www.xamarin.com)\n *\n * Licensed under the MIT license. See LICENSE file in the project root for full license information.\n */\n#include <config.h>\n#include <signal.h>\n#ifdef HAVE_ALLOCA_H\n#include <alloca.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <math.h>\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n\n#include <mono/metadata/assembly.h>\n#include <mono/metadata/loader.h>\n#include <mono/metadata/tabledefs.h>\n#include <mono/metadata/class.h>\n#include <mono/metadata/object.h>\n#include <mono/metadata/tokentype.h>\n#include <mono/metadata/tabledefs.h>\n#include <mono/metadata/threads.h>\n#include <mono/metadata/appdomain.h>\n#include <mono/metadata/debug-helpers.h>\n#include <mono/metadata/profiler-private.h>\n#include <mono/metadata/mono-config.h>\n#include <mono/metadata/environment.h>\n#include <mono/metadata/mono-debug.h>\n#include <mono/metadata/threads-types.h>\n#include <mono/metadata/verify.h>\n#include <mono/metadata/verify-internals.h>\n#include <mono/metadata/mempool-internals.h>\n#include <mono/metadata/attach.h>\n#include <mono/metadata/gc-internals.h>\n#include <mono/utils/mono-math.h>\n#include <mono/utils/mono-compiler.h>\n#include <mono/utils/mono-counters.h>\n#include <mono/utils/mono-logger-internals.h>\n#include <mono/utils/mono-mmap.h>\n#include <mono/utils/dtrace.h>\n\n#include \"mini.h\"\n#include \"mini-runtime.h\"\n#include <string.h>\n#include <ctype.h>\n#include \"trace.h\"\n#include \"version.h\"\n\n#include \"jit-icalls.h\"\n\n/* MacOS includes */\n#include <mach/mach.h>\n#include <mach/mach_error.h>\n#include <mach/exception.h>\n#include <mach/task.h>\n#include <pthread.h>\n#include <dlfcn.h>\n#include <AvailabilityMacros.h>\n\n/* This is #define'd by Boehm GC to _GC_dlopen. */\n#undef dlopen\n\nvoid* dlopen(const char* path, int mode);\n\nvoid\nmono_runtime_install_handlers (void)\n{\n\tmono_runtime_posix_install_handlers ();\n\n\t/* Snow Leopard has a horrible bug: http://openradar.appspot.com/7209349\n\t * This causes obscure SIGTRAP's for any application that comes across this built on\n\t * Snow Leopard.  This is a horrible hack to ensure that the private __CFInitialize\n\t * is run on the main thread, so that we don't get SIGTRAPs later\n\t */\n#if defined (__APPLE__) && (defined (__i386__) || defined (__x86_64__))\n\t{\n\t\tvoid *handle = dlopen (\"/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\", RTLD_LAZY);\n\t\tif (handle == NULL)\n\t\t\treturn;\n\n\t\tdlclose (handle);\n\t}\n#endif\n}\n\ngboolean\nmono_thread_state_init_from_handle (MonoThreadUnwindState *tctx, MonoThreadInfo *info, void *sigctx)\n{\n\tkern_return_t ret;\n\tmach_msg_type_number_t num_state, num_fpstate;\n\tthread_state_t state, fpstate;\n\n\tg_assert (info);\n\t/*Zero enough state to make sure the caller doesn't confuse itself*/\n\ttctx->valid = FALSE;\n\ttctx->unwind_data [MONO_UNWIND_DATA_DOMAIN] = NULL;\n\ttctx->unwind_data [MONO_UNWIND_DATA_LMF] = NULL;\n\ttctx->unwind_data [MONO_UNWIND_DATA_JIT_TLS] = NULL;\n\n\tstate = (thread_state_t) alloca (mono_mach_arch_get_thread_state_size ());\n\tfpstate = (thread_state_t) alloca (mono_mach_arch_get_thread_fpstate_size ());\n\n\tdo {\n\t\tret = mono_mach_arch_get_thread_states (info->native_handle, state, &num_state, fpstate, &num_fpstate);\n\t} while (ret == KERN_ABORTED);\n\tif (ret != KERN_SUCCESS)\n\t\treturn FALSE;\n\n\tmono_mach_arch_thread_states_to_mono_context (state, fpstate, &tctx->ctx);\n\n\t/* mono_set_jit_tls () sets this */\n\tvoid *jit_tls = mono_thread_info_tls_get (info, TLS_KEY_JIT_TLS);\n\t/* SET_APPDOMAIN () sets this */\n\tvoid *domain = mono_thread_info_tls_get (info, TLS_KEY_DOMAIN);\n\n\t/*Thread already started to cleanup, can no longer capture unwind state*/\n\tif (!jit_tls || !domain)\n\t\treturn FALSE;\n\n\t/*\n\t * The current LMF address is kept in a separate TLS variable, and its hard to read its value without\n\t * arch-specific code. But the address of the TLS variable is stored in another TLS variable which\n\t * can be accessed through MonoThreadInfo.\n\t */\n\t/* mono_set_lmf_addr () sets this */\n\tMonoLMF *lmf = NULL;\n\tMonoLMF **addr = (MonoLMF**)mono_thread_info_tls_get (info, TLS_KEY_LMF_ADDR);\n\tif (addr)\n\t\tlmf = *addr;\n\n\ttctx->unwind_data [MONO_UNWIND_DATA_DOMAIN] = domain;\n\ttctx->unwind_data [MONO_UNWIND_DATA_JIT_TLS] = jit_tls;\n\ttctx->unwind_data [MONO_UNWIND_DATA_LMF] = lmf;\n\ttctx->valid = TRUE;\n\n\treturn TRUE;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mono/eglib/gmodule-unix.c": "/*\n * gmodule.c: dl* functions, glib style\n *\n * Author:\n *   Gonzalo Paniagua Javier (gonzalo@novell.com)\n *   Jonathan Chambers (joncham@gmail.com)\n *   Robert Jordan (robertj@gmx.net)\n *\n * (C) 2006 Novell, Inc.\n * (C) 2006 Jonathan Chambers\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#include <config.h>\n\n#include <glib.h>\n#include <gmodule.h>\n\n#if defined(G_OS_UNIX) && defined(HAVE_DLFCN_H)\n#include <dlfcn.h>\n\n/* For Linux and Solaris, need to add others as we port this */\n#define LIBPREFIX \"lib\"\n#define LIBSUFFIX \".so\"\n\nstruct _GModule {\n\tvoid *handle;\n};\n\nGModule *\ng_module_open (const gchar *file, GModuleFlags flags)\n{\n\tint f = 0;\n\tGModule *module;\n\tvoid *handle;\n\t\n\tflags &= G_MODULE_BIND_MASK;\n\tif ((flags & G_MODULE_BIND_LAZY) != 0)\n\t\tf |= RTLD_LAZY;\n\tif ((flags & G_MODULE_BIND_LOCAL) != 0)\n\t\tf |= RTLD_LOCAL;\n\n\thandle = dlopen (file, f);\n\tif (handle == NULL)\n\t\treturn NULL;\n\t\n\tmodule = g_new (GModule,1);\n\tmodule->handle = handle;\n\t\n\treturn module;\n}\n\ngboolean\ng_module_symbol (GModule *module, const gchar *symbol_name, gpointer *symbol)\n{\n\tif (symbol_name == NULL || symbol == NULL)\n\t\treturn FALSE;\n\n\tif (module == NULL || module->handle == NULL)\n\t\treturn FALSE;\n\n\t*symbol = dlsym (module->handle, symbol_name);\n\treturn (*symbol != NULL);\n}\n\nconst gchar *\ng_module_error (void)\n{\n\treturn dlerror ();\n}\n\ngboolean\ng_module_close (GModule *module)\n{\n\tvoid *handle;\n\tif (module == NULL || module->handle == NULL)\n\t\treturn FALSE;\n\n\thandle = module->handle;\n\tmodule->handle = NULL;\n\tg_free (module);\n\treturn (0 == dlclose (handle));\n}\n\n#elif defined (G_OS_WIN32)\n#ifndef PSAPI_VERSION\n#define PSAPI_VERSION 2 // Use the Windows 7 or newer version more directly.\n#endif\n#include <windows.h>\n#include <psapi.h>\n\n#define LIBSUFFIX \".dll\"\n#define LIBPREFIX \"\"\n\nstruct _GModule {\n\tHMODULE handle;\n\tint main_module;\n};\n\nGModule *\ng_module_open (const gchar *file, GModuleFlags flags)\n{\n\tGModule *module;\n\tmodule = g_malloc (sizeof (GModule));\n\tif (module == NULL)\n\t\treturn NULL;\n\n\tif (file != NULL) {\n\t\tgunichar2 *file16;\n\t\tfile16 = u8to16(file); \n\t\tmodule->main_module = FALSE;\n\t\tmodule->handle = LoadLibrary (file16);\n\t\tg_free(file16);\n\t\tif (!module->handle) {\n\t\t\tg_free (module);\n\t\t\treturn NULL;\n\t\t}\n\t\t\t\n\t} else {\n\t\tmodule->main_module = TRUE;\n\t\tmodule->handle = GetModuleHandle (NULL);\n\t}\n\n\treturn module;\n}\n\nstatic gpointer\nw32_find_symbol (const gchar *symbol_name)\n{\n\tHMODULE *modules;\n\tDWORD buffer_size = sizeof (HMODULE) * 1024;\n\tDWORD needed, i;\n\n\tmodules = (HMODULE *) g_malloc (buffer_size);\n\n\tif (modules == NULL)\n\t\treturn NULL;\n\n\tif (!EnumProcessModules (GetCurrentProcess (), modules,\n\t\t\t\t buffer_size, &needed)) {\n\t\tg_free (modules);\n\t\treturn NULL;\n\t}\n\n\t/* check whether the supplied buffer was too small, realloc, retry */\n\tif (needed > buffer_size) {\n\t\tg_free (modules);\n\n\t\tbuffer_size = needed;\n\t\tmodules = (HMODULE *) g_malloc (buffer_size);\n\n\t\tif (modules == NULL)\n\t\t\treturn NULL;\n\n\t\tif (!EnumProcessModules (GetCurrentProcess (), modules,\n\t\t\t\t\t buffer_size, &needed)) {\n\t\t\tg_free (modules);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < needed / sizeof (HANDLE); i++) {\n\t\tgpointer proc = (gpointer)(intptr_t)GetProcAddress (modules [i], symbol_name);\n\t\tif (proc != NULL) {\n\t\t\tg_free (modules);\n\t\t\treturn proc;\n\t\t}\n\t}\n\n\tg_free (modules);\n\treturn NULL;\n}\n\ngboolean\ng_module_symbol (GModule *module, const gchar *symbol_name, gpointer *symbol)\n{\n\tif (module == NULL || symbol_name == NULL || symbol == NULL)\n\t\treturn FALSE;\n\n\tif (module->main_module) {\n\t\t*symbol = (gpointer)(intptr_t)GetProcAddress (module->handle, symbol_name);\n\t\tif (*symbol != NULL)\n\t\t\treturn TRUE;\n\n\t\t*symbol = w32_find_symbol (symbol_name);\n\t\treturn *symbol != NULL;\n\t} else {\n\t\t*symbol = (gpointer)(intptr_t)GetProcAddress (module->handle, symbol_name);\n\t\treturn *symbol != NULL;\n\t}\n}\n\nconst gchar *\ng_module_error (void)\n{\n\tgchar* ret = NULL;\n\tTCHAR* buf = NULL;\n\tDWORD code = GetLastError ();\n\n\tFormatMessage (FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER, NULL, \n\t\tcode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), buf, 0, NULL);\n\n\tret = u16to8 (buf);\n\tLocalFree(buf);\n\n\treturn ret;\n}\n\ngboolean\ng_module_close (GModule *module)\n{\n\tHMODULE handle;\n\tint main_module;\n\n\tif (module == NULL || module->handle == NULL)\n\t\treturn FALSE;\n\n\thandle = module->handle;\n\tmain_module = module->main_module;\n\tmodule->handle = NULL;\n\tg_free (module);\n\treturn (main_module ? 1 : (0 == FreeLibrary (handle)));\n}\n\n#else\n\n#define LIBSUFFIX \"\"\n#define LIBPREFIX \"\"\n\nGModule *\ng_module_open (const gchar *file, GModuleFlags flags)\n{\n\tg_error (\"%s\", \"g_module_open not implemented on this platform\");\n\treturn NULL;\n}\n\ngboolean\ng_module_symbol (GModule *module, const gchar *symbol_name, gpointer *symbol)\n{\n\tg_error (\"%s\", \"g_module_open not implemented on this platform\");\n\treturn FALSE;\n}\n\nconst gchar *\ng_module_error (void)\n{\n\tg_error (\"%s\", \"g_module_open not implemented on this platform\");\n\treturn NULL;\n}\n\ngboolean\ng_module_close (GModule *module)\n{\n\tg_error (\"%s\", \"g_module_open not implemented on this platform\");\n\treturn FALSE;\n}\n#endif\n\ngchar *\ng_module_build_path (const gchar *directory, const gchar *module_name)\n{\n\tconst char *lib_prefix = \"\";\n\t\n\tif (module_name == NULL)\n\t\treturn NULL;\n\n\tif (strncmp (module_name, \"lib\", 3) != 0)\n\t\tlib_prefix = LIBPREFIX;\n\t\n\tif (directory && *directory)\n\t\treturn g_strdup_printf (\"%s/%s%s\" LIBSUFFIX, directory, lib_prefix, module_name);\n\treturn g_strdup_printf (\"%s%s\" LIBSUFFIX, lib_prefix, module_name); \n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/pthread_support.c": "/* \n * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.\n * Copyright (c) 1998 by Fergus Henderson.  All rights reserved.\n * Copyright (c) 2000-2004 by Hewlett-Packard Company.  All rights reserved.\n *\n * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n *\n * Permission is hereby granted to use or copy this program\n * for any purpose,  provided the above notices are retained on all copies.\n * Permission to modify the code and to distribute modified code is granted,\n * provided the above notices are retained, and a notice that the code was\n * modified is included with the above copyright notice.\n */\n/*\n * Support code for LinuxThreads, the clone()-based kernel\n * thread package for Linux which is included in libc6.\n *\n * This code relies on implementation details of LinuxThreads,\n * (i.e. properties not guaranteed by the Pthread standard),\n * though this version now does less of that than the other Pthreads\n * support code.\n *\n * Note that there is a lot of code duplication between linux_threads.c\n * and thread support for some of the other Posix platforms; any changes\n * made here may need to be reflected there too.\n */\n /* DG/UX ix86 support <takis@xfree86.org> */\n/*\n * Linux_threads.c now also includes some code to support HPUX and\n * OSF1 (Compaq Tru64 Unix, really).  The OSF1 support is based on Eric Benson's\n * patch.\n *\n * Eric also suggested an alternate basis for a lock implementation in\n * his code:\n * + #elif defined(OSF1)\n * +    unsigned long GC_allocate_lock = 0;\n * +    msemaphore GC_allocate_semaphore;\n * + #  define GC_TRY_LOCK() \\\n * +    ((msem_lock(&GC_allocate_semaphore, MSEM_IF_NOWAIT) == 0) \\\n * +     ? (GC_allocate_lock = 1) \\\n * +     : 0)\n * + #  define GC_LOCK_TAKEN GC_allocate_lock\n */\n\n/*#define DEBUG_THREADS 1*/\n/*#define GC_ASSERTIONS*/\n\n# include \"private/pthread_support.h\"\n\n# if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \\\n     && !defined(GC_WIN32_THREADS)\n\n# if defined(GC_HPUX_THREADS) && !defined(USE_PTHREAD_SPECIFIC) \\\n     && !defined(USE_COMPILER_TLS)\n#   ifdef __GNUC__\n#     define USE_PTHREAD_SPECIFIC\n      /* Empirically, as of gcc 3.3, USE_COMPILER_TLS doesn't work.\t*/\n#   else\n#     define USE_COMPILER_TLS\n#   endif\n# endif\n\n# if defined USE_HPUX_TLS\n    --> Macro replaced by USE_COMPILER_TLS\n# endif\n\n#ifndef USE_COMPILER_TLS\n# if (defined(GC_DGUX386_THREADS) || defined(GC_OSF1_THREADS) || \\\n      defined(GC_DARWIN_THREADS) || defined(GC_AIX_THREADS)) || \\\n      defined(GC_NETBSD_THREADS) && !defined(USE_PTHREAD_SPECIFIC) || \\\n      defined(GC_FREEBSD_THREADS) && !defined(USE_PTHREAD_SPECIFIC) || \\\n      defined(GC_OPENBSD_THREADS)\n#   define USE_PTHREAD_SPECIFIC\n# endif\n#endif\n\n# if defined(GC_DGUX386_THREADS) && !defined(_POSIX4A_DRAFT10_SOURCE)\n#   define _POSIX4A_DRAFT10_SOURCE 1\n# endif\n\n# if defined(GC_DGUX386_THREADS) && !defined(_USING_POSIX4A_DRAFT10)\n#   define _USING_POSIX4A_DRAFT10 1\n# endif\n\n# ifdef THREAD_LOCAL_ALLOC\n#   if !defined(USE_PTHREAD_SPECIFIC) && !defined(USE_COMPILER_TLS)\n#     include \"private/specific.h\"\n#   endif\n\n/* Note that these macros should be used only to get/set the GC_thread pointer.\n * We need to use both tls and pthread because we use the pthread_create function hook to\n * free the data for foreign threads. When that doesn't happen, libgc could have old\n * pthread_t that get reused...\n */\n#   if defined(USE_PTHREAD_SPECIFIC)\n#     define GC_getspecific pthread_getspecific\n#     define GC_setspecific pthread_setspecific\n#     define GC_key_create pthread_key_create\n      typedef pthread_key_t GC_key_t;\n#   endif\n#   if defined(USE_COMPILER_TLS)\n/* Note sles9 gcc on powerpc gets confused by the define to set GC_thread_tls and pthread_setspecific\n * so we actually use a static inline function decalred below that is equivalent to:\n *   define GC_setspecific(key, v) (GC_thread_tls = (v), pthread_setspecific ((key), (v)))\n */\n#     define GC_getspecific(x) (GC_thread_tls)\n#     define GC_key_create pthread_key_create\n      typedef pthread_key_t GC_key_t;\n#   endif\n# endif\n# include <stdlib.h>\n# include <pthread.h>\n# include <sched.h>\n# include <time.h>\n# include <errno.h>\n# include <unistd.h>\n# include <sys/mman.h>\n# include <sys/time.h>\n# include <sys/types.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <signal.h>\n\n#if defined(GC_DARWIN_THREADS)\n# include \"private/darwin_semaphore.h\"\n#else\n# include <semaphore.h>\n#endif /* !GC_DARWIN_THREADS */\n\n#if defined(GC_DARWIN_THREADS) || defined(GC_FREEBSD_THREADS)\n# include <sys/sysctl.h>\n#endif /* GC_DARWIN_THREADS */\n\n#if defined(GC_NETBSD_THREADS) || defined(GC_OPENBSD_THREADS)\n# include <sys/param.h>\n# include <sys/sysctl.h>\n#endif\n\n\n\n#if defined(GC_DGUX386_THREADS)\n# include <sys/dg_sys_info.h>\n# include <sys/_int_psem.h>\n  /* sem_t is an uint in DG/UX */\n  typedef unsigned int  sem_t;\n#endif /* GC_DGUX386_THREADS */\n\n#ifndef __GNUC__\n#   define __inline__\n#endif\n\n#ifdef GC_USE_LD_WRAP\n#   define WRAP_FUNC(f) __wrap_##f\n#   define REAL_FUNC(f) __real_##f\n#else\n#   define WRAP_FUNC(f) GC_##f\n#   if !defined(GC_DGUX386_THREADS)\n#     define REAL_FUNC(f) f\n#   else /* GC_DGUX386_THREADS */\n#     define REAL_FUNC(f) __d10_##f\n#   endif /* GC_DGUX386_THREADS */\n#   undef pthread_create\n#   if !defined(GC_DARWIN_THREADS)\n#     undef pthread_sigmask\n#   endif\n#   undef pthread_join\n#   undef pthread_detach\n#   if defined(NACL)\n#     undef pthread_exit\n#   endif\n#   if defined(GC_OSF1_THREADS) && defined(_PTHREAD_USE_MANGLED_NAMES_) \\\n       && !defined(_PTHREAD_USE_PTDNAM_)\n/* Restore the original mangled names on Tru64 UNIX.  */\n#     define pthread_create __pthread_create\n#     define pthread_join __pthread_join\n#     define pthread_detach __pthread_detach\n#   endif\n#endif\n\nvoid GC_thr_init();\n\nstatic GC_bool parallel_initialized = FALSE;\n\nvoid GC_init_parallel();\n\nstatic pthread_t main_pthread_self;\nstatic void *main_stack, *main_altstack;\nstatic int main_stack_size, main_altstack_size;\n\n# if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\n\n/* We don't really support thread-local allocation with DBG_HDRS_ALL */\n\n/* work around a dlopen issue (bug #75390), undefs to avoid warnings with redefinitions */\n#undef PACKAGE_BUGREPORT\n#undef PACKAGE_NAME\n#undef PACKAGE_STRING\n#undef PACKAGE_TARNAME\n#undef PACKAGE_VERSION\n#include \"mono/utils/mono-compiler.h\"\n\nstatic\nGC_key_t GC_thread_key;\n\n#ifdef USE_COMPILER_TLS\n__thread void* GC_thread_tls;\n\n/*\n * gcc errors out with /tmp/ccdPMFuq.s:2994: Error: symbol `.LTLS4' is already defined\n * if the inline is added on powerpc\n */\n#if !defined(__ppc__) && !defined(__powerpc__)\ninline\n#endif\nstatic int GC_setspecific (GC_key_t key, void *value) {\n\tGC_thread_tls = value;\n\treturn pthread_setspecific (key, value);\n}\n#endif\n\nstatic GC_bool keys_initialized;\n\n/* Recover the contents of the freelist array fl into the global one gfl.*/\n/* Note that the indexing scheme differs, in that gfl has finer size\t*/\n/* resolution, even if not all entries are used.\t\t\t*/\n/* We hold the allocator lock.\t\t\t\t\t\t*/\nstatic void return_freelists(ptr_t *fl, ptr_t *gfl)\n{\n    int i;\n    ptr_t q, *qptr;\n    size_t nwords;\n\n    for (i = 1; i < NFREELISTS; ++i) {\n\tnwords = i * (GRANULARITY/sizeof(word));\n        qptr = fl + i;\t\n\tq = *qptr;\n\tif ((word)q >= HBLKSIZE) {\n\t  if (gfl[nwords] == 0) {\n\t    gfl[nwords] = q;\n\t  } else {\n\t    /* Concatenate: */\n\t    for (; (word)q >= HBLKSIZE; qptr = &(obj_link(q)), q = *qptr);\n\t    GC_ASSERT(0 == q);\n\t    *qptr = gfl[nwords];\n\t    gfl[nwords] = fl[i];\n\t  }\n\t}\n\t/* Clear fl[i], since the thread structure may hang around.\t*/\n\t/* Do it in a way that is likely to trap if we access it.\t*/\n\tfl[i] = (ptr_t)HBLKSIZE;\n    }\n}\n\n/* We statically allocate a single \"size 0\" object. It is linked to\t*/\n/* itself, and is thus repeatedly reused for all size 0 allocation\t*/\n/* requests.  (Size 0 gcj allocation requests are incorrect, and\t*/\n/* we arrange for those to fault asap.)\t\t\t\t\t*/\nstatic ptr_t size_zero_object = (ptr_t)(&size_zero_object);\n\nvoid GC_delete_gc_thread(pthread_t id, GC_thread gct);\nvoid GC_destroy_thread_local(GC_thread p);\n\nvoid GC_thread_deregister_foreign (void *data)\n{\n    GC_thread me = (GC_thread)data;\n /*   GC_fprintf1( \"\\n\\n\\n\\n --- Deregister %x ---\\n\\n\\n\\n\\n\", me->flags ); */\n    if (me -> flags & FOREIGN_THREAD) {\n\tLOCK();\n /*\tGC_fprintf0( \"\\n\\n\\n\\n --- FOO ---\\n\\n\\n\\n\\n\" ); */\n#if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\n\tGC_destroy_thread_local (me);\n#endif\n\tGC_delete_gc_thread(me->id, me);\n\tUNLOCK();\n    }\n}\n\n/* Each thread structure must be initialized.\t*/\n/* This call must be made from the new thread.\t*/\n/* Caller holds allocation lock.\t\t*/\nvoid GC_init_thread_local(GC_thread p)\n{\n    int i;\n\n    if (!keys_initialized) {\n\tif (0 != GC_key_create(&GC_thread_key, GC_thread_deregister_foreign)) {\n\t    ABORT(\"Failed to create key for local allocator\");\n        }\n\tkeys_initialized = TRUE;\n    }\n    if (0 != GC_setspecific(GC_thread_key, p)) {\n\tABORT(\"Failed to set thread specific allocation pointers\");\n    }\n    for (i = 1; i < NFREELISTS; ++i) {\n\tp -> tlfs.ptrfree_freelists[i] = (ptr_t)1;\n\tp -> tlfs.normal_freelists[i] = (ptr_t)1;\n#\tifdef GC_GCJ_SUPPORT\n\t  p -> tlfs.gcj_freelists[i] = (ptr_t)1;\n#\tendif\n    }   \n    /* Set up the size 0 free lists.\t*/\n    p -> tlfs.ptrfree_freelists[0] = (ptr_t)(&size_zero_object);\n    p -> tlfs.normal_freelists[0] = (ptr_t)(&size_zero_object);\n#   ifdef GC_GCJ_SUPPORT\n\tp -> tlfs.gcj_freelists[0] = (ptr_t)(-1);\n#   endif\n}\n\n#ifdef GC_GCJ_SUPPORT\n  extern ptr_t * GC_gcjobjfreelist;\n#endif\n\n/* We hold the allocator lock.\t*/\nvoid GC_destroy_thread_local(GC_thread p)\n{\n    /* We currently only do this from the thread itself or from\t*/\n    /* the fork handler for a child process.\t\t\t*/\n#   ifndef HANDLE_FORK\n      GC_ASSERT(GC_getspecific(GC_thread_key) == (void *)p);\n#   endif\n    return_freelists(p -> tlfs.ptrfree_freelists, GC_aobjfreelist);\n    return_freelists(p -> tlfs.normal_freelists, GC_objfreelist);\n#   ifdef GC_GCJ_SUPPORT\n\treturn_freelists(p -> tlfs.gcj_freelists, GC_gcjobjfreelist);\n#   endif\n}\n\nextern GC_PTR GC_generic_malloc_many();\n\nGC_PTR GC_local_malloc(size_t bytes)\n{\n    if (EXPECT(!SMALL_ENOUGH(bytes),0)) {\n        return(GC_malloc(bytes));\n    } else {\n\tint index = INDEX_FROM_BYTES(bytes);\n\tptr_t * my_fl;\n\tptr_t my_entry;\n#\tif defined(REDIRECT_MALLOC) && !defined(USE_PTHREAD_SPECIFIC)\n\tGC_key_t k = GC_thread_key;\n#\tendif\n\tvoid * tsd;\n\n#\tif defined(REDIRECT_MALLOC) && !defined(USE_PTHREAD_SPECIFIC)\n\t    if (EXPECT(0 == k, 0)) {\n\t\t/* This can happen if we get called when the world is\t*/\n\t\t/* being initialized.  Whether we can actually complete\t*/\n\t\t/* the initialization then is unclear.\t\t\t*/\n\t\tGC_init_parallel();\n\t\tk = GC_thread_key;\n\t    }\n#\tendif\n\ttsd = GC_getspecific(GC_thread_key);\n#\tifdef GC_ASSERTIONS\n\t  LOCK();\n\t  GC_ASSERT(tsd == (void *)GC_lookup_thread(pthread_self()));\n\t  UNLOCK();\n#\tendif\n\tmy_fl = ((GC_thread)tsd) -> tlfs.normal_freelists + index;\n\tmy_entry = *my_fl;\n\tif (EXPECT((word)my_entry >= HBLKSIZE, 1)) {\n\t    ptr_t next = obj_link(my_entry);\n\t    GC_PTR result = (GC_PTR)my_entry;\n\t    *my_fl = next;\n\t    obj_link(my_entry) = 0;\n\t    PREFETCH_FOR_WRITE(next);\n\t    return result;\n\t} else if ((word)my_entry - 1 < DIRECT_GRANULES) {\n\t    *my_fl = my_entry + index + 1;\n            return GC_malloc(bytes);\n\t} else {\n\t    GC_generic_malloc_many(BYTES_FROM_INDEX(index), NORMAL, my_fl);\n\t    if (*my_fl == 0) return GC_oom_fn(bytes);\n\t    return GC_local_malloc(bytes);\n\t}\n    }\n}\n\nGC_PTR GC_local_malloc_atomic(size_t bytes)\n{\n    if (EXPECT(!SMALL_ENOUGH(bytes), 0)) {\n        return(GC_malloc_atomic(bytes));\n    } else {\n\tint index = INDEX_FROM_BYTES(bytes);\n\tptr_t * my_fl = ((GC_thread)GC_getspecific(GC_thread_key))\n\t\t        -> tlfs.ptrfree_freelists + index;\n\tptr_t my_entry = *my_fl;\n    \n\tif (EXPECT((word)my_entry >= HBLKSIZE, 1)) {\n\t    GC_PTR result = (GC_PTR)my_entry;\n\t    *my_fl = obj_link(my_entry);\n\t    return result;\n\t} else if ((word)my_entry - 1 < DIRECT_GRANULES) {\n\t    *my_fl = my_entry + index + 1;\n        return GC_malloc_atomic(bytes);\n\t} else {\n\t    GC_generic_malloc_many(BYTES_FROM_INDEX(index), PTRFREE, my_fl);\n\t    /* *my_fl is updated while the collector is excluded;\t*/\n\t    /* the free list is always visible to the collector as \t*/\n\t    /* such.\t\t\t\t\t\t\t*/\n\t    if (*my_fl == 0) return GC_oom_fn(bytes);\n\t    return GC_local_malloc_atomic(bytes);\n\t}\n    }\n}\n\n#ifdef GC_GCJ_SUPPORT\n\n#include \"include/gc_gcj.h\"\n\n#ifdef GC_ASSERTIONS\n  extern GC_bool GC_gcj_malloc_initialized;\n#endif\n\nextern int GC_gcj_kind;\n\nGC_PTR GC_local_gcj_malloc(size_t bytes,\n\t\t\t   void * ptr_to_struct_containing_descr)\n{\n    GC_ASSERT(GC_gcj_malloc_initialized);\n    if (EXPECT(!SMALL_ENOUGH(bytes), 0)) {\n        return GC_gcj_malloc(bytes, ptr_to_struct_containing_descr);\n    } else {\n\tint index = INDEX_FROM_BYTES(bytes);\n\tptr_t * my_fl = ((GC_thread)GC_getspecific(GC_thread_key))\n\t                -> tlfs.gcj_freelists + index;\n\tptr_t my_entry = *my_fl;\n\tif (EXPECT((word)my_entry >= HBLKSIZE, 1)) {\n\t    GC_PTR result = (GC_PTR)my_entry;\n\t    GC_ASSERT(!GC_incremental);\n\t    /* We assert that any concurrent marker will stop us.\t*/\n\t    /* Thus it is impossible for a mark procedure to see the \t*/\n\t    /* allocation of the next object, but to see this object \t*/\n\t    /* still containing a free list pointer.  Otherwise the \t*/\n\t    /* marker might find a random \"mark descriptor\".\t\t*/\n\t    *(volatile ptr_t *)my_fl = obj_link(my_entry);\n\t    /* We must update the freelist before we store the pointer.\t*/\n\t    /* Otherwise a GC at this point would see a corrupted\t*/\n\t    /* free list.\t\t\t\t\t\t*/\n\t    /* A memory barrier is probably never needed, since the \t*/\n\t    /* action of stopping this thread will cause prior writes\t*/\n\t    /* to complete.\t\t\t\t\t\t*/\n\t    GC_ASSERT(((void * volatile *)result)[1] == 0); \n\t    *(void * volatile *)result = ptr_to_struct_containing_descr; \n\t    return result;\n\t} else if ((word)my_entry - 1 < DIRECT_GRANULES) {\n\t    if (!GC_incremental) *my_fl = my_entry + index + 1;\n\t    \t/* In the incremental case, we always have to take this */\n\t    \t/* path.  Thus we leave the counter alone.\t\t*/\n            return GC_gcj_malloc(bytes, ptr_to_struct_containing_descr);\n\t} else {\n\t    GC_generic_malloc_many(BYTES_FROM_INDEX(index), GC_gcj_kind, my_fl);\n\t    if (*my_fl == 0) return GC_oom_fn(bytes);\n\t    return GC_local_gcj_malloc(bytes, ptr_to_struct_containing_descr);\n\t}\n    }\n}\n\n/* Similar to GC_local_gcj_malloc, but the size is in words, and we don't\t*/\n/* adjust it.  The size is assumed to be such that it can be \t*/\n/* allocated as a small object.\t\t\t\t\t*/\nvoid * GC_local_gcj_fast_malloc(size_t lw, void * ptr_to_struct_containing_descr)\n{\n\tptr_t * my_fl = ((GC_thread)GC_getspecific(GC_thread_key))\n\t\t-> tlfs.gcj_freelists + lw;\n\tptr_t my_entry = *my_fl;\n\n    GC_ASSERT(GC_gcj_malloc_initialized);\n\n\tif (EXPECT((word)my_entry >= HBLKSIZE, 1)) {\n\t    GC_PTR result = (GC_PTR)my_entry;\n\t    GC_ASSERT(!GC_incremental);\n\t    /* We assert that any concurrent marker will stop us.\t*/\n\t    /* Thus it is impossible for a mark procedure to see the \t*/\n\t    /* allocation of the next object, but to see this object \t*/\n\t    /* still containing a free list pointer.  Otherwise the \t*/\n\t    /* marker might find a random \"mark descriptor\".\t\t*/\n\t    *(volatile ptr_t *)my_fl = obj_link(my_entry);\n\t    /* We must update the freelist before we store the pointer.\t*/\n\t    /* Otherwise a GC at this point would see a corrupted\t*/\n\t    /* free list.\t\t\t\t\t\t*/\n\t    /* A memory barrier is probably never needed, since the \t*/\n\t    /* action of stopping this thread will cause prior writes\t*/\n\t    /* to complete.\t\t\t\t\t\t*/\n\t    GC_ASSERT(((void * volatile *)result)[1] == 0); \n\t    *(void * volatile *)result = ptr_to_struct_containing_descr; \n\t    return result;\n\t} else if ((word)my_entry - 1 < DIRECT_GRANULES) {\n\t    if (!GC_incremental) *my_fl = my_entry + lw + 1;\n\t    \t/* In the incremental case, we always have to take this */\n\t    \t/* path.  Thus we leave the counter alone.\t\t*/\n            return GC_gcj_fast_malloc(lw, ptr_to_struct_containing_descr);\n\t} else {\n\t    GC_generic_malloc_many(BYTES_FROM_INDEX(lw), GC_gcj_kind, my_fl);\n\t    if (*my_fl == 0) return GC_oom_fn(BYTES_FROM_INDEX(lw));\n\t    return GC_local_gcj_fast_malloc(lw, ptr_to_struct_containing_descr);\n\t}\n}\n\n#endif /* GC_GCJ_SUPPORT */\n\n# else  /* !THREAD_LOCAL_ALLOC  && !DBG_HDRS_ALL */\n\n#   define GC_destroy_thread_local(t)\n\n# endif /* !THREAD_LOCAL_ALLOC */\n\n#if 0\n/*\nTo make sure that we're using LinuxThreads and not some other thread\npackage, we generate a dummy reference to `pthread_kill_other_threads_np'\n(was `__pthread_initial_thread_bos' but that disappeared),\nwhich is a symbol defined in LinuxThreads, but (hopefully) not in other\nthread packages.\n\nWe no longer do this, since this code is now portable enough that it might\nactually work for something else.\n*/\nvoid (*dummy_var_to_force_linux_threads)() = pthread_kill_other_threads_np;\n#endif /* 0 */\n\nlong GC_nprocs = 1;\t/* Number of processors.  We may not have\t*/\n\t\t\t/* access to all of them, but this is as good\t*/\n\t\t\t/* a guess as any ...\t\t\t\t*/\n\n#ifdef PARALLEL_MARK\n\n# ifndef MAX_MARKERS\n#   define MAX_MARKERS 16\n# endif\n\nstatic ptr_t marker_sp[MAX_MARKERS] = {0};\n\nvoid * GC_mark_thread(void * id)\n{\n  word my_mark_no = 0;\n\n  marker_sp[(word)id] = GC_approx_sp();\n  for (;; ++my_mark_no) {\n    /* GC_mark_no is passed only to allow GC_help_marker to terminate\t*/\n    /* promptly.  This is important if it were called from the signal\t*/\n    /* handler or from the GC lock acquisition code.  Under Linux, it's\t*/\n    /* not safe to call it from a signal handler, since it uses mutexes\t*/\n    /* and condition variables.  Since it is called only here, the \t*/\n    /* argument is unnecessary.\t\t\t\t\t\t*/\n    if (my_mark_no < GC_mark_no || my_mark_no > GC_mark_no + 2) {\n\t/* resynchronize if we get far off, e.g. because GC_mark_no\t*/\n\t/* wrapped.\t\t\t\t\t\t\t*/\n\tmy_mark_no = GC_mark_no;\n    }\n#   ifdef DEBUG_THREADS\n\tGC_printf1(\"Starting mark helper for mark number %ld\\n\", my_mark_no);\n#   endif\n    GC_help_marker(my_mark_no);\n  }\n}\n\nextern long GC_markers;\t\t/* Number of mark threads we would\t*/\n\t\t\t\t/* like to have.  Includes the \t\t*/\n\t\t\t\t/* initiating thread.\t\t\t*/\n\npthread_t GC_mark_threads[MAX_MARKERS];\n\n#define PTHREAD_CREATE REAL_FUNC(pthread_create)\n\nstatic void start_mark_threads()\n{\n    unsigned i;\n    pthread_attr_t attr;\n\n    if (GC_markers > MAX_MARKERS) {\n\tWARN(\"Limiting number of mark threads\\n\", 0);\n\tGC_markers = MAX_MARKERS;\n    }\n    if (0 != pthread_attr_init(&attr)) ABORT(\"pthread_attr_init failed\");\n\t\n    if (0 != pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED))\n\tABORT(\"pthread_attr_setdetachstate failed\");\n\n#   if defined(HPUX) || defined(GC_DGUX386_THREADS)\n      /* Default stack size is usually too small: fix it. */\n      /* Otherwise marker threads or GC may run out of\t  */\n      /* space.\t\t\t\t\t\t  */\n#     define MIN_STACK_SIZE (8*HBLKSIZE*sizeof(word))\n      {\n\tsize_t old_size;\n\tint code;\n\n        if (pthread_attr_getstacksize(&attr, &old_size) != 0)\n\t  ABORT(\"pthread_attr_getstacksize failed\\n\");\n\tif (old_size < MIN_STACK_SIZE) {\n\t  if (pthread_attr_setstacksize(&attr, MIN_STACK_SIZE) != 0)\n\t\t  ABORT(\"pthread_attr_setstacksize failed\\n\");\n\t}\n      }\n#   endif /* HPUX || GC_DGUX386_THREADS */\n#   ifdef CONDPRINT\n      if (GC_print_stats) {\n\tGC_printf1(\"Starting %ld marker threads\\n\", GC_markers - 1);\n      }\n#   endif\n    for (i = 0; i < GC_markers - 1; ++i) {\n      if (0 != PTHREAD_CREATE(GC_mark_threads + i, &attr,\n\t\t\t      GC_mark_thread, (void *)(word)i)) {\n\tWARN(\"Marker thread creation failed, errno = %ld.\\n\", errno);\n      }\n    }\n}\n\n#else  /* !PARALLEL_MARK */\n\nstatic __inline__ void start_mark_threads()\n{\n}\n\n#endif /* !PARALLEL_MARK */\n\nGC_bool GC_thr_initialized = FALSE;\n\nvolatile GC_thread GC_threads[THREAD_TABLE_SZ];\n\n/* \n * gcc-3.3.6 miscompiles the &GC_thread_key+sizeof(&GC_thread_key) expression so\n * put it into a separate function.\n */\n#   if defined(__GNUC__) && defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\nstatic __attribute__((noinline)) unsigned char* get_gc_thread_key_addr GC_PROTO((void))\n{\n\treturn (unsigned char*)&GC_thread_key;\n}\n\nvoid GC_push_thread_structures GC_PROTO((void))\n{\n    GC_push_all((ptr_t)(GC_threads), (ptr_t)(GC_threads)+sizeof(GC_threads));\n#   if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\n      GC_push_all((ptr_t)get_gc_thread_key_addr(),\n\t  (ptr_t)(get_gc_thread_key_addr())+sizeof(&GC_thread_key));\n#   endif\n}\n\n#else\n\nvoid GC_push_thread_structures GC_PROTO((void))\n{\n    GC_push_all((ptr_t)(GC_threads), (ptr_t)(GC_threads)+sizeof(GC_threads));\n#   if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\n      GC_push_all((ptr_t)(&GC_thread_key),\n\t  (ptr_t)(&GC_thread_key)+sizeof(&GC_thread_key));\n#   endif\n}\n\n#endif\n\n#ifdef THREAD_LOCAL_ALLOC\n/* We must explicitly mark ptrfree and gcj free lists, since the free \t*/\n/* list links wouldn't otherwise be found.  We also set them in the \t*/\n/* normal free lists, since that involves touching less memory than if\t*/\n/* we scanned them normally.\t\t\t\t\t\t*/\nvoid GC_mark_thread_local_free_lists(void)\n{\n    int i, j;\n    GC_thread p;\n    ptr_t q;\n    \n    for (i = 0; i < THREAD_TABLE_SZ; ++i) {\n      for (p = GC_threads[i]; 0 != p; p = p -> next) {\n\tfor (j = 1; j < NFREELISTS; ++j) {\n\t  q = p -> tlfs.ptrfree_freelists[j];\n\t  if ((word)q > HBLKSIZE) GC_set_fl_marks(q);\n\t  q = p -> tlfs.normal_freelists[j];\n\t  if ((word)q > HBLKSIZE) GC_set_fl_marks(q);\n#\t  ifdef GC_GCJ_SUPPORT\n\t    q = p -> tlfs.gcj_freelists[j];\n\t    if ((word)q > HBLKSIZE) GC_set_fl_marks(q);\n#\t  endif /* GC_GCJ_SUPPORT */\n\t}\n      }\n    }\n}\n#endif /* THREAD_LOCAL_ALLOC */\n\nstatic struct GC_Thread_Rep first_thread;\n\n#ifdef NACL\nextern volatile int nacl_thread_parked[MAX_NACL_GC_THREADS];\nextern volatile int nacl_thread_used[MAX_NACL_GC_THREADS];\nextern volatile int nacl_thread_parking_inited;\nextern volatile int nacl_num_gc_threads;\nextern pthread_mutex_t nacl_thread_alloc_lock;\nextern __thread int nacl_thread_idx;\nextern __thread GC_thread nacl_gc_thread_self;\n\nextern void nacl_pre_syscall_hook();\nextern void nacl_post_syscall_hook();\nextern void nacl_register_gc_hooks(void (*pre)(), void (*post)());\n\n#include <stdio.h>\n\nstruct nacl_irt_blockhook {\n  int (*register_block_hooks)(void (*pre)(void), void (*post)(void));\n};\n\nextern size_t nacl_interface_query(const char *interface_ident,\n                            void *table, size_t tablesize);\n\nvoid nacl_initialize_gc_thread()\n{\n    int i;\n    static struct nacl_irt_blockhook gc_hook;\n\n    pthread_mutex_lock(&nacl_thread_alloc_lock);\n    if (!nacl_thread_parking_inited)\n    {\n        for (i = 0; i < MAX_NACL_GC_THREADS; i++) {\n            nacl_thread_used[i] = 0;\n            nacl_thread_parked[i] = 0;\n        }\n        // TODO: replace with public 'register hook' function when\n        // available from glibc\n        nacl_interface_query(\"nacl-irt-blockhook-0.1\", &gc_hook, sizeof(gc_hook));\n        gc_hook.register_block_hooks(nacl_pre_syscall_hook, nacl_post_syscall_hook);\n        nacl_thread_parking_inited = 1;\n    }\n    GC_ASSERT(nacl_num_gc_threads <= MAX_NACL_GC_THREADS);\n    for (i = 0; i < MAX_NACL_GC_THREADS; i++) {\n        if (nacl_thread_used[i] == 0) {\n            nacl_thread_used[i] = 1;\n            nacl_thread_idx = i;\n            nacl_num_gc_threads++;\n            break;\n        }\n    }\n    pthread_mutex_unlock(&nacl_thread_alloc_lock);\n}\n\nvoid nacl_shutdown_gc_thread()\n{\n    pthread_mutex_lock(&nacl_thread_alloc_lock);\n    GC_ASSERT(nacl_thread_idx >= 0 && nacl_thread_idx < MAX_NACL_GC_THREADS);\n    GC_ASSERT(nacl_thread_used[nacl_thread_idx] != 0);\n    nacl_thread_used[nacl_thread_idx] = 0;\n    nacl_thread_idx = -1;\n    nacl_num_gc_threads--;\n    pthread_mutex_unlock(&nacl_thread_alloc_lock);\n}\n\n#endif /* NACL */\n\n/* Add a thread to GC_threads.  We assume it wasn't already there.\t*/\n/* Caller holds allocation lock.\t\t\t\t\t*/\nGC_thread GC_new_thread(pthread_t id)\n{\n    int hv = ((unsigned long)id) % THREAD_TABLE_SZ;\n    GC_thread result;\n    static GC_bool first_thread_used = FALSE;\n    \n    if (!first_thread_used) {\n    \tresult = &first_thread;\n    \tfirst_thread_used = TRUE;\n    } else {\n        result = (struct GC_Thread_Rep *)\n        \t GC_INTERNAL_MALLOC(sizeof(struct GC_Thread_Rep), NORMAL);\n    }\n    if (result == 0) return(0);\n    result -> id = id;\n#ifdef HOST_ANDROID\n    result -> kernel_id = gettid();\n#endif\n    result -> next = GC_threads[hv];\n    GC_threads[hv] = result;\n#ifdef NACL\n    nacl_gc_thread_self = result;\n    nacl_initialize_gc_thread();\n#endif\n    GC_ASSERT(result -> flags == 0 && result -> thread_blocked == 0);\n    return(result);\n}\n\n/* Delete a thread from GC_threads.  We assume it is there.\t*/\n/* (The code intentionally traps if it wasn't.)\t\t\t*/\n/* Caller holds allocation lock.\t\t\t\t*/\nvoid GC_delete_thread(pthread_t id)\n{\n    int hv = ((unsigned long)id) % THREAD_TABLE_SZ;\n    register GC_thread p = GC_threads[hv];\n    register GC_thread prev = 0;\n    \n#ifdef NACL\n    nacl_shutdown_gc_thread();\n    nacl_gc_thread_self = NULL;\n#endif\n\n    while (!pthread_equal(p -> id, id)) {\n        prev = p;\n        p = p -> next;\n    }\n    if (prev == 0) {\n        GC_threads[hv] = p -> next;\n    } else {\n        prev -> next = p -> next;\n    }\n\t\n#ifdef GC_DARWIN_THREADS\n\tmach_port_deallocate(mach_task_self(), p->stop_info.mach_thread);\n#endif\n\t\n    GC_INTERNAL_FREE(p);\n}\n\n/* If a thread has been joined, but we have not yet\t\t*/\n/* been notified, then there may be more than one thread \t*/\n/* in the table with the same pthread id.\t\t\t*/\n/* This is OK, but we need a way to delete a specific one.\t*/\nvoid GC_delete_gc_thread(pthread_t id, GC_thread gc_id)\n{\n    int hv = ((unsigned long)id) % THREAD_TABLE_SZ;\n    register GC_thread p = GC_threads[hv];\n    register GC_thread prev = 0;\n\n    while (p != gc_id) {\n        prev = p;\n        p = p -> next;\n    }\n    if (prev == 0) {\n        GC_threads[hv] = p -> next;\n    } else {\n        prev -> next = p -> next;\n    }\n\t\n#ifdef GC_DARWIN_THREADS\n\tmach_port_deallocate(mach_task_self(), p->stop_info.mach_thread);\n#endif\n\t\n    GC_INTERNAL_FREE(p);\n}\n\n/* Return a GC_thread corresponding to a given pthread_t.\t*/\n/* Returns 0 if it's not there.\t\t\t\t\t*/\n/* Caller holds  allocation lock or otherwise inhibits \t\t*/\n/* updates.\t\t\t\t\t\t\t*/\n/* If there is more than one thread with the given id we \t*/\n/* return the most recent one.\t\t\t\t\t*/\nGC_thread GC_lookup_thread(pthread_t id)\n{\n    int hv = ((unsigned long)id) % THREAD_TABLE_SZ;\n    register GC_thread p = GC_threads[hv];\n    \n    while (p != 0 && !pthread_equal(p -> id, id)) p = p -> next;\n    return(p);\n}\n\nint GC_thread_is_registered (void)\n{\n\tvoid *ptr;\n\n\tLOCK();\n\tptr = (void *)GC_lookup_thread(pthread_self());\n\tUNLOCK();\n\n\treturn ptr ? 1 : 0;\n}\n\nvoid GC_register_altstack (void *stack, int stack_size, void *altstack, int altstack_size)\n{\n\tGC_thread thread;\n\n\tLOCK();\n\tthread = (void *)GC_lookup_thread(pthread_self());\n\tif (thread) {\n\t\tthread->stack = stack;\n\t\tthread->stack_size = stack_size;\n\t\tthread->altstack = altstack;\n\t\tthread->altstack_size = altstack_size;\n\t} else {\n\t\t/*\n\t\t * This happens if we are called before GC_thr_init ().\n\t\t */\n\t\tmain_pthread_self = pthread_self ();\n\t\tmain_stack = stack;\n\t\tmain_stack_size = stack_size;\n\t\tmain_altstack = altstack;\n\t\tmain_altstack_size = altstack_size;\n\t}\n\tUNLOCK();\n}\n\n#ifdef HANDLE_FORK\n/* Remove all entries from the GC_threads table, except the\t*/\n/* one for the current thread.  We need to do this in the child\t*/\n/* process after a fork(), since only the current thread \t*/\n/* survives in the child.\t\t\t\t\t*/\nvoid GC_remove_all_threads_but_me(void)\n{\n    pthread_t self = pthread_self();\n    int hv;\n    GC_thread p, next, me;\n\n    for (hv = 0; hv < THREAD_TABLE_SZ; ++hv) {\n      me = 0;\n      for (p = GC_threads[hv]; 0 != p; p = next) {\n\tnext = p -> next;\n\tif (p -> id == self) {\n\t  me = p;\n\t  p -> next = 0;\n\t} else {\n#\t  ifdef THREAD_LOCAL_ALLOC\n\t    if (!(p -> flags & FINISHED)) {\n\t      GC_destroy_thread_local(p);\n\t    }\n#\t  endif /* THREAD_LOCAL_ALLOC */\n\t    if (p != &first_thread) GC_INTERNAL_FREE(p);\n\t}\n      }\n      GC_threads[hv] = me;\n    }\n    GC_INTERNAL_FREE(p);\n}\n#endif /* HANDLE_FORK */\n\n#ifdef USE_PROC_FOR_LIBRARIES\nint GC_segment_is_thread_stack(ptr_t lo, ptr_t hi)\n{\n    int i;\n    GC_thread p;\n    \n#   ifdef PARALLEL_MARK\n      for (i = 0; i < GC_markers; ++i) {\n\tif (marker_sp[i] > lo & marker_sp[i] < hi) return 1;\n      }\n#   endif\n    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n      for (p = GC_threads[i]; p != 0; p = p -> next) {\n\tif (0 != p -> stack_end) {\n#\t  ifdef STACK_GROWS_UP\n            if (p -> stack_end >= lo && p -> stack_end < hi) return 1;\n#\t  else /* STACK_GROWS_DOWN */\n            if (p -> stack_end > lo && p -> stack_end <= hi) return 1;\n#\t  endif\n\t}\n      }\n    }\n    return 0;\n}\n#endif /* USE_PROC_FOR_LIBRARIES */\n\n#ifdef GC_LINUX_THREADS\n/* Return the number of processors, or i<= 0 if it can't be determined.\t*/\nint GC_get_nprocs()\n{\n#ifndef NACL\n    /* Should be \"return sysconf(_SC_NPROCESSORS_ONLN);\" but that\t*/\n    /* appears to be buggy in many cases.\t\t\t\t*/\n    /* We look for lines \"cpu<n>\" in /proc/stat.\t\t\t*/\n#   define STAT_BUF_SIZE 4096\n#   define STAT_READ read\n\t/* If read is wrapped, this may need to be redefined to call \t*/\n\t/* the real one.\t\t\t\t\t\t*/\n    char stat_buf[STAT_BUF_SIZE];\n    int f;\n    word result = 1;\n\t/* Some old kernels only have a single \"cpu nnnn ...\"\t*/\n\t/* entry in /proc/stat.  We identify those as \t\t*/\n\t/* uniprocessors.\t\t\t\t\t*/\n    size_t i, len = 0;\n\n    f = open(\"/proc/stat\", O_RDONLY);\n    if (f < 0 || (len = STAT_READ(f, stat_buf, STAT_BUF_SIZE)) < 100) {\n\tWARN(\"Couldn't read /proc/stat\\n\", 0);\n\treturn -1;\n    }\n    for (i = 0; i < len - 100; ++i) {\n        if (stat_buf[i] == '\\n' && stat_buf[i+1] == 'c'\n\t    && stat_buf[i+2] == 'p' && stat_buf[i+3] == 'u') {\n\t    int cpu_no = atoi(stat_buf + i + 4);\n\t    if (cpu_no >= result) result = cpu_no + 1;\n\t}\n    }\n    close(f);\n    return result;\n#else /* NACL */\n    return sysconf(_SC_NPROCESSORS_ONLN);\n#endif\n}\n#endif /* GC_LINUX_THREADS */\n\n/* We hold the GC lock.  Wait until an in-progress GC has finished.\t*/\n/* Repeatedly RELEASES GC LOCK in order to wait.\t\t\t*/\n/* If wait_for_all is true, then we exit with the GC lock held and no\t*/\n/* collection in progress; otherwise we just wait for the current GC\t*/\n/* to finish.\t\t\t\t\t\t\t\t*/\nextern GC_bool GC_collection_in_progress();\nvoid GC_wait_for_gc_completion(GC_bool wait_for_all)\n{\n    if (GC_incremental && GC_collection_in_progress()) {\n\tint old_gc_no = GC_gc_no;\n\n\t/* Make sure that no part of our stack is still on the mark stack, */\n\t/* since it's about to be unmapped.\t\t\t\t   */\n\twhile (GC_incremental && GC_collection_in_progress()\n\t       && (wait_for_all || old_gc_no == GC_gc_no)) {\n\t    ENTER_GC();\n\t    GC_in_thread_creation = TRUE;\n            GC_collect_a_little_inner(1);\n\t    GC_in_thread_creation = FALSE;\n\t    EXIT_GC();\n\t    UNLOCK();\n\t    sched_yield();\n\t    LOCK();\n\t}\n    }\n}\n\n#ifdef HANDLE_FORK\n/* Procedures called before and after a fork.  The goal here is to make */\n/* it safe to call GC_malloc() in a forked child.  It's unclear that is\t*/\n/* attainable, since the single UNIX spec seems to imply that one \t*/\n/* should only call async-signal-safe functions, and we probably can't\t*/\n/* quite guarantee that.  But we give it our best shot.  (That same\t*/\n/* spec also implies that it's not safe to call the system malloc\t*/\n/* between fork() and exec().  Thus we're doing no worse than it.\t*/\n\n/* Called before a fork()\t\t*/\nvoid GC_fork_prepare_proc(void)\n{\n    /* Acquire all relevant locks, so that after releasing the locks\t*/\n    /* the child will see a consistent state in which monitor \t\t*/\n    /* invariants hold.\t Unfortunately, we can't acquire libc locks\t*/\n    /* we might need, and there seems to be no guarantee that libc\t*/\n    /* must install a suitable fork handler.\t\t\t\t*/\n    /* Wait for an ongoing GC to finish, since we can't finish it in\t*/\n    /* the (one remaining thread in) the child.\t\t\t\t*/\n      LOCK();\n#     if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\n        GC_wait_for_reclaim();\n#     endif\n      GC_wait_for_gc_completion(TRUE);\n#     if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\n        GC_acquire_mark_lock();\n#     endif\n}\n\n/* Called in parent after a fork()\t*/\nvoid GC_fork_parent_proc(void)\n{\n#   if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\n      GC_release_mark_lock();\n#   endif\n    UNLOCK();\n}\n\n/* Called in child after a fork()\t*/\nvoid GC_fork_child_proc(void)\n{\n    /* Clean up the thread table, so that just our thread is left. */\n#   if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\n      GC_release_mark_lock();\n#   endif\n    GC_remove_all_threads_but_me();\n#   ifdef PARALLEL_MARK\n      /* Turn off parallel marking in the child, since we are probably \t*/\n      /* just going to exec, and we would have to restart mark threads.\t*/\n        GC_markers = 1;\n        GC_parallel = FALSE;\n#   endif /* PARALLEL_MARK */\n    UNLOCK();\n}\n#endif /* HANDLE_FORK */\n\n#if defined(GC_DGUX386_THREADS)\n/* Return the number of processors, or i<= 0 if it can't be determined. */\nint GC_get_nprocs()\n{\n    /* <takis@XFree86.Org> */\n    int numCpus;\n    struct dg_sys_info_pm_info pm_sysinfo;\n    int status =0;\n\n    status = dg_sys_info((long int *) &pm_sysinfo,\n\tDG_SYS_INFO_PM_INFO_TYPE, DG_SYS_INFO_PM_CURRENT_VERSION);\n    if (status < 0)\n       /* set -1 for error */\n       numCpus = -1;\n    else\n      /* Active CPUs */\n      numCpus = pm_sysinfo.idle_vp_count;\n\n#  ifdef DEBUG_THREADS\n    GC_printf1(\"Number of active CPUs in this system: %d\\n\", numCpus);\n#  endif\n    return(numCpus);\n}\n#endif /* GC_DGUX386_THREADS */\n\n/* We hold the allocation lock.\t*/\nvoid GC_thr_init()\n{\n#   ifndef GC_DARWIN_THREADS\n      int dummy;\n#   endif\n    GC_thread t;\n\n    if (GC_thr_initialized) return;\n    GC_thr_initialized = TRUE;\n    \n#   ifdef HANDLE_FORK\n      /* Prepare for a possible fork.\t*/\n        pthread_atfork(GC_fork_prepare_proc, GC_fork_parent_proc,\n\t  \t       GC_fork_child_proc);\n#   endif /* HANDLE_FORK */\n    /* Add the initial thread, so we can stop it.\t*/\n      t = GC_new_thread(pthread_self());\n#     ifdef GC_DARWIN_THREADS\n         t -> stop_info.mach_thread = mach_thread_self();\n#     else\n         t -> stop_info.stack_ptr = (ptr_t)(&dummy);\n#     endif\n      t -> flags = DETACHED | MAIN_THREAD;\n\t\t if (pthread_self () == main_pthread_self) {\n\t\t\t t->stack = main_stack;\n\t\t\t t->stack_size = main_stack_size;\n\t\t\t t->altstack = main_altstack;\n\t\t\t t->altstack_size = main_altstack_size;\n\t\t }\n\n    GC_stop_init();\n\n    /* Set GC_nprocs.  */\n      {\n\tchar * nprocs_string = GETENV(\"GC_NPROCS\");\n\tGC_nprocs = -1;\n\tif (nprocs_string != NULL) GC_nprocs = atoi(nprocs_string);\n      }\n      if (GC_nprocs <= 0) {\n#       if defined(GC_HPUX_THREADS)\n\t  GC_nprocs = pthread_num_processors_np();\n#       endif\n#\tif defined(GC_OSF1_THREADS) || defined(GC_AIX_THREADS) || defined(GC_HAIKU_THREADS)\n\t  GC_nprocs = sysconf(_SC_NPROCESSORS_ONLN);\n\t  if (GC_nprocs <= 0) GC_nprocs = 1;\n#\tendif\n#       if defined(GC_IRIX_THREADS)\n\t  GC_nprocs = sysconf(_SC_NPROC_ONLN);\n\t  if (GC_nprocs <= 0) GC_nprocs = 1;\n#       endif\n#       if defined(GC_DARWIN_THREADS) || defined(GC_FREEBSD_THREADS) || defined(GC_NETBSD_THREADS) || defined(GC_OPENBSD_THREADS)\n\t  int ncpus = 1;\n\t  size_t len = sizeof(ncpus);\n\t  sysctl((int[2]) {CTL_HW, HW_NCPU}, 2, &ncpus, &len, NULL, 0);\n\t  GC_nprocs = ncpus;\n#       endif\n#\tif defined(GC_LINUX_THREADS) || defined(GC_DGUX386_THREADS)\n          GC_nprocs = GC_get_nprocs();\n#\tendif\n      }\n      if (GC_nprocs <= 0) {\n\tWARN(\"GC_get_nprocs() returned %ld\\n\", GC_nprocs);\n\tGC_nprocs = 2;\n#\tifdef PARALLEL_MARK\n\t  GC_markers = 1;\n#\tendif\n      } else {\n#\tifdef PARALLEL_MARK\n          {\n\t    char * markers_string = GETENV(\"GC_MARKERS\");\n\t    if (markers_string != NULL) {\n\t      GC_markers = atoi(markers_string);\n\t    } else {\n\t      GC_markers = GC_nprocs;\n\t\t  if (GC_markers > MAX_MARKERS)\n\t\t\t  GC_markers = MAX_MARKERS;\n\t    }\n          }\n#\tendif\n      }\n#   ifdef PARALLEL_MARK\n#     ifdef CONDPRINT\n        if (GC_print_stats) {\n          GC_printf2(\"Number of processors = %ld, \"\n\t\t \"number of marker threads = %ld\\n\", GC_nprocs, GC_markers);\n\t}\n#     endif\n      if (GC_markers == 1) {\n\tGC_parallel = FALSE;\n#\tifdef CONDPRINT\n\t  if (GC_print_stats) {\n\t    GC_printf0(\"Single marker thread, turning off parallel marking\\n\");\n\t  }\n#\tendif\n      } else {\n\tGC_parallel = TRUE;\n\t/* Disable true incremental collection, but generational is OK.\t*/\n\tGC_time_limit = GC_TIME_UNLIMITED;\n      }\n      /* If we are using a parallel marker, actually start helper threads.  */\n        if (GC_parallel) start_mark_threads();\n#   endif\n}\n\n\n/* Perform all initializations, including those that\t*/\n/* may require allocation.\t\t\t\t*/\n/* Called without allocation lock.\t\t\t*/\n/* Must be called before a second thread is created.\t*/\n/* Called without allocation lock.\t\t\t*/\nvoid GC_init_parallel()\n{\n    if (parallel_initialized) return;\n    parallel_initialized = TRUE;\n\n    /* GC_init() calls us back, so set flag first.\t*/\n    if (!GC_is_initialized) GC_init();\n    /* Initialize thread local free lists if used.\t*/\n#   if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\n      LOCK();\n      GC_init_thread_local(GC_lookup_thread(pthread_self()));\n      UNLOCK();\n#   endif\n}\n\n\n#if !defined(GC_DARWIN_THREADS) && !defined(GC_OPENBSD_THREADS)\n#ifndef NACL\nint WRAP_FUNC(pthread_sigmask)(int how, const sigset_t *set, sigset_t *oset)\n{\n    sigset_t fudged_set;\n    \n    if (set != NULL && (how == SIG_BLOCK || how == SIG_SETMASK)) {\n        fudged_set = *set;\n        sigdelset(&fudged_set, SIG_SUSPEND);\n        set = &fudged_set;\n    }\n    return(REAL_FUNC(pthread_sigmask)(how, set, oset));\n}\n#endif\n#endif /* !GC_DARWIN_THREADS */\n\n/* Wrappers for functions that are likely to block for an appreciable\t*/\n/* length of time.  Must be called in pairs, if at all.\t\t\t*/\n/* Nothing much beyond the system call itself should be executed\t*/\n/* between these.\t\t\t\t\t\t\t*/\n\nvoid GC_start_blocking(void) {\n#   define SP_SLOP 128\n    GC_thread me;\n    LOCK();\n    me = GC_lookup_thread(pthread_self());\n#   ifdef SPARC\n\tme -> stop_info.stack_ptr = (ptr_t)GC_save_regs_in_stack();\n#   else\n#   ifndef GC_DARWIN_THREADS\n\tme -> stop_info.stack_ptr = (ptr_t)GC_approx_sp();\n#   endif\n#   endif\n#   ifdef IA64\n\tme -> backing_store_ptr = (ptr_t)GC_save_regs_in_stack() + SP_SLOP;\n#   endif\n    /* Add some slop to the stack pointer, since the wrapped call may \t*/\n    /* end up pushing more callee-save registers.\t\t\t*/\n#   ifndef GC_DARWIN_THREADS\n#   ifdef STACK_GROWS_UP\n\tme -> stop_info.stack_ptr += SP_SLOP;\n#   else\n\tme -> stop_info.stack_ptr -= SP_SLOP;\n#   endif\n#   endif\n    me -> thread_blocked = TRUE;\n    UNLOCK();\n}\n\nvoid GC_end_blocking(void) {\n    GC_thread me;\n    LOCK();   /* This will block if the world is stopped.\t*/\n    me = GC_lookup_thread(pthread_self());\n    me -> thread_blocked = FALSE;\n    UNLOCK();\n}\n    \n#if defined(GC_DGUX386_THREADS)\n#define __d10_sleep sleep\n#endif /* GC_DGUX386_THREADS */\n\n/* A wrapper for the standard C sleep function\t*/\nint WRAP_FUNC(sleep) (unsigned int seconds)\n{\n    int result;\n\n    GC_start_blocking();\n    result = REAL_FUNC(sleep)(seconds);\n    GC_end_blocking();\n    return result;\n}\n\nstruct start_info {\n    void *(*start_routine)(void *);\n    void *arg;\n    word flags;\n    sem_t registered;   \t/* 1 ==> in our thread table, but \t*/\n\t\t\t\t/* parent hasn't yet noticed.\t\t*/\n};\n\n/* Called at thread exit.\t\t\t\t*/\n/* Never called for main thread.  That's OK, since it\t*/\n/* results in at most a tiny one-time leak.  And \t*/\n/* linuxthreads doesn't reclaim the main threads \t*/\n/* resources or id anyway.\t\t\t\t*/\nvoid GC_thread_exit_proc(void *arg)\n{\n    GC_thread me;\n\n    LOCK();\n    me = GC_lookup_thread(pthread_self());\n    GC_destroy_thread_local(me);\n    if (me -> flags & DETACHED) {\n# ifdef THREAD_LOCAL_ALLOC\n\t\t/* NULL out the tls key to prevent the dtor function from being called */\n\t\tif (0 != GC_setspecific(GC_thread_key, NULL))\n\t\t\tABORT(\"Failed to set thread specific allocation pointers\");\n#endif\n    \tGC_delete_thread(pthread_self());\n    } else {\n\tme -> flags |= FINISHED;\n    }\n#   if defined(THREAD_LOCAL_ALLOC) && !defined(USE_PTHREAD_SPECIFIC) \\\n       && !defined(USE_COMPILER_TLS) && !defined(DBG_HDRS_ALL)\n      GC_remove_specific(GC_thread_key);\n#   endif\n    /* The following may run the GC from \"nonexistent\" thread.\t*/\n    GC_wait_for_gc_completion(FALSE);\n    UNLOCK();\n}\n\nint WRAP_FUNC(pthread_join)(pthread_t thread, void **retval)\n{\n    int result;\n    GC_thread thread_gc_id;\n    \n    LOCK();\n    thread_gc_id = GC_lookup_thread(thread);\n    /* This is guaranteed to be the intended one, since the thread id\t*/\n    /* cant have been recycled by pthreads.\t\t\t\t*/\n    UNLOCK();\n    result = REAL_FUNC(pthread_join)(thread, retval);\n# if defined (GC_FREEBSD_THREADS)\n    /* On FreeBSD, the wrapped pthread_join() sometimes returns (what\n       appears to be) a spurious EINTR which caused the test and real code\n       to gratuitously fail.  Having looked at system pthread library source\n       code, I see how this return code may be generated.  In one path of\n       code, pthread_join() just returns the errno setting of the thread\n       being joined.  This does not match the POSIX specification or the\n       local man pages thus I have taken the liberty to catch this one\n       spurious return value properly conditionalized on GC_FREEBSD_THREADS. */\n    if (result == EINTR) result = 0;\n# endif\n    if (result == 0) {\n        LOCK();\n        /* Here the pthread thread id may have been recycled. */\n        GC_delete_gc_thread(thread, thread_gc_id);\n        UNLOCK();\n    }\n    return result;\n}\n\n#ifdef NACL\n/* TODO: remove, NaCl glibc now supports pthread cleanup functions. */\nvoid\nWRAP_FUNC(pthread_exit)(void *status)\n{\n    REAL_FUNC(pthread_exit)(status);\n}\n#endif\n\nint\nWRAP_FUNC(pthread_detach)(pthread_t thread)\n{\n    int result;\n    GC_thread thread_gc_id;\n    \n    LOCK();\n    thread_gc_id = GC_lookup_thread(thread);\n    UNLOCK();\n    result = REAL_FUNC(pthread_detach)(thread);\n    if (result == 0) {\n      LOCK();\n      thread_gc_id -> flags |= DETACHED;\n      /* Here the pthread thread id may have been recycled. */\n      if (thread_gc_id -> flags & FINISHED) {\n        GC_delete_gc_thread(thread, thread_gc_id);\n      }\n      UNLOCK();\n    }\n    return result;\n}\n\nGC_bool GC_in_thread_creation = FALSE;\n\ntypedef void *(*ThreadStartFn)(void *);\nvoid * GC_start_routine_head(void * arg, void *base_addr,\n\t\t\t     ThreadStartFn *start, void **start_arg )\n{\n    struct start_info * si = arg;\n    void * result;\n    GC_thread me;\n    pthread_t my_pthread;\n\n    my_pthread = pthread_self();\n#   ifdef DEBUG_THREADS\n        GC_printf1(\"Starting thread 0x%lx\\n\", my_pthread);\n        GC_printf1(\"pid = %ld\\n\", (long) getpid());\n        GC_printf1(\"sp = 0x%lx\\n\", (long) &arg);\n#   endif\n    LOCK();\n    GC_in_thread_creation = TRUE;\n    me = GC_new_thread(my_pthread);\n    GC_in_thread_creation = FALSE;\n#ifdef GC_DARWIN_THREADS\n    me -> stop_info.mach_thread = mach_thread_self();\n#else\n    me -> stop_info.stack_ptr = 0;\n#endif\n    me -> flags = si -> flags;\n    /* me -> stack_end = GC_linux_stack_base(); -- currently (11/99)\t*/\n    /* doesn't work because the stack base in /proc/self/stat is the \t*/\n    /* one for the main thread.  There is a strong argument that that's\t*/\n    /* a kernel bug, but a pervasive one.\t\t\t\t*/\n#   ifdef STACK_GROWS_DOWN\n      me -> stack_end = (ptr_t)(((word)(base_addr) + (GC_page_size - 1))\n\t\t                & ~(GC_page_size - 1));\n#\t  ifndef GC_DARWIN_THREADS\n        me -> stop_info.stack_ptr = me -> stack_end - 0x10;\n#\t  endif\n\t/* Needs to be plausible, since an asynchronous stack mark\t*/\n\t/* should not crash.\t\t\t\t\t\t*/\n#   else\n      me -> stack_end = (ptr_t)((word)(base_addr) & ~(GC_page_size - 1));\n      me -> stop_info.stack_ptr = me -> stack_end + 0x10;\n#   endif\n    /* This is dubious, since we may be more than a page into the stack, */\n    /* and hence skip some of it, though it's not clear that matters.\t */\n#   ifdef IA64\n      me -> backing_store_end = (ptr_t)\n\t\t\t(GC_save_regs_in_stack() & ~(GC_page_size - 1));\n      /* This is also < 100% convincing.  We should also read this \t*/\n      /* from /proc, but the hook to do so isn't there yet.\t\t*/\n#   endif /* IA64 */\n    UNLOCK();\n\n    if (start) *start = si -> start_routine;\n    if (start_arg) *start_arg = si -> arg;\n\n\tif (!(si->flags & FOREIGN_THREAD))\n\t\tsem_post(&(si -> registered));\t/* Last action on si.\t*/\n    \t\t\t\t\t/* OK to deallocate.\t*/\n#   if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\n \tLOCK();\n        GC_init_thread_local(me);\n\tUNLOCK();\n#   endif\n\n    return me;\n}\n\nvoid GC_allow_register_threads (void)\n{\n    /* No-op for GC pre-v7. */\n}\n\nint GC_register_my_thread (struct GC_stack_base *sb)\n{\n    struct start_info si = { 0, }; /* stacked for legibility & locking */\n    GC_thread me;\n\n#   ifdef DEBUG_THREADS\n        GC_printf1( \"GC_register_my_thread %p\\n\", &si );\n#   endif\n\n    si.flags = FOREIGN_THREAD;\n\n    if (!parallel_initialized) GC_init_parallel();\n    LOCK();\n    if (!GC_thr_initialized) GC_thr_init();\n    me = GC_lookup_thread(pthread_self());\n    UNLOCK();\n    if (me != NULL)\n\treturn GC_DUPLICATE;\n\n    (void)GC_start_routine_head(&si, sb -> mem_base, NULL, NULL);\n    return GC_SUCCESS;\n}\n\nvoid * GC_start_routine(void * arg)\n{\n    int dummy;\n    struct start_info * si = arg;\n    void * result;\n    GC_thread me;\n    ThreadStartFn start;\n    void *start_arg;\n\n    me = GC_start_routine_head (arg, &dummy, &start, &start_arg);\n\n    pthread_cleanup_push(GC_thread_exit_proc, 0);\n#   ifdef DEBUG_THREADS\n\tGC_printf1(\"start_routine = 0x%lx\\n\", start);\n#   endif\n    result = (*start)(start_arg);\n#if DEBUG_THREADS\n        GC_printf1(\"Finishing thread 0x%x\\n\", pthread_self());\n#endif\n    me -> status = result;\n    pthread_cleanup_pop(1);\n    /* Cleanup acquires lock, ensuring that we can't exit\t\t*/\n    /* while a collection that thinks we're alive is trying to stop     */\n    /* us.\t\t\t\t\t\t\t\t*/\n    return(result);\n}\n\nint\nWRAP_FUNC(pthread_create)(pthread_t *new_thread,\n\t\t  const pthread_attr_t *attr,\n                  void *(*start_routine)(void *), void *arg)\n{\n    int result;\n    int detachstate;\n    word my_flags = 0;\n    struct start_info * si; \n\t/* This is otherwise saved only in an area mmapped by the thread */\n\t/* library, which isn't visible to the collector.\t\t */\n \n    /* We resist the temptation to muck with the stack size here,\t*/\n    /* even if the default is unreasonably small.  That's the client's\t*/\n    /* responsibility.\t\t\t\t\t\t\t*/\n\n    LOCK();\n    si = (struct start_info *)GC_INTERNAL_MALLOC(sizeof(struct start_info),\n\t\t\t\t\t\t NORMAL);\n    UNLOCK();\n    if (!parallel_initialized) GC_init_parallel();\n    if (0 == si) return(ENOMEM);\n    sem_init(&(si -> registered), 0, 0);\n    si -> start_routine = start_routine;\n    si -> arg = arg;\n    LOCK();\n    if (!GC_thr_initialized) GC_thr_init();\n#   ifdef GC_ASSERTIONS\n      {\n\tsize_t stack_size;\n\tif (NULL == attr) {\n\t   pthread_attr_t my_attr;\n\t   pthread_attr_init(&my_attr);\n\t   pthread_attr_getstacksize(&my_attr, &stack_size);\n\t} else {\n\t   pthread_attr_getstacksize(attr, &stack_size);\n\t}\n#       ifdef PARALLEL_MARK\n\t  GC_ASSERT(stack_size >= (8*HBLKSIZE*sizeof(word)));\n#       else\n          /* FreeBSD-5.3/Alpha: default pthread stack is 64K, \t*/\n\t  /* HBLKSIZE=8192, sizeof(word)=8\t\t\t*/\n\t  GC_ASSERT(stack_size >= 65536);\n#       endif\n\t/* Our threads may need to do some work for the GC.\t*/\n\t/* Ridiculously small threads won't work, and they\t*/\n\t/* probably wouldn't work anyway.\t\t\t*/\n      }\n#   endif\n    if (NULL == attr) {\n\tdetachstate = PTHREAD_CREATE_JOINABLE;\n    } else { \n        pthread_attr_getdetachstate(attr, &detachstate);\n    }\n    if (PTHREAD_CREATE_DETACHED == detachstate) my_flags |= DETACHED;\n    si -> flags = my_flags;\n    UNLOCK();\n#   ifdef DEBUG_THREADS\n        GC_printf1(\"About to start new thread from thread 0x%X\\n\",\n\t\t   pthread_self());\n#   endif\n\n    result = REAL_FUNC(pthread_create)(new_thread, attr, GC_start_routine, si);\n\n#   ifdef DEBUG_THREADS\n        GC_printf1(\"Started thread 0x%X\\n\", *new_thread);\n#   endif\n    /* Wait until child has been added to the thread table.\t\t*/\n    /* This also ensures that we hold onto si until the child is done\t*/\n    /* with it.  Thus it doesn't matter whether it is otherwise\t\t*/\n    /* visible to the collector.\t\t\t\t\t*/\n    if (0 == result) {\n\twhile (0 != sem_wait(&(si -> registered))) {\n            if (EINTR != errno) ABORT(\"sem_wait failed\");\n\t}\n    }\n    sem_destroy(&(si -> registered));\n    LOCK();\n    GC_INTERNAL_FREE(si);\n    UNLOCK();\n\n    return(result);\n}\n\n#ifdef GENERIC_COMPARE_AND_SWAP\n  pthread_mutex_t GC_compare_and_swap_lock = PTHREAD_MUTEX_INITIALIZER;\n\n  GC_bool GC_compare_and_exchange(volatile GC_word *addr,\n  \t\t\t          GC_word old, GC_word new_val)\n  {\n    GC_bool result;\n    pthread_mutex_lock(&GC_compare_and_swap_lock);\n    if (*addr == old) {\n      *addr = new_val;\n      result = TRUE;\n    } else {\n      result = FALSE;\n    }\n    pthread_mutex_unlock(&GC_compare_and_swap_lock);\n    return result;\n  }\n  \n  GC_word GC_atomic_add(volatile GC_word *addr, GC_word how_much)\n  {\n    GC_word old;\n    pthread_mutex_lock(&GC_compare_and_swap_lock);\n    old = *addr;\n    *addr = old + how_much;\n    pthread_mutex_unlock(&GC_compare_and_swap_lock);\n    return old;\n  }\n\n#endif /* GENERIC_COMPARE_AND_SWAP */\n/* Spend a few cycles in a way that can't introduce contention with\t*/\n/* othre threads.\t\t\t\t\t\t\t*/\nvoid GC_pause()\n{\n    int i;\n#   if !defined(__GNUC__) || defined(__INTEL_COMPILER)\n      volatile word dummy = 0;\n#   endif\n\n    for (i = 0; i < 10; ++i) { \n#     if defined(__GNUC__) && !defined(__INTEL_COMPILER)\n        __asm__ __volatile__ (\" \" : : : \"memory\");\n#     else\n\t/* Something that's unlikely to be optimized away. */\n\tGC_noop(++dummy);\n#     endif\n    }\n}\n    \n#define SPIN_MAX 128\t/* Maximum number of calls to GC_pause before\t*/\n\t\t\t/* give up.\t\t\t\t\t*/\n\nVOLATILE GC_bool GC_collecting = 0;\n\t\t\t/* A hint that we're in the collector and       */\n                        /* holding the allocation lock for an           */\n                        /* extended period.                             */\n\n#if !defined(USE_SPIN_LOCK) || defined(PARALLEL_MARK)\n/* If we don't want to use the below spinlock implementation, either\t*/\n/* because we don't have a GC_test_and_set implementation, or because \t*/\n/* we don't want to risk sleeping, we can still try spinning on \t*/\n/* pthread_mutex_trylock for a while.  This appears to be very\t\t*/\n/* beneficial in many cases.\t\t\t\t\t\t*/\n/* I suspect that under high contention this is nearly always better\t*/\n/* than the spin lock.  But it's a bit slower on a uniprocessor.\t*/\n/* Hence we still default to the spin lock.\t\t\t\t*/\n/* This is also used to acquire the mark lock for the parallel\t\t*/\n/* marker.\t\t\t\t\t\t\t\t*/\n\n/* Here we use a strict exponential backoff scheme.  I don't know \t*/\n/* whether that's better or worse than the above.  We eventually \t*/\n/* yield by calling pthread_mutex_lock(); it never makes sense to\t*/\n/* explicitly sleep.\t\t\t\t\t\t\t*/\n\n#define LOCK_STATS\n#ifdef LOCK_STATS\n  unsigned long GC_spin_count = 0;\n  unsigned long GC_block_count = 0;\n  unsigned long GC_unlocked_count = 0;\n#endif\n\nvoid GC_generic_lock(pthread_mutex_t * lock)\n{\n#ifndef NO_PTHREAD_TRYLOCK\n    unsigned pause_length = 1;\n    unsigned i;\n    \n    if (0 == pthread_mutex_trylock(lock)) {\n#       ifdef LOCK_STATS\n\t    ++GC_unlocked_count;\n#       endif\n\treturn;\n    }\n    for (; pause_length <= SPIN_MAX; pause_length <<= 1) {\n\tfor (i = 0; i < pause_length; ++i) {\n\t    GC_pause();\n\t}\n        switch(pthread_mutex_trylock(lock)) {\n\t    case 0:\n#\t\tifdef LOCK_STATS\n\t\t    ++GC_spin_count;\n#\t\tendif\n\t\treturn;\n\t    case EBUSY:\n\t\tbreak;\n\t    default:\n\t\tABORT(\"Unexpected error from pthread_mutex_trylock\");\n        }\n    }\n#endif /* !NO_PTHREAD_TRYLOCK */\n#   ifdef LOCK_STATS\n\t++GC_block_count;\n#   endif\n    pthread_mutex_lock(lock);\n}\n\n#endif /* !USE_SPIN_LOCK || PARALLEL_MARK */\n\n#if defined(USE_SPIN_LOCK)\n\n/* Reasonably fast spin locks.  Basically the same implementation */\n/* as STL alloc.h.  This isn't really the right way to do this.   */\n/* but until the POSIX scheduling mess gets straightened out ...  */\n\nvolatile unsigned int GC_allocate_lock = 0;\n\n\nvoid GC_lock()\n{\n#   define low_spin_max 30  /* spin cycles if we suspect uniprocessor */\n#   define high_spin_max SPIN_MAX /* spin cycles for multiprocessor */\n    static unsigned spin_max = low_spin_max;\n    unsigned my_spin_max;\n    static unsigned last_spins = 0;\n    unsigned my_last_spins;\n    int i;\n\n    if (!GC_test_and_set(&GC_allocate_lock)) {\n        return;\n    }\n    my_spin_max = spin_max;\n    my_last_spins = last_spins;\n    for (i = 0; i < my_spin_max; i++) {\n        if (GC_collecting || GC_nprocs == 1) goto yield;\n        if (i < my_last_spins/2 || GC_allocate_lock) {\n            GC_pause();\n            continue;\n        }\n        if (!GC_test_and_set(&GC_allocate_lock)) {\n\t    /*\n             * got it!\n             * Spinning worked.  Thus we're probably not being scheduled\n             * against the other process with which we were contending.\n             * Thus it makes sense to spin longer the next time.\n\t     */\n            last_spins = i;\n            spin_max = high_spin_max;\n            return;\n        }\n    }\n    /* We are probably being scheduled against the other process.  Sleep. */\n    spin_max = low_spin_max;\nyield:\n    for (i = 0;; ++i) {\n        if (!GC_test_and_set(&GC_allocate_lock)) {\n            return;\n        }\n#       define SLEEP_THRESHOLD 12\n\t\t/* Under Linux very short sleeps tend to wait until\t*/\n\t\t/* the current time quantum expires.  On old Linux\t*/\n\t\t/* kernels nanosleep(<= 2ms) just spins under Linux.    */\n\t\t/* (Under 2.4, this happens only for real-time\t\t*/\n\t\t/* processes.)  We want to minimize both behaviors\t*/\n\t\t/* here.\t\t\t\t\t\t*/\n        if (i < SLEEP_THRESHOLD) {\n            sched_yield();\n\t} else {\n\t    struct timespec ts;\n\t\n\t    if (i > 24) i = 24;\n\t\t\t/* Don't wait for more than about 15msecs, even\t*/\n\t\t\t/* under extreme contention.\t\t\t*/\n\t    ts.tv_sec = 0;\n\t    ts.tv_nsec = 1 << i;\n\t    nanosleep(&ts, 0);\n\t}\n    }\n}\n\n#else  /* !USE_SPINLOCK */\nvoid GC_lock()\n{\n#ifndef NO_PTHREAD_TRYLOCK\n    if (1 == GC_nprocs || GC_collecting) {\n\tpthread_mutex_lock(&GC_allocate_ml);\n    } else {\n        GC_generic_lock(&GC_allocate_ml);\n    }\n#else  /* !NO_PTHREAD_TRYLOCK */\n    pthread_mutex_lock(&GC_allocate_ml);\n#endif /* !NO_PTHREAD_TRYLOCK */\n}\n\n#endif /* !USE_SPINLOCK */\n\n#if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\n\n#ifdef GC_ASSERTIONS\n  pthread_t GC_mark_lock_holder = NO_THREAD;\n#endif\n\n#if 0\n  /* Ugly workaround for a linux threads bug in the final versions      */\n  /* of glibc2.1.  Pthread_mutex_trylock sets the mutex owner           */\n  /* field even when it fails to acquire the mutex.  This causes        */\n  /* pthread_cond_wait to die.  Remove for glibc2.2.                    */\n  /* According to the man page, we should use                           */\n  /* PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP, but that isn't actually   */\n  /* defined.                                                           */\n  static pthread_mutex_t mark_mutex =\n        {0, 0, 0, PTHREAD_MUTEX_ERRORCHECK_NP, {0, 0}};\n#else\n  static pthread_mutex_t mark_mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif\n\nstatic pthread_cond_t builder_cv = PTHREAD_COND_INITIALIZER;\n\nvoid GC_acquire_mark_lock()\n{\n/*\n    if (pthread_mutex_lock(&mark_mutex) != 0) {\n\tABORT(\"pthread_mutex_lock failed\");\n    }\n*/\n    GC_generic_lock(&mark_mutex);\n#   ifdef GC_ASSERTIONS\n\tGC_mark_lock_holder = pthread_self();\n#   endif\n}\n\nvoid GC_release_mark_lock()\n{\n    GC_ASSERT(GC_mark_lock_holder == pthread_self());\n#   ifdef GC_ASSERTIONS\n\tGC_mark_lock_holder = NO_THREAD;\n#   endif\n    if (pthread_mutex_unlock(&mark_mutex) != 0) {\n\tABORT(\"pthread_mutex_unlock failed\");\n    }\n}\n\n/* Collector must wait for a freelist builders for 2 reasons:\t\t*/\n/* 1) Mark bits may still be getting examined without lock.\t\t*/\n/* 2) Partial free lists referenced only by locals may not be scanned \t*/\n/*    correctly, e.g. if they contain \"pointer-free\" objects, since the\t*/\n/*    free-list link may be ignored.\t\t\t\t\t*/\nvoid GC_wait_builder()\n{\n    GC_ASSERT(GC_mark_lock_holder == pthread_self());\n#   ifdef GC_ASSERTIONS\n\tGC_mark_lock_holder = NO_THREAD;\n#   endif\n    if (pthread_cond_wait(&builder_cv, &mark_mutex) != 0) {\n\tABORT(\"pthread_cond_wait failed\");\n    }\n    GC_ASSERT(GC_mark_lock_holder == NO_THREAD);\n#   ifdef GC_ASSERTIONS\n\tGC_mark_lock_holder = pthread_self();\n#   endif\n}\n\nvoid GC_wait_for_reclaim()\n{\n    GC_acquire_mark_lock();\n    while (GC_fl_builder_count > 0) {\n\tGC_wait_builder();\n    }\n    GC_release_mark_lock();\n}\n\nvoid GC_notify_all_builder()\n{\n    GC_ASSERT(GC_mark_lock_holder == pthread_self());\n    if (pthread_cond_broadcast(&builder_cv) != 0) {\n\tABORT(\"pthread_cond_broadcast failed\");\n    }\n}\n\n#endif /* PARALLEL_MARK || THREAD_LOCAL_ALLOC */\n\n#ifdef PARALLEL_MARK\n\nstatic pthread_cond_t mark_cv = PTHREAD_COND_INITIALIZER;\n\nvoid GC_wait_marker()\n{\n    GC_ASSERT(GC_mark_lock_holder == pthread_self());\n#   ifdef GC_ASSERTIONS\n\tGC_mark_lock_holder = NO_THREAD;\n#   endif\n    if (pthread_cond_wait(&mark_cv, &mark_mutex) != 0) {\n\tABORT(\"pthread_cond_wait failed\");\n    }\n    GC_ASSERT(GC_mark_lock_holder == NO_THREAD);\n#   ifdef GC_ASSERTIONS\n\tGC_mark_lock_holder = pthread_self();\n#   endif\n}\n\nvoid GC_notify_all_marker()\n{\n    if (pthread_cond_broadcast(&mark_cv) != 0) {\n\tABORT(\"pthread_cond_broadcast failed\");\n    }\n}\n\n#endif /* PARALLEL_MARK */\n\n# endif /* GC_LINUX_THREADS and friends */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/configure.ac": "# Copyright (c) 1999-2001 by Red Hat, Inc. All rights reserved.\n# \n# THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n# OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n# \n# Permission is hereby granted to use or copy this program\n# for any purpose,  provided the above notices are retained on all copies.\n# Permission to modify the code and to distribute modified code is granted,\n# provided the above notices are retained, and a notice that the code was\n# modified is included with the above copyright notice.\n#\n# Original author: Tom Tromey\n# Modified by: Grzegorz Jakacki <jakacki at acm dot org>\n\ndnl Process this file with autoconf to produce configure.\n\nAC_PREREQ([2.53])\nAC_INIT([libgc-mono], [6.6], [Hans_Boehm@hp.com])\n\nAM_INIT_AUTOMAKE([1.9 no-define foreign])\nAC_CONFIG_SRCDIR(gcj_mlc.c)\nAC_CONFIG_MACRO_DIR([m4])\nAC_CANONICAL_HOST\n\nAC_SUBST(PACKAGE)\nAC_SUBST(GC_VERSION)\n\nAC_PROG_CC\nAC_PROG_CXX\n\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n\ndnl automake 1.6 and later need the AM_PROG_AS macro.\nifdef([AM_PROG_AS],[AM_PROG_AS],[])\nAC_CHECK_TOOL(AR, ar)\nAC_CHECK_TOOL(RANLIB, ranlib, :)  # :)\n\nAC_PROG_INSTALL\n\nAM_MAINTAINER_MODE\n\n. [$]{srcdir}/configure.host\n\n# We use a separate variable to pass down CPPFLAGS and CFLAGS from the main mono \n# configure, because of autoconf brokeness\nif test \"x$CPPFLAGS_FOR_LIBGC\" != \"x\"; then\n   CPPFLAGS=$CPPFLAGS_FOR_LIBGC\nfi\nif test \"x$CFLAGS_FOR_LIBGC\" != \"x\"; then\n   CFLAGS=$CFLAGS_FOR_LIBGC\nfi\n\nGC_CFLAGS=${gc_cflags}\nAC_SUBST(GC_CFLAGS)\n\ncase $enable_embed_check in\nno) ;;\n*) AC_MSG_ERROR([This module is now part of 'mono' and cannot be built as a stand-alone module any longer.]) ;;\nesac\n\nTHREADS=$with_libgc_threads\n\nAC_ARG_ENABLE(win32-dllmain,\n[  --enable-win32-dllmain    Define the DllMain function in win32_threads.c even if the collector is not built as a dll],\n)\n\nAC_ARG_ENABLE(parallel-mark,\n[  --enable-parallel-mark\tparallelize marking and free list construction],\n   [case \"$THREADS\" in\n      no | none | single)\n\tAC_MSG_ERROR([Parallel mark requires --enable-threads=x spec])\n\t;;\n    esac]\n)\n\nAC_ARG_ENABLE(cplusplus,\n[  --enable-cplusplus\t\tinstall C++ support],\n)\n\nAM_CPPFLAGS=-I${srcdir}/include\nTHREADDLLIBS=\n## Libraries needed to support dynamic loading and/or threads.\ncase \"$THREADS\" in\n no | none | single)\n    THREADS=none\n    ;;\n posix | pthreads)\n    THREADS=posix\n    AC_CHECK_LIB(pthread, pthread_self, THREADDLLIBS=\"-lpthread\",,)\n    case \"$host\" in\n     x86-*-linux* | ia64-*-linux* | i386-*-linux* | i486-*-linux* | i586-*-linux* | i686-*-linux* | x86_64-*-linux* | alpha*-*-linux* | s390*-*-linux* | sparc*-*-linux* | powerpc-*-linux*)\n\tAC_DEFINE(GC_LINUX_THREADS)\n\tAC_DEFINE(_REENTRANT)\n        if test \"${enable_parallel_mark}\" = yes; then\n\t  AC_DEFINE(PARALLEL_MARK)\n\tfi\n\tAC_DEFINE(THREAD_LOCAL_ALLOC)\n\t;;\n     *-*-linux* | *-*-nacl*)\n\tAC_DEFINE(GC_LINUX_THREADS)\n\tAC_DEFINE(_REENTRANT)\n\t;;\n     *-*-aix*)\n\tAC_DEFINE(GC_AIX_THREADS)\n\tAC_DEFINE(_REENTRANT)\n\t;;\n     *-*-haiku*)\n\tAC_DEFINE(GC_HAIKU_THREADS)\n\tAC_DEFINE(_REENTRANT)\n\t;;\n     *-*-hpux*)\n\tAC_MSG_WARN(\"Only HP/UX 11 threads are supported.\")\n\tAC_DEFINE(GC_HPUX_THREADS)\n\tAC_DEFINE(_POSIX_C_SOURCE,199506L)\n\tif test \"${enable_parallel_mark}\" = yes; then\n\t  AC_DEFINE(PARALLEL_MARK)\n\tfi\n\tAC_DEFINE(THREAD_LOCAL_ALLOC)\n\tTHREADDLLIBS=\"-lpthread -lrt\"\n\t;;\n     *-*-kfreebsd*-gnu)\n\tAC_DEFINE(GC_FREEBSD_THREADS)\n\tINCLUDES=\"$INCLUDES -pthread\"\n\tTHREADDLLIBS=-pthread\n\tAC_DEFINE(_REENTRANT)\n\tif test \"${enable_parallel_mark}\" = yes; then\n\t\tAC_DEFINE(PARALLEL_MARK)\n\tfi\n\tAC_DEFINE(THREAD_LOCAL_ALLOC)\n\tAC_DEFINE(USE_COMPILER_TLS)\n\t;;\n      *-*-freebsd*)\n\tAC_DEFINE(GC_FREEBSD_THREADS)\n\tif test \"x$PTHREAD_CFLAGS\" != \"x\"; then\n\t\tAM_CPPFLAGS=\"$AM_CPPFLAGS $PTHREAD_CFLAGS\"\n\tfi\n\tif test \"x$PTHREAD_LIBS\" = \"x\"; then\n\t\tTHREADDLLIBS=-pthread\n\telse\n\t\tTHREADDLLIBS=\"$PTHREAD_LIBS\"\n\tfi\n\tAC_DEFINE(THREAD_LOCAL_ALLOC)\n\t;;\n     *-*-solaris*)\n\tAC_DEFINE(GC_SOLARIS_THREADS)\n\tAC_DEFINE(GC_SOLARIS_PTHREADS)\n\t;;\n     *-*-irix*)\n\tAC_DEFINE(GC_IRIX_THREADS)\n\t;;\n     *-*-cygwin*)\n\tAC_DEFINE(GC_WIN32_THREADS)\n\t;;\n     *-*-darwin*)\n\tAC_DEFINE(GC_DARWIN_THREADS)\n\tAC_DEFINE(THREAD_LOCAL_ALLOC)\n\tif test \"${enable_parallel_mark}\" = yes; then\n\t  AC_DEFINE(PARALLEL_MARK)\n\tfi\n\t;;\n     *-*-netbsd*)\n\tAC_DEFINE(GC_NETBSD_THREADS)\n\tif test \"${enable_parallel_mark}\" = yes; then\n\t  AC_DEFINE(PARALLEL_MARK)\n\tfi\n\tAC_DEFINE(THREAD_LOCAL_ALLOC)\n\t;;\n     *-*-openbsd*)\n\tAC_DEFINE(GC_OPENBSD_THREADS)\n\tif test \"${enable_parallel_mark}\" = yes; then\n\t  AC_DEFINE(PARALLEL_MARK)\n\tfi\n\tAC_DEFINE(THREAD_LOCAL_ALLOC)\n\t;;\n     *-*-osf*)\n\tAC_DEFINE(GC_OSF1_THREADS)\n        if test \"${enable_parallel_mark}\" = yes; then\n\t  AC_DEFINE(PARALLEL_MARK)\n\t  AC_DEFINE(THREAD_LOCAL_ALLOC)\n\t  # May want to enable it in other cases, too.\n\t  # Measurements havent yet been done.\n\tfi\n\tAM_CPPFLAGS=\"$AM_CPPFLAGS -pthread\"\n\tTHREADDLLIBS=\"-lpthread -lrt\"\n\t;;\n      *)\n\tAC_MSG_ERROR(\"Pthreads not supported by the GC on this platform.\")\n\t;;\n    esac\n    ;;\n win32)\n    AC_DEFINE(GC_WIN32_THREADS)\n    dnl Wine getenv may not return NULL for missing entry\n    AC_DEFINE(NO_GETENV)\n\tif test \"${enable_win32_dllmain}\" = yes; then\n\t   AC_DEFINE(GC_INSIDE_DLL)\n\tfi\n    ;;\n dgux386)\n    THREADS=dgux386\n    AC_MSG_RESULT($THREADDLLIBS)\n    # Use pthread GCC  switch\n    THREADDLLIBS=-pthread\n    if test \"${enable_parallel_mark}\" = yes; then\n        AC_DEFINE(PARALLEL_MARK)\n    fi\n    AC_DEFINE(THREAD_LOCAL_ALLOC)\n    AC_DEFINE(GC_DGUX386_THREADS)\n    AC_DEFINE(DGUX_THREADS)\n    # Enable _POSIX4A_DRAFT10_SOURCE with flag -pthread\n    AM_CPPFLAGS=\"-pthread $AM_CPPFLAGS\"\n    ;;\n aix)\n    THREADS=posix\n    THREADDLLIBS=-lpthread\n    AC_DEFINE(GC_AIX_THREADS)\n    AC_DEFINE(_REENTRANT)\n    ;;\n decosf1 | irix | mach | os2 | solaris | dce | vxworks)\n    AC_MSG_ERROR(thread package $THREADS not yet supported)\n    ;;\n *)\n    AC_MSG_ERROR($THREADS is an unknown thread package)\n    ;;\nesac\nAC_SUBST(THREADDLLIBS)\n\ncase \"$host\" in \n   powerpc-*-darwin*)\n      powerpc_darwin=true\n      ;;\nesac\nAM_CONDITIONAL(POWERPC_DARWIN,test x$powerpc_darwin = xtrue)\n\n# Check if the GCC builtin __sync_bool_compare_and_swap is available.\n# It is preferred in gc_locks.h for PPC as GCC 4.4 has a problem with the inline assembly there.\nAC_MSG_CHECKING(for __sync_bool_compare_and_swap)\nAC_TRY_COMPILE([],[\nvolatile unsigned int foo = 0;\nunsigned int r1 = __sync_bool_compare_and_swap(&foo, 0, 1);\nreturn 0;\n], [\nAC_MSG_RESULT(yes)\nAC_DEFINE(HAS___SYNC_BOOL_COMPARE_AND_SWAP)\n], [\nAC_MSG_RESULT(no)\n])\n\nAC_MSG_CHECKING(for xlc)\nAC_TRY_COMPILE([],[\n #ifndef __xlC__\n # error\n #endif\n], [compiler_xlc=yes], [compiler_xlc=no])\nAC_MSG_RESULT($compiler_xlc)\nAM_CONDITIONAL(COMPILER_XLC,test $compiler_xlc = yes)\nif test $compiler_xlc = yes -a \"$powerpc_darwin\" = true; then\n  # the darwin stack-frame-walking code is completely broken on xlc\n  AC_DEFINE(DARWIN_DONT_PARSE_STACK)\nfi\n\n# We never want libdl on darwin. It is a fake libdl that just ends up making\n# dyld calls anyway\ncase \"$host\" in\n  *-*-darwin*) ;;\n  *) \n    AC_CHECK_LIB(dl, dlopen, THREADDLLIBS=\"$THREADDLLIBS -ldl\")\n    ;;\nesac\n\nAC_SUBST(EXTRA_TEST_LIBS)\n\ntarget_all=libgc.la\nAC_SUBST(target_all)\n\ndnl If the target is an eCos system, use the appropriate eCos\ndnl I/O routines.\ndnl FIXME: this should not be a local option but a global target\ndnl system; at present there is no eCos target.\nTARGET_ECOS=\"no\"\nAC_ARG_WITH(ecos,\n[  --with-ecos             enable runtime eCos target support],\nTARGET_ECOS=\"$with_ecos\"\n)\n\naddobjs=\naddlibs=\naddincludes=\naddtests=\nCXXAM_CPPFLAGS=\ncase \"$TARGET_ECOS\" in\n   no)\n      ;;\n   *)\n      AC_DEFINE(ECOS)\n      CXXINCLUDES=\"-I${TARGET_ECOS}/include\"\n      addobjs=\"$addobjs ecos.lo\"\n      ;;\nesac\n\nif test \"${enable_cplusplus}\" = yes; then\n      addincludes=\"$addincludes include/gc_cpp.h include/gc_allocator.h\"\n      addtests=\"$addtests test_cpp\"\nfi\n\nAM_CONDITIONAL(CPLUSPLUS, test \"${enable_cplusplus}\" = yes)\n\nAC_SUBST(CXX)\n\nAC_SUBST(AM_CPPFLAGS)\nAC_SUBST(CXXINCLUDES)\n\n# Configuration of shared libraries\n#\nAC_MSG_CHECKING(whether to build shared libraries)\nAC_ENABLE_SHARED\n\ncase \"$host\" in\n alpha-*-openbsd*)\n     enable_shared=no\n     AC_MSG_RESULT(no)\n     ;;\n *)\n     AC_MSG_RESULT(yes)\n     ;;\nesac\n\n# Configuration of machine-dependent code\n#\nAC_MSG_CHECKING(which machine-dependent code should be used) \nmachdep=\ncase \"$host\" in\n alpha-*-openbsd*)\n    machdep=\"alpha_mach_dep.lo\"\n    if test x\"${ac_cv_lib_dl_dlopen}\" != xyes ; then\n       AC_MSG_WARN(OpenBSD/Alpha without dlopen(). Shared library support is disabled)\n    fi\n    ;;\n alpha*-*-linux*)\n    machdep=\"alpha_mach_dep.lo\"\n    ;;\n i?86-*-solaris2.[[89]] | i?86-*-solaris2.1?)\n    AC_DEFINE(SOLARIS25_PROC_VDB_BUG_FIXED)\n    ;;\n mipstx39-*-elf*)\n    machdep=\"mips_ultrix_mach_dep.lo\"\n    AC_DEFINE(STACKBASE, __stackbase)\n    AC_DEFINE(DATASTART_IS_ETEXT)\n    ;;\n mips-dec-ultrix*)\n    machdep=\"mips_ultrix_mach-dep.lo\"\n    ;;\n mips-nec-sysv*|mips-unknown-sysv*)\n    ;;\n mips*-*-linux*) \n    ;; \n mips-*-*)\n    machdep=\"mips_sgi_mach_dep.lo\"\n    AC_DEFINE(NO_EXECUTE_PERMISSION)\n    ;;\n sparc-*-netbsd*)\n    machdep=\"sparc_netbsd_mach_dep.lo\"\n    ;;\n sparc-sun-solaris2.3)\n    machdep=\"sparc_mach_dep.lo\"\n    AC_DEFINE(SUNOS53_SHARED_LIB)\n    ;;\n sparc*-sun-solaris2.*)\n    machdep=\"sparc_mach_dep.lo\"\n    ;;\n ia64-*-*)\n     machdep=\"mach_dep.lo ia64_save_regs_in_stack.lo\"\n\ttarget_ia64=true\n    ;;\n *-*-nacl*)\n    AC_DEFINE(NO_EXECUTE_PERMISSION)\n    ;;\nesac\nif test x\"$machdep\" = x; then\nAC_MSG_RESULT($machdep)\n   machdep=\"mach_dep.lo\"\nfi\naddobjs=\"$addobjs $machdep\"\n#\n# Adding object files directly to _LIBADD breaks -j builds, so we need to add the sources\n# instead, but _SOURCES can't contain autoconf substitutions, so add them using automake\n# conditionals.\n#\n#AC_SUBST(addobjs)\nAC_SUBST(addincludes)\nAC_SUBST(addlibs)\nAC_SUBST(addtests)\n\nAM_CONDITIONAL(TARGET_IA64,test x$target_ia64 = xtrue)\n\nAC_PROG_LIBTOOL\n# Use dolt (http://dolt.freedesktop.org/) instead of libtool for building.\nDOLT\n\n#\n# Check for AViiON Machines running DGUX\n#\nac_is_dgux=no\nAC_CHECK_HEADER(sys/dg_sys_info.h,\n[ac_is_dgux=yes;])\n\n    ## :GOTCHA: we do not check anything but sys/dg_sys_info.h\nif test $ac_is_dgux = yes; then\n    if test \"$enable_full_debug\" = \"yes\"; then\n      CFLAGS=\"-g -mstandard -DDGUX -D_DGUX_SOURCE -Di386 -mno-legend -O2\"\n      CXXFLAGS=\"-g -mstandard -DDGUX -D_DGUX_SOURCE -Di386 -mno-legend -O2\"\n    else\n      CFLAGS=\"-DDGUX -D_DGUX_SOURCE -Di386 -mno-legend -O2\"\n      CXXFLAGS=\"-DDGUX -D_DGUX_SOURCE -Di386 -mno-legend -O2\"\n    fi\n    AC_SUBST(CFLAGS)\n    AC_SUBST(CXXFLAGS)\nfi\n\ndnl We use these options to decide which functions to include.\nAC_ARG_WITH(target-subdir,\n[  --with-target-subdir=SUBDIR\n                          configuring with a cross compiler])\nAC_ARG_WITH(cross-host,\n[  --with-cross-host=HOST  configuring with a cross compiler])\n\n# automake wants to see AC_EXEEXT.  But we don't need it.  And having\n# it is actually a problem, because the compiler we're passed can't\n# necessarily do a full link.  So we fool automake here.\nif false; then\n  # autoconf 2.50 runs AC_EXEEXT by default, and the macro expands\n  # to nothing, so nothing would remain between `then' and `fi' if it\n  # were not for the `:' below.\n  :\n  AC_EXEEXT\nfi\n\nAC_MSG_CHECKING([for threads package to use])\nAC_MSG_RESULT($THREADS)\n\ndnl As of 4.13a2, the collector will not properly work on Solaris when\ndnl built with gcc and -O.  So we remove -O in the appropriate case.\ndnl Not needed anymore on Solaris.\nAC_MSG_CHECKING(whether Solaris gcc optimization fix is necessary)\ncase \"$host\" in\n *aix*)\n    if test \"$GCC\" = yes; then\n       AC_MSG_RESULT(yes)\n       new_CFLAGS=\n       for i in $CFLAGS; do\n\t  case \"$i\" in\n\t   -O*)\n\t      ;;\n\t   *)\n\t      new_CFLAGS=\"$new_CFLAGS $i\"\n\t      ;;\n\t  esac\n       done\n       CFLAGS=\"$new_CFLAGS\"\n    else\n       AC_MSG_RESULT(no)\n    fi\n    ;;\n *) AC_MSG_RESULT(no) ;;\nesac\n\ndnl We need to override the top-level CFLAGS.  This is how we do it.\nMY_CFLAGS=\"$CFLAGS\"\nAC_SUBST(MY_CFLAGS)\n\ndnl Include defines that have become de facto standard.\ndnl ALL_INTERIOR_POINTERS can be overridden in startup code.\nAC_DEFINE(SILENT)\nAC_DEFINE(NO_SIGNALS)\nAC_DEFINE(NO_EXECUTE_PERMISSION)\ndnl AC_DEFINE(ALL_INTERIOR_POINTERS)\n\ndnl By default, make the library as general as possible.\nAC_DEFINE(JAVA_FINALIZATION)\nAC_DEFINE(GC_GCJ_SUPPORT)\nAC_DEFINE(ATOMIC_UNCOLLECTABLE)\n\ndnl This is something of a hack.  When cross-compiling we turn off\ndnl some functionality.  We also enable the \"small\" configuration.\ndnl These is only correct when targetting an embedded system.  FIXME.\nif test -n \"${with_cross_host}\"; then\n   AC_DEFINE(NO_SIGSET)\n   AC_DEFINE(NO_CLOCK)\n   AC_DEFINE(SMALL_CONFIG)\n   AC_DEFINE(NO_DEBUGGING)\nfi\n\nUNWINDLIBS=\nAC_ARG_ENABLE(full-debug,\n[  --enable-full-debug\tinclude full support for pointer backtracing etc.],\n[ if test \"$enable_full_debug\" = \"yes\"; then\n    AC_MSG_WARN(\"Should define GC_DEBUG and use debug alloc. in clients.\")\n    AC_DEFINE(KEEP_BACK_PTRS)\n    AC_DEFINE(DBG_HDRS_ALL)\n    case $host in\n      ia64-*-linux* )\n\tAC_DEFINE(MAKE_BACK_GRAPH)\n\tAC_DEFINE(SAVE_CALL_COUNT, 8)\n        AC_CHECK_LIB(unwind, backtrace, [\n\t  AC_DEFINE(GC_HAVE_BUILTIN_BACKTRACE)\n\t  UNWINDLIBS=-lunwind\n\t  AC_MSG_WARN(\"Client code may need to link against libunwind.\")\n\t])\n      ;;\n      x86-*-linux* | i586-*-linux* | i686-*-linux* | x86_64-*-linux* )\n\tAC_DEFINE(MAKE_BACK_GRAPH)\n\tAC_MSG_WARN(\"Client must not use -fomit-frame-pointer.\")\n\tAC_DEFINE(SAVE_CALL_COUNT, 8)\n      ;;\n      i[3456]86-*-dgux*)\n\tAC_DEFINE(MAKE_BACK_GRAPH)\n      ;;\n    esac ]\n  fi)\n\nAC_SUBST(UNWINDLIBS)\n\nAC_ARG_ENABLE(redirect-malloc,\n[  --enable-redirect-malloc  redirect malloc and friends to GC routines])\n\nif test \"${enable_redirect_malloc}\" = yes; then\n    if test \"${enable_full_debug}\" = yes; then\n\tAC_DEFINE(REDIRECT_MALLOC, GC_debug_malloc_replacement)\n\tAC_DEFINE(REDIRECT_REALLOC, GC_debug_realloc_replacement)\n\tAC_DEFINE(REDIRECT_FREE, GC_debug_free)\n    else\n\tAC_DEFINE(REDIRECT_MALLOC, GC_malloc)\n    fi\nfi\n\nAC_DEFINE(_IN_LIBGC)\n\nAC_ARG_ENABLE(gc-assertions,\n[  --enable-gc-assertions  collector-internal assertion checking])\nif test \"${enable_gc_assertions}\" = yes; then\n    AC_DEFINE(GC_ASSERTIONS)\nfi\n\nAC_ARG_ENABLE(quiet-build, [  --enable-quiet-build  Enable quiet libgc build (on by default)], enable_quiet_build=$enableval, enable_quiet_build=yes)\nAM_CONDITIONAL(USE_LIBDIR, test -z \"$with_cross_host\")\n\nAC_ARG_ENABLE(werror, [  --enable-werror Pass -Werror to the C compiler], werror_flag=$enableval, werror_flag=no)\nif test x$werror_flag = xyes; then\n\tWERROR_CFLAGS=\"-Werror\"\nfi\nAC_SUBST([WERROR_CFLAGS])\n\nif test \"${multilib}\" = \"yes\"; then\n  multilib_arg=\"--enable-multilib\"\nelse\n  multilib_arg=\nfi\n\nAC_OUTPUT(Makefile\nm4/Makefile\ninclude/Makefile\ninclude/private/Makefile\ndoc/Makefile,,\nsrcdir=${srcdir}\nhost=${host}\nCONFIG_SHELL=${CONFIG_SHELL-/bin/sh}\nCC=\"${CC}\"\nDEFS=\"$DEFS\"\n)\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/win32_threads.c": "#include \"private/gc_priv.h\"\n\n#if defined(GC_WIN32_THREADS) \n\n#include <windows.h>\n\n#ifdef CYGWIN32\n# include <errno.h>\n\n /* Cygwin-specific forward decls */\n# undef pthread_create \n# undef pthread_sigmask \n# undef pthread_join \n# undef pthread_detach\n# undef dlopen \n\n# define DEBUG_CYGWIN_THREADS 0\n\n  void * GC_start_routine(void * arg);\n  void GC_thread_exit_proc(void *arg);\n\n#endif\n\n/* The type of the first argument to InterlockedExchange.\t*/\n/* Documented to be LONG volatile *, but at least gcc likes \t*/\n/* this better.\t\t\t\t\t\t\t*/\ntypedef LONG * IE_t;\n\n#ifndef MAX_THREADS\n# define MAX_THREADS 256\n    /* FIXME:\t\t\t\t\t\t\t*/\n    /* Things may get quite slow for large numbers of threads,\t*/\n    /* since we look them up with sequential search.\t\t*/\n#endif\n\nGC_bool GC_thr_initialized = FALSE;\n\nDWORD GC_main_thread = 0;\n\nstruct GC_thread_Rep {\n  LONG in_use; /* Updated without lock.\t*/\n  \t\t\t/* We assert that unused \t*/\n  \t\t\t/* entries have invalid ids of\t*/\n  \t\t\t/* zero and zero stack fields.  */\n  DWORD id;\n  HANDLE handle;\n  ptr_t stack_base;\t/* The cold end of the stack.   */\n\t\t\t/* 0 ==> entry not valid.\t*/\n\t\t\t/* !in_use ==> stack_base == 0\t*/\n  GC_bool suspended;\n  GC_bool thread_blocked;\n\n# ifdef CYGWIN32\n    void *status; /* hold exit value until join in case it's a pointer */\n    pthread_t pthread_id;\n    short flags;\t\t/* Protected by GC lock.\t*/\n#\tdefine FINISHED 1   \t/* Thread has exited.\t*/\n#\tdefine DETACHED 2\t/* Thread is intended to be detached.\t*/\n# endif\n};\n\ntypedef volatile struct GC_thread_Rep * GC_thread;\n\n/*\n * We generally assume that volatile ==> memory ordering, at least among\n * volatiles.\n */\n\nvolatile GC_bool GC_please_stop = FALSE;\n\nvolatile struct GC_thread_Rep thread_table[MAX_THREADS];\n\nvolatile LONG GC_max_thread_index = 0; /* Largest index in thread_table\t*/\n\t\t\t\t       /* that was ever used.\t\t*/\n\nextern LONG WINAPI GC_write_fault_handler(struct _EXCEPTION_POINTERS *exc_info);\n\nint GC_thread_is_registered (void)\n{\n#if defined(GC_DLL) || defined(GC_INSIDE_DLL)\n\t/* Registered by DllMain */\n\treturn 1;\n#else\n\t/* FIXME: */\n\treturn 0;\n#endif\n}\n\nvoid GC_allow_register_threads (void)\n{\n    /* No-op for GC pre-v7. */\n}\n\nint GC_register_my_thread (struct GC_stack_base *sb)\n{\n#   if defined(GC_DLL) || defined(GC_INSIDE_DLL)\n\t/* Registered by DllMain. */\n\treturn GC_DUPLICATE;\n#   else\n\t/* TODO: Implement. */\n\treturn GC_UNIMPLEMENTED;\n#   endif\n}\n\nvoid GC_register_altstack (void *stack, int stack_size, void *altstack, int altstack_size)\n{\n}\n\n/*\n * This may be called from DllMain, and hence operates under unusual\n * constraints.\n */\nstatic GC_thread GC_new_thread(void) {\n  int i;\n  /* It appears to be unsafe to acquire a lock here, since this\t*/\n  /* code is apparently not preeemptible on some systems.\t*/\n  /* (This is based on complaints, not on Microsoft's official\t*/\n  /* documentation, which says this should perform \"only simple\t*/\n  /* initialization tasks\".)\t\t\t\t\t*/\n  /* Hence we make do with nonblocking synchronization.\t\t*/\n\n  /* The following should be a noop according to the win32\t*/\n  /* documentation.  There is empirical evidence that it\t*/\n  /* isn't.\t\t- HB\t\t\t\t\t*/\n# if defined(MPROTECT_VDB)\n   if (GC_incremental) SetUnhandledExceptionFilter(GC_write_fault_handler);\n# endif\n                /* cast away volatile qualifier */\n  for (i = 0; InterlockedExchange((IE_t)&thread_table[i].in_use,1) != 0; i++) {\n    /* Compare-and-swap would make this cleaner, but that's not \t*/\n    /* supported before Windows 98 and NT 4.0.  In Windows 2000,\t*/\n    /* InterlockedExchange is supposed to be replaced by\t\t*/\n    /* InterlockedExchangePointer, but that's not really what I\t\t*/\n    /* want here.\t\t\t\t\t\t\t*/\n    if (i == MAX_THREADS - 1)\n      ABORT(\"too many threads\");\n  }\n  /* Update GC_max_thread_index if necessary.  The following is safe,\t*/\n  /* and unlike CompareExchange-based solutions seems to work on all\t*/\n  /* Windows95 and later platforms.\t\t\t\t\t*/\n  /* Unfortunately, GC_max_thread_index may be temporarily out of \t*/\n  /* bounds, so readers have to compensate.\t\t\t\t*/\n  while (i > GC_max_thread_index) {\n    InterlockedIncrement((IE_t)&GC_max_thread_index);\n  }\n  if (GC_max_thread_index >= MAX_THREADS) {\n    /* We overshot due to simultaneous increments.\t*/\n    /* Setting it to MAX_THREADS-1 is always safe.\t*/\n    GC_max_thread_index = MAX_THREADS - 1;\n  }\n  \n# ifdef CYGWIN32\n    thread_table[i].pthread_id = pthread_self();\n# endif\n  if (!DuplicateHandle(GetCurrentProcess(),\n\t               GetCurrentThread(),\n\t\t       GetCurrentProcess(),\n\t\t       (HANDLE*)&thread_table[i].handle,\n\t\t       0,\n\t\t       0,\n\t\t       DUPLICATE_SAME_ACCESS)) {\n\tDWORD last_error = GetLastError();\n\tGC_printf1(\"Last error code: %lx\\n\", last_error);\n\tABORT(\"DuplicateHandle failed\");\n  }\n  thread_table[i].stack_base = GC_get_stack_base();\n  /* Up until this point, GC_push_all_stacks considers this thread\t*/\n  /* invalid.\t\t\t\t\t\t\t\t*/\n  if (thread_table[i].stack_base == NULL) \n    ABORT(\"Failed to find stack base in GC_new_thread\");\n  /* Up until this point, this entry is viewed as reserved but invalid\t*/\n  /* by GC_delete_thread.\t\t\t\t\t\t*/\n  thread_table[i].id = GetCurrentThreadId();\n  /* If this thread is being created while we are trying to stop\t*/\n  /* the world, wait here.  Hopefully this can't happen on any\t*/\n  /* systems that don't allow us to block here.\t\t\t*/\n  while (GC_please_stop) Sleep(20);\n  GC_ASSERT(!thread_table[i]->thread_blocked);\n  return thread_table + i;\n}\n\n/*\n * GC_max_thread_index may temporarily be larger than MAX_THREADS.\n * To avoid subscript errors, we check on access.\n */\n#ifdef __GNUC__\n__inline__\n#endif\nstatic LONG GC_get_max_thread_index()\n{\n  LONG my_max = GC_max_thread_index;\n\n  if (my_max >= MAX_THREADS) return MAX_THREADS-1;\n  return my_max;\n}\n\n/* This is intended to be lock-free, though that\t\t\t*/\n/* assumes that the CloseHandle becomes visible before the \t\t*/\n/* in_use assignment.\t\t\t\t\t\t\t*/\nstatic void GC_delete_gc_thread(GC_thread thr)\n{\n    CloseHandle(thr->handle);\n      /* cast away volatile qualifier */\n    thr->stack_base = 0;\n    thr->id = 0;\n#   ifdef CYGWIN32\n      thr->pthread_id = 0;\n#   endif /* CYGWIN32 */\n    thr->in_use = FALSE;\n}\n\nstatic void GC_delete_thread(DWORD thread_id) {\n  int i;\n  LONG my_max = GC_get_max_thread_index();\n\n  for (i = 0;\n       i <= my_max &&\n       (!thread_table[i].in_use || thread_table[i].id != thread_id);\n       /* Must still be in_use, since nobody else can store our thread_id. */\n       i++) {}\n  if (i > my_max) {\n    WARN(\"Removing nonexistent thread %ld\\n\", (GC_word)thread_id);\n  } else {\n    GC_delete_gc_thread(thread_table+i);\n  }\n}\n\n#ifdef CYGWIN32\n\n/* Return a GC_thread corresponding to a given pthread_t.\t*/\n/* Returns 0 if it's not there.\t\t\t\t\t*/\n/* We assume that this is only called for pthread ids that\t*/\n/* have not yet terminated or are still joinable.\t\t*/\nstatic GC_thread GC_lookup_thread(pthread_t id)\n{\n  int i;\n  LONG my_max = GC_get_max_thread_index();\n\n  for (i = 0;\n       i <= my_max &&\n       (!thread_table[i].in_use || thread_table[i].pthread_id != id\n\t|| !thread_table[i].in_use);\n       /* Must still be in_use, since nobody else can store our thread_id. */\n       i++);\n  if (i > my_max) return 0;\n  return thread_table + i;\n}\n\n#else\n\nstatic GC_thread GC_lookup_thread(DWORD id)\n{\n  int i;\n  LONG max = GC_get_max_thread_index();\n\n  for (i = 0; i <= max; i++)\n    if (thread_table[i].in_use && thread_table[i].id == id)\n      return &thread_table[i];\n\n  return NULL;\n}\n\n#endif /* CYGWIN32 */\n\nvoid GC_push_thread_structures GC_PROTO((void))\n{\n    /* Unlike the other threads implementations, the thread table here\t*/\n    /* contains no pointers to the collectable heap.  Thus we have\t*/\n    /* no private structures we need to preserve.\t\t\t*/\n# ifdef CYGWIN32\n  { int i; /* pthreads may keep a pointer in the thread exit value */\n    LONG my_max = GC_get_max_thread_index();\n\n    for (i = 0; i <= my_max; i++)\n      if (thread_table[i].in_use)\n\tGC_push_all((ptr_t)&(thread_table[i].status),\n                    (ptr_t)(&(thread_table[i].status)+1));\n  }\n# endif\n}\n\n/* Wrappers for functions that are likely to block for an appreciable\t*/\n/* length of time.  Must be called in pairs, if at all.\t\t\t*/\n/* Nothing much beyond the system call itself should be executed\t*/\n/* between these.\t\t\t\t\t\t\t*/\n\nvoid GC_start_blocking(void) {\n    GC_thread me;\n    LOCK();\n#ifdef CYGWIN32\n    me = GC_lookup_thread(pthread_self());\n#else\n    me = GC_lookup_thread(GetCurrentThreadId());\n#endif\n    me->thread_blocked = TRUE;\n    UNLOCK();\n}\n\nvoid GC_end_blocking(void) {\n    GC_thread me;\n    LOCK();   /* This will block if the world is stopped.\t*/\n#ifdef CYGWIN32\n    me = GC_lookup_thread(pthread_self());\n#else\n    me = GC_lookup_thread(GetCurrentThreadId());\n#endif\n    me->thread_blocked = FALSE;\n    UNLOCK();\n}\n\n/* Defined in misc.c */\nextern CRITICAL_SECTION GC_write_cs;\n\nvoid GC_stop_world()\n{\n  DWORD thread_id = GetCurrentThreadId();\n  int i;\n\n  if (!GC_thr_initialized) ABORT(\"GC_stop_world() called before GC_thr_init()\");\n\n  GC_please_stop = TRUE;\n# ifndef CYGWIN32\n    EnterCriticalSection(&GC_write_cs);\n# endif /* !CYGWIN32 */\n  for (i = 0; i <= GC_get_max_thread_index(); i++)\n    if (thread_table[i].stack_base != 0\n\t&& thread_table[i].id != thread_id) {\n      if (thread_table [i].thread_blocked)\n        continue;\n#     ifdef MSWINCE\n        /* SuspendThread will fail if thread is running kernel code */\n\twhile (SuspendThread(thread_table[i].handle) == (DWORD)-1)\n\t  Sleep(10);\n#     else\n\t/* Apparently the Windows 95 GetOpenFileName call creates\t*/\n\t/* a thread that does not properly get cleaned up, and\t\t*/\n\t/* SuspendThread on its descriptor may provoke a crash.\t\t*/\n\t/* This reduces the probability of that event, though it still\t*/\n\t/* appears there's a race here.\t\t\t\t\t*/\n\tDWORD exitCode; \n\tif (GetExitCodeThread(thread_table[i].handle,&exitCode) &&\n            exitCode != STILL_ACTIVE) {\n          thread_table[i].stack_base = 0; /* prevent stack from being pushed */\n#         ifndef CYGWIN32\n            /* this breaks pthread_join on Cygwin, which is guaranteed to  */\n\t    /* only see user pthreads \t\t\t\t\t   */\n\t    thread_table[i].in_use = FALSE;\n\t    CloseHandle(thread_table[i].handle);\n#         endif\n\t  continue;\n\t}\n\tif (SuspendThread(thread_table[i].handle) == (DWORD)-1) {\n          thread_table[i].stack_base = 0; /* prevent stack from being pushed */\n#         ifndef CYGWIN32\n            /* this breaks pthread_join on Cygwin, which is guaranteed to  */\n\t    /* only see user pthreads \t\t\t\t\t   */\n\t    thread_table[i].in_use = FALSE;\n\t    CloseHandle(thread_table[i].handle);\n#         endif\n\t}\n#     endif\n      thread_table[i].suspended = TRUE;\n    }\n# ifndef CYGWIN32\n    LeaveCriticalSection(&GC_write_cs);\n# endif /* !CYGWIN32 */\n}\n\nvoid GC_start_world()\n{\n  DWORD thread_id = GetCurrentThreadId();\n  int i;\n  LONG my_max = GC_get_max_thread_index();\n\n  for (i = 0; i <= my_max; i++)\n    if (thread_table[i].stack_base != 0 && thread_table[i].suspended\n\t&& thread_table[i].id != thread_id) {\n      if (ResumeThread(thread_table[i].handle) == (DWORD)-1)\n\tABORT(\"ResumeThread failed\");\n      thread_table[i].suspended = FALSE;\n    }\n  GC_please_stop = FALSE;\n}\n\n# ifdef _MSC_VER\n#   pragma warning(disable:4715)\n# endif\nptr_t GC_current_stackbottom()\n{\n  DWORD thread_id = GetCurrentThreadId();\n  int i;\n  LONG my_max = GC_get_max_thread_index();\n\n  for (i = 0; i <= my_max; i++)\n    if (thread_table[i].stack_base && thread_table[i].id == thread_id)\n      return thread_table[i].stack_base;\n  ABORT(\"no thread table entry for current thread\");\n}\n# ifdef _MSC_VER\n#   pragma warning(default:4715)\n# endif\n\n# ifdef MSWINCE\n    /* The VirtualQuery calls below won't work properly on WinCE, but\t*/\n    /* since each stack is restricted to an aligned 64K region of\t*/\n    /* virtual memory we can just take the next lowest multiple of 64K.\t*/\n#   define GC_get_stack_min(s) \\\n        ((ptr_t)(((DWORD)(s) - 1) & 0xFFFF0000))\n# else\n    static ptr_t GC_get_stack_min(ptr_t s)\n    {\n\tptr_t bottom;\n\tMEMORY_BASIC_INFORMATION info;\n\tVirtualQuery(s, &info, sizeof(info));\n\tdo {\n\t    bottom = info.BaseAddress;\n\t    VirtualQuery(bottom - 1, &info, sizeof(info));\n\t} while ((info.Protect & PAGE_READWRITE)\n\t\t && !(info.Protect & PAGE_GUARD));\n\treturn(bottom);\n    }\n# endif\n\nvoid GC_push_all_stacks()\n{\n  DWORD thread_id = GetCurrentThreadId();\n  GC_bool found_me = FALSE;\n  int i;\n  int dummy;\n  ptr_t sp, stack_min;\n  GC_thread thread;\n  LONG my_max = GC_get_max_thread_index();\n  \n  for (i = 0; i <= my_max; i++) {\n    thread = thread_table + i;\n    if (thread -> in_use && thread -> stack_base) {\n      if (thread -> id == thread_id) {\n\tsp = (ptr_t) &dummy;\n\tfound_me = TRUE;\n      } else {\n        CONTEXT context;\n        context.ContextFlags = CONTEXT_INTEGER|CONTEXT_CONTROL;\n        if (!GetThreadContext(thread_table[i].handle, &context))\n\t  ABORT(\"GetThreadContext failed\");\n\n        /* Push all registers that might point into the heap.  Frame\t*/\n        /* pointer registers are included in case client code was\t*/\n        /* compiled with the 'omit frame pointer' optimisation.\t\t*/\n#       define PUSH1(reg) GC_push_one((word)context.reg)\n#       define PUSH2(r1,r2) PUSH1(r1), PUSH1(r2)\n#       define PUSH4(r1,r2,r3,r4) PUSH2(r1,r2), PUSH2(r3,r4)\n#       if defined(I386)\n          PUSH4(Edi,Esi,Ebx,Edx), PUSH2(Ecx,Eax), PUSH1(Ebp);\n\t  sp = (ptr_t)context.Esp;\n#\telif defined(X86_64)\n\t  PUSH4(Rax,Rcx,Rdx,Rbx); PUSH2(Rbp, Rsi); PUSH1(Rdi);\n\t  PUSH4(R8, R9, R10, R11); PUSH4(R12, R13, R14, R15);\n\t  sp = (ptr_t)context.Rsp;\n#       elif defined(ARM32)\n\t  PUSH4(R0,R1,R2,R3),PUSH4(R4,R5,R6,R7),PUSH4(R8,R9,R10,R11),PUSH1(R12);\n\t  sp = (ptr_t)context.Sp;\n#       elif defined(SHx)\n\t  PUSH4(R0,R1,R2,R3), PUSH4(R4,R5,R6,R7), PUSH4(R8,R9,R10,R11);\n\t  PUSH2(R12,R13), PUSH1(R14);\n\t  sp = (ptr_t)context.R15;\n#       elif defined(MIPS)\n\t  PUSH4(IntAt,IntV0,IntV1,IntA0), PUSH4(IntA1,IntA2,IntA3,IntT0);\n\t  PUSH4(IntT1,IntT2,IntT3,IntT4), PUSH4(IntT5,IntT6,IntT7,IntS0);\n\t  PUSH4(IntS1,IntS2,IntS3,IntS4), PUSH4(IntS5,IntS6,IntS7,IntT8);\n\t  PUSH4(IntT9,IntK0,IntK1,IntS8);\n\t  sp = (ptr_t)context.IntSp;\n#       elif defined(PPC)\n\t  PUSH4(Gpr0, Gpr3, Gpr4, Gpr5),  PUSH4(Gpr6, Gpr7, Gpr8, Gpr9);\n\t  PUSH4(Gpr10,Gpr11,Gpr12,Gpr14), PUSH4(Gpr15,Gpr16,Gpr17,Gpr18);\n\t  PUSH4(Gpr19,Gpr20,Gpr21,Gpr22), PUSH4(Gpr23,Gpr24,Gpr25,Gpr26);\n\t  PUSH4(Gpr27,Gpr28,Gpr29,Gpr30), PUSH1(Gpr31);\n\t  sp = (ptr_t)context.Gpr1;\n#       elif defined(ALPHA)\n\t  PUSH4(IntV0,IntT0,IntT1,IntT2), PUSH4(IntT3,IntT4,IntT5,IntT6);\n\t  PUSH4(IntT7,IntS0,IntS1,IntS2), PUSH4(IntS3,IntS4,IntS5,IntFp);\n\t  PUSH4(IntA0,IntA1,IntA2,IntA3), PUSH4(IntA4,IntA5,IntT8,IntT9);\n\t  PUSH4(IntT10,IntT11,IntT12,IntAt);\n\t  sp = (ptr_t)context.IntSp;\n#       else\n#         error \"architecture is not supported\"\n#       endif\n      }\n\n      stack_min = GC_get_stack_min(thread->stack_base);\n\n      if (sp >= stack_min && sp < thread->stack_base)\n        GC_push_all_stack(sp, thread->stack_base);\n      else {\n        WARN(\"Thread stack pointer 0x%lx out of range, pushing everything\\n\",\n\t     (unsigned long)sp);\n        GC_push_all_stack(stack_min, thread->stack_base);\n      }\n    }\n  }\n  if (!found_me) ABORT(\"Collecting from unknown thread.\");\n}\n\nvoid GC_get_next_stack(char *start, char **lo, char **hi)\n{\n    int i;\n#   define ADDR_LIMIT (char *)(-1L)\n    char * current_min = ADDR_LIMIT;\n    LONG my_max = GC_get_max_thread_index();\n  \n    for (i = 0; i <= my_max; i++) {\n    \tchar * s = (char *)thread_table[i].stack_base;\n\n\tif (0 != s && s > start && s < current_min) {\n\t    current_min = s;\n\t}\n    }\n    *hi = current_min;\n    if (current_min == ADDR_LIMIT) {\n    \t*lo = ADDR_LIMIT;\n\treturn;\n    }\n    *lo = GC_get_stack_min(current_min);\n    if (*lo < start) *lo = start;\n}\n\n#if !defined(CYGWIN32)\n\n#if !defined(MSWINCE) && defined(GC_DLL)\n\n/* We register threads from DllMain */\n\nGC_API HANDLE WINAPI GC_CreateThread(\n    LPSECURITY_ATTRIBUTES lpThreadAttributes, \n    DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, \n    LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId )\n{\n    return CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress,\n                        lpParameter, dwCreationFlags, lpThreadId);\n}\n\n#else /* defined(MSWINCE) || !defined(GC_DLL))  */\n\n/* We have no DllMain to take care of new threads.  Thus we\t*/\n/* must properly intercept thread creation.\t\t\t*/\n\ntypedef struct {\n    LPTHREAD_START_ROUTINE start;\n    LPVOID param;\n} thread_args;\n\nstatic DWORD WINAPI thread_start(LPVOID arg);\n\nGC_API HANDLE WINAPI GC_CreateThread(\n    LPSECURITY_ATTRIBUTES lpThreadAttributes, \n    DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, \n    LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId )\n{\n    HANDLE thread_h = NULL;\n\n    thread_args *args;\n\n    if (!GC_is_initialized) GC_init();\n    \t\t/* make sure GC is initialized (i.e. main thread is attached) */\n    \n    args = GC_malloc_uncollectable(sizeof(thread_args)); \n\t/* Handed off to and deallocated by child thread.\t*/\n    if (0 == args) {\n\tSetLastError(ERROR_NOT_ENOUGH_MEMORY);\n        return NULL;\n    }\n\n    /* set up thread arguments */\n    \targs -> start = lpStartAddress;\n    \targs -> param = lpParameter;\n\n    thread_h = CreateThread(lpThreadAttributes,\n    \t\t\t    dwStackSize, thread_start,\n    \t\t\t    args, dwCreationFlags,\n    \t\t\t    lpThreadId);\n\n    return thread_h;\n}\n\nstatic DWORD WINAPI thread_start(LPVOID arg)\n{\n    DWORD ret = 0;\n    thread_args *args = (thread_args *)arg;\n\n    GC_new_thread();\n\n    /* Clear the thread entry even if we exit with an exception.\t*/\n    /* This is probably pointless, since an uncaught exception is\t*/\n    /* supposed to result in the process being killed.\t\t\t*/\n#ifndef __GNUC__\n    __try {\n#endif /* __GNUC__ */\n\tret = args->start (args->param);\n#ifndef __GNUC__\n    } __finally {\n#endif /* __GNUC__ */\n\tGC_free(args);\n\tGC_delete_thread(GetCurrentThreadId());\n#ifndef __GNUC__\n    }\n#endif /* __GNUC__ */\n\n    return ret;\n}\n#endif /* !defined(MSWINCE) && !(defined(__MINGW32__) && !defined(_DLL))  */\n\n#endif /* !CYGWIN32 */\n\n#ifdef MSWINCE\n\ntypedef struct {\n    HINSTANCE hInstance;\n    HINSTANCE hPrevInstance;\n    LPWSTR lpCmdLine;\n    int nShowCmd;\n} main_thread_args;\n\nDWORD WINAPI main_thread_start(LPVOID arg);\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,\n\t\t   LPWSTR lpCmdLine, int nShowCmd)\n{\n    DWORD exit_code = 1;\n\n    main_thread_args args = {\n\thInstance, hPrevInstance, lpCmdLine, nShowCmd\n    };\n    HANDLE thread_h;\n    DWORD thread_id;\n\n    /* initialize everything */\n    GC_init();\n\n    /* start the main thread */\n    thread_h = GC_CreateThread(\n\tNULL, 0, main_thread_start, &args, 0, &thread_id);\n\n    if (thread_h != NULL)\n    {\n\tWaitForSingleObject (thread_h, INFINITE);\n\tGetExitCodeThread (thread_h, &exit_code);\n\tCloseHandle (thread_h);\n    }\n\n    GC_deinit();\n    DeleteCriticalSection(&GC_allocate_ml);\n\n    return (int) exit_code;\n}\n\nDWORD WINAPI main_thread_start(LPVOID arg)\n{\n    main_thread_args * args = (main_thread_args *) arg;\n\n    return (DWORD) GC_WinMain (args->hInstance, args->hPrevInstance,\n\t\t\t       args->lpCmdLine, args->nShowCmd);\n}\n\n# else /* !MSWINCE */\n\n/* Called by GC_init() - we hold the allocation lock.\t*/\nvoid GC_thr_init() {\n    if (GC_thr_initialized) return;\n    GC_main_thread = GetCurrentThreadId();\n    GC_thr_initialized = TRUE;\n\n    /* Add the initial thread, so we can stop it.\t*/\n    GC_new_thread();\n}\n\n#ifdef CYGWIN32\n\nstruct start_info {\n    void *(*start_routine)(void *);\n    void *arg;\n    GC_bool detached;\n};\n\nint GC_pthread_join(pthread_t pthread_id, void **retval) {\n    int result;\n    int i;\n    GC_thread me;\n\n#   if DEBUG_CYGWIN_THREADS\n      GC_printf3(\"thread 0x%x(0x%x) is joining thread 0x%x.\\n\",\n\t\t (int)pthread_self(), GetCurrentThreadId(), (int)pthread_id);\n#   endif\n\n    /* Thread being joined might not have registered itself yet. */\n    /* After the join,thread id may have been recycled.\t\t */\n    /* FIXME: It would be better if this worked more like\t */\n    /* pthread_support.c.\t\t\t\t\t */\n\n    while ((me = GC_lookup_thread(pthread_id)) == 0) Sleep(10);\n\n    result = pthread_join(pthread_id, retval);\n\n    GC_delete_gc_thread(me);\n\n#   if DEBUG_CYGWIN_THREADS\n      GC_printf3(\"thread 0x%x(0x%x) completed join with thread 0x%x.\\n\",\n\t\t (int)pthread_self(), GetCurrentThreadId(), (int)pthread_id);\n#   endif\n\n    return result;\n}\n\n/* Cygwin-pthreads calls CreateThread internally, but it's not\n * easily interceptible by us..\n *   so intercept pthread_create instead\n */\nint\nGC_pthread_create(pthread_t *new_thread,\n\t\t  const pthread_attr_t *attr,\n                  void *(*start_routine)(void *), void *arg) {\n    int result;\n    struct start_info * si;\n\n    if (!GC_is_initialized) GC_init();\n    \t\t/* make sure GC is initialized (i.e. main thread is attached) */\n    \n    /* This is otherwise saved only in an area mmapped by the thread */\n    /* library, which isn't visible to the collector.\t\t */\n    si = GC_malloc_uncollectable(sizeof(struct start_info)); \n    if (0 == si) return(EAGAIN);\n\n    si -> start_routine = start_routine;\n    si -> arg = arg;\n    if (attr != 0 &&\n        pthread_attr_getdetachstate(attr, &si->detached)\n\t== PTHREAD_CREATE_DETACHED) {\n      si->detached = TRUE;\n    }\n\n#   if DEBUG_CYGWIN_THREADS\n      GC_printf2(\"About to create a thread from 0x%x(0x%x)\\n\",\n\t\t (int)pthread_self(), GetCurrentThreadId);\n#   endif\n    result = pthread_create(new_thread, attr, GC_start_routine, si); \n\n    if (result) { /* failure */\n      \tGC_free(si);\n    } \n\n    return(result);\n}\n\nvoid * GC_start_routine(void * arg)\n{\n    struct start_info * si = arg;\n    void * result;\n    void *(*start)(void *);\n    void *start_arg;\n    pthread_t pthread_id;\n    GC_thread me;\n    GC_bool detached;\n    int i;\n\n#   if DEBUG_CYGWIN_THREADS\n      GC_printf2(\"thread 0x%x(0x%x) starting...\\n\",(int)pthread_self(),\n\t\t      \t\t\t\t   GetCurrentThreadId());\n#   endif\n\n    /* If a GC occurs before the thread is registered, that GC will\t*/\n    /* ignore this thread.  That's fine, since it will block trying to  */\n    /* acquire the allocation lock, and won't yet hold interesting \t*/\n    /* pointers.\t\t\t\t\t\t\t*/\n    LOCK();\n    /* We register the thread here instead of in the parent, so that\t*/\n    /* we don't need to hold the allocation lock during pthread_create. */\n    me = GC_new_thread();\n    UNLOCK();\n\n    start = si -> start_routine;\n    start_arg = si -> arg;\n    if (si-> detached) me -> flags |= DETACHED;\n    me -> pthread_id = pthread_id = pthread_self();\n\n    GC_free(si); /* was allocated uncollectable */\n\n    pthread_cleanup_push(GC_thread_exit_proc, (void *)me);\n    result = (*start)(start_arg);\n    me -> status = result;\n    pthread_cleanup_pop(0);\n\n#   if DEBUG_CYGWIN_THREADS\n      GC_printf2(\"thread 0x%x(0x%x) returned from start routine.\\n\",\n\t\t (int)pthread_self(),GetCurrentThreadId());\n#   endif\n\n    return(result);\n}\n\nvoid GC_thread_exit_proc(void *arg)\n{\n    GC_thread me = (GC_thread)arg;\n    int i;\n\n#   if DEBUG_CYGWIN_THREADS\n      GC_printf2(\"thread 0x%x(0x%x) called pthread_exit().\\n\",\n\t\t (int)pthread_self(),GetCurrentThreadId());\n#   endif\n\n    LOCK();\n    if (me -> flags & DETACHED) {\n      GC_delete_thread(GetCurrentThreadId());\n    } else {\n      /* deallocate it as part of join */\n      me -> flags |= FINISHED;\n    }\n    UNLOCK();\n}\n\n/* nothing required here... */\nint GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset) {\n  return pthread_sigmask(how, set, oset);\n}\n\nint GC_pthread_detach(pthread_t thread)\n{\n    int result;\n    GC_thread thread_gc_id;\n    \n    LOCK();\n    thread_gc_id = GC_lookup_thread(thread);\n    UNLOCK();\n    result = pthread_detach(thread);\n    if (result == 0) {\n      LOCK();\n      thread_gc_id -> flags |= DETACHED;\n      /* Here the pthread thread id may have been recycled. */\n      if (thread_gc_id -> flags & FINISHED) {\n        GC_delete_gc_thread(thread_gc_id);\n      }\n      UNLOCK();\n    }\n    return result;\n}\n\n#else /* !CYGWIN32 */\n\n/*\n * We avoid acquiring locks here, since this doesn't seem to be preemptable.\n * Pontus Rydin suggests wrapping the thread start routine instead.\n */\n#if defined(GC_DLL) || defined(GC_INSIDE_DLL)\nBOOL WINAPI GC_DllMain(HINSTANCE inst, ULONG reason, LPVOID reserved)\n{\n  switch (reason) {\n  case DLL_PROCESS_ATTACH:\n    GC_init();\t/* Force initialization before thread attach.\t*/\n    /* fall through */\n  case DLL_THREAD_ATTACH:\n    GC_ASSERT(GC_thr_initialized);\n    if (GC_main_thread != GetCurrentThreadId()) {\n        GC_new_thread();\n    } /* o.w. we already did it during GC_thr_init(), called by GC_init() */\n    break;\n\n  case DLL_THREAD_DETACH:\n    GC_delete_thread(GetCurrentThreadId());\n    break;\n\n  case DLL_PROCESS_DETACH:\n    {\n      int i;\n\n      LOCK();\n      for (i = 0; i <= GC_get_max_thread_index(); ++i)\n      {\n          if (thread_table[i].in_use)\n\t    GC_delete_gc_thread(thread_table + i);\n      }\n      UNLOCK();\n\n      GC_deinit();\n      DeleteCriticalSection(&GC_allocate_ml);\n    }\n    break;\n\n  }\n  return TRUE;\n}\n#endif /* GC_DLL */\n#endif /* !CYGWIN32 */\n\n# endif /* !MSWINCE */\n\n#endif /* GC_WIN32_THREADS */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/threadlibs.c": "# include \"gc_config_macros.h\"\n# include \"private/gcconfig.h\"\n# include <stdio.h>\n\nint main()\n{\n#   if defined(GC_USE_LD_WRAP)\n\tprintf(\"-Wl,--wrap -Wl,dlopen \"\n\t       \"-Wl,--wrap -Wl,pthread_create -Wl,--wrap -Wl,pthread_join \"\n\t       \"-Wl,--wrap -Wl,pthread_detach \"\n\t       \"-Wl,--wrap -Wl,pthread_sigmask -Wl,--wrap -Wl,sleep\\n\");\n#   endif\n#   if defined(GC_LINUX_THREADS) || defined(GC_IRIX_THREADS) \\\n\t|| defined(GC_SOLARIS_PTHREADS) \\\n\t|| defined(GC_DARWIN_THREADS) || defined(GC_AIX_THREADS)\n        printf(\"-lpthread\\n\");\n#   endif\n#   if defined(GC_FREEBSD_THREADS) || defined(GC_OPENBSD_THREADS)\n#       if (__FREEBSD_version >= 500000)\n          printf(\"-lpthread\\n\");\n#       else\n          printf(\"-pthread\\n\");\n#       endif\n#   endif\n#   if defined(GC_HPUX_THREADS) || defined(GC_OSF1_THREADS)\n\tprintf(\"-lpthread -lrt\\n\");\n#   endif\n#   if defined(GC_SOLARIS_THREADS) && !defined(GC_SOLARIS_PTHREADS)\n        printf(\"-lthread -ldl\\n\");\n#   endif\n#   if defined(GC_WIN32_THREADS) && defined(CYGWIN32)\n        printf(\"-lpthread\\n\");\n#   endif\n#   if defined(GC_OSF1_THREADS)\n\tprintf(\"-pthread -lrt\"); /* DOB: must be -pthread, not -lpthread */\n#   endif\n    /* You need GCC 3.0.3 to build this one!           */  \n    /* DG/UX native gcc doesnt know what \"-pthread\" is */\n#   if defined(GC_DGUX386_THREADS)\n        printf(\"-ldl -pthread\\n\");\n#   endif\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/ltmain.sh": "#! /bin/sh\n## DO NOT EDIT - This file generated from ./build-aux/ltmain.in\n##               by inline-source v2014-01-03.01\n\n# libtool (GNU libtool) 2.4.6\n# Provide generalized library-building support services.\n# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996\n\n# Copyright (C) 1996-2015 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# GNU Libtool is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\nPROGRAM=libtool\nPACKAGE=libtool\nVERSION=\"2.4.6 Debian-2.4.6-0.1\"\npackage_revision=2.4.6\n\n\n## ------ ##\n## Usage. ##\n## ------ ##\n\n# Run './libtool --help' for help with using this script from the\n# command line.\n\n\n## ------------------------------- ##\n## User overridable command paths. ##\n## ------------------------------- ##\n\n# After configure completes, it has a better idea of some of the\n# shell tools we need than the defaults used by the functions shared\n# with bootstrap, so set those here where they can still be over-\n# ridden by the user, but otherwise take precedence.\n\n: ${AUTOCONF=\"autoconf\"}\n: ${AUTOMAKE=\"automake\"}\n\n\n## -------------------------- ##\n## Source external libraries. ##\n## -------------------------- ##\n\n# Much of our low-level functionality needs to be sourced from external\n# libraries, which are installed to $pkgauxdir.\n\n# Set a version string for this script.\nscriptversion=2015-01-20.17; # UTC\n\n# General shell script boiler plate, and helper functions.\n# Written by Gary V. Vaughan, 2004\n\n# Copyright (C) 2004-2015 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 3 of the License, or\n# (at your option) any later version.\n\n# As a special exception to the GNU General Public License, if you distribute\n# this file as part of a program or library that is built using GNU Libtool,\n# you may include this file under the same distribution terms that you use\n# for the rest of that program.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNES FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program. If not, see <http://www.gnu.org/licenses/>.\n\n# Please report bugs or propose patches to gary@gnu.org.\n\n\n## ------ ##\n## Usage. ##\n## ------ ##\n\n# Evaluate this file near the top of your script to gain access to\n# the functions and variables defined here:\n#\n#   . `echo \"$0\" | ${SED-sed} 's|[^/]*$||'`/build-aux/funclib.sh\n#\n# If you need to override any of the default environment variable\n# settings, do that before evaluating this file.\n\n\n## -------------------- ##\n## Shell normalisation. ##\n## -------------------- ##\n\n# Some shells need a little help to be as Bourne compatible as possible.\n# Before doing anything else, make sure all that help has been provided!\n\nDUALCASE=1; export DUALCASE # for MKS sh\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in *posix*) set -o posix ;; esac\nfi\n\n# NLS nuisances: We save the old values in case they are required later.\n_G_user_locale=\n_G_safe_locale=\nfor _G_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\ndo\n  eval \"if test set = \\\"\\${$_G_var+set}\\\"; then\n          save_$_G_var=\\$$_G_var\n          $_G_var=C\n\t  export $_G_var\n\t  _G_user_locale=\\\"$_G_var=\\\\\\$save_\\$_G_var; \\$_G_user_locale\\\"\n\t  _G_safe_locale=\\\"$_G_var=C; \\$_G_safe_locale\\\"\n\tfi\"\ndone\n\n# CDPATH.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\n# Make sure IFS has a sensible default\nsp=' '\nnl='\n'\nIFS=\"$sp\t$nl\"\n\n# There are apparently some retarded systems that use ';' as a PATH separator!\nif test \"${PATH_SEPARATOR+set}\" != set; then\n  PATH_SEPARATOR=:\n  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {\n    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||\n      PATH_SEPARATOR=';'\n  }\nfi\n\n\n\n## ------------------------- ##\n## Locate command utilities. ##\n## ------------------------- ##\n\n\n# func_executable_p FILE\n# ----------------------\n# Check that FILE is an executable regular file.\nfunc_executable_p ()\n{\n    test -f \"$1\" && test -x \"$1\"\n}\n\n\n# func_path_progs PROGS_LIST CHECK_FUNC [PATH]\n# --------------------------------------------\n# Search for either a program that responds to --version with output\n# containing \"GNU\", or else returned by CHECK_FUNC otherwise, by\n# trying all the directories in PATH with each of the elements of\n# PROGS_LIST.\n#\n# CHECK_FUNC should accept the path to a candidate program, and\n# set $func_check_prog_result if it truncates its output less than\n# $_G_path_prog_max characters.\nfunc_path_progs ()\n{\n    _G_progs_list=$1\n    _G_check_func=$2\n    _G_PATH=${3-\"$PATH\"}\n\n    _G_path_prog_max=0\n    _G_path_prog_found=false\n    _G_save_IFS=$IFS; IFS=${PATH_SEPARATOR-:}\n    for _G_dir in $_G_PATH; do\n      IFS=$_G_save_IFS\n      test -z \"$_G_dir\" && _G_dir=.\n      for _G_prog_name in $_G_progs_list; do\n        for _exeext in '' .EXE; do\n          _G_path_prog=$_G_dir/$_G_prog_name$_exeext\n          func_executable_p \"$_G_path_prog\" || continue\n          case `\"$_G_path_prog\" --version 2>&1` in\n            *GNU*) func_path_progs_result=$_G_path_prog _G_path_prog_found=: ;;\n            *)     $_G_check_func $_G_path_prog\n\t\t   func_path_progs_result=$func_check_prog_result\n\t\t   ;;\n          esac\n          $_G_path_prog_found && break 3\n        done\n      done\n    done\n    IFS=$_G_save_IFS\n    test -z \"$func_path_progs_result\" && {\n      echo \"no acceptable sed could be found in \\$PATH\" >&2\n      exit 1\n    }\n}\n\n\n# We want to be able to use the functions in this file before configure\n# has figured out where the best binaries are kept, which means we have\n# to search for them ourselves - except when the results are already set\n# where we skip the searches.\n\n# Unless the user overrides by setting SED, search the path for either GNU\n# sed, or the sed that truncates its output the least.\ntest -z \"$SED\" && {\n  _G_sed_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/\n  for _G_i in 1 2 3 4 5 6 7; do\n    _G_sed_script=$_G_sed_script$nl$_G_sed_script\n  done\n  echo \"$_G_sed_script\" 2>/dev/null | sed 99q >conftest.sed\n  _G_sed_script=\n\n  func_check_prog_sed ()\n  {\n    _G_path_prog=$1\n\n    _G_count=0\n    printf 0123456789 >conftest.in\n    while :\n    do\n      cat conftest.in conftest.in >conftest.tmp\n      mv conftest.tmp conftest.in\n      cp conftest.in conftest.nl\n      echo '' >> conftest.nl\n      \"$_G_path_prog\" -f conftest.sed <conftest.nl >conftest.out 2>/dev/null || break\n      diff conftest.out conftest.nl >/dev/null 2>&1 || break\n      _G_count=`expr $_G_count + 1`\n      if test \"$_G_count\" -gt \"$_G_path_prog_max\"; then\n        # Best one so far, save it but keep looking for a better one\n        func_check_prog_result=$_G_path_prog\n        _G_path_prog_max=$_G_count\n      fi\n      # 10*(2^10) chars as input seems more than enough\n      test 10 -lt \"$_G_count\" && break\n    done\n    rm -f conftest.in conftest.tmp conftest.nl conftest.out\n  }\n\n  func_path_progs \"sed gsed\" func_check_prog_sed $PATH:/usr/xpg4/bin\n  rm -f conftest.sed\n  SED=$func_path_progs_result\n}\n\n\n# Unless the user overrides by setting GREP, search the path for either GNU\n# grep, or the grep that truncates its output the least.\ntest -z \"$GREP\" && {\n  func_check_prog_grep ()\n  {\n    _G_path_prog=$1\n\n    _G_count=0\n    _G_path_prog_max=0\n    printf 0123456789 >conftest.in\n    while :\n    do\n      cat conftest.in conftest.in >conftest.tmp\n      mv conftest.tmp conftest.in\n      cp conftest.in conftest.nl\n      echo 'GREP' >> conftest.nl\n      \"$_G_path_prog\" -e 'GREP$' -e '-(cannot match)-' <conftest.nl >conftest.out 2>/dev/null || break\n      diff conftest.out conftest.nl >/dev/null 2>&1 || break\n      _G_count=`expr $_G_count + 1`\n      if test \"$_G_count\" -gt \"$_G_path_prog_max\"; then\n        # Best one so far, save it but keep looking for a better one\n        func_check_prog_result=$_G_path_prog\n        _G_path_prog_max=$_G_count\n      fi\n      # 10*(2^10) chars as input seems more than enough\n      test 10 -lt \"$_G_count\" && break\n    done\n    rm -f conftest.in conftest.tmp conftest.nl conftest.out\n  }\n\n  func_path_progs \"grep ggrep\" func_check_prog_grep $PATH:/usr/xpg4/bin\n  GREP=$func_path_progs_result\n}\n\n\n## ------------------------------- ##\n## User overridable command paths. ##\n## ------------------------------- ##\n\n# All uppercase variable names are used for environment variables.  These\n# variables can be overridden by the user before calling a script that\n# uses them if a suitable command of that name is not already available\n# in the command search PATH.\n\n: ${CP=\"cp -f\"}\n: ${ECHO=\"printf %s\\n\"}\n: ${EGREP=\"$GREP -E\"}\n: ${FGREP=\"$GREP -F\"}\n: ${LN_S=\"ln -s\"}\n: ${MAKE=\"make\"}\n: ${MKDIR=\"mkdir\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n: ${SHELL=\"${CONFIG_SHELL-/bin/sh}\"}\n\n\n## -------------------- ##\n## Useful sed snippets. ##\n## -------------------- ##\n\nsed_dirname='s|/[^/]*$||'\nsed_basename='s|^.*/||'\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nsed_quote_subst='s|\\([`\"$\\\\]\\)|\\\\\\1|g'\n\n# Same as above, but do not quote variable references.\nsed_double_quote_subst='s/\\([\"`\\\\]\\)/\\\\\\1/g'\n\n# Sed substitution that turns a string into a regex matching for the\n# string literally.\nsed_make_literal_regex='s|[].[^$\\\\*\\/]|\\\\&|g'\n\n# Sed substitution that converts a w32 file name or path\n# that contains forward slashes, into one that contains\n# (escaped) backslashes.  A very naive implementation.\nsed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n\n# Re-'\\' parameter expansions in output of sed_double_quote_subst that\n# were '\\'-ed in input to the same.  If an odd number of '\\' preceded a\n# '$' in input to sed_double_quote_subst, that '$' was protected from\n# expansion.  Since each input '\\' is now two '\\'s, look for any number\n# of runs of four '\\'s followed by two '\\'s and then a '$'.  '\\' that '$'.\n_G_bs='\\\\'\n_G_bs2='\\\\\\\\'\n_G_bs4='\\\\\\\\\\\\\\\\'\n_G_dollar='\\$'\nsed_double_backslash=\"\\\n  s/$_G_bs4/&\\\\\n/g\n  s/^$_G_bs2$_G_dollar/$_G_bs&/\n  s/\\\\([^$_G_bs]\\\\)$_G_bs2$_G_dollar/\\\\1$_G_bs2$_G_bs$_G_dollar/g\n  s/\\n//g\"\n\n\n## ----------------- ##\n## Global variables. ##\n## ----------------- ##\n\n# Except for the global variables explicitly listed below, the following\n# functions in the '^func_' namespace, and the '^require_' namespace\n# variables initialised in the 'Resource management' section, sourcing\n# this file will not pollute your global namespace with anything\n# else. There's no portable way to scope variables in Bourne shell\n# though, so actually running these functions will sometimes place\n# results into a variable named after the function, and often use\n# temporary variables in the '^_G_' namespace. If you are careful to\n# avoid using those namespaces casually in your sourcing script, things\n# should continue to work as you expect. And, of course, you can freely\n# overwrite any of the functions or variables defined here before\n# calling anything to customize them.\n\nEXIT_SUCCESS=0\nEXIT_FAILURE=1\nEXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.\nEXIT_SKIP=77\t  # $? = 77 is used to indicate a skipped test to automake.\n\n# Allow overriding, eg assuming that you follow the convention of\n# putting '$debug_cmd' at the start of all your functions, you can get\n# bash to show function call trace with:\n#\n#    debug_cmd='eval echo \"${FUNCNAME[0]} $*\" >&2' bash your-script-name\ndebug_cmd=${debug_cmd-\":\"}\nexit_cmd=:\n\n# By convention, finish your script with:\n#\n#    exit $exit_status\n#\n# so that you can set exit_status to non-zero if you want to indicate\n# something went wrong during execution without actually bailing out at\n# the point of failure.\nexit_status=$EXIT_SUCCESS\n\n# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh\n# is ksh but when the shell is invoked as \"sh\" and the current value of\n# the _XPG environment variable is not equal to 1 (one), the special\n# positional parameter $0, within a function call, is the name of the\n# function.\nprogpath=$0\n\n# The name of this program.\nprogname=`$ECHO \"$progpath\" |$SED \"$sed_basename\"`\n\n# Make sure we have an absolute progpath for reexecution:\ncase $progpath in\n  [\\\\/]*|[A-Za-z]:\\\\*) ;;\n  *[\\\\/]*)\n     progdir=`$ECHO \"$progpath\" |$SED \"$sed_dirname\"`\n     progdir=`cd \"$progdir\" && pwd`\n     progpath=$progdir/$progname\n     ;;\n  *)\n     _G_IFS=$IFS\n     IFS=${PATH_SEPARATOR-:}\n     for progdir in $PATH; do\n       IFS=$_G_IFS\n       test -x \"$progdir/$progname\" && break\n     done\n     IFS=$_G_IFS\n     test -n \"$progdir\" || progdir=`pwd`\n     progpath=$progdir/$progname\n     ;;\nesac\n\n\n## ----------------- ##\n## Standard options. ##\n## ----------------- ##\n\n# The following options affect the operation of the functions defined\n# below, and should be set appropriately depending on run-time para-\n# meters passed on the command line.\n\nopt_dry_run=false\nopt_quiet=false\nopt_verbose=false\n\n# Categories 'all' and 'none' are always available.  Append any others\n# you will pass as the first argument to func_warning from your own\n# code.\nwarning_categories=\n\n# By default, display warnings according to 'opt_warning_types'.  Set\n# 'warning_func'  to ':' to elide all warnings, or func_fatal_error to\n# treat the next displayed warning as a fatal error.\nwarning_func=func_warn_and_continue\n\n# Set to 'all' to display all warnings, 'none' to suppress all\n# warnings, or a space delimited list of some subset of\n# 'warning_categories' to display only the listed warnings.\nopt_warning_types=all\n\n\n## -------------------- ##\n## Resource management. ##\n## -------------------- ##\n\n# This section contains definitions for functions that each ensure a\n# particular resource (a file, or a non-empty configuration variable for\n# example) is available, and if appropriate to extract default values\n# from pertinent package files. Call them using their associated\n# 'require_*' variable to ensure that they are executed, at most, once.\n#\n# It's entirely deliberate that calling these functions can set\n# variables that don't obey the namespace limitations obeyed by the rest\n# of this file, in order that that they be as useful as possible to\n# callers.\n\n\n# require_term_colors\n# -------------------\n# Allow display of bold text on terminals that support it.\nrequire_term_colors=func_require_term_colors\nfunc_require_term_colors ()\n{\n    $debug_cmd\n\n    test -t 1 && {\n      # COLORTERM and USE_ANSI_COLORS environment variables take\n      # precedence, because most terminfo databases neglect to describe\n      # whether color sequences are supported.\n      test -n \"${COLORTERM+set}\" && : ${USE_ANSI_COLORS=\"1\"}\n\n      if test 1 = \"$USE_ANSI_COLORS\"; then\n        # Standard ANSI escape sequences\n        tc_reset='\u001b[0m'\n        tc_bold='\u001b[1m';   tc_standout='\u001b[7m'\n        tc_red='\u001b[31m';   tc_green='\u001b[32m'\n        tc_blue='\u001b[34m';  tc_cyan='\u001b[36m'\n      else\n        # Otherwise trust the terminfo database after all.\n        test -n \"`tput sgr0 2>/dev/null`\" && {\n          tc_reset=`tput sgr0`\n          test -n \"`tput bold 2>/dev/null`\" && tc_bold=`tput bold`\n          tc_standout=$tc_bold\n          test -n \"`tput smso 2>/dev/null`\" && tc_standout=`tput smso`\n          test -n \"`tput setaf 1 2>/dev/null`\" && tc_red=`tput setaf 1`\n          test -n \"`tput setaf 2 2>/dev/null`\" && tc_green=`tput setaf 2`\n          test -n \"`tput setaf 4 2>/dev/null`\" && tc_blue=`tput setaf 4`\n          test -n \"`tput setaf 5 2>/dev/null`\" && tc_cyan=`tput setaf 5`\n        }\n      fi\n    }\n\n    require_term_colors=:\n}\n\n\n## ----------------- ##\n## Function library. ##\n## ----------------- ##\n\n# This section contains a variety of useful functions to call in your\n# scripts. Take note of the portable wrappers for features provided by\n# some modern shells, which will fall back to slower equivalents on\n# less featureful shells.\n\n\n# func_append VAR VALUE\n# ---------------------\n# Append VALUE onto the existing contents of VAR.\n\n  # We should try to minimise forks, especially on Windows where they are\n  # unreasonably slow, so skip the feature probes when bash or zsh are\n  # being used:\n  if test set = \"${BASH_VERSION+set}${ZSH_VERSION+set}\"; then\n    : ${_G_HAVE_ARITH_OP=\"yes\"}\n    : ${_G_HAVE_XSI_OPS=\"yes\"}\n    # The += operator was introduced in bash 3.1\n    case $BASH_VERSION in\n      [12].* | 3.0 | 3.0*) ;;\n      *)\n        : ${_G_HAVE_PLUSEQ_OP=\"yes\"}\n        ;;\n    esac\n  fi\n\n  # _G_HAVE_PLUSEQ_OP\n  # Can be empty, in which case the shell is probed, \"yes\" if += is\n  # useable or anything else if it does not work.\n  test -z \"$_G_HAVE_PLUSEQ_OP\" \\\n    && (eval 'x=a; x+=\" b\"; test \"a b\" = \"$x\"') 2>/dev/null \\\n    && _G_HAVE_PLUSEQ_OP=yes\n\nif test yes = \"$_G_HAVE_PLUSEQ_OP\"\nthen\n  # This is an XSI compatible shell, allowing a faster implementation...\n  eval 'func_append ()\n  {\n    $debug_cmd\n\n    eval \"$1+=\\$2\"\n  }'\nelse\n  # ...otherwise fall back to using expr, which is often a shell builtin.\n  func_append ()\n  {\n    $debug_cmd\n\n    eval \"$1=\\$$1\\$2\"\n  }\nfi\n\n\n# func_append_quoted VAR VALUE\n# ----------------------------\n# Quote VALUE and append to the end of shell variable VAR, separated\n# by a space.\nif test yes = \"$_G_HAVE_PLUSEQ_OP\"; then\n  eval 'func_append_quoted ()\n  {\n    $debug_cmd\n\n    func_quote_for_eval \"$2\"\n    eval \"$1+=\\\\ \\$func_quote_for_eval_result\"\n  }'\nelse\n  func_append_quoted ()\n  {\n    $debug_cmd\n\n    func_quote_for_eval \"$2\"\n    eval \"$1=\\$$1\\\\ \\$func_quote_for_eval_result\"\n  }\nfi\n\n\n# func_append_uniq VAR VALUE\n# --------------------------\n# Append unique VALUE onto the existing contents of VAR, assuming\n# entries are delimited by the first character of VALUE.  For example:\n#\n#   func_append_uniq options \" --another-option option-argument\"\n#\n# will only append to $options if \" --another-option option-argument \"\n# is not already present somewhere in $options already (note spaces at\n# each end implied by leading space in second argument).\nfunc_append_uniq ()\n{\n    $debug_cmd\n\n    eval _G_current_value='`$ECHO $'$1'`'\n    _G_delim=`expr \"$2\" : '\\(.\\)'`\n\n    case $_G_delim$_G_current_value$_G_delim in\n      *\"$2$_G_delim\"*) ;;\n      *) func_append \"$@\" ;;\n    esac\n}\n\n\n# func_arith TERM...\n# ------------------\n# Set func_arith_result to the result of evaluating TERMs.\n  test -z \"$_G_HAVE_ARITH_OP\" \\\n    && (eval 'test 2 = $(( 1 + 1 ))') 2>/dev/null \\\n    && _G_HAVE_ARITH_OP=yes\n\nif test yes = \"$_G_HAVE_ARITH_OP\"; then\n  eval 'func_arith ()\n  {\n    $debug_cmd\n\n    func_arith_result=$(( $* ))\n  }'\nelse\n  func_arith ()\n  {\n    $debug_cmd\n\n    func_arith_result=`expr \"$@\"`\n  }\nfi\n\n\n# func_basename FILE\n# ------------------\n# Set func_basename_result to FILE with everything up to and including\n# the last / stripped.\nif test yes = \"$_G_HAVE_XSI_OPS\"; then\n  # If this shell supports suffix pattern removal, then use it to avoid\n  # forking. Hide the definitions single quotes in case the shell chokes\n  # on unsupported syntax...\n  _b='func_basename_result=${1##*/}'\n  _d='case $1 in\n        */*) func_dirname_result=${1%/*}$2 ;;\n        *  ) func_dirname_result=$3        ;;\n      esac'\n\nelse\n  # ...otherwise fall back to using sed.\n  _b='func_basename_result=`$ECHO \"$1\" |$SED \"$sed_basename\"`'\n  _d='func_dirname_result=`$ECHO \"$1\"  |$SED \"$sed_dirname\"`\n      if test \"X$func_dirname_result\" = \"X$1\"; then\n        func_dirname_result=$3\n      else\n        func_append func_dirname_result \"$2\"\n      fi'\nfi\n\neval 'func_basename ()\n{\n    $debug_cmd\n\n    '\"$_b\"'\n}'\n\n\n# func_dirname FILE APPEND NONDIR_REPLACEMENT\n# -------------------------------------------\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\neval 'func_dirname ()\n{\n    $debug_cmd\n\n    '\"$_d\"'\n}'\n\n\n# func_dirname_and_basename FILE APPEND NONDIR_REPLACEMENT\n# --------------------------------------------------------\n# Perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# For efficiency, we do not delegate to the functions above but instead\n# duplicate the functionality here.\neval 'func_dirname_and_basename ()\n{\n    $debug_cmd\n\n    '\"$_b\"'\n    '\"$_d\"'\n}'\n\n\n# func_echo ARG...\n# ----------------\n# Echo program name prefixed message.\nfunc_echo ()\n{\n    $debug_cmd\n\n    _G_message=$*\n\n    func_echo_IFS=$IFS\n    IFS=$nl\n    for _G_line in $_G_message; do\n      IFS=$func_echo_IFS\n      $ECHO \"$progname: $_G_line\"\n    done\n    IFS=$func_echo_IFS\n}\n\n\n# func_echo_all ARG...\n# --------------------\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\"\n}\n\n\n# func_echo_infix_1 INFIX ARG...\n# ------------------------------\n# Echo program name, followed by INFIX on the first line, with any\n# additional lines not showing INFIX.\nfunc_echo_infix_1 ()\n{\n    $debug_cmd\n\n    $require_term_colors\n\n    _G_infix=$1; shift\n    _G_indent=$_G_infix\n    _G_prefix=\"$progname: $_G_infix: \"\n    _G_message=$*\n\n    # Strip color escape sequences before counting printable length\n    for _G_tc in \"$tc_reset\" \"$tc_bold\" \"$tc_standout\" \"$tc_red\" \"$tc_green\" \"$tc_blue\" \"$tc_cyan\"\n    do\n      test -n \"$_G_tc\" && {\n        _G_esc_tc=`$ECHO \"$_G_tc\" | $SED \"$sed_make_literal_regex\"`\n        _G_indent=`$ECHO \"$_G_indent\" | $SED \"s|$_G_esc_tc||g\"`\n      }\n    done\n    _G_indent=\"$progname: \"`echo \"$_G_indent\" | $SED 's|.| |g'`\"  \" ## exclude from sc_prohibit_nested_quotes\n\n    func_echo_infix_1_IFS=$IFS\n    IFS=$nl\n    for _G_line in $_G_message; do\n      IFS=$func_echo_infix_1_IFS\n      $ECHO \"$_G_prefix$tc_bold$_G_line$tc_reset\" >&2\n      _G_prefix=$_G_indent\n    done\n    IFS=$func_echo_infix_1_IFS\n}\n\n\n# func_error ARG...\n# -----------------\n# Echo program name prefixed message to standard error.\nfunc_error ()\n{\n    $debug_cmd\n\n    $require_term_colors\n\n    func_echo_infix_1 \"  $tc_standout${tc_red}error$tc_reset\" \"$*\" >&2\n}\n\n\n# func_fatal_error ARG...\n# -----------------------\n# Echo program name prefixed message to standard error, and exit.\nfunc_fatal_error ()\n{\n    $debug_cmd\n\n    func_error \"$*\"\n    exit $EXIT_FAILURE\n}\n\n\n# func_grep EXPRESSION FILENAME\n# -----------------------------\n# Check whether EXPRESSION matches any line of FILENAME, without output.\nfunc_grep ()\n{\n    $debug_cmd\n\n    $GREP \"$1\" \"$2\" >/dev/null 2>&1\n}\n\n\n# func_len STRING\n# ---------------\n# Set func_len_result to the length of STRING. STRING may not\n# start with a hyphen.\n  test -z \"$_G_HAVE_XSI_OPS\" \\\n    && (eval 'x=a/b/c;\n      test 5aa/bb/cc = \"${#x}${x%%/*}${x%/*}${x#*/}${x##*/}\"') 2>/dev/null \\\n    && _G_HAVE_XSI_OPS=yes\n\nif test yes = \"$_G_HAVE_XSI_OPS\"; then\n  eval 'func_len ()\n  {\n    $debug_cmd\n\n    func_len_result=${#1}\n  }'\nelse\n  func_len ()\n  {\n    $debug_cmd\n\n    func_len_result=`expr \"$1\" : \".*\" 2>/dev/null || echo $max_cmd_len`\n  }\nfi\n\n\n# func_mkdir_p DIRECTORY-PATH\n# ---------------------------\n# Make sure the entire path to DIRECTORY-PATH is available.\nfunc_mkdir_p ()\n{\n    $debug_cmd\n\n    _G_directory_path=$1\n    _G_dir_list=\n\n    if test -n \"$_G_directory_path\" && test : != \"$opt_dry_run\"; then\n\n      # Protect directory names starting with '-'\n      case $_G_directory_path in\n        -*) _G_directory_path=./$_G_directory_path ;;\n      esac\n\n      # While some portion of DIR does not yet exist...\n      while test ! -d \"$_G_directory_path\"; do\n        # ...make a list in topmost first order.  Use a colon delimited\n\t# list incase some portion of path contains whitespace.\n        _G_dir_list=$_G_directory_path:$_G_dir_list\n\n        # If the last portion added has no slash in it, the list is done\n        case $_G_directory_path in */*) ;; *) break ;; esac\n\n        # ...otherwise throw away the child directory and loop\n        _G_directory_path=`$ECHO \"$_G_directory_path\" | $SED -e \"$sed_dirname\"`\n      done\n      _G_dir_list=`$ECHO \"$_G_dir_list\" | $SED 's|:*$||'`\n\n      func_mkdir_p_IFS=$IFS; IFS=:\n      for _G_dir in $_G_dir_list; do\n\tIFS=$func_mkdir_p_IFS\n        # mkdir can fail with a 'File exist' error if two processes\n        # try to create one of the directories concurrently.  Don't\n        # stop in that case!\n        $MKDIR \"$_G_dir\" 2>/dev/null || :\n      done\n      IFS=$func_mkdir_p_IFS\n\n      # Bail out if we (or some other process) failed to create a directory.\n      test -d \"$_G_directory_path\" || \\\n        func_fatal_error \"Failed to create '$1'\"\n    fi\n}\n\n\n# func_mktempdir [BASENAME]\n# -------------------------\n# Make a temporary directory that won't clash with other running\n# libtool processes, and avoids race conditions if possible.  If\n# given, BASENAME is the basename for that directory.\nfunc_mktempdir ()\n{\n    $debug_cmd\n\n    _G_template=${TMPDIR-/tmp}/${1-$progname}\n\n    if test : = \"$opt_dry_run\"; then\n      # Return a directory name, but don't create it in dry-run mode\n      _G_tmpdir=$_G_template-$$\n    else\n\n      # If mktemp works, use that first and foremost\n      _G_tmpdir=`mktemp -d \"$_G_template-XXXXXXXX\" 2>/dev/null`\n\n      if test ! -d \"$_G_tmpdir\"; then\n        # Failing that, at least try and use $RANDOM to avoid a race\n        _G_tmpdir=$_G_template-${RANDOM-0}$$\n\n        func_mktempdir_umask=`umask`\n        umask 0077\n        $MKDIR \"$_G_tmpdir\"\n        umask $func_mktempdir_umask\n      fi\n\n      # If we're not in dry-run mode, bomb out on failure\n      test -d \"$_G_tmpdir\" || \\\n        func_fatal_error \"cannot create temporary directory '$_G_tmpdir'\"\n    fi\n\n    $ECHO \"$_G_tmpdir\"\n}\n\n\n# func_normal_abspath PATH\n# ------------------------\n# Remove doubled-up and trailing slashes, \".\" path components,\n# and cancel out any \"..\" path components in PATH after making\n# it an absolute path.\nfunc_normal_abspath ()\n{\n    $debug_cmd\n\n    # These SED scripts presuppose an absolute path with a trailing slash.\n    _G_pathcar='s|^/\\([^/]*\\).*$|\\1|'\n    _G_pathcdr='s|^/[^/]*||'\n    _G_removedotparts=':dotsl\n\t\ts|/\\./|/|g\n\t\tt dotsl\n\t\ts|/\\.$|/|'\n    _G_collapseslashes='s|/\\{1,\\}|/|g'\n    _G_finalslash='s|/*$|/|'\n\n    # Start from root dir and reassemble the path.\n    func_normal_abspath_result=\n    func_normal_abspath_tpath=$1\n    func_normal_abspath_altnamespace=\n    case $func_normal_abspath_tpath in\n      \"\")\n        # Empty path, that just means $cwd.\n        func_stripname '' '/' \"`pwd`\"\n        func_normal_abspath_result=$func_stripname_result\n        return\n        ;;\n      # The next three entries are used to spot a run of precisely\n      # two leading slashes without using negated character classes;\n      # we take advantage of case's first-match behaviour.\n      ///*)\n        # Unusual form of absolute path, do nothing.\n        ;;\n      //*)\n        # Not necessarily an ordinary path; POSIX reserves leading '//'\n        # and for example Cygwin uses it to access remote file shares\n        # over CIFS/SMB, so we conserve a leading double slash if found.\n        func_normal_abspath_altnamespace=/\n        ;;\n      /*)\n        # Absolute path, do nothing.\n        ;;\n      *)\n        # Relative path, prepend $cwd.\n        func_normal_abspath_tpath=`pwd`/$func_normal_abspath_tpath\n        ;;\n    esac\n\n    # Cancel out all the simple stuff to save iterations.  We also want\n    # the path to end with a slash for ease of parsing, so make sure\n    # there is one (and only one) here.\n    func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n          -e \"$_G_removedotparts\" -e \"$_G_collapseslashes\" -e \"$_G_finalslash\"`\n    while :; do\n      # Processed it all yet?\n      if test / = \"$func_normal_abspath_tpath\"; then\n        # If we ascended to the root using \"..\" the result may be empty now.\n        if test -z \"$func_normal_abspath_result\"; then\n          func_normal_abspath_result=/\n        fi\n        break\n      fi\n      func_normal_abspath_tcomponent=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n          -e \"$_G_pathcar\"`\n      func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n          -e \"$_G_pathcdr\"`\n      # Figure out what to do with it\n      case $func_normal_abspath_tcomponent in\n        \"\")\n          # Trailing empty path component, ignore it.\n          ;;\n        ..)\n          # Parent dir; strip last assembled component from result.\n          func_dirname \"$func_normal_abspath_result\"\n          func_normal_abspath_result=$func_dirname_result\n          ;;\n        *)\n          # Actual path component, append it.\n          func_append func_normal_abspath_result \"/$func_normal_abspath_tcomponent\"\n          ;;\n      esac\n    done\n    # Restore leading double-slash if one was found on entry.\n    func_normal_abspath_result=$func_normal_abspath_altnamespace$func_normal_abspath_result\n}\n\n\n# func_notquiet ARG...\n# --------------------\n# Echo program name prefixed message only when not in quiet mode.\nfunc_notquiet ()\n{\n    $debug_cmd\n\n    $opt_quiet || func_echo ${1+\"$@\"}\n\n    # A bug in bash halts the script if the last line of a function\n    # fails when set -e is in force, so we need another command to\n    # work around that:\n    :\n}\n\n\n# func_relative_path SRCDIR DSTDIR\n# --------------------------------\n# Set func_relative_path_result to the relative path from SRCDIR to DSTDIR.\nfunc_relative_path ()\n{\n    $debug_cmd\n\n    func_relative_path_result=\n    func_normal_abspath \"$1\"\n    func_relative_path_tlibdir=$func_normal_abspath_result\n    func_normal_abspath \"$2\"\n    func_relative_path_tbindir=$func_normal_abspath_result\n\n    # Ascend the tree starting from libdir\n    while :; do\n      # check if we have found a prefix of bindir\n      case $func_relative_path_tbindir in\n        $func_relative_path_tlibdir)\n          # found an exact match\n          func_relative_path_tcancelled=\n          break\n          ;;\n        $func_relative_path_tlibdir*)\n          # found a matching prefix\n          func_stripname \"$func_relative_path_tlibdir\" '' \"$func_relative_path_tbindir\"\n          func_relative_path_tcancelled=$func_stripname_result\n          if test -z \"$func_relative_path_result\"; then\n            func_relative_path_result=.\n          fi\n          break\n          ;;\n        *)\n          func_dirname $func_relative_path_tlibdir\n          func_relative_path_tlibdir=$func_dirname_result\n          if test -z \"$func_relative_path_tlibdir\"; then\n            # Have to descend all the way to the root!\n            func_relative_path_result=../$func_relative_path_result\n            func_relative_path_tcancelled=$func_relative_path_tbindir\n            break\n          fi\n          func_relative_path_result=../$func_relative_path_result\n          ;;\n      esac\n    done\n\n    # Now calculate path; take care to avoid doubling-up slashes.\n    func_stripname '' '/' \"$func_relative_path_result\"\n    func_relative_path_result=$func_stripname_result\n    func_stripname '/' '/' \"$func_relative_path_tcancelled\"\n    if test -n \"$func_stripname_result\"; then\n      func_append func_relative_path_result \"/$func_stripname_result\"\n    fi\n\n    # Normalisation. If bindir is libdir, return '.' else relative path.\n    if test -n \"$func_relative_path_result\"; then\n      func_stripname './' '' \"$func_relative_path_result\"\n      func_relative_path_result=$func_stripname_result\n    fi\n\n    test -n \"$func_relative_path_result\" || func_relative_path_result=.\n\n    :\n}\n\n\n# func_quote_for_eval ARG...\n# --------------------------\n# Aesthetically quote ARGs to be evaled later.\n# This function returns two values:\n#   i) func_quote_for_eval_result\n#      double-quoted, suitable for a subsequent eval\n#  ii) func_quote_for_eval_unquoted_result\n#      has all characters that are still active within double\n#      quotes backslashified.\nfunc_quote_for_eval ()\n{\n    $debug_cmd\n\n    func_quote_for_eval_unquoted_result=\n    func_quote_for_eval_result=\n    while test 0 -lt $#; do\n      case $1 in\n        *[\\\\\\`\\\"\\$]*)\n\t  _G_unquoted_arg=`printf '%s\\n' \"$1\" |$SED \"$sed_quote_subst\"` ;;\n        *)\n          _G_unquoted_arg=$1 ;;\n      esac\n      if test -n \"$func_quote_for_eval_unquoted_result\"; then\n\tfunc_append func_quote_for_eval_unquoted_result \" $_G_unquoted_arg\"\n      else\n        func_append func_quote_for_eval_unquoted_result \"$_G_unquoted_arg\"\n      fi\n\n      case $_G_unquoted_arg in\n        # Double-quote args containing shell metacharacters to delay\n        # word splitting, command substitution and variable expansion\n        # for a subsequent eval.\n        # Many Bourne shells cannot handle close brackets correctly\n        # in scan sets, so we specify it separately.\n        *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n          _G_quoted_arg=\\\"$_G_unquoted_arg\\\"\n          ;;\n        *)\n          _G_quoted_arg=$_G_unquoted_arg\n\t  ;;\n      esac\n\n      if test -n \"$func_quote_for_eval_result\"; then\n\tfunc_append func_quote_for_eval_result \" $_G_quoted_arg\"\n      else\n        func_append func_quote_for_eval_result \"$_G_quoted_arg\"\n      fi\n      shift\n    done\n}\n\n\n# func_quote_for_expand ARG\n# -------------------------\n# Aesthetically quote ARG to be evaled later; same as above,\n# but do not quote variable references.\nfunc_quote_for_expand ()\n{\n    $debug_cmd\n\n    case $1 in\n      *[\\\\\\`\\\"]*)\n\t_G_arg=`$ECHO \"$1\" | $SED \\\n\t    -e \"$sed_double_quote_subst\" -e \"$sed_double_backslash\"` ;;\n      *)\n        _G_arg=$1 ;;\n    esac\n\n    case $_G_arg in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting and command substitution for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        _G_arg=\\\"$_G_arg\\\"\n        ;;\n    esac\n\n    func_quote_for_expand_result=$_G_arg\n}\n\n\n# func_stripname PREFIX SUFFIX NAME\n# ---------------------------------\n# strip PREFIX and SUFFIX from NAME, and store in func_stripname_result.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\nif test yes = \"$_G_HAVE_XSI_OPS\"; then\n  eval 'func_stripname ()\n  {\n    $debug_cmd\n\n    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\n    # positional parameters, so assign one to ordinary variable first.\n    func_stripname_result=$3\n    func_stripname_result=${func_stripname_result#\"$1\"}\n    func_stripname_result=${func_stripname_result%\"$2\"}\n  }'\nelse\n  func_stripname ()\n  {\n    $debug_cmd\n\n    case $2 in\n      .*) func_stripname_result=`$ECHO \"$3\" | $SED -e \"s%^$1%%\" -e \"s%\\\\\\\\$2\\$%%\"`;;\n      *)  func_stripname_result=`$ECHO \"$3\" | $SED -e \"s%^$1%%\" -e \"s%$2\\$%%\"`;;\n    esac\n  }\nfi\n\n\n# func_show_eval CMD [FAIL_EXP]\n# -----------------------------\n# Unless opt_quiet is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.\nfunc_show_eval ()\n{\n    $debug_cmd\n\n    _G_cmd=$1\n    _G_fail_exp=${2-':'}\n\n    func_quote_for_expand \"$_G_cmd\"\n    eval \"func_notquiet $func_quote_for_expand_result\"\n\n    $opt_dry_run || {\n      eval \"$_G_cmd\"\n      _G_status=$?\n      if test 0 -ne \"$_G_status\"; then\n\teval \"(exit $_G_status); $_G_fail_exp\"\n      fi\n    }\n}\n\n\n# func_show_eval_locale CMD [FAIL_EXP]\n# ------------------------------------\n# Unless opt_quiet is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.  Use the saved locale for evaluation.\nfunc_show_eval_locale ()\n{\n    $debug_cmd\n\n    _G_cmd=$1\n    _G_fail_exp=${2-':'}\n\n    $opt_quiet || {\n      func_quote_for_expand \"$_G_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    $opt_dry_run || {\n      eval \"$_G_user_locale\n\t    $_G_cmd\"\n      _G_status=$?\n      eval \"$_G_safe_locale\"\n      if test 0 -ne \"$_G_status\"; then\n\teval \"(exit $_G_status); $_G_fail_exp\"\n      fi\n    }\n}\n\n\n# func_tr_sh\n# ----------\n# Turn $1 into a string suitable for a shell variable name.\n# Result is stored in $func_tr_sh_result.  All characters\n# not in the set a-zA-Z0-9_ are replaced with '_'. Further,\n# if $1 begins with a digit, a '_' is prepended as well.\nfunc_tr_sh ()\n{\n    $debug_cmd\n\n    case $1 in\n    [0-9]* | *[!a-zA-Z0-9_]*)\n      func_tr_sh_result=`$ECHO \"$1\" | $SED -e 's/^\\([0-9]\\)/_\\1/' -e 's/[^a-zA-Z0-9_]/_/g'`\n      ;;\n    * )\n      func_tr_sh_result=$1\n      ;;\n    esac\n}\n\n\n# func_verbose ARG...\n# -------------------\n# Echo program name prefixed message in verbose mode only.\nfunc_verbose ()\n{\n    $debug_cmd\n\n    $opt_verbose && func_echo \"$*\"\n\n    :\n}\n\n\n# func_warn_and_continue ARG...\n# -----------------------------\n# Echo program name prefixed warning message to standard error.\nfunc_warn_and_continue ()\n{\n    $debug_cmd\n\n    $require_term_colors\n\n    func_echo_infix_1 \"${tc_red}warning$tc_reset\" \"$*\" >&2\n}\n\n\n# func_warning CATEGORY ARG...\n# ----------------------------\n# Echo program name prefixed warning message to standard error. Warning\n# messages can be filtered according to CATEGORY, where this function\n# elides messages where CATEGORY is not listed in the global variable\n# 'opt_warning_types'.\nfunc_warning ()\n{\n    $debug_cmd\n\n    # CATEGORY must be in the warning_categories list!\n    case \" $warning_categories \" in\n      *\" $1 \"*) ;;\n      *) func_internal_error \"invalid warning category '$1'\" ;;\n    esac\n\n    _G_category=$1\n    shift\n\n    case \" $opt_warning_types \" in\n      *\" $_G_category \"*) $warning_func ${1+\"$@\"} ;;\n    esac\n}\n\n\n# func_sort_ver VER1 VER2\n# -----------------------\n# 'sort -V' is not generally available.\n# Note this deviates from the version comparison in automake\n# in that it treats 1.5 < 1.5.0, and treats 1.4.4a < 1.4-p3a\n# but this should suffice as we won't be specifying old\n# version formats or redundant trailing .0 in bootstrap.conf.\n# If we did want full compatibility then we should probably\n# use m4_version_compare from autoconf.\nfunc_sort_ver ()\n{\n    $debug_cmd\n\n    printf '%s\\n%s\\n' \"$1\" \"$2\" \\\n      | sort -t. -k 1,1n -k 2,2n -k 3,3n -k 4,4n -k 5,5n -k 6,6n -k 7,7n -k 8,8n -k 9,9n\n}\n\n# func_lt_ver PREV CURR\n# ---------------------\n# Return true if PREV and CURR are in the correct order according to\n# func_sort_ver, otherwise false.  Use it like this:\n#\n#  func_lt_ver \"$prev_ver\" \"$proposed_ver\" || func_fatal_error \"...\"\nfunc_lt_ver ()\n{\n    $debug_cmd\n\n    test \"x$1\" = x`func_sort_ver \"$1\" \"$2\" | $SED 1q`\n}\n\n\n# Local variables:\n# mode: shell-script\n# sh-indentation: 2\n# eval: (add-hook 'before-save-hook 'time-stamp)\n# time-stamp-pattern: \"10/scriptversion=%:y-%02m-%02d.%02H; # UTC\"\n# time-stamp-time-zone: \"UTC\"\n# End:\n#! /bin/sh\n\n# Set a version string for this script.\nscriptversion=2014-01-07.03; # UTC\n\n# A portable, pluggable option parser for Bourne shell.\n# Written by Gary V. Vaughan, 2010\n\n# Copyright (C) 2010-2015 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# Please report bugs or propose patches to gary@gnu.org.\n\n\n## ------ ##\n## Usage. ##\n## ------ ##\n\n# This file is a library for parsing options in your shell scripts along\n# with assorted other useful supporting features that you can make use\n# of too.\n#\n# For the simplest scripts you might need only:\n#\n#   #!/bin/sh\n#   . relative/path/to/funclib.sh\n#   . relative/path/to/options-parser\n#   scriptversion=1.0\n#   func_options ${1+\"$@\"}\n#   eval set dummy \"$func_options_result\"; shift\n#   ...rest of your script...\n#\n# In order for the '--version' option to work, you will need to have a\n# suitably formatted comment like the one at the top of this file\n# starting with '# Written by ' and ending with '# warranty; '.\n#\n# For '-h' and '--help' to work, you will also need a one line\n# description of your script's purpose in a comment directly above the\n# '# Written by ' line, like the one at the top of this file.\n#\n# The default options also support '--debug', which will turn on shell\n# execution tracing (see the comment above debug_cmd below for another\n# use), and '--verbose' and the func_verbose function to allow your script\n# to display verbose messages only when your user has specified\n# '--verbose'.\n#\n# After sourcing this file, you can plug processing for additional\n# options by amending the variables from the 'Configuration' section\n# below, and following the instructions in the 'Option parsing'\n# section further down.\n\n## -------------- ##\n## Configuration. ##\n## -------------- ##\n\n# You should override these variables in your script after sourcing this\n# file so that they reflect the customisations you have added to the\n# option parser.\n\n# The usage line for option parsing errors and the start of '-h' and\n# '--help' output messages. You can embed shell variables for delayed\n# expansion at the time the message is displayed, but you will need to\n# quote other shell meta-characters carefully to prevent them being\n# expanded when the contents are evaled.\nusage='$progpath [OPTION]...'\n\n# Short help message in response to '-h' and '--help'.  Add to this or\n# override it after sourcing this library to reflect the full set of\n# options your script accepts.\nusage_message=\"\\\n       --debug        enable verbose shell tracing\n   -W, --warnings=CATEGORY\n                      report the warnings falling in CATEGORY [all]\n   -v, --verbose      verbosely report processing\n       --version      print version information and exit\n   -h, --help         print short or long help message and exit\n\"\n\n# Additional text appended to 'usage_message' in response to '--help'.\nlong_help_message=\"\nWarning categories include:\n       'all'          show all warnings\n       'none'         turn off all the warnings\n       'error'        warnings are treated as fatal errors\"\n\n# Help message printed before fatal option parsing errors.\nfatal_help=\"Try '\\$progname --help' for more information.\"\n\n\n\n## ------------------------- ##\n## Hook function management. ##\n## ------------------------- ##\n\n# This section contains functions for adding, removing, and running hooks\n# to the main code.  A hook is just a named list of of function, that can\n# be run in order later on.\n\n# func_hookable FUNC_NAME\n# -----------------------\n# Declare that FUNC_NAME will run hooks added with\n# 'func_add_hook FUNC_NAME ...'.\nfunc_hookable ()\n{\n    $debug_cmd\n\n    func_append hookable_fns \" $1\"\n}\n\n\n# func_add_hook FUNC_NAME HOOK_FUNC\n# ---------------------------------\n# Request that FUNC_NAME call HOOK_FUNC before it returns.  FUNC_NAME must\n# first have been declared \"hookable\" by a call to 'func_hookable'.\nfunc_add_hook ()\n{\n    $debug_cmd\n\n    case \" $hookable_fns \" in\n      *\" $1 \"*) ;;\n      *) func_fatal_error \"'$1' does not accept hook functions.\" ;;\n    esac\n\n    eval func_append ${1}_hooks '\" $2\"'\n}\n\n\n# func_remove_hook FUNC_NAME HOOK_FUNC\n# ------------------------------------\n# Remove HOOK_FUNC from the list of functions called by FUNC_NAME.\nfunc_remove_hook ()\n{\n    $debug_cmd\n\n    eval ${1}_hooks='`$ECHO \"\\$'$1'_hooks\" |$SED \"s| '$2'||\"`'\n}\n\n\n# func_run_hooks FUNC_NAME [ARG]...\n# ---------------------------------\n# Run all hook functions registered to FUNC_NAME.\n# It is assumed that the list of hook functions contains nothing more\n# than a whitespace-delimited list of legal shell function names, and\n# no effort is wasted trying to catch shell meta-characters or preserve\n# whitespace.\nfunc_run_hooks ()\n{\n    $debug_cmd\n\n    case \" $hookable_fns \" in\n      *\" $1 \"*) ;;\n      *) func_fatal_error \"'$1' does not support hook funcions.n\" ;;\n    esac\n\n    eval _G_hook_fns=\\$$1_hooks; shift\n\n    for _G_hook in $_G_hook_fns; do\n      eval $_G_hook '\"$@\"'\n\n      # store returned options list back into positional\n      # parameters for next 'cmd' execution.\n      eval _G_hook_result=\\$${_G_hook}_result\n      eval set dummy \"$_G_hook_result\"; shift\n    done\n\n    func_quote_for_eval ${1+\"$@\"}\n    func_run_hooks_result=$func_quote_for_eval_result\n}\n\n\n\n## --------------- ##\n## Option parsing. ##\n## --------------- ##\n\n# In order to add your own option parsing hooks, you must accept the\n# full positional parameter list in your hook function, remove any\n# options that you action, and then pass back the remaining unprocessed\n# options in '<hooked_function_name>_result', escaped suitably for\n# 'eval'.  Like this:\n#\n#    my_options_prep ()\n#    {\n#        $debug_cmd\n#\n#        # Extend the existing usage message.\n#        usage_message=$usage_message'\n#      -s, --silent       don'\\''t print informational messages\n#    '\n#\n#        func_quote_for_eval ${1+\"$@\"}\n#        my_options_prep_result=$func_quote_for_eval_result\n#    }\n#    func_add_hook func_options_prep my_options_prep\n#\n#\n#    my_silent_option ()\n#    {\n#        $debug_cmd\n#\n#        # Note that for efficiency, we parse as many options as we can\n#        # recognise in a loop before passing the remainder back to the\n#        # caller on the first unrecognised argument we encounter.\n#        while test $# -gt 0; do\n#          opt=$1; shift\n#          case $opt in\n#            --silent|-s) opt_silent=: ;;\n#            # Separate non-argument short options:\n#            -s*)         func_split_short_opt \"$_G_opt\"\n#                         set dummy \"$func_split_short_opt_name\" \\\n#                             \"-$func_split_short_opt_arg\" ${1+\"$@\"}\n#                         shift\n#                         ;;\n#            *)            set dummy \"$_G_opt\" \"$*\"; shift; break ;;\n#          esac\n#        done\n#\n#        func_quote_for_eval ${1+\"$@\"}\n#        my_silent_option_result=$func_quote_for_eval_result\n#    }\n#    func_add_hook func_parse_options my_silent_option\n#\n#\n#    my_option_validation ()\n#    {\n#        $debug_cmd\n#\n#        $opt_silent && $opt_verbose && func_fatal_help \"\\\n#    '--silent' and '--verbose' options are mutually exclusive.\"\n#\n#        func_quote_for_eval ${1+\"$@\"}\n#        my_option_validation_result=$func_quote_for_eval_result\n#    }\n#    func_add_hook func_validate_options my_option_validation\n#\n# You'll alse need to manually amend $usage_message to reflect the extra\n# options you parse.  It's preferable to append if you can, so that\n# multiple option parsing hooks can be added safely.\n\n\n# func_options [ARG]...\n# ---------------------\n# All the functions called inside func_options are hookable. See the\n# individual implementations for details.\nfunc_hookable func_options\nfunc_options ()\n{\n    $debug_cmd\n\n    func_options_prep ${1+\"$@\"}\n    eval func_parse_options \\\n        ${func_options_prep_result+\"$func_options_prep_result\"}\n    eval func_validate_options \\\n        ${func_parse_options_result+\"$func_parse_options_result\"}\n\n    eval func_run_hooks func_options \\\n        ${func_validate_options_result+\"$func_validate_options_result\"}\n\n    # save modified positional parameters for caller\n    func_options_result=$func_run_hooks_result\n}\n\n\n# func_options_prep [ARG]...\n# --------------------------\n# All initialisations required before starting the option parse loop.\n# Note that when calling hook functions, we pass through the list of\n# positional parameters.  If a hook function modifies that list, and\n# needs to propogate that back to rest of this script, then the complete\n# modified list must be put in 'func_run_hooks_result' before\n# returning.\nfunc_hookable func_options_prep\nfunc_options_prep ()\n{\n    $debug_cmd\n\n    # Option defaults:\n    opt_verbose=false\n    opt_warning_types=\n\n    func_run_hooks func_options_prep ${1+\"$@\"}\n\n    # save modified positional parameters for caller\n    func_options_prep_result=$func_run_hooks_result\n}\n\n\n# func_parse_options [ARG]...\n# ---------------------------\n# The main option parsing loop.\nfunc_hookable func_parse_options\nfunc_parse_options ()\n{\n    $debug_cmd\n\n    func_parse_options_result=\n\n    # this just eases exit handling\n    while test $# -gt 0; do\n      # Defer to hook functions for initial option parsing, so they\n      # get priority in the event of reusing an option name.\n      func_run_hooks func_parse_options ${1+\"$@\"}\n\n      # Adjust func_parse_options positional parameters to match\n      eval set dummy \"$func_run_hooks_result\"; shift\n\n      # Break out of the loop if we already parsed every option.\n      test $# -gt 0 || break\n\n      _G_opt=$1\n      shift\n      case $_G_opt in\n        --debug|-x)   debug_cmd='set -x'\n                      func_echo \"enabling shell trace mode\"\n                      $debug_cmd\n                      ;;\n\n        --no-warnings|--no-warning|--no-warn)\n                      set dummy --warnings none ${1+\"$@\"}\n                      shift\n\t\t      ;;\n\n        --warnings|--warning|-W)\n                      test $# = 0 && func_missing_arg $_G_opt && break\n                      case \" $warning_categories $1\" in\n                        *\" $1 \"*)\n                          # trailing space prevents matching last $1 above\n                          func_append_uniq opt_warning_types \" $1\"\n                          ;;\n                        *all)\n                          opt_warning_types=$warning_categories\n                          ;;\n                        *none)\n                          opt_warning_types=none\n                          warning_func=:\n                          ;;\n                        *error)\n                          opt_warning_types=$warning_categories\n                          warning_func=func_fatal_error\n                          ;;\n                        *)\n                          func_fatal_error \\\n                             \"unsupported warning category: '$1'\"\n                          ;;\n                      esac\n                      shift\n                      ;;\n\n        --verbose|-v) opt_verbose=: ;;\n        --version)    func_version ;;\n        -\\?|-h)       func_usage ;;\n        --help)       func_help ;;\n\n\t# Separate optargs to long options (plugins may need this):\n\t--*=*)        func_split_equals \"$_G_opt\"\n\t              set dummy \"$func_split_equals_lhs\" \\\n                          \"$func_split_equals_rhs\" ${1+\"$@\"}\n                      shift\n                      ;;\n\n       # Separate optargs to short options:\n        -W*)\n                      func_split_short_opt \"$_G_opt\"\n                      set dummy \"$func_split_short_opt_name\" \\\n                          \"$func_split_short_opt_arg\" ${1+\"$@\"}\n                      shift\n                      ;;\n\n        # Separate non-argument short options:\n        -\\?*|-h*|-v*|-x*)\n                      func_split_short_opt \"$_G_opt\"\n                      set dummy \"$func_split_short_opt_name\" \\\n                          \"-$func_split_short_opt_arg\" ${1+\"$@\"}\n                      shift\n                      ;;\n\n        --)           break ;;\n        -*)           func_fatal_help \"unrecognised option: '$_G_opt'\" ;;\n        *)            set dummy \"$_G_opt\" ${1+\"$@\"}; shift; break ;;\n      esac\n    done\n\n    # save modified positional parameters for caller\n    func_quote_for_eval ${1+\"$@\"}\n    func_parse_options_result=$func_quote_for_eval_result\n}\n\n\n# func_validate_options [ARG]...\n# ------------------------------\n# Perform any sanity checks on option settings and/or unconsumed\n# arguments.\nfunc_hookable func_validate_options\nfunc_validate_options ()\n{\n    $debug_cmd\n\n    # Display all warnings if -W was not given.\n    test -n \"$opt_warning_types\" || opt_warning_types=\" $warning_categories\"\n\n    func_run_hooks func_validate_options ${1+\"$@\"}\n\n    # Bail if the options were screwed!\n    $exit_cmd $EXIT_FAILURE\n\n    # save modified positional parameters for caller\n    func_validate_options_result=$func_run_hooks_result\n}\n\n\n\n## ----------------- ##\n## Helper functions. ##\n## ----------------- ##\n\n# This section contains the helper functions used by the rest of the\n# hookable option parser framework in ascii-betical order.\n\n\n# func_fatal_help ARG...\n# ----------------------\n# Echo program name prefixed message to standard error, followed by\n# a help hint, and exit.\nfunc_fatal_help ()\n{\n    $debug_cmd\n\n    eval \\$ECHO \\\"\"Usage: $usage\"\\\"\n    eval \\$ECHO \\\"\"$fatal_help\"\\\"\n    func_error ${1+\"$@\"}\n    exit $EXIT_FAILURE\n}\n\n\n# func_help\n# ---------\n# Echo long help message to standard output and exit.\nfunc_help ()\n{\n    $debug_cmd\n\n    func_usage_message\n    $ECHO \"$long_help_message\"\n    exit 0\n}\n\n\n# func_missing_arg ARGNAME\n# ------------------------\n# Echo program name prefixed message to standard error and set global\n# exit_cmd.\nfunc_missing_arg ()\n{\n    $debug_cmd\n\n    func_error \"Missing argument for '$1'.\"\n    exit_cmd=exit\n}\n\n\n# func_split_equals STRING\n# ------------------------\n# Set func_split_equals_lhs and func_split_equals_rhs shell variables after\n# splitting STRING at the '=' sign.\ntest -z \"$_G_HAVE_XSI_OPS\" \\\n    && (eval 'x=a/b/c;\n      test 5aa/bb/cc = \"${#x}${x%%/*}${x%/*}${x#*/}${x##*/}\"') 2>/dev/null \\\n    && _G_HAVE_XSI_OPS=yes\n\nif test yes = \"$_G_HAVE_XSI_OPS\"\nthen\n  # This is an XSI compatible shell, allowing a faster implementation...\n  eval 'func_split_equals ()\n  {\n      $debug_cmd\n\n      func_split_equals_lhs=${1%%=*}\n      func_split_equals_rhs=${1#*=}\n      test \"x$func_split_equals_lhs\" = \"x$1\" \\\n        && func_split_equals_rhs=\n  }'\nelse\n  # ...otherwise fall back to using expr, which is often a shell builtin.\n  func_split_equals ()\n  {\n      $debug_cmd\n\n      func_split_equals_lhs=`expr \"x$1\" : 'x\\([^=]*\\)'`\n      func_split_equals_rhs=\n      test \"x$func_split_equals_lhs\" = \"x$1\" \\\n        || func_split_equals_rhs=`expr \"x$1\" : 'x[^=]*=\\(.*\\)$'`\n  }\nfi #func_split_equals\n\n\n# func_split_short_opt SHORTOPT\n# -----------------------------\n# Set func_split_short_opt_name and func_split_short_opt_arg shell\n# variables after splitting SHORTOPT after the 2nd character.\nif test yes = \"$_G_HAVE_XSI_OPS\"\nthen\n  # This is an XSI compatible shell, allowing a faster implementation...\n  eval 'func_split_short_opt ()\n  {\n      $debug_cmd\n\n      func_split_short_opt_arg=${1#??}\n      func_split_short_opt_name=${1%\"$func_split_short_opt_arg\"}\n  }'\nelse\n  # ...otherwise fall back to using expr, which is often a shell builtin.\n  func_split_short_opt ()\n  {\n      $debug_cmd\n\n      func_split_short_opt_name=`expr \"x$1\" : 'x-\\(.\\)'`\n      func_split_short_opt_arg=`expr \"x$1\" : 'x-.\\(.*\\)$'`\n  }\nfi #func_split_short_opt\n\n\n# func_usage\n# ----------\n# Echo short help message to standard output and exit.\nfunc_usage ()\n{\n    $debug_cmd\n\n    func_usage_message\n    $ECHO \"Run '$progname --help |${PAGER-more}' for full usage\"\n    exit 0\n}\n\n\n# func_usage_message\n# ------------------\n# Echo short help message to standard output.\nfunc_usage_message ()\n{\n    $debug_cmd\n\n    eval \\$ECHO \\\"\"Usage: $usage\"\\\"\n    echo\n    $SED -n 's|^# ||\n        /^Written by/{\n          x;p;x\n        }\n\th\n\t/^Written by/q' < \"$progpath\"\n    echo\n    eval \\$ECHO \\\"\"$usage_message\"\\\"\n}\n\n\n# func_version\n# ------------\n# Echo version message to standard output and exit.\nfunc_version ()\n{\n    $debug_cmd\n\n    printf '%s\\n' \"$progname $scriptversion\"\n    $SED -n '\n        /(C)/!b go\n        :more\n        /\\./!{\n          N\n          s|\\n# | |\n          b more\n        }\n        :go\n        /^# Written by /,/# warranty; / {\n          s|^# ||\n          s|^# *$||\n          s|\\((C)\\)[ 0-9,-]*[ ,-]\\([1-9][0-9]* \\)|\\1 \\2|\n          p\n        }\n        /^# Written by / {\n          s|^# ||\n          p\n        }\n        /^warranty; /q' < \"$progpath\"\n\n    exit $?\n}\n\n\n# Local variables:\n# mode: shell-script\n# sh-indentation: 2\n# eval: (add-hook 'before-save-hook 'time-stamp)\n# time-stamp-pattern: \"10/scriptversion=%:y-%02m-%02d.%02H; # UTC\"\n# time-stamp-time-zone: \"UTC\"\n# End:\n\n# Set a version string.\nscriptversion='(GNU libtool) 2.4.6'\n\n\n# func_echo ARG...\n# ----------------\n# Libtool also displays the current mode in messages, so override\n# funclib.sh func_echo with this custom definition.\nfunc_echo ()\n{\n    $debug_cmd\n\n    _G_message=$*\n\n    func_echo_IFS=$IFS\n    IFS=$nl\n    for _G_line in $_G_message; do\n      IFS=$func_echo_IFS\n      $ECHO \"$progname${opt_mode+: $opt_mode}: $_G_line\"\n    done\n    IFS=$func_echo_IFS\n}\n\n\n# func_warning ARG...\n# -------------------\n# Libtool warnings are not categorized, so override funclib.sh\n# func_warning with this simpler definition.\nfunc_warning ()\n{\n    $debug_cmd\n\n    $warning_func ${1+\"$@\"}\n}\n\n\n## ---------------- ##\n## Options parsing. ##\n## ---------------- ##\n\n# Hook in the functions to make sure our own options are parsed during\n# the option parsing loop.\n\nusage='$progpath [OPTION]... [MODE-ARG]...'\n\n# Short help message in response to '-h'.\nusage_message=\"Options:\n       --config             show all configuration variables\n       --debug              enable verbose shell tracing\n   -n, --dry-run            display commands without modifying any files\n       --features           display basic configuration information and exit\n       --mode=MODE          use operation mode MODE\n       --no-warnings        equivalent to '-Wnone'\n       --preserve-dup-deps  don't remove duplicate dependency libraries\n       --quiet, --silent    don't print informational messages\n       --tag=TAG            use configuration variables from tag TAG\n   -v, --verbose            print more informational messages than default\n       --version            print version information\n   -W, --warnings=CATEGORY  report the warnings falling in CATEGORY [all]\n   -h, --help, --help-all   print short, long, or detailed help message\n\"\n\n# Additional text appended to 'usage_message' in response to '--help'.\nfunc_help ()\n{\n    $debug_cmd\n\n    func_usage_message\n    $ECHO \"$long_help_message\n\nMODE must be one of the following:\n\n       clean           remove files from the build directory\n       compile         compile a source file into a libtool object\n       execute         automatically set library path, then run a program\n       finish          complete the installation of libtool libraries\n       install         install libraries or executables\n       link            create a library or an executable\n       uninstall       remove libraries from an installed directory\n\nMODE-ARGS vary depending on the MODE.  When passed as first option,\n'--mode=MODE' may be abbreviated as 'MODE' or a unique abbreviation of that.\nTry '$progname --help --mode=MODE' for a more detailed description of MODE.\n\nWhen reporting a bug, please describe a test case to reproduce it and\ninclude the following information:\n\n       host-triplet:   $host\n       shell:          $SHELL\n       compiler:       $LTCC\n       compiler flags: $LTCFLAGS\n       linker:         $LD (gnu? $with_gnu_ld)\n       version:        $progname (GNU libtool) 2.4.6\n       automake:       `($AUTOMAKE --version) 2>/dev/null |$SED 1q`\n       autoconf:       `($AUTOCONF --version) 2>/dev/null |$SED 1q`\n\nReport bugs to <bug-libtool@gnu.org>.\nGNU libtool home page: <http://www.gnu.org/s/libtool/>.\nGeneral help using GNU software: <http://www.gnu.org/gethelp/>.\"\n    exit 0\n}\n\n\n# func_lo2o OBJECT-NAME\n# ---------------------\n# Transform OBJECT-NAME from a '.lo' suffix to the platform specific\n# object suffix.\n\nlo2o=s/\\\\.lo\\$/.$objext/\no2lo=s/\\\\.$objext\\$/.lo/\n\nif test yes = \"$_G_HAVE_XSI_OPS\"; then\n  eval 'func_lo2o ()\n  {\n    case $1 in\n      *.lo) func_lo2o_result=${1%.lo}.$objext ;;\n      *   ) func_lo2o_result=$1               ;;\n    esac\n  }'\n\n  # func_xform LIBOBJ-OR-SOURCE\n  # ---------------------------\n  # Transform LIBOBJ-OR-SOURCE from a '.o' or '.c' (or otherwise)\n  # suffix to a '.lo' libtool-object suffix.\n  eval 'func_xform ()\n  {\n    func_xform_result=${1%.*}.lo\n  }'\nelse\n  # ...otherwise fall back to using sed.\n  func_lo2o ()\n  {\n    func_lo2o_result=`$ECHO \"$1\" | $SED \"$lo2o\"`\n  }\n\n  func_xform ()\n  {\n    func_xform_result=`$ECHO \"$1\" | $SED 's|\\.[^.]*$|.lo|'`\n  }\nfi\n\n\n# func_fatal_configuration ARG...\n# -------------------------------\n# Echo program name prefixed message to standard error, followed by\n# a configuration failure hint, and exit.\nfunc_fatal_configuration ()\n{\n    func__fatal_error ${1+\"$@\"} \\\n      \"See the $PACKAGE documentation for more information.\" \\\n      \"Fatal configuration error.\"\n}\n\n\n# func_config\n# -----------\n# Display the configuration for all the tags in this script.\nfunc_config ()\n{\n    re_begincf='^# ### BEGIN LIBTOOL'\n    re_endcf='^# ### END LIBTOOL'\n\n    # Default configuration.\n    $SED \"1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\\$d\" < \"$progpath\"\n\n    # Now print the configurations for the tags.\n    for tagname in $taglist; do\n      $SED -n \"/$re_begincf TAG CONFIG: $tagname\\$/,/$re_endcf TAG CONFIG: $tagname\\$/p\" < \"$progpath\"\n    done\n\n    exit $?\n}\n\n\n# func_features\n# -------------\n# Display the features supported by this script.\nfunc_features ()\n{\n    echo \"host: $host\"\n    if test yes = \"$build_libtool_libs\"; then\n      echo \"enable shared libraries\"\n    else\n      echo \"disable shared libraries\"\n    fi\n    if test yes = \"$build_old_libs\"; then\n      echo \"enable static libraries\"\n    else\n      echo \"disable static libraries\"\n    fi\n\n    exit $?\n}\n\n\n# func_enable_tag TAGNAME\n# -----------------------\n# Verify that TAGNAME is valid, and either flag an error and exit, or\n# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist\n# variable here.\nfunc_enable_tag ()\n{\n    # Global variable:\n    tagname=$1\n\n    re_begincf=\"^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\\$\"\n    re_endcf=\"^# ### END LIBTOOL TAG CONFIG: $tagname\\$\"\n    sed_extractcf=/$re_begincf/,/$re_endcf/p\n\n    # Validate tagname.\n    case $tagname in\n      *[!-_A-Za-z0-9,/]*)\n        func_fatal_error \"invalid tag name: $tagname\"\n        ;;\n    esac\n\n    # Don't test for the \"default\" C tag, as we know it's\n    # there but not specially marked.\n    case $tagname in\n        CC) ;;\n    *)\n        if $GREP \"$re_begincf\" \"$progpath\" >/dev/null 2>&1; then\n\t  taglist=\"$taglist $tagname\"\n\n\t  # Evaluate the configuration.  Be careful to quote the path\n\t  # and the sed script, to avoid splitting on whitespace, but\n\t  # also don't use non-portable quotes within backquotes within\n\t  # quotes we have to do it in 2 steps:\n\t  extractedcf=`$SED -n -e \"$sed_extractcf\" < \"$progpath\"`\n\t  eval \"$extractedcf\"\n        else\n\t  func_error \"ignoring unknown tag $tagname\"\n        fi\n        ;;\n    esac\n}\n\n\n# func_check_version_match\n# ------------------------\n# Ensure that we are using m4 macros, and libtool script from the same\n# release of libtool.\nfunc_check_version_match ()\n{\n    if test \"$package_revision\" != \"$macro_revision\"; then\n      if test \"$VERSION\" != \"$macro_version\"; then\n        if test -z \"$macro_version\"; then\n          cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from an older release.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n        else\n          cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n        fi\n      else\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,\n$progname: but the definition of this LT_INIT comes from revision $macro_revision.\n$progname: You should recreate aclocal.m4 with macros from revision $package_revision\n$progname: of $PACKAGE $VERSION and run autoconf again.\n_LT_EOF\n      fi\n\n      exit $EXIT_MISMATCH\n    fi\n}\n\n\n# libtool_options_prep [ARG]...\n# -----------------------------\n# Preparation for options parsed by libtool.\nlibtool_options_prep ()\n{\n    $debug_mode\n\n    # Option defaults:\n    opt_config=false\n    opt_dlopen=\n    opt_dry_run=false\n    opt_help=false\n    opt_mode=\n    opt_preserve_dup_deps=false\n    opt_quiet=false\n\n    nonopt=\n    preserve_args=\n\n    # Shorthand for --mode=foo, only valid as the first argument\n    case $1 in\n    clean|clea|cle|cl)\n      shift; set dummy --mode clean ${1+\"$@\"}; shift\n      ;;\n    compile|compil|compi|comp|com|co|c)\n      shift; set dummy --mode compile ${1+\"$@\"}; shift\n      ;;\n    execute|execut|execu|exec|exe|ex|e)\n      shift; set dummy --mode execute ${1+\"$@\"}; shift\n      ;;\n    finish|finis|fini|fin|fi|f)\n      shift; set dummy --mode finish ${1+\"$@\"}; shift\n      ;;\n    install|instal|insta|inst|ins|in|i)\n      shift; set dummy --mode install ${1+\"$@\"}; shift\n      ;;\n    link|lin|li|l)\n      shift; set dummy --mode link ${1+\"$@\"}; shift\n      ;;\n    uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)\n      shift; set dummy --mode uninstall ${1+\"$@\"}; shift\n      ;;\n    esac\n\n    # Pass back the list of options.\n    func_quote_for_eval ${1+\"$@\"}\n    libtool_options_prep_result=$func_quote_for_eval_result\n}\nfunc_add_hook func_options_prep libtool_options_prep\n\n\n# libtool_parse_options [ARG]...\n# ---------------------------------\n# Provide handling for libtool specific options.\nlibtool_parse_options ()\n{\n    $debug_cmd\n\n    # Perform our own loop to consume as many options as possible in\n    # each iteration.\n    while test $# -gt 0; do\n      _G_opt=$1\n      shift\n      case $_G_opt in\n        --dry-run|--dryrun|-n)\n                        opt_dry_run=:\n                        ;;\n\n        --config)       func_config ;;\n\n        --dlopen|-dlopen)\n                        opt_dlopen=\"${opt_dlopen+$opt_dlopen\n}$1\"\n                        shift\n                        ;;\n\n        --preserve-dup-deps)\n                        opt_preserve_dup_deps=: ;;\n\n        --features)     func_features ;;\n\n        --finish)       set dummy --mode finish ${1+\"$@\"}; shift ;;\n\n        --help)         opt_help=: ;;\n\n        --help-all)     opt_help=': help-all' ;;\n\n        --mode)         test $# = 0 && func_missing_arg $_G_opt && break\n                        opt_mode=$1\n                        case $1 in\n                          # Valid mode arguments:\n                          clean|compile|execute|finish|install|link|relink|uninstall) ;;\n\n                          # Catch anything else as an error\n                          *) func_error \"invalid argument for $_G_opt\"\n                             exit_cmd=exit\n                             break\n                             ;;\n                        esac\n                        shift\n                        ;;\n\n        --no-silent|--no-quiet)\n                        opt_quiet=false\n                        func_append preserve_args \" $_G_opt\"\n                        ;;\n\n        --no-warnings|--no-warning|--no-warn)\n                        opt_warning=false\n                        func_append preserve_args \" $_G_opt\"\n                        ;;\n\n        --no-verbose)\n                        opt_verbose=false\n                        func_append preserve_args \" $_G_opt\"\n                        ;;\n\n        --silent|--quiet)\n                        opt_quiet=:\n                        opt_verbose=false\n                        func_append preserve_args \" $_G_opt\"\n                        ;;\n\n        --tag)          test $# = 0 && func_missing_arg $_G_opt && break\n                        opt_tag=$1\n                        func_append preserve_args \" $_G_opt $1\"\n                        func_enable_tag \"$1\"\n                        shift\n                        ;;\n\n        --verbose|-v)   opt_quiet=false\n                        opt_verbose=:\n                        func_append preserve_args \" $_G_opt\"\n                        ;;\n\n\t# An option not handled by this hook function:\n        *)\t\tset dummy \"$_G_opt\" ${1+\"$@\"};\tshift; break  ;;\n      esac\n    done\n\n\n    # save modified positional parameters for caller\n    func_quote_for_eval ${1+\"$@\"}\n    libtool_parse_options_result=$func_quote_for_eval_result\n}\nfunc_add_hook func_parse_options libtool_parse_options\n\n\n\n# libtool_validate_options [ARG]...\n# ---------------------------------\n# Perform any sanity checks on option settings and/or unconsumed\n# arguments.\nlibtool_validate_options ()\n{\n    # save first non-option argument\n    if test 0 -lt $#; then\n      nonopt=$1\n      shift\n    fi\n\n    # preserve --debug\n    test : = \"$debug_cmd\" || func_append preserve_args \" --debug\"\n\n    case $host in\n      # Solaris2 added to fix http://debbugs.gnu.org/cgi/bugreport.cgi?bug=16452\n      # see also: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=59788\n      *cygwin* | *mingw* | *pw32* | *cegcc* | *solaris2* | *os2*)\n        # don't eliminate duplications in $postdeps and $predeps\n        opt_duplicate_compiler_generated_deps=:\n        ;;\n      *)\n        opt_duplicate_compiler_generated_deps=$opt_preserve_dup_deps\n        ;;\n    esac\n\n    $opt_help || {\n      # Sanity checks first:\n      func_check_version_match\n\n      test yes != \"$build_libtool_libs\" \\\n        && test yes != \"$build_old_libs\" \\\n        && func_fatal_configuration \"not configured to build any kind of library\"\n\n      # Darwin sucks\n      eval std_shrext=\\\"$shrext_cmds\\\"\n\n      # Only execute mode is allowed to have -dlopen flags.\n      if test -n \"$opt_dlopen\" && test execute != \"$opt_mode\"; then\n        func_error \"unrecognized option '-dlopen'\"\n        $ECHO \"$help\" 1>&2\n        exit $EXIT_FAILURE\n      fi\n\n      # Change the help message to a mode-specific one.\n      generic_help=$help\n      help=\"Try '$progname --help --mode=$opt_mode' for more information.\"\n    }\n\n    # Pass back the unparsed argument list\n    func_quote_for_eval ${1+\"$@\"}\n    libtool_validate_options_result=$func_quote_for_eval_result\n}\nfunc_add_hook func_validate_options libtool_validate_options\n\n\n# Process options as early as possible so that --help and --version\n# can return quickly.\nfunc_options ${1+\"$@\"}\neval set dummy \"$func_options_result\"; shift\n\n\n\n## ----------- ##\n##    Main.    ##\n## ----------- ##\n\nmagic='%%%MAGIC variable%%%'\nmagic_exe='%%%MAGIC EXE variable%%%'\n\n# Global variables.\nextracted_archives=\nextracted_serial=0\n\n# If this variable is set in any of the actions, the command in it\n# will be execed at the end.  This prevents here-documents from being\n# left over by shells.\nexec_cmd=\n\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n$1\n_LTECHO_EOF'\n}\n\n# func_generated_by_libtool\n# True iff stdin has been generated by Libtool. This function is only\n# a basic sanity check; it will hardly flush out determined imposters.\nfunc_generated_by_libtool_p ()\n{\n  $GREP \"^# Generated by .*$PACKAGE\" > /dev/null 2>&1\n}\n\n# func_lalib_p file\n# True iff FILE is a libtool '.la' library or '.lo' object file.\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_lalib_p ()\n{\n    test -f \"$1\" &&\n      $SED -e 4q \"$1\" 2>/dev/null | func_generated_by_libtool_p\n}\n\n# func_lalib_unsafe_p file\n# True iff FILE is a libtool '.la' library or '.lo' object file.\n# This function implements the same check as func_lalib_p without\n# resorting to external programs.  To this end, it redirects stdin and\n# closes it afterwards, without saving the original file descriptor.\n# As a safety measure, use it only where a negative result would be\n# fatal anyway.  Works if 'file' does not exist.\nfunc_lalib_unsafe_p ()\n{\n    lalib_p=no\n    if test -f \"$1\" && test -r \"$1\" && exec 5<&0 <\"$1\"; then\n\tfor lalib_p_l in 1 2 3 4\n\tdo\n\t    read lalib_p_line\n\t    case $lalib_p_line in\n\t\t\\#\\ Generated\\ by\\ *$PACKAGE* ) lalib_p=yes; break;;\n\t    esac\n\tdone\n\texec 0<&5 5<&-\n    fi\n    test yes = \"$lalib_p\"\n}\n\n# func_ltwrapper_script_p file\n# True iff FILE is a libtool wrapper script\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_script_p ()\n{\n    test -f \"$1\" &&\n      $lt_truncate_bin < \"$1\" 2>/dev/null | func_generated_by_libtool_p\n}\n\n# func_ltwrapper_executable_p file\n# True iff FILE is a libtool wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_executable_p ()\n{\n    func_ltwrapper_exec_suffix=\n    case $1 in\n    *.exe) ;;\n    *) func_ltwrapper_exec_suffix=.exe ;;\n    esac\n    $GREP \"$magic_exe\" \"$1$func_ltwrapper_exec_suffix\" >/dev/null 2>&1\n}\n\n# func_ltwrapper_scriptname file\n# Assumes file is an ltwrapper_executable\n# uses $file to determine the appropriate filename for a\n# temporary ltwrapper_script.\nfunc_ltwrapper_scriptname ()\n{\n    func_dirname_and_basename \"$1\" \"\" \".\"\n    func_stripname '' '.exe' \"$func_basename_result\"\n    func_ltwrapper_scriptname_result=$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper\n}\n\n# func_ltwrapper_p file\n# True iff FILE is a libtool wrapper script or wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_p ()\n{\n    func_ltwrapper_script_p \"$1\" || func_ltwrapper_executable_p \"$1\"\n}\n\n\n# func_execute_cmds commands fail_cmd\n# Execute tilde-delimited COMMANDS.\n# If FAIL_CMD is given, eval that upon failure.\n# FAIL_CMD may read-access the current command in variable CMD!\nfunc_execute_cmds ()\n{\n    $debug_cmd\n\n    save_ifs=$IFS; IFS='~'\n    for cmd in $1; do\n      IFS=$sp$nl\n      eval cmd=\\\"$cmd\\\"\n      IFS=$save_ifs\n      func_show_eval \"$cmd\" \"${2-:}\"\n    done\n    IFS=$save_ifs\n}\n\n\n# func_source file\n# Source FILE, adding directory component if necessary.\n# Note that it is not necessary on cygwin/mingw to append a dot to\n# FILE even if both FILE and FILE.exe exist: automatic-append-.exe\n# behavior happens only for exec(3), not for open(2)!  Also, sourcing\n# 'FILE.' does not work on cygwin managed mounts.\nfunc_source ()\n{\n    $debug_cmd\n\n    case $1 in\n    */* | *\\\\*)\t. \"$1\" ;;\n    *)\t\t. \"./$1\" ;;\n    esac\n}\n\n\n# func_resolve_sysroot PATH\n# Replace a leading = in PATH with a sysroot.  Store the result into\n# func_resolve_sysroot_result\nfunc_resolve_sysroot ()\n{\n  func_resolve_sysroot_result=$1\n  case $func_resolve_sysroot_result in\n  =*)\n    func_stripname '=' '' \"$func_resolve_sysroot_result\"\n    func_resolve_sysroot_result=$lt_sysroot$func_stripname_result\n    ;;\n  esac\n}\n\n# func_replace_sysroot PATH\n# If PATH begins with the sysroot, replace it with = and\n# store the result into func_replace_sysroot_result.\nfunc_replace_sysroot ()\n{\n  case $lt_sysroot:$1 in\n  ?*:\"$lt_sysroot\"*)\n    func_stripname \"$lt_sysroot\" '' \"$1\"\n    func_replace_sysroot_result='='$func_stripname_result\n    ;;\n  *)\n    # Including no sysroot.\n    func_replace_sysroot_result=$1\n    ;;\n  esac\n}\n\n# func_infer_tag arg\n# Infer tagged configuration to use if any are available and\n# if one wasn't chosen via the \"--tag\" command line option.\n# Only attempt this if the compiler in the base compile\n# command doesn't match the default compiler.\n# arg is usually of the form 'gcc ...'\nfunc_infer_tag ()\n{\n    $debug_cmd\n\n    if test -n \"$available_tags\" && test -z \"$tagname\"; then\n      CC_quoted=\n      for arg in $CC; do\n\tfunc_append_quoted CC_quoted \"$arg\"\n      done\n      CC_expanded=`func_echo_all $CC`\n      CC_quoted_expanded=`func_echo_all $CC_quoted`\n      case $@ in\n      # Blanks in the command may have been stripped by the calling shell,\n      # but not from the CC environment variable when configure was run.\n      \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n      \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*) ;;\n      # Blanks at the start of $base_compile will cause this to fail\n      # if we don't check for them as well.\n      *)\n\tfor z in $available_tags; do\n\t  if $GREP \"^# ### BEGIN LIBTOOL TAG CONFIG: $z$\" < \"$progpath\" > /dev/null; then\n\t    # Evaluate the configuration.\n\t    eval \"`$SED -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`\"\n\t    CC_quoted=\n\t    for arg in $CC; do\n\t      # Double-quote args containing other shell metacharacters.\n\t      func_append_quoted CC_quoted \"$arg\"\n\t    done\n\t    CC_expanded=`func_echo_all $CC`\n\t    CC_quoted_expanded=`func_echo_all $CC_quoted`\n\t    case \"$@ \" in\n\t    \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n\t    \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*)\n\t      # The compiler in the base compile command matches\n\t      # the one in the tagged configuration.\n\t      # Assume this is the tagged configuration we want.\n\t      tagname=$z\n\t      break\n\t      ;;\n\t    esac\n\t  fi\n\tdone\n\t# If $tagname still isn't set, then no tagged configuration\n\t# was found and let the user know that the \"--tag\" command\n\t# line option must be used.\n\tif test -z \"$tagname\"; then\n\t  func_echo \"unable to infer tagged configuration\"\n\t  func_fatal_error \"specify a tag with '--tag'\"\n#\telse\n#\t  func_verbose \"using $tagname tagged configuration\"\n\tfi\n\t;;\n      esac\n    fi\n}\n\n\n\n# func_write_libtool_object output_name pic_name nonpic_name\n# Create a libtool object file (analogous to a \".la\" file),\n# but don't create it if we're doing a dry run.\nfunc_write_libtool_object ()\n{\n    write_libobj=$1\n    if test yes = \"$build_libtool_libs\"; then\n      write_lobj=\\'$2\\'\n    else\n      write_lobj=none\n    fi\n\n    if test yes = \"$build_old_libs\"; then\n      write_oldobj=\\'$3\\'\n    else\n      write_oldobj=none\n    fi\n\n    $opt_dry_run || {\n      cat >${write_libobj}T <<EOF\n# $write_libobj - a libtool object file\n# Generated by $PROGRAM (GNU $PACKAGE) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# Name of the PIC object.\npic_object=$write_lobj\n\n# Name of the non-PIC object\nnon_pic_object=$write_oldobj\n\nEOF\n      $MV \"${write_libobj}T\" \"$write_libobj\"\n    }\n}\n\n\n##################################################\n# FILE NAME AND PATH CONVERSION HELPER FUNCTIONS #\n##################################################\n\n# func_convert_core_file_wine_to_w32 ARG\n# Helper function used by file name conversion functions when $build is *nix,\n# and $host is mingw, cygwin, or some other w32 environment. Relies on a\n# correctly configured wine environment available, with the winepath program\n# in $build's $PATH.\n#\n# ARG is the $build file name to be converted to w32 format.\n# Result is available in $func_convert_core_file_wine_to_w32_result, and will\n# be empty on error (or when ARG is empty)\nfunc_convert_core_file_wine_to_w32 ()\n{\n  $debug_cmd\n\n  func_convert_core_file_wine_to_w32_result=$1\n  if test -n \"$1\"; then\n    # Unfortunately, winepath does not exit with a non-zero error code, so we\n    # are forced to check the contents of stdout. On the other hand, if the\n    # command is not found, the shell will set an exit code of 127 and print\n    # *an error message* to stdout. So we must check for both error code of\n    # zero AND non-empty stdout, which explains the odd construction:\n    func_convert_core_file_wine_to_w32_tmp=`winepath -w \"$1\" 2>/dev/null`\n    if test \"$?\" -eq 0 && test -n \"$func_convert_core_file_wine_to_w32_tmp\"; then\n      func_convert_core_file_wine_to_w32_result=`$ECHO \"$func_convert_core_file_wine_to_w32_tmp\" |\n        $SED -e \"$sed_naive_backslashify\"`\n    else\n      func_convert_core_file_wine_to_w32_result=\n    fi\n  fi\n}\n# end: func_convert_core_file_wine_to_w32\n\n\n# func_convert_core_path_wine_to_w32 ARG\n# Helper function used by path conversion functions when $build is *nix, and\n# $host is mingw, cygwin, or some other w32 environment. Relies on a correctly\n# configured wine environment available, with the winepath program in $build's\n# $PATH. Assumes ARG has no leading or trailing path separator characters.\n#\n# ARG is path to be converted from $build format to win32.\n# Result is available in $func_convert_core_path_wine_to_w32_result.\n# Unconvertible file (directory) names in ARG are skipped; if no directory names\n# are convertible, then the result may be empty.\nfunc_convert_core_path_wine_to_w32 ()\n{\n  $debug_cmd\n\n  # unfortunately, winepath doesn't convert paths, only file names\n  func_convert_core_path_wine_to_w32_result=\n  if test -n \"$1\"; then\n    oldIFS=$IFS\n    IFS=:\n    for func_convert_core_path_wine_to_w32_f in $1; do\n      IFS=$oldIFS\n      func_convert_core_file_wine_to_w32 \"$func_convert_core_path_wine_to_w32_f\"\n      if test -n \"$func_convert_core_file_wine_to_w32_result\"; then\n        if test -z \"$func_convert_core_path_wine_to_w32_result\"; then\n          func_convert_core_path_wine_to_w32_result=$func_convert_core_file_wine_to_w32_result\n        else\n          func_append func_convert_core_path_wine_to_w32_result \";$func_convert_core_file_wine_to_w32_result\"\n        fi\n      fi\n    done\n    IFS=$oldIFS\n  fi\n}\n# end: func_convert_core_path_wine_to_w32\n\n\n# func_cygpath ARGS...\n# Wrapper around calling the cygpath program via LT_CYGPATH. This is used when\n# when (1) $build is *nix and Cygwin is hosted via a wine environment; or (2)\n# $build is MSYS and $host is Cygwin, or (3) $build is Cygwin. In case (1) or\n# (2), returns the Cygwin file name or path in func_cygpath_result (input\n# file name or path is assumed to be in w32 format, as previously converted\n# from $build's *nix or MSYS format). In case (3), returns the w32 file name\n# or path in func_cygpath_result (input file name or path is assumed to be in\n# Cygwin format). Returns an empty string on error.\n#\n# ARGS are passed to cygpath, with the last one being the file name or path to\n# be converted.\n#\n# Specify the absolute *nix (or w32) name to cygpath in the LT_CYGPATH\n# environment variable; do not put it in $PATH.\nfunc_cygpath ()\n{\n  $debug_cmd\n\n  if test -n \"$LT_CYGPATH\" && test -f \"$LT_CYGPATH\"; then\n    func_cygpath_result=`$LT_CYGPATH \"$@\" 2>/dev/null`\n    if test \"$?\" -ne 0; then\n      # on failure, ensure result is empty\n      func_cygpath_result=\n    fi\n  else\n    func_cygpath_result=\n    func_error \"LT_CYGPATH is empty or specifies non-existent file: '$LT_CYGPATH'\"\n  fi\n}\n#end: func_cygpath\n\n\n# func_convert_core_msys_to_w32 ARG\n# Convert file name or path ARG from MSYS format to w32 format.  Return\n# result in func_convert_core_msys_to_w32_result.\nfunc_convert_core_msys_to_w32 ()\n{\n  $debug_cmd\n\n  # awkward: cmd appends spaces to result\n  func_convert_core_msys_to_w32_result=`( cmd //c echo \"$1\" ) 2>/dev/null |\n    $SED -e 's/[ ]*$//' -e \"$sed_naive_backslashify\"`\n}\n#end: func_convert_core_msys_to_w32\n\n\n# func_convert_file_check ARG1 ARG2\n# Verify that ARG1 (a file name in $build format) was converted to $host\n# format in ARG2. Otherwise, emit an error message, but continue (resetting\n# func_to_host_file_result to ARG1).\nfunc_convert_file_check ()\n{\n  $debug_cmd\n\n  if test -z \"$2\" && test -n \"$1\"; then\n    func_error \"Could not determine host file name corresponding to\"\n    func_error \"  '$1'\"\n    func_error \"Continuing, but uninstalled executables may not work.\"\n    # Fallback:\n    func_to_host_file_result=$1\n  fi\n}\n# end func_convert_file_check\n\n\n# func_convert_path_check FROM_PATHSEP TO_PATHSEP FROM_PATH TO_PATH\n# Verify that FROM_PATH (a path in $build format) was converted to $host\n# format in TO_PATH. Otherwise, emit an error message, but continue, resetting\n# func_to_host_file_result to a simplistic fallback value (see below).\nfunc_convert_path_check ()\n{\n  $debug_cmd\n\n  if test -z \"$4\" && test -n \"$3\"; then\n    func_error \"Could not determine the host path corresponding to\"\n    func_error \"  '$3'\"\n    func_error \"Continuing, but uninstalled executables may not work.\"\n    # Fallback.  This is a deliberately simplistic \"conversion\" and\n    # should not be \"improved\".  See libtool.info.\n    if test \"x$1\" != \"x$2\"; then\n      lt_replace_pathsep_chars=\"s|$1|$2|g\"\n      func_to_host_path_result=`echo \"$3\" |\n        $SED -e \"$lt_replace_pathsep_chars\"`\n    else\n      func_to_host_path_result=$3\n    fi\n  fi\n}\n# end func_convert_path_check\n\n\n# func_convert_path_front_back_pathsep FRONTPAT BACKPAT REPL ORIG\n# Modifies func_to_host_path_result by prepending REPL if ORIG matches FRONTPAT\n# and appending REPL if ORIG matches BACKPAT.\nfunc_convert_path_front_back_pathsep ()\n{\n  $debug_cmd\n\n  case $4 in\n  $1 ) func_to_host_path_result=$3$func_to_host_path_result\n    ;;\n  esac\n  case $4 in\n  $2 ) func_append func_to_host_path_result \"$3\"\n    ;;\n  esac\n}\n# end func_convert_path_front_back_pathsep\n\n\n##################################################\n# $build to $host FILE NAME CONVERSION FUNCTIONS #\n##################################################\n# invoked via '$to_host_file_cmd ARG'\n#\n# In each case, ARG is the path to be converted from $build to $host format.\n# Result will be available in $func_to_host_file_result.\n\n\n# func_to_host_file ARG\n# Converts the file name ARG from $build format to $host format. Return result\n# in func_to_host_file_result.\nfunc_to_host_file ()\n{\n  $debug_cmd\n\n  $to_host_file_cmd \"$1\"\n}\n# end func_to_host_file\n\n\n# func_to_tool_file ARG LAZY\n# converts the file name ARG from $build format to toolchain format. Return\n# result in func_to_tool_file_result.  If the conversion in use is listed\n# in (the comma separated) LAZY, no conversion takes place.\nfunc_to_tool_file ()\n{\n  $debug_cmd\n\n  case ,$2, in\n    *,\"$to_tool_file_cmd\",*)\n      func_to_tool_file_result=$1\n      ;;\n    *)\n      $to_tool_file_cmd \"$1\"\n      func_to_tool_file_result=$func_to_host_file_result\n      ;;\n  esac\n}\n# end func_to_tool_file\n\n\n# func_convert_file_noop ARG\n# Copy ARG to func_to_host_file_result.\nfunc_convert_file_noop ()\n{\n  func_to_host_file_result=$1\n}\n# end func_convert_file_noop\n\n\n# func_convert_file_msys_to_w32 ARG\n# Convert file name ARG from (mingw) MSYS to (mingw) w32 format; automatic\n# conversion to w32 is not available inside the cwrapper.  Returns result in\n# func_to_host_file_result.\nfunc_convert_file_msys_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_file_result=$1\n  if test -n \"$1\"; then\n    func_convert_core_msys_to_w32 \"$1\"\n    func_to_host_file_result=$func_convert_core_msys_to_w32_result\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_msys_to_w32\n\n\n# func_convert_file_cygwin_to_w32 ARG\n# Convert file name ARG from Cygwin to w32 format.  Returns result in\n# func_to_host_file_result.\nfunc_convert_file_cygwin_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_file_result=$1\n  if test -n \"$1\"; then\n    # because $build is cygwin, we call \"the\" cygpath in $PATH; no need to use\n    # LT_CYGPATH in this case.\n    func_to_host_file_result=`cygpath -m \"$1\"`\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_cygwin_to_w32\n\n\n# func_convert_file_nix_to_w32 ARG\n# Convert file name ARG from *nix to w32 format.  Requires a wine environment\n# and a working winepath. Returns result in func_to_host_file_result.\nfunc_convert_file_nix_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_file_result=$1\n  if test -n \"$1\"; then\n    func_convert_core_file_wine_to_w32 \"$1\"\n    func_to_host_file_result=$func_convert_core_file_wine_to_w32_result\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_nix_to_w32\n\n\n# func_convert_file_msys_to_cygwin ARG\n# Convert file name ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.\n# Returns result in func_to_host_file_result.\nfunc_convert_file_msys_to_cygwin ()\n{\n  $debug_cmd\n\n  func_to_host_file_result=$1\n  if test -n \"$1\"; then\n    func_convert_core_msys_to_w32 \"$1\"\n    func_cygpath -u \"$func_convert_core_msys_to_w32_result\"\n    func_to_host_file_result=$func_cygpath_result\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_msys_to_cygwin\n\n\n# func_convert_file_nix_to_cygwin ARG\n# Convert file name ARG from *nix to Cygwin format.  Requires Cygwin installed\n# in a wine environment, working winepath, and LT_CYGPATH set.  Returns result\n# in func_to_host_file_result.\nfunc_convert_file_nix_to_cygwin ()\n{\n  $debug_cmd\n\n  func_to_host_file_result=$1\n  if test -n \"$1\"; then\n    # convert from *nix to w32, then use cygpath to convert from w32 to cygwin.\n    func_convert_core_file_wine_to_w32 \"$1\"\n    func_cygpath -u \"$func_convert_core_file_wine_to_w32_result\"\n    func_to_host_file_result=$func_cygpath_result\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_nix_to_cygwin\n\n\n#############################################\n# $build to $host PATH CONVERSION FUNCTIONS #\n#############################################\n# invoked via '$to_host_path_cmd ARG'\n#\n# In each case, ARG is the path to be converted from $build to $host format.\n# The result will be available in $func_to_host_path_result.\n#\n# Path separators are also converted from $build format to $host format.  If\n# ARG begins or ends with a path separator character, it is preserved (but\n# converted to $host format) on output.\n#\n# All path conversion functions are named using the following convention:\n#   file name conversion function    : func_convert_file_X_to_Y ()\n#   path conversion function         : func_convert_path_X_to_Y ()\n# where, for any given $build/$host combination the 'X_to_Y' value is the\n# same.  If conversion functions are added for new $build/$host combinations,\n# the two new functions must follow this pattern, or func_init_to_host_path_cmd\n# will break.\n\n\n# func_init_to_host_path_cmd\n# Ensures that function \"pointer\" variable $to_host_path_cmd is set to the\n# appropriate value, based on the value of $to_host_file_cmd.\nto_host_path_cmd=\nfunc_init_to_host_path_cmd ()\n{\n  $debug_cmd\n\n  if test -z \"$to_host_path_cmd\"; then\n    func_stripname 'func_convert_file_' '' \"$to_host_file_cmd\"\n    to_host_path_cmd=func_convert_path_$func_stripname_result\n  fi\n}\n\n\n# func_to_host_path ARG\n# Converts the path ARG from $build format to $host format. Return result\n# in func_to_host_path_result.\nfunc_to_host_path ()\n{\n  $debug_cmd\n\n  func_init_to_host_path_cmd\n  $to_host_path_cmd \"$1\"\n}\n# end func_to_host_path\n\n\n# func_convert_path_noop ARG\n# Copy ARG to func_to_host_path_result.\nfunc_convert_path_noop ()\n{\n  func_to_host_path_result=$1\n}\n# end func_convert_path_noop\n\n\n# func_convert_path_msys_to_w32 ARG\n# Convert path ARG from (mingw) MSYS to (mingw) w32 format; automatic\n# conversion to w32 is not available inside the cwrapper.  Returns result in\n# func_to_host_path_result.\nfunc_convert_path_msys_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_path_result=$1\n  if test -n \"$1\"; then\n    # Remove leading and trailing path separator characters from ARG.  MSYS\n    # behavior is inconsistent here; cygpath turns them into '.;' and ';.';\n    # and winepath ignores them completely.\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_msys_to_w32 \"$func_to_host_path_tmp1\"\n    func_to_host_path_result=$func_convert_core_msys_to_w32_result\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_msys_to_w32\n\n\n# func_convert_path_cygwin_to_w32 ARG\n# Convert path ARG from Cygwin to w32 format.  Returns result in\n# func_to_host_file_result.\nfunc_convert_path_cygwin_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_path_result=$1\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_to_host_path_result=`cygpath -m -p \"$func_to_host_path_tmp1\"`\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_cygwin_to_w32\n\n\n# func_convert_path_nix_to_w32 ARG\n# Convert path ARG from *nix to w32 format.  Requires a wine environment and\n# a working winepath.  Returns result in func_to_host_file_result.\nfunc_convert_path_nix_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_path_result=$1\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_path_wine_to_w32 \"$func_to_host_path_tmp1\"\n    func_to_host_path_result=$func_convert_core_path_wine_to_w32_result\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_nix_to_w32\n\n\n# func_convert_path_msys_to_cygwin ARG\n# Convert path ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.\n# Returns result in func_to_host_file_result.\nfunc_convert_path_msys_to_cygwin ()\n{\n  $debug_cmd\n\n  func_to_host_path_result=$1\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_msys_to_w32 \"$func_to_host_path_tmp1\"\n    func_cygpath -u -p \"$func_convert_core_msys_to_w32_result\"\n    func_to_host_path_result=$func_cygpath_result\n    func_convert_path_check : : \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" : \"$1\"\n  fi\n}\n# end func_convert_path_msys_to_cygwin\n\n\n# func_convert_path_nix_to_cygwin ARG\n# Convert path ARG from *nix to Cygwin format.  Requires Cygwin installed in a\n# a wine environment, working winepath, and LT_CYGPATH set.  Returns result in\n# func_to_host_file_result.\nfunc_convert_path_nix_to_cygwin ()\n{\n  $debug_cmd\n\n  func_to_host_path_result=$1\n  if test -n \"$1\"; then\n    # Remove leading and trailing path separator characters from\n    # ARG. msys behavior is inconsistent here, cygpath turns them\n    # into '.;' and ';.', and winepath ignores them completely.\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_path_wine_to_w32 \"$func_to_host_path_tmp1\"\n    func_cygpath -u -p \"$func_convert_core_path_wine_to_w32_result\"\n    func_to_host_path_result=$func_cygpath_result\n    func_convert_path_check : : \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" : \"$1\"\n  fi\n}\n# end func_convert_path_nix_to_cygwin\n\n\n# func_dll_def_p FILE\n# True iff FILE is a Windows DLL '.def' file.\n# Keep in sync with _LT_DLL_DEF_P in libtool.m4\nfunc_dll_def_p ()\n{\n  $debug_cmd\n\n  func_dll_def_p_tmp=`$SED -n \\\n    -e 's/^[\t ]*//' \\\n    -e '/^\\(;.*\\)*$/d' \\\n    -e 's/^\\(EXPORTS\\|LIBRARY\\)\\([\t ].*\\)*$/DEF/p' \\\n    -e q \\\n    \"$1\"`\n  test DEF = \"$func_dll_def_p_tmp\"\n}\n\n\n# func_mode_compile arg...\nfunc_mode_compile ()\n{\n    $debug_cmd\n\n    # Get the compilation command and the source file.\n    base_compile=\n    srcfile=$nonopt  #  always keep a non-empty value in \"srcfile\"\n    suppress_opt=yes\n    suppress_output=\n    arg_mode=normal\n    libobj=\n    later=\n    pie_flag=\n\n    for arg\n    do\n      case $arg_mode in\n      arg  )\n\t# do not \"continue\".  Instead, add this to base_compile\n\tlastarg=$arg\n\targ_mode=normal\n\t;;\n\n      target )\n\tlibobj=$arg\n\targ_mode=normal\n\tcontinue\n\t;;\n\n      normal )\n\t# Accept any command-line options.\n\tcase $arg in\n\t-o)\n\t  test -n \"$libobj\" && \\\n\t    func_fatal_error \"you cannot specify '-o' more than once\"\n\t  arg_mode=target\n\t  continue\n\t  ;;\n\n\t-pie | -fpie | -fPIE)\n          func_append pie_flag \" $arg\"\n\t  continue\n\t  ;;\n\n\t-shared | -static | -prefer-pic | -prefer-non-pic)\n\t  func_append later \" $arg\"\n\t  continue\n\t  ;;\n\n\t-no-suppress)\n\t  suppress_opt=no\n\t  continue\n\t  ;;\n\n\t-Xcompiler)\n\t  arg_mode=arg  #  the next one goes into the \"base_compile\" arg list\n\t  continue      #  The current \"srcfile\" will either be retained or\n\t  ;;            #  replaced later.  I would guess that would be a bug.\n\n\t-Wc,*)\n\t  func_stripname '-Wc,' '' \"$arg\"\n\t  args=$func_stripname_result\n\t  lastarg=\n\t  save_ifs=$IFS; IFS=,\n\t  for arg in $args; do\n\t    IFS=$save_ifs\n\t    func_append_quoted lastarg \"$arg\"\n\t  done\n\t  IFS=$save_ifs\n\t  func_stripname ' ' '' \"$lastarg\"\n\t  lastarg=$func_stripname_result\n\n\t  # Add the arguments to base_compile.\n\t  func_append base_compile \" $lastarg\"\n\t  continue\n\t  ;;\n\n\t*)\n\t  # Accept the current argument as the source file.\n\t  # The previous \"srcfile\" becomes the current argument.\n\t  #\n\t  lastarg=$srcfile\n\t  srcfile=$arg\n\t  ;;\n\tesac  #  case $arg\n\t;;\n      esac    #  case $arg_mode\n\n      # Aesthetically quote the previous argument.\n      func_append_quoted base_compile \"$lastarg\"\n    done # for arg\n\n    case $arg_mode in\n    arg)\n      func_fatal_error \"you must specify an argument for -Xcompile\"\n      ;;\n    target)\n      func_fatal_error \"you must specify a target with '-o'\"\n      ;;\n    *)\n      # Get the name of the library object.\n      test -z \"$libobj\" && {\n\tfunc_basename \"$srcfile\"\n\tlibobj=$func_basename_result\n      }\n      ;;\n    esac\n\n    # Recognize several different file suffixes.\n    # If the user specifies -o file.o, it is replaced with file.lo\n    case $libobj in\n    *.[cCFSifmso] | \\\n    *.ada | *.adb | *.ads | *.asm | \\\n    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \\\n    *.[fF][09]? | *.for | *.java | *.go | *.obj | *.sx | *.cu | *.cup)\n      func_xform \"$libobj\"\n      libobj=$func_xform_result\n      ;;\n    esac\n\n    case $libobj in\n    *.lo) func_lo2o \"$libobj\"; obj=$func_lo2o_result ;;\n    *)\n      func_fatal_error \"cannot determine name of library object from '$libobj'\"\n      ;;\n    esac\n\n    func_infer_tag $base_compile\n\n    for arg in $later; do\n      case $arg in\n      -shared)\n\ttest yes = \"$build_libtool_libs\" \\\n\t  || func_fatal_configuration \"cannot build a shared library\"\n\tbuild_old_libs=no\n\tcontinue\n\t;;\n\n      -static)\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tcontinue\n\t;;\n\n      -prefer-pic)\n\tpic_mode=yes\n\tcontinue\n\t;;\n\n      -prefer-non-pic)\n\tpic_mode=no\n\tcontinue\n\t;;\n      esac\n    done\n\n    func_quote_for_eval \"$libobj\"\n    test \"X$libobj\" != \"X$func_quote_for_eval_result\" \\\n      && $ECHO \"X$libobj\" | $GREP '[]~#^*{};<>?\"'\"'\"'\t &()|`$[]' \\\n      && func_warning \"libobj name '$libobj' may not contain shell special characters.\"\n    func_dirname_and_basename \"$obj\" \"/\" \"\"\n    objname=$func_basename_result\n    xdir=$func_dirname_result\n    lobj=$xdir$objdir/$objname\n\n    test -z \"$base_compile\" && \\\n      func_fatal_help \"you must specify a compilation command\"\n\n    # Delete any leftover library objects.\n    if test yes = \"$build_old_libs\"; then\n      removelist=\"$obj $lobj $libobj ${libobj}T\"\n    else\n      removelist=\"$lobj $libobj ${libobj}T\"\n    fi\n\n    # On Cygwin there's no \"real\" PIC flag so we must build both object types\n    case $host_os in\n    cygwin* | mingw* | pw32* | os2* | cegcc*)\n      pic_mode=default\n      ;;\n    esac\n    if test no = \"$pic_mode\" && test pass_all != \"$deplibs_check_method\"; then\n      # non-PIC code in shared libraries is not supported\n      pic_mode=default\n    fi\n\n    # Calculate the filename of the output object if compiler does\n    # not support -o with -c\n    if test no = \"$compiler_c_o\"; then\n      output_obj=`$ECHO \"$srcfile\" | $SED 's%^.*/%%; s%\\.[^.]*$%%'`.$objext\n      lockfile=$output_obj.lock\n    else\n      output_obj=\n      need_locks=no\n      lockfile=\n    fi\n\n    # Lock this critical section if it is needed\n    # We use this script file to make the link, it avoids creating a new file\n    if test yes = \"$need_locks\"; then\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    elif test warn = \"$need_locks\"; then\n      if test -f \"$lockfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile exists and contains:\n`cat $lockfile 2>/dev/null`\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support '-c' and '-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n      func_append removelist \" $output_obj\"\n      $ECHO \"$srcfile\" > \"$lockfile\"\n    fi\n\n    $opt_dry_run || $RM $removelist\n    func_append removelist \" $lockfile\"\n    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15\n\n    func_to_tool_file \"$srcfile\" func_convert_file_msys_to_w32\n    srcfile=$func_to_tool_file_result\n    func_quote_for_eval \"$srcfile\"\n    qsrcfile=$func_quote_for_eval_result\n\n    # Only build a PIC object if we are building libtool libraries.\n    if test yes = \"$build_libtool_libs\"; then\n      # Without this assignment, base_compile gets emptied.\n      fbsd_hideous_sh_bug=$base_compile\n\n      if test no != \"$pic_mode\"; then\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      else\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile\"\n      fi\n\n      func_mkdir_p \"$xdir$objdir\"\n\n      if test -z \"$output_obj\"; then\n\t# Place PIC objects in $objdir\n\tfunc_append command \" -o $lobj\"\n      fi\n\n      func_show_eval_locale \"$command\"\t\\\n          'test -n \"$output_obj\" && $RM $removelist; exit $EXIT_FAILURE'\n\n      if test warn = \"$need_locks\" &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support '-c' and '-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed, then go on to compile the next one\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$lobj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$lobj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n\n      # Allow error messages only from the first compilation.\n      if test yes = \"$suppress_opt\"; then\n\tsuppress_output=' >/dev/null 2>&1'\n      fi\n    fi\n\n    # Only build a position-dependent object if we build old libraries.\n    if test yes = \"$build_old_libs\"; then\n      if test yes != \"$pic_mode\"; then\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile$pie_flag\"\n      else\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      fi\n      if test yes = \"$compiler_c_o\"; then\n\tfunc_append command \" -o $obj\"\n      fi\n\n      # Suppress compiler output if we already did a PIC compilation.\n      func_append command \"$suppress_output\"\n      func_show_eval_locale \"$command\" \\\n        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'\n\n      if test warn = \"$need_locks\" &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support '-c' and '-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$obj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$obj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n    fi\n\n    $opt_dry_run || {\n      func_write_libtool_object \"$libobj\" \"$objdir/$objname\" \"$objname\"\n\n      # Unlock the critical section if it was locked\n      if test no != \"$need_locks\"; then\n\tremovelist=$lockfile\n        $RM \"$lockfile\"\n      fi\n    }\n\n    exit $EXIT_SUCCESS\n}\n\n$opt_help || {\n  test compile = \"$opt_mode\" && func_mode_compile ${1+\"$@\"}\n}\n\nfunc_mode_help ()\n{\n    # We need to display help for each of the modes.\n    case $opt_mode in\n      \"\")\n        # Generic help is extracted from the usage comments\n        # at the start of this file.\n        func_help\n        ;;\n\n      clean)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...\n\nRemove files from the build directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically '/bin/rm').  RM-OPTIONS are options (such as '-f') to be passed\nto RM.\n\nIf FILE is a libtool library, object or program, all the files associated\nwith it are deleted. Otherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      compile)\n      $ECHO \\\n\"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE\n\nCompile a source file into a libtool library object.\n\nThis mode accepts the following additional options:\n\n  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE\n  -no-suppress      do not suppress compiler output for multiple passes\n  -prefer-pic       try to build PIC objects only\n  -prefer-non-pic   try to build non-PIC objects only\n  -shared           do not build a '.o' file suitable for static linking\n  -static           only build a '.o' file suitable for static linking\n  -Wc,FLAG          pass FLAG directly to the compiler\n\nCOMPILE-COMMAND is a command to be used in creating a 'standard' object file\nfrom the given SOURCEFILE.\n\nThe output file name is determined by removing the directory component from\nSOURCEFILE, then substituting the C source code suffix '.c' with the\nlibrary object suffix, '.lo'.\"\n        ;;\n\n      execute)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...\n\nAutomatically set library path, then run a program.\n\nThis mode accepts the following additional options:\n\n  -dlopen FILE      add the directory containing FILE to the library path\n\nThis mode sets the library path environment variable according to '-dlopen'\nflags.\n\nIf any of the ARGS are libtool executable wrappers, then they are translated\ninto their corresponding uninstalled binary, and any of their required library\ndirectories are added to the library path.\n\nThen, COMMAND is executed, with ARGS as arguments.\"\n        ;;\n\n      finish)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...\n\nComplete the installation of libtool libraries.\n\nEach LIBDIR is a directory that contains libtool libraries.\n\nThe commands that this mode executes may require superuser privileges.  Use\nthe '--dry-run' option if you just want to see what would be executed.\"\n        ;;\n\n      install)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...\n\nInstall executables or libraries.\n\nINSTALL-COMMAND is the installation command.  The first component should be\neither the 'install' or 'cp' program.\n\nThe following components of INSTALL-COMMAND are treated specially:\n\n  -inst-prefix-dir PREFIX-DIR  Use PREFIX-DIR as a staging area for installation\n\nThe rest of the components are interpreted as arguments to that command (only\nBSD-compatible install options are recognized).\"\n        ;;\n\n      link)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...\n\nLink object files or libraries together to form another library, or to\ncreate an executable program.\n\nLINK-COMMAND is a command using the C compiler that you would use to create\na program from several object files.\n\nThe following components of LINK-COMMAND are treated specially:\n\n  -all-static       do not do any dynamic linking at all\n  -avoid-version    do not add a version suffix if possible\n  -bindir BINDIR    specify path to binaries directory (for systems where\n                    libraries must be found in the PATH setting at runtime)\n  -dlopen FILE      '-dlpreopen' FILE if it cannot be dlopened at runtime\n  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols\n  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)\n  -export-symbols SYMFILE\n                    try to export only the symbols listed in SYMFILE\n  -export-symbols-regex REGEX\n                    try to export only the symbols matching REGEX\n  -LLIBDIR          search LIBDIR for required installed libraries\n  -lNAME            OUTPUT-FILE requires the installed library libNAME\n  -module           build a library that can dlopened\n  -no-fast-install  disable the fast-install mode\n  -no-install       link a not-installable executable\n  -no-undefined     declare that a library does not refer to external symbols\n  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects\n  -objectlist FILE  use a list of object files found in FILE to specify objects\n  -os2dllname NAME  force a short DLL name on OS/2 (no effect on other OSes)\n  -precious-files-regex REGEX\n                    don't remove output files matching REGEX\n  -release RELEASE  specify package release information\n  -rpath LIBDIR     the created library will eventually be installed in LIBDIR\n  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries\n  -shared           only do dynamic linking of libtool libraries\n  -shrext SUFFIX    override the standard shared library file extension\n  -static           do not do any dynamic linking of uninstalled libtool libraries\n  -static-libtool-libs\n                    do not do any dynamic linking of libtool libraries\n  -version-info CURRENT[:REVISION[:AGE]]\n                    specify library version info [each variable defaults to 0]\n  -weak LIBNAME     declare that the target provides the LIBNAME interface\n  -Wc,FLAG\n  -Xcompiler FLAG   pass linker-specific FLAG directly to the compiler\n  -Wl,FLAG\n  -Xlinker FLAG     pass linker-specific FLAG directly to the linker\n  -XCClinker FLAG   pass link-specific FLAG to the compiler driver (CC)\n\nAll other options (arguments beginning with '-') are ignored.\n\nEvery other argument is treated as a filename.  Files ending in '.la' are\ntreated as uninstalled libtool libraries, other files are standard or library\nobject files.\n\nIf the OUTPUT-FILE ends in '.la', then a libtool library is created,\nonly library objects ('.lo' files) may be specified, and '-rpath' is\nrequired, except when creating a convenience library.\n\nIf OUTPUT-FILE ends in '.a' or '.lib', then a standard library is created\nusing 'ar' and 'ranlib', or on Windows using 'lib'.\n\nIf OUTPUT-FILE ends in '.lo' or '.$objext', then a reloadable object file\nis created, otherwise an executable program is created.\"\n        ;;\n\n      uninstall)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...\n\nRemove libraries from an installation directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically '/bin/rm').  RM-OPTIONS are options (such as '-f') to be passed\nto RM.\n\nIf FILE is a libtool library, all the files associated with it are deleted.\nOtherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      *)\n        func_fatal_help \"invalid operation mode '$opt_mode'\"\n        ;;\n    esac\n\n    echo\n    $ECHO \"Try '$progname --help' for more information about other modes.\"\n}\n\n# Now that we've collected a possible --mode arg, show help if necessary\nif $opt_help; then\n  if test : = \"$opt_help\"; then\n    func_mode_help\n  else\n    {\n      func_help noexit\n      for opt_mode in compile link execute install finish uninstall clean; do\n\tfunc_mode_help\n      done\n    } | $SED -n '1p; 2,$s/^Usage:/  or: /p'\n    {\n      func_help noexit\n      for opt_mode in compile link execute install finish uninstall clean; do\n\techo\n\tfunc_mode_help\n      done\n    } |\n    $SED '1d\n      /^When reporting/,/^Report/{\n\tH\n\td\n      }\n      $x\n      /information about other modes/d\n      /more detailed .*MODE/d\n      s/^Usage:.*--mode=\\([^ ]*\\) .*/Description of \\1 mode:/'\n  fi\n  exit $?\nfi\n\n\n# func_mode_execute arg...\nfunc_mode_execute ()\n{\n    $debug_cmd\n\n    # The first argument is the command name.\n    cmd=$nonopt\n    test -z \"$cmd\" && \\\n      func_fatal_help \"you must specify a COMMAND\"\n\n    # Handle -dlopen flags immediately.\n    for file in $opt_dlopen; do\n      test -f \"$file\" \\\n\t|| func_fatal_help \"'$file' is not a file\"\n\n      dir=\n      case $file in\n      *.la)\n\tfunc_resolve_sysroot \"$file\"\n\tfile=$func_resolve_sysroot_result\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"'$lib' is not a valid libtool archive\"\n\n\t# Read the libtool library.\n\tdlname=\n\tlibrary_names=\n\tfunc_source \"$file\"\n\n\t# Skip this library if it cannot be dlopened.\n\tif test -z \"$dlname\"; then\n\t  # Warn if it was a shared library.\n\t  test -n \"$library_names\" && \\\n\t    func_warning \"'$file' was not linked with '-export-dynamic'\"\n\t  continue\n\tfi\n\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=$func_dirname_result\n\n\tif test -f \"$dir/$objdir/$dlname\"; then\n\t  func_append dir \"/$objdir\"\n\telse\n\t  if test ! -f \"$dir/$dlname\"; then\n\t    func_fatal_error \"cannot find '$dlname' in '$dir' or '$dir/$objdir'\"\n\t  fi\n\tfi\n\t;;\n\n      *.lo)\n\t# Just add the directory containing the .lo file.\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=$func_dirname_result\n\t;;\n\n      *)\n\tfunc_warning \"'-dlopen' is ignored for non-libtool libraries and objects\"\n\tcontinue\n\t;;\n      esac\n\n      # Get the absolute pathname.\n      absdir=`cd \"$dir\" && pwd`\n      test -n \"$absdir\" && dir=$absdir\n\n      # Now add the directory to shlibpath_var.\n      if eval \"test -z \\\"\\$$shlibpath_var\\\"\"; then\n\teval \"$shlibpath_var=\\\"\\$dir\\\"\"\n      else\n\teval \"$shlibpath_var=\\\"\\$dir:\\$$shlibpath_var\\\"\"\n      fi\n    done\n\n    # This variable tells wrapper scripts just to set shlibpath_var\n    # rather than running their programs.\n    libtool_execute_magic=$magic\n\n    # Check if any of the arguments is a wrapper script.\n    args=\n    for file\n    do\n      case $file in\n      -* | *.la | *.lo ) ;;\n      *)\n\t# Do a test to see if this is really a libtool program.\n\tif func_ltwrapper_script_p \"$file\"; then\n\t  func_source \"$file\"\n\t  # Transform arg to wrapped name.\n\t  file=$progdir/$program\n\telif func_ltwrapper_executable_p \"$file\"; then\n\t  func_ltwrapper_scriptname \"$file\"\n\t  func_source \"$func_ltwrapper_scriptname_result\"\n\t  # Transform arg to wrapped name.\n\t  file=$progdir/$program\n\tfi\n\t;;\n      esac\n      # Quote arguments (to preserve shell metacharacters).\n      func_append_quoted args \"$file\"\n    done\n\n    if $opt_dry_run; then\n      # Display what would be done.\n      if test -n \"$shlibpath_var\"; then\n\teval \"\\$ECHO \\\"\\$shlibpath_var=\\$$shlibpath_var\\\"\"\n\techo \"export $shlibpath_var\"\n      fi\n      $ECHO \"$cmd$args\"\n      exit $EXIT_SUCCESS\n    else\n      if test -n \"$shlibpath_var\"; then\n\t# Export the shlibpath_var.\n\teval \"export $shlibpath_var\"\n      fi\n\n      # Restore saved environment variables\n      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\n      do\n\teval \"if test \\\"\\${save_$lt_var+set}\\\" = set; then\n                $lt_var=\\$save_$lt_var; export $lt_var\n\t      else\n\t\t$lt_unset $lt_var\n\t      fi\"\n      done\n\n      # Now prepare to actually exec the command.\n      exec_cmd=\\$cmd$args\n    fi\n}\n\ntest execute = \"$opt_mode\" && func_mode_execute ${1+\"$@\"}\n\n\n# func_mode_finish arg...\nfunc_mode_finish ()\n{\n    $debug_cmd\n\n    libs=\n    libdirs=\n    admincmds=\n\n    for opt in \"$nonopt\" ${1+\"$@\"}\n    do\n      if test -d \"$opt\"; then\n\tfunc_append libdirs \" $opt\"\n\n      elif test -f \"$opt\"; then\n\tif func_lalib_unsafe_p \"$opt\"; then\n\t  func_append libs \" $opt\"\n\telse\n\t  func_warning \"'$opt' is not a valid libtool archive\"\n\tfi\n\n      else\n\tfunc_fatal_error \"invalid argument '$opt'\"\n      fi\n    done\n\n    if test -n \"$libs\"; then\n      if test -n \"$lt_sysroot\"; then\n        sysroot_regex=`$ECHO \"$lt_sysroot\" | $SED \"$sed_make_literal_regex\"`\n        sysroot_cmd=\"s/\\([ ']\\)$sysroot_regex/\\1/g;\"\n      else\n        sysroot_cmd=\n      fi\n\n      # Remove sysroot references\n      if $opt_dry_run; then\n        for lib in $libs; do\n          echo \"removing references to $lt_sysroot and '=' prefixes from $lib\"\n        done\n      else\n        tmpdir=`func_mktempdir`\n        for lib in $libs; do\n\t  $SED -e \"$sysroot_cmd s/\\([ ']-[LR]\\)=/\\1/g; s/\\([ ']\\)=/\\1/g\" $lib \\\n\t    > $tmpdir/tmp-la\n\t  mv -f $tmpdir/tmp-la $lib\n\tdone\n        ${RM}r \"$tmpdir\"\n      fi\n    fi\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      for libdir in $libdirs; do\n\tif test -n \"$finish_cmds\"; then\n\t  # Do each command in the finish commands.\n\t  func_execute_cmds \"$finish_cmds\" 'admincmds=\"$admincmds\n'\"$cmd\"'\"'\n\tfi\n\tif test -n \"$finish_eval\"; then\n\t  # Do the single finish_eval.\n\t  eval cmds=\\\"$finish_eval\\\"\n\t  $opt_dry_run || eval \"$cmds\" || func_append admincmds \"\n       $cmds\"\n\tfi\n      done\n    fi\n\n    # Exit here if they wanted silent mode.\n    $opt_quiet && exit $EXIT_SUCCESS\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      echo \"----------------------------------------------------------------------\"\n      echo \"Libraries have been installed in:\"\n      for libdir in $libdirs; do\n\t$ECHO \"   $libdir\"\n      done\n      echo\n      echo \"If you ever happen to want to link against installed libraries\"\n      echo \"in a given directory, LIBDIR, you must either use libtool, and\"\n      echo \"specify the full pathname of the library, or use the '-LLIBDIR'\"\n      echo \"flag during linking and do at least one of the following:\"\n      if test -n \"$shlibpath_var\"; then\n\techo \"   - add LIBDIR to the '$shlibpath_var' environment variable\"\n\techo \"     during execution\"\n      fi\n      if test -n \"$runpath_var\"; then\n\techo \"   - add LIBDIR to the '$runpath_var' environment variable\"\n\techo \"     during linking\"\n      fi\n      if test -n \"$hardcode_libdir_flag_spec\"; then\n\tlibdir=LIBDIR\n\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\n\t$ECHO \"   - use the '$flag' linker flag\"\n      fi\n      if test -n \"$admincmds\"; then\n\t$ECHO \"   - have your system administrator run these commands:$admincmds\"\n      fi\n      if test -f /etc/ld.so.conf; then\n\techo \"   - have your system administrator add LIBDIR to '/etc/ld.so.conf'\"\n      fi\n      echo\n\n      echo \"See any operating system documentation about shared libraries for\"\n      case $host in\n\tsolaris2.[6789]|solaris2.1[0-9])\n\t  echo \"more information, such as the ld(1), crle(1) and ld.so(8) manual\"\n\t  echo \"pages.\"\n\t  ;;\n\t*)\n\t  echo \"more information, such as the ld(1) and ld.so(8) manual pages.\"\n\t  ;;\n      esac\n      echo \"----------------------------------------------------------------------\"\n    fi\n    exit $EXIT_SUCCESS\n}\n\ntest finish = \"$opt_mode\" && func_mode_finish ${1+\"$@\"}\n\n\n# func_mode_install arg...\nfunc_mode_install ()\n{\n    $debug_cmd\n\n    # There may be an optional sh(1) argument at the beginning of\n    # install_prog (especially on Windows NT).\n    if test \"$SHELL\" = \"$nonopt\" || test /bin/sh = \"$nonopt\" ||\n       # Allow the use of GNU shtool's install command.\n       case $nonopt in *shtool*) :;; *) false;; esac\n    then\n      # Aesthetically quote it.\n      func_quote_for_eval \"$nonopt\"\n      install_prog=\"$func_quote_for_eval_result \"\n      arg=$1\n      shift\n    else\n      install_prog=\n      arg=$nonopt\n    fi\n\n    # The real first argument should be the name of the installation program.\n    # Aesthetically quote it.\n    func_quote_for_eval \"$arg\"\n    func_append install_prog \"$func_quote_for_eval_result\"\n    install_shared_prog=$install_prog\n    case \" $install_prog \" in\n      *[\\\\\\ /]cp\\ *) install_cp=: ;;\n      *) install_cp=false ;;\n    esac\n\n    # We need to accept at least all the BSD install flags.\n    dest=\n    files=\n    opts=\n    prev=\n    install_type=\n    isdir=false\n    stripme=\n    no_mode=:\n    for arg\n    do\n      arg2=\n      if test -n \"$dest\"; then\n\tfunc_append files \" $dest\"\n\tdest=$arg\n\tcontinue\n      fi\n\n      case $arg in\n      -d) isdir=: ;;\n      -f)\n\tif $install_cp; then :; else\n\t  prev=$arg\n\tfi\n\t;;\n      -g | -m | -o)\n\tprev=$arg\n\t;;\n      -s)\n\tstripme=\" -s\"\n\tcontinue\n\t;;\n      -*)\n\t;;\n      *)\n\t# If the previous option needed an argument, then skip it.\n\tif test -n \"$prev\"; then\n\t  if test X-m = \"X$prev\" && test -n \"$install_override_mode\"; then\n\t    arg2=$install_override_mode\n\t    no_mode=false\n\t  fi\n\t  prev=\n\telse\n\t  dest=$arg\n\t  continue\n\tfi\n\t;;\n      esac\n\n      # Aesthetically quote the argument.\n      func_quote_for_eval \"$arg\"\n      func_append install_prog \" $func_quote_for_eval_result\"\n      if test -n \"$arg2\"; then\n\tfunc_quote_for_eval \"$arg2\"\n      fi\n      func_append install_shared_prog \" $func_quote_for_eval_result\"\n    done\n\n    test -z \"$install_prog\" && \\\n      func_fatal_help \"you must specify an install program\"\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the '$prev' option requires an argument\"\n\n    if test -n \"$install_override_mode\" && $no_mode; then\n      if $install_cp; then :; else\n\tfunc_quote_for_eval \"$install_override_mode\"\n\tfunc_append install_shared_prog \" -m $func_quote_for_eval_result\"\n      fi\n    fi\n\n    if test -z \"$files\"; then\n      if test -z \"$dest\"; then\n\tfunc_fatal_help \"no file or destination specified\"\n      else\n\tfunc_fatal_help \"you must specify a destination\"\n      fi\n    fi\n\n    # Strip any trailing slash from the destination.\n    func_stripname '' '/' \"$dest\"\n    dest=$func_stripname_result\n\n    # Check to see that the destination is a directory.\n    test -d \"$dest\" && isdir=:\n    if $isdir; then\n      destdir=$dest\n      destname=\n    else\n      func_dirname_and_basename \"$dest\" \"\" \".\"\n      destdir=$func_dirname_result\n      destname=$func_basename_result\n\n      # Not a directory, so check to see that there is only one file specified.\n      set dummy $files; shift\n      test \"$#\" -gt 1 && \\\n\tfunc_fatal_help \"'$dest' is not a directory\"\n    fi\n    case $destdir in\n    [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n    *)\n      for file in $files; do\n\tcase $file in\n\t*.lo) ;;\n\t*)\n\t  func_fatal_help \"'$destdir' must be an absolute directory name\"\n\t  ;;\n\tesac\n      done\n      ;;\n    esac\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=$magic\n\n    staticlibs=\n    future_libdirs=\n    current_libdirs=\n    for file in $files; do\n\n      # Do each installation.\n      case $file in\n      *.$libext)\n\t# Do the static libraries later.\n\tfunc_append staticlibs \" $file\"\n\t;;\n\n      *.la)\n\tfunc_resolve_sysroot \"$file\"\n\tfile=$func_resolve_sysroot_result\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"'$file' is not a valid libtool archive\"\n\n\tlibrary_names=\n\told_library=\n\trelink_command=\n\tfunc_source \"$file\"\n\n\t# Add the libdir to current_libdirs if it is the destination.\n\tif test \"X$destdir\" = \"X$libdir\"; then\n\t  case \"$current_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append current_libdirs \" $libdir\" ;;\n\t  esac\n\telse\n\t  # Note the libdir as a future libdir.\n\t  case \"$future_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append future_libdirs \" $libdir\" ;;\n\t  esac\n\tfi\n\n\tfunc_dirname \"$file\" \"/\" \"\"\n\tdir=$func_dirname_result\n\tfunc_append dir \"$objdir\"\n\n\tif test -n \"$relink_command\"; then\n\t  # Determine the prefix the user has applied to our future dir.\n\t  inst_prefix_dir=`$ECHO \"$destdir\" | $SED -e \"s%$libdir\\$%%\"`\n\n\t  # Don't allow the user to place us outside of our expected\n\t  # location b/c this prevents finding dependent libraries that\n\t  # are installed to the same prefix.\n\t  # At present, this check doesn't affect windows .dll's that\n\t  # are installed into $libdir/../bin (currently, that works fine)\n\t  # but it's something to keep an eye on.\n\t  test \"$inst_prefix_dir\" = \"$destdir\" && \\\n\t    func_fatal_error \"error: cannot install '$file' to a directory not ending in $libdir\"\n\n\t  if test -n \"$inst_prefix_dir\"; then\n\t    # Stick the inst_prefix_dir data into the link command.\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%\"`\n\t  else\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%%\"`\n\t  fi\n\n\t  func_warning \"relinking '$file'\"\n\t  func_show_eval \"$relink_command\" \\\n\t    'func_fatal_error \"error: relink '\\''$file'\\'' with the above command before installing it\"'\n\tfi\n\n\t# See the names of the shared library.\n\tset dummy $library_names; shift\n\tif test -n \"$1\"; then\n\t  realname=$1\n\t  shift\n\n\t  srcname=$realname\n\t  test -n \"$relink_command\" && srcname=${realname}T\n\n\t  # Install the shared library and build the symlinks.\n\t  func_show_eval \"$install_shared_prog $dir/$srcname $destdir/$realname\" \\\n\t      'exit $?'\n\t  tstripme=$stripme\n\t  case $host_os in\n\t  cygwin* | mingw* | pw32* | cegcc*)\n\t    case $realname in\n\t    *.dll.a)\n\t      tstripme=\n\t      ;;\n\t    esac\n\t    ;;\n\t  os2*)\n\t    case $realname in\n\t    *_dll.a)\n\t      tstripme=\n\t      ;;\n\t    esac\n\t    ;;\n\t  esac\n\t  if test -n \"$tstripme\" && test -n \"$striplib\"; then\n\t    func_show_eval \"$striplib $destdir/$realname\" 'exit $?'\n\t  fi\n\n\t  if test \"$#\" -gt 0; then\n\t    # Delete the old symlinks, and create new ones.\n\t    # Try 'ln -sf' first, because the 'ln' binary might depend on\n\t    # the symlink we replace!  Solaris /bin/ln does not understand -f,\n\t    # so we also need to try rm && ln -s.\n\t    for linkname\n\t    do\n\t      test \"$linkname\" != \"$realname\" \\\n\t\t&& func_show_eval \"(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })\"\n\t    done\n\t  fi\n\n\t  # Do each command in the postinstall commands.\n\t  lib=$destdir/$realname\n\t  func_execute_cmds \"$postinstall_cmds\" 'exit $?'\n\tfi\n\n\t# Install the pseudo-library for information purposes.\n\tfunc_basename \"$file\"\n\tname=$func_basename_result\n\tinstname=$dir/${name}i\n\tfunc_show_eval \"$install_prog $instname $destdir/$name\" 'exit $?'\n\n\t# Maybe install the static library, too.\n\ttest -n \"$old_library\" && func_append staticlibs \" $dir/$old_library\"\n\t;;\n\n      *.lo)\n\t# Install (i.e. copy) a libtool object.\n\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=$destdir/$destname\n\telse\n\t  func_basename \"$file\"\n\t  destfile=$func_basename_result\n\t  destfile=$destdir/$destfile\n\tfi\n\n\t# Deduce the name of the destination old-style object file.\n\tcase $destfile in\n\t*.lo)\n\t  func_lo2o \"$destfile\"\n\t  staticdest=$func_lo2o_result\n\t  ;;\n\t*.$objext)\n\t  staticdest=$destfile\n\t  destfile=\n\t  ;;\n\t*)\n\t  func_fatal_help \"cannot copy a libtool object to '$destfile'\"\n\t  ;;\n\tesac\n\n\t# Install the libtool object if requested.\n\ttest -n \"$destfile\" && \\\n\t  func_show_eval \"$install_prog $file $destfile\" 'exit $?'\n\n\t# Install the old object if enabled.\n\tif test yes = \"$build_old_libs\"; then\n\t  # Deduce the name of the old-style object file.\n\t  func_lo2o \"$file\"\n\t  staticobj=$func_lo2o_result\n\t  func_show_eval \"$install_prog \\$staticobj \\$staticdest\" 'exit $?'\n\tfi\n\texit $EXIT_SUCCESS\n\t;;\n\n      *)\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=$destdir/$destname\n\telse\n\t  func_basename \"$file\"\n\t  destfile=$func_basename_result\n\t  destfile=$destdir/$destfile\n\tfi\n\n\t# If the file is missing, and there is a .exe on the end, strip it\n\t# because it is most likely a libtool script we actually want to\n\t# install\n\tstripped_ext=\n\tcase $file in\n\t  *.exe)\n\t    if test ! -f \"$file\"; then\n\t      func_stripname '' '.exe' \"$file\"\n\t      file=$func_stripname_result\n\t      stripped_ext=.exe\n\t    fi\n\t    ;;\n\tesac\n\n\t# Do a test to see if this is really a libtool program.\n\tcase $host in\n\t*cygwin* | *mingw*)\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      wrapper=$func_ltwrapper_scriptname_result\n\t    else\n\t      func_stripname '' '.exe' \"$file\"\n\t      wrapper=$func_stripname_result\n\t    fi\n\t    ;;\n\t*)\n\t    wrapper=$file\n\t    ;;\n\tesac\n\tif func_ltwrapper_script_p \"$wrapper\"; then\n\t  notinst_deplibs=\n\t  relink_command=\n\n\t  func_source \"$wrapper\"\n\n\t  # Check the variables that should have been set.\n\t  test -z \"$generated_by_libtool_version\" && \\\n\t    func_fatal_error \"invalid libtool wrapper script '$wrapper'\"\n\n\t  finalize=:\n\t  for lib in $notinst_deplibs; do\n\t    # Check to see that each library is installed.\n\t    libdir=\n\t    if test -f \"$lib\"; then\n\t      func_source \"$lib\"\n\t    fi\n\t    libfile=$libdir/`$ECHO \"$lib\" | $SED 's%^.*/%%g'`\n\t    if test -n \"$libdir\" && test ! -f \"$libfile\"; then\n\t      func_warning \"'$lib' has not been installed in '$libdir'\"\n\t      finalize=false\n\t    fi\n\t  done\n\n\t  relink_command=\n\t  func_source \"$wrapper\"\n\n\t  outputname=\n\t  if test no = \"$fast_install\" && test -n \"$relink_command\"; then\n\t    $opt_dry_run || {\n\t      if $finalize; then\n\t        tmpdir=`func_mktempdir`\n\t\tfunc_basename \"$file$stripped_ext\"\n\t\tfile=$func_basename_result\n\t        outputname=$tmpdir/$file\n\t        # Replace the output file specification.\n\t        relink_command=`$ECHO \"$relink_command\" | $SED 's%@OUTPUT@%'\"$outputname\"'%g'`\n\n\t        $opt_quiet || {\n\t          func_quote_for_expand \"$relink_command\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t        }\n\t        if eval \"$relink_command\"; then :\n\t          else\n\t\t  func_error \"error: relink '$file' with the above command before installing it\"\n\t\t  $opt_dry_run || ${RM}r \"$tmpdir\"\n\t\t  continue\n\t        fi\n\t        file=$outputname\n\t      else\n\t        func_warning \"cannot relink '$file'\"\n\t      fi\n\t    }\n\t  else\n\t    # Install the binary that we compiled earlier.\n\t    file=`$ECHO \"$file$stripped_ext\" | $SED \"s%\\([^/]*\\)$%$objdir/\\1%\"`\n\t  fi\n\tfi\n\n\t# remove .exe since cygwin /usr/bin/install will append another\n\t# one anyway\n\tcase $install_prog,$host in\n\t*/usr/bin/install*,*cygwin*)\n\t  case $file:$destfile in\n\t  *.exe:*.exe)\n\t    # this is ok\n\t    ;;\n\t  *.exe:*)\n\t    destfile=$destfile.exe\n\t    ;;\n\t  *:*.exe)\n\t    func_stripname '' '.exe' \"$destfile\"\n\t    destfile=$func_stripname_result\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tfunc_show_eval \"$install_prog\\$stripme \\$file \\$destfile\" 'exit $?'\n\t$opt_dry_run || if test -n \"$outputname\"; then\n\t  ${RM}r \"$tmpdir\"\n\tfi\n\t;;\n      esac\n    done\n\n    for file in $staticlibs; do\n      func_basename \"$file\"\n      name=$func_basename_result\n\n      # Set up the ranlib parameters.\n      oldlib=$destdir/$name\n      func_to_tool_file \"$oldlib\" func_convert_file_msys_to_w32\n      tool_oldlib=$func_to_tool_file_result\n\n      func_show_eval \"$install_prog \\$file \\$oldlib\" 'exit $?'\n\n      if test -n \"$stripme\" && test -n \"$old_striplib\"; then\n\tfunc_show_eval \"$old_striplib $tool_oldlib\" 'exit $?'\n      fi\n\n      # Do each command in the postinstall commands.\n      func_execute_cmds \"$old_postinstall_cmds\" 'exit $?'\n    done\n\n    test -n \"$future_libdirs\" && \\\n      func_warning \"remember to run '$progname --finish$future_libdirs'\"\n\n    if test -n \"$current_libdirs\"; then\n      # Maybe just do a dry run.\n      $opt_dry_run && current_libdirs=\" -n$current_libdirs\"\n      exec_cmd='$SHELL \"$progpath\" $preserve_args --finish$current_libdirs'\n    else\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest install = \"$opt_mode\" && func_mode_install ${1+\"$@\"}\n\n\n# func_generate_dlsyms outputname originator pic_p\n# Extract symbols from dlprefiles and create ${outputname}S.o with\n# a dlpreopen symbol table.\nfunc_generate_dlsyms ()\n{\n    $debug_cmd\n\n    my_outputname=$1\n    my_originator=$2\n    my_pic_p=${3-false}\n    my_prefix=`$ECHO \"$my_originator\" | $SED 's%[^a-zA-Z0-9]%_%g'`\n    my_dlsyms=\n\n    if test -n \"$dlfiles$dlprefiles\" || test no != \"$dlself\"; then\n      if test -n \"$NM\" && test -n \"$global_symbol_pipe\"; then\n\tmy_dlsyms=${my_outputname}S.c\n      else\n\tfunc_error \"not configured to extract global symbols from dlpreopened files\"\n      fi\n    fi\n\n    if test -n \"$my_dlsyms\"; then\n      case $my_dlsyms in\n      \"\") ;;\n      *.c)\n\t# Discover the nlist of each of the dlfiles.\n\tnlist=$output_objdir/$my_outputname.nm\n\n\tfunc_show_eval \"$RM $nlist ${nlist}S ${nlist}T\"\n\n\t# Parse the name list into a source file.\n\tfunc_verbose \"creating $output_objdir/$my_dlsyms\"\n\n\t$opt_dry_run || $ECHO > \"$output_objdir/$my_dlsyms\" \"\\\n/* $my_dlsyms - symbol resolution table for '$my_outputname' dlsym emulation. */\n/* Generated by $PROGRAM (GNU $PACKAGE) $VERSION */\n\n#ifdef __cplusplus\nextern \\\"C\\\" {\n#endif\n\n#if defined __GNUC__ && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 4)) || (__GNUC__ > 4))\n#pragma GCC diagnostic ignored \\\"-Wstrict-prototypes\\\"\n#endif\n\n/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */\n#if defined _WIN32 || defined __CYGWIN__ || defined _WIN32_WCE\n/* DATA imports from DLLs on WIN32 can't be const, because runtime\n   relocations are performed -- see ld's documentation on pseudo-relocs.  */\n# define LT_DLSYM_CONST\n#elif defined __osf__\n/* This system does not cope well with relocations in const data.  */\n# define LT_DLSYM_CONST\n#else\n# define LT_DLSYM_CONST const\n#endif\n\n#define STREQ(s1, s2) (strcmp ((s1), (s2)) == 0)\n\n/* External symbol declarations for the compiler. */\\\n\"\n\n\tif test yes = \"$dlself\"; then\n\t  func_verbose \"generating symbol list for '$output'\"\n\n\t  $opt_dry_run || echo ': @PROGRAM@ ' > \"$nlist\"\n\n\t  # Add our own program objects to the symbol list.\n\t  progfiles=`$ECHO \"$objs$old_deplibs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\t  for progfile in $progfiles; do\n\t    func_to_tool_file \"$progfile\" func_convert_file_msys_to_w32\n\t    func_verbose \"extracting global C symbols from '$func_to_tool_file_result'\"\n\t    $opt_dry_run || eval \"$NM $func_to_tool_file_result | $global_symbol_pipe >> '$nlist'\"\n\t  done\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  if test -n \"$export_symbols_regex\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -e \"$export_symbols_regex\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  # Prepare the list of exported symbols\n\t  if test -z \"$export_symbols\"; then\n\t    export_symbols=$output_objdir/$outputname.exp\n\t    $opt_dry_run || {\n\t      $RM $export_symbols\n\t      eval \"$SED -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \\(.*\\)$/\\1/p' \"'< \"$nlist\" > \"$export_symbols\"'\n\t      case $host in\n\t      *cygwin* | *mingw* | *cegcc* )\n                eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n                eval 'cat \"$export_symbols\" >> \"$output_objdir/$outputname.def\"'\n\t        ;;\n\t      esac\n\t    }\n\t  else\n\t    $opt_dry_run || {\n\t      eval \"$SED -e 's/\\([].[*^$]\\)/\\\\\\\\\\1/g' -e 's/^/ /' -e 's/$/$/'\"' < \"$export_symbols\" > \"$output_objdir/$outputname.exp\"'\n\t      eval '$GREP -f \"$output_objdir/$outputname.exp\" < \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t      case $host in\n\t        *cygwin* | *mingw* | *cegcc* )\n\t          eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n\t          eval 'cat \"$nlist\" >> \"$output_objdir/$outputname.def\"'\n\t          ;;\n\t      esac\n\t    }\n\t  fi\n\tfi\n\n\tfor dlprefile in $dlprefiles; do\n\t  func_verbose \"extracting global C symbols from '$dlprefile'\"\n\t  func_basename \"$dlprefile\"\n\t  name=$func_basename_result\n          case $host in\n\t    *cygwin* | *mingw* | *cegcc* )\n\t      # if an import library, we need to obtain dlname\n\t      if func_win32_import_lib_p \"$dlprefile\"; then\n\t        func_tr_sh \"$dlprefile\"\n\t        eval \"curr_lafile=\\$libfile_$func_tr_sh_result\"\n\t        dlprefile_dlbasename=\n\t        if test -n \"$curr_lafile\" && func_lalib_p \"$curr_lafile\"; then\n\t          # Use subshell, to avoid clobbering current variable values\n\t          dlprefile_dlname=`source \"$curr_lafile\" && echo \"$dlname\"`\n\t          if test -n \"$dlprefile_dlname\"; then\n\t            func_basename \"$dlprefile_dlname\"\n\t            dlprefile_dlbasename=$func_basename_result\n\t          else\n\t            # no lafile. user explicitly requested -dlpreopen <import library>.\n\t            $sharedlib_from_linklib_cmd \"$dlprefile\"\n\t            dlprefile_dlbasename=$sharedlib_from_linklib_result\n\t          fi\n\t        fi\n\t        $opt_dry_run || {\n\t          if test -n \"$dlprefile_dlbasename\"; then\n\t            eval '$ECHO \": $dlprefile_dlbasename\" >> \"$nlist\"'\n\t          else\n\t            func_warning \"Could not compute DLL name from $name\"\n\t            eval '$ECHO \": $name \" >> \"$nlist\"'\n\t          fi\n\t          func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t          eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe |\n\t            $SED -e '/I __imp/d' -e 's/I __nm_/D /;s/_nm__//' >> '$nlist'\"\n\t        }\n\t      else # not an import lib\n\t        $opt_dry_run || {\n\t          eval '$ECHO \": $name \" >> \"$nlist\"'\n\t          func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t          eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t        }\n\t      fi\n\t    ;;\n\t    *)\n\t      $opt_dry_run || {\n\t        eval '$ECHO \": $name \" >> \"$nlist\"'\n\t        func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t        eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t      }\n\t    ;;\n          esac\n\tdone\n\n\t$opt_dry_run || {\n\t  # Make sure we have at least an empty file.\n\t  test -f \"$nlist\" || : > \"$nlist\"\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T\n\t    $MV \"$nlist\"T \"$nlist\"\n\t  fi\n\n\t  # Try sorting and uniquifying the output.\n\t  if $GREP -v \"^: \" < \"$nlist\" |\n\t      if sort -k 3 </dev/null >/dev/null 2>&1; then\n\t\tsort -k 3\n\t      else\n\t\tsort +2\n\t      fi |\n\t      uniq > \"$nlist\"S; then\n\t    :\n\t  else\n\t    $GREP -v \"^: \" < \"$nlist\" > \"$nlist\"S\n\t  fi\n\n\t  if test -f \"$nlist\"S; then\n\t    eval \"$global_symbol_to_cdecl\"' < \"$nlist\"S >> \"$output_objdir/$my_dlsyms\"'\n\t  else\n\t    echo '/* NONE */' >> \"$output_objdir/$my_dlsyms\"\n\t  fi\n\n\t  func_show_eval '$RM \"${nlist}I\"'\n\t  if test -n \"$global_symbol_to_import\"; then\n\t    eval \"$global_symbol_to_import\"' < \"$nlist\"S > \"$nlist\"I'\n\t  fi\n\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n\n/* The mapping between symbol names and symbols.  */\ntypedef struct {\n  const char *name;\n  void *address;\n} lt_dlsymlist;\nextern LT_DLSYM_CONST lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[];\\\n\"\n\n\t  if test -s \"$nlist\"I; then\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\nstatic void lt_syminit(void)\n{\n  LT_DLSYM_CONST lt_dlsymlist *symbol = lt_${my_prefix}_LTX_preloaded_symbols;\n  for (; symbol->name; ++symbol)\n    {\"\n\t    $SED 's/.*/      if (STREQ (symbol->name, \\\"&\\\")) symbol->address = (void *) \\&&;/' < \"$nlist\"I >> \"$output_objdir/$my_dlsyms\"\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\n    }\n}\"\n\t  fi\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\nLT_DLSYM_CONST lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[] =\n{ {\\\"$my_originator\\\", (void *) 0},\"\n\n\t  if test -s \"$nlist\"I; then\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\n  {\\\"@INIT@\\\", (void *) &lt_syminit},\"\n\t  fi\n\n\t  case $need_lib_prefix in\n\t  no)\n\t    eval \"$global_symbol_to_c_name_address\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  *)\n\t    eval \"$global_symbol_to_c_name_address_lib_prefix\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  esac\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt_${my_prefix}_LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\\\n\"\n\t} # !$opt_dry_run\n\n\tpic_flag_for_symtable=\n\tcase \"$compile_command \" in\n\t*\" -static \"*) ;;\n\t*)\n\t  case $host in\n\t  # compiling the symbol table file with pic_flag works around\n\t  # a FreeBSD bug that causes programs to crash when -lm is\n\t  # linked before any other PIC object.  But we must not use\n\t  # pic_flag when linking with -static.  The problem exists in\n\t  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.\n\t  *-*-freebsd2.*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)\n\t    pic_flag_for_symtable=\" $pic_flag -DFREEBSD_WORKAROUND\" ;;\n\t  *-*-hpux*)\n\t    pic_flag_for_symtable=\" $pic_flag\"  ;;\n\t  *)\n\t    $my_pic_p && pic_flag_for_symtable=\" $pic_flag\"\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tsymtab_cflags=\n\tfor arg in $LTCFLAGS; do\n\t  case $arg in\n\t  -pie | -fpie | -fPIE) ;;\n\t  *) func_append symtab_cflags \" $arg\" ;;\n\t  esac\n\tdone\n\n\t# Now compile the dynamic symbol file.\n\tfunc_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable \"$my_dlsyms\")' 'exit $?'\n\n\t# Clean up the generated files.\n\tfunc_show_eval '$RM \"$output_objdir/$my_dlsyms\" \"$nlist\" \"${nlist}S\" \"${nlist}T\" \"${nlist}I\"'\n\n\t# Transform the symbol file into the correct name.\n\tsymfileobj=$output_objdir/${my_outputname}S.$objext\n\tcase $host in\n\t*cygwin* | *mingw* | *cegcc* )\n\t  if test -f \"$output_objdir/$my_outputname.def\"; then\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t  else\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  fi\n\t  ;;\n\t*)\n\t  compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  ;;\n\tesac\n\t;;\n      *)\n\tfunc_fatal_error \"unknown suffix for '$my_dlsyms'\"\n\t;;\n      esac\n    else\n      # We keep going just in case the user didn't refer to\n      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe\n      # really was required.\n\n      # Nullify the symbol file.\n      compile_command=`$ECHO \"$compile_command\" | $SED \"s% @SYMFILE@%%\"`\n      finalize_command=`$ECHO \"$finalize_command\" | $SED \"s% @SYMFILE@%%\"`\n    fi\n}\n\n# func_cygming_gnu_implib_p ARG\n# This predicate returns with zero status (TRUE) if\n# ARG is a GNU/binutils-style import library. Returns\n# with nonzero status (FALSE) otherwise.\nfunc_cygming_gnu_implib_p ()\n{\n  $debug_cmd\n\n  func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n  func_cygming_gnu_implib_tmp=`$NM \"$func_to_tool_file_result\" | eval \"$global_symbol_pipe\" | $EGREP ' (_head_[A-Za-z0-9_]+_[ad]l*|[A-Za-z0-9_]+_[ad]l*_iname)$'`\n  test -n \"$func_cygming_gnu_implib_tmp\"\n}\n\n# func_cygming_ms_implib_p ARG\n# This predicate returns with zero status (TRUE) if\n# ARG is an MS-style import library. Returns\n# with nonzero status (FALSE) otherwise.\nfunc_cygming_ms_implib_p ()\n{\n  $debug_cmd\n\n  func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n  func_cygming_ms_implib_tmp=`$NM \"$func_to_tool_file_result\" | eval \"$global_symbol_pipe\" | $GREP '_NULL_IMPORT_DESCRIPTOR'`\n  test -n \"$func_cygming_ms_implib_tmp\"\n}\n\n# func_win32_libid arg\n# return the library type of file 'arg'\n#\n# Need a lot of goo to handle *both* DLLs and import libs\n# Has to be a shell function in order to 'eat' the argument\n# that is supplied when $file_magic_command is called.\n# Despite the name, also deal with 64 bit binaries.\nfunc_win32_libid ()\n{\n  $debug_cmd\n\n  win32_libid_type=unknown\n  win32_fileres=`file -L $1 2>/dev/null`\n  case $win32_fileres in\n  *ar\\ archive\\ import\\ library*) # definitely import\n    win32_libid_type=\"x86 archive import\"\n    ;;\n  *ar\\ archive*) # could be an import, or static\n    # Keep the egrep pattern in sync with the one in _LT_CHECK_MAGIC_METHOD.\n    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |\n       $EGREP 'file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)' >/dev/null; then\n      case $nm_interface in\n      \"MS dumpbin\")\n\tif func_cygming_ms_implib_p \"$1\" ||\n\t   func_cygming_gnu_implib_p \"$1\"\n\tthen\n\t  win32_nmres=import\n\telse\n\t  win32_nmres=\n\tfi\n\t;;\n      *)\n\tfunc_to_tool_file \"$1\" func_convert_file_msys_to_w32\n\twin32_nmres=`eval $NM -f posix -A \\\"$func_to_tool_file_result\\\" |\n\t  $SED -n -e '\n\t    1,100{\n\t\t/ I /{\n\t\t    s|.*|import|\n\t\t    p\n\t\t    q\n\t\t}\n\t    }'`\n\t;;\n      esac\n      case $win32_nmres in\n      import*)  win32_libid_type=\"x86 archive import\";;\n      *)        win32_libid_type=\"x86 archive static\";;\n      esac\n    fi\n    ;;\n  *DLL*)\n    win32_libid_type=\"x86 DLL\"\n    ;;\n  *executable*) # but shell scripts are \"executable\" too...\n    case $win32_fileres in\n    *MS\\ Windows\\ PE\\ Intel*)\n      win32_libid_type=\"x86 DLL\"\n      ;;\n    esac\n    ;;\n  esac\n  $ECHO \"$win32_libid_type\"\n}\n\n# func_cygming_dll_for_implib ARG\n#\n# Platform-specific function to extract the\n# name of the DLL associated with the specified\n# import library ARG.\n# Invoked by eval'ing the libtool variable\n#    $sharedlib_from_linklib_cmd\n# Result is available in the variable\n#    $sharedlib_from_linklib_result\nfunc_cygming_dll_for_implib ()\n{\n  $debug_cmd\n\n  sharedlib_from_linklib_result=`$DLLTOOL --identify-strict --identify \"$1\"`\n}\n\n# func_cygming_dll_for_implib_fallback_core SECTION_NAME LIBNAMEs\n#\n# The is the core of a fallback implementation of a\n# platform-specific function to extract the name of the\n# DLL associated with the specified import library LIBNAME.\n#\n# SECTION_NAME is either .idata$6 or .idata$7, depending\n# on the platform and compiler that created the implib.\n#\n# Echos the name of the DLL associated with the\n# specified import library.\nfunc_cygming_dll_for_implib_fallback_core ()\n{\n  $debug_cmd\n\n  match_literal=`$ECHO \"$1\" | $SED \"$sed_make_literal_regex\"`\n  $OBJDUMP -s --section \"$1\" \"$2\" 2>/dev/null |\n    $SED '/^Contents of section '\"$match_literal\"':/{\n      # Place marker at beginning of archive member dllname section\n      s/.*/====MARK====/\n      p\n      d\n    }\n    # These lines can sometimes be longer than 43 characters, but\n    # are always uninteresting\n    /:[\t ]*file format pe[i]\\{,1\\}-/d\n    /^In archive [^:]*:/d\n    # Ensure marker is printed\n    /^====MARK====/p\n    # Remove all lines with less than 43 characters\n    /^.\\{43\\}/!d\n    # From remaining lines, remove first 43 characters\n    s/^.\\{43\\}//' |\n    $SED -n '\n      # Join marker and all lines until next marker into a single line\n      /^====MARK====/ b para\n      H\n      $ b para\n      b\n      :para\n      x\n      s/\\n//g\n      # Remove the marker\n      s/^====MARK====//\n      # Remove trailing dots and whitespace\n      s/[\\. \\t]*$//\n      # Print\n      /./p' |\n    # we now have a list, one entry per line, of the stringified\n    # contents of the appropriate section of all members of the\n    # archive that possess that section. Heuristic: eliminate\n    # all those that have a first or second character that is\n    # a '.' (that is, objdump's representation of an unprintable\n    # character.) This should work for all archives with less than\n    # 0x302f exports -- but will fail for DLLs whose name actually\n    # begins with a literal '.' or a single character followed by\n    # a '.'.\n    #\n    # Of those that remain, print the first one.\n    $SED -e '/^\\./d;/^.\\./d;q'\n}\n\n# func_cygming_dll_for_implib_fallback ARG\n# Platform-specific function to extract the\n# name of the DLL associated with the specified\n# import library ARG.\n#\n# This fallback implementation is for use when $DLLTOOL\n# does not support the --identify-strict option.\n# Invoked by eval'ing the libtool variable\n#    $sharedlib_from_linklib_cmd\n# Result is available in the variable\n#    $sharedlib_from_linklib_result\nfunc_cygming_dll_for_implib_fallback ()\n{\n  $debug_cmd\n\n  if func_cygming_gnu_implib_p \"$1\"; then\n    # binutils import library\n    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$7' \"$1\"`\n  elif func_cygming_ms_implib_p \"$1\"; then\n    # ms-generated import library\n    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$6' \"$1\"`\n  else\n    # unknown\n    sharedlib_from_linklib_result=\n  fi\n}\n\n\n# func_extract_an_archive dir oldlib\nfunc_extract_an_archive ()\n{\n    $debug_cmd\n\n    f_ex_an_ar_dir=$1; shift\n    f_ex_an_ar_oldlib=$1\n    if test yes = \"$lock_old_archive_extraction\"; then\n      lockfile=$f_ex_an_ar_oldlib.lock\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    fi\n    func_show_eval \"(cd \\$f_ex_an_ar_dir && $AR x \\\"\\$f_ex_an_ar_oldlib\\\")\" \\\n\t\t   'stat=$?; rm -f \"$lockfile\"; exit $stat'\n    if test yes = \"$lock_old_archive_extraction\"; then\n      $opt_dry_run || rm -f \"$lockfile\"\n    fi\n    if ($AR t \"$f_ex_an_ar_oldlib\" | sort | sort -uc >/dev/null 2>&1); then\n     :\n    else\n      func_fatal_error \"object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib\"\n    fi\n}\n\n\n# func_extract_archives gentop oldlib ...\nfunc_extract_archives ()\n{\n    $debug_cmd\n\n    my_gentop=$1; shift\n    my_oldlibs=${1+\"$@\"}\n    my_oldobjs=\n    my_xlib=\n    my_xabs=\n    my_xdir=\n\n    for my_xlib in $my_oldlibs; do\n      # Extract the objects.\n      case $my_xlib in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) my_xabs=$my_xlib ;;\n\t*) my_xabs=`pwd`\"/$my_xlib\" ;;\n      esac\n      func_basename \"$my_xlib\"\n      my_xlib=$func_basename_result\n      my_xlib_u=$my_xlib\n      while :; do\n        case \" $extracted_archives \" in\n\t*\" $my_xlib_u \"*)\n\t  func_arith $extracted_serial + 1\n\t  extracted_serial=$func_arith_result\n\t  my_xlib_u=lt$extracted_serial-$my_xlib ;;\n\t*) break ;;\n\tesac\n      done\n      extracted_archives=\"$extracted_archives $my_xlib_u\"\n      my_xdir=$my_gentop/$my_xlib_u\n\n      func_mkdir_p \"$my_xdir\"\n\n      case $host in\n      *-darwin*)\n\tfunc_verbose \"Extracting $my_xabs\"\n\t# Do not bother doing anything if just a dry run\n\t$opt_dry_run || {\n\t  darwin_orig_dir=`pwd`\n\t  cd $my_xdir || exit $?\n\t  darwin_archive=$my_xabs\n\t  darwin_curdir=`pwd`\n\t  func_basename \"$darwin_archive\"\n\t  darwin_base_archive=$func_basename_result\n\t  darwin_arches=`$LIPO -info \"$darwin_archive\" 2>/dev/null | $GREP Architectures 2>/dev/null || true`\n\t  if test -n \"$darwin_arches\"; then\n\t    darwin_arches=`$ECHO \"$darwin_arches\" | $SED -e 's/.*are://'`\n\t    darwin_arch=\n\t    func_verbose \"$darwin_base_archive has multiple architectures $darwin_arches\"\n\t    for darwin_arch in  $darwin_arches; do\n\t      func_mkdir_p \"unfat-$$/$darwin_base_archive-$darwin_arch\"\n\t      $LIPO -thin $darwin_arch -output \"unfat-$$/$darwin_base_archive-$darwin_arch/$darwin_base_archive\" \"$darwin_archive\"\n\t      cd \"unfat-$$/$darwin_base_archive-$darwin_arch\"\n\t      func_extract_an_archive \"`pwd`\" \"$darwin_base_archive\"\n\t      cd \"$darwin_curdir\"\n\t      $RM \"unfat-$$/$darwin_base_archive-$darwin_arch/$darwin_base_archive\"\n\t    done # $darwin_arches\n            ## Okay now we've a bunch of thin objects, gotta fatten them up :)\n\t    darwin_filelist=`find unfat-$$ -type f -name \\*.o -print -o -name \\*.lo -print | $SED -e \"$sed_basename\" | sort -u`\n\t    darwin_file=\n\t    darwin_files=\n\t    for darwin_file in $darwin_filelist; do\n\t      darwin_files=`find unfat-$$ -name $darwin_file -print | sort | $NL2SP`\n\t      $LIPO -create -output \"$darwin_file\" $darwin_files\n\t    done # $darwin_filelist\n\t    $RM -rf unfat-$$\n\t    cd \"$darwin_orig_dir\"\n\t  else\n\t    cd $darwin_orig_dir\n\t    func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t  fi # $darwin_arches\n\t} # !$opt_dry_run\n\t;;\n      *)\n        func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t;;\n      esac\n      my_oldobjs=\"$my_oldobjs \"`find $my_xdir -name \\*.$objext -print -o -name \\*.lo -print | sort | $NL2SP`\n    done\n\n    func_extract_archives_result=$my_oldobjs\n}\n\n\n# func_emit_wrapper [arg=no]\n#\n# Emit a libtool wrapper script on stdout.\n# Don't directly open a file because we may want to\n# incorporate the script contents within a cygwin/mingw\n# wrapper executable.  Must ONLY be called from within\n# func_mode_link because it depends on a number of variables\n# set therein.\n#\n# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\n# variable will take.  If 'yes', then the emitted script\n# will assume that the directory where it is stored is\n# the $objdir directory.  This is a cygwin/mingw-specific\n# behavior.\nfunc_emit_wrapper ()\n{\n\tfunc_emit_wrapper_arg1=${1-no}\n\n\t$ECHO \"\\\n#! $SHELL\n\n# $output - temporary wrapper script for $objdir/$outputname\n# Generated by $PROGRAM (GNU $PACKAGE) $VERSION\n#\n# The $output program cannot be directly executed until all the libtool\n# libraries that it depends on are installed.\n#\n# This wrapper script should never be moved out of the build directory.\n# If it is, it will not operate correctly.\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nsed_quote_subst='$sed_quote_subst'\n\n# Be Bourne compatible\nif test -n \\\"\\${ZSH_VERSION+set}\\\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse\n  case \\`(set -o) 2>/dev/null\\` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nrelink_command=\\\"$relink_command\\\"\n\n# This environment variable determines our operation mode.\nif test \\\"\\$libtool_install_magic\\\" = \\\"$magic\\\"; then\n  # install mode needs the following variables:\n  generated_by_libtool_version='$macro_version'\n  notinst_deplibs='$notinst_deplibs'\nelse\n  # When we are sourced in execute mode, \\$file and \\$ECHO are already set.\n  if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n    file=\\\"\\$0\\\"\"\n\n    qECHO=`$ECHO \"$ECHO\" | $SED \"$sed_quote_subst\"`\n    $ECHO \"\\\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$1\n_LTECHO_EOF'\n}\n    ECHO=\\\"$qECHO\\\"\n  fi\n\n# Very basic option parsing. These options are (a) specific to\n# the libtool wrapper, (b) are identical between the wrapper\n# /script/ and the wrapper /executable/ that is used only on\n# windows platforms, and (c) all begin with the string \"--lt-\"\n# (application programs are unlikely to have options that match\n# this pattern).\n#\n# There are only two supported options: --lt-debug and\n# --lt-dump-script. There is, deliberately, no --lt-help.\n#\n# The first argument to this parsing function should be the\n# script's $0 value, followed by \"$@\".\nlt_option_debug=\nfunc_parse_lt_options ()\n{\n  lt_script_arg0=\\$0\n  shift\n  for lt_opt\n  do\n    case \\\"\\$lt_opt\\\" in\n    --lt-debug) lt_option_debug=1 ;;\n    --lt-dump-script)\n        lt_dump_D=\\`\\$ECHO \\\"X\\$lt_script_arg0\\\" | $SED -e 's/^X//' -e 's%/[^/]*$%%'\\`\n        test \\\"X\\$lt_dump_D\\\" = \\\"X\\$lt_script_arg0\\\" && lt_dump_D=.\n        lt_dump_F=\\`\\$ECHO \\\"X\\$lt_script_arg0\\\" | $SED -e 's/^X//' -e 's%^.*/%%'\\`\n        cat \\\"\\$lt_dump_D/\\$lt_dump_F\\\"\n        exit 0\n      ;;\n    --lt-*)\n        \\$ECHO \\\"Unrecognized --lt- option: '\\$lt_opt'\\\" 1>&2\n        exit 1\n      ;;\n    esac\n  done\n\n  # Print the debug banner immediately:\n  if test -n \\\"\\$lt_option_debug\\\"; then\n    echo \\\"$outputname:$output:\\$LINENO: libtool wrapper (GNU $PACKAGE) $VERSION\\\" 1>&2\n  fi\n}\n\n# Used when --lt-debug. Prints its arguments to stdout\n# (redirection is the responsibility of the caller)\nfunc_lt_dump_args ()\n{\n  lt_dump_args_N=1;\n  for lt_arg\n  do\n    \\$ECHO \\\"$outputname:$output:\\$LINENO: newargv[\\$lt_dump_args_N]: \\$lt_arg\\\"\n    lt_dump_args_N=\\`expr \\$lt_dump_args_N + 1\\`\n  done\n}\n\n# Core function for launching the target application\nfunc_exec_program_core ()\n{\n\"\n  case $host in\n  # Backslashes separate directories on plain windows\n  *-*-mingw | *-*-os2* | *-cegcc*)\n    $ECHO \"\\\n      if test -n \\\"\\$lt_option_debug\\\"; then\n        \\$ECHO \\\"$outputname:$output:\\$LINENO: newargv[0]: \\$progdir\\\\\\\\\\$program\\\" 1>&2\n        func_lt_dump_args \\${1+\\\"\\$@\\\"} 1>&2\n      fi\n      exec \\\"\\$progdir\\\\\\\\\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n    ;;\n\n  *)\n    $ECHO \"\\\n      if test -n \\\"\\$lt_option_debug\\\"; then\n        \\$ECHO \\\"$outputname:$output:\\$LINENO: newargv[0]: \\$progdir/\\$program\\\" 1>&2\n        func_lt_dump_args \\${1+\\\"\\$@\\\"} 1>&2\n      fi\n      exec \\\"\\$progdir/\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n    ;;\n  esac\n  $ECHO \"\\\n      \\$ECHO \\\"\\$0: cannot exec \\$program \\$*\\\" 1>&2\n      exit 1\n}\n\n# A function to encapsulate launching the target application\n# Strips options in the --lt-* namespace from \\$@ and\n# launches target application with the remaining arguments.\nfunc_exec_program ()\n{\n  case \\\" \\$* \\\" in\n  *\\\\ --lt-*)\n    for lt_wr_arg\n    do\n      case \\$lt_wr_arg in\n      --lt-*) ;;\n      *) set x \\\"\\$@\\\" \\\"\\$lt_wr_arg\\\"; shift;;\n      esac\n      shift\n    done ;;\n  esac\n  func_exec_program_core \\${1+\\\"\\$@\\\"}\n}\n\n  # Parse options\n  func_parse_lt_options \\\"\\$0\\\" \\${1+\\\"\\$@\\\"}\n\n  # Find the directory that this script lives in.\n  thisdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*$%%'\\`\n  test \\\"x\\$thisdir\\\" = \\\"x\\$file\\\" && thisdir=.\n\n  # Follow symbolic links until we get to the real thisdir.\n  file=\\`ls -ld \\\"\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  while test -n \\\"\\$file\\\"; do\n    destdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*\\$%%'\\`\n\n    # If there was a directory component, then change thisdir.\n    if test \\\"x\\$destdir\\\" != \\\"x\\$file\\\"; then\n      case \\\"\\$destdir\\\" in\n      [\\\\\\\\/]* | [A-Za-z]:[\\\\\\\\/]*) thisdir=\\\"\\$destdir\\\" ;;\n      *) thisdir=\\\"\\$thisdir/\\$destdir\\\" ;;\n      esac\n    fi\n\n    file=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%^.*/%%'\\`\n    file=\\`ls -ld \\\"\\$thisdir/\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  done\n\n  # Usually 'no', except on cygwin/mingw when embedded into\n  # the cwrapper.\n  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_arg1\n  if test \\\"\\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\\\" = \\\"yes\\\"; then\n    # special case for '.'\n    if test \\\"\\$thisdir\\\" = \\\".\\\"; then\n      thisdir=\\`pwd\\`\n    fi\n    # remove .libs from thisdir\n    case \\\"\\$thisdir\\\" in\n    *[\\\\\\\\/]$objdir ) thisdir=\\`\\$ECHO \\\"\\$thisdir\\\" | $SED 's%[\\\\\\\\/][^\\\\\\\\/]*$%%'\\` ;;\n    $objdir )   thisdir=. ;;\n    esac\n  fi\n\n  # Try to get the absolute directory name.\n  absdir=\\`cd \\\"\\$thisdir\\\" && pwd\\`\n  test -n \\\"\\$absdir\\\" && thisdir=\\\"\\$absdir\\\"\n\"\n\n\tif test yes = \"$fast_install\"; then\n\t  $ECHO \"\\\n  program=lt-'$outputname'$exeext\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\n  if test ! -f \\\"\\$progdir/\\$program\\\" ||\n     { file=\\`ls -1dt \\\"\\$progdir/\\$program\\\" \\\"\\$progdir/../\\$program\\\" 2>/dev/null | $SED 1q\\`; \\\\\n       test \\\"X\\$file\\\" != \\\"X\\$progdir/\\$program\\\"; }; then\n\n    file=\\\"\\$\\$-\\$program\\\"\n\n    if test ! -d \\\"\\$progdir\\\"; then\n      $MKDIR \\\"\\$progdir\\\"\n    else\n      $RM \\\"\\$progdir/\\$file\\\"\n    fi\"\n\n\t  $ECHO \"\\\n\n    # relink executable if necessary\n    if test -n \\\"\\$relink_command\\\"; then\n      if relink_command_output=\\`eval \\$relink_command 2>&1\\`; then :\n      else\n\t\\$ECHO \\\"\\$relink_command_output\\\" >&2\n\t$RM \\\"\\$progdir/\\$file\\\"\n\texit 1\n      fi\n    fi\n\n    $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\" 2>/dev/null ||\n    { $RM \\\"\\$progdir/\\$program\\\";\n      $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\"; }\n    $RM \\\"\\$progdir/\\$file\\\"\n  fi\"\n\telse\n\t  $ECHO \"\\\n  program='$outputname'\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\"\n\tfi\n\n\t$ECHO \"\\\n\n  if test -f \\\"\\$progdir/\\$program\\\"; then\"\n\n\t# fixup the dll searchpath if we need to.\n\t#\n\t# Fix the DLL searchpath if we need to.  Do this before prepending\n\t# to shlibpath, because on Windows, both are PATH and uninstalled\n\t# libraries must come first.\n\tif test -n \"$dllsearchpath\"; then\n\t  $ECHO \"\\\n    # Add the dll search path components to the executable PATH\n    PATH=$dllsearchpath:\\$PATH\n\"\n\tfi\n\n\t# Export our shlibpath_var if we have one.\n\tif test yes = \"$shlibpath_overrides_runpath\" && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n\t  $ECHO \"\\\n    # Add our own library path to $shlibpath_var\n    $shlibpath_var=\\\"$temp_rpath\\$$shlibpath_var\\\"\n\n    # Some systems cannot cope with colon-terminated $shlibpath_var\n    # The second colon is a workaround for a bug in BeOS R4 sed\n    $shlibpath_var=\\`\\$ECHO \\\"\\$$shlibpath_var\\\" | $SED 's/::*\\$//'\\`\n\n    export $shlibpath_var\n\"\n\tfi\n\n\t$ECHO \"\\\n    if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n      # Run the actual program with our arguments.\n      func_exec_program \\${1+\\\"\\$@\\\"}\n    fi\n  else\n    # The program doesn't exist.\n    \\$ECHO \\\"\\$0: error: '\\$progdir/\\$program' does not exist\\\" 1>&2\n    \\$ECHO \\\"This script is just a wrapper for \\$program.\\\" 1>&2\n    \\$ECHO \\\"See the $PACKAGE documentation for more information.\\\" 1>&2\n    exit 1\n  fi\nfi\\\n\"\n}\n\n\n# func_emit_cwrapperexe_src\n# emit the source code for a wrapper executable on stdout\n# Must ONLY be called from within func_mode_link because\n# it depends on a number of variable set therein.\nfunc_emit_cwrapperexe_src ()\n{\n\tcat <<EOF\n\n/* $cwrappersource - temporary wrapper executable for $objdir/$outputname\n   Generated by $PROGRAM (GNU $PACKAGE) $VERSION\n\n   The $output program cannot be directly executed until all the libtool\n   libraries that it depends on are installed.\n\n   This wrapper executable should never be moved out of the build directory.\n   If it is, it will not operate correctly.\n*/\nEOF\n\t    cat <<\"EOF\"\n#ifdef _MSC_VER\n# define _CRT_SECURE_NO_DEPRECATE 1\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef _MSC_VER\n# include <direct.h>\n# include <process.h>\n# include <io.h>\n#else\n# include <unistd.h>\n# include <stdint.h>\n# ifdef __CYGWIN__\n#  include <io.h>\n# endif\n#endif\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n#define STREQ(s1, s2) (strcmp ((s1), (s2)) == 0)\n\n/* declarations of non-ANSI functions */\n#if defined __MINGW32__\n# ifdef __STRICT_ANSI__\nint _putenv (const char *);\n# endif\n#elif defined __CYGWIN__\n# ifdef __STRICT_ANSI__\nchar *realpath (const char *, char *);\nint putenv (char *);\nint setenv (const char *, const char *, int);\n# endif\n/* #elif defined other_platform || defined ... */\n#endif\n\n/* portability defines, excluding path handling macros */\n#if defined _MSC_VER\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n# define S_IXUSR _S_IEXEC\n#elif defined __MINGW32__\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n#elif defined __CYGWIN__\n# define HAVE_SETENV\n# define FOPEN_WB \"wb\"\n/* #elif defined other platforms ... */\n#endif\n\n#if defined PATH_MAX\n# define LT_PATHMAX PATH_MAX\n#elif defined MAXPATHLEN\n# define LT_PATHMAX MAXPATHLEN\n#else\n# define LT_PATHMAX 1024\n#endif\n\n#ifndef S_IXOTH\n# define S_IXOTH 0\n#endif\n#ifndef S_IXGRP\n# define S_IXGRP 0\n#endif\n\n/* path handling portability macros */\n#ifndef DIR_SEPARATOR\n# define DIR_SEPARATOR '/'\n# define PATH_SEPARATOR ':'\n#endif\n\n#if defined _WIN32 || defined __MSDOS__ || defined __DJGPP__ || \\\n  defined __OS2__\n# define HAVE_DOS_BASED_FILE_SYSTEM\n# define FOPEN_WB \"wb\"\n# ifndef DIR_SEPARATOR_2\n#  define DIR_SEPARATOR_2 '\\\\'\n# endif\n# ifndef PATH_SEPARATOR_2\n#  define PATH_SEPARATOR_2 ';'\n# endif\n#endif\n\n#ifndef DIR_SEPARATOR_2\n# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)\n#else /* DIR_SEPARATOR_2 */\n# define IS_DIR_SEPARATOR(ch) \\\n\t(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))\n#endif /* DIR_SEPARATOR_2 */\n\n#ifndef PATH_SEPARATOR_2\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)\n#else /* PATH_SEPARATOR_2 */\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)\n#endif /* PATH_SEPARATOR_2 */\n\n#ifndef FOPEN_WB\n# define FOPEN_WB \"w\"\n#endif\n#ifndef _O_BINARY\n# define _O_BINARY 0\n#endif\n\n#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))\n#define XFREE(stale) do { \\\n  if (stale) { free (stale); stale = 0; } \\\n} while (0)\n\n#if defined LT_DEBUGWRAPPER\nstatic int lt_debug = 1;\n#else\nstatic int lt_debug = 0;\n#endif\n\nconst char *program_name = \"libtool-wrapper\"; /* in case xstrdup fails */\n\nvoid *xmalloc (size_t num);\nchar *xstrdup (const char *string);\nconst char *base_name (const char *name);\nchar *find_executable (const char *wrapper);\nchar *chase_symlinks (const char *pathspec);\nint make_executable (const char *path);\nint check_executable (const char *path);\nchar *strendzap (char *str, const char *pat);\nvoid lt_debugprintf (const char *file, int line, const char *fmt, ...);\nvoid lt_fatal (const char *file, int line, const char *message, ...);\nstatic const char *nonnull (const char *s);\nstatic const char *nonempty (const char *s);\nvoid lt_setenv (const char *name, const char *value);\nchar *lt_extend_str (const char *orig_value, const char *add, int to_end);\nvoid lt_update_exe_path (const char *name, const char *value);\nvoid lt_update_lib_path (const char *name, const char *value);\nchar **prepare_spawn (char **argv);\nvoid lt_dump_script (FILE *f);\nEOF\n\n\t    cat <<EOF\n#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 5)\n# define externally_visible volatile\n#else\n# define externally_visible __attribute__((externally_visible)) volatile\n#endif\nexternally_visible const char * MAGIC_EXE = \"$magic_exe\";\nconst char * LIB_PATH_VARNAME = \"$shlibpath_var\";\nEOF\n\n\t    if test yes = \"$shlibpath_overrides_runpath\" && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n              func_to_host_path \"$temp_rpath\"\n\t      cat <<EOF\nconst char * LIB_PATH_VALUE   = \"$func_to_host_path_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * LIB_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test -n \"$dllsearchpath\"; then\n              func_to_host_path \"$dllsearchpath:\"\n\t      cat <<EOF\nconst char * EXE_PATH_VARNAME = \"PATH\";\nconst char * EXE_PATH_VALUE   = \"$func_to_host_path_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * EXE_PATH_VARNAME = \"\";\nconst char * EXE_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test yes = \"$fast_install\"; then\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"lt-$outputname\"; /* hopefully, no .exe */\nEOF\n\t    else\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"$outputname\"; /* hopefully, no .exe */\nEOF\n\t    fi\n\n\n\t    cat <<\"EOF\"\n\n#define LTWRAPPER_OPTION_PREFIX         \"--lt-\"\n\nstatic const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;\nstatic const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX \"dump-script\";\nstatic const char *debug_opt            = LTWRAPPER_OPTION_PREFIX \"debug\";\n\nint\nmain (int argc, char *argv[])\n{\n  char **newargz;\n  int  newargc;\n  char *tmp_pathspec;\n  char *actual_cwrapper_path;\n  char *actual_cwrapper_name;\n  char *target_name;\n  char *lt_argv_zero;\n  int rval = 127;\n\n  int i;\n\n  program_name = (char *) xstrdup (base_name (argv[0]));\n  newargz = XMALLOC (char *, (size_t) argc + 1);\n\n  /* very simple arg parsing; don't want to rely on getopt\n   * also, copy all non cwrapper options to newargz, except\n   * argz[0], which is handled differently\n   */\n  newargc=0;\n  for (i = 1; i < argc; i++)\n    {\n      if (STREQ (argv[i], dumpscript_opt))\n\t{\nEOF\n\t    case $host in\n\t      *mingw* | *cygwin* )\n\t\t# make stdout use \"unix\" line endings\n\t\techo \"          setmode(1,_O_BINARY);\"\n\t\t;;\n\t      esac\n\n\t    cat <<\"EOF\"\n\t  lt_dump_script (stdout);\n\t  return 0;\n\t}\n      if (STREQ (argv[i], debug_opt))\n\t{\n          lt_debug = 1;\n          continue;\n\t}\n      if (STREQ (argv[i], ltwrapper_option_prefix))\n        {\n          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX\n             namespace, but it is not one of the ones we know about and\n             have already dealt with, above (inluding dump-script), then\n             report an error. Otherwise, targets might begin to believe\n             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX\n             namespace. The first time any user complains about this, we'll\n             need to make LTWRAPPER_OPTION_PREFIX a configure-time option\n             or a configure.ac-settable value.\n           */\n          lt_fatal (__FILE__, __LINE__,\n\t\t    \"unrecognized %s option: '%s'\",\n                    ltwrapper_option_prefix, argv[i]);\n        }\n      /* otherwise ... */\n      newargz[++newargc] = xstrdup (argv[i]);\n    }\n  newargz[++newargc] = NULL;\n\nEOF\n\t    cat <<EOF\n  /* The GNU banner must be the first non-error debug message */\n  lt_debugprintf (__FILE__, __LINE__, \"libtool wrapper (GNU $PACKAGE) $VERSION\\n\");\nEOF\n\t    cat <<\"EOF\"\n  lt_debugprintf (__FILE__, __LINE__, \"(main) argv[0]: %s\\n\", argv[0]);\n  lt_debugprintf (__FILE__, __LINE__, \"(main) program_name: %s\\n\", program_name);\n\n  tmp_pathspec = find_executable (argv[0]);\n  if (tmp_pathspec == NULL)\n    lt_fatal (__FILE__, __LINE__, \"couldn't find %s\", argv[0]);\n  lt_debugprintf (__FILE__, __LINE__,\n                  \"(main) found exe (before symlink chase) at: %s\\n\",\n\t\t  tmp_pathspec);\n\n  actual_cwrapper_path = chase_symlinks (tmp_pathspec);\n  lt_debugprintf (__FILE__, __LINE__,\n                  \"(main) found exe (after symlink chase) at: %s\\n\",\n\t\t  actual_cwrapper_path);\n  XFREE (tmp_pathspec);\n\n  actual_cwrapper_name = xstrdup (base_name (actual_cwrapper_path));\n  strendzap (actual_cwrapper_path, actual_cwrapper_name);\n\n  /* wrapper name transforms */\n  strendzap (actual_cwrapper_name, \".exe\");\n  tmp_pathspec = lt_extend_str (actual_cwrapper_name, \".exe\", 1);\n  XFREE (actual_cwrapper_name);\n  actual_cwrapper_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  /* target_name transforms -- use actual target program name; might have lt- prefix */\n  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));\n  strendzap (target_name, \".exe\");\n  tmp_pathspec = lt_extend_str (target_name, \".exe\", 1);\n  XFREE (target_name);\n  target_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(main) libtool target name: %s\\n\",\n\t\t  target_name);\nEOF\n\n\t    cat <<EOF\n  newargz[0] =\n    XMALLOC (char, (strlen (actual_cwrapper_path) +\n\t\t    strlen (\"$objdir\") + 1 + strlen (actual_cwrapper_name) + 1));\n  strcpy (newargz[0], actual_cwrapper_path);\n  strcat (newargz[0], \"$objdir\");\n  strcat (newargz[0], \"/\");\nEOF\n\n\t    cat <<\"EOF\"\n  /* stop here, and copy so we don't have to do this twice */\n  tmp_pathspec = xstrdup (newargz[0]);\n\n  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */\n  strcat (newargz[0], actual_cwrapper_name);\n\n  /* DO want the lt- prefix here if it exists, so use target_name */\n  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);\n  XFREE (tmp_pathspec);\n  tmp_pathspec = NULL;\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t    cat <<\"EOF\"\n  {\n    char* p;\n    while ((p = strchr (newargz[0], '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n    while ((p = strchr (lt_argv_zero, '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n  }\nEOF\n\t    ;;\n\t    esac\n\n\t    cat <<\"EOF\"\n  XFREE (target_name);\n  XFREE (actual_cwrapper_path);\n  XFREE (actual_cwrapper_name);\n\n  lt_setenv (\"BIN_SH\", \"xpg4\"); /* for Tru64 */\n  lt_setenv (\"DUALCASE\", \"1\");  /* for MSK sh */\n  /* Update the DLL searchpath.  EXE_PATH_VALUE ($dllsearchpath) must\n     be prepended before (that is, appear after) LIB_PATH_VALUE ($temp_rpath)\n     because on Windows, both *_VARNAMEs are PATH but uninstalled\n     libraries must come first. */\n  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);\n  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);\n\n  lt_debugprintf (__FILE__, __LINE__, \"(main) lt_argv_zero: %s\\n\",\n\t\t  nonnull (lt_argv_zero));\n  for (i = 0; i < newargc; i++)\n    {\n      lt_debugprintf (__FILE__, __LINE__, \"(main) newargz[%d]: %s\\n\",\n\t\t      i, nonnull (newargz[i]));\n    }\n\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n  /* execv doesn't actually work on mingw as expected on unix */\n  newargz = prepare_spawn (newargz);\n  rval = (int) _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);\n  if (rval == -1)\n    {\n      /* failed to start process */\n      lt_debugprintf (__FILE__, __LINE__,\n\t\t      \"(main) failed to launch target \\\"%s\\\": %s\\n\",\n\t\t      lt_argv_zero, nonnull (strerror (errno)));\n      return 127;\n    }\n  return rval;\nEOF\n\t\t;;\n\t      *)\n\t\tcat <<\"EOF\"\n  execv (lt_argv_zero, newargz);\n  return rval; /* =127, but avoids unused variable warning */\nEOF\n\t\t;;\n\t    esac\n\n\t    cat <<\"EOF\"\n}\n\nvoid *\nxmalloc (size_t num)\n{\n  void *p = (void *) malloc (num);\n  if (!p)\n    lt_fatal (__FILE__, __LINE__, \"memory exhausted\");\n\n  return p;\n}\n\nchar *\nxstrdup (const char *string)\n{\n  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),\n\t\t\t  string) : NULL;\n}\n\nconst char *\nbase_name (const char *name)\n{\n  const char *base;\n\n#if defined HAVE_DOS_BASED_FILE_SYSTEM\n  /* Skip over the disk name in MSDOS pathnames. */\n  if (isalpha ((unsigned char) name[0]) && name[1] == ':')\n    name += 2;\n#endif\n\n  for (base = name; *name; name++)\n    if (IS_DIR_SEPARATOR (*name))\n      base = name + 1;\n  return base;\n}\n\nint\ncheck_executable (const char *path)\n{\n  struct stat st;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(check_executable): %s\\n\",\n                  nonempty (path));\n  if ((!path) || (!*path))\n    return 0;\n\n  if ((stat (path, &st) >= 0)\n      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n    return 1;\n  else\n    return 0;\n}\n\nint\nmake_executable (const char *path)\n{\n  int rval = 0;\n  struct stat st;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(make_executable): %s\\n\",\n                  nonempty (path));\n  if ((!path) || (!*path))\n    return 0;\n\n  if (stat (path, &st) >= 0)\n    {\n      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);\n    }\n  return rval;\n}\n\n/* Searches for the full path of the wrapper.  Returns\n   newly allocated full path name if found, NULL otherwise\n   Does not chase symlinks, even on platforms that support them.\n*/\nchar *\nfind_executable (const char *wrapper)\n{\n  int has_slash = 0;\n  const char *p;\n  const char *p_next;\n  /* static buffer for getcwd */\n  char tmp[LT_PATHMAX + 1];\n  size_t tmp_len;\n  char *concat_name;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(find_executable): %s\\n\",\n                  nonempty (wrapper));\n\n  if ((wrapper == NULL) || (*wrapper == '\\0'))\n    return NULL;\n\n  /* Absolute path? */\n#if defined HAVE_DOS_BASED_FILE_SYSTEM\n  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')\n    {\n      concat_name = xstrdup (wrapper);\n      if (check_executable (concat_name))\n\treturn concat_name;\n      XFREE (concat_name);\n    }\n  else\n    {\n#endif\n      if (IS_DIR_SEPARATOR (wrapper[0]))\n\t{\n\t  concat_name = xstrdup (wrapper);\n\t  if (check_executable (concat_name))\n\t    return concat_name;\n\t  XFREE (concat_name);\n\t}\n#if defined HAVE_DOS_BASED_FILE_SYSTEM\n    }\n#endif\n\n  for (p = wrapper; *p; p++)\n    if (*p == '/')\n      {\n\thas_slash = 1;\n\tbreak;\n      }\n  if (!has_slash)\n    {\n      /* no slashes; search PATH */\n      const char *path = getenv (\"PATH\");\n      if (path != NULL)\n\t{\n\t  for (p = path; *p; p = p_next)\n\t    {\n\t      const char *q;\n\t      size_t p_len;\n\t      for (q = p; *q; q++)\n\t\tif (IS_PATH_SEPARATOR (*q))\n\t\t  break;\n\t      p_len = (size_t) (q - p);\n\t      p_next = (*q == '\\0' ? q : q + 1);\n\t      if (p_len == 0)\n\t\t{\n\t\t  /* empty path: current directory */\n\t\t  if (getcwd (tmp, LT_PATHMAX) == NULL)\n\t\t    lt_fatal (__FILE__, __LINE__, \"getcwd failed: %s\",\n                              nonnull (strerror (errno)));\n\t\t  tmp_len = strlen (tmp);\n\t\t  concat_name =\n\t\t    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, tmp, tmp_len);\n\t\t  concat_name[tmp_len] = '/';\n\t\t  strcpy (concat_name + tmp_len + 1, wrapper);\n\t\t}\n\t      else\n\t\t{\n\t\t  concat_name =\n\t\t    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, p, p_len);\n\t\t  concat_name[p_len] = '/';\n\t\t  strcpy (concat_name + p_len + 1, wrapper);\n\t\t}\n\t      if (check_executable (concat_name))\n\t\treturn concat_name;\n\t      XFREE (concat_name);\n\t    }\n\t}\n      /* not found in PATH; assume curdir */\n    }\n  /* Relative path | not found in path: prepend cwd */\n  if (getcwd (tmp, LT_PATHMAX) == NULL)\n    lt_fatal (__FILE__, __LINE__, \"getcwd failed: %s\",\n              nonnull (strerror (errno)));\n  tmp_len = strlen (tmp);\n  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n  memcpy (concat_name, tmp, tmp_len);\n  concat_name[tmp_len] = '/';\n  strcpy (concat_name + tmp_len + 1, wrapper);\n\n  if (check_executable (concat_name))\n    return concat_name;\n  XFREE (concat_name);\n  return NULL;\n}\n\nchar *\nchase_symlinks (const char *pathspec)\n{\n#ifndef S_ISLNK\n  return xstrdup (pathspec);\n#else\n  char buf[LT_PATHMAX];\n  struct stat s;\n  char *tmp_pathspec = xstrdup (pathspec);\n  char *p;\n  int has_symlinks = 0;\n  while (strlen (tmp_pathspec) && !has_symlinks)\n    {\n      lt_debugprintf (__FILE__, __LINE__,\n\t\t      \"checking path component for symlinks: %s\\n\",\n\t\t      tmp_pathspec);\n      if (lstat (tmp_pathspec, &s) == 0)\n\t{\n\t  if (S_ISLNK (s.st_mode) != 0)\n\t    {\n\t      has_symlinks = 1;\n\t      break;\n\t    }\n\n\t  /* search backwards for last DIR_SEPARATOR */\n\t  p = tmp_pathspec + strlen (tmp_pathspec) - 1;\n\t  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    p--;\n\t  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    {\n\t      /* no more DIR_SEPARATORS left */\n\t      break;\n\t    }\n\t  *p = '\\0';\n\t}\n      else\n\t{\n\t  lt_fatal (__FILE__, __LINE__,\n\t\t    \"error accessing file \\\"%s\\\": %s\",\n\t\t    tmp_pathspec, nonnull (strerror (errno)));\n\t}\n    }\n  XFREE (tmp_pathspec);\n\n  if (!has_symlinks)\n    {\n      return xstrdup (pathspec);\n    }\n\n  tmp_pathspec = realpath (pathspec, buf);\n  if (tmp_pathspec == 0)\n    {\n      lt_fatal (__FILE__, __LINE__,\n\t\t\"could not follow symlinks for %s\", pathspec);\n    }\n  return xstrdup (tmp_pathspec);\n#endif\n}\n\nchar *\nstrendzap (char *str, const char *pat)\n{\n  size_t len, patlen;\n\n  assert (str != NULL);\n  assert (pat != NULL);\n\n  len = strlen (str);\n  patlen = strlen (pat);\n\n  if (patlen <= len)\n    {\n      str += len - patlen;\n      if (STREQ (str, pat))\n\t*str = '\\0';\n    }\n  return str;\n}\n\nvoid\nlt_debugprintf (const char *file, int line, const char *fmt, ...)\n{\n  va_list args;\n  if (lt_debug)\n    {\n      (void) fprintf (stderr, \"%s:%s:%d: \", program_name, file, line);\n      va_start (args, fmt);\n      (void) vfprintf (stderr, fmt, args);\n      va_end (args);\n    }\n}\n\nstatic void\nlt_error_core (int exit_status, const char *file,\n\t       int line, const char *mode,\n\t       const char *message, va_list ap)\n{\n  fprintf (stderr, \"%s:%s:%d: %s: \", program_name, file, line, mode);\n  vfprintf (stderr, message, ap);\n  fprintf (stderr, \".\\n\");\n\n  if (exit_status >= 0)\n    exit (exit_status);\n}\n\nvoid\nlt_fatal (const char *file, int line, const char *message, ...)\n{\n  va_list ap;\n  va_start (ap, message);\n  lt_error_core (EXIT_FAILURE, file, line, \"FATAL\", message, ap);\n  va_end (ap);\n}\n\nstatic const char *\nnonnull (const char *s)\n{\n  return s ? s : \"(null)\";\n}\n\nstatic const char *\nnonempty (const char *s)\n{\n  return (s && !*s) ? \"(empty)\" : nonnull (s);\n}\n\nvoid\nlt_setenv (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_setenv) setting '%s' to '%s'\\n\",\n                  nonnull (name), nonnull (value));\n  {\n#ifdef HAVE_SETENV\n    /* always make a copy, for consistency with !HAVE_SETENV */\n    char *str = xstrdup (value);\n    setenv (name, str, 1);\n#else\n    size_t len = strlen (name) + 1 + strlen (value) + 1;\n    char *str = XMALLOC (char, len);\n    sprintf (str, \"%s=%s\", name, value);\n    if (putenv (str) != EXIT_SUCCESS)\n      {\n        XFREE (str);\n      }\n#endif\n  }\n}\n\nchar *\nlt_extend_str (const char *orig_value, const char *add, int to_end)\n{\n  char *new_value;\n  if (orig_value && *orig_value)\n    {\n      size_t orig_value_len = strlen (orig_value);\n      size_t add_len = strlen (add);\n      new_value = XMALLOC (char, add_len + orig_value_len + 1);\n      if (to_end)\n        {\n          strcpy (new_value, orig_value);\n          strcpy (new_value + orig_value_len, add);\n        }\n      else\n        {\n          strcpy (new_value, add);\n          strcpy (new_value + add_len, orig_value);\n        }\n    }\n  else\n    {\n      new_value = xstrdup (add);\n    }\n  return new_value;\n}\n\nvoid\nlt_update_exe_path (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_update_exe_path) modifying '%s' by prepending '%s'\\n\",\n                  nonnull (name), nonnull (value));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      /* some systems can't cope with a ':'-terminated path #' */\n      size_t len = strlen (new_value);\n      while ((len > 0) && IS_PATH_SEPARATOR (new_value[len-1]))\n        {\n          new_value[--len] = '\\0';\n        }\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nvoid\nlt_update_lib_path (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_update_lib_path) modifying '%s' by prepending '%s'\\n\",\n                  nonnull (name), nonnull (value));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nEOF\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n\n/* Prepares an argument vector before calling spawn().\n   Note that spawn() does not by itself call the command interpreter\n     (getenv (\"COMSPEC\") != NULL ? getenv (\"COMSPEC\") :\n      ({ OSVERSIONINFO v; v.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n         GetVersionEx(&v);\n         v.dwPlatformId == VER_PLATFORM_WIN32_NT;\n      }) ? \"cmd.exe\" : \"command.com\").\n   Instead it simply concatenates the arguments, separated by ' ', and calls\n   CreateProcess().  We must quote the arguments since Win32 CreateProcess()\n   interprets characters like ' ', '\\t', '\\\\', '\"' (but not '<' and '>') in a\n   special way:\n   - Space and tab are interpreted as delimiters. They are not treated as\n     delimiters if they are surrounded by double quotes: \"...\".\n   - Unescaped double quotes are removed from the input. Their only effect is\n     that within double quotes, space and tab are treated like normal\n     characters.\n   - Backslashes not followed by double quotes are not special.\n   - But 2*n+1 backslashes followed by a double quote become\n     n backslashes followed by a double quote (n >= 0):\n       \\\" -> \"\n       \\\\\\\" -> \\\"\n       \\\\\\\\\\\" -> \\\\\"\n */\n#define SHELL_SPECIAL_CHARS \"\\\"\\\\ \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\n#define SHELL_SPACE_CHARS \" \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\nchar **\nprepare_spawn (char **argv)\n{\n  size_t argc;\n  char **new_argv;\n  size_t i;\n\n  /* Count number of arguments.  */\n  for (argc = 0; argv[argc] != NULL; argc++)\n    ;\n\n  /* Allocate new argument vector.  */\n  new_argv = XMALLOC (char *, argc + 1);\n\n  /* Put quoted arguments into the new argument vector.  */\n  for (i = 0; i < argc; i++)\n    {\n      const char *string = argv[i];\n\n      if (string[0] == '\\0')\n\tnew_argv[i] = xstrdup (\"\\\"\\\"\");\n      else if (strpbrk (string, SHELL_SPECIAL_CHARS) != NULL)\n\t{\n\t  int quote_around = (strpbrk (string, SHELL_SPACE_CHARS) != NULL);\n\t  size_t length;\n\t  unsigned int backslashes;\n\t  const char *s;\n\t  char *quoted_string;\n\t  char *p;\n\n\t  length = 0;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    length++;\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\tlength += backslashes + 1;\n\t      length++;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    length += backslashes + 1;\n\n\t  quoted_string = XMALLOC (char, length + 1);\n\n\t  p = quoted_string;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    *p++ = '\"';\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\t{\n\t\t  unsigned int j;\n\t\t  for (j = backslashes + 1; j > 0; j--)\n\t\t    *p++ = '\\\\';\n\t\t}\n\t      *p++ = c;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    {\n\t      unsigned int j;\n\t      for (j = backslashes; j > 0; j--)\n\t\t*p++ = '\\\\';\n\t      *p++ = '\"';\n\t    }\n\t  *p = '\\0';\n\n\t  new_argv[i] = quoted_string;\n\t}\n      else\n\tnew_argv[i] = (char *) string;\n    }\n  new_argv[argc] = NULL;\n\n  return new_argv;\n}\nEOF\n\t\t;;\n\t    esac\n\n            cat <<\"EOF\"\nvoid lt_dump_script (FILE* f)\n{\nEOF\n\t    func_emit_wrapper yes |\n\t      $SED -n -e '\ns/^\\(.\\{79\\}\\)\\(..*\\)/\\1\\\n\\2/\nh\ns/\\([\\\\\"]\\)/\\\\\\1/g\ns/$/\\\\n/\ns/\\([^\\n]*\\).*/  fputs (\"\\1\", f);/p\ng\nD'\n            cat <<\"EOF\"\n}\nEOF\n}\n# end: func_emit_cwrapperexe_src\n\n# func_win32_import_lib_p ARG\n# True if ARG is an import lib, as indicated by $file_magic_cmd\nfunc_win32_import_lib_p ()\n{\n    $debug_cmd\n\n    case `eval $file_magic_cmd \\\"\\$1\\\" 2>/dev/null | $SED -e 10q` in\n    *import*) : ;;\n    *) false ;;\n    esac\n}\n\n# func_suncc_cstd_abi\n# !!ONLY CALL THIS FOR SUN CC AFTER $compile_command IS FULLY EXPANDED!!\n# Several compiler flags select an ABI that is incompatible with the\n# Cstd library. Avoid specifying it if any are in CXXFLAGS.\nfunc_suncc_cstd_abi ()\n{\n    $debug_cmd\n\n    case \" $compile_command \" in\n    *\" -compat=g \"*|*\\ -std=c++[0-9][0-9]\\ *|*\" -library=stdcxx4 \"*|*\" -library=stlport4 \"*)\n      suncc_use_cstd_abi=no\n      ;;\n    *)\n      suncc_use_cstd_abi=yes\n      ;;\n    esac\n}\n\n# func_mode_link arg...\nfunc_mode_link ()\n{\n    $debug_cmd\n\n    case $host in\n    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n      # It is impossible to link a dll without this setting, and\n      # we shouldn't force the makefile maintainer to figure out\n      # what system we are compiling for in order to pass an extra\n      # flag for every libtool invocation.\n      # allow_undefined=no\n\n      # FIXME: Unfortunately, there are problems with the above when trying\n      # to make a dll that has undefined symbols, in which case not\n      # even a static library is built.  For now, we need to specify\n      # -no-undefined on the libtool link line when we can be certain\n      # that all symbols are satisfied, otherwise we get a static library.\n      allow_undefined=yes\n      ;;\n    *)\n      allow_undefined=yes\n      ;;\n    esac\n    libtool_args=$nonopt\n    base_compile=\"$nonopt $@\"\n    compile_command=$nonopt\n    finalize_command=$nonopt\n\n    compile_rpath=\n    finalize_rpath=\n    compile_shlibpath=\n    finalize_shlibpath=\n    convenience=\n    old_convenience=\n    deplibs=\n    old_deplibs=\n    compiler_flags=\n    linker_flags=\n    dllsearchpath=\n    lib_search_path=`pwd`\n    inst_prefix_dir=\n    new_inherited_linker_flags=\n\n    avoid_version=no\n    bindir=\n    dlfiles=\n    dlprefiles=\n    dlself=no\n    export_dynamic=no\n    export_symbols=\n    export_symbols_regex=\n    generated=\n    libobjs=\n    ltlibs=\n    module=no\n    no_install=no\n    objs=\n    os2dllname=\n    non_pic_objects=\n    precious_files_regex=\n    prefer_static_libs=no\n    preload=false\n    prev=\n    prevarg=\n    release=\n    rpath=\n    xrpath=\n    perm_rpath=\n    temp_rpath=\n    thread_safe=no\n    vinfo=\n    vinfo_number=no\n    weak_libs=\n    single_module=$wl-single_module\n    func_infer_tag $base_compile\n\n    # We need to know -static, to get the right output filenames.\n    for arg\n    do\n      case $arg in\n      -shared)\n\ttest yes != \"$build_libtool_libs\" \\\n\t  && func_fatal_configuration \"cannot build a shared library\"\n\tbuild_old_libs=no\n\tbreak\n\t;;\n      -all-static | -static | -static-libtool-libs)\n\tcase $arg in\n\t-all-static)\n\t  if test yes = \"$build_libtool_libs\" && test -z \"$link_static_flag\"; then\n\t    func_warning \"complete static linking is impossible in this configuration\"\n\t  fi\n\t  if test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\t-static)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=built\n\t  ;;\n\t-static-libtool-libs)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\tesac\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tbreak\n\t;;\n      esac\n    done\n\n    # See if our shared archives depend on static archives.\n    test -n \"$old_archive_from_new_cmds\" && build_old_libs=yes\n\n    # Go through the arguments, transforming them on the way.\n    while test \"$#\" -gt 0; do\n      arg=$1\n      shift\n      func_quote_for_eval \"$arg\"\n      qarg=$func_quote_for_eval_unquoted_result\n      func_append libtool_args \" $func_quote_for_eval_result\"\n\n      # If the previous option needs an argument, assign it.\n      if test -n \"$prev\"; then\n\tcase $prev in\n\toutput)\n\t  func_append compile_command \" @OUTPUT@\"\n\t  func_append finalize_command \" @OUTPUT@\"\n\t  ;;\n\tesac\n\n\tcase $prev in\n\tbindir)\n\t  bindir=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\tdlfiles|dlprefiles)\n\t  $preload || {\n\t    # Add the symbol object into the linking commands.\n\t    func_append compile_command \" @SYMFILE@\"\n\t    func_append finalize_command \" @SYMFILE@\"\n\t    preload=:\n\t  }\n\t  case $arg in\n\t  *.la | *.lo) ;;  # We handle these cases below.\n\t  force)\n\t    if test no = \"$dlself\"; then\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  self)\n\t    if test dlprefiles = \"$prev\"; then\n\t      dlself=yes\n\t    elif test dlfiles = \"$prev\" && test yes != \"$dlopen_self\"; then\n\t      dlself=yes\n\t    else\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  *)\n\t    if test dlfiles = \"$prev\"; then\n\t      func_append dlfiles \" $arg\"\n\t    else\n\t      func_append dlprefiles \" $arg\"\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  esac\n\t  ;;\n\texpsyms)\n\t  export_symbols=$arg\n\t  test -f \"$arg\" \\\n\t    || func_fatal_error \"symbol file '$arg' does not exist\"\n\t  prev=\n\t  continue\n\t  ;;\n\texpsyms_regex)\n\t  export_symbols_regex=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\tframework)\n\t  case $host in\n\t    *-*-darwin*)\n\t      case \"$deplibs \" in\n\t\t*\" $qarg.ltframework \"*) ;;\n\t\t*) func_append deplibs \" $qarg.ltframework\" # this is fixed later\n\t\t   ;;\n\t      esac\n\t      ;;\n\t  esac\n\t  prev=\n\t  continue\n\t  ;;\n\tinst_prefix)\n\t  inst_prefix_dir=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\tmllvm)\n\t  # Clang does not use LLVM to link, so we can simply discard any\n\t  # '-mllvm $arg' options when doing the link step.\n\t  prev=\n\t  continue\n\t  ;;\n\tobjectlist)\n\t  if test -f \"$arg\"; then\n\t    save_arg=$arg\n\t    moreargs=\n\t    for fil in `cat \"$save_arg\"`\n\t    do\n#\t      func_append moreargs \" $fil\"\n\t      arg=$fil\n\t      # A libtool-controlled object.\n\n\t      # Check to see that this really is a libtool object.\n\t      if func_lalib_unsafe_p \"$arg\"; then\n\t\tpic_object=\n\t\tnon_pic_object=\n\n\t\t# Read the .lo file\n\t\tfunc_source \"$arg\"\n\n\t\tif test -z \"$pic_object\" ||\n\t\t   test -z \"$non_pic_object\" ||\n\t\t   test none = \"$pic_object\" &&\n\t\t   test none = \"$non_pic_object\"; then\n\t\t  func_fatal_error \"cannot find name of object for '$arg'\"\n\t\tfi\n\n\t\t# Extract subdirectory from the argument.\n\t\tfunc_dirname \"$arg\" \"/\" \"\"\n\t\txdir=$func_dirname_result\n\n\t\tif test none != \"$pic_object\"; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  pic_object=$xdir$pic_object\n\n\t\t  if test dlfiles = \"$prev\"; then\n\t\t    if test yes = \"$build_libtool_libs\" && test yes = \"$dlopen_support\"; then\n\t\t      func_append dlfiles \" $pic_object\"\n\t\t      prev=\n\t\t      continue\n\t\t    else\n\t\t      # If libtool objects are unsupported, then we need to preload.\n\t\t      prev=dlprefiles\n\t\t    fi\n\t\t  fi\n\n\t\t  # CHECK ME:  I think I busted this.  -Ossama\n\t\t  if test dlprefiles = \"$prev\"; then\n\t\t    # Preload the old-style object.\n\t\t    func_append dlprefiles \" $pic_object\"\n\t\t    prev=\n\t\t  fi\n\n\t\t  # A PIC object.\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  arg=$pic_object\n\t\tfi\n\n\t\t# Non-PIC object.\n\t\tif test none != \"$non_pic_object\"; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  non_pic_object=$xdir$non_pic_object\n\n\t\t  # A standard non-PIC object\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\t  if test -z \"$pic_object\" || test none = \"$pic_object\"; then\n\t\t    arg=$non_pic_object\n\t\t  fi\n\t\telse\n\t\t  # If the PIC object exists, use it instead.\n\t\t  # $xdir was prepended to $pic_object above.\n\t\t  non_pic_object=$pic_object\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\tfi\n\t      else\n\t\t# Only an error if not doing a dry-run.\n\t\tif $opt_dry_run; then\n\t\t  # Extract subdirectory from the argument.\n\t\t  func_dirname \"$arg\" \"/\" \"\"\n\t\t  xdir=$func_dirname_result\n\n\t\t  func_lo2o \"$arg\"\n\t\t  pic_object=$xdir$objdir/$func_lo2o_result\n\t\t  non_pic_object=$xdir$func_lo2o_result\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t        else\n\t\t  func_fatal_error \"'$arg' is not a valid libtool object\"\n\t\tfi\n\t      fi\n\t    done\n\t  else\n\t    func_fatal_error \"link input file '$arg' does not exist\"\n\t  fi\n\t  arg=$save_arg\n\t  prev=\n\t  continue\n\t  ;;\n\tos2dllname)\n\t  os2dllname=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\tprecious_regex)\n\t  precious_files_regex=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\trelease)\n\t  release=-$arg\n\t  prev=\n\t  continue\n\t  ;;\n\trpath | xrpath)\n\t  # We need an absolute path.\n\t  case $arg in\n\t  [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t  *)\n\t    func_fatal_error \"only absolute run-paths are allowed\"\n\t    ;;\n\t  esac\n\t  if test rpath = \"$prev\"; then\n\t    case \"$rpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) func_append rpath \" $arg\" ;;\n\t    esac\n\t  else\n\t    case \"$xrpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) func_append xrpath \" $arg\" ;;\n\t    esac\n\t  fi\n\t  prev=\n\t  continue\n\t  ;;\n\tshrext)\n\t  shrext_cmds=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\tweak)\n\t  func_append weak_libs \" $arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\txcclinker)\n\t  func_append linker_flags \" $qarg\"\n\t  func_append compiler_flags \" $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txcompiler)\n\t  func_append compiler_flags \" $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txlinker)\n\t  func_append linker_flags \" $qarg\"\n\t  func_append compiler_flags \" $wl$qarg\"\n\t  prev=\n\t  func_append compile_command \" $wl$qarg\"\n\t  func_append finalize_command \" $wl$qarg\"\n\t  continue\n\t  ;;\n\t*)\n\t  eval \"$prev=\\\"\\$arg\\\"\"\n\t  prev=\n\t  continue\n\t  ;;\n\tesac\n      fi # test -n \"$prev\"\n\n      prevarg=$arg\n\n      case $arg in\n      -all-static)\n\tif test -n \"$link_static_flag\"; then\n\t  # See comment for -static flag below, for more details.\n\t  func_append compile_command \" $link_static_flag\"\n\t  func_append finalize_command \" $link_static_flag\"\n\tfi\n\tcontinue\n\t;;\n\n      -allow-undefined)\n\t# FIXME: remove this flag sometime in the future.\n\tfunc_fatal_error \"'-allow-undefined' must not be used because it is the default\"\n\t;;\n\n      -avoid-version)\n\tavoid_version=yes\n\tcontinue\n\t;;\n\n      -bindir)\n\tprev=bindir\n\tcontinue\n\t;;\n\n      -dlopen)\n\tprev=dlfiles\n\tcontinue\n\t;;\n\n      -dlpreopen)\n\tprev=dlprefiles\n\tcontinue\n\t;;\n\n      -export-dynamic)\n\texport_dynamic=yes\n\tcontinue\n\t;;\n\n      -export-symbols | -export-symbols-regex)\n\tif test -n \"$export_symbols\" || test -n \"$export_symbols_regex\"; then\n\t  func_fatal_error \"more than one -exported-symbols argument is not allowed\"\n\tfi\n\tif test X-export-symbols = \"X$arg\"; then\n\t  prev=expsyms\n\telse\n\t  prev=expsyms_regex\n\tfi\n\tcontinue\n\t;;\n\n      -framework)\n\tprev=framework\n\tcontinue\n\t;;\n\n      -inst-prefix-dir)\n\tprev=inst_prefix\n\tcontinue\n\t;;\n\n      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*\n      # so, if we see these flags be careful not to treat them like -L\n      -L[A-Z][A-Z]*:*)\n\tcase $with_gcc/$host in\n\tno/*-*-irix* | /*-*-irix*)\n\t  func_append compile_command \" $arg\"\n\t  func_append finalize_command \" $arg\"\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -L*)\n\tfunc_stripname \"-L\" '' \"$arg\"\n\tif test -z \"$func_stripname_result\"; then\n\t  if test \"$#\" -gt 0; then\n\t    func_fatal_error \"require no space between '-L' and '$1'\"\n\t  else\n\t    func_fatal_error \"need path for '-L' option\"\n\t  fi\n\tfi\n\tfunc_resolve_sysroot \"$func_stripname_result\"\n\tdir=$func_resolve_sysroot_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  absdir=`cd \"$dir\" && pwd`\n\t  test -z \"$absdir\" && \\\n\t    func_fatal_error \"cannot determine absolute directory name of '$dir'\"\n\t  dir=$absdir\n\t  ;;\n\tesac\n\tcase \"$deplibs \" in\n\t*\" -L$dir \"* | *\" $arg \"*)\n\t  # Will only happen for absolute or sysroot arguments\n\t  ;;\n\t*)\n\t  # Preserve sysroot, but never include relative directories\n\t  case $dir in\n\t    [\\\\/]* | [A-Za-z]:[\\\\/]* | =*) func_append deplibs \" $arg\" ;;\n\t    *) func_append deplibs \" -L$dir\" ;;\n\t  esac\n\t  func_append lib_search_path \" $dir\"\n\t  ;;\n\tesac\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`$ECHO \"$dir\" | $SED 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$dir:\"*) ;;\n\t  ::) dllsearchpath=$dir;;\n\t  *) func_append dllsearchpath \":$dir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) func_append dllsearchpath \":$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -l*)\n\tif test X-lc = \"X$arg\" || test X-lm = \"X$arg\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # These systems don't actually have a C or math library (as such)\n\t    continue\n\t    ;;\n\t  *-*-os2*)\n\t    # These systems don't actually have a C library (as such)\n\t    test X-lc = \"X$arg\" && continue\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly* | *-*-bitrig*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    test X-lc = \"X$arg\" && continue\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C and math libraries are in the System framework\n\t    func_append deplibs \" System.ltframework\"\n\t    continue\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    test X-lc = \"X$arg\" && continue\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    test X-lc = \"X$arg\" && continue\n\t    ;;\n\t  esac\n\telif test X-lc_r = \"X$arg\"; then\n\t case $host in\n\t *-*-openbsd* | *-*-freebsd* | *-*-dragonfly* | *-*-bitrig*)\n\t   # Do not include libc_r directly, use -pthread flag.\n\t   continue\n\t   ;;\n\t esac\n\tfi\n\tfunc_append deplibs \" $arg\"\n\tcontinue\n\t;;\n\n      -mllvm)\n\tprev=mllvm\n\tcontinue\n\t;;\n\n      -module)\n\tmodule=yes\n\tcontinue\n\t;;\n\n      # Tru64 UNIX uses -model [arg] to determine the layout of C++\n      # classes, name mangling, and exception handling.\n      # Darwin uses the -arch flag to determine output architecture.\n      -model|-arch|-isysroot|--sysroot)\n\tfunc_append compiler_flags \" $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \\\n      |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)\n\tfunc_append compiler_flags \" $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tcase \"$new_inherited_linker_flags \" in\n\t    *\" $arg \"*) ;;\n\t    * ) func_append new_inherited_linker_flags \" $arg\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -multi_module)\n\tsingle_module=$wl-multi_module\n\tcontinue\n\t;;\n\n      -no-fast-install)\n\tfast_install=no\n\tcontinue\n\t;;\n\n      -no-install)\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)\n\t  # The PATH hackery in wrapper scripts is required on Windows\n\t  # and Darwin in order for the loader to find any dlls it needs.\n\t  func_warning \"'-no-install' is ignored for $host\"\n\t  func_warning \"assuming '-no-fast-install' instead\"\n\t  fast_install=no\n\t  ;;\n\t*) no_install=yes ;;\n\tesac\n\tcontinue\n\t;;\n\n      -no-undefined)\n\tallow_undefined=no\n\tcontinue\n\t;;\n\n      -objectlist)\n\tprev=objectlist\n\tcontinue\n\t;;\n\n      -os2dllname)\n\tprev=os2dllname\n\tcontinue\n\t;;\n\n      -o) prev=output ;;\n\n      -precious-files-regex)\n\tprev=precious_regex\n\tcontinue\n\t;;\n\n      -release)\n\tprev=release\n\tcontinue\n\t;;\n\n      -rpath)\n\tprev=rpath\n\tcontinue\n\t;;\n\n      -R)\n\tprev=xrpath\n\tcontinue\n\t;;\n\n      -R*)\n\tfunc_stripname '-R' '' \"$arg\"\n\tdir=$func_stripname_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t=*)\n\t  func_stripname '=' '' \"$dir\"\n\t  dir=$lt_sysroot$func_stripname_result\n\t  ;;\n\t*)\n\t  func_fatal_error \"only absolute run-paths are allowed\"\n\t  ;;\n\tesac\n\tcase \"$xrpath \" in\n\t*\" $dir \"*) ;;\n\t*) func_append xrpath \" $dir\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -shared)\n\t# The effects of -shared are defined in a previous loop.\n\tcontinue\n\t;;\n\n      -shrext)\n\tprev=shrext\n\tcontinue\n\t;;\n\n      -static | -static-libtool-libs)\n\t# The effects of -static are defined in a previous loop.\n\t# We used to do the same as -all-static on platforms that\n\t# didn't have a PIC flag, but the assumption that the effects\n\t# would be equivalent was wrong.  It would break on at least\n\t# Digital Unix and AIX.\n\tcontinue\n\t;;\n\n      -thread-safe)\n\tthread_safe=yes\n\tcontinue\n\t;;\n\n      -version-info)\n\tprev=vinfo\n\tcontinue\n\t;;\n\n      -version-number)\n\tprev=vinfo\n\tvinfo_number=yes\n\tcontinue\n\t;;\n\n      -weak)\n        prev=weak\n\tcontinue\n\t;;\n\n      -Wc,*)\n\tfunc_stripname '-Wc,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=$IFS; IFS=,\n\tfor flag in $args; do\n\t  IFS=$save_ifs\n          func_quote_for_eval \"$flag\"\n\t  func_append arg \" $func_quote_for_eval_result\"\n\t  func_append compiler_flags \" $func_quote_for_eval_result\"\n\tdone\n\tIFS=$save_ifs\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Wl,*)\n\tfunc_stripname '-Wl,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=$IFS; IFS=,\n\tfor flag in $args; do\n\t  IFS=$save_ifs\n          func_quote_for_eval \"$flag\"\n\t  func_append arg \" $wl$func_quote_for_eval_result\"\n\t  func_append compiler_flags \" $wl$func_quote_for_eval_result\"\n\t  func_append linker_flags \" $func_quote_for_eval_result\"\n\tdone\n\tIFS=$save_ifs\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Xcompiler)\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -Xlinker)\n\tprev=xlinker\n\tcontinue\n\t;;\n\n      -XCClinker)\n\tprev=xcclinker\n\tcontinue\n\t;;\n\n      # -msg_* for osf cc\n      -msg_*)\n\tfunc_quote_for_eval \"$arg\"\n\targ=$func_quote_for_eval_result\n\t;;\n\n      # Flags to be passed through unchanged, with rationale:\n      # -64, -mips[0-9]      enable 64-bit mode for the SGI compiler\n      # -r[0-9][0-9]*        specify processor for the SGI compiler\n      # -xarch=*, -xtarget=* enable 64-bit mode for the Sun compiler\n      # +DA*, +DD*           enable 64-bit mode for the HP compiler\n      # -q*                  compiler args for the IBM compiler\n      # -m*, -t[45]*, -txscale* architecture-specific flags for GCC\n      # -F/path              path to uninstalled frameworks, gcc on darwin\n      # -p, -pg, --coverage, -fprofile-*  profiling flags for GCC\n      # -fstack-protector*   stack protector flags for GCC\n      # @file                GCC response files\n      # -tp=*                Portland pgcc target processor selection\n      # --sysroot=*          for sysroot support\n      # -O*, -g*, -flto*, -fwhopr*, -fuse-linker-plugin GCC link-time optimization\n      # -specs=*             GCC specs files\n      # -stdlib=*            select c++ std lib with clang\n      # -fsanitize=*         Clang/GCC memory and address sanitizer\n      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \\\n      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*|-tp=*|--sysroot=*| \\\n      -O*|-g*|-flto*|-fwhopr*|-fuse-linker-plugin|-fstack-protector*|-stdlib=*| \\\n      -specs=*|-fsanitize=*)\n        func_quote_for_eval \"$arg\"\n\targ=$func_quote_for_eval_result\n        func_append compile_command \" $arg\"\n        func_append finalize_command \" $arg\"\n        func_append compiler_flags \" $arg\"\n        continue\n        ;;\n\n      -Z*)\n        if test os2 = \"`expr $host : '.*\\(os2\\)'`\"; then\n          # OS/2 uses -Zxxx to specify OS/2-specific options\n\t  compiler_flags=\"$compiler_flags $arg\"\n\t  func_append compile_command \" $arg\"\n\t  func_append finalize_command \" $arg\"\n\t  case $arg in\n\t  -Zlinker | -Zstack)\n\t    prev=xcompiler\n\t    ;;\n\t  esac\n\t  continue\n        else\n\t  # Otherwise treat like 'Some other compiler flag' below\n\t  func_quote_for_eval \"$arg\"\n\t  arg=$func_quote_for_eval_result\n        fi\n\t;;\n\n      # Some other compiler flag.\n      -* | +*)\n        func_quote_for_eval \"$arg\"\n\targ=$func_quote_for_eval_result\n\t;;\n\n      *.$objext)\n\t# A standard object.\n\tfunc_append objs \" $arg\"\n\t;;\n\n      *.lo)\n\t# A libtool-controlled object.\n\n\t# Check to see that this really is a libtool object.\n\tif func_lalib_unsafe_p \"$arg\"; then\n\t  pic_object=\n\t  non_pic_object=\n\n\t  # Read the .lo file\n\t  func_source \"$arg\"\n\n\t  if test -z \"$pic_object\" ||\n\t     test -z \"$non_pic_object\" ||\n\t     test none = \"$pic_object\" &&\n\t     test none = \"$non_pic_object\"; then\n\t    func_fatal_error \"cannot find name of object for '$arg'\"\n\t  fi\n\n\t  # Extract subdirectory from the argument.\n\t  func_dirname \"$arg\" \"/\" \"\"\n\t  xdir=$func_dirname_result\n\n\t  test none = \"$pic_object\" || {\n\t    # Prepend the subdirectory the object is found in.\n\t    pic_object=$xdir$pic_object\n\n\t    if test dlfiles = \"$prev\"; then\n\t      if test yes = \"$build_libtool_libs\" && test yes = \"$dlopen_support\"; then\n\t\tfunc_append dlfiles \" $pic_object\"\n\t\tprev=\n\t\tcontinue\n\t      else\n\t\t# If libtool objects are unsupported, then we need to preload.\n\t\tprev=dlprefiles\n\t      fi\n\t    fi\n\n\t    # CHECK ME:  I think I busted this.  -Ossama\n\t    if test dlprefiles = \"$prev\"; then\n\t      # Preload the old-style object.\n\t      func_append dlprefiles \" $pic_object\"\n\t      prev=\n\t    fi\n\n\t    # A PIC object.\n\t    func_append libobjs \" $pic_object\"\n\t    arg=$pic_object\n\t  }\n\n\t  # Non-PIC object.\n\t  if test none != \"$non_pic_object\"; then\n\t    # Prepend the subdirectory the object is found in.\n\t    non_pic_object=$xdir$non_pic_object\n\n\t    # A standard non-PIC object\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t    if test -z \"$pic_object\" || test none = \"$pic_object\"; then\n\t      arg=$non_pic_object\n\t    fi\n\t  else\n\t    # If the PIC object exists, use it instead.\n\t    # $xdir was prepended to $pic_object above.\n\t    non_pic_object=$pic_object\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  fi\n\telse\n\t  # Only an error if not doing a dry-run.\n\t  if $opt_dry_run; then\n\t    # Extract subdirectory from the argument.\n\t    func_dirname \"$arg\" \"/\" \"\"\n\t    xdir=$func_dirname_result\n\n\t    func_lo2o \"$arg\"\n\t    pic_object=$xdir$objdir/$func_lo2o_result\n\t    non_pic_object=$xdir$func_lo2o_result\n\t    func_append libobjs \" $pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  else\n\t    func_fatal_error \"'$arg' is not a valid libtool object\"\n\t  fi\n\tfi\n\t;;\n\n      *.$libext)\n\t# An archive.\n\tfunc_append deplibs \" $arg\"\n\tfunc_append old_deplibs \" $arg\"\n\tcontinue\n\t;;\n\n      *.la)\n\t# A libtool-controlled library.\n\n\tfunc_resolve_sysroot \"$arg\"\n\tif test dlfiles = \"$prev\"; then\n\t  # This library was specified with -dlopen.\n\t  func_append dlfiles \" $func_resolve_sysroot_result\"\n\t  prev=\n\telif test dlprefiles = \"$prev\"; then\n\t  # The library was specified with -dlpreopen.\n\t  func_append dlprefiles \" $func_resolve_sysroot_result\"\n\t  prev=\n\telse\n\t  func_append deplibs \" $func_resolve_sysroot_result\"\n\tfi\n\tcontinue\n\t;;\n\n      # Some other compiler argument.\n      *)\n\t# Unknown arguments in both finalize_command and compile_command need\n\t# to be aesthetically quoted because they are evaled later.\n\tfunc_quote_for_eval \"$arg\"\n\targ=$func_quote_for_eval_result\n\t;;\n      esac # arg\n\n      # Now actually substitute the argument into the commands.\n      if test -n \"$arg\"; then\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n      fi\n    done # argument parsing loop\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the '$prevarg' option requires an argument\"\n\n    if test yes = \"$export_dynamic\" && test -n \"$export_dynamic_flag_spec\"; then\n      eval arg=\\\"$export_dynamic_flag_spec\\\"\n      func_append compile_command \" $arg\"\n      func_append finalize_command \" $arg\"\n    fi\n\n    oldlibs=\n    # calculate the name of the file, without its directory\n    func_basename \"$output\"\n    outputname=$func_basename_result\n    libobjs_save=$libobjs\n\n    if test -n \"$shlibpath_var\"; then\n      # get the directories listed in $shlibpath_var\n      eval shlib_search_path=\\`\\$ECHO \\\"\\$$shlibpath_var\\\" \\| \\$SED \\'s/:/ /g\\'\\`\n    else\n      shlib_search_path=\n    fi\n    eval sys_lib_search_path=\\\"$sys_lib_search_path_spec\\\"\n    eval sys_lib_dlsearch_path=\\\"$sys_lib_dlsearch_path_spec\\\"\n\n    # Definition is injected by LT_CONFIG during libtool generation.\n    func_munge_path_list sys_lib_dlsearch_path \"$LT_SYS_LIBRARY_PATH\"\n\n    func_dirname \"$output\" \"/\" \"\"\n    output_objdir=$func_dirname_result$objdir\n    func_to_tool_file \"$output_objdir/\"\n    tool_output_objdir=$func_to_tool_file_result\n    # Create the object directory.\n    func_mkdir_p \"$output_objdir\"\n\n    # Determine the type of output\n    case $output in\n    \"\")\n      func_fatal_help \"you must specify an output file\"\n      ;;\n    *.$libext) linkmode=oldlib ;;\n    *.lo | *.$objext) linkmode=obj ;;\n    *.la) linkmode=lib ;;\n    *) linkmode=prog ;; # Anything else should be a program.\n    esac\n\n    specialdeplibs=\n\n    libs=\n    # Find all interdependent deplibs by searching for libraries\n    # that are linked more than once (e.g. -la -lb -la)\n    for deplib in $deplibs; do\n      if $opt_preserve_dup_deps; then\n\tcase \"$libs \" in\n\t*\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\tesac\n      fi\n      func_append libs \" $deplib\"\n    done\n\n    if test lib = \"$linkmode\"; then\n      libs=\"$predeps $libs $compiler_lib_search_path $postdeps\"\n\n      # Compute libraries that are listed more than once in $predeps\n      # $postdeps and mark them as special (i.e., whose duplicates are\n      # not to be eliminated).\n      pre_post_deps=\n      if $opt_duplicate_compiler_generated_deps; then\n\tfor pre_post_dep in $predeps $postdeps; do\n\t  case \"$pre_post_deps \" in\n\t  *\" $pre_post_dep \"*) func_append specialdeplibs \" $pre_post_deps\" ;;\n\t  esac\n\t  func_append pre_post_deps \" $pre_post_dep\"\n\tdone\n      fi\n      pre_post_deps=\n    fi\n\n    deplibs=\n    newdependency_libs=\n    newlib_search_path=\n    need_relink=no # whether we're linking any uninstalled libtool libraries\n    notinst_deplibs= # not-installed libtool libraries\n    notinst_path= # paths that contain not-installed libtool libraries\n\n    case $linkmode in\n    lib)\n\tpasses=\"conv dlpreopen link\"\n\tfor file in $dlfiles $dlprefiles; do\n\t  case $file in\n\t  *.la) ;;\n\t  *)\n\t    func_fatal_help \"libraries can '-dlopen' only libtool libraries: $file\"\n\t    ;;\n\t  esac\n\tdone\n\t;;\n    prog)\n\tcompile_deplibs=\n\tfinalize_deplibs=\n\talldeplibs=false\n\tnewdlfiles=\n\tnewdlprefiles=\n\tpasses=\"conv scan dlopen dlpreopen link\"\n\t;;\n    *)  passes=\"conv\"\n\t;;\n    esac\n\n    for pass in $passes; do\n      # The preopen pass in lib mode reverses $deplibs; put it back here\n      # so that -L comes before libs that need it for instance...\n      if test lib,link = \"$linkmode,$pass\"; then\n\t## FIXME: Find the place where the list is rebuilt in the wrong\n\t##        order, and fix it there properly\n        tmp_deplibs=\n\tfor deplib in $deplibs; do\n\t  tmp_deplibs=\"$deplib $tmp_deplibs\"\n\tdone\n\tdeplibs=$tmp_deplibs\n      fi\n\n      if test lib,link = \"$linkmode,$pass\" ||\n\t test prog,scan = \"$linkmode,$pass\"; then\n\tlibs=$deplibs\n\tdeplibs=\n      fi\n      if test prog = \"$linkmode\"; then\n\tcase $pass in\n\tdlopen) libs=$dlfiles ;;\n\tdlpreopen) libs=$dlprefiles ;;\n\tlink)\n\t  libs=\"$deplibs %DEPLIBS%\"\n\t  test \"X$link_all_deplibs\" != Xno && libs=\"$libs $dependency_libs\"\n\t  ;;\n\tesac\n      fi\n      if test lib,dlpreopen = \"$linkmode,$pass\"; then\n\t# Collect and forward deplibs of preopened libtool libs\n\tfor lib in $dlprefiles; do\n\t  # Ignore non-libtool-libs\n\t  dependency_libs=\n\t  func_resolve_sysroot \"$lib\"\n\t  case $lib in\n\t  *.la)\tfunc_source \"$func_resolve_sysroot_result\" ;;\n\t  esac\n\n\t  # Collect preopened libtool deplibs, except any this library\n\t  # has declared as weak libs\n\t  for deplib in $dependency_libs; do\n\t    func_basename \"$deplib\"\n            deplib_base=$func_basename_result\n\t    case \" $weak_libs \" in\n\t    *\" $deplib_base \"*) ;;\n\t    *) func_append deplibs \" $deplib\" ;;\n\t    esac\n\t  done\n\tdone\n\tlibs=$dlprefiles\n      fi\n      if test dlopen = \"$pass\"; then\n\t# Collect dlpreopened libraries\n\tsave_deplibs=$deplibs\n\tdeplibs=\n      fi\n\n      for deplib in $libs; do\n\tlib=\n\tfound=false\n\tcase $deplib in\n\t-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \\\n        |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)\n\t  if test prog,link = \"$linkmode,$pass\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    func_append compiler_flags \" $deplib\"\n\t    if test lib = \"$linkmode\"; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) func_append new_inherited_linker_flags \" $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-l*)\n\t  if test lib != \"$linkmode\" && test prog != \"$linkmode\"; then\n\t    func_warning \"'-l' is ignored for archives/objects\"\n\t    continue\n\t  fi\n\t  func_stripname '-l' '' \"$deplib\"\n\t  name=$func_stripname_result\n\t  if test lib = \"$linkmode\"; then\n\t    searchdirs=\"$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path\"\n\t  else\n\t    searchdirs=\"$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path\"\n\t  fi\n\t  for searchdir in $searchdirs; do\n\t    for search_ext in .la $std_shrext .so .a; do\n\t      # Search the libtool library\n\t      lib=$searchdir/lib$name$search_ext\n\t      if test -f \"$lib\"; then\n\t\tif test .la = \"$search_ext\"; then\n\t\t  found=:\n\t\telse\n\t\t  found=false\n\t\tfi\n\t\tbreak 2\n\t      fi\n\t    done\n\t  done\n\t  if $found; then\n\t    # deplib is a libtool library\n\t    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,\n\t    # We need to do some special things here, and not later.\n\t    if test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t      case \" $predeps $postdeps \" in\n\t      *\" $deplib \"*)\n\t\tif func_lalib_p \"$lib\"; then\n\t\t  library_names=\n\t\t  old_library=\n\t\t  func_source \"$lib\"\n\t\t  for l in $old_library $library_names; do\n\t\t    ll=$l\n\t\t  done\n\t\t  if test \"X$ll\" = \"X$old_library\"; then # only static version available\n\t\t    found=false\n\t\t    func_dirname \"$lib\" \"\" \".\"\n\t\t    ladir=$func_dirname_result\n\t\t    lib=$ladir/$old_library\n\t\t    if test prog,link = \"$linkmode,$pass\"; then\n\t\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t\t    else\n\t\t      deplibs=\"$deplib $deplibs\"\n\t\t      test lib = \"$linkmode\" && newdependency_libs=\"$deplib $newdependency_libs\"\n\t\t    fi\n\t\t    continue\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *) ;;\n\t      esac\n\t    fi\n\t  else\n\t    # deplib doesn't seem to be a libtool library\n\t    if test prog,link = \"$linkmode,$pass\"; then\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      deplibs=\"$deplib $deplibs\"\n\t      test lib = \"$linkmode\" && newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    continue\n\t  fi\n\t  ;; # -l\n\t*.ltframework)\n\t  if test prog,link = \"$linkmode,$pass\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$deplib $deplibs\"\n\t    if test lib = \"$linkmode\"; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) func_append new_inherited_linker_flags \" $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-L*)\n\t  case $linkmode in\n\t  lib)\n\t    deplibs=\"$deplib $deplibs\"\n\t    test conv = \"$pass\" && continue\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    func_stripname '-L' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t    ;;\n\t  prog)\n\t    if test conv = \"$pass\"; then\n\t      deplibs=\"$deplib $deplibs\"\n\t      continue\n\t    fi\n\t    if test scan = \"$pass\"; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    func_stripname '-L' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t    ;;\n\t  *)\n\t    func_warning \"'-L' is ignored for archives/objects\"\n\t    ;;\n\t  esac # linkmode\n\t  continue\n\t  ;; # -L\n\t-R*)\n\t  if test link = \"$pass\"; then\n\t    func_stripname '-R' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    dir=$func_resolve_sysroot_result\n\t    # Make sure the xrpath contains only unique directories.\n\t    case \"$xrpath \" in\n\t    *\" $dir \"*) ;;\n\t    *) func_append xrpath \" $dir\" ;;\n\t    esac\n\t  fi\n\t  deplibs=\"$deplib $deplibs\"\n\t  continue\n\t  ;;\n\t*.la)\n\t  func_resolve_sysroot \"$deplib\"\n\t  lib=$func_resolve_sysroot_result\n\t  ;;\n\t*.$libext)\n\t  if test conv = \"$pass\"; then\n\t    deplibs=\"$deplib $deplibs\"\n\t    continue\n\t  fi\n\t  case $linkmode in\n\t  lib)\n\t    # Linking convenience modules into shared libraries is allowed,\n\t    # but linking other static libraries is non-portable.\n\t    case \" $dlpreconveniencelibs \" in\n\t    *\" $deplib \"*) ;;\n\t    *)\n\t      valid_a_lib=false\n\t      case $deplibs_check_method in\n\t\tmatch_pattern*)\n\t\t  set dummy $deplibs_check_method; shift\n\t\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t\t  if eval \"\\$ECHO \\\"$deplib\\\"\" 2>/dev/null | $SED 10q \\\n\t\t    | $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t    valid_a_lib=:\n\t\t  fi\n\t\t;;\n\t\tpass_all)\n\t\t  valid_a_lib=:\n\t\t;;\n\t      esac\n\t      if $valid_a_lib; then\n\t\techo\n\t\t$ECHO \"*** Warning: Linking the shared library $output against the\"\n\t\t$ECHO \"*** static library $deplib is not portable!\"\n\t\tdeplibs=\"$deplib $deplibs\"\n\t      else\n\t\techo\n\t\t$ECHO \"*** Warning: Trying to link with static lib archive $deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because the file extensions .$libext of this argument makes me believe\"\n\t\techo \"*** that it is just a static archive that I should not use here.\"\n\t      fi\n\t      ;;\n\t    esac\n\t    continue\n\t    ;;\n\t  prog)\n\t    if test link != \"$pass\"; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    continue\n\t    ;;\n\t  esac # linkmode\n\t  ;; # *.$libext\n\t*.lo | *.$objext)\n\t  if test conv = \"$pass\"; then\n\t    deplibs=\"$deplib $deplibs\"\n\t  elif test prog = \"$linkmode\"; then\n\t    if test dlpreopen = \"$pass\" || test yes != \"$dlopen_support\" || test no = \"$build_libtool_libs\"; then\n\t      # If there is no dlopen support or we're linking statically,\n\t      # we need to preload.\n\t      func_append newdlprefiles \" $deplib\"\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      func_append newdlfiles \" $deplib\"\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t%DEPLIBS%)\n\t  alldeplibs=:\n\t  continue\n\t  ;;\n\tesac # case $deplib\n\n\t$found || test -f \"$lib\" \\\n\t  || func_fatal_error \"cannot find the library '$lib' or unhandled argument '$deplib'\"\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$lib\" \\\n\t  || func_fatal_error \"'$lib' is not a valid libtool archive\"\n\n\tfunc_dirname \"$lib\" \"\" \".\"\n\tladir=$func_dirname_result\n\n\tdlname=\n\tdlopen=\n\tdlpreopen=\n\tlibdir=\n\tlibrary_names=\n\told_library=\n\tinherited_linker_flags=\n\t# If the library was installed with an old release of libtool,\n\t# it will not redefine variables installed, or shouldnotlink\n\tinstalled=yes\n\tshouldnotlink=no\n\tavoidtemprpath=\n\n\n\t# Read the .la file\n\tfunc_source \"$lib\"\n\n\t# Convert \"-framework foo\" to \"foo.ltframework\"\n\tif test -n \"$inherited_linker_flags\"; then\n\t  tmp_inherited_linker_flags=`$ECHO \"$inherited_linker_flags\" | $SED 's/-framework \\([^ $]*\\)/\\1.ltframework/g'`\n\t  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do\n\t    case \" $new_inherited_linker_flags \" in\n\t      *\" $tmp_inherited_linker_flag \"*) ;;\n\t      *) func_append new_inherited_linker_flags \" $tmp_inherited_linker_flag\";;\n\t    esac\n\t  done\n\tfi\n\tdependency_libs=`$ECHO \" $dependency_libs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tif test lib,link = \"$linkmode,$pass\" ||\n\t   test prog,scan = \"$linkmode,$pass\" ||\n\t   { test prog != \"$linkmode\" && test lib != \"$linkmode\"; }; then\n\t  test -n \"$dlopen\" && func_append dlfiles \" $dlopen\"\n\t  test -n \"$dlpreopen\" && func_append dlprefiles \" $dlpreopen\"\n\tfi\n\n\tif test conv = \"$pass\"; then\n\t  # Only check for convenience libraries\n\t  deplibs=\"$lib $deplibs\"\n\t  if test -z \"$libdir\"; then\n\t    if test -z \"$old_library\"; then\n\t      func_fatal_error \"cannot find name of link library for '$lib'\"\n\t    fi\n\t    # It is a libtool convenience library, so add in its objects.\n\t    func_append convenience \" $ladir/$objdir/$old_library\"\n\t    func_append old_convenience \" $ladir/$objdir/$old_library\"\n\t    tmp_libs=\n\t    for deplib in $dependency_libs; do\n\t      deplibs=\"$deplib $deplibs\"\n\t      if $opt_preserve_dup_deps; then\n\t\tcase \"$tmp_libs \" in\n\t\t*\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\t\tesac\n\t      fi\n\t      func_append tmp_libs \" $deplib\"\n\t    done\n\t  elif test prog != \"$linkmode\" && test lib != \"$linkmode\"; then\n\t    func_fatal_error \"'$lib' is not a convenience library\"\n\t  fi\n\t  continue\n\tfi # $pass = conv\n\n\n\t# Get the name of the library we link against.\n\tlinklib=\n\tif test -n \"$old_library\" &&\n\t   { test yes = \"$prefer_static_libs\" ||\n\t     test built,no = \"$prefer_static_libs,$installed\"; }; then\n\t  linklib=$old_library\n\telse\n\t  for l in $old_library $library_names; do\n\t    linklib=$l\n\t  done\n\tfi\n\tif test -z \"$linklib\"; then\n\t  func_fatal_error \"cannot find name of link library for '$lib'\"\n\tfi\n\n\t# This library was specified with -dlopen.\n\tif test dlopen = \"$pass\"; then\n\t  test -z \"$libdir\" \\\n\t    && func_fatal_error \"cannot -dlopen a convenience library: '$lib'\"\n\t  if test -z \"$dlname\" ||\n\t     test yes != \"$dlopen_support\" ||\n\t     test no = \"$build_libtool_libs\"\n\t  then\n\t    # If there is no dlname, no dlopen support or we're linking\n\t    # statically, we need to preload.  We also need to preload any\n\t    # dependent libraries so libltdl's deplib preloader doesn't\n\t    # bomb out in the load deplibs phase.\n\t    func_append dlprefiles \" $lib $dependency_libs\"\n\t  else\n\t    func_append newdlfiles \" $lib\"\n\t  fi\n\t  continue\n\tfi # $pass = dlopen\n\n\t# We need an absolute path.\n\tcase $ladir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs_ladir=$ladir ;;\n\t*)\n\t  abs_ladir=`cd \"$ladir\" && pwd`\n\t  if test -z \"$abs_ladir\"; then\n\t    func_warning \"cannot determine absolute directory name of '$ladir'\"\n\t    func_warning \"passing it literally to the linker, although it might fail\"\n\t    abs_ladir=$ladir\n\t  fi\n\t  ;;\n\tesac\n\tfunc_basename \"$lib\"\n\tlaname=$func_basename_result\n\n\t# Find the relevant object directory and library name.\n\tif test yes = \"$installed\"; then\n\t  if test ! -f \"$lt_sysroot$libdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    func_warning \"library '$lib' was moved.\"\n\t    dir=$ladir\n\t    absdir=$abs_ladir\n\t    libdir=$abs_ladir\n\t  else\n\t    dir=$lt_sysroot$libdir\n\t    absdir=$lt_sysroot$libdir\n\t  fi\n\t  test yes = \"$hardcode_automatic\" && avoidtemprpath=yes\n\telse\n\t  if test ! -f \"$ladir/$objdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    dir=$ladir\n\t    absdir=$abs_ladir\n\t    # Remove this search path later\n\t    func_append notinst_path \" $abs_ladir\"\n\t  else\n\t    dir=$ladir/$objdir\n\t    absdir=$abs_ladir/$objdir\n\t    # Remove this search path later\n\t    func_append notinst_path \" $abs_ladir\"\n\t  fi\n\tfi # $installed = yes\n\tfunc_stripname 'lib' '.la' \"$laname\"\n\tname=$func_stripname_result\n\n\t# This library was specified with -dlpreopen.\n\tif test dlpreopen = \"$pass\"; then\n\t  if test -z \"$libdir\" && test prog = \"$linkmode\"; then\n\t    func_fatal_error \"only libraries may -dlpreopen a convenience library: '$lib'\"\n\t  fi\n\t  case $host in\n\t    # special handling for platforms with PE-DLLs.\n\t    *cygwin* | *mingw* | *cegcc* )\n\t      # Linker will automatically link against shared library if both\n\t      # static and shared are present.  Therefore, ensure we extract\n\t      # symbols from the import library if a shared library is present\n\t      # (otherwise, the dlopen module name will be incorrect).  We do\n\t      # this by putting the import library name into $newdlprefiles.\n\t      # We recover the dlopen module name by 'saving' the la file\n\t      # name in a special purpose variable, and (later) extracting the\n\t      # dlname from the la file.\n\t      if test -n \"$dlname\"; then\n\t        func_tr_sh \"$dir/$linklib\"\n\t        eval \"libfile_$func_tr_sh_result=\\$abs_ladir/\\$laname\"\n\t        func_append newdlprefiles \" $dir/$linklib\"\n\t      else\n\t        func_append newdlprefiles \" $dir/$old_library\"\n\t        # Keep a list of preopened convenience libraries to check\n\t        # that they are being used correctly in the link pass.\n\t        test -z \"$libdir\" && \\\n\t          func_append dlpreconveniencelibs \" $dir/$old_library\"\n\t      fi\n\t    ;;\n\t    * )\n\t      # Prefer using a static library (so that no silly _DYNAMIC symbols\n\t      # are required to link).\n\t      if test -n \"$old_library\"; then\n\t        func_append newdlprefiles \" $dir/$old_library\"\n\t        # Keep a list of preopened convenience libraries to check\n\t        # that they are being used correctly in the link pass.\n\t        test -z \"$libdir\" && \\\n\t          func_append dlpreconveniencelibs \" $dir/$old_library\"\n\t      # Otherwise, use the dlname, so that lt_dlopen finds it.\n\t      elif test -n \"$dlname\"; then\n\t        func_append newdlprefiles \" $dir/$dlname\"\n\t      else\n\t        func_append newdlprefiles \" $dir/$linklib\"\n\t      fi\n\t    ;;\n\t  esac\n\tfi # $pass = dlpreopen\n\n\tif test -z \"$libdir\"; then\n\t  # Link the convenience library\n\t  if test lib = \"$linkmode\"; then\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t  elif test prog,link = \"$linkmode,$pass\"; then\n\t    compile_deplibs=\"$dir/$old_library $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$old_library $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$lib $deplibs\" # used for prog,scan pass\n\t  fi\n\t  continue\n\tfi\n\n\n\tif test prog = \"$linkmode\" && test link != \"$pass\"; then\n\t  func_append newlib_search_path \" $ladir\"\n\t  deplibs=\"$lib $deplibs\"\n\n\t  linkalldeplibs=false\n\t  if test no != \"$link_all_deplibs\" || test -z \"$library_names\" ||\n\t     test no = \"$build_libtool_libs\"; then\n\t    linkalldeplibs=:\n\t  fi\n\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    case $deplib in\n\t    -L*) func_stripname '-L' '' \"$deplib\"\n\t         func_resolve_sysroot \"$func_stripname_result\"\n\t         func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t\t ;;\n\t    esac\n\t    # Need to link against all dependency_libs?\n\t    if $linkalldeplibs; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      # Need to hardcode shared library paths\n\t      # or/and link against static libraries\n\t      newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    if $opt_preserve_dup_deps; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\t      esac\n\t    fi\n\t    func_append tmp_libs \" $deplib\"\n\t  done # for deplib\n\t  continue\n\tfi # $linkmode = prog...\n\n\tif test prog,link = \"$linkmode,$pass\"; then\n\t  if test -n \"$library_names\" &&\n\t     { { test no = \"$prefer_static_libs\" ||\n\t         test built,yes = \"$prefer_static_libs,$installed\"; } ||\n\t       test -z \"$old_library\"; }; then\n\t    # We need to hardcode the library path\n\t    if test -n \"$shlibpath_var\" && test -z \"$avoidtemprpath\"; then\n\t      # Make sure the rpath contains only unique directories.\n\t      case $temp_rpath: in\n\t      *\"$absdir:\"*) ;;\n\t      *) func_append temp_rpath \"$absdir:\" ;;\n\t      esac\n\t    fi\n\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) func_append compile_rpath \" $absdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append finalize_rpath \" $libdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t  fi # $linkmode,$pass = prog,link...\n\n\t  if $alldeplibs &&\n\t     { test pass_all = \"$deplibs_check_method\" ||\n\t       { test yes = \"$build_libtool_libs\" &&\n\t\t test -n \"$library_names\"; }; }; then\n\t    # We only need to search for static libraries\n\t    continue\n\t  fi\n\tfi\n\n\tlink_static=no # Whether the deplib will be linked statically\n\tuse_static_libs=$prefer_static_libs\n\tif test built = \"$use_static_libs\" && test yes = \"$installed\"; then\n\t  use_static_libs=no\n\tfi\n\tif test -n \"$library_names\" &&\n\t   { test no = \"$use_static_libs\" || test -z \"$old_library\"; }; then\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc* | *os2*)\n\t      # No point in relinking DLLs because paths are not encoded\n\t      func_append notinst_deplibs \" $lib\"\n\t      need_relink=no\n\t    ;;\n\t  *)\n\t    if test no = \"$installed\"; then\n\t      func_append notinst_deplibs \" $lib\"\n\t      need_relink=yes\n\t    fi\n\t    ;;\n\t  esac\n\t  # This is a shared library\n\n\t  # Warn about portability, can't link against -module's on some\n\t  # systems (darwin).  Don't bleat about dlopened modules though!\n\t  dlopenmodule=\n\t  for dlpremoduletest in $dlprefiles; do\n\t    if test \"X$dlpremoduletest\" = \"X$lib\"; then\n\t      dlopenmodule=$dlpremoduletest\n\t      break\n\t    fi\n\t  done\n\t  if test -z \"$dlopenmodule\" && test yes = \"$shouldnotlink\" && test link = \"$pass\"; then\n\t    echo\n\t    if test prog = \"$linkmode\"; then\n\t      $ECHO \"*** Warning: Linking the executable $output against the loadable module\"\n\t    else\n\t      $ECHO \"*** Warning: Linking the shared library $output against the loadable module\"\n\t    fi\n\t    $ECHO \"*** $linklib is not portable!\"\n\t  fi\n\t  if test lib = \"$linkmode\" &&\n\t     test yes = \"$hardcode_into_libs\"; then\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) func_append compile_rpath \" $absdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append finalize_rpath \" $libdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t  fi\n\n\t  if test -n \"$old_archive_from_expsyms_cmds\"; then\n\t    # figure out the soname\n\t    set dummy $library_names\n\t    shift\n\t    realname=$1\n\t    shift\n\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t    # use dlname if we got it. it's perfectly good, no?\n\t    if test -n \"$dlname\"; then\n\t      soname=$dlname\n\t    elif test -n \"$soname_spec\"; then\n\t      # bleh windows\n\t      case $host in\n\t      *cygwin* | mingw* | *cegcc* | *os2*)\n\t        func_arith $current - $age\n\t\tmajor=$func_arith_result\n\t\tversuffix=-$major\n\t\t;;\n\t      esac\n\t      eval soname=\\\"$soname_spec\\\"\n\t    else\n\t      soname=$realname\n\t    fi\n\n\t    # Make a new name for the extract_expsyms_cmds to use\n\t    soroot=$soname\n\t    func_basename \"$soroot\"\n\t    soname=$func_basename_result\n\t    func_stripname 'lib' '.dll' \"$soname\"\n\t    newlib=libimp-$func_stripname_result.a\n\n\t    # If the library has no export list, then create one now\n\t    if test -f \"$output_objdir/$soname-def\"; then :\n\t    else\n\t      func_verbose \"extracting exported symbol list from '$soname'\"\n\t      func_execute_cmds \"$extract_expsyms_cmds\" 'exit $?'\n\t    fi\n\n\t    # Create $newlib\n\t    if test -f \"$output_objdir/$newlib\"; then :; else\n\t      func_verbose \"generating import library for '$soname'\"\n\t      func_execute_cmds \"$old_archive_from_expsyms_cmds\" 'exit $?'\n\t    fi\n\t    # make sure the library variables are pointing to the new library\n\t    dir=$output_objdir\n\t    linklib=$newlib\n\t  fi # test -n \"$old_archive_from_expsyms_cmds\"\n\n\t  if test prog = \"$linkmode\" || test relink != \"$opt_mode\"; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    lib_linked=yes\n\t    case $hardcode_action in\n\t    immediate | unsupported)\n\t      if test no = \"$hardcode_direct\"; then\n\t\tadd=$dir/$linklib\n\t\tcase $host in\n\t\t  *-*-sco3.2v5.0.[024]*) add_dir=-L$dir ;;\n\t\t  *-*-sysv4*uw2*) add_dir=-L$dir ;;\n\t\t  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \\\n\t\t    *-*-unixware7*) add_dir=-L$dir ;;\n\t\t  *-*-darwin* )\n\t\t    # if the lib is a (non-dlopened) module then we cannot\n\t\t    # link against it, someone is ignoring the earlier warnings\n\t\t    if /usr/bin/file -L $add 2> /dev/null |\n\t\t\t $GREP \": [^:]* bundle\" >/dev/null; then\n\t\t      if test \"X$dlopenmodule\" != \"X$lib\"; then\n\t\t\t$ECHO \"*** Warning: lib $linklib is a module, not a shared library\"\n\t\t\tif test -z \"$old_library\"; then\n\t\t\t  echo\n\t\t\t  echo \"*** And there doesn't seem to be a static archive available\"\n\t\t\t  echo \"*** The link will probably fail, sorry\"\n\t\t\telse\n\t\t\t  add=$dir/$old_library\n\t\t\tfi\n\t\t      elif test -n \"$old_library\"; then\n\t\t\tadd=$dir/$old_library\n\t\t      fi\n\t\t    fi\n\t\tesac\n\t      elif test no = \"$hardcode_minus_L\"; then\n\t\tcase $host in\n\t\t*-*-sunos*) add_shlibpath=$dir ;;\n\t\tesac\n\t\tadd_dir=-L$dir\n\t\tadd=-l$name\n\t      elif test no = \"$hardcode_shlibpath_var\"; then\n\t\tadd_shlibpath=$dir\n\t\tadd=-l$name\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    relink)\n\t      if test yes = \"$hardcode_direct\" &&\n\t         test no = \"$hardcode_direct_absolute\"; then\n\t\tadd=$dir/$linklib\n\t      elif test yes = \"$hardcode_minus_L\"; then\n\t\tadd_dir=-L$absdir\n\t\t# Try looking first in the location we're being installed to.\n\t\tif test -n \"$inst_prefix_dir\"; then\n\t\t  case $libdir in\n\t\t    [\\\\/]*)\n\t\t      func_append add_dir \" -L$inst_prefix_dir$libdir\"\n\t\t      ;;\n\t\t  esac\n\t\tfi\n\t\tadd=-l$name\n\t      elif test yes = \"$hardcode_shlibpath_var\"; then\n\t\tadd_shlibpath=$dir\n\t\tadd=-l$name\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    *) lib_linked=no ;;\n\t    esac\n\n\t    if test yes != \"$lib_linked\"; then\n\t      func_fatal_configuration \"unsupported hardcode properties\"\n\t    fi\n\n\t    if test -n \"$add_shlibpath\"; then\n\t      case :$compile_shlibpath: in\n\t      *\":$add_shlibpath:\"*) ;;\n\t      *) func_append compile_shlibpath \"$add_shlibpath:\" ;;\n\t      esac\n\t    fi\n\t    if test prog = \"$linkmode\"; then\n\t      test -n \"$add_dir\" && compile_deplibs=\"$add_dir $compile_deplibs\"\n\t      test -n \"$add\" && compile_deplibs=\"$add $compile_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t      if test yes != \"$hardcode_direct\" &&\n\t\t test yes != \"$hardcode_minus_L\" &&\n\t\t test yes = \"$hardcode_shlibpath_var\"; then\n\t\tcase :$finalize_shlibpath: in\n\t\t*\":$libdir:\"*) ;;\n\t\t*) func_append finalize_shlibpath \"$libdir:\" ;;\n\t\tesac\n\t      fi\n\t    fi\n\t  fi\n\n\t  if test prog = \"$linkmode\" || test relink = \"$opt_mode\"; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    # Finalize command for both is simple: just hardcode it.\n\t    if test yes = \"$hardcode_direct\" &&\n\t       test no = \"$hardcode_direct_absolute\"; then\n\t      add=$libdir/$linklib\n\t    elif test yes = \"$hardcode_minus_L\"; then\n\t      add_dir=-L$libdir\n\t      add=-l$name\n\t    elif test yes = \"$hardcode_shlibpath_var\"; then\n\t      case :$finalize_shlibpath: in\n\t      *\":$libdir:\"*) ;;\n\t      *) func_append finalize_shlibpath \"$libdir:\" ;;\n\t      esac\n\t      add=-l$name\n\t    elif test yes = \"$hardcode_automatic\"; then\n\t      if test -n \"$inst_prefix_dir\" &&\n\t\t test -f \"$inst_prefix_dir$libdir/$linklib\"; then\n\t\tadd=$inst_prefix_dir$libdir/$linklib\n\t      else\n\t\tadd=$libdir/$linklib\n\t      fi\n\t    else\n\t      # We cannot seem to hardcode it, guess we'll fake it.\n\t      add_dir=-L$libdir\n\t      # Try looking first in the location we're being installed to.\n\t      if test -n \"$inst_prefix_dir\"; then\n\t\tcase $libdir in\n\t\t  [\\\\/]*)\n\t\t    func_append add_dir \" -L$inst_prefix_dir$libdir\"\n\t\t    ;;\n\t\tesac\n\t      fi\n\t      add=-l$name\n\t    fi\n\n\t    if test prog = \"$linkmode\"; then\n\t      test -n \"$add_dir\" && finalize_deplibs=\"$add_dir $finalize_deplibs\"\n\t      test -n \"$add\" && finalize_deplibs=\"$add $finalize_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t    fi\n\t  fi\n\telif test prog = \"$linkmode\"; then\n\t  # Here we assume that one of hardcode_direct or hardcode_minus_L\n\t  # is not unsupported.  This is valid on all known static and\n\t  # shared platforms.\n\t  if test unsupported != \"$hardcode_direct\"; then\n\t    test -n \"$old_library\" && linklib=$old_library\n\t    compile_deplibs=\"$dir/$linklib $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$linklib $finalize_deplibs\"\n\t  else\n\t    compile_deplibs=\"-l$name -L$dir $compile_deplibs\"\n\t    finalize_deplibs=\"-l$name -L$dir $finalize_deplibs\"\n\t  fi\n\telif test yes = \"$build_libtool_libs\"; then\n\t  # Not a shared library\n\t  if test pass_all != \"$deplibs_check_method\"; then\n\t    # We're trying link a shared library against a static one\n\t    # but the system doesn't support it.\n\n\t    # Just print a warning and add the library to dependency_libs so\n\t    # that the program can be linked against the static library.\n\t    echo\n\t    $ECHO \"*** Warning: This system cannot link to static lib archive $lib.\"\n\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t    echo \"*** shared version of the library, which you do not appear to have.\"\n\t    if test yes = \"$module\"; then\n\t      echo \"*** But as you try to build a module library, libtool will still create \"\n\t      echo \"*** a static module, that should work as long as the dlopening application\"\n\t      echo \"*** is linked with the -dlopen flag to resolve symbols at runtime.\"\n\t      if test -z \"$global_symbol_pipe\"; then\n\t\techo\n\t\techo \"*** However, this would only work if libtool was able to extract symbol\"\n\t\techo \"*** lists from a program, using 'nm' or equivalent, but libtool could\"\n\t\techo \"*** not find such a program.  So, this module is probably useless.\"\n\t\techo \"*** 'nm' from GNU binutils and a full rebuild may help.\"\n\t      fi\n\t      if test no = \"$build_old_libs\"; then\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  else\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t    link_static=yes\n\t  fi\n\tfi # link shared/static library?\n\n\tif test lib = \"$linkmode\"; then\n\t  if test -n \"$dependency_libs\" &&\n\t     { test yes != \"$hardcode_into_libs\" ||\n\t       test yes = \"$build_old_libs\" ||\n\t       test yes = \"$link_static\"; }; then\n\t    # Extract -R from dependency_libs\n\t    temp_deplibs=\n\t    for libdir in $dependency_libs; do\n\t      case $libdir in\n\t      -R*) func_stripname '-R' '' \"$libdir\"\n\t           temp_xrpath=$func_stripname_result\n\t\t   case \" $xrpath \" in\n\t\t   *\" $temp_xrpath \"*) ;;\n\t\t   *) func_append xrpath \" $temp_xrpath\";;\n\t\t   esac;;\n\t      *) func_append temp_deplibs \" $libdir\";;\n\t      esac\n\t    done\n\t    dependency_libs=$temp_deplibs\n\t  fi\n\n\t  func_append newlib_search_path \" $absdir\"\n\t  # Link against this library\n\t  test no = \"$link_static\" && newdependency_libs=\"$abs_ladir/$laname $newdependency_libs\"\n\t  # ... and its dependency_libs\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    case $deplib in\n              -L*) func_stripname '-L' '' \"$deplib\"\n                   func_resolve_sysroot \"$func_stripname_result\";;\n              *) func_resolve_sysroot \"$deplib\" ;;\n            esac\n\t    if $opt_preserve_dup_deps; then\n\t      case \"$tmp_libs \" in\n\t      *\" $func_resolve_sysroot_result \"*)\n                func_append specialdeplibs \" $func_resolve_sysroot_result\" ;;\n\t      esac\n\t    fi\n\t    func_append tmp_libs \" $func_resolve_sysroot_result\"\n\t  done\n\n\t  if test no != \"$link_all_deplibs\"; then\n\t    # Add the search paths of all dependency libraries\n\t    for deplib in $dependency_libs; do\n\t      path=\n\t      case $deplib in\n\t      -L*) path=$deplib ;;\n\t      *.la)\n\t        func_resolve_sysroot \"$deplib\"\n\t        deplib=$func_resolve_sysroot_result\n\t        func_dirname \"$deplib\" \"\" \".\"\n\t\tdir=$func_dirname_result\n\t\t# We need an absolute path.\n\t\tcase $dir in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) absdir=$dir ;;\n\t\t*)\n\t\t  absdir=`cd \"$dir\" && pwd`\n\t\t  if test -z \"$absdir\"; then\n\t\t    func_warning \"cannot determine absolute directory name of '$dir'\"\n\t\t    absdir=$dir\n\t\t  fi\n\t\t  ;;\n\t\tesac\n\t\tif $GREP \"^installed=no\" $deplib > /dev/null; then\n\t\tcase $host in\n\t\t*-*-darwin*)\n\t\t  depdepl=\n\t\t  eval deplibrary_names=`$SED -n -e 's/^library_names=\\(.*\\)$/\\1/p' $deplib`\n\t\t  if test -n \"$deplibrary_names\"; then\n\t\t    for tmp in $deplibrary_names; do\n\t\t      depdepl=$tmp\n\t\t    done\n\t\t    if test -f \"$absdir/$objdir/$depdepl\"; then\n\t\t      depdepl=$absdir/$objdir/$depdepl\n\t\t      darwin_install_name=`$OTOOL -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`\n                      if test -z \"$darwin_install_name\"; then\n                          darwin_install_name=`$OTOOL64 -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`\n                      fi\n\t\t      func_append compiler_flags \" $wl-dylib_file $wl$darwin_install_name:$depdepl\"\n\t\t      func_append linker_flags \" -dylib_file $darwin_install_name:$depdepl\"\n\t\t      path=\n\t\t    fi\n\t\t  fi\n\t\t  ;;\n\t\t*)\n\t\t  path=-L$absdir/$objdir\n\t\t  ;;\n\t\tesac\n\t\telse\n\t\t  eval libdir=`$SED -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\t  test -z \"$libdir\" && \\\n\t\t    func_fatal_error \"'$deplib' is not a valid libtool archive\"\n\t\t  test \"$absdir\" != \"$libdir\" && \\\n\t\t    func_warning \"'$deplib' seems to be moved\"\n\n\t\t  path=-L$absdir\n\t\tfi\n\t\t;;\n\t      esac\n\t      case \" $deplibs \" in\n\t      *\" $path \"*) ;;\n\t      *) deplibs=\"$path $deplibs\" ;;\n\t      esac\n\t    done\n\t  fi # link_all_deplibs != no\n\tfi # linkmode = lib\n      done # for deplib in $libs\n      if test link = \"$pass\"; then\n\tif test prog = \"$linkmode\"; then\n\t  compile_deplibs=\"$new_inherited_linker_flags $compile_deplibs\"\n\t  finalize_deplibs=\"$new_inherited_linker_flags $finalize_deplibs\"\n\telse\n\t  compiler_flags=\"$compiler_flags \"`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfi\n      fi\n      dependency_libs=$newdependency_libs\n      if test dlpreopen = \"$pass\"; then\n\t# Link the dlpreopened libraries before other libraries\n\tfor deplib in $save_deplibs; do\n\t  deplibs=\"$deplib $deplibs\"\n\tdone\n      fi\n      if test dlopen != \"$pass\"; then\n\ttest conv = \"$pass\" || {\n\t  # Make sure lib_search_path contains only unique directories.\n\t  lib_search_path=\n\t  for dir in $newlib_search_path; do\n\t    case \"$lib_search_path \" in\n\t    *\" $dir \"*) ;;\n\t    *) func_append lib_search_path \" $dir\" ;;\n\t    esac\n\t  done\n\t  newlib_search_path=\n\t}\n\n\tif test prog,link = \"$linkmode,$pass\"; then\n\t  vars=\"compile_deplibs finalize_deplibs\"\n\telse\n\t  vars=deplibs\n\tfi\n\tfor var in $vars dependency_libs; do\n\t  # Add libraries to $var in reverse order\n\t  eval tmp_libs=\\\"\\$$var\\\"\n\t  new_libs=\n\t  for deplib in $tmp_libs; do\n\t    # FIXME: Pedantically, this is the right thing to do, so\n\t    #        that some nasty dependency loop isn't accidentally\n\t    #        broken:\n\t    #new_libs=\"$deplib $new_libs\"\n\t    # Pragmatically, this seems to cause very few problems in\n\t    # practice:\n\t    case $deplib in\n\t    -L*) new_libs=\"$deplib $new_libs\" ;;\n\t    -R*) ;;\n\t    *)\n\t      # And here is the reason: when a library appears more\n\t      # than once as an explicit dependence of a library, or\n\t      # is implicitly linked in more than once by the\n\t      # compiler, it is considered special, and multiple\n\t      # occurrences thereof are not removed.  Compare this\n\t      # with having the same library being listed as a\n\t      # dependency of multiple other libraries: in this case,\n\t      # we know (pedantically, we assume) the library does not\n\t      # need to be listed more than once, so we keep only the\n\t      # last copy.  This is not always right, but it is rare\n\t      # enough that we require users that really mean to play\n\t      # such unportable linking tricks to link the library\n\t      # using -Wl,-lname, so that libtool does not consider it\n\t      # for duplicate removal.\n\t      case \" $specialdeplibs \" in\n\t      *\" $deplib \"*) new_libs=\"$deplib $new_libs\" ;;\n\t      *)\n\t\tcase \" $new_libs \" in\n\t\t*\" $deplib \"*) ;;\n\t\t*) new_libs=\"$deplib $new_libs\" ;;\n\t\tesac\n\t\t;;\n\t      esac\n\t      ;;\n\t    esac\n\t  done\n\t  tmp_libs=\n\t  for deplib in $new_libs; do\n\t    case $deplib in\n\t    -L*)\n\t      case \" $tmp_libs \" in\n\t      *\" $deplib \"*) ;;\n\t      *) func_append tmp_libs \" $deplib\" ;;\n\t      esac\n\t      ;;\n\t    *) func_append tmp_libs \" $deplib\" ;;\n\t    esac\n\t  done\n\t  eval $var=\\\"$tmp_libs\\\"\n\tdone # for var\n      fi\n\n      # Add Sun CC postdeps if required:\n      test CXX = \"$tagname\" && {\n        case $host_os in\n        linux*)\n          case `$CC -V 2>&1 | sed 5q` in\n          *Sun\\ C*) # Sun C++ 5.9\n            func_suncc_cstd_abi\n\n            if test no != \"$suncc_use_cstd_abi\"; then\n              func_append postdeps ' -library=Cstd -library=Crun'\n            fi\n            ;;\n          esac\n          ;;\n\n        solaris*)\n          func_cc_basename \"$CC\"\n          case $func_cc_basename_result in\n          CC* | sunCC*)\n            func_suncc_cstd_abi\n\n            if test no != \"$suncc_use_cstd_abi\"; then\n              func_append postdeps ' -library=Cstd -library=Crun'\n            fi\n            ;;\n          esac\n          ;;\n        esac\n      }\n\n      # Last step: remove runtime libs from dependency_libs\n      # (they stay in deplibs)\n      tmp_libs=\n      for i in $dependency_libs; do\n\tcase \" $predeps $postdeps $compiler_lib_search_path \" in\n\t*\" $i \"*)\n\t  i=\n\t  ;;\n\tesac\n\tif test -n \"$i\"; then\n\t  func_append tmp_libs \" $i\"\n\tfi\n      done\n      dependency_libs=$tmp_libs\n    done # for pass\n    if test prog = \"$linkmode\"; then\n      dlfiles=$newdlfiles\n    fi\n    if test prog = \"$linkmode\" || test lib = \"$linkmode\"; then\n      dlprefiles=$newdlprefiles\n    fi\n\n    case $linkmode in\n    oldlib)\n      if test -n \"$dlfiles$dlprefiles\" || test no != \"$dlself\"; then\n\tfunc_warning \"'-dlopen' is ignored for archives\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"'-l' and '-L' are ignored for archives\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"'-rpath' is ignored for archives\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"'-R' is ignored for archives\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"'-version-info/-version-number' is ignored for archives\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"'-release' is ignored for archives\"\n\n      test -n \"$export_symbols$export_symbols_regex\" && \\\n\tfunc_warning \"'-export-symbols' is ignored for archives\"\n\n      # Now set the variables for building old libraries.\n      build_libtool_libs=no\n      oldlibs=$output\n      func_append objs \"$old_deplibs\"\n      ;;\n\n    lib)\n      # Make sure we only generate libraries of the form 'libNAME.la'.\n      case $outputname in\n      lib*)\n\tfunc_stripname 'lib' '.la' \"$outputname\"\n\tname=$func_stripname_result\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval libname=\\\"$libname_spec\\\"\n\t;;\n      *)\n\ttest no = \"$module\" \\\n\t  && func_fatal_help \"libtool library '$output' must begin with 'lib'\"\n\n\tif test no != \"$need_lib_prefix\"; then\n\t  # Add the \"lib\" prefix for modules if required\n\t  func_stripname '' '.la' \"$outputname\"\n\t  name=$func_stripname_result\n\t  eval shared_ext=\\\"$shrext_cmds\\\"\n\t  eval libname=\\\"$libname_spec\\\"\n\telse\n\t  func_stripname '' '.la' \"$outputname\"\n\t  libname=$func_stripname_result\n\tfi\n\t;;\n      esac\n\n      if test -n \"$objs\"; then\n\tif test pass_all != \"$deplibs_check_method\"; then\n\t  func_fatal_error \"cannot build libtool library '$output' from non-libtool objects on this host:$objs\"\n\telse\n\t  echo\n\t  $ECHO \"*** Warning: Linking the shared library $output against the non-libtool\"\n\t  $ECHO \"*** objects $objs is not portable!\"\n\t  func_append libobjs \" $objs\"\n\tfi\n      fi\n\n      test no = \"$dlself\" \\\n\t|| func_warning \"'-dlopen self' is ignored for libtool libraries\"\n\n      set dummy $rpath\n      shift\n      test 1 -lt \"$#\" \\\n\t&& func_warning \"ignoring multiple '-rpath's for a libtool library\"\n\n      install_libdir=$1\n\n      oldlibs=\n      if test -z \"$rpath\"; then\n\tif test yes = \"$build_libtool_libs\"; then\n\t  # Building a libtool convenience library.\n\t  # Some compilers have problems with a '.al' extension so\n\t  # convenience libraries should have the same extension an\n\t  # archive normally would.\n\t  oldlibs=\"$output_objdir/$libname.$libext $oldlibs\"\n\t  build_libtool_libs=convenience\n\t  build_old_libs=yes\n\tfi\n\n\ttest -n \"$vinfo\" && \\\n\t  func_warning \"'-version-info/-version-number' is ignored for convenience libraries\"\n\n\ttest -n \"$release\" && \\\n\t  func_warning \"'-release' is ignored for convenience libraries\"\n      else\n\n\t# Parse the version information argument.\n\tsave_ifs=$IFS; IFS=:\n\tset dummy $vinfo 0 0 0\n\tshift\n\tIFS=$save_ifs\n\n\ttest -n \"$7\" && \\\n\t  func_fatal_help \"too many parameters to '-version-info'\"\n\n\t# convert absolute version numbers to libtool ages\n\t# this retains compatibility with .la files and attempts\n\t# to make the code below a bit more comprehensible\n\n\tcase $vinfo_number in\n\tyes)\n\t  number_major=$1\n\t  number_minor=$2\n\t  number_revision=$3\n\t  #\n\t  # There are really only two kinds -- those that\n\t  # use the current revision as the major version\n\t  # and those that subtract age and use age as\n\t  # a minor version.  But, then there is irix\n\t  # that has an extra 1 added just for fun\n\t  #\n\t  case $version_type in\n\t  # correct linux to gnu/linux during the next big refactor\n\t  darwin|freebsd-elf|linux|osf|windows|none)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=$number_minor\n\t    revision=$number_revision\n\t    ;;\n\t  freebsd-aout|qnx|sunos)\n\t    current=$number_major\n\t    revision=$number_minor\n\t    age=0\n\t    ;;\n\t  irix|nonstopux)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=$number_minor\n\t    revision=$number_minor\n\t    lt_irix_increment=no\n\t    ;;\n\t  *)\n\t    func_fatal_configuration \"$modename: unknown library version type '$version_type'\"\n\t    ;;\n\t  esac\n\t  ;;\n\tno)\n\t  current=$1\n\t  revision=$2\n\t  age=$3\n\t  ;;\n\tesac\n\n\t# Check that each of the things are valid numbers.\n\tcase $current in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"CURRENT '$current' must be a nonnegative integer\"\n\t  func_fatal_error \"'$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $revision in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"REVISION '$revision' must be a nonnegative integer\"\n\t  func_fatal_error \"'$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $age in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"AGE '$age' must be a nonnegative integer\"\n\t  func_fatal_error \"'$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tif test \"$age\" -gt \"$current\"; then\n\t  func_error \"AGE '$age' is greater than the current interface number '$current'\"\n\t  func_fatal_error \"'$vinfo' is not valid version information\"\n\tfi\n\n\t# Calculate the version variables.\n\tmajor=\n\tversuffix=\n\tverstring=\n\tcase $version_type in\n\tnone) ;;\n\n\tdarwin)\n\t  # Like Linux, but with the current version available in\n\t  # verstring for coding it into the library header\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=$major.$age.$revision\n\t  # Darwin ld doesn't like 0 for these options...\n\t  func_arith $current + 1\n\t  minor_current=$func_arith_result\n\t  xlcverstring=\"$wl-compatibility_version $wl$minor_current $wl-current_version $wl$minor_current.$revision\"\n\t  verstring=\"-compatibility_version $minor_current -current_version $minor_current.$revision\"\n          # On Darwin other compilers\n          case $CC in\n              nagfor*)\n                  verstring=\"$wl-compatibility_version $wl$minor_current $wl-current_version $wl$minor_current.$revision\"\n                  ;;\n              *)\n                  verstring=\"-compatibility_version $minor_current -current_version $minor_current.$revision\"\n                  ;;\n          esac\n\t  ;;\n\n\tfreebsd-aout)\n\t  major=.$current\n\t  versuffix=.$current.$revision\n\t  ;;\n\n\tfreebsd-elf)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=$major.$age.$revision\n\t  ;;\n\n\tirix | nonstopux)\n\t  if test no = \"$lt_irix_increment\"; then\n\t    func_arith $current - $age\n\t  else\n\t    func_arith $current - $age + 1\n\t  fi\n\t  major=$func_arith_result\n\n\t  case $version_type in\n\t    nonstopux) verstring_prefix=nonstopux ;;\n\t    *)         verstring_prefix=sgi ;;\n\t  esac\n\t  verstring=$verstring_prefix$major.$revision\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$revision\n\t  while test 0 -ne \"$loop\"; do\n\t    func_arith $revision - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=$verstring_prefix$major.$iface:$verstring\n\t  done\n\n\t  # Before this point, $major must not contain '.'.\n\t  major=.$major\n\t  versuffix=$major.$revision\n\t  ;;\n\n\tlinux) # correct to gnu/linux during the next big refactor\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=$major.$age.$revision\n\t  ;;\n\n\tosf)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=.$current.$age.$revision\n\t  verstring=$current.$age.$revision\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$age\n\t  while test 0 -ne \"$loop\"; do\n\t    func_arith $current - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=$verstring:$iface.0\n\t  done\n\n\t  # Make executables depend on our current version.\n\t  func_append verstring \":$current.0\"\n\t  ;;\n\n\tqnx)\n\t  major=.$current\n\t  versuffix=.$current\n\t  ;;\n\n\tsco)\n\t  major=.$current\n\t  versuffix=.$current\n\t  ;;\n\n\tsunos)\n\t  major=.$current\n\t  versuffix=.$current.$revision\n\t  ;;\n\n\twindows)\n\t  # Use '-' rather than '.', since we only want one\n\t  # extension on DOS 8.3 file systems.\n\t  func_arith $current - $age\n\t  major=$func_arith_result\n\t  versuffix=-$major\n\t  ;;\n\n\t*)\n\t  func_fatal_configuration \"unknown library version type '$version_type'\"\n\t  ;;\n\tesac\n\n\t# Clear the version info if we defaulted, and they specified a release.\n\tif test -z \"$vinfo\" && test -n \"$release\"; then\n\t  major=\n\t  case $version_type in\n\t  darwin)\n\t    # we can't check for \"0.0\" in archive_cmds due to quoting\n\t    # problems, so we reset it completely\n\t    verstring=\n\t    ;;\n\t  *)\n\t    verstring=0.0\n\t    ;;\n\t  esac\n\t  if test no = \"$need_version\"; then\n\t    versuffix=\n\t  else\n\t    versuffix=.0.0\n\t  fi\n\tfi\n\n\t# Remove version info from name if versioning should be avoided\n\tif test yes,no = \"$avoid_version,$need_version\"; then\n\t  major=\n\t  versuffix=\n\t  verstring=\n\tfi\n\n\t# Check to see if the archive will have undefined symbols.\n\tif test yes = \"$allow_undefined\"; then\n\t  if test unsupported = \"$allow_undefined_flag\"; then\n\t    if test yes = \"$build_old_libs\"; then\n\t      func_warning \"undefined symbols not allowed in $host shared libraries; building static only\"\n\t      build_libtool_libs=no\n\t    else\n\t      func_fatal_error \"can't build $host shared library unless -no-undefined is specified\"\n\t    fi\n\t  fi\n\telse\n\t  # Don't allow undefined symbols.\n\t  allow_undefined_flag=$no_undefined_flag\n\tfi\n\n      fi\n\n      func_generate_dlsyms \"$libname\" \"$libname\" :\n      func_append libobjs \" $symfileobj\"\n      test \" \" = \"$libobjs\" && libobjs=\n\n      if test relink != \"$opt_mode\"; then\n\t# Remove our outputs, but don't remove object files since they\n\t# may have been created when compiling PIC objects.\n\tremovelist=\n\ttempremovelist=`$ECHO \"$output_objdir/*\"`\n\tfor p in $tempremovelist; do\n\t  case $p in\n\t    *.$objext | *.gcno)\n\t       ;;\n\t    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/$libname$release.*)\n\t       if test -n \"$precious_files_regex\"; then\n\t\t if $ECHO \"$p\" | $EGREP -e \"$precious_files_regex\" >/dev/null 2>&1\n\t\t then\n\t\t   continue\n\t\t fi\n\t       fi\n\t       func_append removelist \" $p\"\n\t       ;;\n\t    *) ;;\n\t  esac\n\tdone\n\ttest -n \"$removelist\" && \\\n\t  func_show_eval \"${RM}r \\$removelist\"\n      fi\n\n      # Now set the variables for building old libraries.\n      if test yes = \"$build_old_libs\" && test convenience != \"$build_libtool_libs\"; then\n\tfunc_append oldlibs \" $output_objdir/$libname.$libext\"\n\n\t# Transform .lo files to .o files.\n\toldobjs=\"$objs \"`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.$libext$/d; $lo2o\" | $NL2SP`\n      fi\n\n      # Eliminate all temporary directories.\n      #for path in $notinst_path; do\n      #\tlib_search_path=`$ECHO \"$lib_search_path \" | $SED \"s% $path % %g\"`\n      #\tdeplibs=`$ECHO \"$deplibs \" | $SED \"s% -L$path % %g\"`\n      #\tdependency_libs=`$ECHO \"$dependency_libs \" | $SED \"s% -L$path % %g\"`\n      #done\n\n      if test -n \"$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\ttemp_xrpath=\n\tfor libdir in $xrpath; do\n\t  func_replace_sysroot \"$libdir\"\n\t  func_append temp_xrpath \" -R$func_replace_sysroot_result\"\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_rpath \" $libdir\" ;;\n\t  esac\n\tdone\n\tif test yes != \"$hardcode_into_libs\" || test yes = \"$build_old_libs\"; then\n\t  dependency_libs=\"$temp_xrpath $dependency_libs\"\n\tfi\n      fi\n\n      # Make sure dlfiles contains only unique files that won't be dlpreopened\n      old_dlfiles=$dlfiles\n      dlfiles=\n      for lib in $old_dlfiles; do\n\tcase \" $dlprefiles $dlfiles \" in\n\t*\" $lib \"*) ;;\n\t*) func_append dlfiles \" $lib\" ;;\n\tesac\n      done\n\n      # Make sure dlprefiles contains only unique files\n      old_dlprefiles=$dlprefiles\n      dlprefiles=\n      for lib in $old_dlprefiles; do\n\tcase \"$dlprefiles \" in\n\t*\" $lib \"*) ;;\n\t*) func_append dlprefiles \" $lib\" ;;\n\tesac\n      done\n\n      if test yes = \"$build_libtool_libs\"; then\n\tif test -n \"$rpath\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # these systems don't actually have a c library (as such)!\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C library is in the System framework\n\t    func_append deplibs \" System.ltframework\"\n\t    ;;\n\t  *-*-netbsd*)\n\t    # Don't link with libc until the a.out ld.so is fixed.\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    ;;\n\t  *)\n\t    # Add libc to deplibs on all other systems if necessary.\n\t    if test yes = \"$build_libtool_need_lc\"; then\n\t      func_append deplibs \" -lc\"\n\t    fi\n\t    ;;\n\t  esac\n\tfi\n\n\t# Transform deplibs into only deplibs that can be linked in shared.\n\tname_save=$name\n\tlibname_save=$libname\n\trelease_save=$release\n\tversuffix_save=$versuffix\n\tmajor_save=$major\n\t# I'm not sure if I'm treating the release correctly.  I think\n\t# release should show up in the -l (ie -lgmp5) so we don't want to\n\t# add it in twice.  Is that correct?\n\trelease=\n\tversuffix=\n\tmajor=\n\tnewdeplibs=\n\tdroppeddeps=no\n\tcase $deplibs_check_method in\n\tpass_all)\n\t  # Don't check for shared/static.  Everything works.\n\t  # This might be a little naive.  We might want to check\n\t  # whether the library exists or not.  But this is on\n\t  # osf3 & osf4 and I'm not really sure... Just\n\t  # implementing what was already the behavior.\n\t  newdeplibs=$deplibs\n\t  ;;\n\ttest_compile)\n\t  # This code stresses the \"libraries are programs\" paradigm to its\n\t  # limits. Maybe even breaks it.  We compile a program, linking it\n\t  # against the deplibs as a proxy for the library.  Then we can check\n\t  # whether they linked in statically or dynamically with ldd.\n\t  $opt_dry_run || $RM conftest.c\n\t  cat > conftest.c <<EOF\n\t  int main() { return 0; }\nEOF\n\t  $opt_dry_run || $RM conftest\n\t  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then\n\t    ldd_output=`ldd conftest`\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\tif test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t\t  case \" $predeps $postdeps \" in\n\t\t  *\" $i \"*)\n\t\t    func_append newdeplibs \" $i\"\n\t\t    i=\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t\tif test -n \"$i\"; then\n\t\t  libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t  deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t  set dummy $deplib_matches; shift\n\t\t  deplib_match=$1\n\t\t  if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0; then\n\t\t    func_append newdeplibs \" $i\"\n\t\t  else\n\t\t    droppeddeps=yes\n\t\t    echo\n\t\t    $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t    echo \"*** shared version of the library, which I believe you do not have\"\n\t\t    echo \"*** because a test_compile did reveal that the linker did not use it for\"\n\t\t    echo \"*** its dynamic dependency list that programs get resolved with at runtime.\"\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *)\n\t\tfunc_append newdeplibs \" $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  else\n\t    # Error occurred in the first compile.  Let's try to salvage\n\t    # the situation: Compile a separate program for each library.\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\t$opt_dry_run || $RM conftest\n\t\tif $LTCC $LTCFLAGS -o conftest conftest.c $i; then\n\t\t  ldd_output=`ldd conftest`\n\t\t  if test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t\t    case \" $predeps $postdeps \" in\n\t\t    *\" $i \"*)\n\t\t      func_append newdeplibs \" $i\"\n\t\t      i=\n\t\t      ;;\n\t\t    esac\n\t\t  fi\n\t\t  if test -n \"$i\"; then\n\t\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t    deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t    set dummy $deplib_matches; shift\n\t\t    deplib_match=$1\n\t\t    if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0; then\n\t\t      func_append newdeplibs \" $i\"\n\t\t    else\n\t\t      droppeddeps=yes\n\t\t      echo\n\t\t      $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t      echo \"*** I have the capability to make that library automatically link in when\"\n\t\t      echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t      echo \"*** shared version of the library, which you do not appear to have\"\n\t\t      echo \"*** because a test_compile did reveal that the linker did not use this one\"\n\t\t      echo \"*** as a dynamic dependency that programs can get resolved with at runtime.\"\n\t\t    fi\n\t\t  fi\n\t\telse\n\t\t  droppeddeps=yes\n\t\t  echo\n\t\t  $ECHO \"*** Warning!  Library $i is needed by this library but I was not able to\"\n\t\t  echo \"*** make it link in!  You will probably need to install it or some\"\n\t\t  echo \"*** library that it depends on before this library will be fully\"\n\t\t  echo \"*** functional.  Installing it before continuing would be even better.\"\n\t\tfi\n\t\t;;\n\t      *)\n\t\tfunc_append newdeplibs \" $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  fi\n\t  ;;\n\tfile_magic*)\n\t  set dummy $deplibs_check_method; shift\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  func_append newdeplibs \" $a_deplib\"\n\t\t  a_deplib=\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\"; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tif test -n \"$file_magic_glob\"; then\n\t\t  libnameglob=`func_echo_all \"$libname\" | $SED -e $file_magic_glob`\n\t\telse\n\t\t  libnameglob=$libname\n\t\tfi\n\t\ttest yes = \"$want_nocaseglob\" && nocaseglob=`shopt -p nocaseglob`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  if test yes = \"$want_nocaseglob\"; then\n\t\t    shopt -s nocaseglob\n\t\t    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`\n\t\t    $nocaseglob\n\t\t  else\n\t\t    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`\n\t\t  fi\n\t\t  for potent_lib in $potential_libs; do\n\t\t      # Follow soft links.\n\t\t      if ls -lLd \"$potent_lib\" 2>/dev/null |\n\t\t\t $GREP \" -> \" >/dev/null; then\n\t\t\tcontinue\n\t\t      fi\n\t\t      # The statement above tries to avoid entering an\n\t\t      # endless loop below, in case of cyclic links.\n\t\t      # We might still enter an endless loop, since a link\n\t\t      # loop can be closed while we follow links,\n\t\t      # but so what?\n\t\t      potlib=$potent_lib\n\t\t      while test -h \"$potlib\" 2>/dev/null; do\n\t\t\tpotliblink=`ls -ld $potlib | $SED 's/.* -> //'`\n\t\t\tcase $potliblink in\n\t\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) potlib=$potliblink;;\n\t\t\t*) potlib=`$ECHO \"$potlib\" | $SED 's|[^/]*$||'`\"$potliblink\";;\n\t\t\tesac\n\t\t      done\n\t\t      if eval $file_magic_cmd \\\"\\$potlib\\\" 2>/dev/null |\n\t\t\t $SED -e 10q |\n\t\t\t $EGREP \"$file_magic_regex\" > /dev/null; then\n\t\t\tfunc_append newdeplibs \" $a_deplib\"\n\t\t\ta_deplib=\n\t\t\tbreak 2\n\t\t      fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\"; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\"; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for file magic test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a file magic. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      func_append newdeplibs \" $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tmatch_pattern*)\n\t  set dummy $deplibs_check_method; shift\n\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  func_append newdeplibs \" $a_deplib\"\n\t\t  a_deplib=\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\"; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t    potlib=$potent_lib # see symlink-check above in file_magic test\n\t\t    if eval \"\\$ECHO \\\"$potent_lib\\\"\" 2>/dev/null | $SED 10q | \\\n\t\t       $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t      func_append newdeplibs \" $a_deplib\"\n\t\t      a_deplib=\n\t\t      break 2\n\t\t    fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\"; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\"; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for regex pattern test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a regex pattern. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      func_append newdeplibs \" $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tnone | unknown | *)\n\t  newdeplibs=\n\t  tmp_deplibs=`$ECHO \" $deplibs\" | $SED 's/ -lc$//; s/ -[LR][^ ]*//g'`\n\t  if test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t    for i in $predeps $postdeps; do\n\t      # can't use Xsed below, because $i might contain '/'\n\t      tmp_deplibs=`$ECHO \" $tmp_deplibs\" | $SED \"s|$i||\"`\n\t    done\n\t  fi\n\t  case $tmp_deplibs in\n\t  *[!\\\t\\ ]*)\n\t    echo\n\t    if test none = \"$deplibs_check_method\"; then\n\t      echo \"*** Warning: inter-library dependencies are not supported in this platform.\"\n\t    else\n\t      echo \"*** Warning: inter-library dependencies are not known to be supported.\"\n\t    fi\n\t    echo \"*** All declared inter-library dependencies are being dropped.\"\n\t    droppeddeps=yes\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tversuffix=$versuffix_save\n\tmajor=$major_save\n\trelease=$release_save\n\tlibname=$libname_save\n\tname=$name_save\n\n\tcase $host in\n\t*-*-rhapsody* | *-*-darwin1.[012])\n\t  # On Rhapsody replace the C library with the System framework\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t  ;;\n\tesac\n\n\tif test yes = \"$droppeddeps\"; then\n\t  if test yes = \"$module\"; then\n\t    echo\n\t    echo \"*** Warning: libtool could not satisfy all declared inter-library\"\n\t    $ECHO \"*** dependencies of module $libname.  Therefore, libtool will create\"\n\t    echo \"*** a static module, that should work as long as the dlopening\"\n\t    echo \"*** application is linked with the -dlopen flag.\"\n\t    if test -z \"$global_symbol_pipe\"; then\n\t      echo\n\t      echo \"*** However, this would only work if libtool was able to extract symbol\"\n\t      echo \"*** lists from a program, using 'nm' or equivalent, but libtool could\"\n\t      echo \"*** not find such a program.  So, this module is probably useless.\"\n\t      echo \"*** 'nm' from GNU binutils and a full rebuild may help.\"\n\t    fi\n\t    if test no = \"$build_old_libs\"; then\n\t      oldlibs=$output_objdir/$libname.$libext\n\t      build_libtool_libs=module\n\t      build_old_libs=yes\n\t    else\n\t      build_libtool_libs=no\n\t    fi\n\t  else\n\t    echo \"*** The inter-library dependencies that have been dropped here will be\"\n\t    echo \"*** automatically added whenever a program is linked with this library\"\n\t    echo \"*** or is declared to -dlopen it.\"\n\n\t    if test no = \"$allow_undefined\"; then\n\t      echo\n\t      echo \"*** Since this library must not contain undefined symbols,\"\n\t      echo \"*** because either the platform does not support them or\"\n\t      echo \"*** it was explicitly requested with -no-undefined,\"\n\t      echo \"*** libtool will only create a static version of it.\"\n\t      if test no = \"$build_old_libs\"; then\n\t\toldlibs=$output_objdir/$libname.$libext\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  fi\n\tfi\n\t# Done checking deplibs!\n\tdeplibs=$newdeplibs\n      fi\n      # Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n      case $host in\n\t*-*-darwin*)\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  new_inherited_linker_flags=`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  deplibs=`$ECHO \" $deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  ;;\n      esac\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    func_append new_libs \" -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) func_append new_libs \" $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) func_append new_libs \" $deplib\" ;;\n\tesac\n      done\n      deplibs=$new_libs\n\n      # All the library-specific variables (install_libdir is set above).\n      library_names=\n      old_library=\n      dlname=\n\n      # Test again, we may have decided not to build it any more\n      if test yes = \"$build_libtool_libs\"; then\n\t# Remove $wl instances when linking with ld.\n\t# FIXME: should test the right _cmds variable.\n\tcase $archive_cmds in\n\t  *\\$LD\\ *) wl= ;;\n        esac\n\tif test yes = \"$hardcode_into_libs\"; then\n\t  # Hardcode the library paths\n\t  hardcode_libdirs=\n\t  dep_rpath=\n\t  rpath=$finalize_rpath\n\t  test relink = \"$opt_mode\" || rpath=$compile_rpath$rpath\n\t  for libdir in $rpath; do\n\t    if test -n \"$hardcode_libdir_flag_spec\"; then\n\t      if test -n \"$hardcode_libdir_separator\"; then\n\t\tfunc_replace_sysroot \"$libdir\"\n\t\tlibdir=$func_replace_sysroot_result\n\t\tif test -z \"$hardcode_libdirs\"; then\n\t\t  hardcode_libdirs=$libdir\n\t\telse\n\t\t  # Just accumulate the unique libdirs.\n\t\t  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t\t  *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t    ;;\n\t\t  *)\n\t\t    func_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t      else\n\t\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t\tfunc_append dep_rpath \" $flag\"\n\t      fi\n\t    elif test -n \"$runpath_var\"; then\n\t      case \"$perm_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append perm_rpath \" $libdir\" ;;\n\t      esac\n\t    fi\n\t  done\n\t  # Substitute the hardcoded libdirs into the rpath.\n\t  if test -n \"$hardcode_libdir_separator\" &&\n\t     test -n \"$hardcode_libdirs\"; then\n\t    libdir=$hardcode_libdirs\n\t    eval \"dep_rpath=\\\"$hardcode_libdir_flag_spec\\\"\"\n\t  fi\n\t  if test -n \"$runpath_var\" && test -n \"$perm_rpath\"; then\n\t    # We should set the runpath_var.\n\t    rpath=\n\t    for dir in $perm_rpath; do\n\t      func_append rpath \"$dir:\"\n\t    done\n\t    eval \"$runpath_var='$rpath\\$$runpath_var'; export $runpath_var\"\n\t  fi\n\t  test -n \"$dep_rpath\" && deplibs=\"$dep_rpath $deplibs\"\n\tfi\n\n\tshlibpath=$finalize_shlibpath\n\ttest relink = \"$opt_mode\" || shlibpath=$compile_shlibpath$shlibpath\n\tif test -n \"$shlibpath\"; then\n\t  eval \"$shlibpath_var='$shlibpath\\$$shlibpath_var'; export $shlibpath_var\"\n\tfi\n\n\t# Get the real and link names of the library.\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval library_names=\\\"$library_names_spec\\\"\n\tset dummy $library_names\n\tshift\n\trealname=$1\n\tshift\n\n\tif test -n \"$soname_spec\"; then\n\t  eval soname=\\\"$soname_spec\\\"\n\telse\n\t  soname=$realname\n\tfi\n\tif test -z \"$dlname\"; then\n\t  dlname=$soname\n\tfi\n\n\tlib=$output_objdir/$realname\n\tlinknames=\n\tfor link\n\tdo\n\t  func_append linknames \" $link\"\n\tdone\n\n\t# Use standard objects if they are pic\n\ttest -z \"$pic_flag\" && libobjs=`$ECHO \"$libobjs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\ttest \"X$libobjs\" = \"X \" && libobjs=\n\n\tdelfiles=\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  $opt_dry_run || cp \"$export_symbols\" \"$output_objdir/$libname.uexp\"\n\t  export_symbols=$output_objdir/$libname.uexp\n\t  func_append delfiles \" $export_symbols\"\n\tfi\n\n\torig_export_symbols=\n\tcase $host_os in\n\tcygwin* | mingw* | cegcc*)\n\t  if test -n \"$export_symbols\" && test -z \"$export_symbols_regex\"; then\n\t    # exporting using user supplied symfile\n\t    func_dll_def_p \"$export_symbols\" || {\n\t      # and it's NOT already a .def file. Must figure out\n\t      # which of the given symbols are data symbols and tag\n\t      # them as such. So, trigger use of export_symbols_cmds.\n\t      # export_symbols gets reassigned inside the \"prepare\n\t      # the list of exported symbols\" if statement, so the\n\t      # include_expsyms logic still works.\n\t      orig_export_symbols=$export_symbols\n\t      export_symbols=\n\t      always_export_symbols=yes\n\t    }\n\t  fi\n\t  ;;\n\tesac\n\n\t# Prepare the list of exported symbols\n\tif test -z \"$export_symbols\"; then\n\t  if test yes = \"$always_export_symbols\" || test -n \"$export_symbols_regex\"; then\n\t    func_verbose \"generating symbol list for '$libname.la'\"\n\t    export_symbols=$output_objdir/$libname.exp\n\t    $opt_dry_run || $RM $export_symbols\n\t    cmds=$export_symbols_cmds\n\t    save_ifs=$IFS; IFS='~'\n\t    for cmd1 in $cmds; do\n\t      IFS=$save_ifs\n\t      # Take the normal branch if the nm_file_list_spec branch\n\t      # doesn't work or if tool conversion is not needed.\n\t      case $nm_file_list_spec~$to_tool_file_cmd in\n\t\t*~func_convert_file_noop | *~func_convert_file_msys_to_w32 | ~*)\n\t\t  try_normal_branch=yes\n\t\t  eval cmd=\\\"$cmd1\\\"\n\t\t  func_len \" $cmd\"\n\t\t  len=$func_len_result\n\t\t  ;;\n\t\t*)\n\t\t  try_normal_branch=no\n\t\t  ;;\n\t      esac\n\t      if test yes = \"$try_normal_branch\" \\\n\t\t && { test \"$len\" -lt \"$max_cmd_len\" \\\n\t\t      || test \"$max_cmd_len\" -le -1; }\n\t      then\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\tskipped_export=false\n\t      elif test -n \"$nm_file_list_spec\"; then\n\t\tfunc_basename \"$output\"\n\t\toutput_la=$func_basename_result\n\t\tsave_libobjs=$libobjs\n\t\tsave_output=$output\n\t\toutput=$output_objdir/$output_la.nm\n\t\tfunc_to_tool_file \"$output\"\n\t\tlibobjs=$nm_file_list_spec$func_to_tool_file_result\n\t\tfunc_append delfiles \" $output\"\n\t\tfunc_verbose \"creating $NM input file list: $output\"\n\t\tfor obj in $save_libobjs; do\n\t\t  func_to_tool_file \"$obj\"\n\t\t  $ECHO \"$func_to_tool_file_result\"\n\t\tdone > \"$output\"\n\t\teval cmd=\\\"$cmd1\\\"\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\toutput=$save_output\n\t\tlibobjs=$save_libobjs\n\t\tskipped_export=false\n\t      else\n\t\t# The command line is too long to execute in one step.\n\t\tfunc_verbose \"using reloadable object file for export list...\"\n\t\tskipped_export=:\n\t\t# Break out early, otherwise skipped_export may be\n\t\t# set to false by a later but shorter cmd.\n\t\tbreak\n\t      fi\n\t    done\n\t    IFS=$save_ifs\n\t    if test -n \"$export_symbols_regex\" && test : != \"$skipped_export\"; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  tmp_export_symbols=$export_symbols\n\t  test -n \"$orig_export_symbols\" && tmp_export_symbols=$orig_export_symbols\n\t  $opt_dry_run || eval '$ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"'\n\tfi\n\n\tif test : != \"$skipped_export\" && test -n \"$orig_export_symbols\"; then\n\t  # The given exports_symbols file has to be filtered, so filter it.\n\t  func_verbose \"filter symbol list for '$libname.la' to tag DATA exports\"\n\t  # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t  # 's' commands, which not all seds can handle. GNU sed should be fine\n\t  # though. Also, the filter scales superlinearly with the number of\n\t  # global variables. join(1) would be nice here, but unfortunately\n\t  # isn't a blessed tool.\n\t  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t  func_append delfiles \" $export_symbols $output_objdir/$libname.filter\"\n\t  export_symbols=$output_objdir/$libname.def\n\t  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\tfi\n\n\ttmp_deplibs=\n\tfor test_deplib in $deplibs; do\n\t  case \" $convenience \" in\n\t  *\" $test_deplib \"*) ;;\n\t  *)\n\t    func_append tmp_deplibs \" $test_deplib\"\n\t    ;;\n\t  esac\n\tdone\n\tdeplibs=$tmp_deplibs\n\n\tif test -n \"$convenience\"; then\n\t  if test -n \"$whole_archive_flag_spec\" &&\n\t    test yes = \"$compiler_needs_object\" &&\n\t    test -z \"$libobjs\"; then\n\t    # extract the archives, so we have objects to list.\n\t    # TODO: could optimize this to just extract one archive.\n\t    whole_archive_flag_spec=\n\t  fi\n\t  if test -n \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  else\n\t    gentop=$output_objdir/${outputname}x\n\t    func_append generated \" $gentop\"\n\n\t    func_extract_archives $gentop $convenience\n\t    func_append libobjs \" $func_extract_archives_result\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\tfi\n\n\tif test yes = \"$thread_safe\" && test -n \"$thread_safe_flag_spec\"; then\n\t  eval flag=\\\"$thread_safe_flag_spec\\\"\n\t  func_append linker_flags \" $flag\"\n\tfi\n\n\t# Make a backup of the uninstalled library when relinking\n\tif test relink = \"$opt_mode\"; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?\n\tfi\n\n\t# Do each of the archive commands.\n\tif test yes = \"$module\" && test -n \"$module_cmds\"; then\n\t  if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$module_expsym_cmds\\\"\n\t    cmds=$module_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$module_cmds\\\"\n\t    cmds=$module_cmds\n\t  fi\n\telse\n\t  if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$archive_expsym_cmds\\\"\n\t    cmds=$archive_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$archive_cmds\\\"\n\t    cmds=$archive_cmds\n\t  fi\n\tfi\n\n\tif test : != \"$skipped_export\" &&\n\t   func_len \" $test_cmds\" &&\n\t   len=$func_len_result &&\n\t   test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  :\n\telse\n\t  # The command line is too long to link in one step, link piecewise\n\t  # or, if using GNU ld and skipped_export is not :, use a linker\n\t  # script.\n\n\t  # Save the value of $output and $libobjs because we want to\n\t  # use them later.  If we have whole_archive_flag_spec, we\n\t  # want to use save_libobjs as it was before\n\t  # whole_archive_flag_spec was expanded, because we can't\n\t  # assume the linker understands whole_archive_flag_spec.\n\t  # This may have to be revisited, in case too many\n\t  # convenience libraries get linked in and end up exceeding\n\t  # the spec.\n\t  if test -z \"$convenience\" || test -z \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t  fi\n\t  save_output=$output\n\t  func_basename \"$output\"\n\t  output_la=$func_basename_result\n\n\t  # Clear the reloadable object creation command queue and\n\t  # initialize k to one.\n\t  test_cmds=\n\t  concat_cmds=\n\t  objlist=\n\t  last_robj=\n\t  k=1\n\n\t  if test -n \"$save_libobjs\" && test : != \"$skipped_export\" && test yes = \"$with_gnu_ld\"; then\n\t    output=$output_objdir/$output_la.lnkscript\n\t    func_verbose \"creating GNU ld script: $output\"\n\t    echo 'INPUT (' > $output\n\t    for obj in $save_libobjs\n\t    do\n\t      func_to_tool_file \"$obj\"\n\t      $ECHO \"$func_to_tool_file_result\" >> $output\n\t    done\n\t    echo ')' >> $output\n\t    func_append delfiles \" $output\"\n\t    func_to_tool_file \"$output\"\n\t    output=$func_to_tool_file_result\n\t  elif test -n \"$save_libobjs\" && test : != \"$skipped_export\" && test -n \"$file_list_spec\"; then\n\t    output=$output_objdir/$output_la.lnk\n\t    func_verbose \"creating linker input file list: $output\"\n\t    : > $output\n\t    set x $save_libobjs\n\t    shift\n\t    firstobj=\n\t    if test yes = \"$compiler_needs_object\"; then\n\t      firstobj=\"$1 \"\n\t      shift\n\t    fi\n\t    for obj\n\t    do\n\t      func_to_tool_file \"$obj\"\n\t      $ECHO \"$func_to_tool_file_result\" >> $output\n\t    done\n\t    func_append delfiles \" $output\"\n\t    func_to_tool_file \"$output\"\n\t    output=$firstobj\\\"$file_list_spec$func_to_tool_file_result\\\"\n\t  else\n\t    if test -n \"$save_libobjs\"; then\n\t      func_verbose \"creating reloadable object files...\"\n\t      output=$output_objdir/$output_la-$k.$objext\n\t      eval test_cmds=\\\"$reload_cmds\\\"\n\t      func_len \" $test_cmds\"\n\t      len0=$func_len_result\n\t      len=$len0\n\n\t      # Loop over the list of objects to be linked.\n\t      for obj in $save_libobjs\n\t      do\n\t\tfunc_len \" $obj\"\n\t\tfunc_arith $len + $func_len_result\n\t\tlen=$func_arith_result\n\t\tif test -z \"$objlist\" ||\n\t\t   test \"$len\" -lt \"$max_cmd_len\"; then\n\t\t  func_append objlist \" $obj\"\n\t\telse\n\t\t  # The command $test_cmds is almost too long, add a\n\t\t  # command to the queue.\n\t\t  if test 1 -eq \"$k\"; then\n\t\t    # The first file doesn't have a previous command to add.\n\t\t    reload_objs=$objlist\n\t\t    eval concat_cmds=\\\"$reload_cmds\\\"\n\t\t  else\n\t\t    # All subsequent reloadable object files will link in\n\t\t    # the last one created.\n\t\t    reload_objs=\"$objlist $last_robj\"\n\t\t    eval concat_cmds=\\\"\\$concat_cmds~$reload_cmds~\\$RM $last_robj\\\"\n\t\t  fi\n\t\t  last_robj=$output_objdir/$output_la-$k.$objext\n\t\t  func_arith $k + 1\n\t\t  k=$func_arith_result\n\t\t  output=$output_objdir/$output_la-$k.$objext\n\t\t  objlist=\" $obj\"\n\t\t  func_len \" $last_robj\"\n\t\t  func_arith $len0 + $func_len_result\n\t\t  len=$func_arith_result\n\t\tfi\n\t      done\n\t      # Handle the remaining objects by creating one last\n\t      # reloadable object file.  All subsequent reloadable object\n\t      # files will link in the last one created.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      reload_objs=\"$objlist $last_robj\"\n\t      eval concat_cmds=\\\"\\$concat_cmds$reload_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t        eval concat_cmds=\\\"\\$concat_cmds~\\$RM $last_robj\\\"\n\t      fi\n\t      func_append delfiles \" $output\"\n\n\t    else\n\t      output=\n\t    fi\n\n\t    ${skipped_export-false} && {\n\t      func_verbose \"generating symbol list for '$libname.la'\"\n\t      export_symbols=$output_objdir/$libname.exp\n\t      $opt_dry_run || $RM $export_symbols\n\t      libobjs=$output\n\t      # Append the command to create the export file.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\$concat_cmds$export_symbols_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t\teval concat_cmds=\\\"\\$concat_cmds~\\$RM $last_robj\\\"\n\t      fi\n\t    }\n\n\t    test -n \"$save_libobjs\" &&\n\t      func_verbose \"creating a temporary reloadable object file: $output\"\n\n\t    # Loop through the commands generated above and execute them.\n\t    save_ifs=$IFS; IFS='~'\n\t    for cmd in $concat_cmds; do\n\t      IFS=$save_ifs\n\t      $opt_quiet || {\n\t\t  func_quote_for_expand \"$cmd\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t      }\n\t      $opt_dry_run || eval \"$cmd\" || {\n\t\tlt_exit=$?\n\n\t\t# Restore the uninstalled library and exit\n\t\tif test relink = \"$opt_mode\"; then\n\t\t  ( cd \"$output_objdir\" && \\\n\t\t    $RM \"${realname}T\" && \\\n\t\t    $MV \"${realname}U\" \"$realname\" )\n\t\tfi\n\n\t\texit $lt_exit\n\t      }\n\t    done\n\t    IFS=$save_ifs\n\n\t    if test -n \"$export_symbols_regex\" && ${skipped_export-false}; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\n          ${skipped_export-false} && {\n\t    if test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t      tmp_export_symbols=$export_symbols\n\t      test -n \"$orig_export_symbols\" && tmp_export_symbols=$orig_export_symbols\n\t      $opt_dry_run || eval '$ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"'\n\t    fi\n\n\t    if test -n \"$orig_export_symbols\"; then\n\t      # The given exports_symbols file has to be filtered, so filter it.\n\t      func_verbose \"filter symbol list for '$libname.la' to tag DATA exports\"\n\t      # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t      # 's' commands, which not all seds can handle. GNU sed should be fine\n\t      # though. Also, the filter scales superlinearly with the number of\n\t      # global variables. join(1) would be nice here, but unfortunately\n\t      # isn't a blessed tool.\n\t      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t      func_append delfiles \" $export_symbols $output_objdir/$libname.filter\"\n\t      export_symbols=$output_objdir/$libname.def\n\t      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\t    fi\n\t  }\n\n\t  libobjs=$output\n\t  # Restore the value of output.\n\t  output=$save_output\n\n\t  if test -n \"$convenience\" && test -n \"$whole_archive_flag_spec\"; then\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\t  # Expand the library linking commands again to reset the\n\t  # value of $libobjs for piecewise linking.\n\n\t  # Do each of the archive commands.\n\t  if test yes = \"$module\" && test -n \"$module_cmds\"; then\n\t    if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t      cmds=$module_expsym_cmds\n\t    else\n\t      cmds=$module_cmds\n\t    fi\n\t  else\n\t    if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t      cmds=$archive_expsym_cmds\n\t    else\n\t      cmds=$archive_cmds\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$delfiles\"; then\n\t  # Append the command to remove temporary files to $cmds.\n\t  eval cmds=\\\"\\$cmds~\\$RM $delfiles\\\"\n\tfi\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=$output_objdir/${outputname}x\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  func_append libobjs \" $func_extract_archives_result\"\n\t  test \"X$libobjs\" = \"X \" && libobjs=\n\tfi\n\n\tsave_ifs=$IFS; IFS='~'\n\tfor cmd in $cmds; do\n\t  IFS=$sp$nl\n\t  eval cmd=\\\"$cmd\\\"\n\t  IFS=$save_ifs\n\t  $opt_quiet || {\n\t    func_quote_for_expand \"$cmd\"\n\t    eval \"func_echo $func_quote_for_expand_result\"\n\t  }\n\t  $opt_dry_run || eval \"$cmd\" || {\n\t    lt_exit=$?\n\n\t    # Restore the uninstalled library and exit\n\t    if test relink = \"$opt_mode\"; then\n\t      ( cd \"$output_objdir\" && \\\n\t        $RM \"${realname}T\" && \\\n\t\t$MV \"${realname}U\" \"$realname\" )\n\t    fi\n\n\t    exit $lt_exit\n\t  }\n\tdone\n\tIFS=$save_ifs\n\n\t# Restore the uninstalled library and exit\n\tif test relink = \"$opt_mode\"; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?\n\n\t  if test -n \"$convenience\"; then\n\t    if test -z \"$whole_archive_flag_spec\"; then\n\t      func_show_eval '${RM}r \"$gentop\"'\n\t    fi\n\t  fi\n\n\t  exit $EXIT_SUCCESS\n\tfi\n\n\t# Create links to the real library.\n\tfor linkname in $linknames; do\n\t  if test \"$realname\" != \"$linkname\"; then\n\t    func_show_eval '(cd \"$output_objdir\" && $RM \"$linkname\" && $LN_S \"$realname\" \"$linkname\")' 'exit $?'\n\t  fi\n\tdone\n\n\t# If -module or -export-dynamic was specified, set the dlname.\n\tif test yes = \"$module\" || test yes = \"$export_dynamic\"; then\n\t  # On all known operating systems, these are identical.\n\t  dlname=$soname\n\tfi\n      fi\n      ;;\n\n    obj)\n      if test -n \"$dlfiles$dlprefiles\" || test no != \"$dlself\"; then\n\tfunc_warning \"'-dlopen' is ignored for objects\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"'-l' and '-L' are ignored for objects\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"'-rpath' is ignored for objects\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"'-R' is ignored for objects\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"'-version-info' is ignored for objects\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"'-release' is ignored for objects\"\n\n      case $output in\n      *.lo)\n\ttest -n \"$objs$old_deplibs\" && \\\n\t  func_fatal_error \"cannot build library object '$output' from non-libtool objects\"\n\n\tlibobj=$output\n\tfunc_lo2o \"$libobj\"\n\tobj=$func_lo2o_result\n\t;;\n      *)\n\tlibobj=\n\tobj=$output\n\t;;\n      esac\n\n      # Delete the old objects.\n      $opt_dry_run || $RM $obj $libobj\n\n      # Objects from convenience libraries.  This assumes\n      # single-version convenience libraries.  Whenever we create\n      # different ones for PIC/non-PIC, this we'll have to duplicate\n      # the extraction.\n      reload_conv_objs=\n      gentop=\n      # if reload_cmds runs $LD directly, get rid of -Wl from\n      # whole_archive_flag_spec and hope we can get by with turning comma\n      # into space.\n      case $reload_cmds in\n        *\\$LD[\\ \\$]*) wl= ;;\n      esac\n      if test -n \"$convenience\"; then\n\tif test -n \"$whole_archive_flag_spec\"; then\n\t  eval tmp_whole_archive_flags=\\\"$whole_archive_flag_spec\\\"\n\t  test -n \"$wl\" || tmp_whole_archive_flags=`$ECHO \"$tmp_whole_archive_flags\" | $SED 's|,| |g'`\n\t  reload_conv_objs=$reload_objs\\ $tmp_whole_archive_flags\n\telse\n\t  gentop=$output_objdir/${obj}x\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $convenience\n\t  reload_conv_objs=\"$reload_objs $func_extract_archives_result\"\n\tfi\n      fi\n\n      # If we're not building shared, we need to use non_pic_objs\n      test yes = \"$build_libtool_libs\" || libobjs=$non_pic_objects\n\n      # Create the old-style object.\n      reload_objs=$objs$old_deplibs' '`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.$libext$/d; /\\.lib$/d; $lo2o\" | $NL2SP`' '$reload_conv_objs\n\n      output=$obj\n      func_execute_cmds \"$reload_cmds\" 'exit $?'\n\n      # Exit if we aren't doing a library object file.\n      if test -z \"$libobj\"; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      test yes = \"$build_libtool_libs\" || {\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\t# Create an invalid libtool object if no PIC, so that we don't\n\t# accidentally link it into a program.\n\t# $show \"echo timestamp > $libobj\"\n\t# $opt_dry_run || eval \"echo timestamp > $libobj\" || exit $?\n\texit $EXIT_SUCCESS\n      }\n\n      if test -n \"$pic_flag\" || test default != \"$pic_mode\"; then\n\t# Only do commands if we really have different PIC objects.\n\treload_objs=\"$libobjs $reload_conv_objs\"\n\toutput=$libobj\n\tfunc_execute_cmds \"$reload_cmds\" 'exit $?'\n      fi\n\n      if test -n \"$gentop\"; then\n\tfunc_show_eval '${RM}r \"$gentop\"'\n      fi\n\n      exit $EXIT_SUCCESS\n      ;;\n\n    prog)\n      case $host in\n\t*cygwin*) func_stripname '' '.exe' \"$output\"\n\t          output=$func_stripname_result.exe;;\n      esac\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"'-version-info' is ignored for programs\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"'-release' is ignored for programs\"\n\n      $preload \\\n\t&& test unknown,unknown,unknown = \"$dlopen_support,$dlopen_self,$dlopen_self_static\" \\\n\t&& func_warning \"'LT_INIT([dlopen])' not used. Assuming no dlopen support.\"\n\n      case $host in\n      *-*-rhapsody* | *-*-darwin1.[012])\n\t# On Rhapsody replace the C library is the System framework\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t;;\n      esac\n\n      case $host in\n      *-*-darwin*)\n\t# Don't allow lazy linking, it breaks C++ global constructors\n\t# But is supposedly fixed on 10.4 or later (yay!).\n\tif test CXX = \"$tagname\"; then\n\t  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in\n\t    10.[0123])\n\t      func_append compile_command \" $wl-bind_at_load\"\n\t      func_append finalize_command \" $wl-bind_at_load\"\n\t    ;;\n\t  esac\n\tfi\n\t# Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t;;\n      esac\n\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $compile_deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    func_append new_libs \" -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $compile_deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) func_append new_libs \" $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) func_append new_libs \" $deplib\" ;;\n\tesac\n      done\n      compile_deplibs=$new_libs\n\n\n      func_append compile_command \" $compile_deplibs\"\n      func_append finalize_command \" $finalize_deplibs\"\n\n      if test -n \"$rpath$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\tfor libdir in $rpath $xrpath; do\n\t  # This is the magic to use -rpath.\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_rpath \" $libdir\" ;;\n\t  esac\n\tdone\n      fi\n\n      # Now hardcode the library paths\n      rpath=\n      hardcode_libdirs=\n      for libdir in $compile_rpath $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=$libdir\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\tfunc_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    func_append rpath \" $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append perm_rpath \" $libdir\" ;;\n\t  esac\n\tfi\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`$ECHO \"$libdir\" | $SED -e 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$libdir:\"*) ;;\n\t  ::) dllsearchpath=$libdir;;\n\t  *) func_append dllsearchpath \":$libdir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) func_append dllsearchpath \":$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=$hardcode_libdirs\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      compile_rpath=$rpath\n\n      rpath=\n      hardcode_libdirs=\n      for libdir in $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=$libdir\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\tfunc_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    func_append rpath \" $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$finalize_perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_perm_rpath \" $libdir\" ;;\n\t  esac\n\tfi\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=$hardcode_libdirs\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      finalize_rpath=$rpath\n\n      if test -n \"$libobjs\" && test yes = \"$build_old_libs\"; then\n\t# Transform all the library objects into standard objects.\n\tcompile_command=`$ECHO \"$compile_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\tfinalize_command=`$ECHO \"$finalize_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n      fi\n\n      func_generate_dlsyms \"$outputname\" \"@PROGRAM@\" false\n\n      # template prelinking step\n      if test -n \"$prelink_cmds\"; then\n\tfunc_execute_cmds \"$prelink_cmds\" 'exit $?'\n      fi\n\n      wrappers_required=:\n      case $host in\n      *cegcc* | *mingw32ce*)\n        # Disable wrappers for cegcc and mingw32ce hosts, we are cross compiling anyway.\n        wrappers_required=false\n        ;;\n      *cygwin* | *mingw* )\n        test yes = \"$build_libtool_libs\" || wrappers_required=false\n        ;;\n      *)\n        if test no = \"$need_relink\" || test yes != \"$build_libtool_libs\"; then\n          wrappers_required=false\n        fi\n        ;;\n      esac\n      $wrappers_required || {\n\t# Replace the output file specification.\n\tcompile_command=`$ECHO \"$compile_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\tlink_command=$compile_command$compile_rpath\n\n\t# We have no uninstalled library dependencies, so finalize right now.\n\texit_status=0\n\tfunc_show_eval \"$link_command\" 'exit_status=$?'\n\n\tif test -n \"$postlink_cmds\"; then\n\t  func_to_tool_file \"$output\"\n\t  postlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\t  func_execute_cmds \"$postlink_cmds\" 'exit $?'\n\tfi\n\n\t# Delete the generated files.\n\tif test -f \"$output_objdir/${outputname}S.$objext\"; then\n\t  func_show_eval '$RM \"$output_objdir/${outputname}S.$objext\"'\n\tfi\n\n\texit $exit_status\n      }\n\n      if test -n \"$compile_shlibpath$finalize_shlibpath\"; then\n\tcompile_command=\"$shlibpath_var=\\\"$compile_shlibpath$finalize_shlibpath\\$$shlibpath_var\\\" $compile_command\"\n      fi\n      if test -n \"$finalize_shlibpath\"; then\n\tfinalize_command=\"$shlibpath_var=\\\"$finalize_shlibpath\\$$shlibpath_var\\\" $finalize_command\"\n      fi\n\n      compile_var=\n      finalize_var=\n      if test -n \"$runpath_var\"; then\n\tif test -n \"$perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $perm_rpath; do\n\t    func_append rpath \"$dir:\"\n\t  done\n\t  compile_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n\tif test -n \"$finalize_perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $finalize_perm_rpath; do\n\t    func_append rpath \"$dir:\"\n\t  done\n\t  finalize_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n      fi\n\n      if test yes = \"$no_install\"; then\n\t# We don't need to create a wrapper script.\n\tlink_command=$compile_var$compile_command$compile_rpath\n\t# Replace the output file specification.\n\tlink_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\t# Delete the old output file.\n\t$opt_dry_run || $RM $output\n\t# Link the executable and exit\n\tfunc_show_eval \"$link_command\" 'exit $?'\n\n\tif test -n \"$postlink_cmds\"; then\n\t  func_to_tool_file \"$output\"\n\t  postlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\t  func_execute_cmds \"$postlink_cmds\" 'exit $?'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      case $hardcode_action,$fast_install in\n        relink,*)\n\t  # Fast installation is not supported\n\t  link_command=$compile_var$compile_command$compile_rpath\n\t  relink_command=$finalize_var$finalize_command$finalize_rpath\n\n\t  func_warning \"this platform does not like uninstalled shared libraries\"\n\t  func_warning \"'$output' will be relinked during installation\"\n\t  ;;\n        *,yes)\n\t  link_command=$finalize_var$compile_command$finalize_rpath\n\t  relink_command=`$ECHO \"$compile_var$compile_command$compile_rpath\" | $SED 's%@OUTPUT@%\\$progdir/\\$file%g'`\n          ;;\n\t*,no)\n\t  link_command=$compile_var$compile_command$compile_rpath\n\t  relink_command=$finalize_var$finalize_command$finalize_rpath\n          ;;\n\t*,needless)\n\t  link_command=$finalize_var$compile_command$finalize_rpath\n\t  relink_command=\n          ;;\n      esac\n\n      # Replace the output file specification.\n      link_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g'`\n\n      # Delete the old output files.\n      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname\n\n      func_show_eval \"$link_command\" 'exit $?'\n\n      if test -n \"$postlink_cmds\"; then\n\tfunc_to_tool_file \"$output_objdir/$outputname\"\n\tpostlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\tfunc_execute_cmds \"$postlink_cmds\" 'exit $?'\n      fi\n\n      # Now create the wrapper script.\n      func_verbose \"creating $output\"\n\n      # Quote the relink command for shipping.\n      if test -n \"$relink_command\"; then\n\t# Preserve any variables that may affect compiler behavior\n\tfor var in $variables_saved_for_relink; do\n\t  if eval test -z \\\"\\${$var+set}\\\"; then\n\t    relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\t  elif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t    relink_command=\"$var=; export $var; $relink_command\"\n\t  else\n\t    func_quote_for_eval \"$var_value\"\n\t    relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\t  fi\n\tdone\n\trelink_command=\"(cd `pwd`; $relink_command)\"\n\trelink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      fi\n\n      # Only actually do things if not in dry run mode.\n      $opt_dry_run || {\n\t# win32 will think the script is a binary if it has\n\t# a .exe suffix, so we strip it off here.\n\tcase $output in\n\t  *.exe) func_stripname '' '.exe' \"$output\"\n\t         output=$func_stripname_result ;;\n\tesac\n\t# test for cygwin because mv fails w/o .exe extensions\n\tcase $host in\n\t  *cygwin*)\n\t    exeext=.exe\n\t    func_stripname '' '.exe' \"$outputname\"\n\t    outputname=$func_stripname_result ;;\n\t  *) exeext= ;;\n\tesac\n\tcase $host in\n\t  *cygwin* | *mingw* )\n\t    func_dirname_and_basename \"$output\" \"\" \".\"\n\t    output_name=$func_basename_result\n\t    output_path=$func_dirname_result\n\t    cwrappersource=$output_path/$objdir/lt-$output_name.c\n\t    cwrapper=$output_path/$output_name.exe\n\t    $RM $cwrappersource $cwrapper\n\t    trap \"$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_cwrapperexe_src > $cwrappersource\n\n\t    # The wrapper executable is built using the $host compiler,\n\t    # because it contains $host paths and files. If cross-\n\t    # compiling, it, like the target executable, must be\n\t    # executed on the $host or under an emulation environment.\n\t    $opt_dry_run || {\n\t      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource\n\t      $STRIP $cwrapper\n\t    }\n\n\t    # Now, create the wrapper script for func_source use:\n\t    func_ltwrapper_scriptname $cwrapper\n\t    $RM $func_ltwrapper_scriptname_result\n\t    trap \"$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE\" 1 2 15\n\t    $opt_dry_run || {\n\t      # note: this script will not be executed, so do not chmod.\n\t      if test \"x$build\" = \"x$host\"; then\n\t\t$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result\n\t      else\n\t\tfunc_emit_wrapper no > $func_ltwrapper_scriptname_result\n\t      fi\n\t    }\n\t  ;;\n\t  * )\n\t    $RM $output\n\t    trap \"$RM $output; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_wrapper no > $output\n\t    chmod +x $output\n\t  ;;\n\tesac\n      }\n      exit $EXIT_SUCCESS\n      ;;\n    esac\n\n    # See if we need to build an old-fashioned archive.\n    for oldlib in $oldlibs; do\n\n      case $build_libtool_libs in\n        convenience)\n\t  oldobjs=\"$libobjs_save $symfileobj\"\n\t  addlibs=$convenience\n\t  build_libtool_libs=no\n\t  ;;\n\tmodule)\n\t  oldobjs=$libobjs_save\n\t  addlibs=$old_convenience\n\t  build_libtool_libs=no\n          ;;\n\t*)\n\t  oldobjs=\"$old_deplibs $non_pic_objects\"\n\t  $preload && test -f \"$symfileobj\" \\\n\t    && func_append oldobjs \" $symfileobj\"\n\t  addlibs=$old_convenience\n\t  ;;\n      esac\n\n      if test -n \"$addlibs\"; then\n\tgentop=$output_objdir/${outputname}x\n\tfunc_append generated \" $gentop\"\n\n\tfunc_extract_archives $gentop $addlibs\n\tfunc_append oldobjs \" $func_extract_archives_result\"\n      fi\n\n      # Do each command in the archive commands.\n      if test -n \"$old_archive_from_new_cmds\" && test yes = \"$build_libtool_libs\"; then\n\tcmds=$old_archive_from_new_cmds\n      else\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=$output_objdir/${outputname}x\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  func_append oldobjs \" $func_extract_archives_result\"\n\tfi\n\n\t# POSIX demands no paths to be encoded in archives.  We have\n\t# to avoid creating archives with duplicate basenames if we\n\t# might have to extract them afterwards, e.g., when creating a\n\t# static archive out of a convenience library, or when linking\n\t# the entirety of a libtool archive into another (currently\n\t# not supported by libtool).\n\tif (for obj in $oldobjs\n\t    do\n\t      func_basename \"$obj\"\n\t      $ECHO \"$func_basename_result\"\n\t    done | sort | sort -uc >/dev/null 2>&1); then\n\t  :\n\telse\n\t  echo \"copying selected object files to avoid basename conflicts...\"\n\t  gentop=$output_objdir/${outputname}x\n\t  func_append generated \" $gentop\"\n\t  func_mkdir_p \"$gentop\"\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  counter=1\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_basename \"$obj\"\n\t    objbase=$func_basename_result\n\t    case \" $oldobjs \" in\n\t    \" \") oldobjs=$obj ;;\n\t    *[\\ /]\"$objbase \"*)\n\t      while :; do\n\t\t# Make sure we don't pick an alternate name that also\n\t\t# overlaps.\n\t\tnewobj=lt$counter-$objbase\n\t\tfunc_arith $counter + 1\n\t\tcounter=$func_arith_result\n\t\tcase \" $oldobjs \" in\n\t\t*[\\ /]\"$newobj \"*) ;;\n\t\t*) if test ! -f \"$gentop/$newobj\"; then break; fi ;;\n\t\tesac\n\t      done\n\t      func_show_eval \"ln $obj $gentop/$newobj || cp $obj $gentop/$newobj\"\n\t      func_append oldobjs \" $gentop/$newobj\"\n\t      ;;\n\t    *) func_append oldobjs \" $obj\" ;;\n\t    esac\n\t  done\n\tfi\n\tfunc_to_tool_file \"$oldlib\" func_convert_file_msys_to_w32\n\ttool_oldlib=$func_to_tool_file_result\n\teval cmds=\\\"$old_archive_cmds\\\"\n\n\tfunc_len \" $cmds\"\n\tlen=$func_len_result\n\tif test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  cmds=$old_archive_cmds\n\telif test -n \"$archiver_list_spec\"; then\n\t  func_verbose \"using command file archive linking...\"\n\t  for obj in $oldobjs\n\t  do\n\t    func_to_tool_file \"$obj\"\n\t    $ECHO \"$func_to_tool_file_result\"\n\t  done > $output_objdir/$libname.libcmd\n\t  func_to_tool_file \"$output_objdir/$libname.libcmd\"\n\t  oldobjs=\" $archiver_list_spec$func_to_tool_file_result\"\n\t  cmds=$old_archive_cmds\n\telse\n\t  # the command line is too long to link in one step, link in parts\n\t  func_verbose \"using piecewise archive linking...\"\n\t  save_RANLIB=$RANLIB\n\t  RANLIB=:\n\t  objlist=\n\t  concat_cmds=\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  # Is there a better way of finding the last object in the list?\n\t  for obj in $save_oldobjs\n\t  do\n\t    last_oldobj=$obj\n\t  done\n\t  eval test_cmds=\\\"$old_archive_cmds\\\"\n\t  func_len \" $test_cmds\"\n\t  len0=$func_len_result\n\t  len=$len0\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_len \" $obj\"\n\t    func_arith $len + $func_len_result\n\t    len=$func_arith_result\n\t    func_append objlist \" $obj\"\n\t    if test \"$len\" -lt \"$max_cmd_len\"; then\n\t      :\n\t    else\n\t      # the above command should be used before it gets too long\n\t      oldobjs=$objlist\n\t      if test \"$obj\" = \"$last_oldobj\"; then\n\t\tRANLIB=$save_RANLIB\n\t      fi\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\$concat_cmds$old_archive_cmds\\\"\n\t      objlist=\n\t      len=$len0\n\t    fi\n\t  done\n\t  RANLIB=$save_RANLIB\n\t  oldobjs=$objlist\n\t  if test -z \"$oldobjs\"; then\n\t    eval cmds=\\\"\\$concat_cmds\\\"\n\t  else\n\t    eval cmds=\\\"\\$concat_cmds~\\$old_archive_cmds\\\"\n\t  fi\n\tfi\n      fi\n      func_execute_cmds \"$cmds\" 'exit $?'\n    done\n\n    test -n \"$generated\" && \\\n      func_show_eval \"${RM}r$generated\"\n\n    # Now create the libtool archive.\n    case $output in\n    *.la)\n      old_library=\n      test yes = \"$build_old_libs\" && old_library=$libname.$libext\n      func_verbose \"creating $output\"\n\n      # Preserve any variables that may affect compiler behavior\n      for var in $variables_saved_for_relink; do\n\tif eval test -z \\\"\\${$var+set}\\\"; then\n\t  relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\telif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t  relink_command=\"$var=; export $var; $relink_command\"\n\telse\n\t  func_quote_for_eval \"$var_value\"\n\t  relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\tfi\n      done\n      # Quote the link command for shipping.\n      relink_command=\"(cd `pwd`; $SHELL \\\"$progpath\\\" $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)\"\n      relink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      if test yes = \"$hardcode_automatic\"; then\n\trelink_command=\n      fi\n\n      # Only create the output if not a dry run.\n      $opt_dry_run || {\n\tfor installed in no yes; do\n\t  if test yes = \"$installed\"; then\n\t    if test -z \"$install_libdir\"; then\n\t      break\n\t    fi\n\t    output=$output_objdir/${outputname}i\n\t    # Replace all uninstalled libtool libraries with the installed ones\n\t    newdependency_libs=\n\t    for deplib in $dependency_libs; do\n\t      case $deplib in\n\t      *.la)\n\t\tfunc_basename \"$deplib\"\n\t\tname=$func_basename_result\n\t\tfunc_resolve_sysroot \"$deplib\"\n\t\teval libdir=`$SED -n -e 's/^libdir=\\(.*\\)$/\\1/p' $func_resolve_sysroot_result`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"'$deplib' is not a valid libtool archive\"\n\t\tfunc_append newdependency_libs \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      -L*)\n\t\tfunc_stripname -L '' \"$deplib\"\n\t\tfunc_replace_sysroot \"$func_stripname_result\"\n\t\tfunc_append newdependency_libs \" -L$func_replace_sysroot_result\"\n\t\t;;\n\t      -R*)\n\t\tfunc_stripname -R '' \"$deplib\"\n\t\tfunc_replace_sysroot \"$func_stripname_result\"\n\t\tfunc_append newdependency_libs \" -R$func_replace_sysroot_result\"\n\t\t;;\n\t      *) func_append newdependency_libs \" $deplib\" ;;\n\t      esac\n\t    done\n\t    dependency_libs=$newdependency_libs\n\t    newdlfiles=\n\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t      *.la)\n\t        func_basename \"$lib\"\n\t\tname=$func_basename_result\n\t\teval libdir=`$SED -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"'$lib' is not a valid libtool archive\"\n\t\tfunc_append newdlfiles \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      *) func_append newdlfiles \" $lib\" ;;\n\t      esac\n\t    done\n\t    dlfiles=$newdlfiles\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t      *.la)\n\t\t# Only pass preopened files to the pseudo-archive (for\n\t\t# eventual linking with the app. that links it) if we\n\t\t# didn't already link the preopened objects directly into\n\t\t# the library:\n\t\tfunc_basename \"$lib\"\n\t\tname=$func_basename_result\n\t\teval libdir=`$SED -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"'$lib' is not a valid libtool archive\"\n\t\tfunc_append newdlprefiles \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      esac\n\t    done\n\t    dlprefiles=$newdlprefiles\n\t  else\n\t    newdlfiles=\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=$lib ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      func_append newdlfiles \" $abs\"\n\t    done\n\t    dlfiles=$newdlfiles\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=$lib ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      func_append newdlprefiles \" $abs\"\n\t    done\n\t    dlprefiles=$newdlprefiles\n\t  fi\n\t  $RM $output\n\t  # place dlname in correct position for cygwin\n\t  # In fact, it would be nice if we could use this code for all target\n\t  # systems that can't hard-code library paths into their executables\n\t  # and that have no shared library path variable independent of PATH,\n\t  # but it turns out we can't easily determine that from inspecting\n\t  # libtool variables, so we have to hard-code the OSs to which it\n\t  # applies here; at the moment, that means platforms that use the PE\n\t  # object format with DLL files.  See the long comment at the top of\n\t  # tests/bindir.at for full details.\n\t  tdlname=$dlname\n\t  case $host,$output,$installed,$module,$dlname in\n\t    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll)\n\t      # If a -bindir argument was supplied, place the dll there.\n\t      if test -n \"$bindir\"; then\n\t\tfunc_relative_path \"$install_libdir\" \"$bindir\"\n\t\ttdlname=$func_relative_path_result/$dlname\n\t      else\n\t\t# Otherwise fall back on heuristic.\n\t\ttdlname=../bin/$dlname\n\t      fi\n\t      ;;\n\t  esac\n\t  $ECHO > $output \"\\\n# $outputname - a libtool library file\n# Generated by $PROGRAM (GNU $PACKAGE) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# The name that we can dlopen(3).\ndlname='$tdlname'\n\n# Names of this library.\nlibrary_names='$library_names'\n\n# The name of the static archive.\nold_library='$old_library'\n\n# Linker flags that cannot go in dependency_libs.\ninherited_linker_flags='$new_inherited_linker_flags'\n\n# Libraries that this one depends upon.\ndependency_libs='$dependency_libs'\n\n# Names of additional weak libraries provided by this library\nweak_library_names='$weak_libs'\n\n# Version information for $libname.\ncurrent=$current\nage=$age\nrevision=$revision\n\n# Is this an already installed library?\ninstalled=$installed\n\n# Should we warn about portability when linking against -modules?\nshouldnotlink=$module\n\n# Files to dlopen/dlpreopen\ndlopen='$dlfiles'\ndlpreopen='$dlprefiles'\n\n# Directory that this library needs to be installed in:\nlibdir='$install_libdir'\"\n\t  if test no,yes = \"$installed,$need_relink\"; then\n\t    $ECHO >> $output \"\\\nrelink_command=\\\"$relink_command\\\"\"\n\t  fi\n\tdone\n      }\n\n      # Do a symbolic link so that the libtool archive can be found in\n      # LD_LIBRARY_PATH before the program is installed.\n      func_show_eval '( cd \"$output_objdir\" && $RM \"$outputname\" && $LN_S \"../$outputname\" \"$outputname\" )' 'exit $?'\n      ;;\n    esac\n    exit $EXIT_SUCCESS\n}\n\nif test link = \"$opt_mode\" || test relink = \"$opt_mode\"; then\n  func_mode_link ${1+\"$@\"}\nfi\n\n\n# func_mode_uninstall arg...\nfunc_mode_uninstall ()\n{\n    $debug_cmd\n\n    RM=$nonopt\n    files=\n    rmforce=false\n    exit_status=0\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=$magic\n\n    for arg\n    do\n      case $arg in\n      -f) func_append RM \" $arg\"; rmforce=: ;;\n      -*) func_append RM \" $arg\" ;;\n      *) func_append files \" $arg\" ;;\n      esac\n    done\n\n    test -z \"$RM\" && \\\n      func_fatal_help \"you must specify an RM program\"\n\n    rmdirs=\n\n    for file in $files; do\n      func_dirname \"$file\" \"\" \".\"\n      dir=$func_dirname_result\n      if test . = \"$dir\"; then\n\todir=$objdir\n      else\n\todir=$dir/$objdir\n      fi\n      func_basename \"$file\"\n      name=$func_basename_result\n      test uninstall = \"$opt_mode\" && odir=$dir\n\n      # Remember odir for removal later, being careful to avoid duplicates\n      if test clean = \"$opt_mode\"; then\n\tcase \" $rmdirs \" in\n\t  *\" $odir \"*) ;;\n\t  *) func_append rmdirs \" $odir\" ;;\n\tesac\n      fi\n\n      # Don't error if the file doesn't exist and rm -f was used.\n      if { test -L \"$file\"; } >/dev/null 2>&1 ||\n\t { test -h \"$file\"; } >/dev/null 2>&1 ||\n\t test -f \"$file\"; then\n\t:\n      elif test -d \"$file\"; then\n\texit_status=1\n\tcontinue\n      elif $rmforce; then\n\tcontinue\n      fi\n\n      rmfiles=$file\n\n      case $name in\n      *.la)\n\t# Possibly a libtool archive, so verify it.\n\tif func_lalib_p \"$file\"; then\n\t  func_source $dir/$name\n\n\t  # Delete the libtool libraries and symlinks.\n\t  for n in $library_names; do\n\t    func_append rmfiles \" $odir/$n\"\n\t  done\n\t  test -n \"$old_library\" && func_append rmfiles \" $odir/$old_library\"\n\n\t  case $opt_mode in\n\t  clean)\n\t    case \" $library_names \" in\n\t    *\" $dlname \"*) ;;\n\t    *) test -n \"$dlname\" && func_append rmfiles \" $odir/$dlname\" ;;\n\t    esac\n\t    test -n \"$libdir\" && func_append rmfiles \" $odir/$name $odir/${name}i\"\n\t    ;;\n\t  uninstall)\n\t    if test -n \"$library_names\"; then\n\t      # Do each command in the postuninstall commands.\n\t      func_execute_cmds \"$postuninstall_cmds\" '$rmforce || exit_status=1'\n\t    fi\n\n\t    if test -n \"$old_library\"; then\n\t      # Do each command in the old_postuninstall commands.\n\t      func_execute_cmds \"$old_postuninstall_cmds\" '$rmforce || exit_status=1'\n\t    fi\n\t    # FIXME: should reinstall the best remaining shared library.\n\t    ;;\n\t  esac\n\tfi\n\t;;\n\n      *.lo)\n\t# Possibly a libtool object, so verify it.\n\tif func_lalib_p \"$file\"; then\n\n\t  # Read the .lo file\n\t  func_source $dir/$name\n\n\t  # Add PIC object to the list of files to remove.\n\t  if test -n \"$pic_object\" && test none != \"$pic_object\"; then\n\t    func_append rmfiles \" $dir/$pic_object\"\n\t  fi\n\n\t  # Add non-PIC object to the list of files to remove.\n\t  if test -n \"$non_pic_object\" && test none != \"$non_pic_object\"; then\n\t    func_append rmfiles \" $dir/$non_pic_object\"\n\t  fi\n\tfi\n\t;;\n\n      *)\n\tif test clean = \"$opt_mode\"; then\n\t  noexename=$name\n\t  case $file in\n\t  *.exe)\n\t    func_stripname '' '.exe' \"$file\"\n\t    file=$func_stripname_result\n\t    func_stripname '' '.exe' \"$name\"\n\t    noexename=$func_stripname_result\n\t    # $file with .exe has already been added to rmfiles,\n\t    # add $file without .exe\n\t    func_append rmfiles \" $file\"\n\t    ;;\n\t  esac\n\t  # Do a test to see if this is a libtool program.\n\t  if func_ltwrapper_p \"$file\"; then\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      relink_command=\n\t      func_source $func_ltwrapper_scriptname_result\n\t      func_append rmfiles \" $func_ltwrapper_scriptname_result\"\n\t    else\n\t      relink_command=\n\t      func_source $dir/$noexename\n\t    fi\n\n\t    # note $name still contains .exe if it was in $file originally\n\t    # as does the version of $file that was added into $rmfiles\n\t    func_append rmfiles \" $odir/$name $odir/${name}S.$objext\"\n\t    if test yes = \"$fast_install\" && test -n \"$relink_command\"; then\n\t      func_append rmfiles \" $odir/lt-$name\"\n\t    fi\n\t    if test \"X$noexename\" != \"X$name\"; then\n\t      func_append rmfiles \" $odir/lt-$noexename.c\"\n\t    fi\n\t  fi\n\tfi\n\t;;\n      esac\n      func_show_eval \"$RM $rmfiles\" 'exit_status=1'\n    done\n\n    # Try to remove the $objdir's in the directories where we deleted files\n    for dir in $rmdirs; do\n      if test -d \"$dir\"; then\n\tfunc_show_eval \"rmdir $dir >/dev/null 2>&1\"\n      fi\n    done\n\n    exit $exit_status\n}\n\nif test uninstall = \"$opt_mode\" || test clean = \"$opt_mode\"; then\n  func_mode_uninstall ${1+\"$@\"}\nfi\n\ntest -z \"$opt_mode\" && {\n  help=$generic_help\n  func_fatal_help \"you must specify a MODE\"\n}\n\ntest -z \"$exec_cmd\" && \\\n  func_fatal_help \"invalid operation mode '$opt_mode'\"\n\nif test -n \"$exec_cmd\"; then\n  eval exec \"$exec_cmd\"\n  exit $EXIT_FAILURE\nfi\n\nexit $exit_status\n\n\n# The TAGs below are defined such that we never get into a situation\n# where we disable both kinds of libraries.  Given conflicting\n# choices, we go for a static library, that is the most portable,\n# since we can't tell whether shared libraries were disabled because\n# the user asked for that or because the platform doesn't support\n# them.  This is particularly important on AIX, because we don't\n# support having both static and shared libraries enabled at the same\n# time on that platform, so we default to a shared-only configuration.\n# If a disable-shared tag is given, we'll fallback to a static-only\n# configuration.  But we'll never go from static-only to shared-only.\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-shared\nbuild_libtool_libs=no\nbuild_old_libs=yes\n# ### END LIBTOOL TAG CONFIG: disable-shared\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-static\nbuild_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`\n# ### END LIBTOOL TAG CONFIG: disable-static\n\n# Local Variables:\n# mode:shell-script\n# sh-indentation:2\n# End:\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/dyn_load.c": "/*\n * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n * Copyright (c) 1997 by Silicon Graphics.  All rights reserved.\n *\n * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n *\n * Permission is hereby granted to use or copy this program\n * for any purpose,  provided the above notices are retained on all copies.\n * Permission to modify the code and to distribute modified code is granted,\n * provided the above notices are retained, and a notice that the code was\n * modified is included with the above copyright notice.\n *\n * Original author: Bill Janssen\n * Heavily modified by Hans Boehm and others\n */\n\n/*\n * This is incredibly OS specific code for tracking down data sections in\n * dynamic libraries.  There appears to be no way of doing this quickly\n * without groveling through undocumented data structures.  We would argue\n * that this is a bug in the design of the dlopen interface.  THIS CODE\n * MAY BREAK IN FUTURE OS RELEASES.  If this matters to you, don't hesitate\n * to let your vendor know ...\n *\n * None of this is safe with dlclose and incremental collection.\n * But then not much of anything is safe in the presence of dlclose.\n */\n#if (defined(__linux__) || defined(__GLIBC__) || defined(__native_client__)) && !defined(_GNU_SOURCE)\n    /* Can't test LINUX, since this must be define before other includes */\n#   define _GNU_SOURCE\n#endif\n#if !defined(MACOS) && !defined(_WIN32_WCE)\n#  include <sys/types.h>\n#endif\n#include \"private/gc_priv.h\"\n\n/* BTL: avoid circular redefinition of dlopen if GC_SOLARIS_THREADS defined */\n# if (defined(GC_PTHREADS) || defined(GC_SOLARIS_THREADS)) \\\n      && defined(dlopen) && !defined(GC_USE_LD_WRAP)\n    /* To support threads in Solaris, gc.h interposes on dlopen by       */\n    /* defining \"dlopen\" to be \"GC_dlopen\", which is implemented below.  */\n    /* However, both GC_FirstDLOpenedLinkMap() and GC_dlopen() use the   */\n    /* real system dlopen() in their implementation. We first remove     */\n    /* gc.h's dlopen definition and restore it later, after GC_dlopen(). */\n#   undef dlopen\n#   define GC_must_restore_redefined_dlopen\n# else\n#   undef GC_must_restore_redefined_dlopen\n# endif\n\n#if (defined(DYNAMIC_LOADING) || defined(MSWIN32) || defined(MSWINCE)) \\\n    && !defined(PCR)\n#if !defined(SUNOS4) && !defined(SUNOS5DL) && !defined(IRIX5) && \\\n    !defined(MSWIN32) && !defined(MSWINCE) && \\\n    !(defined(ALPHA) && defined(OSF1)) && \\\n    !defined(HPUX) && !((defined(LINUX) || defined(NACL)) && defined(__ELF__)) && \\\n    !defined(RS6000) && !defined(SCO_ELF) && !defined(DGUX) && \\\n    !(defined(FREEBSD) && defined(__ELF__)) && \\\n    !(defined(OPENBSD) && (defined(__ELF__) || defined(M68K))) && \\\n    !(defined(NETBSD) && defined(__ELF__)) && !defined(HURD) && \\\n    !defined(DARWIN) && !defined(HAIKU)\n --> We only know how to find data segments of dynamic libraries for the\n --> above.  Additional SVR4 variants might not be too\n --> hard to add.\n#endif\n\n#include <stdio.h>\n#ifdef SUNOS5DL\n/* Avoid  #error \"large files are not supported by libelf\" errors */\n#if defined(_ILP32) && (_FILE_OFFSET_BITS != 32)\n#undef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 32\n#endif\n#   include <sys/elf.h>\n#   include <dlfcn.h>\n#   include <link.h>\n#endif\n#ifdef SUNOS4\n#   include <dlfcn.h>\n#   include <link.h>\n#   include <a.out.h>\n  /* struct link_map field overrides */\n#   define l_next\tlm_next\n#   define l_addr\tlm_addr\n#   define l_name\tlm_name\n#endif\n\n#if defined(NETBSD)\n#   include <machine/elf_machdep.h>\n#   define ELFSIZE ARCH_ELFSIZE\n#endif\n\n#if (defined(LINUX) || defined(NACL)) && defined(__ELF__) || defined(SCO_ELF) || \\\n    (defined(FREEBSD) && defined(__ELF__)) || defined(DGUX) || \\\n    (defined(OPENBSD) && defined(__ELF__)) || \\\n    (defined(NETBSD) && defined(__ELF__)) || defined(HURD)\n#   include <stddef.h>\n# if !defined(OPENBSD)\n#   include <elf.h>\n# endif\n#   include <link.h>\n#endif\n\n/* Newer versions of GNU/Linux define this macro.  We\n * define it similarly for any ELF systems that don't.  */\n#  ifndef ElfW\n#    if defined(FREEBSD)\n#      if __ELF_WORD_SIZE == 32\n#        define ElfW(type) Elf32_##type\n#      else\n#        define ElfW(type) Elf64_##type\n#      endif\n#    else\n#      ifdef NETBSD\n#        if ELFSIZE == 32\n#          define ElfW(type) Elf32_##type\n#        else\n#          define ElfW(type) Elf64_##type\n#        endif\n#      else\n#        if !defined(ELF_CLASS) || ELF_CLASS == ELFCLASS32\n#          define ElfW(type) Elf32_##type\n#        else\n#          define ElfW(type) Elf64_##type\n#\t endif\n#      endif\n#    endif\n#  endif \n\n#if defined(SUNOS5DL) && !defined(USE_PROC_FOR_LIBRARIES)\n\n#ifdef LINT\n    Elf32_Dyn _DYNAMIC;\n#endif\n\nstatic struct link_map *\nGC_FirstDLOpenedLinkMap()\n{\n    extern ElfW(Dyn) _DYNAMIC;\n    ElfW(Dyn) *dp;\n    struct r_debug *r;\n    static struct link_map * cachedResult = 0;\n    static ElfW(Dyn) *dynStructureAddr = 0;\n    \t\t\t/* BTL: added to avoid Solaris 5.3 ld.so _DYNAMIC bug */\n\n#   ifdef SUNOS53_SHARED_LIB\n\t/* BTL: Avoid the Solaris 5.3 bug that _DYNAMIC isn't being set\t*/\n\t/* up properly in dynamically linked .so's. This means we have\t*/\n\t/* to use its value in the set of original object files loaded\t*/\n\t/* at program startup.\t\t\t\t\t\t*/\n\tif( dynStructureAddr == 0 ) {\n\t  void* startupSyms = dlopen(0, RTLD_LAZY);\n\t  dynStructureAddr = (ElfW(Dyn)*)dlsym(startupSyms, \"_DYNAMIC\");\n\t\t}\n#   else\n\tdynStructureAddr = &_DYNAMIC;\n#   endif\n\n    if( dynStructureAddr == 0) {\n        return(0);\n    }\n    if( cachedResult == 0 ) {\n        int tag;\n        for( dp = ((ElfW(Dyn) *)(&_DYNAMIC)); (tag = dp->d_tag) != 0; dp++ ) {\n            if( tag == DT_DEBUG ) {\n                struct link_map *lm\n                        = ((struct r_debug *)(dp->d_un.d_ptr))->r_map;\n                if( lm != 0 ) cachedResult = lm->l_next; /* might be NIL */\n                break;\n            }\n        }\n    }\n    return cachedResult;\n}\n\n#endif /* SUNOS5DL ... */\n\n/* BTL: added to fix circular dlopen definition if GC_SOLARIS_THREADS defined */\n# if defined(GC_must_restore_redefined_dlopen)\n#   define dlopen GC_dlopen\n# endif\n\n#if defined(SUNOS4) && !defined(USE_PROC_FOR_LIBRARIES)\n\n#ifdef LINT\n    struct link_dynamic _DYNAMIC;\n#endif\n\nstatic struct link_map *\nGC_FirstDLOpenedLinkMap()\n{\n    extern struct link_dynamic _DYNAMIC;\n\n    if( &_DYNAMIC == 0) {\n        return(0);\n    }\n    return(_DYNAMIC.ld_un.ld_1->ld_loaded);\n}\n\n/* Return the address of the ld.so allocated common symbol\t*/\n/* with the least address, or 0 if none.\t\t\t*/\nstatic ptr_t GC_first_common()\n{\n    ptr_t result = 0;\n    extern struct link_dynamic _DYNAMIC;\n    struct rtc_symb * curr_symbol;\n    \n    if( &_DYNAMIC == 0) {\n        return(0);\n    }\n    curr_symbol = _DYNAMIC.ldd -> ldd_cp;\n    for (; curr_symbol != 0; curr_symbol = curr_symbol -> rtc_next) {\n        if (result == 0\n            || (ptr_t)(curr_symbol -> rtc_sp -> n_value) < result) {\n            result = (ptr_t)(curr_symbol -> rtc_sp -> n_value);\n        }\n    }\n    return(result);\n}\n\n#endif  /* SUNOS4 ... */\n\n# if defined(SUNOS4) || defined(SUNOS5DL)\n/* Add dynamic library data sections to the root set.\t\t*/\n# if !defined(PCR) && !defined(GC_SOLARIS_THREADS) && defined(THREADS)\n#   ifndef SRC_M3\n\t--> fix mutual exclusion with dlopen\n#   endif  /* We assume M3 programs don't call dlopen for now */\n# endif\n\n# ifndef USE_PROC_FOR_LIBRARIES\nvoid GC_register_dynamic_libraries()\n{\n  struct link_map *lm = GC_FirstDLOpenedLinkMap();\n  \n\n  for (lm = GC_FirstDLOpenedLinkMap();\n       lm != (struct link_map *) 0;  lm = lm->l_next)\n    {\n#     ifdef SUNOS4\n\tstruct exec *e;\n\t \n        e = (struct exec *) lm->lm_addr;\n        GC_add_roots_inner(\n      \t\t    ((char *) (N_DATOFF(*e) + lm->lm_addr)),\n\t\t    ((char *) (N_BSSADDR(*e) + e->a_bss + lm->lm_addr)),\n\t\t    TRUE);\n#     endif\n#     ifdef SUNOS5DL\n\tElfW(Ehdr) * e;\n        ElfW(Phdr) * p;\n        unsigned long offset;\n        char * start;\n        register int i;\n        \n        e = (ElfW(Ehdr) *) lm->l_addr;\n        if (e == NULL)\n          continue;\n\n        p = ((ElfW(Phdr) *)(((char *)(e)) + e->e_phoff));\n        offset = ((unsigned long)(lm->l_addr));\n        for( i = 0; i < (int)(e->e_phnum); ((i++),(p++)) ) {\n          switch( p->p_type ) {\n            case PT_LOAD:\n              {\n                if( !(p->p_flags & PF_W) ) break;\n                start = ((char *)(p->p_vaddr)) + offset;\n                GC_add_roots_inner(\n                  start,\n                  start + p->p_memsz,\n                  TRUE\n                );\n              }\n              break;\n            default:\n              break;\n          }\n\t}\n#     endif\n    }\n#   ifdef SUNOS4\n      {\n      \tstatic ptr_t common_start = 0;\n      \tptr_t common_end;\n      \textern ptr_t GC_find_limit();\n      \t\n      \tif (common_start == 0) common_start = GC_first_common();\n      \tif (common_start != 0) {\n      \t    common_end = GC_find_limit(common_start, TRUE);\n      \t    GC_add_roots_inner((char *)common_start, (char *)common_end, TRUE);\n      \t}\n      }\n#   endif\n}\n\n# endif /* !USE_PROC ... */\n# endif /* SUNOS */\n\n#if (defined(LINUX) || defined(NACL)) && defined(__ELF__) || defined(SCO_ELF) || \\\n    (defined(FREEBSD) && defined(__ELF__)) || defined(DGUX) || \\\n    (defined(OPENBSD) && defined(__ELF__)) || \\\n    (defined(NETBSD) && defined(__ELF__)) || defined(HURD)\n\n\n#ifdef USE_PROC_FOR_LIBRARIES\n\n#include <string.h>\n\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#define MAPS_BUF_SIZE (32*1024)\n\nextern ssize_t GC_repeat_read(int fd, char *buf, size_t count);\n\t/* Repeatedly read until buffer is filled, or EOF is encountered */\n\t/* Defined in os_dep.c.  \t\t\t\t\t */\n\nchar *GC_parse_map_entry(char *buf_ptr, word *start, word *end,\n                         char *prot_buf, unsigned int *maj_dev);\nword GC_apply_to_maps(word (*fn)(char *));\n\t/* From os_dep.c\t*/\n\nword GC_register_map_entries(char *maps)\n{\n    char prot_buf[5];\n    char *buf_ptr = maps;\n    int count;\n    word start, end;\n    unsigned int maj_dev;\n    word least_ha, greatest_ha;\n    unsigned i;\n    word datastart = (word)(DATASTART);\n\n    /* Compute heap bounds. FIXME: Should be done by add_to_heap?\t*/\n\tleast_ha = (word)(-1);\n\tgreatest_ha = 0;\n\tfor (i = 0; i < GC_n_heap_sects; ++i) {\n\t    word sect_start = (word)GC_heap_sects[i].hs_start;\n\t    word sect_end = sect_start + GC_heap_sects[i].hs_bytes;\n\t    if (sect_start < least_ha) least_ha = sect_start;\n\t    if (sect_end > greatest_ha) greatest_ha = sect_end;\n        }\n    \tif (greatest_ha < (word)GC_scratch_last_end_ptr)\n\t    greatest_ha = (word)GC_scratch_last_end_ptr; \n\n    for (;;) {\n        buf_ptr = GC_parse_map_entry(buf_ptr, &start, &end, prot_buf, &maj_dev);\n\tif (buf_ptr == NULL) return 1;\n\tif (prot_buf[1] == 'w') {\n\t    /* This is a writable mapping.  Add it to\t\t*/\n\t    /* the root set unless it is already otherwise\t*/\n\t    /* accounted for.\t\t\t\t\t*/\n\t    if (start <= (word)GC_stackbottom && end >= (word)GC_stackbottom) {\n\t\t/* Stack mapping; discard\t*/\n\t\tcontinue;\n\t    }\n#\t    ifdef THREADS\n\t      if (GC_segment_is_thread_stack(start, end)) continue;\n#\t    endif\n\t    /* We no longer exclude the main data segment.\t\t*/\n\t    if (start < least_ha && end > least_ha) {\n\t\tend = least_ha;\n\t    }\n\t    if (start < greatest_ha && end > greatest_ha) {\n\t\tstart = greatest_ha;\n\t    }\n\t    if (start >= least_ha && end <= greatest_ha) continue;\n\t    GC_add_roots_inner((char *)start, (char *)end, TRUE);\n\t}\n    }\n    return 1;\n}\n\nvoid GC_register_dynamic_libraries()\n{\n   if (!GC_apply_to_maps(GC_register_map_entries))\n       ABORT(\"Failed to read /proc for library registration.\");\n}\n\n/* We now take care of the main data segment ourselves: */\nGC_bool GC_register_main_static_data()\n{\n  return FALSE;\n}\n  \n# define HAVE_REGISTER_MAIN_STATIC_DATA\n\n#endif /* USE_PROC_FOR_LIBRARIES */\n\n#if !defined(USE_PROC_FOR_LIBRARIES)\n/* The following is the preferred way to walk dynamic libraries\t*/\n/* For glibc 2.2.4+.  Unfortunately, it doesn't work for older\t*/\n/* versions.  Thanks to Jakub Jelinek for most of the code.\t*/\n\n# if (defined(LINUX) || defined (__GLIBC__) || defined(NACL)) /* Are others OK here, too? */ \\\n     && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2) \\\n         || (__GLIBC__ == 2 && __GLIBC_MINOR__ == 2 && defined(DT_CONFIG))) \\\n\t || defined(OPENBSD)\n\n/* We have the header files for a glibc that includes dl_iterate_phdr.\t*/\n/* It may still not be available in the library on the target system.   */\n/* Thus we also treat it as a weak symbol.\t\t\t\t*/\n#define HAVE_DL_ITERATE_PHDR\n\nstatic int GC_register_dynlib_callback(info, size, ptr)\n     struct dl_phdr_info * info;\n     size_t size;\n     void * ptr;\n{\n  const ElfW(Phdr) * p;\n  char * start;\n  register int i;\n\n  /* Make sure struct dl_phdr_info is at least as big as we need.  */\n  if (size < offsetof (struct dl_phdr_info, dlpi_phnum)\n      + sizeof (info->dlpi_phnum))\n    return -1;\n\n  p = info->dlpi_phdr;\n  for( i = 0; i < (int)(info->dlpi_phnum); ((i++),(p++)) ) {\n    switch( p->p_type ) {\n      case PT_LOAD:\n\t{\n\t  if( !(p->p_flags & PF_W) ) break;\n\t  start = ((char *)(p->p_vaddr)) + info->dlpi_addr;\n\t  GC_add_roots_inner(start, start + p->p_memsz, TRUE);\n\t}\n      break;\n      default:\n\tbreak;\n    }\n  }\n\n  * (int *)ptr = 1;\t/* Signal that we were called */\n  return 0;\n}     \n\n/* Return TRUE if we succeed, FALSE if dl_iterate_phdr wasn't there. */\n\n#pragma weak dl_iterate_phdr\n\nGC_bool GC_register_dynamic_libraries_dl_iterate_phdr()\n{\n  if (dl_iterate_phdr) {\n    int did_something = 0;\n    dl_iterate_phdr(GC_register_dynlib_callback, &did_something);\n    if (!did_something) {\n\t/* dl_iterate_phdr may forget the static data segment in\t*/\n\t/* statically linked executables.\t\t\t\t*/\n\tGC_add_roots_inner(DATASTART, (char *)(DATAEND), TRUE);\n#       if defined(DATASTART2)\n          GC_add_roots_inner(DATASTART2, (char *)(DATAEND2), TRUE);\n#       endif\n    }\n\n    return TRUE;\n  } else {\n    return FALSE;\n  }\n}\n\n/* Do we need to separately register the main static data segment? */\nGC_bool GC_register_main_static_data()\n{\n  return (dl_iterate_phdr == 0);\n}\n\n#define HAVE_REGISTER_MAIN_STATIC_DATA\n\n# else /* !LINUX || version(glibc) < 2.2.4 */\n\n/* Dynamic loading code for Linux running ELF. Somewhat tested on\n * Linux/x86, untested but hopefully should work on Linux/Alpha. \n * This code was derived from the Solaris/ELF support. Thanks to\n * whatever kind soul wrote that.  - Patrick Bridges */\n\n/* This doesn't necessarily work in all cases, e.g. with preloaded\n * dynamic libraries.\t\t\t\t\t\t*/\n\n#if defined(NETBSD) || defined(OPENBSD)\n# if !defined(OPENBSD)\n#  include <sys/exec_elf.h>\n# endif\n/* for compatibility with 1.4.x */\n#  ifndef DT_DEBUG\n#  define DT_DEBUG     21\n#  endif\n#  ifndef PT_LOAD\n#  define PT_LOAD      1\n#  endif\n#  ifndef PF_W\n#  define PF_W         2\n#  endif\n#else\n#  include <elf.h>\n#endif\n#include <link.h>\n\n# endif\n\n#ifdef __GNUC__\n# pragma weak _DYNAMIC\n#endif\nextern ElfW(Dyn) _DYNAMIC[];\n\nstatic struct link_map *\nGC_FirstDLOpenedLinkMap()\n{\n    ElfW(Dyn) *dp;\n    static struct link_map *cachedResult = 0;\n\n    if( _DYNAMIC == 0) {\n        return(0);\n    }\n    if( cachedResult == 0 ) {\n        int tag;\n        for( dp = _DYNAMIC; (tag = dp->d_tag) != 0; dp++ ) {\n\t    /* FIXME: The DT_DEBUG header is not mandated by the\t*/\n\t    /* ELF spec.  This code appears to be dependent on\t\t*/\n\t    /* idiosynchracies of older GNU tool chains.  If this code\t*/\n\t    /* fails for you, the real problem is probably that it is\t*/\n\t    /* being used at all.  You should be getting the \t\t*/\n\t    /* dl_iterate_phdr version.\t\t\t\t\t*/\n            if( tag == DT_DEBUG ) {\n                struct link_map *lm\n                        = ((struct r_debug *)(dp->d_un.d_ptr))->r_map;\n                if( lm != 0 ) cachedResult = lm->l_next; /* might be NIL */\n                break;\n            }\n        }\n    }\n    return cachedResult;\n}\n\n\nvoid GC_register_dynamic_libraries()\n{\n  struct link_map *lm;\n  \n\n# ifdef HAVE_DL_ITERATE_PHDR\n    if (GC_register_dynamic_libraries_dl_iterate_phdr()) {\n\treturn;\n    }\n# endif\n  lm = GC_FirstDLOpenedLinkMap();\n  for (lm = GC_FirstDLOpenedLinkMap();\n       lm != (struct link_map *) 0;  lm = lm->l_next)\n    {\n\tElfW(Ehdr) * e;\n        ElfW(Phdr) * p;\n        unsigned long offset;\n        char * start;\n        register int i;\n        \n        e = (ElfW(Ehdr) *) lm->l_addr;\n        if (e == NULL)\n          continue;\n\n        p = ((ElfW(Phdr) *)(((char *)(e)) + e->e_phoff));\n        offset = ((unsigned long)(lm->l_addr));\n        for( i = 0; i < (int)(e->e_phnum); ((i++),(p++)) ) {\n          switch( p->p_type ) {\n            case PT_LOAD:\n              {\n                if( !(p->p_flags & PF_W) ) break;\n                start = ((char *)(p->p_vaddr)) + offset;\n                GC_add_roots_inner(start, start + p->p_memsz, TRUE);\n              }\n              break;\n            default:\n              break;\n          }\n\t}\n    }\n}\n\n#endif /* !USE_PROC_FOR_LIBRARIES */\n\n#endif /* LINUX */\n\n#if defined(IRIX5) || (defined(USE_PROC_FOR_LIBRARIES) && !defined(LINUX))\n\n#include <sys/procfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <elf.h>\n#include <errno.h>\n#include <signal.h>  /* Only for the following test. */\n#ifndef _sigargs\n# define IRIX6\n#endif\n\nextern void * GC_roots_present();\n\t/* The type is a lie, since the real type doesn't make sense here, */\n\t/* and we only test for NULL.\t\t\t\t\t   */\n\n\n/* We use /proc to track down all parts of the address space that are\t*/\n/* mapped by the process, and throw out regions we know we shouldn't\t*/\n/* worry about.  This may also work under other SVR4 variants.\t\t*/\nvoid GC_register_dynamic_libraries()\n{\n    static int fd = -1;\n    char buf[30];\n    static prmap_t * addr_map = 0;\n    static int current_sz = 0;\t/* Number of records currently in addr_map */\n    static int needed_sz;\t/* Required size of addr_map\t\t*/\n    register int i;\n    register long flags;\n    register ptr_t start;\n    register ptr_t limit;\n    ptr_t heap_start = (ptr_t)HEAP_START;\n    ptr_t heap_end = heap_start;\n\n#   ifdef SUNOS5DL\n#     define MA_PHYS 0\n#   endif /* SUNOS5DL */\n\n    if (fd < 0) {\n      sprintf(buf, \"/proc/%d\", getpid());\n\t/* The above generates a lint complaint, since pid_t varies.\t*/\n\t/* It's unclear how to improve this.\t\t\t\t*/\n      fd = open(buf, O_RDONLY);\n      if (fd < 0) {\n    \tABORT(\"/proc open failed\");\n      }\n    }\n    if (ioctl(fd, PIOCNMAP, &needed_sz) < 0) {\n\tGC_err_printf2(\"fd = %d, errno = %d\\n\", fd, errno);\n    \tABORT(\"/proc PIOCNMAP ioctl failed\");\n    }\n    if (needed_sz >= current_sz) {\n        current_sz = needed_sz * 2 + 1;\n        \t\t/* Expansion, plus room for 0 record */\n        addr_map = (prmap_t *)GC_scratch_alloc((word)\n\t\t\t\t\t\t(current_sz * sizeof(prmap_t)));\n    }\n    if (ioctl(fd, PIOCMAP, addr_map) < 0) {\n        GC_err_printf4(\"fd = %d, errno = %d, needed_sz = %d, addr_map = 0x%X\\n\",\n                        fd, errno, needed_sz, addr_map);\n    \tABORT(\"/proc PIOCMAP ioctl failed\");\n    };\n    if (GC_n_heap_sects > 0) {\n    \theap_end = GC_heap_sects[GC_n_heap_sects-1].hs_start\n    \t\t\t+ GC_heap_sects[GC_n_heap_sects-1].hs_bytes;\n    \tif (heap_end < GC_scratch_last_end_ptr) heap_end = GC_scratch_last_end_ptr; \n    }\n    for (i = 0; i < needed_sz; i++) {\n        flags = addr_map[i].pr_mflags;\n        if ((flags & (MA_BREAK | MA_STACK | MA_PHYS\n\t\t      | MA_FETCHOP | MA_NOTCACHED)) != 0) goto irrelevant;\n        if ((flags & (MA_READ | MA_WRITE)) != (MA_READ | MA_WRITE))\n            goto irrelevant;\n          /* The latter test is empirically useless in very old Irix\t*/\n\t  /* versions.  Other than the\t\t\t\t\t*/\n          /* main data and stack segments, everything appears to be\t*/\n          /* mapped readable, writable, executable, and shared(!!).\t*/\n          /* This makes no sense to me.\t- HB\t\t\t\t*/\n        start = (ptr_t)(addr_map[i].pr_vaddr);\n        if (GC_roots_present(start)) goto irrelevant;\n        if (start < heap_end && start >= heap_start)\n        \tgoto irrelevant;\n#\tifdef MMAP_STACKS\n\t  if (GC_is_thread_stack(start)) goto irrelevant;\n#\tendif /* MMAP_STACKS */\n\n        limit = start + addr_map[i].pr_size;\n\t/* The following seemed to be necessary for very old versions \t*/\n\t/* of Irix, but it has been reported to discard relevant\t*/\n\t/* segments under Irix 6.5.  \t\t\t\t\t*/\n#\tifndef IRIX6\n\t  if (addr_map[i].pr_off == 0 && strncmp(start, ELFMAG, 4) == 0) {\n\t    /* Discard text segments, i.e. 0-offset mappings against\t*/\n\t    /* executable files which appear to have ELF headers.\t*/\n\t    caddr_t arg;\n\t    int obj;\n#\t    define MAP_IRR_SZ 10\n\t    static ptr_t map_irr[MAP_IRR_SZ];\n\t    \t\t\t\t/* Known irrelevant map entries\t*/\n\t    static int n_irr = 0;\n\t    struct stat buf;\n\t    register int i;\n\t    \n\t    for (i = 0; i < n_irr; i++) {\n\t        if (map_irr[i] == start) goto irrelevant;\n\t    }\n\t    arg = (caddr_t)start;\n\t    obj = ioctl(fd, PIOCOPENM, &arg);\n\t    if (obj >= 0) {\n\t        fstat(obj, &buf);\n\t        close(obj);\n\t        if ((buf.st_mode & 0111) != 0) {\n\t            if (n_irr < MAP_IRR_SZ) {\n\t                map_irr[n_irr++] = start;\n\t            }\n\t            goto irrelevant;\n\t        }\n\t    }\n\t  }\n#\tendif /* !IRIX6 */\n        GC_add_roots_inner(start, limit, TRUE);\n      irrelevant: ;\n    }\n    /* Dont keep cached descriptor, for now.  Some kernels don't like us */\n    /* to keep a /proc file descriptor around during kill -9.\t\t */\n    \tif (close(fd) < 0) ABORT(\"Couldnt close /proc file\");\n\tfd = -1;\n}\n\n# endif /* USE_PROC || IRIX5 */\n\n# if defined(MSWIN32) || defined(MSWINCE)\n\n# define WIN32_LEAN_AND_MEAN\n# define NOSERVICE\n# include <windows.h>\n# include <stdlib.h>\n\n  /* We traverse the entire address space and register all segments \t*/\n  /* that could possibly have been written to.\t\t\t\t*/\n  \n  extern GC_bool GC_is_heap_base (ptr_t p);\n\n# ifdef GC_WIN32_THREADS\n    extern void GC_get_next_stack(char *start, char **lo, char **hi);\n    void GC_cond_add_roots(char *base, char * limit)\n    {\n      char * curr_base = base;\n      char * next_stack_lo;\n      char * next_stack_hi;\n   \n      if (base == limit) return;\n      for(;;) {\n\t  GC_get_next_stack(curr_base, &next_stack_lo, &next_stack_hi);\n\t  if (next_stack_lo >= limit) break;\n\t  GC_add_roots_inner(curr_base, next_stack_lo, TRUE);\n\t  curr_base = next_stack_hi;\n      }\n      if (curr_base < limit) GC_add_roots_inner(curr_base, limit, TRUE);\n    }\n# else\n    void GC_cond_add_roots(char *base, char * limit)\n    {\n      char dummy;\n      char * stack_top\n\t = (char *) ((word)(&dummy) & ~(GC_sysinfo.dwAllocationGranularity-1));\n      if (base == limit) return;\n      if (limit > stack_top && base < GC_stackbottom) {\n    \t  /* Part of the stack; ignore it. */\n    \t  return;\n      }\n      GC_add_roots_inner(base, limit, TRUE);\n    }\n# endif\n\n# ifdef MSWINCE\n  /* Do we need to separately register the main static data segment? */\n  GC_bool GC_register_main_static_data()\n  {\n    return FALSE;\n  }\n# else /* win32 */\n  extern GC_bool GC_no_win32_dlls;\n\n  GC_bool GC_register_main_static_data()\n  {\n    return GC_no_win32_dlls;\n  }\n# endif /* win32 */\n  \n# define HAVE_REGISTER_MAIN_STATIC_DATA\n\n  /* The frame buffer testing code is dead in this version.\t*/\n  /* We leave it here temporarily in case the switch to just \t*/\n  /* testing for MEM_IMAGE sections causes un expected \t\t*/\n  /* problems.\t\t\t\t\t\t\t*/\n  GC_bool GC_warn_fb = TRUE;\t/* Warn about traced likely \t*/\n  \t\t\t\t/* graphics memory.\t\t*/\n  GC_bool GC_disallow_ignore_fb = FALSE;\n  int GC_ignore_fb_mb;\t/* Ignore mappings bigger than the \t*/\n  \t\t\t/* specified number of MB.\t\t*/\n  GC_bool GC_ignore_fb = FALSE; /* Enable frame buffer \t*/\n  \t\t\t\t/* checking.\t\t*/\n  \n  /* Issue warning if tracing apparent framebuffer. \t\t*/\n  /* This limits us to one warning, and it's a back door to\t*/\n  /* disable that.\t\t\t\t\t\t*/\n \n  /* Should [start, start+len) be treated as a frame buffer\t*/\n  /* and ignored?\t\t\t\t\t\t*/\n  /* Unfortunately, we currently are not quite sure how to tell\t*/\n  /* this automatically, and rely largely on user input.\t*/\n  /* We expect that any mapping with type MEM_MAPPED (which \t*/\n  /* apparently excludes library data sections) can be safely\t*/\n  /* ignored.  But we're too chicken to do that in this \t*/\n  /* version.\t\t\t\t\t\t\t*/\n  /* Based on a very limited sample, it appears that:\t\t*/\n  /* \t- Frame buffer mappings appear as mappings of large\t*/\n  /*\t  length, usually a bit less than a power of two.\t*/\n  /*\t- The definition of \"a bit less\" in the above cannot\t*/\n  /*\t  be made more precise.\t\t\t\t\t*/\n  /*\t- Have a starting address at best 64K aligned.\t\t*/\n  /*\t- Have type == MEM_MAPPED.\t\t\t\t*/\n  static GC_bool is_frame_buffer(ptr_t start, size_t len, DWORD tp)\n  {\n    static GC_bool initialized = FALSE;\n#   define MB (1024*1024)\n#   define DEFAULT_FB_MB 15\n#   define MIN_FB_MB 3\n\n    if (GC_disallow_ignore_fb || tp != MEM_MAPPED) return FALSE;\n    if (!initialized) {\n      char * ignore_fb_string =  GETENV(\"GC_IGNORE_FB\");\n\n      if (0 != ignore_fb_string) {\n\twhile (*ignore_fb_string == ' ' || *ignore_fb_string == '\\t')\n\t  ++ignore_fb_string;\n\tif (*ignore_fb_string == '\\0') {\n\t  GC_ignore_fb_mb = DEFAULT_FB_MB;\n\t} else {\n\t  GC_ignore_fb_mb = atoi(ignore_fb_string);\n\t  if (GC_ignore_fb_mb < MIN_FB_MB) {\n\t    WARN(\"Bad GC_IGNORE_FB value.  Using %ld\\n\", DEFAULT_FB_MB);\n\t    GC_ignore_fb_mb = DEFAULT_FB_MB;\n\t  }\n\t}\n\tGC_ignore_fb = TRUE;\n      } else {\n\tGC_ignore_fb_mb = DEFAULT_FB_MB;  /* For warning */\n      }\n      initialized = TRUE;\n    }\n    if (len >= ((size_t)GC_ignore_fb_mb << 20)) {\n      if (GC_ignore_fb) {\n\treturn TRUE;\n      } else {\n\tif (GC_warn_fb) {\n\t  WARN(\"Possible frame buffer mapping at 0x%lx: \\n\"\n\t       \"\\tConsider setting GC_IGNORE_FB to improve performance.\\n\",\n\t       start);\n\t  GC_warn_fb = FALSE;\n\t}\n\treturn FALSE;\n      }\n    } else {\n      return FALSE;\n    }\n  }\n\n# ifdef DEBUG_VIRTUALQUERY\n  void GC_dump_meminfo(MEMORY_BASIC_INFORMATION *buf)\n  {\n    GC_printf4(\"BaseAddress = %lx, AllocationBase = %lx, RegionSize = %lx(%lu)\\n\",\n\t       buf -> BaseAddress, buf -> AllocationBase, buf -> RegionSize,\n\t       buf -> RegionSize);\n    GC_printf4(\"\\tAllocationProtect = %lx, State = %lx, Protect = %lx, \"\n\t       \"Type = %lx\\n\",\n\t       buf -> AllocationProtect, buf -> State, buf -> Protect,\n\t       buf -> Type);\n  }\n# endif /* DEBUG_VIRTUALQUERY */\n\n  void GC_register_dynamic_libraries()\n  {\n    MEMORY_BASIC_INFORMATION buf;\n    DWORD result;\n    DWORD protect;\n    LPVOID p;\n    char * base;\n    char * limit, * new_limit;\n\n#   ifdef MSWIN32\n      if (GC_no_win32_dlls) return;\n#   endif\n    base = limit = p = GC_sysinfo.lpMinimumApplicationAddress;\n#   if defined(MSWINCE) && !defined(_WIN32_WCE_EMULATION)\n    /* Only the first 32 MB of address space belongs to the current process */\n    while (p < (LPVOID)0x02000000) {\n        result = VirtualQuery(p, &buf, sizeof(buf));\n\tif (result == 0) {\n\t    /* Page is free; advance to the next possible allocation base */\n\t    new_limit = (char *)\n\t\t(((DWORD) p + GC_sysinfo.dwAllocationGranularity)\n\t\t & ~(GC_sysinfo.dwAllocationGranularity-1));\n\t} else\n#   else\n    while (p < GC_sysinfo.lpMaximumApplicationAddress) {\n        result = VirtualQuery(p, &buf, sizeof(buf));\n#   endif\n\t{\n\t    if (result != sizeof(buf)) {\n\t\tABORT(\"Weird VirtualQuery result\");\n\t    }\n\t    new_limit = (char *)p + buf.RegionSize;\n\t    protect = buf.Protect;\n\t    if (buf.State == MEM_COMMIT\n\t\t&& (protect == PAGE_EXECUTE_READWRITE\n\t\t    || protect == PAGE_READWRITE)\n\t\t&& !GC_is_heap_base(buf.AllocationBase)\n\t\t/* This used to check for\n\t\t * !is_frame_buffer(p, buf.RegionSize, buf.Type)\n\t\t * instead of just checking for MEM_IMAGE.\n\t\t * If something breaks, change it back. */\n\t\t&& buf.Type == MEM_IMAGE) {  \n#\t        ifdef DEBUG_VIRTUALQUERY\n\t          GC_dump_meminfo(&buf);\n#\t        endif\n\t\tif ((char *)p != limit) {\n\t\t    GC_cond_add_roots(base, limit);\n\t\t    base = p;\n\t\t}\n\t\tlimit = new_limit;\n\t    }\n\t}\n        if (p > (LPVOID)new_limit /* overflow */) break;\n        p = (LPVOID)new_limit;\n    }\n    GC_cond_add_roots(base, limit);\n  }\n\n#endif /* MSWIN32 || MSWINCE */\n  \n#if defined(ALPHA) && defined(OSF1)\n\n#include <loader.h>\n\nvoid GC_register_dynamic_libraries()\n{\n  int status;\n  ldr_process_t mypid;\n\n  /* module */\n    ldr_module_t moduleid = LDR_NULL_MODULE;\n    ldr_module_info_t moduleinfo;\n    size_t moduleinfosize = sizeof(moduleinfo);\n    size_t modulereturnsize;    \n\n  /* region */\n    ldr_region_t region; \n    ldr_region_info_t regioninfo;\n    size_t regioninfosize = sizeof(regioninfo);\n    size_t regionreturnsize;\n\n  /* Obtain id of this process */\n    mypid = ldr_my_process();\n  \n  /* For each module */\n    while (TRUE) {\n\n      /* Get the next (first) module */\n        status = ldr_next_module(mypid, &moduleid);\n\n      /* Any more modules? */\n        if (moduleid == LDR_NULL_MODULE)\n            break;    /* No more modules */\n\n      /* Check status AFTER checking moduleid because */\n      /* of a bug in the non-shared ldr_next_module stub */\n        if (status != 0 ) {\n            GC_printf1(\"dynamic_load: status = %ld\\n\", (long)status);\n            {\n                extern char *sys_errlist[];\n                extern int sys_nerr;\n                extern int errno;\n                if (errno <= sys_nerr) {\n                    GC_printf1(\"dynamic_load: %s\\n\", (long)sys_errlist[errno]);\n               } else {\n                    GC_printf1(\"dynamic_load: %d\\n\", (long)errno);\n                }\n        }\n            ABORT(\"ldr_next_module failed\");\n         }\n\n      /* Get the module information */\n        status = ldr_inq_module(mypid, moduleid, &moduleinfo,\n                                moduleinfosize, &modulereturnsize); \n        if (status != 0 )\n            ABORT(\"ldr_inq_module failed\");\n\n      /* is module for the main program (i.e. nonshared portion)? */\n          if (moduleinfo.lmi_flags & LDR_MAIN)\n              continue;    /* skip the main module */\n\n#     ifdef VERBOSE\n          GC_printf(\"---Module---\\n\");\n          GC_printf(\"Module ID            = %16ld\\n\", moduleinfo.lmi_modid);\n          GC_printf(\"Count of regions     = %16d\\n\", moduleinfo.lmi_nregion);\n          GC_printf(\"flags for module     = %16lx\\n\", moduleinfo.lmi_flags); \n          GC_printf(\"pathname of module   = \\\"%s\\\"\\n\", moduleinfo.lmi_name);\n#     endif\n\n      /* For each region in this module */\n        for (region = 0; region < moduleinfo.lmi_nregion; region++) {\n\n          /* Get the region information */\n            status = ldr_inq_region(mypid, moduleid, region, &regioninfo,\n                                    regioninfosize, &regionreturnsize);\n            if (status != 0 )\n                ABORT(\"ldr_inq_region failed\");\n\n          /* only process writable (data) regions */\n            if (! (regioninfo.lri_prot & LDR_W))\n                continue;\n\n#         ifdef VERBOSE\n              GC_printf(\"--- Region ---\\n\");\n              GC_printf(\"Region number    = %16ld\\n\",\n              \t        regioninfo.lri_region_no);\n              GC_printf(\"Protection flags = %016x\\n\",  regioninfo.lri_prot);\n              GC_printf(\"Virtual address  = %16p\\n\",   regioninfo.lri_vaddr);\n              GC_printf(\"Mapped address   = %16p\\n\",   regioninfo.lri_mapaddr);\n              GC_printf(\"Region size      = %16ld\\n\",  regioninfo.lri_size);\n              GC_printf(\"Region name      = \\\"%s\\\"\\n\", regioninfo.lri_name);\n#         endif\n\n          /* register region as a garbage collection root */\n            GC_add_roots_inner (\n                (char *)regioninfo.lri_mapaddr,\n                (char *)regioninfo.lri_mapaddr + regioninfo.lri_size,\n                TRUE);\n\n        }\n    }\n}\n#endif\n\n#if defined(HPUX)\n\n#include <errno.h>\n#include <dl.h>\n\nextern int errno;\nextern char *sys_errlist[];\nextern int sys_nerr;\n\nvoid GC_register_dynamic_libraries()\n{\n  int status;\n  int index = 1; /* Ordinal position in shared library search list */\n  struct shl_descriptor *shl_desc; /* Shared library info, see dl.h */\n\n  /* For each dynamic library loaded */\n    while (TRUE) {\n\n      /* Get info about next shared library */\n        status = shl_get(index, &shl_desc);\n\n      /* Check if this is the end of the list or if some error occured */\n        if (status != 0) {\n#\t ifdef GC_HPUX_THREADS\n\t   /* I've seen errno values of 0.  The man page is not clear\t*/\n\t   /* as to whether errno should get set on a -1 return.\t*/\n\t   break;\n#\t else\n          if (errno == EINVAL) {\n              break; /* Moved past end of shared library list --> finished */\n          } else {\n              if (errno <= sys_nerr) {\n                    GC_printf1(\"dynamic_load: %s\\n\", (long) sys_errlist[errno]);\n              } else {\n                    GC_printf1(\"dynamic_load: %d\\n\", (long) errno);\n\t      }\n              ABORT(\"shl_get failed\");\n          }\n#\t endif\n        }\n\n#     ifdef VERBOSE\n          GC_printf0(\"---Shared library---\\n\");\n          GC_printf1(\"\\tfilename        = \\\"%s\\\"\\n\", shl_desc->filename);\n          GC_printf1(\"\\tindex           = %d\\n\", index);\n          GC_printf1(\"\\thandle          = %08x\\n\",\n\t\t\t\t\t(unsigned long) shl_desc->handle);\n          GC_printf1(\"\\ttext seg. start = %08x\\n\", shl_desc->tstart);\n          GC_printf1(\"\\ttext seg. end   = %08x\\n\", shl_desc->tend);\n          GC_printf1(\"\\tdata seg. start = %08x\\n\", shl_desc->dstart);\n          GC_printf1(\"\\tdata seg. end   = %08x\\n\", shl_desc->dend);\n          GC_printf1(\"\\tref. count      = %lu\\n\", shl_desc->ref_count);\n#     endif\n\n      /* register shared library's data segment as a garbage collection root */\n        GC_add_roots_inner((char *) shl_desc->dstart,\n\t\t\t   (char *) shl_desc->dend, TRUE);\n\n        index++;\n    }\n}\n#endif /* HPUX */\n\n#ifdef RS6000\n#pragma alloca\n#include <sys/ldr.h>\n#include <sys/errno.h>\nvoid GC_register_dynamic_libraries()\n{\n\tint len;\n\tchar *ldibuf;\n\tint ldibuflen;\n\tstruct ld_info *ldi;\n\n\tldibuf = alloca(ldibuflen = 8192);\n\n\twhile ( (len = loadquery(L_GETINFO,ldibuf,ldibuflen)) < 0) {\n\t\tif (errno != ENOMEM) {\n\t\t\tABORT(\"loadquery failed\");\n\t\t}\n\t\tldibuf = alloca(ldibuflen *= 2);\n\t}\n\n\tldi = (struct ld_info *)ldibuf;\n\twhile (ldi) {\n\t\tlen = ldi->ldinfo_next;\n\t\tGC_add_roots_inner(\n\t\t\t\tldi->ldinfo_dataorg,\n\t\t\t\t(ptr_t)(unsigned long)ldi->ldinfo_dataorg\n\t\t\t        + ldi->ldinfo_datasize,\n\t\t\t\tTRUE);\n\t\tldi = len ? (struct ld_info *)((char *)ldi + len) : 0;\n\t}\n}\n#endif /* RS6000 */\n\n#ifdef DARWIN\n\n/* __private_extern__ hack required for pre-3.4 gcc versions.\t*/\n#ifndef __private_extern__\n# define __private_extern__ extern\n# include <mach-o/dyld.h>\n# undef __private_extern__\n#else\n# include <mach-o/dyld.h>\n#endif\n#include <mach-o/getsect.h>\n\n/*#define DARWIN_DEBUG*/\n\nconst static struct { \n        const char *seg;\n        const char *sect;\n} GC_dyld_sections[] = {\n        { SEG_DATA, SECT_DATA },\n        { SEG_DATA, SECT_BSS },\n        { SEG_DATA, SECT_COMMON }\n};\n    \n#ifdef DARWIN_DEBUG\nstatic const char *GC_dyld_name_for_hdr(struct mach_header *hdr) {\n    unsigned long i,c;\n    c = _dyld_image_count();\n    for(i=0;i<c;i++) if(_dyld_get_image_header(i) == hdr)\n        return _dyld_get_image_name(i);\n    return NULL;\n}\n#endif\n        \n/* This should never be called by a thread holding the lock */\nstatic void GC_dyld_image_add(struct mach_header* hdr, unsigned long slide) {\n    unsigned long start,end,i;\n    const struct section *sec;\n    if (GC_no_dls) return;\n    for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {\n        sec = getsectbynamefromheader(\n            hdr,GC_dyld_sections[i].seg,GC_dyld_sections[i].sect);\n        if(sec == NULL || sec->size == 0) continue;\n        start = slide + sec->addr;\n        end = start + sec->size;\n#\tifdef DARWIN_DEBUG\n            GC_printf4(\"Adding section at %p-%p (%lu bytes) from image %s\\n\",\n                start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n#       endif\n        GC_add_roots((char*)start,(char*)end);\n    }\n#   ifdef DARWIN_DEBUG\n        GC_print_static_roots();\n#   endif\n}\n\n/* This should never be called by a thread holding the lock */\nstatic void GC_dyld_image_remove(struct mach_header* hdr, unsigned long slide) {\n    unsigned long start,end,i;\n    const struct section *sec;\n    for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {\n        sec = getsectbynamefromheader(\n            hdr,GC_dyld_sections[i].seg,GC_dyld_sections[i].sect);\n        if(sec == NULL || sec->size == 0) continue;\n        start = slide + sec->addr;\n        end = start + sec->size;\n#\tifdef DARWIN_DEBUG\n            GC_printf4(\"Removing section at %p-%p (%lu bytes) from image %s\\n\",\n                start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n#\t\tendif\n        GC_remove_roots((char*)start,(char*)end);\n    }\n#   ifdef DARWIN_DEBUG\n        GC_print_static_roots();\n#   endif\n}\n\nvoid GC_register_dynamic_libraries() {\n    /* Currently does nothing. The callbacks are setup by GC_init_dyld() \n    The dyld library takes it from there. */\n}\n\n/* The _dyld_* functions have an internal lock so no _dyld functions\n   can be called while the world is stopped without the risk of a deadlock.\n   Because of this we MUST setup callbacks BEFORE we ever stop the world.\n   This should be called BEFORE any thread in created and WITHOUT the\n   allocation lock held. */\n   \nvoid GC_init_dyld() {\n  static GC_bool initialized = FALSE;\n  char *bind_fully_env = NULL;\n  \n  if(initialized) return;\n  \n#   ifdef DARWIN_DEBUG\n  GC_printf0(\"Registering dyld callbacks...\\n\");\n#   endif\n  \n  /* Apple's Documentation:\n     When you call _dyld_register_func_for_add_image, the dynamic linker runtime\n     calls the specified callback (func) once for each of the images that is\n     currently loaded into the program. When a new image is added to the program,\n     your callback is called again with the mach_header for the new image, and the \t\n     virtual memory slide amount of the new image. \n     \n     This WILL properly register already linked libraries and libraries \n     linked in the future\n  */\n  \n    _dyld_register_func_for_add_image(GC_dyld_image_add);\n    _dyld_register_func_for_remove_image(GC_dyld_image_remove);\n\n    /* Set this early to avoid reentrancy issues. */\n    initialized = TRUE;\n\n    bind_fully_env = getenv(\"DYLD_BIND_AT_LAUNCH\");\n    \n    if (bind_fully_env == NULL) {\n#   ifdef DARWIN_DEBUG\n      GC_printf0(\"Forcing full bind of GC code...\\n\");\n#   endif\n      \n      if(!_dyld_bind_fully_image_containing_address((unsigned long*)GC_malloc))\n        GC_abort(\"_dyld_bind_fully_image_containing_address failed\");\n    }\n\n}\n\n#define HAVE_REGISTER_MAIN_STATIC_DATA\nGC_bool GC_register_main_static_data()\n{\n  /* Already done through dyld callbacks */\n  return FALSE;\n}\n\n#endif /* DARWIN */\n\n#if defined(HAIKU)\n\n#include <kernel/image.h>\n\nvoid GC_register_dynamic_libraries()\n{\n    image_info info;\n    int32 cookie = 0;\n    while (get_next_image_info(0, &cookie, &info) == B_OK)\n    {\n        void *data = info.data;\n\tGC_add_roots_inner(data, data + info.data_size, TRUE);\n    }\n}\n\n#endif /* HAIKU */\n\n#else /* !DYNAMIC_LOADING */\n\n#ifdef PCR\n\n#   include \"il/PCR_IL.h\"\n#   include \"th/PCR_ThCtl.h\"\n#   include \"mm/PCR_MM.h\"\n\nvoid GC_register_dynamic_libraries()\n{\n    /* Add new static data areas of dynamically loaded modules.\t*/\n        {\n          PCR_IL_LoadedFile * p = PCR_IL_GetLastLoadedFile();\n          PCR_IL_LoadedSegment * q;\n          \n          /* Skip uncommited files */\n          while (p != NIL && !(p -> lf_commitPoint)) {\n              /* The loading of this file has not yet been committed\t*/\n              /* Hence its description could be inconsistent.  \t\t*/\n              /* Furthermore, it hasn't yet been run.  Hence its data\t*/\n              /* segments can't possibly reference heap allocated\t*/\n              /* objects.\t\t\t\t\t\t*/\n              p = p -> lf_prev;\n          }\n          for (; p != NIL; p = p -> lf_prev) {\n            for (q = p -> lf_ls; q != NIL; q = q -> ls_next) {\n              if ((q -> ls_flags & PCR_IL_SegFlags_Traced_MASK)\n                  == PCR_IL_SegFlags_Traced_on) {\n                GC_add_roots_inner\n                \t((char *)(q -> ls_addr), \n                \t (char *)(q -> ls_addr) + q -> ls_bytes,\n                \t TRUE);\n              }\n            }\n          }\n        }\n}\n\n\n#else /* !PCR */\n\nvoid GC_register_dynamic_libraries(){}\n\nint GC_no_dynamic_loading;\n\n#endif /* !PCR */\n\n#endif /* !DYNAMIC_LOADING */\n\n#ifndef HAVE_REGISTER_MAIN_STATIC_DATA\n\n/* Do we need to separately register the main static data segment? */\nGC_bool GC_register_main_static_data()\n{\n  return TRUE;\n}\n#endif /* HAVE_REGISTER_MAIN_STATIC_DATA */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/Makefile.am": "# Copyright (c) 1999-2001 by Red Hat, Inc. All rights reserved.\n# \n# THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n# OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n# \n# Permission is hereby granted to use or copy this program\n# for any purpose,  provided the above notices are retained on all copies.\n# Permission to modify the code and to distribute modified code is granted,\n# provided the above notices are retained, and a notice that the code was\n# modified is included with the above copyright notice.\n#\n# Original author: Tom Tromey\n# Severely truncated by Hans-J. Boehm\n\n## Process this file with automake to produce Makefile.in.\n\n## FIXME: `make dist' in this directory will not currently work.  Many\n## files that should be in the distribution are not mentioned in this\n## Makefile.am.\n\nACLOCAL_AMFLAGS = -I m4\n\nSUBDIRS = m4 include doc\n\nAM_CPPFLAGS = -I$(top_builddir)/.. -I$(top_srcdir)/..\n\n#\n# libtool is not capable of creating shared/static versions of a convenience\n# library, so we have to do it ourselves\n#\n\nnoinst_LTLIBRARIES = libmonogc.la libmonogc-static.la\n\nEXTRA_DIST = \n    ## more items will be succesively added below\n\nif POWERPC_DARWIN\nasm_libgc_sources = powerpc_darwin_mach_dep.s\nendif\n\nif TARGET_IA64\nasm_libgc_sources = ia64_save_regs_in_stack.s\nendif\n\nlibmonogc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\ndyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c \\\nmalloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\nobj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\nsolaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \\\nbackgraph.c win32_threads.c \\\npthread_support.c pthread_stop_world.c darwin_stop_world.c \\\nmach_dep.c $(asm_libgc_sources)\n\n# Include THREADDLLIBS here to ensure that the correct versions of\n# linuxthread semaphore functions get linked:\nlibmonogc_la_LIBADD = $(THREADDLLIBS) $(UNWINDLIBS)\nlibmonogc_la_DEPENDENCIES =\nlibmonogc_la_LDFLAGS = -version-info 1:2:0\n\nEXTRA_libmonogc_la_SOURCES = alpha_mach_dep.S \\\n    mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_darwin_mach_dep.s \\\n    rs6000_mach_dep.s sparc_mach_dep.S sparc_netbsd_mach_dep.s \\\n    sparc_sunos4_mach_dep.s ia64_save_regs_in_stack.s\n\nlibmonogc_static_la_SOURCES = $(libmonogc_la_SOURCES)\nlibmonogc_static_la_LIBADD = $(libmonogc_la_LIBADD)\nlibmonogc_static_la_LDFLAGS = -static\n\nEXTRA_DIST += alpha_mach_dep.S mips_sgi_mach_dep.s sparc_mach_dep.S\n\nAM_CFLAGS = $(WERROR_CFLAGS) @GC_CFLAGS@\n\nif CPLUSPLUS\nextra_checks = test_cpp\nelse\nextra_checks = \nendif\n\n#check_PROGRAMS = gctest $(extra_checks)\n\n#test.o:\t$(srcdir)/tests/test.c\n#\t$(COMPILE) -c $(srcdir)/tests/test.c\n# \tUsing $< in the above seems to fail with the HP/UX on Itanium make.\n#test_cpp.o:\t$(srcdir)/tests/test_cpp.cc\n#\t$(CXXCOMPILE) -c $(srcdir)/tests/test_cpp.cc\n\n## FIXME: this is probably the reason why some files from BUILT_SOURCES\n##     are included in the distribution\n# gctest_OBJECTS = test.o\n#gctest_SOURCES = tests/test.c\n#gctest_LDADD = ./libgc.la $(THREADDLLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)\n#test_cpp_SOURCES = tests/test_cpp.cc\n#test_cpp_LDADD = ./libgc.la ./libgccpp.la $(THREADDLLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)\n\n#TESTS = gctest $(extra_checks)\n\n## FIXME: relies on internal code generated by automake.\nall_objs = $(libgc_la_OBJECTS)\n$(all_objs) : include/private/gcconfig.h include/private/gc_priv.h \\\ninclude/private/gc_hdrs.h include/gc.h include/gc_gcj.h include/gc_mark.h\n\n## FIXME: we shouldn't have to do this, but automake forces us to.\nif COMPILER_XLC\n  ## XLC neither requires nor tolerates the unnecessary assembler goop\n  ASM_CPP_OPTIONS =\nelse\n  ## We use -Wp,-P to strip #line directives.  Irix `as' chokes on\n  ## these.\n  ASM_CPP_OPTIONS = -Wp,-P -x assembler-with-cpp\nendif\n.s.lo:\n## We use -Wp,-P to strip #line directives.  Irix `as' chokes on\n## these.\n\t$(LTCOMPILE) $(ASM_CPP_OPTIONS) -c $<\n\n## We have our own definition of LTCOMPILE because we want to use our\n## CFLAGS, not those passed in from the top level make.\nLTCOMPILE = $(LIBTOOL) --mode=compile --tag=CC $(CC) $(DEFS) \\\n\t-I$(top_srcdir)/include $(AM_CPPFLAGS) $(CPPFLAGS) \\\n\t$(AM_CFLAGS) $(MY_CFLAGS) $(GC_CFLAGS) \nLINK = $(LIBTOOL) --mode=link $(CC) $(AM_CFLAGS) $(MY_CFLAGS) $(LDFLAGS) -o $@\n\n# Work around what appears to be a GNU make bug handling MAKEFLAGS\n# values defined in terms of make variables, as is the case for CC and\n# friends when we are called from the top level Makefile.\nAM_MAKEFLAGS = \\\n\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n\t\"CFLAGS=$(CFLAGS)\" \\\n\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n\t\"INSTALL=$(INSTALL)\" \\\n\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n\t\"LDFLAGS=$(LDFLAGS)\" \\\n\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n\t\"MAKE=$(MAKE)\" \\\n\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n\t\"PICFLAG=$(PICFLAG)\" \\\n\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n\t\"SHELL=$(SHELL)\" \\\n\t\"EXPECT=$(EXPECT)\" \\\n\t\"RUNTEST=$(RUNTEST)\" \\\n\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n\t\"exec_prefix=$(exec_prefix)\" \\\n\t\"infodir=$(infodir)\" \\\n\t\"libdir=$(libdir)\" \\\n\t\"prefix=$(prefix)\" \\\n\t\"tooldir=$(tooldir)\" \\\n\t\"AR=$(AR)\" \\\n\t\"AS=$(AS)\" \\\n\t\"CC=$(CC)\" \\\n\t\"CXX=$(CXX)\" \\\n\t\"LD=$(LD)\" \\\n\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n\t\"NM=$(NM)\" \\\n\t\"PICFLAG=$(PICFLAG)\" \\\n\t\"RANLIB=$(RANLIB)\" \\\n\t\"DESTDIR=$(DESTDIR)\"\n\nMAKEOVERRIDES=\n\n# files used by makefiles other than Makefile.am\n#\nEXTRA_DIST += add_gc_prefix.c gcname.c if_mach.c if_not_there.c hpux_test_and_clear.s pc_excludes gc.mak MacOS.c MacProjects.sit.hqx mach_dep.c setjmp_t.c threadlibs.c AmigaOS.c version.h Mac_files/datastart.c Mac_files/dataend.c Mac_files/MacOS_config.h Mac_files/MacOS_Test_config.h\n\n# cord package\n#\nEXTRA_DIST += cord cord/cordbscs.c cord/cordtest.c cord/de.c cord/de_win.c cord/de_win.ICO cord/cordprnt.c cord/cordxtra.c cord/de_cmds.h cord/de_win.h cord/de_win.RC\n\n# this is an auxiliary shell file used by Makefile and Makefile.direct\n#\nCONFIG_STATUS_DEPENDENCIES = $(srcdir)/configure.host\n\n# :FIXME: why do we distribute this one???\n#\nEXTRA_DIST += configure.host\n\n#\n# :GOTCHA: GNU make rule for making .s out of .S is flawed, \n# it will not remove dest if building fails\n.S.s:\n\tif $(CPP) $< >$@ ; then :; else rm -f $@; fi\n\ntest:\n\ntest-bundle:\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/gc_dlopen.c": "/*\n * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n * Copyright (c) 1997 by Silicon Graphics.  All rights reserved.\n * Copyright (c) 2000 by Hewlett-Packard Company.  All rights reserved.\n *\n * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n *\n * Permission is hereby granted to use or copy this program\n * for any purpose,  provided the above notices are retained on all copies.\n * Permission to modify the code and to distribute modified code is granted,\n * provided the above notices are retained, and a notice that the code was\n * modified is included with the above copyright notice.\n *\n * Original author: Bill Janssen\n * Heavily modified by Hans Boehm and others\n */\n\n/*\n * This used to be in dyn_load.c.  It was extracted into a separate file\n * to avoid having to link against libdl.{a,so} if the client doesn't call\n * dlopen.  Of course this fails if the collector is in a dynamic\n * library. -HB\n */\n\n#include \"private/gc_priv.h\"\n\n# if defined(DYNAMIC_LOADING) && (defined(GC_PTHREADS) && !defined(GC_DARWIN_THREADS)) \\\n      || defined(GC_SOLARIS_THREADS)\n\n# if defined(dlopen) && !defined(GC_USE_LD_WRAP)\n    /* To support various threads pkgs, gc.h interposes on dlopen by     */\n    /* defining \"dlopen\" to be \"GC_dlopen\", which is implemented below.  */\n    /* However, both GC_FirstDLOpenedLinkMap() and GC_dlopen() use the   */\n    /* real system dlopen() in their implementation. We first remove     */\n    /* gc.h's dlopen definition and restore it later, after GC_dlopen(). */\n#   undef dlopen\n# endif\n\n  /* Make sure we're not in the middle of a collection, and make\t*/\n  /* sure we don't start any.\tReturns previous value of GC_dont_gc.\t*/\n  /* This is invoked prior to a dlopen call to avoid synchronization\t*/\n  /* issues.  We can't just acquire the allocation lock, since startup \t*/\n  /* code in dlopen may try to allocate.\t\t\t\t*/\n  /* This solution risks heap growth in the presence of many dlopen\t*/\n  /* calls in either a multithreaded environment, or if the library\t*/\n  /* initialization code allocates substantial amounts of GC'ed memory.\t*/\n  /* But I don't know of a better solution.\t\t\t\t*/\n  static void disable_gc_for_dlopen()\n  {\n    LOCK();\n    while (GC_incremental && GC_collection_in_progress()) {\n\tGC_collect_a_little_inner(1000);\n    }\n    ++GC_dont_gc;\n    UNLOCK();\n  }\n\n  /* Redefine dlopen to guarantee mutual exclusion with\t*/\n  /* GC_register_dynamic_libraries.\t\t\t*/\n  /* Should probably happen for other operating\tsystems, too. */\n\n#include <dlfcn.h>\n\n#ifdef GC_USE_LD_WRAP\n  void * __wrap_dlopen(const char *path, int mode)\n#else\n  void * GC_dlopen(path, mode)\n  GC_CONST char * path;\n  int mode;\n#endif\n{\n    void * result;\n    \n#   ifndef USE_PROC_FOR_LIBRARIES\n      disable_gc_for_dlopen();\n#   endif\n#   ifdef GC_USE_LD_WRAP\n      result = (void *)__real_dlopen(path, mode);\n#   else\n      result = dlopen(path, mode);\n#   endif\n#   ifndef USE_PROC_FOR_LIBRARIES\n      GC_enable(); /* undoes disable_gc_for_dlopen */\n#   endif\n    return(result);\n}\n# endif  /* GC_PTHREADS || GC_SOLARIS_THREADS ... */\n\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/pthread_stop_world.c": "#include \"private/pthread_support.h\"\n\n#if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \\\n     && !defined(GC_IRIX_THREADS) && !defined(GC_WIN32_THREADS) \\\n     && !defined(GC_DARWIN_THREADS) && !defined(GC_AIX_THREADS)\n\n#include <signal.h>\n#include <semaphore.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/time.h>\n\n/* work around a dlopen issue (bug #75390), undefs to avoid warnings with redefinitions */\n#undef PACKAGE_BUGREPORT\n#undef PACKAGE_NAME\n#undef PACKAGE_STRING\n#undef PACKAGE_TARNAME\n#undef PACKAGE_VERSION\n#include \"mono/utils/mono-compiler.h\"\n\n#ifdef NACL\nvolatile int __nacl_thread_suspension_needed = 0;\npthread_t nacl_thread_parker = -1;\n\nvolatile int nacl_thread_parked[MAX_NACL_GC_THREADS];\nvolatile int nacl_thread_used[MAX_NACL_GC_THREADS];\nvolatile int nacl_thread_parking_inited = 0;\nvolatile int nacl_num_gc_threads = 0;\npthread_mutex_t nacl_thread_alloc_lock = PTHREAD_MUTEX_INITIALIZER;\n__thread int nacl_thread_idx = -1;\n__thread GC_thread nacl_gc_thread_self = NULL;\n#endif\n\n#if DEBUG_THREADS\n\n#ifndef NSIG\n# if defined(MAXSIG)\n#  define NSIG (MAXSIG+1)\n# elif defined(_NSIG)\n#  define NSIG _NSIG\n# elif defined(__SIGRTMAX)\n#  define NSIG (__SIGRTMAX+1)\n# else\n  --> please fix it\n# endif\n#endif\n\n#ifndef NACL\nvoid GC_print_sig_mask()\n{\n    sigset_t blocked;\n    int i;\n\n    if (pthread_sigmask(SIG_BLOCK, NULL, &blocked) != 0)\n    \tABORT(\"pthread_sigmask\");\n    GC_printf0(\"Blocked: \");\n    for (i = 1; i < NSIG; i++) {\n        if (sigismember(&blocked, i)) { GC_printf1(\"%ld \",(long) i); }\n    }\n    GC_printf0(\"\\n\");\n}\n#endif /* NACL */\n#endif\n\n/* Remove the signals that we want to allow in thread stopping \t*/\n/* handler from a set.\t\t\t\t\t\t*/\nvoid GC_remove_allowed_signals(sigset_t *set)\n{\n#   ifdef NO_SIGNALS\n      if (sigdelset(set, SIGINT) != 0\n\t  || sigdelset(set, SIGQUIT) != 0\n\t  || sigdelset(set, SIGABRT) != 0\n\t  || sigdelset(set, SIGTERM) != 0) {\n        ABORT(\"sigdelset() failed\");\n      }\n#   endif\n\n#   ifdef MPROTECT_VDB\n      /* Handlers write to the thread structure, which is in the heap,\t*/\n      /* and hence can trigger a protection fault.\t\t\t*/\n      if (sigdelset(set, SIGSEGV) != 0\n#\t  ifdef SIGBUS\n\t    || sigdelset(set, SIGBUS) != 0\n# \t  endif\n\t  ) {\n        ABORT(\"sigdelset() failed\");\n      }\n#   endif\n}\n\nstatic sigset_t suspend_handler_mask;\n\nword GC_stop_count;\t/* Incremented at the beginning of GC_stop_world. */\n\n#ifdef GC_OSF1_THREADS\n  GC_bool GC_retry_signals = TRUE;\n#else\n  GC_bool GC_retry_signals = FALSE;\n#endif\n\n/*\n * We use signals to stop threads during GC.\n * \n * Suspended threads wait in signal handler for SIG_THR_RESTART.\n * That's more portable than semaphores or condition variables.\n * (We do use sem_post from a signal handler, but that should be portable.)\n *\n * The thread suspension signal SIG_SUSPEND is now defined in gc_priv.h.\n * Note that we can't just stop a thread; we need it to save its stack\n * pointer(s) and acknowledge.\n */\n\n#ifndef SIG_THR_RESTART\n#  if defined(GC_HPUX_THREADS) || defined(GC_OSF1_THREADS)\n#    ifdef _SIGRTMIN\n#      define SIG_THR_RESTART _SIGRTMIN + 5\n#    else\n#      define SIG_THR_RESTART SIGRTMIN + 5\n#    endif\n#  else\n#   define SIG_THR_RESTART SIGXCPU\n#  endif\n#endif\n\nsem_t GC_suspend_ack_sem;\n\nstatic void _GC_suspend_handler(int sig)\n{\n#ifndef NACL\n    int dummy;\n    pthread_t my_thread = pthread_self();\n    GC_thread me;\n#   ifdef PARALLEL_MARK\n\tword my_mark_no = GC_mark_no;\n\t/* Marker can't proceed until we acknowledge.  Thus this is\t*/\n\t/* guaranteed to be the mark_no correspending to our \t\t*/\n\t/* suspension, i.e. the marker can't have incremented it yet.\t*/\n#   endif\n    word my_stop_count = GC_stop_count;\n\n    if (sig != SIG_SUSPEND) ABORT(\"Bad signal in suspend_handler\");\n\n#if DEBUG_THREADS\n    GC_printf1(\"Suspending 0x%lx\\n\", my_thread);\n#endif\n\n    me = GC_lookup_thread(my_thread);\n    /* The lookup here is safe, since I'm doing this on behalf  */\n    /* of a thread which holds the allocation lock in order\t*/\n    /* to stop the world.  Thus concurrent modification of the\t*/\n    /* data structure is impossible.\t\t\t\t*/\n    if (me -> stop_info.last_stop_count == my_stop_count) {\n\t/* Duplicate signal.  OK if we are retrying.\t*/\n\tif (!GC_retry_signals) {\n\t    WARN(\"Duplicate suspend signal in thread %lx\\n\",\n\t\t pthread_self());\n\t}\n\treturn;\n    }\n#   ifdef SPARC\n\tme -> stop_info.stack_ptr = (ptr_t)GC_save_regs_in_stack();\n#   else\n\tme -> stop_info.stack_ptr = (ptr_t)(&dummy);\n#   endif\n#   ifdef IA64\n\tme -> backing_store_ptr = (ptr_t)GC_save_regs_in_stack();\n#   endif\n\n    /* Tell the thread that wants to stop the world that this   */\n    /* thread has been stopped.  Note that sem_post() is  \t*/\n    /* the only async-signal-safe primitive in LinuxThreads.    */\n    sem_post(&GC_suspend_ack_sem);\n    me -> stop_info.last_stop_count = my_stop_count;\n\n    /* Wait until that thread tells us to restart by sending    */\n    /* this thread a SIG_THR_RESTART signal.\t\t\t*/\n    /* SIG_THR_RESTART should be masked at this point.  Thus there\t*/\n    /* is no race.\t\t\t\t\t\t*/\n    do {\n\t    me->stop_info.signal = 0;\n\t    sigsuspend(&suspend_handler_mask);        /* Wait for signal */\n    } while (me->stop_info.signal != SIG_THR_RESTART);\n    /* If the RESTART signal gets lost, we can still lose.  That should be  */\n    /* less likely than losing the SUSPEND signal, since we don't do much   */\n    /* between the sem_post and sigsuspend.\t   \t\t\t    */\n    /* We'd need more handshaking to work around that, since we don't want  */\n    /* to accidentally leave a RESTART signal pending, thus causing us to   */\n    /* continue prematurely in a future round.\t\t\t\t    */ \n\n    /* Tell the thread that wants to start the world that this  */\n    /* thread has been started.  Note that sem_post() is  \t*/\n    /* the only async-signal-safe primitive in LinuxThreads.    */\n    sem_post(&GC_suspend_ack_sem);\n\n\n#if DEBUG_THREADS\n    GC_printf1(\"Continuing 0x%lx\\n\", my_thread);\n#endif\n\n#endif /* NACL */\n}\n\nvoid GC_suspend_handler(int sig)\n{\n\tint old_errno = errno;\n\t_GC_suspend_handler(sig);\n\terrno = old_errno;\n}\n\nstatic void _GC_restart_handler(int sig)\n{\n    pthread_t my_thread = pthread_self();\n    GC_thread me;\n\n    if (sig != SIG_THR_RESTART) ABORT(\"Bad signal in suspend_handler\");\n\n    /* Let the GC_suspend_handler() know that we got a SIG_THR_RESTART. */\n    /* The lookup here is safe, since I'm doing this on behalf  */\n    /* of a thread which holds the allocation lock in order\t*/\n    /* to stop the world.  Thus concurrent modification of the\t*/\n    /* data structure is impossible.\t\t\t\t*/\n    me = GC_lookup_thread(my_thread);\n    me->stop_info.signal = SIG_THR_RESTART;\n\n    /*\n    ** Note: even if we didn't do anything useful here,\n    ** it would still be necessary to have a signal handler,\n    ** rather than ignoring the signals, otherwise\n    ** the signals will not be delivered at all, and\n    ** will thus not interrupt the sigsuspend() above.\n    */\n\n#if DEBUG_THREADS\n    GC_printf1(\"In GC_restart_handler for 0x%lx\\n\", pthread_self());\n#endif\n}\n\n# ifdef IA64\n#   define IF_IA64(x) x\n# else\n#   define IF_IA64(x)\n# endif\n/* We hold allocation lock.  Should do exactly the right thing if the\t*/\n/* world is stopped.  Should not fail if it isn't.\t\t\t*/\nstatic void pthread_push_all_stacks()\n{\n    GC_bool found_me = FALSE;\n    int i;\n    GC_thread p;\n    ptr_t lo, hi;\n    /* On IA64, we also need to scan the register backing store. */\n    IF_IA64(ptr_t bs_lo; ptr_t bs_hi;)\n    pthread_t me = pthread_self();\n    \n    if (!GC_thr_initialized) GC_thr_init();\n    #if DEBUG_THREADS\n        GC_printf1(\"Pushing stacks from thread 0x%lx\\n\", (unsigned long) me);\n    #endif\n    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n      for (p = GC_threads[i]; p != 0; p = p -> next) {\n        if (p -> flags & FINISHED) continue;\n        if (pthread_equal(p -> id, me)) {\n#  \t    ifdef SPARC\n\t        lo = (ptr_t)GC_save_regs_in_stack();\n#  \t    else\n \t        lo = GC_approx_sp();\n#           endif\n\t    found_me = TRUE;\n\t    IF_IA64(bs_hi = (ptr_t)GC_save_regs_in_stack();)\n\t} else {\n\t    lo = p -> stop_info.stack_ptr;\n\t    IF_IA64(bs_hi = p -> backing_store_ptr;)\n\t}\n        if ((p -> flags & MAIN_THREAD) == 0) {\n\t    hi = p -> stack_end;\n\t    IF_IA64(bs_lo = p -> backing_store_end);\n        } else {\n            /* The original stack. */\n            hi = GC_stackbottom;\n\t    IF_IA64(bs_lo = BACKING_STORE_BASE;)\n        }\n        #if DEBUG_THREADS\n            GC_printf3(\"Stack for thread 0x%lx = [%lx,%lx)\\n\",\n    \t        (unsigned long) p -> id,\n\t\t(unsigned long) lo, (unsigned long) hi);\n        #endif\n\tif (0 == lo) ABORT(\"GC_push_all_stacks: sp not set!\\n\");\n\tif (p->altstack && lo >= p->altstack && lo <= p->altstack + p->altstack_size)\n\t\thi = p->altstack + p->altstack_size;\n       /* FIXME: Need to scan the normal stack too, but how ? */\n\n#       ifdef STACK_GROWS_UP\n\t  /* We got them backwards! */\n          GC_push_all_stack(hi, lo);\n#       else\n          GC_push_all_stack(lo, hi);\n#\tendif\n#       ifdef NACL\n\t  /* Push reg_storage as roots, this will cover the reg context */\n          GC_push_all_stack(p -> stop_info.reg_storage, p -> stop_info.reg_storage + NACL_GC_REG_STORAGE_SIZE);\n#       endif\n#\tifdef IA64\n#         if DEBUG_THREADS\n            GC_printf3(\"Reg stack for thread 0x%lx = [%lx,%lx)\\n\",\n    \t        (unsigned long) p -> id,\n\t\t(unsigned long) bs_lo, (unsigned long) bs_hi);\n#\t  endif\n          if (pthread_equal(p -> id, me)) {\n\t    GC_push_all_eager(bs_lo, bs_hi);\n\t  } else {\n\t    GC_push_all_stack(bs_lo, bs_hi);\n\t  }\n#\tendif\n      }\n    }\n    if (!found_me && !GC_in_thread_creation)\n      ABORT(\"Collecting from unknown thread.\");\n}\n\nvoid GC_restart_handler(int sig)\n{\n\tint old_errno = errno;\n\t_GC_restart_handler (sig);\n\terrno = old_errno;\n}\n\n/* We hold allocation lock.  Should do exactly the right thing if the\t*/\n/* world is stopped.  Should not fail if it isn't.\t\t\t*/\nvoid GC_push_all_stacks()\n{\n    pthread_push_all_stacks();\n}\n\n/* There seems to be a very rare thread stopping problem.  To help us  */\n/* debug that, we save the ids of the stopping thread. */\npthread_t GC_stopping_thread;\nint GC_stopping_pid;\n\n#ifdef HOST_ANDROID\nstatic\nint android_thread_kill(pid_t tid, int sig)\n{\n    int  ret;\n    int  old_errno = errno;\n\n    ret = tkill(tid, sig);\n    if (ret < 0) {\n        ret = errno;\n        errno = old_errno;\n    }\n\n    return ret;\n}\n#endif\n\n/* We hold the allocation lock.  Suspend all threads that might\t*/\n/* still be running.  Return the number of suspend signals that\t*/\n/* were sent. */\nint GC_suspend_all()\n{\n#ifndef NACL\n    int n_live_threads = 0;\n    int i;\n    GC_thread p;\n    int result;\n    pthread_t my_thread = pthread_self();\n    \n    GC_stopping_thread = my_thread;    /* debugging only.      */\n    GC_stopping_pid = getpid();                /* debugging only.      */\n    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n      for (p = GC_threads[i]; p != 0; p = p -> next) {\n        if (p -> id != my_thread) {\n            if (p -> flags & FINISHED) continue;\n            if (p -> stop_info.last_stop_count == GC_stop_count) continue;\n\t    if (p -> thread_blocked) /* Will wait */ continue;\n            n_live_threads++;\n\t    #if DEBUG_THREADS\n\t      GC_printf1(\"Sending suspend signal to 0x%lx\\n\", p -> id);\n\t    #endif\n\n#ifndef HOST_ANDROID\n        result = pthread_kill(p -> id, SIG_SUSPEND);\n#else\n        result = android_thread_kill(p -> kernel_id, SIG_SUSPEND);\n#endif\n\t    switch(result) {\n                case ESRCH:\n                    /* Not really there anymore.  Possible? */\n                    n_live_threads--;\n                    break;\n                case 0:\n                    break;\n                default:\n                    ABORT(\"pthread_kill failed\");\n            }\n        }\n      }\n    }\n    return n_live_threads;\n#else /* NACL */\n    return 0;\n#endif\n}\n\n/* Caller holds allocation lock.\t*/\nstatic void pthread_stop_world()\n{\n#ifndef NACL\n    int i;\n    int n_live_threads;\n    int code;\n\n    #if DEBUG_THREADS\n    GC_printf1(\"Stopping the world from 0x%lx\\n\", pthread_self());\n    #endif\n\n    n_live_threads = GC_suspend_all();\n\n      if (GC_retry_signals) {\n\t  unsigned long wait_usecs = 0;  /* Total wait since retry.\t*/\n#\t  define WAIT_UNIT 3000\n#\t  define RETRY_INTERVAL 100000\n\t  for (;;) {\n\t      int ack_count;\n\n\t      sem_getvalue(&GC_suspend_ack_sem, &ack_count);\n\t      if (ack_count == n_live_threads) break;\n\t      if (wait_usecs > RETRY_INTERVAL) {\n\t\t  int newly_sent = GC_suspend_all();\n\n#                 ifdef CONDPRINT\n\t\t    if (GC_print_stats) {\n\t\t      GC_printf1(\"Resent %ld signals after timeout\\n\",\n\t\t\t\t newly_sent);\n\t\t    }\n#                 endif\n\t\t  sem_getvalue(&GC_suspend_ack_sem, &ack_count);\n\t\t  if (newly_sent < n_live_threads - ack_count) {\n\t\t      WARN(\"Lost some threads during GC_stop_world?!\\n\",0);\n\t\t      n_live_threads = ack_count + newly_sent;\n\t\t  }\n\t\t  wait_usecs = 0;\n\t      }\n\t      usleep(WAIT_UNIT);\n\t      wait_usecs += WAIT_UNIT;\n\t  }\n      }\n    for (i = 0; i < n_live_threads; i++) {\n\t  while (0 != (code = sem_wait(&GC_suspend_ack_sem))) {\n\t      if (errno != EINTR) {\n\t         GC_err_printf1(\"Sem_wait returned %ld\\n\", (unsigned long)code);\n\t         ABORT(\"sem_wait for handler failed\");\n\t      }\n\t  }\n    }\n    #if DEBUG_THREADS\n      GC_printf1(\"World stopped from 0x%lx\\n\", pthread_self());\n    #endif\n    GC_stopping_thread = 0;  /* debugging only */\n#else /* NACL */\n    GC_thread p;\n    int i;\n    int num_sleeps = 0;\n\n    #if DEBUG_THREADS\n    GC_printf1(\"pthread_stop_world: num_threads %d\\n\", nacl_num_gc_threads - 1);\n    #endif\n    nacl_thread_parker = pthread_self();\n    __nacl_thread_suspension_needed = 1;\n    \n    while (1) {\n\t#define NACL_PARK_WAIT_NANOSECONDS 100000\n        #define NANOS_PER_SECOND 1000000000\n        int num_threads_parked = 0;\n        struct timespec ts;\n        int num_used = 0;\n\t/* Check the 'parked' flag for each thread the GC knows about */\n        for (i = 0; i < MAX_NACL_GC_THREADS && num_used < nacl_num_gc_threads; i++) {\n            if (nacl_thread_used[i] == 1) {\n                num_used++;\n                if (nacl_thread_parked[i] == 1) {\n                    num_threads_parked++;\n                }\n            }\n        }\n\t/* -1 for the current thread */\n        if (num_threads_parked >= nacl_num_gc_threads - 1)\n            break;\n        ts.tv_sec = 0;\n        ts.tv_nsec = NACL_PARK_WAIT_NANOSECONDS;\n        #if DEBUG_THREADS\n        GC_printf1(\"sleeping waiting for %d threads to park...\\n\", nacl_num_gc_threads - num_threads_parked - 1);\n        #endif\n        nanosleep(&ts, 0);\n        if (++num_sleeps > NANOS_PER_SECOND / NACL_PARK_WAIT_NANOSECONDS) {\n            GC_printf1(\"GC appears stalled waiting for %d threads to park...\\n\", nacl_num_gc_threads - num_threads_parked - 1);\n            num_sleeps = 0;\n        }\n    }\n\n#endif /* NACL */\n}\n\n\n#ifdef NACL\n\n#if __x86_64__\n\n#define NACL_STORE_REGS()  \\\n    do {                  \\\n\t__asm__ __volatile__ (\"push %rbx\");\\\n\t__asm__ __volatile__ (\"push %rbp\");\\\n\t__asm__ __volatile__ (\"push %r12\");\\\n\t__asm__ __volatile__ (\"push %r13\");\\\n\t__asm__ __volatile__ (\"push %r14\");\\\n\t__asm__ __volatile__ (\"push %r15\");\\\n\t__asm__ __volatile__ (\"mov %%esp, %0\" : \"=m\" (nacl_gc_thread_self->stop_info.stack_ptr));\\\n        memcpy(nacl_gc_thread_self->stop_info.reg_storage, nacl_gc_thread_self->stop_info.stack_ptr, NACL_GC_REG_STORAGE_SIZE * sizeof(ptr_t));\\\n        __asm__ __volatile__ (\"naclasp $48, %r15\");\\\n    } while (0)\n\n#elif __i386__\n\n#define NACL_STORE_REGS()  \\\n    do {                  \\\n\t__asm__ __volatile__ (\"push %ebx\");\\\n\t__asm__ __volatile__ (\"push %ebp\");\\\n\t__asm__ __volatile__ (\"push %esi\");\\\n\t__asm__ __volatile__ (\"push %edi\");\\\n\t__asm__ __volatile__ (\"mov %%esp, %0\" : \"=m\" (nacl_gc_thread_self->stop_info.stack_ptr));\\\n        memcpy(nacl_gc_thread_self->stop_info.reg_storage, nacl_gc_thread_self->stop_info.stack_ptr, NACL_GC_REG_STORAGE_SIZE * sizeof(ptr_t));\\\n\t__asm__ __volatile__ (\"add $16, %esp\");\\\n    } while (0)\n\n#elif __arm__\n\n#define NACL_STORE_REGS()  \\\n    do {                   \\\n\t__asm__ __volatile__ (                      \\\n\t\t\".align 4\\n\\t\"                      \\\n\t\t\"bic %0, %0, #0xc0000000\\n\\t\"       \\\n\t\t\"str sp, [%0]\\n\\t\"                  \\\n\t\t\"bic %1, %1, #0xc0000000\\n\\t\"       \\\n\t\t\"stm %1, {r4-r8,r10-r12,lr}\\n\\t\"    \\\n\t\t\t:                                               \\\n\t\t\t: \"r\" (&nacl_gc_thread_self->stop_info.stack_ptr), \\\n\t\t\t \"r\"(nacl_gc_thread_self->stop_info.reg_storage) \\\n\t\t\t: \"memory\");                 \\\n    } while (0)\n#else\n\n#error \"Please port NACL_STORE_REGS\"\n\n#endif\n\nvoid nacl_pre_syscall_hook()\n{\n    int local_dummy = 0;\n    if (nacl_thread_idx != -1) {\n\tNACL_STORE_REGS();\n        nacl_gc_thread_self->stop_info.stack_ptr = (ptr_t)(&local_dummy);\n        nacl_thread_parked[nacl_thread_idx] = 1;\n    }\n}\n\nvoid __nacl_suspend_thread_if_needed();\n\nvoid nacl_post_syscall_hook()\n{\n    /* Calling __nacl_suspend_thread_if_needed() right away should guarantee we don't mutate the GC set. */\n    __nacl_suspend_thread_if_needed();\n    if (nacl_thread_idx != -1) {\n        nacl_thread_parked[nacl_thread_idx] = 0;\n    }\n}\n\nvoid __nacl_suspend_thread_if_needed() {\n    if (__nacl_thread_suspension_needed) {\n        pthread_t self = pthread_self();\n        int local_dummy = 0;\n        /* Don't try to park the thread parker. */\n        if (nacl_thread_parker == self)\n            return;\n\n        /* This can happen when a thread is created   */\n        /* outside of the GC system (wthread mostly). */\n        if (nacl_thread_idx < 0)\n            return;\n\n        /* If it was already 'parked', we're returning from a syscall, */\n        /* so don't bother storing registers again, the GC has a set.  */\n        if (!nacl_thread_parked[nacl_thread_idx]) {\n            NACL_STORE_REGS();\n            nacl_gc_thread_self->stop_info.stack_ptr = (ptr_t)(&local_dummy);\n        }\n        nacl_thread_parked[nacl_thread_idx] = 1;\n        while (__nacl_thread_suspension_needed)\n            ; /* spin */\n        nacl_thread_parked[nacl_thread_idx] = 0;\n\n        /* Clear out the reg storage for next suspend. */\n        memset(nacl_gc_thread_self->stop_info.reg_storage, 0, NACL_GC_REG_STORAGE_SIZE * sizeof(ptr_t));\n    }\n}\n\n#endif /* NACL */\n\n/* Caller holds allocation lock.\t*/\nvoid GC_stop_world()\n{\n    if (GC_notify_event)\n        GC_notify_event (GC_EVENT_PRE_STOP_WORLD);\n\tGC_process_togglerefs ();\n    /* Make sure all free list construction has stopped before we start. */\n    /* No new construction can start, since free list construction is\t*/\n    /* required to acquire and release the GC lock before it starts,\t*/\n    /* and we have the lock.\t\t\t\t\t\t*/\n#   ifdef PARALLEL_MARK\n      GC_acquire_mark_lock();\n      GC_ASSERT(GC_fl_builder_count == 0);\n      /* We should have previously waited for it to become zero. */\n#   endif /* PARALLEL_MARK */\n    ++GC_stop_count;\n\tpthread_stop_world ();\n#   ifdef PARALLEL_MARK\n      GC_release_mark_lock();\n#   endif\n    if (GC_notify_event)\n        GC_notify_event (GC_EVENT_POST_STOP_WORLD);\n}\n\n/* Caller holds allocation lock, and has held it continuously since\t*/\n/* the world stopped.\t\t\t\t\t\t\t*/\nstatic void pthread_start_world()\n{\n#ifndef NACL\n    pthread_t my_thread = pthread_self();\n    register int i;\n    register GC_thread p;\n    register int n_live_threads = 0;\n    register int result;\n    int code;\n\n#   if DEBUG_THREADS\n      GC_printf0(\"World starting\\n\");\n#   endif\n    if (GC_notify_event)\n        GC_notify_event (GC_EVENT_PRE_START_WORLD);\n\n    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n      for (p = GC_threads[i]; p != 0; p = p -> next) {\n        if (p -> id != my_thread) {\n            if (p -> flags & FINISHED) continue;\n\t    if (p -> thread_blocked) continue;\n            n_live_threads++;\n\t    #if DEBUG_THREADS\n\t      GC_printf1(\"Sending restart signal to 0x%lx\\n\", p -> id);\n\t    #endif\n\n#ifndef HOST_ANDROID\n        result = pthread_kill(p -> id, SIG_THR_RESTART);\n#else\n        result = android_thread_kill(p -> kernel_id, SIG_THR_RESTART);\n#endif\n\t    switch(result) {\n                case ESRCH:\n                    /* Not really there anymore.  Possible? */\n                    n_live_threads--;\n                    break;\n                case 0:\n                    break;\n                default:\n                    ABORT(\"pthread_kill failed\");\n            }\n        }\n      }\n    }\n\n    #if DEBUG_THREADS\n    GC_printf0 (\"All threads signaled\");\n    #endif\n\n    for (i = 0; i < n_live_threads; i++) {\n\twhile (0 != (code = sem_wait(&GC_suspend_ack_sem))) {\n\t    if (errno != EINTR) {\n\t\tGC_err_printf1(\"Sem_wait returned %ld\\n\", (unsigned long)code);\n\t\tABORT(\"sem_wait for handler failed\");\n\t    }\n\t}\n    }\n  \n    if (GC_notify_event)\n        GC_notify_event (GC_EVENT_POST_START_WORLD);\n    #if DEBUG_THREADS\n      GC_printf0(\"World started\\n\");\n    #endif\n#else /* NACL */\n    if (GC_notify_event)\n        GC_notify_event (GC_EVENT_PRE_START_WORLD);\n#   if DEBUG_THREADS\n    GC_printf0(\"World starting\\n\");\n#   endif\n    __nacl_thread_suspension_needed = 0;\n    if (GC_notify_event)\n        GC_notify_event (GC_EVENT_POST_START_WORLD);\n#endif /* NACL */\n}\n\nvoid GC_start_world()\n{\n\tpthread_start_world ();\n}\n\nstatic void pthread_stop_init() {\n#ifndef NACL\n    struct sigaction act;\n    \n    if (sem_init(&GC_suspend_ack_sem, 0, 0) != 0)\n        ABORT(\"sem_init failed\");\n\n    act.sa_flags = SA_RESTART;\n    if (sigfillset(&act.sa_mask) != 0) {\n    \tABORT(\"sigfillset() failed\");\n    }\n    GC_remove_allowed_signals(&act.sa_mask);\n    /* SIG_THR_RESTART is set in the resulting mask.\t\t*/\n    /* It is unmasked by the handler when necessary. \t\t*/\n    act.sa_handler = GC_suspend_handler;\n    if (sigaction(SIG_SUSPEND, &act, NULL) != 0) {\n    \tABORT(\"Cannot set SIG_SUSPEND handler\");\n    }\n\n    act.sa_handler = GC_restart_handler;\n    if (sigaction(SIG_THR_RESTART, &act, NULL) != 0) {\n    \tABORT(\"Cannot set SIG_THR_RESTART handler\");\n    }\n\n    /* Inititialize suspend_handler_mask. It excludes SIG_THR_RESTART. */\n      if (sigfillset(&suspend_handler_mask) != 0) ABORT(\"sigfillset() failed\");\n      GC_remove_allowed_signals(&suspend_handler_mask);\n      if (sigdelset(&suspend_handler_mask, SIG_THR_RESTART) != 0)\n\t  ABORT(\"sigdelset() failed\");\n\n    /* Check for GC_RETRY_SIGNALS.\t*/\n      if (0 != GETENV(\"GC_RETRY_SIGNALS\")) {\n\t  GC_retry_signals = TRUE;\n      }\n      if (0 != GETENV(\"GC_NO_RETRY_SIGNALS\")) {\n\t  GC_retry_signals = FALSE;\n      }\n#     ifdef CONDPRINT\n          if (GC_print_stats && GC_retry_signals) {\n              GC_printf0(\"Will retry suspend signal if necessary.\\n\");\n\t  }\n#     endif\n#endif /* NACL */\n}\n\n/* We hold the allocation lock.\t*/\nvoid GC_stop_init()\n{\n\tpthread_stop_init ();\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/Makefile.in": "# Makefile.in generated by automake 1.15 from Makefile.am.\n# @configure_input@\n\n# Copyright (C) 1994-2014 Free Software Foundation, Inc.\n\n# This Makefile.in is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n# PARTICULAR PURPOSE.\n\n@SET_MAKE@\n\n# Copyright (c) 1999-2001 by Red Hat, Inc. All rights reserved.\n# \n# THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n# OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n# \n# Permission is hereby granted to use or copy this program\n# for any purpose,  provided the above notices are retained on all copies.\n# Permission to modify the code and to distribute modified code is granted,\n# provided the above notices are retained, and a notice that the code was\n# modified is included with the above copyright notice.\n#\n# Original author: Tom Tromey\n# Severely truncated by Hans-J. Boehm\n\nVPATH = @srcdir@\nam__is_gnu_make = { \\\n  if test -z '$(MAKELEVEL)'; then \\\n    false; \\\n  elif test -n '$(MAKE_HOST)'; then \\\n    true; \\\n  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \\\n    true; \\\n  else \\\n    false; \\\n  fi; \\\n}\nam__make_running_with_option = \\\n  case $${target_option-} in \\\n      ?) ;; \\\n      *) echo \"am__make_running_with_option: internal error: invalid\" \\\n              \"target option '$${target_option-}' specified\" >&2; \\\n         exit 1;; \\\n  esac; \\\n  has_opt=no; \\\n  sane_makeflags=$$MAKEFLAGS; \\\n  if $(am__is_gnu_make); then \\\n    sane_makeflags=$$MFLAGS; \\\n  else \\\n    case $$MAKEFLAGS in \\\n      *\\\\[\\ \\\t]*) \\\n        bs=\\\\; \\\n        sane_makeflags=`printf '%s\\n' \"$$MAKEFLAGS\" \\\n          | sed \"s/$$bs$$bs[$$bs $$bs\t]*//g\"`;; \\\n    esac; \\\n  fi; \\\n  skip_next=no; \\\n  strip_trailopt () \\\n  { \\\n    flg=`printf '%s\\n' \"$$flg\" | sed \"s/$$1.*$$//\"`; \\\n  }; \\\n  for flg in $$sane_makeflags; do \\\n    test $$skip_next = yes && { skip_next=no; continue; }; \\\n    case $$flg in \\\n      *=*|--*) continue;; \\\n        -*I) strip_trailopt 'I'; skip_next=yes;; \\\n      -*I?*) strip_trailopt 'I';; \\\n        -*O) strip_trailopt 'O'; skip_next=yes;; \\\n      -*O?*) strip_trailopt 'O';; \\\n        -*l) strip_trailopt 'l'; skip_next=yes;; \\\n      -*l?*) strip_trailopt 'l';; \\\n      -[dEDm]) skip_next=yes;; \\\n      -[JT]) skip_next=yes;; \\\n    esac; \\\n    case $$flg in \\\n      *$$target_option*) has_opt=yes; break;; \\\n    esac; \\\n  done; \\\n  test $$has_opt = yes\nam__make_dryrun = (target_option=n; $(am__make_running_with_option))\nam__make_keepgoing = (target_option=k; $(am__make_running_with_option))\npkgdatadir = $(datadir)/@PACKAGE@\npkgincludedir = $(includedir)/@PACKAGE@\npkglibdir = $(libdir)/@PACKAGE@\npkglibexecdir = $(libexecdir)/@PACKAGE@\nam__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\ninstall_sh_DATA = $(install_sh) -c -m 644\ninstall_sh_PROGRAM = $(install_sh) -c\ninstall_sh_SCRIPT = $(install_sh) -c\nINSTALL_HEADER = $(INSTALL_DATA)\ntransform = $(program_transform_name)\nNORMAL_INSTALL = :\nPRE_INSTALL = :\nPOST_INSTALL = :\nNORMAL_UNINSTALL = :\nPRE_UNINSTALL = :\nPOST_UNINSTALL = :\nbuild_triplet = @build@\nhost_triplet = @host@\nsubdir = .\nACLOCAL_M4 = $(top_srcdir)/aclocal.m4\nam__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \\\n\t$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \\\n\t$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \\\n\t$(top_srcdir)/acinclude.m4 $(top_srcdir)/configure.ac\nam__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n\t$(ACLOCAL_M4)\nDIST_COMMON = $(srcdir)/Makefile.am $(top_srcdir)/configure \\\n\t$(am__configure_deps) $(am__DIST_COMMON)\nam__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n configure.lineno config.status.lineno\nmkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs\nCONFIG_CLEAN_FILES =\nCONFIG_CLEAN_VPATH_FILES =\nLTLIBRARIES = $(noinst_LTLIBRARIES)\nam__DEPENDENCIES_1 =\nam__DEPENDENCIES_2 = $(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)\nlibmonogc_static_la_DEPENDENCIES = $(am__DEPENDENCIES_2)\nam__libmonogc_static_la_SOURCES_DIST = allchblk.c alloc.c blacklst.c \\\n\tchecksums.c dbg_mlc.c dyn_load.c finalize.c gc_dlopen.c \\\n\tgcj_mlc.c headers.c malloc.c mallocx.c mark.c mark_rts.c \\\n\tmisc.c new_hblk.c obj_map.c os_dep.c pcr_interface.c \\\n\tptr_chck.c real_malloc.c reclaim.c solaris_pthreads.c \\\n\tsolaris_threads.c specific.c stubborn.c typd_mlc.c backgraph.c \\\n\twin32_threads.c pthread_support.c pthread_stop_world.c \\\n\tdarwin_stop_world.c mach_dep.c powerpc_darwin_mach_dep.s \\\n\tia64_save_regs_in_stack.s\n@POWERPC_DARWIN_FALSE@@TARGET_IA64_TRUE@am__objects_1 = ia64_save_regs_in_stack.lo\n@POWERPC_DARWIN_TRUE@am__objects_1 = powerpc_darwin_mach_dep.lo\nam__objects_2 = allchblk.lo alloc.lo blacklst.lo checksums.lo \\\n\tdbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo \\\n\theaders.lo malloc.lo mallocx.lo mark.lo mark_rts.lo misc.lo \\\n\tnew_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo ptr_chck.lo \\\n\treal_malloc.lo reclaim.lo solaris_pthreads.lo \\\n\tsolaris_threads.lo specific.lo stubborn.lo typd_mlc.lo \\\n\tbackgraph.lo win32_threads.lo pthread_support.lo \\\n\tpthread_stop_world.lo darwin_stop_world.lo mach_dep.lo \\\n\t$(am__objects_1)\nam_libmonogc_static_la_OBJECTS = $(am__objects_2)\nlibmonogc_static_la_OBJECTS = $(am_libmonogc_static_la_OBJECTS)\nAM_V_lt = $(am__v_lt_@AM_V@)\nam__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)\nam__v_lt_0 = --silent\nam__v_lt_1 = \nlibmonogc_static_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \\\n\t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \\\n\t$(AM_CFLAGS) $(CFLAGS) $(libmonogc_static_la_LDFLAGS) \\\n\t$(LDFLAGS) -o $@\nam__libmonogc_la_SOURCES_DIST = allchblk.c alloc.c blacklst.c \\\n\tchecksums.c dbg_mlc.c dyn_load.c finalize.c gc_dlopen.c \\\n\tgcj_mlc.c headers.c malloc.c mallocx.c mark.c mark_rts.c \\\n\tmisc.c new_hblk.c obj_map.c os_dep.c pcr_interface.c \\\n\tptr_chck.c real_malloc.c reclaim.c solaris_pthreads.c \\\n\tsolaris_threads.c specific.c stubborn.c typd_mlc.c backgraph.c \\\n\twin32_threads.c pthread_support.c pthread_stop_world.c \\\n\tdarwin_stop_world.c mach_dep.c powerpc_darwin_mach_dep.s \\\n\tia64_save_regs_in_stack.s\nam_libmonogc_la_OBJECTS = allchblk.lo alloc.lo blacklst.lo \\\n\tchecksums.lo dbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo \\\n\tgcj_mlc.lo headers.lo malloc.lo mallocx.lo mark.lo mark_rts.lo \\\n\tmisc.lo new_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo \\\n\tptr_chck.lo real_malloc.lo reclaim.lo solaris_pthreads.lo \\\n\tsolaris_threads.lo specific.lo stubborn.lo typd_mlc.lo \\\n\tbackgraph.lo win32_threads.lo pthread_support.lo \\\n\tpthread_stop_world.lo darwin_stop_world.lo mach_dep.lo \\\n\t$(am__objects_1)\nlibmonogc_la_OBJECTS = $(am_libmonogc_la_OBJECTS)\nlibmonogc_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n\t$(libmonogc_la_LDFLAGS) $(LDFLAGS) -o $@\nAM_V_P = $(am__v_P_@AM_V@)\nam__v_P_ = $(am__v_P_@AM_DEFAULT_V@)\nam__v_P_0 = false\nam__v_P_1 = :\nAM_V_GEN = $(am__v_GEN_@AM_V@)\nam__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)\nam__v_GEN_0 = @echo \"  GEN     \" $@;\nam__v_GEN_1 = \nAM_V_at = $(am__v_at_@AM_V@)\nam__v_at_ = $(am__v_at_@AM_DEFAULT_V@)\nam__v_at_0 = @\nam__v_at_1 = \nDEFAULT_INCLUDES = -I.@am__isrc@\ndepcomp = $(SHELL) $(top_srcdir)/depcomp\nam__depfiles_maybe = depfiles\nam__mv = mv -f\nCPPASCOMPILE = $(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CCASFLAGS) $(CCASFLAGS)\nLTCPPASCOMPILE = $(LIBTOOL) $(AM_V_lt) $(AM_LIBTOOLFLAGS) \\\n\t$(LIBTOOLFLAGS) --mode=compile $(CCAS) $(DEFS) \\\n\t$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \\\n\t$(AM_CCASFLAGS) $(CCASFLAGS)\nAM_V_CPPAS = $(am__v_CPPAS_@AM_V@)\nam__v_CPPAS_ = $(am__v_CPPAS_@AM_DEFAULT_V@)\nam__v_CPPAS_0 = @echo \"  CPPAS   \" $@;\nam__v_CPPAS_1 = \nCOMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\nAM_V_CC = $(am__v_CC_@AM_V@)\nam__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)\nam__v_CC_0 = @echo \"  CC      \" $@;\nam__v_CC_1 = \nCCLD = $(CC)\nAM_V_CCLD = $(am__v_CCLD_@AM_V@)\nam__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)\nam__v_CCLD_0 = @echo \"  CCLD    \" $@;\nam__v_CCLD_1 = \nCCASCOMPILE = $(CCAS) $(AM_CCASFLAGS) $(CCASFLAGS)\nLTCCASCOMPILE = $(LIBTOOL) $(AM_V_lt) $(AM_LIBTOOLFLAGS) \\\n\t$(LIBTOOLFLAGS) --mode=compile $(CCAS) $(AM_CCASFLAGS) \\\n\t$(CCASFLAGS)\nAM_V_CCAS = $(am__v_CCAS_@AM_V@)\nam__v_CCAS_ = $(am__v_CCAS_@AM_DEFAULT_V@)\nam__v_CCAS_0 = @echo \"  CCAS    \" $@;\nam__v_CCAS_1 = \nSOURCES = $(libmonogc_static_la_SOURCES) $(libmonogc_la_SOURCES) \\\n\t$(EXTRA_libmonogc_la_SOURCES)\nDIST_SOURCES = $(am__libmonogc_static_la_SOURCES_DIST) \\\n\t$(am__libmonogc_la_SOURCES_DIST) $(EXTRA_libmonogc_la_SOURCES)\nRECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \\\n\tctags-recursive dvi-recursive html-recursive info-recursive \\\n\tinstall-data-recursive install-dvi-recursive \\\n\tinstall-exec-recursive install-html-recursive \\\n\tinstall-info-recursive install-pdf-recursive \\\n\tinstall-ps-recursive install-recursive installcheck-recursive \\\n\tinstalldirs-recursive pdf-recursive ps-recursive \\\n\ttags-recursive uninstall-recursive\nam__can_run_installinfo = \\\n  case $$AM_UPDATE_INFO_DIR in \\\n    n|no|NO) false;; \\\n    *) (install-info --version) >/dev/null 2>&1;; \\\n  esac\nRECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n  distclean-recursive maintainer-clean-recursive\nam__recursive_targets = \\\n  $(RECURSIVE_TARGETS) \\\n  $(RECURSIVE_CLEAN_TARGETS) \\\n  $(am__extra_recursive_targets)\nAM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \\\n\tcscope distdir dist dist-all distcheck\nam__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)\n# Read a list of newline-separated strings from the standard input,\n# and print each of them once, without duplicates.  Input order is\n# *not* preserved.\nam__uniquify_input = $(AWK) '\\\n  BEGIN { nonempty = 0; } \\\n  { items[$$0] = 1; nonempty = 1; } \\\n  END { if (nonempty) { for (i in items) print i; }; } \\\n'\n# Make sure the list of sources is unique.  This is necessary because,\n# e.g., the same source file might be shared among _SOURCES variables\n# for different programs/libraries.\nam__define_uniq_tagged_files = \\\n  list='$(am__tagged_files)'; \\\n  unique=`for i in $$list; do \\\n    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n  done | $(am__uniquify_input)`\nETAGS = etags\nCTAGS = ctags\nCSCOPE = cscope\nDIST_SUBDIRS = $(SUBDIRS)\nam__DIST_COMMON = $(srcdir)/Makefile.in compile config.guess \\\n\tconfig.sub depcomp install-sh ltconfig ltmain.sh missing \\\n\tmkinstalldirs\nDISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\ndistdir = $(PACKAGE)-$(VERSION)\ntop_distdir = $(distdir)\nam__remove_distdir = \\\n  if test -d \"$(distdir)\"; then \\\n    find \"$(distdir)\" -type d ! -perm -200 -exec chmod u+w {} ';' \\\n      && rm -rf \"$(distdir)\" \\\n      || { sleep 5 && rm -rf \"$(distdir)\"; }; \\\n  else :; fi\nam__post_remove_distdir = $(am__remove_distdir)\nam__relativize = \\\n  dir0=`pwd`; \\\n  sed_first='s,^\\([^/]*\\)/.*$$,\\1,'; \\\n  sed_rest='s,^[^/]*/*,,'; \\\n  sed_last='s,^.*/\\([^/]*\\)$$,\\1,'; \\\n  sed_butlast='s,/*[^/]*$$,,'; \\\n  while test -n \"$$dir1\"; do \\\n    first=`echo \"$$dir1\" | sed -e \"$$sed_first\"`; \\\n    if test \"$$first\" != \".\"; then \\\n      if test \"$$first\" = \"..\"; then \\\n        dir2=`echo \"$$dir0\" | sed -e \"$$sed_last\"`/\"$$dir2\"; \\\n        dir0=`echo \"$$dir0\" | sed -e \"$$sed_butlast\"`; \\\n      else \\\n        first2=`echo \"$$dir2\" | sed -e \"$$sed_first\"`; \\\n        if test \"$$first2\" = \"$$first\"; then \\\n          dir2=`echo \"$$dir2\" | sed -e \"$$sed_rest\"`; \\\n        else \\\n          dir2=\"../$$dir2\"; \\\n        fi; \\\n        dir0=\"$$dir0\"/\"$$first\"; \\\n      fi; \\\n    fi; \\\n    dir1=`echo \"$$dir1\" | sed -e \"$$sed_rest\"`; \\\n  done; \\\n  reldir=\"$$dir2\"\nDIST_ARCHIVES = $(distdir).tar.gz\nGZIP_ENV = --best\nDIST_TARGETS = dist-gzip\ndistuninstallcheck_listfiles = find . -type f -print\nam__distuninstallcheck_listfiles = $(distuninstallcheck_listfiles) \\\n  | sed 's|^\\./|$(prefix)/|' | grep -v '$(infodir)/dir$$'\ndistcleancheck_listfiles = find . -type f -print\nACLOCAL = @ACLOCAL@\nAMTAR = @AMTAR@\nAM_CPPFLAGS = -I$(top_builddir)/.. -I$(top_srcdir)/..\nAM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@\nAR = @AR@\nAUTOCONF = @AUTOCONF@\nAUTOHEADER = @AUTOHEADER@\nAUTOMAKE = @AUTOMAKE@\nAWK = @AWK@\nCC = @CC@\nCCAS = @CCAS@\nCCASDEPMODE = @CCASDEPMODE@\nCCASFLAGS = @CCASFLAGS@\nCCDEPMODE = @CCDEPMODE@\nCFLAGS = @CFLAGS@\nCPP = @CPP@\nCPPFLAGS = @CPPFLAGS@\nCXX = @CXX@\nCXXCPP = @CXXCPP@\nCXXDEPMODE = @CXXDEPMODE@\nCXXFLAGS = @CXXFLAGS@\nCXXINCLUDES = @CXXINCLUDES@\nCYGPATH_W = @CYGPATH_W@\nDEFS = @DEFS@\nDEPDIR = @DEPDIR@\nDLLTOOL = @DLLTOOL@\nDOLT_BASH = @DOLT_BASH@\nDSYMUTIL = @DSYMUTIL@\nDUMPBIN = @DUMPBIN@\nECHO_C = @ECHO_C@\nECHO_N = @ECHO_N@\nECHO_T = @ECHO_T@\nEGREP = @EGREP@\nEXEEXT = @EXEEXT@\nEXTRA_TEST_LIBS = @EXTRA_TEST_LIBS@\nFGREP = @FGREP@\nGC_CFLAGS = @GC_CFLAGS@\nGC_VERSION = @GC_VERSION@\nGREP = @GREP@\nINSTALL = @INSTALL@\nINSTALL_DATA = @INSTALL_DATA@\nINSTALL_PROGRAM = @INSTALL_PROGRAM@\nINSTALL_SCRIPT = @INSTALL_SCRIPT@\nINSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\nLD = @LD@\nLDFLAGS = @LDFLAGS@\nLIBOBJS = @LIBOBJS@\nLIBS = @LIBS@\nLIBTOOL = @LIBTOOL@\nLIPO = @LIPO@\nLN_S = @LN_S@\nLTCOMPILE = $(LIBTOOL) --mode=compile --tag=CC $(CC) $(DEFS) \\\n\t-I$(top_srcdir)/include $(AM_CPPFLAGS) $(CPPFLAGS) \\\n\t$(AM_CFLAGS) $(MY_CFLAGS) $(GC_CFLAGS) \n\nLTCXXCOMPILE = @LTCXXCOMPILE@\nLTLIBOBJS = @LTLIBOBJS@\nLT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@\nMAINT = @MAINT@\nMAKEINFO = @MAKEINFO@\nMANIFEST_TOOL = @MANIFEST_TOOL@\nMKDIR_P = @MKDIR_P@\nMY_CFLAGS = @MY_CFLAGS@\nNM = @NM@\nNMEDIT = @NMEDIT@\nOBJDUMP = @OBJDUMP@\nOBJEXT = @OBJEXT@\nOTOOL = @OTOOL@\nOTOOL64 = @OTOOL64@\nPACKAGE = @PACKAGE@\nPACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\nPACKAGE_NAME = @PACKAGE_NAME@\nPACKAGE_STRING = @PACKAGE_STRING@\nPACKAGE_TARNAME = @PACKAGE_TARNAME@\nPACKAGE_URL = @PACKAGE_URL@\nPACKAGE_VERSION = @PACKAGE_VERSION@\nPATH_SEPARATOR = @PATH_SEPARATOR@\nRANLIB = @RANLIB@\nSED = @SED@\nSET_MAKE = @SET_MAKE@\nSHELL = @SHELL@\nSTRIP = @STRIP@\nTHREADDLLIBS = @THREADDLLIBS@\nUNWINDLIBS = @UNWINDLIBS@\nVERSION = @VERSION@\nWERROR_CFLAGS = @WERROR_CFLAGS@\nabs_builddir = @abs_builddir@\nabs_srcdir = @abs_srcdir@\nabs_top_builddir = @abs_top_builddir@\nabs_top_srcdir = @abs_top_srcdir@\nac_ct_AR = @ac_ct_AR@\nac_ct_CC = @ac_ct_CC@\nac_ct_CXX = @ac_ct_CXX@\nac_ct_DUMPBIN = @ac_ct_DUMPBIN@\naddincludes = @addincludes@\naddlibs = @addlibs@\naddtests = @addtests@\nam__include = @am__include@\nam__leading_dot = @am__leading_dot@\nam__quote = @am__quote@\nam__tar = @am__tar@\nam__untar = @am__untar@\nbindir = @bindir@\nbuild = @build@\nbuild_alias = @build_alias@\nbuild_cpu = @build_cpu@\nbuild_os = @build_os@\nbuild_vendor = @build_vendor@\nbuilddir = @builddir@\ndatadir = @datadir@\ndatarootdir = @datarootdir@\ndocdir = @docdir@\ndvidir = @dvidir@\nexec_prefix = @exec_prefix@\nhost = @host@\nhost_alias = @host_alias@\nhost_cpu = @host_cpu@\nhost_os = @host_os@\nhost_vendor = @host_vendor@\nhtmldir = @htmldir@\nincludedir = @includedir@\ninfodir = @infodir@\ninstall_sh = @install_sh@\nlibdir = @libdir@\nlibexecdir = @libexecdir@\nlocaledir = @localedir@\nlocalstatedir = @localstatedir@\nmandir = @mandir@\nmkdir_p = @mkdir_p@\noldincludedir = @oldincludedir@\npdfdir = @pdfdir@\nprefix = @prefix@\nprogram_transform_name = @program_transform_name@\npsdir = @psdir@\nrunstatedir = @runstatedir@\nsbindir = @sbindir@\nsharedstatedir = @sharedstatedir@\nsrcdir = @srcdir@\nsysconfdir = @sysconfdir@\ntarget_alias = @target_alias@\ntarget_all = @target_all@\ntop_build_prefix = @top_build_prefix@\ntop_builddir = @top_builddir@\ntop_srcdir = @top_srcdir@\nACLOCAL_AMFLAGS = -I m4\nSUBDIRS = m4 include doc\n\n#\n# libtool is not capable of creating shared/static versions of a convenience\n# library, so we have to do it ourselves\n#\nnoinst_LTLIBRARIES = libmonogc.la libmonogc-static.la\n\n# files used by makefiles other than Makefile.am\n#\n\n# cord package\n#\n\n# :FIXME: why do we distribute this one???\n#\nEXTRA_DIST = alpha_mach_dep.S mips_sgi_mach_dep.s sparc_mach_dep.S \\\n\tadd_gc_prefix.c gcname.c if_mach.c if_not_there.c \\\n\thpux_test_and_clear.s pc_excludes gc.mak MacOS.c \\\n\tMacProjects.sit.hqx mach_dep.c setjmp_t.c threadlibs.c \\\n\tAmigaOS.c version.h Mac_files/datastart.c Mac_files/dataend.c \\\n\tMac_files/MacOS_config.h Mac_files/MacOS_Test_config.h cord \\\n\tcord/cordbscs.c cord/cordtest.c cord/de.c cord/de_win.c \\\n\tcord/de_win.ICO cord/cordprnt.c cord/cordxtra.c cord/de_cmds.h \\\n\tcord/de_win.h cord/de_win.RC configure.host\n@POWERPC_DARWIN_TRUE@asm_libgc_sources = powerpc_darwin_mach_dep.s\n@TARGET_IA64_TRUE@asm_libgc_sources = ia64_save_regs_in_stack.s\nlibmonogc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\ndyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c \\\nmalloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\nobj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\nsolaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \\\nbackgraph.c win32_threads.c \\\npthread_support.c pthread_stop_world.c darwin_stop_world.c \\\nmach_dep.c $(asm_libgc_sources)\n\n\n# Include THREADDLLIBS here to ensure that the correct versions of\n# linuxthread semaphore functions get linked:\nlibmonogc_la_LIBADD = $(THREADDLLIBS) $(UNWINDLIBS)\nlibmonogc_la_DEPENDENCIES = \nlibmonogc_la_LDFLAGS = -version-info 1:2:0\nEXTRA_libmonogc_la_SOURCES = alpha_mach_dep.S \\\n    mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_darwin_mach_dep.s \\\n    rs6000_mach_dep.s sparc_mach_dep.S sparc_netbsd_mach_dep.s \\\n    sparc_sunos4_mach_dep.s ia64_save_regs_in_stack.s\n\nlibmonogc_static_la_SOURCES = $(libmonogc_la_SOURCES)\nlibmonogc_static_la_LIBADD = $(libmonogc_la_LIBADD)\nlibmonogc_static_la_LDFLAGS = -static\nAM_CFLAGS = $(WERROR_CFLAGS) @GC_CFLAGS@\n@CPLUSPLUS_FALSE@extra_checks = \n@CPLUSPLUS_TRUE@extra_checks = test_cpp\n\n#check_PROGRAMS = gctest $(extra_checks)\n\n#test.o:\t$(srcdir)/tests/test.c\n#\t$(COMPILE) -c $(srcdir)/tests/test.c\n# \tUsing $< in the above seems to fail with the HP/UX on Itanium make.\n#test_cpp.o:\t$(srcdir)/tests/test_cpp.cc\n#\t$(CXXCOMPILE) -c $(srcdir)/tests/test_cpp.cc\n\n# gctest_OBJECTS = test.o\n#gctest_SOURCES = tests/test.c\n#gctest_LDADD = ./libgc.la $(THREADDLLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)\n#test_cpp_SOURCES = tests/test_cpp.cc\n#test_cpp_LDADD = ./libgc.la ./libgccpp.la $(THREADDLLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)\n\n#TESTS = gctest $(extra_checks)\nall_objs = $(libgc_la_OBJECTS)\n@COMPILER_XLC_FALSE@ASM_CPP_OPTIONS = -Wp,-P -x assembler-with-cpp\n@COMPILER_XLC_TRUE@ASM_CPP_OPTIONS = \nLINK = $(LIBTOOL) --mode=link $(CC) $(AM_CFLAGS) $(MY_CFLAGS) $(LDFLAGS) -o $@\n\n# Work around what appears to be a GNU make bug handling MAKEFLAGS\n# values defined in terms of make variables, as is the case for CC and\n# friends when we are called from the top level Makefile.\nAM_MAKEFLAGS = \\\n\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n\t\"CFLAGS=$(CFLAGS)\" \\\n\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n\t\"INSTALL=$(INSTALL)\" \\\n\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n\t\"LDFLAGS=$(LDFLAGS)\" \\\n\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n\t\"MAKE=$(MAKE)\" \\\n\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n\t\"PICFLAG=$(PICFLAG)\" \\\n\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n\t\"SHELL=$(SHELL)\" \\\n\t\"EXPECT=$(EXPECT)\" \\\n\t\"RUNTEST=$(RUNTEST)\" \\\n\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n\t\"exec_prefix=$(exec_prefix)\" \\\n\t\"infodir=$(infodir)\" \\\n\t\"libdir=$(libdir)\" \\\n\t\"prefix=$(prefix)\" \\\n\t\"tooldir=$(tooldir)\" \\\n\t\"AR=$(AR)\" \\\n\t\"AS=$(AS)\" \\\n\t\"CC=$(CC)\" \\\n\t\"CXX=$(CXX)\" \\\n\t\"LD=$(LD)\" \\\n\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n\t\"NM=$(NM)\" \\\n\t\"PICFLAG=$(PICFLAG)\" \\\n\t\"RANLIB=$(RANLIB)\" \\\n\t\"DESTDIR=$(DESTDIR)\"\n\nMAKEOVERRIDES = \n\n# this is an auxiliary shell file used by Makefile and Makefile.direct\n#\nCONFIG_STATUS_DEPENDENCIES = $(srcdir)/configure.host\nall: all-recursive\n\n.SUFFIXES:\n.SUFFIXES: .S .c .lo .o .obj .s\nam--refresh: Makefile\n\t@:\n$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n\t@for dep in $?; do \\\n\t  case '$(am__configure_deps)' in \\\n\t    *$$dep*) \\\n\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n\t\t&& exit 0; \\\n\t      exit 1;; \\\n\t  esac; \\\n\tdone; \\\n\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n\t$(am__cd) $(top_srcdir) && \\\n\t  $(AUTOMAKE) --foreign Makefile\nMakefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n\t@case '$?' in \\\n\t  *config.status*) \\\n\t    echo ' $(SHELL) ./config.status'; \\\n\t    $(SHELL) ./config.status;; \\\n\t  *) \\\n\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n\tesac;\n\n$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n\t$(SHELL) ./config.status --recheck\n\n$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n\t$(am__cd) $(srcdir) && $(AUTOCONF)\n$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n$(am__aclocal_m4_deps):\n\nclean-noinstLTLIBRARIES:\n\t-test -z \"$(noinst_LTLIBRARIES)\" || rm -f $(noinst_LTLIBRARIES)\n\t@list='$(noinst_LTLIBRARIES)'; \\\n\tlocs=`for p in $$list; do echo $$p; done | \\\n\t      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \\\n\t      sort -u`; \\\n\ttest -z \"$$locs\" || { \\\n\t  echo rm -f $${locs}; \\\n\t  rm -f $${locs}; \\\n\t}\n\nlibmonogc-static.la: $(libmonogc_static_la_OBJECTS) $(libmonogc_static_la_DEPENDENCIES) $(EXTRA_libmonogc_static_la_DEPENDENCIES) \n\t$(AM_V_CCLD)$(libmonogc_static_la_LINK)  $(libmonogc_static_la_OBJECTS) $(libmonogc_static_la_LIBADD) $(LIBS)\n\nlibmonogc.la: $(libmonogc_la_OBJECTS) $(libmonogc_la_DEPENDENCIES) $(EXTRA_libmonogc_la_DEPENDENCIES) \n\t$(AM_V_CCLD)$(libmonogc_la_LINK)  $(libmonogc_la_OBJECTS) $(libmonogc_la_LIBADD) $(LIBS)\n\nmostlyclean-compile:\n\t-rm -f *.$(OBJEXT)\n\ndistclean-compile:\n\t-rm -f *.tab.c\n\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allchblk.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alloc.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alpha_mach_dep.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/backgraph.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/blacklst.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/checksums.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/darwin_stop_world.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dbg_mlc.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dyn_load.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/finalize.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gc_dlopen.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gcj_mlc.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/headers.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mach_dep.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/malloc.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mallocx.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mark.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mark_rts.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/misc.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/new_hblk.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/obj_map.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/os_dep.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pcr_interface.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pthread_stop_world.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pthread_support.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ptr_chck.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/real_malloc.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/reclaim.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/solaris_pthreads.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/solaris_threads.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sparc_mach_dep.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/specific.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stubborn.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/typd_mlc.Plo@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/win32_threads.Plo@am__quote@\n\n.S.o:\n@am__fastdepCCAS_TRUE@\t$(AM_V_CPPAS)$(CPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n@am__fastdepCCAS_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS@am__nodep@)$(CPPASCOMPILE) -c -o $@ $<\n\n.S.obj:\n@am__fastdepCCAS_TRUE@\t$(AM_V_CPPAS)$(CPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n@am__fastdepCCAS_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS@am__nodep@)$(CPPASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n\n.S.lo:\n@am__fastdepCCAS_TRUE@\t$(AM_V_CPPAS)$(LTCPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n@am__fastdepCCAS_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS@am__nodep@)$(LTCPPASCOMPILE) -c -o $@ $<\n\n.c.o:\n@am__fastdepCC_TRUE@\t$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<\n\n.c.obj:\n@am__fastdepCC_TRUE@\t$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n\n.c.lo:\n@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<\n\n.s.o:\n\t$(AM_V_CCAS)$(CCASCOMPILE) -c -o $@ $<\n\n.s.obj:\n\t$(AM_V_CCAS)$(CCASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n\nmostlyclean-libtool:\n\t-rm -f *.lo\n\nclean-libtool:\n\t-rm -rf .libs _libs\n\ndistclean-libtool:\n\t-rm -f libtool config.lt\n\n# This directory's subdirectories are mostly independent; you can cd\n# into them and run 'make' without going through this Makefile.\n# To change the values of 'make' variables: instead of editing Makefiles,\n# (1) if the variable is set in 'config.status', edit 'config.status'\n#     (which will cause the Makefiles to be regenerated when you run 'make');\n# (2) otherwise, pass the desired values on the 'make' command line.\n$(am__recursive_targets):\n\t@fail=; \\\n\tif $(am__make_keepgoing); then \\\n\t  failcom='fail=yes'; \\\n\telse \\\n\t  failcom='exit 1'; \\\n\tfi; \\\n\tdot_seen=no; \\\n\ttarget=`echo $@ | sed s/-recursive//`; \\\n\tcase \"$@\" in \\\n\t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n\t  *) list='$(SUBDIRS)' ;; \\\n\tesac; \\\n\tfor subdir in $$list; do \\\n\t  echo \"Making $$target in $$subdir\"; \\\n\t  if test \"$$subdir\" = \".\"; then \\\n\t    dot_seen=yes; \\\n\t    local_target=\"$$target-am\"; \\\n\t  else \\\n\t    local_target=\"$$target\"; \\\n\t  fi; \\\n\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n\t  || eval $$failcom; \\\n\tdone; \\\n\tif test \"$$dot_seen\" = \"no\"; then \\\n\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n\tfi; test -z \"$$fail\"\n\nID: $(am__tagged_files)\n\t$(am__define_uniq_tagged_files); mkid -fID $$unique\ntags: tags-recursive\nTAGS: tags\n\ntags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)\n\tset x; \\\n\there=`pwd`; \\\n\tif ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \\\n\t  include_option=--etags-include; \\\n\t  empty_fix=.; \\\n\telse \\\n\t  include_option=--include; \\\n\t  empty_fix=; \\\n\tfi; \\\n\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n\t  if test \"$$subdir\" = .; then :; else \\\n\t    test ! -f $$subdir/TAGS || \\\n\t      set \"$$@\" \"$$include_option=$$here/$$subdir/TAGS\"; \\\n\t  fi; \\\n\tdone; \\\n\t$(am__define_uniq_tagged_files); \\\n\tshift; \\\n\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n\t  if test $$# -gt 0; then \\\n\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n\t      \"$$@\" $$unique; \\\n\t  else \\\n\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n\t      $$unique; \\\n\t  fi; \\\n\tfi\nctags: ctags-recursive\n\nCTAGS: ctags\nctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)\n\t$(am__define_uniq_tagged_files); \\\n\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n\t     $$unique\n\nGTAGS:\n\there=`$(am__cd) $(top_builddir) && pwd` \\\n\t  && $(am__cd) $(top_srcdir) \\\n\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\ncscope: cscope.files\n\ttest ! -s cscope.files \\\n\t  || $(CSCOPE) -b -q $(AM_CSCOPEFLAGS) $(CSCOPEFLAGS) -i cscope.files $(CSCOPE_ARGS)\nclean-cscope:\n\t-rm -f cscope.files\ncscope.files: clean-cscope cscopelist\ncscopelist: cscopelist-recursive\n\ncscopelist-am: $(am__tagged_files)\n\tlist='$(am__tagged_files)'; \\\n\tcase \"$(srcdir)\" in \\\n\t  [\\\\/]* | ?:[\\\\/]*) sdir=\"$(srcdir)\" ;; \\\n\t  *) sdir=$(subdir)/$(srcdir) ;; \\\n\tesac; \\\n\tfor i in $$list; do \\\n\t  if test -f \"$$i\"; then \\\n\t    echo \"$(subdir)/$$i\"; \\\n\t  else \\\n\t    echo \"$$sdir/$$i\"; \\\n\t  fi; \\\n\tdone >> $(top_builddir)/cscope.files\n\ndistclean-tags:\n\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n\t-rm -f cscope.out cscope.in.out cscope.po.out cscope.files\n\ndistdir: $(DISTFILES)\n\t$(am__remove_distdir)\n\ttest -d \"$(distdir)\" || mkdir \"$(distdir)\"\n\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n\tlist='$(DISTFILES)'; \\\n\t  dist_files=`for file in $$list; do echo $$file; done | \\\n\t  sed -e \"s|^$$srcdirstrip/||;t\" \\\n\t      -e \"s|^$$topsrcdirstrip/|$(top_builddir)/|;t\"`; \\\n\tcase $$dist_files in \\\n\t  */*) $(MKDIR_P) `echo \"$$dist_files\" | \\\n\t\t\t   sed '/\\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \\\n\t\t\t   sort -u` ;; \\\n\tesac; \\\n\tfor file in $$dist_files; do \\\n\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n\t  if test -d $$d/$$file; then \\\n\t    dir=`echo \"/$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n\t    if test -d \"$(distdir)/$$file\"; then \\\n\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n\t    fi; \\\n\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n\t      cp -fpR $(srcdir)/$$file \"$(distdir)$$dir\" || exit 1; \\\n\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n\t    fi; \\\n\t    cp -fpR $$d/$$file \"$(distdir)$$dir\" || exit 1; \\\n\t  else \\\n\t    test -f \"$(distdir)/$$file\" \\\n\t    || cp -p $$d/$$file \"$(distdir)/$$file\" \\\n\t    || exit 1; \\\n\t  fi; \\\n\tdone\n\t@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \\\n\t  if test \"$$subdir\" = .; then :; else \\\n\t    $(am__make_dryrun) \\\n\t      || test -d \"$(distdir)/$$subdir\" \\\n\t      || $(MKDIR_P) \"$(distdir)/$$subdir\" \\\n\t      || exit 1; \\\n\t    dir1=$$subdir; dir2=\"$(distdir)/$$subdir\"; \\\n\t    $(am__relativize); \\\n\t    new_distdir=$$reldir; \\\n\t    dir1=$$subdir; dir2=\"$(top_distdir)\"; \\\n\t    $(am__relativize); \\\n\t    new_top_distdir=$$reldir; \\\n\t    echo \" (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir=\"$$new_top_distdir\" distdir=\"$$new_distdir\" \\\\\"; \\\n\t    echo \"     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)\"; \\\n\t    ($(am__cd) $$subdir && \\\n\t      $(MAKE) $(AM_MAKEFLAGS) \\\n\t        top_distdir=\"$$new_top_distdir\" \\\n\t        distdir=\"$$new_distdir\" \\\n\t\tam__remove_distdir=: \\\n\t\tam__skip_length_check=: \\\n\t\tam__skip_mode_fix=: \\\n\t        distdir) \\\n\t      || exit 1; \\\n\t  fi; \\\n\tdone\n\t-test -n \"$(am__skip_mode_fix)\" \\\n\t|| find \"$(distdir)\" -type d ! -perm -755 \\\n\t\t-exec chmod u+rwx,go+rx {} \\; -o \\\n\t  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \\; -o \\\n\t  ! -type d ! -perm -400 -exec chmod a+r {} \\; -o \\\n\t  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \\; \\\n\t|| chmod -R a+r \"$(distdir)\"\ndist-gzip: distdir\n\ttardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz\n\t$(am__post_remove_distdir)\n\ndist-bzip2: distdir\n\ttardir=$(distdir) && $(am__tar) | BZIP2=$${BZIP2--9} bzip2 -c >$(distdir).tar.bz2\n\t$(am__post_remove_distdir)\n\ndist-lzip: distdir\n\ttardir=$(distdir) && $(am__tar) | lzip -c $${LZIP_OPT--9} >$(distdir).tar.lz\n\t$(am__post_remove_distdir)\n\ndist-xz: distdir\n\ttardir=$(distdir) && $(am__tar) | XZ_OPT=$${XZ_OPT--e} xz -c >$(distdir).tar.xz\n\t$(am__post_remove_distdir)\n\ndist-tarZ: distdir\n\t@echo WARNING: \"Support for distribution archives compressed with\" \\\n\t\t       \"legacy program 'compress' is deprecated.\" >&2\n\t@echo WARNING: \"It will be removed altogether in Automake 2.0\" >&2\n\ttardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z\n\t$(am__post_remove_distdir)\n\ndist-shar: distdir\n\t@echo WARNING: \"Support for shar distribution archives is\" \\\n\t               \"deprecated.\" >&2\n\t@echo WARNING: \"It will be removed altogether in Automake 2.0\" >&2\n\tshar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz\n\t$(am__post_remove_distdir)\n\ndist-zip: distdir\n\t-rm -f $(distdir).zip\n\tzip -rq $(distdir).zip $(distdir)\n\t$(am__post_remove_distdir)\n\ndist dist-all:\n\t$(MAKE) $(AM_MAKEFLAGS) $(DIST_TARGETS) am__post_remove_distdir='@:'\n\t$(am__post_remove_distdir)\n\n# This target untars the dist file and tries a VPATH configuration.  Then\n# it guarantees that the distribution is self-contained by making another\n# tarfile.\ndistcheck: dist\n\tcase '$(DIST_ARCHIVES)' in \\\n\t*.tar.gz*) \\\n\t  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\\\n\t*.tar.bz2*) \\\n\t  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\\\n\t*.tar.lz*) \\\n\t  lzip -dc $(distdir).tar.lz | $(am__untar) ;;\\\n\t*.tar.xz*) \\\n\t  xz -dc $(distdir).tar.xz | $(am__untar) ;;\\\n\t*.tar.Z*) \\\n\t  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\\\n\t*.shar.gz*) \\\n\t  GZIP=$(GZIP_ENV) gzip -dc $(distdir).shar.gz | unshar ;;\\\n\t*.zip*) \\\n\t  unzip $(distdir).zip ;;\\\n\tesac\n\tchmod -R a-w $(distdir)\n\tchmod u+w $(distdir)\n\tmkdir $(distdir)/_build $(distdir)/_build/sub $(distdir)/_inst\n\tchmod a-w $(distdir)\n\ttest -d $(distdir)/_build || exit 0; \\\n\tdc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\\\/]:[\\\\/],/,'` \\\n\t  && dc_destdir=\"$${TMPDIR-/tmp}/am-dc-$$$$/\" \\\n\t  && am__cwd=`pwd` \\\n\t  && $(am__cd) $(distdir)/_build/sub \\\n\t  && ../../configure \\\n\t    $(AM_DISTCHECK_CONFIGURE_FLAGS) \\\n\t    $(DISTCHECK_CONFIGURE_FLAGS) \\\n\t    --srcdir=../.. --prefix=\"$$dc_install_base\" \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) dvi \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) check \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) install \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) installcheck \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) uninstall \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir=\"$$dc_install_base\" \\\n\t        distuninstallcheck \\\n\t  && chmod -R a-w \"$$dc_install_base\" \\\n\t  && ({ \\\n\t       (cd ../.. && umask 077 && mkdir \"$$dc_destdir\") \\\n\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" install \\\n\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" uninstall \\\n\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" \\\n\t            distuninstallcheck_dir=\"$$dc_destdir\" distuninstallcheck; \\\n\t      } || { rm -rf \"$$dc_destdir\"; exit 1; }) \\\n\t  && rm -rf \"$$dc_destdir\" \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) dist \\\n\t  && rm -rf $(DIST_ARCHIVES) \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \\\n\t  && cd \"$$am__cwd\" \\\n\t  || exit 1\n\t$(am__post_remove_distdir)\n\t@(echo \"$(distdir) archives ready for distribution: \"; \\\n\t  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \\\n\t  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'\ndistuninstallcheck:\n\t@test -n '$(distuninstallcheck_dir)' || { \\\n\t  echo 'ERROR: trying to run $@ with an empty' \\\n\t       '$$(distuninstallcheck_dir)' >&2; \\\n\t  exit 1; \\\n\t}; \\\n\t$(am__cd) '$(distuninstallcheck_dir)' || { \\\n\t  echo 'ERROR: cannot chdir into $(distuninstallcheck_dir)' >&2; \\\n\t  exit 1; \\\n\t}; \\\n\ttest `$(am__distuninstallcheck_listfiles) | wc -l` -eq 0 \\\n\t   || { echo \"ERROR: files left after uninstall:\" ; \\\n\t        if test -n \"$(DESTDIR)\"; then \\\n\t          echo \"  (check DESTDIR support)\"; \\\n\t        fi ; \\\n\t        $(distuninstallcheck_listfiles) ; \\\n\t        exit 1; } >&2\ndistcleancheck: distclean\n\t@if test '$(srcdir)' = . ; then \\\n\t  echo \"ERROR: distcleancheck can only run from a VPATH build\" ; \\\n\t  exit 1 ; \\\n\tfi\n\t@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \\\n\t  || { echo \"ERROR: files left in build directory after distclean:\" ; \\\n\t       $(distcleancheck_listfiles) ; \\\n\t       exit 1; } >&2\ncheck-am: all-am\ncheck: check-recursive\nall-am: Makefile $(LTLIBRARIES)\ninstalldirs: installdirs-recursive\ninstalldirs-am:\ninstall: install-recursive\ninstall-exec: install-exec-recursive\ninstall-data: install-data-recursive\nuninstall: uninstall-recursive\n\ninstall-am: all-am\n\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n\ninstallcheck: installcheck-recursive\ninstall-strip:\n\tif test -z '$(STRIP)'; then \\\n\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n\t      install; \\\n\telse \\\n\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n\tfi\nmostlyclean-generic:\n\nclean-generic:\n\ndistclean-generic:\n\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n\nmaintainer-clean-generic:\n\t@echo \"This command is intended for maintainers to use\"\n\t@echo \"it deletes files that may require special tools to rebuild.\"\nclean: clean-recursive\n\nclean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \\\n\tmostlyclean-am\n\ndistclean: distclean-recursive\n\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n\t-rm -rf ./$(DEPDIR)\n\t-rm -f Makefile\ndistclean-am: clean-am distclean-compile distclean-generic \\\n\tdistclean-libtool distclean-tags\n\ndvi: dvi-recursive\n\ndvi-am:\n\nhtml: html-recursive\n\nhtml-am:\n\ninfo: info-recursive\n\ninfo-am:\n\ninstall-data-am:\n\ninstall-dvi: install-dvi-recursive\n\ninstall-dvi-am:\n\ninstall-exec-am:\n\ninstall-html: install-html-recursive\n\ninstall-html-am:\n\ninstall-info: install-info-recursive\n\ninstall-info-am:\n\ninstall-man:\n\ninstall-pdf: install-pdf-recursive\n\ninstall-pdf-am:\n\ninstall-ps: install-ps-recursive\n\ninstall-ps-am:\n\ninstallcheck-am:\n\nmaintainer-clean: maintainer-clean-recursive\n\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n\t-rm -rf $(top_srcdir)/autom4te.cache\n\t-rm -rf ./$(DEPDIR)\n\t-rm -f Makefile\nmaintainer-clean-am: distclean-am maintainer-clean-generic\n\nmostlyclean: mostlyclean-recursive\n\nmostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n\tmostlyclean-libtool\n\npdf: pdf-recursive\n\npdf-am:\n\nps: ps-recursive\n\nps-am:\n\nuninstall-am:\n\n.MAKE: $(am__recursive_targets) install-am install-strip\n\n.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am \\\n\tam--refresh check check-am clean clean-cscope clean-generic \\\n\tclean-libtool clean-noinstLTLIBRARIES cscope cscopelist-am \\\n\tctags ctags-am dist dist-all dist-bzip2 dist-gzip dist-lzip \\\n\tdist-shar dist-tarZ dist-xz dist-zip distcheck distclean \\\n\tdistclean-compile distclean-generic distclean-libtool \\\n\tdistclean-tags distcleancheck distdir distuninstallcheck dvi \\\n\tdvi-am html html-am info info-am install install-am \\\n\tinstall-data install-data-am install-dvi install-dvi-am \\\n\tinstall-exec install-exec-am install-html install-html-am \\\n\tinstall-info install-info-am install-man install-pdf \\\n\tinstall-pdf-am install-ps install-ps-am install-strip \\\n\tinstallcheck installcheck-am installdirs installdirs-am \\\n\tmaintainer-clean maintainer-clean-generic mostlyclean \\\n\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n\tpdf pdf-am ps ps-am tags tags-am uninstall uninstall-am\n\n.PRECIOUS: Makefile\n\n$(all_objs) : include/private/gcconfig.h include/private/gc_priv.h \\\ninclude/private/gc_hdrs.h include/gc.h include/gc_gcj.h include/gc_mark.h\n.s.lo:\n\t$(LTCOMPILE) $(ASM_CPP_OPTIONS) -c $<\n\n#\n# :GOTCHA: GNU make rule for making .s out of .S is flawed, \n# it will not remove dest if building fails\n.S.s:\n\tif $(CPP) $< >$@ ; then :; else rm -f $@; fi\n\ntest:\n\ntest-bundle:\n\n# Tell versions [3.59,3.63) of GNU make to not export all variables.\n# Otherwise a system limit (for SysV at least) may be exceeded.\n.NOEXPORT:\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/include/gc_pthread_redirects.h": "/* Our pthread support normally needs to intercept a number of thread\t*/\n/* calls.  We arrange to do that here, if appropriate.\t\t\t*/\n\n#ifndef GC_PTHREAD_REDIRECTS_H\n\n#define GC_PTHREAD_REDIRECTS_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n  void * GC_dlopen(const char *path, int mode);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#if defined(GC_SOLARIS_THREADS)\n/* We need to intercept calls to many of the threads primitives, so \t*/\n/* that we can locate thread stacks and stop the world.\t\t\t*/\n/* Note also that the collector cannot see thread specific data.\t*/\n/* Thread specific data should generally consist of pointers to\t\t*/\n/* uncollectable objects (allocated with GC_malloc_uncollectable,\t*/\n/* not the system malloc), which are deallocated using the destructor\t*/\n/* facility in thr_keycreate.  Alternatively, keep a redundant pointer\t*/\n/* to thread specific data on the thread stack.\t\t\t        */\n# include <thread.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n  int GC_thr_create(void *stack_base, size_t stack_size,\n                    void *(*start_routine)(void *), void *arg, long flags,\n                    thread_t *new_thread);\n  int GC_thr_join(thread_t wait_for, thread_t *departed, void **status);\n  int GC_thr_suspend(thread_t target_thread);\n  int GC_thr_continue(thread_t target_thread);\n# define thr_create GC_thr_create\n# define thr_join GC_thr_join\n# define thr_suspend GC_thr_suspend\n# define thr_continue GC_thr_continue\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#endif /* GC_SOLARIS_THREADS */\n\n#if defined(GC_SOLARIS_PTHREADS)\n\n# include <pthread.h>\n# include <signal.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n  extern int GC_pthread_create(pthread_t *new_thread,\n    \t\t\t         const pthread_attr_t *attr,\n          \t\t\t void * (*thread_execp)(void *), void *arg);\n  extern int GC_pthread_join(pthread_t wait_for, void **status);\n  extern int GC_pthread_detach(pthread_t thread);\n# define pthread_join GC_pthread_join\n# define pthread_create GC_pthread_create\n# define pthread_detach GC_pthread_detach\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#endif\n\n#if defined(GC_SOLARIS_PTHREADS) || defined(GC_SOLARIS_THREADS)\n# define dlopen GC_dlopen\n#endif /* SOLARIS_THREADS || SOLARIS_PTHREADS */\n\n#if !defined(GC_USE_LD_WRAP) && (defined(GC_PTHREADS) || defined(GC_DARWIN_THREADS) || defined(GC_MACOSX_THREADS)) && !defined(GC_SOLARIS_PTHREADS)\n/* We treat these similarly. */\n# include <pthread.h>\n# include <signal.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n  int GC_pthread_create(pthread_t *new_thread,\n                        const pthread_attr_t *attr,\n\t\t        void *(*start_routine)(void *), void *arg);\n#ifndef GC_DARWIN_THREADS\n  int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);\n#endif\n  int GC_pthread_join(pthread_t thread, void **retval);\n  int GC_pthread_detach(pthread_t thread);\n#if defined(__native_client__) || defined(NACL)\n  void GC_pthread_exit(void *status);\n# undef pthread_exit\n# define pthread_exit GC_pthread_exit\n#endif\n\n#if defined(GC_OSF1_THREADS) \\\n    && defined(_PTHREAD_USE_MANGLED_NAMES_) && !defined(_PTHREAD_USE_PTDNAM_)\n/* Unless the compiler supports #pragma extern_prefix, the Tru64 UNIX\n   <pthread.h> redefines some POSIX thread functions to use mangled names.\n   If so, undef them before redefining. */\n# undef pthread_create\n# undef pthread_join\n# undef pthread_detach\n#endif\n\n# define pthread_create GC_pthread_create\n# define pthread_join GC_pthread_join\n# define pthread_detach GC_pthread_detach\n\n#ifndef GC_DARWIN_THREADS \n# ifdef GC_NETBSD_THREADS\n#  undef pthread_sigmask\n# endif\n# define pthread_sigmask GC_pthread_sigmask\n# define dlopen GC_dlopen\n#endif\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#endif /* GC_xxxxx_THREADS */\n\n#endif /* GC_PTHREAD_REDIRECTS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/m4/libtool.m4": "# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-\n#\n#   Copyright (C) 1996-2001, 2003-2015 Free Software Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\nm4_define([_LT_COPYING], [dnl\n# Copyright (C) 2014 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# GNU Libtool is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of of the License, or\n# (at your option) any later version.\n#\n# As a special exception to the GNU General Public License, if you\n# distribute this file as part of a program or library that is built\n# using GNU Libtool, you may include this file under the  same\n# distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n])\n\n# serial 58 LT_INIT\n\n\n# LT_PREREQ(VERSION)\n# ------------------\n# Complain and exit if this libtool version is less that VERSION.\nm4_defun([LT_PREREQ],\n[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,\n       [m4_default([$3],\n\t\t   [m4_fatal([Libtool version $1 or higher is required],\n\t\t             63)])],\n       [$2])])\n\n\n# _LT_CHECK_BUILDDIR\n# ------------------\n# Complain if the absolute build directory name contains unusual characters\nm4_defun([_LT_CHECK_BUILDDIR],\n[case `pwd` in\n  *\\ * | *\\\t*)\n    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;\nesac\n])\n\n\n# LT_INIT([OPTIONS])\n# ------------------\nAC_DEFUN([LT_INIT],\n[AC_PREREQ([2.62])dnl We use AC_PATH_PROGS_FEATURE_CHECK\nAC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl\nAC_BEFORE([$0], [LT_LANG])dnl\nAC_BEFORE([$0], [LT_OUTPUT])dnl\nAC_BEFORE([$0], [LTDL_INIT])dnl\nm4_require([_LT_CHECK_BUILDDIR])dnl\n\ndnl Autoconf doesn't catch unexpanded LT_ macros by default:\nm4_pattern_forbid([^_?LT_[A-Z_]+$])dnl\nm4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl\ndnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4\ndnl unless we require an AC_DEFUNed macro:\nAC_REQUIRE([LTOPTIONS_VERSION])dnl\nAC_REQUIRE([LTSUGAR_VERSION])dnl\nAC_REQUIRE([LTVERSION_VERSION])dnl\nAC_REQUIRE([LTOBSOLETE_VERSION])dnl\nm4_require([_LT_PROG_LTMAIN])dnl\n\n_LT_SHELL_INIT([SHELL=${CONFIG_SHELL-/bin/sh}])\n\ndnl Parse OPTIONS\n_LT_SET_OPTIONS([$0], [$1])\n\n# This can be used to rebuild libtool when needed\nLIBTOOL_DEPS=$ltmain\n\n# Always use our own libtool.\nLIBTOOL='$(SHELL) $(top_builddir)/libtool'\nAC_SUBST(LIBTOOL)dnl\n\n_LT_SETUP\n\n# Only expand once:\nm4_define([LT_INIT])\n])# LT_INIT\n\n# Old names:\nAU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])\nAU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PROG_LIBTOOL], [])\ndnl AC_DEFUN([AM_PROG_LIBTOOL], [])\n\n\n# _LT_PREPARE_CC_BASENAME\n# -----------------------\nm4_defun([_LT_PREPARE_CC_BASENAME], [\n# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.\nfunc_cc_basename ()\n{\n    for cc_temp in @S|@*\"\"; do\n      case $cc_temp in\n        compile | *[[\\\\/]]compile | ccache | *[[\\\\/]]ccache ) ;;\n        distcc | *[[\\\\/]]distcc | purify | *[[\\\\/]]purify ) ;;\n        \\-*) ;;\n        *) break;;\n      esac\n    done\n    func_cc_basename_result=`$ECHO \"$cc_temp\" | $SED \"s%.*/%%; s%^$host_alias-%%\"`\n}\n])# _LT_PREPARE_CC_BASENAME\n\n\n# _LT_CC_BASENAME(CC)\n# -------------------\n# It would be clearer to call AC_REQUIREs from _LT_PREPARE_CC_BASENAME,\n# but that macro is also expanded into generated libtool script, which\n# arranges for $SED and $ECHO to be set by different means.\nm4_defun([_LT_CC_BASENAME],\n[m4_require([_LT_PREPARE_CC_BASENAME])dnl\nAC_REQUIRE([_LT_DECL_SED])dnl\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl\nfunc_cc_basename $1\ncc_basename=$func_cc_basename_result\n])\n\n\n# _LT_FILEUTILS_DEFAULTS\n# ----------------------\n# It is okay to use these file commands and assume they have been set\n# sensibly after 'm4_require([_LT_FILEUTILS_DEFAULTS])'.\nm4_defun([_LT_FILEUTILS_DEFAULTS],\n[: ${CP=\"cp -f\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n])# _LT_FILEUTILS_DEFAULTS\n\n\n# _LT_SETUP\n# ---------\nm4_defun([_LT_SETUP],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_REQUIRE([_LT_PREPARE_SED_QUOTE_VARS])dnl\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl\n\n_LT_DECL([], [PATH_SEPARATOR], [1], [The PATH separator for the build system])dnl\ndnl\n_LT_DECL([], [host_alias], [0], [The host system])dnl\n_LT_DECL([], [host], [0])dnl\n_LT_DECL([], [host_os], [0])dnl\ndnl\n_LT_DECL([], [build_alias], [0], [The build system])dnl\n_LT_DECL([], [build], [0])dnl\n_LT_DECL([], [build_os], [0])dnl\ndnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\ndnl\nAC_REQUIRE([AC_PROG_LN_S])dnl\ntest -z \"$LN_S\" && LN_S=\"ln -s\"\n_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl\ndnl\nAC_REQUIRE([LT_CMD_MAX_LEN])dnl\n_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally \"o\")])dnl\n_LT_DECL([], [exeext], [0], [Executable file suffix (normally \"\")])dnl\ndnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nm4_require([_LT_PATH_CONVERSION_FUNCTIONS])dnl\nm4_require([_LT_CMD_RELOAD])dnl\nm4_require([_LT_CHECK_MAGIC_METHOD])dnl\nm4_require([_LT_CHECK_SHAREDLIB_FROM_LINKLIB])dnl\nm4_require([_LT_CMD_OLD_ARCHIVE])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_WITH_SYSROOT])dnl\nm4_require([_LT_CMD_TRUNCATE])dnl\n\n_LT_CONFIG_LIBTOOL_INIT([\n# See if we are running on zsh, and set the options that allow our\n# commands through without removal of \\ escapes INIT.\nif test -n \"\\${ZSH_VERSION+set}\"; then\n   setopt NO_GLOB_SUBST\nfi\n])\nif test -n \"${ZSH_VERSION+set}\"; then\n   setopt NO_GLOB_SUBST\nfi\n\n_LT_CHECK_OBJDIR\n\nm4_require([_LT_TAG_COMPILER])dnl\n\ncase $host_os in\naix3*)\n  # AIX sometimes has problems with the GCC collect2 program.  For some\n  # reason, if we set the COLLECT_NAMES environment variable, the problems\n  # vanish in a puff of smoke.\n  if test set != \"${COLLECT_NAMES+set}\"; then\n    COLLECT_NAMES=\n    export COLLECT_NAMES\n  fi\n  ;;\nesac\n\n# Global variables:\nofile=libtool\ncan_build_shared=yes\n\n# All known linkers require a '.a' archive for static linking (except MSVC,\n# which needs '.lib').\nlibext=a\n\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n\nold_CC=$CC\nold_CFLAGS=$CFLAGS\n\n# Set sane defaults for various variables\ntest -z \"$CC\" && CC=cc\ntest -z \"$LTCC\" && LTCC=$CC\ntest -z \"$LTCFLAGS\" && LTCFLAGS=$CFLAGS\ntest -z \"$LD\" && LD=ld\ntest -z \"$ac_objext\" && ac_objext=o\n\n_LT_CC_BASENAME([$compiler])\n\n# Only perform the check for file, if the check method requires it\ntest -z \"$MAGIC_CMD\" && MAGIC_CMD=file\ncase $deplibs_check_method in\nfile_magic*)\n  if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n    _LT_PATH_MAGIC\n  fi\n  ;;\nesac\n\n# Use C for the default configuration in the libtool script\nLT_SUPPORTED_TAG([CC])\n_LT_LANG_C_CONFIG\n_LT_LANG_DEFAULT_CONFIG\n_LT_CONFIG_COMMANDS\n])# _LT_SETUP\n\n\n# _LT_PREPARE_SED_QUOTE_VARS\n# --------------------------\n# Define a few sed substitution that help us do robust quoting.\nm4_defun([_LT_PREPARE_SED_QUOTE_VARS],\n[# Backslashify metacharacters that are still active within\n# double-quoted strings.\nsed_quote_subst='s/\\([[\"`$\\\\]]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([[\"`\\\\]]\\)/\\\\\\1/g'\n\n# Sed substitution to delay expansion of an escaped shell variable in a\n# double_quote_subst'ed string.\ndelay_variable_subst='s/\\\\\\\\\\\\\\\\\\\\\\$/\\\\\\\\\\\\$/g'\n\n# Sed substitution to delay expansion of an escaped single quote.\ndelay_single_quote_subst='s/'\\''/'\\'\\\\\\\\\\\\\\'\\''/g'\n\n# Sed substitution to avoid accidental globbing in evaled expressions\nno_glob_subst='s/\\*/\\\\\\*/g'\n])\n\n# _LT_PROG_LTMAIN\n# ---------------\n# Note that this code is called both from 'configure', and 'config.status'\n# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,\n# 'config.status' has no value for ac_aux_dir unless we are using Automake,\n# so we pass a copy along to make sure it has a sensible value anyway.\nm4_defun([_LT_PROG_LTMAIN],\n[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl\n_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])\nltmain=$ac_aux_dir/ltmain.sh\n])# _LT_PROG_LTMAIN\n\n\n## ------------------------------------- ##\n## Accumulate code for creating libtool. ##\n## ------------------------------------- ##\n\n# So that we can recreate a full libtool script including additional\n# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS\n# in macros and then make a single call at the end using the 'libtool'\n# label.\n\n\n# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])\n# ----------------------------------------\n# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL_INIT],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_INIT])\n\n\n# _LT_CONFIG_LIBTOOL([COMMANDS])\n# ------------------------------\n# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])\n\n\n# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])\n# -----------------------------------------------------\nm4_defun([_LT_CONFIG_SAVE_COMMANDS],\n[_LT_CONFIG_LIBTOOL([$1])\n_LT_CONFIG_LIBTOOL_INIT([$2])\n])\n\n\n# _LT_FORMAT_COMMENT([COMMENT])\n# -----------------------------\n# Add leading comment marks to the start of each line, and a trailing\n# full-stop to the whole comment if one is not present already.\nm4_define([_LT_FORMAT_COMMENT],\n[m4_ifval([$1], [\nm4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],\n              [['`$\\]], [\\\\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])\n)])\n\n\n\n## ------------------------ ##\n## FIXME: Eliminate VARNAME ##\n## ------------------------ ##\n\n\n# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])\n# -------------------------------------------------------------------\n# CONFIGNAME is the name given to the value in the libtool script.\n# VARNAME is the (base) name used in the configure script.\n# VALUE may be 0, 1 or 2 for a computed quote escaped value based on\n# VARNAME.  Any other value will be used directly.\nm4_define([_LT_DECL],\n[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],\n    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],\n\t[m4_ifval([$1], [$1], [$2])])\n    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])\n    m4_ifval([$4],\n\t[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])\n    lt_dict_add_subkey([lt_decl_dict], [$2],\n\t[tagged?], [m4_ifval([$5], [yes], [no])])])\n])\n\n\n# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])\n# --------------------------------------------------------\nm4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])\n\n\n# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_tag_varnames],\n[_lt_decl_filter([tagged?], [yes], $@)])\n\n\n# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])\n# ---------------------------------------------------------\nm4_define([_lt_decl_filter],\n[m4_case([$#],\n  [0], [m4_fatal([$0: too few arguments: $#])],\n  [1], [m4_fatal([$0: too few arguments: $#: $1])],\n  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],\n  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],\n  [lt_dict_filter([lt_decl_dict], $@)])[]dnl\n])\n\n\n# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])\n# --------------------------------------------------\nm4_define([lt_decl_quote_varnames],\n[_lt_decl_filter([value], [1], $@)])\n\n\n# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_dquote_varnames],\n[_lt_decl_filter([value], [2], $@)])\n\n\n# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_varnames_tagged],\n[m4_assert([$# <= 2])dnl\n_$0(m4_quote(m4_default([$1], [[, ]])),\n    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),\n    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])\nm4_define([_lt_decl_varnames_tagged],\n[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])\n\n\n# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_all_varnames],\n[_$0(m4_quote(m4_default([$1], [[, ]])),\n     m4_if([$2], [],\n\t   m4_quote(lt_decl_varnames),\n\tm4_quote(m4_shift($@))))[]dnl\n])\nm4_define([_lt_decl_all_varnames],\n[lt_join($@, lt_decl_varnames_tagged([$1],\n\t\t\tlt_decl_tag_varnames([[, ]], m4_shift($@))))dnl\n])\n\n\n# _LT_CONFIG_STATUS_DECLARE([VARNAME])\n# ------------------------------------\n# Quote a variable value, and forward it to 'config.status' so that its\n# declaration there will have the same value as in 'configure'.  VARNAME\n# must have a single quote delimited value for this to work.\nm4_define([_LT_CONFIG_STATUS_DECLARE],\n[$1='`$ECHO \"$][$1\" | $SED \"$delay_single_quote_subst\"`'])\n\n\n# _LT_CONFIG_STATUS_DECLARATIONS\n# ------------------------------\n# We delimit libtool config variables with single quotes, so when\n# we write them to config.status, we have to be sure to quote all\n# embedded single quotes properly.  In configure, this macro expands\n# each variable declared with _LT_DECL (and _LT_TAGDECL) into:\n#\n#    <var>='`$ECHO \"$<var>\" | $SED \"$delay_single_quote_subst\"`'\nm4_defun([_LT_CONFIG_STATUS_DECLARATIONS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),\n    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAGS\n# ----------------\n# Output comment and list of tags supported by the script\nm4_defun([_LT_LIBTOOL_TAGS],\n[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl\navailable_tags='_LT_TAGS'dnl\n])\n\n\n# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])\n# -----------------------------------\n# Extract the dictionary values for VARNAME (optionally with TAG) and\n# expand to a commented shell variable setting:\n#\n#    # Some comment about what VAR is for.\n#    visible_name=$lt_internal_name\nm4_define([_LT_LIBTOOL_DECLARE],\n[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],\n\t\t\t\t\t   [description])))[]dnl\nm4_pushdef([_libtool_name],\n    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl\nm4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),\n    [0], [_libtool_name=[$]$1],\n    [1], [_libtool_name=$lt_[]$1],\n    [2], [_libtool_name=$lt_[]$1],\n    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl\nm4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl\n])\n\n\n# _LT_LIBTOOL_CONFIG_VARS\n# -----------------------\n# Produce commented declarations of non-tagged libtool config variables\n# suitable for insertion in the LIBTOOL CONFIG section of the 'libtool'\n# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG\n# section) are produced by _LT_LIBTOOL_TAG_VARS.\nm4_defun([_LT_LIBTOOL_CONFIG_VARS],\n[m4_foreach([_lt_var],\n    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAG_VARS(TAG)\n# -------------------------\nm4_define([_LT_LIBTOOL_TAG_VARS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])\n\n\n# _LT_TAGVAR(VARNAME, [TAGNAME])\n# ------------------------------\nm4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])\n\n\n# _LT_CONFIG_COMMANDS\n# -------------------\n# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of\n# variables for single and double quote escaping we saved from calls\n# to _LT_DECL, we can put quote escaped variables declarations\n# into 'config.status', and then the shell code to quote escape them in\n# for loops in 'config.status'.  Finally, any additional code accumulated\n# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.\nm4_defun([_LT_CONFIG_COMMANDS],\n[AC_PROVIDE_IFELSE([LT_OUTPUT],\n\tdnl If the libtool generation code has been placed in $CONFIG_LT,\n\tdnl instead of duplicating it all over again into config.status,\n\tdnl then we will have config.status run $CONFIG_LT later, so it\n\tdnl needs to know what name is stored there:\n        [AC_CONFIG_COMMANDS([libtool],\n            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],\n    dnl If the libtool generation code is destined for config.status,\n    dnl expand the accumulated commands and init code now:\n    [AC_CONFIG_COMMANDS([libtool],\n        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])\n])#_LT_CONFIG_COMMANDS\n\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],\n[\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nsed_quote_subst='$sed_quote_subst'\ndouble_quote_subst='$double_quote_subst'\ndelay_variable_subst='$delay_variable_subst'\n_LT_CONFIG_STATUS_DECLARATIONS\nLTCC='$LTCC'\nLTCFLAGS='$LTCFLAGS'\ncompiler='$compiler_DEFAULT'\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$[]1\n_LTECHO_EOF'\n}\n\n# Quote evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_quote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED \\\\\"\\\\\\$sed_quote_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\" ## exclude from sc_prohibit_nested_quotes\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n# Double-quote double-evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_dquote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED -e \\\\\"\\\\\\$double_quote_subst\\\\\" -e \\\\\"\\\\\\$sed_quote_subst\\\\\" -e \\\\\"\\\\\\$delay_variable_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\" ## exclude from sc_prohibit_nested_quotes\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n_LT_OUTPUT_LIBTOOL_INIT\n])\n\n# _LT_GENERATED_FILE_INIT(FILE, [COMMENT])\n# ------------------------------------\n# Generate a child script FILE with all initialization necessary to\n# reuse the environment learned by the parent script, and make the\n# file executable.  If COMMENT is supplied, it is inserted after the\n# '#!' sequence but before initialization text begins.  After this\n# macro, additional text can be appended to FILE to form the body of\n# the child script.  The macro ends with non-zero status if the\n# file could not be fully written (such as if the disk is full).\nm4_ifdef([AS_INIT_GENERATED],\n[m4_defun([_LT_GENERATED_FILE_INIT],[AS_INIT_GENERATED($@)])],\n[m4_defun([_LT_GENERATED_FILE_INIT],\n[m4_require([AS_PREPARE])]dnl\n[m4_pushdef([AS_MESSAGE_LOG_FD])]dnl\n[lt_write_fail=0\ncat >$1 <<_ASEOF || lt_write_fail=1\n#! $SHELL\n# Generated by $as_me.\n$2\nSHELL=\\${CONFIG_SHELL-$SHELL}\nexport SHELL\n_ASEOF\ncat >>$1 <<\\_ASEOF || lt_write_fail=1\nAS_SHELL_SANITIZE\n_AS_PREPARE\nexec AS_MESSAGE_FD>&1\n_ASEOF\ntest 0 = \"$lt_write_fail\" && chmod +x $1[]dnl\nm4_popdef([AS_MESSAGE_LOG_FD])])])# _LT_GENERATED_FILE_INIT\n\n# LT_OUTPUT\n# ---------\n# This macro allows early generation of the libtool script (before\n# AC_OUTPUT is called), incase it is used in configure for compilation\n# tests.\nAC_DEFUN([LT_OUTPUT],\n[: ${CONFIG_LT=./config.lt}\nAC_MSG_NOTICE([creating $CONFIG_LT])\n_LT_GENERATED_FILE_INIT([\"$CONFIG_LT\"],\n[# Run this file to recreate a libtool stub with the current configuration.])\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nlt_cl_silent=false\nexec AS_MESSAGE_LOG_FD>>config.log\n{\n  echo\n  AS_BOX([Running $as_me.])\n} >&AS_MESSAGE_LOG_FD\n\nlt_cl_help=\"\\\n'$as_me' creates a local libtool stub from the current configuration,\nfor use in further configure time tests before the real libtool is\ngenerated.\n\nUsage: $[0] [[OPTIONS]]\n\n  -h, --help      print this help, then exit\n  -V, --version   print version number, then exit\n  -q, --quiet     do not print progress messages\n  -d, --debug     don't remove temporary files\n\nReport bugs to <bug-libtool@gnu.org>.\"\n\nlt_cl_version=\"\\\nm4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl\nm4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])\nconfigured by $[0], generated by m4_PACKAGE_STRING.\n\nCopyright (C) 2011 Free Software Foundation, Inc.\nThis config.lt script is free software; the Free Software Foundation\ngives unlimited permision to copy, distribute and modify it.\"\n\nwhile test 0 != $[#]\ndo\n  case $[1] in\n    --version | --v* | -V )\n      echo \"$lt_cl_version\"; exit 0 ;;\n    --help | --h* | -h )\n      echo \"$lt_cl_help\"; exit 0 ;;\n    --debug | --d* | -d )\n      debug=: ;;\n    --quiet | --q* | --silent | --s* | -q )\n      lt_cl_silent=: ;;\n\n    -*) AC_MSG_ERROR([unrecognized option: $[1]\nTry '$[0] --help' for more information.]) ;;\n\n    *) AC_MSG_ERROR([unrecognized argument: $[1]\nTry '$[0] --help' for more information.]) ;;\n  esac\n  shift\ndone\n\nif $lt_cl_silent; then\n  exec AS_MESSAGE_FD>/dev/null\nfi\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<_LTEOF\n_LT_OUTPUT_LIBTOOL_COMMANDS_INIT\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nAC_MSG_NOTICE([creating $ofile])\n_LT_OUTPUT_LIBTOOL_COMMANDS\nAS_EXIT(0)\n_LTEOF\nchmod +x \"$CONFIG_LT\"\n\n# configure is writing to config.log, but config.lt does its own redirection,\n# appending to config.log, which fails on DOS, as config.log is still kept\n# open by configure.  Here we exec the FD to /dev/null, effectively closing\n# config.log, so it can be properly (re)opened and appended to by config.lt.\nlt_cl_success=:\ntest yes = \"$silent\" &&\n  lt_config_lt_args=\"$lt_config_lt_args --quiet\"\nexec AS_MESSAGE_LOG_FD>/dev/null\n$SHELL \"$CONFIG_LT\" $lt_config_lt_args || lt_cl_success=false\nexec AS_MESSAGE_LOG_FD>>config.log\n$lt_cl_success || AS_EXIT(1)\n])# LT_OUTPUT\n\n\n# _LT_CONFIG(TAG)\n# ---------------\n# If TAG is the built-in tag, create an initial libtool script with a\n# default configuration from the untagged config vars.  Otherwise add code\n# to config.status for appending the configuration named by TAG from the\n# matching tagged config vars.\nm4_defun([_LT_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_CONFIG_SAVE_COMMANDS([\n  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl\n  m4_if(_LT_TAG, [C], [\n    # See if we are running on zsh, and set the options that allow our\n    # commands through without removal of \\ escapes.\n    if test -n \"${ZSH_VERSION+set}\"; then\n      setopt NO_GLOB_SUBST\n    fi\n\n    cfgfile=${ofile}T\n    trap \"$RM \\\"$cfgfile\\\"; exit 1\" 1 2 15\n    $RM \"$cfgfile\"\n\n    cat <<_LT_EOF >> \"$cfgfile\"\n#! $SHELL\n# Generated automatically by $as_me ($PACKAGE) $VERSION\n# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:\n# NOTE: Changes made to this file will be lost: look at ltmain.sh.\n\n# Provide generalized library-building support services.\n# Written by Gordon Matzigkeit, 1996\n\n_LT_COPYING\n_LT_LIBTOOL_TAGS\n\n# Configured defaults for sys_lib_dlsearch_path munging.\n: \\${LT_SYS_LIBRARY_PATH=\"$configure_time_lt_sys_library_path\"}\n\n# ### BEGIN LIBTOOL CONFIG\n_LT_LIBTOOL_CONFIG_VARS\n_LT_LIBTOOL_TAG_VARS\n# ### END LIBTOOL CONFIG\n\n_LT_EOF\n\n    cat <<'_LT_EOF' >> \"$cfgfile\"\n\n# ### BEGIN FUNCTIONS SHARED WITH CONFIGURE\n\n_LT_PREPARE_MUNGE_PATH_LIST\n_LT_PREPARE_CC_BASENAME\n\n# ### END FUNCTIONS SHARED WITH CONFIGURE\n\n_LT_EOF\n\n  case $host_os in\n  aix3*)\n    cat <<\\_LT_EOF >> \"$cfgfile\"\n# AIX sometimes has problems with the GCC collect2 program.  For some\n# reason, if we set the COLLECT_NAMES environment variable, the problems\n# vanish in a puff of smoke.\nif test set != \"${COLLECT_NAMES+set}\"; then\n  COLLECT_NAMES=\n  export COLLECT_NAMES\nfi\n_LT_EOF\n    ;;\n  esac\n\n  _LT_PROG_LTMAIN\n\n  # We use sed instead of cat because bash on DJGPP gets confused if\n  # if finds mixed CR/LF and LF-only lines.  Since sed operates in\n  # text mode, it properly converts lines to CR/LF.  This bash problem\n  # is reportedly fixed, but why not run on old versions too?\n  sed '$q' \"$ltmain\" >> \"$cfgfile\" \\\n     || (rm -f \"$cfgfile\"; exit 1)\n\n   mv -f \"$cfgfile\" \"$ofile\" ||\n    (rm -f \"$ofile\" && cp \"$cfgfile\" \"$ofile\" && rm -f \"$cfgfile\")\n  chmod +x \"$ofile\"\n],\n[cat <<_LT_EOF >> \"$ofile\"\n\ndnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded\ndnl in a comment (ie after a #).\n# ### BEGIN LIBTOOL TAG CONFIG: $1\n_LT_LIBTOOL_TAG_VARS(_LT_TAG)\n# ### END LIBTOOL TAG CONFIG: $1\n_LT_EOF\n])dnl /m4_if\n],\n[m4_if([$1], [], [\n    PACKAGE='$PACKAGE'\n    VERSION='$VERSION'\n    RM='$RM'\n    ofile='$ofile'], [])\n])dnl /_LT_CONFIG_SAVE_COMMANDS\n])# _LT_CONFIG\n\n\n# LT_SUPPORTED_TAG(TAG)\n# ---------------------\n# Trace this macro to discover what tags are supported by the libtool\n# --tag option, using:\n#    autoconf --trace 'LT_SUPPORTED_TAG:$1'\nAC_DEFUN([LT_SUPPORTED_TAG], [])\n\n\n# C support is built-in for now\nm4_define([_LT_LANG_C_enabled], [])\nm4_define([_LT_TAGS], [])\n\n\n# LT_LANG(LANG)\n# -------------\n# Enable libtool support for the given language if not already enabled.\nAC_DEFUN([LT_LANG],\n[AC_BEFORE([$0], [LT_OUTPUT])dnl\nm4_case([$1],\n  [C],\t\t\t[_LT_LANG(C)],\n  [C++],\t\t[_LT_LANG(CXX)],\n  [Go],\t\t\t[_LT_LANG(GO)],\n  [Java],\t\t[_LT_LANG(GCJ)],\n  [Fortran 77],\t\t[_LT_LANG(F77)],\n  [Fortran],\t\t[_LT_LANG(FC)],\n  [Windows Resource],\t[_LT_LANG(RC)],\n  [m4_ifdef([_LT_LANG_]$1[_CONFIG],\n    [_LT_LANG($1)],\n    [m4_fatal([$0: unsupported language: \"$1\"])])])dnl\n])# LT_LANG\n\n\n# _LT_LANG(LANGNAME)\n# ------------------\nm4_defun([_LT_LANG],\n[m4_ifdef([_LT_LANG_]$1[_enabled], [],\n  [LT_SUPPORTED_TAG([$1])dnl\n  m4_append([_LT_TAGS], [$1 ])dnl\n  m4_define([_LT_LANG_]$1[_enabled], [])dnl\n  _LT_LANG_$1_CONFIG($1)])dnl\n])# _LT_LANG\n\n\nm4_ifndef([AC_PROG_GO], [\n############################################################\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_GO.  When it is available in    #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n############################################################\nm4_defun([AC_PROG_GO],\n[AC_LANG_PUSH(Go)dnl\nAC_ARG_VAR([GOC],     [Go compiler command])dnl\nAC_ARG_VAR([GOFLAGS], [Go compiler flags])dnl\n_AC_ARG_VAR_LDFLAGS()dnl\nAC_CHECK_TOOL(GOC, gccgo)\nif test -z \"$GOC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    AC_CHECK_PROG(GOC, [${ac_tool_prefix}gccgo], [${ac_tool_prefix}gccgo])\n  fi\nfi\nif test -z \"$GOC\"; then\n  AC_CHECK_PROG(GOC, gccgo, gccgo, false)\nfi\n])#m4_defun\n])#m4_ifndef\n\n\n# _LT_LANG_DEFAULT_CONFIG\n# -----------------------\nm4_defun([_LT_LANG_DEFAULT_CONFIG],\n[AC_PROVIDE_IFELSE([AC_PROG_CXX],\n  [LT_LANG(CXX)],\n  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_F77],\n  [LT_LANG(F77)],\n  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_FC],\n  [LT_LANG(FC)],\n  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])\n\ndnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal\ndnl pulling things in needlessly.\nAC_PROVIDE_IFELSE([AC_PROG_GCJ],\n  [LT_LANG(GCJ)],\n  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],\n    [LT_LANG(GCJ)],\n    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],\n      [LT_LANG(GCJ)],\n      [m4_ifdef([AC_PROG_GCJ],\n\t[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([A][M_PROG_GCJ],\n\t[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([LT_PROG_GCJ],\n\t[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])\n\nAC_PROVIDE_IFELSE([AC_PROG_GO],\n  [LT_LANG(GO)],\n  [m4_define([AC_PROG_GO], defn([AC_PROG_GO])[LT_LANG(GO)])])\n\nAC_PROVIDE_IFELSE([LT_PROG_RC],\n  [LT_LANG(RC)],\n  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])\n])# _LT_LANG_DEFAULT_CONFIG\n\n# Obsolete macros:\nAU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])\nAU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])\nAU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])\nAU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])\nAU_DEFUN([AC_LIBTOOL_RC], [LT_LANG(Windows Resource)])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_CXX], [])\ndnl AC_DEFUN([AC_LIBTOOL_F77], [])\ndnl AC_DEFUN([AC_LIBTOOL_FC], [])\ndnl AC_DEFUN([AC_LIBTOOL_GCJ], [])\ndnl AC_DEFUN([AC_LIBTOOL_RC], [])\n\n\n# _LT_TAG_COMPILER\n# ----------------\nm4_defun([_LT_TAG_COMPILER],\n[AC_REQUIRE([AC_PROG_CC])dnl\n\n_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl\n_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl\n_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl\n_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl\n\n# If no C compiler was specified, use CC.\nLTCC=${LTCC-\"$CC\"}\n\n# If no C compiler flags were specified, use CFLAGS.\nLTCFLAGS=${LTCFLAGS-\"$CFLAGS\"}\n\n# Allow CC to be a program name with arguments.\ncompiler=$CC\n])# _LT_TAG_COMPILER\n\n\n# _LT_COMPILER_BOILERPLATE\n# ------------------------\n# Check for compiler boilerplate output or warnings with\n# the simple compiler test code.\nm4_defun([_LT_COMPILER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_compile_test_code\" >conftest.$ac_ext\neval \"$ac_compile\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_compiler_boilerplate=`cat conftest.err`\n$RM conftest*\n])# _LT_COMPILER_BOILERPLATE\n\n\n# _LT_LINKER_BOILERPLATE\n# ----------------------\n# Check for linker boilerplate output or warnings with\n# the simple link test code.\nm4_defun([_LT_LINKER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_link_test_code\" >conftest.$ac_ext\neval \"$ac_link\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_linker_boilerplate=`cat conftest.err`\n$RM -r conftest*\n])# _LT_LINKER_BOILERPLATE\n\n# _LT_REQUIRED_DARWIN_CHECKS\n# -------------------------\nm4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[\n  case $host_os in\n    rhapsody* | darwin*)\n    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])\n    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])\n    AC_CHECK_TOOL([LIPO], [lipo], [:])\n    AC_CHECK_TOOL([OTOOL], [otool], [:])\n    AC_CHECK_TOOL([OTOOL64], [otool64], [:])\n    _LT_DECL([], [DSYMUTIL], [1],\n      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])\n    _LT_DECL([], [NMEDIT], [1],\n      [Tool to change global to local symbols on Mac OS X])\n    _LT_DECL([], [LIPO], [1],\n      [Tool to manipulate fat objects and archives on Mac OS X])\n    _LT_DECL([], [OTOOL], [1],\n      [ldd/readelf like tool for Mach-O binaries on Mac OS X])\n    _LT_DECL([], [OTOOL64], [1],\n      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])\n\n    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],\n      [lt_cv_apple_cc_single_mod=no\n      if test -z \"$LT_MULTI_MODULE\"; then\n\t# By default we will add the -single_module flag. You can override\n\t# by either setting the environment variable LT_MULTI_MODULE\n\t# non-empty at configure time, or by adding -multi_module to the\n\t# link flags.\n\trm -rf libconftest.dylib*\n\techo \"int foo(void){return 1;}\" > conftest.c\n\techo \"$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n-dynamiclib -Wl,-single_module conftest.c\" >&AS_MESSAGE_LOG_FD\n\t$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n\t  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err\n        _lt_result=$?\n\t# If there is a non-empty error log, and \"single_module\"\n\t# appears in it, assume the flag caused a linker warning\n        if test -s conftest.err && $GREP single_module conftest.err; then\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\t# Otherwise, if the output was created with a 0 exit code from\n\t# the compiler, it worked.\n\telif test -f libconftest.dylib && test 0 = \"$_lt_result\"; then\n\t  lt_cv_apple_cc_single_mod=yes\n\telse\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\tfi\n\trm -rf libconftest.dylib*\n\trm -f conftest.*\n      fi])\n\n    AC_CACHE_CHECK([for -exported_symbols_list linker flag],\n      [lt_cv_ld_exported_symbols_list],\n      [lt_cv_ld_exported_symbols_list=no\n      save_LDFLAGS=$LDFLAGS\n      echo \"_main\" > conftest.sym\n      LDFLAGS=\"$LDFLAGS -Wl,-exported_symbols_list,conftest.sym\"\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n\t[lt_cv_ld_exported_symbols_list=yes],\n\t[lt_cv_ld_exported_symbols_list=no])\n\tLDFLAGS=$save_LDFLAGS\n    ])\n\n    AC_CACHE_CHECK([for -force_load linker flag],[lt_cv_ld_force_load],\n      [lt_cv_ld_force_load=no\n      cat > conftest.c << _LT_EOF\nint forced_loaded() { return 2;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS -c -o conftest.o conftest.c\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&AS_MESSAGE_LOG_FD\n      echo \"$AR cru libconftest.a conftest.o\" >&AS_MESSAGE_LOG_FD\n      $AR cru libconftest.a conftest.o 2>&AS_MESSAGE_LOG_FD\n      echo \"$RANLIB libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $RANLIB libconftest.a 2>&AS_MESSAGE_LOG_FD\n      cat > conftest.c << _LT_EOF\nint main() { return 0;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err\n      _lt_result=$?\n      if test -s conftest.err && $GREP force_load conftest.err; then\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      elif test -f conftest && test 0 = \"$_lt_result\" && $GREP forced_load conftest >/dev/null 2>&1; then\n\tlt_cv_ld_force_load=yes\n      else\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      fi\n        rm -f conftest.err libconftest.a conftest conftest.c\n        rm -rf conftest.dSYM\n    ])\n    case $host_os in\n    rhapsody* | darwin1.[[012]])\n      _lt_dar_allow_undefined='$wl-undefined ${wl}suppress' ;;\n    darwin1.*)\n      _lt_dar_allow_undefined='$wl-flat_namespace $wl-undefined ${wl}suppress' ;;\n    darwin*) # darwin 5.x on\n      # if running on 10.5 or later, the deployment target defaults\n      # to the OS version, if on x86, and 10.4, the deployment\n      # target defaults to 10.4. Don't you love it?\n      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in\n\t10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)\n\t  _lt_dar_allow_undefined='$wl-undefined ${wl}dynamic_lookup' ;;\n\t10.[[012]][[,.]]*)\n\t  _lt_dar_allow_undefined='$wl-flat_namespace $wl-undefined ${wl}suppress' ;;\n\t10.*)\n\t  _lt_dar_allow_undefined='$wl-undefined ${wl}dynamic_lookup' ;;\n      esac\n    ;;\n  esac\n    if test yes = \"$lt_cv_apple_cc_single_mod\"; then\n      _lt_dar_single_mod='$single_module'\n    fi\n    if test yes = \"$lt_cv_ld_exported_symbols_list\"; then\n      _lt_dar_export_syms=' $wl-exported_symbols_list,$output_objdir/$libname-symbols.expsym'\n    else\n      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/$libname-symbols.expsym $lib'\n    fi\n    if test : != \"$DSYMUTIL\" && test no = \"$lt_cv_ld_force_load\"; then\n      _lt_dsymutil='~$DSYMUTIL $lib || :'\n    else\n      _lt_dsymutil=\n    fi\n    ;;\n  esac\n])\n\n\n# _LT_DARWIN_LINKER_FEATURES([TAG])\n# ---------------------------------\n# Checks for linker and compiler features on darwin\nm4_defun([_LT_DARWIN_LINKER_FEATURES],\n[\n  m4_require([_LT_REQUIRED_DARWIN_CHECKS])\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_automatic, $1)=yes\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  if test yes = \"$lt_cv_ld_force_load\"; then\n    _LT_TAGVAR(whole_archive_flag_spec, $1)='`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience $wl-force_load,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"`'\n    m4_case([$1], [F77], [_LT_TAGVAR(compiler_needs_object, $1)=yes],\n                  [FC],  [_LT_TAGVAR(compiler_needs_object, $1)=yes])\n  else\n    _LT_TAGVAR(whole_archive_flag_spec, $1)=''\n  fi\n  _LT_TAGVAR(link_all_deplibs, $1)=yes\n  _LT_TAGVAR(allow_undefined_flag, $1)=$_lt_dar_allow_undefined\n  case $cc_basename in\n     ifort*|nagfor*) _lt_dar_can_shared=yes ;;\n     *) _lt_dar_can_shared=$GCC ;;\n  esac\n  if test yes = \"$_lt_dar_can_shared\"; then\n    output_verbose_link_cmd=func_echo_all\n    _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring $_lt_dar_single_mod$_lt_dsymutil\"\n    _LT_TAGVAR(module_cmds, $1)=\"\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags$_lt_dsymutil\"\n    _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's|^|_|' < \\$export_symbols > \\$output_objdir/\\$libname-symbols.expsym~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring $_lt_dar_single_mod$_lt_dar_export_syms$_lt_dsymutil\"\n    _LT_TAGVAR(module_expsym_cmds, $1)=\"sed -e 's|^|_|' < \\$export_symbols > \\$output_objdir/\\$libname-symbols.expsym~\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags$_lt_dar_export_syms$_lt_dsymutil\"\n    m4_if([$1], [CXX],\n[   if test yes != \"$lt_cv_apple_cc_single_mod\"; then\n      _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -r -keep_private_externs -nostdlib -o \\$lib-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$lib-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring$_lt_dsymutil\"\n      _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's|^|_|' < \\$export_symbols > \\$output_objdir/\\$libname-symbols.expsym~\\$CC -r -keep_private_externs -nostdlib -o \\$lib-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$lib-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring$_lt_dar_export_syms$_lt_dsymutil\"\n    fi\n],[])\n  else\n  _LT_TAGVAR(ld_shlibs, $1)=no\n  fi\n])\n\n# _LT_SYS_MODULE_PATH_AIX([TAGNAME])\n# ----------------------------------\n# Links a minimal program and checks the executable\n# for the system default hardcoded library path. In most cases,\n# this is /usr/lib:/lib, but when the MPI compilers are used\n# the location of the communication and MPI libs are included too.\n# If we don't find anything, use the default library path according\n# to the aix ld manual.\n# Store the results from the different compilers for each TAGNAME.\n# Allow to override them for all tags through lt_cv_aix_libpath.\nm4_defun([_LT_SYS_MODULE_PATH_AIX],\n[m4_require([_LT_DECL_SED])dnl\nif test set = \"${lt_cv_aix_libpath+set}\"; then\n  aix_libpath=$lt_cv_aix_libpath\nelse\n  AC_CACHE_VAL([_LT_TAGVAR([lt_cv_aix_libpath_], [$1])],\n  [AC_LINK_IFELSE([AC_LANG_PROGRAM],[\n  lt_aix_libpath_sed='[\n      /Import File Strings/,/^$/ {\n\t  /^0/ {\n\t      s/^0  *\\([^ ]*\\) *$/\\1/\n\t      p\n\t  }\n      }]'\n  _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n  # Check for a 64-bit object if we didn't find anything.\n  if test -z \"$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\"; then\n    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n  fi],[])\n  if test -z \"$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\"; then\n    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=/usr/lib:/lib\n  fi\n  ])\n  aix_libpath=$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\nfi\n])# _LT_SYS_MODULE_PATH_AIX\n\n\n# _LT_SHELL_INIT(ARG)\n# -------------------\nm4_define([_LT_SHELL_INIT],\n[m4_divert_text([M4SH-INIT], [$1\n])])# _LT_SHELL_INIT\n\n\n\n# _LT_PROG_ECHO_BACKSLASH\n# -----------------------\n# Find how we can fake an echo command that does not interpret backslash.\n# In particular, with Autoconf 2.60 or later we add some code to the start\n# of the generated configure script that will find a shell with a builtin\n# printf (that we can use as an echo command).\nm4_defun([_LT_PROG_ECHO_BACKSLASH],\n[ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n\nAC_MSG_CHECKING([how to print strings])\n# Test print first, because it will be a builtin if present.\nif test \"X`( print -r -- -n ) 2>/dev/null`\" = X-n && \\\n   test \"X`print -r -- $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='print -r --'\nelif test \"X`printf %s $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='printf %s\\n'\nelse\n  # Use this function as a fallback that always works.\n  func_fallback_echo ()\n  {\n    eval 'cat <<_LTECHO_EOF\n$[]1\n_LTECHO_EOF'\n  }\n  ECHO='func_fallback_echo'\nfi\n\n# func_echo_all arg...\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\"\n}\n\ncase $ECHO in\n  printf*) AC_MSG_RESULT([printf]) ;;\n  print*) AC_MSG_RESULT([print -r]) ;;\n  *) AC_MSG_RESULT([cat]) ;;\nesac\n\nm4_ifdef([_AS_DETECT_SUGGESTED],\n[_AS_DETECT_SUGGESTED([\n  test -n \"${ZSH_VERSION+set}${BASH_VERSION+set}\" || (\n    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n    PATH=/empty FPATH=/empty; export PATH FPATH\n    test \"X`printf %s $ECHO`\" = \"X$ECHO\" \\\n      || test \"X`print -r -- $ECHO`\" = \"X$ECHO\" )])])\n\n_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])\n_LT_DECL([], [ECHO], [1], [An echo program that protects backslashes])\n])# _LT_PROG_ECHO_BACKSLASH\n\n\n# _LT_WITH_SYSROOT\n# ----------------\nAC_DEFUN([_LT_WITH_SYSROOT],\n[AC_MSG_CHECKING([for sysroot])\nAC_ARG_WITH([sysroot],\n[AS_HELP_STRING([--with-sysroot@<:@=DIR@:>@],\n  [Search for dependent libraries within DIR (or the compiler's sysroot\n   if not specified).])],\n[], [with_sysroot=no])\n\ndnl lt_sysroot will always be passed unquoted.  We quote it here\ndnl in case the user passed a directory name.\nlt_sysroot=\ncase $with_sysroot in #(\n yes)\n   if test yes = \"$GCC\"; then\n     lt_sysroot=`$CC --print-sysroot 2>/dev/null`\n   fi\n   ;; #(\n /*)\n   lt_sysroot=`echo \"$with_sysroot\" | sed -e \"$sed_quote_subst\"`\n   ;; #(\n no|'')\n   ;; #(\n *)\n   AC_MSG_RESULT([$with_sysroot])\n   AC_MSG_ERROR([The sysroot must be an absolute path.])\n   ;;\nesac\n\n AC_MSG_RESULT([${lt_sysroot:-no}])\n_LT_DECL([], [lt_sysroot], [0], [The root where to search for ]dnl\n[dependent libraries, and where our libraries should be installed.])])\n\n# _LT_ENABLE_LOCK\n# ---------------\nm4_defun([_LT_ENABLE_LOCK],\n[AC_ARG_ENABLE([libtool-lock],\n  [AS_HELP_STRING([--disable-libtool-lock],\n    [avoid locking (might break parallel builds)])])\ntest no = \"$enable_libtool_lock\" || enable_libtool_lock=yes\n\n# Some flags need to be propagated to the compiler or linker for good\n# libtool support.\ncase $host in\nia64-*-hpux*)\n  # Find out what ABI is being produced by ac_compile, and set mode\n  # options accordingly.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.$ac_objext` in\n      *ELF-32*)\n\tHPUX_IA64_MODE=32\n\t;;\n      *ELF-64*)\n\tHPUX_IA64_MODE=64\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n*-*-irix6*)\n  # Find out what ABI is being produced by ac_compile, and set linker\n  # options accordingly.\n  echo '[#]line '$LINENO' \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    if test yes = \"$lt_cv_prog_gnu_ld\"; then\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -melf32bsmip\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -melf32bmipn32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -melf64bmip\"\n\t;;\n      esac\n    else\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -32\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -n32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -64\"\n\t  ;;\n      esac\n    fi\n  fi\n  rm -rf conftest*\n  ;;\n\nmips64*-*linux*)\n  # Find out what ABI is being produced by ac_compile, and set linker\n  # options accordingly.\n  echo '[#]line '$LINENO' \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    emul=elf\n    case `/usr/bin/file conftest.$ac_objext` in\n      *32-bit*)\n\temul=\"${emul}32\"\n\t;;\n      *64-bit*)\n\temul=\"${emul}64\"\n\t;;\n    esac\n    case `/usr/bin/file conftest.$ac_objext` in\n      *MSB*)\n\temul=\"${emul}btsmip\"\n\t;;\n      *LSB*)\n\temul=\"${emul}ltsmip\"\n\t;;\n    esac\n    case `/usr/bin/file conftest.$ac_objext` in\n      *N32*)\n\temul=\"${emul}n32\"\n\t;;\n    esac\n    LD=\"${LD-ld} -m $emul\"\n  fi\n  rm -rf conftest*\n  ;;\n\nx86_64-*kfreebsd*-gnu|x86_64-*linux*|powerpc*-*linux*| \\\ns390*-*linux*|s390*-*tpf*|sparc*-*linux*)\n  # Find out what ABI is being produced by ac_compile, and set linker\n  # options accordingly.  Note that the listed cases only cover the\n  # situations where additional linker options are needed (such as when\n  # doing 32-bit compilation for a host where ld defaults to 64-bit, or\n  # vice versa); the common cases where no linker options are needed do\n  # not appear in the list.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n      *32-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_i386_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    case `/usr/bin/file conftest.o` in\n\t      *x86-64*)\n\t\tLD=\"${LD-ld} -m elf32_x86_64\"\n\t\t;;\n\t      *)\n\t\tLD=\"${LD-ld} -m elf_i386\"\n\t\t;;\n\t    esac\n\t    ;;\n\t  powerpc64le-*linux*)\n\t    LD=\"${LD-ld} -m elf32lppclinux\"\n\t    ;;\n\t  powerpc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32ppclinux\"\n\t    ;;\n\t  s390x-*linux*)\n\t    LD=\"${LD-ld} -m elf_s390\"\n\t    ;;\n\t  sparc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32_sparc\"\n\t    ;;\n\tesac\n\t;;\n      *64-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_x86_64_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_x86_64\"\n\t    ;;\n\t  powerpcle-*linux*)\n\t    LD=\"${LD-ld} -m elf64lppc\"\n\t    ;;\n\t  powerpc-*linux*)\n\t    LD=\"${LD-ld} -m elf64ppc\"\n\t    ;;\n\t  s390*-*linux*|s390*-*tpf*)\n\t    LD=\"${LD-ld} -m elf64_s390\"\n\t    ;;\n\t  sparc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64_sparc\"\n\t    ;;\n\tesac\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n\n*-*-sco3.2v5*)\n  # On SCO OpenServer 5, we need -belf to get full-featured binaries.\n  SAVE_CFLAGS=$CFLAGS\n  CFLAGS=\"$CFLAGS -belf\"\n  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,\n    [AC_LANG_PUSH(C)\n     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])\n     AC_LANG_POP])\n  if test yes != \"$lt_cv_cc_needs_belf\"; then\n    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf\n    CFLAGS=$SAVE_CFLAGS\n  fi\n  ;;\n*-*solaris*)\n  # Find out what ABI is being produced by ac_compile, and set linker\n  # options accordingly.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n    *64-bit*)\n      case $lt_cv_prog_gnu_ld in\n      yes*)\n        case $host in\n        i?86-*-solaris*|x86_64-*-solaris*)\n          LD=\"${LD-ld} -m elf_x86_64\"\n          ;;\n        sparc*-*-solaris*)\n          LD=\"${LD-ld} -m elf64_sparc\"\n          ;;\n        esac\n        # GNU ld 2.21 introduced _sol2 emulations.  Use them if available.\n        if ${LD-ld} -V | grep _sol2 >/dev/null 2>&1; then\n          LD=${LD-ld}_sol2\n        fi\n        ;;\n      *)\n\tif ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then\n\t  LD=\"${LD-ld} -64\"\n\tfi\n\t;;\n      esac\n      ;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\nesac\n\nneed_locks=$enable_libtool_lock\n])# _LT_ENABLE_LOCK\n\n\n# _LT_PROG_AR\n# -----------\nm4_defun([_LT_PROG_AR],\n[AC_CHECK_TOOLS(AR, [ar], false)\n: ${AR=ar}\n: ${AR_FLAGS=cru}\n_LT_DECL([], [AR], [1], [The archiver])\n_LT_DECL([], [AR_FLAGS], [1], [Flags to create an archive])\n\nAC_CACHE_CHECK([for archiver @FILE support], [lt_cv_ar_at_file],\n  [lt_cv_ar_at_file=no\n   AC_COMPILE_IFELSE([AC_LANG_PROGRAM],\n     [echo conftest.$ac_objext > conftest.lst\n      lt_ar_try='$AR $AR_FLAGS libconftest.a @conftest.lst >&AS_MESSAGE_LOG_FD'\n      AC_TRY_EVAL([lt_ar_try])\n      if test 0 -eq \"$ac_status\"; then\n\t# Ensure the archiver fails upon bogus file names.\n\trm -f conftest.$ac_objext libconftest.a\n\tAC_TRY_EVAL([lt_ar_try])\n\tif test 0 -ne \"$ac_status\"; then\n          lt_cv_ar_at_file=@\n        fi\n      fi\n      rm -f conftest.* libconftest.a\n     ])\n  ])\n\nif test no = \"$lt_cv_ar_at_file\"; then\n  archiver_list_spec=\nelse\n  archiver_list_spec=$lt_cv_ar_at_file\nfi\n_LT_DECL([], [archiver_list_spec], [1],\n  [How to feed a file listing to the archiver])\n])# _LT_PROG_AR\n\n\n# _LT_CMD_OLD_ARCHIVE\n# -------------------\nm4_defun([_LT_CMD_OLD_ARCHIVE],\n[_LT_PROG_AR\n\nAC_CHECK_TOOL(STRIP, strip, :)\ntest -z \"$STRIP\" && STRIP=:\n_LT_DECL([], [STRIP], [1], [A symbol stripping program])\n\nAC_CHECK_TOOL(RANLIB, ranlib, :)\ntest -z \"$RANLIB\" && RANLIB=:\n_LT_DECL([], [RANLIB], [1],\n    [Commands used to install an old-style archive])\n\n# Determine commands to create old-style static archives.\nold_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'\nold_postinstall_cmds='chmod 644 $oldlib'\nold_postuninstall_cmds=\n\nif test -n \"$RANLIB\"; then\n  case $host_os in\n  bitrig* | openbsd*)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB -t \\$tool_oldlib\"\n    ;;\n  *)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB \\$tool_oldlib\"\n    ;;\n  esac\n  old_archive_cmds=\"$old_archive_cmds~\\$RANLIB \\$tool_oldlib\"\nfi\n\ncase $host_os in\n  darwin*)\n    lock_old_archive_extraction=yes ;;\n  *)\n    lock_old_archive_extraction=no ;;\nesac\n_LT_DECL([], [old_postinstall_cmds], [2])\n_LT_DECL([], [old_postuninstall_cmds], [2])\n_LT_TAGDECL([], [old_archive_cmds], [2],\n    [Commands used to build an old-style archive])\n_LT_DECL([], [lock_old_archive_extraction], [0],\n    [Whether to use a lock for old archive extraction])\n])# _LT_CMD_OLD_ARCHIVE\n\n\n# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#\t\t[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------------------\n# Check whether the given compiler option works\nAC_DEFUN([_LT_COMPILER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n   lt_compiler_flag=\"$3\"  ## exclude from sc_useless_quotes_in_assignment\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   # The option is referenced via a variable to avoid confusing sed.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>conftest.err)\n   ac_status=$?\n   cat conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s \"$ac_outfile\"; then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings other than the usual output.\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' >conftest.exp\n     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then\n       $2=yes\n     fi\n   fi\n   $RM conftest*\n])\n\nif test yes = \"[$]$2\"; then\n    m4_if([$5], , :, [$5])\nelse\n    m4_if([$6], , :, [$6])\nfi\n])# _LT_COMPILER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])\n\n\n# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#                  [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------\n# Check whether the given linker option works\nAC_DEFUN([_LT_LINKER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   save_LDFLAGS=$LDFLAGS\n   LDFLAGS=\"$LDFLAGS $3\"\n   echo \"$lt_simple_link_test_code\" > conftest.$ac_ext\n   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then\n     # The linker can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     if test -s conftest.err; then\n       # Append any errors to the config.log.\n       cat conftest.err 1>&AS_MESSAGE_LOG_FD\n       $ECHO \"$_lt_linker_boilerplate\" | $SED '/^$/d' > conftest.exp\n       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n       if diff conftest.exp conftest.er2 >/dev/null; then\n         $2=yes\n       fi\n     else\n       $2=yes\n     fi\n   fi\n   $RM -r conftest*\n   LDFLAGS=$save_LDFLAGS\n])\n\nif test yes = \"[$]$2\"; then\n    m4_if([$4], , :, [$4])\nelse\n    m4_if([$5], , :, [$5])\nfi\n])# _LT_LINKER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])\n\n\n# LT_CMD_MAX_LEN\n#---------------\nAC_DEFUN([LT_CMD_MAX_LEN],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n# find the maximum length of command line arguments\nAC_MSG_CHECKING([the maximum length of command line arguments])\nAC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl\n  i=0\n  teststring=ABCD\n\n  case $build_os in\n  msdosdjgpp*)\n    # On DJGPP, this test can blow up pretty badly due to problems in libc\n    # (any single argument exceeding 2000 bytes causes a buffer overrun\n    # during glob expansion).  Even if it were fixed, the result of this\n    # check would be larger than it should be.\n    lt_cv_sys_max_cmd_len=12288;    # 12K is about right\n    ;;\n\n  gnu*)\n    # Under GNU Hurd, this test is not required because there is\n    # no limit to the length of command line arguments.\n    # Libtool will interpret -1 as no limit whatsoever\n    lt_cv_sys_max_cmd_len=-1;\n    ;;\n\n  cygwin* | mingw* | cegcc*)\n    # On Win9x/ME, this test blows up -- it succeeds, but takes\n    # about 5 minutes as the teststring grows exponentially.\n    # Worse, since 9x/ME are not pre-emptively multitasking,\n    # you end up with a \"frozen\" computer, even though with patience\n    # the test eventually succeeds (with a max line length of 256k).\n    # Instead, let's just punt: use the minimum linelength reported by\n    # all of the supported platforms: 8192 (on NT/2K/XP).\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  mint*)\n    # On MiNT this can take a long time and run out of memory.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  amigaos*)\n    # On AmigaOS with pdksh, this test takes hours, literally.\n    # So we just punt and use a minimum line length of 8192.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  bitrig* | darwin* | dragonfly* | freebsd* | netbsd* | openbsd*)\n    # This has been around since 386BSD, at least.  Likely further.\n    if test -x /sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`\n    elif test -x /usr/sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`\n    else\n      lt_cv_sys_max_cmd_len=65536\t# usable default for all BSDs\n    fi\n    # And add a safety zone\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    ;;\n\n  interix*)\n    # We know the value 262144 and hardcode it with a safety zone (like BSD)\n    lt_cv_sys_max_cmd_len=196608\n    ;;\n\n  os2*)\n    # The test takes a long time on OS/2.\n    lt_cv_sys_max_cmd_len=8192\n    ;;\n\n  osf*)\n    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure\n    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not\n    # nice to cause kernel panics so lets avoid the loop below.\n    # First set a reasonable default.\n    lt_cv_sys_max_cmd_len=16384\n    #\n    if test -x /sbin/sysconfig; then\n      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in\n        *1*) lt_cv_sys_max_cmd_len=-1 ;;\n      esac\n    fi\n    ;;\n  sco3.2v5*)\n    lt_cv_sys_max_cmd_len=102400\n    ;;\n  sysv5* | sco5v6* | sysv4.2uw2*)\n    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`\n    if test -n \"$kargmax\"; then\n      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[\t ]]//'`\n    else\n      lt_cv_sys_max_cmd_len=32768\n    fi\n    ;;\n  *)\n    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`\n    if test -n \"$lt_cv_sys_max_cmd_len\" && \\\n       test undefined != \"$lt_cv_sys_max_cmd_len\"; then\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    else\n      # Make teststring a little bigger before we do anything with it.\n      # a 1K string should be a reasonable start.\n      for i in 1 2 3 4 5 6 7 8; do\n        teststring=$teststring$teststring\n      done\n      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n      # If test is not a shell built-in, we'll probably end up computing a\n      # maximum length that is only half of the actual maximum length, but\n      # we can't tell.\n      while { test X`env echo \"$teststring$teststring\" 2>/dev/null` \\\n\t         = \"X$teststring$teststring\"; } >/dev/null 2>&1 &&\n\t      test 17 != \"$i\" # 1/2 MB should be enough\n      do\n        i=`expr $i + 1`\n        teststring=$teststring$teststring\n      done\n      # Only check the string length outside the loop.\n      lt_cv_sys_max_cmd_len=`expr \"X$teststring\" : \".*\" 2>&1`\n      teststring=\n      # Add a significant safety factor because C++ compilers can tack on\n      # massive amounts of additional arguments before passing them to the\n      # linker.  It appears as though 1/2 is a usable value.\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n    fi\n    ;;\n  esac\n])\nif test -n \"$lt_cv_sys_max_cmd_len\"; then\n  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)\nelse\n  AC_MSG_RESULT(none)\nfi\nmax_cmd_len=$lt_cv_sys_max_cmd_len\n_LT_DECL([], [max_cmd_len], [0],\n    [What is the maximum length of a command?])\n])# LT_CMD_MAX_LEN\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])\n\n\n# _LT_HEADER_DLFCN\n# ----------------\nm4_defun([_LT_HEADER_DLFCN],\n[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl\n])# _LT_HEADER_DLFCN\n\n\n# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,\n#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)\n# ----------------------------------------------------------------\nm4_defun([_LT_TRY_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test yes = \"$cross_compiling\"; then :\n  [$4]\nelse\n  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n  lt_status=$lt_dlunknown\n  cat > conftest.$ac_ext <<_LT_EOF\n[#line $LINENO \"configure\"\n#include \"confdefs.h\"\n\n#if HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <stdio.h>\n\n#ifdef RTLD_GLOBAL\n#  define LT_DLGLOBAL\t\tRTLD_GLOBAL\n#else\n#  ifdef DL_GLOBAL\n#    define LT_DLGLOBAL\t\tDL_GLOBAL\n#  else\n#    define LT_DLGLOBAL\t\t0\n#  endif\n#endif\n\n/* We may have to define LT_DLLAZY_OR_NOW in the command line if we\n   find out it does not work in some platform. */\n#ifndef LT_DLLAZY_OR_NOW\n#  ifdef RTLD_LAZY\n#    define LT_DLLAZY_OR_NOW\t\tRTLD_LAZY\n#  else\n#    ifdef DL_LAZY\n#      define LT_DLLAZY_OR_NOW\t\tDL_LAZY\n#    else\n#      ifdef RTLD_NOW\n#        define LT_DLLAZY_OR_NOW\tRTLD_NOW\n#      else\n#        ifdef DL_NOW\n#          define LT_DLLAZY_OR_NOW\tDL_NOW\n#        else\n#          define LT_DLLAZY_OR_NOW\t0\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n\n/* When -fvisibility=hidden is used, assume the code has been annotated\n   correspondingly for the symbols needed.  */\n#if defined __GNUC__ && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))\nint fnord () __attribute__((visibility(\"default\")));\n#endif\n\nint fnord () { return 42; }\nint main ()\n{\n  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);\n  int status = $lt_dlunknown;\n\n  if (self)\n    {\n      if (dlsym (self,\"fnord\"))       status = $lt_dlno_uscore;\n      else\n        {\n\t  if (dlsym( self,\"_fnord\"))  status = $lt_dlneed_uscore;\n          else puts (dlerror ());\n\t}\n      /* dlclose (self); */\n    }\n  else\n    puts (dlerror ());\n\n  return status;\n}]\n_LT_EOF\n  if AC_TRY_EVAL(ac_link) && test -s \"conftest$ac_exeext\" 2>/dev/null; then\n    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null\n    lt_status=$?\n    case x$lt_status in\n      x$lt_dlno_uscore) $1 ;;\n      x$lt_dlneed_uscore) $2 ;;\n      x$lt_dlunknown|x*) $3 ;;\n    esac\n  else :\n    # compilation failed\n    $3\n  fi\nfi\nrm -fr conftest*\n])# _LT_TRY_DLOPEN_SELF\n\n\n# LT_SYS_DLOPEN_SELF\n# ------------------\nAC_DEFUN([LT_SYS_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test yes != \"$enable_dlopen\"; then\n  enable_dlopen=unknown\n  enable_dlopen_self=unknown\n  enable_dlopen_self_static=unknown\nelse\n  lt_cv_dlopen=no\n  lt_cv_dlopen_libs=\n\n  case $host_os in\n  beos*)\n    lt_cv_dlopen=load_add_on\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ;;\n\n  mingw* | pw32* | cegcc*)\n    lt_cv_dlopen=LoadLibrary\n    lt_cv_dlopen_libs=\n    ;;\n\n  cygwin*)\n    lt_cv_dlopen=dlopen\n    lt_cv_dlopen_libs=\n    ;;\n\n  darwin*)\n    # if libdl is installed we need to link against it\n    AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=dlopen lt_cv_dlopen_libs=-ldl],[\n    lt_cv_dlopen=dyld\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ])\n    ;;\n\n  tpf*)\n    # Don't try to run any link tests for TPF.  We know it's impossible\n    # because TPF is a cross-compiler, and we know how we open DSOs.\n    lt_cv_dlopen=dlopen\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=no\n    ;;\n\n  *)\n    AC_CHECK_FUNC([shl_load],\n\t  [lt_cv_dlopen=shl_load],\n      [AC_CHECK_LIB([dld], [shl_load],\n\t    [lt_cv_dlopen=shl_load lt_cv_dlopen_libs=-ldld],\n\t[AC_CHECK_FUNC([dlopen],\n\t      [lt_cv_dlopen=dlopen],\n\t  [AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=dlopen lt_cv_dlopen_libs=-ldl],\n\t    [AC_CHECK_LIB([svld], [dlopen],\n\t\t  [lt_cv_dlopen=dlopen lt_cv_dlopen_libs=-lsvld],\n\t      [AC_CHECK_LIB([dld], [dld_link],\n\t\t    [lt_cv_dlopen=dld_link lt_cv_dlopen_libs=-ldld])\n\t      ])\n\t    ])\n\t  ])\n\t])\n      ])\n    ;;\n  esac\n\n  if test no = \"$lt_cv_dlopen\"; then\n    enable_dlopen=no\n  else\n    enable_dlopen=yes\n  fi\n\n  case $lt_cv_dlopen in\n  dlopen)\n    save_CPPFLAGS=$CPPFLAGS\n    test yes = \"$ac_cv_header_dlfcn_h\" && CPPFLAGS=\"$CPPFLAGS -DHAVE_DLFCN_H\"\n\n    save_LDFLAGS=$LDFLAGS\n    wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $export_dynamic_flag_spec\\\"\n\n    save_LIBS=$LIBS\n    LIBS=\"$lt_cv_dlopen_libs $LIBS\"\n\n    AC_CACHE_CHECK([whether a program can dlopen itself],\n\t  lt_cv_dlopen_self, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,\n\t    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)\n    ])\n\n    if test yes = \"$lt_cv_dlopen_self\"; then\n      wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $lt_prog_compiler_static\\\"\n      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],\n\t  lt_cv_dlopen_self_static, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,\n\t    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)\n      ])\n    fi\n\n    CPPFLAGS=$save_CPPFLAGS\n    LDFLAGS=$save_LDFLAGS\n    LIBS=$save_LIBS\n    ;;\n  esac\n\n  case $lt_cv_dlopen_self in\n  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;\n  *) enable_dlopen_self=unknown ;;\n  esac\n\n  case $lt_cv_dlopen_self_static in\n  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;\n  *) enable_dlopen_self_static=unknown ;;\n  esac\nfi\n_LT_DECL([dlopen_support], [enable_dlopen], [0],\n\t [Whether dlopen is supported])\n_LT_DECL([dlopen_self], [enable_dlopen_self], [0],\n\t [Whether dlopen of programs is supported])\n_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],\n\t [Whether dlopen of statically linked programs is supported])\n])# LT_SYS_DLOPEN_SELF\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])\n\n\n# _LT_COMPILER_C_O([TAGNAME])\n# ---------------------------\n# Check to see if options -c and -o are simultaneously supported by compiler.\n# This macro does not hard code the compiler like AC_PROG_CC_C_O.\nm4_defun([_LT_COMPILER_C_O],\n[m4_require([_LT_DECL_SED])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no\n   $RM -r conftest 2>/dev/null\n   mkdir conftest\n   cd conftest\n   mkdir out\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n   lt_compiler_flag=\"-o out/conftest2.$ac_objext\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>out/conftest.err)\n   ac_status=$?\n   cat out/conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s out/conftest2.$ac_objext\n   then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' > out/conftest.exp\n     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2\n     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then\n       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n     fi\n   fi\n   chmod u+w . 2>&AS_MESSAGE_LOG_FD\n   $RM conftest*\n   # SGI C++ compiler will create directory out/ii_files/ for\n   # template instantiation\n   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files\n   $RM out/* && rmdir out\n   cd ..\n   $RM -r conftest\n   $RM conftest*\n])\n_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],\n\t[Does compiler simultaneously support -c and -o options?])\n])# _LT_COMPILER_C_O\n\n\n# _LT_COMPILER_FILE_LOCKS([TAGNAME])\n# ----------------------------------\n# Check to see if we can do hard links to lock some files if needed\nm4_defun([_LT_COMPILER_FILE_LOCKS],\n[m4_require([_LT_ENABLE_LOCK])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_COMPILER_C_O([$1])\n\nhard_links=nottested\nif test no = \"$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)\" && test no != \"$need_locks\"; then\n  # do not overwrite the value of need_locks provided by the user\n  AC_MSG_CHECKING([if we can lock with hard links])\n  hard_links=yes\n  $RM conftest*\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  touch conftest.a\n  ln conftest.a conftest.b 2>&5 || hard_links=no\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  AC_MSG_RESULT([$hard_links])\n  if test no = \"$hard_links\"; then\n    AC_MSG_WARN(['$CC' does not support '-c -o', so 'make -j' may be unsafe])\n    need_locks=warn\n  fi\nelse\n  need_locks=no\nfi\n_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])\n])# _LT_COMPILER_FILE_LOCKS\n\n\n# _LT_CHECK_OBJDIR\n# ----------------\nm4_defun([_LT_CHECK_OBJDIR],\n[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],\n[rm -f .libs 2>/dev/null\nmkdir .libs 2>/dev/null\nif test -d .libs; then\n  lt_cv_objdir=.libs\nelse\n  # MS-DOS does not allow filenames that begin with a dot.\n  lt_cv_objdir=_libs\nfi\nrmdir .libs 2>/dev/null])\nobjdir=$lt_cv_objdir\n_LT_DECL([], [objdir], [0],\n         [The name of the directory that contains temporary libtool files])dnl\nm4_pattern_allow([LT_OBJDIR])dnl\nAC_DEFINE_UNQUOTED([LT_OBJDIR], \"$lt_cv_objdir/\",\n  [Define to the sub-directory where libtool stores uninstalled libraries.])\n])# _LT_CHECK_OBJDIR\n\n\n# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])\n# --------------------------------------\n# Check hardcoding attributes.\nm4_defun([_LT_LINKER_HARDCODE_LIBPATH],\n[AC_MSG_CHECKING([how to hardcode library paths into programs])\n_LT_TAGVAR(hardcode_action, $1)=\nif test -n \"$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\" ||\n   test -n \"$_LT_TAGVAR(runpath_var, $1)\" ||\n   test yes = \"$_LT_TAGVAR(hardcode_automatic, $1)\"; then\n\n  # We can hardcode non-existent directories.\n  if test no != \"$_LT_TAGVAR(hardcode_direct, $1)\" &&\n     # If the only mechanism to avoid hardcoding is shlibpath_var, we\n     # have to relink, otherwise we might link with an installed library\n     # when we should be linking with a yet-to-be-installed one\n     ## test no != \"$_LT_TAGVAR(hardcode_shlibpath_var, $1)\" &&\n     test no != \"$_LT_TAGVAR(hardcode_minus_L, $1)\"; then\n    # Linking always hardcodes the temporary library directory.\n    _LT_TAGVAR(hardcode_action, $1)=relink\n  else\n    # We can link without hardcoding, and we can hardcode nonexisting dirs.\n    _LT_TAGVAR(hardcode_action, $1)=immediate\n  fi\nelse\n  # We cannot hardcode anything, or else we can only hardcode existing\n  # directories.\n  _LT_TAGVAR(hardcode_action, $1)=unsupported\nfi\nAC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])\n\nif test relink = \"$_LT_TAGVAR(hardcode_action, $1)\" ||\n   test yes = \"$_LT_TAGVAR(inherit_rpath, $1)\"; then\n  # Fast installation is not supported\n  enable_fast_install=no\nelif test yes = \"$shlibpath_overrides_runpath\" ||\n     test no = \"$enable_shared\"; then\n  # Fast installation is not necessary\n  enable_fast_install=needless\nfi\n_LT_TAGDECL([], [hardcode_action], [0],\n    [How to hardcode a shared library path into an executable])\n])# _LT_LINKER_HARDCODE_LIBPATH\n\n\n# _LT_CMD_STRIPLIB\n# ----------------\nm4_defun([_LT_CMD_STRIPLIB],\n[m4_require([_LT_DECL_EGREP])\nstriplib=\nold_striplib=\nAC_MSG_CHECKING([whether stripping libraries is possible])\nif test -n \"$STRIP\" && $STRIP -V 2>&1 | $GREP \"GNU strip\" >/dev/null; then\n  test -z \"$old_striplib\" && old_striplib=\"$STRIP --strip-debug\"\n  test -z \"$striplib\" && striplib=\"$STRIP --strip-unneeded\"\n  AC_MSG_RESULT([yes])\nelse\n# FIXME - insert some real tests, host_os isn't really good enough\n  case $host_os in\n  darwin*)\n    if test -n \"$STRIP\"; then\n      striplib=\"$STRIP -x\"\n      old_striplib=\"$STRIP -S\"\n      AC_MSG_RESULT([yes])\n    else\n      AC_MSG_RESULT([no])\n    fi\n    ;;\n  *)\n    AC_MSG_RESULT([no])\n    ;;\n  esac\nfi\n_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])\n_LT_DECL([], [striplib], [1])\n])# _LT_CMD_STRIPLIB\n\n\n# _LT_PREPARE_MUNGE_PATH_LIST\n# ---------------------------\n# Make sure func_munge_path_list() is defined correctly.\nm4_defun([_LT_PREPARE_MUNGE_PATH_LIST],\n[[# func_munge_path_list VARIABLE PATH\n# -----------------------------------\n# VARIABLE is name of variable containing _space_ separated list of\n# directories to be munged by the contents of PATH, which is string\n# having a format:\n# \"DIR[:DIR]:\"\n#       string \"DIR[ DIR]\" will be prepended to VARIABLE\n# \":DIR[:DIR]\"\n#       string \"DIR[ DIR]\" will be appended to VARIABLE\n# \"DIRP[:DIRP]::[DIRA:]DIRA\"\n#       string \"DIRP[ DIRP]\" will be prepended to VARIABLE and string\n#       \"DIRA[ DIRA]\" will be appended to VARIABLE\n# \"DIR[:DIR]\"\n#       VARIABLE will be replaced by \"DIR[ DIR]\"\nfunc_munge_path_list ()\n{\n    case x@S|@2 in\n    x)\n        ;;\n    *:)\n        eval @S|@1=\\\"`$ECHO @S|@2 | $SED 's/:/ /g'` \\@S|@@S|@1\\\"\n        ;;\n    x:*)\n        eval @S|@1=\\\"\\@S|@@S|@1 `$ECHO @S|@2 | $SED 's/:/ /g'`\\\"\n        ;;\n    *::*)\n        eval @S|@1=\\\"\\@S|@@S|@1\\ `$ECHO @S|@2 | $SED -e 's/.*:://' -e 's/:/ /g'`\\\"\n        eval @S|@1=\\\"`$ECHO @S|@2 | $SED -e 's/::.*//' -e 's/:/ /g'`\\ \\@S|@@S|@1\\\"\n        ;;\n    *)\n        eval @S|@1=\\\"`$ECHO @S|@2 | $SED 's/:/ /g'`\\\"\n        ;;\n    esac\n}\n]])# _LT_PREPARE_PATH_LIST\n\n\n# _LT_SYS_DYNAMIC_LINKER([TAG])\n# -----------------------------\n# PORTME Fill in your ld.so characteristics\nm4_defun([_LT_SYS_DYNAMIC_LINKER],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_OBJDUMP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nm4_require([_LT_PREPARE_MUNGE_PATH_LIST])dnl\nAC_MSG_CHECKING([dynamic linker characteristics])\nm4_if([$1],\n\t[], [\nif test yes = \"$GCC\"; then\n  case $host_os in\n    darwin*) lt_awk_arg='/^libraries:/,/LR/' ;;\n    *) lt_awk_arg='/^libraries:/' ;;\n  esac\n  case $host_os in\n    mingw* | cegcc*) lt_sed_strip_eq='s|=\\([[A-Za-z]]:\\)|\\1|g' ;;\n    *) lt_sed_strip_eq='s|=/|/|g' ;;\n  esac\n  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e \"s/^libraries://\" -e $lt_sed_strip_eq`\n  case $lt_search_path_spec in\n  *\\;*)\n    # if the path contains \";\" then we assume it to be the separator\n    # otherwise default to the standard path separator (i.e. \":\") - it is\n    # assumed that no part of a normal pathname contains \";\" but that should\n    # okay in the real world where \";\" in dirpaths is itself problematic.\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED 's/;/ /g'`\n    ;;\n  *)\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED \"s/$PATH_SEPARATOR/ /g\"`\n    ;;\n  esac\n  # Ok, now we have the path, separated by spaces, we can step through it\n  # and add multilib dir if necessary...\n  lt_tmp_lt_search_path_spec=\n  lt_multi_os_dir=/`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`\n  # ...but if some path component already ends with the multilib dir we assume\n  # that all is fine and trust -print-search-dirs as is (GCC 4.2? or newer).\n  case \"$lt_multi_os_dir; $lt_search_path_spec \" in\n  \"/; \"* | \"/.; \"* | \"/./; \"* | *\"$lt_multi_os_dir \"* | *\"$lt_multi_os_dir/ \"*)\n    lt_multi_os_dir=\n    ;;\n  esac\n  for lt_sys_path in $lt_search_path_spec; do\n    if test -d \"$lt_sys_path$lt_multi_os_dir\"; then\n      lt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path$lt_multi_os_dir\"\n    elif test -n \"$lt_multi_os_dir\"; then\n      test -d \"$lt_sys_path\" && \\\n\tlt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path\"\n    fi\n  done\n  lt_search_path_spec=`$ECHO \"$lt_tmp_lt_search_path_spec\" | awk '\nBEGIN {RS = \" \"; FS = \"/|\\n\";} {\n  lt_foo = \"\";\n  lt_count = 0;\n  for (lt_i = NF; lt_i > 0; lt_i--) {\n    if ($lt_i != \"\" && $lt_i != \".\") {\n      if ($lt_i == \"..\") {\n        lt_count++;\n      } else {\n        if (lt_count == 0) {\n          lt_foo = \"/\" $lt_i lt_foo;\n        } else {\n          lt_count--;\n        }\n      }\n    }\n  }\n  if (lt_foo != \"\") { lt_freq[[lt_foo]]++; }\n  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }\n}'`\n  # AWK program above erroneously prepends '/' to C:/dos/paths\n  # for these hosts.\n  case $host_os in\n    mingw* | cegcc*) lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" |\\\n      $SED 's|/\\([[A-Za-z]]:\\)|\\1|g'` ;;\n  esac\n  sys_lib_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $lt_NL2SP`\nelse\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\nfi])\nlibrary_names_spec=\nlibname_spec='lib$name'\nsoname_spec=\nshrext_cmds=.so\npostinstall_cmds=\npostuninstall_cmds=\nfinish_cmds=\nfinish_eval=\nshlibpath_var=\nshlibpath_overrides_runpath=unknown\nversion_type=none\ndynamic_linker=\"$host_os ld.so\"\nsys_lib_dlsearch_path_spec=\"/lib /usr/lib\"\nneed_lib_prefix=unknown\nhardcode_into_libs=no\n\n# when you set need_version to no, make sure it does not cause -set_version\n# flags to be left without arguments\nneed_version=unknown\n\nAC_ARG_VAR([LT_SYS_LIBRARY_PATH],\n[User-defined run-time library search path.])\n\ncase $host_os in\naix3*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='$libname$release$shared_ext$versuffix $libname.a'\n  shlibpath_var=LIBPATH\n\n  # AIX 3 has no versioning support, so we append a major version to the name.\n  soname_spec='$libname$release$shared_ext$major'\n  ;;\n\naix[[4-9]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  hardcode_into_libs=yes\n  if test ia64 = \"$host_cpu\"; then\n    # AIX 5 supports IA64\n    library_names_spec='$libname$release$shared_ext$major $libname$release$shared_ext$versuffix $libname$shared_ext'\n    shlibpath_var=LD_LIBRARY_PATH\n  else\n    # With GCC up to 2.95.x, collect2 would create an import file\n    # for dependence libraries.  The import file would start with\n    # the line '#! .'.  This would cause the generated library to\n    # depend on '.', always an invalid library.  This was fixed in\n    # development snapshots of GCC prior to 3.0.\n    case $host_os in\n      aix4 | aix4.[[01]] | aix4.[[01]].*)\n      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'\n\t   echo ' yes '\n\t   echo '#endif'; } | $CC -E - | $GREP yes > /dev/null; then\n\t:\n      else\n\tcan_build_shared=no\n      fi\n      ;;\n    esac\n    # Using Import Files as archive members, it is possible to support\n    # filename-based versioning of shared library archives on AIX. While\n    # this would work for both with and without runtime linking, it will\n    # prevent static linking of such archives. So we do filename-based\n    # shared library versioning with .so extension only, which is used\n    # when both runtime linking and shared linking is enabled.\n    # Unfortunately, runtime linking may impact performance, so we do\n    # not want this to be the default eventually. Also, we use the\n    # versioned .so libs for executables only if there is the -brtl\n    # linker flag in LDFLAGS as well, or --with-aix-soname=svr4 only.\n    # To allow for filename-based versioning support, we need to create\n    # libNAME.so.V as an archive file, containing:\n    # *) an Import File, referring to the versioned filename of the\n    #    archive as well as the shared archive member, telling the\n    #    bitwidth (32 or 64) of that shared object, and providing the\n    #    list of exported symbols of that shared object, eventually\n    #    decorated with the 'weak' keyword\n    # *) the shared object with the F_LOADONLY flag set, to really avoid\n    #    it being seen by the linker.\n    # At run time we better use the real file rather than another symlink,\n    # but for link time we create the symlink libNAME.so -> libNAME.so.V\n\n    case $with_aix_soname,$aix_use_runtimelinking in\n    # AIX (on Power*) has no versioning support, so currently we cannot hardcode correct\n    # soname into executable. Probably we can add versioning support to\n    # collect2, so additional links can be useful in future.\n    aix,yes) # traditional libtool\n      dynamic_linker='AIX unversionable lib.so'\n      # If using run time linking (on AIX 4.2 or later) use lib<name>.so\n      # instead of lib<name>.a to let people know that these are not\n      # typical AIX shared libraries.\n      library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n      ;;\n    aix,no) # traditional AIX only\n      dynamic_linker='AIX lib.a[(]lib.so.V[)]'\n      # We preserve .a as extension for shared libraries through AIX4.2\n      # and later when we are not doing run time linking.\n      library_names_spec='$libname$release.a $libname.a'\n      soname_spec='$libname$release$shared_ext$major'\n      ;;\n    svr4,*) # full svr4 only\n      dynamic_linker=\"AIX lib.so.V[(]$shared_archive_member_spec.o[)]\"\n      library_names_spec='$libname$release$shared_ext$major $libname$shared_ext'\n      # We do not specify a path in Import Files, so LIBPATH fires.\n      shlibpath_overrides_runpath=yes\n      ;;\n    *,yes) # both, prefer svr4\n      dynamic_linker=\"AIX lib.so.V[(]$shared_archive_member_spec.o[)], lib.a[(]lib.so.V[)]\"\n      library_names_spec='$libname$release$shared_ext$major $libname$shared_ext'\n      # unpreferred sharedlib libNAME.a needs extra handling\n      postinstall_cmds='test -n \"$linkname\" || linkname=\"$realname\"~func_stripname \"\" \".so\" \"$linkname\"~$install_shared_prog \"$dir/$func_stripname_result.$libext\" \"$destdir/$func_stripname_result.$libext\"~test -z \"$tstripme\" || test -z \"$striplib\" || $striplib \"$destdir/$func_stripname_result.$libext\"'\n      postuninstall_cmds='for n in $library_names $old_library; do :; done~func_stripname \"\" \".so\" \"$n\"~test \"$func_stripname_result\" = \"$n\" || func_append rmfiles \" $odir/$func_stripname_result.$libext\"'\n      # We do not specify a path in Import Files, so LIBPATH fires.\n      shlibpath_overrides_runpath=yes\n      ;;\n    *,no) # both, prefer aix\n      dynamic_linker=\"AIX lib.a[(]lib.so.V[)], lib.so.V[(]$shared_archive_member_spec.o[)]\"\n      library_names_spec='$libname$release.a $libname.a'\n      soname_spec='$libname$release$shared_ext$major'\n      # unpreferred sharedlib libNAME.so.V and symlink libNAME.so need extra handling\n      postinstall_cmds='test -z \"$dlname\" || $install_shared_prog $dir/$dlname $destdir/$dlname~test -z \"$tstripme\" || test -z \"$striplib\" || $striplib $destdir/$dlname~test -n \"$linkname\" || linkname=$realname~func_stripname \"\" \".a\" \"$linkname\"~(cd \"$destdir\" && $LN_S -f $dlname $func_stripname_result.so)'\n      postuninstall_cmds='test -z \"$dlname\" || func_append rmfiles \" $odir/$dlname\"~for n in $old_library $library_names; do :; done~func_stripname \"\" \".a\" \"$n\"~func_append rmfiles \" $odir/$func_stripname_result.so\"'\n      ;;\n    esac\n    shlibpath_var=LIBPATH\n  fi\n  ;;\n\namigaos*)\n  case $host_cpu in\n  powerpc)\n    # Since July 2007 AmigaOS4 officially supports .so libraries.\n    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n    ;;\n  m68k)\n    library_names_spec='$libname.ixlibrary $libname.a'\n    # Create ${libname}_ixlibrary.a entries in /sys/libs.\n    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all \"$lib\" | $SED '\\''s%^.*/\\([[^/]]*\\)\\.ixlibrary$%\\1%'\\''`; $RM /sys/libs/${libname}_ixlibrary.a; $show \"cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a\"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'\n    ;;\n  esac\n  ;;\n\nbeos*)\n  library_names_spec='$libname$shared_ext'\n  dynamic_linker=\"$host_os ld.so\"\n  shlibpath_var=LIBRARY_PATH\n  ;;\n\nbsdi[[45]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=\"/shlib /usr/lib /usr/local/lib\"\n  # the default ld.so.conf also contains /usr/contrib/lib and\n  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow\n  # libtool to hard-code these into programs\n  ;;\n\ncygwin* | mingw* | pw32* | cegcc*)\n  version_type=windows\n  shrext_cmds=.dll\n  need_version=no\n  need_lib_prefix=no\n\n  case $GCC,$cc_basename in\n  yes,*)\n    # gcc\n    library_names_spec='$libname.dll.a'\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\$file`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\$base_file'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname~\n      chmod a+x \\$dldir/$dlname~\n      if test -n '\\''$stripme'\\'' && test -n '\\''$striplib'\\''; then\n        eval '\\''$striplib \\$dldir/$dlname'\\'' || exit \\$?;\n      fi'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n\n    case $host_os in\n    cygwin*)\n      # Cygwin DLLs use 'cyg' prefix rather than 'lib'\n      soname_spec='`echo $libname | sed -e 's/^lib/cyg/'``echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'\nm4_if([$1], [],[\n      sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/lib/w32api\"])\n      ;;\n    mingw* | cegcc*)\n      # MinGW DLLs use traditional 'lib' prefix\n      soname_spec='$libname`echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'\n      ;;\n    pw32*)\n      # pw32 DLLs use 'pw' prefix rather than 'lib'\n      library_names_spec='`echo $libname | sed -e 's/^lib/pw/'``echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'\n      ;;\n    esac\n    dynamic_linker='Win32 ld.exe'\n    ;;\n\n  *,cl*)\n    # Native MSVC\n    libname_spec='$name'\n    soname_spec='$libname`echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'\n    library_names_spec='$libname.dll.lib'\n\n    case $build_os in\n    mingw*)\n      sys_lib_search_path_spec=\n      lt_save_ifs=$IFS\n      IFS=';'\n      for lt_path in $LIB\n      do\n        IFS=$lt_save_ifs\n        # Let DOS variable expansion print the short 8.3 style file name.\n        lt_path=`cd \"$lt_path\" 2>/dev/null && cmd //C \"for %i in (\".\") do @echo %~si\"`\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec $lt_path\"\n      done\n      IFS=$lt_save_ifs\n      # Convert to MSYS style.\n      sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | sed -e 's|\\\\\\\\|/|g' -e 's| \\\\([[a-zA-Z]]\\\\):| /\\\\1|g' -e 's|^ ||'`\n      ;;\n    cygwin*)\n      # Convert to unix form, then to dos form, then back to unix form\n      # but this time dos style (no spaces!) so that the unix form looks\n      # like /cygdrive/c/PROGRA~1:/cygdr...\n      sys_lib_search_path_spec=`cygpath --path --unix \"$LIB\"`\n      sys_lib_search_path_spec=`cygpath --path --dos \"$sys_lib_search_path_spec\" 2>/dev/null`\n      sys_lib_search_path_spec=`cygpath --path --unix \"$sys_lib_search_path_spec\" | $SED -e \"s/$PATH_SEPARATOR/ /g\"`\n      ;;\n    *)\n      sys_lib_search_path_spec=$LIB\n      if $ECHO \"$sys_lib_search_path_spec\" | [$GREP ';[c-zC-Z]:/' >/dev/null]; then\n        # It is most probably a Windows format PATH.\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e 's/;/ /g'`\n      else\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e \"s/$PATH_SEPARATOR/ /g\"`\n      fi\n      # FIXME: find the short name or the path components, as spaces are\n      # common. (e.g. \"Program Files\" -> \"PROGRA~1\")\n      ;;\n    esac\n\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\$file`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\$base_file'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n    dynamic_linker='Win32 link.exe'\n    ;;\n\n  *)\n    # Assume MSVC wrapper\n    library_names_spec='$libname`echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext $libname.lib'\n    dynamic_linker='Win32 ld.exe'\n    ;;\n  esac\n  # FIXME: first we should search . and the directory the executable is in\n  shlibpath_var=PATH\n  ;;\n\ndarwin* | rhapsody*)\n  dynamic_linker=\"$host_os dyld\"\n  version_type=darwin\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$major$shared_ext $libname$shared_ext'\n  soname_spec='$libname$release$major$shared_ext'\n  shlibpath_overrides_runpath=yes\n  shlibpath_var=DYLD_LIBRARY_PATH\n  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'\nm4_if([$1], [],[\n  sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/local/lib\"])\n  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'\n  ;;\n\ndgux*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\nfreebsd* | dragonfly*)\n  # DragonFly does not have aout.  When/if they implement a new\n  # versioning mechanism, adjust this.\n  if test -x /usr/bin/objformat; then\n    objformat=`/usr/bin/objformat`\n  else\n    case $host_os in\n    freebsd[[23]].*) objformat=aout ;;\n    *) objformat=elf ;;\n    esac\n  fi\n  version_type=freebsd-$objformat\n  case $version_type in\n    freebsd-elf*)\n      library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n      soname_spec='$libname$release$shared_ext$major'\n      need_version=no\n      need_lib_prefix=no\n      ;;\n    freebsd-*)\n      library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'\n      need_version=yes\n      ;;\n  esac\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_os in\n  freebsd2.*)\n    shlibpath_overrides_runpath=yes\n    ;;\n  freebsd3.[[01]]* | freebsdelf3.[[01]]*)\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \\\n  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)\n    shlibpath_overrides_runpath=no\n    hardcode_into_libs=yes\n    ;;\n  *) # from 4.6 on, and DragonFly\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  esac\n  ;;\n\nhaiku*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  dynamic_linker=\"$host_os runtime_loader\"\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'\n  hardcode_into_libs=yes\n  ;;\n\nhpux9* | hpux10* | hpux11*)\n  # Give a soname corresponding to the major version so that dld.sl refuses to\n  # link against other versions.\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  case $host_cpu in\n  ia64*)\n    shrext_cmds='.so'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.so\"\n    shlibpath_var=LD_LIBRARY_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n    soname_spec='$libname$release$shared_ext$major'\n    if test 32 = \"$HPUX_IA64_MODE\"; then\n      sys_lib_search_path_spec=\"/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib\"\n      sys_lib_dlsearch_path_spec=/usr/lib/hpux32\n    else\n      sys_lib_search_path_spec=\"/usr/lib/hpux64 /usr/local/lib/hpux64\"\n      sys_lib_dlsearch_path_spec=/usr/lib/hpux64\n    fi\n    ;;\n  hppa*64*)\n    shrext_cmds='.sl'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n    soname_spec='$libname$release$shared_ext$major'\n    sys_lib_search_path_spec=\"/usr/lib/pa20_64 /usr/ccs/lib/pa20_64\"\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  *)\n    shrext_cmds='.sl'\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=SHLIB_PATH\n    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n    soname_spec='$libname$release$shared_ext$major'\n    ;;\n  esac\n  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...\n  postinstall_cmds='chmod 555 $lib'\n  # or fails outright, so override atomically:\n  install_override_mode=555\n  ;;\n\ninterix[[3-9]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $host_os in\n    nonstopux*) version_type=nonstopux ;;\n    *)\n\tif test yes = \"$lt_cv_prog_gnu_ld\"; then\n\t\tversion_type=linux # correct to gnu/linux during the next big refactor\n\telse\n\t\tversion_type=irix\n\tfi ;;\n  esac\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='$libname$release$shared_ext$major'\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$release$shared_ext $libname$shared_ext'\n  case $host_os in\n  irix5* | nonstopux*)\n    libsuff= shlibsuff=\n    ;;\n  *)\n    case $LD in # libtool.m4 will add one of these switches to LD\n    *-32|*\"-32 \"|*-melf32bsmip|*\"-melf32bsmip \")\n      libsuff= shlibsuff= libmagic=32-bit;;\n    *-n32|*\"-n32 \"|*-melf32bmipn32|*\"-melf32bmipn32 \")\n      libsuff=32 shlibsuff=N32 libmagic=N32;;\n    *-64|*\"-64 \"|*-melf64bmip|*\"-melf64bmip \")\n      libsuff=64 shlibsuff=64 libmagic=64-bit;;\n    *) libsuff= shlibsuff= libmagic=never-match;;\n    esac\n    ;;\n  esac\n  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_search_path_spec=\"/usr/lib$libsuff /lib$libsuff /usr/local/lib$libsuff\"\n  sys_lib_dlsearch_path_spec=\"/usr/lib$libsuff /lib$libsuff\"\n  hardcode_into_libs=yes\n  ;;\n\n# No shared lib support for Linux oldld, aout, or coff.\nlinux*oldld* | linux*aout* | linux*coff*)\n  dynamic_linker=no\n  ;;\n\nlinux*android*)\n  version_type=none # Android doesn't support versioned libraries.\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext'\n  soname_spec='$libname$release$shared_ext'\n  finish_cmds=\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n\n  dynamic_linker='Android linker'\n  # Don't embed -rpath directories since the linker doesn't support them.\n  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n  ;;\n\n# This must be glibc/ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -n $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n\n  # Some binutils ld are patched to set DT_RUNPATH\n  AC_CACHE_VAL([lt_cv_shlibpath_overrides_runpath],\n    [lt_cv_shlibpath_overrides_runpath=no\n    save_LDFLAGS=$LDFLAGS\n    save_libdir=$libdir\n    eval \"libdir=/foo; wl=\\\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\\\"; \\\n\t LDFLAGS=\\\"\\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\\\"\"\n    AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n      [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep \"RUNPATH.*$libdir\" >/dev/null],\n\t [lt_cv_shlibpath_overrides_runpath=yes])])\n    LDFLAGS=$save_LDFLAGS\n    libdir=$save_libdir\n    ])\n  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath\n\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n\n  # Ideally, we could use ldconfig to report *all* directores which are\n  # searched for libraries, however this is still not possible.  Aside from not\n  # being certain /sbin/ldconfig is available, command\n  # 'ldconfig -N -X -v | grep ^/' on 64bit Fedora does not report /usr/lib64,\n  # even though it is searched at run-time.  Try to do the best guess by\n  # appending ld.so.conf contents (and includes) to the search path.\n  if test -f /etc/ld.so.conf; then\n    lt_ld_extra=`awk '/^include / { system(sprintf(\"cd /etc; cat %s 2>/dev/null\", \\[$]2)); skip = 1; } { if (!skip) print \\[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[\t ]*hwcap[\t ]/d;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/\"//g;/^$/d' | tr '\\n' ' '`\n    sys_lib_dlsearch_path_spec=\"/lib /usr/lib $lt_ld_extra\"\n  fi\n\n  # We used to test for /lib/ld.so.1 and disable shared libraries on\n  # powerpc, because MkLinux only supported shared libraries with the\n  # GNU dynamic linker.  Since this was broken with cross compilers,\n  # most powerpc-linux boxes support dynamic linking these days and\n  # people can always --disable-shared, the test was removed, and we\n  # assume the GNU/Linux dynamic linker is in use.\n  dynamic_linker='GNU/Linux ld.so'\n  ;;\n\nnetbsdelf*-gnu)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='NetBSD ld.elf_so'\n  ;;\n\nnetbsd*)\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'\n    finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n    dynamic_linker='NetBSD (a.out) ld.so'\n  else\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n    soname_spec='$libname$release$shared_ext$major'\n    dynamic_linker='NetBSD ld.elf_so'\n  fi\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  ;;\n\nnewsos6)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\n*nto* | *qnx*)\n  version_type=qnx\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='ldqnx.so'\n  ;;\n\nopenbsd* | bitrig*)\n  version_type=sunos\n  sys_lib_dlsearch_path_spec=/usr/lib\n  need_lib_prefix=no\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\"; then\n    need_version=no\n  else\n    need_version=yes\n  fi\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\nos2*)\n  libname_spec='$name'\n  version_type=windows\n  shrext_cmds=.dll\n  need_version=no\n  need_lib_prefix=no\n  # OS/2 can only load a DLL with a base name of 8 characters or less.\n  soname_spec='`test -n \"$os2dllname\" && libname=\"$os2dllname\";\n    v=$($ECHO $release$versuffix | tr -d .-);\n    n=$($ECHO $libname | cut -b -$((8 - ${#v})) | tr . _);\n    $ECHO $n$v`$shared_ext'\n  library_names_spec='${libname}_dll.$libext'\n  dynamic_linker='OS/2 ld.exe'\n  shlibpath_var=BEGINLIBPATH\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n  postinstall_cmds='base_file=`basename \\$file`~\n    dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\$base_file'\\''i; $ECHO \\$dlname'\\''`~\n    dldir=$destdir/`dirname \\$dlpath`~\n    test -d \\$dldir || mkdir -p \\$dldir~\n    $install_prog $dir/$dlname \\$dldir/$dlname~\n    chmod a+x \\$dldir/$dlname~\n    if test -n '\\''$stripme'\\'' && test -n '\\''$striplib'\\''; then\n      eval '\\''$striplib \\$dldir/$dlname'\\'' || exit \\$?;\n    fi'\n  postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; $ECHO \\$dlname'\\''`~\n    dlpath=$dir/\\$dldll~\n    $RM \\$dlpath'\n  ;;\n\nosf3* | osf4* | osf5*)\n  version_type=osf\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='$libname$release$shared_ext$major'\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib\"\n  sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n  ;;\n\nrdos*)\n  dynamic_linker=no\n  ;;\n\nsolaris*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  # ldd complains unless libraries are executable\n  postinstall_cmds='chmod +x $lib'\n  ;;\n\nsunos4*)\n  version_type=sunos\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/usr/etc\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  if test yes = \"$with_gnu_ld\"; then\n    need_lib_prefix=no\n  fi\n  need_version=yes\n  ;;\n\nsysv4 | sysv4.3*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_vendor in\n    sni)\n      shlibpath_overrides_runpath=no\n      need_lib_prefix=no\n      runpath_var=LD_RUN_PATH\n      ;;\n    siemens)\n      need_lib_prefix=no\n      ;;\n    motorola)\n      need_lib_prefix=no\n      need_version=no\n      shlibpath_overrides_runpath=no\n      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'\n      ;;\n  esac\n  ;;\n\nsysv4*MP*)\n  if test -d /usr/nec; then\n    version_type=linux # correct to gnu/linux during the next big refactor\n    library_names_spec='$libname$shared_ext.$versuffix $libname$shared_ext.$major $libname$shared_ext'\n    soname_spec='$libname$shared_ext.$major'\n    shlibpath_var=LD_LIBRARY_PATH\n  fi\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  version_type=sco\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  if test yes = \"$with_gnu_ld\"; then\n    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'\n  else\n    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'\n    case $host_os in\n      sco3.2v5*)\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec /lib\"\n\t;;\n    esac\n  fi\n  sys_lib_dlsearch_path_spec='/usr/lib'\n  ;;\n\ntpf*)\n  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nuts4*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\n*)\n  dynamic_linker=no\n  ;;\nesac\nAC_MSG_RESULT([$dynamic_linker])\ntest no = \"$dynamic_linker\" && can_build_shared=no\n\nvariables_saved_for_relink=\"PATH $shlibpath_var $runpath_var\"\nif test yes = \"$GCC\"; then\n  variables_saved_for_relink=\"$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH\"\nfi\n\nif test set = \"${lt_cv_sys_lib_search_path_spec+set}\"; then\n  sys_lib_search_path_spec=$lt_cv_sys_lib_search_path_spec\nfi\n\nif test set = \"${lt_cv_sys_lib_dlsearch_path_spec+set}\"; then\n  sys_lib_dlsearch_path_spec=$lt_cv_sys_lib_dlsearch_path_spec\nfi\n\n# remember unaugmented sys_lib_dlsearch_path content for libtool script decls...\nconfigure_time_dlsearch_path=$sys_lib_dlsearch_path_spec\n\n# ... but it needs LT_SYS_LIBRARY_PATH munging for other configure-time code\nfunc_munge_path_list sys_lib_dlsearch_path_spec \"$LT_SYS_LIBRARY_PATH\"\n\n# to be used as default LT_SYS_LIBRARY_PATH value in generated libtool\nconfigure_time_lt_sys_library_path=$LT_SYS_LIBRARY_PATH\n\n_LT_DECL([], [variables_saved_for_relink], [1],\n    [Variables whose values should be saved in libtool wrapper scripts and\n    restored at link time])\n_LT_DECL([], [need_lib_prefix], [0],\n    [Do we need the \"lib\" prefix for modules?])\n_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])\n_LT_DECL([], [version_type], [0], [Library versioning type])\n_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])\n_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])\n_LT_DECL([], [shlibpath_overrides_runpath], [0],\n    [Is shlibpath searched before the hard-coded library search path?])\n_LT_DECL([], [libname_spec], [1], [Format of library name prefix])\n_LT_DECL([], [library_names_spec], [1],\n    [[List of archive names.  First name is the real one, the rest are links.\n    The last name is the one that the linker finds with -lNAME]])\n_LT_DECL([], [soname_spec], [1],\n    [[The coded name of the library, if different from the real name]])\n_LT_DECL([], [install_override_mode], [1],\n    [Permission mode override for installation of shared libraries])\n_LT_DECL([], [postinstall_cmds], [2],\n    [Command to use after installation of a shared archive])\n_LT_DECL([], [postuninstall_cmds], [2],\n    [Command to use after uninstallation of a shared archive])\n_LT_DECL([], [finish_cmds], [2],\n    [Commands used to finish a libtool library installation in a directory])\n_LT_DECL([], [finish_eval], [1],\n    [[As \"finish_cmds\", except a single script fragment to be evaled but\n    not shown]])\n_LT_DECL([], [hardcode_into_libs], [0],\n    [Whether we should hardcode library paths into libraries])\n_LT_DECL([], [sys_lib_search_path_spec], [2],\n    [Compile-time system search path for libraries])\n_LT_DECL([sys_lib_dlsearch_path_spec], [configure_time_dlsearch_path], [2],\n    [Detected run-time system search path for libraries])\n_LT_DECL([], [configure_time_lt_sys_library_path], [2],\n    [Explicit LT_SYS_LIBRARY_PATH set during ./configure time])\n])# _LT_SYS_DYNAMIC_LINKER\n\n\n# _LT_PATH_TOOL_PREFIX(TOOL)\n# --------------------------\n# find a file program that can recognize shared library\nAC_DEFUN([_LT_PATH_TOOL_PREFIX],\n[m4_require([_LT_DECL_EGREP])dnl\nAC_MSG_CHECKING([for $1])\nAC_CACHE_VAL(lt_cv_path_MAGIC_CMD,\n[case $MAGIC_CMD in\n[[\\\\/*] |  ?:[\\\\/]*])\n  lt_cv_path_MAGIC_CMD=$MAGIC_CMD # Let the user override the test with a path.\n  ;;\n*)\n  lt_save_MAGIC_CMD=$MAGIC_CMD\n  lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR\ndnl $ac_dummy forces splitting on constant user-supplied paths.\ndnl POSIX.2 word splitting is done only on the output of word expansions,\ndnl not every word.  This closes a longstanding sh security hole.\n  ac_dummy=\"m4_if([$2], , $PATH, [$2])\"\n  for ac_dir in $ac_dummy; do\n    IFS=$lt_save_ifs\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$1\"; then\n      lt_cv_path_MAGIC_CMD=$ac_dir/\"$1\"\n      if test -n \"$file_magic_test_file\"; then\n\tcase $deplibs_check_method in\n\t\"file_magic \"*)\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"file_magic \\(.*\\)\"`\n\t  MAGIC_CMD=$lt_cv_path_MAGIC_CMD\n\t  if eval $file_magic_cmd \\$file_magic_test_file 2> /dev/null |\n\t    $EGREP \"$file_magic_regex\" > /dev/null; then\n\t    :\n\t  else\n\t    cat <<_LT_EOF 1>&2\n\n*** Warning: the command libtool uses to detect shared libraries,\n*** $file_magic_cmd, produces output that libtool cannot recognize.\n*** The result is that libtool may fail to recognize shared libraries\n*** as such.  This will affect the creation of libtool libraries that\n*** depend on shared libraries, but programs linked with such libtool\n*** libraries will work regardless of this problem.  Nevertheless, you\n*** may want to report the problem to your system manager and/or to\n*** bug-libtool@gnu.org\n\n_LT_EOF\n\t  fi ;;\n\tesac\n      fi\n      break\n    fi\n  done\n  IFS=$lt_save_ifs\n  MAGIC_CMD=$lt_save_MAGIC_CMD\n  ;;\nesac])\nMAGIC_CMD=$lt_cv_path_MAGIC_CMD\nif test -n \"$MAGIC_CMD\"; then\n  AC_MSG_RESULT($MAGIC_CMD)\nelse\n  AC_MSG_RESULT(no)\nfi\n_LT_DECL([], [MAGIC_CMD], [0],\n\t [Used to examine libraries when file_magic_cmd begins with \"file\"])dnl\n])# _LT_PATH_TOOL_PREFIX\n\n# Old name:\nAU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])\n\n\n# _LT_PATH_MAGIC\n# --------------\n# find a file program that can recognize a shared library\nm4_defun([_LT_PATH_MAGIC],\n[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)\nif test -z \"$lt_cv_path_MAGIC_CMD\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)\n  else\n    MAGIC_CMD=:\n  fi\nfi\n])# _LT_PATH_MAGIC\n\n\n# LT_PATH_LD\n# ----------\n# find the pathname to the GNU or non-GNU linker\nAC_DEFUN([LT_PATH_LD],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PROG_ECHO_BACKSLASH])dnl\n\nAC_ARG_WITH([gnu-ld],\n    [AS_HELP_STRING([--with-gnu-ld],\n\t[assume the C compiler uses GNU ld @<:@default=no@:>@])],\n    [test no = \"$withval\" || with_gnu_ld=yes],\n    [with_gnu_ld=no])dnl\n\nac_prog=ld\nif test yes = \"$GCC\"; then\n  # Check if gcc -print-prog-name=ld gives a path.\n  AC_MSG_CHECKING([for ld used by $CC])\n  case $host in\n  *-*-mingw*)\n    # gcc leaves a trailing carriage return, which upsets mingw\n    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\\015'` ;;\n  *)\n    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;\n  esac\n  case $ac_prog in\n    # Accept absolute paths.\n    [[\\\\/]]* | ?:[[\\\\/]]*)\n      re_direlt='/[[^/]][[^/]]*/\\.\\./'\n      # Canonicalize the pathname of ld\n      ac_prog=`$ECHO \"$ac_prog\"| $SED 's%\\\\\\\\%/%g'`\n      while $ECHO \"$ac_prog\" | $GREP \"$re_direlt\" > /dev/null 2>&1; do\n\tac_prog=`$ECHO $ac_prog| $SED \"s%$re_direlt%/%\"`\n      done\n      test -z \"$LD\" && LD=$ac_prog\n      ;;\n  \"\")\n    # If it fails, then pretend we aren't using GCC.\n    ac_prog=ld\n    ;;\n  *)\n    # If it is relative, then search for the first ld in PATH.\n    with_gnu_ld=unknown\n    ;;\n  esac\nelif test yes = \"$with_gnu_ld\"; then\n  AC_MSG_CHECKING([for GNU ld])\nelse\n  AC_MSG_CHECKING([for non-GNU ld])\nfi\nAC_CACHE_VAL(lt_cv_path_LD,\n[if test -z \"$LD\"; then\n  lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR\n  for ac_dir in $PATH; do\n    IFS=$lt_save_ifs\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n      lt_cv_path_LD=$ac_dir/$ac_prog\n      # Check to see if the program is GNU ld.  I'd rather use --version,\n      # but apparently some variants of GNU ld only accept -v.\n      # Break only if it was the GNU/non-GNU ld that we prefer.\n      case `\"$lt_cv_path_LD\" -v 2>&1 </dev/null` in\n      *GNU* | *'with BFD'*)\n\ttest no != \"$with_gnu_ld\" && break\n\t;;\n      *)\n\ttest yes != \"$with_gnu_ld\" && break\n\t;;\n      esac\n    fi\n  done\n  IFS=$lt_save_ifs\nelse\n  lt_cv_path_LD=$LD # Let the user override the test with a path.\nfi])\nLD=$lt_cv_path_LD\nif test -n \"$LD\"; then\n  AC_MSG_RESULT($LD)\nelse\n  AC_MSG_RESULT(no)\nfi\ntest -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\n_LT_PATH_LD_GNU\nAC_SUBST([LD])\n\n_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])\n])# LT_PATH_LD\n\n# Old names:\nAU_ALIAS([AM_PROG_LD], [LT_PATH_LD])\nAU_ALIAS([AC_PROG_LD], [LT_PATH_LD])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_LD], [])\ndnl AC_DEFUN([AC_PROG_LD], [])\n\n\n# _LT_PATH_LD_GNU\n#- --------------\nm4_defun([_LT_PATH_LD_GNU],\n[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,\n[# I'd rather use --version here, but apparently some GNU lds only accept -v.\ncase `$LD -v 2>&1 </dev/null` in\n*GNU* | *'with BFD'*)\n  lt_cv_prog_gnu_ld=yes\n  ;;\n*)\n  lt_cv_prog_gnu_ld=no\n  ;;\nesac])\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n])# _LT_PATH_LD_GNU\n\n\n# _LT_CMD_RELOAD\n# --------------\n# find reload flag for linker\n#   -- PORTME Some linkers may need a different reload flag.\nm4_defun([_LT_CMD_RELOAD],\n[AC_CACHE_CHECK([for $LD option to reload object files],\n  lt_cv_ld_reload_flag,\n  [lt_cv_ld_reload_flag='-r'])\nreload_flag=$lt_cv_ld_reload_flag\ncase $reload_flag in\n\"\" | \" \"*) ;;\n*) reload_flag=\" $reload_flag\" ;;\nesac\nreload_cmds='$LD$reload_flag -o $output$reload_objs'\ncase $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    if test yes != \"$GCC\"; then\n      reload_cmds=false\n    fi\n    ;;\n  darwin*)\n    if test yes = \"$GCC\"; then\n      reload_cmds='$LTCC $LTCFLAGS -nostdlib $wl-r -o $output$reload_objs'\n    else\n      reload_cmds='$LD$reload_flag -o $output$reload_objs'\n    fi\n    ;;\nesac\n_LT_TAGDECL([], [reload_flag], [1], [How to create reloadable object files])dnl\n_LT_TAGDECL([], [reload_cmds], [2])dnl\n])# _LT_CMD_RELOAD\n\n\n# _LT_PATH_DD\n# -----------\n# find a working dd\nm4_defun([_LT_PATH_DD],\n[AC_CACHE_CHECK([for a working dd], [ac_cv_path_lt_DD],\n[printf 0123456789abcdef0123456789abcdef >conftest.i\ncat conftest.i conftest.i >conftest2.i\n: ${lt_DD:=$DD}\nAC_PATH_PROGS_FEATURE_CHECK([lt_DD], [dd],\n[if \"$ac_path_lt_DD\" bs=32 count=1 <conftest2.i >conftest.out 2>/dev/null; then\n  cmp -s conftest.i conftest.out \\\n  && ac_cv_path_lt_DD=\"$ac_path_lt_DD\" ac_path_lt_DD_found=:\nfi])\nrm -f conftest.i conftest2.i conftest.out])\n])# _LT_PATH_DD\n\n\n# _LT_CMD_TRUNCATE\n# ----------------\n# find command to truncate a binary pipe\nm4_defun([_LT_CMD_TRUNCATE],\n[m4_require([_LT_PATH_DD])\nAC_CACHE_CHECK([how to truncate binary pipes], [lt_cv_truncate_bin],\n[printf 0123456789abcdef0123456789abcdef >conftest.i\ncat conftest.i conftest.i >conftest2.i\nlt_cv_truncate_bin=\nif \"$ac_cv_path_lt_DD\" bs=32 count=1 <conftest2.i >conftest.out 2>/dev/null; then\n  cmp -s conftest.i conftest.out \\\n  && lt_cv_truncate_bin=\"$ac_cv_path_lt_DD bs=4096 count=1\"\nfi\nrm -f conftest.i conftest2.i conftest.out\ntest -z \"$lt_cv_truncate_bin\" && lt_cv_truncate_bin=\"$SED -e 4q\"])\n_LT_DECL([lt_truncate_bin], [lt_cv_truncate_bin], [1],\n  [Command to truncate a binary pipe])\n])# _LT_CMD_TRUNCATE\n\n\n# _LT_CHECK_MAGIC_METHOD\n# ----------------------\n# how to check for library dependencies\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_MAGIC_METHOD],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nAC_CACHE_CHECK([how to recognize dependent libraries],\nlt_cv_deplibs_check_method,\n[lt_cv_file_magic_cmd='$MAGIC_CMD'\nlt_cv_file_magic_test_file=\nlt_cv_deplibs_check_method='unknown'\n# Need to set the preceding variable on all platforms that support\n# interlibrary dependencies.\n# 'none' -- dependencies not supported.\n# 'unknown' -- same as none, but documents that we really don't know.\n# 'pass_all' -- all dependencies passed with no checks.\n# 'test_compile' -- check by making test program.\n# 'file_magic [[regex]]' -- check by looking for files in library path\n# that responds to the $file_magic_cmd with a given extended regex.\n# If you have 'file' or equivalent on your system and you're not sure\n# whether 'pass_all' will *always* work, you probably want this one.\n\ncase $host_os in\naix[[4-9]]*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbeos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbsdi[[45]]*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'\n  lt_cv_file_magic_cmd='/usr/bin/file -L'\n  lt_cv_file_magic_test_file=/shlib/libc.so\n  ;;\n\ncygwin*)\n  # func_win32_libid is a shell function defined in ltmain.sh\n  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n  lt_cv_file_magic_cmd='func_win32_libid'\n  ;;\n\nmingw* | pw32*)\n  # Base MSYS/MinGW do not provide the 'file' command needed by\n  # func_win32_libid shell function, so use a weaker test based on 'objdump',\n  # unless we find 'file', for example because we are cross-compiling.\n  if ( file / ) >/dev/null 2>&1; then\n    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n    lt_cv_file_magic_cmd='func_win32_libid'\n  else\n    # Keep this pattern in sync with the one in func_win32_libid.\n    lt_cv_deplibs_check_method='file_magic file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)'\n    lt_cv_file_magic_cmd='$OBJDUMP -f'\n  fi\n  ;;\n\ncegcc*)\n  # use the weaker test based on 'objdump'. See mingw*.\n  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'\n  lt_cv_file_magic_cmd='$OBJDUMP -f'\n  ;;\n\ndarwin* | rhapsody*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nfreebsd* | dragonfly*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    case $host_cpu in\n    i*86 )\n      # Not sure whether the presence of OpenBSD here was a mistake.\n      # Let's accept both of them until this is cleared up.\n      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'\n      lt_cv_file_magic_cmd=/usr/bin/file\n      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`\n      ;;\n    esac\n  else\n    lt_cv_deplibs_check_method=pass_all\n  fi\n  ;;\n\nhaiku*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhpux10.20* | hpux11*)\n  lt_cv_file_magic_cmd=/usr/bin/file\n  case $host_cpu in\n  ia64*)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'\n    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so\n    ;;\n  hppa*64*)\n    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\\.[0-9]']\n    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl\n    ;;\n  *)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]]\\.[[0-9]]) shared library'\n    lt_cv_file_magic_test_file=/usr/lib/libc.sl\n    ;;\n  esac\n  ;;\n\ninterix[[3-9]]*)\n  # PIC code is broken on Interix 3.x, that's why |\\.a not |_pic\\.a here\n  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|\\.a)$'\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $LD in\n  *-32|*\"-32 \") libmagic=32-bit;;\n  *-n32|*\"-n32 \") libmagic=N32;;\n  *-64|*\"-64 \") libmagic=64-bit;;\n  *) libmagic=never-match;;\n  esac\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\n# This must be glibc/ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nnetbsd* | netbsdelf*-gnu)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|_pic\\.a)$'\n  fi\n  ;;\n\nnewos6*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'\n  lt_cv_file_magic_cmd=/usr/bin/file\n  lt_cv_file_magic_test_file=/usr/lib/libnls.so\n  ;;\n\n*nto* | *qnx*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nopenbsd* | bitrig*)\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\"; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|\\.so|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  fi\n  ;;\n\nosf3* | osf4* | osf5*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nrdos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsolaris*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv4 | sysv4.3*)\n  case $host_vendor in\n  motorola)\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'\n    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`\n    ;;\n  ncr)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  sequent)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'\n    ;;\n  sni)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method=\"file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib\"\n    lt_cv_file_magic_test_file=/lib/libc.so\n    ;;\n  siemens)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  pc)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  esac\n  ;;\n\ntpf*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nos2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nesac\n])\n\nfile_magic_glob=\nwant_nocaseglob=no\nif test \"$build\" = \"$host\"; then\n  case $host_os in\n  mingw* | pw32*)\n    if ( shopt | grep nocaseglob ) >/dev/null 2>&1; then\n      want_nocaseglob=yes\n    else\n      file_magic_glob=`echo aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ | $SED -e \"s/\\(..\\)/s\\/[[\\1]]\\/[[\\1]]\\/g;/g\"`\n    fi\n    ;;\n  esac\nfi\n\nfile_magic_cmd=$lt_cv_file_magic_cmd\ndeplibs_check_method=$lt_cv_deplibs_check_method\ntest -z \"$deplibs_check_method\" && deplibs_check_method=unknown\n\n_LT_DECL([], [deplibs_check_method], [1],\n    [Method to check whether dependent libraries are shared objects])\n_LT_DECL([], [file_magic_cmd], [1],\n    [Command to use when deplibs_check_method = \"file_magic\"])\n_LT_DECL([], [file_magic_glob], [1],\n    [How to find potential files when deplibs_check_method = \"file_magic\"])\n_LT_DECL([], [want_nocaseglob], [1],\n    [Find potential files using nocaseglob when deplibs_check_method = \"file_magic\"])\n])# _LT_CHECK_MAGIC_METHOD\n\n\n# LT_PATH_NM\n# ----------\n# find the pathname to a BSD- or MS-compatible name lister\nAC_DEFUN([LT_PATH_NM],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,\n[if test -n \"$NM\"; then\n  # Let the user override the test.\n  lt_cv_path_NM=$NM\nelse\n  lt_nm_to_check=${ac_tool_prefix}nm\n  if test -n \"$ac_tool_prefix\" && test \"$build\" = \"$host\"; then\n    lt_nm_to_check=\"$lt_nm_to_check nm\"\n  fi\n  for lt_tmp_nm in $lt_nm_to_check; do\n    lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR\n    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do\n      IFS=$lt_save_ifs\n      test -z \"$ac_dir\" && ac_dir=.\n      tmp_nm=$ac_dir/$lt_tmp_nm\n      if test -f \"$tmp_nm\" || test -f \"$tmp_nm$ac_exeext\"; then\n\t# Check to see if the nm accepts a BSD-compat flag.\n\t# Adding the 'sed 1q' prevents false positives on HP-UX, which says:\n\t#   nm: unknown option \"B\" ignored\n\t# Tru64's nm complains that /dev/null is an invalid object file\n\t# MSYS converts /dev/null to NUL, MinGW nm treats NUL as empty\n\tcase $build_os in\n\tmingw*) lt_bad_file=conftest.nm/nofile ;;\n\t*) lt_bad_file=/dev/null ;;\n\tesac\n\tcase `\"$tmp_nm\" -B $lt_bad_file 2>&1 | sed '1q'` in\n\t*$lt_bad_file* | *'Invalid file or object type'*)\n\t  lt_cv_path_NM=\"$tmp_nm -B\"\n\t  break 2\n\t  ;;\n\t*)\n\t  case `\"$tmp_nm\" -p /dev/null 2>&1 | sed '1q'` in\n\t  */dev/null*)\n\t    lt_cv_path_NM=\"$tmp_nm -p\"\n\t    break 2\n\t    ;;\n\t  *)\n\t    lt_cv_path_NM=${lt_cv_path_NM=\"$tmp_nm\"} # keep the first match, but\n\t    continue # so that we can try to find one that supports BSD flags\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n      fi\n    done\n    IFS=$lt_save_ifs\n  done\n  : ${lt_cv_path_NM=no}\nfi])\nif test no != \"$lt_cv_path_NM\"; then\n  NM=$lt_cv_path_NM\nelse\n  # Didn't find any BSD compatible name lister, look for dumpbin.\n  if test -n \"$DUMPBIN\"; then :\n    # Let the user override the test.\n  else\n    AC_CHECK_TOOLS(DUMPBIN, [dumpbin \"link -dump\"], :)\n    case `$DUMPBIN -symbols -headers /dev/null 2>&1 | sed '1q'` in\n    *COFF*)\n      DUMPBIN=\"$DUMPBIN -symbols -headers\"\n      ;;\n    *)\n      DUMPBIN=:\n      ;;\n    esac\n  fi\n  AC_SUBST([DUMPBIN])\n  if test : != \"$DUMPBIN\"; then\n    NM=$DUMPBIN\n  fi\nfi\ntest -z \"$NM\" && NM=nm\nAC_SUBST([NM])\n_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl\n\nAC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],\n  [lt_cv_nm_interface=\"BSD nm\"\n  echo \"int some_variable = 0;\" > conftest.$ac_ext\n  (eval echo \"\\\"\\$as_me:$LINENO: $ac_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$ac_compile\" 2>conftest.err)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: output\\\"\" >&AS_MESSAGE_LOG_FD)\n  cat conftest.out >&AS_MESSAGE_LOG_FD\n  if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n    lt_cv_nm_interface=\"MS dumpbin\"\n  fi\n  rm -f conftest*])\n])# LT_PATH_NM\n\n# Old names:\nAU_ALIAS([AM_PROG_NM], [LT_PATH_NM])\nAU_ALIAS([AC_PROG_NM], [LT_PATH_NM])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_NM], [])\ndnl AC_DEFUN([AC_PROG_NM], [])\n\n# _LT_CHECK_SHAREDLIB_FROM_LINKLIB\n# --------------------------------\n# how to determine the name of the shared library\n# associated with a specific link library.\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_SHAREDLIB_FROM_LINKLIB],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nm4_require([_LT_DECL_DLLTOOL])\nAC_CACHE_CHECK([how to associate runtime and link libraries],\nlt_cv_sharedlib_from_linklib_cmd,\n[lt_cv_sharedlib_from_linklib_cmd='unknown'\n\ncase $host_os in\ncygwin* | mingw* | pw32* | cegcc*)\n  # two different shell functions defined in ltmain.sh;\n  # decide which one to use based on capabilities of $DLLTOOL\n  case `$DLLTOOL --help 2>&1` in\n  *--identify-strict*)\n    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib\n    ;;\n  *)\n    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib_fallback\n    ;;\n  esac\n  ;;\n*)\n  # fallback: assume linklib IS sharedlib\n  lt_cv_sharedlib_from_linklib_cmd=$ECHO\n  ;;\nesac\n])\nsharedlib_from_linklib_cmd=$lt_cv_sharedlib_from_linklib_cmd\ntest -z \"$sharedlib_from_linklib_cmd\" && sharedlib_from_linklib_cmd=$ECHO\n\n_LT_DECL([], [sharedlib_from_linklib_cmd], [1],\n    [Command to associate shared and link libraries])\n])# _LT_CHECK_SHAREDLIB_FROM_LINKLIB\n\n\n# _LT_PATH_MANIFEST_TOOL\n# ----------------------\n# locate the manifest tool\nm4_defun([_LT_PATH_MANIFEST_TOOL],\n[AC_CHECK_TOOL(MANIFEST_TOOL, mt, :)\ntest -z \"$MANIFEST_TOOL\" && MANIFEST_TOOL=mt\nAC_CACHE_CHECK([if $MANIFEST_TOOL is a manifest tool], [lt_cv_path_mainfest_tool],\n  [lt_cv_path_mainfest_tool=no\n  echo \"$as_me:$LINENO: $MANIFEST_TOOL '-?'\" >&AS_MESSAGE_LOG_FD\n  $MANIFEST_TOOL '-?' 2>conftest.err > conftest.out\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  if $GREP 'Manifest Tool' conftest.out > /dev/null; then\n    lt_cv_path_mainfest_tool=yes\n  fi\n  rm -f conftest*])\nif test yes != \"$lt_cv_path_mainfest_tool\"; then\n  MANIFEST_TOOL=:\nfi\n_LT_DECL([], [MANIFEST_TOOL], [1], [Manifest tool])dnl\n])# _LT_PATH_MANIFEST_TOOL\n\n\n# _LT_DLL_DEF_P([FILE])\n# ---------------------\n# True iff FILE is a Windows DLL '.def' file.\n# Keep in sync with func_dll_def_p in the libtool script\nAC_DEFUN([_LT_DLL_DEF_P],\n[dnl\n  test DEF = \"`$SED -n dnl\n    -e '\\''s/^[[\t ]]*//'\\'' dnl Strip leading whitespace\n    -e '\\''/^\\(;.*\\)*$/d'\\'' dnl      Delete empty lines and comments\n    -e '\\''s/^\\(EXPORTS\\|LIBRARY\\)\\([[\t ]].*\\)*$/DEF/p'\\'' dnl\n    -e q dnl                          Only consider the first \"real\" line\n    $1`\" dnl\n])# _LT_DLL_DEF_P\n\n\n# LT_LIB_M\n# --------\n# check for math library\nAC_DEFUN([LT_LIB_M],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nLIBM=\ncase $host in\n*-*-beos* | *-*-cegcc* | *-*-cygwin* | *-*-haiku* | *-*-pw32* | *-*-darwin*)\n  # These system don't have libm, or don't need it\n  ;;\n*-ncr-sysv4.3*)\n  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=-lmw)\n  AC_CHECK_LIB(m, cos, LIBM=\"$LIBM -lm\")\n  ;;\n*)\n  AC_CHECK_LIB(m, cos, LIBM=-lm)\n  ;;\nesac\nAC_SUBST([LIBM])\n])# LT_LIB_M\n\n# Old name:\nAU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_CHECK_LIBM], [])\n\n\n# _LT_COMPILER_NO_RTTI([TAGNAME])\n# -------------------------------\nm4_defun([_LT_COMPILER_NO_RTTI],\n[m4_require([_LT_TAG_COMPILER])dnl\n\n_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n\nif test yes = \"$GCC\"; then\n  case $cc_basename in\n  nvcc*)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -Xcompiler -fno-builtin' ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin' ;;\n  esac\n\n  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],\n    lt_cv_prog_compiler_rtti_exceptions,\n    [-fno-rtti -fno-exceptions], [],\n    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\"$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions\"])\nfi\n_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],\n\t[Compiler flag to turn off builtin functions])\n])# _LT_COMPILER_NO_RTTI\n\n\n# _LT_CMD_GLOBAL_SYMBOLS\n# ----------------------\nm4_defun([_LT_CMD_GLOBAL_SYMBOLS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_PROG_AWK])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_TAG_COMPILER])dnl\n\n# Check for command to grab the raw symbol name followed by C symbol from nm.\nAC_MSG_CHECKING([command to parse $NM output from $compiler object])\nAC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],\n[\n# These are sane defaults that work on at least a few old systems.\n# [They come from Ultrix.  What could be older than Ultrix?!! ;)]\n\n# Character class describing NM global symbol codes.\nsymcode='[[BCDEGRST]]'\n\n# Regexp to match symbols that can be accessed directly from C.\nsympat='\\([[_A-Za-z]][[_A-Za-z0-9]]*\\)'\n\n# Define system-specific variables.\ncase $host_os in\naix*)\n  symcode='[[BCDT]]'\n  ;;\ncygwin* | mingw* | pw32* | cegcc*)\n  symcode='[[ABCDGISTW]]'\n  ;;\nhpux*)\n  if test ia64 = \"$host_cpu\"; then\n    symcode='[[ABCDEGRST]]'\n  fi\n  ;;\nirix* | nonstopux*)\n  symcode='[[BCDEGRST]]'\n  ;;\nosf*)\n  symcode='[[BCDEGQRST]]'\n  ;;\nsolaris*)\n  symcode='[[BDRT]]'\n  ;;\nsco3.2v5*)\n  symcode='[[DT]]'\n  ;;\nsysv4.2uw2*)\n  symcode='[[DT]]'\n  ;;\nsysv5* | sco5v6* | unixware* | OpenUNIX*)\n  symcode='[[ABDT]]'\n  ;;\nsysv4)\n  symcode='[[DFNSTU]]'\n  ;;\nesac\n\n# If we're using GNU nm, then use its standard symbol codes.\ncase `$NM -V 2>&1` in\n*GNU* | *'with BFD'*)\n  symcode='[[ABCDGIRSTW]]' ;;\nesac\n\nif test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n  # Gets list of data symbols to import.\n  lt_cv_sys_global_symbol_to_import=\"sed -n -e 's/^I .* \\(.*\\)$/\\1/p'\"\n  # Adjust the below global symbol transforms to fixup imported variables.\n  lt_cdecl_hook=\" -e 's/^I .* \\(.*\\)$/extern __declspec(dllimport) char \\1;/p'\"\n  lt_c_name_hook=\" -e 's/^I .* \\(.*\\)$/  {\\\"\\1\\\", (void *) 0},/p'\"\n  lt_c_name_lib_hook=\"\\\n  -e 's/^I .* \\(lib.*\\)$/  {\\\"\\1\\\", (void *) 0},/p'\\\n  -e 's/^I .* \\(.*\\)$/  {\\\"lib\\1\\\", (void *) 0},/p'\"\nelse\n  # Disable hooks by default.\n  lt_cv_sys_global_symbol_to_import=\n  lt_cdecl_hook=\n  lt_c_name_hook=\n  lt_c_name_lib_hook=\nfi\n\n# Transform an extracted symbol line into a proper C declaration.\n# Some systems (esp. on ia64) link data and code symbols differently,\n# so use this general approach.\nlt_cv_sys_global_symbol_to_cdecl=\"sed -n\"\\\n$lt_cdecl_hook\\\n\" -e 's/^T .* \\(.*\\)$/extern int \\1();/p'\"\\\n\" -e 's/^$symcode$symcode* .* \\(.*\\)$/extern char \\1;/p'\"\n\n# Transform an extracted symbol line into symbol name and symbol address\nlt_cv_sys_global_symbol_to_c_name_address=\"sed -n\"\\\n$lt_c_name_hook\\\n\" -e 's/^: \\(.*\\) .*$/  {\\\"\\1\\\", (void *) 0},/p'\"\\\n\" -e 's/^$symcode$symcode* .* \\(.*\\)$/  {\\\"\\1\\\", (void *) \\&\\1},/p'\"\n\n# Transform an extracted symbol line into symbol name with lib prefix and\n# symbol address.\nlt_cv_sys_global_symbol_to_c_name_address_lib_prefix=\"sed -n\"\\\n$lt_c_name_lib_hook\\\n\" -e 's/^: \\(.*\\) .*$/  {\\\"\\1\\\", (void *) 0},/p'\"\\\n\" -e 's/^$symcode$symcode* .* \\(lib.*\\)$/  {\\\"\\1\\\", (void *) \\&\\1},/p'\"\\\n\" -e 's/^$symcode$symcode* .* \\(.*\\)$/  {\\\"lib\\1\\\", (void *) \\&\\1},/p'\"\n\n# Handle CRLF in mingw tool chain\nopt_cr=\ncase $build_os in\nmingw*)\n  opt_cr=`$ECHO 'x\\{0,1\\}' | tr x '\\015'` # option cr in regexp\n  ;;\nesac\n\n# Try without a prefix underscore, then with it.\nfor ac_symprfx in \"\" \"_\"; do\n\n  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.\n  symxfrm=\"\\\\1 $ac_symprfx\\\\2 \\\\2\"\n\n  # Write the raw and C identifiers.\n  if test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n    # Fake it for dumpbin and say T for any non-static function,\n    # D for any global variable and I for any imported variable.\n    # Also find C++ and __fastcall symbols from MSVC++,\n    # which start with @ or ?.\n    lt_cv_sys_global_symbol_pipe=\"$AWK ['\"\\\n\"     {last_section=section; section=\\$ 3};\"\\\n\"     /^COFF SYMBOL TABLE/{for(i in hide) delete hide[i]};\"\\\n\"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};\"\\\n\"     /^ *Symbol name *: /{split(\\$ 0,sn,\\\":\\\"); si=substr(sn[2],2)};\"\\\n\"     /^ *Type *: code/{print \\\"T\\\",si,substr(si,length(prfx))};\"\\\n\"     /^ *Type *: data/{print \\\"I\\\",si,substr(si,length(prfx))};\"\\\n\"     \\$ 0!~/External *\\|/{next};\"\\\n\"     / 0+ UNDEF /{next}; / UNDEF \\([^|]\\)*()/{next};\"\\\n\"     {if(hide[section]) next};\"\\\n\"     {f=\\\"D\\\"}; \\$ 0~/\\(\\).*\\|/{f=\\\"T\\\"};\"\\\n\"     {split(\\$ 0,a,/\\||\\r/); split(a[2],s)};\"\\\n\"     s[1]~/^[@?]/{print f,s[1],s[1]; next};\"\\\n\"     s[1]~prfx {split(s[1],t,\\\"@\\\"); print f,t[1],substr(t[1],length(prfx))}\"\\\n\"     ' prfx=^$ac_symprfx]\"\n  else\n    lt_cv_sys_global_symbol_pipe=\"sed -n -e 's/^.*[[\t ]]\\($symcode$symcode*\\)[[\t ]][[\t ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'\"\n  fi\n  lt_cv_sys_global_symbol_pipe=\"$lt_cv_sys_global_symbol_pipe | sed '/ __gnu_lto/d'\"\n\n  # Check to see that the pipe works correctly.\n  pipe_works=no\n\n  rm -f conftest*\n  cat > conftest.$ac_ext <<_LT_EOF\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nchar nm_test_var;\nvoid nm_test_func(void);\nvoid nm_test_func(void){}\n#ifdef __cplusplus\n}\n#endif\nint main(){nm_test_var='a';nm_test_func();return(0);}\n_LT_EOF\n\n  if AC_TRY_EVAL(ac_compile); then\n    # Now try to grab the symbols.\n    nlist=conftest.nm\n    if AC_TRY_EVAL(NM conftest.$ac_objext \\| \"$lt_cv_sys_global_symbol_pipe\" \\> $nlist) && test -s \"$nlist\"; then\n      # Try sorting and uniquifying the output.\n      if sort \"$nlist\" | uniq > \"$nlist\"T; then\n\tmv -f \"$nlist\"T \"$nlist\"\n      else\n\trm -f \"$nlist\"T\n      fi\n\n      # Make sure that we snagged all the symbols we need.\n      if $GREP ' nm_test_var$' \"$nlist\" >/dev/null; then\n\tif $GREP ' nm_test_func$' \"$nlist\" >/dev/null; then\n\t  cat <<_LT_EOF > conftest.$ac_ext\n/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */\n#if defined _WIN32 || defined __CYGWIN__ || defined _WIN32_WCE\n/* DATA imports from DLLs on WIN32 can't be const, because runtime\n   relocations are performed -- see ld's documentation on pseudo-relocs.  */\n# define LT@&t@_DLSYM_CONST\n#elif defined __osf__\n/* This system does not cope well with relocations in const data.  */\n# define LT@&t@_DLSYM_CONST\n#else\n# define LT@&t@_DLSYM_CONST const\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n_LT_EOF\n\t  # Now generate the symbol file.\n\t  eval \"$lt_cv_sys_global_symbol_to_cdecl\"' < \"$nlist\" | $GREP -v main >> conftest.$ac_ext'\n\n\t  cat <<_LT_EOF >> conftest.$ac_ext\n\n/* The mapping between symbol names and symbols.  */\nLT@&t@_DLSYM_CONST struct {\n  const char *name;\n  void       *address;\n}\nlt__PROGRAM__LTX_preloaded_symbols[[]] =\n{\n  { \"@PROGRAM@\", (void *) 0 },\n_LT_EOF\n\t  $SED \"s/^$symcode$symcode* .* \\(.*\\)$/  {\\\"\\1\\\", (void *) \\&\\1},/\" < \"$nlist\" | $GREP -v main >> conftest.$ac_ext\n\t  cat <<\\_LT_EOF >> conftest.$ac_ext\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt__PROGRAM__LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n_LT_EOF\n\t  # Now try linking the two files.\n\t  mv conftest.$ac_objext conftstm.$ac_objext\n\t  lt_globsym_save_LIBS=$LIBS\n\t  lt_globsym_save_CFLAGS=$CFLAGS\n\t  LIBS=conftstm.$ac_objext\n\t  CFLAGS=\"$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)\"\n\t  if AC_TRY_EVAL(ac_link) && test -s conftest$ac_exeext; then\n\t    pipe_works=yes\n\t  fi\n\t  LIBS=$lt_globsym_save_LIBS\n\t  CFLAGS=$lt_globsym_save_CFLAGS\n\telse\n\t  echo \"cannot find nm_test_func in $nlist\" >&AS_MESSAGE_LOG_FD\n\tfi\n      else\n\techo \"cannot find nm_test_var in $nlist\" >&AS_MESSAGE_LOG_FD\n      fi\n    else\n      echo \"cannot run $lt_cv_sys_global_symbol_pipe\" >&AS_MESSAGE_LOG_FD\n    fi\n  else\n    echo \"$progname: failed program was:\" >&AS_MESSAGE_LOG_FD\n    cat conftest.$ac_ext >&5\n  fi\n  rm -rf conftest* conftst*\n\n  # Do not use the global_symbol_pipe unless it works.\n  if test yes = \"$pipe_works\"; then\n    break\n  else\n    lt_cv_sys_global_symbol_pipe=\n  fi\ndone\n])\nif test -z \"$lt_cv_sys_global_symbol_pipe\"; then\n  lt_cv_sys_global_symbol_to_cdecl=\nfi\nif test -z \"$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl\"; then\n  AC_MSG_RESULT(failed)\nelse\n  AC_MSG_RESULT(ok)\nfi\n\n# Response file support.\nif test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n  nm_file_list_spec='@'\nelif $NM --help 2>/dev/null | grep '[[@]]FILE' >/dev/null; then\n  nm_file_list_spec='@'\nfi\n\n_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],\n    [Take the output of nm and produce a listing of raw symbols and C names])\n_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],\n    [Transform the output of nm in a proper C declaration])\n_LT_DECL([global_symbol_to_import], [lt_cv_sys_global_symbol_to_import], [1],\n    [Transform the output of nm into a list of symbols to manually relocate])\n_LT_DECL([global_symbol_to_c_name_address],\n    [lt_cv_sys_global_symbol_to_c_name_address], [1],\n    [Transform the output of nm in a C name address pair])\n_LT_DECL([global_symbol_to_c_name_address_lib_prefix],\n    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],\n    [Transform the output of nm in a C name address pair when lib prefix is needed])\n_LT_DECL([nm_interface], [lt_cv_nm_interface], [1],\n    [The name lister interface])\n_LT_DECL([], [nm_file_list_spec], [1],\n    [Specify filename containing input files for $NM])\n]) # _LT_CMD_GLOBAL_SYMBOLS\n\n\n# _LT_COMPILER_PIC([TAGNAME])\n# ---------------------------\nm4_defun([_LT_COMPILER_PIC],\n[m4_require([_LT_TAG_COMPILER])dnl\n_LT_TAGVAR(lt_prog_compiler_wl, $1)=\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n_LT_TAGVAR(lt_prog_compiler_static, $1)=\n\nm4_if([$1], [CXX], [\n  # C++ specific cases for pic, static, wl, etc.\n  if test yes = \"$GXX\"; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n    aix*)\n      # All AIX code is PIC.\n      if test ia64 = \"$host_cpu\"; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the '-m68020' flag to GCC prevents building anything better,\n            # like '-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n    mingw* | cygwin* | os2* | pw32* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      case $host_os in\n      os2*)\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-static'\n\t;;\n      esac\n      ;;\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n    *djgpp*)\n      # DJGPP does not support shared libraries at all\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n      ;;\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n    *qnx* | *nto*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    case $host_os in\n      aix[[4-9]]*)\n\t# All AIX code is PIC.\n\tif test ia64 = \"$host_cpu\"; then\n\t  # AIX 5 now supports IA64 processor\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\telse\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n\tfi\n\t;;\n      chorus*)\n\tcase $cc_basename in\n\tcxch68*)\n\t  # Green Hills C++ Compiler\n\t  # _LT_TAGVAR(lt_prog_compiler_static, $1)=\"--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a\"\n\t  ;;\n\tesac\n\t;;\n      mingw* | cygwin* | os2* | pw32* | cegcc*)\n\t# This hack is so that the source file can tell whether it is being\n\t# built for inclusion in a dll (and should export symbols for example).\n\tm4_if([$1], [GCJ], [],\n\t  [_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n\t;;\n      dgux*)\n\tcase $cc_basename in\n\t  ec++*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  ghcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      freebsd* | dragonfly*)\n\t# FreeBSD uses GNU C++\n\t;;\n      hpux9* | hpux10* | hpux11*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-a ${wl}archive'\n\t    if test ia64 != \"$host_cpu\"; then\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t    fi\n\t    ;;\n\t  aCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-a ${wl}archive'\n\t    case $host_cpu in\n\t    hppa*64*|ia64*)\n\t      # +Z the default\n\t      ;;\n\t    *)\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t      ;;\n\t    esac\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      interix*)\n\t# This is c89, which is MS Visual C++ (no shared libs)\n\t# Anyone wants to do a port?\n\t;;\n      irix5* | irix6* | nonstopux*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    # CC pic flag -KPIC is the default.\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    # KAI C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    ;;\n\t  ecpc* )\n\t    # old Intel C++ for x86_64, which still supported -KPIC.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  icpc* )\n\t    # Intel C++, used to be incompatible with GCC.\n\t    # ICC 10 doesn't accept -KPIC any more.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  pgCC* | pgcpp*)\n\t    # Portland Group C++ compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  xlc* | xlC* | bgxl[[cC]]* | mpixl[[cC]]*)\n\t    # IBM XL 8.0, 9.0 on PPC and BlueGene\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n      lynxos*)\n\t;;\n      m88k*)\n\t;;\n      mvs*)\n\tcase $cc_basename in\n\t  cxx*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      netbsd* | netbsdelf*-gnu)\n\t;;\n      *qnx* | *nto*)\n        # QNX uses GNU C++, but need to define -shared option too, otherwise\n        # it will coredump.\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n        ;;\n      osf3* | osf4* | osf5*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    ;;\n\t  RCC*)\n\t    # Rational C++ 2.4.1\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  cxx*)\n\t    # Digital/Compaq C++\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      psos*)\n\t;;\n      solaris*)\n\tcase $cc_basename in\n\t  CC* | sunCC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t    ;;\n\t  gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sunos4*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.x\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  lcc*)\n\t    # Lucid\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\tesac\n\t;;\n      tandem*)\n\tcase $cc_basename in\n\t  NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      vxworks*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n\t;;\n    esac\n  fi\n],\n[\n  if test yes = \"$GCC\"; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n      aix*)\n      # All AIX code is PIC.\n      if test ia64 = \"$host_cpu\"; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the '-m68020' flag to GCC prevents building anything better,\n            # like '-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      case $host_os in\n      os2*)\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-static'\n\t;;\n      esac\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n\n    msdosdjgpp*)\n      # Just because we use GCC doesn't mean we suddenly get shared libraries\n      # on systems that don't support them.\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      enable_shared=no\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n\n    case $cc_basename in\n    nvcc*) # Cuda Compiler Driver 2.2\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Xlinker '\n      if test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"-Xcompiler $_LT_TAGVAR(lt_prog_compiler_pic, $1)\"\n      fi\n      ;;\n    esac\n  else\n    # PORTME Check for flag to pass linker flags through the system compiler.\n    case $host_os in\n    aix*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      if test ia64 = \"$host_cpu\"; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      else\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n      fi\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      case $cc_basename in\n      nagfor*)\n        # NAG Fortran compiler\n        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,-Wl,,'\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n        _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      esac\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      case $host_os in\n      os2*)\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-static'\n\t;;\n      esac\n      ;;\n\n    hpux9* | hpux10* | hpux11*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but\n      # not for PA HP-UX.\n      case $host_cpu in\n      hppa*64*|ia64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t;;\n      esac\n      # Is there a better lt_prog_compiler_static that works with the bundled CC?\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-a ${wl}archive'\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC (with -KPIC) is the default.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n      case $cc_basename in\n      # old Intel for x86_64, which still supported -KPIC.\n      ecc*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # icc used to be incompatible with GCC.\n      # ICC 10 doesn't accept -KPIC any more.\n      icc* | ifort*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # Lahey Fortran 8.1.\n      lf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'\n\t;;\n      nagfor*)\n\t# NAG Fortran compiler\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,-Wl,,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t;;\n      tcc*)\n\t# Fabrice Bellard et al's Tiny C Compiler\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t;;\n      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)\n        # Portland Group compilers (*not* the Pentium gcc compiler,\n\t# which looks to be a dead project)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      ccc*)\n        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n        # All Alpha code is PIC.\n        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n        ;;\n      xl* | bgxl* | bgf* | mpixl*)\n\t# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t;;\n      *)\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ Ceres\\ Fortran* | *Sun*Fortran*\\ [[1-7]].* | *Sun*Fortran*\\ 8.[[0-3]]*)\n\t  # Sun Fortran 8.3 passes all unrecognized flags to the linker\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''\n\t  ;;\n\t*Sun\\ F* | *Sun*Fortran*)\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t  ;;\n\t*Sun\\ C*)\n\t  # Sun C 5.9\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  ;;\n        *Intel*\\ [[CF]]*Compiler*)\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t  ;;\n\t*Portland\\ Group*)\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  ;;\n\tesac\n\t;;\n      esac\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    osf3* | osf4* | osf5*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # All OSF/1 code is PIC.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    rdos*)\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      case $cc_basename in\n      f77* | f90* | f95* | sunf77* | sunf90* | sunf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4 | sysv4.2uw2* | sysv4.3*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    unicos*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n    esac\n  fi\n])\ncase $host_os in\n  # For platforms that do not support PIC, -DPIC is meaningless:\n  *djgpp*)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n    ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])\"\n    ;;\nesac\n\nAC_CACHE_CHECK([for $compiler option to produce PIC],\n  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_prog_compiler_pic, $1)])\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)\n\n#\n# Check to make sure the PIC flag actually works.\n#\nif test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],\n    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],\n    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],\n    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in\n     \"\" | \" \"*) ;;\n     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=\" $_LT_TAGVAR(lt_prog_compiler_pic, $1)\" ;;\n     esac],\n    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])\nfi\n_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],\n\t[Additional compiler flags for building library objects])\n\n_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],\n\t[How to pass a linker flag through the compiler])\n#\n# Check to make sure the static flag actually works.\n#\nwl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\\\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\\\"\n_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],\n  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),\n  $lt_tmp_static_flag,\n  [],\n  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])\n_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],\n\t[Compiler flag to prevent dynamic linking])\n])# _LT_COMPILER_PIC\n\n\n# _LT_LINKER_SHLIBS([TAGNAME])\n# ----------------------------\n# See if the linker supports building shared libraries.\nm4_defun([_LT_LINKER_SHLIBS],\n[AC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nm4_require([_LT_PATH_MANIFEST_TOOL])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\nm4_if([$1], [CXX], [\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  case $host_os in\n  aix[[4-9]]*)\n    # If we're using GNU nm, then we don't want the \"-C\" option.\n    # -C means demangle to GNU nm, but means don't demangle to AIX nm.\n    # Without the \"-l\" option, or with the \"-B\" option, AIX nm treats\n    # weak defined symbols like other global defined symbols, whereas\n    # GNU nm marks them as \"W\".\n    # While the 'weak' keyword is ignored in the Export File, we need\n    # it in the Import File for the 'aix-soname' feature, so we have\n    # to replace the \"-B\" option with \"-P\" for AIX nm.\n    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { if (\\$ 2 == \"W\") { print \\$ 3 \" weak\" } else { print \\$ 3 } } }'\\'' | sort -u > $export_symbols'\n    else\n      _LT_TAGVAR(export_symbols_cmds, $1)='`func_echo_all $NM | $SED -e '\\''s/B\\([[^B]]*\\)$/P\\1/'\\''` -PCpgl $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\") || (\\$ 2 == \"V\") || (\\$ 2 == \"Z\")) && ([substr](\\$ 1,1,1) != \".\")) { if ((\\$ 2 == \"W\") || (\\$ 2 == \"V\") || (\\$ 2 == \"Z\")) { print \\$ 1 \" weak\" } else { print \\$ 1 } } }'\\'' | sort -u > $export_symbols'\n    fi\n    ;;\n  pw32*)\n    _LT_TAGVAR(export_symbols_cmds, $1)=$ltdll_cmds\n    ;;\n  cygwin* | mingw* | cegcc*)\n    case $cc_basename in\n    cl*)\n      _LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'\n      ;;\n    *)\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']\n      ;;\n    esac\n    ;;\n  linux* | k*bsd*-gnu | gnu*)\n    _LT_TAGVAR(link_all_deplibs, $1)=no\n    ;;\n  *)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n    ;;\n  esac\n], [\n  runpath_var=\n  _LT_TAGVAR(allow_undefined_flag, $1)=\n  _LT_TAGVAR(always_export_symbols, $1)=no\n  _LT_TAGVAR(archive_cmds, $1)=\n  _LT_TAGVAR(archive_expsym_cmds, $1)=\n  _LT_TAGVAR(compiler_needs_object, $1)=no\n  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n  _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(hardcode_automatic, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_direct_absolute, $1)=no\n  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n  _LT_TAGVAR(hardcode_minus_L, $1)=no\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_TAGVAR(inherit_rpath, $1)=no\n  _LT_TAGVAR(link_all_deplibs, $1)=unknown\n  _LT_TAGVAR(module_cmds, $1)=\n  _LT_TAGVAR(module_expsym_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_new_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=\n  _LT_TAGVAR(thread_safe_flag_spec, $1)=\n  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n  # include_expsyms should be a list of space-separated symbols to be *always*\n  # included in the symbol list\n  _LT_TAGVAR(include_expsyms, $1)=\n  # exclude_expsyms can be an extended regexp of symbols to exclude\n  # it will be wrapped by ' (' and ')$', so one must not match beginning or\n  # end of line.  Example: 'a|bc|.*d.*' will exclude the symbols 'a' and 'bc',\n  # as well as any symbol that contains 'd'.\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out\n  # platforms (ab)use it in PIC code, but their linkers get confused if\n  # the symbol is explicitly referenced.  Since portable code cannot\n  # rely on this symbol name, it's probably fine to never include it in\n  # preloaded symbol tables.\n  # Exclude shared library initialization/finalization symbols.\ndnl Note also adjust exclude_expsyms for C++ above.\n  extract_expsyms_cmds=\n\n  case $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    # FIXME: the MSVC++ port hasn't been tested in a loooong time\n    # When not using gcc, we currently assume that we are using\n    # Microsoft Visual C++.\n    if test yes != \"$GCC\"; then\n      with_gnu_ld=no\n    fi\n    ;;\n  interix*)\n    # we just hope/assume this is gcc and not c89 (= MSVC++)\n    with_gnu_ld=yes\n    ;;\n  openbsd* | bitrig*)\n    with_gnu_ld=no\n    ;;\n  linux* | k*bsd*-gnu | gnu*)\n    _LT_TAGVAR(link_all_deplibs, $1)=no\n    ;;\n  esac\n\n  _LT_TAGVAR(ld_shlibs, $1)=yes\n\n  # On some targets, GNU ld is compatible enough with the native linker\n  # that we're better off using the native interface for both.\n  lt_use_gnu_ld_interface=no\n  if test yes = \"$with_gnu_ld\"; then\n    case $host_os in\n      aix*)\n\t# The AIX port of GNU ld has always aspired to compatibility\n\t# with the native linker.  However, as the warning in the GNU ld\n\t# block says, versions before 2.19.5* couldn't really create working\n\t# shared libraries, regardless of the interface used.\n\tcase `$LD -v 2>&1` in\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.19.5*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.[[2-9]]*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ [[3-9]]*) ;;\n\t  *)\n\t    lt_use_gnu_ld_interface=yes\n\t    ;;\n\tesac\n\t;;\n      *)\n\tlt_use_gnu_ld_interface=yes\n\t;;\n    esac\n  fi\n\n  if test yes = \"$lt_use_gnu_ld_interface\"; then\n    # If archive_cmds runs LD, not CC, wlarc should be empty\n    wlarc='$wl'\n\n    # Set some defaults for GNU ld with shared library support. These\n    # are reset later if shared libraries are not supported. Putting them\n    # here allows them to be overridden if necessary.\n    runpath_var=LD_RUN_PATH\n    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n    # ancient GNU ld didn't support --whole-archive et. al.\n    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=$wlarc'--whole-archive$convenience '$wlarc'--no-whole-archive'\n    else\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n    supports_anon_versioning=no\n    case `$LD -v | $SED -e 's/([^)]\\+)\\s\\+//' 2>&1` in\n      *GNU\\ gold*) supports_anon_versioning=yes ;;\n      *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.10.*) ;; # catch versions < 2.11\n      *\\ 2.11.93.0.2\\ *) supports_anon_versioning=yes ;; # RH7.3 ...\n      *\\ 2.11.92.0.12\\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...\n      *\\ 2.11.*) ;; # other 2.11 versions\n      *) supports_anon_versioning=yes ;;\n    esac\n\n    # See if GNU ld supports shared libraries.\n    case $host_os in\n    aix[[3-9]]*)\n      # On AIX/PPC, the GNU linker is very broken\n      if test ia64 != \"$host_cpu\"; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: the GNU linker, at least up to release 2.19, is reported\n*** to be unable to reliably create shared libraries on AIX.\n*** Therefore, libtool is disabling shared libraries support.  If you\n*** really care for shared libraries, you may want to install binutils\n*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.\n*** You will then need to restart the configuration process.\n\n_LT_EOF\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    beos*)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t# support --undefined.  This deserves some investigation.  FIXME\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n      # as there is no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-all-symbols'\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=no\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']\n\n      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t# If the export-symbols file already is a .def file, use it as\n\t# is; otherwise, prepend EXPORTS...\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then\n          cp $export_symbols $output_objdir/$soname.def;\n        else\n          echo EXPORTS > $output_objdir/$soname.def;\n          cat $export_symbols >> $output_objdir/$soname.def;\n        fi~\n        $CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    haiku*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    os2*)\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      shrext_cmds=.dll\n      _LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t$ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t$ECHO EXPORTS >> $output_objdir/$libname.def~\n\temxexp $libobjs | $SED /\"_DLL_InitTerm\"/d >> $output_objdir/$libname.def~\n\t$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\temximp -o $lib $output_objdir/$libname.def'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t$ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t$ECHO EXPORTS >> $output_objdir/$libname.def~\n\tprefix_cmds=\"$SED\"~\n\tif test EXPORTS = \"`$SED 1q $export_symbols`\"; then\n\t  prefix_cmds=\"$prefix_cmds -e 1d\";\n\tfi~\n\tprefix_cmds=\"$prefix_cmds -e \\\"s/^\\(.*\\)$/_\\1/g\\\"\"~\n\tcat $export_symbols | $prefix_cmds >> $output_objdir/$libname.def~\n\t$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\temximp -o $lib $output_objdir/$libname.def'\n      _LT_TAGVAR(old_archive_From_new_cmds, $1)='emximp -o $output_objdir/${libname}_dll.a $output_objdir/$libname.def'\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      ;;\n\n    interix[[3-9]]*)\n      _LT_TAGVAR(hardcode_direct, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n      # Instead, shared libraries are loaded at an image base (0x10000000 by\n      # default) and relocated if they conflict, which is a slow very memory\n      # consuming and fragmenting process.  To avoid this, we pick a random,\n      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s|^|_|\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--retain-symbols-file,$output_objdir/$soname.expsym $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      ;;\n\n    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)\n      tmp_diet=no\n      if test linux-dietlibc = \"$host_os\"; then\n\tcase $cc_basename in\n\t  diet\\ *) tmp_diet=yes;;\t# linux-dietlibc with static linking (!diet-dyn)\n\tesac\n      fi\n      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \\\n\t && test no = \"$tmp_diet\"\n      then\n\ttmp_addflag=' $pic_flag'\n\ttmp_sharedflag='-shared'\n\tcase $cc_basename,$host_cpu in\n        pgcc*)\t\t\t\t# Portland Group C compiler\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n\t  tmp_addflag=' $pic_flag'\n\t  ;;\n\tpgf77* | pgf90* | pgf95* | pgfortran*)\n\t\t\t\t\t# Portland Group f77 and f90 compilers\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n\t  tmp_addflag=' $pic_flag -Mnomain' ;;\n\tecc*,ia64* | icc*,ia64*)\t# Intel C compiler on ia64\n\t  tmp_addflag=' -i_dynamic' ;;\n\tefc*,ia64* | ifort*,ia64*)\t# Intel Fortran compiler on ia64\n\t  tmp_addflag=' -i_dynamic -nofor_main' ;;\n\tifc* | ifort*)\t\t\t# Intel Fortran compiler\n\t  tmp_addflag=' -nofor_main' ;;\n\tlf95*)\t\t\t\t# Lahey Fortran 8.1\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n\t  tmp_sharedflag='--shared' ;;\n        nagfor*)                        # NAGFOR 5.3\n          tmp_sharedflag='-Wl,-shared' ;;\n\txl[[cC]]* | bgxl[[cC]]* | mpixl[[cC]]*) # IBM XL C 8.0 on PPC (deal with xlf below)\n\t  tmp_sharedflag='-qmkshrobj'\n\t  tmp_addflag= ;;\n\tnvcc*)\t# Cuda Compiler Driver 2.2\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  ;;\n\tesac\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\t\t\t# Sun C 5.9\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  tmp_sharedflag='-G' ;;\n\t*Sun\\ F*)\t\t\t# Sun Fortran 8.3\n\t  tmp_sharedflag='-G' ;;\n\tesac\n\t_LT_TAGVAR(archive_cmds, $1)='$CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\n        if test yes = \"$supports_anon_versioning\"; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n            cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n            echo \"local: *; };\" >> $output_objdir/$libname.ver~\n            $CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-version-script $wl$output_objdir/$libname.ver -o $lib'\n        fi\n\n\tcase $cc_basename in\n\ttcc*)\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='-rdynamic'\n\t  ;;\n\txlf* | bgf* | bgxlf* | mpixlf*)\n\t  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $linker_flags -soname $soname -o $lib'\n\t  if test yes = \"$supports_anon_versioning\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n              cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n              echo \"local: *; };\" >> $output_objdir/$libname.ver~\n              $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'\n\t  fi\n\t  ;;\n\tesac\n      else\n        _LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    netbsd* | netbsdelf*-gnu)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'\n\twlarc=\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n      fi\n      ;;\n\n    solaris*)\n      if $LD -v 2>&1 | $GREP 'BFD 2\\.8' > /dev/null; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: The releases 2.8.* of the GNU linker cannot reliably\n*** create shared libraries on Solaris systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.9.1 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)\n      case `$LD -v 2>&1` in\n        *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.1[[0-5]].*)\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 cannot\n*** reliably create shared libraries on SCO systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n\t;;\n\t*)\n\t  # For security reasons, it is highly recommended that you always\n\t  # use absolute paths for naming shared libraries, and exclude the\n\t  # DT_RUNPATH tag from executables and libraries.  But doing so\n\t  # requires that you compile everything twice, which is a pain.\n\t  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t;;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      wlarc=\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n    esac\n\n    if test no = \"$_LT_TAGVAR(ld_shlibs, $1)\"; then\n      runpath_var=\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n  else\n    # PORTME fill in a description of your system's linker (not GNU ld)\n    case $host_os in\n    aix3*)\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'\n      # Note: this linker hardcodes the directories in LIBPATH if there\n      # are no directories specified by -L.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      if test yes = \"$GCC\" && test -z \"$lt_prog_compiler_static\"; then\n\t# Neither direct hardcoding nor static linking is supported with a\n\t# broken collect2.\n\t_LT_TAGVAR(hardcode_direct, $1)=unsupported\n      fi\n      ;;\n\n    aix[[4-9]]*)\n      if test ia64 = \"$host_cpu\"; then\n\t# On IA64, the linker does run time linking by default, so we don't\n\t# have to do anything special.\n\taix_use_runtimelinking=no\n\texp_sym_flag='-Bexport'\n\tno_entry_flag=\n      else\n\t# If we're using GNU nm, then we don't want the \"-C\" option.\n\t# -C means demangle to GNU nm, but means don't demangle to AIX nm.\n\t# Without the \"-l\" option, or with the \"-B\" option, AIX nm treats\n\t# weak defined symbols like other global defined symbols, whereas\n\t# GNU nm marks them as \"W\".\n\t# While the 'weak' keyword is ignored in the Export File, we need\n\t# it in the Import File for the 'aix-soname' feature, so we have\n\t# to replace the \"-B\" option with \"-P\" for AIX nm.\n\tif $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { if (\\$ 2 == \"W\") { print \\$ 3 \" weak\" } else { print \\$ 3 } } }'\\'' | sort -u > $export_symbols'\n\telse\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='`func_echo_all $NM | $SED -e '\\''s/B\\([[^B]]*\\)$/P\\1/'\\''` -PCpgl $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\") || (\\$ 2 == \"V\") || (\\$ 2 == \"Z\")) && ([substr](\\$ 1,1,1) != \".\")) { if ((\\$ 2 == \"W\") || (\\$ 2 == \"V\") || (\\$ 2 == \"Z\")) { print \\$ 1 \" weak\" } else { print \\$ 1 } } }'\\'' | sort -u > $export_symbols'\n\tfi\n\taix_use_runtimelinking=no\n\n\t# Test if we are trying to use run time linking or normal\n\t# AIX style linking. If -brtl is somewhere in LDFLAGS, we\n\t# have runtime linking enabled, and use it for executables.\n\t# For shared libraries, we enable/disable runtime linking\n\t# depending on the kind of the shared library created -\n\t# when \"with_aix_soname,aix_use_runtimelinking\" is:\n\t# \"aix,no\"   lib.a(lib.so.V) shared, rtl:no,  for executables\n\t# \"aix,yes\"  lib.so          shared, rtl:yes, for executables\n\t#            lib.a           static archive\n\t# \"both,no\"  lib.so.V(shr.o) shared, rtl:yes\n\t#            lib.a(lib.so.V) shared, rtl:no,  for executables\n\t# \"both,yes\" lib.so.V(shr.o) shared, rtl:yes, for executables\n\t#            lib.a(lib.so.V) shared, rtl:no\n\t# \"svr4,*\"   lib.so.V(shr.o) shared, rtl:yes, for executables\n\t#            lib.a           static archive\n\tcase $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t  for ld_flag in $LDFLAGS; do\n\t  if (test x-brtl = \"x$ld_flag\" || test x-Wl,-brtl = \"x$ld_flag\"); then\n\t    aix_use_runtimelinking=yes\n\t    break\n\t  fi\n\t  done\n\t  if test svr4,no = \"$with_aix_soname,$aix_use_runtimelinking\"; then\n\t    # With aix-soname=svr4, we create the lib.so.V shared archives only,\n\t    # so we don't have lib.a shared libs to link our executables.\n\t    # We have to force runtime linking in this case.\n\t    aix_use_runtimelinking=yes\n\t    LDFLAGS=\"$LDFLAGS -Wl,-brtl\"\n\t  fi\n\t  ;;\n\tesac\n\n\texp_sym_flag='-bexport'\n\tno_entry_flag='-bnoentry'\n      fi\n\n      # When large executables or shared objects are built, AIX ld can\n      # have problems creating the table of contents.  If linking a library\n      # or program results in \"error TOC overflow\" add -mminimal-toc to\n      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n      _LT_TAGVAR(archive_cmds, $1)=''\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(file_list_spec, $1)='$wl-f,'\n      case $with_aix_soname,$aix_use_runtimelinking in\n      aix,*) ;; # traditional, no import file\n      svr4,* | *,yes) # use import file\n\t# The Import File defines what to hardcode.\n\t_LT_TAGVAR(hardcode_direct, $1)=no\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n\t;;\n      esac\n\n      if test yes = \"$GCC\"; then\n\tcase $host_os in aix4.[[012]]|aix4.[[012]].*)\n\t# We only want to do this on AIX 4.2 and lower, the check\n\t# below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`$CC -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t   strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t  # We have reworked collect2\n\t  :\n\t  else\n\t  # We have old collect2\n\t  _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t  # It fails to find uninstalled libraries when the uninstalled\n\t  # path is not listed in the libpath.  Setting hardcode_minus_L\n\t  # to unsupported forces relinking\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n\t  ;;\n\tesac\n\tshared_flag='-shared'\n\tif test yes = \"$aix_use_runtimelinking\"; then\n\t  shared_flag=\"$shared_flag \"'$wl-G'\n\tfi\n\t# Need to ensure runtime linking is disabled for the traditional\n\t# shared library, or the linker may eventually find shared libraries\n\t# /with/ Import File - we do not want to mix them.\n\tshared_flag_aix='-shared'\n\tshared_flag_svr4='-shared $wl-G'\n      else\n\t# not using gcc\n\tif test ia64 = \"$host_cpu\"; then\n\t# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t# chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n\telse\n\t  if test yes = \"$aix_use_runtimelinking\"; then\n\t    shared_flag='$wl-G'\n\t  else\n\t    shared_flag='$wl-bM:SRE'\n\t  fi\n\t  shared_flag_aix='$wl-bM:SRE'\n\t  shared_flag_svr4='$wl-G'\n\tfi\n      fi\n\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-bexpall'\n      # It seems that -bexpall does not export symbols beginning with\n      # underscore (_), so it is better to generate a list of symbols to export.\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      if test aix,yes = \"$with_aix_soname,$aix_use_runtimelinking\"; then\n\t# Warning - without using the other runtime loading flags (-brtl),\n\t# -berok will link without error, but may produce a broken library.\n\t_LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n        # Determine the default libpath from the value encoded in an\n        # empty executable.\n        _LT_SYS_MODULE_PATH_AIX([$1])\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'\"$aix_libpath\"\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs $wl'$no_entry_flag' $compiler_flags `if test -n \"$allow_undefined_flag\"; then func_echo_all \"$wl$allow_undefined_flag\"; else :; fi` $wl'$exp_sym_flag:\\$export_symbols' '$shared_flag\n      else\n\tif test ia64 = \"$host_cpu\"; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R $libdir:/usr/lib:/lib'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\$wl$no_entry_flag\"' $compiler_flags $wl$allow_undefined_flag '\"\\$wl$exp_sym_flag:\\$export_symbols\"\n\telse\n\t # Determine the default libpath from the value encoded in an\n\t # empty executable.\n\t _LT_SYS_MODULE_PATH_AIX([$1])\n\t _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'\"$aix_libpath\"\n\t  # Warning - without using the other run time loading flags,\n\t  # -berok will link without error, but may produce a broken library.\n\t  _LT_TAGVAR(no_undefined_flag, $1)=' $wl-bernotok'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-berok'\n\t  if test yes = \"$with_gnu_ld\"; then\n\t    # We only use this code for GNU lds that support --whole-archive.\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive$convenience $wl--no-whole-archive'\n\t  else\n\t    # Exported symbols can be pulled into shared objects from archives\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t  fi\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$RM -r $output_objdir/$realname.d~$MKDIR $output_objdir/$realname.d'\n\t  # -brtl affects multiple linker settings, -berok does not and is overridden later\n\t  compiler_flags_filtered='`func_echo_all \"$compiler_flags \" | $SED -e \"s%-brtl\\\\([[, ]]\\\\)%-berok\\\\1%g\"`'\n\t  if test svr4 != \"$with_aix_soname\"; then\n\t    # This is similar to how AIX traditionally builds its shared libraries.\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$CC '$shared_flag_aix' -o $output_objdir/$realname.d/$soname $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$realname.d/$soname'\n\t  fi\n\t  if test aix != \"$with_aix_soname\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$CC '$shared_flag_svr4' -o $output_objdir/$realname.d/$shared_archive_member_spec.o $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$STRIP -e $output_objdir/$realname.d/$shared_archive_member_spec.o~( func_echo_all \"#! $soname($shared_archive_member_spec.o)\"; if test shr_64 = \"$shared_archive_member_spec\"; then func_echo_all \"# 64\"; else func_echo_all \"# 32\"; fi; cat $export_symbols ) > $output_objdir/$realname.d/$shared_archive_member_spec.imp~$AR $AR_FLAGS $output_objdir/$soname $output_objdir/$realname.d/$shared_archive_member_spec.o $output_objdir/$realname.d/$shared_archive_member_spec.imp'\n\t  else\n\t    # used by -dlpreopen to get the symbols\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$MV  $output_objdir/$realname.d/$soname $output_objdir'\n\t  fi\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$RM -r $output_objdir/$realname.d'\n\tfi\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    bsdi[[45]]*)\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # When not using gcc, we currently assume that we are using\n      # Microsoft Visual C++.\n      # hardcode_libdir_flag_spec is actually meaningless, as there is\n      # no search path for DLLs.\n      case $cc_basename in\n      cl*)\n\t# Native MSVC\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t_LT_TAGVAR(always_export_symbols, $1)=yes\n\t_LT_TAGVAR(file_list_spec, $1)='@'\n\t# Tell ltmain to make .lib files, not .a files.\n\tlibext=lib\n\t# Tell ltmain to make .dll files, not .so files.\n\tshrext_cmds=.dll\n\t# FIXME: Setting linknames here is a bad hack.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~linknames='\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then\n            cp \"$export_symbols\" \"$output_objdir/$soname.def\";\n            echo \"$tool_output_objdir$soname.def\" > \"$output_objdir/$soname.exp\";\n          else\n            $SED -e '\\''s/^/-link -EXPORT:/'\\'' < $export_symbols > $output_objdir/$soname.exp;\n          fi~\n          $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs \"@$tool_output_objdir$soname.exp\" -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~\n          linknames='\n\t# The linker will not automatically build a static lib if we build a DLL.\n\t# _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t_LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'\n\t_LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1,DATA/'\\'' | $SED -e '\\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\\'' | sort | uniq > $export_symbols'\n\t# Don't use ranlib\n\t_LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'\n\t_LT_TAGVAR(postlink_cmds, $1)='lt_outputfile=\"@OUTPUT@\"~\n          lt_tool_outputfile=\"@TOOL_OUTPUT@\"~\n          case $lt_outputfile in\n            *.exe|*.EXE) ;;\n            *)\n              lt_outputfile=$lt_outputfile.exe\n              lt_tool_outputfile=$lt_tool_outputfile.exe\n              ;;\n          esac~\n          if test : != \"$MANIFEST_TOOL\" && test -f \"$lt_outputfile.manifest\"; then\n            $MANIFEST_TOOL -manifest \"$lt_tool_outputfile.manifest\" -outputresource:\"$lt_tool_outputfile\" || exit 1;\n            $RM \"$lt_outputfile.manifest\";\n          fi'\n\t;;\n      *)\n\t# Assume MSVC wrapper\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Tell ltmain to make .lib files, not .a files.\n\tlibext=lib\n\t# Tell ltmain to make .dll files, not .so files.\n\tshrext_cmds=.dll\n\t# FIXME: Setting linknames here is a bad hack.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `func_echo_all \"$deplibs\" | $SED '\\''s/ -lc$//'\\''` -link -dll~linknames='\n\t# The linker will automatically build a .lib file if we build a DLL.\n\t_LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t# FIXME: Should let the user specify the lib program.\n\t_LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t;;\n      esac\n      ;;\n\n    darwin* | rhapsody*)\n      _LT_DARWIN_LINKER_FEATURES($1)\n      ;;\n\n    dgux*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor\n    # support.  Future versions do this automatically, but an explicit c++rt0.o\n    # does not break anything, and helps significantly (at the cost of a little\n    # extra space).\n    freebsd2.2*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # Unfortunately, older versions of FreeBSD 2 do not have this feature.\n    freebsd2.*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.\n    freebsd* | dragonfly*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    hpux9*)\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared $pic_flag $wl+b $wl$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test \"x$output_objdir/$soname\" = \"x$lib\" || mv $output_objdir/$soname $lib'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test \"x$output_objdir/$soname\" = \"x$lib\" || mv $output_objdir/$soname $lib'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n\n      # hardcode_minus_L: Not really in the search PATH,\n      # but as the default location of the library.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n      ;;\n\n    hpux10*)\n      if test yes,no = \"$GCC,$with_gnu_ld\"; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      if test no = \"$with_gnu_ld\"; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n\t# hardcode_minus_L: Not really in the search PATH,\n\t# but as the default location of the library.\n\t_LT_TAGVAR(hardcode_minus_L, $1)=yes\n      fi\n      ;;\n\n    hpux11*)\n      if test yes,no = \"$GCC,$with_gnu_ld\"; then\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl+h $wl$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl+h $wl$soname $wl+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      else\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\tm4_if($1, [], [\n\t  # Older versions of the 11.00 compiler do not understand -b yet\n\t  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)\n\t  _LT_LINKER_OPTION([if $CC understands -b],\n\t    _LT_TAGVAR(lt_cv_prog_compiler__b, $1), [-b],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'])],\n\t  [_LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'])\n\t  ;;\n\tesac\n      fi\n      if test no = \"$with_gnu_ld\"; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\tcase $host_cpu in\n\thppa*64*|ia64*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n\n\t  # hardcode_minus_L: Not really in the search PATH,\n\t  # but as the default location of the library.\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  ;;\n\tesac\n      fi\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n\t# Try to use the -exported_symbol ld option, if it does not\n\t# work, assume that -exports_file does not work either and\n\t# implicitly export all symbols.\n\t# This should be the same for all languages, so no per-tag cache variable.\n\tAC_CACHE_CHECK([whether the $host_os linker accepts -exported_symbol],\n\t  [lt_cv_irix_exported_symbol],\n\t  [save_LDFLAGS=$LDFLAGS\n\t   LDFLAGS=\"$LDFLAGS -shared $wl-exported_symbol ${wl}foo $wl-update_registry $wl/dev/null\"\n\t   AC_LINK_IFELSE(\n\t     [AC_LANG_SOURCE(\n\t        [AC_LANG_CASE([C], [[int foo (void) { return 0; }]],\n\t\t\t      [C++], [[int foo (void) { return 0; }]],\n\t\t\t      [Fortran 77], [[\n      subroutine foo\n      end]],\n\t\t\t      [Fortran], [[\n      subroutine foo\n      end]])])],\n\t      [lt_cv_irix_exported_symbol=yes],\n\t      [lt_cv_irix_exported_symbol=no])\n           LDFLAGS=$save_LDFLAGS])\n\tif test yes = \"$lt_cv_irix_exported_symbol\"; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations $wl-exports_file $wl$export_symbols -o $lib'\n\tfi\n\t_LT_TAGVAR(link_all_deplibs, $1)=no\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -exports_file $export_symbols -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(inherit_rpath, $1)=yes\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    linux*)\n      case $cc_basename in\n      tcc*)\n\t# Fabrice Bellard et al's Tiny C Compiler\n\t_LT_TAGVAR(ld_shlibs, $1)=yes\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t;;\n      esac\n      ;;\n\n    netbsd* | netbsdelf*-gnu)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *nto* | *qnx*)\n      ;;\n\n    openbsd* | bitrig*)\n      if test -f /usr/libexec/ld.so; then\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\tif test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\"; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags $wl-retain-symbols-file,$export_symbols'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n\telse\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\tfi\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    os2*)\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      shrext_cmds=.dll\n      _LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t$ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t$ECHO EXPORTS >> $output_objdir/$libname.def~\n\temxexp $libobjs | $SED /\"_DLL_InitTerm\"/d >> $output_objdir/$libname.def~\n\t$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\temximp -o $lib $output_objdir/$libname.def'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t$ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t$ECHO EXPORTS >> $output_objdir/$libname.def~\n\tprefix_cmds=\"$SED\"~\n\tif test EXPORTS = \"`$SED 1q $export_symbols`\"; then\n\t  prefix_cmds=\"$prefix_cmds -e 1d\";\n\tfi~\n\tprefix_cmds=\"$prefix_cmds -e \\\"s/^\\(.*\\)$/_\\1/g\\\"\"~\n\tcat $export_symbols | $prefix_cmds >> $output_objdir/$libname.def~\n\t$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\temximp -o $lib $output_objdir/$libname.def'\n      _LT_TAGVAR(old_archive_From_new_cmds, $1)='emximp -o $output_objdir/${libname}_dll.a $output_objdir/$libname.def'\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      ;;\n\n    osf3*)\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    osf4* | osf5*)\t# as osf3* with the addition of -msym flag\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $pic_flag $libobjs $deplibs $compiler_flags $wl-msym $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done; printf \"%s\\\\n\" \"-hidden\">> $lib.exp~\n          $CC -shared$allow_undefined_flag $wl-input $wl$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib~$RM $lib.exp'\n\n\t# Both c and cxx compiler support -rpath directly\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'\n      if test yes = \"$GCC\"; then\n\twlarc='$wl'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl-z ${wl}text $wl-h $wl$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n          $CC -shared $pic_flag $wl-z ${wl}text $wl-M $wl$lib.exp $wl-h $wl$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n      else\n\tcase `$CC -V 2>&1` in\n\t*\"Compilers 5.0\"*)\n\t  wlarc=''\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G$allow_undefined_flag -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n            $LD -G$allow_undefined_flag -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'\n\t  ;;\n\t*)\n\t  wlarc='$wl'\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G$allow_undefined_flag -h $soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n            $CC -G$allow_undefined_flag -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n\t  ;;\n\tesac\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      case $host_os in\n      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n      *)\n\t# The compiler driver will combine and reorder linker options,\n\t# but understands '-z linker_flag'.  GCC discards it without '$wl',\n\t# but is careful enough not to reorder.\n\t# Supported since Solaris 2.6 (maybe 2.5.1?)\n\tif test yes = \"$GCC\"; then\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl-z ${wl}allextract$convenience $wl-z ${wl}defaultextract'\n\telse\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\tfi\n\t;;\n      esac\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    sunos4*)\n      if test sequent = \"$host_vendor\"; then\n\t# Use $CC to link under sequent, because it throws in some extra .o\n\t# files that make .init and .fini sections work.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h $soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4)\n      case $host_vendor in\n\tsni)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???\n\t;;\n\tsiemens)\n\t  ## LD is ld it makes a PLAMLIB\n\t  ## CC just makes a GrossModule.\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n        ;;\n\tmotorola)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie\n\t;;\n      esac\n      runpath_var='LD_RUN_PATH'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4.3*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\trunpath_var=LD_RUN_PATH\n\thardcode_runpath_var=yes\n\t_LT_TAGVAR(ld_shlibs, $1)=yes\n      fi\n      ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6*)\n      # Note: We CANNOT use -z defs as we might desire, because we do not\n      # link with -lc, and that would cause any symbols used from libc to\n      # always be unresolved, which means just about no library would\n      # ever link correctly.  If we're not using GNU ld we use -z text\n      # though, which does catch some bad symbols but isn't as heavy-handed\n      # as -z defs.\n      _LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'\n      _LT_TAGVAR(allow_undefined_flag, $1)='$wl-z,nodefs'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R,$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-Bexport'\n      runpath_var='LD_RUN_PATH'\n\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      _LT_TAGVAR(ld_shlibs, $1)=no\n      ;;\n    esac\n\n    if test sni = \"$host_vendor\"; then\n      case $host in\n      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-Blargedynsym'\n\t;;\n      esac\n    fi\n  fi\n])\nAC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\ntest no = \"$_LT_TAGVAR(ld_shlibs, $1)\" && can_build_shared=no\n\n_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld\n\n_LT_DECL([], [libext], [0], [Old archive suffix (normally \"a\")])dnl\n_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally \".so\")])dnl\n_LT_DECL([], [extract_expsyms_cmds], [2],\n    [The commands to extract the exported symbol list from a shared archive])\n\n#\n# Do we need to explicitly link libc?\n#\ncase \"x$_LT_TAGVAR(archive_cmds_need_lc, $1)\" in\nx|xyes)\n  # Assume -lc should be added\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\n  if test yes,yes = \"$GCC,$enable_shared\"; then\n    case $_LT_TAGVAR(archive_cmds, $1) in\n    *'~'*)\n      # FIXME: we may have to deal with multi-command sequences.\n      ;;\n    '$CC '*)\n      # Test whether the compiler implicitly links with -lc since on some\n      # systems, -lgcc has to come before -lc. If gcc already passes -lc\n      # to ld, don't add -lc before -lgcc.\n      AC_CACHE_CHECK([whether -lc should be explicitly linked in],\n\t[lt_cv_]_LT_TAGVAR(archive_cmds_need_lc, $1),\n\t[$RM conftest*\n\techo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n\tif AC_TRY_EVAL(ac_compile) 2>conftest.err; then\n\t  soname=conftest\n\t  lib=conftest\n\t  libobjs=conftest.$ac_objext\n\t  deplibs=\n\t  wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)\n\t  pic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)\n\t  compiler_flags=-v\n\t  linker_flags=-v\n\t  verstring=\n\t  output_objdir=.\n\t  libname=conftest\n\t  lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\n\t  if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\\>\\&1 \\| $GREP \\\" -lc \\\" \\>/dev/null 2\\>\\&1)\n\t  then\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t  else\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  fi\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag\n\telse\n\t  cat conftest.err 1>&5\n\tfi\n\t$RM conftest*\n\t])\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=$lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)\n      ;;\n    esac\n  fi\n  ;;\nesac\n\n_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],\n    [Whether or not to add -lc for building shared libraries])\n_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],\n    [enable_shared_with_static_runtimes], [0],\n    [Whether or not to disallow shared libs when runtime libs are static])\n_LT_TAGDECL([], [export_dynamic_flag_spec], [1],\n    [Compiler flag to allow reflexive dlopens])\n_LT_TAGDECL([], [whole_archive_flag_spec], [1],\n    [Compiler flag to generate shared objects directly from archives])\n_LT_TAGDECL([], [compiler_needs_object], [1],\n    [Whether the compiler copes with passing no objects directly])\n_LT_TAGDECL([], [old_archive_from_new_cmds], [2],\n    [Create an old-style archive from a shared archive])\n_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],\n    [Create a temporary old-style archive to link instead of a shared archive])\n_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])\n_LT_TAGDECL([], [archive_expsym_cmds], [2])\n_LT_TAGDECL([], [module_cmds], [2],\n    [Commands used to build a loadable module if different from building\n    a shared archive.])\n_LT_TAGDECL([], [module_expsym_cmds], [2])\n_LT_TAGDECL([], [with_gnu_ld], [1],\n    [Whether we are building with GNU ld or not])\n_LT_TAGDECL([], [allow_undefined_flag], [1],\n    [Flag that allows shared libraries with undefined symbols to be built])\n_LT_TAGDECL([], [no_undefined_flag], [1],\n    [Flag that enforces no undefined symbols])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],\n    [Flag to hardcode $libdir into a binary during linking.\n    This must work even if $libdir does not exist])\n_LT_TAGDECL([], [hardcode_libdir_separator], [1],\n    [Whether we need a single \"-rpath\" flag with a separated argument])\n_LT_TAGDECL([], [hardcode_direct], [0],\n    [Set to \"yes\" if using DIR/libNAME$shared_ext during linking hardcodes\n    DIR into the resulting binary])\n_LT_TAGDECL([], [hardcode_direct_absolute], [0],\n    [Set to \"yes\" if using DIR/libNAME$shared_ext during linking hardcodes\n    DIR into the resulting binary and the resulting library dependency is\n    \"absolute\", i.e impossible to change by setting $shlibpath_var if the\n    library is relocated])\n_LT_TAGDECL([], [hardcode_minus_L], [0],\n    [Set to \"yes\" if using the -LDIR flag during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_shlibpath_var], [0],\n    [Set to \"yes\" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_automatic], [0],\n    [Set to \"yes\" if building a shared library automatically hardcodes DIR\n    into the library and all subsequent libraries and executables linked\n    against it])\n_LT_TAGDECL([], [inherit_rpath], [0],\n    [Set to yes if linker adds runtime paths of dependent libraries\n    to runtime path list])\n_LT_TAGDECL([], [link_all_deplibs], [0],\n    [Whether libtool must link a program against all its dependency libraries])\n_LT_TAGDECL([], [always_export_symbols], [0],\n    [Set to \"yes\" if exported symbols are required])\n_LT_TAGDECL([], [export_symbols_cmds], [2],\n    [The commands to list exported symbols])\n_LT_TAGDECL([], [exclude_expsyms], [1],\n    [Symbols that should not be listed in the preloaded symbols])\n_LT_TAGDECL([], [include_expsyms], [1],\n    [Symbols that must always be exported])\n_LT_TAGDECL([], [prelink_cmds], [2],\n    [Commands necessary for linking programs (against libraries) with templates])\n_LT_TAGDECL([], [postlink_cmds], [2],\n    [Commands necessary for finishing linking programs])\n_LT_TAGDECL([], [file_list_spec], [1],\n    [Specify filename containing input files])\ndnl FIXME: Not yet implemented\ndnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],\ndnl    [Compiler flag to generate thread safe objects])\n])# _LT_LINKER_SHLIBS\n\n\n# _LT_LANG_C_CONFIG([TAG])\n# ------------------------\n# Ensure that the configuration variables for a C compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_C_CONFIG],\n[m4_require([_LT_DECL_EGREP])dnl\nlt_save_CC=$CC\nAC_LANG_PUSH(C)\n\n# Source file extension for C test sources.\nac_ext=c\n\n# Object file extension for compiled C test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"int some_variable = 0;\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='int main(){return(0);}'\n\n_LT_TAG_COMPILER\n# Save the default compiler, since it gets overwritten when the other\n# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.\ncompiler_DEFAULT=$CC\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_SYS_DYNAMIC_LINKER($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n  LT_SYS_DLOPEN_SELF\n  _LT_CMD_STRIPLIB\n\n  # Report what library types will actually be built\n  AC_MSG_CHECKING([if libtool supports shared libraries])\n  AC_MSG_RESULT([$can_build_shared])\n\n  AC_MSG_CHECKING([whether to build shared libraries])\n  test no = \"$can_build_shared\" && enable_shared=no\n\n  # On AIX, shared libraries and static libraries use the same namespace, and\n  # are all built from PIC.\n  case $host_os in\n  aix3*)\n    test yes = \"$enable_shared\" && enable_static=no\n    if test -n \"$RANLIB\"; then\n      archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n      postinstall_cmds='$RANLIB $lib'\n    fi\n    ;;\n\n  aix[[4-9]]*)\n    if test ia64 != \"$host_cpu\"; then\n      case $enable_shared,$with_aix_soname,$aix_use_runtimelinking in\n      yes,aix,yes) ;;\t\t\t# shared object as lib.so file only\n      yes,svr4,*) ;;\t\t\t# shared object as lib.so archive member only\n      yes,*) enable_static=no ;;\t# shared object in lib.a archive as well\n      esac\n    fi\n    ;;\n  esac\n  AC_MSG_RESULT([$enable_shared])\n\n  AC_MSG_CHECKING([whether to build static libraries])\n  # Make sure either enable_shared or enable_static is yes.\n  test yes = \"$enable_shared\" || enable_static=yes\n  AC_MSG_RESULT([$enable_static])\n\n  _LT_CONFIG($1)\nfi\nAC_LANG_POP\nCC=$lt_save_CC\n])# _LT_LANG_C_CONFIG\n\n\n# _LT_LANG_CXX_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a C++ compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_CXX_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PATH_MANIFEST_TOOL])dnl\nif test -n \"$CXX\" && ( test no != \"$CXX\" &&\n    ( (test g++ = \"$CXX\" && `g++ -v >/dev/null 2>&1` ) ||\n    (test g++ != \"$CXX\"))); then\n  AC_PROG_CXXCPP\nelse\n  _lt_caught_CXX_error=yes\nfi\n\nAC_LANG_PUSH(C++)\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(compiler_needs_object, $1)=no\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for C++ test sources.\nac_ext=cpp\n\n# Object file extension for compiled C++ test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the CXX compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test yes != \"$_lt_caught_CXX_error\"; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"int some_variable = 0;\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_CFLAGS=$CFLAGS\n  lt_save_LD=$LD\n  lt_save_GCC=$GCC\n  GCC=$GXX\n  lt_save_with_gnu_ld=$with_gnu_ld\n  lt_save_path_LD=$lt_cv_path_LD\n  if test -n \"${lt_cv_prog_gnu_ldcxx+set}\"; then\n    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx\n  else\n    $as_unset lt_cv_prog_gnu_ld\n  fi\n  if test -n \"${lt_cv_path_LDCXX+set}\"; then\n    lt_cv_path_LD=$lt_cv_path_LDCXX\n  else\n    $as_unset lt_cv_path_LD\n  fi\n  test -z \"${LDCXX+set}\" || LD=$LDCXX\n  CC=${CXX-\"c++\"}\n  CFLAGS=$CXXFLAGS\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    # We don't want -fno-exception when compiling C++ code, so set the\n    # no_builtin_flag separately\n    if test yes = \"$GXX\"; then\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n    else\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n    fi\n\n    if test yes = \"$GXX\"; then\n      # Set up default GNU C++ configuration\n\n      LT_PATH_LD\n\n      # Check if GNU C++ uses GNU ld as the underlying linker, since the\n      # archiving commands below assume that GNU ld is being used.\n      if test yes = \"$with_gnu_ld\"; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n\n        # If archive_cmds runs LD, not CC, wlarc should be empty\n        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to\n        #     investigate it a little bit more. (MM)\n        wlarc='$wl'\n\n        # ancient GNU ld didn't support --whole-archive et. al.\n        if eval \"`$CC -print-prog-name=ld` --help 2>&1\" |\n\t  $GREP 'no-whole-archive' > /dev/null; then\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=$wlarc'--whole-archive$convenience '$wlarc'--no-whole-archive'\n        else\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\n        fi\n      else\n        with_gnu_ld=no\n        wlarc=\n\n        # A generic and very simple default shared library creation\n        # command for GNU C++ for the case where it uses the native\n        # linker, instead of GNU ld.  If possible, this setting should\n        # overridden to take advantage of the native linker features on\n        # the platform it is being used on.\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n      fi\n\n      # Commands to make compiler produce verbose output that lists\n      # what \"hidden\" libraries, object files and flags are used when\n      # linking a shared library.\n      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n    else\n      GXX=no\n      with_gnu_ld=no\n      wlarc=\n    fi\n\n    # PORTME: fill in a description of your system's C++ link characteristics\n    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\n    _LT_TAGVAR(ld_shlibs, $1)=yes\n    case $host_os in\n      aix3*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n      aix[[4-9]]*)\n        if test ia64 = \"$host_cpu\"; then\n          # On IA64, the linker does run time linking by default, so we don't\n          # have to do anything special.\n          aix_use_runtimelinking=no\n          exp_sym_flag='-Bexport'\n          no_entry_flag=\n        else\n          aix_use_runtimelinking=no\n\n          # Test if we are trying to use run time linking or normal\n          # AIX style linking. If -brtl is somewhere in LDFLAGS, we\n          # have runtime linking enabled, and use it for executables.\n          # For shared libraries, we enable/disable runtime linking\n          # depending on the kind of the shared library created -\n          # when \"with_aix_soname,aix_use_runtimelinking\" is:\n          # \"aix,no\"   lib.a(lib.so.V) shared, rtl:no,  for executables\n          # \"aix,yes\"  lib.so          shared, rtl:yes, for executables\n          #            lib.a           static archive\n          # \"both,no\"  lib.so.V(shr.o) shared, rtl:yes\n          #            lib.a(lib.so.V) shared, rtl:no,  for executables\n          # \"both,yes\" lib.so.V(shr.o) shared, rtl:yes, for executables\n          #            lib.a(lib.so.V) shared, rtl:no\n          # \"svr4,*\"   lib.so.V(shr.o) shared, rtl:yes, for executables\n          #            lib.a           static archive\n          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t    for ld_flag in $LDFLAGS; do\n\t      case $ld_flag in\n\t      *-brtl*)\n\t        aix_use_runtimelinking=yes\n\t        break\n\t        ;;\n\t      esac\n\t    done\n\t    if test svr4,no = \"$with_aix_soname,$aix_use_runtimelinking\"; then\n\t      # With aix-soname=svr4, we create the lib.so.V shared archives only,\n\t      # so we don't have lib.a shared libs to link our executables.\n\t      # We have to force runtime linking in this case.\n\t      aix_use_runtimelinking=yes\n\t      LDFLAGS=\"$LDFLAGS -Wl,-brtl\"\n\t    fi\n\t    ;;\n          esac\n\n          exp_sym_flag='-bexport'\n          no_entry_flag='-bnoentry'\n        fi\n\n        # When large executables or shared objects are built, AIX ld can\n        # have problems creating the table of contents.  If linking a library\n        # or program results in \"error TOC overflow\" add -mminimal-toc to\n        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n        _LT_TAGVAR(archive_cmds, $1)=''\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        _LT_TAGVAR(file_list_spec, $1)='$wl-f,'\n        case $with_aix_soname,$aix_use_runtimelinking in\n        aix,*) ;;\t# no import file\n        svr4,* | *,yes) # use import file\n          # The Import File defines what to hardcode.\n          _LT_TAGVAR(hardcode_direct, $1)=no\n          _LT_TAGVAR(hardcode_direct_absolute, $1)=no\n          ;;\n        esac\n\n        if test yes = \"$GXX\"; then\n          case $host_os in aix4.[[012]]|aix4.[[012]].*)\n          # We only want to do this on AIX 4.2 and lower, the check\n          # below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`$CC -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t     strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t    # We have reworked collect2\n\t    :\n\t  else\n\t    # We have old collect2\n\t    _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t    # It fails to find uninstalled libraries when the uninstalled\n\t    # path is not listed in the libpath.  Setting hardcode_minus_L\n\t    # to unsupported forces relinking\n\t    _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n          esac\n          shared_flag='-shared'\n\t  if test yes = \"$aix_use_runtimelinking\"; then\n\t    shared_flag=$shared_flag' $wl-G'\n\t  fi\n\t  # Need to ensure runtime linking is disabled for the traditional\n\t  # shared library, or the linker may eventually find shared libraries\n\t  # /with/ Import File - we do not want to mix them.\n\t  shared_flag_aix='-shared'\n\t  shared_flag_svr4='-shared $wl-G'\n        else\n          # not using gcc\n          if test ia64 = \"$host_cpu\"; then\n\t  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t  # chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n          else\n\t    if test yes = \"$aix_use_runtimelinking\"; then\n\t      shared_flag='$wl-G'\n\t    else\n\t      shared_flag='$wl-bM:SRE'\n\t    fi\n\t    shared_flag_aix='$wl-bM:SRE'\n\t    shared_flag_svr4='$wl-G'\n          fi\n        fi\n\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-bexpall'\n        # It seems that -bexpall does not export symbols beginning with\n        # underscore (_), so it is better to generate a list of symbols to\n\t# export.\n        _LT_TAGVAR(always_export_symbols, $1)=yes\n\tif test aix,yes = \"$with_aix_soname,$aix_use_runtimelinking\"; then\n          # Warning - without using the other runtime loading flags (-brtl),\n          # -berok will link without error, but may produce a broken library.\n          # The \"-G\" linker flag allows undefined symbols.\n          _LT_TAGVAR(no_undefined_flag, $1)='-bernotok'\n          # Determine the default libpath from the value encoded in an empty\n          # executable.\n          _LT_SYS_MODULE_PATH_AIX([$1])\n          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'\"$aix_libpath\"\n\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs $wl'$no_entry_flag' $compiler_flags `if test -n \"$allow_undefined_flag\"; then func_echo_all \"$wl$allow_undefined_flag\"; else :; fi` $wl'$exp_sym_flag:\\$export_symbols' '$shared_flag\n        else\n          if test ia64 = \"$host_cpu\"; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R $libdir:/usr/lib:/lib'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\$wl$no_entry_flag\"' $compiler_flags $wl$allow_undefined_flag '\"\\$wl$exp_sym_flag:\\$export_symbols\"\n          else\n\t    # Determine the default libpath from the value encoded in an\n\t    # empty executable.\n\t    _LT_SYS_MODULE_PATH_AIX([$1])\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'\"$aix_libpath\"\n\t    # Warning - without using the other run time loading flags,\n\t    # -berok will link without error, but may produce a broken library.\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' $wl-bernotok'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-berok'\n\t    if test yes = \"$with_gnu_ld\"; then\n\t      # We only use this code for GNU lds that support --whole-archive.\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive$convenience $wl--no-whole-archive'\n\t    else\n\t      # Exported symbols can be pulled into shared objects from archives\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t    fi\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$RM -r $output_objdir/$realname.d~$MKDIR $output_objdir/$realname.d'\n\t    # -brtl affects multiple linker settings, -berok does not and is overridden later\n\t    compiler_flags_filtered='`func_echo_all \"$compiler_flags \" | $SED -e \"s%-brtl\\\\([[, ]]\\\\)%-berok\\\\1%g\"`'\n\t    if test svr4 != \"$with_aix_soname\"; then\n\t      # This is similar to how AIX traditionally builds its shared\n\t      # libraries. Need -bnortl late, we may have -brtl in LDFLAGS.\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$CC '$shared_flag_aix' -o $output_objdir/$realname.d/$soname $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$realname.d/$soname'\n\t    fi\n\t    if test aix != \"$with_aix_soname\"; then\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$CC '$shared_flag_svr4' -o $output_objdir/$realname.d/$shared_archive_member_spec.o $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$STRIP -e $output_objdir/$realname.d/$shared_archive_member_spec.o~( func_echo_all \"#! $soname($shared_archive_member_spec.o)\"; if test shr_64 = \"$shared_archive_member_spec\"; then func_echo_all \"# 64\"; else func_echo_all \"# 32\"; fi; cat $export_symbols ) > $output_objdir/$realname.d/$shared_archive_member_spec.imp~$AR $AR_FLAGS $output_objdir/$soname $output_objdir/$realname.d/$shared_archive_member_spec.o $output_objdir/$realname.d/$shared_archive_member_spec.imp'\n\t    else\n\t      # used by -dlpreopen to get the symbols\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$MV  $output_objdir/$realname.d/$soname $output_objdir'\n\t    fi\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$RM -r $output_objdir/$realname.d'\n          fi\n        fi\n        ;;\n\n      beos*)\n\tif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t  # support --undefined.  This deserves some investigation.  FIXME\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      chorus*)\n        case $cc_basename in\n          *)\n\t  # FIXME: insert proper C++ library support\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\t  ;;\n        esac\n        ;;\n\n      cygwin* | mingw* | pw32* | cegcc*)\n\tcase $GXX,$cc_basename in\n\t,cl* | no,cl*)\n\t  # Native MSVC\n\t  # hardcode_libdir_flag_spec is actually meaningless, as there is\n\t  # no search path for DLLs.\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  _LT_TAGVAR(always_export_symbols, $1)=yes\n\t  _LT_TAGVAR(file_list_spec, $1)='@'\n\t  # Tell ltmain to make .lib files, not .a files.\n\t  libext=lib\n\t  # Tell ltmain to make .dll files, not .so files.\n\t  shrext_cmds=.dll\n\t  # FIXME: Setting linknames here is a bad hack.\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~linknames='\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then\n              cp \"$export_symbols\" \"$output_objdir/$soname.def\";\n              echo \"$tool_output_objdir$soname.def\" > \"$output_objdir/$soname.exp\";\n            else\n              $SED -e '\\''s/^/-link -EXPORT:/'\\'' < $export_symbols > $output_objdir/$soname.exp;\n            fi~\n            $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs \"@$tool_output_objdir$soname.exp\" -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~\n            linknames='\n\t  # The linker will not automatically build a static lib if we build a DLL.\n\t  # _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t  # Don't use ranlib\n\t  _LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'\n\t  _LT_TAGVAR(postlink_cmds, $1)='lt_outputfile=\"@OUTPUT@\"~\n            lt_tool_outputfile=\"@TOOL_OUTPUT@\"~\n            case $lt_outputfile in\n              *.exe|*.EXE) ;;\n              *)\n                lt_outputfile=$lt_outputfile.exe\n                lt_tool_outputfile=$lt_tool_outputfile.exe\n                ;;\n            esac~\n            func_to_tool_file \"$lt_outputfile\"~\n            if test : != \"$MANIFEST_TOOL\" && test -f \"$lt_outputfile.manifest\"; then\n              $MANIFEST_TOOL -manifest \"$lt_tool_outputfile.manifest\" -outputresource:\"$lt_tool_outputfile\" || exit 1;\n              $RM \"$lt_outputfile.manifest\";\n            fi'\n\t  ;;\n\t*)\n\t  # g++\n\t  # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n\t  # as there is no search path for DLLs.\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-all-symbols'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  _LT_TAGVAR(always_export_symbols, $1)=no\n\t  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\n\t  if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t    # If the export-symbols file already is a .def file, use it as\n\t    # is; otherwise, prepend EXPORTS...\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then\n              cp $export_symbols $output_objdir/$soname.def;\n            else\n              echo EXPORTS > $output_objdir/$soname.def;\n              cat $export_symbols >> $output_objdir/$soname.def;\n            fi~\n            $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t  ;;\n\tesac\n\t;;\n      darwin* | rhapsody*)\n        _LT_DARWIN_LINKER_FEATURES($1)\n\t;;\n\n      os2*)\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t_LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\tshrext_cmds=.dll\n\t_LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t  $ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t  $ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t  $ECHO EXPORTS >> $output_objdir/$libname.def~\n\t  emxexp $libobjs | $SED /\"_DLL_InitTerm\"/d >> $output_objdir/$libname.def~\n\t  $CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\t  emximp -o $lib $output_objdir/$libname.def'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t  $ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t  $ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t  $ECHO EXPORTS >> $output_objdir/$libname.def~\n\t  prefix_cmds=\"$SED\"~\n\t  if test EXPORTS = \"`$SED 1q $export_symbols`\"; then\n\t    prefix_cmds=\"$prefix_cmds -e 1d\";\n\t  fi~\n\t  prefix_cmds=\"$prefix_cmds -e \\\"s/^\\(.*\\)$/_\\1/g\\\"\"~\n\t  cat $export_symbols | $prefix_cmds >> $output_objdir/$libname.def~\n\t  $CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\t  emximp -o $lib $output_objdir/$libname.def'\n\t_LT_TAGVAR(old_archive_From_new_cmds, $1)='emximp -o $output_objdir/${libname}_dll.a $output_objdir/$libname.def'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t;;\n\n      dgux*)\n        case $cc_basename in\n          ec++*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          ghcx*)\n\t    # Green Hills C++ Compiler\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      freebsd2.*)\n        # C++ shared libraries reported to be fairly broken before\n\t# switch to ELF\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      freebsd-elf*)\n        _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n        ;;\n\n      freebsd* | dragonfly*)\n        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF\n        # conventions\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n        ;;\n\n      haiku*)\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        ;;\n\n      hpux9*)\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t             # but as the default\n\t\t\t\t             # location of the library.\n\n        case $cc_basename in\n          CC*)\n            # FIXME: insert proper C++ library support\n            _LT_TAGVAR(ld_shlibs, $1)=no\n            ;;\n          aCC*)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b $wl+b $wl$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test \"x$output_objdir/$soname\" = \"x$lib\" || mv $output_objdir/$soname $lib'\n            # Commands to make compiler produce verbose output that lists\n            # what \"hidden\" libraries, object files and flags are used when\n            # linking a shared library.\n            #\n            # There doesn't appear to be a way to prevent this compiler from\n            # explicitly linking system object files so we need to strip them\n            # from the output so that they don't get included in the library\n            # dependencies.\n            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP \"\\-L\"`; list= ; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n            ;;\n          *)\n            if test yes = \"$GXX\"; then\n              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib $pic_flag $wl+b $wl$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test \"x$output_objdir/$soname\" = \"x$lib\" || mv $output_objdir/$soname $lib'\n            else\n              # FIXME: insert proper C++ library support\n              _LT_TAGVAR(ld_shlibs, $1)=no\n            fi\n            ;;\n        esac\n        ;;\n\n      hpux10*|hpux11*)\n        if test no = \"$with_gnu_ld\"; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n          case $host_cpu in\n            hppa*64*|ia64*)\n              ;;\n            *)\n\t      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n              ;;\n          esac\n        fi\n        case $host_cpu in\n          hppa*64*|ia64*)\n            _LT_TAGVAR(hardcode_direct, $1)=no\n            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n            ;;\n          *)\n            _LT_TAGVAR(hardcode_direct, $1)=yes\n            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t\t         # but as the default\n\t\t\t\t\t         # location of the library.\n            ;;\n        esac\n\n        case $cc_basename in\n          CC*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          aCC*)\n\t    case $host_cpu in\n\t      hppa*64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      ia64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      *)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t    esac\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP \"\\-L\"`; list= ; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n          *)\n\t    if test yes = \"$GXX\"; then\n\t      if test no = \"$with_gnu_ld\"; then\n\t        case $host_cpu in\n\t          hppa*64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC $wl+h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          ia64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag $wl+h $wl$soname $wl+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          *)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t        esac\n\t      fi\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      interix[[3-9]]*)\n\t_LT_TAGVAR(hardcode_direct, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n\t# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n\t# Instead, shared libraries are loaded at an image base (0x10000000 by\n\t# default) and relocated if they conflict, which is a slow very memory\n\t# consuming and fragmenting process.  To avoid this, we pick a random,\n\t# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n\t# time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s|^|_|\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--retain-symbols-file,$output_objdir/$soname.expsym $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t;;\n      irix5* | irix6*)\n        case $cc_basename in\n          CC*)\n\t    # SGI C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -ar\", where \"CC\" is the IRIX C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    if test yes = \"$GXX\"; then\n\t      if test no = \"$with_gnu_ld\"; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n\t      else\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` -o $lib'\n\t      fi\n\t    fi\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\t    ;;\n        esac\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(inherit_rpath, $1)=yes\n        ;;\n\n      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\$tempext\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\$tempext\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib $wl-retain-symbols-file,$export_symbols; mv \\$templib $lib'\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP \"ld\"`; rm -f libconftest$shared_ext; list= ; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -Bstatic\", where \"CC\" is the KAI C++ compiler.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'\n\t    ;;\n\t  icpc* | ecpc* )\n\t    # Intel C++\n\t    with_gnu_ld=yes\n\t    # version 8.0 and above of icpc choke on multiply defined symbols\n\t    # if we add $predep_objects and $postdep_objects, however 7.1 and\n\t    # earlier do not add the objects themselves.\n\t    case `$CC -V 2>&1` in\n\t      *\"Version 7.\"*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t      *)  # Version 8.0 or newer\n\t        tmp_idyn=\n\t        case $host_cpu in\n\t\t  ia64*) tmp_idyn=' -i_dynamic';;\n\t\tesac\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t    esac\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive$convenience $wl--no-whole-archive'\n\t    ;;\n          pgCC* | pgcpp*)\n            # Portland Group C++ compiler\n\t    case `$CC -V` in\n\t    *pgCC\\ [[1-5]].* | *pgcpp\\ [[1-5]].*)\n\t      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~\n               rm -rf $tpldir~\n               $CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~\n               compile_command=\"$compile_command `find $tpldir -name \\*.o | sort | $NL2SP`\"'\n\t      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~\n                rm -rf $tpldir~\n                $CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~\n                $AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \\*.o | sort | $NL2SP`~\n                $RANLIB $oldlib'\n\t      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~\n                rm -rf $tpldir~\n                $CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n                $CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | sort | $NL2SP` $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~\n                rm -rf $tpldir~\n                $CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n                $CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | sort | $NL2SP` $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\t      ;;\n\t    *) # Version 6 and above use weak symbols\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\t      ;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl--rpath $wl$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n            ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname  -o $lib $wl-retain-symbols-file $wl$export_symbols'\n\n\t    runpath_var=LD_RUN_PATH\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld .*$\\)/\\1/\"`; list= ; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"X$list\" | $Xsed'\n\t    ;;\n\t  xl* | mpixl* | bgxl*)\n\t    # IBM XL 8.0 on PPC, with GNU ld\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t    if test yes = \"$supports_anon_versioning\"; then\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n                cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n                echo \"local: *; };\" >> $output_objdir/$libname.ver~\n                $CC -qmkshrobj $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-version-script $wl$output_objdir/$libname.ver -o $lib'\n\t    fi\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -G$allow_undefined_flag -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G$allow_undefined_flag -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-retain-symbols-file $wl$export_symbols'\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n\t      _LT_TAGVAR(compiler_needs_object, $1)=yes\n\n\t      # Not sure whether something based on\n\t      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1\n\t      # would be better.\n\t      output_verbose_link_cmd='func_echo_all'\n\n\t      # Archives containing C++ object files must be created using\n\t      # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t      # necessary to make sure instantiated templates are included\n\t      # in the archive.\n\t      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n\n      lynxos*)\n        # FIXME: insert proper C++ library support\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      m88k*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      mvs*)\n        case $cc_basename in\n          cxx*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\t  *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\tesac\n\t;;\n\n      netbsd*)\n        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'\n\t  wlarc=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\tfi\n\t# Workaround some broken pre-1.5 toolchains\n\toutput_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e \"s:-lgcc -lc -lgcc::\"'\n\t;;\n\n      *nto* | *qnx*)\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n\t;;\n\n      openbsd* | bitrig*)\n\tif test -f /usr/libexec/ld.so; then\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t  if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-retain-symbols-file,$export_symbols -o $lib'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)=$wlarc'--whole-archive$convenience '$wlarc'--no-whole-archive'\n\t  fi\n\t  output_verbose_link_cmd=func_echo_all\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      osf3* | osf4* | osf5*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo \"$lib\" | $SED -e \"s/\\$tempext\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Archives containing C++ object files must be created using\n\t    # the KAI C++ compiler.\n\t    case $host in\n\t      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;\n\t      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;\n\t    esac\n\t    ;;\n          RCC*)\n\t    # Rational C++ 2.4.1\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          cxx*)\n\t    case $host in\n\t      osf3*)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n\t\t;;\n\t      *)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done~\n                  echo \"-hidden\">> $lib.exp~\n                  $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname $wl-input $wl$lib.exp  `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib~\n                  $RM $lib.exp'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t\t;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\" | $GREP -v \"ld:\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld.*$\\)/\\1/\"`; list= ; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n\t  *)\n\t    if test yes,no = \"$GXX,$with_gnu_ld\"; then\n\t      _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\\*'\n\t      case $host in\n\t        osf3*)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n\t\t  ;;\n\t        *)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-msym $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n\t\t  ;;\n\t      esac\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n\t      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t      # Commands to make compiler produce verbose output that lists\n\t      # what \"hidden\" libraries, object files and flags are used when\n\t      # linking a shared library.\n\t      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      psos*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      sunos4*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.x\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          lcc*)\n\t    # Lucid\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      solaris*)\n        case $cc_basename in\n          CC* | sunCC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G$allow_undefined_flag -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n              $CC -G$allow_undefined_flag $wl-M $wl$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t    case $host_os in\n\t      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t      *)\n\t\t# The compiler driver will combine and reorder linker options,\n\t\t# but understands '-z linker_flag'.\n\t        # Supported since Solaris 2.6 (maybe 2.5.1?)\n\t\t_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\t        ;;\n\t    esac\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\n\t    output_verbose_link_cmd='func_echo_all'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t    ;;\n          gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-h $wl$soname -o $lib'\n\n\t    # The C++ compiler must be used to create the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    # GNU C++ compiler with Solaris linker\n\t    if test yes,no = \"$GXX,$with_gnu_ld\"; then\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' $wl-z ${wl}defs'\n\t      if $CC --version | $GREP -v '^2\\.7' > /dev/null; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n                  $CC -shared $pic_flag -nostdlib $wl-M $wl$lib.exp $wl-h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      else\n\t        # g++ 2.7 appears to require '-G' NOT '-shared' on this\n\t        # platform.\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n                  $CC -G -nostdlib $wl-M $wl$lib.exp $wl-h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      fi\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R $wl$libdir'\n\t      case $host_os in\n\t\tsolaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t\t*)\n\t\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl-z ${wl}allextract$convenience $wl-z ${wl}defaultextract'\n\t\t  ;;\n\t      esac\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      case $cc_basename in\n        CC*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n      esac\n      ;;\n\n      sysv5* | sco3.2v5* | sco5v6*)\n\t# Note: We CANNOT use -z defs as we might desire, because we do not\n\t# link with -lc, and that would cause any symbols used from libc to\n\t# always be unresolved, which means just about no library would\n\t# ever link correctly.  If we're not using GNU ld we use -z text\n\t# though, which does catch some bad symbols but isn't as heavy-handed\n\t# as -z defs.\n\t_LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'\n\t_LT_TAGVAR(allow_undefined_flag, $1)='$wl-z,nodefs'\n\t_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R,$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n\t_LT_TAGVAR(link_all_deplibs, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-Bexport'\n\trunpath_var='LD_RUN_PATH'\n\n\tcase $cc_basename in\n          CC*)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Tprelink_objects $oldobjs~\n              '\"$_LT_TAGVAR(old_archive_cmds, $1)\"\n\t    _LT_TAGVAR(reload_cmds, $1)='$CC -Tprelink_objects $reload_objs~\n              '\"$_LT_TAGVAR(reload_cmds, $1)\"\n\t    ;;\n\t  *)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    ;;\n\tesac\n      ;;\n\n      tandem*)\n        case $cc_basename in\n          NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      vxworks*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      *)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n    esac\n\n    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\n    test no = \"$_LT_TAGVAR(ld_shlibs, $1)\" && can_build_shared=no\n\n    _LT_TAGVAR(GCC, $1)=$GXX\n    _LT_TAGVAR(LD, $1)=$LD\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\n  LDCXX=$LD\n  LD=$lt_save_LD\n  GCC=$lt_save_GCC\n  with_gnu_ld=$lt_save_with_gnu_ld\n  lt_cv_path_LDCXX=$lt_cv_path_LD\n  lt_cv_path_LD=$lt_save_path_LD\n  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld\n  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld\nfi # test yes != \"$_lt_caught_CXX_error\"\n\nAC_LANG_POP\n])# _LT_LANG_CXX_CONFIG\n\n\n# _LT_FUNC_STRIPNAME_CNF\n# ----------------------\n# func_stripname_cnf prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n#\n# This function is identical to the (non-XSI) version of func_stripname,\n# except this one can be used by m4 code that may be executed by configure,\n# rather than the libtool script.\nm4_defun([_LT_FUNC_STRIPNAME_CNF],[dnl\nAC_REQUIRE([_LT_DECL_SED])\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])\nfunc_stripname_cnf ()\n{\n  case @S|@2 in\n  .*) func_stripname_result=`$ECHO \"@S|@3\" | $SED \"s%^@S|@1%%; s%\\\\\\\\@S|@2\\$%%\"`;;\n  *)  func_stripname_result=`$ECHO \"@S|@3\" | $SED \"s%^@S|@1%%; s%@S|@2\\$%%\"`;;\n  esac\n} # func_stripname_cnf\n])# _LT_FUNC_STRIPNAME_CNF\n\n\n# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])\n# ---------------------------------\n# Figure out \"hidden\" library dependencies from verbose\n# compiler output when linking a shared library.\n# Parse the compiler output and extract the necessary\n# objects, libraries and library flags.\nm4_defun([_LT_SYS_HIDDEN_LIBDEPS],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nAC_REQUIRE([_LT_FUNC_STRIPNAME_CNF])dnl\n# Dependencies to place before and after the object being linked:\n_LT_TAGVAR(predep_objects, $1)=\n_LT_TAGVAR(postdep_objects, $1)=\n_LT_TAGVAR(predeps, $1)=\n_LT_TAGVAR(postdeps, $1)=\n_LT_TAGVAR(compiler_lib_search_path, $1)=\n\ndnl we can't use the lt_simple_compile_test_code here,\ndnl because it contains code intended for an executable,\ndnl not a library.  It's possible we should let each\ndnl tag define a new lt_????_link_test_code variable,\ndnl but it's only used here...\nm4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF\nint a;\nvoid foo (void) { a = 0; }\n_LT_EOF\n], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF\nclass Foo\n{\npublic:\n  Foo (void) { a = 0; }\nprivate:\n  int a;\n};\n_LT_EOF\n], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer*4 a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF\npublic class foo {\n  private int a;\n  public void bar (void) {\n    a = 0;\n  }\n};\n_LT_EOF\n], [$1], [GO], [cat > conftest.$ac_ext <<_LT_EOF\npackage foo\nfunc foo() {\n}\n_LT_EOF\n])\n\n_lt_libdeps_save_CFLAGS=$CFLAGS\ncase \"$CC $CFLAGS \" in #(\n*\\ -flto*\\ *) CFLAGS=\"$CFLAGS -fno-lto\" ;;\n*\\ -fwhopr*\\ *) CFLAGS=\"$CFLAGS -fno-whopr\" ;;\n*\\ -fuse-linker-plugin*\\ *) CFLAGS=\"$CFLAGS -fno-use-linker-plugin\" ;;\nesac\n\ndnl Parse the compiler output and extract the necessary\ndnl objects, libraries and library flags.\nif AC_TRY_EVAL(ac_compile); then\n  # Parse the compiler output and extract the necessary\n  # objects, libraries and library flags.\n\n  # Sentinel used to keep track of whether or not we are before\n  # the conftest object file.\n  pre_test_object_deps_done=no\n\n  for p in `eval \"$output_verbose_link_cmd\"`; do\n    case $prev$p in\n\n    -L* | -R* | -l*)\n       # Some compilers place space between \"-{L,R}\" and the path.\n       # Remove the space.\n       if test x-L = \"$p\" ||\n          test x-R = \"$p\"; then\n\t prev=$p\n\t continue\n       fi\n\n       # Expand the sysroot to ease extracting the directories later.\n       if test -z \"$prev\"; then\n         case $p in\n         -L*) func_stripname_cnf '-L' '' \"$p\"; prev=-L; p=$func_stripname_result ;;\n         -R*) func_stripname_cnf '-R' '' \"$p\"; prev=-R; p=$func_stripname_result ;;\n         -l*) func_stripname_cnf '-l' '' \"$p\"; prev=-l; p=$func_stripname_result ;;\n         esac\n       fi\n       case $p in\n       =*) func_stripname_cnf '=' '' \"$p\"; p=$lt_sysroot$func_stripname_result ;;\n       esac\n       if test no = \"$pre_test_object_deps_done\"; then\n\t case $prev in\n\t -L | -R)\n\t   # Internal compiler library paths should come after those\n\t   # provided the user.  The postdeps already come after the\n\t   # user supplied libs so there is no need to process them.\n\t   if test -z \"$_LT_TAGVAR(compiler_lib_search_path, $1)\"; then\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=$prev$p\n\t   else\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${_LT_TAGVAR(compiler_lib_search_path, $1)} $prev$p\"\n\t   fi\n\t   ;;\n\t # The \"-l\" case would never come before the object being\n\t # linked, so don't bother handling this case.\n\t esac\n       else\n\t if test -z \"$_LT_TAGVAR(postdeps, $1)\"; then\n\t   _LT_TAGVAR(postdeps, $1)=$prev$p\n\t else\n\t   _LT_TAGVAR(postdeps, $1)=\"${_LT_TAGVAR(postdeps, $1)} $prev$p\"\n\t fi\n       fi\n       prev=\n       ;;\n\n    *.lto.$objext) ;; # Ignore GCC LTO objects\n    *.$objext)\n       # This assumes that the test object file only shows up\n       # once in the compiler output.\n       if test \"$p\" = \"conftest.$objext\"; then\n\t pre_test_object_deps_done=yes\n\t continue\n       fi\n\n       if test no = \"$pre_test_object_deps_done\"; then\n\t if test -z \"$_LT_TAGVAR(predep_objects, $1)\"; then\n\t   _LT_TAGVAR(predep_objects, $1)=$p\n\t else\n\t   _LT_TAGVAR(predep_objects, $1)=\"$_LT_TAGVAR(predep_objects, $1) $p\"\n\t fi\n       else\n\t if test -z \"$_LT_TAGVAR(postdep_objects, $1)\"; then\n\t   _LT_TAGVAR(postdep_objects, $1)=$p\n\t else\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$_LT_TAGVAR(postdep_objects, $1) $p\"\n\t fi\n       fi\n       ;;\n\n    *) ;; # Ignore the rest.\n\n    esac\n  done\n\n  # Clean up.\n  rm -f a.out a.exe\nelse\n  echo \"libtool.m4: error: problem compiling $1 test program\"\nfi\n\n$RM -f confest.$objext\nCFLAGS=$_lt_libdeps_save_CFLAGS\n\n# PORTME: override above test on systems where it is broken\nm4_if([$1], [CXX],\n[case $host_os in\ninterix[[3-9]]*)\n  # Interix 3.5 installs completely hosed .la files for C++, so rather than\n  # hack all around it, let's just trust \"g++\" to DTRT.\n  _LT_TAGVAR(predep_objects,$1)=\n  _LT_TAGVAR(postdep_objects,$1)=\n  _LT_TAGVAR(postdeps,$1)=\n  ;;\nesac\n])\n\ncase \" $_LT_TAGVAR(postdeps, $1) \" in\n*\" -lc \"*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;\nesac\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=\nif test -n \"${_LT_TAGVAR(compiler_lib_search_path, $1)}\"; then\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo \" ${_LT_TAGVAR(compiler_lib_search_path, $1)}\" | $SED -e 's! -L! !g' -e 's!^ !!'`\nfi\n_LT_TAGDECL([], [compiler_lib_search_dirs], [1],\n    [The directories searched by this compiler when creating a shared library])\n_LT_TAGDECL([], [predep_objects], [1],\n    [Dependencies to place before and after the objects being linked to\n    create a shared library])\n_LT_TAGDECL([], [postdep_objects], [1])\n_LT_TAGDECL([], [predeps], [1])\n_LT_TAGDECL([], [postdeps], [1])\n_LT_TAGDECL([], [compiler_lib_search_path], [1],\n    [The library search path used internally by the compiler when linking\n    a shared library])\n])# _LT_SYS_HIDDEN_LIBDEPS\n\n\n# _LT_LANG_F77_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a Fortran 77 compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_F77_CONFIG],\n[AC_LANG_PUSH(Fortran 77)\nif test -z \"$F77\" || test no = \"$F77\"; then\n  _lt_disable_F77=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for f77 test sources.\nac_ext=f\n\n# Object file extension for compiled f77 test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the F77 compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test yes != \"$_lt_disable_F77\"; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_GCC=$GCC\n  lt_save_CFLAGS=$CFLAGS\n  CC=${F77-\"f77\"}\n  CFLAGS=$FFLAGS\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n  GCC=$G77\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test no = \"$can_build_shared\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test yes = \"$enable_shared\" && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test ia64 != \"$host_cpu\"; then\n\t  case $enable_shared,$with_aix_soname,$aix_use_runtimelinking in\n\t  yes,aix,yes) ;;\t\t# shared object as lib.so file only\n\t  yes,svr4,*) ;;\t\t# shared object as lib.so archive member only\n\t  yes,*) enable_static=no ;;\t# shared object in lib.a archive as well\n\t  esac\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test yes = \"$enable_shared\" || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=$G77\n    _LT_TAGVAR(LD, $1)=$LD\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\nfi # test yes != \"$_lt_disable_F77\"\n\nAC_LANG_POP\n])# _LT_LANG_F77_CONFIG\n\n\n# _LT_LANG_FC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for a Fortran compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_FC_CONFIG],\n[AC_LANG_PUSH(Fortran)\n\nif test -z \"$FC\" || test no = \"$FC\"; then\n  _lt_disable_FC=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for fc test sources.\nac_ext=${ac_fc_srcext-f}\n\n# Object file extension for compiled fc test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the FC compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test yes != \"$_lt_disable_FC\"; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_GCC=$GCC\n  lt_save_CFLAGS=$CFLAGS\n  CC=${FC-\"f95\"}\n  CFLAGS=$FCFLAGS\n  compiler=$CC\n  GCC=$ac_cv_fc_compiler_gnu\n\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test no = \"$can_build_shared\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test yes = \"$enable_shared\" && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test ia64 != \"$host_cpu\"; then\n\t  case $enable_shared,$with_aix_soname,$aix_use_runtimelinking in\n\t  yes,aix,yes) ;;\t\t# shared object as lib.so file only\n\t  yes,svr4,*) ;;\t\t# shared object as lib.so archive member only\n\t  yes,*) enable_static=no ;;\t# shared object in lib.a archive as well\n\t  esac\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test yes = \"$enable_shared\" || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=$ac_cv_fc_compiler_gnu\n    _LT_TAGVAR(LD, $1)=$LD\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\nfi # test yes != \"$_lt_disable_FC\"\n\nAC_LANG_POP\n])# _LT_LANG_FC_CONFIG\n\n\n# _LT_LANG_GCJ_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Java Compiler compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_GCJ_CONFIG],\n[AC_REQUIRE([LT_PROG_GCJ])dnl\nAC_LANG_SAVE\n\n# Source file extension for Java test sources.\nac_ext=java\n\n# Object file extension for compiled Java test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"class foo {}\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GCJ-\"gcj\"}\nCFLAGS=$GCJFLAGS\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=$LD\n_LT_CC_BASENAME([$compiler])\n\n# GCJ did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_GCJ_CONFIG\n\n\n# _LT_LANG_GO_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Go compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_GO_CONFIG],\n[AC_REQUIRE([LT_PROG_GO])dnl\nAC_LANG_SAVE\n\n# Source file extension for Go test sources.\nac_ext=go\n\n# Object file extension for compiled Go test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"package main; func main() { }\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='package main; func main() { }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GOC-\"gccgo\"}\nCFLAGS=$GOFLAGS\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=$LD\n_LT_CC_BASENAME([$compiler])\n\n# Go did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_GO_CONFIG\n\n\n# _LT_LANG_RC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for the Windows resource compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_RC_CONFIG],\n[AC_REQUIRE([LT_PROG_RC])dnl\nAC_LANG_SAVE\n\n# Source file extension for RC test sources.\nac_ext=rc\n\n# Object file extension for compiled RC test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code='sample MENU { MENUITEM \"&Soup\", 100, CHECKED }'\n\n# Code to be used in simple link tests\nlt_simple_link_test_code=$lt_simple_compile_test_code\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=\nCC=${RC-\"windres\"}\nCFLAGS=\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n\nif test -n \"$compiler\"; then\n  :\n  _LT_CONFIG($1)\nfi\n\nGCC=$lt_save_GCC\nAC_LANG_RESTORE\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_RC_CONFIG\n\n\n# LT_PROG_GCJ\n# -----------\nAC_DEFUN([LT_PROG_GCJ],\n[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],\n  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],\n    [AC_CHECK_TOOL(GCJ, gcj,)\n      test set = \"${GCJFLAGS+set}\" || GCJFLAGS=\"-g -O2\"\n      AC_SUBST(GCJFLAGS)])])[]dnl\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_GCJ], [])\n\n\n# LT_PROG_GO\n# ----------\nAC_DEFUN([LT_PROG_GO],\n[AC_CHECK_TOOL(GOC, gccgo,)\n])\n\n\n# LT_PROG_RC\n# ----------\nAC_DEFUN([LT_PROG_RC],\n[AC_CHECK_TOOL(RC, windres,)\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_RC], [])\n\n\n# _LT_DECL_EGREP\n# --------------\n# If we don't have a new enough Autoconf to choose the best grep\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_EGREP],\n[AC_REQUIRE([AC_PROG_EGREP])dnl\nAC_REQUIRE([AC_PROG_FGREP])dnl\ntest -z \"$GREP\" && GREP=grep\n_LT_DECL([], [GREP], [1], [A grep program that handles long lines])\n_LT_DECL([], [EGREP], [1], [An ERE matcher])\n_LT_DECL([], [FGREP], [1], [A literal string matcher])\ndnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too\nAC_SUBST([GREP])\n])\n\n\n# _LT_DECL_OBJDUMP\n# --------------\n# If we don't have a new enough Autoconf to choose the best objdump\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_OBJDUMP],\n[AC_CHECK_TOOL(OBJDUMP, objdump, false)\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])\nAC_SUBST([OBJDUMP])\n])\n\n# _LT_DECL_DLLTOOL\n# ----------------\n# Ensure DLLTOOL variable is set.\nm4_defun([_LT_DECL_DLLTOOL],\n[AC_CHECK_TOOL(DLLTOOL, dlltool, false)\ntest -z \"$DLLTOOL\" && DLLTOOL=dlltool\n_LT_DECL([], [DLLTOOL], [1], [DLL creation program])\nAC_SUBST([DLLTOOL])\n])\n\n# _LT_DECL_SED\n# ------------\n# Check for a fully-functional sed program, that truncates\n# as few characters as possible.  Prefer GNU sed if found.\nm4_defun([_LT_DECL_SED],\n[AC_PROG_SED\ntest -z \"$SED\" && SED=sed\nXsed=\"$SED -e 1s/^X//\"\n_LT_DECL([], [SED], [1], [A sed program that does not truncate output])\n_LT_DECL([], [Xsed], [\"\\$SED -e 1s/^X//\"],\n    [Sed that helps us avoid accidentally triggering echo(1) options like -n])\n])# _LT_DECL_SED\n\nm4_ifndef([AC_PROG_SED], [\n############################################################\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_SED.  When it is available in   #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n############################################################\n\nm4_defun([AC_PROG_SED],\n[AC_MSG_CHECKING([for a sed that does not truncate output])\nAC_CACHE_VAL(lt_cv_path_SED,\n[# Loop through the user's path and test for sed and gsed.\n# Then use that list of sed's as ones to test for truncation.\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n  for lt_ac_prog in sed gsed; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      if $as_executable_p \"$as_dir/$lt_ac_prog$ac_exec_ext\"; then\n        lt_ac_sed_list=\"$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext\"\n      fi\n    done\n  done\ndone\nIFS=$as_save_IFS\nlt_ac_max=0\nlt_ac_count=0\n# Add /usr/xpg4/bin/sed as it is typically found on Solaris\n# along with /bin/sed that truncates output.\nfor lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do\n  test ! -f \"$lt_ac_sed\" && continue\n  cat /dev/null > conftest.in\n  lt_ac_count=0\n  echo $ECHO_N \"0123456789$ECHO_C\" >conftest.in\n  # Check for GNU sed and select it if it is found.\n  if \"$lt_ac_sed\" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then\n    lt_cv_path_SED=$lt_ac_sed\n    break\n  fi\n  while true; do\n    cat conftest.in conftest.in >conftest.tmp\n    mv conftest.tmp conftest.in\n    cp conftest.in conftest.nl\n    echo >>conftest.nl\n    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break\n    cmp -s conftest.out conftest.nl || break\n    # 10000 chars as input seems more than enough\n    test 10 -lt \"$lt_ac_count\" && break\n    lt_ac_count=`expr $lt_ac_count + 1`\n    if test \"$lt_ac_count\" -gt \"$lt_ac_max\"; then\n      lt_ac_max=$lt_ac_count\n      lt_cv_path_SED=$lt_ac_sed\n    fi\n  done\ndone\n])\nSED=$lt_cv_path_SED\nAC_SUBST([SED])\nAC_MSG_RESULT([$SED])\n])#AC_PROG_SED\n])#m4_ifndef\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_SED], [])\n\n\n# _LT_CHECK_SHELL_FEATURES\n# ------------------------\n# Find out whether the shell is Bourne or XSI compatible,\n# or has some other useful features.\nm4_defun([_LT_CHECK_SHELL_FEATURES],\n[if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then\n  lt_unset=unset\nelse\n  lt_unset=false\nfi\n_LT_DECL([], [lt_unset], [0], [whether the shell understands \"unset\"])dnl\n\n# test EBCDIC or ASCII\ncase `echo X|tr X '\\101'` in\n A) # ASCII based system\n    # \\n is not interpreted correctly by Solaris 8 /usr/ucb/tr\n  lt_SP2NL='tr \\040 \\012'\n  lt_NL2SP='tr \\015\\012 \\040\\040'\n  ;;\n *) # EBCDIC based system\n  lt_SP2NL='tr \\100 \\n'\n  lt_NL2SP='tr \\r\\n \\100\\100'\n  ;;\nesac\n_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl\n_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl\n])# _LT_CHECK_SHELL_FEATURES\n\n\n# _LT_PATH_CONVERSION_FUNCTIONS\n# -----------------------------\n# Determine what file name conversion functions should be used by\n# func_to_host_file (and, implicitly, by func_to_host_path).  These are needed\n# for certain cross-compile configurations and native mingw.\nm4_defun([_LT_PATH_CONVERSION_FUNCTIONS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_MSG_CHECKING([how to convert $build file names to $host format])\nAC_CACHE_VAL(lt_cv_to_host_file_cmd,\n[case $host in\n  *-*-mingw* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_host_file_cmd=func_convert_file_msys_to_w32\n        ;;\n      *-*-cygwin* )\n        lt_cv_to_host_file_cmd=func_convert_file_cygwin_to_w32\n        ;;\n      * ) # otherwise, assume *nix\n        lt_cv_to_host_file_cmd=func_convert_file_nix_to_w32\n        ;;\n    esac\n    ;;\n  *-*-cygwin* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_host_file_cmd=func_convert_file_msys_to_cygwin\n        ;;\n      *-*-cygwin* )\n        lt_cv_to_host_file_cmd=func_convert_file_noop\n        ;;\n      * ) # otherwise, assume *nix\n        lt_cv_to_host_file_cmd=func_convert_file_nix_to_cygwin\n        ;;\n    esac\n    ;;\n  * ) # unhandled hosts (and \"normal\" native builds)\n    lt_cv_to_host_file_cmd=func_convert_file_noop\n    ;;\nesac\n])\nto_host_file_cmd=$lt_cv_to_host_file_cmd\nAC_MSG_RESULT([$lt_cv_to_host_file_cmd])\n_LT_DECL([to_host_file_cmd], [lt_cv_to_host_file_cmd],\n         [0], [convert $build file names to $host format])dnl\n\nAC_MSG_CHECKING([how to convert $build file names to toolchain format])\nAC_CACHE_VAL(lt_cv_to_tool_file_cmd,\n[#assume ordinary cross tools, or native build.\nlt_cv_to_tool_file_cmd=func_convert_file_noop\ncase $host in\n  *-*-mingw* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_tool_file_cmd=func_convert_file_msys_to_w32\n        ;;\n    esac\n    ;;\nesac\n])\nto_tool_file_cmd=$lt_cv_to_tool_file_cmd\nAC_MSG_RESULT([$lt_cv_to_tool_file_cmd])\n_LT_DECL([to_tool_file_cmd], [lt_cv_to_tool_file_cmd],\n         [0], [convert $build files to toolchain format])dnl\n])# _LT_PATH_CONVERSION_FUNCTIONS\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/m4/ltoptions.m4": "# Helper functions for option handling.                    -*- Autoconf -*-\n#\n#   Copyright (C) 2004-2005, 2007-2009, 2011-2015 Free Software\n#   Foundation, Inc.\n#   Written by Gary V. Vaughan, 2004\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\n# serial 8 ltoptions.m4\n\n# This is to help aclocal find these macros, as it can't see m4_define.\nAC_DEFUN([LTOPTIONS_VERSION], [m4_if([1])])\n\n\n# _LT_MANGLE_OPTION(MACRO-NAME, OPTION-NAME)\n# ------------------------------------------\nm4_define([_LT_MANGLE_OPTION],\n[[_LT_OPTION_]m4_bpatsubst($1__$2, [[^a-zA-Z0-9_]], [_])])\n\n\n# _LT_SET_OPTION(MACRO-NAME, OPTION-NAME)\n# ---------------------------------------\n# Set option OPTION-NAME for macro MACRO-NAME, and if there is a\n# matching handler defined, dispatch to it.  Other OPTION-NAMEs are\n# saved as a flag.\nm4_define([_LT_SET_OPTION],\n[m4_define(_LT_MANGLE_OPTION([$1], [$2]))dnl\nm4_ifdef(_LT_MANGLE_DEFUN([$1], [$2]),\n        _LT_MANGLE_DEFUN([$1], [$2]),\n    [m4_warning([Unknown $1 option '$2'])])[]dnl\n])\n\n\n# _LT_IF_OPTION(MACRO-NAME, OPTION-NAME, IF-SET, [IF-NOT-SET])\n# ------------------------------------------------------------\n# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\nm4_define([_LT_IF_OPTION],\n[m4_ifdef(_LT_MANGLE_OPTION([$1], [$2]), [$3], [$4])])\n\n\n# _LT_UNLESS_OPTIONS(MACRO-NAME, OPTION-LIST, IF-NOT-SET)\n# -------------------------------------------------------\n# Execute IF-NOT-SET unless all options in OPTION-LIST for MACRO-NAME\n# are set.\nm4_define([_LT_UNLESS_OPTIONS],\n[m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),\n\t    [m4_ifdef(_LT_MANGLE_OPTION([$1], _LT_Option),\n\t\t      [m4_define([$0_found])])])[]dnl\nm4_ifdef([$0_found], [m4_undefine([$0_found])], [$3\n])[]dnl\n])\n\n\n# _LT_SET_OPTIONS(MACRO-NAME, OPTION-LIST)\n# ----------------------------------------\n# OPTION-LIST is a space-separated list of Libtool options associated\n# with MACRO-NAME.  If any OPTION has a matching handler declared with\n# LT_OPTION_DEFINE, dispatch to that macro; otherwise complain about\n# the unknown option and exit.\nm4_defun([_LT_SET_OPTIONS],\n[# Set options\nm4_foreach([_LT_Option], m4_split(m4_normalize([$2])),\n    [_LT_SET_OPTION([$1], _LT_Option)])\n\nm4_if([$1],[LT_INIT],[\n  dnl\n  dnl Simply set some default values (i.e off) if boolean options were not\n  dnl specified:\n  _LT_UNLESS_OPTIONS([LT_INIT], [dlopen], [enable_dlopen=no\n  ])\n  _LT_UNLESS_OPTIONS([LT_INIT], [win32-dll], [enable_win32_dll=no\n  ])\n  dnl\n  dnl If no reference was made to various pairs of opposing options, then\n  dnl we run the default mode handler for the pair.  For example, if neither\n  dnl 'shared' nor 'disable-shared' was passed, we enable building of shared\n  dnl archives by default:\n  _LT_UNLESS_OPTIONS([LT_INIT], [shared disable-shared], [_LT_ENABLE_SHARED])\n  _LT_UNLESS_OPTIONS([LT_INIT], [static disable-static], [_LT_ENABLE_STATIC])\n  _LT_UNLESS_OPTIONS([LT_INIT], [pic-only no-pic], [_LT_WITH_PIC])\n  _LT_UNLESS_OPTIONS([LT_INIT], [fast-install disable-fast-install],\n\t\t   [_LT_ENABLE_FAST_INSTALL])\n  _LT_UNLESS_OPTIONS([LT_INIT], [aix-soname=aix aix-soname=both aix-soname=svr4],\n\t\t   [_LT_WITH_AIX_SONAME([aix])])\n  ])\n])# _LT_SET_OPTIONS\n\n\n## --------------------------------- ##\n## Macros to handle LT_INIT options. ##\n## --------------------------------- ##\n\n# _LT_MANGLE_DEFUN(MACRO-NAME, OPTION-NAME)\n# -----------------------------------------\nm4_define([_LT_MANGLE_DEFUN],\n[[_LT_OPTION_DEFUN_]m4_bpatsubst(m4_toupper([$1__$2]), [[^A-Z0-9_]], [_])])\n\n\n# LT_OPTION_DEFINE(MACRO-NAME, OPTION-NAME, CODE)\n# -----------------------------------------------\nm4_define([LT_OPTION_DEFINE],\n[m4_define(_LT_MANGLE_DEFUN([$1], [$2]), [$3])[]dnl\n])# LT_OPTION_DEFINE\n\n\n# dlopen\n# ------\nLT_OPTION_DEFINE([LT_INIT], [dlopen], [enable_dlopen=yes\n])\n\nAU_DEFUN([AC_LIBTOOL_DLOPEN],\n[_LT_SET_OPTION([LT_INIT], [dlopen])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the 'dlopen' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN], [])\n\n\n# win32-dll\n# ---------\n# Declare package support for building win32 dll's.\nLT_OPTION_DEFINE([LT_INIT], [win32-dll],\n[enable_win32_dll=yes\n\ncase $host in\n*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-cegcc*)\n  AC_CHECK_TOOL(AS, as, false)\n  AC_CHECK_TOOL(DLLTOOL, dlltool, false)\n  AC_CHECK_TOOL(OBJDUMP, objdump, false)\n  ;;\nesac\n\ntest -z \"$AS\" && AS=as\n_LT_DECL([], [AS],      [1], [Assembler program])dnl\n\ntest -z \"$DLLTOOL\" && DLLTOOL=dlltool\n_LT_DECL([], [DLLTOOL], [1], [DLL creation program])dnl\n\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [Object dumper program])dnl\n])# win32-dll\n\nAU_DEFUN([AC_LIBTOOL_WIN32_DLL],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n_LT_SET_OPTION([LT_INIT], [win32-dll])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the 'win32-dll' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_WIN32_DLL], [])\n\n\n# _LT_ENABLE_SHARED([DEFAULT])\n# ----------------------------\n# implement the --enable-shared flag, and supports the 'shared' and\n# 'disable-shared' LT_INIT options.\n# DEFAULT is either 'yes' or 'no'.  If omitted, it defaults to 'yes'.\nm4_define([_LT_ENABLE_SHARED],\n[m4_define([_LT_ENABLE_SHARED_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([shared],\n    [AS_HELP_STRING([--enable-shared@<:@=PKGS@:>@],\n\t[build shared libraries @<:@default=]_LT_ENABLE_SHARED_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_shared=yes ;;\n    no) enable_shared=no ;;\n    *)\n      enable_shared=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,\n      for pkg in $enableval; do\n\tIFS=$lt_save_ifs\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_shared=yes\n\tfi\n      done\n      IFS=$lt_save_ifs\n      ;;\n    esac],\n    [enable_shared=]_LT_ENABLE_SHARED_DEFAULT)\n\n    _LT_DECL([build_libtool_libs], [enable_shared], [0],\n\t[Whether or not to build shared libraries])\n])# _LT_ENABLE_SHARED\n\nLT_OPTION_DEFINE([LT_INIT], [shared], [_LT_ENABLE_SHARED([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-shared], [_LT_ENABLE_SHARED([no])])\n\n# Old names:\nAC_DEFUN([AC_ENABLE_SHARED],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[shared])\n])\n\nAC_DEFUN([AC_DISABLE_SHARED],\n[_LT_SET_OPTION([LT_INIT], [disable-shared])\n])\n\nAU_DEFUN([AM_ENABLE_SHARED], [AC_ENABLE_SHARED($@)])\nAU_DEFUN([AM_DISABLE_SHARED], [AC_DISABLE_SHARED($@)])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_ENABLE_SHARED], [])\ndnl AC_DEFUN([AM_DISABLE_SHARED], [])\n\n\n\n# _LT_ENABLE_STATIC([DEFAULT])\n# ----------------------------\n# implement the --enable-static flag, and support the 'static' and\n# 'disable-static' LT_INIT options.\n# DEFAULT is either 'yes' or 'no'.  If omitted, it defaults to 'yes'.\nm4_define([_LT_ENABLE_STATIC],\n[m4_define([_LT_ENABLE_STATIC_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([static],\n    [AS_HELP_STRING([--enable-static@<:@=PKGS@:>@],\n\t[build static libraries @<:@default=]_LT_ENABLE_STATIC_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_static=yes ;;\n    no) enable_static=no ;;\n    *)\n     enable_static=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,\n      for pkg in $enableval; do\n\tIFS=$lt_save_ifs\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_static=yes\n\tfi\n      done\n      IFS=$lt_save_ifs\n      ;;\n    esac],\n    [enable_static=]_LT_ENABLE_STATIC_DEFAULT)\n\n    _LT_DECL([build_old_libs], [enable_static], [0],\n\t[Whether or not to build static libraries])\n])# _LT_ENABLE_STATIC\n\nLT_OPTION_DEFINE([LT_INIT], [static], [_LT_ENABLE_STATIC([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-static], [_LT_ENABLE_STATIC([no])])\n\n# Old names:\nAC_DEFUN([AC_ENABLE_STATIC],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[static])\n])\n\nAC_DEFUN([AC_DISABLE_STATIC],\n[_LT_SET_OPTION([LT_INIT], [disable-static])\n])\n\nAU_DEFUN([AM_ENABLE_STATIC], [AC_ENABLE_STATIC($@)])\nAU_DEFUN([AM_DISABLE_STATIC], [AC_DISABLE_STATIC($@)])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_ENABLE_STATIC], [])\ndnl AC_DEFUN([AM_DISABLE_STATIC], [])\n\n\n\n# _LT_ENABLE_FAST_INSTALL([DEFAULT])\n# ----------------------------------\n# implement the --enable-fast-install flag, and support the 'fast-install'\n# and 'disable-fast-install' LT_INIT options.\n# DEFAULT is either 'yes' or 'no'.  If omitted, it defaults to 'yes'.\nm4_define([_LT_ENABLE_FAST_INSTALL],\n[m4_define([_LT_ENABLE_FAST_INSTALL_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([fast-install],\n    [AS_HELP_STRING([--enable-fast-install@<:@=PKGS@:>@],\n    [optimize for fast installation @<:@default=]_LT_ENABLE_FAST_INSTALL_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_fast_install=yes ;;\n    no) enable_fast_install=no ;;\n    *)\n      enable_fast_install=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,\n      for pkg in $enableval; do\n\tIFS=$lt_save_ifs\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_fast_install=yes\n\tfi\n      done\n      IFS=$lt_save_ifs\n      ;;\n    esac],\n    [enable_fast_install=]_LT_ENABLE_FAST_INSTALL_DEFAULT)\n\n_LT_DECL([fast_install], [enable_fast_install], [0],\n\t [Whether or not to optimize for fast installation])dnl\n])# _LT_ENABLE_FAST_INSTALL\n\nLT_OPTION_DEFINE([LT_INIT], [fast-install], [_LT_ENABLE_FAST_INSTALL([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-fast-install], [_LT_ENABLE_FAST_INSTALL([no])])\n\n# Old names:\nAU_DEFUN([AC_ENABLE_FAST_INSTALL],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[fast-install])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you put\nthe 'fast-install' option into LT_INIT's first parameter.])\n])\n\nAU_DEFUN([AC_DISABLE_FAST_INSTALL],\n[_LT_SET_OPTION([LT_INIT], [disable-fast-install])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you put\nthe 'disable-fast-install' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_ENABLE_FAST_INSTALL], [])\ndnl AC_DEFUN([AM_DISABLE_FAST_INSTALL], [])\n\n\n# _LT_WITH_AIX_SONAME([DEFAULT])\n# ----------------------------------\n# implement the --with-aix-soname flag, and support the `aix-soname=aix'\n# and `aix-soname=both' and `aix-soname=svr4' LT_INIT options. DEFAULT\n# is either `aix', `both' or `svr4'.  If omitted, it defaults to `aix'.\nm4_define([_LT_WITH_AIX_SONAME],\n[m4_define([_LT_WITH_AIX_SONAME_DEFAULT], [m4_if($1, svr4, svr4, m4_if($1, both, both, aix))])dnl\nshared_archive_member_spec=\ncase $host,$enable_shared in\npower*-*-aix[[5-9]]*,yes)\n  AC_MSG_CHECKING([which variant of shared library versioning to provide])\n  AC_ARG_WITH([aix-soname],\n    [AS_HELP_STRING([--with-aix-soname=aix|svr4|both],\n      [shared library versioning (aka \"SONAME\") variant to provide on AIX, @<:@default=]_LT_WITH_AIX_SONAME_DEFAULT[@:>@.])],\n    [case $withval in\n    aix|svr4|both)\n      ;;\n    *)\n      AC_MSG_ERROR([Unknown argument to --with-aix-soname])\n      ;;\n    esac\n    lt_cv_with_aix_soname=$with_aix_soname],\n    [AC_CACHE_VAL([lt_cv_with_aix_soname],\n      [lt_cv_with_aix_soname=]_LT_WITH_AIX_SONAME_DEFAULT)\n    with_aix_soname=$lt_cv_with_aix_soname])\n  AC_MSG_RESULT([$with_aix_soname])\n  if test aix != \"$with_aix_soname\"; then\n    # For the AIX way of multilib, we name the shared archive member\n    # based on the bitwidth used, traditionally 'shr.o' or 'shr_64.o',\n    # and 'shr.imp' or 'shr_64.imp', respectively, for the Import File.\n    # Even when GNU compilers ignore OBJECT_MODE but need '-maix64' flag,\n    # the AIX toolchain works better with OBJECT_MODE set (default 32).\n    if test 64 = \"${OBJECT_MODE-32}\"; then\n      shared_archive_member_spec=shr_64\n    else\n      shared_archive_member_spec=shr\n    fi\n  fi\n  ;;\n*)\n  with_aix_soname=aix\n  ;;\nesac\n\n_LT_DECL([], [shared_archive_member_spec], [0],\n    [Shared archive member basename, for filename based shared library versioning on AIX])dnl\n])# _LT_WITH_AIX_SONAME\n\nLT_OPTION_DEFINE([LT_INIT], [aix-soname=aix], [_LT_WITH_AIX_SONAME([aix])])\nLT_OPTION_DEFINE([LT_INIT], [aix-soname=both], [_LT_WITH_AIX_SONAME([both])])\nLT_OPTION_DEFINE([LT_INIT], [aix-soname=svr4], [_LT_WITH_AIX_SONAME([svr4])])\n\n\n# _LT_WITH_PIC([MODE])\n# --------------------\n# implement the --with-pic flag, and support the 'pic-only' and 'no-pic'\n# LT_INIT options.\n# MODE is either 'yes' or 'no'.  If omitted, it defaults to 'both'.\nm4_define([_LT_WITH_PIC],\n[AC_ARG_WITH([pic],\n    [AS_HELP_STRING([--with-pic@<:@=PKGS@:>@],\n\t[try to use only PIC/non-PIC objects @<:@default=use both@:>@])],\n    [lt_p=${PACKAGE-default}\n    case $withval in\n    yes|no) pic_mode=$withval ;;\n    *)\n      pic_mode=default\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,\n      for lt_pkg in $withval; do\n\tIFS=$lt_save_ifs\n\tif test \"X$lt_pkg\" = \"X$lt_p\"; then\n\t  pic_mode=yes\n\tfi\n      done\n      IFS=$lt_save_ifs\n      ;;\n    esac],\n    [pic_mode=m4_default([$1], [default])])\n\n_LT_DECL([], [pic_mode], [0], [What type of objects to build])dnl\n])# _LT_WITH_PIC\n\nLT_OPTION_DEFINE([LT_INIT], [pic-only], [_LT_WITH_PIC([yes])])\nLT_OPTION_DEFINE([LT_INIT], [no-pic], [_LT_WITH_PIC([no])])\n\n# Old name:\nAU_DEFUN([AC_LIBTOOL_PICMODE],\n[_LT_SET_OPTION([LT_INIT], [pic-only])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the 'pic-only' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_PICMODE], [])\n\n## ----------------- ##\n## LTDL_INIT Options ##\n## ----------------- ##\n\nm4_define([_LTDL_MODE], [])\nLT_OPTION_DEFINE([LTDL_INIT], [nonrecursive],\n\t\t [m4_define([_LTDL_MODE], [nonrecursive])])\nLT_OPTION_DEFINE([LTDL_INIT], [recursive],\n\t\t [m4_define([_LTDL_MODE], [recursive])])\nLT_OPTION_DEFINE([LTDL_INIT], [subproject],\n\t\t [m4_define([_LTDL_MODE], [subproject])])\n\nm4_define([_LTDL_TYPE], [])\nLT_OPTION_DEFINE([LTDL_INIT], [installable],\n\t\t [m4_define([_LTDL_TYPE], [installable])])\nLT_OPTION_DEFINE([LTDL_INIT], [convenience],\n\t\t [m4_define([_LTDL_TYPE], [convenience])])\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/m4/lib-link.m4": "# lib-link.m4 serial 21 (gettext-0.18)\ndnl Copyright (C) 2001-2010 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Bruno Haible.\n\nAC_PREREQ([2.54])\n\ndnl AC_LIB_LINKFLAGS(name [, dependencies]) searches for libname and\ndnl the libraries corresponding to explicit and implicit dependencies.\ndnl Sets and AC_SUBSTs the LIB${NAME} and LTLIB${NAME} variables and\ndnl augments the CPPFLAGS variable.\ndnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname\ndnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.\nAC_DEFUN([AC_LIB_LINKFLAGS],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  AC_REQUIRE([AC_LIB_RPATH])\n  pushdef([Name],[translit([$1],[./-], [___])])\n  pushdef([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                                [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  AC_CACHE_CHECK([how to link with lib[]$1], [ac_cv_lib[]Name[]_libs], [\n    AC_LIB_LINKFLAGS_BODY([$1], [$2])\n    ac_cv_lib[]Name[]_libs=\"$LIB[]NAME\"\n    ac_cv_lib[]Name[]_ltlibs=\"$LTLIB[]NAME\"\n    ac_cv_lib[]Name[]_cppflags=\"$INC[]NAME\"\n    ac_cv_lib[]Name[]_prefix=\"$LIB[]NAME[]_PREFIX\"\n  ])\n  LIB[]NAME=\"$ac_cv_lib[]Name[]_libs\"\n  LTLIB[]NAME=\"$ac_cv_lib[]Name[]_ltlibs\"\n  INC[]NAME=\"$ac_cv_lib[]Name[]_cppflags\"\n  LIB[]NAME[]_PREFIX=\"$ac_cv_lib[]Name[]_prefix\"\n  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)\n  AC_SUBST([LIB]NAME)\n  AC_SUBST([LTLIB]NAME)\n  AC_SUBST([LIB]NAME[_PREFIX])\n  dnl Also set HAVE_LIB[]NAME so that AC_LIB_HAVE_LINKFLAGS can reuse the\n  dnl results of this search when this library appears as a dependency.\n  HAVE_LIB[]NAME=yes\n  popdef([NAME])\n  popdef([Name])\n])\n\ndnl AC_LIB_HAVE_LINKFLAGS(name, dependencies, includes, testcode, [missing-message])\ndnl searches for libname and the libraries corresponding to explicit and\ndnl implicit dependencies, together with the specified include files and\ndnl the ability to compile and link the specified testcode. The missing-message\ndnl defaults to 'no' and may contain additional hints for the user.\ndnl If found, it sets and AC_SUBSTs HAVE_LIB${NAME}=yes and the LIB${NAME}\ndnl and LTLIB${NAME} variables and augments the CPPFLAGS variable, and\ndnl #defines HAVE_LIB${NAME} to 1. Otherwise, it sets and AC_SUBSTs\ndnl HAVE_LIB${NAME}=no and LIB${NAME} and LTLIB${NAME} to empty.\ndnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname\ndnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.\nAC_DEFUN([AC_LIB_HAVE_LINKFLAGS],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  AC_REQUIRE([AC_LIB_RPATH])\n  pushdef([Name],[translit([$1],[./-], [___])])\n  pushdef([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                                [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n\n  dnl Search for lib[]Name and define LIB[]NAME, LTLIB[]NAME and INC[]NAME\n  dnl accordingly.\n  AC_LIB_LINKFLAGS_BODY([$1], [$2])\n\n  dnl Add $INC[]NAME to CPPFLAGS before performing the following checks,\n  dnl because if the user has installed lib[]Name and not disabled its use\n  dnl via --without-lib[]Name-prefix, he wants to use it.\n  ac_save_CPPFLAGS=\"$CPPFLAGS\"\n  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)\n\n  AC_CACHE_CHECK([for lib[]$1], [ac_cv_lib[]Name], [\n    ac_save_LIBS=\"$LIBS\"\n    dnl If $LIB[]NAME contains some -l options, add it to the end of LIBS,\n    dnl because these -l options might require -L options that are present in\n    dnl LIBS. -l options benefit only from the -L options listed before it.\n    dnl Otherwise, add it to the front of LIBS, because it may be a static\n    dnl library that depends on another static library that is present in LIBS.\n    dnl Static libraries benefit only from the static libraries listed after\n    dnl it.\n    case \" $LIB[]NAME\" in\n      *\" -l\"*) LIBS=\"$LIBS $LIB[]NAME\" ;;\n      *)       LIBS=\"$LIB[]NAME $LIBS\" ;;\n    esac\n    AC_TRY_LINK([$3], [$4],\n      [ac_cv_lib[]Name=yes],\n      [ac_cv_lib[]Name='m4_if([$5], [], [no], [[$5]])'])\n    LIBS=\"$ac_save_LIBS\"\n  ])\n  if test \"$ac_cv_lib[]Name\" = yes; then\n    HAVE_LIB[]NAME=yes\n    AC_DEFINE([HAVE_LIB]NAME, 1, [Define if you have the lib][$1 library.])\n    AC_MSG_CHECKING([how to link with lib[]$1])\n    AC_MSG_RESULT([$LIB[]NAME])\n  else\n    HAVE_LIB[]NAME=no\n    dnl If $LIB[]NAME didn't lead to a usable library, we don't need\n    dnl $INC[]NAME either.\n    CPPFLAGS=\"$ac_save_CPPFLAGS\"\n    LIB[]NAME=\n    LTLIB[]NAME=\n    LIB[]NAME[]_PREFIX=\n  fi\n  AC_SUBST([HAVE_LIB]NAME)\n  AC_SUBST([LIB]NAME)\n  AC_SUBST([LTLIB]NAME)\n  AC_SUBST([LIB]NAME[_PREFIX])\n  popdef([NAME])\n  popdef([Name])\n])\n\ndnl Determine the platform dependent parameters needed to use rpath:\ndnl   acl_libext,\ndnl   acl_shlibext,\ndnl   acl_hardcode_libdir_flag_spec,\ndnl   acl_hardcode_libdir_separator,\ndnl   acl_hardcode_direct,\ndnl   acl_hardcode_minus_L.\nAC_DEFUN([AC_LIB_RPATH],\n[\n  dnl Tell automake >= 1.10 to complain if config.rpath is missing.\n  m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([config.rpath])])\n  AC_REQUIRE([AC_PROG_CC])                dnl we use $CC, $GCC, $LDFLAGS\n  AC_REQUIRE([AC_LIB_PROG_LD])            dnl we use $LD, $with_gnu_ld\n  AC_REQUIRE([AC_CANONICAL_HOST])         dnl we use $host\n  AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT]) dnl we use $ac_aux_dir\n  AC_CACHE_CHECK([for shared library run path origin], [acl_cv_rpath], [\n    CC=\"$CC\" GCC=\"$GCC\" LDFLAGS=\"$LDFLAGS\" LD=\"$LD\" with_gnu_ld=\"$with_gnu_ld\" \\\n    ${CONFIG_SHELL-/bin/sh} \"$ac_aux_dir/config.rpath\" \"$host\" > conftest.sh\n    . ./conftest.sh\n    rm -f ./conftest.sh\n    acl_cv_rpath=done\n  ])\n  wl=\"$acl_cv_wl\"\n  acl_libext=\"$acl_cv_libext\"\n  acl_shlibext=\"$acl_cv_shlibext\"\n  acl_libname_spec=\"$acl_cv_libname_spec\"\n  acl_library_names_spec=\"$acl_cv_library_names_spec\"\n  acl_hardcode_libdir_flag_spec=\"$acl_cv_hardcode_libdir_flag_spec\"\n  acl_hardcode_libdir_separator=\"$acl_cv_hardcode_libdir_separator\"\n  acl_hardcode_direct=\"$acl_cv_hardcode_direct\"\n  acl_hardcode_minus_L=\"$acl_cv_hardcode_minus_L\"\n  dnl Determine whether the user wants rpath handling at all.\n  AC_ARG_ENABLE([rpath],\n    [  --disable-rpath         do not hardcode runtime library paths],\n    :, enable_rpath=yes)\n])\n\ndnl AC_LIB_FROMPACKAGE(name, package)\ndnl declares that libname comes from the given package. The configure file\ndnl will then not have a --with-libname-prefix option but a\ndnl --with-package-prefix option. Several libraries can come from the same\ndnl package. This declaration must occur before an AC_LIB_LINKFLAGS or similar\ndnl macro call that searches for libname.\nAC_DEFUN([AC_LIB_FROMPACKAGE],\n[\n  pushdef([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                                [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  define([acl_frompackage_]NAME, [$2])\n  popdef([NAME])\n  pushdef([PACK],[$2])\n  pushdef([PACKUP],[translit(PACK,[abcdefghijklmnopqrstuvwxyz./-],\n                                  [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  define([acl_libsinpackage_]PACKUP,\n    m4_ifdef([acl_libsinpackage_]PACKUP, [acl_libsinpackage_]PACKUP[[, ]],)[lib$1])\n  popdef([PACKUP])\n  popdef([PACK])\n])\n\ndnl AC_LIB_LINKFLAGS_BODY(name [, dependencies]) searches for libname and\ndnl the libraries corresponding to explicit and implicit dependencies.\ndnl Sets the LIB${NAME}, LTLIB${NAME} and INC${NAME} variables.\ndnl Also, sets the LIB${NAME}_PREFIX variable to nonempty if libname was found\ndnl in ${LIB${NAME}_PREFIX}/$acl_libdirstem.\nAC_DEFUN([AC_LIB_LINKFLAGS_BODY],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])\n  pushdef([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                                [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  pushdef([PACK],[m4_ifdef([acl_frompackage_]NAME, [acl_frompackage_]NAME, lib[$1])])\n  pushdef([PACKUP],[translit(PACK,[abcdefghijklmnopqrstuvwxyz./-],\n                                  [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  pushdef([PACKLIBS],[m4_ifdef([acl_frompackage_]NAME, [acl_libsinpackage_]PACKUP, lib[$1])])\n  dnl Autoconf >= 2.61 supports dots in --with options.\n  pushdef([P_A_C_K],[m4_if(m4_version_compare(m4_defn([m4_PACKAGE_VERSION]),[2.61]),[-1],[translit(PACK,[.],[_])],PACK)])\n  dnl By default, look in $includedir and $libdir.\n  use_additional=yes\n  AC_LIB_WITH_FINAL_PREFIX([\n    eval additional_includedir=\\\"$includedir\\\"\n    eval additional_libdir=\\\"$libdir\\\"\n  ])\n  AC_ARG_WITH(P_A_C_K[-prefix],\n[[  --with-]]P_A_C_K[[-prefix[=DIR]  search for ]PACKLIBS[ in DIR/include and DIR/lib\n  --without-]]P_A_C_K[[-prefix     don't search for ]PACKLIBS[ in includedir and libdir]],\n[\n    if test \"X$withval\" = \"Xno\"; then\n      use_additional=no\n    else\n      if test \"X$withval\" = \"X\"; then\n        AC_LIB_WITH_FINAL_PREFIX([\n          eval additional_includedir=\\\"$includedir\\\"\n          eval additional_libdir=\\\"$libdir\\\"\n        ])\n      else\n        additional_includedir=\"$withval/include\"\n        additional_libdir=\"$withval/$acl_libdirstem\"\n        if test \"$acl_libdirstem2\" != \"$acl_libdirstem\" \\\n           && ! test -d \"$withval/$acl_libdirstem\"; then\n          additional_libdir=\"$withval/$acl_libdirstem2\"\n        fi\n      fi\n    fi\n])\n  dnl Search the library and its dependencies in $additional_libdir and\n  dnl $LDFLAGS. Using breadth-first-seach.\n  LIB[]NAME=\n  LTLIB[]NAME=\n  INC[]NAME=\n  LIB[]NAME[]_PREFIX=\n  dnl HAVE_LIB${NAME} is an indicator that LIB${NAME}, LTLIB${NAME} have been\n  dnl computed. So it has to be reset here.\n  HAVE_LIB[]NAME=\n  rpathdirs=\n  ltrpathdirs=\n  names_already_handled=\n  names_next_round='$1 $2'\n  while test -n \"$names_next_round\"; do\n    names_this_round=\"$names_next_round\"\n    names_next_round=\n    for name in $names_this_round; do\n      already_handled=\n      for n in $names_already_handled; do\n        if test \"$n\" = \"$name\"; then\n          already_handled=yes\n          break\n        fi\n      done\n      if test -z \"$already_handled\"; then\n        names_already_handled=\"$names_already_handled $name\"\n        dnl See if it was already located by an earlier AC_LIB_LINKFLAGS\n        dnl or AC_LIB_HAVE_LINKFLAGS call.\n        uppername=`echo \"$name\" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./-|ABCDEFGHIJKLMNOPQRSTUVWXYZ___|'`\n        eval value=\\\"\\$HAVE_LIB$uppername\\\"\n        if test -n \"$value\"; then\n          if test \"$value\" = yes; then\n            eval value=\\\"\\$LIB$uppername\\\"\n            test -z \"$value\" || LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$value\"\n            eval value=\\\"\\$LTLIB$uppername\\\"\n            test -z \"$value\" || LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }$value\"\n          else\n            dnl An earlier call to AC_LIB_HAVE_LINKFLAGS has determined\n            dnl that this library doesn't exist. So just drop it.\n            :\n          fi\n        else\n          dnl Search the library lib$name in $additional_libdir and $LDFLAGS\n          dnl and the already constructed $LIBNAME/$LTLIBNAME.\n          found_dir=\n          found_la=\n          found_so=\n          found_a=\n          eval libname=\\\"$acl_libname_spec\\\"    # typically: libname=lib$name\n          if test -n \"$acl_shlibext\"; then\n            shrext=\".$acl_shlibext\"             # typically: shrext=.so\n          else\n            shrext=\n          fi\n          if test $use_additional = yes; then\n            dir=\"$additional_libdir\"\n            dnl The same code as in the loop below:\n            dnl First look for a shared library.\n            if test -n \"$acl_shlibext\"; then\n              if test -f \"$dir/$libname$shrext\"; then\n                found_dir=\"$dir\"\n                found_so=\"$dir/$libname$shrext\"\n              else\n                if test \"$acl_library_names_spec\" = '$libname$shrext$versuffix'; then\n                  ver=`(cd \"$dir\" && \\\n                        for f in \"$libname$shrext\".*; do echo \"$f\"; done \\\n                        | sed -e \"s,^$libname$shrext\\\\\\\\.,,\" \\\n                        | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \\\n                        | sed 1q ) 2>/dev/null`\n                  if test -n \"$ver\" && test -f \"$dir/$libname$shrext.$ver\"; then\n                    found_dir=\"$dir\"\n                    found_so=\"$dir/$libname$shrext.$ver\"\n                  fi\n                else\n                  eval library_names=\\\"$acl_library_names_spec\\\"\n                  for f in $library_names; do\n                    if test -f \"$dir/$f\"; then\n                      found_dir=\"$dir\"\n                      found_so=\"$dir/$f\"\n                      break\n                    fi\n                  done\n                fi\n              fi\n            fi\n            dnl Then look for a static library.\n            if test \"X$found_dir\" = \"X\"; then\n              if test -f \"$dir/$libname.$acl_libext\"; then\n                found_dir=\"$dir\"\n                found_a=\"$dir/$libname.$acl_libext\"\n              fi\n            fi\n            if test \"X$found_dir\" != \"X\"; then\n              if test -f \"$dir/$libname.la\"; then\n                found_la=\"$dir/$libname.la\"\n              fi\n            fi\n          fi\n          if test \"X$found_dir\" = \"X\"; then\n            for x in $LDFLAGS $LTLIB[]NAME; do\n              AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n              case \"$x\" in\n                -L*)\n                  dir=`echo \"X$x\" | sed -e 's/^X-L//'`\n                  dnl First look for a shared library.\n                  if test -n \"$acl_shlibext\"; then\n                    if test -f \"$dir/$libname$shrext\"; then\n                      found_dir=\"$dir\"\n                      found_so=\"$dir/$libname$shrext\"\n                    else\n                      if test \"$acl_library_names_spec\" = '$libname$shrext$versuffix'; then\n                        ver=`(cd \"$dir\" && \\\n                              for f in \"$libname$shrext\".*; do echo \"$f\"; done \\\n                              | sed -e \"s,^$libname$shrext\\\\\\\\.,,\" \\\n                              | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \\\n                              | sed 1q ) 2>/dev/null`\n                        if test -n \"$ver\" && test -f \"$dir/$libname$shrext.$ver\"; then\n                          found_dir=\"$dir\"\n                          found_so=\"$dir/$libname$shrext.$ver\"\n                        fi\n                      else\n                        eval library_names=\\\"$acl_library_names_spec\\\"\n                        for f in $library_names; do\n                          if test -f \"$dir/$f\"; then\n                            found_dir=\"$dir\"\n                            found_so=\"$dir/$f\"\n                            break\n                          fi\n                        done\n                      fi\n                    fi\n                  fi\n                  dnl Then look for a static library.\n                  if test \"X$found_dir\" = \"X\"; then\n                    if test -f \"$dir/$libname.$acl_libext\"; then\n                      found_dir=\"$dir\"\n                      found_a=\"$dir/$libname.$acl_libext\"\n                    fi\n                  fi\n                  if test \"X$found_dir\" != \"X\"; then\n                    if test -f \"$dir/$libname.la\"; then\n                      found_la=\"$dir/$libname.la\"\n                    fi\n                  fi\n                  ;;\n              esac\n              if test \"X$found_dir\" != \"X\"; then\n                break\n              fi\n            done\n          fi\n          if test \"X$found_dir\" != \"X\"; then\n            dnl Found the library.\n            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$found_dir -l$name\"\n            if test \"X$found_so\" != \"X\"; then\n              dnl Linking with a shared library. We attempt to hardcode its\n              dnl directory into the executable's runpath, unless it's the\n              dnl standard /usr/lib.\n              if test \"$enable_rpath\" = no \\\n                 || test \"X$found_dir\" = \"X/usr/$acl_libdirstem\" \\\n                 || test \"X$found_dir\" = \"X/usr/$acl_libdirstem2\"; then\n                dnl No hardcoding is needed.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n              else\n                dnl Use an explicit option to hardcode DIR into the resulting\n                dnl binary.\n                dnl Potentially add DIR to ltrpathdirs.\n                dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.\n                haveit=\n                for x in $ltrpathdirs; do\n                  if test \"X$x\" = \"X$found_dir\"; then\n                    haveit=yes\n                    break\n                  fi\n                done\n                if test -z \"$haveit\"; then\n                  ltrpathdirs=\"$ltrpathdirs $found_dir\"\n                fi\n                dnl The hardcoding into $LIBNAME is system dependent.\n                if test \"$acl_hardcode_direct\" = yes; then\n                  dnl Using DIR/libNAME.so during linking hardcodes DIR into the\n                  dnl resulting binary.\n                  LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                else\n                  if test -n \"$acl_hardcode_libdir_flag_spec\" && test \"$acl_hardcode_minus_L\" = no; then\n                    dnl Use an explicit option to hardcode DIR into the resulting\n                    dnl binary.\n                    LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                    dnl Potentially add DIR to rpathdirs.\n                    dnl The rpathdirs will be appended to $LIBNAME at the end.\n                    haveit=\n                    for x in $rpathdirs; do\n                      if test \"X$x\" = \"X$found_dir\"; then\n                        haveit=yes\n                        break\n                      fi\n                    done\n                    if test -z \"$haveit\"; then\n                      rpathdirs=\"$rpathdirs $found_dir\"\n                    fi\n                  else\n                    dnl Rely on \"-L$found_dir\".\n                    dnl But don't add it if it's already contained in the LDFLAGS\n                    dnl or the already constructed $LIBNAME\n                    haveit=\n                    for x in $LDFLAGS $LIB[]NAME; do\n                      AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                      if test \"X$x\" = \"X-L$found_dir\"; then\n                        haveit=yes\n                        break\n                      fi\n                    done\n                    if test -z \"$haveit\"; then\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir\"\n                    fi\n                    if test \"$acl_hardcode_minus_L\" != no; then\n                      dnl FIXME: Not sure whether we should use\n                      dnl \"-L$found_dir -l$name\" or \"-L$found_dir $found_so\"\n                      dnl here.\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                    else\n                      dnl We cannot use $acl_hardcode_runpath_var and LD_RUN_PATH\n                      dnl here, because this doesn't fit in flags passed to the\n                      dnl compiler. So give up. No hardcoding. This affects only\n                      dnl very old systems.\n                      dnl FIXME: Not sure whether we should use\n                      dnl \"-L$found_dir -l$name\" or \"-L$found_dir $found_so\"\n                      dnl here.\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-l$name\"\n                    fi\n                  fi\n                fi\n              fi\n            else\n              if test \"X$found_a\" != \"X\"; then\n                dnl Linking with a static library.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_a\"\n              else\n                dnl We shouldn't come here, but anyway it's good to have a\n                dnl fallback.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir -l$name\"\n              fi\n            fi\n            dnl Assume the include files are nearby.\n            additional_includedir=\n            case \"$found_dir\" in\n              */$acl_libdirstem | */$acl_libdirstem/)\n                basedir=`echo \"X$found_dir\" | sed -e 's,^X,,' -e \"s,/$acl_libdirstem/\"'*$,,'`\n                if test \"$name\" = '$1'; then\n                  LIB[]NAME[]_PREFIX=\"$basedir\"\n                fi\n                additional_includedir=\"$basedir/include\"\n                ;;\n              */$acl_libdirstem2 | */$acl_libdirstem2/)\n                basedir=`echo \"X$found_dir\" | sed -e 's,^X,,' -e \"s,/$acl_libdirstem2/\"'*$,,'`\n                if test \"$name\" = '$1'; then\n                  LIB[]NAME[]_PREFIX=\"$basedir\"\n                fi\n                additional_includedir=\"$basedir/include\"\n                ;;\n            esac\n            if test \"X$additional_includedir\" != \"X\"; then\n              dnl Potentially add $additional_includedir to $INCNAME.\n              dnl But don't add it\n              dnl   1. if it's the standard /usr/include,\n              dnl   2. if it's /usr/local/include and we are using GCC on Linux,\n              dnl   3. if it's already present in $CPPFLAGS or the already\n              dnl      constructed $INCNAME,\n              dnl   4. if it doesn't exist as a directory.\n              if test \"X$additional_includedir\" != \"X/usr/include\"; then\n                haveit=\n                if test \"X$additional_includedir\" = \"X/usr/local/include\"; then\n                  if test -n \"$GCC\"; then\n                    case $host_os in\n                      linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n                    esac\n                  fi\n                fi\n                if test -z \"$haveit\"; then\n                  for x in $CPPFLAGS $INC[]NAME; do\n                    AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                    if test \"X$x\" = \"X-I$additional_includedir\"; then\n                      haveit=yes\n                      break\n                    fi\n                  done\n                  if test -z \"$haveit\"; then\n                    if test -d \"$additional_includedir\"; then\n                      dnl Really add $additional_includedir to $INCNAME.\n                      INC[]NAME=\"${INC[]NAME}${INC[]NAME:+ }-I$additional_includedir\"\n                    fi\n                  fi\n                fi\n              fi\n            fi\n            dnl Look for dependencies.\n            if test -n \"$found_la\"; then\n              dnl Read the .la file. It defines the variables\n              dnl dlname, library_names, old_library, dependency_libs, current,\n              dnl age, revision, installed, dlopen, dlpreopen, libdir.\n              save_libdir=\"$libdir\"\n              case \"$found_la\" in\n                */* | *\\\\*) . \"$found_la\" ;;\n                *) . \"./$found_la\" ;;\n              esac\n              libdir=\"$save_libdir\"\n              dnl We use only dependency_libs.\n              for dep in $dependency_libs; do\n                case \"$dep\" in\n                  -L*)\n                    additional_libdir=`echo \"X$dep\" | sed -e 's/^X-L//'`\n                    dnl Potentially add $additional_libdir to $LIBNAME and $LTLIBNAME.\n                    dnl But don't add it\n                    dnl   1. if it's the standard /usr/lib,\n                    dnl   2. if it's /usr/local/lib and we are using GCC on Linux,\n                    dnl   3. if it's already present in $LDFLAGS or the already\n                    dnl      constructed $LIBNAME,\n                    dnl   4. if it doesn't exist as a directory.\n                    if test \"X$additional_libdir\" != \"X/usr/$acl_libdirstem\" \\\n                       && test \"X$additional_libdir\" != \"X/usr/$acl_libdirstem2\"; then\n                      haveit=\n                      if test \"X$additional_libdir\" = \"X/usr/local/$acl_libdirstem\" \\\n                         || test \"X$additional_libdir\" = \"X/usr/local/$acl_libdirstem2\"; then\n                        if test -n \"$GCC\"; then\n                          case $host_os in\n                            linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n                          esac\n                        fi\n                      fi\n                      if test -z \"$haveit\"; then\n                        haveit=\n                        for x in $LDFLAGS $LIB[]NAME; do\n                          AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                          if test \"X$x\" = \"X-L$additional_libdir\"; then\n                            haveit=yes\n                            break\n                          fi\n                        done\n                        if test -z \"$haveit\"; then\n                          if test -d \"$additional_libdir\"; then\n                            dnl Really add $additional_libdir to $LIBNAME.\n                            LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$additional_libdir\"\n                          fi\n                        fi\n                        haveit=\n                        for x in $LDFLAGS $LTLIB[]NAME; do\n                          AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                          if test \"X$x\" = \"X-L$additional_libdir\"; then\n                            haveit=yes\n                            break\n                          fi\n                        done\n                        if test -z \"$haveit\"; then\n                          if test -d \"$additional_libdir\"; then\n                            dnl Really add $additional_libdir to $LTLIBNAME.\n                            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$additional_libdir\"\n                          fi\n                        fi\n                      fi\n                    fi\n                    ;;\n                  -R*)\n                    dir=`echo \"X$dep\" | sed -e 's/^X-R//'`\n                    if test \"$enable_rpath\" != no; then\n                      dnl Potentially add DIR to rpathdirs.\n                      dnl The rpathdirs will be appended to $LIBNAME at the end.\n                      haveit=\n                      for x in $rpathdirs; do\n                        if test \"X$x\" = \"X$dir\"; then\n                          haveit=yes\n                          break\n                        fi\n                      done\n                      if test -z \"$haveit\"; then\n                        rpathdirs=\"$rpathdirs $dir\"\n                      fi\n                      dnl Potentially add DIR to ltrpathdirs.\n                      dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.\n                      haveit=\n                      for x in $ltrpathdirs; do\n                        if test \"X$x\" = \"X$dir\"; then\n                          haveit=yes\n                          break\n                        fi\n                      done\n                      if test -z \"$haveit\"; then\n                        ltrpathdirs=\"$ltrpathdirs $dir\"\n                      fi\n                    fi\n                    ;;\n                  -l*)\n                    dnl Handle this in the next round.\n                    names_next_round=\"$names_next_round \"`echo \"X$dep\" | sed -e 's/^X-l//'`\n                    ;;\n                  *.la)\n                    dnl Handle this in the next round. Throw away the .la's\n                    dnl directory; it is already contained in a preceding -L\n                    dnl option.\n                    names_next_round=\"$names_next_round \"`echo \"X$dep\" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\\.la$,,'`\n                    ;;\n                  *)\n                    dnl Most likely an immediate library name.\n                    LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$dep\"\n                    LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }$dep\"\n                    ;;\n                esac\n              done\n            fi\n          else\n            dnl Didn't find the library; assume it is in the system directories\n            dnl known to the linker and runtime loader. (All the system\n            dnl directories known to the linker should also be known to the\n            dnl runtime loader, otherwise the system is severely misconfigured.)\n            LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-l$name\"\n            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-l$name\"\n          fi\n        fi\n      fi\n    done\n  done\n  if test \"X$rpathdirs\" != \"X\"; then\n    if test -n \"$acl_hardcode_libdir_separator\"; then\n      dnl Weird platform: only the last -rpath option counts, the user must\n      dnl pass all path elements in one option. We can arrange that for a\n      dnl single library, but not when more than one $LIBNAMEs are used.\n      alldirs=\n      for found_dir in $rpathdirs; do\n        alldirs=\"${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$found_dir\"\n      done\n      dnl Note: acl_hardcode_libdir_flag_spec uses $libdir and $wl.\n      acl_save_libdir=\"$libdir\"\n      libdir=\"$alldirs\"\n      eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n      libdir=\"$acl_save_libdir\"\n      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$flag\"\n    else\n      dnl The -rpath options are cumulative.\n      for found_dir in $rpathdirs; do\n        acl_save_libdir=\"$libdir\"\n        libdir=\"$found_dir\"\n        eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n        libdir=\"$acl_save_libdir\"\n        LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$flag\"\n      done\n    fi\n  fi\n  if test \"X$ltrpathdirs\" != \"X\"; then\n    dnl When using libtool, the option that works for both libraries and\n    dnl executables is -R. The -R options are cumulative.\n    for found_dir in $ltrpathdirs; do\n      LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-R$found_dir\"\n    done\n  fi\n  popdef([P_A_C_K])\n  popdef([PACKLIBS])\n  popdef([PACKUP])\n  popdef([PACK])\n  popdef([NAME])\n])\n\ndnl AC_LIB_APPENDTOVAR(VAR, CONTENTS) appends the elements of CONTENTS to VAR,\ndnl unless already present in VAR.\ndnl Works only for CPPFLAGS, not for LIB* variables because that sometimes\ndnl contains two or three consecutive elements that belong together.\nAC_DEFUN([AC_LIB_APPENDTOVAR],\n[\n  for element in [$2]; do\n    haveit=\n    for x in $[$1]; do\n      AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n      if test \"X$x\" = \"X$element\"; then\n        haveit=yes\n        break\n      fi\n    done\n    if test -z \"$haveit\"; then\n      [$1]=\"${[$1]}${[$1]:+ }$element\"\n    fi\n  done\n])\n\ndnl For those cases where a variable contains several -L and -l options\ndnl referring to unknown libraries and directories, this macro determines the\ndnl necessary additional linker options for the runtime path.\ndnl AC_LIB_LINKFLAGS_FROM_LIBS([LDADDVAR], [LIBSVALUE], [USE-LIBTOOL])\ndnl sets LDADDVAR to linker options needed together with LIBSVALUE.\ndnl If USE-LIBTOOL evaluates to non-empty, linking with libtool is assumed,\ndnl otherwise linking without libtool is assumed.\nAC_DEFUN([AC_LIB_LINKFLAGS_FROM_LIBS],\n[\n  AC_REQUIRE([AC_LIB_RPATH])\n  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])\n  $1=\n  if test \"$enable_rpath\" != no; then\n    if test -n \"$acl_hardcode_libdir_flag_spec\" && test \"$acl_hardcode_minus_L\" = no; then\n      dnl Use an explicit option to hardcode directories into the resulting\n      dnl binary.\n      rpathdirs=\n      next=\n      for opt in $2; do\n        if test -n \"$next\"; then\n          dir=\"$next\"\n          dnl No need to hardcode the standard /usr/lib.\n          if test \"X$dir\" != \"X/usr/$acl_libdirstem\" \\\n             && test \"X$dir\" != \"X/usr/$acl_libdirstem2\"; then\n            rpathdirs=\"$rpathdirs $dir\"\n          fi\n          next=\n        else\n          case $opt in\n            -L) next=yes ;;\n            -L*) dir=`echo \"X$opt\" | sed -e 's,^X-L,,'`\n                 dnl No need to hardcode the standard /usr/lib.\n                 if test \"X$dir\" != \"X/usr/$acl_libdirstem\" \\\n                    && test \"X$dir\" != \"X/usr/$acl_libdirstem2\"; then\n                   rpathdirs=\"$rpathdirs $dir\"\n                 fi\n                 next= ;;\n            *) next= ;;\n          esac\n        fi\n      done\n      if test \"X$rpathdirs\" != \"X\"; then\n        if test -n \"\"$3\"\"; then\n          dnl libtool is used for linking. Use -R options.\n          for dir in $rpathdirs; do\n            $1=\"${$1}${$1:+ }-R$dir\"\n          done\n        else\n          dnl The linker is used for linking directly.\n          if test -n \"$acl_hardcode_libdir_separator\"; then\n            dnl Weird platform: only the last -rpath option counts, the user\n            dnl must pass all path elements in one option.\n            alldirs=\n            for dir in $rpathdirs; do\n              alldirs=\"${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$dir\"\n            done\n            acl_save_libdir=\"$libdir\"\n            libdir=\"$alldirs\"\n            eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n            libdir=\"$acl_save_libdir\"\n            $1=\"$flag\"\n          else\n            dnl The -rpath options are cumulative.\n            for dir in $rpathdirs; do\n              acl_save_libdir=\"$libdir\"\n              libdir=\"$dir\"\n              eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n              libdir=\"$acl_save_libdir\"\n              $1=\"${$1}${$1:+ }$flag\"\n            done\n          fi\n        fi\n      fi\n    fi\n  fi\n  AC_SUBST([$1])\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/doc/README.changes": "This is a rough history of garbage collector bugs and versions.\n\nThis has been maintained with varying diligence over the years.\n\nI made an attempt to include recent contributors here.  I apologize for any\nomissions.\n\n-------------------------\n\n  Version 1.3 and immediately preceding versions contained spurious\nassembly language assignments to TMP_SP.  Only the assignment in the PC/RT\ncode is necessary.  On other machines, with certain compiler options,\nthe assignments can lead to an unsaved register being overwritten.\nKnown to cause problems under SunOS 3.5 WITHOUT the -O option.  (With\n-O the compiler recognizes it as dead code.  It probably shouldn't,\nbut that's another story.)\n\n  Version 1.4 and earlier versions used compile time determined values\nfor the stack base.  This no longer works on Sun 3s, since Sun 3/80s use\na different stack base.  We now use a straightforward heuristic on all\nmachines on which it is known to work (incl. Sun 3s) and compile-time\ndetermined values for the rest.  There should really be library calls\nto determine such values.\n\n  Version 1.5 and earlier did not ensure 8 byte alignment for objects\nallocated on a sparc based machine.\n\n  Version 1.8 added ULTRIX support in gc_private.h.\n  \n  Version 1.9 fixed a major bug in gc_realloc.\n  \n  Version 2.0 introduced a consistent naming convention for collector\nroutines and added support for registering dynamic library data segments\nin the standard mark_roots.c.  Most of the data structures were revamped.\nThe treatment of interior pointers was completely changed.  Finalization\nwas added.  Support for locking was added.  Object kinds were added.\nWe added a black listing facility to avoid allocating at addresses known\nto occur as integers somewhere in the address space.  Much of this\nwas accomplished by adapting ideas and code from the PCR collector.\nThe test program was changed and expanded.\n\n  Version 2.1 was the first stable version since 1.9, and added support\nfor PPCR.\n\n  Version 2.2 added debugging allocation, and fixed various bugs.  Among them:\n- GC_realloc could fail to extend the size of the object for certain large object sizes.\n- A blatant subscript range error in GC_printf, which unfortunately\n  wasn't exercised on machines with sufficient stack alignment constraints.\n- GC_register_displacement did the wrong thing if it was called after\n  any allocation had taken place.\n- The leak finding code would eventually break after 2048 byte\n  byte objects leaked.\n- interface.c didn't compile.\n- The heap size remained much too small for large stacks.\n- The stack clearing code behaved badly for large stacks, and perhaps\n  on HP/PA machines.\n\n  Version 2.3 added ALL_INTERIOR_POINTERS and fixed the following bugs:\n- Missing declaration of etext in the A/UX version.\n- Some PCR root-finding problems.\n- Blacklisting was not 100% effective, because the plausible future\n  heap bounds were being miscalculated.\n- GC_realloc didn't handle out-of-memory correctly.\n- GC_base could return a nonzero value for addresses inside free blocks.\n- test.c wasn't really thread safe, and could erroneously report failure\n  in a multithreaded environment.  (The locking primitives need to be\n  replaced for other threads packages.)\n- GC_CONS was thoroughly broken.\n- On a SPARC with dynamic linking, signals stayed diabled while the\n  client code was running.\n  (Thanks to Manuel Serrano at INRIA for reporting the last two.)\n  \n  Version 2.4 added GC_free_space_divisor as a tuning knob, added\n  support for OS/2 and linux, and fixed the following bugs:\n- On machines with unaligned pointers (e.g. Sun 3), every 128th word could\n  fail to be considered for marking.\n- Dynamic_load.c erroneously added 4 bytes to the length of the data and\n  bss sections of the dynamic library.  This could result in a bad memory\n  reference if the actual length was a multiple of a page.  (Observed on\n  Sun 3.  Can probably also happen on a Sun 4.)\n  (Thanks to Robert Brazile for pointing out that the Sun 3 version\n  was broken.  Dynamic library handling is still broken on Sun 3s\n  under 4.1.1U1, but apparently not 4.1.1.  If you have such a machine,\n  use -Bstatic.)\n  \n  Version 2.5 fixed the following bugs:\n- Removed an explicit call to exit(1)\n- Fixed calls to GC_printf and GC_err_printf, so the correct number of\n  arguments are always supplied.  The OS/2 C compiler gets confused if\n  the number of actuals and the number of formals differ.  (ANSI C\n  doesn't require this to work.  The ANSI sanctioned way of doing things\n  causes too many compatibility problems.)\n  \n  Version 3.0  added generational/incremental collection and stubborn\n  objects.\n\n  Version 3.1 added the following features:\n- A workaround for a SunOS 4.X SPARC C compiler\n  misfeature that caused problems when the collector was turned into\n  a dynamic library.  \n- A fix for a bug in GC_base that could result in a memory fault.\n- A fix for a performance bug (and several other misfeatures) pointed\n  out by Dave Detlefs and Al Dosser.\n- Use of dirty bit information for static data under Solaris 2.X.\n- DEC Alpha/OSF1 support (thanks to Al Dosser).\n- Incremental collection on more platforms.\n- A more refined heap expansion policy.  Less space usage by default.\n- Various minor enhancements to reduce space usage, and to reduce\n  the amount of memory scanned by the collector.\n- Uncollectable allocation without per object overhead.\n- More conscientious handling of out-of-memory conditions.\n- Fixed a bug in debugging stubborn allocation.\n- Fixed a bug that resulted in occasional erroneous reporting of smashed\n  objects with debugging allocation.\n- Fixed bogus leak reports of size 4096 blocks with FIND_LEAK.\n\n  Version 3.2 fixed a serious and not entirely repeatable bug in\n  the incremental collector.  It appeared only when dirty bit info\n  on the roots was available, which is normally only under Solaris.\n  It also added GC_general_register_disappearing_link, and some\n  testing code.  Interface.c disappeared.\n\n  Version 3.3 fixes several bugs and adds new ports:\n- PCR-specific bugs.\n- Missing locking in GC_free, redundant FASTUNLOCK\n  in GC_malloc_stubborn, and 2 bugs in\n  GC_unregister_disappearing_link.\n  All of the above were pointed out by Neil Sharman\n  (neil@cs.mu.oz.au).\n- Common symbols allocated by the SunOS4.X dynamic loader\n  were not included in the root set.\n- Bug in GC_finalize (reported by Brian Beuning and Al Dosser)\n- Merged Amiga port from Jesper Peterson (untested)\n- Merged NeXT port from Thomas Funke (significantly\n  modified and untested)\n\n  Version 3.4:\n- Fixed a performance bug in GC_realloc.\n- Updated the amiga port.\n- Added NetBSD and 386BSD ports.\n- Added cord library.\n- Added trivial performance enhancement for\n  ALL_INTERIOR_POINTERS.  (Don't scan last word.)\n  \n  Version 3.5\n- Minor collections now mark from roots only once, if that\n  doesn't cause an excessive pause.\n- The stack clearing heuristic was refined to prevent anomalies\n  with very heavily recursive programs and sparse stacks.\n- Fixed a bug that prevented mark stack growth in some cases.\n  GC_objects_are_marked should be set to TRUE after a call\n  to GC_push_roots and as part of GC_push_marked, since\n  both can now set mark bits.  I think this is only a performance\n  bug, but I wouldn't bet on it.  It's certainly very hard to argue\n  that the old version was correct.\n- Fixed an incremental collection bug that prevented it from\n  working at all when HBLKSIZE != getpagesize()\n- Changed dynamic_loading.c to include gc_priv.h before testing\n  DYNAMIC_LOADING.  SunOS dynamic library scanning\n  must have been broken in 3.4.\n- Object size rounding now adapts to program behavior.\n- Added a workaround (provided by Manuel Serrano and\n  colleagues) to a long-standing SunOS 4.X (and 3.X?) ld bug\n  that I had incorrectly assumed to have been squished.\n  The collector was broken if the text segment size was within\n  32 bytes of a multiple of 8K bytes, and if the beginning of\n  the data segment contained interesting roots.  The workaround\n  assumes a demand-loadable executable.  The original may have\n  have \"worked\" in some other cases.\n- Added dynamic library support under IRIX5.\n- Added support for EMX under OS/2 (thanks to Ari Huttunen).\n  \nVersion 3.6:\n- fixed a bug in the mark stack growth code that was introduced\n  in 3.4.\n- fixed Makefile to work around DEC AXP compiler tail recursion\n  bug.\n\nVersion 3.7:\n- Added a workaround for an HP/UX compiler bug.\n- Fixed another stack clearing performance bug.  Reworked\n  that code once more.\n  \nVersion 4.0:\n- Added support for Solaris threads (which was possible\n  only by reimplementing some fraction of Solaris threads,\n  since Sun doesn't currently make the thread debugging\n  interface available).\n- Added non-threads win32 and win32S support.\n- (Grudgingly, with suitable muttering of obscenities) renamed\n  files so that the collector distribution could live on a FAT\n  file system.  Files that are guaranteed to be useless on\n  a PC still have long names.  Gc_inline.h and gc_private.h\n  still exist, but now just include  gc_inl.h and gc_priv.h.\n- Fixed a really obscure bug in finalization that could cause\n  undetected mark stack overflows.  (I would be surprised if\n  any real code ever tickled this one.)\n- Changed finalization code to dynamically resize the hash\n  tables it maintains.  (This probably does not matter for well-\n  -written code.  It no doubt does for C++ code that overuses\n  destructors.)\n- Added typed allocation primitives.  Rewrote the marker to\n  accommodate them with more reasonable efficiency.  This\n  change should also speed up marking for GC_malloc allocated\n  objects a little.  See gc_typed.h for new primitives.\n- Improved debugging facilities slightly.  Allocation time\n  stack traces are now kept by default on SPARC/SUNOS4.\n  (Thanks to Scott Schwartz.)\n- Added better support for small heap applications.\n- Significantly extended cord package.  Fixed a bug in the\n  implementation of lazily read files.  Printf and friends now\n  have cord variants.  Cord traversals are a bit faster.\n- Made ALL_INTERIOR_POINTERS recognition the default.\n- Fixed de so that it can run in constant space, independent\n  of file size.  Added simple string searching to cords and de.\n- Added the Hull-Ellis C++ interface.\n- Added dynamic library support for OSF/1.\n  (Thanks to Al Dosser and Tim Bingham at DEC.)\n- Changed argument to GC_expand_hp to be expressed\n  in units of bytes instead of heap blocks.  (Necessary\n  since the heap block size now varies depending on\n  configuration.  The old version was never very clean.)\n- Added GC_get_heap_size().  The previous \"equivalent\"\n  was broken.\n- Restructured the Makefile a bit.  \n\nSince version 4.0:\n- Changed finalization implementation to guarantee that\n  finalization procedures are called outside of the allocation\n  lock, making direct use of the interface a little less dangerous.\n  MAY BREAK EXISTING CLIENTS that assume finalizers\n  are protected by a lock.  Since there seem to be few multithreaded\n  clients that use finalization, this is hopefully not much of\n  a problem.\n- Fixed a gross bug in CORD_prev.\n- Fixed a bug in blacklst.c that could result in unbounded\n  heap growth during startup on machines that do not clear\n  memory obtained from the OS (e.g. win32S).\n- Ported de editor to win32/win32S.  (This is now the only\n  version with a mouse-sensitive UI.)\n- Added GC_malloc_ignore_off_page to allocate large arrays\n  in the presence of ALL_INTERIOR_POINTERS.\n- Changed GC_call_with_alloc_lock to not disable signals in\n  the single-threaded case.\n- Reduced retry count in GC_collect_or_expand for garbage\n  collecting when out of memory.\n- Made uncollectable allocations bypass black-listing, as they\n  should.\n- Fixed a bug in typed_test in test.c that could cause (legitimate)\n  GC crashes.\n- Fixed some potential synchronization problems in finalize.c\n- Fixed a real locking problem in typd_mlc.c.\n- Worked around an AIX 3.2 compiler feature that results in\n  out of bounds memory references.\n- Partially worked around an IRIX5.2 beta problem (which may\n  or may not persist to the final release).\n- Fixed a bug in the heap integrity checking code that could\n  result in explicitly deallocated objects being identified as\n  smashed.  Fixed a bug in the dbg_mlc stack saving code\n  that caused old argument pointers to be considered live.\n- Fixed a bug in CORD_ncmp (and hence CORD_str).\n- Repaired the OS2 port, which had suffered from bit rot\n  in 4.0.  Worked around what appears to be CSet/2 V1.0\n  optimizer bug.\n- Fixed a Makefile bug for target \"c++\".\n\nSince version 4.1:\n- Multiple bug fixes/workarounds in the Solaris threads version.\n  (It occasionally failed to locate some register contents for\n  marking.  It also turns out that thr_suspend and friends are\n  unreliable in Solaris 2.3.  Dirty bit reads appear\n  to be unreliable under some weird \n  circumstances.  My stack marking code\n  contained a serious performance bug.  The new code is\n  extremely defensive, and has not failed in several cpu\n  hours of testing.  But  no guarantees ...)\n- Added MacOS support (thanks to Patrick Beard.)\n- Fixed several syntactic bugs in gc_c++.h and friends.  (These\n  didn't bother g++, but did bother most other compilers.)\n  Fixed gc_c++.h finalization interface.  (It didn't.)\n- 64 bit alignment for allocated objects was not guaranteed in a\n  few cases in which it should have been.\n- Added GC_malloc_atomic_ignore_off_page.\n- Added GC_collect_a_little.\n- Added some prototypes to gc.h.\n- Some other minor bug fixes (notably in Makefile).\n- Fixed OS/2 / EMX port (thanks to Ari Huttunen).\n- Fixed AmigaDOS port. (thanks to Michel Schinz).\n- Fixed the DATASTART definition under Solaris.  There\n  was a 1 in 16K chance of the collector missing the first\n  64K of static data (and thus crashing).\n- Fixed some blatant anachronisms in the README file.\n- Fixed PCR-Makefile for upcoming PPCR release.\n\nSince version 4.2:\n- Fixed SPARC alignment problem with GC_DEBUG.\n- Fixed Solaris threads /proc workaround.  The real\n  problem was an interaction with mprotect.\n- Incorporated fix from Patrick Beard for gc_c++.h (now gc_cpp.h).\n- Slightly improved allocator space utilization by\n  fixing the GC_size_map mechanism.\n- Integrated some Sony News and MIPS RISCos 4.51\n  patches.  (Thanks to Nobuyuki Hikichi of\n  Software Research Associates, Inc. Japan)\n- Fixed HP_PA alignment problem.  (Thanks to\n  xjam@cork.cs.berkeley.edu.)\n- Added GC_same_obj and friends.  Changed GC_base\n  to return 0 for pointers past the end of large objects.\n  Improved GC_base performance with ALL_INTERIOR_POINTERS\n  on machines with a slow integer mod operation.\n  Added GC_PTR_ADD, GC_PTR_STORE, etc. to prepare\n  for preprocessor.\n- changed the default on most UNIX machines to be that\n  signals are not disabled during critical GC operations.\n  This is still ANSI-conforming, though somewhat dangerous\n  in the presence of signal handlers. But the performance\n  cost of the alternative is sometimes problematic.\n  Can be changed back with a minor Makefile edit.\n- renamed IS_STRING in gc.h, to CORD_IS_STRING, thus\n  following my own naming convention.  Added the function\n  CORD_to_const_char_star.\n- Fixed a gross bug in GC_finalize.  Symptom: occasional\n  address faults in that function.  (Thanks to Anselm\n  Baird-Smith (Anselm.BairdSmith@inria.fr)\n- Added port to ICL DRS6000 running DRS/NX.  Restructured\n  things a bit to factor out common code, and remove obsolete\n  code.  Collector should now run under SUNOS5 with either\n  mprotect or /proc dirty bits.  (Thanks to Douglas Steel\n  (doug@wg.icl.co.uk)).\n- More bug fixes and workarounds for Solaris 2.X.  (These were\n  mostly related to putting the collector in a dynamic library,\n  which didn't really work before.  Also SOLARIS_THREADS\n  didn't interact well with dl_open.)  Thanks to btlewis@eng.sun.com.\n- Fixed a serious performance bug on the DEC Alpha.  The text\n  segment was getting registered as part of the root set.\n  (Amazingly, the result was still fast enough that the bug\n  was not conspicuous.) The fix works on OSF/1, version 1.3.\n  Hopefully it also works on other versions of OSF/1 ...\n- Fixed a bug in GC_clear_roots.\n- Fixed a bug in GC_generic_malloc_words_small that broke\n  gc_inl.h.  (Reported by Antoine de Maricourt.  I broke it\n  in trying to tweak the Mac port.) \n- Fixed some problems with cord/de under Linux.\n- Fixed some cord problems, notably with CORD_riter4.\n- Added DG/UX port.\n  Thanks to Ben A. Mesander (ben@piglet.cr.usgs.gov)\n- Added finalization registration routines with weaker ordering\n  constraints.  (This is necessary for C++ finalization with\n  multiple inheritance, since the compiler often adds self-cycles.)\n- Filled the holes in the SCO port. (Thanks to Michael Arnoldus\n  <chime@proinf.dk>.)\n- John Ellis' additions to the C++ support:  From John:\n\n* I completely rewrote the documentation in the interface gc_c++.h\n(later renamed gc_cpp.h).  I've tried to make it both clearer and more\nprecise.\n\n* The definition of accessibility now ignores pointers from an\nfinalizable object (an object with a clean-up function) to itself.\nThis allows objects with virtual base classes to be finalizable by the\ncollector.  Compilers typically implement virtual base classes using\npointers from an object to itself, which under the old definition of\naccessibility prevented objects with virtual base classes from ever\nbeing collected or finalized.\n\n* gc_cleanup now includes gc as a virtual base.  This was enabled by\nthe change in the definition of accessibility.\n\n* I added support for operator new[].  Since most (all?) compilers\ndon't yet support operator new[], it is conditionalized on\n-DOPERATOR_NEW_ARRAY.  The code is untested, but its trivial and looks\ncorrect.\n\n* The test program test_gc_c++ (later renamed test_cpp.cc)\ntries to test for the C++-specific functionality not tested by the\nother programs.\n- Added <unistd.h> include to misc.c.  (Needed for ppcr.)\n- Added PowerMac port. (Thanks to Patrick Beard again.)\n- Fixed \"srcdir\"-related Makefile problems.  Changed things so\n  that all externally visible include files always appear in the\n  include subdirectory of the source.  Made gc.h directly\n  includable from C++ code.  (These were at Per\n  Bothner's suggestion.)\n- Changed Intel code to also mark from ebp (Kevin Warne's\n  suggestion).\n- Renamed C++ related files so they could live in a FAT\n  file system. (Charles Fiterman's suggestion.)\n- Changed Windows NT Makefile to include C++ support in\n  gc.lib.  Added C++ test as Makefile target.\n  \nSince version 4.3:\n - ASM_CLEAR_CODE was erroneously defined for HP\n   PA machines, resulting in a compile error.\n - Fixed OS/2 Makefile to create a library.  (Thanks to\n   Mark Boulter (mboulter@vnet.ibm.com)).\n - Gc_cleanup objects didn't work if they were created on\n   the stack.  Fixed.\n - One copy of Gc_cpp.h in the distribution was out of \n   synch, and failed to document some known compiler\n   problems with explicit destructor invocation.  Partially\n   fixed.  There are probably other compilers on which\n   gc_cleanup is miscompiled.\n - Fixed Makefile to pass C compiler flags to C++ compiler.\n - Added Mac fixes.\n - Fixed os_dep.c to work around what appears to be\n   a new and different VirtualQuery bug under newer\n   versions of win32S.\n - GC_non_gc_bytes was not correctly maintained by\n   GC_free.  Fixed.  Thanks to James Clark (jjc@jclark.com).\n - Added GC_set_max_heap_size.\n - Changed allocation code to ignore blacklisting if it is preventing\n   use of a very large block of memory.  This has the advantage\n   that naive code allocating very large objects is much more\n   likely to work.  The downside is you might no\n   longer find out that such code should really use\n   GC_malloc_ignore_off_page.\n - Changed GC_printf under win32 to close and reopen the file\n   between calls.  FAT file systems otherwise make the log file\n   useless for debugging.\n - Added GC_try_to_collect and GC_get_bytes_since_gc.  These\n   allow starting an abortable collection during idle times. \n   This facility does not require special OS support.  (Thanks to\n   Michael Spertus of Geodesic Systems for suggesting this.  It was\n   actually an easy addition.  Kumar Srikantan previously added a similar\n   facility to a now ancient version of the collector.  At the time\n   this was much harder, and the result was less convincing.)\n - Added some support for the Borland development environment.  (Thanks\n   to John Ellis and Michael Spertus.)\n - Removed a misfeature from checksums.c that caused unexpected \n   heap growth.  (Thanks to Scott Schwartz.)\n - Changed finalize.c to call WARN if it encounters a finalization cycle.\n   WARN is defined in gc_priv.h to write a message, usually to stdout.\n   In many environments, this may be inappropriate.\n - Renamed NO_PARAMS in gc.h to GC_NO_PARAMS, thus adhering to my own\n   naming convention.\n - Added GC_set_warn_proc to intercept warnings.\n - Fixed Amiga port. (Thanks to Michel Schinz (schinz@alphanet.ch).)\n - Fixed a bug in mark.c that could result in an access to unmapped\n   memory from GC_mark_from_mark_stack on machines with unaligned\n   pointers.\n - Fixed a win32 specific performance bug that could result in scanning of\n   objects allocated with the system malloc.\n - Added REDIRECT_MALLOC.\n\nSince version 4.4:\n - Fixed many minor and one major README bugs. (Thanks to Franklin Chen\n   (chen@adi.com) for pointing out many of them.)\n - Fixed ALPHA/OSF/1 dynamic library support. (Thanks to Jonathan Bachrach\n   (jonathan@harlequin.com)).\n - Added incremental GC support (MPROTECT_VDB) for Linux (with some\n   help from Bruno Haible).\n - Altered SPARC recognition tests in gc.h and config.h (mostly as\n   suggested by Fergus Henderson).\n - Added basic incremental GC support for win32, as implemented by\n   Windows NT and Windows 95.  GC_enable_incremental is a noop\n   under win32s, which doesn't implement enough of the VM interface.\n - Added -DLARGE_CONFIG.\n - Fixed GC_..._ignore_off_page to also function without\n   -DALL_INTERIOR_POINTERS.\n - (Hopefully) fixed RS/6000 port.  (Only the test was broken.)\n - Fixed a performance bug in the nonincremental collector running\n   on machines supporting incremental collection with MPROTECT_VDB\n   (e.g. SunOS 4, DEC AXP).  This turned into a correctness bug under\n   win32s with win32 incremental collection.  (Not all memory protection\n   was disabled.)\n - Fixed some ppcr related bit rot.\n - Caused dynamic libraries to be unregistered before reregistering.\n   The old way turned out to be a performance bug on some machines.\n - GC_root_size was not properly maintained under MSWIN32.\n - Added -DNO_DEBUGGING and GC_dump.\n - Fixed a couple of bugs arising with SOLARIS_THREADS +\n   REDIRECT_MALLOC.\n - Added NetBSD/M68K port.  (Thanks to Peter Seebach\n   <seebs@taniemarie.solon.com>.)\n - Fixed a serious realloc bug.  For certain object sizes, the collector\n   wouldn't scan the expanded part of the object.  (Thanks to Clay Spence\n   (cds@peanut.sarnoff.com) for noticing the problem, and helping me to\n   track it down.)\n   \nSince version 4.5:\n - Added Linux ELF support.  (Thanks to Arrigo Triulzi <arrigo@ic.ac.uk>.)\n - GC_base crashed if it was called before any other GC_ routines.\n   This could happen if a gc_cleanup object was allocated outside the heap\n   before any heap allocation.\n - The heap expansion heuristic was not stable if all objects had finalization\n   enabled.  Fixed finalize.c to count memory in finalization queue and\n   avoid explicit deallocation.  Changed alloc.c to also consider this count.\n   (This is still not recommended.  It's expensive if nothing else.)  Thanks\n   to John Ellis for pointing this out.\n - GC_malloc_uncollectable(0) was broken.  Thanks to Phong Vo for pointing\n   this out.\n - The collector didn't compile under Linux 1.3.X.  (Thanks to Fred Gilham for\n   pointing this out.)  The current workaround is ugly, but expected to be\n   temporary.\n - Fixed a formatting problem for SPARC stack traces.\n - Fixed some '=='s in os_dep.c that should have been assignments.\n   Fortunately these were in code that should never be executed anyway.\n   (Thanks to Fergus Henderson.)\n - Fixed the heap block allocator to only drop blacklisted blocks in small\n   chunks.  Made BL_LIMIT self adjusting.  (Both of these were in response\n   to heap growth observed by Paul Graham.)\n - Fixed the Metrowerks/68K Mac code to also mark from a6.  (Thanks\n   to Patrick Beard.)\n - Significantly updated README.debugging.\n - Fixed some problems with longjmps out of signal handlers, especially under\n   Solaris.  Added a workaround for the fact that siglongjmp doesn't appear to\n   do the right thing with -lthread under Solaris.\n - Added MSDOS/djgpp port.  (Thanks to Mitch Harris  (maharri@uiuc.edu).)\n - Added \"make reserved_namespace\" and \"make user_namespace\".  The\n   first renames ALL \"GC_xxx\" identifiers as \"_GC_xxx\".  The second is the\n   inverse transformation.  Note that doing this is guaranteed to break all\n   clients written for the other names.\n - descriptor field for kind NORMAL in GC_obj_kinds with ADD_BYTE_AT_END\n   defined should be -ALIGNMENT not WORDS_TO_BYTES(-1).  This is\n   a serious bug on machines with pointer alignment of less than a word.\n - GC_ignore_self_finalize_mark_proc didn't handle pointers to very near the\n   end of the object correctly.  Caused failures of the C++ test on a DEC Alpha\n   with g++.\n - gc_inl.h still had problems.  Partially fixed.  Added warnings at the\n   beginning to hopefully specify the remaining dangers.\n - Added DATAEND definition to config.h.\n - Fixed some of the .h file organization.  Fixed \"make floppy\".\n \nSince version 4.6:\n - Fixed some compilation problems with -DCHECKSUMS (thanks to Ian Searle)\n - Updated some Mac specific files to synchronize with Patrick Beard.\n - Fixed a serious bug for machines with non-word-aligned pointers.\n   (Thanks to Patrick Beard for pointing out the problem.  The collector\n   should fail almost any conceivable test immediately on such machines.)\n\nSince version 4.7:\n - Changed a \"comment\" in a MacOS specific part of mach-dep.c that caused\n   gcc to fail on other platforms.\n\nSince version 4.8\n - More README.debugging fixes.\n - Objects ready for finalization, but not finalized in the same GC\n   cycle, could be prematurely collected.  This occasionally happened\n   in test_cpp.\n - Too little memory was obtained from the system for very large\n   objects.  That could cause a heap explosion if these objects were\n   not contiguous (e.g. under PCR), and too much of them was blacklisted.\n - Due to an improper initialization, the collector was too hesitant to\n   allocate blacklisted objects immediately after system startup.\n - Moved GC_arrays from the data into the bss segment by not explicitly\n   initializing it to zero.  This significantly\n   reduces the size of executables, and probably avoids some disk accesses\n   on program startup.  It's conceivable that it might break a port that I\n   didn't test.\n - Fixed EMX_MAKEFILE to reflect the gc_c++.h to gc_cpp.h renaming which\n   occurred a while ago.\n\nSince 4.9:\n - Fixed a typo around a call to GC_collect_or_expand in alloc.c.  It broke\n   handling of out of memory.  (Thanks to Patrick Beard for noticing.)\n\nSince 4.10:\n - Rationalized (hopefully) GC_try_to_collect in an incremental collection\n   environment.  It appeared to not handle a call while a collection was in\n   progress, and was otherwise too conservative.\n - Merged GC_reclaim_or_delete_all into GC_reclaim_all to get rid of some\n   code.\n - Added Patrick Beard's Mac fixes, with substantial completely untested\n   modifications.\n - Fixed the MPROTECT_VDB code to deal with large pages and imprecise\n   fault addresses (as on an UltraSPARC running Solaris 2.5).  Note that this\n   was not a problem in the default configuration, which uses PROC_VDB.\n - The DEC Alpha assembly code needed to restore $gp between calls.\n   Thanks to Fergus Henderson for tracking this down and supplying a\n   patch.\n - The write command for \"de\" was completely broken for large files.\n   I used the easiest portable fix, which involved changing the semantics\n   so that f.new is written instead of overwriting f.  That's safer anyway.\n - Added README.solaris2 with a discussion of the possible problems of\n   mixing the collector's sbrk allocation with malloc/realloc.\n - Changed the data segment starting address for SGI machines.  The\n   old code failed under IRIX6.\n - Required double word alignment for MIPS.\n - Various minor fixes to remove warnings.\n - Attempted to fix some Solaris threads problems reported by Zhiying Chen.\n   In particular, the collector could try to fork a thread with the\n   world stopped as part of GC_thr_init.  It also failed to deal with\n   the case in which the original thread terminated before the whole\n   process did.\n - Added -DNO_EXECUTE_PERMISSION.  This has a major performance impact\n   on the incremental collector under Irix, and perhaps under other\n   operating systems.\n - Added some code to support allocating the heap with mmap.  This may\n   be preferable under some circumstances.\n - Integrated dynamic library support for HP.\n   (Thanks to Knut Tvedten <knuttv@ifi.uio.no>.)\n - Integrated James Clark's win32 threads support, and made a number\n   of changes to it, many of which were suggested by Pontus Rydin.\n   This is still not 100% solid.\n - Integrated Alistair Crooks' support for UTS4 running on an Amdahl\n   370-class machine.\n - Fixed a serious bug in explicitly typed allocation.  Objects requiring\n   large descriptors where handled in a way that usually resulted in\n   a segmentation fault in the marker.  (Thanks to Jeremy Fitzhardinge\n   for helping to track this down.)\n - Added partial support for GNU win32 development.  (Thanks to Fergus\n   Henderson.)\n - Added optional support for Java-style finalization semantics.  (Thanks\n   to Patrick Bridges.)  This is recommended only for Java implementations.\n - GC_malloc_uncollectable faulted instead of returning 0 when out of\n   memory.  (Thanks to dan@math.uiuc.edu for noticing.)\n - Calls to GC_base before the collector was initialized failed on a\n   DEC Alpha.  (Thanks to Matthew Flatt.)\n - Added base pointer checking to GC_REGISTER_FINALIZER in debugging\n   mode, at the suggestion of Jeremy Fitzhardinge.\n - GC_debug_realloc failed for uncollectable objects.  (Thanks to\n   Jeremy Fitzhardinge.)\n - Explicitly typed allocation could crash if it ran out of memory.\n   (Thanks to Jeremy Fitzhardinge.)\n - Added minimal support for a DEC Alpha running Linux.\n - Fixed a problem with allocation of objects whose size overflowed\n   ptrdiff_t.  (This now fails unconditionally, as it should.)\n - Added the beginning of Irix pthread support.\n - Integrated Xiaokun Zhu's fixes for djgpp 2.01.\n - Added SGI-style STL allocator support (gc_alloc.h).\n - Fixed a serious bug in README.solaris2.  Multithreaded programs must include\n   gc.h with SOLARIS_THREADS defined.\n - Changed GC_free so it actually deallocates uncollectable objects.\n   (Thanks to Peter Chubb for pointing out the problem.)\n - Added Linux ELF support for dynamic libararies.  (Thanks again to\n   Patrick Bridges.)\n - Changed the Borland cc configuration so that the assembler is not\n   required.\n - Fixed a bug in the C++ test that caused it to fail in 64-bit\n   environments.\n\nSince 4.11:\n - Fixed ElfW definition in dyn_load.c. (Thanks to Fergus Henderson.)\n   This prevented the dynamic library support from compiling on some\n   older ELF Linux systems.\n - Fixed UTS4 port (which I apparently mangled during the integration)\n   (Thanks to again to Alistair Crooks.)\n - \"Make C++\" failed on Suns with SC4.0, due to a problem with \"bool\".\n   Fixed in gc_priv.h.\n - Added more pieces for GNU win32.  (Thanks to Timothy N. Newsham.)\n   The current state of things should suffice for at least some\n   applications.\n - Changed the out of memory retry count handling as suggested by\n   Kenjiro Taura.  (This matters only if GC_max_retries > 0, which\n   is no longer the default.)\n - If a /proc read failed repeatedly, GC_written_pages was not updated\n   correctly.  (Thanks to Peter Chubb for diagnosing this.)\n - Under unlikely circumstances, the allocator could infinite loop in\n   an out of memory situation.  (Thanks again to Kenjiro Taura for\n   identifying the problem and supplying a fix.)\n - Fixed a syntactic error in the DJGPP code.  (Thanks to Fergus\n   Henderson for finding this by inspection.)  Also fixed a test program\n   problem with DJGPP (Thanks to Peter Monks.)\n - Atomic uncollectable objects were not treated correctly by the\n   incremental collector.  This resulted in weird log statistics and\n   occasional performance problems.  (Thanks to Peter Chubb for pointing\n   this out.)\n - Fixed some problems resulting from compilers that dont define\n   __STDC__.  In this case void * and char * were used inconsistently\n   in some cases.  (Void * should not have been used at all.  If\n   you have an ANSI superset compiler that does not define __STDC__,\n   please compile with -D__STDC__=0. Thanks to Manuel Serrano and others\n   for pointing out the problem.)\n - Fixed a compilation problem on Irix with -n32 and -DIRIX_THREADS.\n   Also fixed some other IRIX_THREADS problems which may or may not have\n   had observable symptoms.\n - Fixed an HP PA compilation problem in dyn_load.c.  (Thanks to\n   Philippe Queinnec.)\n - SEGV fault handlers sometimes did not get reset correctly.  (Thanks\n   to David Pickens.)\n - Added a fix for SOLARIS_THREADS on Intel.  (Thanks again to David\n   Pickens.)  This probably needs more work to become functional.\n - Fixed struct sigcontext_struct in os_dep.c for compilation under\n   Linux 2.1.X.\t(Thanks to Fergus Henderson.)\n - Changed the DJGPP STACKBOTTOM and DATASTART values to those suggested\n   by Kristian Kristensen.  These may still not be right, but it is\n   it is likely to work more often than what was there before.  They may\n   even be exactly right.\n - Added a #include <string.h> to test_cpp.cc.  This appears to help\n   with HP/UX and gcc.  (Thanks to assar@sics.se.)\n - Version 4.11 failed to run in incremental mode on recent 64-bit Irix\n   kernels.  This was a problem related to page unaligned heap segments.\n   Changed the code to page align heap sections on all platforms.\n   (I had mistakenly identified this as a kernel problem earlier.\n   It was not.)\n - Version 4.11 did not make allocated storage executable, except on\n   one or two platforms, due to a bug in a #if test.  (Thanks to Dave\n   Grove for pointing this out.)\n - Added sparc_sunos4_mach_dep.s to support Sun's compilers under SunOS4.\n - Added GC_exclude_static_roots.\n - Fixed the object size mapping algorithm.  This shouldn't matter,\n   but the old code was ugly.\n - Heap checking code could die if one of the allocated objects was\n   larger than its base address.  (Unsigned underflow problem.  Thanks\n   to Clay Spence for isolating the problem.)\n - Added RS6000 (AIX) dynamic library support and fixed STACK_BOTTOM.\n   (Thanks to Fred Stearns.)\n - Added Fergus Henderson's patches for improved robustness with large\n   heaps and lots of blacklisting.\n - Added Peter Chubb's changes to support Solaris Pthreads, to support\n   MMAP allocation in Solaris, to allow Solaris to find dynamic libraries\n   through /proc, to add malloc_typed_ignore_off_page, and a few other\n   minor features and bug fixes.\n - The Solaris 2 port should not use sbrk.  I received confirmation from\n   Sun that the use of sbrk and malloc in the same program is not\n   supported.  The collector now defines USE_MMAP by default on Solaris.\n - Replaced the djgpp makefile with Gary Leavens' version.\n - Fixed MSWIN32 detection test.\n - Added Fergus Henderson's patches to allow putting the collector into\n   a DLL under GNU win32.\n - Added Ivan V. Demakov's port to Watcom C on X86.\n - Added Ian Piumarta's Linux/PowerPC port.\n - On Brian Burton's suggestion added PointerFreeGC to the placement\n   options in gc_cpp.h.  This is of course unsafe, and may be controversial.\n   On the other hand, it seems to be needed often enough that it's worth\n   adding as a standard facility.\n\nSince 4.12:\n - Fixed a crucial bug in the Watcom port.  There was a redundant decl\n   of GC_push_one in gc_priv.h.\n - Added FINALIZE_ON_DEMAND.\n - Fixed some pre-ANSI cc problems in test.c.\n - Removed getpagesize() use for Solaris.  It seems to be missing in one\n   or two versions.\n - Fixed bool handling for SPARCCompiler version 4.2.\n - Fixed some files in include that had gotten unlinked from the main\n   copy.\n - Some RS/6000 fixes (missing casts).  Thanks to Toralf Foerster.\n - Fixed several problems in GC_debug_realloc, affecting mostly the\n   FIND_LEAK case.\n - GC_exclude_static_roots contained a buggy unsigned comparison to\n   terminate a loop.  (Thanks to Wilson Ho.)\n - CORD_str failed if the substring occurred at the last possible position.\n   (Only affects cord users.)\n - Fixed Linux code to deal with RedHat 5.0 and integrated Peter Bigot's\n   os_dep.c code for dealing with various Linux versions.\n - Added workaround for Irix pthreads sigaction bug and possible signal\n   misdirection problems.\nSince alpha1:\n - Changed RS6000 STACKBOTTOM.\n - Integrated Patrick Beard's Mac changes.\n - Alpha1 didn't compile on Irix m.n, m < 6.\n - Replaced Makefile.dj with a new one from Gary Leavens.\n - Added Andrew Stitcher's changes to support SCO OpenServer.\n - Added PRINT_BLACK_LIST, to allow debugging of high densities of false\n   pointers.\n - Added code to debug allocator to keep track of return address\n   in GC_malloc caller, thus giving a bit more context.\n - Changed default behavior of large block allocator to more\n   aggressively avoid fragmentation.  This is likely to slow down the\n   collector when it succeeds at reducing space cost.\n - Integrated Fergus Henderson's CYGWIN32 changes.  They are untested,\n   but needed for newer versions.\n - USE_MMAP had some serious bugs.  This caused the collector to fail\n   consistently on Solaris with -DSMALL_CONFIG.\n - Added Linux threads support, thanks largely to Fergus Henderson.\nSince alpha2:\n - Fixed more Linux threads problems.\n - Changed default GC_free_space_divisor to 3 with new large block allocation.\n   (Thanks to Matthew Flatt for some measurements that suggest the old\n   value sometimes favors space too much over time.)\n - More CYGWIN32 fixes.\n - Integrated Tyson-Dowd's Linux-M68K port.\n - Minor HP PA and DEC UNIX fixes from Fergus Henderson.\n - Integrated Christoffe Raffali's Linux-SPARC changes.\n - Allowed for one more GC fixup iteration after a full GC in incremental\n   mode.  Some quick measurements suggested that this significantly\n   reduces pause times even with smaller GC_RATE values.\n - Moved some more GC data structures into GC_arrays.  This decreases\n   pause times and GC overhead, but makes debugging slightly less convenient.\n - Fixed namespace pollution problem (\"excl_table\").\n - Made GC_incremental a constant for -DSMALL_CONFIG, hopefully shrinking\n   that slightly.\n - Added some win32 threads fixes.\n - Integrated Ivan Demakov and David Stes' Watcom fixes.\n - Various other minor fixes contributed by many people.\n - Renamed config.h to gcconfig.h, since config.h tends to be used for\n   many other things.\n - Integrated Matthew Flatt's support for 68K MacOS \"far globals\".\n - Fixed up some of the dynamic library Makefile targets for consistency\n   across platforms.\n - Fixed a USE_MMAP typo that caused out-of-memory handling to fail\n   on Solaris.\n - Added code to test.c to test thread creation a bit more.\n - Integrated GC_win32_free_heap, as suggested by Ivan Demakov.\n - Fixed Solaris 2.7 stack base finding problem.  (This may actually\n   have been done in an earlier alpha release.)\nSince alpha3:\n - Fixed MSWIN32 recognition test, which interfered with cygwin.\n - Removed unnecessary gc_watcom.asm from distribution.  Removed\n   some obsolete README.win32 text.\n - Added Alpha Linux incremental GC support.  (Thanks to Philipp Tomsich\n   for code for retrieving the fault address in a signal handler.)\n   Changed Linux signal handler context argument to be a pointer.\n - Took care of some new warnings generated by the 7.3 SGI compiler.\n - Integrated Phillip Musumeci's FreeBSD/ELF fixes.\n - -DIRIX_THREADS was broken with the -o32 ABI (typo in gc_priv.h>\n\nSince 4.13:\n - Fixed GC_print_source_ptr to not use a prototype.\n - generalized CYGWIN test.\n - gc::new did the wrong thing with PointerFreeGC placement.\n   (Thanks to Rauli Ruohonen.)\n - In the ALL_INTERIOR_POINTERS (default) case, some callee-save register\n   values could fail to be scanned if the register was saved and\n   reused in a GC frame.  This showed up in verbose mode with gctest\n   compiled with an unreleased SGI compiler.  I vaguely recall an old\n   bug report that may have been related.  The bug was probably quite old.\n   (The problem was that the stack scanning could be deferred until\n   after the relevant frame was overwritten, and the new save location\n   might be outside the scanned area.  Fixed by more eager stack scanning.)\n - PRINT_BLACK_LIST had some problems.  A few source addresses were garbage.\n - Replaced Makefile.dj and added -I flags to cord make targets.\n   (Thanks to Gary Leavens.)\n - GC_try_to_collect was broken with the nonincremental collector.\n - gc_cleanup destructors could pass the wrong address to\n   GC_register_finalizer_ignore_self in the presence of multiple\n   inheritance.  (Thanks to Darrell Schiebel.)\n - Changed PowerPC Linux stack finding code.\n\nSince 4.14alpha1\n - -DSMALL_CONFIG did not work reliably with large (> 4K) pages.\n   Recycling the mark stack during expansion could result in a size\n   zero heap segment, which confused things.  (This was probably also an\n   issue with the normal config and huge pages.)\n - Did more work to make sure that callee-save registers were scanned\n   completely, even with the setjmp-based code.  Added USE_GENERIC_PUSH_REGS\n   macro to facilitate testing on machines I have access to.\n - Added code to explicitly push register contents for win32 threads.\n   This seems to be necessary.  (Thanks to Pierre de Rop.)\n\nSince 4.14alpha2\n - changed STACKBOTTOM for DJGPP (Thanks to Salvador Eduardo Tropea).\n \nSince 4.14\n - Reworked large block allocator.  Now uses multiple doubly linked free\n   lists to approximate best fit.\n - Changed heap expansion heuristic.  Entirely free blocks are no longer\n   counted towards the heap size.  This seems to have a major impact on\n   heap size stability; the old version could expand the heap way too\n   much in the presence of large block fragmentation.\n - added -DGC_ASSERTIONS and some simple assertions inside the collector.\n   This is mainlyt for collector debugging.\n - added -DUSE_MUNMAP to allow the heap to shrink.  Suupported on only\n   a few UNIX-like platforms for now.\n - added GC_dump_regions() for debugging of fragmentation issues.\n - Changed PowerPC pointer alignment under Linux to 4.  (This needs\n   checking by someone who has one.  The suggestions came to me via a\n   rather circuitous path.)\n - Changed the Linux/Alpha port to walk the data segment backwards until\n   it encounters a SIGSEGV.  The old way to find the start of the data\n   segment broke with a recent release.\n - cordxtra.c needed to call GC_REGISTER_FINALIZER instead of\n   GC_register_finalizer, so that it would continue to work with GC_DEBUG.\n - allochblk sometimes cleared the wrong block for debugging purposes\n   when it dropped blacklisted blocks.  This could result in spurious\n   error reports with GC_DEBUG.\n - added MACOS X Server support.  (Thanks to Andrew Stone.)\n - Changed the Solaris threads code to ignore stack limits > 8 MB with\n   a warning.  Empirically, it is not safe to access arbitrary pages\n   in such large stacks.  And the dirty bit implementation does not\n   guarantee that none of them will be accessed.\n - Integrated Martin Tauchmann's Amiga changes.\n - Integrated James Dominy's OpenBSD/SPARC port.\n\nSince 5.0alpha1\n - Fixed bugs introduced in alpha1 (OpenBSD & large block initialization).\n - Added -DKEEP_BACK_PTRS and backptr.h interface.  (The implementation\n   idea came from Al Demers.)\n\nSince 5.0alpha2\n - Added some highly incomplete code to support a copied young generation.\n   Comments on nursery.h are appreciated.\n - Changed -DFIND_LEAK, -DJAVA_FINALIZATION, and -DFINALIZE_ON_DEMAND,\n   so the same effect could be obtained with a runtime switch.   This is\n   a step towards standardizing on a single dynamic GC library.\n - Significantly changed the way leak detection is handled, as a consequence\n   of the above.\n\nSince 5.0 alpha3\n - Added protection fault handling patch for Linux/M68K from Fergus\n   Henderson and Roman Hodek.\n - Removed the tests for SGI_SOURCE in new_gc_alloc.h.  This was causing that\n   interface to fail on nonSGI platforms.\n - Changed the Linux stack finding code to use /proc, after changing it\n   to use HEURISTIC1.  (Thanks to David Mossberger for pointing out the\n   /proc hook.)\n - Added HP/UX incremental GC support and HP/UX 11 thread support.\n   Thread support is currently still flakey.\n - Added basic Linux/IA64 support.\n - Integrated Anthony Green's PicoJava support.\n - Integrated Scott Ananian's StrongARM/NetBSD support.\n - Fixed some fairly serious performance bugs in the incremental\n   collector.  These have probably been there essentially forever.\n   (Mark bits were sometimes set before scanning dirty pages.\n   The reclaim phase unnecessarily dirtied full small object pages.)\n - Changed the reclaim phase to ignore nearly full pages to avoid\n   touching them.\n - Limited GC_black_list_spacing to roughly the heap growth increment.\n - Changed full collection triggering heuristic to decrease full GC\n   frequency by default, but to explicitly trigger full GCs during\n   heap growth.  This doesn't always improve things, but on average it's\n   probably a win.\n - GC_debug_free(0, ...) failed.  Thanks to Fergus Henderson for the\n   bug report and fix.\n\nSince 5.0 alpha4\n - GC_malloc_explicitly_typed and friends sometimes failed to\n   initialize first word.\n - Added allocation routines and support in the marker for mark descriptors\n   in a type structure referenced by the first word of an object.  This was\n   introduced to support gcj, but hopefully in a way that makes it\n   generically useful.\n - Added GC_requested_heapsize, and inhibited collections in nonincremental\n   mode if the actual used heap size is less than what was explicitly\n   requested.\n - The Solaris pthreads version of GC_pthread_create didn't handle a NULL\n   attribute pointer.  Solaris thread support used the wrong default thread\n   stack size.  (Thanks to Melissa O'Neill for the patch.)\n - Changed PUSH_CONTENTS macro to no longer modify first parameter.\n   This usually doesn't matter, but it was certainly an accident waiting\n   to happen ...\n - Added GC_register_finalizer_no_order and friends to gc.h.  They're\n   needed by Java implementations.\n - Integrated a fix for a win32 deadlock resulting from clock() calling\n   malloc.  (Thanks to Chris Dodd.)\n - Integrated Hiroshi Kawashima's port to Linux/MIPS.  This was designed\n   for a handheld platform, and may or may not be sufficient for other\n   machines.\n - Fixed a va_arg problem with the %c specifier in cordprnt.c.  It appears\n   that this was always broken, but recent versions of gcc are the first to\n   report the (statically detectable) bug.\n - Added an attempt at a more general solution to dlopen races/deadlocks.\n   GC_dlopen now temporarily disables collection.  Still not ideal, but ...\n - Added -DUSE_I686_PREFETCH, -DUSE_3DNOW_PREFETCH, and support for IA64\n   prefetch instructions.  May improve performance measurably, but I'm not\n   sure the code will run correctly on processors that don't support the\n   instruction.  Won't build except with very recent gcc.\n - Added caching for header lookups in the marker.  This seems to result\n   in a barely measurable performance gain.  Added support for interleaved\n   lookups of two pointers, but unconfigured that since the performance\n   gain is currently near zero, and it adds to code size.\n - Changed Linux DATA_START definition to check both data_start and\n   __data_start, since nothing else seems to be portable.\n - Added -DUSE_LD_WRAP to optionally take advantage of the GNU ld function\n   wrapping mechanism.  Probably currently useful only on Linux.\n - Moved some variables for the scratch allocator into GC_arrays, on\n   Martin Hirzel's suggestion.\n - Fixed a win32 threads bug that caused the collector to not look for\n   interior pointers from one of the thread stacks without\n   ALL_INTERIOR_POINTERS.  (Thanks to Jeff Sturm.)\n - Added Mingw32 support.  (Thanks again to Jeff Sturm for the patch.)\n - Changed the alpha port to use the generic register scanning code instead\n   of alpha_mach_dep.s.  Alpha_mach_dep.s doesn't look for pointers in fp\n   registers, but gcc sometimes spills pointers there.  (Thanks to Manuel\n   Serrano for helping me debug this by email.)  Changed the IA64 code to\n   do something similar for similar reasons.\n\n[5.0alpha5 doesn't really exist, but it may have escaped.]\n\nSince 5.0alpha6:\n - -DREDIRECT_MALLOC was broken in alpha6. Fixed.\n - Cleaned up gc_ccp.h slightly, thus also causing the HP C++ compiler to\n   accept it.\n - Removed accidental reference to dbg_mlc.c, which caused dbg_mlc.o to be\n   linked into every executable.\n - Added PREFETCH to bitmap marker.  Changed it to use the header cache.\n - GC_push_marked sometimes pushed one object too many, resulting in a\n   segmentation fault in GC_mark_from_mark_stack.  This was probably an old\n   bug.  It finally showed up in gctest on win32.\n - Gc_priv.h erroneously #defined GC_incremental to be TRUE instead of FALSE\n   when SMALL_CONFIG was defined.  This was no doubt a major performance bug for\n   the default win32 configuration.\n - Removed -DSMALL_CONFIG from NT_MAKEFILE.  It seemed like an anchronism now\n   that the average PC has 64MB or so.\n - Integrated Bryce McKinley's patches for linux threads and dynamic loading\n   from the libgcj tree.  Turned on dynamic loading support for Linux/PPC.\n - Changed the stack finding code to use environ on HP/UX.  (Thanks\n   to Gustavo Rodriguez-Rivera for the suggestion.)  This should probably\n   be done on other platforms, too.  Since I can't test those, that'll\n   wait until after 5.0.\n\nSince 5.0alpha7:\n - Fixed threadlibs.c for linux threads.  -DUSE_LD_WRAP was broken and\n   -ldl was omitted.  Fixed Linux stack finding code to handle\n   -DUSE_LD_WRAP correctly.\n - Added MSWIN32 exception handler around marker, so that the collector\n   can recover from root segments that are unmapped during the collection.\n   This caused occasional failures under Windows 98, and may also be\n   an issue under Windows NT/2000.\n\nSince 5.0\n - Fixed a gc.h header bug which showed up under Irix.  (Thanks to\n   Dan Sullivan.)\n - Fixed a typo in GC_double_descr in typd_mlc.c.\n   This probably could result in objects described by array descriptors not\n   getting traced correctly.  (Thanks to Ben Hutchings for pointing this out.)\n - The block nearly full tests in reclaim.c were not correct for 64 bit\n   environments.  This could result in unnecessary heap growth under unlikely\n   conditions.\n\nSince 5.1\n - dyn_load.c declared GC_scratch_last_end_ptr as an extern even if it\n   was defined as a macro.  This prevented the collector from building on\n   Irix.\n - We quietly assumed that indirect mark descriptors were never 0.\n   Our own typed allocation interface violated that.  This could result\n   in segmentation faults in the marker with typed allocation.\n - Fixed a _DUSE_MUNMAP bug in the heap block allocation code.\n   (Thanks to Ben Hutchings for the patch.)\n - Taught the collector about VC++ handling array operator new.\n   (Thanks again to Ben Hutchings for the patch.)\n - The two copies of gc_hdrs.h had diverged.  Made one a link to the other\n   again.\n\nSince 5.2  (A few 5.2 patches are not in 6.0alpha1)\n - Fixed _end declaration for OSF1.\n - There were lots of spurious leak reports in leak detection mode, caused\n   by the fact that some pages were not being swept, and hence unmarked\n   objects weren't making it onto free lists.  (This bug dated back to 5.0.)\n - Fixed a typo in the liblinuxgc.so Makefile rule.\n - Added the GetExitCodeThread to Win32 GC_stop_world to (mostly) work\n   around a Windows 95 GetOpenFileName problem.  (Thanks to Jacob Navia.)\n\nSince 5.3\n - Fixed a typo that prevented compilation with -DUSE_3DNOW_PREFETCH.\n   (Thanks to Shawn Wagner for actually testing this.)\n - Fixed GC_is_thread_stack in solaris_threads.c.  It forgot to return a value\n   in the common case.  I wonder why nobody noticed?\n - Fixed another silly syntax problem in GC_double_descr.  (Thanks to\n   Fergus Henderson for finding it.)\n - Fixed a GC_gcj_malloc bug: It tended to release the allocator lock twice.\n\nSince 5.4  (A few 5.3 patches are not in 6.0alpha2)\n - Added HP/PA prefetch support.\n - Added -DDBG_HDRS_ALL and -DSHORT_DBG_HDRS to reduce the cost and improve\n   the reliability of generating pointer backtrace information, e.g. in\n   the Bigloo environment.\n - Added parallel marking support (-DPARALLEL_MARK).  This currently\n   works only under IA32 and IA64 Linux, but it shouldn't be hard to adapt\n   to other platforms.  This is intended to be a lighter-weight (less\n   new code, probably not as scalable) solution than the work by Toshio Endo\n   et al, at the University of Tokyo.  A number of their ideas were\n   reused, though the code wasn't, and the underlying data structure\n   is significantly different.  In particular, we keep the global mark\n   stack as a single shared data structure, but most of the work is done\n   on smaller thread-local mark stacks.\n - Changed GC_malloc_many to be cheaper, and to require less mutual exclusion\n   with -DPARALLEL_MARK.\n - Added full support for thread local allocation under Linux\n   (-DTHREAD_LOCAL_ALLOC).  This is a thin veneer on GC_malloc_many, and\n   should be easily portable to other platforms, especially those that\n   support pthreads.\n - CLEAR_DOUBLE was not always getting invoked when it should have been.\n - GC_gcj_malloc and friends used different out of memory handling than\n   everything else, probably because I forgot about one when I implemented\n   the other.  They now both call GC_oom_fn(), not GC_oom_action().\n - Integrated Jakub Jelinek's fixes for Linux/SPARC.\n - Moved GC_objfreelist, GC_aobjfreelist, and GC_words_allocd out of\n   GC_arrays, and separately registered the first two as excluded roots.\n   This makes code compiled with gc_inl.h less dependent on the\n   collector version.  (It would be nice to remove the inclusion of\n   gc_priv.h by gc_inl.h completely, but we're not there yet.  The\n   locking definitions in gc_priv.h are still referenced.)\n   This change was later coniditoned on SEPARATE_GLOBALS, which\n   is not defined by default, since it involves a performance hit.\n - Register GC_obj_kinds separately as an excluded root region.  The\n   attempt to register it with GC_arrays was usually failing.  (This wasn't\n   serious, but seemed to generate some confusion.) \n - Moved backptr.h to gc_backptr.h.\n\nSince 6.0alpha1\n - Added USE_MARK_BYTES to reduce the need for compare-and-swap on platforms\n   for which that's expensive.\n - Fixed a locking bug ib GC_gcj_malloc and some locking assertion problems.\n - Added a missing volatile to OR_WORD and renamed the parameter to\n   GC_compare_and_swap so it's not a C++ reserved word.  (Thanks to\n   Toshio Endo for pointing out both of those.)\n - Changed Linux dynamic library registration code to look at /proc/self/maps\n   instead of the rld data structures when REDIRECT_MALLOC is defined.\n   Otherwise some of the rld data data structures may be prematurely garbage\n   collected.  (Thanks to Eric Benson for helping to track this down.)\n - Fixed USE_LD_WRAP a bit more, so it should now work without threads.\n - Renamed XXX_THREADS macros to GC_XXX_THREADS for namespace correctness.\n   Tomporarily added some backward compatibility definitions.  Renamed\n   USE_LD_WRAP to GC_USE_LD_WRAP.\n - Many MACOSX POWERPC changes, some additions to the gctest output, and\n   a few minor generic bug fixes.  (Thanks to Dietmar Planitzer.)\n\nSince 6.0 alpha2\n - Fixed the /proc/self/maps code to not seek, since that apparently is not\n   reliable across all interesting kernels.\n - Fixed some compilation problems in the absence of PARALLEL_MARK\n   (introduced in alpha2).\n - Fixed an algorithmic problem with PARALLEL_MARK.  If work needs to\n   be given back to the main mark \"stack\", the BOTTOM entries of the local\n   stack should be given away, not the top ones.  This has substantial\n   performance impact, especially for > 2 processors, from what I can tell.\n - Extracted gc_lock.h from gc_priv.h.  This should eventually make it a\n   bit easier to avoid including gc_priv.h in clients.\n - Moved all include files to include/ and removed duplicate links to the\n   same file.  The old scheme was a bad idea because it was too easy to get the\n   copies out of sync, and many systems don't support hard links.\n   Unfortunately, it's likely that I broke some of the non-Unix Makefiles in\n   the process, although I tried to update them appropriately.\n - Removed the partial support for a copied nursery.  It's not clear that\n   this would be a tremendous win, since we don't consistently lose to\n   generational copying collectors.  And it would significantly complicate\n   many things.  May be reintroduced if/when it really turns out to win.\n - Removed references to IRIX_JDK_THREADS, since I believe there never\n   were and never will be any clients.\n - Added some code to linux_threads.c to possibly support HPUX threads\n   using the Linux code.  Unfortunately, it doesn't work yet, and is\n   currently disabled.\n - Added support under Linux/X86 for saving the call chain, both in (debug)\n   objects for client debugging, and in GC_arrays._last_stack for GC\n   debugging.  This was previously supported only under Solaris.  It is\n   not enabled by default under X86, since it requires that code be compiled\n   to explicitly dave frame pointers on the call stack.  (With gcc this\n   currently happens by default, but is often turned off explicitly.)\n   To turn it on, define SAVE_CALL_CHAIN.\n \nSince 6.0 alpha3\n - Moved up the detection of mostly full blocks to the initiatiation of the\n   sweep phase.  This eliminates some lock conention in the PARALLEL_MARK case,\n   as multiple threads try to look at mostly full blocks concurrently.\n - Restored the code in GC_malloc_many that grabs a prefix of the global\n   free list.  This avoids the case in which every GC_malloc_many call\n   tries and fails to allocate a new heap block, and the returns a single\n   object from the global free list.\n - Some minor fixes in new_hblk.c.  (Attempted to build free lists in order\n   of increasing addresses instead of decreasing addresses for cache performance\n   reasons.  But this seems to be only a very minor gain with -DEAGER_SWEEP,\n   and a loss in other cases.  So the change was backed out.)\n - Fixed some of the documentation.  (Thanks in large part to Fergus\n   Henderson.)\n - Fixed the Linux USE_PROC_FOR_LIBRARIES code to deal with apps that perform\n   large numbers of mmaps.  (Thanks to Eric Benson.)  Also fixed that code to\n   deal with short reads.\n - Added GC_get_total_bytes(). \n - Fixed leak detection mode to avoid spurious messages under linuxthreads.\n   (This should also now be easy for the other supported threads packages.\n   But the code is tricky enough that I'm hesitant to do it without being able\n   to test.  Everything allocated in the GC thread support itself should be\n   explicitly deallocated.)\n - Made it possible (with luck) to redirect malloc to GC_local_malloc.\n\nSince 6.0 alpha4\n - Changed the definition of GC_pause in linux_threads.c to use a volatile\n   asm.  Some versions of gcc apparently optimize away writes to local volatile\n   variables.  This caused poor locking behaviour starting at about\n   4 processors.\n - Added GC_start_blocking(), GC_end_blocking() calls and wrapper for sleep\n   to linux_threads.c.\n   The first two calls could be used to generally avoid sending GC signals to\n   blocked threads, avoiding both premature wakeups and unnecessary overhead.\n - Fixed a serious bug in thread-local allocation.  At thread termination,\n   GC_free could get called on small integers.  Changed the code for thread\n   termination to more efficiently return left-over free-lists.\n - Integrated Kjetil Matheussen's BeOS support.\n - Rearranged the directory structure to create the doc and tests\n   subdirectories.\n - Sort of integrated Eric Benson's patch for OSF1.  This provided basic\n   OSF1 thread support by suitably extending hpux_irix_threads.c.  Based\n   on earlier email conversations with David Butenhof, I suspect that it\n   will be more reliable in the long run to base this on linux_threads.c\n   instead.  Thus I attempted to patch up linux_threads.c based on Eric's code.\n   The result is almost certainly broken, but hopefully close enough that\n   someone with access to a machine can pick it up.\n - Integrated lots of minor changes from the NetBSD distribution.  (These\n   were supplied by David Brownlee.  I'm not sure about the original\n   authors.)\n - Hacked a bit more on the HP/UX thread-support in linux_threads.c.  It\n   now appears to work in the absence of incremental collection.  Renamed\n   hpux_irix_threads.c back to irix_threads.c, and removed the attempt to\n   support HPUX there.\n - Changed gc.h to define _REENTRANT in cases in which it should already\n   have been defined. It is still safer to also define it on the command\n   line. \n\nSince 6.0alpha5:\n - Changed the definition of DATASTART on ALPHA and IA64, where data_start\n   and __data_start are not defined by earlier versions of glibc.  This might\n   need to be fixed on other platforms as well.\n - Changed the way the stack base and backing store base are found on IA64.\n   This should now remain reliable on future kernels.  But since it relies\n   on /proc, it will no longer work in the simulated NUE environment.\n - Made the call to random() in dbg_mlc.c with -DKEEP_BACK_PTRS dependent\n   on the OS.  On non-Unix systems, rand() should be used instead.  Handled\n   small RAND_MAX.  (Thanks to Peter Ross for pointing this out.)\n - Fixed the cord make rules to create the cord subdirectory, if necessary.\n   (Thanks to Doug Moen.)\n - Changed fo_object_size calculation in finalize.c.  Turned finalization\n   of nonheap object into a no-op.  Removed anachronism from GC_size()\n   implementation.\n - Changed GC_push_dirty call in solaris_threads.c to GC_push_selected.\n   It was missed in a previous renaming. (Thanks to Vladimir Tsichevski\n   for pointing this out.)\n - Arranged to not not mask SIGABRT in linux_threads.c.  (Thanks to Bryce\n   McKinlay.) \n - Added GC_no_dls hook for applications that want to register their own\n   roots.\n - Integrated Kjetil Matheussen's Amiga changes.\n - Added FREEBSD_STACKBOTTOM.  Changed the X86/FreeBSD port to use it.\n   (Thanks to Matthew Flatt.)\n - Added pthread_detach interception for platforms supported by linux_threads.c\n   and irix_threads.c.  Should also be added for Solaris?\n - Changed the USE_MMAP code to check for the case in which we got the\n   high end of the address space, i.e. mem_ptr + mem_sz == 0.  It appears\n   that this can happen under Solaris 7.  It seems to be allowed by what\n   I would claim is an oversight in the mmap specification.  (Thanks to Toshio\n   Endo for pointing out the problem.)\n - Cleanup of linux_threads.c.  Some code was originally cloned from\n   irix_threads.c and now unnecessary.  Some comments were obviously wrong.\n - (Mostly) fixed a longstanding problem with setting of dirty bits from\n   a signal handler.  In the presence of threads, dirty bits could get lost,\n   since the etting of a bit in the bit vector was not atomic with respect\n   to other updates.  The fix is 100% correct only for platforms for which\n   GC_test_and_set is defined.  The goal is to make that all platforms with\n   thread support.  Matters only if incremental GC and threads are both\n   enabled.\n - made GC_all_interior_pointers (a.k.a. ALL_INTERIOR_POINTERS) an\n   initialization time, instead of build-time option.  This is a \n   nontrivial, high risk change.  It should slow down the code measurably\n   only if MERGE_SIZES is not defined, which is a very nonstandard\n   configuration.   \n - Added doc/README.environment, and implemented what it describes.  This\n   allows a number of additional configuration options to be set through\n   the environment.  It documents a few previously undocumented options.\n - Integrated Eric Benson's leak testing improvements.\n - Removed the option to throw away the beginning of each page (DISCARD_WORDS).\n   This became less and less useful as processors enforce stricter alignment.\n   And it hadn't been tested in ages, and was thus probably broken anyway.\n\nSince 6.0alpha6:\n - Added GC_finalizer_notifier.  Fixed GC_finalize_on_demand.  (The variable\n   actually wasn't being tested at the right points.  The build-time flag\n   was.)\n - Added Tom Tromey's S390 Linux patch.\n - Added code to push GC_finalize_now in GC_push_finalizer_structures.\n   (Thanks to Matthew Flatt.)\n - Added GC_push_gc_structures() to push all GC internal roots.\n - Integrated some FreeBSD changes from Matthew Flatt.\n - It looks like USRSTACK is not always correctly defined under Solaris.\n   Hacked gcconfig.h to attempt to work around the problem.  The result\n   is not well tested.  (Thanks again to Matthew Flatt for pointing this\n   out.  The gross hack is mine. - HB)\n - Added Ji-Yong Chung's win32 threads and C++ fixes.\n - Arranged for hpux_test_and_clear.s to no longer be needed or built.\n   It was causing build problems with gas, and it's not clear this is\n   better than the pthreads alternative on this platform.\n - Some MINGW32 fixes from Hubert Garavel.\n - Added Initial Hitachi SH4 port from Kaz Kojima.\n - Ported thread-local allocation and parallel mark code to HP/UX on PA_RISC.\n - Made include/gc_mark.h more public and separated out the really private\n   pieces.  This is probably still not quite sufficient for clients that\n   want to supply their own kind of type information.  But it's a start.\n   This involved lots of identifier renaming to make it namespace clean.\n - Added GC_dont_precollect for clients that need complete control over\n   the root set.\n - GC_is_visible didn't do the right thing with gcj objects.  (Not that\n   many people are likely to care, but ...)\n - Don't redefine read with GC_USE_LD_WRAP.\n - Initial port to LINUX/HP_PA.  Incremental collection and threads are not\n   yet supported.  (Incremental collection should work if you have the\n   right kernel.  Threads may work with a sufficiently patched pthread\n   library.)\n - Changed gcconfig.h to recognize __i386__ as an alternative to i386 in\n   many places.  (Thanks to Benjamin Lerman.)\n - Made win32_threads.c more tolerant of detaching a thread that it didn't\n   know about.  (Thanks to Paul Nash.)\n - Added Makefile.am and configure.ac from gcc to the distribution, with\n   minimal changes.  For the moment, those are just placeholders.  In the\n   future, we're planning to switch to a GNU-style build environment for\n   Un*x-like systems, though the old Makefile will remain as a backup.\n - Turned off STUBBORN_ALLOC by default, and added it back as a Makefile\n   option.\n - Redistributed some functions between malloc.c and mallocx.c, so that\n   simple statically linked apps no longer pull in mallocx.o.\n - Changed large object allocation to clear the first and last few words\n   of each block before releassing the lock.  Otherwise the marker could see\n   objects with nonsensical type descriptors.\n - Fixed a couple of subtle problems that could result in not recognizing\n   interior pointers from the stack.  (I believe these were introduced\n   in 6.0alpha6.)\n - GC_debug_free_inner called GC_free, which tried to reacquire the\n   allocator lock, and hence deadlocked.  (DBG_HDRS_ALL probably never worked\n   with threads?)\n - Fixed several problems with back traces.  Accidental references to a free\n   list could cause the free list pointer to be overwritten by a back pointer.\n   There seemed to be some problems with the encoding of root and finalizer\n   references.\n  \nSince 6.0alpha7:\n - Changed GC_debug_malloc_replacement and GC_debug_realloc_replacement\n   so that they compile under Irix.  (Thanks to Dave Love.)\n - Updated powerpc_macosx_mach_dep.s so that it works if the collector\n   is in a dynamic library.  (Thanks to Andrew Begel.)\n - Transformed README.debugging into debugging.html, updating and\n   expanding it in the process.  Added gcdescr.html and tree.html\n   from the web site to the GC distribution.\n - Fixed several problems related to PRINT_BLACK_LIST. This involved\n   restructuring some of the marker macros.\n - Fixed some problems with the sizing of objects with debug information.\n   Finalization was broken KEEP_BACK_PTRS or PRINT_BLACK_LIST.  Reduced the\n   object size with SHORT_DEBUG_HDRS by another word.\n - The \"Needed to allocate blacklisted ...\" warning had inadvertently\n   been turned off by default, due to a buggy test in allchblk.c.  Turned\n   it back on.\n - Removed the marker macros to deal with 2 pointers in interleaved fashion.\n   They were messy and the performance improvement seemed minimal.  We'll\n   leave such scheduling issues to the compiler.\n - Changed Linux/PowerPC test to also check for __powerpc__ in response\n   to a discussion on the gcc mailing list.\n - On Matthew Flatt's suggestion removed the \"static\" from the jmp_buf\n   declaration in GC_generic_push_regs.  This was causing problems in\n   systems that register all of their own roots.  It looks far more correct\n   to me without the \"static\" anyway. \n - Fixed several problems with thread local allocation of pointerfree or\n   typed objects.  The collector was reclaiming thread-local free lists, since\n   it wasn't following the link fields.\n - There was apparently a long-standing race condition related to multithreaded\n   incremental collection.  A collection could be started and a thread stopped\n   between the memory unprotect system call and the setting of the\n   corresponding dirt bit.  I believe this did not affect Solaris or PCR, which\n   use a different dirty-bit implementation.  Fixed this by installing\n   signal handlers with sigaction instead of signal, and disabling the thread\n   suspend signal while in the write-protect handler.  (It is unclear\n   whether this scenario ever actually occurred.  I found it while tracking\n   down the following:)\n - Incremental collection did not cooperate correctly with the PARALLEL_MARK\n   implementation of GC_malloc_many or the local_malloc primitves.  It still\n   doesn't work well, but it shouldn't lose memory anymore.\n - Integrated some changes from the gcc source tree that I had previously\n   missed.  (Thanks to Bryce McKinley for the reminder/diff.)\n - Added Makefile.direct as a copy of the default Makefile, which would\n   normally be overwritten if configure is run.\n - Changed the gc.tar target in Makefile.direct to embed the version number\n   in the gc directory name.  This will affect future tar file distributions.\n - Changed the Irix dynamic library finding code to no longer try to\n   eliminate writable text segments under Irix6.x, since that is probably no\n   longer necessary, and can apparently be unsafe on occasion.  (Thanks to\n   Shiro Kawai for pointing this out.)\n - GC_cleanup with GC_DEBUG enabled passed a real object base address to\n   GC_debug_register_finalizer_ignore_self, which expected a pointer past the\n   debug header.  Call GC_register_finalizer_ignore_self instead, even with\n   debugging enabled.  (Thanks to Jean-Daniel Fekete for catching this.)\n - The collector didn't build with call chain saving enabled but NARGS=0.\n   (Thanks to Maarten Thibaut.)\n - Fixed up the GNU-style build files enough so that they work in some\n   obvious cases.\n - Added initial port to Digital Mars compiler for win32. (Thanks to Walter\n   Bright.)\n\nSince 6.0alpha8:\n - added README.macros.\n - Made gc.mak a symbolic link to work around winzip's tendency to ignore\n   hard links.\n - Simplified the setting of NEED_FIND_LIMIT in os_dep.c, possibly breaking\n   it on untested platforms.\n - Integrated initial GNU HURD port. (Thanks to Chris Lingard and Igor\n   Khavkine.)\n - A few more fixes for Digital Mars compiler (Walter Bright).\n - Fixed gcc version recognition.  Renamed OPERATOR_NEW_ARRAY to\n   GC_OPERATOR_NEW_ARRAY.  Changed GC_OPERATOR_NEW_ARRAY to be the default.\n   It can be overridden with -DGC_NO_OPERATOR_NEW_ARRAY.  (Thanks to\n   Cesar Eduardo Barros.) \n - Changed the byte size to free-list mapping in thread local allocation\n   so that size 0 allocations are handled correctly.\n - Fixed Linux/MIPS stackbottom for new toolchain. (Thanks to Ryan Murray.)\n - Changed finalization registration to invoke GC_oom_fn when it runs out\n   of memory.\n - Removed lvalue cast in finalize.c.  This caused some debug configurations\n   not to build with some non-gcc compilers.\n\nSince 6.0alpha9:\n - Two more bug fixes for KEEP_BACK_PTRS and DBG_HDRS_ALL.\n - Fixed a stack clearing problem that resulted in SIGILL with a\n   misaligned stack pointer for multithreaded SPARC builds.\n - Integrated another HURD patch (thanks to Igor Khavkine).\n\nSince 6.0:\n - Non-debug, atomic allocations could result in bogus smashed object\n   reports with debugging on.  (Thanks to Patrick Doyle for the small\n   test case.)\n - Fixed GC_get_register_stack_base (Itanium only) to work around a glibc\n   2.2.4 bug.\n - Initial port to HP/UX on Itanium.  Thread support and both 32 and 64\n   bit ABIs appear to work.  Parallel mark support doesn't yet, due to\n   some inline assembly code issues.  Thread local allocation does appear\n   to work.\n - ifdef'ed out glibc2.1/Itanium workaround.  I suspect nobody is using\n   that combination anymore.\n - Added a patch to make new_gc_alloc.h usable with gcc3.0.  (Thanks to\n   Dimitris Vyzovitis for the patch.)\n - Debugged 64-bit support on HP/UX PA-RISC.\n - Turned on dynamic loading support for FreeBSD/ELF.  (Thanks to Peter\n   Housel.)\n - Unregistering of finalizers with debugging allocation was broken.\n   (Thanks to Jani Kajala for the test case.)\n - Old finalizers were not returned correctly from GC_debug_register_finalizer.\n - Disabled MPROTECT_VDB for Linux/M68K based on a report that it doesn't work.\n - Cleaned up some statistics gathering code in reclaim.c (Thanks to Walter\n   Bright.)\n - Added some support for OpenBSD/ELF/Linux.  (Thanks to Suzuki Toshiya.)\n - Added Jakub Jelinek's patch to use dl_iterate_phdr for dynamic library\n   traversal to dyn_load.c.  Changed it to weakly reference dl_iterate_phdr,\n   so that the old code is stilll used with old versions of glibc.\n - Cleaned up feature test macros for various threads packages and\n   integrated (partially functional) FreeBSD threads code from Loren Rittle.\n   It's likely that the cleanup broke something, since it touched lots of\n   code.  It's also likelly that it fixed some unreported bugs in the\n   less common thread implementations, since some of the original code\n   didn't stand up to close scrutiny.  Support for the next pthreads\n   implementation should be easier to add.\n\nSince 6.1alpha1:\n - No longer wrap read by default in multithreaded applications.  It was\n   pointed out on the libgcj list that this holds the allocation lock for\n   way too long if the read blocks.  For now, reads into the heap are\n   broken with incremental collection.  It's possible to turn this back on\n   if you make sure that read calls don't block (e.g. by calling select\n   first).\n - Fix ifdef in Solaris_threads.h to refer to GC_SOLARIS_THREADS.\n - Added check for environment variable GC_IGNORE_GCJ_INFO.\n - Added printing of stop-the-world GC times if GC_PRINT_STATS environment\n   variable is set.\n - The calloc definition in leak_detector.h was missing parentheses, and\n   realloc was missing a second argument to GC_REALLOC.\n   (Thanks to Elrond (elrond<at>samba-tng.org).)\n - Added GC_PRINT_BACK_HEIGHT environment variable and associated\n   code, mostly in the new file backgraph.c.  See doc/README.environment.\n - Added -DUSE_GLOBAL_ALLOC to work around a Windows NT issue.  (Thanks to\n   Jonathan Clark.)\n - Integrated port to NEC EWS4800 (MIPS-based workstation, with somewhat\n   different address-space layout). This may help for other machines with\n   holes in the data segment.  (Thanks to Hironori Sakamoto.)\n - Changed the order in which GC_push_roots and friends push things onto\n   the mark stack.  GC_push_all calls need to come first, since we can't\n   necessarily recovere if those overflow the mark stack.  (Thanks to\n   Matthew Flatt for tracking down the problem.)\n - Some minor cleanups to mostly support the Intel compiler on Linux/IA64.\n\nSince 6.1 alpha2:\n - Minor cleanup on the gcconfig.h section for SPARC.\n - Minor fix to support Intel compiler for I386/Linux. (Thanks to Sven\n   Hartrumpf.)\n - Added SPARC V9 (64-bit) support.  (Thanks to Jeff Sturm.)\n - Restructured the way in which we determine whether or not to keep\n   call stacks for debug allocation.  By default SAVE_CALL_COUNT is\n   now zero on all platforms.  Added SAVE_CALL_NARGS parameters.\n   If possible, use execinfo.h to capture call stack.  (This should\n   add support for a number of new platforms, though often at\n   considerable runtime expense.)\n - Try to print symbolic information for call stacks.  On Linux, we\n   do this with a combination of execinfo.h and running addr2line in\n   a separate process.  This is both much more expensive and much more\n   useful.  Amazingly, it seems to be fast enough for most purposes.\n - Redefined strdup if -DREDIRECT_MALLOC is given.\n - Changed incremental collector and MPROTECT_VDB implementation so that,\n   under favorable conditions, pointerfree objects are not protected.\n   Added GC_incremental_protection_needs() to determine ahead of time whether\n   pointerfree objects may be protected.  Replaced GC_write_hint() with\n   GC_remove_protection().\n - Added test for GC_ENABLE_INCREMENTAL environment variable.\n - Made GC_time_limit runtime configurable.  Added GC_PAUSE_TIME_TARGET\n   environment variable.\n - Eliminated GC_page_sz, a duplicate of GC_page_size.\n - Caused the Solaris and Irix thread creation primitives to call\n   GC_init_inner().\n \nSince 6.1alpha3:\n - Fixed typo in sparc_mach_dep.S, preventing the 64-bit version from\n   building.  Increased 64-bit heap size limit in test.c slightly, since\n   a functional SPARC collector seems to slightly exceed the old limits.\n   (Thanks again to Jeff Sturm.)\n - Use NPRGREG in solaris_threads.c, thus printing all registers if things\n   go wrong.\n - Added GC_MARKERS environment variable to allow use of a single marker\n   thread on an MP without confusing the lock implementation.\n - Collect much less aggressively in incremental mode with GC_TIME_UNLIMITED.\n   This is really a purely generational mode, and we can afford to \n   postpone the collection until the heap is (nearly) full.\n - Remove read() wrapper for MPROTECT_VDB.  It was causing more harm than\n   good.  It is often no longer needed if system calls avoid writing to\n   pointerfull heap objects.\n - Fix MACOSX test in gcconfig.h. (Thanks to John Clements.)\n - Change GC_test_and_set so that it consistently has one argument.\n   Add spaces to ::: in powerpc assembly code in gc_locks.h.\n   (Thanks to Ryan Murray.)\n - Fixed a formatting error in dbg_mlc.c.  Added prototype to GC_abort()\n   declaration.   (Thanks to Michael Smith.)\n - Removed \"source\" argument to GC_find_start().  Eliminate GC_FIND_START().\n - Added win32 recognition code in configure.ac.  Changed some of the\n   dllimport/export defines in gc.h.  (Thanks to Adam Megacz.)\n - GC_malloc_many didn't set hb_last_reclaimed when it called \n   GC_reclaim_generic.  (I'm not sure this matters much, but ...)\n - Allocating uncollectable objects with debug information sometimes\n   allocated objects that were one byte too small, since uncollectable\n   objects don't have the extra byte added at the end.  (Thanks to\n   Wink Saville for pointing this out.)\n - Added a bit more assertion checking to make sure that gcj objects\n   on free lists never have a nonzero second word.\n - Replaced BCC_MAKEFILE with an up-to-date one.  (Thanks to \n   Andre Leiradella.)\n - Upgraded libtool, cinfigure.in and some related files to hopefully\n   support NetBSD/SPARC.  (Thanks to Adrian Bunk.)  Unfortunately,\n   libtool 1.4.2 seemed to be buggy due to missing quotes in several\n   \"test\" invocations.  Fixed those in the ltmain.sh script.\n - Some win32-specific patches, including the introduction of\n   GC_CreateThread.  (Thanks to Adam Megacz.)\n - Merged in gcj changes from Anthony Green to support embedded systems.\n - Tried to consistently rename preprocessed assembly files with a capital\n   .S extension.\n - Use alpha_mach_dep.S on ALPHA again.  It doesn't really matter, but this\n   makes our distribution consistent with the gcc one, avoiding future merge\n   problems.\n - Move GET_MEM definition into gcconfig.h.  Include gcconfig.h slightly\n   later in gc_priv.h to avoid forward references to ptr_t.\n - Add some testing of local allocation to test.c.\n - Change definition of INVALID_QTID in specific.h.  The -1 value was used\n   inconsistently, and too likely to collide with a valid stack address.\n   Some general clean-up of specific.[ch].  Added assertions.  (Thanks\n   to Michael Smith for tracking down an intermittent bug to this\n   general area.  I'm not sure it has been squashed yet, however.)\n - On Pthread systems it was not safe to call GC_malloc() between fork()\n   and exec().  According to the applicable standards, it doesn't appear\n   to be safe to call malloc() or many other libc functions either, thus\n   it's not clear this is fixable.  Added experimental support for\n   -DHANDLE_FORK in linux_threads.c which tries to support it.  It may\n   succeed if libc does the right thing.  I'm not sure whether it does.\n   (Thanks to Kenneth Schalk for pointing out this issue.)\n - Documented thread local allocation primitives to require an\n   explicit GC_init call.  GC_init_parallel is no longer declared to\n   be a constructor function, since that isn't portable and often\n   seems to lead to initialization order problems.\n - Changed gc_cpp.cc and gc_cpp.h in one more attempt to make them\n   compatible with Visual C++ 6.  (Thanks to Wink Saville for the\n   patch.)\n - Some more patches for Linux on HP PA-RISC.\n - Added include/gc_allocator.h.  It implements (hopefully) standard\n   conforming (as opposed to SGI-style) allocators that allocate\n   collectable (gc_allocator) or GC-traceable, but not collectable\n   (traceable_allocator) objects.  This borrows heavily from libstc++,\n   which borrows heavily from the SGI implementation, this part of\n   which was written by Matt Austern.  Changed test_cpp.cc to very\n   minimally test this.\n - On Linux/X86, retry mmap with a different start argument.  That should\n   allow the collector to use more (closer to 3GB) of the address space.\n   (Thanks to Jeffrey Mark Siskind for tracking this down.)\n - Force 64 bit alignment with GCJ support.  (Reflects Bryce McKinley's\n   patch to the gcc tree.)\n - Refined the choice of sa_handler vs. sa_sigaction in GC_dirty_init\n   to accomodate some glibc5 systems.  (Thanks to Dan Fandrich for the\n   patch.)\n - Compensated for the fact that current versions of glibc set\n   __libc_stack_end incorrectly on Linux/IA64 while initialization code\n   is running.  This could cause the collector to miss 16 bytes of\n   the memory stack if GC_malloc or friends where called before main().\n - Mostly integrated Takis Psarogiannakopoulos' port to DG/UX Inix 86.\n   This will probably take another iteration to work, since his\n   patch conflicted with the libtool upgrade. \n - Added README.arm.cross containing some information about cross-\n   compiling to an ARM processor from Margaret Fleck.\n\nSince 6.1alpha4:\n - Added GC_finalizer_mem_freed, and changed some of the code that\n   decided on heap expansion to look at it.  Memory explicitly\n   deallocated by finalizers essentially needs to be counted as reclaimed\n   by the GC.  Otherwise there are cases in which the heap can grow\n   unboundedly.  (Thanks to Mark Reichert for the test case.)\n - Integrated Adam Megacz patches to not scan dynamic libraries if\n   we are compiling with gcc on win32.  Otherwise we need structured\n   exception handling to deal with asynchronously unmapped root\n   segments, and gcc doesn't directly support that.\n - Integrated Anthony Green's patch to support Wine.\n - GC_OPERATOR_NEW_ARRAY was misspelled OPERATOR_NEW_ARRAY in several\n   places, including gc_cpp.cc.  (Thanks to Wink Saville for pointing\n   this out.)\n - Integrated Loren James Rittle's Alpha FreeBSD patches.  In\n   response to Richard Henderson's suggestion, these also\n   changed the declarations of symbols like _end on many platforms to\n   that they wouldn't mistakenly be declared as short data symbols.\n - Integrated changes from the Debian distribution.  (Thanks to Ryan Murray\n   for pointing these out.)  Fix C++ comments in POWERPC port.  Add ARM32\n   incremental GC support.  Get rid of USE_GENERIC_PUSH_REGS for alpha/Linux,\n   this time for real.  Use va_copy to get rid of cord printf problems\n   (finally).\n - Close file descriptor used to count cpus.  Thanks to Jeff Sturm for\n   pointing out the omission.\n - Don't just drop gcj free lists in GC_start_reclaim, since that can\n   eventually cause the marker to see a bogus mark descriptor in the \n   dropped objects.  The usual symptom was a very intermittent segmentation\n   fault in the marker.  This mattered only if one of the GC_gcj_malloc\n   variants was used.  (Thanks to Michael Smith, Jeff Sturm, Bryce\n   McKinley and Tom Tromey for helping to track this down.)\n - Fixed Linux and Solaris/64 SPARC configuration.  (Thanks to David Miller,\n   Jeff Sturm, Tom Tromey, and Christian Joensson.)\n - Fixed a typo in strdup definition.  (Thanks to Gerard A Allan.)\n - Changed Makefile.direct to invoke $(CC) to assemble alpha_mach_dep.S.\n   This is needed on Linux.  I'm not sure whether it's better or worse\n   on Tru64.\n - Changed gc_cpp.h once more to declare operator new and friends only in\n   a Microsoft environment.  This may need further fine tuning.  (Thanks to\n   Johannes Schmidt for pointing out that the older code breaks on gcc3.0.4.)\n - Don't ever override strdup if it's already macro defined.  (Thanks to\n   Adnan Ali for pointing out the problem.)\n - Changed gc_cpp.h yet again to also overload placement new.  Due to the\n   C++ overloading rules, the other overloaded new operations otherwise hide\n   placement new, which causes many STL uses to break.  (Thanks to Reza\n   Shahidi for reporting this, and to Matt Austern for proposing a fix.)\n - Integrated cygwin pthreads support from Dan Bonachea.\n - Turn on DYNAMIC_LOADING for NetBSD.  (Thanks to Krister Walfridsson.)\n - Changed printing code to print more complete GC times.\n - Applied Mark Mitchell's Irix patch to correct some bitrot.\n - Clarified which object-printing routines in dbg_mlc.c should hold\n   the allocation lock.  Restructured the code to allow reasonable object\n   printing with -DREDIRECT_MALLOC.\n - Fix the Linux mmap code to always start with 0x1000 as the initial hint.\n   Minor patches for 64-bit AIX, particularly to STACKBOTTOM.\n   (Thanks again to Jeffrey Mark Siskind.)\n - Renamed \"SUSPENDED\" flag for Solaris threads support to avoid a conflict\n   with a system header. (Thanks to Philp Brown.)\n - Cause win32_threads.c to handle an out of range stack pointer correctly,\n   though currently with a warning.  (Thanks to Jonathan Clark for\n   observing that win32 applications may temporarily use the stack\n   pointer for other purposes, and suggesting a fix.  Unfortunately, it's\n   not clear that there is a complete solution to this problem.)\n\nSince 6.1alpha5:\n - Added GC_MAXIMUM_HEAP_SIZE environment variable.\n - Fix configure.ac for MIPS/LINUX. (Thanks to H.J. Lu.)\n - Double page hash table size for -DLARGE_CONFIG.\n - Integrated Bo Thorsen's X86-64 support.\n - STACKBOTTOM definition for LINUX/MIPS was partially changed back.\n   (Thanks to H.J. Lu and Hiroshi Kawashima for resolving this.)\n - Replaced all occurrences of LINUX_DATA_START in gcconfig.h with\n   SEARCH_FOR_DATA_START.  It doesn't hurt to falll back to a search.\n   And __data_start doesn't seem to get defined correctly of the GC\n   library is loaded with LD_PRELOAD, e.g. for leak detection.\n - If the GC_find_leak environment variable is set, do a\n   atexit(GC_gcollect) to give us at least one chance to detect leaks.\n   This may report some very benign leaks, but ...\n - Addeded REDIRECT_FREE.  It's necessary if we want leak detection with\n   LD_PRELOAD.\n - Defer printing of leaked objects, as for smashed objects.\n - Fixed process and descriptor leak in GC_print_callers.  Try for\n   line number even if we got function name.)\n - Ported parallel GC support and thread local allocation to Alpha.\n   Not yet well-tested.\n - Added GC_DUMP_REGULARLY and added finalization statistics to GC_dump().\n - Fixed Makefile.am to mention alpha_mach_dep.S instead of the defunct\n   alpha_mach_dep.s.  (Thanks to Fergus Henderson.)\n - Incorporated a change to new_gc_alloc.h, suggested by Johannes Schmidt,\n   which should make it work with gcc3.1.  (I would still like to encourage\n   use of gc_allocator.h instead.) \n - Use alpha_mach_dep.S only on Linux.  (It's not clear that this is\n   optimal, but it otherwise didn't build on Tru64.  Thanks to Fergus\n   Henderson.)\n - Added ifdef to guard free() in os_dep.c.  Otherwise we get a\n   compilation error on Irix.  (Thanks to Dai Sato.)\n - Added an experimental version of GC_memalign to mallocx.c.  This can't\n   always work, since we don't handle alignment requests in the hblk-level\n   allocator, and we can't handle arbitrary pointer displacements unless\n   GC_all_interior_pointers is enabled.  But it should work for alignment\n   requests up to HBLKSIZE.  This is not yet documented in the standard\n   places.\n - Finally debugged the OSF1/Tru64 thread support.  This needs more testing,\n   since I needed to add a somewhat unconvincing workaround for signal\n   delivery issues that I don't yet completely understand.  But it does\n   pass my tests, even in parallel GC mode.  Incremental GC support is\n   disabled if thread support is enabled, due to the signal issues.\n - Eliminated name-space-incorrect definition of _cdecl from gc_cpp.h.\n - Added GC_debug_malloc_replacement and GC_debug_realloc_replacement\n   declarations to gc.h.  On IA64, this is required for REDIRECT_MALLOC\n   to work correctly with these.\n - Fixed Linux USE_PROC_FOR_LIBRARIES to work with a 64-bit /proc format.\n\nSince 6.1:\n - Guard the test for GC_DUMP_REGULARLY in misc.c with\n   \"#ifndef NO_DEBUGGING\".  Otherwise it fails to build with NO_DEBUGGING\n   defined.  (Thanks to Manuel Serrano.)\n - Message about retrying suspend signals was incorrectly generated even when\n   flag was not set.\n - Cleaned up MACOSX/NEXT root registration code.  There was apparently a\n   separate ifdef case in GC_register_data_segments() for no reason.\n - Removed MPROTECT_VDB for MACOSX port, based on one negative report.\n - Arrange for gc.h and friends to be correctly installed with GNU-style\n   \"make install\".\n - Enable the GNU-style build facility include C++ support in the library\n   with --enable-cplusplus. (Thanks to Thomas Maier for some of the patch.)\n - Mark from GC_thread_key in linux_threads.c, in case that's allocated\n   from the garbage collected heap, as it is with our own thread-specific\n   storage implementation.  (Thanks to Jeff Sturm.)\n - Mark all free list header blocks if they are heap allocated.  This avoids\n   some unnecessary tracing.  And it remains correct if we clear the\n   root set. (Thanks to Jeff Sturm for identifying the bug.)\n - Improved S390/Linux support.  Add S390/Linux 64-bit support.  (Thanks\n   to Ulrich Weigand.)\n - Corrected the spelling of GC_{M,C}ALLOC_EXPLICTLY_TYPED to\n   GC_{M,C}ALLOC_EXPLICITLY_TYPED in gc_typed.h.  This is technically\n   an interface change.  Based on the fact that nobody reported this,\n   I suspect/hope there were no clients.\n - Cleaned up gc_typed.h so that (1) it adds an extern \"C\" declaration\n   when appropriate, (2) doesn't generate references to undefined internal\n   macros, and (3) allows easier manual construction of descriptors.\n - Close the file descriptor used by GC_print_address_map().\n - Set the \"close-on-exec\" bit for various file descriptors maintained\n   for the collector's internal use.\n - Added a hack to find memory segments owned by the system allocator\n   under win32.  Based on my tests, this tends to eventually find all\n   segments, though it may take a while.  There appear to be cleaner,\n   but slower solutions under NT/XP.  But they rely on an API that's\n   unsupported under 9X.\n - Changed Linux PowerPC stack finding to LINUX_STACKBOTTOM.  (Thanks\n   to Akira Tagoh for pointing out that HEURISTIC1 doesn't work on\n   64-bit kernels.)\n - Added GC_set_free_space_divisor to avoid some Windows dll issues.\n - Added FIXUP_POINTER, POINTER_SHIFT, POINTER_MASK to allow preprocessing\n   of candidate pointers for tagging, etc.\n - Always lock around GC_notify_full_gc().  Simplified code for\n   invoking GC_notify_full_gc().\n - Changed the way DATASTART is defined on FreeBSD to be robust against\n   an unmapped page after etext.  (Thanks to Hironori Sakamoto for\n   tracking down the intermittent failure.)\n - Made GC_enable() and GC_disable() official.  Deprecated direct update\n   of GC_dont_gc.  Changed GC_gcollect to be a noop when garbage collection\n   is disabled.\n - Call GC_register_dynamic_libraries before stopping the world on Linux,\n   in order to avoid a potential deadlock due to the dl_iterate_phdr lock.\n - Introduced a more general mechanism for platform-dependent code to\n   decide whether the main data segment should be handled separately\n   from dynamic libraries, or registered by GC_register_dynamic_libraries.\n   The latter is more reliable and easier on Linux with dl_iterate_phdr. \n\nSince 6.2alpha1:\n - Fixed the completely broken FreeBSD code in 6.2alpha1.  (Thanks to\n   Hironori Sakamoto for the patch.)\n - Changed IRIX reference in dbg_mlc.c to IRIX5. (Thanks to Marcus Herbert.)\n - Attempted to work around the problems with .S filenames and the SGI\n   compiler.  (Reported by several people. Untested.)\n - Worked around an HP/UX make issue with the GNU-style build process.\n - Fixed the --enable-cplusplus build machinery to allow builds without\n   a C++ compiler.  (That was always the intent ...)\n - Changed the debugging allocation macros to explicitly pass the return\n   address for Linux and XXXBSD on hardware for which we can't get stack\n   traces.  Use __builtin_return_address(0) to generate it when possible.\n   Some of the configuration work was cleaned up (good) and moved to gc.h\n   (bad, but necessary).  This should make leak detection more useful\n   on a number of platforms.  (Thanks to Fabian Thylman for the suggestion.)\n - Fixed compilation problems in dbg_mlc.c with GC_ADD_CALLER.\n - Bumped revision number for dynamic library.\n\nSince 6.2alpha2:\n - Don't include execinfo.h in os_dep.c when it's not needed, and may not exist.\n\nSince 6.2alpha3:\n - Use LINUX_STACKBOTTOM for >= glibc2.2 on Linux/MIPS.  (See Debian bug\n   # 177204)\n - Integrated Jeff Sturm and Jesse Rosenstock's MACOSX threads patches.\n - Integrated Grzegorz Jakacki's substantial GNU build patch.  \"Make dist\"\n   should now work for the GNU build process.  Documentation files\n   are installed under share/gc.\n - Tweaked gc_cpp.h to again support the Borland compiler.  (Thanks to\n   Rene Girard for pointing out the problems.)\n - Updated BCC_MAKEFILE (thanks to Rene Girard).\n - Added GC_ASSERT check for minimum thread stack size.\n - Added --enable-gc-assertions.\n - Added some web documentation to the distribution.  Updated it in the\n   process.\n - Separate gc_conf_macros.h from gc.h.\n - Added generic GC_THREADS client-defined macro to set the appropriate\n   GC_XXX_THREADS internal macro.  (gc_config_macros.h.)\n - Add debugging versions of _ignore_off_page allocation primitves.\n - Moved declarations of GC_make_closure and GC_debug_invoke_finalizer\n   from gc.h to gc_priv.h.\n - Reset GC_fail_count even if only a small allocation succeeds.\n - Integrated Brian Alliet's patch for dynamic library support on Darwin.\n - gc_cpp.h's gc_cleanup destructor called GC_REGISTER_FINALIZER_IGNORE_SELF\n   when it should have called the lower case version, since it was\n   explicitly computing a base pointer.\n\nSince 6.2alpha4:\n - GC_invoke_finalizers could, under rare conditions, set\n   GC_finalizer_mem_freed to an essentially random value.  This could\n   possibly cause unbounded heap growth for long-running applications\n   under some conditions.  (The bug was introduced in 6.1alpha5, and\n   is not in gcc3.3.  Thanks to Ben Hutchings for finding it.)\n - Attempted to sanitize the various DLL macros.  GC_USE_DLL disappeared.\n   GC_DLL is used instead.  All internal tests are now on GC_DLL.\n   README.macros is now more precise about the intended meaning.\n - Include DllMain in the multithreaded win32 version only if the\n   collector is actually built as a dll.  (Thanks to Mohan Embar for\n   a version of the patch.)\n - Hide the cygwin threadAttach/Detach functions.  They were violating our\n   namespace rules.  \n - Fixed an assertion in GC_check_heap_proc.  Added GC_STATIC_ASSERT.\n   (Thanks again to Ben Hutchings.)\n - Removed some obsolete definitions for Linux/PowerPC in gcconfig.h.\n - CORD_cat was not rebalancing unbalanced trees in some cases, violating\n   a CORD invariant.  Also tweaked the rebalancing rule for\n   CORD_cat_char_star.  (Thanks to Alexandr Petrosian for the bug report\n   and patch.)\n - Added hand-coded structured exception handling support to mark.c.\n   This should enable support of dynamic libraries under win32 with\n   gcc-compiled code.  (Thanks to Ranjit Mathew for the patch.)\n   Turned on dynamic library scanning for win32/gcc.\n - Removed some remnants of read wrapping.  (Thanks to Kenneth Schalk.)\n   GC_USE_LD_WRAP ws probably broken in recent versions.\n - The build could fail on some platforms since gcconfig.h could include\n   declarations mentioning ptr_t, which was not defined, e.g. when if_mach\n   was built.  (Thanks to Yann Dirson for pointing this out.)  Also\n   cleaned up tests for GC_PRIVATE_H in gcconfig.h a bit. \n - The GC_LOOP_ON_ABORT environment variable interfered with incremental\n   collection, since the write fault handler was erroneously overridden.\n   Handlers are now set up in the correct order.\n - It used to be possible to call GC_mark_thread_local_free_lists() while\n   the world was not stopped during an incremental GC.  This was not safe.\n   Fortunately, it was also unnecessary.  Added GC_world_stopped flag\n   to avoid it.  (This caused occasional crashes in GC_set_fl_marks\n   with thread local allocation and incremental GC.  This probably happened\n   primarily on old, slow multiprocessors.)\n - Allowed overriding of MAX_THREADS in win32_threads.c from the build\n   command line.  (Patch from Yannis Bres.)\n - Taught the IA64/linux code to determine the register backing store base from\n   /proc/self/maps after checking the __libc symbol, but before guessing.\n   (__libc symbols are on the endangered list, and the guess is likely to not\n   always be right for 2.6 kernels.)  Restructured the code to read and parse\n   /proc/self/maps so it only exists in one place (all platforms).\n - The -DUSE_PROC_FOR_LIBRARIES code was broken on Linux.  It claimed that it\n   also registered the main data segment, but didn't actually do so.  (I don't\n   think anyone actually uses this configuration, but ...)\n - Made another attempt to get --enablecplusplus to do the right thing.\n   Since there are unavoidable problems with C programs linking against a\n   dynamic library that includes C++ code, I separated out the c++ code into\n   libgccpp.\n\nSince 6.2alpha5:\n - There was an extra underscore in the name of GC_save_registers_in_stack\n   for NetBSD/SPARC.  (Thanks to Jaap Boender for the patch.)\n - Integrated Brian Alliet's patch for Darwin.  This restructured the\n   linuxthreads/pthreads support to separate generic pthreads support\n   from more the system-dependent thread-stopping code.  I believe this\n   should make it easier to eliminate the code duplication between\n   pthreads platforms in the future.  The patch included some other\n   code cleanups.\n - Integrated Dan Bonachea's patch to support AIX threads.  This required\n   substantial manual integration, mostly due to conflicts with other\n   recent threads changes.  It may take another iteration to\n   get it to work.\n - Removed HPUX/PA-RISC support from aix_irix_threads.c.  It wasn't used\n   anyway and it cluttered up the code.  And anything we can do to migrate\n   towards generic pthreads support is a good thing.\n - Added a more explicit test for tracing of function arguments to test.c.\n   (Thanks to Dan Grayson.)\n - Added Akira Tagoh's PowerPC64 patch.\n - Fixed some bit rot in the Cygwin port.  (Thanks to Dan Bonachea for\n   pointing it out.)  Gc.h now includes just windows.h, not winbase.h.\n - Declared GC_save_regs_in_stack() in gc_priv.h.  Remove other declarations.\n - Changed --enable-cplusplus to use automake consitionals.  The old way\n   confused libtool.  \"Make install\" didn't work correctly for the old version.\n   Previously --enable-cplusplus was broken on cygwin.\n - Changed the C version of GC_push_regs to fail at compile time if it is\n   generated with an empty body.  This seems to have been the cause of one\n   or two subtle failures on unusual platforms.  Those failures should\n   now occur at build time and be easily fixable.\n\nSince 6.2alpha6:\n - Integrated a second round of Irix/AIX patches from Dan Bonachea.\n   Renamed mips_sgi_mach_dep.S back to mips_sgi_mach_dep.s, since it requires\n   the Irix assembler to do the C preprocessing; gcc -E doesn't work.\n - Fixed Makefile.direct for DARWIN.  (Thanks to Manuel Serrano.)\n - There was a race between GC_pthread_detach and thread exit that could\n   result in a thread structure being deallocated by GC_pthread_detach\n   even though it was still needed by the thread exit code.  (Thanks to\n   Dick Porter for the small test case that allowed this to be debugged.)\n - Fixed version parsing for non-alpha versions in acinclude.m4 and\n   version checking in version.h.\n\nSince 6.2:\n - Integrated some NetBSD patches forwarded to me by Marc Recht.  These\n   were already in the NetBSD package.    \n - GC_pthread_create waited for the semaphore even if pthread_create failed.\n   Thanks to Dick Porter for the pthread_support.c patch.  Applied the\n   analogous fix for aix_irix_threads.c.\n - Added Rainer Orth's Tru64 fixes.\n - The check for exceeding the thread table size in win32 threadDetach\n   was incorrect.  (Thanks to Alexandr Petrosian for the patch.)\n - Applied Andrew Begel's patch to correct some reentrancy issues\n   with dynamic loading on Darwin.\n - GC_CreateThread() was neglecting to duplicate the thread handle in\n   the table.  (Thanks to Tum Nguyen for the patch.)\n - Pass +ESdbgasm only on PA-RISC machines with vendor compiler.\n   (Thanks to Roger Sayle for the patch.)\n - Applied more AIX threads patches from Scott Ananian.\n\nSince 6.3alpha1:\n - Reenabled I_HOLD_LOCK assertion in aix_irix_threads.h.\n - Put back the WINABI qualifier for GC_CreateThread.  (Thanks to\n   Danny Smith for the patch.  6.3alpha1 had the qualifier in one place\n   but not elsewhere, which was clearly wrong.)\n - Sometimes explicitly define __private_extern__ before DARWIN dyld.h\n   include.  (Thanks to Andreas Tobker for postting the patch.)\n - Included signal.h from pthread_support.c.  Removed GC_looping_handler,\n   which was dead code.\n - GC_find_start was misdeclared by gc_pmark.h if PRINT_BLACK_LIST was\n   defined.  (Thanks to Glauco Masotti for testing and reporting this.)\n   Changed GC_find_start to never just return 0.  According to its\n   comment it doesn't, and it's unclear that's correct.\n - GC_alloc_large had several largely compensating bugs in the\n   computation of GC_words_wasted.  (It was confused about bytes vs.\n   words in two places.)\n - Integrated Slava Sysoltev's patch to support more recent versions of\n   the Intel compiler on IA64/Linux.\n - Changed win32 spinlock initialization to conditionally set a spin count.\n   (Emmanual Stumpf pointed out that enabling this makes a large performance\n   difference on win32 multiprocessors.)  Also cleaned up the win32 spinlock\n   initialization code a bit.\n - Fixed thread support for HP/UX/IA64.  The register backing store base for\n   the main thread was sometimes not set correctly.  (Thanks to Laurent\n   Morichetti.)\n - Added -DEMPTY_GETENV_RESULTS flag to work around Wine problem.\n - Declare GC_stack_alloc and GC_stack_free in solaris_threads.h to\n   avoid 64-bit size mismatches.  (Thanks to Bernie Solomon.)\n - Fixed GC_generic_push_regs to avoid a potential and very unfortunate\n   tail call optimization.  This could lead to prematurely reclaimed\n   objects on configurations that used the generic routine and the new\n   build infrastructure (which potentially optimizes mach_dep.c).\n   This was a serious bug, but it's unclear whether it has resulted in\n   any real failures.\n - Fixed CORD_str to deal with signed characters.  (Thanks to Alexandr\n   Petrosian for noticing the problem and supplying the patch.)\n - Merged a couple of NOSYS/ECOS tests into os_dep.c from gcj.  (Thanks\n   to Anthony Green.)\n - Partially merged a win32 patch from Ben Hutchings, and substantially\n   revised other parts of win32_threads.c.  It had several problems.\n   Under MinGW with a statically linked library, the main thread was\n   not registered.  Cygwin detached threads leaked thread descriptors.\n   There were several race conditions.  For now, unfortunately the\n   static threads limit remains, though we increased it, and made table\n   traversal cost depend on the actual thread count.\n   There is also still some code duplication with pthread_support.c.\n   (Thread descriptors did become much smaller, since Ben Hutchings\n   removed the thread context from them.)\n - Integrated a Solaris configure.ac patch from Rainer Orth.\n - Added GC_IGNORE_FB and associated warning to very partially address\n   the issue of the collector treating a mapped frame buffer as part\n   of the root set.  (Thanks to David Peroutka for providing some\n   insight.  More would be helpful.  Is there anything that can be used\n   to at least partially identify such memory segments?)\n   \nSince 6.3alpha2:\n - Removed -DSMALL_CONFIG from BCC_MAKEFILE.\n - Changed macros to test for an ARM processor (Patch from Richard Earnshaw.)\n - Mostly applied a DJGPP patch from Doug Kaufman.  Especially Makefile.dj\n   had suffered from serious bit rot.\n - Rewrote GC_apply_to_maps, eliminating an off-by-one subscript error,\n   and a call to alloca (for lcc compatibility).\n - Changed USE_MUNMAP behavior on posixy platforms to immediately remap\n   the memory with PROT_NONE instead of unmapping it.  The latter risks\n   an intervening mmap grabbing the address space out from underneath us.\n   Updated this code to reflect a cleaner patch from Ulrich Drepper.\n - Replaced _T with _Tp in new_gc_alloc.h to avoid a MACOS X conflict.\n   (Patch from Andrew Begel.)\n - Dynamically choose whether or not lock should spin on win32.  (Thanks\n   to Maurizio Vairani for the patch.)  This may be a significant performance\n   improvement for win32.\n - Fix Makefile.direct to actually include NT_STATIC_THREADS_MAKEFILE\n   in the distribution.  (Again thanks to Maurizio Vairani.)\n - Maybe_install_looping_handler() was accidentally exported, violating\n   our name space convention.\n - Made os_dep.c use sigsetjmp and SA_NODEFER for NetBSD.  (Thanks to\n   Christian Limpach.)  (I generalized the patch to use sigsetjmp on all\n   UNIX_LIKE platforms, admittedly a slightly risky move.  But it may avoid\n   similar problems on some other platforms. I also cleaned up the defn\n   of UNIX_LIKE a bit. - Hans)\n - Integrated Andrew Begel's Darwin threads patch, adjusted according to\n   some of Fergus Hendersons's comments.  (Patch didn't apply cleanly,\n   errors are possible.)\n - Added another test or two for the Intel 8.0 compiler to avoid\n   confusing it with gcc.  The single-threaded collector should now build\n   with icc, at least on ia64. \n\nSince 6.3alpha3:\n - USE_MMAP was broken by confusion in the code dealing with USE_MMAP_ANON.\n   (This was pointed out, and fixes were suggested by several other people.)\n - Darwin supprt was broken in alpha3 as a result of my misintegration of\n   Andrew Begel's patches.  Fixed with another patch from Andrew Begel.\n - A new sanity check in pthread_stop_world.c:GC_push_all_stacks() was\n   overly aggressive.  We may collect from an unregistered thread during\n   thread creation.  Fixed by explicitly checking for that case.  (Added\n   GC_in_thread_creation.)\n\nSince 6.3alpha4:\n - Fix & vs && typo in GC_generic_malloc and\n   GC_generic_malloc_ignore_off_page.  (Propagated from the gcc tree.)\n - Removed SA_NODEFER hack from NetBSD and Solaris write-protect handler.\n   (According to Christian Limpach, the NetBSD problem is fixed.\n   Presumably so is the Solaris 2.3 problem.)\n - Removed placement delete from gc_cpp.h for the SGI compiler.\n   (Thanks to Simon Gornall for the patch.)\n - Changed semantics of the GC_IGNORE_FB environment variable, based \n   on experimentation by Nicolas Cannasse pointing out that the old\n   interpretation was useless.  We still need help in identifying win32\n   graphics memory mappings.  The current \"solution\" is a hack.\n - Removed \"MAKEOVERRIDES =\" from Makefile.am and thus Makefile.in.\n   It probably made more sense in the gcc context.\n - Explicitly ensure that NEED_FIND_LIMIT is defined for {Open,Net}BSD/ELF.\n - Replaced USE_HPUX_TLS macro by USE_COMPILER_TLS, since gcc often\n   supports the same extension on various platforms.\n - Added some basic (completely untested) defines for win64, in support\n   of future work.\n - Declared GC_jmp_buf in os_dep.s as JMP_BUF instead of jmp_buf, fixing\n   a memory overwrite bug on Solaris and perhaps other platforms.\n - Added 0 != __libc_stack_end test to GC_linux_stack_base.  (Thanks to Jakub\n   Jelinek, both for the patch, and for explaining the problem to me.)\n   Otherwise \"prelink\"ing could cause the collector to fail.\n - Changed default thread local storage implementation to USE_PTHREAD_SPECIFIC\n   for HP/UX with gcc.  The compiler-based implementation appears to work\n   only with the vendor compiler.\n - Export GC_debug_header_size and GC_USR_PTR_FROM_BASE from gc_mark.h,\n   making client mark code cleaner and less dependent on GC version.\n - Export several new procedures and GC_generic_malloc from gc_mark.h\n   to support user-defined kinds.  Use the new procedures to replace existing\n   code in gcj_mlc.c and typd_mlc.c.\n - Added support for GC_BACKTRACES.\n - Fixed a remaining problem in CORD_str with signed characters.  (Thanks\n   to Alexandr Petrosian for the patch.)\n - Removed supposedly redundant, but very buggy, definitions of finalizer\n   macros from javaxfc.h.  Fortunately this file probably has no users.\n   The correct declarations were already in gc.h.\n - Also need to set GC_in_thread_creation while waiting for GC during\n   thread termination, since it is also possible to collect from an\n   unregistered thread in that case.\n - Define NO_GETENV for Windows CE, since getenv doesn't appear to exist.\n   + some other minor WinCE fixes. (Thanks to Alain Novak.)\n - Added GC_register_describe_type_fn.\n - Arrange for debugging finalizer registration to ignore non-heap\n   registrations, since the regular version of the routine also behaves\n   that way.\n - GC_gcj_malloc and friends need to check for finalizers waiting to be run.\n   One of the more obscure allocation routines with missing a LOCK() call.\n - Fixed cvtres invocations in NT_MAKEFILE and NT_STATIC_THREADS_MAKEFILE\n   to work with VS.NET.\n - Cleaned up GC_INIT calls in test.  Updated gc.man to encourage GC_INIT\n   use in portable code.\n - Taught the GC to use libunwind if --enable-full-debug is specified on\n   IA64 and libunwind is present.\n - The USE_MUNMAP code could get confused about the age of a block and\n   prematurely unmap it.  GC_unmap_old had a bug related to wrapping of\n   GC_gc_no.  GC_freehblk and GC_merge_unmapped didn't maintain\n   hb_last_reclaimed reasonably when blocks were merged.  The code was\n   fixed to reflect original intent, but that may not always be an\n   improvement.  See todo list item.\n\nSince 6.3alpha5:\n - Define USE_GENERIC_PUSH_REGS for NetBSD/M68K.\n - Fixed the X86_64 PREFETCH macros to correctly handle ia32e (which uses\n   different prefetch instructions from AMD64).  (Thanks to H.J. Lu.)\n - GC_config_macros.h did not correctly define GC_WIN32_THREADS from\n   GC_THREADS. \n - Added simple_example.html.\n - Merged Andrew Gray's patch to correctly restore signal handlers on\n   FreeBSD.\n - Merged a patch from Andreas Jaeger to deal with prefetch-related warnings\n   on x86-64.  Added some other casts so that the PREFETCH macros\n   always get a ptr_t argument.  Removed some casts inthe PREFETCH\n   implementations.\n - At Jesse Jones suggestion: Added a header guard for gc_allocator.h\n   and changed GC_debug_free to clobber contents of deallocated object.\n - The signal masking code in pthread_stop_world.c contained some errors.\n   In particular SIGSEGV was masked in the handler, in spite of the fact that\n   it wrote to the heap.  This could lead to an uncaught SIGSEGV, which\n   apparently became much more likely in Linux 2.6.  Also fixed some\n   typos, and reduced code duplication in the same area.\n - Remove ltconfig, clean up configure messages for DGUX (thanks to\n   Adrian Bunk for the patches).\n - Integrated NetBSD/OpenBSD patches from Marc Recht and Matthias Drochner.\n\nSince gc6.3alpha6:\n - Compile test_cpp.cc with CXXCOMPILE instead of COMPILE.\n - Very large allocations could cause a collector hang.  Correct\n   calculation of GC_collect_at_heapsize.\n - GC_print_hblkfreelist printed some bogus results if USE_MUNMAP\n   was defined.\n - The generic GC_THREADS macro didn't work correctly on Solaris,\n   since the implementation failed to include gc_config_macros.h\n   before deciding whether or not to compile the rest of the file.\n - Threadlibs.c failed to expand the generic GC_THREADS macro.\n - Correct MacOSX thread stop code. (Thanks to Dick Porter.)\n - SMALL_OBJ definition was off by one.  This could cause crashes\n   at startup.  (Thanks to Zoltan Varga for narrowing this down to\n   a trivial test case.)\n - Integrate Paolo Molara's patch to deal with a race in the Darwin\n   thread stopping code.\n - Changed X86_64 implementation to use SA_SIGINFO in the MPROTECT_VDB\n   implementation.  The old approach appears to have been broken by\n   recent kernels.\n - Add GC_ATTR_UNUSED to eliminate a warning in gc_allocator.h.  (Thanks\n   to Andrew Begel.)\n - Fix GC_task_self declaration in os_dep.c.  (Thanks to Andrew Pinski.)\n - Increase INITIAL_BUF_SZ in os_dep.c for Solaris /proc reads.\n\nSince 6.3:\n - Merge gcconfig.h changes from gcc tree.\n - Unconditionally include gc_priv.h in solaris_pthreads.c, win32_threads.h,\n   aix_irix_threads.c, and solaris_threads.c to get thread definitions.\n - Start marker threads in GC_thr_init, so that they get started even\n   if no other threads are ever started.  (Oddly enough, the parallel\n   collector worked correctly, though not well, with no helper threads.)\n - Go ahead and split large blocks in GC_allochblk_nth if GC_dont_gc\n   is set.  (Thanks to Alexander Petrossian.)\n - GC_PRINT_BACK_HEIGHT would deadlock with thread support.\n - Let in_progress_space in backgraph.s grow dynamically.\n - Fix README.solaris2.  The GC_thr_init() hack doesn't work anymore.\n - Convert GC_finalizer_mem_freed to bytes in allchblk.c.\n - Add missing declaration for GC_generic_malloc_words_small_inner.\n   Without it, s390x breaks.  (Thanks to Ulrich Weigand.)\n - Applied several MacOSX patches to support older tool chains.\n   (Thanks to Stefan Ring.)\n - Bug fix for NetBSD/amd64.  (Thanks to Marc Recht.)  Add NetBSD/sh3\n   support.  (Thanks to Uchiyama Yasushi.)\n - Fixed an uninitialized variable in cordprnt.c.  (Thanks to gcc for\n   providing the warning.)\n - Eliminated some, but not all, gcc -Wall warnings.\n - Changed some old style casts to reinterpret_cast in new_gc_alloc.h.\n   (Thanks to Dan Grayson.)\n - GC_extend_size_map shouldn't adjust for GC_all_interior_pointers if\n   GC_DONT_ADD_BYTE_AT_END is set.\n - Changed some (long) casts to (word) in preparation for win64.\n   (Thanks to Peter Colson.)\n - Changed \"int stack_size\" declaration in pthread_support.c to use\n   size_t.  (Only mattered with GC_ASSERTIONS enabled.)\n - Added CRIS (etrax) support.  (Thanks to Simon Posnjak and\n   Hans-Peter Nilsson.)\n - Removed GC_IGNORE_FB frame buffer recognition, and replaced\n   it with a check that the mapping type is MEM_IMAGE.\n   In theory, this should work much better, but it is a high\n   risk change for win32.  (Thanks to Ashley Bone for the crucial\n   experimental data behind this, and to Rutger Ovidus for\n   some further experiments.)\n - Fixed print_block_list to print the correct kind number for\n   STUBBORN.  (Thanks to Rutger Ovidus.)\n - GC_allochblk_nth incremented GC_words_wasted by bytes rather than\n   words.\n - Consider GC_words_wasted in GC_adj_words_allocd only if it is within\n   reason.  (A hack to avoid some extremely unlikely scenarios in which\n   we manage to allocate only \"wasted\" space.  7.0 has a better fix.)\n - Changed PowerPC GC_clear implementation to use lwsync instead of\n   eieio, since the documentation recommends against eieio, and\n   it seems to be incorrect if the preceding memory op is a load.\n - Fixed print_block_list to print the correct kind number for\n   STUBBORN.  (Thanks to Rutger Ovidus.)\n - Have configure.ac generate an error if it is asked to support\n   pthreads, but doesn't know how to.\n - Added Kazuhiro Inaoka's patch for Renesas M32R support.\n - Have the GNU build mechanism link with -ldl.  Rename THREADLIBS\n   to THREADDLLIBS to reflect this.  (Thanks to Sven Verdoolaege.)\n - Added Hannes Mehnert's patch for FreeBSD/SPARC support.\n - Merged some FreeBSD specific patches to threadlibs.c and dyn_load.c.\n   (Thanks tp John Merryweather Cooper.)\n - Define MPROTECT_VDB on MACOSX only if threads are being used, since the\n   dirty page tracking mechanism uses threads.  (This avoids an undefined\n   reference to _GC_darwin_register_mach_handler_thread.)\n - By popular demand, use __libc symbols only if we are built with\n   USE_LIBC_PRIVATES, which is off by default, and not otherwise documented.\n - Ignore GC_enable_incremental() requests when KEEP_BACK_PTRS is set.\n   The GC itself will dirty lots of pages in this cases, probably making\n   it counterproductive on all platforms.  And the DARWIN port crashes.\n\nSince GC6.4:\n - Integrated Paolo Molaro's patch to deal with EINTR in sem_wait.\n - Make GC_approx_sp() write to dummy location to ensure that stack\n   is grown here, when sp looks reasonable, rather than later, when\n   it might look like a bad memory reference.  (Problem was never\n   observed that I know of.  But on rereading the code it seemed\n   dubious.)\n - Separate out GC_with_callee_saves_pushed and sometimes call\n   it from GC_suspend_handler in pthread_stop_world.c.  Callee-save\n   register values sometimes failed to get traced under HP/UX on\n   PA-RISC.  Linux/IA64 had the same problem, though non-stacked\n   callee-save registers seem to be so rarely used there that nobody\n   ever noticed.\n - Integrated an ancient Darwin powerpc_darwin_machine_dep.s patch\n   from Andreas Tobler, which I had lost.\n - Fix compare_and_exchange implementation for gcc/IA64 to deal with\n   pickier compiler versions.\n - Fixed Itanium 32-bit ABI support (HP/UX).  In particular, the\n   compare_and_exchange implementation didn't consider that possibility.\n - Undefine GC_pthread_detach in win32_threads.c.  (Thanks to\n   Tagliapietra Tommaso.)\n - Fixed inclusion of frame.h for NETBSD in os_dep.c.\n - Applied Dan Bonachea's patch to use mmap on AIX.\n - Several fixes to resurrect the Irix port on recent OS versions.\n - Change ALPHA to use LINUX_STACKBOTTOM.\n - Change SPARC64/LINUX to also use LINUX_STACKBOTTOM.  Deal with potential\n   bad values of __libc_stack_end on that platform.  (Thanks to David Miller.)\n - Relax gctest to allow larger heap if ALIGN_DOUBLE isn't set.\n   (Unnecessary in 7.0)\n - Force a define of __STDC__=0 for the IBM compiler on AIX, so that\n   we get prototypes.  (Unnecessary in 7.0)\n - GC_INIT definition for AIX and CYGWIN referred to DATASTART and DATAEND\n   which are only defined in private include files.\n - Integrated some small gcconfig.h patches from Dan Bonachea.  Also\n   relaxed assertion about FreeBSD stack size in pthread_support.c.\n - Integrated Andrew Begel's darwin_stop_world.c patch for 64-bit\n   support.  This may need additional work.\n - Avoided potentially infinite recursion in GC_save_callers if\n   the system backtrace calls malloc.  The workaround currently requires\n   __thread support if this code is used with threads.\n - Avoided another similar infinite recursion by conditionally\n   invoking GC_save_callers in alloc.c.  (Thanks to Matthias Andree\n   for helping to track down both of these.)\n - Removed all traces of aix_irix_threads.c.  AIX and Irix now use\n   pthread_support.c and pthread_stop_world.c.  The old code appeared\n   to be unreliable for AIX, and was not regularly maintained.\n - On Irix, ignore segments with MA_FETCHOP or MA_NOTCACHED attributed;\n   they're not always safe to read.\n - Fixed a previously vacuous assertion (diagnosed by the SGI compiler)\n   in GC_remove_from_fl.\n - Fix stack_size assertion in GC_pthread_create.\n - Fix assertion in GC_steal_mark_stack.\n  \nSince 6.5\n - Fix CPU count detection for Irix and FreeBSD. (Thanks to Dan Bonachea.)\n - Integrate Dan Bonachea's patch for the IBM XLC compiler on Darwin.\n - Integrated Andreas Tobler's FreeBSD/PowerPC patch.\n - Don't access the GC thread structure from the restart handler.  It's\n   unsafe, since the handler may run too late.  (Thanks to Ben Maurer for\n   tracking this down.)\n - Applied Christian Thalinger's patch to change comment syntax in\n   alpha_mach_dep.S.\n - Added test for GC_no_dls in GC_dyld_image_add for DARWIN. (Thanks to\n   Juan Jose Garcia Ripoli).\n - Use LINUX_STACKBOTTOM for Linux/SH and LINUX/ARM. (Thanks to Sugioka\n   Toshinobu and Christian Thalinger.)\n - Rewrote GC_parse_map_entry.  This assumed a fixed column layout of\n   /proc/self/maps on Linux.  This ceased to be true about 2 years ago.\n   The old code is probably quite problemetic with -DREDIRECT_MALLOC.  It\n   is also used by default for IA64, though I haven't seen actual failures\n   there.\n - More consistently define HBLKSIZE to 4096 on 64 bit architectures with\n   4K pages.  (Thanks to Andrew Haley.)\n - With win32 threads, GC_stop_world needs to acquire GC_write_cs.  (Thanks\n   to Ben Hutchings for the observation and patch.)\n - Move up struct callinfo declaration to make gcc 4.0.2. happy.\n\nTo do:\n - The USE_MUNMAP code should really use a separate data structure\n   indexed by physical page to keep track of time since last use of\n   a page.  Using hblk headers means we lose track of ages when\n   blocks are merged, and we can't unmap pages that have been allocated and\n   dropped by the blacklisting code.  I suspect both of these matter.\n - A dynamic libgc.so references dlopen unconditionally, but doesn't link\n   against libdl.\n - GC_proc_fd for Solaris is not correctly updated in response to a\n   fork() call.  Thus incremental collection in the child won't work\n   correctly.  (Thanks to Ben Cottrell for pointing this out.)\n - --enable-redirect-malloc is mostly untested and known not to work\n   on some platforms. \n - There seem to be outstanding issues on Solaris/X86, possibly with\n   finding the data segment starting address.  Information/patches would\n   be appreciated.\n - Very large root set sizes (> 16 MB or so) could cause the collector\n   to abort with an unexpected mark stack overflow.  (Thanks again to\n   Peter Chubb.)  NOT YET FIXED.  Workaround is to increase the initial\n   size.\n - The SGI version of the collector marks from mmapped pages, even\n   if they are not part of dynamic library static data areas.  This\n   causes performance problems with some SGI libraries that use mmap\n   as a bitmap allocator.  NOT YET FIXED.  It may be possible to turn\n   off DYNAMIC_LOADING in the collector as a workaround.  It may also\n   be possible to conditionally intercept mmap and use GC_exclude_static_roots.\n   The real fix is to walk rld data structures, which looks possible.\n - Incremental collector should handle large objects better.  Currently,\n   it looks like the whole object is treated as dirty if any part of it\n   is.\n \n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/doc/README.linux": "See README.alpha for Linux on DEC AXP info.\n\nThis file applies mostly to Linux/Intel IA32.  Ports to Linux on an M68K, IA64,\nSPARC, MIPS, Alpha and PowerPC are also integrated.  They should behave\nsimilarly, except that the PowerPC port lacks incremental GC support, and\nit is unknown to what extent the Linux threads code is functional.\nSee below for M68K specific notes.\n\nIncremental GC is generally supported.\n\nDynamic libraries are supported on an ELF system.  A static executable\nshould be linked with the gcc option \"-Wl,-defsym,_DYNAMIC=0\".\n\nThe collector appears to work reliably with Linux threads, but beware \nof older versions of glibc and gdb.\n\nThe garbage collector uses SIGPWR and SIGXCPU if it is used with\nLinux threads.  These should not be touched by the client program.\n\nTo use threads, you need to abide by the following requirements:\n\n1) You need to use LinuxThreads or NPTL (which are included in libc6).\n\n   The collector relies on some implementation details of the LinuxThreads\n   package.  This code may not work on other\n   pthread implementations (in particular it will *not* work with\n   MIT pthreads).\n\n2) You must compile the collector with -DGC_LINUX_THREADS and -D_REENTRANT\n   specified in the Makefile.\n\n3a) Every file that makes thread calls should define GC_LINUX_THREADS and \n   _REENTRANT and then include gc.h.  Gc.h redefines some of the\n   pthread primitives as macros which also provide the collector with\n   information it requires.\n\n3b) A new alternative to (3a) is to build the collector and compile GC clients\n   with -DGC_USE_LD_WRAP, and to link the final program with\n\n   (for ld) --wrap read --wrap dlopen --wrap pthread_create \\\n\t    --wrap pthread_join --wrap pthread_detach \\\n\t    --wrap pthread_sigmask --wrap sleep\n\n   (for gcc) -Wl,--wrap -Wl,read -Wl,--wrap -Wl,dlopen -Wl,--wrap \\\n\t     -Wl,pthread_create -Wl,--wrap -Wl,pthread_join -Wl,--wrap \\\n\t     -Wl,pthread_detach -Wl,--wrap -Wl,pthread_sigmask \\\n\t     -Wl,--wrap -Wl,sleep\n\n   In any case, _REENTRANT should be defined during compilation.\n\n4) Dlopen() disables collection during its execution.  (It can't run\n   concurrently with the collector, since the collector looks at its\n   data structures.  It can't acquire the allocator lock, since arbitrary\n   user startup code may run as part of dlopen().)  Under unusual\n   conditions, this may cause unexpected heap growth.\n\n5) The combination of GC_LINUX_THREADS, REDIRECT_MALLOC, and incremental\n   collection fails in seemingly random places.  This hasn't been tracked\n   down yet, but is perhaps not completely astonishing.  The thread package\n   uses malloc, and thus can presumably get SIGSEGVs while inside the\n   package.  There is no real guarantee that signals are handled properly\n   at that point.\n\n6) Thread local storage may not be viewed as part of the root set by the\n   collector.  This probably depends on the linuxthreads version.  For the\n   time being, any collectable memory referenced by thread local storage should\n   also be referenced from elsewhere, or be allocated as uncollectable.\n   (This is really a bug that should be fixed somehow.)\n\n\nM68K LINUX:\n(From Richard Zidlicky)\nThe bad news is that it can crash every linux-m68k kernel on a 68040,\nso an additional test is needed somewhere on startup. I have meanwhile\npatches to correct the problem in 68040 buserror handler but it is not\nyet in any standard kernel.\n\nHere is a simple test program to detect whether the kernel has the\nproblem. It could be run as a separate check in configure or tested \nupon startup. If it fails (return !0) than mprotect can't be used\non that system.\n\n/*\n * test for bug that may crash 68040 based Linux\n */\n\n#include <sys/mman.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n\nchar *membase;\nint pagesize=4096;\nint pageshift=12;\nint x_taken=0;\n\nint sighandler(int sig)\n{\n   mprotect(membase,pagesize,PROT_READ|PROT_WRITE);\n   x_taken=1;\n}\n\nmain()\n{\n  long l;\n\n   signal(SIGSEGV,sighandler);\n   l=(long)mmap(NULL,pagesize,PROT_READ,MAP_PRIVATE | MAP_ANON,-1,0);\n  if (l==-1)\n     {\n       perror(\"mmap/malloc\");\n       abort();\n     }\n  membase=(char*)l;\n    *(long*)(membase+sizeof(long))=123456789;\n  if (*(long*)(membase+sizeof(long)) != 123456789 )\n    {\n      fprintf(stderr,\"writeback failed !\\n\");\n      exit(1);\n    }\n  if (!x_taken)\n    {\n      fprintf(stderr,\"exception not taken !\\n\");\n      exit(1);\n    }\n  fprintf(stderr,\"vmtest Ok\\n\");\n  exit(0);\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/doc/README.solaris2": "The collector supports both incremental collection and threads under\nSolaris 2.  The incremental collector normally retrieves page dirty information\nthrough the appropriate /proc calls.  But it can also be configured\n(by defining MPROTECT_VDB instead of PROC_VDB in gcconfig.h) to use mprotect\nand signals.  This may result in shorter pause times, but it is no longer\nsafe to issue arbitrary system calls that write to the heap.\n\nUnder other UNIX versions,\nthe collector normally obtains memory through sbrk.  There is some reason\nto expect that this is not safe if the client program also calls the system\nmalloc, or especially realloc.  The sbrk man page strongly suggests this is\nnot safe: \"Many library routines use malloc() internally, so use brk()\nand sbrk() only when you know  that malloc() definitely will not be used by\nany library routine.\"  This doesn't make a lot of sense to me, since there\nseems to be no documentation as to which routines can transitively call malloc.\nNonetheless, under Solaris2, the collector now (since 4.12) allocates\nmemory using mmap by default.  (It defines USE_MMAP in gcconfig.h.)\nYou may want to reverse this decisions if you use -DREDIRECT_MALLOC=...\n\n\nSOLARIS THREADS:\n\nThe collector must be compiled with -DGC_SOLARIS_THREADS (thr_ functions)\nor -DGC_SOLARIS_PTHREADS (pthread_ functions) to be thread safe.\nIt is also essential that gc.h be included in files that call thr_create,\nthr_join, thr_suspend, thr_continue, or dlopen.  Gc.h macro defines\nthese to also do GC bookkeeping, etc.  Gc.h must be included with\none or both of these macros defined, otherwise\nthese replacements are not visible.\nA collector built in this way way only be used by programs that are\nlinked with the threads library.\n\nIn this mode, the collector contains various workarounds for older Solaris\nbugs.  Mostly, these should not be noticeable unless you look at system\ncall traces.  However, it cannot protect a guard page at the end of\na thread stack.  If you know that you will only be running Solaris2.5\nor later, it should be possible to fix this by compiling the collector\nwith -DSOLARIS23_MPROTECT_BUG_FIXED.\n\nSince 5.0 alpha5, dlopen disables collection temporarily,\nunless USE_PROC_FOR_LIBRARIES is defined.  In some unlikely cases, this\ncan result in unpleasant heap growth.  But it seems better than the\nrace/deadlock issues we had before.\n\nIf solaris_threads are used on an X86 processor with malloc redirected to\nGC_malloc a deadlock is likely to result.\n\nIt appears that there is a problem in using gc_cpp.h in conjunction with\nSolaris threads and Sun's C++ runtime.  Apparently the overloaded new operator\nis invoked by some iostream initialization code before threads are correctly\ninitialized.  As a result, call to thr_self() in garbage collector\ninitialization  segfaults.  Currently the only known workaround is to not\ninvoke the garbage collector from a user defined global operator new, or to\nhave it invoke the garbage-collector's allocators only after main has started.\n(Note that the latter requires a moderately expensive test in operator\ndelete.)\n\nHans-J. Boehm\n(The above contains my personal opinions, which are probably not shared\nby anyone else.)\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/runtime/monodis-wrapper.in": "#! /bin/sh\nr='@mono_build_root@'\nMONO_CFG_DIR='@mono_cfg_dir@'\nexport MONO_CFG_DIR\nexec \"$r/libtool\" --mode=execute -dlopen \"$r/mono/mini/libmono-2.0.la\" \"$r/mono/dis/monodis\" \"$@\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/netcore/corerun/coreclrhost.h": "// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\n//\n// APIs for hosting CoreCLR\n//\n\n#ifndef __CORECLR_HOST_H__\n#define __CORECLR_HOST_H__\n\n#if defined(_WIN32) && defined(_M_IX86)\n#define CORECLR_CALLING_CONVENTION __stdcall\n#else\n#define CORECLR_CALLING_CONVENTION\n#endif\n\n// For each hosting API, we define a function prototype and a function pointer\n// The prototype is useful for implicit linking against the dynamic coreclr\n// library and the pointer for explicit dynamic loading (dlopen, LoadLibrary)\n#define CORECLR_HOSTING_API(function, ...) \\\n    extern \"C\" int CORECLR_CALLING_CONVENTION function(__VA_ARGS__); \\\n    typedef int (CORECLR_CALLING_CONVENTION *function##_ptr)(__VA_ARGS__)\n    \n//\n// Initialize the CoreCLR. Creates and starts CoreCLR host and creates an app domain\n//\n// Parameters:\n//  exePath                 - Absolute path of the executable that invoked the ExecuteAssembly (the native host application)\n//  appDomainFriendlyName   - Friendly name of the app domain that will be created to execute the assembly\n//  propertyCount           - Number of properties (elements of the following two arguments)\n//  propertyKeys            - Keys of properties of the app domain\n//  propertyValues          - Values of properties of the app domain\n//  hostHandle              - Output parameter, handle of the created host\n//  domainId                - Output parameter, id of the created app domain \n//\n// Returns:\n//  HRESULT indicating status of the operation. S_OK if the assembly was successfully executed\n//\nCORECLR_HOSTING_API(coreclr_initialize,\n            const char* exePath,\n            const char* appDomainFriendlyName,\n            int propertyCount,\n            const char** propertyKeys,\n            const char** propertyValues,\n            void** hostHandle,\n            unsigned int* domainId);\n\n//\n// Shutdown CoreCLR. It unloads the app domain and stops the CoreCLR host.\n//\n// Parameters:\n//  hostHandle              - Handle of the host\n//  domainId                - Id of the domain\n//\n// Returns:\n//  HRESULT indicating status of the operation. S_OK if the assembly was successfully executed\n//\nCORECLR_HOSTING_API(coreclr_shutdown,\n            void* hostHandle,\n            unsigned int domainId);\n\n//\n// Shutdown CoreCLR. It unloads the app domain and stops the CoreCLR host.\n//\n// Parameters:\n//  hostHandle              - Handle of the host\n//  domainId                - Id of the domain\n//  latchedExitCode         - Latched exit code after domain unloaded\n//\n// Returns:\n//  HRESULT indicating status of the operation. S_OK if the assembly was successfully executed\n//\nCORECLR_HOSTING_API(coreclr_shutdown_2,\n            void* hostHandle,\n            unsigned int domainId,\n            int* latchedExitCode);\n\n//\n// Create a native callable function pointer for a managed method.\n//\n// Parameters:\n//  hostHandle              - Handle of the host\n//  domainId                - Id of the domain \n//  entryPointAssemblyName  - Name of the assembly which holds the custom entry point\n//  entryPointTypeName      - Name of the type which holds the custom entry point\n//  entryPointMethodName    - Name of the method which is the custom entry point\n//  delegate                - Output parameter, the function stores a native callable function pointer to the delegate at the specified address\n//\n// Returns:\n//  HRESULT indicating status of the operation. S_OK if the assembly was successfully executed\n//\nCORECLR_HOSTING_API(coreclr_create_delegate,\n            void* hostHandle,\n            unsigned int domainId,\n            const char* entryPointAssemblyName,\n            const char* entryPointTypeName,\n            const char* entryPointMethodName,\n            void** delegate);\n\n//\n// Execute a managed assembly with given arguments\n//\n// Parameters:\n//  hostHandle              - Handle of the host\n//  domainId                - Id of the domain \n//  argc                    - Number of arguments passed to the executed assembly\n//  argv                    - Array of arguments passed to the executed assembly\n//  managedAssemblyPath     - Path of the managed assembly to execute (or NULL if using a custom entrypoint).\n//  exitCode                - Exit code returned by the executed assembly\n//\n// Returns:\n//  HRESULT indicating status of the operation. S_OK if the assembly was successfully executed\n//\nCORECLR_HOSTING_API(coreclr_execute_assembly,\n            void* hostHandle,\n            unsigned int domainId,\n            int argc,\n            const char** argv,\n            const char* managedAssemblyPath,\n            unsigned int* exitCode);\n\n#undef CORECLR_HOSTING_API\n                      \n#endif // __CORECLR_HOST_H__\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/netcore/corerun/coreruncommon.cpp": "// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\n//\n// Code that is used by both the Unix corerun and coreconsole.\n//\n\n#include \"config.h\"\n\n#include <cstdlib>\n#include <cstring>\n#include <assert.h>\n#include <dirent.h>\n#include <dlfcn.h>\n#include <limits.h>\n#include <set>\n#include <string>\n#include <string.h>\n#include <sys/stat.h>\n#if defined(__FreeBSD__)\n#include <sys/types.h>\n#include <sys/param.h>\n#endif\n#if HAVE_GETAUXVAL\n#include <sys/auxv.h>\n#endif\n#if defined(HAVE_SYS_SYSCTL_H) || defined(__FreeBSD__)\n#include <sys/sysctl.h>\n#endif\n#include \"coreruncommon.h\"\n#include \"coreclrhost.h\"\n#include <unistd.h>\n#ifndef SUCCEEDED\n#define SUCCEEDED(Status) ((Status) >= 0)\n#endif // !SUCCEEDED\n\n// Name of the environment variable controlling server GC.\n// If set to 1, server GC is enabled on startup. If 0, server GC is\n// disabled. Server GC is off by default.\nstatic const char* serverGcVar = \"COMPlus_gcServer\";\n\n// Name of environment variable to control \"System.Globalization.Invariant\"\n// Set to 1 for Globalization Invariant mode to be true. Default is false.\nstatic const char* globalizationInvariantVar = \"CORECLR_GLOBAL_INVARIANT\";\n\n#if defined(__linux__)\n#define symlinkEntrypointExecutable \"/proc/self/exe\"\n#elif !defined(__APPLE__)\n#define symlinkEntrypointExecutable \"/proc/curproc/exe\"\n#endif\n\nbool GetEntrypointExecutableAbsolutePath(std::string& entrypointExecutable)\n{\n    bool result = false;\n    \n    entrypointExecutable.clear();\n\n    // Get path to the executable for the current process using\n    // platform specific means.\n#if defined(__APPLE__)\n    \n    // On Mac, we ask the OS for the absolute path to the entrypoint executable\n    uint32_t lenActualPath = 0;\n    if (_NSGetExecutablePath(nullptr, &lenActualPath) == -1)\n    {\n        // OSX has placed the actual path length in lenActualPath,\n        // so re-attempt the operation\n        std::string resizedPath(lenActualPath, '\\0');\n        char *pResizedPath = const_cast<char *>(resizedPath.c_str());\n        if (_NSGetExecutablePath(pResizedPath, &lenActualPath) == 0)\n        {\n            entrypointExecutable.assign(pResizedPath);\n            result = true;\n        }\n    }\n#elif defined (__FreeBSD__)\n    static const int name[] = {\n        CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1\n    };\n    char path[PATH_MAX];\n    size_t len;\n\n    len = sizeof(path);\n    if (sysctl(name, 4, path, &len, nullptr, 0) == 0)\n    {\n        entrypointExecutable.assign(path);\n        result = true;\n    }\n    else\n    {\n        // ENOMEM\n        result = false;\n    }\n#elif defined(__NetBSD__) && defined(KERN_PROC_PATHNAME)\n    static const int name[] = {\n        CTL_KERN, KERN_PROC_ARGS, -1, KERN_PROC_PATHNAME,\n    };\n    char path[MAXPATHLEN];\n    size_t len;\n\n    len = sizeof(path);\n    if (sysctl(name, __arraycount(name), path, &len, NULL, 0) != -1)\n    {\n        entrypointExecutable.assign(path);\n        result = true;\n    }\n    else\n    {\n        result = false;\n    }\n#else\n\n#if HAVE_GETAUXVAL && defined(AT_EXECFN)\n    const char *execfn = (const char *)getauxval(AT_EXECFN);\n\n    if (execfn)\n    {\n        entrypointExecutable.assign(execfn);\n        result = true;\n    }\n    else\n#endif\n    // On other OSs, return the symlink that will be resolved by GetAbsolutePath\n    // to fetch the entrypoint EXE absolute path, inclusive of filename.\n    result = GetAbsolutePath(symlinkEntrypointExecutable, entrypointExecutable);\n#endif \n\n    return result;\n}\n\nbool GetAbsolutePath(const char* path, std::string& absolutePath)\n{\n    bool result = false;\n\n    char realPath[PATH_MAX];\n    if (realpath(path, realPath) != nullptr && realPath[0] != '\\0')\n    {\n        absolutePath.assign(realPath);\n        // realpath should return canonicalized path without the trailing slash\n        assert(absolutePath.back() != '/');\n\n        result = true;\n    }\n\n    return result;\n}\n\nbool GetDirectory(const char* absolutePath, std::string& directory)\n{\n    directory.assign(absolutePath);\n    size_t lastSlash = directory.rfind('/');\n    if (lastSlash != std::string::npos)\n    {\n        directory.erase(lastSlash);\n        return true;\n    }\n\n    return false;\n}\n\nbool GetClrFilesAbsolutePath(const char* currentExePath, const char* clrFilesPath, std::string& clrFilesAbsolutePath)\n{\n    std::string clrFilesRelativePath;\n    const char* clrFilesPathLocal = clrFilesPath;\n    if (clrFilesPathLocal == nullptr)\n    {\n        // There was no CLR files path specified, use the folder of the corerun/coreconsole\n        if (!GetDirectory(currentExePath, clrFilesRelativePath))\n        {\n            perror(\"Failed to get directory from argv[0]\");\n            return false;\n        }\n\n        clrFilesPathLocal = clrFilesRelativePath.c_str();\n\n        // TODO: consider using an env variable (if defined) as a fall-back.\n        // The windows version of the corerun uses core_root env variable\n    }\n\n    if (!GetAbsolutePath(clrFilesPathLocal, clrFilesAbsolutePath))\n    {\n        perror(\"Failed to convert CLR files path to absolute path\");\n        return false;\n    }\n\n    return true;\n}\n\nvoid AddFilesFromDirectoryToTpaList(const char* directory, std::string& tpaList)\n{\n    const char * const tpaExtensions[] = {\n                \".ni.dll\",      // Probe for .ni.dll first so that it's preferred if ni and il coexist in the same dir\n                \".dll\",\n                \".ni.exe\",\n                \".exe\",\n                };\n\n    DIR* dir = opendir(directory);\n    if (dir == nullptr)\n    {\n        return;\n    }\n\n    std::set<std::string> addedAssemblies;\n\n    // Walk the directory for each extension separately so that we first get files with .ni.dll extension,\n    // then files with .dll extension, etc.\n    for (size_t extIndex = 0; extIndex < sizeof(tpaExtensions) / sizeof(tpaExtensions[0]); extIndex++)\n    {\n        const char* ext = tpaExtensions[extIndex];\n        int extLength = strlen(ext);\n\n        struct dirent* entry;\n\n        // For all entries in the directory\n        while ((entry = readdir(dir)) != nullptr)\n        {\n            // We are interested in files only\n            switch (entry->d_type)\n            {\n            case DT_REG:\n                break;\n\n            // Handle symlinks and file systems that do not support d_type\n            case DT_LNK:\n            case DT_UNKNOWN:\n                {\n                    std::string fullFilename;\n\n                    fullFilename.append(directory);\n                    fullFilename.append(\"/\");\n                    fullFilename.append(entry->d_name);\n\n                    struct stat sb;\n                    if (stat(fullFilename.c_str(), &sb) == -1)\n                    {\n                        continue;\n                    }\n\n                    if (!S_ISREG(sb.st_mode))\n                    {\n                        continue;\n                    }\n                }\n                break;\n\n            default:\n                continue;\n            }\n\n            std::string filename(entry->d_name);\n\n            // Check if the extension matches the one we are looking for\n            int extPos = filename.length() - extLength;\n            if ((extPos <= 0) || (filename.compare(extPos, extLength, ext) != 0))\n            {\n                continue;\n            }\n\n            std::string filenameWithoutExt(filename.substr(0, extPos));\n\n            // Make sure if we have an assembly with multiple extensions present,\n            // we insert only one version of it.\n            if (addedAssemblies.find(filenameWithoutExt) == addedAssemblies.end())\n            {\n                addedAssemblies.insert(filenameWithoutExt);\n\n                tpaList.append(directory);\n                tpaList.append(\"/\");\n                tpaList.append(filename);\n                tpaList.append(\":\");\n            }\n        }\n        \n        // Rewind the directory stream to be able to iterate over it for the next extension\n        rewinddir(dir);\n    }\n    \n    closedir(dir);\n}\n\nconst char* GetEnvValueBoolean(const char* envVariable)\n{\n    const char* envValue = std::getenv(envVariable);\n    if (envValue == nullptr)\n    {\n        envValue = \"0\";\n    }\n    // CoreCLR expects strings \"true\" and \"false\" instead of \"1\" and \"0\".\n    return (std::strcmp(envValue, \"1\") == 0 || strcasecmp(envValue, \"true\") == 0) ? \"true\" : \"false\";\n}\n\nstatic void *TryLoadHostPolicy(const char *hostPolicyPath)\n{\n#if defined(__APPLE__)\n    static const char LibrarySuffix[] = \".dylib\";\n#else // Various Linux-related OS-es\n    static const char LibrarySuffix[] = \".so\";\n#endif\n\n    std::string hostPolicyCompletePath(hostPolicyPath);\n    hostPolicyCompletePath.append(LibrarySuffix);\n\n    void *libraryPtr = dlopen(hostPolicyCompletePath.c_str(), RTLD_LAZY);\n    if (libraryPtr == nullptr)\n    {\n        fprintf(stderr, \"Failed to load mock hostpolicy at path '%s'. Error: %s\", hostPolicyCompletePath.c_str(), dlerror());\n    }\n\n    return libraryPtr;\n}\n\nint ExecuteManagedAssembly(\n            const char* currentExeAbsolutePath,\n            const char* clrFilesAbsolutePath,\n            const char* managedAssemblyAbsolutePath,\n            int managedAssemblyArgc,\n            const char** managedAssemblyArgv)\n{\n    // Indicates failure\n    int exitCode = -1;\n\n#ifdef _ARM_\n    // libunwind library is used to unwind stack frame, but libunwind for ARM\n    // does not support ARM vfpv3/NEON registers in DWARF format correctly.\n    // Therefore let's disable stack unwinding using DWARF information\n    // See https://github.com/dotnet/coreclr/issues/6698\n    //\n    // libunwind use following methods to unwind stack frame.\n    // UNW_ARM_METHOD_ALL          0xFF\n    // UNW_ARM_METHOD_DWARF        0x01\n    // UNW_ARM_METHOD_FRAME        0x02\n    // UNW_ARM_METHOD_EXIDX        0x04\n    putenv(const_cast<char *>(\"UNW_ARM_UNWIND_METHOD=6\"));\n#endif // _ARM_\n\n    std::string coreClrDllPath(clrFilesAbsolutePath);\n    coreClrDllPath.append(\"/\");\n    coreClrDllPath.append(coreClrDll);\n\n    if (coreClrDllPath.length() >= PATH_MAX)\n    {\n        fprintf(stderr, \"Absolute path to libcoreclr.so too long\\n\");\n        return -1;\n    }\n\n    // Get just the path component of the managed assembly path\n    std::string appPath;\n    GetDirectory(managedAssemblyAbsolutePath, appPath);\n\n    std::string tpaList;\n    if (strlen(managedAssemblyAbsolutePath) > 0)\n    {\n        // Target assembly should be added to the tpa list. Otherwise corerun.exe\n        // may find wrong assembly to execute.\n        // Details can be found at https://github.com/dotnet/coreclr/issues/5631\n        tpaList = managedAssemblyAbsolutePath;\n        tpaList.append(\":\");\n    }\n\n    // Construct native search directory paths\n    std::string nativeDllSearchDirs(appPath);\n    char *coreLibraries = getenv(\"CORE_LIBRARIES\");\n    if (coreLibraries)\n    {\n        nativeDllSearchDirs.append(\":\");\n        nativeDllSearchDirs.append(coreLibraries);\n        if (std::strcmp(coreLibraries, clrFilesAbsolutePath) != 0)\n        {\n            AddFilesFromDirectoryToTpaList(coreLibraries, tpaList);\n        }\n    }\n\n    nativeDllSearchDirs.append(\":\");\n    nativeDllSearchDirs.append(clrFilesAbsolutePath);\n\n    void* hostpolicyLib = nullptr;\n    char* mockHostpolicyPath = getenv(\"MOCK_HOSTPOLICY\");\n    if (mockHostpolicyPath)\n    {\n        hostpolicyLib = TryLoadHostPolicy(mockHostpolicyPath);\n        if (hostpolicyLib == nullptr)\n        {\n            return -1;\n        }\n    }\n\n    AddFilesFromDirectoryToTpaList(clrFilesAbsolutePath, tpaList);\n\n    void* coreclrLib = dlopen(coreClrDllPath.c_str(), RTLD_NOW | RTLD_LOCAL);\n    if (coreclrLib != nullptr)\n    {\n        coreclr_initialize_ptr initializeCoreCLR = (coreclr_initialize_ptr)dlsym(coreclrLib, \"coreclr_initialize\");\n        coreclr_execute_assembly_ptr executeAssembly = (coreclr_execute_assembly_ptr)dlsym(coreclrLib, \"coreclr_execute_assembly\");\n        coreclr_shutdown_2_ptr shutdownCoreCLR = (coreclr_shutdown_2_ptr)dlsym(coreclrLib, \"coreclr_shutdown_2\");\n\n        if (initializeCoreCLR == nullptr)\n        {\n            fprintf(stderr, \"Function coreclr_initialize not found in the libcoreclr.so\\n\");\n        }\n        else if (executeAssembly == nullptr)\n        {\n            fprintf(stderr, \"Function coreclr_execute_assembly not found in the libcoreclr.so\\n\");\n        }\n        else if (shutdownCoreCLR == nullptr)\n        {\n            fprintf(stderr, \"Function coreclr_shutdown_2 not found in the libcoreclr.so\\n\");\n        }\n        else\n        {\n            // Check whether we are enabling server GC (off by default)\n            const char* useServerGc = GetEnvValueBoolean(serverGcVar);\n\n            // Check Globalization Invariant mode (false by default)\n            const char* globalizationInvariant = GetEnvValueBoolean(globalizationInvariantVar);\n\n            // Allowed property names:\n            // APPBASE\n            // - The base path of the application from which the exe and other assemblies will be loaded\n            //\n            // TRUSTED_PLATFORM_ASSEMBLIES\n            // - The list of complete paths to each of the fully trusted assemblies\n            //\n            // APP_PATHS\n            // - The list of paths which will be probed by the assembly loader\n            //\n            // APP_NI_PATHS\n            // - The list of additional paths that the assembly loader will probe for ngen images\n            //\n            // NATIVE_DLL_SEARCH_DIRECTORIES\n            // - The list of paths that will be probed for native DLLs called by PInvoke\n            //\n            const char *propertyKeys[] = {\n                \"TRUSTED_PLATFORM_ASSEMBLIES\",\n                \"APP_PATHS\",\n                \"APP_NI_PATHS\",\n                \"NATIVE_DLL_SEARCH_DIRECTORIES\",\n                \"System.GC.Server\",\n                \"System.Globalization.Invariant\",\n            };\n            const char *propertyValues[] = {\n                // TRUSTED_PLATFORM_ASSEMBLIES\n                tpaList.c_str(),\n                // APP_PATHS\n                appPath.c_str(),\n                // APP_NI_PATHS\n                appPath.c_str(),\n                // NATIVE_DLL_SEARCH_DIRECTORIES\n                nativeDllSearchDirs.c_str(),\n                // System.GC.Server\n                useServerGc,\n                // System.Globalization.Invariant\n                globalizationInvariant,\n            };\n\n            void* hostHandle;\n            unsigned int domainId;\n\n            int st = initializeCoreCLR(\n                        currentExeAbsolutePath, \n                        \"unixcorerun\", \n                        sizeof(propertyKeys) / sizeof(propertyKeys[0]), \n                        propertyKeys, \n                        propertyValues, \n                        &hostHandle, \n                        &domainId);\n\n            if (!SUCCEEDED(st))\n            {\n                fprintf(stderr, \"coreclr_initialize failed - status: 0x%08x\\n\", st);\n                exitCode = -1;\n            }\n            else \n            {\n                st = executeAssembly(\n                        hostHandle,\n                        domainId,\n                        managedAssemblyArgc,\n                        managedAssemblyArgv,\n                        managedAssemblyAbsolutePath,\n                        (unsigned int*)&exitCode);\n\n                if (!SUCCEEDED(st))\n                {\n                    fprintf(stderr, \"coreclr_execute_assembly failed - status: 0x%08x\\n\", st);\n                    exitCode = -1;\n                }\n\n                int latchedExitCode = 0;\n                st = shutdownCoreCLR(hostHandle, domainId, &latchedExitCode);\n                if (!SUCCEEDED(st))\n                {\n                    fprintf(stderr, \"coreclr_shutdown failed - status: 0x%08x\\n\", st);\n                    exitCode = -1;\n                }\n\n                if (exitCode != -1)\n                {\n                    exitCode = latchedExitCode;\n                }\n            }\n        }\n    }\n    else\n    {\n        const char* error = dlerror();\n        fprintf(stderr, \"dlopen failed to open the libcoreclr.so with error %s\\n\", error);\n    }\n\n    if (hostpolicyLib)\n    {\n        if(dlclose(hostpolicyLib) != 0)\n        {\n            fprintf(stderr, \"Warning - dlclose of mock hostpolicy failed.\\n\");\n        }\n    }\n\n    return exitCode;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/m4/libtool.m4": "# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-\n#\n#   Copyright (C) 1996-2001, 2003-2015 Free Software Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\nm4_define([_LT_COPYING], [dnl\n# Copyright (C) 2014 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# GNU Libtool is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of of the License, or\n# (at your option) any later version.\n#\n# As a special exception to the GNU General Public License, if you\n# distribute this file as part of a program or library that is built\n# using GNU Libtool, you may include this file under the  same\n# distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n])\n\n# serial 58 LT_INIT\n\n\n# LT_PREREQ(VERSION)\n# ------------------\n# Complain and exit if this libtool version is less that VERSION.\nm4_defun([LT_PREREQ],\n[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,\n       [m4_default([$3],\n\t\t   [m4_fatal([Libtool version $1 or higher is required],\n\t\t             63)])],\n       [$2])])\n\n\n# _LT_CHECK_BUILDDIR\n# ------------------\n# Complain if the absolute build directory name contains unusual characters\nm4_defun([_LT_CHECK_BUILDDIR],\n[case `pwd` in\n  *\\ * | *\\\t*)\n    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;\nesac\n])\n\n\n# LT_INIT([OPTIONS])\n# ------------------\nAC_DEFUN([LT_INIT],\n[AC_PREREQ([2.62])dnl We use AC_PATH_PROGS_FEATURE_CHECK\nAC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl\nAC_BEFORE([$0], [LT_LANG])dnl\nAC_BEFORE([$0], [LT_OUTPUT])dnl\nAC_BEFORE([$0], [LTDL_INIT])dnl\nm4_require([_LT_CHECK_BUILDDIR])dnl\n\ndnl Autoconf doesn't catch unexpanded LT_ macros by default:\nm4_pattern_forbid([^_?LT_[A-Z_]+$])dnl\nm4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl\ndnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4\ndnl unless we require an AC_DEFUNed macro:\nAC_REQUIRE([LTOPTIONS_VERSION])dnl\nAC_REQUIRE([LTSUGAR_VERSION])dnl\nAC_REQUIRE([LTVERSION_VERSION])dnl\nAC_REQUIRE([LTOBSOLETE_VERSION])dnl\nm4_require([_LT_PROG_LTMAIN])dnl\n\n_LT_SHELL_INIT([SHELL=${CONFIG_SHELL-/bin/sh}])\n\ndnl Parse OPTIONS\n_LT_SET_OPTIONS([$0], [$1])\n\n# This can be used to rebuild libtool when needed\nLIBTOOL_DEPS=$ltmain\n\n# Always use our own libtool.\nLIBTOOL='$(SHELL) $(top_builddir)/libtool'\nAC_SUBST(LIBTOOL)dnl\n\n_LT_SETUP\n\n# Only expand once:\nm4_define([LT_INIT])\n])# LT_INIT\n\n# Old names:\nAU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])\nAU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PROG_LIBTOOL], [])\ndnl AC_DEFUN([AM_PROG_LIBTOOL], [])\n\n\n# _LT_PREPARE_CC_BASENAME\n# -----------------------\nm4_defun([_LT_PREPARE_CC_BASENAME], [\n# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.\nfunc_cc_basename ()\n{\n    for cc_temp in @S|@*\"\"; do\n      case $cc_temp in\n        compile | *[[\\\\/]]compile | ccache | *[[\\\\/]]ccache ) ;;\n        distcc | *[[\\\\/]]distcc | purify | *[[\\\\/]]purify ) ;;\n        \\-*) ;;\n        *) break;;\n      esac\n    done\n    func_cc_basename_result=`$ECHO \"$cc_temp\" | $SED \"s%.*/%%; s%^$host_alias-%%\"`\n}\n])# _LT_PREPARE_CC_BASENAME\n\n\n# _LT_CC_BASENAME(CC)\n# -------------------\n# It would be clearer to call AC_REQUIREs from _LT_PREPARE_CC_BASENAME,\n# but that macro is also expanded into generated libtool script, which\n# arranges for $SED and $ECHO to be set by different means.\nm4_defun([_LT_CC_BASENAME],\n[m4_require([_LT_PREPARE_CC_BASENAME])dnl\nAC_REQUIRE([_LT_DECL_SED])dnl\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl\nfunc_cc_basename $1\ncc_basename=$func_cc_basename_result\n])\n\n\n# _LT_FILEUTILS_DEFAULTS\n# ----------------------\n# It is okay to use these file commands and assume they have been set\n# sensibly after 'm4_require([_LT_FILEUTILS_DEFAULTS])'.\nm4_defun([_LT_FILEUTILS_DEFAULTS],\n[: ${CP=\"cp -f\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n])# _LT_FILEUTILS_DEFAULTS\n\n\n# _LT_SETUP\n# ---------\nm4_defun([_LT_SETUP],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_REQUIRE([_LT_PREPARE_SED_QUOTE_VARS])dnl\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl\n\n_LT_DECL([], [PATH_SEPARATOR], [1], [The PATH separator for the build system])dnl\ndnl\n_LT_DECL([], [host_alias], [0], [The host system])dnl\n_LT_DECL([], [host], [0])dnl\n_LT_DECL([], [host_os], [0])dnl\ndnl\n_LT_DECL([], [build_alias], [0], [The build system])dnl\n_LT_DECL([], [build], [0])dnl\n_LT_DECL([], [build_os], [0])dnl\ndnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\ndnl\nAC_REQUIRE([AC_PROG_LN_S])dnl\ntest -z \"$LN_S\" && LN_S=\"ln -s\"\n_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl\ndnl\nAC_REQUIRE([LT_CMD_MAX_LEN])dnl\n_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally \"o\")])dnl\n_LT_DECL([], [exeext], [0], [Executable file suffix (normally \"\")])dnl\ndnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nm4_require([_LT_PATH_CONVERSION_FUNCTIONS])dnl\nm4_require([_LT_CMD_RELOAD])dnl\nm4_require([_LT_CHECK_MAGIC_METHOD])dnl\nm4_require([_LT_CHECK_SHAREDLIB_FROM_LINKLIB])dnl\nm4_require([_LT_CMD_OLD_ARCHIVE])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_WITH_SYSROOT])dnl\nm4_require([_LT_CMD_TRUNCATE])dnl\n\n_LT_CONFIG_LIBTOOL_INIT([\n# See if we are running on zsh, and set the options that allow our\n# commands through without removal of \\ escapes INIT.\nif test -n \"\\${ZSH_VERSION+set}\"; then\n   setopt NO_GLOB_SUBST\nfi\n])\nif test -n \"${ZSH_VERSION+set}\"; then\n   setopt NO_GLOB_SUBST\nfi\n\n_LT_CHECK_OBJDIR\n\nm4_require([_LT_TAG_COMPILER])dnl\n\ncase $host_os in\naix3*)\n  # AIX sometimes has problems with the GCC collect2 program.  For some\n  # reason, if we set the COLLECT_NAMES environment variable, the problems\n  # vanish in a puff of smoke.\n  if test set != \"${COLLECT_NAMES+set}\"; then\n    COLLECT_NAMES=\n    export COLLECT_NAMES\n  fi\n  ;;\nesac\n\n# Global variables:\nofile=libtool\ncan_build_shared=yes\n\n# All known linkers require a '.a' archive for static linking (except MSVC,\n# which needs '.lib').\nlibext=a\n\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n\nold_CC=$CC\nold_CFLAGS=$CFLAGS\n\n# Set sane defaults for various variables\ntest -z \"$CC\" && CC=cc\ntest -z \"$LTCC\" && LTCC=$CC\ntest -z \"$LTCFLAGS\" && LTCFLAGS=$CFLAGS\ntest -z \"$LD\" && LD=ld\ntest -z \"$ac_objext\" && ac_objext=o\n\n_LT_CC_BASENAME([$compiler])\n\n# Only perform the check for file, if the check method requires it\ntest -z \"$MAGIC_CMD\" && MAGIC_CMD=file\ncase $deplibs_check_method in\nfile_magic*)\n  if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n    _LT_PATH_MAGIC\n  fi\n  ;;\nesac\n\n# Use C for the default configuration in the libtool script\nLT_SUPPORTED_TAG([CC])\n_LT_LANG_C_CONFIG\n_LT_LANG_DEFAULT_CONFIG\n_LT_CONFIG_COMMANDS\n])# _LT_SETUP\n\n\n# _LT_PREPARE_SED_QUOTE_VARS\n# --------------------------\n# Define a few sed substitution that help us do robust quoting.\nm4_defun([_LT_PREPARE_SED_QUOTE_VARS],\n[# Backslashify metacharacters that are still active within\n# double-quoted strings.\nsed_quote_subst='s/\\([[\"`$\\\\]]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([[\"`\\\\]]\\)/\\\\\\1/g'\n\n# Sed substitution to delay expansion of an escaped shell variable in a\n# double_quote_subst'ed string.\ndelay_variable_subst='s/\\\\\\\\\\\\\\\\\\\\\\$/\\\\\\\\\\\\$/g'\n\n# Sed substitution to delay expansion of an escaped single quote.\ndelay_single_quote_subst='s/'\\''/'\\'\\\\\\\\\\\\\\'\\''/g'\n\n# Sed substitution to avoid accidental globbing in evaled expressions\nno_glob_subst='s/\\*/\\\\\\*/g'\n])\n\n# _LT_PROG_LTMAIN\n# ---------------\n# Note that this code is called both from 'configure', and 'config.status'\n# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,\n# 'config.status' has no value for ac_aux_dir unless we are using Automake,\n# so we pass a copy along to make sure it has a sensible value anyway.\nm4_defun([_LT_PROG_LTMAIN],\n[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl\n_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])\nltmain=$ac_aux_dir/ltmain.sh\n])# _LT_PROG_LTMAIN\n\n\n## ------------------------------------- ##\n## Accumulate code for creating libtool. ##\n## ------------------------------------- ##\n\n# So that we can recreate a full libtool script including additional\n# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS\n# in macros and then make a single call at the end using the 'libtool'\n# label.\n\n\n# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])\n# ----------------------------------------\n# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL_INIT],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_INIT])\n\n\n# _LT_CONFIG_LIBTOOL([COMMANDS])\n# ------------------------------\n# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])\n\n\n# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])\n# -----------------------------------------------------\nm4_defun([_LT_CONFIG_SAVE_COMMANDS],\n[_LT_CONFIG_LIBTOOL([$1])\n_LT_CONFIG_LIBTOOL_INIT([$2])\n])\n\n\n# _LT_FORMAT_COMMENT([COMMENT])\n# -----------------------------\n# Add leading comment marks to the start of each line, and a trailing\n# full-stop to the whole comment if one is not present already.\nm4_define([_LT_FORMAT_COMMENT],\n[m4_ifval([$1], [\nm4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],\n              [['`$\\]], [\\\\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])\n)])\n\n\n\n## ------------------------ ##\n## FIXME: Eliminate VARNAME ##\n## ------------------------ ##\n\n\n# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])\n# -------------------------------------------------------------------\n# CONFIGNAME is the name given to the value in the libtool script.\n# VARNAME is the (base) name used in the configure script.\n# VALUE may be 0, 1 or 2 for a computed quote escaped value based on\n# VARNAME.  Any other value will be used directly.\nm4_define([_LT_DECL],\n[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],\n    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],\n\t[m4_ifval([$1], [$1], [$2])])\n    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])\n    m4_ifval([$4],\n\t[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])\n    lt_dict_add_subkey([lt_decl_dict], [$2],\n\t[tagged?], [m4_ifval([$5], [yes], [no])])])\n])\n\n\n# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])\n# --------------------------------------------------------\nm4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])\n\n\n# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_tag_varnames],\n[_lt_decl_filter([tagged?], [yes], $@)])\n\n\n# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])\n# ---------------------------------------------------------\nm4_define([_lt_decl_filter],\n[m4_case([$#],\n  [0], [m4_fatal([$0: too few arguments: $#])],\n  [1], [m4_fatal([$0: too few arguments: $#: $1])],\n  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],\n  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],\n  [lt_dict_filter([lt_decl_dict], $@)])[]dnl\n])\n\n\n# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])\n# --------------------------------------------------\nm4_define([lt_decl_quote_varnames],\n[_lt_decl_filter([value], [1], $@)])\n\n\n# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_dquote_varnames],\n[_lt_decl_filter([value], [2], $@)])\n\n\n# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_varnames_tagged],\n[m4_assert([$# <= 2])dnl\n_$0(m4_quote(m4_default([$1], [[, ]])),\n    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),\n    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])\nm4_define([_lt_decl_varnames_tagged],\n[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])\n\n\n# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_all_varnames],\n[_$0(m4_quote(m4_default([$1], [[, ]])),\n     m4_if([$2], [],\n\t   m4_quote(lt_decl_varnames),\n\tm4_quote(m4_shift($@))))[]dnl\n])\nm4_define([_lt_decl_all_varnames],\n[lt_join($@, lt_decl_varnames_tagged([$1],\n\t\t\tlt_decl_tag_varnames([[, ]], m4_shift($@))))dnl\n])\n\n\n# _LT_CONFIG_STATUS_DECLARE([VARNAME])\n# ------------------------------------\n# Quote a variable value, and forward it to 'config.status' so that its\n# declaration there will have the same value as in 'configure'.  VARNAME\n# must have a single quote delimited value for this to work.\nm4_define([_LT_CONFIG_STATUS_DECLARE],\n[$1='`$ECHO \"$][$1\" | $SED \"$delay_single_quote_subst\"`'])\n\n\n# _LT_CONFIG_STATUS_DECLARATIONS\n# ------------------------------\n# We delimit libtool config variables with single quotes, so when\n# we write them to config.status, we have to be sure to quote all\n# embedded single quotes properly.  In configure, this macro expands\n# each variable declared with _LT_DECL (and _LT_TAGDECL) into:\n#\n#    <var>='`$ECHO \"$<var>\" | $SED \"$delay_single_quote_subst\"`'\nm4_defun([_LT_CONFIG_STATUS_DECLARATIONS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),\n    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAGS\n# ----------------\n# Output comment and list of tags supported by the script\nm4_defun([_LT_LIBTOOL_TAGS],\n[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl\navailable_tags='_LT_TAGS'dnl\n])\n\n\n# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])\n# -----------------------------------\n# Extract the dictionary values for VARNAME (optionally with TAG) and\n# expand to a commented shell variable setting:\n#\n#    # Some comment about what VAR is for.\n#    visible_name=$lt_internal_name\nm4_define([_LT_LIBTOOL_DECLARE],\n[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],\n\t\t\t\t\t   [description])))[]dnl\nm4_pushdef([_libtool_name],\n    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl\nm4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),\n    [0], [_libtool_name=[$]$1],\n    [1], [_libtool_name=$lt_[]$1],\n    [2], [_libtool_name=$lt_[]$1],\n    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl\nm4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl\n])\n\n\n# _LT_LIBTOOL_CONFIG_VARS\n# -----------------------\n# Produce commented declarations of non-tagged libtool config variables\n# suitable for insertion in the LIBTOOL CONFIG section of the 'libtool'\n# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG\n# section) are produced by _LT_LIBTOOL_TAG_VARS.\nm4_defun([_LT_LIBTOOL_CONFIG_VARS],\n[m4_foreach([_lt_var],\n    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAG_VARS(TAG)\n# -------------------------\nm4_define([_LT_LIBTOOL_TAG_VARS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])\n\n\n# _LT_TAGVAR(VARNAME, [TAGNAME])\n# ------------------------------\nm4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])\n\n\n# _LT_CONFIG_COMMANDS\n# -------------------\n# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of\n# variables for single and double quote escaping we saved from calls\n# to _LT_DECL, we can put quote escaped variables declarations\n# into 'config.status', and then the shell code to quote escape them in\n# for loops in 'config.status'.  Finally, any additional code accumulated\n# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.\nm4_defun([_LT_CONFIG_COMMANDS],\n[AC_PROVIDE_IFELSE([LT_OUTPUT],\n\tdnl If the libtool generation code has been placed in $CONFIG_LT,\n\tdnl instead of duplicating it all over again into config.status,\n\tdnl then we will have config.status run $CONFIG_LT later, so it\n\tdnl needs to know what name is stored there:\n        [AC_CONFIG_COMMANDS([libtool],\n            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],\n    dnl If the libtool generation code is destined for config.status,\n    dnl expand the accumulated commands and init code now:\n    [AC_CONFIG_COMMANDS([libtool],\n        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])\n])#_LT_CONFIG_COMMANDS\n\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],\n[\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nsed_quote_subst='$sed_quote_subst'\ndouble_quote_subst='$double_quote_subst'\ndelay_variable_subst='$delay_variable_subst'\n_LT_CONFIG_STATUS_DECLARATIONS\nLTCC='$LTCC'\nLTCFLAGS='$LTCFLAGS'\ncompiler='$compiler_DEFAULT'\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$[]1\n_LTECHO_EOF'\n}\n\n# Quote evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_quote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED \\\\\"\\\\\\$sed_quote_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\" ## exclude from sc_prohibit_nested_quotes\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n# Double-quote double-evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_dquote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED -e \\\\\"\\\\\\$double_quote_subst\\\\\" -e \\\\\"\\\\\\$sed_quote_subst\\\\\" -e \\\\\"\\\\\\$delay_variable_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\" ## exclude from sc_prohibit_nested_quotes\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n_LT_OUTPUT_LIBTOOL_INIT\n])\n\n# _LT_GENERATED_FILE_INIT(FILE, [COMMENT])\n# ------------------------------------\n# Generate a child script FILE with all initialization necessary to\n# reuse the environment learned by the parent script, and make the\n# file executable.  If COMMENT is supplied, it is inserted after the\n# '#!' sequence but before initialization text begins.  After this\n# macro, additional text can be appended to FILE to form the body of\n# the child script.  The macro ends with non-zero status if the\n# file could not be fully written (such as if the disk is full).\nm4_ifdef([AS_INIT_GENERATED],\n[m4_defun([_LT_GENERATED_FILE_INIT],[AS_INIT_GENERATED($@)])],\n[m4_defun([_LT_GENERATED_FILE_INIT],\n[m4_require([AS_PREPARE])]dnl\n[m4_pushdef([AS_MESSAGE_LOG_FD])]dnl\n[lt_write_fail=0\ncat >$1 <<_ASEOF || lt_write_fail=1\n#! $SHELL\n# Generated by $as_me.\n$2\nSHELL=\\${CONFIG_SHELL-$SHELL}\nexport SHELL\n_ASEOF\ncat >>$1 <<\\_ASEOF || lt_write_fail=1\nAS_SHELL_SANITIZE\n_AS_PREPARE\nexec AS_MESSAGE_FD>&1\n_ASEOF\ntest 0 = \"$lt_write_fail\" && chmod +x $1[]dnl\nm4_popdef([AS_MESSAGE_LOG_FD])])])# _LT_GENERATED_FILE_INIT\n\n# LT_OUTPUT\n# ---------\n# This macro allows early generation of the libtool script (before\n# AC_OUTPUT is called), incase it is used in configure for compilation\n# tests.\nAC_DEFUN([LT_OUTPUT],\n[: ${CONFIG_LT=./config.lt}\nAC_MSG_NOTICE([creating $CONFIG_LT])\n_LT_GENERATED_FILE_INIT([\"$CONFIG_LT\"],\n[# Run this file to recreate a libtool stub with the current configuration.])\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nlt_cl_silent=false\nexec AS_MESSAGE_LOG_FD>>config.log\n{\n  echo\n  AS_BOX([Running $as_me.])\n} >&AS_MESSAGE_LOG_FD\n\nlt_cl_help=\"\\\n'$as_me' creates a local libtool stub from the current configuration,\nfor use in further configure time tests before the real libtool is\ngenerated.\n\nUsage: $[0] [[OPTIONS]]\n\n  -h, --help      print this help, then exit\n  -V, --version   print version number, then exit\n  -q, --quiet     do not print progress messages\n  -d, --debug     don't remove temporary files\n\nReport bugs to <bug-libtool@gnu.org>.\"\n\nlt_cl_version=\"\\\nm4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl\nm4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])\nconfigured by $[0], generated by m4_PACKAGE_STRING.\n\nCopyright (C) 2011 Free Software Foundation, Inc.\nThis config.lt script is free software; the Free Software Foundation\ngives unlimited permision to copy, distribute and modify it.\"\n\nwhile test 0 != $[#]\ndo\n  case $[1] in\n    --version | --v* | -V )\n      echo \"$lt_cl_version\"; exit 0 ;;\n    --help | --h* | -h )\n      echo \"$lt_cl_help\"; exit 0 ;;\n    --debug | --d* | -d )\n      debug=: ;;\n    --quiet | --q* | --silent | --s* | -q )\n      lt_cl_silent=: ;;\n\n    -*) AC_MSG_ERROR([unrecognized option: $[1]\nTry '$[0] --help' for more information.]) ;;\n\n    *) AC_MSG_ERROR([unrecognized argument: $[1]\nTry '$[0] --help' for more information.]) ;;\n  esac\n  shift\ndone\n\nif $lt_cl_silent; then\n  exec AS_MESSAGE_FD>/dev/null\nfi\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<_LTEOF\n_LT_OUTPUT_LIBTOOL_COMMANDS_INIT\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nAC_MSG_NOTICE([creating $ofile])\n_LT_OUTPUT_LIBTOOL_COMMANDS\nAS_EXIT(0)\n_LTEOF\nchmod +x \"$CONFIG_LT\"\n\n# configure is writing to config.log, but config.lt does its own redirection,\n# appending to config.log, which fails on DOS, as config.log is still kept\n# open by configure.  Here we exec the FD to /dev/null, effectively closing\n# config.log, so it can be properly (re)opened and appended to by config.lt.\nlt_cl_success=:\ntest yes = \"$silent\" &&\n  lt_config_lt_args=\"$lt_config_lt_args --quiet\"\nexec AS_MESSAGE_LOG_FD>/dev/null\n$SHELL \"$CONFIG_LT\" $lt_config_lt_args || lt_cl_success=false\nexec AS_MESSAGE_LOG_FD>>config.log\n$lt_cl_success || AS_EXIT(1)\n])# LT_OUTPUT\n\n\n# _LT_CONFIG(TAG)\n# ---------------\n# If TAG is the built-in tag, create an initial libtool script with a\n# default configuration from the untagged config vars.  Otherwise add code\n# to config.status for appending the configuration named by TAG from the\n# matching tagged config vars.\nm4_defun([_LT_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_CONFIG_SAVE_COMMANDS([\n  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl\n  m4_if(_LT_TAG, [C], [\n    # See if we are running on zsh, and set the options that allow our\n    # commands through without removal of \\ escapes.\n    if test -n \"${ZSH_VERSION+set}\"; then\n      setopt NO_GLOB_SUBST\n    fi\n\n    cfgfile=${ofile}T\n    trap \"$RM \\\"$cfgfile\\\"; exit 1\" 1 2 15\n    $RM \"$cfgfile\"\n\n    cat <<_LT_EOF >> \"$cfgfile\"\n#! $SHELL\n# Generated automatically by $as_me ($PACKAGE) $VERSION\n# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:\n# NOTE: Changes made to this file will be lost: look at ltmain.sh.\n\n# Provide generalized library-building support services.\n# Written by Gordon Matzigkeit, 1996\n\n_LT_COPYING\n_LT_LIBTOOL_TAGS\n\n# Configured defaults for sys_lib_dlsearch_path munging.\n: \\${LT_SYS_LIBRARY_PATH=\"$configure_time_lt_sys_library_path\"}\n\n# ### BEGIN LIBTOOL CONFIG\n_LT_LIBTOOL_CONFIG_VARS\n_LT_LIBTOOL_TAG_VARS\n# ### END LIBTOOL CONFIG\n\n_LT_EOF\n\n    cat <<'_LT_EOF' >> \"$cfgfile\"\n\n# ### BEGIN FUNCTIONS SHARED WITH CONFIGURE\n\n_LT_PREPARE_MUNGE_PATH_LIST\n_LT_PREPARE_CC_BASENAME\n\n# ### END FUNCTIONS SHARED WITH CONFIGURE\n\n_LT_EOF\n\n  case $host_os in\n  aix3*)\n    cat <<\\_LT_EOF >> \"$cfgfile\"\n# AIX sometimes has problems with the GCC collect2 program.  For some\n# reason, if we set the COLLECT_NAMES environment variable, the problems\n# vanish in a puff of smoke.\nif test set != \"${COLLECT_NAMES+set}\"; then\n  COLLECT_NAMES=\n  export COLLECT_NAMES\nfi\n_LT_EOF\n    ;;\n  esac\n\n  _LT_PROG_LTMAIN\n\n  # We use sed instead of cat because bash on DJGPP gets confused if\n  # if finds mixed CR/LF and LF-only lines.  Since sed operates in\n  # text mode, it properly converts lines to CR/LF.  This bash problem\n  # is reportedly fixed, but why not run on old versions too?\n  sed '$q' \"$ltmain\" >> \"$cfgfile\" \\\n     || (rm -f \"$cfgfile\"; exit 1)\n\n   mv -f \"$cfgfile\" \"$ofile\" ||\n    (rm -f \"$ofile\" && cp \"$cfgfile\" \"$ofile\" && rm -f \"$cfgfile\")\n  chmod +x \"$ofile\"\n],\n[cat <<_LT_EOF >> \"$ofile\"\n\ndnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded\ndnl in a comment (ie after a #).\n# ### BEGIN LIBTOOL TAG CONFIG: $1\n_LT_LIBTOOL_TAG_VARS(_LT_TAG)\n# ### END LIBTOOL TAG CONFIG: $1\n_LT_EOF\n])dnl /m4_if\n],\n[m4_if([$1], [], [\n    PACKAGE='$PACKAGE'\n    VERSION='$VERSION'\n    RM='$RM'\n    ofile='$ofile'], [])\n])dnl /_LT_CONFIG_SAVE_COMMANDS\n])# _LT_CONFIG\n\n\n# LT_SUPPORTED_TAG(TAG)\n# ---------------------\n# Trace this macro to discover what tags are supported by the libtool\n# --tag option, using:\n#    autoconf --trace 'LT_SUPPORTED_TAG:$1'\nAC_DEFUN([LT_SUPPORTED_TAG], [])\n\n\n# C support is built-in for now\nm4_define([_LT_LANG_C_enabled], [])\nm4_define([_LT_TAGS], [])\n\n\n# LT_LANG(LANG)\n# -------------\n# Enable libtool support for the given language if not already enabled.\nAC_DEFUN([LT_LANG],\n[AC_BEFORE([$0], [LT_OUTPUT])dnl\nm4_case([$1],\n  [C],\t\t\t[_LT_LANG(C)],\n  [C++],\t\t[_LT_LANG(CXX)],\n  [Go],\t\t\t[_LT_LANG(GO)],\n  [Java],\t\t[_LT_LANG(GCJ)],\n  [Fortran 77],\t\t[_LT_LANG(F77)],\n  [Fortran],\t\t[_LT_LANG(FC)],\n  [Windows Resource],\t[_LT_LANG(RC)],\n  [m4_ifdef([_LT_LANG_]$1[_CONFIG],\n    [_LT_LANG($1)],\n    [m4_fatal([$0: unsupported language: \"$1\"])])])dnl\n])# LT_LANG\n\n\n# _LT_LANG(LANGNAME)\n# ------------------\nm4_defun([_LT_LANG],\n[m4_ifdef([_LT_LANG_]$1[_enabled], [],\n  [LT_SUPPORTED_TAG([$1])dnl\n  m4_append([_LT_TAGS], [$1 ])dnl\n  m4_define([_LT_LANG_]$1[_enabled], [])dnl\n  _LT_LANG_$1_CONFIG($1)])dnl\n])# _LT_LANG\n\n\nm4_ifndef([AC_PROG_GO], [\n############################################################\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_GO.  When it is available in    #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n############################################################\nm4_defun([AC_PROG_GO],\n[AC_LANG_PUSH(Go)dnl\nAC_ARG_VAR([GOC],     [Go compiler command])dnl\nAC_ARG_VAR([GOFLAGS], [Go compiler flags])dnl\n_AC_ARG_VAR_LDFLAGS()dnl\nAC_CHECK_TOOL(GOC, gccgo)\nif test -z \"$GOC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    AC_CHECK_PROG(GOC, [${ac_tool_prefix}gccgo], [${ac_tool_prefix}gccgo])\n  fi\nfi\nif test -z \"$GOC\"; then\n  AC_CHECK_PROG(GOC, gccgo, gccgo, false)\nfi\n])#m4_defun\n])#m4_ifndef\n\n\n# _LT_LANG_DEFAULT_CONFIG\n# -----------------------\nm4_defun([_LT_LANG_DEFAULT_CONFIG],\n[AC_PROVIDE_IFELSE([AC_PROG_CXX],\n  [LT_LANG(CXX)],\n  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_F77],\n  [LT_LANG(F77)],\n  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_FC],\n  [LT_LANG(FC)],\n  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])\n\ndnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal\ndnl pulling things in needlessly.\nAC_PROVIDE_IFELSE([AC_PROG_GCJ],\n  [LT_LANG(GCJ)],\n  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],\n    [LT_LANG(GCJ)],\n    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],\n      [LT_LANG(GCJ)],\n      [m4_ifdef([AC_PROG_GCJ],\n\t[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([A][M_PROG_GCJ],\n\t[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([LT_PROG_GCJ],\n\t[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])\n\nAC_PROVIDE_IFELSE([AC_PROG_GO],\n  [LT_LANG(GO)],\n  [m4_define([AC_PROG_GO], defn([AC_PROG_GO])[LT_LANG(GO)])])\n\nAC_PROVIDE_IFELSE([LT_PROG_RC],\n  [LT_LANG(RC)],\n  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])\n])# _LT_LANG_DEFAULT_CONFIG\n\n# Obsolete macros:\nAU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])\nAU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])\nAU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])\nAU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])\nAU_DEFUN([AC_LIBTOOL_RC], [LT_LANG(Windows Resource)])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_CXX], [])\ndnl AC_DEFUN([AC_LIBTOOL_F77], [])\ndnl AC_DEFUN([AC_LIBTOOL_FC], [])\ndnl AC_DEFUN([AC_LIBTOOL_GCJ], [])\ndnl AC_DEFUN([AC_LIBTOOL_RC], [])\n\n\n# _LT_TAG_COMPILER\n# ----------------\nm4_defun([_LT_TAG_COMPILER],\n[AC_REQUIRE([AC_PROG_CC])dnl\n\n_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl\n_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl\n_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl\n_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl\n\n# If no C compiler was specified, use CC.\nLTCC=${LTCC-\"$CC\"}\n\n# If no C compiler flags were specified, use CFLAGS.\nLTCFLAGS=${LTCFLAGS-\"$CFLAGS\"}\n\n# Allow CC to be a program name with arguments.\ncompiler=$CC\n])# _LT_TAG_COMPILER\n\n\n# _LT_COMPILER_BOILERPLATE\n# ------------------------\n# Check for compiler boilerplate output or warnings with\n# the simple compiler test code.\nm4_defun([_LT_COMPILER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_compile_test_code\" >conftest.$ac_ext\neval \"$ac_compile\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_compiler_boilerplate=`cat conftest.err`\n$RM conftest*\n])# _LT_COMPILER_BOILERPLATE\n\n\n# _LT_LINKER_BOILERPLATE\n# ----------------------\n# Check for linker boilerplate output or warnings with\n# the simple link test code.\nm4_defun([_LT_LINKER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_link_test_code\" >conftest.$ac_ext\neval \"$ac_link\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_linker_boilerplate=`cat conftest.err`\n$RM -r conftest*\n])# _LT_LINKER_BOILERPLATE\n\n# _LT_REQUIRED_DARWIN_CHECKS\n# -------------------------\nm4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[\n  case $host_os in\n    rhapsody* | darwin*)\n    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])\n    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])\n    AC_CHECK_TOOL([LIPO], [lipo], [:])\n    AC_CHECK_TOOL([OTOOL], [otool], [:])\n    AC_CHECK_TOOL([OTOOL64], [otool64], [:])\n    _LT_DECL([], [DSYMUTIL], [1],\n      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])\n    _LT_DECL([], [NMEDIT], [1],\n      [Tool to change global to local symbols on Mac OS X])\n    _LT_DECL([], [LIPO], [1],\n      [Tool to manipulate fat objects and archives on Mac OS X])\n    _LT_DECL([], [OTOOL], [1],\n      [ldd/readelf like tool for Mach-O binaries on Mac OS X])\n    _LT_DECL([], [OTOOL64], [1],\n      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])\n\n    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],\n      [lt_cv_apple_cc_single_mod=no\n      if test -z \"$LT_MULTI_MODULE\"; then\n\t# By default we will add the -single_module flag. You can override\n\t# by either setting the environment variable LT_MULTI_MODULE\n\t# non-empty at configure time, or by adding -multi_module to the\n\t# link flags.\n\trm -rf libconftest.dylib*\n\techo \"int foo(void){return 1;}\" > conftest.c\n\techo \"$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n-dynamiclib -Wl,-single_module conftest.c\" >&AS_MESSAGE_LOG_FD\n\t$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n\t  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err\n        _lt_result=$?\n\t# If there is a non-empty error log, and \"single_module\"\n\t# appears in it, assume the flag caused a linker warning\n        if test -s conftest.err && $GREP single_module conftest.err; then\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\t# Otherwise, if the output was created with a 0 exit code from\n\t# the compiler, it worked.\n\telif test -f libconftest.dylib && test 0 = \"$_lt_result\"; then\n\t  lt_cv_apple_cc_single_mod=yes\n\telse\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\tfi\n\trm -rf libconftest.dylib*\n\trm -f conftest.*\n      fi])\n\n    AC_CACHE_CHECK([for -exported_symbols_list linker flag],\n      [lt_cv_ld_exported_symbols_list],\n      [lt_cv_ld_exported_symbols_list=no\n      save_LDFLAGS=$LDFLAGS\n      echo \"_main\" > conftest.sym\n      LDFLAGS=\"$LDFLAGS -Wl,-exported_symbols_list,conftest.sym\"\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n\t[lt_cv_ld_exported_symbols_list=yes],\n\t[lt_cv_ld_exported_symbols_list=no])\n\tLDFLAGS=$save_LDFLAGS\n    ])\n\n    AC_CACHE_CHECK([for -force_load linker flag],[lt_cv_ld_force_load],\n      [lt_cv_ld_force_load=no\n      cat > conftest.c << _LT_EOF\nint forced_loaded() { return 2;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS -c -o conftest.o conftest.c\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&AS_MESSAGE_LOG_FD\n      echo \"$AR cru libconftest.a conftest.o\" >&AS_MESSAGE_LOG_FD\n      $AR cru libconftest.a conftest.o 2>&AS_MESSAGE_LOG_FD\n      echo \"$RANLIB libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $RANLIB libconftest.a 2>&AS_MESSAGE_LOG_FD\n      cat > conftest.c << _LT_EOF\nint main() { return 0;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err\n      _lt_result=$?\n      if test -s conftest.err && $GREP force_load conftest.err; then\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      elif test -f conftest && test 0 = \"$_lt_result\" && $GREP forced_load conftest >/dev/null 2>&1; then\n\tlt_cv_ld_force_load=yes\n      else\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      fi\n        rm -f conftest.err libconftest.a conftest conftest.c\n        rm -rf conftest.dSYM\n    ])\n    case $host_os in\n    rhapsody* | darwin1.[[012]])\n      _lt_dar_allow_undefined='$wl-undefined ${wl}suppress' ;;\n    darwin1.*)\n      _lt_dar_allow_undefined='$wl-flat_namespace $wl-undefined ${wl}suppress' ;;\n    darwin*) # darwin 5.x on\n      # if running on 10.5 or later, the deployment target defaults\n      # to the OS version, if on x86, and 10.4, the deployment\n      # target defaults to 10.4. Don't you love it?\n      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in\n\t10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)\n\t  _lt_dar_allow_undefined='$wl-undefined ${wl}dynamic_lookup' ;;\n\t10.[[012]][[,.]]*)\n\t  _lt_dar_allow_undefined='$wl-flat_namespace $wl-undefined ${wl}suppress' ;;\n\t10.*)\n\t  _lt_dar_allow_undefined='$wl-undefined ${wl}dynamic_lookup' ;;\n      esac\n    ;;\n  esac\n    if test yes = \"$lt_cv_apple_cc_single_mod\"; then\n      _lt_dar_single_mod='$single_module'\n    fi\n    if test yes = \"$lt_cv_ld_exported_symbols_list\"; then\n      _lt_dar_export_syms=' $wl-exported_symbols_list,$output_objdir/$libname-symbols.expsym'\n    else\n      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/$libname-symbols.expsym $lib'\n    fi\n    if test : != \"$DSYMUTIL\" && test no = \"$lt_cv_ld_force_load\"; then\n      _lt_dsymutil='~$DSYMUTIL $lib || :'\n    else\n      _lt_dsymutil=\n    fi\n    ;;\n  esac\n])\n\n\n# _LT_DARWIN_LINKER_FEATURES([TAG])\n# ---------------------------------\n# Checks for linker and compiler features on darwin\nm4_defun([_LT_DARWIN_LINKER_FEATURES],\n[\n  m4_require([_LT_REQUIRED_DARWIN_CHECKS])\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_automatic, $1)=yes\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  if test yes = \"$lt_cv_ld_force_load\"; then\n    _LT_TAGVAR(whole_archive_flag_spec, $1)='`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience $wl-force_load,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"`'\n    m4_case([$1], [F77], [_LT_TAGVAR(compiler_needs_object, $1)=yes],\n                  [FC],  [_LT_TAGVAR(compiler_needs_object, $1)=yes])\n  else\n    _LT_TAGVAR(whole_archive_flag_spec, $1)=''\n  fi\n  _LT_TAGVAR(link_all_deplibs, $1)=yes\n  _LT_TAGVAR(allow_undefined_flag, $1)=$_lt_dar_allow_undefined\n  case $cc_basename in\n     ifort*|nagfor*) _lt_dar_can_shared=yes ;;\n     *) _lt_dar_can_shared=$GCC ;;\n  esac\n  if test yes = \"$_lt_dar_can_shared\"; then\n    output_verbose_link_cmd=func_echo_all\n    _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring $_lt_dar_single_mod$_lt_dsymutil\"\n    _LT_TAGVAR(module_cmds, $1)=\"\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags$_lt_dsymutil\"\n    _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's|^|_|' < \\$export_symbols > \\$output_objdir/\\$libname-symbols.expsym~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring $_lt_dar_single_mod$_lt_dar_export_syms$_lt_dsymutil\"\n    _LT_TAGVAR(module_expsym_cmds, $1)=\"sed -e 's|^|_|' < \\$export_symbols > \\$output_objdir/\\$libname-symbols.expsym~\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags$_lt_dar_export_syms$_lt_dsymutil\"\n    m4_if([$1], [CXX],\n[   if test yes != \"$lt_cv_apple_cc_single_mod\"; then\n      _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -r -keep_private_externs -nostdlib -o \\$lib-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$lib-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring$_lt_dsymutil\"\n      _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's|^|_|' < \\$export_symbols > \\$output_objdir/\\$libname-symbols.expsym~\\$CC -r -keep_private_externs -nostdlib -o \\$lib-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$lib-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring$_lt_dar_export_syms$_lt_dsymutil\"\n    fi\n],[])\n  else\n  _LT_TAGVAR(ld_shlibs, $1)=no\n  fi\n])\n\n# _LT_SYS_MODULE_PATH_AIX([TAGNAME])\n# ----------------------------------\n# Links a minimal program and checks the executable\n# for the system default hardcoded library path. In most cases,\n# this is /usr/lib:/lib, but when the MPI compilers are used\n# the location of the communication and MPI libs are included too.\n# If we don't find anything, use the default library path according\n# to the aix ld manual.\n# Store the results from the different compilers for each TAGNAME.\n# Allow to override them for all tags through lt_cv_aix_libpath.\nm4_defun([_LT_SYS_MODULE_PATH_AIX],\n[m4_require([_LT_DECL_SED])dnl\nif test set = \"${lt_cv_aix_libpath+set}\"; then\n  aix_libpath=$lt_cv_aix_libpath\nelse\n  AC_CACHE_VAL([_LT_TAGVAR([lt_cv_aix_libpath_], [$1])],\n  [AC_LINK_IFELSE([AC_LANG_PROGRAM],[\n  lt_aix_libpath_sed='[\n      /Import File Strings/,/^$/ {\n\t  /^0/ {\n\t      s/^0  *\\([^ ]*\\) *$/\\1/\n\t      p\n\t  }\n      }]'\n  _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n  # Check for a 64-bit object if we didn't find anything.\n  if test -z \"$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\"; then\n    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n  fi],[])\n  if test -z \"$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\"; then\n    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=/usr/lib:/lib\n  fi\n  ])\n  aix_libpath=$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\nfi\n])# _LT_SYS_MODULE_PATH_AIX\n\n\n# _LT_SHELL_INIT(ARG)\n# -------------------\nm4_define([_LT_SHELL_INIT],\n[m4_divert_text([M4SH-INIT], [$1\n])])# _LT_SHELL_INIT\n\n\n\n# _LT_PROG_ECHO_BACKSLASH\n# -----------------------\n# Find how we can fake an echo command that does not interpret backslash.\n# In particular, with Autoconf 2.60 or later we add some code to the start\n# of the generated configure script that will find a shell with a builtin\n# printf (that we can use as an echo command).\nm4_defun([_LT_PROG_ECHO_BACKSLASH],\n[ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n\nAC_MSG_CHECKING([how to print strings])\n# Test print first, because it will be a builtin if present.\nif test \"X`( print -r -- -n ) 2>/dev/null`\" = X-n && \\\n   test \"X`print -r -- $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='print -r --'\nelif test \"X`printf %s $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='printf %s\\n'\nelse\n  # Use this function as a fallback that always works.\n  func_fallback_echo ()\n  {\n    eval 'cat <<_LTECHO_EOF\n$[]1\n_LTECHO_EOF'\n  }\n  ECHO='func_fallback_echo'\nfi\n\n# func_echo_all arg...\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\"\n}\n\ncase $ECHO in\n  printf*) AC_MSG_RESULT([printf]) ;;\n  print*) AC_MSG_RESULT([print -r]) ;;\n  *) AC_MSG_RESULT([cat]) ;;\nesac\n\nm4_ifdef([_AS_DETECT_SUGGESTED],\n[_AS_DETECT_SUGGESTED([\n  test -n \"${ZSH_VERSION+set}${BASH_VERSION+set}\" || (\n    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n    PATH=/empty FPATH=/empty; export PATH FPATH\n    test \"X`printf %s $ECHO`\" = \"X$ECHO\" \\\n      || test \"X`print -r -- $ECHO`\" = \"X$ECHO\" )])])\n\n_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])\n_LT_DECL([], [ECHO], [1], [An echo program that protects backslashes])\n])# _LT_PROG_ECHO_BACKSLASH\n\n\n# _LT_WITH_SYSROOT\n# ----------------\nAC_DEFUN([_LT_WITH_SYSROOT],\n[AC_MSG_CHECKING([for sysroot])\nAC_ARG_WITH([sysroot],\n[AS_HELP_STRING([--with-sysroot@<:@=DIR@:>@],\n  [Search for dependent libraries within DIR (or the compiler's sysroot\n   if not specified).])],\n[], [with_sysroot=no])\n\ndnl lt_sysroot will always be passed unquoted.  We quote it here\ndnl in case the user passed a directory name.\nlt_sysroot=\ncase $with_sysroot in #(\n yes)\n   if test yes = \"$GCC\"; then\n     lt_sysroot=`$CC --print-sysroot 2>/dev/null`\n   fi\n   ;; #(\n /*)\n   lt_sysroot=`echo \"$with_sysroot\" | sed -e \"$sed_quote_subst\"`\n   ;; #(\n no|'')\n   ;; #(\n *)\n   AC_MSG_RESULT([$with_sysroot])\n   AC_MSG_ERROR([The sysroot must be an absolute path.])\n   ;;\nesac\n\n AC_MSG_RESULT([${lt_sysroot:-no}])\n_LT_DECL([], [lt_sysroot], [0], [The root where to search for ]dnl\n[dependent libraries, and where our libraries should be installed.])])\n\n# _LT_ENABLE_LOCK\n# ---------------\nm4_defun([_LT_ENABLE_LOCK],\n[AC_ARG_ENABLE([libtool-lock],\n  [AS_HELP_STRING([--disable-libtool-lock],\n    [avoid locking (might break parallel builds)])])\ntest no = \"$enable_libtool_lock\" || enable_libtool_lock=yes\n\n# Some flags need to be propagated to the compiler or linker for good\n# libtool support.\ncase $host in\nia64-*-hpux*)\n  # Find out what ABI is being produced by ac_compile, and set mode\n  # options accordingly.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.$ac_objext` in\n      *ELF-32*)\n\tHPUX_IA64_MODE=32\n\t;;\n      *ELF-64*)\n\tHPUX_IA64_MODE=64\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n*-*-irix6*)\n  # Find out what ABI is being produced by ac_compile, and set linker\n  # options accordingly.\n  echo '[#]line '$LINENO' \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    if test yes = \"$lt_cv_prog_gnu_ld\"; then\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -melf32bsmip\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -melf32bmipn32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -melf64bmip\"\n\t;;\n      esac\n    else\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -32\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -n32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -64\"\n\t  ;;\n      esac\n    fi\n  fi\n  rm -rf conftest*\n  ;;\n\nmips64*-*linux*)\n  # Find out what ABI is being produced by ac_compile, and set linker\n  # options accordingly.\n  echo '[#]line '$LINENO' \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    emul=elf\n    case `/usr/bin/file conftest.$ac_objext` in\n      *32-bit*)\n\temul=\"${emul}32\"\n\t;;\n      *64-bit*)\n\temul=\"${emul}64\"\n\t;;\n    esac\n    case `/usr/bin/file conftest.$ac_objext` in\n      *MSB*)\n\temul=\"${emul}btsmip\"\n\t;;\n      *LSB*)\n\temul=\"${emul}ltsmip\"\n\t;;\n    esac\n    case `/usr/bin/file conftest.$ac_objext` in\n      *N32*)\n\temul=\"${emul}n32\"\n\t;;\n    esac\n    LD=\"${LD-ld} -m $emul\"\n  fi\n  rm -rf conftest*\n  ;;\n\nx86_64-*kfreebsd*-gnu|x86_64-*linux*|powerpc*-*linux*| \\\ns390*-*linux*|s390*-*tpf*|sparc*-*linux*)\n  # Find out what ABI is being produced by ac_compile, and set linker\n  # options accordingly.  Note that the listed cases only cover the\n  # situations where additional linker options are needed (such as when\n  # doing 32-bit compilation for a host where ld defaults to 64-bit, or\n  # vice versa); the common cases where no linker options are needed do\n  # not appear in the list.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n      *32-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_i386_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    case `/usr/bin/file conftest.o` in\n\t      *x86-64*)\n\t\tLD=\"${LD-ld} -m elf32_x86_64\"\n\t\t;;\n\t      *)\n\t\tLD=\"${LD-ld} -m elf_i386\"\n\t\t;;\n\t    esac\n\t    ;;\n\t  powerpc64le-*linux*)\n\t    LD=\"${LD-ld} -m elf32lppclinux\"\n\t    ;;\n\t  powerpc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32ppclinux\"\n\t    ;;\n\t  s390x-*linux*)\n\t    LD=\"${LD-ld} -m elf_s390\"\n\t    ;;\n\t  sparc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32_sparc\"\n\t    ;;\n\tesac\n\t;;\n      *64-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_x86_64_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_x86_64\"\n\t    ;;\n\t  powerpcle-*linux*)\n\t    LD=\"${LD-ld} -m elf64lppc\"\n\t    ;;\n\t  powerpc-*linux*)\n\t    LD=\"${LD-ld} -m elf64ppc\"\n\t    ;;\n\t  s390*-*linux*|s390*-*tpf*)\n\t    LD=\"${LD-ld} -m elf64_s390\"\n\t    ;;\n\t  sparc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64_sparc\"\n\t    ;;\n\tesac\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n\n*-*-sco3.2v5*)\n  # On SCO OpenServer 5, we need -belf to get full-featured binaries.\n  SAVE_CFLAGS=$CFLAGS\n  CFLAGS=\"$CFLAGS -belf\"\n  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,\n    [AC_LANG_PUSH(C)\n     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])\n     AC_LANG_POP])\n  if test yes != \"$lt_cv_cc_needs_belf\"; then\n    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf\n    CFLAGS=$SAVE_CFLAGS\n  fi\n  ;;\n*-*solaris*)\n  # Find out what ABI is being produced by ac_compile, and set linker\n  # options accordingly.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n    *64-bit*)\n      case $lt_cv_prog_gnu_ld in\n      yes*)\n        case $host in\n        i?86-*-solaris*|x86_64-*-solaris*)\n          LD=\"${LD-ld} -m elf_x86_64\"\n          ;;\n        sparc*-*-solaris*)\n          LD=\"${LD-ld} -m elf64_sparc\"\n          ;;\n        esac\n        # GNU ld 2.21 introduced _sol2 emulations.  Use them if available.\n        if ${LD-ld} -V | grep _sol2 >/dev/null 2>&1; then\n          LD=${LD-ld}_sol2\n        fi\n        ;;\n      *)\n\tif ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then\n\t  LD=\"${LD-ld} -64\"\n\tfi\n\t;;\n      esac\n      ;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\nesac\n\nneed_locks=$enable_libtool_lock\n])# _LT_ENABLE_LOCK\n\n\n# _LT_PROG_AR\n# -----------\nm4_defun([_LT_PROG_AR],\n[AC_CHECK_TOOLS(AR, [ar], false)\n: ${AR=ar}\n: ${AR_FLAGS=cru}\n_LT_DECL([], [AR], [1], [The archiver])\n_LT_DECL([], [AR_FLAGS], [1], [Flags to create an archive])\n\nAC_CACHE_CHECK([for archiver @FILE support], [lt_cv_ar_at_file],\n  [lt_cv_ar_at_file=no\n   AC_COMPILE_IFELSE([AC_LANG_PROGRAM],\n     [echo conftest.$ac_objext > conftest.lst\n      lt_ar_try='$AR $AR_FLAGS libconftest.a @conftest.lst >&AS_MESSAGE_LOG_FD'\n      AC_TRY_EVAL([lt_ar_try])\n      if test 0 -eq \"$ac_status\"; then\n\t# Ensure the archiver fails upon bogus file names.\n\trm -f conftest.$ac_objext libconftest.a\n\tAC_TRY_EVAL([lt_ar_try])\n\tif test 0 -ne \"$ac_status\"; then\n          lt_cv_ar_at_file=@\n        fi\n      fi\n      rm -f conftest.* libconftest.a\n     ])\n  ])\n\nif test no = \"$lt_cv_ar_at_file\"; then\n  archiver_list_spec=\nelse\n  archiver_list_spec=$lt_cv_ar_at_file\nfi\n_LT_DECL([], [archiver_list_spec], [1],\n  [How to feed a file listing to the archiver])\n])# _LT_PROG_AR\n\n\n# _LT_CMD_OLD_ARCHIVE\n# -------------------\nm4_defun([_LT_CMD_OLD_ARCHIVE],\n[_LT_PROG_AR\n\nAC_CHECK_TOOL(STRIP, strip, :)\ntest -z \"$STRIP\" && STRIP=:\n_LT_DECL([], [STRIP], [1], [A symbol stripping program])\n\nAC_CHECK_TOOL(RANLIB, ranlib, :)\ntest -z \"$RANLIB\" && RANLIB=:\n_LT_DECL([], [RANLIB], [1],\n    [Commands used to install an old-style archive])\n\n# Determine commands to create old-style static archives.\nold_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'\nold_postinstall_cmds='chmod 644 $oldlib'\nold_postuninstall_cmds=\n\nif test -n \"$RANLIB\"; then\n  case $host_os in\n  bitrig* | openbsd*)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB -t \\$tool_oldlib\"\n    ;;\n  *)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB \\$tool_oldlib\"\n    ;;\n  esac\n  old_archive_cmds=\"$old_archive_cmds~\\$RANLIB \\$tool_oldlib\"\nfi\n\ncase $host_os in\n  darwin*)\n    lock_old_archive_extraction=yes ;;\n  *)\n    lock_old_archive_extraction=no ;;\nesac\n_LT_DECL([], [old_postinstall_cmds], [2])\n_LT_DECL([], [old_postuninstall_cmds], [2])\n_LT_TAGDECL([], [old_archive_cmds], [2],\n    [Commands used to build an old-style archive])\n_LT_DECL([], [lock_old_archive_extraction], [0],\n    [Whether to use a lock for old archive extraction])\n])# _LT_CMD_OLD_ARCHIVE\n\n\n# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#\t\t[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------------------\n# Check whether the given compiler option works\nAC_DEFUN([_LT_COMPILER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n   lt_compiler_flag=\"$3\"  ## exclude from sc_useless_quotes_in_assignment\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   # The option is referenced via a variable to avoid confusing sed.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>conftest.err)\n   ac_status=$?\n   cat conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s \"$ac_outfile\"; then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings other than the usual output.\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' >conftest.exp\n     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then\n       $2=yes\n     fi\n   fi\n   $RM conftest*\n])\n\nif test yes = \"[$]$2\"; then\n    m4_if([$5], , :, [$5])\nelse\n    m4_if([$6], , :, [$6])\nfi\n])# _LT_COMPILER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])\n\n\n# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#                  [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------\n# Check whether the given linker option works\nAC_DEFUN([_LT_LINKER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   save_LDFLAGS=$LDFLAGS\n   LDFLAGS=\"$LDFLAGS $3\"\n   echo \"$lt_simple_link_test_code\" > conftest.$ac_ext\n   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then\n     # The linker can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     if test -s conftest.err; then\n       # Append any errors to the config.log.\n       cat conftest.err 1>&AS_MESSAGE_LOG_FD\n       $ECHO \"$_lt_linker_boilerplate\" | $SED '/^$/d' > conftest.exp\n       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n       if diff conftest.exp conftest.er2 >/dev/null; then\n         $2=yes\n       fi\n     else\n       $2=yes\n     fi\n   fi\n   $RM -r conftest*\n   LDFLAGS=$save_LDFLAGS\n])\n\nif test yes = \"[$]$2\"; then\n    m4_if([$4], , :, [$4])\nelse\n    m4_if([$5], , :, [$5])\nfi\n])# _LT_LINKER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])\n\n\n# LT_CMD_MAX_LEN\n#---------------\nAC_DEFUN([LT_CMD_MAX_LEN],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n# find the maximum length of command line arguments\nAC_MSG_CHECKING([the maximum length of command line arguments])\nAC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl\n  i=0\n  teststring=ABCD\n\n  case $build_os in\n  msdosdjgpp*)\n    # On DJGPP, this test can blow up pretty badly due to problems in libc\n    # (any single argument exceeding 2000 bytes causes a buffer overrun\n    # during glob expansion).  Even if it were fixed, the result of this\n    # check would be larger than it should be.\n    lt_cv_sys_max_cmd_len=12288;    # 12K is about right\n    ;;\n\n  gnu*)\n    # Under GNU Hurd, this test is not required because there is\n    # no limit to the length of command line arguments.\n    # Libtool will interpret -1 as no limit whatsoever\n    lt_cv_sys_max_cmd_len=-1;\n    ;;\n\n  cygwin* | mingw* | cegcc*)\n    # On Win9x/ME, this test blows up -- it succeeds, but takes\n    # about 5 minutes as the teststring grows exponentially.\n    # Worse, since 9x/ME are not pre-emptively multitasking,\n    # you end up with a \"frozen\" computer, even though with patience\n    # the test eventually succeeds (with a max line length of 256k).\n    # Instead, let's just punt: use the minimum linelength reported by\n    # all of the supported platforms: 8192 (on NT/2K/XP).\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  mint*)\n    # On MiNT this can take a long time and run out of memory.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  amigaos*)\n    # On AmigaOS with pdksh, this test takes hours, literally.\n    # So we just punt and use a minimum line length of 8192.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  bitrig* | darwin* | dragonfly* | freebsd* | netbsd* | openbsd*)\n    # This has been around since 386BSD, at least.  Likely further.\n    if test -x /sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`\n    elif test -x /usr/sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`\n    else\n      lt_cv_sys_max_cmd_len=65536\t# usable default for all BSDs\n    fi\n    # And add a safety zone\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    ;;\n\n  interix*)\n    # We know the value 262144 and hardcode it with a safety zone (like BSD)\n    lt_cv_sys_max_cmd_len=196608\n    ;;\n\n  os2*)\n    # The test takes a long time on OS/2.\n    lt_cv_sys_max_cmd_len=8192\n    ;;\n\n  osf*)\n    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure\n    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not\n    # nice to cause kernel panics so lets avoid the loop below.\n    # First set a reasonable default.\n    lt_cv_sys_max_cmd_len=16384\n    #\n    if test -x /sbin/sysconfig; then\n      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in\n        *1*) lt_cv_sys_max_cmd_len=-1 ;;\n      esac\n    fi\n    ;;\n  sco3.2v5*)\n    lt_cv_sys_max_cmd_len=102400\n    ;;\n  sysv5* | sco5v6* | sysv4.2uw2*)\n    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`\n    if test -n \"$kargmax\"; then\n      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[\t ]]//'`\n    else\n      lt_cv_sys_max_cmd_len=32768\n    fi\n    ;;\n  *)\n    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`\n    if test -n \"$lt_cv_sys_max_cmd_len\" && \\\n       test undefined != \"$lt_cv_sys_max_cmd_len\"; then\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    else\n      # Make teststring a little bigger before we do anything with it.\n      # a 1K string should be a reasonable start.\n      for i in 1 2 3 4 5 6 7 8; do\n        teststring=$teststring$teststring\n      done\n      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n      # If test is not a shell built-in, we'll probably end up computing a\n      # maximum length that is only half of the actual maximum length, but\n      # we can't tell.\n      while { test X`env echo \"$teststring$teststring\" 2>/dev/null` \\\n\t         = \"X$teststring$teststring\"; } >/dev/null 2>&1 &&\n\t      test 17 != \"$i\" # 1/2 MB should be enough\n      do\n        i=`expr $i + 1`\n        teststring=$teststring$teststring\n      done\n      # Only check the string length outside the loop.\n      lt_cv_sys_max_cmd_len=`expr \"X$teststring\" : \".*\" 2>&1`\n      teststring=\n      # Add a significant safety factor because C++ compilers can tack on\n      # massive amounts of additional arguments before passing them to the\n      # linker.  It appears as though 1/2 is a usable value.\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n    fi\n    ;;\n  esac\n])\nif test -n \"$lt_cv_sys_max_cmd_len\"; then\n  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)\nelse\n  AC_MSG_RESULT(none)\nfi\nmax_cmd_len=$lt_cv_sys_max_cmd_len\n_LT_DECL([], [max_cmd_len], [0],\n    [What is the maximum length of a command?])\n])# LT_CMD_MAX_LEN\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])\n\n\n# _LT_HEADER_DLFCN\n# ----------------\nm4_defun([_LT_HEADER_DLFCN],\n[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl\n])# _LT_HEADER_DLFCN\n\n\n# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,\n#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)\n# ----------------------------------------------------------------\nm4_defun([_LT_TRY_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test yes = \"$cross_compiling\"; then :\n  [$4]\nelse\n  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n  lt_status=$lt_dlunknown\n  cat > conftest.$ac_ext <<_LT_EOF\n[#line $LINENO \"configure\"\n#include \"confdefs.h\"\n\n#if HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <stdio.h>\n\n#ifdef RTLD_GLOBAL\n#  define LT_DLGLOBAL\t\tRTLD_GLOBAL\n#else\n#  ifdef DL_GLOBAL\n#    define LT_DLGLOBAL\t\tDL_GLOBAL\n#  else\n#    define LT_DLGLOBAL\t\t0\n#  endif\n#endif\n\n/* We may have to define LT_DLLAZY_OR_NOW in the command line if we\n   find out it does not work in some platform. */\n#ifndef LT_DLLAZY_OR_NOW\n#  ifdef RTLD_LAZY\n#    define LT_DLLAZY_OR_NOW\t\tRTLD_LAZY\n#  else\n#    ifdef DL_LAZY\n#      define LT_DLLAZY_OR_NOW\t\tDL_LAZY\n#    else\n#      ifdef RTLD_NOW\n#        define LT_DLLAZY_OR_NOW\tRTLD_NOW\n#      else\n#        ifdef DL_NOW\n#          define LT_DLLAZY_OR_NOW\tDL_NOW\n#        else\n#          define LT_DLLAZY_OR_NOW\t0\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n\n/* When -fvisibility=hidden is used, assume the code has been annotated\n   correspondingly for the symbols needed.  */\n#if defined __GNUC__ && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))\nint fnord () __attribute__((visibility(\"default\")));\n#endif\n\nint fnord () { return 42; }\nint main ()\n{\n  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);\n  int status = $lt_dlunknown;\n\n  if (self)\n    {\n      if (dlsym (self,\"fnord\"))       status = $lt_dlno_uscore;\n      else\n        {\n\t  if (dlsym( self,\"_fnord\"))  status = $lt_dlneed_uscore;\n          else puts (dlerror ());\n\t}\n      /* dlclose (self); */\n    }\n  else\n    puts (dlerror ());\n\n  return status;\n}]\n_LT_EOF\n  if AC_TRY_EVAL(ac_link) && test -s \"conftest$ac_exeext\" 2>/dev/null; then\n    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null\n    lt_status=$?\n    case x$lt_status in\n      x$lt_dlno_uscore) $1 ;;\n      x$lt_dlneed_uscore) $2 ;;\n      x$lt_dlunknown|x*) $3 ;;\n    esac\n  else :\n    # compilation failed\n    $3\n  fi\nfi\nrm -fr conftest*\n])# _LT_TRY_DLOPEN_SELF\n\n\n# LT_SYS_DLOPEN_SELF\n# ------------------\nAC_DEFUN([LT_SYS_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test yes != \"$enable_dlopen\"; then\n  enable_dlopen=unknown\n  enable_dlopen_self=unknown\n  enable_dlopen_self_static=unknown\nelse\n  lt_cv_dlopen=no\n  lt_cv_dlopen_libs=\n\n  case $host_os in\n  beos*)\n    lt_cv_dlopen=load_add_on\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ;;\n\n  mingw* | pw32* | cegcc*)\n    lt_cv_dlopen=LoadLibrary\n    lt_cv_dlopen_libs=\n    ;;\n\n  cygwin*)\n    lt_cv_dlopen=dlopen\n    lt_cv_dlopen_libs=\n    ;;\n\n  darwin*)\n    # if libdl is installed we need to link against it\n    AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=dlopen lt_cv_dlopen_libs=-ldl],[\n    lt_cv_dlopen=dyld\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ])\n    ;;\n\n  tpf*)\n    # Don't try to run any link tests for TPF.  We know it's impossible\n    # because TPF is a cross-compiler, and we know how we open DSOs.\n    lt_cv_dlopen=dlopen\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=no\n    ;;\n\n  *)\n    AC_CHECK_FUNC([shl_load],\n\t  [lt_cv_dlopen=shl_load],\n      [AC_CHECK_LIB([dld], [shl_load],\n\t    [lt_cv_dlopen=shl_load lt_cv_dlopen_libs=-ldld],\n\t[AC_CHECK_FUNC([dlopen],\n\t      [lt_cv_dlopen=dlopen],\n\t  [AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=dlopen lt_cv_dlopen_libs=-ldl],\n\t    [AC_CHECK_LIB([svld], [dlopen],\n\t\t  [lt_cv_dlopen=dlopen lt_cv_dlopen_libs=-lsvld],\n\t      [AC_CHECK_LIB([dld], [dld_link],\n\t\t    [lt_cv_dlopen=dld_link lt_cv_dlopen_libs=-ldld])\n\t      ])\n\t    ])\n\t  ])\n\t])\n      ])\n    ;;\n  esac\n\n  if test no = \"$lt_cv_dlopen\"; then\n    enable_dlopen=no\n  else\n    enable_dlopen=yes\n  fi\n\n  case $lt_cv_dlopen in\n  dlopen)\n    save_CPPFLAGS=$CPPFLAGS\n    test yes = \"$ac_cv_header_dlfcn_h\" && CPPFLAGS=\"$CPPFLAGS -DHAVE_DLFCN_H\"\n\n    save_LDFLAGS=$LDFLAGS\n    wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $export_dynamic_flag_spec\\\"\n\n    save_LIBS=$LIBS\n    LIBS=\"$lt_cv_dlopen_libs $LIBS\"\n\n    AC_CACHE_CHECK([whether a program can dlopen itself],\n\t  lt_cv_dlopen_self, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,\n\t    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)\n    ])\n\n    if test yes = \"$lt_cv_dlopen_self\"; then\n      wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $lt_prog_compiler_static\\\"\n      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],\n\t  lt_cv_dlopen_self_static, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,\n\t    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)\n      ])\n    fi\n\n    CPPFLAGS=$save_CPPFLAGS\n    LDFLAGS=$save_LDFLAGS\n    LIBS=$save_LIBS\n    ;;\n  esac\n\n  case $lt_cv_dlopen_self in\n  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;\n  *) enable_dlopen_self=unknown ;;\n  esac\n\n  case $lt_cv_dlopen_self_static in\n  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;\n  *) enable_dlopen_self_static=unknown ;;\n  esac\nfi\n_LT_DECL([dlopen_support], [enable_dlopen], [0],\n\t [Whether dlopen is supported])\n_LT_DECL([dlopen_self], [enable_dlopen_self], [0],\n\t [Whether dlopen of programs is supported])\n_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],\n\t [Whether dlopen of statically linked programs is supported])\n])# LT_SYS_DLOPEN_SELF\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])\n\n\n# _LT_COMPILER_C_O([TAGNAME])\n# ---------------------------\n# Check to see if options -c and -o are simultaneously supported by compiler.\n# This macro does not hard code the compiler like AC_PROG_CC_C_O.\nm4_defun([_LT_COMPILER_C_O],\n[m4_require([_LT_DECL_SED])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no\n   $RM -r conftest 2>/dev/null\n   mkdir conftest\n   cd conftest\n   mkdir out\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n   lt_compiler_flag=\"-o out/conftest2.$ac_objext\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>out/conftest.err)\n   ac_status=$?\n   cat out/conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s out/conftest2.$ac_objext\n   then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' > out/conftest.exp\n     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2\n     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then\n       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n     fi\n   fi\n   chmod u+w . 2>&AS_MESSAGE_LOG_FD\n   $RM conftest*\n   # SGI C++ compiler will create directory out/ii_files/ for\n   # template instantiation\n   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files\n   $RM out/* && rmdir out\n   cd ..\n   $RM -r conftest\n   $RM conftest*\n])\n_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],\n\t[Does compiler simultaneously support -c and -o options?])\n])# _LT_COMPILER_C_O\n\n\n# _LT_COMPILER_FILE_LOCKS([TAGNAME])\n# ----------------------------------\n# Check to see if we can do hard links to lock some files if needed\nm4_defun([_LT_COMPILER_FILE_LOCKS],\n[m4_require([_LT_ENABLE_LOCK])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_COMPILER_C_O([$1])\n\nhard_links=nottested\nif test no = \"$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)\" && test no != \"$need_locks\"; then\n  # do not overwrite the value of need_locks provided by the user\n  AC_MSG_CHECKING([if we can lock with hard links])\n  hard_links=yes\n  $RM conftest*\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  touch conftest.a\n  ln conftest.a conftest.b 2>&5 || hard_links=no\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  AC_MSG_RESULT([$hard_links])\n  if test no = \"$hard_links\"; then\n    AC_MSG_WARN(['$CC' does not support '-c -o', so 'make -j' may be unsafe])\n    need_locks=warn\n  fi\nelse\n  need_locks=no\nfi\n_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])\n])# _LT_COMPILER_FILE_LOCKS\n\n\n# _LT_CHECK_OBJDIR\n# ----------------\nm4_defun([_LT_CHECK_OBJDIR],\n[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],\n[rm -f .libs 2>/dev/null\nmkdir .libs 2>/dev/null\nif test -d .libs; then\n  lt_cv_objdir=.libs\nelse\n  # MS-DOS does not allow filenames that begin with a dot.\n  lt_cv_objdir=_libs\nfi\nrmdir .libs 2>/dev/null])\nobjdir=$lt_cv_objdir\n_LT_DECL([], [objdir], [0],\n         [The name of the directory that contains temporary libtool files])dnl\nm4_pattern_allow([LT_OBJDIR])dnl\nAC_DEFINE_UNQUOTED([LT_OBJDIR], \"$lt_cv_objdir/\",\n  [Define to the sub-directory where libtool stores uninstalled libraries.])\n])# _LT_CHECK_OBJDIR\n\n\n# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])\n# --------------------------------------\n# Check hardcoding attributes.\nm4_defun([_LT_LINKER_HARDCODE_LIBPATH],\n[AC_MSG_CHECKING([how to hardcode library paths into programs])\n_LT_TAGVAR(hardcode_action, $1)=\nif test -n \"$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\" ||\n   test -n \"$_LT_TAGVAR(runpath_var, $1)\" ||\n   test yes = \"$_LT_TAGVAR(hardcode_automatic, $1)\"; then\n\n  # We can hardcode non-existent directories.\n  if test no != \"$_LT_TAGVAR(hardcode_direct, $1)\" &&\n     # If the only mechanism to avoid hardcoding is shlibpath_var, we\n     # have to relink, otherwise we might link with an installed library\n     # when we should be linking with a yet-to-be-installed one\n     ## test no != \"$_LT_TAGVAR(hardcode_shlibpath_var, $1)\" &&\n     test no != \"$_LT_TAGVAR(hardcode_minus_L, $1)\"; then\n    # Linking always hardcodes the temporary library directory.\n    _LT_TAGVAR(hardcode_action, $1)=relink\n  else\n    # We can link without hardcoding, and we can hardcode nonexisting dirs.\n    _LT_TAGVAR(hardcode_action, $1)=immediate\n  fi\nelse\n  # We cannot hardcode anything, or else we can only hardcode existing\n  # directories.\n  _LT_TAGVAR(hardcode_action, $1)=unsupported\nfi\nAC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])\n\nif test relink = \"$_LT_TAGVAR(hardcode_action, $1)\" ||\n   test yes = \"$_LT_TAGVAR(inherit_rpath, $1)\"; then\n  # Fast installation is not supported\n  enable_fast_install=no\nelif test yes = \"$shlibpath_overrides_runpath\" ||\n     test no = \"$enable_shared\"; then\n  # Fast installation is not necessary\n  enable_fast_install=needless\nfi\n_LT_TAGDECL([], [hardcode_action], [0],\n    [How to hardcode a shared library path into an executable])\n])# _LT_LINKER_HARDCODE_LIBPATH\n\n\n# _LT_CMD_STRIPLIB\n# ----------------\nm4_defun([_LT_CMD_STRIPLIB],\n[m4_require([_LT_DECL_EGREP])\nstriplib=\nold_striplib=\nAC_MSG_CHECKING([whether stripping libraries is possible])\nif test -n \"$STRIP\" && $STRIP -V 2>&1 | $GREP \"GNU strip\" >/dev/null; then\n  test -z \"$old_striplib\" && old_striplib=\"$STRIP --strip-debug\"\n  test -z \"$striplib\" && striplib=\"$STRIP --strip-unneeded\"\n  AC_MSG_RESULT([yes])\nelse\n# FIXME - insert some real tests, host_os isn't really good enough\n  case $host_os in\n  darwin*)\n    if test -n \"$STRIP\"; then\n      striplib=\"$STRIP -x\"\n      old_striplib=\"$STRIP -S\"\n      AC_MSG_RESULT([yes])\n    else\n      AC_MSG_RESULT([no])\n    fi\n    ;;\n  *)\n    AC_MSG_RESULT([no])\n    ;;\n  esac\nfi\n_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])\n_LT_DECL([], [striplib], [1])\n])# _LT_CMD_STRIPLIB\n\n\n# _LT_PREPARE_MUNGE_PATH_LIST\n# ---------------------------\n# Make sure func_munge_path_list() is defined correctly.\nm4_defun([_LT_PREPARE_MUNGE_PATH_LIST],\n[[# func_munge_path_list VARIABLE PATH\n# -----------------------------------\n# VARIABLE is name of variable containing _space_ separated list of\n# directories to be munged by the contents of PATH, which is string\n# having a format:\n# \"DIR[:DIR]:\"\n#       string \"DIR[ DIR]\" will be prepended to VARIABLE\n# \":DIR[:DIR]\"\n#       string \"DIR[ DIR]\" will be appended to VARIABLE\n# \"DIRP[:DIRP]::[DIRA:]DIRA\"\n#       string \"DIRP[ DIRP]\" will be prepended to VARIABLE and string\n#       \"DIRA[ DIRA]\" will be appended to VARIABLE\n# \"DIR[:DIR]\"\n#       VARIABLE will be replaced by \"DIR[ DIR]\"\nfunc_munge_path_list ()\n{\n    case x@S|@2 in\n    x)\n        ;;\n    *:)\n        eval @S|@1=\\\"`$ECHO @S|@2 | $SED 's/:/ /g'` \\@S|@@S|@1\\\"\n        ;;\n    x:*)\n        eval @S|@1=\\\"\\@S|@@S|@1 `$ECHO @S|@2 | $SED 's/:/ /g'`\\\"\n        ;;\n    *::*)\n        eval @S|@1=\\\"\\@S|@@S|@1\\ `$ECHO @S|@2 | $SED -e 's/.*:://' -e 's/:/ /g'`\\\"\n        eval @S|@1=\\\"`$ECHO @S|@2 | $SED -e 's/::.*//' -e 's/:/ /g'`\\ \\@S|@@S|@1\\\"\n        ;;\n    *)\n        eval @S|@1=\\\"`$ECHO @S|@2 | $SED 's/:/ /g'`\\\"\n        ;;\n    esac\n}\n]])# _LT_PREPARE_PATH_LIST\n\n\n# _LT_SYS_DYNAMIC_LINKER([TAG])\n# -----------------------------\n# PORTME Fill in your ld.so characteristics\nm4_defun([_LT_SYS_DYNAMIC_LINKER],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_OBJDUMP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nm4_require([_LT_PREPARE_MUNGE_PATH_LIST])dnl\nAC_MSG_CHECKING([dynamic linker characteristics])\nm4_if([$1],\n\t[], [\nif test yes = \"$GCC\"; then\n  case $host_os in\n    darwin*) lt_awk_arg='/^libraries:/,/LR/' ;;\n    *) lt_awk_arg='/^libraries:/' ;;\n  esac\n  case $host_os in\n    mingw* | cegcc*) lt_sed_strip_eq='s|=\\([[A-Za-z]]:\\)|\\1|g' ;;\n    *) lt_sed_strip_eq='s|=/|/|g' ;;\n  esac\n  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e \"s/^libraries://\" -e $lt_sed_strip_eq`\n  case $lt_search_path_spec in\n  *\\;*)\n    # if the path contains \";\" then we assume it to be the separator\n    # otherwise default to the standard path separator (i.e. \":\") - it is\n    # assumed that no part of a normal pathname contains \";\" but that should\n    # okay in the real world where \";\" in dirpaths is itself problematic.\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED 's/;/ /g'`\n    ;;\n  *)\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED \"s/$PATH_SEPARATOR/ /g\"`\n    ;;\n  esac\n  # Ok, now we have the path, separated by spaces, we can step through it\n  # and add multilib dir if necessary...\n  lt_tmp_lt_search_path_spec=\n  lt_multi_os_dir=/`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`\n  # ...but if some path component already ends with the multilib dir we assume\n  # that all is fine and trust -print-search-dirs as is (GCC 4.2? or newer).\n  case \"$lt_multi_os_dir; $lt_search_path_spec \" in\n  \"/; \"* | \"/.; \"* | \"/./; \"* | *\"$lt_multi_os_dir \"* | *\"$lt_multi_os_dir/ \"*)\n    lt_multi_os_dir=\n    ;;\n  esac\n  for lt_sys_path in $lt_search_path_spec; do\n    if test -d \"$lt_sys_path$lt_multi_os_dir\"; then\n      lt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path$lt_multi_os_dir\"\n    elif test -n \"$lt_multi_os_dir\"; then\n      test -d \"$lt_sys_path\" && \\\n\tlt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path\"\n    fi\n  done\n  lt_search_path_spec=`$ECHO \"$lt_tmp_lt_search_path_spec\" | awk '\nBEGIN {RS = \" \"; FS = \"/|\\n\";} {\n  lt_foo = \"\";\n  lt_count = 0;\n  for (lt_i = NF; lt_i > 0; lt_i--) {\n    if ($lt_i != \"\" && $lt_i != \".\") {\n      if ($lt_i == \"..\") {\n        lt_count++;\n      } else {\n        if (lt_count == 0) {\n          lt_foo = \"/\" $lt_i lt_foo;\n        } else {\n          lt_count--;\n        }\n      }\n    }\n  }\n  if (lt_foo != \"\") { lt_freq[[lt_foo]]++; }\n  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }\n}'`\n  # AWK program above erroneously prepends '/' to C:/dos/paths\n  # for these hosts.\n  case $host_os in\n    mingw* | cegcc*) lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" |\\\n      $SED 's|/\\([[A-Za-z]]:\\)|\\1|g'` ;;\n  esac\n  sys_lib_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $lt_NL2SP`\nelse\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\nfi])\nlibrary_names_spec=\nlibname_spec='lib$name'\nsoname_spec=\nshrext_cmds=.so\npostinstall_cmds=\npostuninstall_cmds=\nfinish_cmds=\nfinish_eval=\nshlibpath_var=\nshlibpath_overrides_runpath=unknown\nversion_type=none\ndynamic_linker=\"$host_os ld.so\"\nsys_lib_dlsearch_path_spec=\"/lib /usr/lib\"\nneed_lib_prefix=unknown\nhardcode_into_libs=no\n\n# when you set need_version to no, make sure it does not cause -set_version\n# flags to be left without arguments\nneed_version=unknown\n\nAC_ARG_VAR([LT_SYS_LIBRARY_PATH],\n[User-defined run-time library search path.])\n\ncase $host_os in\naix3*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='$libname$release$shared_ext$versuffix $libname.a'\n  shlibpath_var=LIBPATH\n\n  # AIX 3 has no versioning support, so we append a major version to the name.\n  soname_spec='$libname$release$shared_ext$major'\n  ;;\n\naix[[4-9]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  hardcode_into_libs=yes\n  if test ia64 = \"$host_cpu\"; then\n    # AIX 5 supports IA64\n    library_names_spec='$libname$release$shared_ext$major $libname$release$shared_ext$versuffix $libname$shared_ext'\n    shlibpath_var=LD_LIBRARY_PATH\n  else\n    # With GCC up to 2.95.x, collect2 would create an import file\n    # for dependence libraries.  The import file would start with\n    # the line '#! .'.  This would cause the generated library to\n    # depend on '.', always an invalid library.  This was fixed in\n    # development snapshots of GCC prior to 3.0.\n    case $host_os in\n      aix4 | aix4.[[01]] | aix4.[[01]].*)\n      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'\n\t   echo ' yes '\n\t   echo '#endif'; } | $CC -E - | $GREP yes > /dev/null; then\n\t:\n      else\n\tcan_build_shared=no\n      fi\n      ;;\n    esac\n    # Using Import Files as archive members, it is possible to support\n    # filename-based versioning of shared library archives on AIX. While\n    # this would work for both with and without runtime linking, it will\n    # prevent static linking of such archives. So we do filename-based\n    # shared library versioning with .so extension only, which is used\n    # when both runtime linking and shared linking is enabled.\n    # Unfortunately, runtime linking may impact performance, so we do\n    # not want this to be the default eventually. Also, we use the\n    # versioned .so libs for executables only if there is the -brtl\n    # linker flag in LDFLAGS as well, or --with-aix-soname=svr4 only.\n    # To allow for filename-based versioning support, we need to create\n    # libNAME.so.V as an archive file, containing:\n    # *) an Import File, referring to the versioned filename of the\n    #    archive as well as the shared archive member, telling the\n    #    bitwidth (32 or 64) of that shared object, and providing the\n    #    list of exported symbols of that shared object, eventually\n    #    decorated with the 'weak' keyword\n    # *) the shared object with the F_LOADONLY flag set, to really avoid\n    #    it being seen by the linker.\n    # At run time we better use the real file rather than another symlink,\n    # but for link time we create the symlink libNAME.so -> libNAME.so.V\n\n    case $with_aix_soname,$aix_use_runtimelinking in\n    # AIX (on Power*) has no versioning support, so currently we cannot hardcode correct\n    # soname into executable. Probably we can add versioning support to\n    # collect2, so additional links can be useful in future.\n    aix,yes) # traditional libtool\n      dynamic_linker='AIX unversionable lib.so'\n      # If using run time linking (on AIX 4.2 or later) use lib<name>.so\n      # instead of lib<name>.a to let people know that these are not\n      # typical AIX shared libraries.\n      library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n      ;;\n    aix,no) # traditional AIX only\n      dynamic_linker='AIX lib.a[(]lib.so.V[)]'\n      # We preserve .a as extension for shared libraries through AIX4.2\n      # and later when we are not doing run time linking.\n      library_names_spec='$libname$release.a $libname.a'\n      soname_spec='$libname$release$shared_ext$major'\n      ;;\n    svr4,*) # full svr4 only\n      dynamic_linker=\"AIX lib.so.V[(]$shared_archive_member_spec.o[)]\"\n      library_names_spec='$libname$release$shared_ext$major $libname$shared_ext'\n      # We do not specify a path in Import Files, so LIBPATH fires.\n      shlibpath_overrides_runpath=yes\n      ;;\n    *,yes) # both, prefer svr4\n      dynamic_linker=\"AIX lib.so.V[(]$shared_archive_member_spec.o[)], lib.a[(]lib.so.V[)]\"\n      library_names_spec='$libname$release$shared_ext$major $libname$shared_ext'\n      # unpreferred sharedlib libNAME.a needs extra handling\n      postinstall_cmds='test -n \"$linkname\" || linkname=\"$realname\"~func_stripname \"\" \".so\" \"$linkname\"~$install_shared_prog \"$dir/$func_stripname_result.$libext\" \"$destdir/$func_stripname_result.$libext\"~test -z \"$tstripme\" || test -z \"$striplib\" || $striplib \"$destdir/$func_stripname_result.$libext\"'\n      postuninstall_cmds='for n in $library_names $old_library; do :; done~func_stripname \"\" \".so\" \"$n\"~test \"$func_stripname_result\" = \"$n\" || func_append rmfiles \" $odir/$func_stripname_result.$libext\"'\n      # We do not specify a path in Import Files, so LIBPATH fires.\n      shlibpath_overrides_runpath=yes\n      ;;\n    *,no) # both, prefer aix\n      dynamic_linker=\"AIX lib.a[(]lib.so.V[)], lib.so.V[(]$shared_archive_member_spec.o[)]\"\n      library_names_spec='$libname$release.a $libname.a'\n      soname_spec='$libname$release$shared_ext$major'\n      # unpreferred sharedlib libNAME.so.V and symlink libNAME.so need extra handling\n      postinstall_cmds='test -z \"$dlname\" || $install_shared_prog $dir/$dlname $destdir/$dlname~test -z \"$tstripme\" || test -z \"$striplib\" || $striplib $destdir/$dlname~test -n \"$linkname\" || linkname=$realname~func_stripname \"\" \".a\" \"$linkname\"~(cd \"$destdir\" && $LN_S -f $dlname $func_stripname_result.so)'\n      postuninstall_cmds='test -z \"$dlname\" || func_append rmfiles \" $odir/$dlname\"~for n in $old_library $library_names; do :; done~func_stripname \"\" \".a\" \"$n\"~func_append rmfiles \" $odir/$func_stripname_result.so\"'\n      ;;\n    esac\n    shlibpath_var=LIBPATH\n  fi\n  ;;\n\namigaos*)\n  case $host_cpu in\n  powerpc)\n    # Since July 2007 AmigaOS4 officially supports .so libraries.\n    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n    ;;\n  m68k)\n    library_names_spec='$libname.ixlibrary $libname.a'\n    # Create ${libname}_ixlibrary.a entries in /sys/libs.\n    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all \"$lib\" | $SED '\\''s%^.*/\\([[^/]]*\\)\\.ixlibrary$%\\1%'\\''`; $RM /sys/libs/${libname}_ixlibrary.a; $show \"cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a\"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'\n    ;;\n  esac\n  ;;\n\nbeos*)\n  library_names_spec='$libname$shared_ext'\n  dynamic_linker=\"$host_os ld.so\"\n  shlibpath_var=LIBRARY_PATH\n  ;;\n\nbsdi[[45]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=\"/shlib /usr/lib /usr/local/lib\"\n  # the default ld.so.conf also contains /usr/contrib/lib and\n  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow\n  # libtool to hard-code these into programs\n  ;;\n\ncygwin* | mingw* | pw32* | cegcc*)\n  version_type=windows\n  shrext_cmds=.dll\n  need_version=no\n  need_lib_prefix=no\n\n  case $GCC,$cc_basename in\n  yes,*)\n    # gcc\n    library_names_spec='$libname.dll.a'\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\$file`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\$base_file'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname~\n      chmod a+x \\$dldir/$dlname~\n      if test -n '\\''$stripme'\\'' && test -n '\\''$striplib'\\''; then\n        eval '\\''$striplib \\$dldir/$dlname'\\'' || exit \\$?;\n      fi'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n\n    case $host_os in\n    cygwin*)\n      # Cygwin DLLs use 'cyg' prefix rather than 'lib'\n      soname_spec='`echo $libname | sed -e 's/^lib/cyg/'``echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'\nm4_if([$1], [],[\n      sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/lib/w32api\"])\n      ;;\n    mingw* | cegcc*)\n      # MinGW DLLs use traditional 'lib' prefix\n      soname_spec='$libname`echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'\n      ;;\n    pw32*)\n      # pw32 DLLs use 'pw' prefix rather than 'lib'\n      library_names_spec='`echo $libname | sed -e 's/^lib/pw/'``echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'\n      ;;\n    esac\n    dynamic_linker='Win32 ld.exe'\n    ;;\n\n  *,cl*)\n    # Native MSVC\n    libname_spec='$name'\n    soname_spec='$libname`echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'\n    library_names_spec='$libname.dll.lib'\n\n    case $build_os in\n    mingw*)\n      sys_lib_search_path_spec=\n      lt_save_ifs=$IFS\n      IFS=';'\n      for lt_path in $LIB\n      do\n        IFS=$lt_save_ifs\n        # Let DOS variable expansion print the short 8.3 style file name.\n        lt_path=`cd \"$lt_path\" 2>/dev/null && cmd //C \"for %i in (\".\") do @echo %~si\"`\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec $lt_path\"\n      done\n      IFS=$lt_save_ifs\n      # Convert to MSYS style.\n      sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | sed -e 's|\\\\\\\\|/|g' -e 's| \\\\([[a-zA-Z]]\\\\):| /\\\\1|g' -e 's|^ ||'`\n      ;;\n    cygwin*)\n      # Convert to unix form, then to dos form, then back to unix form\n      # but this time dos style (no spaces!) so that the unix form looks\n      # like /cygdrive/c/PROGRA~1:/cygdr...\n      sys_lib_search_path_spec=`cygpath --path --unix \"$LIB\"`\n      sys_lib_search_path_spec=`cygpath --path --dos \"$sys_lib_search_path_spec\" 2>/dev/null`\n      sys_lib_search_path_spec=`cygpath --path --unix \"$sys_lib_search_path_spec\" | $SED -e \"s/$PATH_SEPARATOR/ /g\"`\n      ;;\n    *)\n      sys_lib_search_path_spec=$LIB\n      if $ECHO \"$sys_lib_search_path_spec\" | [$GREP ';[c-zC-Z]:/' >/dev/null]; then\n        # It is most probably a Windows format PATH.\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e 's/;/ /g'`\n      else\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e \"s/$PATH_SEPARATOR/ /g\"`\n      fi\n      # FIXME: find the short name or the path components, as spaces are\n      # common. (e.g. \"Program Files\" -> \"PROGRA~1\")\n      ;;\n    esac\n\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\$file`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\$base_file'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n    dynamic_linker='Win32 link.exe'\n    ;;\n\n  *)\n    # Assume MSVC wrapper\n    library_names_spec='$libname`echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext $libname.lib'\n    dynamic_linker='Win32 ld.exe'\n    ;;\n  esac\n  # FIXME: first we should search . and the directory the executable is in\n  shlibpath_var=PATH\n  ;;\n\ndarwin* | rhapsody*)\n  dynamic_linker=\"$host_os dyld\"\n  version_type=darwin\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$major$shared_ext $libname$shared_ext'\n  soname_spec='$libname$release$major$shared_ext'\n  shlibpath_overrides_runpath=yes\n  shlibpath_var=DYLD_LIBRARY_PATH\n  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'\nm4_if([$1], [],[\n  sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/local/lib\"])\n  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'\n  ;;\n\ndgux*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\nfreebsd* | dragonfly*)\n  # DragonFly does not have aout.  When/if they implement a new\n  # versioning mechanism, adjust this.\n  if test -x /usr/bin/objformat; then\n    objformat=`/usr/bin/objformat`\n  else\n    case $host_os in\n    freebsd[[23]].*) objformat=aout ;;\n    *) objformat=elf ;;\n    esac\n  fi\n  version_type=freebsd-$objformat\n  case $version_type in\n    freebsd-elf*)\n      library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n      soname_spec='$libname$release$shared_ext$major'\n      need_version=no\n      need_lib_prefix=no\n      ;;\n    freebsd-*)\n      library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'\n      need_version=yes\n      ;;\n  esac\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_os in\n  freebsd2.*)\n    shlibpath_overrides_runpath=yes\n    ;;\n  freebsd3.[[01]]* | freebsdelf3.[[01]]*)\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \\\n  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)\n    shlibpath_overrides_runpath=no\n    hardcode_into_libs=yes\n    ;;\n  *) # from 4.6 on, and DragonFly\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  esac\n  ;;\n\nhaiku*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  dynamic_linker=\"$host_os runtime_loader\"\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'\n  hardcode_into_libs=yes\n  ;;\n\nhpux9* | hpux10* | hpux11*)\n  # Give a soname corresponding to the major version so that dld.sl refuses to\n  # link against other versions.\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  case $host_cpu in\n  ia64*)\n    shrext_cmds='.so'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.so\"\n    shlibpath_var=LD_LIBRARY_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n    soname_spec='$libname$release$shared_ext$major'\n    if test 32 = \"$HPUX_IA64_MODE\"; then\n      sys_lib_search_path_spec=\"/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib\"\n      sys_lib_dlsearch_path_spec=/usr/lib/hpux32\n    else\n      sys_lib_search_path_spec=\"/usr/lib/hpux64 /usr/local/lib/hpux64\"\n      sys_lib_dlsearch_path_spec=/usr/lib/hpux64\n    fi\n    ;;\n  hppa*64*)\n    shrext_cmds='.sl'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n    soname_spec='$libname$release$shared_ext$major'\n    sys_lib_search_path_spec=\"/usr/lib/pa20_64 /usr/ccs/lib/pa20_64\"\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  *)\n    shrext_cmds='.sl'\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=SHLIB_PATH\n    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n    soname_spec='$libname$release$shared_ext$major'\n    ;;\n  esac\n  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...\n  postinstall_cmds='chmod 555 $lib'\n  # or fails outright, so override atomically:\n  install_override_mode=555\n  ;;\n\ninterix[[3-9]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $host_os in\n    nonstopux*) version_type=nonstopux ;;\n    *)\n\tif test yes = \"$lt_cv_prog_gnu_ld\"; then\n\t\tversion_type=linux # correct to gnu/linux during the next big refactor\n\telse\n\t\tversion_type=irix\n\tfi ;;\n  esac\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='$libname$release$shared_ext$major'\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$release$shared_ext $libname$shared_ext'\n  case $host_os in\n  irix5* | nonstopux*)\n    libsuff= shlibsuff=\n    ;;\n  *)\n    case $LD in # libtool.m4 will add one of these switches to LD\n    *-32|*\"-32 \"|*-melf32bsmip|*\"-melf32bsmip \")\n      libsuff= shlibsuff= libmagic=32-bit;;\n    *-n32|*\"-n32 \"|*-melf32bmipn32|*\"-melf32bmipn32 \")\n      libsuff=32 shlibsuff=N32 libmagic=N32;;\n    *-64|*\"-64 \"|*-melf64bmip|*\"-melf64bmip \")\n      libsuff=64 shlibsuff=64 libmagic=64-bit;;\n    *) libsuff= shlibsuff= libmagic=never-match;;\n    esac\n    ;;\n  esac\n  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_search_path_spec=\"/usr/lib$libsuff /lib$libsuff /usr/local/lib$libsuff\"\n  sys_lib_dlsearch_path_spec=\"/usr/lib$libsuff /lib$libsuff\"\n  hardcode_into_libs=yes\n  ;;\n\n# No shared lib support for Linux oldld, aout, or coff.\nlinux*oldld* | linux*aout* | linux*coff*)\n  dynamic_linker=no\n  ;;\n\nlinux*android*)\n  version_type=none # Android doesn't support versioned libraries.\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext'\n  soname_spec='$libname$release$shared_ext'\n  finish_cmds=\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n\n  dynamic_linker='Android linker'\n  # Don't embed -rpath directories since the linker doesn't support them.\n  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n  ;;\n\n# This must be glibc/ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -n $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n\n  # Some binutils ld are patched to set DT_RUNPATH\n  AC_CACHE_VAL([lt_cv_shlibpath_overrides_runpath],\n    [lt_cv_shlibpath_overrides_runpath=no\n    save_LDFLAGS=$LDFLAGS\n    save_libdir=$libdir\n    eval \"libdir=/foo; wl=\\\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\\\"; \\\n\t LDFLAGS=\\\"\\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\\\"\"\n    AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n      [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep \"RUNPATH.*$libdir\" >/dev/null],\n\t [lt_cv_shlibpath_overrides_runpath=yes])])\n    LDFLAGS=$save_LDFLAGS\n    libdir=$save_libdir\n    ])\n  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath\n\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n\n  # Ideally, we could use ldconfig to report *all* directores which are\n  # searched for libraries, however this is still not possible.  Aside from not\n  # being certain /sbin/ldconfig is available, command\n  # 'ldconfig -N -X -v | grep ^/' on 64bit Fedora does not report /usr/lib64,\n  # even though it is searched at run-time.  Try to do the best guess by\n  # appending ld.so.conf contents (and includes) to the search path.\n  if test -f /etc/ld.so.conf; then\n    lt_ld_extra=`awk '/^include / { system(sprintf(\"cd /etc; cat %s 2>/dev/null\", \\[$]2)); skip = 1; } { if (!skip) print \\[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[\t ]*hwcap[\t ]/d;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/\"//g;/^$/d' | tr '\\n' ' '`\n    sys_lib_dlsearch_path_spec=\"/lib /usr/lib $lt_ld_extra\"\n  fi\n\n  # We used to test for /lib/ld.so.1 and disable shared libraries on\n  # powerpc, because MkLinux only supported shared libraries with the\n  # GNU dynamic linker.  Since this was broken with cross compilers,\n  # most powerpc-linux boxes support dynamic linking these days and\n  # people can always --disable-shared, the test was removed, and we\n  # assume the GNU/Linux dynamic linker is in use.\n  dynamic_linker='GNU/Linux ld.so'\n  ;;\n\nnetbsdelf*-gnu)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='NetBSD ld.elf_so'\n  ;;\n\nnetbsd*)\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'\n    finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n    dynamic_linker='NetBSD (a.out) ld.so'\n  else\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n    soname_spec='$libname$release$shared_ext$major'\n    dynamic_linker='NetBSD ld.elf_so'\n  fi\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  ;;\n\nnewsos6)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\n*nto* | *qnx*)\n  version_type=qnx\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='ldqnx.so'\n  ;;\n\nopenbsd* | bitrig*)\n  version_type=sunos\n  sys_lib_dlsearch_path_spec=/usr/lib\n  need_lib_prefix=no\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\"; then\n    need_version=no\n  else\n    need_version=yes\n  fi\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\nos2*)\n  libname_spec='$name'\n  version_type=windows\n  shrext_cmds=.dll\n  need_version=no\n  need_lib_prefix=no\n  # OS/2 can only load a DLL with a base name of 8 characters or less.\n  soname_spec='`test -n \"$os2dllname\" && libname=\"$os2dllname\";\n    v=$($ECHO $release$versuffix | tr -d .-);\n    n=$($ECHO $libname | cut -b -$((8 - ${#v})) | tr . _);\n    $ECHO $n$v`$shared_ext'\n  library_names_spec='${libname}_dll.$libext'\n  dynamic_linker='OS/2 ld.exe'\n  shlibpath_var=BEGINLIBPATH\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n  postinstall_cmds='base_file=`basename \\$file`~\n    dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\$base_file'\\''i; $ECHO \\$dlname'\\''`~\n    dldir=$destdir/`dirname \\$dlpath`~\n    test -d \\$dldir || mkdir -p \\$dldir~\n    $install_prog $dir/$dlname \\$dldir/$dlname~\n    chmod a+x \\$dldir/$dlname~\n    if test -n '\\''$stripme'\\'' && test -n '\\''$striplib'\\''; then\n      eval '\\''$striplib \\$dldir/$dlname'\\'' || exit \\$?;\n    fi'\n  postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; $ECHO \\$dlname'\\''`~\n    dlpath=$dir/\\$dldll~\n    $RM \\$dlpath'\n  ;;\n\nosf3* | osf4* | osf5*)\n  version_type=osf\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='$libname$release$shared_ext$major'\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib\"\n  sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n  ;;\n\nrdos*)\n  dynamic_linker=no\n  ;;\n\nsolaris*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  # ldd complains unless libraries are executable\n  postinstall_cmds='chmod +x $lib'\n  ;;\n\nsunos4*)\n  version_type=sunos\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/usr/etc\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  if test yes = \"$with_gnu_ld\"; then\n    need_lib_prefix=no\n  fi\n  need_version=yes\n  ;;\n\nsysv4 | sysv4.3*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_vendor in\n    sni)\n      shlibpath_overrides_runpath=no\n      need_lib_prefix=no\n      runpath_var=LD_RUN_PATH\n      ;;\n    siemens)\n      need_lib_prefix=no\n      ;;\n    motorola)\n      need_lib_prefix=no\n      need_version=no\n      shlibpath_overrides_runpath=no\n      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'\n      ;;\n  esac\n  ;;\n\nsysv4*MP*)\n  if test -d /usr/nec; then\n    version_type=linux # correct to gnu/linux during the next big refactor\n    library_names_spec='$libname$shared_ext.$versuffix $libname$shared_ext.$major $libname$shared_ext'\n    soname_spec='$libname$shared_ext.$major'\n    shlibpath_var=LD_LIBRARY_PATH\n  fi\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  version_type=sco\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  if test yes = \"$with_gnu_ld\"; then\n    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'\n  else\n    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'\n    case $host_os in\n      sco3.2v5*)\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec /lib\"\n\t;;\n    esac\n  fi\n  sys_lib_dlsearch_path_spec='/usr/lib'\n  ;;\n\ntpf*)\n  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nuts4*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\n*)\n  dynamic_linker=no\n  ;;\nesac\nAC_MSG_RESULT([$dynamic_linker])\ntest no = \"$dynamic_linker\" && can_build_shared=no\n\nvariables_saved_for_relink=\"PATH $shlibpath_var $runpath_var\"\nif test yes = \"$GCC\"; then\n  variables_saved_for_relink=\"$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH\"\nfi\n\nif test set = \"${lt_cv_sys_lib_search_path_spec+set}\"; then\n  sys_lib_search_path_spec=$lt_cv_sys_lib_search_path_spec\nfi\n\nif test set = \"${lt_cv_sys_lib_dlsearch_path_spec+set}\"; then\n  sys_lib_dlsearch_path_spec=$lt_cv_sys_lib_dlsearch_path_spec\nfi\n\n# remember unaugmented sys_lib_dlsearch_path content for libtool script decls...\nconfigure_time_dlsearch_path=$sys_lib_dlsearch_path_spec\n\n# ... but it needs LT_SYS_LIBRARY_PATH munging for other configure-time code\nfunc_munge_path_list sys_lib_dlsearch_path_spec \"$LT_SYS_LIBRARY_PATH\"\n\n# to be used as default LT_SYS_LIBRARY_PATH value in generated libtool\nconfigure_time_lt_sys_library_path=$LT_SYS_LIBRARY_PATH\n\n_LT_DECL([], [variables_saved_for_relink], [1],\n    [Variables whose values should be saved in libtool wrapper scripts and\n    restored at link time])\n_LT_DECL([], [need_lib_prefix], [0],\n    [Do we need the \"lib\" prefix for modules?])\n_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])\n_LT_DECL([], [version_type], [0], [Library versioning type])\n_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])\n_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])\n_LT_DECL([], [shlibpath_overrides_runpath], [0],\n    [Is shlibpath searched before the hard-coded library search path?])\n_LT_DECL([], [libname_spec], [1], [Format of library name prefix])\n_LT_DECL([], [library_names_spec], [1],\n    [[List of archive names.  First name is the real one, the rest are links.\n    The last name is the one that the linker finds with -lNAME]])\n_LT_DECL([], [soname_spec], [1],\n    [[The coded name of the library, if different from the real name]])\n_LT_DECL([], [install_override_mode], [1],\n    [Permission mode override for installation of shared libraries])\n_LT_DECL([], [postinstall_cmds], [2],\n    [Command to use after installation of a shared archive])\n_LT_DECL([], [postuninstall_cmds], [2],\n    [Command to use after uninstallation of a shared archive])\n_LT_DECL([], [finish_cmds], [2],\n    [Commands used to finish a libtool library installation in a directory])\n_LT_DECL([], [finish_eval], [1],\n    [[As \"finish_cmds\", except a single script fragment to be evaled but\n    not shown]])\n_LT_DECL([], [hardcode_into_libs], [0],\n    [Whether we should hardcode library paths into libraries])\n_LT_DECL([], [sys_lib_search_path_spec], [2],\n    [Compile-time system search path for libraries])\n_LT_DECL([sys_lib_dlsearch_path_spec], [configure_time_dlsearch_path], [2],\n    [Detected run-time system search path for libraries])\n_LT_DECL([], [configure_time_lt_sys_library_path], [2],\n    [Explicit LT_SYS_LIBRARY_PATH set during ./configure time])\n])# _LT_SYS_DYNAMIC_LINKER\n\n\n# _LT_PATH_TOOL_PREFIX(TOOL)\n# --------------------------\n# find a file program that can recognize shared library\nAC_DEFUN([_LT_PATH_TOOL_PREFIX],\n[m4_require([_LT_DECL_EGREP])dnl\nAC_MSG_CHECKING([for $1])\nAC_CACHE_VAL(lt_cv_path_MAGIC_CMD,\n[case $MAGIC_CMD in\n[[\\\\/*] |  ?:[\\\\/]*])\n  lt_cv_path_MAGIC_CMD=$MAGIC_CMD # Let the user override the test with a path.\n  ;;\n*)\n  lt_save_MAGIC_CMD=$MAGIC_CMD\n  lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR\ndnl $ac_dummy forces splitting on constant user-supplied paths.\ndnl POSIX.2 word splitting is done only on the output of word expansions,\ndnl not every word.  This closes a longstanding sh security hole.\n  ac_dummy=\"m4_if([$2], , $PATH, [$2])\"\n  for ac_dir in $ac_dummy; do\n    IFS=$lt_save_ifs\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$1\"; then\n      lt_cv_path_MAGIC_CMD=$ac_dir/\"$1\"\n      if test -n \"$file_magic_test_file\"; then\n\tcase $deplibs_check_method in\n\t\"file_magic \"*)\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"file_magic \\(.*\\)\"`\n\t  MAGIC_CMD=$lt_cv_path_MAGIC_CMD\n\t  if eval $file_magic_cmd \\$file_magic_test_file 2> /dev/null |\n\t    $EGREP \"$file_magic_regex\" > /dev/null; then\n\t    :\n\t  else\n\t    cat <<_LT_EOF 1>&2\n\n*** Warning: the command libtool uses to detect shared libraries,\n*** $file_magic_cmd, produces output that libtool cannot recognize.\n*** The result is that libtool may fail to recognize shared libraries\n*** as such.  This will affect the creation of libtool libraries that\n*** depend on shared libraries, but programs linked with such libtool\n*** libraries will work regardless of this problem.  Nevertheless, you\n*** may want to report the problem to your system manager and/or to\n*** bug-libtool@gnu.org\n\n_LT_EOF\n\t  fi ;;\n\tesac\n      fi\n      break\n    fi\n  done\n  IFS=$lt_save_ifs\n  MAGIC_CMD=$lt_save_MAGIC_CMD\n  ;;\nesac])\nMAGIC_CMD=$lt_cv_path_MAGIC_CMD\nif test -n \"$MAGIC_CMD\"; then\n  AC_MSG_RESULT($MAGIC_CMD)\nelse\n  AC_MSG_RESULT(no)\nfi\n_LT_DECL([], [MAGIC_CMD], [0],\n\t [Used to examine libraries when file_magic_cmd begins with \"file\"])dnl\n])# _LT_PATH_TOOL_PREFIX\n\n# Old name:\nAU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])\n\n\n# _LT_PATH_MAGIC\n# --------------\n# find a file program that can recognize a shared library\nm4_defun([_LT_PATH_MAGIC],\n[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)\nif test -z \"$lt_cv_path_MAGIC_CMD\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)\n  else\n    MAGIC_CMD=:\n  fi\nfi\n])# _LT_PATH_MAGIC\n\n\n# LT_PATH_LD\n# ----------\n# find the pathname to the GNU or non-GNU linker\nAC_DEFUN([LT_PATH_LD],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PROG_ECHO_BACKSLASH])dnl\n\nAC_ARG_WITH([gnu-ld],\n    [AS_HELP_STRING([--with-gnu-ld],\n\t[assume the C compiler uses GNU ld @<:@default=no@:>@])],\n    [test no = \"$withval\" || with_gnu_ld=yes],\n    [with_gnu_ld=no])dnl\n\nac_prog=ld\nif test yes = \"$GCC\"; then\n  # Check if gcc -print-prog-name=ld gives a path.\n  AC_MSG_CHECKING([for ld used by $CC])\n  case $host in\n  *-*-mingw*)\n    # gcc leaves a trailing carriage return, which upsets mingw\n    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\\015'` ;;\n  *)\n    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;\n  esac\n  case $ac_prog in\n    # Accept absolute paths.\n    [[\\\\/]]* | ?:[[\\\\/]]*)\n      re_direlt='/[[^/]][[^/]]*/\\.\\./'\n      # Canonicalize the pathname of ld\n      ac_prog=`$ECHO \"$ac_prog\"| $SED 's%\\\\\\\\%/%g'`\n      while $ECHO \"$ac_prog\" | $GREP \"$re_direlt\" > /dev/null 2>&1; do\n\tac_prog=`$ECHO $ac_prog| $SED \"s%$re_direlt%/%\"`\n      done\n      test -z \"$LD\" && LD=$ac_prog\n      ;;\n  \"\")\n    # If it fails, then pretend we aren't using GCC.\n    ac_prog=ld\n    ;;\n  *)\n    # If it is relative, then search for the first ld in PATH.\n    with_gnu_ld=unknown\n    ;;\n  esac\nelif test yes = \"$with_gnu_ld\"; then\n  AC_MSG_CHECKING([for GNU ld])\nelse\n  AC_MSG_CHECKING([for non-GNU ld])\nfi\nAC_CACHE_VAL(lt_cv_path_LD,\n[if test -z \"$LD\"; then\n  lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR\n  for ac_dir in $PATH; do\n    IFS=$lt_save_ifs\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n      lt_cv_path_LD=$ac_dir/$ac_prog\n      # Check to see if the program is GNU ld.  I'd rather use --version,\n      # but apparently some variants of GNU ld only accept -v.\n      # Break only if it was the GNU/non-GNU ld that we prefer.\n      case `\"$lt_cv_path_LD\" -v 2>&1 </dev/null` in\n      *GNU* | *'with BFD'*)\n\ttest no != \"$with_gnu_ld\" && break\n\t;;\n      *)\n\ttest yes != \"$with_gnu_ld\" && break\n\t;;\n      esac\n    fi\n  done\n  IFS=$lt_save_ifs\nelse\n  lt_cv_path_LD=$LD # Let the user override the test with a path.\nfi])\nLD=$lt_cv_path_LD\nif test -n \"$LD\"; then\n  AC_MSG_RESULT($LD)\nelse\n  AC_MSG_RESULT(no)\nfi\ntest -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\n_LT_PATH_LD_GNU\nAC_SUBST([LD])\n\n_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])\n])# LT_PATH_LD\n\n# Old names:\nAU_ALIAS([AM_PROG_LD], [LT_PATH_LD])\nAU_ALIAS([AC_PROG_LD], [LT_PATH_LD])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_LD], [])\ndnl AC_DEFUN([AC_PROG_LD], [])\n\n\n# _LT_PATH_LD_GNU\n#- --------------\nm4_defun([_LT_PATH_LD_GNU],\n[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,\n[# I'd rather use --version here, but apparently some GNU lds only accept -v.\ncase `$LD -v 2>&1 </dev/null` in\n*GNU* | *'with BFD'*)\n  lt_cv_prog_gnu_ld=yes\n  ;;\n*)\n  lt_cv_prog_gnu_ld=no\n  ;;\nesac])\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n])# _LT_PATH_LD_GNU\n\n\n# _LT_CMD_RELOAD\n# --------------\n# find reload flag for linker\n#   -- PORTME Some linkers may need a different reload flag.\nm4_defun([_LT_CMD_RELOAD],\n[AC_CACHE_CHECK([for $LD option to reload object files],\n  lt_cv_ld_reload_flag,\n  [lt_cv_ld_reload_flag='-r'])\nreload_flag=$lt_cv_ld_reload_flag\ncase $reload_flag in\n\"\" | \" \"*) ;;\n*) reload_flag=\" $reload_flag\" ;;\nesac\nreload_cmds='$LD$reload_flag -o $output$reload_objs'\ncase $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    if test yes != \"$GCC\"; then\n      reload_cmds=false\n    fi\n    ;;\n  darwin*)\n    if test yes = \"$GCC\"; then\n      reload_cmds='$LTCC $LTCFLAGS -nostdlib $wl-r -o $output$reload_objs'\n    else\n      reload_cmds='$LD$reload_flag -o $output$reload_objs'\n    fi\n    ;;\nesac\n_LT_TAGDECL([], [reload_flag], [1], [How to create reloadable object files])dnl\n_LT_TAGDECL([], [reload_cmds], [2])dnl\n])# _LT_CMD_RELOAD\n\n\n# _LT_PATH_DD\n# -----------\n# find a working dd\nm4_defun([_LT_PATH_DD],\n[AC_CACHE_CHECK([for a working dd], [ac_cv_path_lt_DD],\n[printf 0123456789abcdef0123456789abcdef >conftest.i\ncat conftest.i conftest.i >conftest2.i\n: ${lt_DD:=$DD}\nAC_PATH_PROGS_FEATURE_CHECK([lt_DD], [dd],\n[if \"$ac_path_lt_DD\" bs=32 count=1 <conftest2.i >conftest.out 2>/dev/null; then\n  cmp -s conftest.i conftest.out \\\n  && ac_cv_path_lt_DD=\"$ac_path_lt_DD\" ac_path_lt_DD_found=:\nfi])\nrm -f conftest.i conftest2.i conftest.out])\n])# _LT_PATH_DD\n\n\n# _LT_CMD_TRUNCATE\n# ----------------\n# find command to truncate a binary pipe\nm4_defun([_LT_CMD_TRUNCATE],\n[m4_require([_LT_PATH_DD])\nAC_CACHE_CHECK([how to truncate binary pipes], [lt_cv_truncate_bin],\n[printf 0123456789abcdef0123456789abcdef >conftest.i\ncat conftest.i conftest.i >conftest2.i\nlt_cv_truncate_bin=\nif \"$ac_cv_path_lt_DD\" bs=32 count=1 <conftest2.i >conftest.out 2>/dev/null; then\n  cmp -s conftest.i conftest.out \\\n  && lt_cv_truncate_bin=\"$ac_cv_path_lt_DD bs=4096 count=1\"\nfi\nrm -f conftest.i conftest2.i conftest.out\ntest -z \"$lt_cv_truncate_bin\" && lt_cv_truncate_bin=\"$SED -e 4q\"])\n_LT_DECL([lt_truncate_bin], [lt_cv_truncate_bin], [1],\n  [Command to truncate a binary pipe])\n])# _LT_CMD_TRUNCATE\n\n\n# _LT_CHECK_MAGIC_METHOD\n# ----------------------\n# how to check for library dependencies\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_MAGIC_METHOD],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nAC_CACHE_CHECK([how to recognize dependent libraries],\nlt_cv_deplibs_check_method,\n[lt_cv_file_magic_cmd='$MAGIC_CMD'\nlt_cv_file_magic_test_file=\nlt_cv_deplibs_check_method='unknown'\n# Need to set the preceding variable on all platforms that support\n# interlibrary dependencies.\n# 'none' -- dependencies not supported.\n# 'unknown' -- same as none, but documents that we really don't know.\n# 'pass_all' -- all dependencies passed with no checks.\n# 'test_compile' -- check by making test program.\n# 'file_magic [[regex]]' -- check by looking for files in library path\n# that responds to the $file_magic_cmd with a given extended regex.\n# If you have 'file' or equivalent on your system and you're not sure\n# whether 'pass_all' will *always* work, you probably want this one.\n\ncase $host_os in\naix[[4-9]]*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbeos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbsdi[[45]]*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'\n  lt_cv_file_magic_cmd='/usr/bin/file -L'\n  lt_cv_file_magic_test_file=/shlib/libc.so\n  ;;\n\ncygwin*)\n  # func_win32_libid is a shell function defined in ltmain.sh\n  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n  lt_cv_file_magic_cmd='func_win32_libid'\n  ;;\n\nmingw* | pw32*)\n  # Base MSYS/MinGW do not provide the 'file' command needed by\n  # func_win32_libid shell function, so use a weaker test based on 'objdump',\n  # unless we find 'file', for example because we are cross-compiling.\n  if ( file / ) >/dev/null 2>&1; then\n    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n    lt_cv_file_magic_cmd='func_win32_libid'\n  else\n    # Keep this pattern in sync with the one in func_win32_libid.\n    lt_cv_deplibs_check_method='file_magic file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)'\n    lt_cv_file_magic_cmd='$OBJDUMP -f'\n  fi\n  ;;\n\ncegcc*)\n  # use the weaker test based on 'objdump'. See mingw*.\n  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'\n  lt_cv_file_magic_cmd='$OBJDUMP -f'\n  ;;\n\ndarwin* | rhapsody*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nfreebsd* | dragonfly*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    case $host_cpu in\n    i*86 )\n      # Not sure whether the presence of OpenBSD here was a mistake.\n      # Let's accept both of them until this is cleared up.\n      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'\n      lt_cv_file_magic_cmd=/usr/bin/file\n      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`\n      ;;\n    esac\n  else\n    lt_cv_deplibs_check_method=pass_all\n  fi\n  ;;\n\nhaiku*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhpux10.20* | hpux11*)\n  lt_cv_file_magic_cmd=/usr/bin/file\n  case $host_cpu in\n  ia64*)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'\n    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so\n    ;;\n  hppa*64*)\n    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\\.[0-9]']\n    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl\n    ;;\n  *)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]]\\.[[0-9]]) shared library'\n    lt_cv_file_magic_test_file=/usr/lib/libc.sl\n    ;;\n  esac\n  ;;\n\ninterix[[3-9]]*)\n  # PIC code is broken on Interix 3.x, that's why |\\.a not |_pic\\.a here\n  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|\\.a)$'\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $LD in\n  *-32|*\"-32 \") libmagic=32-bit;;\n  *-n32|*\"-n32 \") libmagic=N32;;\n  *-64|*\"-64 \") libmagic=64-bit;;\n  *) libmagic=never-match;;\n  esac\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\n# This must be glibc/ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nnetbsd* | netbsdelf*-gnu)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|_pic\\.a)$'\n  fi\n  ;;\n\nnewos6*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'\n  lt_cv_file_magic_cmd=/usr/bin/file\n  lt_cv_file_magic_test_file=/usr/lib/libnls.so\n  ;;\n\n*nto* | *qnx*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nopenbsd* | bitrig*)\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\"; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|\\.so|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  fi\n  ;;\n\nosf3* | osf4* | osf5*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nrdos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsolaris*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv4 | sysv4.3*)\n  case $host_vendor in\n  motorola)\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'\n    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`\n    ;;\n  ncr)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  sequent)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'\n    ;;\n  sni)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method=\"file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib\"\n    lt_cv_file_magic_test_file=/lib/libc.so\n    ;;\n  siemens)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  pc)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  esac\n  ;;\n\ntpf*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nos2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nesac\n])\n\nfile_magic_glob=\nwant_nocaseglob=no\nif test \"$build\" = \"$host\"; then\n  case $host_os in\n  mingw* | pw32*)\n    if ( shopt | grep nocaseglob ) >/dev/null 2>&1; then\n      want_nocaseglob=yes\n    else\n      file_magic_glob=`echo aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ | $SED -e \"s/\\(..\\)/s\\/[[\\1]]\\/[[\\1]]\\/g;/g\"`\n    fi\n    ;;\n  esac\nfi\n\nfile_magic_cmd=$lt_cv_file_magic_cmd\ndeplibs_check_method=$lt_cv_deplibs_check_method\ntest -z \"$deplibs_check_method\" && deplibs_check_method=unknown\n\n_LT_DECL([], [deplibs_check_method], [1],\n    [Method to check whether dependent libraries are shared objects])\n_LT_DECL([], [file_magic_cmd], [1],\n    [Command to use when deplibs_check_method = \"file_magic\"])\n_LT_DECL([], [file_magic_glob], [1],\n    [How to find potential files when deplibs_check_method = \"file_magic\"])\n_LT_DECL([], [want_nocaseglob], [1],\n    [Find potential files using nocaseglob when deplibs_check_method = \"file_magic\"])\n])# _LT_CHECK_MAGIC_METHOD\n\n\n# LT_PATH_NM\n# ----------\n# find the pathname to a BSD- or MS-compatible name lister\nAC_DEFUN([LT_PATH_NM],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,\n[if test -n \"$NM\"; then\n  # Let the user override the test.\n  lt_cv_path_NM=$NM\nelse\n  lt_nm_to_check=${ac_tool_prefix}nm\n  if test -n \"$ac_tool_prefix\" && test \"$build\" = \"$host\"; then\n    lt_nm_to_check=\"$lt_nm_to_check nm\"\n  fi\n  for lt_tmp_nm in $lt_nm_to_check; do\n    lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR\n    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do\n      IFS=$lt_save_ifs\n      test -z \"$ac_dir\" && ac_dir=.\n      tmp_nm=$ac_dir/$lt_tmp_nm\n      if test -f \"$tmp_nm\" || test -f \"$tmp_nm$ac_exeext\"; then\n\t# Check to see if the nm accepts a BSD-compat flag.\n\t# Adding the 'sed 1q' prevents false positives on HP-UX, which says:\n\t#   nm: unknown option \"B\" ignored\n\t# Tru64's nm complains that /dev/null is an invalid object file\n\t# MSYS converts /dev/null to NUL, MinGW nm treats NUL as empty\n\tcase $build_os in\n\tmingw*) lt_bad_file=conftest.nm/nofile ;;\n\t*) lt_bad_file=/dev/null ;;\n\tesac\n\tcase `\"$tmp_nm\" -B $lt_bad_file 2>&1 | sed '1q'` in\n\t*$lt_bad_file* | *'Invalid file or object type'*)\n\t  lt_cv_path_NM=\"$tmp_nm -B\"\n\t  break 2\n\t  ;;\n\t*)\n\t  case `\"$tmp_nm\" -p /dev/null 2>&1 | sed '1q'` in\n\t  */dev/null*)\n\t    lt_cv_path_NM=\"$tmp_nm -p\"\n\t    break 2\n\t    ;;\n\t  *)\n\t    lt_cv_path_NM=${lt_cv_path_NM=\"$tmp_nm\"} # keep the first match, but\n\t    continue # so that we can try to find one that supports BSD flags\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n      fi\n    done\n    IFS=$lt_save_ifs\n  done\n  : ${lt_cv_path_NM=no}\nfi])\nif test no != \"$lt_cv_path_NM\"; then\n  NM=$lt_cv_path_NM\nelse\n  # Didn't find any BSD compatible name lister, look for dumpbin.\n  if test -n \"$DUMPBIN\"; then :\n    # Let the user override the test.\n  else\n    AC_CHECK_TOOLS(DUMPBIN, [dumpbin \"link -dump\"], :)\n    case `$DUMPBIN -symbols -headers /dev/null 2>&1 | sed '1q'` in\n    *COFF*)\n      DUMPBIN=\"$DUMPBIN -symbols -headers\"\n      ;;\n    *)\n      DUMPBIN=:\n      ;;\n    esac\n  fi\n  AC_SUBST([DUMPBIN])\n  if test : != \"$DUMPBIN\"; then\n    NM=$DUMPBIN\n  fi\nfi\ntest -z \"$NM\" && NM=nm\nAC_SUBST([NM])\n_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl\n\nAC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],\n  [lt_cv_nm_interface=\"BSD nm\"\n  echo \"int some_variable = 0;\" > conftest.$ac_ext\n  (eval echo \"\\\"\\$as_me:$LINENO: $ac_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$ac_compile\" 2>conftest.err)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: output\\\"\" >&AS_MESSAGE_LOG_FD)\n  cat conftest.out >&AS_MESSAGE_LOG_FD\n  if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n    lt_cv_nm_interface=\"MS dumpbin\"\n  fi\n  rm -f conftest*])\n])# LT_PATH_NM\n\n# Old names:\nAU_ALIAS([AM_PROG_NM], [LT_PATH_NM])\nAU_ALIAS([AC_PROG_NM], [LT_PATH_NM])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_NM], [])\ndnl AC_DEFUN([AC_PROG_NM], [])\n\n# _LT_CHECK_SHAREDLIB_FROM_LINKLIB\n# --------------------------------\n# how to determine the name of the shared library\n# associated with a specific link library.\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_SHAREDLIB_FROM_LINKLIB],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nm4_require([_LT_DECL_DLLTOOL])\nAC_CACHE_CHECK([how to associate runtime and link libraries],\nlt_cv_sharedlib_from_linklib_cmd,\n[lt_cv_sharedlib_from_linklib_cmd='unknown'\n\ncase $host_os in\ncygwin* | mingw* | pw32* | cegcc*)\n  # two different shell functions defined in ltmain.sh;\n  # decide which one to use based on capabilities of $DLLTOOL\n  case `$DLLTOOL --help 2>&1` in\n  *--identify-strict*)\n    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib\n    ;;\n  *)\n    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib_fallback\n    ;;\n  esac\n  ;;\n*)\n  # fallback: assume linklib IS sharedlib\n  lt_cv_sharedlib_from_linklib_cmd=$ECHO\n  ;;\nesac\n])\nsharedlib_from_linklib_cmd=$lt_cv_sharedlib_from_linklib_cmd\ntest -z \"$sharedlib_from_linklib_cmd\" && sharedlib_from_linklib_cmd=$ECHO\n\n_LT_DECL([], [sharedlib_from_linklib_cmd], [1],\n    [Command to associate shared and link libraries])\n])# _LT_CHECK_SHAREDLIB_FROM_LINKLIB\n\n\n# _LT_PATH_MANIFEST_TOOL\n# ----------------------\n# locate the manifest tool\nm4_defun([_LT_PATH_MANIFEST_TOOL],\n[AC_CHECK_TOOL(MANIFEST_TOOL, mt, :)\ntest -z \"$MANIFEST_TOOL\" && MANIFEST_TOOL=mt\nAC_CACHE_CHECK([if $MANIFEST_TOOL is a manifest tool], [lt_cv_path_mainfest_tool],\n  [lt_cv_path_mainfest_tool=no\n  echo \"$as_me:$LINENO: $MANIFEST_TOOL '-?'\" >&AS_MESSAGE_LOG_FD\n  $MANIFEST_TOOL '-?' 2>conftest.err > conftest.out\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  if $GREP 'Manifest Tool' conftest.out > /dev/null; then\n    lt_cv_path_mainfest_tool=yes\n  fi\n  rm -f conftest*])\nif test yes != \"$lt_cv_path_mainfest_tool\"; then\n  MANIFEST_TOOL=:\nfi\n_LT_DECL([], [MANIFEST_TOOL], [1], [Manifest tool])dnl\n])# _LT_PATH_MANIFEST_TOOL\n\n\n# _LT_DLL_DEF_P([FILE])\n# ---------------------\n# True iff FILE is a Windows DLL '.def' file.\n# Keep in sync with func_dll_def_p in the libtool script\nAC_DEFUN([_LT_DLL_DEF_P],\n[dnl\n  test DEF = \"`$SED -n dnl\n    -e '\\''s/^[[\t ]]*//'\\'' dnl Strip leading whitespace\n    -e '\\''/^\\(;.*\\)*$/d'\\'' dnl      Delete empty lines and comments\n    -e '\\''s/^\\(EXPORTS\\|LIBRARY\\)\\([[\t ]].*\\)*$/DEF/p'\\'' dnl\n    -e q dnl                          Only consider the first \"real\" line\n    $1`\" dnl\n])# _LT_DLL_DEF_P\n\n\n# LT_LIB_M\n# --------\n# check for math library\nAC_DEFUN([LT_LIB_M],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nLIBM=\ncase $host in\n*-*-beos* | *-*-cegcc* | *-*-cygwin* | *-*-haiku* | *-*-pw32* | *-*-darwin*)\n  # These system don't have libm, or don't need it\n  ;;\n*-ncr-sysv4.3*)\n  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=-lmw)\n  AC_CHECK_LIB(m, cos, LIBM=\"$LIBM -lm\")\n  ;;\n*)\n  AC_CHECK_LIB(m, cos, LIBM=-lm)\n  ;;\nesac\nAC_SUBST([LIBM])\n])# LT_LIB_M\n\n# Old name:\nAU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_CHECK_LIBM], [])\n\n\n# _LT_COMPILER_NO_RTTI([TAGNAME])\n# -------------------------------\nm4_defun([_LT_COMPILER_NO_RTTI],\n[m4_require([_LT_TAG_COMPILER])dnl\n\n_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n\nif test yes = \"$GCC\"; then\n  case $cc_basename in\n  nvcc*)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -Xcompiler -fno-builtin' ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin' ;;\n  esac\n\n  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],\n    lt_cv_prog_compiler_rtti_exceptions,\n    [-fno-rtti -fno-exceptions], [],\n    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\"$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions\"])\nfi\n_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],\n\t[Compiler flag to turn off builtin functions])\n])# _LT_COMPILER_NO_RTTI\n\n\n# _LT_CMD_GLOBAL_SYMBOLS\n# ----------------------\nm4_defun([_LT_CMD_GLOBAL_SYMBOLS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_PROG_AWK])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_TAG_COMPILER])dnl\n\n# Check for command to grab the raw symbol name followed by C symbol from nm.\nAC_MSG_CHECKING([command to parse $NM output from $compiler object])\nAC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],\n[\n# These are sane defaults that work on at least a few old systems.\n# [They come from Ultrix.  What could be older than Ultrix?!! ;)]\n\n# Character class describing NM global symbol codes.\nsymcode='[[BCDEGRST]]'\n\n# Regexp to match symbols that can be accessed directly from C.\nsympat='\\([[_A-Za-z]][[_A-Za-z0-9]]*\\)'\n\n# Define system-specific variables.\ncase $host_os in\naix*)\n  symcode='[[BCDT]]'\n  ;;\ncygwin* | mingw* | pw32* | cegcc*)\n  symcode='[[ABCDGISTW]]'\n  ;;\nhpux*)\n  if test ia64 = \"$host_cpu\"; then\n    symcode='[[ABCDEGRST]]'\n  fi\n  ;;\nirix* | nonstopux*)\n  symcode='[[BCDEGRST]]'\n  ;;\nosf*)\n  symcode='[[BCDEGQRST]]'\n  ;;\nsolaris*)\n  symcode='[[BDRT]]'\n  ;;\nsco3.2v5*)\n  symcode='[[DT]]'\n  ;;\nsysv4.2uw2*)\n  symcode='[[DT]]'\n  ;;\nsysv5* | sco5v6* | unixware* | OpenUNIX*)\n  symcode='[[ABDT]]'\n  ;;\nsysv4)\n  symcode='[[DFNSTU]]'\n  ;;\nesac\n\n# If we're using GNU nm, then use its standard symbol codes.\ncase `$NM -V 2>&1` in\n*GNU* | *'with BFD'*)\n  symcode='[[ABCDGIRSTW]]' ;;\nesac\n\nif test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n  # Gets list of data symbols to import.\n  lt_cv_sys_global_symbol_to_import=\"sed -n -e 's/^I .* \\(.*\\)$/\\1/p'\"\n  # Adjust the below global symbol transforms to fixup imported variables.\n  lt_cdecl_hook=\" -e 's/^I .* \\(.*\\)$/extern __declspec(dllimport) char \\1;/p'\"\n  lt_c_name_hook=\" -e 's/^I .* \\(.*\\)$/  {\\\"\\1\\\", (void *) 0},/p'\"\n  lt_c_name_lib_hook=\"\\\n  -e 's/^I .* \\(lib.*\\)$/  {\\\"\\1\\\", (void *) 0},/p'\\\n  -e 's/^I .* \\(.*\\)$/  {\\\"lib\\1\\\", (void *) 0},/p'\"\nelse\n  # Disable hooks by default.\n  lt_cv_sys_global_symbol_to_import=\n  lt_cdecl_hook=\n  lt_c_name_hook=\n  lt_c_name_lib_hook=\nfi\n\n# Transform an extracted symbol line into a proper C declaration.\n# Some systems (esp. on ia64) link data and code symbols differently,\n# so use this general approach.\nlt_cv_sys_global_symbol_to_cdecl=\"sed -n\"\\\n$lt_cdecl_hook\\\n\" -e 's/^T .* \\(.*\\)$/extern int \\1();/p'\"\\\n\" -e 's/^$symcode$symcode* .* \\(.*\\)$/extern char \\1;/p'\"\n\n# Transform an extracted symbol line into symbol name and symbol address\nlt_cv_sys_global_symbol_to_c_name_address=\"sed -n\"\\\n$lt_c_name_hook\\\n\" -e 's/^: \\(.*\\) .*$/  {\\\"\\1\\\", (void *) 0},/p'\"\\\n\" -e 's/^$symcode$symcode* .* \\(.*\\)$/  {\\\"\\1\\\", (void *) \\&\\1},/p'\"\n\n# Transform an extracted symbol line into symbol name with lib prefix and\n# symbol address.\nlt_cv_sys_global_symbol_to_c_name_address_lib_prefix=\"sed -n\"\\\n$lt_c_name_lib_hook\\\n\" -e 's/^: \\(.*\\) .*$/  {\\\"\\1\\\", (void *) 0},/p'\"\\\n\" -e 's/^$symcode$symcode* .* \\(lib.*\\)$/  {\\\"\\1\\\", (void *) \\&\\1},/p'\"\\\n\" -e 's/^$symcode$symcode* .* \\(.*\\)$/  {\\\"lib\\1\\\", (void *) \\&\\1},/p'\"\n\n# Handle CRLF in mingw tool chain\nopt_cr=\ncase $build_os in\nmingw*)\n  opt_cr=`$ECHO 'x\\{0,1\\}' | tr x '\\015'` # option cr in regexp\n  ;;\nesac\n\n# Try without a prefix underscore, then with it.\nfor ac_symprfx in \"\" \"_\"; do\n\n  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.\n  symxfrm=\"\\\\1 $ac_symprfx\\\\2 \\\\2\"\n\n  # Write the raw and C identifiers.\n  if test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n    # Fake it for dumpbin and say T for any non-static function,\n    # D for any global variable and I for any imported variable.\n    # Also find C++ and __fastcall symbols from MSVC++,\n    # which start with @ or ?.\n    lt_cv_sys_global_symbol_pipe=\"$AWK ['\"\\\n\"     {last_section=section; section=\\$ 3};\"\\\n\"     /^COFF SYMBOL TABLE/{for(i in hide) delete hide[i]};\"\\\n\"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};\"\\\n\"     /^ *Symbol name *: /{split(\\$ 0,sn,\\\":\\\"); si=substr(sn[2],2)};\"\\\n\"     /^ *Type *: code/{print \\\"T\\\",si,substr(si,length(prfx))};\"\\\n\"     /^ *Type *: data/{print \\\"I\\\",si,substr(si,length(prfx))};\"\\\n\"     \\$ 0!~/External *\\|/{next};\"\\\n\"     / 0+ UNDEF /{next}; / UNDEF \\([^|]\\)*()/{next};\"\\\n\"     {if(hide[section]) next};\"\\\n\"     {f=\\\"D\\\"}; \\$ 0~/\\(\\).*\\|/{f=\\\"T\\\"};\"\\\n\"     {split(\\$ 0,a,/\\||\\r/); split(a[2],s)};\"\\\n\"     s[1]~/^[@?]/{print f,s[1],s[1]; next};\"\\\n\"     s[1]~prfx {split(s[1],t,\\\"@\\\"); print f,t[1],substr(t[1],length(prfx))}\"\\\n\"     ' prfx=^$ac_symprfx]\"\n  else\n    lt_cv_sys_global_symbol_pipe=\"sed -n -e 's/^.*[[\t ]]\\($symcode$symcode*\\)[[\t ]][[\t ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'\"\n  fi\n  lt_cv_sys_global_symbol_pipe=\"$lt_cv_sys_global_symbol_pipe | sed '/ __gnu_lto/d'\"\n\n  # Check to see that the pipe works correctly.\n  pipe_works=no\n\n  rm -f conftest*\n  cat > conftest.$ac_ext <<_LT_EOF\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nchar nm_test_var;\nvoid nm_test_func(void);\nvoid nm_test_func(void){}\n#ifdef __cplusplus\n}\n#endif\nint main(){nm_test_var='a';nm_test_func();return(0);}\n_LT_EOF\n\n  if AC_TRY_EVAL(ac_compile); then\n    # Now try to grab the symbols.\n    nlist=conftest.nm\n    if AC_TRY_EVAL(NM conftest.$ac_objext \\| \"$lt_cv_sys_global_symbol_pipe\" \\> $nlist) && test -s \"$nlist\"; then\n      # Try sorting and uniquifying the output.\n      if sort \"$nlist\" | uniq > \"$nlist\"T; then\n\tmv -f \"$nlist\"T \"$nlist\"\n      else\n\trm -f \"$nlist\"T\n      fi\n\n      # Make sure that we snagged all the symbols we need.\n      if $GREP ' nm_test_var$' \"$nlist\" >/dev/null; then\n\tif $GREP ' nm_test_func$' \"$nlist\" >/dev/null; then\n\t  cat <<_LT_EOF > conftest.$ac_ext\n/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */\n#if defined _WIN32 || defined __CYGWIN__ || defined _WIN32_WCE\n/* DATA imports from DLLs on WIN32 can't be const, because runtime\n   relocations are performed -- see ld's documentation on pseudo-relocs.  */\n# define LT@&t@_DLSYM_CONST\n#elif defined __osf__\n/* This system does not cope well with relocations in const data.  */\n# define LT@&t@_DLSYM_CONST\n#else\n# define LT@&t@_DLSYM_CONST const\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n_LT_EOF\n\t  # Now generate the symbol file.\n\t  eval \"$lt_cv_sys_global_symbol_to_cdecl\"' < \"$nlist\" | $GREP -v main >> conftest.$ac_ext'\n\n\t  cat <<_LT_EOF >> conftest.$ac_ext\n\n/* The mapping between symbol names and symbols.  */\nLT@&t@_DLSYM_CONST struct {\n  const char *name;\n  void       *address;\n}\nlt__PROGRAM__LTX_preloaded_symbols[[]] =\n{\n  { \"@PROGRAM@\", (void *) 0 },\n_LT_EOF\n\t  $SED \"s/^$symcode$symcode* .* \\(.*\\)$/  {\\\"\\1\\\", (void *) \\&\\1},/\" < \"$nlist\" | $GREP -v main >> conftest.$ac_ext\n\t  cat <<\\_LT_EOF >> conftest.$ac_ext\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt__PROGRAM__LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n_LT_EOF\n\t  # Now try linking the two files.\n\t  mv conftest.$ac_objext conftstm.$ac_objext\n\t  lt_globsym_save_LIBS=$LIBS\n\t  lt_globsym_save_CFLAGS=$CFLAGS\n\t  LIBS=conftstm.$ac_objext\n\t  CFLAGS=\"$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)\"\n\t  if AC_TRY_EVAL(ac_link) && test -s conftest$ac_exeext; then\n\t    pipe_works=yes\n\t  fi\n\t  LIBS=$lt_globsym_save_LIBS\n\t  CFLAGS=$lt_globsym_save_CFLAGS\n\telse\n\t  echo \"cannot find nm_test_func in $nlist\" >&AS_MESSAGE_LOG_FD\n\tfi\n      else\n\techo \"cannot find nm_test_var in $nlist\" >&AS_MESSAGE_LOG_FD\n      fi\n    else\n      echo \"cannot run $lt_cv_sys_global_symbol_pipe\" >&AS_MESSAGE_LOG_FD\n    fi\n  else\n    echo \"$progname: failed program was:\" >&AS_MESSAGE_LOG_FD\n    cat conftest.$ac_ext >&5\n  fi\n  rm -rf conftest* conftst*\n\n  # Do not use the global_symbol_pipe unless it works.\n  if test yes = \"$pipe_works\"; then\n    break\n  else\n    lt_cv_sys_global_symbol_pipe=\n  fi\ndone\n])\nif test -z \"$lt_cv_sys_global_symbol_pipe\"; then\n  lt_cv_sys_global_symbol_to_cdecl=\nfi\nif test -z \"$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl\"; then\n  AC_MSG_RESULT(failed)\nelse\n  AC_MSG_RESULT(ok)\nfi\n\n# Response file support.\nif test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n  nm_file_list_spec='@'\nelif $NM --help 2>/dev/null | grep '[[@]]FILE' >/dev/null; then\n  nm_file_list_spec='@'\nfi\n\n_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],\n    [Take the output of nm and produce a listing of raw symbols and C names])\n_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],\n    [Transform the output of nm in a proper C declaration])\n_LT_DECL([global_symbol_to_import], [lt_cv_sys_global_symbol_to_import], [1],\n    [Transform the output of nm into a list of symbols to manually relocate])\n_LT_DECL([global_symbol_to_c_name_address],\n    [lt_cv_sys_global_symbol_to_c_name_address], [1],\n    [Transform the output of nm in a C name address pair])\n_LT_DECL([global_symbol_to_c_name_address_lib_prefix],\n    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],\n    [Transform the output of nm in a C name address pair when lib prefix is needed])\n_LT_DECL([nm_interface], [lt_cv_nm_interface], [1],\n    [The name lister interface])\n_LT_DECL([], [nm_file_list_spec], [1],\n    [Specify filename containing input files for $NM])\n]) # _LT_CMD_GLOBAL_SYMBOLS\n\n\n# _LT_COMPILER_PIC([TAGNAME])\n# ---------------------------\nm4_defun([_LT_COMPILER_PIC],\n[m4_require([_LT_TAG_COMPILER])dnl\n_LT_TAGVAR(lt_prog_compiler_wl, $1)=\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n_LT_TAGVAR(lt_prog_compiler_static, $1)=\n\nm4_if([$1], [CXX], [\n  # C++ specific cases for pic, static, wl, etc.\n  if test yes = \"$GXX\"; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n    aix*)\n      # All AIX code is PIC.\n      if test ia64 = \"$host_cpu\"; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the '-m68020' flag to GCC prevents building anything better,\n            # like '-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n    mingw* | cygwin* | os2* | pw32* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      case $host_os in\n      os2*)\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-static'\n\t;;\n      esac\n      ;;\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n    *djgpp*)\n      # DJGPP does not support shared libraries at all\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n      ;;\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n    *qnx* | *nto*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    case $host_os in\n      aix[[4-9]]*)\n\t# All AIX code is PIC.\n\tif test ia64 = \"$host_cpu\"; then\n\t  # AIX 5 now supports IA64 processor\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\telse\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n\tfi\n\t;;\n      chorus*)\n\tcase $cc_basename in\n\tcxch68*)\n\t  # Green Hills C++ Compiler\n\t  # _LT_TAGVAR(lt_prog_compiler_static, $1)=\"--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a\"\n\t  ;;\n\tesac\n\t;;\n      mingw* | cygwin* | os2* | pw32* | cegcc*)\n\t# This hack is so that the source file can tell whether it is being\n\t# built for inclusion in a dll (and should export symbols for example).\n\tm4_if([$1], [GCJ], [],\n\t  [_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n\t;;\n      dgux*)\n\tcase $cc_basename in\n\t  ec++*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  ghcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      freebsd* | dragonfly*)\n\t# FreeBSD uses GNU C++\n\t;;\n      hpux9* | hpux10* | hpux11*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-a ${wl}archive'\n\t    if test ia64 != \"$host_cpu\"; then\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t    fi\n\t    ;;\n\t  aCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-a ${wl}archive'\n\t    case $host_cpu in\n\t    hppa*64*|ia64*)\n\t      # +Z the default\n\t      ;;\n\t    *)\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t      ;;\n\t    esac\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      interix*)\n\t# This is c89, which is MS Visual C++ (no shared libs)\n\t# Anyone wants to do a port?\n\t;;\n      irix5* | irix6* | nonstopux*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    # CC pic flag -KPIC is the default.\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    # KAI C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    ;;\n\t  ecpc* )\n\t    # old Intel C++ for x86_64, which still supported -KPIC.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  icpc* )\n\t    # Intel C++, used to be incompatible with GCC.\n\t    # ICC 10 doesn't accept -KPIC any more.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  pgCC* | pgcpp*)\n\t    # Portland Group C++ compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  xlc* | xlC* | bgxl[[cC]]* | mpixl[[cC]]*)\n\t    # IBM XL 8.0, 9.0 on PPC and BlueGene\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n      lynxos*)\n\t;;\n      m88k*)\n\t;;\n      mvs*)\n\tcase $cc_basename in\n\t  cxx*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      netbsd* | netbsdelf*-gnu)\n\t;;\n      *qnx* | *nto*)\n        # QNX uses GNU C++, but need to define -shared option too, otherwise\n        # it will coredump.\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n        ;;\n      osf3* | osf4* | osf5*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    ;;\n\t  RCC*)\n\t    # Rational C++ 2.4.1\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  cxx*)\n\t    # Digital/Compaq C++\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      psos*)\n\t;;\n      solaris*)\n\tcase $cc_basename in\n\t  CC* | sunCC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t    ;;\n\t  gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sunos4*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.x\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  lcc*)\n\t    # Lucid\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\tesac\n\t;;\n      tandem*)\n\tcase $cc_basename in\n\t  NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      vxworks*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n\t;;\n    esac\n  fi\n],\n[\n  if test yes = \"$GCC\"; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n      aix*)\n      # All AIX code is PIC.\n      if test ia64 = \"$host_cpu\"; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the '-m68020' flag to GCC prevents building anything better,\n            # like '-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      case $host_os in\n      os2*)\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-static'\n\t;;\n      esac\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n\n    msdosdjgpp*)\n      # Just because we use GCC doesn't mean we suddenly get shared libraries\n      # on systems that don't support them.\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      enable_shared=no\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n\n    case $cc_basename in\n    nvcc*) # Cuda Compiler Driver 2.2\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Xlinker '\n      if test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"-Xcompiler $_LT_TAGVAR(lt_prog_compiler_pic, $1)\"\n      fi\n      ;;\n    esac\n  else\n    # PORTME Check for flag to pass linker flags through the system compiler.\n    case $host_os in\n    aix*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      if test ia64 = \"$host_cpu\"; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      else\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n      fi\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      case $cc_basename in\n      nagfor*)\n        # NAG Fortran compiler\n        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,-Wl,,'\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n        _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      esac\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      case $host_os in\n      os2*)\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-static'\n\t;;\n      esac\n      ;;\n\n    hpux9* | hpux10* | hpux11*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but\n      # not for PA HP-UX.\n      case $host_cpu in\n      hppa*64*|ia64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t;;\n      esac\n      # Is there a better lt_prog_compiler_static that works with the bundled CC?\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-a ${wl}archive'\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC (with -KPIC) is the default.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n      case $cc_basename in\n      # old Intel for x86_64, which still supported -KPIC.\n      ecc*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # icc used to be incompatible with GCC.\n      # ICC 10 doesn't accept -KPIC any more.\n      icc* | ifort*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # Lahey Fortran 8.1.\n      lf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'\n\t;;\n      nagfor*)\n\t# NAG Fortran compiler\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,-Wl,,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t;;\n      tcc*)\n\t# Fabrice Bellard et al's Tiny C Compiler\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t;;\n      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)\n        # Portland Group compilers (*not* the Pentium gcc compiler,\n\t# which looks to be a dead project)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      ccc*)\n        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n        # All Alpha code is PIC.\n        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n        ;;\n      xl* | bgxl* | bgf* | mpixl*)\n\t# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t;;\n      *)\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ Ceres\\ Fortran* | *Sun*Fortran*\\ [[1-7]].* | *Sun*Fortran*\\ 8.[[0-3]]*)\n\t  # Sun Fortran 8.3 passes all unrecognized flags to the linker\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''\n\t  ;;\n\t*Sun\\ F* | *Sun*Fortran*)\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t  ;;\n\t*Sun\\ C*)\n\t  # Sun C 5.9\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  ;;\n        *Intel*\\ [[CF]]*Compiler*)\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t  ;;\n\t*Portland\\ Group*)\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  ;;\n\tesac\n\t;;\n      esac\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    osf3* | osf4* | osf5*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # All OSF/1 code is PIC.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    rdos*)\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      case $cc_basename in\n      f77* | f90* | f95* | sunf77* | sunf90* | sunf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4 | sysv4.2uw2* | sysv4.3*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    unicos*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n    esac\n  fi\n])\ncase $host_os in\n  # For platforms that do not support PIC, -DPIC is meaningless:\n  *djgpp*)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n    ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])\"\n    ;;\nesac\n\nAC_CACHE_CHECK([for $compiler option to produce PIC],\n  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_prog_compiler_pic, $1)])\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)\n\n#\n# Check to make sure the PIC flag actually works.\n#\nif test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],\n    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],\n    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],\n    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in\n     \"\" | \" \"*) ;;\n     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=\" $_LT_TAGVAR(lt_prog_compiler_pic, $1)\" ;;\n     esac],\n    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])\nfi\n_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],\n\t[Additional compiler flags for building library objects])\n\n_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],\n\t[How to pass a linker flag through the compiler])\n#\n# Check to make sure the static flag actually works.\n#\nwl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\\\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\\\"\n_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],\n  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),\n  $lt_tmp_static_flag,\n  [],\n  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])\n_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],\n\t[Compiler flag to prevent dynamic linking])\n])# _LT_COMPILER_PIC\n\n\n# _LT_LINKER_SHLIBS([TAGNAME])\n# ----------------------------\n# See if the linker supports building shared libraries.\nm4_defun([_LT_LINKER_SHLIBS],\n[AC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nm4_require([_LT_PATH_MANIFEST_TOOL])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\nm4_if([$1], [CXX], [\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  case $host_os in\n  aix[[4-9]]*)\n    # If we're using GNU nm, then we don't want the \"-C\" option.\n    # -C means demangle to GNU nm, but means don't demangle to AIX nm.\n    # Without the \"-l\" option, or with the \"-B\" option, AIX nm treats\n    # weak defined symbols like other global defined symbols, whereas\n    # GNU nm marks them as \"W\".\n    # While the 'weak' keyword is ignored in the Export File, we need\n    # it in the Import File for the 'aix-soname' feature, so we have\n    # to replace the \"-B\" option with \"-P\" for AIX nm.\n    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { if (\\$ 2 == \"W\") { print \\$ 3 \" weak\" } else { print \\$ 3 } } }'\\'' | sort -u > $export_symbols'\n    else\n      _LT_TAGVAR(export_symbols_cmds, $1)='`func_echo_all $NM | $SED -e '\\''s/B\\([[^B]]*\\)$/P\\1/'\\''` -PCpgl $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\") || (\\$ 2 == \"V\") || (\\$ 2 == \"Z\")) && ([substr](\\$ 1,1,1) != \".\")) { if ((\\$ 2 == \"W\") || (\\$ 2 == \"V\") || (\\$ 2 == \"Z\")) { print \\$ 1 \" weak\" } else { print \\$ 1 } } }'\\'' | sort -u > $export_symbols'\n    fi\n    ;;\n  pw32*)\n    _LT_TAGVAR(export_symbols_cmds, $1)=$ltdll_cmds\n    ;;\n  cygwin* | mingw* | cegcc*)\n    case $cc_basename in\n    cl*)\n      _LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'\n      ;;\n    *)\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']\n      ;;\n    esac\n    ;;\n  linux* | k*bsd*-gnu | gnu*)\n    _LT_TAGVAR(link_all_deplibs, $1)=no\n    ;;\n  *)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n    ;;\n  esac\n], [\n  runpath_var=\n  _LT_TAGVAR(allow_undefined_flag, $1)=\n  _LT_TAGVAR(always_export_symbols, $1)=no\n  _LT_TAGVAR(archive_cmds, $1)=\n  _LT_TAGVAR(archive_expsym_cmds, $1)=\n  _LT_TAGVAR(compiler_needs_object, $1)=no\n  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n  _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(hardcode_automatic, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_direct_absolute, $1)=no\n  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n  _LT_TAGVAR(hardcode_minus_L, $1)=no\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_TAGVAR(inherit_rpath, $1)=no\n  _LT_TAGVAR(link_all_deplibs, $1)=unknown\n  _LT_TAGVAR(module_cmds, $1)=\n  _LT_TAGVAR(module_expsym_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_new_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=\n  _LT_TAGVAR(thread_safe_flag_spec, $1)=\n  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n  # include_expsyms should be a list of space-separated symbols to be *always*\n  # included in the symbol list\n  _LT_TAGVAR(include_expsyms, $1)=\n  # exclude_expsyms can be an extended regexp of symbols to exclude\n  # it will be wrapped by ' (' and ')$', so one must not match beginning or\n  # end of line.  Example: 'a|bc|.*d.*' will exclude the symbols 'a' and 'bc',\n  # as well as any symbol that contains 'd'.\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out\n  # platforms (ab)use it in PIC code, but their linkers get confused if\n  # the symbol is explicitly referenced.  Since portable code cannot\n  # rely on this symbol name, it's probably fine to never include it in\n  # preloaded symbol tables.\n  # Exclude shared library initialization/finalization symbols.\ndnl Note also adjust exclude_expsyms for C++ above.\n  extract_expsyms_cmds=\n\n  case $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    # FIXME: the MSVC++ port hasn't been tested in a loooong time\n    # When not using gcc, we currently assume that we are using\n    # Microsoft Visual C++.\n    if test yes != \"$GCC\"; then\n      with_gnu_ld=no\n    fi\n    ;;\n  interix*)\n    # we just hope/assume this is gcc and not c89 (= MSVC++)\n    with_gnu_ld=yes\n    ;;\n  openbsd* | bitrig*)\n    with_gnu_ld=no\n    ;;\n  linux* | k*bsd*-gnu | gnu*)\n    _LT_TAGVAR(link_all_deplibs, $1)=no\n    ;;\n  esac\n\n  _LT_TAGVAR(ld_shlibs, $1)=yes\n\n  # On some targets, GNU ld is compatible enough with the native linker\n  # that we're better off using the native interface for both.\n  lt_use_gnu_ld_interface=no\n  if test yes = \"$with_gnu_ld\"; then\n    case $host_os in\n      aix*)\n\t# The AIX port of GNU ld has always aspired to compatibility\n\t# with the native linker.  However, as the warning in the GNU ld\n\t# block says, versions before 2.19.5* couldn't really create working\n\t# shared libraries, regardless of the interface used.\n\tcase `$LD -v 2>&1` in\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.19.5*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.[[2-9]]*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ [[3-9]]*) ;;\n\t  *)\n\t    lt_use_gnu_ld_interface=yes\n\t    ;;\n\tesac\n\t;;\n      *)\n\tlt_use_gnu_ld_interface=yes\n\t;;\n    esac\n  fi\n\n  if test yes = \"$lt_use_gnu_ld_interface\"; then\n    # If archive_cmds runs LD, not CC, wlarc should be empty\n    wlarc='$wl'\n\n    # Set some defaults for GNU ld with shared library support. These\n    # are reset later if shared libraries are not supported. Putting them\n    # here allows them to be overridden if necessary.\n    runpath_var=LD_RUN_PATH\n    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n    # ancient GNU ld didn't support --whole-archive et. al.\n    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=$wlarc'--whole-archive$convenience '$wlarc'--no-whole-archive'\n    else\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n    supports_anon_versioning=no\n    case `$LD -v | $SED -e 's/([^)]\\+)\\s\\+//' 2>&1` in\n      *GNU\\ gold*) supports_anon_versioning=yes ;;\n      *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.10.*) ;; # catch versions < 2.11\n      *\\ 2.11.93.0.2\\ *) supports_anon_versioning=yes ;; # RH7.3 ...\n      *\\ 2.11.92.0.12\\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...\n      *\\ 2.11.*) ;; # other 2.11 versions\n      *) supports_anon_versioning=yes ;;\n    esac\n\n    # See if GNU ld supports shared libraries.\n    case $host_os in\n    aix[[3-9]]*)\n      # On AIX/PPC, the GNU linker is very broken\n      if test ia64 != \"$host_cpu\"; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: the GNU linker, at least up to release 2.19, is reported\n*** to be unable to reliably create shared libraries on AIX.\n*** Therefore, libtool is disabling shared libraries support.  If you\n*** really care for shared libraries, you may want to install binutils\n*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.\n*** You will then need to restart the configuration process.\n\n_LT_EOF\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    beos*)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t# support --undefined.  This deserves some investigation.  FIXME\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n      # as there is no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-all-symbols'\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=no\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']\n\n      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t# If the export-symbols file already is a .def file, use it as\n\t# is; otherwise, prepend EXPORTS...\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then\n          cp $export_symbols $output_objdir/$soname.def;\n        else\n          echo EXPORTS > $output_objdir/$soname.def;\n          cat $export_symbols >> $output_objdir/$soname.def;\n        fi~\n        $CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    haiku*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    os2*)\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      shrext_cmds=.dll\n      _LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t$ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t$ECHO EXPORTS >> $output_objdir/$libname.def~\n\temxexp $libobjs | $SED /\"_DLL_InitTerm\"/d >> $output_objdir/$libname.def~\n\t$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\temximp -o $lib $output_objdir/$libname.def'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t$ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t$ECHO EXPORTS >> $output_objdir/$libname.def~\n\tprefix_cmds=\"$SED\"~\n\tif test EXPORTS = \"`$SED 1q $export_symbols`\"; then\n\t  prefix_cmds=\"$prefix_cmds -e 1d\";\n\tfi~\n\tprefix_cmds=\"$prefix_cmds -e \\\"s/^\\(.*\\)$/_\\1/g\\\"\"~\n\tcat $export_symbols | $prefix_cmds >> $output_objdir/$libname.def~\n\t$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\temximp -o $lib $output_objdir/$libname.def'\n      _LT_TAGVAR(old_archive_From_new_cmds, $1)='emximp -o $output_objdir/${libname}_dll.a $output_objdir/$libname.def'\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      ;;\n\n    interix[[3-9]]*)\n      _LT_TAGVAR(hardcode_direct, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n      # Instead, shared libraries are loaded at an image base (0x10000000 by\n      # default) and relocated if they conflict, which is a slow very memory\n      # consuming and fragmenting process.  To avoid this, we pick a random,\n      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s|^|_|\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--retain-symbols-file,$output_objdir/$soname.expsym $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      ;;\n\n    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)\n      tmp_diet=no\n      if test linux-dietlibc = \"$host_os\"; then\n\tcase $cc_basename in\n\t  diet\\ *) tmp_diet=yes;;\t# linux-dietlibc with static linking (!diet-dyn)\n\tesac\n      fi\n      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \\\n\t && test no = \"$tmp_diet\"\n      then\n\ttmp_addflag=' $pic_flag'\n\ttmp_sharedflag='-shared'\n\tcase $cc_basename,$host_cpu in\n        pgcc*)\t\t\t\t# Portland Group C compiler\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n\t  tmp_addflag=' $pic_flag'\n\t  ;;\n\tpgf77* | pgf90* | pgf95* | pgfortran*)\n\t\t\t\t\t# Portland Group f77 and f90 compilers\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n\t  tmp_addflag=' $pic_flag -Mnomain' ;;\n\tecc*,ia64* | icc*,ia64*)\t# Intel C compiler on ia64\n\t  tmp_addflag=' -i_dynamic' ;;\n\tefc*,ia64* | ifort*,ia64*)\t# Intel Fortran compiler on ia64\n\t  tmp_addflag=' -i_dynamic -nofor_main' ;;\n\tifc* | ifort*)\t\t\t# Intel Fortran compiler\n\t  tmp_addflag=' -nofor_main' ;;\n\tlf95*)\t\t\t\t# Lahey Fortran 8.1\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n\t  tmp_sharedflag='--shared' ;;\n        nagfor*)                        # NAGFOR 5.3\n          tmp_sharedflag='-Wl,-shared' ;;\n\txl[[cC]]* | bgxl[[cC]]* | mpixl[[cC]]*) # IBM XL C 8.0 on PPC (deal with xlf below)\n\t  tmp_sharedflag='-qmkshrobj'\n\t  tmp_addflag= ;;\n\tnvcc*)\t# Cuda Compiler Driver 2.2\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  ;;\n\tesac\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\t\t\t# Sun C 5.9\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  tmp_sharedflag='-G' ;;\n\t*Sun\\ F*)\t\t\t# Sun Fortran 8.3\n\t  tmp_sharedflag='-G' ;;\n\tesac\n\t_LT_TAGVAR(archive_cmds, $1)='$CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\n        if test yes = \"$supports_anon_versioning\"; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n            cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n            echo \"local: *; };\" >> $output_objdir/$libname.ver~\n            $CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-version-script $wl$output_objdir/$libname.ver -o $lib'\n        fi\n\n\tcase $cc_basename in\n\ttcc*)\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='-rdynamic'\n\t  ;;\n\txlf* | bgf* | bgxlf* | mpixlf*)\n\t  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $linker_flags -soname $soname -o $lib'\n\t  if test yes = \"$supports_anon_versioning\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n              cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n              echo \"local: *; };\" >> $output_objdir/$libname.ver~\n              $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'\n\t  fi\n\t  ;;\n\tesac\n      else\n        _LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    netbsd* | netbsdelf*-gnu)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'\n\twlarc=\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n      fi\n      ;;\n\n    solaris*)\n      if $LD -v 2>&1 | $GREP 'BFD 2\\.8' > /dev/null; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: The releases 2.8.* of the GNU linker cannot reliably\n*** create shared libraries on Solaris systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.9.1 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)\n      case `$LD -v 2>&1` in\n        *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.1[[0-5]].*)\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 cannot\n*** reliably create shared libraries on SCO systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n\t;;\n\t*)\n\t  # For security reasons, it is highly recommended that you always\n\t  # use absolute paths for naming shared libraries, and exclude the\n\t  # DT_RUNPATH tag from executables and libraries.  But doing so\n\t  # requires that you compile everything twice, which is a pain.\n\t  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t;;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      wlarc=\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n    esac\n\n    if test no = \"$_LT_TAGVAR(ld_shlibs, $1)\"; then\n      runpath_var=\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n  else\n    # PORTME fill in a description of your system's linker (not GNU ld)\n    case $host_os in\n    aix3*)\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'\n      # Note: this linker hardcodes the directories in LIBPATH if there\n      # are no directories specified by -L.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      if test yes = \"$GCC\" && test -z \"$lt_prog_compiler_static\"; then\n\t# Neither direct hardcoding nor static linking is supported with a\n\t# broken collect2.\n\t_LT_TAGVAR(hardcode_direct, $1)=unsupported\n      fi\n      ;;\n\n    aix[[4-9]]*)\n      if test ia64 = \"$host_cpu\"; then\n\t# On IA64, the linker does run time linking by default, so we don't\n\t# have to do anything special.\n\taix_use_runtimelinking=no\n\texp_sym_flag='-Bexport'\n\tno_entry_flag=\n      else\n\t# If we're using GNU nm, then we don't want the \"-C\" option.\n\t# -C means demangle to GNU nm, but means don't demangle to AIX nm.\n\t# Without the \"-l\" option, or with the \"-B\" option, AIX nm treats\n\t# weak defined symbols like other global defined symbols, whereas\n\t# GNU nm marks them as \"W\".\n\t# While the 'weak' keyword is ignored in the Export File, we need\n\t# it in the Import File for the 'aix-soname' feature, so we have\n\t# to replace the \"-B\" option with \"-P\" for AIX nm.\n\tif $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { if (\\$ 2 == \"W\") { print \\$ 3 \" weak\" } else { print \\$ 3 } } }'\\'' | sort -u > $export_symbols'\n\telse\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='`func_echo_all $NM | $SED -e '\\''s/B\\([[^B]]*\\)$/P\\1/'\\''` -PCpgl $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\") || (\\$ 2 == \"V\") || (\\$ 2 == \"Z\")) && ([substr](\\$ 1,1,1) != \".\")) { if ((\\$ 2 == \"W\") || (\\$ 2 == \"V\") || (\\$ 2 == \"Z\")) { print \\$ 1 \" weak\" } else { print \\$ 1 } } }'\\'' | sort -u > $export_symbols'\n\tfi\n\taix_use_runtimelinking=no\n\n\t# Test if we are trying to use run time linking or normal\n\t# AIX style linking. If -brtl is somewhere in LDFLAGS, we\n\t# have runtime linking enabled, and use it for executables.\n\t# For shared libraries, we enable/disable runtime linking\n\t# depending on the kind of the shared library created -\n\t# when \"with_aix_soname,aix_use_runtimelinking\" is:\n\t# \"aix,no\"   lib.a(lib.so.V) shared, rtl:no,  for executables\n\t# \"aix,yes\"  lib.so          shared, rtl:yes, for executables\n\t#            lib.a           static archive\n\t# \"both,no\"  lib.so.V(shr.o) shared, rtl:yes\n\t#            lib.a(lib.so.V) shared, rtl:no,  for executables\n\t# \"both,yes\" lib.so.V(shr.o) shared, rtl:yes, for executables\n\t#            lib.a(lib.so.V) shared, rtl:no\n\t# \"svr4,*\"   lib.so.V(shr.o) shared, rtl:yes, for executables\n\t#            lib.a           static archive\n\tcase $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t  for ld_flag in $LDFLAGS; do\n\t  if (test x-brtl = \"x$ld_flag\" || test x-Wl,-brtl = \"x$ld_flag\"); then\n\t    aix_use_runtimelinking=yes\n\t    break\n\t  fi\n\t  done\n\t  if test svr4,no = \"$with_aix_soname,$aix_use_runtimelinking\"; then\n\t    # With aix-soname=svr4, we create the lib.so.V shared archives only,\n\t    # so we don't have lib.a shared libs to link our executables.\n\t    # We have to force runtime linking in this case.\n\t    aix_use_runtimelinking=yes\n\t    LDFLAGS=\"$LDFLAGS -Wl,-brtl\"\n\t  fi\n\t  ;;\n\tesac\n\n\texp_sym_flag='-bexport'\n\tno_entry_flag='-bnoentry'\n      fi\n\n      # When large executables or shared objects are built, AIX ld can\n      # have problems creating the table of contents.  If linking a library\n      # or program results in \"error TOC overflow\" add -mminimal-toc to\n      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n      _LT_TAGVAR(archive_cmds, $1)=''\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(file_list_spec, $1)='$wl-f,'\n      case $with_aix_soname,$aix_use_runtimelinking in\n      aix,*) ;; # traditional, no import file\n      svr4,* | *,yes) # use import file\n\t# The Import File defines what to hardcode.\n\t_LT_TAGVAR(hardcode_direct, $1)=no\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n\t;;\n      esac\n\n      if test yes = \"$GCC\"; then\n\tcase $host_os in aix4.[[012]]|aix4.[[012]].*)\n\t# We only want to do this on AIX 4.2 and lower, the check\n\t# below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`$CC -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t   strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t  # We have reworked collect2\n\t  :\n\t  else\n\t  # We have old collect2\n\t  _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t  # It fails to find uninstalled libraries when the uninstalled\n\t  # path is not listed in the libpath.  Setting hardcode_minus_L\n\t  # to unsupported forces relinking\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n\t  ;;\n\tesac\n\tshared_flag='-shared'\n\tif test yes = \"$aix_use_runtimelinking\"; then\n\t  shared_flag=\"$shared_flag \"'$wl-G'\n\tfi\n\t# Need to ensure runtime linking is disabled for the traditional\n\t# shared library, or the linker may eventually find shared libraries\n\t# /with/ Import File - we do not want to mix them.\n\tshared_flag_aix='-shared'\n\tshared_flag_svr4='-shared $wl-G'\n      else\n\t# not using gcc\n\tif test ia64 = \"$host_cpu\"; then\n\t# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t# chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n\telse\n\t  if test yes = \"$aix_use_runtimelinking\"; then\n\t    shared_flag='$wl-G'\n\t  else\n\t    shared_flag='$wl-bM:SRE'\n\t  fi\n\t  shared_flag_aix='$wl-bM:SRE'\n\t  shared_flag_svr4='$wl-G'\n\tfi\n      fi\n\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-bexpall'\n      # It seems that -bexpall does not export symbols beginning with\n      # underscore (_), so it is better to generate a list of symbols to export.\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      if test aix,yes = \"$with_aix_soname,$aix_use_runtimelinking\"; then\n\t# Warning - without using the other runtime loading flags (-brtl),\n\t# -berok will link without error, but may produce a broken library.\n\t_LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n        # Determine the default libpath from the value encoded in an\n        # empty executable.\n        _LT_SYS_MODULE_PATH_AIX([$1])\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'\"$aix_libpath\"\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs $wl'$no_entry_flag' $compiler_flags `if test -n \"$allow_undefined_flag\"; then func_echo_all \"$wl$allow_undefined_flag\"; else :; fi` $wl'$exp_sym_flag:\\$export_symbols' '$shared_flag\n      else\n\tif test ia64 = \"$host_cpu\"; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R $libdir:/usr/lib:/lib'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\$wl$no_entry_flag\"' $compiler_flags $wl$allow_undefined_flag '\"\\$wl$exp_sym_flag:\\$export_symbols\"\n\telse\n\t # Determine the default libpath from the value encoded in an\n\t # empty executable.\n\t _LT_SYS_MODULE_PATH_AIX([$1])\n\t _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'\"$aix_libpath\"\n\t  # Warning - without using the other run time loading flags,\n\t  # -berok will link without error, but may produce a broken library.\n\t  _LT_TAGVAR(no_undefined_flag, $1)=' $wl-bernotok'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-berok'\n\t  if test yes = \"$with_gnu_ld\"; then\n\t    # We only use this code for GNU lds that support --whole-archive.\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive$convenience $wl--no-whole-archive'\n\t  else\n\t    # Exported symbols can be pulled into shared objects from archives\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t  fi\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$RM -r $output_objdir/$realname.d~$MKDIR $output_objdir/$realname.d'\n\t  # -brtl affects multiple linker settings, -berok does not and is overridden later\n\t  compiler_flags_filtered='`func_echo_all \"$compiler_flags \" | $SED -e \"s%-brtl\\\\([[, ]]\\\\)%-berok\\\\1%g\"`'\n\t  if test svr4 != \"$with_aix_soname\"; then\n\t    # This is similar to how AIX traditionally builds its shared libraries.\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$CC '$shared_flag_aix' -o $output_objdir/$realname.d/$soname $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$realname.d/$soname'\n\t  fi\n\t  if test aix != \"$with_aix_soname\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$CC '$shared_flag_svr4' -o $output_objdir/$realname.d/$shared_archive_member_spec.o $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$STRIP -e $output_objdir/$realname.d/$shared_archive_member_spec.o~( func_echo_all \"#! $soname($shared_archive_member_spec.o)\"; if test shr_64 = \"$shared_archive_member_spec\"; then func_echo_all \"# 64\"; else func_echo_all \"# 32\"; fi; cat $export_symbols ) > $output_objdir/$realname.d/$shared_archive_member_spec.imp~$AR $AR_FLAGS $output_objdir/$soname $output_objdir/$realname.d/$shared_archive_member_spec.o $output_objdir/$realname.d/$shared_archive_member_spec.imp'\n\t  else\n\t    # used by -dlpreopen to get the symbols\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$MV  $output_objdir/$realname.d/$soname $output_objdir'\n\t  fi\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$RM -r $output_objdir/$realname.d'\n\tfi\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    bsdi[[45]]*)\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # When not using gcc, we currently assume that we are using\n      # Microsoft Visual C++.\n      # hardcode_libdir_flag_spec is actually meaningless, as there is\n      # no search path for DLLs.\n      case $cc_basename in\n      cl*)\n\t# Native MSVC\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t_LT_TAGVAR(always_export_symbols, $1)=yes\n\t_LT_TAGVAR(file_list_spec, $1)='@'\n\t# Tell ltmain to make .lib files, not .a files.\n\tlibext=lib\n\t# Tell ltmain to make .dll files, not .so files.\n\tshrext_cmds=.dll\n\t# FIXME: Setting linknames here is a bad hack.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~linknames='\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then\n            cp \"$export_symbols\" \"$output_objdir/$soname.def\";\n            echo \"$tool_output_objdir$soname.def\" > \"$output_objdir/$soname.exp\";\n          else\n            $SED -e '\\''s/^/-link -EXPORT:/'\\'' < $export_symbols > $output_objdir/$soname.exp;\n          fi~\n          $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs \"@$tool_output_objdir$soname.exp\" -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~\n          linknames='\n\t# The linker will not automatically build a static lib if we build a DLL.\n\t# _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t_LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'\n\t_LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1,DATA/'\\'' | $SED -e '\\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\\'' | sort | uniq > $export_symbols'\n\t# Don't use ranlib\n\t_LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'\n\t_LT_TAGVAR(postlink_cmds, $1)='lt_outputfile=\"@OUTPUT@\"~\n          lt_tool_outputfile=\"@TOOL_OUTPUT@\"~\n          case $lt_outputfile in\n            *.exe|*.EXE) ;;\n            *)\n              lt_outputfile=$lt_outputfile.exe\n              lt_tool_outputfile=$lt_tool_outputfile.exe\n              ;;\n          esac~\n          if test : != \"$MANIFEST_TOOL\" && test -f \"$lt_outputfile.manifest\"; then\n            $MANIFEST_TOOL -manifest \"$lt_tool_outputfile.manifest\" -outputresource:\"$lt_tool_outputfile\" || exit 1;\n            $RM \"$lt_outputfile.manifest\";\n          fi'\n\t;;\n      *)\n\t# Assume MSVC wrapper\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Tell ltmain to make .lib files, not .a files.\n\tlibext=lib\n\t# Tell ltmain to make .dll files, not .so files.\n\tshrext_cmds=.dll\n\t# FIXME: Setting linknames here is a bad hack.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `func_echo_all \"$deplibs\" | $SED '\\''s/ -lc$//'\\''` -link -dll~linknames='\n\t# The linker will automatically build a .lib file if we build a DLL.\n\t_LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t# FIXME: Should let the user specify the lib program.\n\t_LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t;;\n      esac\n      ;;\n\n    darwin* | rhapsody*)\n      _LT_DARWIN_LINKER_FEATURES($1)\n      ;;\n\n    dgux*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor\n    # support.  Future versions do this automatically, but an explicit c++rt0.o\n    # does not break anything, and helps significantly (at the cost of a little\n    # extra space).\n    freebsd2.2*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # Unfortunately, older versions of FreeBSD 2 do not have this feature.\n    freebsd2.*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.\n    freebsd* | dragonfly*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    hpux9*)\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared $pic_flag $wl+b $wl$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test \"x$output_objdir/$soname\" = \"x$lib\" || mv $output_objdir/$soname $lib'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test \"x$output_objdir/$soname\" = \"x$lib\" || mv $output_objdir/$soname $lib'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n\n      # hardcode_minus_L: Not really in the search PATH,\n      # but as the default location of the library.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n      ;;\n\n    hpux10*)\n      if test yes,no = \"$GCC,$with_gnu_ld\"; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      if test no = \"$with_gnu_ld\"; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n\t# hardcode_minus_L: Not really in the search PATH,\n\t# but as the default location of the library.\n\t_LT_TAGVAR(hardcode_minus_L, $1)=yes\n      fi\n      ;;\n\n    hpux11*)\n      if test yes,no = \"$GCC,$with_gnu_ld\"; then\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl+h $wl$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl+h $wl$soname $wl+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      else\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\tm4_if($1, [], [\n\t  # Older versions of the 11.00 compiler do not understand -b yet\n\t  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)\n\t  _LT_LINKER_OPTION([if $CC understands -b],\n\t    _LT_TAGVAR(lt_cv_prog_compiler__b, $1), [-b],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'])],\n\t  [_LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'])\n\t  ;;\n\tesac\n      fi\n      if test no = \"$with_gnu_ld\"; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\tcase $host_cpu in\n\thppa*64*|ia64*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n\n\t  # hardcode_minus_L: Not really in the search PATH,\n\t  # but as the default location of the library.\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  ;;\n\tesac\n      fi\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n\t# Try to use the -exported_symbol ld option, if it does not\n\t# work, assume that -exports_file does not work either and\n\t# implicitly export all symbols.\n\t# This should be the same for all languages, so no per-tag cache variable.\n\tAC_CACHE_CHECK([whether the $host_os linker accepts -exported_symbol],\n\t  [lt_cv_irix_exported_symbol],\n\t  [save_LDFLAGS=$LDFLAGS\n\t   LDFLAGS=\"$LDFLAGS -shared $wl-exported_symbol ${wl}foo $wl-update_registry $wl/dev/null\"\n\t   AC_LINK_IFELSE(\n\t     [AC_LANG_SOURCE(\n\t        [AC_LANG_CASE([C], [[int foo (void) { return 0; }]],\n\t\t\t      [C++], [[int foo (void) { return 0; }]],\n\t\t\t      [Fortran 77], [[\n      subroutine foo\n      end]],\n\t\t\t      [Fortran], [[\n      subroutine foo\n      end]])])],\n\t      [lt_cv_irix_exported_symbol=yes],\n\t      [lt_cv_irix_exported_symbol=no])\n           LDFLAGS=$save_LDFLAGS])\n\tif test yes = \"$lt_cv_irix_exported_symbol\"; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations $wl-exports_file $wl$export_symbols -o $lib'\n\tfi\n\t_LT_TAGVAR(link_all_deplibs, $1)=no\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -exports_file $export_symbols -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(inherit_rpath, $1)=yes\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    linux*)\n      case $cc_basename in\n      tcc*)\n\t# Fabrice Bellard et al's Tiny C Compiler\n\t_LT_TAGVAR(ld_shlibs, $1)=yes\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t;;\n      esac\n      ;;\n\n    netbsd* | netbsdelf*-gnu)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *nto* | *qnx*)\n      ;;\n\n    openbsd* | bitrig*)\n      if test -f /usr/libexec/ld.so; then\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\tif test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\"; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags $wl-retain-symbols-file,$export_symbols'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n\telse\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\tfi\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    os2*)\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      shrext_cmds=.dll\n      _LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t$ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t$ECHO EXPORTS >> $output_objdir/$libname.def~\n\temxexp $libobjs | $SED /\"_DLL_InitTerm\"/d >> $output_objdir/$libname.def~\n\t$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\temximp -o $lib $output_objdir/$libname.def'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t$ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t$ECHO EXPORTS >> $output_objdir/$libname.def~\n\tprefix_cmds=\"$SED\"~\n\tif test EXPORTS = \"`$SED 1q $export_symbols`\"; then\n\t  prefix_cmds=\"$prefix_cmds -e 1d\";\n\tfi~\n\tprefix_cmds=\"$prefix_cmds -e \\\"s/^\\(.*\\)$/_\\1/g\\\"\"~\n\tcat $export_symbols | $prefix_cmds >> $output_objdir/$libname.def~\n\t$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\temximp -o $lib $output_objdir/$libname.def'\n      _LT_TAGVAR(old_archive_From_new_cmds, $1)='emximp -o $output_objdir/${libname}_dll.a $output_objdir/$libname.def'\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      ;;\n\n    osf3*)\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    osf4* | osf5*)\t# as osf3* with the addition of -msym flag\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $pic_flag $libobjs $deplibs $compiler_flags $wl-msym $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done; printf \"%s\\\\n\" \"-hidden\">> $lib.exp~\n          $CC -shared$allow_undefined_flag $wl-input $wl$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib~$RM $lib.exp'\n\n\t# Both c and cxx compiler support -rpath directly\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'\n      if test yes = \"$GCC\"; then\n\twlarc='$wl'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl-z ${wl}text $wl-h $wl$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n          $CC -shared $pic_flag $wl-z ${wl}text $wl-M $wl$lib.exp $wl-h $wl$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n      else\n\tcase `$CC -V 2>&1` in\n\t*\"Compilers 5.0\"*)\n\t  wlarc=''\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G$allow_undefined_flag -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n            $LD -G$allow_undefined_flag -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'\n\t  ;;\n\t*)\n\t  wlarc='$wl'\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G$allow_undefined_flag -h $soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n            $CC -G$allow_undefined_flag -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n\t  ;;\n\tesac\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      case $host_os in\n      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n      *)\n\t# The compiler driver will combine and reorder linker options,\n\t# but understands '-z linker_flag'.  GCC discards it without '$wl',\n\t# but is careful enough not to reorder.\n\t# Supported since Solaris 2.6 (maybe 2.5.1?)\n\tif test yes = \"$GCC\"; then\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl-z ${wl}allextract$convenience $wl-z ${wl}defaultextract'\n\telse\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\tfi\n\t;;\n      esac\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    sunos4*)\n      if test sequent = \"$host_vendor\"; then\n\t# Use $CC to link under sequent, because it throws in some extra .o\n\t# files that make .init and .fini sections work.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h $soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4)\n      case $host_vendor in\n\tsni)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???\n\t;;\n\tsiemens)\n\t  ## LD is ld it makes a PLAMLIB\n\t  ## CC just makes a GrossModule.\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n        ;;\n\tmotorola)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie\n\t;;\n      esac\n      runpath_var='LD_RUN_PATH'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4.3*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\trunpath_var=LD_RUN_PATH\n\thardcode_runpath_var=yes\n\t_LT_TAGVAR(ld_shlibs, $1)=yes\n      fi\n      ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6*)\n      # Note: We CANNOT use -z defs as we might desire, because we do not\n      # link with -lc, and that would cause any symbols used from libc to\n      # always be unresolved, which means just about no library would\n      # ever link correctly.  If we're not using GNU ld we use -z text\n      # though, which does catch some bad symbols but isn't as heavy-handed\n      # as -z defs.\n      _LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'\n      _LT_TAGVAR(allow_undefined_flag, $1)='$wl-z,nodefs'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R,$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-Bexport'\n      runpath_var='LD_RUN_PATH'\n\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      _LT_TAGVAR(ld_shlibs, $1)=no\n      ;;\n    esac\n\n    if test sni = \"$host_vendor\"; then\n      case $host in\n      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-Blargedynsym'\n\t;;\n      esac\n    fi\n  fi\n])\nAC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\ntest no = \"$_LT_TAGVAR(ld_shlibs, $1)\" && can_build_shared=no\n\n_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld\n\n_LT_DECL([], [libext], [0], [Old archive suffix (normally \"a\")])dnl\n_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally \".so\")])dnl\n_LT_DECL([], [extract_expsyms_cmds], [2],\n    [The commands to extract the exported symbol list from a shared archive])\n\n#\n# Do we need to explicitly link libc?\n#\ncase \"x$_LT_TAGVAR(archive_cmds_need_lc, $1)\" in\nx|xyes)\n  # Assume -lc should be added\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\n  if test yes,yes = \"$GCC,$enable_shared\"; then\n    case $_LT_TAGVAR(archive_cmds, $1) in\n    *'~'*)\n      # FIXME: we may have to deal with multi-command sequences.\n      ;;\n    '$CC '*)\n      # Test whether the compiler implicitly links with -lc since on some\n      # systems, -lgcc has to come before -lc. If gcc already passes -lc\n      # to ld, don't add -lc before -lgcc.\n      AC_CACHE_CHECK([whether -lc should be explicitly linked in],\n\t[lt_cv_]_LT_TAGVAR(archive_cmds_need_lc, $1),\n\t[$RM conftest*\n\techo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n\tif AC_TRY_EVAL(ac_compile) 2>conftest.err; then\n\t  soname=conftest\n\t  lib=conftest\n\t  libobjs=conftest.$ac_objext\n\t  deplibs=\n\t  wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)\n\t  pic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)\n\t  compiler_flags=-v\n\t  linker_flags=-v\n\t  verstring=\n\t  output_objdir=.\n\t  libname=conftest\n\t  lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\n\t  if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\\>\\&1 \\| $GREP \\\" -lc \\\" \\>/dev/null 2\\>\\&1)\n\t  then\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t  else\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  fi\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag\n\telse\n\t  cat conftest.err 1>&5\n\tfi\n\t$RM conftest*\n\t])\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=$lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)\n      ;;\n    esac\n  fi\n  ;;\nesac\n\n_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],\n    [Whether or not to add -lc for building shared libraries])\n_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],\n    [enable_shared_with_static_runtimes], [0],\n    [Whether or not to disallow shared libs when runtime libs are static])\n_LT_TAGDECL([], [export_dynamic_flag_spec], [1],\n    [Compiler flag to allow reflexive dlopens])\n_LT_TAGDECL([], [whole_archive_flag_spec], [1],\n    [Compiler flag to generate shared objects directly from archives])\n_LT_TAGDECL([], [compiler_needs_object], [1],\n    [Whether the compiler copes with passing no objects directly])\n_LT_TAGDECL([], [old_archive_from_new_cmds], [2],\n    [Create an old-style archive from a shared archive])\n_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],\n    [Create a temporary old-style archive to link instead of a shared archive])\n_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])\n_LT_TAGDECL([], [archive_expsym_cmds], [2])\n_LT_TAGDECL([], [module_cmds], [2],\n    [Commands used to build a loadable module if different from building\n    a shared archive.])\n_LT_TAGDECL([], [module_expsym_cmds], [2])\n_LT_TAGDECL([], [with_gnu_ld], [1],\n    [Whether we are building with GNU ld or not])\n_LT_TAGDECL([], [allow_undefined_flag], [1],\n    [Flag that allows shared libraries with undefined symbols to be built])\n_LT_TAGDECL([], [no_undefined_flag], [1],\n    [Flag that enforces no undefined symbols])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],\n    [Flag to hardcode $libdir into a binary during linking.\n    This must work even if $libdir does not exist])\n_LT_TAGDECL([], [hardcode_libdir_separator], [1],\n    [Whether we need a single \"-rpath\" flag with a separated argument])\n_LT_TAGDECL([], [hardcode_direct], [0],\n    [Set to \"yes\" if using DIR/libNAME$shared_ext during linking hardcodes\n    DIR into the resulting binary])\n_LT_TAGDECL([], [hardcode_direct_absolute], [0],\n    [Set to \"yes\" if using DIR/libNAME$shared_ext during linking hardcodes\n    DIR into the resulting binary and the resulting library dependency is\n    \"absolute\", i.e impossible to change by setting $shlibpath_var if the\n    library is relocated])\n_LT_TAGDECL([], [hardcode_minus_L], [0],\n    [Set to \"yes\" if using the -LDIR flag during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_shlibpath_var], [0],\n    [Set to \"yes\" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_automatic], [0],\n    [Set to \"yes\" if building a shared library automatically hardcodes DIR\n    into the library and all subsequent libraries and executables linked\n    against it])\n_LT_TAGDECL([], [inherit_rpath], [0],\n    [Set to yes if linker adds runtime paths of dependent libraries\n    to runtime path list])\n_LT_TAGDECL([], [link_all_deplibs], [0],\n    [Whether libtool must link a program against all its dependency libraries])\n_LT_TAGDECL([], [always_export_symbols], [0],\n    [Set to \"yes\" if exported symbols are required])\n_LT_TAGDECL([], [export_symbols_cmds], [2],\n    [The commands to list exported symbols])\n_LT_TAGDECL([], [exclude_expsyms], [1],\n    [Symbols that should not be listed in the preloaded symbols])\n_LT_TAGDECL([], [include_expsyms], [1],\n    [Symbols that must always be exported])\n_LT_TAGDECL([], [prelink_cmds], [2],\n    [Commands necessary for linking programs (against libraries) with templates])\n_LT_TAGDECL([], [postlink_cmds], [2],\n    [Commands necessary for finishing linking programs])\n_LT_TAGDECL([], [file_list_spec], [1],\n    [Specify filename containing input files])\ndnl FIXME: Not yet implemented\ndnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],\ndnl    [Compiler flag to generate thread safe objects])\n])# _LT_LINKER_SHLIBS\n\n\n# _LT_LANG_C_CONFIG([TAG])\n# ------------------------\n# Ensure that the configuration variables for a C compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_C_CONFIG],\n[m4_require([_LT_DECL_EGREP])dnl\nlt_save_CC=$CC\nAC_LANG_PUSH(C)\n\n# Source file extension for C test sources.\nac_ext=c\n\n# Object file extension for compiled C test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"int some_variable = 0;\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='int main(){return(0);}'\n\n_LT_TAG_COMPILER\n# Save the default compiler, since it gets overwritten when the other\n# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.\ncompiler_DEFAULT=$CC\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_SYS_DYNAMIC_LINKER($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n  LT_SYS_DLOPEN_SELF\n  _LT_CMD_STRIPLIB\n\n  # Report what library types will actually be built\n  AC_MSG_CHECKING([if libtool supports shared libraries])\n  AC_MSG_RESULT([$can_build_shared])\n\n  AC_MSG_CHECKING([whether to build shared libraries])\n  test no = \"$can_build_shared\" && enable_shared=no\n\n  # On AIX, shared libraries and static libraries use the same namespace, and\n  # are all built from PIC.\n  case $host_os in\n  aix3*)\n    test yes = \"$enable_shared\" && enable_static=no\n    if test -n \"$RANLIB\"; then\n      archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n      postinstall_cmds='$RANLIB $lib'\n    fi\n    ;;\n\n  aix[[4-9]]*)\n    if test ia64 != \"$host_cpu\"; then\n      case $enable_shared,$with_aix_soname,$aix_use_runtimelinking in\n      yes,aix,yes) ;;\t\t\t# shared object as lib.so file only\n      yes,svr4,*) ;;\t\t\t# shared object as lib.so archive member only\n      yes,*) enable_static=no ;;\t# shared object in lib.a archive as well\n      esac\n    fi\n    ;;\n  esac\n  AC_MSG_RESULT([$enable_shared])\n\n  AC_MSG_CHECKING([whether to build static libraries])\n  # Make sure either enable_shared or enable_static is yes.\n  test yes = \"$enable_shared\" || enable_static=yes\n  AC_MSG_RESULT([$enable_static])\n\n  _LT_CONFIG($1)\nfi\nAC_LANG_POP\nCC=$lt_save_CC\n])# _LT_LANG_C_CONFIG\n\n\n# _LT_LANG_CXX_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a C++ compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_CXX_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PATH_MANIFEST_TOOL])dnl\nif test -n \"$CXX\" && ( test no != \"$CXX\" &&\n    ( (test g++ = \"$CXX\" && `g++ -v >/dev/null 2>&1` ) ||\n    (test g++ != \"$CXX\"))); then\n  AC_PROG_CXXCPP\nelse\n  _lt_caught_CXX_error=yes\nfi\n\nAC_LANG_PUSH(C++)\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(compiler_needs_object, $1)=no\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for C++ test sources.\nac_ext=cpp\n\n# Object file extension for compiled C++ test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the CXX compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test yes != \"$_lt_caught_CXX_error\"; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"int some_variable = 0;\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_CFLAGS=$CFLAGS\n  lt_save_LD=$LD\n  lt_save_GCC=$GCC\n  GCC=$GXX\n  lt_save_with_gnu_ld=$with_gnu_ld\n  lt_save_path_LD=$lt_cv_path_LD\n  if test -n \"${lt_cv_prog_gnu_ldcxx+set}\"; then\n    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx\n  else\n    $as_unset lt_cv_prog_gnu_ld\n  fi\n  if test -n \"${lt_cv_path_LDCXX+set}\"; then\n    lt_cv_path_LD=$lt_cv_path_LDCXX\n  else\n    $as_unset lt_cv_path_LD\n  fi\n  test -z \"${LDCXX+set}\" || LD=$LDCXX\n  CC=${CXX-\"c++\"}\n  CFLAGS=$CXXFLAGS\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    # We don't want -fno-exception when compiling C++ code, so set the\n    # no_builtin_flag separately\n    if test yes = \"$GXX\"; then\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n    else\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n    fi\n\n    if test yes = \"$GXX\"; then\n      # Set up default GNU C++ configuration\n\n      LT_PATH_LD\n\n      # Check if GNU C++ uses GNU ld as the underlying linker, since the\n      # archiving commands below assume that GNU ld is being used.\n      if test yes = \"$with_gnu_ld\"; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n\n        # If archive_cmds runs LD, not CC, wlarc should be empty\n        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to\n        #     investigate it a little bit more. (MM)\n        wlarc='$wl'\n\n        # ancient GNU ld didn't support --whole-archive et. al.\n        if eval \"`$CC -print-prog-name=ld` --help 2>&1\" |\n\t  $GREP 'no-whole-archive' > /dev/null; then\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=$wlarc'--whole-archive$convenience '$wlarc'--no-whole-archive'\n        else\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\n        fi\n      else\n        with_gnu_ld=no\n        wlarc=\n\n        # A generic and very simple default shared library creation\n        # command for GNU C++ for the case where it uses the native\n        # linker, instead of GNU ld.  If possible, this setting should\n        # overridden to take advantage of the native linker features on\n        # the platform it is being used on.\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n      fi\n\n      # Commands to make compiler produce verbose output that lists\n      # what \"hidden\" libraries, object files and flags are used when\n      # linking a shared library.\n      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n    else\n      GXX=no\n      with_gnu_ld=no\n      wlarc=\n    fi\n\n    # PORTME: fill in a description of your system's C++ link characteristics\n    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\n    _LT_TAGVAR(ld_shlibs, $1)=yes\n    case $host_os in\n      aix3*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n      aix[[4-9]]*)\n        if test ia64 = \"$host_cpu\"; then\n          # On IA64, the linker does run time linking by default, so we don't\n          # have to do anything special.\n          aix_use_runtimelinking=no\n          exp_sym_flag='-Bexport'\n          no_entry_flag=\n        else\n          aix_use_runtimelinking=no\n\n          # Test if we are trying to use run time linking or normal\n          # AIX style linking. If -brtl is somewhere in LDFLAGS, we\n          # have runtime linking enabled, and use it for executables.\n          # For shared libraries, we enable/disable runtime linking\n          # depending on the kind of the shared library created -\n          # when \"with_aix_soname,aix_use_runtimelinking\" is:\n          # \"aix,no\"   lib.a(lib.so.V) shared, rtl:no,  for executables\n          # \"aix,yes\"  lib.so          shared, rtl:yes, for executables\n          #            lib.a           static archive\n          # \"both,no\"  lib.so.V(shr.o) shared, rtl:yes\n          #            lib.a(lib.so.V) shared, rtl:no,  for executables\n          # \"both,yes\" lib.so.V(shr.o) shared, rtl:yes, for executables\n          #            lib.a(lib.so.V) shared, rtl:no\n          # \"svr4,*\"   lib.so.V(shr.o) shared, rtl:yes, for executables\n          #            lib.a           static archive\n          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t    for ld_flag in $LDFLAGS; do\n\t      case $ld_flag in\n\t      *-brtl*)\n\t        aix_use_runtimelinking=yes\n\t        break\n\t        ;;\n\t      esac\n\t    done\n\t    if test svr4,no = \"$with_aix_soname,$aix_use_runtimelinking\"; then\n\t      # With aix-soname=svr4, we create the lib.so.V shared archives only,\n\t      # so we don't have lib.a shared libs to link our executables.\n\t      # We have to force runtime linking in this case.\n\t      aix_use_runtimelinking=yes\n\t      LDFLAGS=\"$LDFLAGS -Wl,-brtl\"\n\t    fi\n\t    ;;\n          esac\n\n          exp_sym_flag='-bexport'\n          no_entry_flag='-bnoentry'\n        fi\n\n        # When large executables or shared objects are built, AIX ld can\n        # have problems creating the table of contents.  If linking a library\n        # or program results in \"error TOC overflow\" add -mminimal-toc to\n        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n        _LT_TAGVAR(archive_cmds, $1)=''\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        _LT_TAGVAR(file_list_spec, $1)='$wl-f,'\n        case $with_aix_soname,$aix_use_runtimelinking in\n        aix,*) ;;\t# no import file\n        svr4,* | *,yes) # use import file\n          # The Import File defines what to hardcode.\n          _LT_TAGVAR(hardcode_direct, $1)=no\n          _LT_TAGVAR(hardcode_direct_absolute, $1)=no\n          ;;\n        esac\n\n        if test yes = \"$GXX\"; then\n          case $host_os in aix4.[[012]]|aix4.[[012]].*)\n          # We only want to do this on AIX 4.2 and lower, the check\n          # below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`$CC -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t     strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t    # We have reworked collect2\n\t    :\n\t  else\n\t    # We have old collect2\n\t    _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t    # It fails to find uninstalled libraries when the uninstalled\n\t    # path is not listed in the libpath.  Setting hardcode_minus_L\n\t    # to unsupported forces relinking\n\t    _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n          esac\n          shared_flag='-shared'\n\t  if test yes = \"$aix_use_runtimelinking\"; then\n\t    shared_flag=$shared_flag' $wl-G'\n\t  fi\n\t  # Need to ensure runtime linking is disabled for the traditional\n\t  # shared library, or the linker may eventually find shared libraries\n\t  # /with/ Import File - we do not want to mix them.\n\t  shared_flag_aix='-shared'\n\t  shared_flag_svr4='-shared $wl-G'\n        else\n          # not using gcc\n          if test ia64 = \"$host_cpu\"; then\n\t  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t  # chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n          else\n\t    if test yes = \"$aix_use_runtimelinking\"; then\n\t      shared_flag='$wl-G'\n\t    else\n\t      shared_flag='$wl-bM:SRE'\n\t    fi\n\t    shared_flag_aix='$wl-bM:SRE'\n\t    shared_flag_svr4='$wl-G'\n          fi\n        fi\n\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-bexpall'\n        # It seems that -bexpall does not export symbols beginning with\n        # underscore (_), so it is better to generate a list of symbols to\n\t# export.\n        _LT_TAGVAR(always_export_symbols, $1)=yes\n\tif test aix,yes = \"$with_aix_soname,$aix_use_runtimelinking\"; then\n          # Warning - without using the other runtime loading flags (-brtl),\n          # -berok will link without error, but may produce a broken library.\n          # The \"-G\" linker flag allows undefined symbols.\n          _LT_TAGVAR(no_undefined_flag, $1)='-bernotok'\n          # Determine the default libpath from the value encoded in an empty\n          # executable.\n          _LT_SYS_MODULE_PATH_AIX([$1])\n          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'\"$aix_libpath\"\n\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs $wl'$no_entry_flag' $compiler_flags `if test -n \"$allow_undefined_flag\"; then func_echo_all \"$wl$allow_undefined_flag\"; else :; fi` $wl'$exp_sym_flag:\\$export_symbols' '$shared_flag\n        else\n          if test ia64 = \"$host_cpu\"; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R $libdir:/usr/lib:/lib'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\$wl$no_entry_flag\"' $compiler_flags $wl$allow_undefined_flag '\"\\$wl$exp_sym_flag:\\$export_symbols\"\n          else\n\t    # Determine the default libpath from the value encoded in an\n\t    # empty executable.\n\t    _LT_SYS_MODULE_PATH_AIX([$1])\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'\"$aix_libpath\"\n\t    # Warning - without using the other run time loading flags,\n\t    # -berok will link without error, but may produce a broken library.\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' $wl-bernotok'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-berok'\n\t    if test yes = \"$with_gnu_ld\"; then\n\t      # We only use this code for GNU lds that support --whole-archive.\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive$convenience $wl--no-whole-archive'\n\t    else\n\t      # Exported symbols can be pulled into shared objects from archives\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t    fi\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$RM -r $output_objdir/$realname.d~$MKDIR $output_objdir/$realname.d'\n\t    # -brtl affects multiple linker settings, -berok does not and is overridden later\n\t    compiler_flags_filtered='`func_echo_all \"$compiler_flags \" | $SED -e \"s%-brtl\\\\([[, ]]\\\\)%-berok\\\\1%g\"`'\n\t    if test svr4 != \"$with_aix_soname\"; then\n\t      # This is similar to how AIX traditionally builds its shared\n\t      # libraries. Need -bnortl late, we may have -brtl in LDFLAGS.\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$CC '$shared_flag_aix' -o $output_objdir/$realname.d/$soname $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$realname.d/$soname'\n\t    fi\n\t    if test aix != \"$with_aix_soname\"; then\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$CC '$shared_flag_svr4' -o $output_objdir/$realname.d/$shared_archive_member_spec.o $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$STRIP -e $output_objdir/$realname.d/$shared_archive_member_spec.o~( func_echo_all \"#! $soname($shared_archive_member_spec.o)\"; if test shr_64 = \"$shared_archive_member_spec\"; then func_echo_all \"# 64\"; else func_echo_all \"# 32\"; fi; cat $export_symbols ) > $output_objdir/$realname.d/$shared_archive_member_spec.imp~$AR $AR_FLAGS $output_objdir/$soname $output_objdir/$realname.d/$shared_archive_member_spec.o $output_objdir/$realname.d/$shared_archive_member_spec.imp'\n\t    else\n\t      # used by -dlpreopen to get the symbols\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$MV  $output_objdir/$realname.d/$soname $output_objdir'\n\t    fi\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$RM -r $output_objdir/$realname.d'\n          fi\n        fi\n        ;;\n\n      beos*)\n\tif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t  # support --undefined.  This deserves some investigation.  FIXME\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      chorus*)\n        case $cc_basename in\n          *)\n\t  # FIXME: insert proper C++ library support\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\t  ;;\n        esac\n        ;;\n\n      cygwin* | mingw* | pw32* | cegcc*)\n\tcase $GXX,$cc_basename in\n\t,cl* | no,cl*)\n\t  # Native MSVC\n\t  # hardcode_libdir_flag_spec is actually meaningless, as there is\n\t  # no search path for DLLs.\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  _LT_TAGVAR(always_export_symbols, $1)=yes\n\t  _LT_TAGVAR(file_list_spec, $1)='@'\n\t  # Tell ltmain to make .lib files, not .a files.\n\t  libext=lib\n\t  # Tell ltmain to make .dll files, not .so files.\n\t  shrext_cmds=.dll\n\t  # FIXME: Setting linknames here is a bad hack.\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~linknames='\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then\n              cp \"$export_symbols\" \"$output_objdir/$soname.def\";\n              echo \"$tool_output_objdir$soname.def\" > \"$output_objdir/$soname.exp\";\n            else\n              $SED -e '\\''s/^/-link -EXPORT:/'\\'' < $export_symbols > $output_objdir/$soname.exp;\n            fi~\n            $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs \"@$tool_output_objdir$soname.exp\" -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~\n            linknames='\n\t  # The linker will not automatically build a static lib if we build a DLL.\n\t  # _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t  # Don't use ranlib\n\t  _LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'\n\t  _LT_TAGVAR(postlink_cmds, $1)='lt_outputfile=\"@OUTPUT@\"~\n            lt_tool_outputfile=\"@TOOL_OUTPUT@\"~\n            case $lt_outputfile in\n              *.exe|*.EXE) ;;\n              *)\n                lt_outputfile=$lt_outputfile.exe\n                lt_tool_outputfile=$lt_tool_outputfile.exe\n                ;;\n            esac~\n            func_to_tool_file \"$lt_outputfile\"~\n            if test : != \"$MANIFEST_TOOL\" && test -f \"$lt_outputfile.manifest\"; then\n              $MANIFEST_TOOL -manifest \"$lt_tool_outputfile.manifest\" -outputresource:\"$lt_tool_outputfile\" || exit 1;\n              $RM \"$lt_outputfile.manifest\";\n            fi'\n\t  ;;\n\t*)\n\t  # g++\n\t  # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n\t  # as there is no search path for DLLs.\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-all-symbols'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  _LT_TAGVAR(always_export_symbols, $1)=no\n\t  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\n\t  if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t    # If the export-symbols file already is a .def file, use it as\n\t    # is; otherwise, prepend EXPORTS...\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then\n              cp $export_symbols $output_objdir/$soname.def;\n            else\n              echo EXPORTS > $output_objdir/$soname.def;\n              cat $export_symbols >> $output_objdir/$soname.def;\n            fi~\n            $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t  ;;\n\tesac\n\t;;\n      darwin* | rhapsody*)\n        _LT_DARWIN_LINKER_FEATURES($1)\n\t;;\n\n      os2*)\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t_LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\tshrext_cmds=.dll\n\t_LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t  $ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t  $ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t  $ECHO EXPORTS >> $output_objdir/$libname.def~\n\t  emxexp $libobjs | $SED /\"_DLL_InitTerm\"/d >> $output_objdir/$libname.def~\n\t  $CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\t  emximp -o $lib $output_objdir/$libname.def'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t  $ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t  $ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t  $ECHO EXPORTS >> $output_objdir/$libname.def~\n\t  prefix_cmds=\"$SED\"~\n\t  if test EXPORTS = \"`$SED 1q $export_symbols`\"; then\n\t    prefix_cmds=\"$prefix_cmds -e 1d\";\n\t  fi~\n\t  prefix_cmds=\"$prefix_cmds -e \\\"s/^\\(.*\\)$/_\\1/g\\\"\"~\n\t  cat $export_symbols | $prefix_cmds >> $output_objdir/$libname.def~\n\t  $CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\t  emximp -o $lib $output_objdir/$libname.def'\n\t_LT_TAGVAR(old_archive_From_new_cmds, $1)='emximp -o $output_objdir/${libname}_dll.a $output_objdir/$libname.def'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t;;\n\n      dgux*)\n        case $cc_basename in\n          ec++*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          ghcx*)\n\t    # Green Hills C++ Compiler\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      freebsd2.*)\n        # C++ shared libraries reported to be fairly broken before\n\t# switch to ELF\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      freebsd-elf*)\n        _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n        ;;\n\n      freebsd* | dragonfly*)\n        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF\n        # conventions\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n        ;;\n\n      haiku*)\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        ;;\n\n      hpux9*)\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t             # but as the default\n\t\t\t\t             # location of the library.\n\n        case $cc_basename in\n          CC*)\n            # FIXME: insert proper C++ library support\n            _LT_TAGVAR(ld_shlibs, $1)=no\n            ;;\n          aCC*)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b $wl+b $wl$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test \"x$output_objdir/$soname\" = \"x$lib\" || mv $output_objdir/$soname $lib'\n            # Commands to make compiler produce verbose output that lists\n            # what \"hidden\" libraries, object files and flags are used when\n            # linking a shared library.\n            #\n            # There doesn't appear to be a way to prevent this compiler from\n            # explicitly linking system object files so we need to strip them\n            # from the output so that they don't get included in the library\n            # dependencies.\n            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP \"\\-L\"`; list= ; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n            ;;\n          *)\n            if test yes = \"$GXX\"; then\n              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib $pic_flag $wl+b $wl$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test \"x$output_objdir/$soname\" = \"x$lib\" || mv $output_objdir/$soname $lib'\n            else\n              # FIXME: insert proper C++ library support\n              _LT_TAGVAR(ld_shlibs, $1)=no\n            fi\n            ;;\n        esac\n        ;;\n\n      hpux10*|hpux11*)\n        if test no = \"$with_gnu_ld\"; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n          case $host_cpu in\n            hppa*64*|ia64*)\n              ;;\n            *)\n\t      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n              ;;\n          esac\n        fi\n        case $host_cpu in\n          hppa*64*|ia64*)\n            _LT_TAGVAR(hardcode_direct, $1)=no\n            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n            ;;\n          *)\n            _LT_TAGVAR(hardcode_direct, $1)=yes\n            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t\t         # but as the default\n\t\t\t\t\t         # location of the library.\n            ;;\n        esac\n\n        case $cc_basename in\n          CC*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          aCC*)\n\t    case $host_cpu in\n\t      hppa*64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      ia64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      *)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t    esac\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP \"\\-L\"`; list= ; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n          *)\n\t    if test yes = \"$GXX\"; then\n\t      if test no = \"$with_gnu_ld\"; then\n\t        case $host_cpu in\n\t          hppa*64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC $wl+h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          ia64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag $wl+h $wl$soname $wl+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          *)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t        esac\n\t      fi\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      interix[[3-9]]*)\n\t_LT_TAGVAR(hardcode_direct, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n\t# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n\t# Instead, shared libraries are loaded at an image base (0x10000000 by\n\t# default) and relocated if they conflict, which is a slow very memory\n\t# consuming and fragmenting process.  To avoid this, we pick a random,\n\t# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n\t# time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s|^|_|\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--retain-symbols-file,$output_objdir/$soname.expsym $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t;;\n      irix5* | irix6*)\n        case $cc_basename in\n          CC*)\n\t    # SGI C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -ar\", where \"CC\" is the IRIX C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    if test yes = \"$GXX\"; then\n\t      if test no = \"$with_gnu_ld\"; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n\t      else\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` -o $lib'\n\t      fi\n\t    fi\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\t    ;;\n        esac\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(inherit_rpath, $1)=yes\n        ;;\n\n      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\$tempext\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\$tempext\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib $wl-retain-symbols-file,$export_symbols; mv \\$templib $lib'\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP \"ld\"`; rm -f libconftest$shared_ext; list= ; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -Bstatic\", where \"CC\" is the KAI C++ compiler.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'\n\t    ;;\n\t  icpc* | ecpc* )\n\t    # Intel C++\n\t    with_gnu_ld=yes\n\t    # version 8.0 and above of icpc choke on multiply defined symbols\n\t    # if we add $predep_objects and $postdep_objects, however 7.1 and\n\t    # earlier do not add the objects themselves.\n\t    case `$CC -V 2>&1` in\n\t      *\"Version 7.\"*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t      *)  # Version 8.0 or newer\n\t        tmp_idyn=\n\t        case $host_cpu in\n\t\t  ia64*) tmp_idyn=' -i_dynamic';;\n\t\tesac\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t    esac\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive$convenience $wl--no-whole-archive'\n\t    ;;\n          pgCC* | pgcpp*)\n            # Portland Group C++ compiler\n\t    case `$CC -V` in\n\t    *pgCC\\ [[1-5]].* | *pgcpp\\ [[1-5]].*)\n\t      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~\n               rm -rf $tpldir~\n               $CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~\n               compile_command=\"$compile_command `find $tpldir -name \\*.o | sort | $NL2SP`\"'\n\t      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~\n                rm -rf $tpldir~\n                $CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~\n                $AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \\*.o | sort | $NL2SP`~\n                $RANLIB $oldlib'\n\t      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~\n                rm -rf $tpldir~\n                $CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n                $CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | sort | $NL2SP` $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~\n                rm -rf $tpldir~\n                $CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n                $CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | sort | $NL2SP` $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\t      ;;\n\t    *) # Version 6 and above use weak symbols\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\t      ;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl--rpath $wl$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n            ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname  -o $lib $wl-retain-symbols-file $wl$export_symbols'\n\n\t    runpath_var=LD_RUN_PATH\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld .*$\\)/\\1/\"`; list= ; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"X$list\" | $Xsed'\n\t    ;;\n\t  xl* | mpixl* | bgxl*)\n\t    # IBM XL 8.0 on PPC, with GNU ld\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t    if test yes = \"$supports_anon_versioning\"; then\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n                cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n                echo \"local: *; };\" >> $output_objdir/$libname.ver~\n                $CC -qmkshrobj $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-version-script $wl$output_objdir/$libname.ver -o $lib'\n\t    fi\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -G$allow_undefined_flag -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G$allow_undefined_flag -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-retain-symbols-file $wl$export_symbols'\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n\t      _LT_TAGVAR(compiler_needs_object, $1)=yes\n\n\t      # Not sure whether something based on\n\t      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1\n\t      # would be better.\n\t      output_verbose_link_cmd='func_echo_all'\n\n\t      # Archives containing C++ object files must be created using\n\t      # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t      # necessary to make sure instantiated templates are included\n\t      # in the archive.\n\t      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n\n      lynxos*)\n        # FIXME: insert proper C++ library support\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      m88k*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      mvs*)\n        case $cc_basename in\n          cxx*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\t  *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\tesac\n\t;;\n\n      netbsd*)\n        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'\n\t  wlarc=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\tfi\n\t# Workaround some broken pre-1.5 toolchains\n\toutput_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e \"s:-lgcc -lc -lgcc::\"'\n\t;;\n\n      *nto* | *qnx*)\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n\t;;\n\n      openbsd* | bitrig*)\n\tif test -f /usr/libexec/ld.so; then\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t  if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-retain-symbols-file,$export_symbols -o $lib'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)=$wlarc'--whole-archive$convenience '$wlarc'--no-whole-archive'\n\t  fi\n\t  output_verbose_link_cmd=func_echo_all\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      osf3* | osf4* | osf5*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo \"$lib\" | $SED -e \"s/\\$tempext\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Archives containing C++ object files must be created using\n\t    # the KAI C++ compiler.\n\t    case $host in\n\t      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;\n\t      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;\n\t    esac\n\t    ;;\n          RCC*)\n\t    # Rational C++ 2.4.1\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          cxx*)\n\t    case $host in\n\t      osf3*)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n\t\t;;\n\t      *)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done~\n                  echo \"-hidden\">> $lib.exp~\n                  $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname $wl-input $wl$lib.exp  `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib~\n                  $RM $lib.exp'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t\t;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\" | $GREP -v \"ld:\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld.*$\\)/\\1/\"`; list= ; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n\t  *)\n\t    if test yes,no = \"$GXX,$with_gnu_ld\"; then\n\t      _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\\*'\n\t      case $host in\n\t        osf3*)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n\t\t  ;;\n\t        *)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-msym $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n\t\t  ;;\n\t      esac\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n\t      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t      # Commands to make compiler produce verbose output that lists\n\t      # what \"hidden\" libraries, object files and flags are used when\n\t      # linking a shared library.\n\t      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      psos*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      sunos4*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.x\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          lcc*)\n\t    # Lucid\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      solaris*)\n        case $cc_basename in\n          CC* | sunCC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G$allow_undefined_flag -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n              $CC -G$allow_undefined_flag $wl-M $wl$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t    case $host_os in\n\t      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t      *)\n\t\t# The compiler driver will combine and reorder linker options,\n\t\t# but understands '-z linker_flag'.\n\t        # Supported since Solaris 2.6 (maybe 2.5.1?)\n\t\t_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\t        ;;\n\t    esac\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\n\t    output_verbose_link_cmd='func_echo_all'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t    ;;\n          gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-h $wl$soname -o $lib'\n\n\t    # The C++ compiler must be used to create the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    # GNU C++ compiler with Solaris linker\n\t    if test yes,no = \"$GXX,$with_gnu_ld\"; then\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' $wl-z ${wl}defs'\n\t      if $CC --version | $GREP -v '^2\\.7' > /dev/null; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n                  $CC -shared $pic_flag -nostdlib $wl-M $wl$lib.exp $wl-h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      else\n\t        # g++ 2.7 appears to require '-G' NOT '-shared' on this\n\t        # platform.\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n                  $CC -G -nostdlib $wl-M $wl$lib.exp $wl-h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      fi\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R $wl$libdir'\n\t      case $host_os in\n\t\tsolaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t\t*)\n\t\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl-z ${wl}allextract$convenience $wl-z ${wl}defaultextract'\n\t\t  ;;\n\t      esac\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      case $cc_basename in\n        CC*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n      esac\n      ;;\n\n      sysv5* | sco3.2v5* | sco5v6*)\n\t# Note: We CANNOT use -z defs as we might desire, because we do not\n\t# link with -lc, and that would cause any symbols used from libc to\n\t# always be unresolved, which means just about no library would\n\t# ever link correctly.  If we're not using GNU ld we use -z text\n\t# though, which does catch some bad symbols but isn't as heavy-handed\n\t# as -z defs.\n\t_LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'\n\t_LT_TAGVAR(allow_undefined_flag, $1)='$wl-z,nodefs'\n\t_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R,$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n\t_LT_TAGVAR(link_all_deplibs, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-Bexport'\n\trunpath_var='LD_RUN_PATH'\n\n\tcase $cc_basename in\n          CC*)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Tprelink_objects $oldobjs~\n              '\"$_LT_TAGVAR(old_archive_cmds, $1)\"\n\t    _LT_TAGVAR(reload_cmds, $1)='$CC -Tprelink_objects $reload_objs~\n              '\"$_LT_TAGVAR(reload_cmds, $1)\"\n\t    ;;\n\t  *)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    ;;\n\tesac\n      ;;\n\n      tandem*)\n        case $cc_basename in\n          NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      vxworks*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      *)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n    esac\n\n    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\n    test no = \"$_LT_TAGVAR(ld_shlibs, $1)\" && can_build_shared=no\n\n    _LT_TAGVAR(GCC, $1)=$GXX\n    _LT_TAGVAR(LD, $1)=$LD\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\n  LDCXX=$LD\n  LD=$lt_save_LD\n  GCC=$lt_save_GCC\n  with_gnu_ld=$lt_save_with_gnu_ld\n  lt_cv_path_LDCXX=$lt_cv_path_LD\n  lt_cv_path_LD=$lt_save_path_LD\n  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld\n  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld\nfi # test yes != \"$_lt_caught_CXX_error\"\n\nAC_LANG_POP\n])# _LT_LANG_CXX_CONFIG\n\n\n# _LT_FUNC_STRIPNAME_CNF\n# ----------------------\n# func_stripname_cnf prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n#\n# This function is identical to the (non-XSI) version of func_stripname,\n# except this one can be used by m4 code that may be executed by configure,\n# rather than the libtool script.\nm4_defun([_LT_FUNC_STRIPNAME_CNF],[dnl\nAC_REQUIRE([_LT_DECL_SED])\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])\nfunc_stripname_cnf ()\n{\n  case @S|@2 in\n  .*) func_stripname_result=`$ECHO \"@S|@3\" | $SED \"s%^@S|@1%%; s%\\\\\\\\@S|@2\\$%%\"`;;\n  *)  func_stripname_result=`$ECHO \"@S|@3\" | $SED \"s%^@S|@1%%; s%@S|@2\\$%%\"`;;\n  esac\n} # func_stripname_cnf\n])# _LT_FUNC_STRIPNAME_CNF\n\n\n# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])\n# ---------------------------------\n# Figure out \"hidden\" library dependencies from verbose\n# compiler output when linking a shared library.\n# Parse the compiler output and extract the necessary\n# objects, libraries and library flags.\nm4_defun([_LT_SYS_HIDDEN_LIBDEPS],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nAC_REQUIRE([_LT_FUNC_STRIPNAME_CNF])dnl\n# Dependencies to place before and after the object being linked:\n_LT_TAGVAR(predep_objects, $1)=\n_LT_TAGVAR(postdep_objects, $1)=\n_LT_TAGVAR(predeps, $1)=\n_LT_TAGVAR(postdeps, $1)=\n_LT_TAGVAR(compiler_lib_search_path, $1)=\n\ndnl we can't use the lt_simple_compile_test_code here,\ndnl because it contains code intended for an executable,\ndnl not a library.  It's possible we should let each\ndnl tag define a new lt_????_link_test_code variable,\ndnl but it's only used here...\nm4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF\nint a;\nvoid foo (void) { a = 0; }\n_LT_EOF\n], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF\nclass Foo\n{\npublic:\n  Foo (void) { a = 0; }\nprivate:\n  int a;\n};\n_LT_EOF\n], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer*4 a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF\npublic class foo {\n  private int a;\n  public void bar (void) {\n    a = 0;\n  }\n};\n_LT_EOF\n], [$1], [GO], [cat > conftest.$ac_ext <<_LT_EOF\npackage foo\nfunc foo() {\n}\n_LT_EOF\n])\n\n_lt_libdeps_save_CFLAGS=$CFLAGS\ncase \"$CC $CFLAGS \" in #(\n*\\ -flto*\\ *) CFLAGS=\"$CFLAGS -fno-lto\" ;;\n*\\ -fwhopr*\\ *) CFLAGS=\"$CFLAGS -fno-whopr\" ;;\n*\\ -fuse-linker-plugin*\\ *) CFLAGS=\"$CFLAGS -fno-use-linker-plugin\" ;;\nesac\n\ndnl Parse the compiler output and extract the necessary\ndnl objects, libraries and library flags.\nif AC_TRY_EVAL(ac_compile); then\n  # Parse the compiler output and extract the necessary\n  # objects, libraries and library flags.\n\n  # Sentinel used to keep track of whether or not we are before\n  # the conftest object file.\n  pre_test_object_deps_done=no\n\n  for p in `eval \"$output_verbose_link_cmd\"`; do\n    case $prev$p in\n\n    -L* | -R* | -l*)\n       # Some compilers place space between \"-{L,R}\" and the path.\n       # Remove the space.\n       if test x-L = \"$p\" ||\n          test x-R = \"$p\"; then\n\t prev=$p\n\t continue\n       fi\n\n       # Expand the sysroot to ease extracting the directories later.\n       if test -z \"$prev\"; then\n         case $p in\n         -L*) func_stripname_cnf '-L' '' \"$p\"; prev=-L; p=$func_stripname_result ;;\n         -R*) func_stripname_cnf '-R' '' \"$p\"; prev=-R; p=$func_stripname_result ;;\n         -l*) func_stripname_cnf '-l' '' \"$p\"; prev=-l; p=$func_stripname_result ;;\n         esac\n       fi\n       case $p in\n       =*) func_stripname_cnf '=' '' \"$p\"; p=$lt_sysroot$func_stripname_result ;;\n       esac\n       if test no = \"$pre_test_object_deps_done\"; then\n\t case $prev in\n\t -L | -R)\n\t   # Internal compiler library paths should come after those\n\t   # provided the user.  The postdeps already come after the\n\t   # user supplied libs so there is no need to process them.\n\t   if test -z \"$_LT_TAGVAR(compiler_lib_search_path, $1)\"; then\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=$prev$p\n\t   else\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${_LT_TAGVAR(compiler_lib_search_path, $1)} $prev$p\"\n\t   fi\n\t   ;;\n\t # The \"-l\" case would never come before the object being\n\t # linked, so don't bother handling this case.\n\t esac\n       else\n\t if test -z \"$_LT_TAGVAR(postdeps, $1)\"; then\n\t   _LT_TAGVAR(postdeps, $1)=$prev$p\n\t else\n\t   _LT_TAGVAR(postdeps, $1)=\"${_LT_TAGVAR(postdeps, $1)} $prev$p\"\n\t fi\n       fi\n       prev=\n       ;;\n\n    *.lto.$objext) ;; # Ignore GCC LTO objects\n    *.$objext)\n       # This assumes that the test object file only shows up\n       # once in the compiler output.\n       if test \"$p\" = \"conftest.$objext\"; then\n\t pre_test_object_deps_done=yes\n\t continue\n       fi\n\n       if test no = \"$pre_test_object_deps_done\"; then\n\t if test -z \"$_LT_TAGVAR(predep_objects, $1)\"; then\n\t   _LT_TAGVAR(predep_objects, $1)=$p\n\t else\n\t   _LT_TAGVAR(predep_objects, $1)=\"$_LT_TAGVAR(predep_objects, $1) $p\"\n\t fi\n       else\n\t if test -z \"$_LT_TAGVAR(postdep_objects, $1)\"; then\n\t   _LT_TAGVAR(postdep_objects, $1)=$p\n\t else\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$_LT_TAGVAR(postdep_objects, $1) $p\"\n\t fi\n       fi\n       ;;\n\n    *) ;; # Ignore the rest.\n\n    esac\n  done\n\n  # Clean up.\n  rm -f a.out a.exe\nelse\n  echo \"libtool.m4: error: problem compiling $1 test program\"\nfi\n\n$RM -f confest.$objext\nCFLAGS=$_lt_libdeps_save_CFLAGS\n\n# PORTME: override above test on systems where it is broken\nm4_if([$1], [CXX],\n[case $host_os in\ninterix[[3-9]]*)\n  # Interix 3.5 installs completely hosed .la files for C++, so rather than\n  # hack all around it, let's just trust \"g++\" to DTRT.\n  _LT_TAGVAR(predep_objects,$1)=\n  _LT_TAGVAR(postdep_objects,$1)=\n  _LT_TAGVAR(postdeps,$1)=\n  ;;\nesac\n])\n\ncase \" $_LT_TAGVAR(postdeps, $1) \" in\n*\" -lc \"*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;\nesac\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=\nif test -n \"${_LT_TAGVAR(compiler_lib_search_path, $1)}\"; then\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo \" ${_LT_TAGVAR(compiler_lib_search_path, $1)}\" | $SED -e 's! -L! !g' -e 's!^ !!'`\nfi\n_LT_TAGDECL([], [compiler_lib_search_dirs], [1],\n    [The directories searched by this compiler when creating a shared library])\n_LT_TAGDECL([], [predep_objects], [1],\n    [Dependencies to place before and after the objects being linked to\n    create a shared library])\n_LT_TAGDECL([], [postdep_objects], [1])\n_LT_TAGDECL([], [predeps], [1])\n_LT_TAGDECL([], [postdeps], [1])\n_LT_TAGDECL([], [compiler_lib_search_path], [1],\n    [The library search path used internally by the compiler when linking\n    a shared library])\n])# _LT_SYS_HIDDEN_LIBDEPS\n\n\n# _LT_LANG_F77_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a Fortran 77 compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_F77_CONFIG],\n[AC_LANG_PUSH(Fortran 77)\nif test -z \"$F77\" || test no = \"$F77\"; then\n  _lt_disable_F77=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for f77 test sources.\nac_ext=f\n\n# Object file extension for compiled f77 test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the F77 compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test yes != \"$_lt_disable_F77\"; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_GCC=$GCC\n  lt_save_CFLAGS=$CFLAGS\n  CC=${F77-\"f77\"}\n  CFLAGS=$FFLAGS\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n  GCC=$G77\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test no = \"$can_build_shared\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test yes = \"$enable_shared\" && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test ia64 != \"$host_cpu\"; then\n\t  case $enable_shared,$with_aix_soname,$aix_use_runtimelinking in\n\t  yes,aix,yes) ;;\t\t# shared object as lib.so file only\n\t  yes,svr4,*) ;;\t\t# shared object as lib.so archive member only\n\t  yes,*) enable_static=no ;;\t# shared object in lib.a archive as well\n\t  esac\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test yes = \"$enable_shared\" || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=$G77\n    _LT_TAGVAR(LD, $1)=$LD\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\nfi # test yes != \"$_lt_disable_F77\"\n\nAC_LANG_POP\n])# _LT_LANG_F77_CONFIG\n\n\n# _LT_LANG_FC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for a Fortran compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_FC_CONFIG],\n[AC_LANG_PUSH(Fortran)\n\nif test -z \"$FC\" || test no = \"$FC\"; then\n  _lt_disable_FC=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for fc test sources.\nac_ext=${ac_fc_srcext-f}\n\n# Object file extension for compiled fc test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the FC compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test yes != \"$_lt_disable_FC\"; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_GCC=$GCC\n  lt_save_CFLAGS=$CFLAGS\n  CC=${FC-\"f95\"}\n  CFLAGS=$FCFLAGS\n  compiler=$CC\n  GCC=$ac_cv_fc_compiler_gnu\n\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test no = \"$can_build_shared\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test yes = \"$enable_shared\" && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test ia64 != \"$host_cpu\"; then\n\t  case $enable_shared,$with_aix_soname,$aix_use_runtimelinking in\n\t  yes,aix,yes) ;;\t\t# shared object as lib.so file only\n\t  yes,svr4,*) ;;\t\t# shared object as lib.so archive member only\n\t  yes,*) enable_static=no ;;\t# shared object in lib.a archive as well\n\t  esac\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test yes = \"$enable_shared\" || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=$ac_cv_fc_compiler_gnu\n    _LT_TAGVAR(LD, $1)=$LD\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\nfi # test yes != \"$_lt_disable_FC\"\n\nAC_LANG_POP\n])# _LT_LANG_FC_CONFIG\n\n\n# _LT_LANG_GCJ_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Java Compiler compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_GCJ_CONFIG],\n[AC_REQUIRE([LT_PROG_GCJ])dnl\nAC_LANG_SAVE\n\n# Source file extension for Java test sources.\nac_ext=java\n\n# Object file extension for compiled Java test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"class foo {}\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GCJ-\"gcj\"}\nCFLAGS=$GCJFLAGS\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=$LD\n_LT_CC_BASENAME([$compiler])\n\n# GCJ did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_GCJ_CONFIG\n\n\n# _LT_LANG_GO_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Go compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_GO_CONFIG],\n[AC_REQUIRE([LT_PROG_GO])dnl\nAC_LANG_SAVE\n\n# Source file extension for Go test sources.\nac_ext=go\n\n# Object file extension for compiled Go test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"package main; func main() { }\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='package main; func main() { }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GOC-\"gccgo\"}\nCFLAGS=$GOFLAGS\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=$LD\n_LT_CC_BASENAME([$compiler])\n\n# Go did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_GO_CONFIG\n\n\n# _LT_LANG_RC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for the Windows resource compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_RC_CONFIG],\n[AC_REQUIRE([LT_PROG_RC])dnl\nAC_LANG_SAVE\n\n# Source file extension for RC test sources.\nac_ext=rc\n\n# Object file extension for compiled RC test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code='sample MENU { MENUITEM \"&Soup\", 100, CHECKED }'\n\n# Code to be used in simple link tests\nlt_simple_link_test_code=$lt_simple_compile_test_code\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=\nCC=${RC-\"windres\"}\nCFLAGS=\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n\nif test -n \"$compiler\"; then\n  :\n  _LT_CONFIG($1)\nfi\n\nGCC=$lt_save_GCC\nAC_LANG_RESTORE\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_RC_CONFIG\n\n\n# LT_PROG_GCJ\n# -----------\nAC_DEFUN([LT_PROG_GCJ],\n[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],\n  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],\n    [AC_CHECK_TOOL(GCJ, gcj,)\n      test set = \"${GCJFLAGS+set}\" || GCJFLAGS=\"-g -O2\"\n      AC_SUBST(GCJFLAGS)])])[]dnl\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_GCJ], [])\n\n\n# LT_PROG_GO\n# ----------\nAC_DEFUN([LT_PROG_GO],\n[AC_CHECK_TOOL(GOC, gccgo,)\n])\n\n\n# LT_PROG_RC\n# ----------\nAC_DEFUN([LT_PROG_RC],\n[AC_CHECK_TOOL(RC, windres,)\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_RC], [])\n\n\n# _LT_DECL_EGREP\n# --------------\n# If we don't have a new enough Autoconf to choose the best grep\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_EGREP],\n[AC_REQUIRE([AC_PROG_EGREP])dnl\nAC_REQUIRE([AC_PROG_FGREP])dnl\ntest -z \"$GREP\" && GREP=grep\n_LT_DECL([], [GREP], [1], [A grep program that handles long lines])\n_LT_DECL([], [EGREP], [1], [An ERE matcher])\n_LT_DECL([], [FGREP], [1], [A literal string matcher])\ndnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too\nAC_SUBST([GREP])\n])\n\n\n# _LT_DECL_OBJDUMP\n# --------------\n# If we don't have a new enough Autoconf to choose the best objdump\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_OBJDUMP],\n[AC_CHECK_TOOL(OBJDUMP, objdump, false)\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])\nAC_SUBST([OBJDUMP])\n])\n\n# _LT_DECL_DLLTOOL\n# ----------------\n# Ensure DLLTOOL variable is set.\nm4_defun([_LT_DECL_DLLTOOL],\n[AC_CHECK_TOOL(DLLTOOL, dlltool, false)\ntest -z \"$DLLTOOL\" && DLLTOOL=dlltool\n_LT_DECL([], [DLLTOOL], [1], [DLL creation program])\nAC_SUBST([DLLTOOL])\n])\n\n# _LT_DECL_SED\n# ------------\n# Check for a fully-functional sed program, that truncates\n# as few characters as possible.  Prefer GNU sed if found.\nm4_defun([_LT_DECL_SED],\n[AC_PROG_SED\ntest -z \"$SED\" && SED=sed\nXsed=\"$SED -e 1s/^X//\"\n_LT_DECL([], [SED], [1], [A sed program that does not truncate output])\n_LT_DECL([], [Xsed], [\"\\$SED -e 1s/^X//\"],\n    [Sed that helps us avoid accidentally triggering echo(1) options like -n])\n])# _LT_DECL_SED\n\nm4_ifndef([AC_PROG_SED], [\n############################################################\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_SED.  When it is available in   #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n############################################################\n\nm4_defun([AC_PROG_SED],\n[AC_MSG_CHECKING([for a sed that does not truncate output])\nAC_CACHE_VAL(lt_cv_path_SED,\n[# Loop through the user's path and test for sed and gsed.\n# Then use that list of sed's as ones to test for truncation.\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n  for lt_ac_prog in sed gsed; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      if $as_executable_p \"$as_dir/$lt_ac_prog$ac_exec_ext\"; then\n        lt_ac_sed_list=\"$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext\"\n      fi\n    done\n  done\ndone\nIFS=$as_save_IFS\nlt_ac_max=0\nlt_ac_count=0\n# Add /usr/xpg4/bin/sed as it is typically found on Solaris\n# along with /bin/sed that truncates output.\nfor lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do\n  test ! -f \"$lt_ac_sed\" && continue\n  cat /dev/null > conftest.in\n  lt_ac_count=0\n  echo $ECHO_N \"0123456789$ECHO_C\" >conftest.in\n  # Check for GNU sed and select it if it is found.\n  if \"$lt_ac_sed\" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then\n    lt_cv_path_SED=$lt_ac_sed\n    break\n  fi\n  while true; do\n    cat conftest.in conftest.in >conftest.tmp\n    mv conftest.tmp conftest.in\n    cp conftest.in conftest.nl\n    echo >>conftest.nl\n    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break\n    cmp -s conftest.out conftest.nl || break\n    # 10000 chars as input seems more than enough\n    test 10 -lt \"$lt_ac_count\" && break\n    lt_ac_count=`expr $lt_ac_count + 1`\n    if test \"$lt_ac_count\" -gt \"$lt_ac_max\"; then\n      lt_ac_max=$lt_ac_count\n      lt_cv_path_SED=$lt_ac_sed\n    fi\n  done\ndone\n])\nSED=$lt_cv_path_SED\nAC_SUBST([SED])\nAC_MSG_RESULT([$SED])\n])#AC_PROG_SED\n])#m4_ifndef\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_SED], [])\n\n\n# _LT_CHECK_SHELL_FEATURES\n# ------------------------\n# Find out whether the shell is Bourne or XSI compatible,\n# or has some other useful features.\nm4_defun([_LT_CHECK_SHELL_FEATURES],\n[if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then\n  lt_unset=unset\nelse\n  lt_unset=false\nfi\n_LT_DECL([], [lt_unset], [0], [whether the shell understands \"unset\"])dnl\n\n# test EBCDIC or ASCII\ncase `echo X|tr X '\\101'` in\n A) # ASCII based system\n    # \\n is not interpreted correctly by Solaris 8 /usr/ucb/tr\n  lt_SP2NL='tr \\040 \\012'\n  lt_NL2SP='tr \\015\\012 \\040\\040'\n  ;;\n *) # EBCDIC based system\n  lt_SP2NL='tr \\100 \\n'\n  lt_NL2SP='tr \\r\\n \\100\\100'\n  ;;\nesac\n_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl\n_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl\n])# _LT_CHECK_SHELL_FEATURES\n\n\n# _LT_PATH_CONVERSION_FUNCTIONS\n# -----------------------------\n# Determine what file name conversion functions should be used by\n# func_to_host_file (and, implicitly, by func_to_host_path).  These are needed\n# for certain cross-compile configurations and native mingw.\nm4_defun([_LT_PATH_CONVERSION_FUNCTIONS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_MSG_CHECKING([how to convert $build file names to $host format])\nAC_CACHE_VAL(lt_cv_to_host_file_cmd,\n[case $host in\n  *-*-mingw* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_host_file_cmd=func_convert_file_msys_to_w32\n        ;;\n      *-*-cygwin* )\n        lt_cv_to_host_file_cmd=func_convert_file_cygwin_to_w32\n        ;;\n      * ) # otherwise, assume *nix\n        lt_cv_to_host_file_cmd=func_convert_file_nix_to_w32\n        ;;\n    esac\n    ;;\n  *-*-cygwin* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_host_file_cmd=func_convert_file_msys_to_cygwin\n        ;;\n      *-*-cygwin* )\n        lt_cv_to_host_file_cmd=func_convert_file_noop\n        ;;\n      * ) # otherwise, assume *nix\n        lt_cv_to_host_file_cmd=func_convert_file_nix_to_cygwin\n        ;;\n    esac\n    ;;\n  * ) # unhandled hosts (and \"normal\" native builds)\n    lt_cv_to_host_file_cmd=func_convert_file_noop\n    ;;\nesac\n])\nto_host_file_cmd=$lt_cv_to_host_file_cmd\nAC_MSG_RESULT([$lt_cv_to_host_file_cmd])\n_LT_DECL([to_host_file_cmd], [lt_cv_to_host_file_cmd],\n         [0], [convert $build file names to $host format])dnl\n\nAC_MSG_CHECKING([how to convert $build file names to toolchain format])\nAC_CACHE_VAL(lt_cv_to_tool_file_cmd,\n[#assume ordinary cross tools, or native build.\nlt_cv_to_tool_file_cmd=func_convert_file_noop\ncase $host in\n  *-*-mingw* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_tool_file_cmd=func_convert_file_msys_to_w32\n        ;;\n    esac\n    ;;\nesac\n])\nto_tool_file_cmd=$lt_cv_to_tool_file_cmd\nAC_MSG_RESULT([$lt_cv_to_tool_file_cmd])\n_LT_DECL([to_tool_file_cmd], [lt_cv_to_tool_file_cmd],\n         [0], [convert $build files to toolchain format])dnl\n])# _LT_PATH_CONVERSION_FUNCTIONS\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/m4/ltoptions.m4": "# Helper functions for option handling.                    -*- Autoconf -*-\n#\n#   Copyright (C) 2004-2005, 2007-2009, 2011-2015 Free Software\n#   Foundation, Inc.\n#   Written by Gary V. Vaughan, 2004\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\n# serial 8 ltoptions.m4\n\n# This is to help aclocal find these macros, as it can't see m4_define.\nAC_DEFUN([LTOPTIONS_VERSION], [m4_if([1])])\n\n\n# _LT_MANGLE_OPTION(MACRO-NAME, OPTION-NAME)\n# ------------------------------------------\nm4_define([_LT_MANGLE_OPTION],\n[[_LT_OPTION_]m4_bpatsubst($1__$2, [[^a-zA-Z0-9_]], [_])])\n\n\n# _LT_SET_OPTION(MACRO-NAME, OPTION-NAME)\n# ---------------------------------------\n# Set option OPTION-NAME for macro MACRO-NAME, and if there is a\n# matching handler defined, dispatch to it.  Other OPTION-NAMEs are\n# saved as a flag.\nm4_define([_LT_SET_OPTION],\n[m4_define(_LT_MANGLE_OPTION([$1], [$2]))dnl\nm4_ifdef(_LT_MANGLE_DEFUN([$1], [$2]),\n        _LT_MANGLE_DEFUN([$1], [$2]),\n    [m4_warning([Unknown $1 option '$2'])])[]dnl\n])\n\n\n# _LT_IF_OPTION(MACRO-NAME, OPTION-NAME, IF-SET, [IF-NOT-SET])\n# ------------------------------------------------------------\n# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\nm4_define([_LT_IF_OPTION],\n[m4_ifdef(_LT_MANGLE_OPTION([$1], [$2]), [$3], [$4])])\n\n\n# _LT_UNLESS_OPTIONS(MACRO-NAME, OPTION-LIST, IF-NOT-SET)\n# -------------------------------------------------------\n# Execute IF-NOT-SET unless all options in OPTION-LIST for MACRO-NAME\n# are set.\nm4_define([_LT_UNLESS_OPTIONS],\n[m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),\n\t    [m4_ifdef(_LT_MANGLE_OPTION([$1], _LT_Option),\n\t\t      [m4_define([$0_found])])])[]dnl\nm4_ifdef([$0_found], [m4_undefine([$0_found])], [$3\n])[]dnl\n])\n\n\n# _LT_SET_OPTIONS(MACRO-NAME, OPTION-LIST)\n# ----------------------------------------\n# OPTION-LIST is a space-separated list of Libtool options associated\n# with MACRO-NAME.  If any OPTION has a matching handler declared with\n# LT_OPTION_DEFINE, dispatch to that macro; otherwise complain about\n# the unknown option and exit.\nm4_defun([_LT_SET_OPTIONS],\n[# Set options\nm4_foreach([_LT_Option], m4_split(m4_normalize([$2])),\n    [_LT_SET_OPTION([$1], _LT_Option)])\n\nm4_if([$1],[LT_INIT],[\n  dnl\n  dnl Simply set some default values (i.e off) if boolean options were not\n  dnl specified:\n  _LT_UNLESS_OPTIONS([LT_INIT], [dlopen], [enable_dlopen=no\n  ])\n  _LT_UNLESS_OPTIONS([LT_INIT], [win32-dll], [enable_win32_dll=no\n  ])\n  dnl\n  dnl If no reference was made to various pairs of opposing options, then\n  dnl we run the default mode handler for the pair.  For example, if neither\n  dnl 'shared' nor 'disable-shared' was passed, we enable building of shared\n  dnl archives by default:\n  _LT_UNLESS_OPTIONS([LT_INIT], [shared disable-shared], [_LT_ENABLE_SHARED])\n  _LT_UNLESS_OPTIONS([LT_INIT], [static disable-static], [_LT_ENABLE_STATIC])\n  _LT_UNLESS_OPTIONS([LT_INIT], [pic-only no-pic], [_LT_WITH_PIC])\n  _LT_UNLESS_OPTIONS([LT_INIT], [fast-install disable-fast-install],\n\t\t   [_LT_ENABLE_FAST_INSTALL])\n  _LT_UNLESS_OPTIONS([LT_INIT], [aix-soname=aix aix-soname=both aix-soname=svr4],\n\t\t   [_LT_WITH_AIX_SONAME([aix])])\n  ])\n])# _LT_SET_OPTIONS\n\n\n## --------------------------------- ##\n## Macros to handle LT_INIT options. ##\n## --------------------------------- ##\n\n# _LT_MANGLE_DEFUN(MACRO-NAME, OPTION-NAME)\n# -----------------------------------------\nm4_define([_LT_MANGLE_DEFUN],\n[[_LT_OPTION_DEFUN_]m4_bpatsubst(m4_toupper([$1__$2]), [[^A-Z0-9_]], [_])])\n\n\n# LT_OPTION_DEFINE(MACRO-NAME, OPTION-NAME, CODE)\n# -----------------------------------------------\nm4_define([LT_OPTION_DEFINE],\n[m4_define(_LT_MANGLE_DEFUN([$1], [$2]), [$3])[]dnl\n])# LT_OPTION_DEFINE\n\n\n# dlopen\n# ------\nLT_OPTION_DEFINE([LT_INIT], [dlopen], [enable_dlopen=yes\n])\n\nAU_DEFUN([AC_LIBTOOL_DLOPEN],\n[_LT_SET_OPTION([LT_INIT], [dlopen])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the 'dlopen' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN], [])\n\n\n# win32-dll\n# ---------\n# Declare package support for building win32 dll's.\nLT_OPTION_DEFINE([LT_INIT], [win32-dll],\n[enable_win32_dll=yes\n\ncase $host in\n*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-cegcc*)\n  AC_CHECK_TOOL(AS, as, false)\n  AC_CHECK_TOOL(DLLTOOL, dlltool, false)\n  AC_CHECK_TOOL(OBJDUMP, objdump, false)\n  ;;\nesac\n\ntest -z \"$AS\" && AS=as\n_LT_DECL([], [AS],      [1], [Assembler program])dnl\n\ntest -z \"$DLLTOOL\" && DLLTOOL=dlltool\n_LT_DECL([], [DLLTOOL], [1], [DLL creation program])dnl\n\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [Object dumper program])dnl\n])# win32-dll\n\nAU_DEFUN([AC_LIBTOOL_WIN32_DLL],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n_LT_SET_OPTION([LT_INIT], [win32-dll])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the 'win32-dll' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_WIN32_DLL], [])\n\n\n# _LT_ENABLE_SHARED([DEFAULT])\n# ----------------------------\n# implement the --enable-shared flag, and supports the 'shared' and\n# 'disable-shared' LT_INIT options.\n# DEFAULT is either 'yes' or 'no'.  If omitted, it defaults to 'yes'.\nm4_define([_LT_ENABLE_SHARED],\n[m4_define([_LT_ENABLE_SHARED_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([shared],\n    [AS_HELP_STRING([--enable-shared@<:@=PKGS@:>@],\n\t[build shared libraries @<:@default=]_LT_ENABLE_SHARED_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_shared=yes ;;\n    no) enable_shared=no ;;\n    *)\n      enable_shared=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,\n      for pkg in $enableval; do\n\tIFS=$lt_save_ifs\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_shared=yes\n\tfi\n      done\n      IFS=$lt_save_ifs\n      ;;\n    esac],\n    [enable_shared=]_LT_ENABLE_SHARED_DEFAULT)\n\n    _LT_DECL([build_libtool_libs], [enable_shared], [0],\n\t[Whether or not to build shared libraries])\n])# _LT_ENABLE_SHARED\n\nLT_OPTION_DEFINE([LT_INIT], [shared], [_LT_ENABLE_SHARED([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-shared], [_LT_ENABLE_SHARED([no])])\n\n# Old names:\nAC_DEFUN([AC_ENABLE_SHARED],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[shared])\n])\n\nAC_DEFUN([AC_DISABLE_SHARED],\n[_LT_SET_OPTION([LT_INIT], [disable-shared])\n])\n\nAU_DEFUN([AM_ENABLE_SHARED], [AC_ENABLE_SHARED($@)])\nAU_DEFUN([AM_DISABLE_SHARED], [AC_DISABLE_SHARED($@)])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_ENABLE_SHARED], [])\ndnl AC_DEFUN([AM_DISABLE_SHARED], [])\n\n\n\n# _LT_ENABLE_STATIC([DEFAULT])\n# ----------------------------\n# implement the --enable-static flag, and support the 'static' and\n# 'disable-static' LT_INIT options.\n# DEFAULT is either 'yes' or 'no'.  If omitted, it defaults to 'yes'.\nm4_define([_LT_ENABLE_STATIC],\n[m4_define([_LT_ENABLE_STATIC_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([static],\n    [AS_HELP_STRING([--enable-static@<:@=PKGS@:>@],\n\t[build static libraries @<:@default=]_LT_ENABLE_STATIC_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_static=yes ;;\n    no) enable_static=no ;;\n    *)\n     enable_static=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,\n      for pkg in $enableval; do\n\tIFS=$lt_save_ifs\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_static=yes\n\tfi\n      done\n      IFS=$lt_save_ifs\n      ;;\n    esac],\n    [enable_static=]_LT_ENABLE_STATIC_DEFAULT)\n\n    _LT_DECL([build_old_libs], [enable_static], [0],\n\t[Whether or not to build static libraries])\n])# _LT_ENABLE_STATIC\n\nLT_OPTION_DEFINE([LT_INIT], [static], [_LT_ENABLE_STATIC([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-static], [_LT_ENABLE_STATIC([no])])\n\n# Old names:\nAC_DEFUN([AC_ENABLE_STATIC],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[static])\n])\n\nAC_DEFUN([AC_DISABLE_STATIC],\n[_LT_SET_OPTION([LT_INIT], [disable-static])\n])\n\nAU_DEFUN([AM_ENABLE_STATIC], [AC_ENABLE_STATIC($@)])\nAU_DEFUN([AM_DISABLE_STATIC], [AC_DISABLE_STATIC($@)])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_ENABLE_STATIC], [])\ndnl AC_DEFUN([AM_DISABLE_STATIC], [])\n\n\n\n# _LT_ENABLE_FAST_INSTALL([DEFAULT])\n# ----------------------------------\n# implement the --enable-fast-install flag, and support the 'fast-install'\n# and 'disable-fast-install' LT_INIT options.\n# DEFAULT is either 'yes' or 'no'.  If omitted, it defaults to 'yes'.\nm4_define([_LT_ENABLE_FAST_INSTALL],\n[m4_define([_LT_ENABLE_FAST_INSTALL_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([fast-install],\n    [AS_HELP_STRING([--enable-fast-install@<:@=PKGS@:>@],\n    [optimize for fast installation @<:@default=]_LT_ENABLE_FAST_INSTALL_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_fast_install=yes ;;\n    no) enable_fast_install=no ;;\n    *)\n      enable_fast_install=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,\n      for pkg in $enableval; do\n\tIFS=$lt_save_ifs\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_fast_install=yes\n\tfi\n      done\n      IFS=$lt_save_ifs\n      ;;\n    esac],\n    [enable_fast_install=]_LT_ENABLE_FAST_INSTALL_DEFAULT)\n\n_LT_DECL([fast_install], [enable_fast_install], [0],\n\t [Whether or not to optimize for fast installation])dnl\n])# _LT_ENABLE_FAST_INSTALL\n\nLT_OPTION_DEFINE([LT_INIT], [fast-install], [_LT_ENABLE_FAST_INSTALL([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-fast-install], [_LT_ENABLE_FAST_INSTALL([no])])\n\n# Old names:\nAU_DEFUN([AC_ENABLE_FAST_INSTALL],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[fast-install])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you put\nthe 'fast-install' option into LT_INIT's first parameter.])\n])\n\nAU_DEFUN([AC_DISABLE_FAST_INSTALL],\n[_LT_SET_OPTION([LT_INIT], [disable-fast-install])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you put\nthe 'disable-fast-install' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_ENABLE_FAST_INSTALL], [])\ndnl AC_DEFUN([AM_DISABLE_FAST_INSTALL], [])\n\n\n# _LT_WITH_AIX_SONAME([DEFAULT])\n# ----------------------------------\n# implement the --with-aix-soname flag, and support the `aix-soname=aix'\n# and `aix-soname=both' and `aix-soname=svr4' LT_INIT options. DEFAULT\n# is either `aix', `both' or `svr4'.  If omitted, it defaults to `aix'.\nm4_define([_LT_WITH_AIX_SONAME],\n[m4_define([_LT_WITH_AIX_SONAME_DEFAULT], [m4_if($1, svr4, svr4, m4_if($1, both, both, aix))])dnl\nshared_archive_member_spec=\ncase $host,$enable_shared in\npower*-*-aix[[5-9]]*,yes)\n  AC_MSG_CHECKING([which variant of shared library versioning to provide])\n  AC_ARG_WITH([aix-soname],\n    [AS_HELP_STRING([--with-aix-soname=aix|svr4|both],\n      [shared library versioning (aka \"SONAME\") variant to provide on AIX, @<:@default=]_LT_WITH_AIX_SONAME_DEFAULT[@:>@.])],\n    [case $withval in\n    aix|svr4|both)\n      ;;\n    *)\n      AC_MSG_ERROR([Unknown argument to --with-aix-soname])\n      ;;\n    esac\n    lt_cv_with_aix_soname=$with_aix_soname],\n    [AC_CACHE_VAL([lt_cv_with_aix_soname],\n      [lt_cv_with_aix_soname=]_LT_WITH_AIX_SONAME_DEFAULT)\n    with_aix_soname=$lt_cv_with_aix_soname])\n  AC_MSG_RESULT([$with_aix_soname])\n  if test aix != \"$with_aix_soname\"; then\n    # For the AIX way of multilib, we name the shared archive member\n    # based on the bitwidth used, traditionally 'shr.o' or 'shr_64.o',\n    # and 'shr.imp' or 'shr_64.imp', respectively, for the Import File.\n    # Even when GNU compilers ignore OBJECT_MODE but need '-maix64' flag,\n    # the AIX toolchain works better with OBJECT_MODE set (default 32).\n    if test 64 = \"${OBJECT_MODE-32}\"; then\n      shared_archive_member_spec=shr_64\n    else\n      shared_archive_member_spec=shr\n    fi\n  fi\n  ;;\n*)\n  with_aix_soname=aix\n  ;;\nesac\n\n_LT_DECL([], [shared_archive_member_spec], [0],\n    [Shared archive member basename, for filename based shared library versioning on AIX])dnl\n])# _LT_WITH_AIX_SONAME\n\nLT_OPTION_DEFINE([LT_INIT], [aix-soname=aix], [_LT_WITH_AIX_SONAME([aix])])\nLT_OPTION_DEFINE([LT_INIT], [aix-soname=both], [_LT_WITH_AIX_SONAME([both])])\nLT_OPTION_DEFINE([LT_INIT], [aix-soname=svr4], [_LT_WITH_AIX_SONAME([svr4])])\n\n\n# _LT_WITH_PIC([MODE])\n# --------------------\n# implement the --with-pic flag, and support the 'pic-only' and 'no-pic'\n# LT_INIT options.\n# MODE is either 'yes' or 'no'.  If omitted, it defaults to 'both'.\nm4_define([_LT_WITH_PIC],\n[AC_ARG_WITH([pic],\n    [AS_HELP_STRING([--with-pic@<:@=PKGS@:>@],\n\t[try to use only PIC/non-PIC objects @<:@default=use both@:>@])],\n    [lt_p=${PACKAGE-default}\n    case $withval in\n    yes|no) pic_mode=$withval ;;\n    *)\n      pic_mode=default\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,\n      for lt_pkg in $withval; do\n\tIFS=$lt_save_ifs\n\tif test \"X$lt_pkg\" = \"X$lt_p\"; then\n\t  pic_mode=yes\n\tfi\n      done\n      IFS=$lt_save_ifs\n      ;;\n    esac],\n    [pic_mode=m4_default([$1], [default])])\n\n_LT_DECL([], [pic_mode], [0], [What type of objects to build])dnl\n])# _LT_WITH_PIC\n\nLT_OPTION_DEFINE([LT_INIT], [pic-only], [_LT_WITH_PIC([yes])])\nLT_OPTION_DEFINE([LT_INIT], [no-pic], [_LT_WITH_PIC([no])])\n\n# Old name:\nAU_DEFUN([AC_LIBTOOL_PICMODE],\n[_LT_SET_OPTION([LT_INIT], [pic-only])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the 'pic-only' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_PICMODE], [])\n\n## ----------------- ##\n## LTDL_INIT Options ##\n## ----------------- ##\n\nm4_define([_LTDL_MODE], [])\nLT_OPTION_DEFINE([LTDL_INIT], [nonrecursive],\n\t\t [m4_define([_LTDL_MODE], [nonrecursive])])\nLT_OPTION_DEFINE([LTDL_INIT], [recursive],\n\t\t [m4_define([_LTDL_MODE], [recursive])])\nLT_OPTION_DEFINE([LTDL_INIT], [subproject],\n\t\t [m4_define([_LTDL_MODE], [subproject])])\n\nm4_define([_LTDL_TYPE], [])\nLT_OPTION_DEFINE([LTDL_INIT], [installable],\n\t\t [m4_define([_LTDL_TYPE], [installable])])\nLT_OPTION_DEFINE([LTDL_INIT], [convenience],\n\t\t [m4_define([_LTDL_TYPE], [convenience])])\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/m4/lib-link.m4": "# lib-link.m4 serial 21 (gettext-0.18)\ndnl Copyright (C) 2001-2010 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Bruno Haible.\n\nAC_PREREQ([2.54])\n\ndnl AC_LIB_LINKFLAGS(name [, dependencies]) searches for libname and\ndnl the libraries corresponding to explicit and implicit dependencies.\ndnl Sets and AC_SUBSTs the LIB${NAME} and LTLIB${NAME} variables and\ndnl augments the CPPFLAGS variable.\ndnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname\ndnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.\nAC_DEFUN([AC_LIB_LINKFLAGS],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  AC_REQUIRE([AC_LIB_RPATH])\n  pushdef([Name],[translit([$1],[./-], [___])])\n  pushdef([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                                [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  AC_CACHE_CHECK([how to link with lib[]$1], [ac_cv_lib[]Name[]_libs], [\n    AC_LIB_LINKFLAGS_BODY([$1], [$2])\n    ac_cv_lib[]Name[]_libs=\"$LIB[]NAME\"\n    ac_cv_lib[]Name[]_ltlibs=\"$LTLIB[]NAME\"\n    ac_cv_lib[]Name[]_cppflags=\"$INC[]NAME\"\n    ac_cv_lib[]Name[]_prefix=\"$LIB[]NAME[]_PREFIX\"\n  ])\n  LIB[]NAME=\"$ac_cv_lib[]Name[]_libs\"\n  LTLIB[]NAME=\"$ac_cv_lib[]Name[]_ltlibs\"\n  INC[]NAME=\"$ac_cv_lib[]Name[]_cppflags\"\n  LIB[]NAME[]_PREFIX=\"$ac_cv_lib[]Name[]_prefix\"\n  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)\n  AC_SUBST([LIB]NAME)\n  AC_SUBST([LTLIB]NAME)\n  AC_SUBST([LIB]NAME[_PREFIX])\n  dnl Also set HAVE_LIB[]NAME so that AC_LIB_HAVE_LINKFLAGS can reuse the\n  dnl results of this search when this library appears as a dependency.\n  HAVE_LIB[]NAME=yes\n  popdef([NAME])\n  popdef([Name])\n])\n\ndnl AC_LIB_HAVE_LINKFLAGS(name, dependencies, includes, testcode, [missing-message])\ndnl searches for libname and the libraries corresponding to explicit and\ndnl implicit dependencies, together with the specified include files and\ndnl the ability to compile and link the specified testcode. The missing-message\ndnl defaults to 'no' and may contain additional hints for the user.\ndnl If found, it sets and AC_SUBSTs HAVE_LIB${NAME}=yes and the LIB${NAME}\ndnl and LTLIB${NAME} variables and augments the CPPFLAGS variable, and\ndnl #defines HAVE_LIB${NAME} to 1. Otherwise, it sets and AC_SUBSTs\ndnl HAVE_LIB${NAME}=no and LIB${NAME} and LTLIB${NAME} to empty.\ndnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname\ndnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.\nAC_DEFUN([AC_LIB_HAVE_LINKFLAGS],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  AC_REQUIRE([AC_LIB_RPATH])\n  pushdef([Name],[translit([$1],[./-], [___])])\n  pushdef([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                                [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n\n  dnl Search for lib[]Name and define LIB[]NAME, LTLIB[]NAME and INC[]NAME\n  dnl accordingly.\n  AC_LIB_LINKFLAGS_BODY([$1], [$2])\n\n  dnl Add $INC[]NAME to CPPFLAGS before performing the following checks,\n  dnl because if the user has installed lib[]Name and not disabled its use\n  dnl via --without-lib[]Name-prefix, he wants to use it.\n  ac_save_CPPFLAGS=\"$CPPFLAGS\"\n  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)\n\n  AC_CACHE_CHECK([for lib[]$1], [ac_cv_lib[]Name], [\n    ac_save_LIBS=\"$LIBS\"\n    dnl If $LIB[]NAME contains some -l options, add it to the end of LIBS,\n    dnl because these -l options might require -L options that are present in\n    dnl LIBS. -l options benefit only from the -L options listed before it.\n    dnl Otherwise, add it to the front of LIBS, because it may be a static\n    dnl library that depends on another static library that is present in LIBS.\n    dnl Static libraries benefit only from the static libraries listed after\n    dnl it.\n    case \" $LIB[]NAME\" in\n      *\" -l\"*) LIBS=\"$LIBS $LIB[]NAME\" ;;\n      *)       LIBS=\"$LIB[]NAME $LIBS\" ;;\n    esac\n    AC_TRY_LINK([$3], [$4],\n      [ac_cv_lib[]Name=yes],\n      [ac_cv_lib[]Name='m4_if([$5], [], [no], [[$5]])'])\n    LIBS=\"$ac_save_LIBS\"\n  ])\n  if test \"$ac_cv_lib[]Name\" = yes; then\n    HAVE_LIB[]NAME=yes\n    AC_DEFINE([HAVE_LIB]NAME, 1, [Define if you have the lib][$1 library.])\n    AC_MSG_CHECKING([how to link with lib[]$1])\n    AC_MSG_RESULT([$LIB[]NAME])\n  else\n    HAVE_LIB[]NAME=no\n    dnl If $LIB[]NAME didn't lead to a usable library, we don't need\n    dnl $INC[]NAME either.\n    CPPFLAGS=\"$ac_save_CPPFLAGS\"\n    LIB[]NAME=\n    LTLIB[]NAME=\n    LIB[]NAME[]_PREFIX=\n  fi\n  AC_SUBST([HAVE_LIB]NAME)\n  AC_SUBST([LIB]NAME)\n  AC_SUBST([LTLIB]NAME)\n  AC_SUBST([LIB]NAME[_PREFIX])\n  popdef([NAME])\n  popdef([Name])\n])\n\ndnl Determine the platform dependent parameters needed to use rpath:\ndnl   acl_libext,\ndnl   acl_shlibext,\ndnl   acl_hardcode_libdir_flag_spec,\ndnl   acl_hardcode_libdir_separator,\ndnl   acl_hardcode_direct,\ndnl   acl_hardcode_minus_L.\nAC_DEFUN([AC_LIB_RPATH],\n[\n  dnl Tell automake >= 1.10 to complain if config.rpath is missing.\n  m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([config.rpath])])\n  AC_REQUIRE([AC_PROG_CC])                dnl we use $CC, $GCC, $LDFLAGS\n  AC_REQUIRE([AC_LIB_PROG_LD])            dnl we use $LD, $with_gnu_ld\n  AC_REQUIRE([AC_CANONICAL_HOST])         dnl we use $host\n  AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT]) dnl we use $ac_aux_dir\n  AC_CACHE_CHECK([for shared library run path origin], [acl_cv_rpath], [\n    CC=\"$CC\" GCC=\"$GCC\" LDFLAGS=\"$LDFLAGS\" LD=\"$LD\" with_gnu_ld=\"$with_gnu_ld\" \\\n    ${CONFIG_SHELL-/bin/sh} \"$ac_aux_dir/config.rpath\" \"$host\" > conftest.sh\n    . ./conftest.sh\n    rm -f ./conftest.sh\n    acl_cv_rpath=done\n  ])\n  wl=\"$acl_cv_wl\"\n  acl_libext=\"$acl_cv_libext\"\n  acl_shlibext=\"$acl_cv_shlibext\"\n  acl_libname_spec=\"$acl_cv_libname_spec\"\n  acl_library_names_spec=\"$acl_cv_library_names_spec\"\n  acl_hardcode_libdir_flag_spec=\"$acl_cv_hardcode_libdir_flag_spec\"\n  acl_hardcode_libdir_separator=\"$acl_cv_hardcode_libdir_separator\"\n  acl_hardcode_direct=\"$acl_cv_hardcode_direct\"\n  acl_hardcode_minus_L=\"$acl_cv_hardcode_minus_L\"\n  dnl Determine whether the user wants rpath handling at all.\n  AC_ARG_ENABLE([rpath],\n    [  --disable-rpath         do not hardcode runtime library paths],\n    :, enable_rpath=yes)\n])\n\ndnl AC_LIB_FROMPACKAGE(name, package)\ndnl declares that libname comes from the given package. The configure file\ndnl will then not have a --with-libname-prefix option but a\ndnl --with-package-prefix option. Several libraries can come from the same\ndnl package. This declaration must occur before an AC_LIB_LINKFLAGS or similar\ndnl macro call that searches for libname.\nAC_DEFUN([AC_LIB_FROMPACKAGE],\n[\n  pushdef([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                                [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  define([acl_frompackage_]NAME, [$2])\n  popdef([NAME])\n  pushdef([PACK],[$2])\n  pushdef([PACKUP],[translit(PACK,[abcdefghijklmnopqrstuvwxyz./-],\n                                  [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  define([acl_libsinpackage_]PACKUP,\n    m4_ifdef([acl_libsinpackage_]PACKUP, [acl_libsinpackage_]PACKUP[[, ]],)[lib$1])\n  popdef([PACKUP])\n  popdef([PACK])\n])\n\ndnl AC_LIB_LINKFLAGS_BODY(name [, dependencies]) searches for libname and\ndnl the libraries corresponding to explicit and implicit dependencies.\ndnl Sets the LIB${NAME}, LTLIB${NAME} and INC${NAME} variables.\ndnl Also, sets the LIB${NAME}_PREFIX variable to nonempty if libname was found\ndnl in ${LIB${NAME}_PREFIX}/$acl_libdirstem.\nAC_DEFUN([AC_LIB_LINKFLAGS_BODY],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])\n  pushdef([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                                [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  pushdef([PACK],[m4_ifdef([acl_frompackage_]NAME, [acl_frompackage_]NAME, lib[$1])])\n  pushdef([PACKUP],[translit(PACK,[abcdefghijklmnopqrstuvwxyz./-],\n                                  [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  pushdef([PACKLIBS],[m4_ifdef([acl_frompackage_]NAME, [acl_libsinpackage_]PACKUP, lib[$1])])\n  dnl Autoconf >= 2.61 supports dots in --with options.\n  pushdef([P_A_C_K],[m4_if(m4_version_compare(m4_defn([m4_PACKAGE_VERSION]),[2.61]),[-1],[translit(PACK,[.],[_])],PACK)])\n  dnl By default, look in $includedir and $libdir.\n  use_additional=yes\n  AC_LIB_WITH_FINAL_PREFIX([\n    eval additional_includedir=\\\"$includedir\\\"\n    eval additional_libdir=\\\"$libdir\\\"\n  ])\n  AC_ARG_WITH(P_A_C_K[-prefix],\n[[  --with-]]P_A_C_K[[-prefix[=DIR]  search for ]PACKLIBS[ in DIR/include and DIR/lib\n  --without-]]P_A_C_K[[-prefix     don't search for ]PACKLIBS[ in includedir and libdir]],\n[\n    if test \"X$withval\" = \"Xno\"; then\n      use_additional=no\n    else\n      if test \"X$withval\" = \"X\"; then\n        AC_LIB_WITH_FINAL_PREFIX([\n          eval additional_includedir=\\\"$includedir\\\"\n          eval additional_libdir=\\\"$libdir\\\"\n        ])\n      else\n        additional_includedir=\"$withval/include\"\n        additional_libdir=\"$withval/$acl_libdirstem\"\n        if test \"$acl_libdirstem2\" != \"$acl_libdirstem\" \\\n           && ! test -d \"$withval/$acl_libdirstem\"; then\n          additional_libdir=\"$withval/$acl_libdirstem2\"\n        fi\n      fi\n    fi\n])\n  dnl Search the library and its dependencies in $additional_libdir and\n  dnl $LDFLAGS. Using breadth-first-seach.\n  LIB[]NAME=\n  LTLIB[]NAME=\n  INC[]NAME=\n  LIB[]NAME[]_PREFIX=\n  dnl HAVE_LIB${NAME} is an indicator that LIB${NAME}, LTLIB${NAME} have been\n  dnl computed. So it has to be reset here.\n  HAVE_LIB[]NAME=\n  rpathdirs=\n  ltrpathdirs=\n  names_already_handled=\n  names_next_round='$1 $2'\n  while test -n \"$names_next_round\"; do\n    names_this_round=\"$names_next_round\"\n    names_next_round=\n    for name in $names_this_round; do\n      already_handled=\n      for n in $names_already_handled; do\n        if test \"$n\" = \"$name\"; then\n          already_handled=yes\n          break\n        fi\n      done\n      if test -z \"$already_handled\"; then\n        names_already_handled=\"$names_already_handled $name\"\n        dnl See if it was already located by an earlier AC_LIB_LINKFLAGS\n        dnl or AC_LIB_HAVE_LINKFLAGS call.\n        uppername=`echo \"$name\" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./-|ABCDEFGHIJKLMNOPQRSTUVWXYZ___|'`\n        eval value=\\\"\\$HAVE_LIB$uppername\\\"\n        if test -n \"$value\"; then\n          if test \"$value\" = yes; then\n            eval value=\\\"\\$LIB$uppername\\\"\n            test -z \"$value\" || LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$value\"\n            eval value=\\\"\\$LTLIB$uppername\\\"\n            test -z \"$value\" || LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }$value\"\n          else\n            dnl An earlier call to AC_LIB_HAVE_LINKFLAGS has determined\n            dnl that this library doesn't exist. So just drop it.\n            :\n          fi\n        else\n          dnl Search the library lib$name in $additional_libdir and $LDFLAGS\n          dnl and the already constructed $LIBNAME/$LTLIBNAME.\n          found_dir=\n          found_la=\n          found_so=\n          found_a=\n          eval libname=\\\"$acl_libname_spec\\\"    # typically: libname=lib$name\n          if test -n \"$acl_shlibext\"; then\n            shrext=\".$acl_shlibext\"             # typically: shrext=.so\n          else\n            shrext=\n          fi\n          if test $use_additional = yes; then\n            dir=\"$additional_libdir\"\n            dnl The same code as in the loop below:\n            dnl First look for a shared library.\n            if test -n \"$acl_shlibext\"; then\n              if test -f \"$dir/$libname$shrext\"; then\n                found_dir=\"$dir\"\n                found_so=\"$dir/$libname$shrext\"\n              else\n                if test \"$acl_library_names_spec\" = '$libname$shrext$versuffix'; then\n                  ver=`(cd \"$dir\" && \\\n                        for f in \"$libname$shrext\".*; do echo \"$f\"; done \\\n                        | sed -e \"s,^$libname$shrext\\\\\\\\.,,\" \\\n                        | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \\\n                        | sed 1q ) 2>/dev/null`\n                  if test -n \"$ver\" && test -f \"$dir/$libname$shrext.$ver\"; then\n                    found_dir=\"$dir\"\n                    found_so=\"$dir/$libname$shrext.$ver\"\n                  fi\n                else\n                  eval library_names=\\\"$acl_library_names_spec\\\"\n                  for f in $library_names; do\n                    if test -f \"$dir/$f\"; then\n                      found_dir=\"$dir\"\n                      found_so=\"$dir/$f\"\n                      break\n                    fi\n                  done\n                fi\n              fi\n            fi\n            dnl Then look for a static library.\n            if test \"X$found_dir\" = \"X\"; then\n              if test -f \"$dir/$libname.$acl_libext\"; then\n                found_dir=\"$dir\"\n                found_a=\"$dir/$libname.$acl_libext\"\n              fi\n            fi\n            if test \"X$found_dir\" != \"X\"; then\n              if test -f \"$dir/$libname.la\"; then\n                found_la=\"$dir/$libname.la\"\n              fi\n            fi\n          fi\n          if test \"X$found_dir\" = \"X\"; then\n            for x in $LDFLAGS $LTLIB[]NAME; do\n              AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n              case \"$x\" in\n                -L*)\n                  dir=`echo \"X$x\" | sed -e 's/^X-L//'`\n                  dnl First look for a shared library.\n                  if test -n \"$acl_shlibext\"; then\n                    if test -f \"$dir/$libname$shrext\"; then\n                      found_dir=\"$dir\"\n                      found_so=\"$dir/$libname$shrext\"\n                    else\n                      if test \"$acl_library_names_spec\" = '$libname$shrext$versuffix'; then\n                        ver=`(cd \"$dir\" && \\\n                              for f in \"$libname$shrext\".*; do echo \"$f\"; done \\\n                              | sed -e \"s,^$libname$shrext\\\\\\\\.,,\" \\\n                              | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \\\n                              | sed 1q ) 2>/dev/null`\n                        if test -n \"$ver\" && test -f \"$dir/$libname$shrext.$ver\"; then\n                          found_dir=\"$dir\"\n                          found_so=\"$dir/$libname$shrext.$ver\"\n                        fi\n                      else\n                        eval library_names=\\\"$acl_library_names_spec\\\"\n                        for f in $library_names; do\n                          if test -f \"$dir/$f\"; then\n                            found_dir=\"$dir\"\n                            found_so=\"$dir/$f\"\n                            break\n                          fi\n                        done\n                      fi\n                    fi\n                  fi\n                  dnl Then look for a static library.\n                  if test \"X$found_dir\" = \"X\"; then\n                    if test -f \"$dir/$libname.$acl_libext\"; then\n                      found_dir=\"$dir\"\n                      found_a=\"$dir/$libname.$acl_libext\"\n                    fi\n                  fi\n                  if test \"X$found_dir\" != \"X\"; then\n                    if test -f \"$dir/$libname.la\"; then\n                      found_la=\"$dir/$libname.la\"\n                    fi\n                  fi\n                  ;;\n              esac\n              if test \"X$found_dir\" != \"X\"; then\n                break\n              fi\n            done\n          fi\n          if test \"X$found_dir\" != \"X\"; then\n            dnl Found the library.\n            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$found_dir -l$name\"\n            if test \"X$found_so\" != \"X\"; then\n              dnl Linking with a shared library. We attempt to hardcode its\n              dnl directory into the executable's runpath, unless it's the\n              dnl standard /usr/lib.\n              if test \"$enable_rpath\" = no \\\n                 || test \"X$found_dir\" = \"X/usr/$acl_libdirstem\" \\\n                 || test \"X$found_dir\" = \"X/usr/$acl_libdirstem2\"; then\n                dnl No hardcoding is needed.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n              else\n                dnl Use an explicit option to hardcode DIR into the resulting\n                dnl binary.\n                dnl Potentially add DIR to ltrpathdirs.\n                dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.\n                haveit=\n                for x in $ltrpathdirs; do\n                  if test \"X$x\" = \"X$found_dir\"; then\n                    haveit=yes\n                    break\n                  fi\n                done\n                if test -z \"$haveit\"; then\n                  ltrpathdirs=\"$ltrpathdirs $found_dir\"\n                fi\n                dnl The hardcoding into $LIBNAME is system dependent.\n                if test \"$acl_hardcode_direct\" = yes; then\n                  dnl Using DIR/libNAME.so during linking hardcodes DIR into the\n                  dnl resulting binary.\n                  LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                else\n                  if test -n \"$acl_hardcode_libdir_flag_spec\" && test \"$acl_hardcode_minus_L\" = no; then\n                    dnl Use an explicit option to hardcode DIR into the resulting\n                    dnl binary.\n                    LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                    dnl Potentially add DIR to rpathdirs.\n                    dnl The rpathdirs will be appended to $LIBNAME at the end.\n                    haveit=\n                    for x in $rpathdirs; do\n                      if test \"X$x\" = \"X$found_dir\"; then\n                        haveit=yes\n                        break\n                      fi\n                    done\n                    if test -z \"$haveit\"; then\n                      rpathdirs=\"$rpathdirs $found_dir\"\n                    fi\n                  else\n                    dnl Rely on \"-L$found_dir\".\n                    dnl But don't add it if it's already contained in the LDFLAGS\n                    dnl or the already constructed $LIBNAME\n                    haveit=\n                    for x in $LDFLAGS $LIB[]NAME; do\n                      AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                      if test \"X$x\" = \"X-L$found_dir\"; then\n                        haveit=yes\n                        break\n                      fi\n                    done\n                    if test -z \"$haveit\"; then\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir\"\n                    fi\n                    if test \"$acl_hardcode_minus_L\" != no; then\n                      dnl FIXME: Not sure whether we should use\n                      dnl \"-L$found_dir -l$name\" or \"-L$found_dir $found_so\"\n                      dnl here.\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                    else\n                      dnl We cannot use $acl_hardcode_runpath_var and LD_RUN_PATH\n                      dnl here, because this doesn't fit in flags passed to the\n                      dnl compiler. So give up. No hardcoding. This affects only\n                      dnl very old systems.\n                      dnl FIXME: Not sure whether we should use\n                      dnl \"-L$found_dir -l$name\" or \"-L$found_dir $found_so\"\n                      dnl here.\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-l$name\"\n                    fi\n                  fi\n                fi\n              fi\n            else\n              if test \"X$found_a\" != \"X\"; then\n                dnl Linking with a static library.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_a\"\n              else\n                dnl We shouldn't come here, but anyway it's good to have a\n                dnl fallback.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir -l$name\"\n              fi\n            fi\n            dnl Assume the include files are nearby.\n            additional_includedir=\n            case \"$found_dir\" in\n              */$acl_libdirstem | */$acl_libdirstem/)\n                basedir=`echo \"X$found_dir\" | sed -e 's,^X,,' -e \"s,/$acl_libdirstem/\"'*$,,'`\n                if test \"$name\" = '$1'; then\n                  LIB[]NAME[]_PREFIX=\"$basedir\"\n                fi\n                additional_includedir=\"$basedir/include\"\n                ;;\n              */$acl_libdirstem2 | */$acl_libdirstem2/)\n                basedir=`echo \"X$found_dir\" | sed -e 's,^X,,' -e \"s,/$acl_libdirstem2/\"'*$,,'`\n                if test \"$name\" = '$1'; then\n                  LIB[]NAME[]_PREFIX=\"$basedir\"\n                fi\n                additional_includedir=\"$basedir/include\"\n                ;;\n            esac\n            if test \"X$additional_includedir\" != \"X\"; then\n              dnl Potentially add $additional_includedir to $INCNAME.\n              dnl But don't add it\n              dnl   1. if it's the standard /usr/include,\n              dnl   2. if it's /usr/local/include and we are using GCC on Linux,\n              dnl   3. if it's already present in $CPPFLAGS or the already\n              dnl      constructed $INCNAME,\n              dnl   4. if it doesn't exist as a directory.\n              if test \"X$additional_includedir\" != \"X/usr/include\"; then\n                haveit=\n                if test \"X$additional_includedir\" = \"X/usr/local/include\"; then\n                  if test -n \"$GCC\"; then\n                    case $host_os in\n                      linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n                    esac\n                  fi\n                fi\n                if test -z \"$haveit\"; then\n                  for x in $CPPFLAGS $INC[]NAME; do\n                    AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                    if test \"X$x\" = \"X-I$additional_includedir\"; then\n                      haveit=yes\n                      break\n                    fi\n                  done\n                  if test -z \"$haveit\"; then\n                    if test -d \"$additional_includedir\"; then\n                      dnl Really add $additional_includedir to $INCNAME.\n                      INC[]NAME=\"${INC[]NAME}${INC[]NAME:+ }-I$additional_includedir\"\n                    fi\n                  fi\n                fi\n              fi\n            fi\n            dnl Look for dependencies.\n            if test -n \"$found_la\"; then\n              dnl Read the .la file. It defines the variables\n              dnl dlname, library_names, old_library, dependency_libs, current,\n              dnl age, revision, installed, dlopen, dlpreopen, libdir.\n              save_libdir=\"$libdir\"\n              case \"$found_la\" in\n                */* | *\\\\*) . \"$found_la\" ;;\n                *) . \"./$found_la\" ;;\n              esac\n              libdir=\"$save_libdir\"\n              dnl We use only dependency_libs.\n              for dep in $dependency_libs; do\n                case \"$dep\" in\n                  -L*)\n                    additional_libdir=`echo \"X$dep\" | sed -e 's/^X-L//'`\n                    dnl Potentially add $additional_libdir to $LIBNAME and $LTLIBNAME.\n                    dnl But don't add it\n                    dnl   1. if it's the standard /usr/lib,\n                    dnl   2. if it's /usr/local/lib and we are using GCC on Linux,\n                    dnl   3. if it's already present in $LDFLAGS or the already\n                    dnl      constructed $LIBNAME,\n                    dnl   4. if it doesn't exist as a directory.\n                    if test \"X$additional_libdir\" != \"X/usr/$acl_libdirstem\" \\\n                       && test \"X$additional_libdir\" != \"X/usr/$acl_libdirstem2\"; then\n                      haveit=\n                      if test \"X$additional_libdir\" = \"X/usr/local/$acl_libdirstem\" \\\n                         || test \"X$additional_libdir\" = \"X/usr/local/$acl_libdirstem2\"; then\n                        if test -n \"$GCC\"; then\n                          case $host_os in\n                            linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n                          esac\n                        fi\n                      fi\n                      if test -z \"$haveit\"; then\n                        haveit=\n                        for x in $LDFLAGS $LIB[]NAME; do\n                          AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                          if test \"X$x\" = \"X-L$additional_libdir\"; then\n                            haveit=yes\n                            break\n                          fi\n                        done\n                        if test -z \"$haveit\"; then\n                          if test -d \"$additional_libdir\"; then\n                            dnl Really add $additional_libdir to $LIBNAME.\n                            LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$additional_libdir\"\n                          fi\n                        fi\n                        haveit=\n                        for x in $LDFLAGS $LTLIB[]NAME; do\n                          AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                          if test \"X$x\" = \"X-L$additional_libdir\"; then\n                            haveit=yes\n                            break\n                          fi\n                        done\n                        if test -z \"$haveit\"; then\n                          if test -d \"$additional_libdir\"; then\n                            dnl Really add $additional_libdir to $LTLIBNAME.\n                            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$additional_libdir\"\n                          fi\n                        fi\n                      fi\n                    fi\n                    ;;\n                  -R*)\n                    dir=`echo \"X$dep\" | sed -e 's/^X-R//'`\n                    if test \"$enable_rpath\" != no; then\n                      dnl Potentially add DIR to rpathdirs.\n                      dnl The rpathdirs will be appended to $LIBNAME at the end.\n                      haveit=\n                      for x in $rpathdirs; do\n                        if test \"X$x\" = \"X$dir\"; then\n                          haveit=yes\n                          break\n                        fi\n                      done\n                      if test -z \"$haveit\"; then\n                        rpathdirs=\"$rpathdirs $dir\"\n                      fi\n                      dnl Potentially add DIR to ltrpathdirs.\n                      dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.\n                      haveit=\n                      for x in $ltrpathdirs; do\n                        if test \"X$x\" = \"X$dir\"; then\n                          haveit=yes\n                          break\n                        fi\n                      done\n                      if test -z \"$haveit\"; then\n                        ltrpathdirs=\"$ltrpathdirs $dir\"\n                      fi\n                    fi\n                    ;;\n                  -l*)\n                    dnl Handle this in the next round.\n                    names_next_round=\"$names_next_round \"`echo \"X$dep\" | sed -e 's/^X-l//'`\n                    ;;\n                  *.la)\n                    dnl Handle this in the next round. Throw away the .la's\n                    dnl directory; it is already contained in a preceding -L\n                    dnl option.\n                    names_next_round=\"$names_next_round \"`echo \"X$dep\" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\\.la$,,'`\n                    ;;\n                  *)\n                    dnl Most likely an immediate library name.\n                    LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$dep\"\n                    LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }$dep\"\n                    ;;\n                esac\n              done\n            fi\n          else\n            dnl Didn't find the library; assume it is in the system directories\n            dnl known to the linker and runtime loader. (All the system\n            dnl directories known to the linker should also be known to the\n            dnl runtime loader, otherwise the system is severely misconfigured.)\n            LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-l$name\"\n            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-l$name\"\n          fi\n        fi\n      fi\n    done\n  done\n  if test \"X$rpathdirs\" != \"X\"; then\n    if test -n \"$acl_hardcode_libdir_separator\"; then\n      dnl Weird platform: only the last -rpath option counts, the user must\n      dnl pass all path elements in one option. We can arrange that for a\n      dnl single library, but not when more than one $LIBNAMEs are used.\n      alldirs=\n      for found_dir in $rpathdirs; do\n        alldirs=\"${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$found_dir\"\n      done\n      dnl Note: acl_hardcode_libdir_flag_spec uses $libdir and $wl.\n      acl_save_libdir=\"$libdir\"\n      libdir=\"$alldirs\"\n      eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n      libdir=\"$acl_save_libdir\"\n      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$flag\"\n    else\n      dnl The -rpath options are cumulative.\n      for found_dir in $rpathdirs; do\n        acl_save_libdir=\"$libdir\"\n        libdir=\"$found_dir\"\n        eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n        libdir=\"$acl_save_libdir\"\n        LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$flag\"\n      done\n    fi\n  fi\n  if test \"X$ltrpathdirs\" != \"X\"; then\n    dnl When using libtool, the option that works for both libraries and\n    dnl executables is -R. The -R options are cumulative.\n    for found_dir in $ltrpathdirs; do\n      LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-R$found_dir\"\n    done\n  fi\n  popdef([P_A_C_K])\n  popdef([PACKLIBS])\n  popdef([PACKUP])\n  popdef([PACK])\n  popdef([NAME])\n])\n\ndnl AC_LIB_APPENDTOVAR(VAR, CONTENTS) appends the elements of CONTENTS to VAR,\ndnl unless already present in VAR.\ndnl Works only for CPPFLAGS, not for LIB* variables because that sometimes\ndnl contains two or three consecutive elements that belong together.\nAC_DEFUN([AC_LIB_APPENDTOVAR],\n[\n  for element in [$2]; do\n    haveit=\n    for x in $[$1]; do\n      AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n      if test \"X$x\" = \"X$element\"; then\n        haveit=yes\n        break\n      fi\n    done\n    if test -z \"$haveit\"; then\n      [$1]=\"${[$1]}${[$1]:+ }$element\"\n    fi\n  done\n])\n\ndnl For those cases where a variable contains several -L and -l options\ndnl referring to unknown libraries and directories, this macro determines the\ndnl necessary additional linker options for the runtime path.\ndnl AC_LIB_LINKFLAGS_FROM_LIBS([LDADDVAR], [LIBSVALUE], [USE-LIBTOOL])\ndnl sets LDADDVAR to linker options needed together with LIBSVALUE.\ndnl If USE-LIBTOOL evaluates to non-empty, linking with libtool is assumed,\ndnl otherwise linking without libtool is assumed.\nAC_DEFUN([AC_LIB_LINKFLAGS_FROM_LIBS],\n[\n  AC_REQUIRE([AC_LIB_RPATH])\n  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])\n  $1=\n  if test \"$enable_rpath\" != no; then\n    if test -n \"$acl_hardcode_libdir_flag_spec\" && test \"$acl_hardcode_minus_L\" = no; then\n      dnl Use an explicit option to hardcode directories into the resulting\n      dnl binary.\n      rpathdirs=\n      next=\n      for opt in $2; do\n        if test -n \"$next\"; then\n          dir=\"$next\"\n          dnl No need to hardcode the standard /usr/lib.\n          if test \"X$dir\" != \"X/usr/$acl_libdirstem\" \\\n             && test \"X$dir\" != \"X/usr/$acl_libdirstem2\"; then\n            rpathdirs=\"$rpathdirs $dir\"\n          fi\n          next=\n        else\n          case $opt in\n            -L) next=yes ;;\n            -L*) dir=`echo \"X$opt\" | sed -e 's,^X-L,,'`\n                 dnl No need to hardcode the standard /usr/lib.\n                 if test \"X$dir\" != \"X/usr/$acl_libdirstem\" \\\n                    && test \"X$dir\" != \"X/usr/$acl_libdirstem2\"; then\n                   rpathdirs=\"$rpathdirs $dir\"\n                 fi\n                 next= ;;\n            *) next= ;;\n          esac\n        fi\n      done\n      if test \"X$rpathdirs\" != \"X\"; then\n        if test -n \"\"$3\"\"; then\n          dnl libtool is used for linking. Use -R options.\n          for dir in $rpathdirs; do\n            $1=\"${$1}${$1:+ }-R$dir\"\n          done\n        else\n          dnl The linker is used for linking directly.\n          if test -n \"$acl_hardcode_libdir_separator\"; then\n            dnl Weird platform: only the last -rpath option counts, the user\n            dnl must pass all path elements in one option.\n            alldirs=\n            for dir in $rpathdirs; do\n              alldirs=\"${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$dir\"\n            done\n            acl_save_libdir=\"$libdir\"\n            libdir=\"$alldirs\"\n            eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n            libdir=\"$acl_save_libdir\"\n            $1=\"$flag\"\n          else\n            dnl The -rpath options are cumulative.\n            for dir in $rpathdirs; do\n              acl_save_libdir=\"$libdir\"\n              libdir=\"$dir\"\n              eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n              libdir=\"$acl_save_libdir\"\n              $1=\"${$1}${$1:+ }$flag\"\n            done\n          fi\n        fi\n      fi\n    fi\n  fi\n  AC_SUBST([$1])\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Data.Odbc/tests/System.Data.Odbc.Tests.csproj": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"14.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <Import Project=\"$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory), dir.props))\\dir.props\" />\n  <PropertyGroup>\n    <ProjectGuid>{F3E72F35-0351-4D67-2209-725BCAD807BA}</ProjectGuid>\n    <DefineConstants Condition=\"'$(TargetsWindows)' == 'true'\">$(DefineConstants);TargetsWindows</DefineConstants>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp-Unix-Debug|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp-Unix-Release|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp-Windows_NT-Debug|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp-Windows_NT-Release|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netfx-Windows_NT-Debug|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netfx-Windows_NT-Release|AnyCPU'\" />\n  <ItemGroup>\n    <Compile Include=\"DependencyCheckTest.cs\" />\n    <Compile Include=\"Helpers.cs\" />\n    <Compile Include=\"IntegrationTestBase.cs\" />\n    <Compile Include=\"CommandBuilderTests.cs\" />\n    <Compile Include=\"OdbcConnectionSchemaTests.cs\" />\n    <Compile Include=\"ReaderTests.cs\" />\n    <Compile Include=\"SmokeTest.cs\" />\n    <Compile Include=\"TestCommon\\DataTestUtility.cs\" />\n    <Compile Include=\"TestCommon\\CheckConnStrSetupFactAttribute.cs\" />\n    <Compile Include=\"OdbcParameterTests.cs\" />\n  </ItemGroup>\n  <ItemGroup Condition=\"'$(TargetsUnix)' == 'true'\">\n    <Compile Include=\"$(CommonPath)\\Interop\\Unix\\Interop.Libraries.cs\">\n      <Link>Common\\Interop\\Unix\\Interop.Libraries.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Unix\\libdl\\Interop.dlopen.cs\">\n      <Link>Common\\Interop\\Unix\\libdl\\Interop.dlopen.cs</Link>\n    </Compile>\n  </ItemGroup>\n  <ItemGroup Condition=\"'$(TargetsLinux)' == 'true'\">\n    <Compile Include=\"$(CommonPath)\\Interop\\Linux\\Interop.Libraries.cs\">\n      <Link>Common\\Interop\\Linux\\Interop.Libraries.cs</Link>\n    </Compile>\n  </ItemGroup>\n  <ItemGroup Condition=\"'$(TargetsOSX)' == 'true'\">\n    <Compile Include=\"$(CommonPath)\\Interop\\OSX\\Interop.Libraries.cs\">\n      <Link>Common\\Interop\\OSX\\Interop.Libraries.cs</Link>\n    </Compile>\n  </ItemGroup>\n  <ItemGroup Condition=\"'$(TargetsWindows)' == 'true'\">\n    <Compile Include=\"$(CommonPath)\\Interop\\Windows\\Interop.Libraries.cs\">\n      <Link>Common\\Interop\\Windows\\Interop.Libraries.cs</Link>\n    </Compile>\n    <Compile Include=\"ConnectionStrings.Windows.cs\" />\n  </ItemGroup>\n  <ItemGroup Condition=\"'$(TargetsWindows)' != 'true'\">\n    <Compile Include=\"ConnectionStrings.Unix.cs\" />\n  </ItemGroup>\n  <Import Project=\"$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory), dir.targets))\\dir.targets\" />\n</Project>",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Data.Odbc/tests/Helpers.cs": "// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\n\nnamespace System.Data.Odbc.Tests\n{\n    public static class Helpers\n    {\n        public const string OdbcIsAvailable = nameof(Helpers) + \".\" + nameof(CheckOdbcIsAvailable);\n        public const string OdbcNotAvailable = nameof(Helpers) + \".\" + nameof(CheckOdbcNotAvailable);\n\n        public static bool CheckOdbcNotAvailable() => !CheckOdbcIsAvailable();\n\n        private static bool CheckOdbcIsAvailable() =>\n#if TargetsWindows\n                !PlatformDetection.IsWindowsNanoServer && (!PlatformDetection.IsWindowsServerCore || Environment.Is64BitProcess);\n#else\n                Interop.Libdl.dlopen(Interop.Libraries.Odbc32, Interop.Libdl.RTLD_NOW) != IntPtr.Zero;\n#endif\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Native/Unix/System.Security.Cryptography.Native/opensslshim.c": "// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n//\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#include \"opensslshim.h\"\n\n// Define pointers to all the used ICU functions\n#define PER_FUNCTION_BLOCK(fn, isRequired) __typeof(fn) fn##_ptr;\nFOR_ALL_OPENSSL_FUNCTIONS\n#undef PER_FUNCTION_BLOCK\n\n// x.x.x, considering the max number of decimal digits for each component\n#define MaxVersionStringLength 32\n#define SONAME_BASE \"libssl.so.\"\n\nstatic void* libssl = NULL;\n\nstatic bool OpenLibrary()\n{\n    // If there is an override of the version specified using the CLR_OPENSSL_VERSION_OVERRIDE\n    // env variable, try to load that first.\n    // The format of the value in the env variable is expected to be the version numbers,\n    // like 1.0.0, 1.0.2 etc.\n    char* versionOverride = getenv(\"CLR_OPENSSL_VERSION_OVERRIDE\");\n\n    if ((versionOverride != NULL) && strnlen(versionOverride, MaxVersionStringLength + 1) <= MaxVersionStringLength)\n    {\n        char soName[sizeof(SONAME_BASE) + MaxVersionStringLength] = SONAME_BASE;\n\n        strcat(soName, versionOverride);\n        libssl = dlopen(soName, RTLD_LAZY);\n    }\n\n    if (libssl == NULL)\n    {\n        // Debian 9 has dropped support for SSLv3 and so they have bumped their soname. Let's try it\n        // before trying the version 1.0.0 to make it less probable that some of our other dependencies \n        // end up loading conflicting version of libssl.\n        libssl = dlopen(\"libssl.so.1.0.2\", RTLD_LAZY);\n    }\n\n    if (libssl == NULL)\n    {\n        // Now try the default versioned so naming as described in the OpenSSL doc\n        libssl = dlopen(\"libssl.so.1.0.0\", RTLD_LAZY);\n    }\n\n    if (libssl == NULL)\n    {\n        // Fedora derived distros use different naming for the version 1.0.0\n        libssl = dlopen(\"libssl.so.10\", RTLD_LAZY);\n    }\n\n    return libssl != NULL;\n}\n\n__attribute__((constructor))\nstatic void InitializeOpenSSLShim()\n{\n    if (!OpenLibrary())\n    {\n        fprintf(stderr, \"No usable version of the libssl was found\\n\");\n        abort();\n    }\n\n    // Get pointers to all the ICU functions that are needed\n#define PER_FUNCTION_BLOCK(fn, isRequired) \\\n    fn##_ptr = (__typeof(fn))(dlsym(libssl, #fn)); \\\n    if ((fn##_ptr) == NULL && isRequired) { fprintf(stderr, \"Cannot get required symbol \" #fn \" from libssl\\n\"); abort(); }\n\n    FOR_ALL_OPENSSL_FUNCTIONS\n#undef PER_FUNCTION_BLOCK    \n}\n\n__attribute__((destructor))\nstatic void ShutdownOpenSSLShim()\n{\n    if (libssl != NULL)\n    {\n        dlclose(libssl);\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Native/Unix/System.Security.Cryptography.Native/CMakeLists.txt": "\nproject(System.Security.Cryptography.Native)\n\nset(CMAKE_INCLUDE_CURRENT_DIR ON)\n\n# These are happening inside of OpenSSL-defined macros out of our control\nadd_compile_options(-Wno-cast-align)\n\nadd_definitions(-DPIC=1)\n\nif(CMAKE_STATIC_LIB_LINK)\n   set(CMAKE_FIND_LIBRARY_SUFFIXES .a)\nendif(CMAKE_STATIC_LIB_LINK)\n\nfind_package(OpenSSL REQUIRED)\ninclude_directories(SYSTEM ${OPENSSL_INCLUDE_DIR})\n\nset(NATIVECRYPTO_SOURCES\n    openssl.c\n    pal_asn1.c\n    pal_asn1_print.c\n    pal_bignum.c\n    pal_bio.c\n    pal_dsa.c\n    pal_ecdsa.c\n    pal_ecc_import_export.c\n    pal_eckey.c\n    pal_err.c\n    pal_evp.c\n    pal_evp_pkey.c\n    pal_evp_pkey_dsa.c\n    pal_evp_pkey_ecdh.c\n    pal_evp_pkey_eckey.c\n    pal_evp_pkey_rsa.c\n    pal_evp_cipher.c\n    pal_hmac.c\n    pal_pkcs12.c\n    pal_pkcs7.c\n    pal_rsa.c\n    pal_ssl.c\n    pal_x509.c\n    pal_x509_name.c\n    pal_x509_root.c\n    pal_x509ext.c\n)\n\nif (FEATURE_DISTRO_AGNOSTIC_SSL)\n    if (NOT CMAKE_SYSTEM_NAME STREQUAL Linux)\n        message(FATAL_ERROR \"FEATURE_DISTRO_AGNOSTIC_SSL can only be enabled for Linux\")\n    endif()\n\n    list(APPEND NATIVECRYPTO_SOURCES\n        opensslshim.c\n    )\n    add_definitions(-DFEATURE_DISTRO_AGNOSTIC_SSL)\nendif()\n\nadd_library(objlib OBJECT ${NATIVECRYPTO_SOURCES} ${VERSION_FILE_PATH})\n\nadd_library(System.Security.Cryptography.Native.OpenSsl\n    SHARED\n    $<TARGET_OBJECTS:objlib>\n)\n\nadd_library(System.Security.Cryptography.Native.OpenSsl-Static\n    STATIC\n    $<TARGET_OBJECTS:objlib>\n)\n\n# Disable the \"lib\" prefix.\nset_target_properties(System.Security.Cryptography.Native.OpenSsl PROPERTIES PREFIX \"\")\n\n# Disable the \"lib\" prefix and override default name\nset_target_properties(System.Security.Cryptography.Native.OpenSsl-Static PROPERTIES PREFIX \"\")\nset_target_properties(System.Security.Cryptography.Native.OpenSsl-Static PROPERTIES OUTPUT_NAME System.Security.Cryptography.Native.OpenSsl CLEAN_DIRECT_OUTPUT 1)\n\nif (FEATURE_DISTRO_AGNOSTIC_SSL)\n    add_custom_command(TARGET System.Security.Cryptography.Native.OpenSsl POST_BUILD\n        COMMENT \"Verifying System.Security.Cryptography.Native.OpenSsl.so dependencies\"\n        COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/../verify-so.sh \n            $<TARGET_FILE:System.Security.Cryptography.Native.OpenSsl> \n            \"Verification failed. System.Security.Cryptography.Native.OpenSsl.so has undefined dependencies. These are likely OpenSSL APIs that need to be added to opensslshim.h\"\n        VERBATIM\n    )\n\n    # Link with libdl.so to get the dlopen / dlsym / dlclose\n    target_link_libraries(System.Security.Cryptography.Native.OpenSsl\n      dl\n    )\nelse()\n    target_link_libraries(System.Security.Cryptography.Native.OpenSsl\n      ${OPENSSL_CRYPTO_LIBRARY}\n      ${OPENSSL_SSL_LIBRARY}\n    )\n  \n    # On OS X every library emits the manner in which it should be referenced.\n    # All of our libraries are referenced via @rpath, which is similar to how Linux and Windows\n    # libraries are loaded. The homebrew installation of OpenSSL (libcrypto, libssl) uses the\n    # full path to the library installation. This means that this library is not flexible to\n    # users installing newer libcrypto in the working directory, or to systems which do not\n    # install to the same path as homebrew does.\n    #\n    # So, after compiling, rewrite the references to libcrypto to be more flexible.\n    if (APPLE)\n        add_custom_command(TARGET System.Security.Cryptography.Native.OpenSsl POST_BUILD\n            COMMAND ${CMAKE_INSTALL_NAME_TOOL} -change /usr/local/opt/openssl/lib/libcrypto.1.0.0.dylib @rpath/libcrypto.1.0.0.dylib $<TARGET_FILE:System.Security.Cryptography.Native.OpenSsl>\n            COMMAND ${CMAKE_INSTALL_NAME_TOOL} -change /usr/local/opt/openssl/lib/libssl.1.0.0.dylib @rpath/libssl.1.0.0.dylib $<TARGET_FILE:System.Security.Cryptography.Native.OpenSsl>\n            COMMAND ${CMAKE_INSTALL_NAME_TOOL} -add_rpath @loader_path $<TARGET_FILE:System.Security.Cryptography.Native.OpenSsl>\n            )\n    endif()\nendif()\n\ninclude(configure.cmake)\n\ninstall_library_and_symbols (System.Security.Cryptography.Native.OpenSsl)\ninstall (TARGETS System.Security.Cryptography.Native.OpenSsl-Static DESTINATION .)\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Common/src/Interop/Unix/libdl/Interop.dlopen.cs": "// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Runtime.InteropServices;\n\ninternal partial class Interop\n{\n    internal partial class Libdl\n    {\n        public const int RTLD_NOW = 0x002;\n\n        [DllImport(Libraries.Libdl)]\n        public static extern IntPtr dlopen(string fileName, int flag);\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Drawing.Common/src/System.Drawing.Common.csproj": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"14.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <Import Project=\"$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory), dir.props))\\dir.props\" />\n  <PropertyGroup>\n    <OutputType>Library</OutputType>\n    <ProjectGuid>{191B3618-FECD-4ABD-9D6B-5AC90DC33621}</ProjectGuid>\n    <DefineConstants>$(DefineConstants);DRAWING_NAMESPACE</DefineConstants>\n    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n    <WarningsNotAsErrors>CS0618</WarningsNotAsErrors>\n    <DefineConstants Condition=\"'$(TargetsWindows)' == 'true'\">$(DefineConstants);FEATURE_WINDOWS_SYSTEM_COLORS;FEATURE_SYSTEM_EVENTS</DefineConstants>\n    <DefineConstants Condition=\"'$(TargetsUnix)' == 'true'\">$(DefineConstants);CORECLR;NETCORE</DefineConstants>\n    <DefineConstants Condition=\"'$(TargetGroup)' == 'netcoreapp2.0'\">$(DefineConstants);netcoreapp20</DefineConstants>\n    <IsPartialFacadeAssembly Condition=\"'$(TargetGroup)' == 'netfx'\">true</IsPartialFacadeAssembly>\n    <GeneratePlatformNotSupportedAssemblyMessage Condition=\"'$(TargetGroup)' == 'netstandard'\">SR.PlatformNotSupported_Drawing</GeneratePlatformNotSupportedAssemblyMessage>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp2.0-Unix-Debug|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp2.0-Unix-Release|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp2.0-Windows_NT-Debug|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp2.0-Windows_NT-Release|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp-Windows_NT-Debug|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp-Windows_NT-Release|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp-Unix-Debug|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp-Unix-Release|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netfx-Debug|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netfx-Release|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netstandard-Debug|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netstandard-Release|AnyCPU'\" />\n  <ItemGroup Condition=\"$(TargetGroup.StartsWith('netcoreapp'))\">\n    <!-- Shared source code, all configurations -->\n    <Compile Include=\"System\\Drawing\\Bitmap.cs\" />\n    <Compile Include=\"System\\Drawing\\BitmapSuffixInSameAssemblyAttribute.cs\" />\n    <Compile Include=\"System\\Drawing\\BitmapSuffixInSatelliteAssemblyAttribute.cs\" />\n    <Compile Include=\"System\\Drawing\\Brushes.cs\" />\n    <Compile Include=\"System\\Drawing\\CharacterRange.cs\" />\n    <Compile Include=\"System\\Drawing\\ColorTranslator.cs\" />\n    <Compile Include=\"System\\Drawing\\ContentAlignment.cs\" />\n    <Compile Include=\"System\\Drawing\\IDeviceContext.cs\" />\n    <Compile Include=\"System\\Drawing\\GdiplusNative.cs\" />\n    <Compile Include=\"System\\Drawing\\Graphics.cs\" />\n    <Compile Include=\"System\\Drawing\\GraphicsUnit.cs\" />\n    <Compile Include=\"System\\Drawing\\Icon.NotSerializable.cs\" />\n    <Compile Include=\"System\\Drawing\\Image.NotSerializable.cs\" />\n    <Compile Include=\"System\\Drawing\\Image.cs\" />\n    <Compile Include=\"System\\Drawing\\ImageType.cs\" />\n    <Compile Include=\"System\\Drawing\\Pen.cs\" />\n    <Compile Include=\"System\\Drawing\\Pens.cs\" />\n    <Compile Include=\"System\\Drawing\\RotateFlipType.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemColors.cs\" />\n    <Compile Include=\"System\\Drawing\\StringFormat.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemFonts.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemPens.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrinterUnit.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PreviewPageInfo.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintEventHandler.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintAction.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintPageEventHandler.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\QueryPageSettingsEventArgs.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\QueryPageSettingsEventHandler.cs\" />\n    <Compile Include=\"System\\Drawing\\Design\\CategoryNameCollection.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\Blend.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\BrushType.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\ColorBlend.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CombineMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CompositingMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CompositingQuality.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CoordinateSpace.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\DashStyle.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\FillMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\FlushIntention.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\GraphicsContainer.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\HatchBrush.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\HatchStyle.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\InterpolationMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\LinearGradientMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\LinearGradientBrush.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\LineCap.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\LineJoin.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\MatrixOrder.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\Matrix.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\PathData.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\PathGradientBrush.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\PathPointType.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\PenAlignment.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\PenType.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\PixelOffsetMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\QualityMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\RegionData.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\SmoothingMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\WrapMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\WarpMode.cs\" />\n    <Compile Include=\"System\\Drawing\\CopyPixelOperation.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorAdjustType.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorChannelFlags.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorMap.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorMapType.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorMatrixFlags.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\EmfPlusRecordType.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\EmfType.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\Encoder.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\EncoderParameterValueType.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\EncoderValue.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\FrameDimension.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ImageCodecFlags.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ImageFlags.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ImageFormat.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ImageLockMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetafileType.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\PaletteFlags.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\PixelFormat.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\PlayRecordCallback.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\PropertyItem.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\WmfPlaceableFileHeader.cs\" />\n    <Compile Include=\"System\\Drawing\\FontStyle.cs\" />\n    <Compile Include=\"System\\Drawing\\Region.cs\" />\n    <Compile Include=\"System\\Drawing\\StringAlignment.cs\" />\n    <Compile Include=\"System\\Drawing\\StringDigitSubstitute.cs\" />\n    <Compile Include=\"System\\Drawing\\StringFormatFlags.cs\" />\n    <Compile Include=\"System\\Drawing\\StringTrimming.cs\" />\n    <Compile Include=\"System\\Drawing\\StringUnit.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\GenericFontFamilies.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\HotkeyPrefix.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\TextRenderingHint.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\PrivateFontCollection.cs\" />\n    <Compile Include=\"System\\Drawing\\ClientUtils.cs\" />\n    <Compile Include=\"misc\\CompModSwitches.cs\" />\n    <Compile Include=\"misc\\DebugHandleTracker.cs\" />\n    <Compile Include=\"misc\\HandleCollector.cs\" />\n    <Compile Include=\"System\\Drawing\\Gdiplus.cs\" />\n    <Compile Include=\"System\\Drawing\\NativeMethods.cs\" />\n    <Compile Include=\"System\\Drawing\\UnsafeNativeMethods.cs\" />\n    <Compile Include=\"System\\Drawing\\Internal\\GPPOINT.cs\" />\n    <Compile Include=\"System\\Drawing\\Internal\\GPPOINTF.cs\" />\n    <Compile Include=\"System\\Drawing\\Internal\\GPRECT.cs\" />\n    <Compile Include=\"System\\Drawing\\Internal\\GPRECTF.cs\" />\n    <Compile Include=\"System\\Drawing\\Internal\\ISystemEventTracker.cs\" />\n    <Compile Include=\"System\\Drawing\\Brush.cs\" />\n    <Compile Include=\"System\\Drawing\\Font.NotSerializable.cs\" />\n    <Compile Include=\"System\\Drawing\\FontFamily.cs\" />\n    <Compile Include=\"System\\Drawing\\SolidBrush.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemBrushes.cs\" />\n    <Compile Include=\"System\\Drawing\\TextureBrush.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CustomLineCapType.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\EmfPlusFlags.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetafileHeaderWmf.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetafileHeaderEmf.cs\" />\n    <Compile Include=\"System\\Drawing\\PropertyItemInternal.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\Duplex.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\InvalidPrinterException.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\InvalidPrinterException.Core.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\Margins.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PaperKinds.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PaperSize.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PaperSource.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PaperSourceKind.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrinterResolution.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrinterResolutionKind.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrinterUnitConvert.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintRange.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\AdjustableArrowCap.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CustomLineCap.cs\" />\n    <Compile Include=\"System\\Drawing\\DashCap.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\GraphicsPathIterator.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\GraphicsState.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\SafeCustomLineCapHandle.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\FontCollection.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\InstalledFontCollection.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorMatrix.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorPalette.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\EncoderParameter.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\EncoderParameters.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ImageAttributes.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ImageCodecInfo.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ImageCodecInfoPrivate.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetafileFrameUnit.cs\" />\n    <Compile Include=\"$(CommonPath)\\System\\Drawing\\ColorConverterCommon.cs\">\n      <Link>System\\Drawing\\ColorConverterCommon.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\System\\Drawing\\ColorTable.cs\">\n      <Link>System\\Drawing\\ColorTable.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\System\\Drawing\\ColorUtil.netcoreapp20.cs\">\n      <Link>System\\Drawing\\ColorUtil.netcoreapp20.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\System\\Drawing\\KnownColorTable.cs\">\n      <Link>System\\Drawing\\KnownColorTable.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\System\\Runtime\\InteropServices\\FunctionWrapper.cs\">\n      <Link>Common\\System\\Runtime\\InteropServices\\FunctionWrapper.cs</Link>\n    </Compile>\n    <EmbeddedResource Include=\"Resources\\System\\Drawing\\DefaultComponent.bmp\">\n      <LogicalName>System.Drawing.DefaultComponent.bmp</LogicalName>\n    </EmbeddedResource>\n    <EmbeddedResource Include=\"Resources\\System\\Drawing\\Printing\\PrintDocument.bmp\" />\n    <EmbeddedResource Include=\"Resources\\System\\Drawing\\ShieldIcon.ico\">\n      <LogicalName>System.Drawing.ShieldIcon.ico</LogicalName>\n    </EmbeddedResource>\n  </ItemGroup>\n  <ItemGroup Condition=\"'$(TargetGroup)' == 'netcoreapp2.0'\">\n    <Compile Include=\"misc\\InvalidEnumArgumentException.cs\" />\n    <Compile Include=\"$(CommonPath)\\System\\Drawing\\KnownColor.cs\">\n      <Link>System\\Drawing\\KnownColor.cs</Link>\n    </Compile>\n  </ItemGroup>\n  <ItemGroup Condition=\"$(TargetGroup.StartsWith('netcoreapp')) AND '$(TargetsWindows)' == 'true'\">\n    <!-- Windows-specific -->\n    <Compile Include=\"AssemblyRef.cs\" />\n    <Compile Include=\"SRDescriptionAttribute.cs\" />\n    <Compile Include=\"System\\Drawing\\Bitmap.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\BitmapSelector.cs\" />\n    <Compile Include=\"System\\Drawing\\BufferedGraphics.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\BufferedGraphicsContext.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\BufferedGraphicsManager.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CustomLineCap.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\GraphicsPath.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Font.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\FontFamily.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\GdiplusNative.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Graphics.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\GraphicsContext.cs\" />\n    <Compile Include=\"System\\Drawing\\Icon.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Image.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\ImageAnimator.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\ImageInfo.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\BitmapData.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\Metafile.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetafileHeader.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetaHeader.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Internal\\GPStream.cs\" />\n    <Compile Include=\"System\\Drawing\\Internal\\SystemColorTracker.cs\" />\n    <Compile Include=\"System\\Drawing\\LocalAppContextSwitches.cs\" />\n    <Compile Include=\"System\\Drawing\\Pen.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\DefaultPrintController.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\ModeField.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PageSettings.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PreviewPrintController.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintController.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintDocument.Windows.cs\">\n      <SubType>Component</SubType>\n    </Compile>\n    <Compile Include=\"System\\Drawing\\Printing\\PrinterSettings.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintEventArgs.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintPageEventArgs.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintPreviewGraphics.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\TriState.cs\" />\n    <Compile Include=\"System\\Drawing\\Region.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemFonts.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemIcons.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\ToolboxBitmapAttribute.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\PrivateFontCollection.Windows.cs\" />\n    <Compile Include=\"misc\\DbgUtil.cs\" />\n    <Compile Include=\"misc\\DpiHelper.cs\" />\n    <Compile Include=\"misc\\ExternDll.cs\" />\n    <Compile Include=\"misc\\GDI\\ApplyGraphicsProperties.cs\" />\n    <Compile Include=\"misc\\GDI\\DeviceContext.cs\" />\n    <Compile Include=\"misc\\GDI\\DeviceContexts.cs\" />\n    <Compile Include=\"misc\\GDI\\DeviceContextType.cs\" />\n    <Compile Include=\"misc\\GDI\\NativeMethods.cs\" />\n    <Compile Include=\"misc\\GDI\\SafeNativeMethods.cs\" />\n    <Compile Include=\"misc\\GDI\\UnsafeNativeMethods.cs\" />\n    <Compile Include=\"misc\\GDI\\WindowsGraphics.cs\" />\n    <Compile Include=\"misc\\GDI\\WindowsRegion.cs\" />\n    <Compile Include=\"misc\\GDI\\WindowsRegionCombineMode.cs\" />\n    <Compile Include=\"$(CommonPath)\\System\\LocalAppContext.cs\" />\n    <Compile Include=\"$(CommonPath)\\System\\Numerics\\Hashing\\HashHelpers.cs\">\n      <Link>Common\\System\\Numerics\\Hashing\\HashHelpers.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Windows\\Interop.Libraries.cs\">\n      <Link>Common\\Interop\\Windows\\Interop.Libraries.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Windows\\kernel32\\Interop.FreeLibrary.cs\">\n      <Link>Common\\Interop\\Windows\\kernel32\\Interop.FreeLibrary.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Windows\\kernel32\\Interop.LoadLibraryEx.cs\">\n      <Link>Common\\Interop\\Windows\\kernel32\\Interop.LoadLibraryEx.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Windows\\kernel32\\Interop.GetProcAddress.cs\">\n      <Link>Common\\Interop\\Windows\\kernel32\\Interop.GetProcAddress.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Windows\\user32\\Interop.GetSysColor.cs\">\n      <Link>Common\\Interop\\Windows\\user32\\Interop.GetSysColor.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Windows\\user32\\Interop.Win32SystemColors.cs\">\n      <Link>Common\\Interop\\Windows\\user32\\Interop.Win32SystemColors.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Microsoft\\Win32\\SafeHandles\\SafeLibraryHandle.cs\">\n      <Link>Common\\Microsoft\\Win32\\SafeHandles\\SafeLibraryHandle.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\System\\Runtime\\InteropServices\\FunctionWrapper.Windows.cs\">\n      <Link>Common\\System\\Runtime\\InteropServices\\FunctionWrapper.Windows.cs</Link>\n    </Compile>\n  </ItemGroup>\n  <ItemGroup Condition=\"$(TargetGroup.StartsWith('netcoreapp')) AND '$(TargetsUnix)' == 'true'\">\n    <!-- Unix-specific -->\n    <Compile Include=\"System\\Drawing\\Graphics.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Icon.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemFonts.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\BitmapData.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\Metafile.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetafileHeader.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetaHeader.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\LibcupsNative.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintingServices.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PageSettings.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PreviewPrintController.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintController.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintDocument.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrinterSettings.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintEventArgs.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintPageEventArgs.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\StandardPrintController.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Bitmap.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\BufferedGraphics.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\BufferedGraphicsManager.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\BufferedGraphicsContext.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\macFunctions.cs\" />\n    <Compile Include=\"System\\Drawing\\Font.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\FontFamily.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\GdiplusNative.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\GdiPlusStreamHelper.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\LibX11Functions.cs\" />\n    <Compile Include=\"System\\Drawing\\MarshallingHelpers.cs\" />\n    <Compile Include=\"System\\Drawing\\NativeStructs.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\ImageAnimator.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Image.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Pen.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Region.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\SRDescriptionAttribute.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemIcons.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\ToolboxBitmapAttribute.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\AdjustableArrowCap.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CustomLineCap.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\GraphicsPath.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\PrivateFontCollection.Unix.cs\" />\n    <Compile Include=\"MonoTODOAttribute.cs\" />\n    <Compile Include=\"misc\\ExternDll.Unix.cs\" />\n    <Compile Include=\"$(CommonPath)\\Interop\\Unix\\Interop.Libraries.cs\">\n      <Link>Common\\Interop\\Unix\\Interop.Libraries.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Unix\\libdl\\Interop.dlopen.cs\">\n      <Link>Common\\Interop\\Unix\\libdl\\Interop.dlopen.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Unix\\libdl\\Interop.dlsym.cs\">\n      <Link>Common\\Interop\\Unix\\libdl\\Interop.dlsym.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\System\\Runtime\\InteropServices\\FunctionWrapper.Unix.cs\">\n      <Link>Common\\System\\Runtime\\InteropServices\\FunctionWrapper.Unix.cs</Link>\n    </Compile>\n    <EmbeddedResource Include=\"Resources\\System\\Drawing\\Error.ico\">\n      <LogicalName>placeholder.ico</LogicalName>\n    </EmbeddedResource>\n  </ItemGroup>\n  <ItemGroup Condition=\"'$(TargetGroup)' != 'netfx'\">\n    <Reference Include=\"Microsoft.Win32.Primitives\" />\n    <Reference Condition=\"'$(TargetsWindows)' == 'true'\" Include=\"Microsoft.Win32.SystemEvents\" />\n    <Reference Include=\"System.Collections\" />\n    <Reference Include=\"System.Collections.NonGeneric\" />\n    <Reference Include=\"System.Collections.Specialized\" />\n    <Reference Include=\"System.Diagnostics.Debug\" />\n    <Reference Include=\"System.Diagnostics.StackTrace\" />\n    <Reference Include=\"System.Diagnostics.Tools\" />\n    <Reference Include=\"System.Diagnostics.TraceSource\" />\n    <Reference Include=\"System.Drawing.Primitives\" />\n    <Reference Include=\"System.IO.FileSystem\" />\n    <Reference Include=\"System.Resources.ResourceManager\" />\n    <Reference Include=\"System.Runtime\" />\n    <Reference Include=\"System.Runtime.Extensions\" />\n    <Reference Include=\"System.Runtime.InteropServices\" />\n    <Reference Include=\"System.Runtime.InteropServices.RuntimeInformation\" />\n    <Reference Include=\"System.ComponentModel\" />\n    <Reference Include=\"System.ComponentModel.Primitives\" />\n    <Reference Include=\"System.Threading\" />\n    <Reference Include=\"System.Threading.Thread\" />\n    <Reference Include=\"System.Text.Encoding.Extensions\" />\n  </ItemGroup>\n  <ItemGroup Condition=\"'$(TargetGroup)' == 'netfx'\">\n    <Reference Include=\"mscorlib\" />\n    <Reference Include=\"System\" />\n    <Reference Include=\"System.Drawing\" />\n  </ItemGroup>\n  <Import Project=\"$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory), dir.targets))\\dir.targets\" />\n</Project>\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Drawing.Common/src/System/Drawing/GdiplusNative.Unix.cs": "\ufeff// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System.Drawing.Drawing2D;\nusing System.Drawing.Imaging;\nusing System.Drawing.Text;\nusing System.IO;\nusing System.Runtime.InteropServices;\n\nnamespace System.Drawing\n{\n    internal partial class SafeNativeMethods\n    {\n        internal unsafe partial class Gdip\n        {\n            private const string LibraryName = \"libgdiplus\";\n            public static IntPtr Display = IntPtr.Zero;\n\n            // Indicates whether X11 is available. It's available on Linux but not on recent macOS versions\n            // When set to false, where Carbon Drawing is used instead.\n            // macOS users can force X11 by setting the SYSTEM_DRAWING_COMMON_FORCE_X11 flag.\n            public static bool UseX11Drawable { get; } =\n                !RuntimeInformation.IsOSPlatform(OSPlatform.OSX) ||\n                Environment.GetEnvironmentVariable(\"SYSTEM_DRAWING_COMMON_FORCE_X11\") != null;\n\n            private static IntPtr LoadNativeLibrary()\n            {\n                string libraryName;\n\n                IntPtr lib = IntPtr.Zero;\n                if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))\n                {\n                    libraryName = \"libgdiplus.dylib\";\n                    lib = Interop.Libdl.dlopen(libraryName, Interop.Libdl.RTLD_NOW);\n                }\n                else\n                {\n                    // Various Unix package managers have chosen different names for the \"libgdiplus\" shared library.\n                    // The mono project, where libgdiplus originated, allowed both of the names below to be used, via\n                    // a global configuration setting. We prefer the \"unversioned\" shared object name, and fallback to\n                    // the name suffixed with \".0\".\n                    libraryName = \"libgdiplus.so\";\n                    lib = Interop.Libdl.dlopen(libraryName, Interop.Libdl.RTLD_NOW);\n                    if (lib == IntPtr.Zero)\n                    {\n                        lib = Interop.Libdl.dlopen(\"libgdiplus.so.0\", Interop.Libdl.RTLD_NOW);\n                    }\n                }\n\n                // If we couldn't find libgdiplus in the system search path, try to look for libgdiplus in the\n                // NuGet package folders. This matches the DllImport behavior.\n                if (lib == IntPtr.Zero)\n                {\n                    string[] searchDirectories = ((string)AppContext.GetData(\"NATIVE_DLL_SEARCH_DIRECTORIES\")).Split(':');\n\n                    foreach (var searchDirectory in searchDirectories)\n                    {\n                        var searchPath = Path.Combine(searchDirectory, libraryName);\n\n                        lib = Interop.Libdl.dlopen(searchPath, Interop.Libdl.RTLD_NOW);\n\n                        if (lib != IntPtr.Zero)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                // This function may return a null handle. If it does, individual functions loaded from it will throw a DllNotFoundException,\n                // but not until an attempt is made to actually use the function (rather than load it). This matches how PInvokes behave.\n                return lib;\n            }\n\n            private static IntPtr LoadFunctionPointer(IntPtr nativeLibraryHandle, string functionName) => Interop.Libdl.dlsym(nativeLibraryHandle, functionName);\n\n            private static void PlatformInitialize()\n            {\n                LoadFunctionPointers();\n            }\n\n            private static void LoadFunctionPointers()\n            {\n                GdiplusStartup_ptr = FunctionWrapper.Load<GdiplusStartup_delegate>(s_gdipModule, \"GdiplusStartup\", LibraryName);\n                GdiplusShutdown_ptr = FunctionWrapper.Load<GdiplusShutdown_delegate>(s_gdipModule, \"GdiplusShutdown\", LibraryName);\n                GdipAlloc_ptr = FunctionWrapper.Load<GdipAlloc_delegate>(s_gdipModule, \"GdipAlloc\", LibraryName);\n                GdipFree_ptr = FunctionWrapper.Load<GdipFree_delegate>(s_gdipModule, \"GdipFree\", LibraryName);\n                GdipDeleteBrush_ptr = FunctionWrapper.Load<GdipDeleteBrush_delegate>(s_gdipModule, \"GdipDeleteBrush\", LibraryName);\n                GdipGetBrushType_ptr = FunctionWrapper.Load<GdipGetBrushType_delegate>(s_gdipModule, \"GdipGetBrushType\", LibraryName);\n                GdipCreateFromHDC_ptr = FunctionWrapper.Load<GdipCreateFromHDC_delegate>(s_gdipModule, \"GdipCreateFromHDC\", LibraryName);\n                GdipDeleteGraphics_ptr = FunctionWrapper.Load<GdipDeleteGraphics_delegate>(s_gdipModule, \"GdipDeleteGraphics\", LibraryName);\n                GdipRestoreGraphics_ptr = FunctionWrapper.Load<GdipRestoreGraphics_delegate>(s_gdipModule, \"GdipRestoreGraphics\", LibraryName);\n                GdipSaveGraphics_ptr = FunctionWrapper.Load<GdipSaveGraphics_delegate>(s_gdipModule, \"GdipSaveGraphics\", LibraryName);\n                GdipDrawArc_ptr = FunctionWrapper.Load<GdipDrawArc_delegate>(s_gdipModule, \"GdipDrawArc\", LibraryName);\n                GdipDrawArcI_ptr = FunctionWrapper.Load<GdipDrawArcI_delegate>(s_gdipModule, \"GdipDrawArcI\", LibraryName);\n                GdipDrawBezier_ptr = FunctionWrapper.Load<GdipDrawBezier_delegate>(s_gdipModule, \"GdipDrawBezier\", LibraryName);\n                GdipDrawBezierI_ptr = FunctionWrapper.Load<GdipDrawBezierI_delegate>(s_gdipModule, \"GdipDrawBezierI\", LibraryName);\n                GdipDrawEllipseI_ptr = FunctionWrapper.Load<GdipDrawEllipseI_delegate>(s_gdipModule, \"GdipDrawEllipseI\", LibraryName);\n                GdipDrawEllipse_ptr = FunctionWrapper.Load<GdipDrawEllipse_delegate>(s_gdipModule, \"GdipDrawEllipse\", LibraryName);\n                GdipDrawLine_ptr = FunctionWrapper.Load<GdipDrawLine_delegate>(s_gdipModule, \"GdipDrawLine\", LibraryName);\n                GdipDrawLineI_ptr = FunctionWrapper.Load<GdipDrawLineI_delegate>(s_gdipModule, \"GdipDrawLineI\", LibraryName);\n                GdipDrawLines_ptr = FunctionWrapper.Load<GdipDrawLines_delegate>(s_gdipModule, \"GdipDrawLines\", LibraryName);\n                GdipDrawLinesI_ptr = FunctionWrapper.Load<GdipDrawLinesI_delegate>(s_gdipModule, \"GdipDrawLinesI\", LibraryName);\n                GdipDrawPath_ptr = FunctionWrapper.Load<GdipDrawPath_delegate>(s_gdipModule, \"GdipDrawPath\", LibraryName);\n                GdipDrawPie_ptr = FunctionWrapper.Load<GdipDrawPie_delegate>(s_gdipModule, \"GdipDrawPie\", LibraryName);\n                GdipDrawPieI_ptr = FunctionWrapper.Load<GdipDrawPieI_delegate>(s_gdipModule, \"GdipDrawPieI\", LibraryName);\n                GdipDrawPolygon_ptr = FunctionWrapper.Load<GdipDrawPolygon_delegate>(s_gdipModule, \"GdipDrawPolygon\", LibraryName);\n                GdipDrawPolygonI_ptr = FunctionWrapper.Load<GdipDrawPolygonI_delegate>(s_gdipModule, \"GdipDrawPolygonI\", LibraryName);\n                GdipDrawRectangle_ptr = FunctionWrapper.Load<GdipDrawRectangle_delegate>(s_gdipModule, \"GdipDrawRectangle\", LibraryName);\n                GdipDrawRectangleI_ptr = FunctionWrapper.Load<GdipDrawRectangleI_delegate>(s_gdipModule, \"GdipDrawRectangleI\", LibraryName);\n                GdipDrawRectangles_ptr = FunctionWrapper.Load<GdipDrawRectangles_delegate>(s_gdipModule, \"GdipDrawRectangles\", LibraryName);\n                GdipDrawRectanglesI_ptr = FunctionWrapper.Load<GdipDrawRectanglesI_delegate>(s_gdipModule, \"GdipDrawRectanglesI\", LibraryName);\n                GdipFillEllipseI_ptr = FunctionWrapper.Load<GdipFillEllipseI_delegate>(s_gdipModule, \"GdipFillEllipseI\", LibraryName);\n                GdipFillEllipse_ptr = FunctionWrapper.Load<GdipFillEllipse_delegate>(s_gdipModule, \"GdipFillEllipse\", LibraryName);\n                GdipFillPolygon_ptr = FunctionWrapper.Load<GdipFillPolygon_delegate>(s_gdipModule, \"GdipFillPolygon\", LibraryName);\n                GdipFillPolygonI_ptr = FunctionWrapper.Load<GdipFillPolygonI_delegate>(s_gdipModule, \"GdipFillPolygonI\", LibraryName);\n                GdipFillPolygon2_ptr = FunctionWrapper.Load<GdipFillPolygon2_delegate>(s_gdipModule, \"GdipFillPolygon2\", LibraryName);\n                GdipFillPolygon2I_ptr = FunctionWrapper.Load<GdipFillPolygon2I_delegate>(s_gdipModule, \"GdipFillPolygon2I\", LibraryName);\n                GdipFillRectangle_ptr = FunctionWrapper.Load<GdipFillRectangle_delegate>(s_gdipModule, \"GdipFillRectangle\", LibraryName);\n                GdipFillRectangleI_ptr = FunctionWrapper.Load<GdipFillRectangleI_delegate>(s_gdipModule, \"GdipFillRectangleI\", LibraryName);\n                GdipFillRectangles_ptr = FunctionWrapper.Load<GdipFillRectangles_delegate>(s_gdipModule, \"GdipFillRectangles\", LibraryName);\n                GdipFillRectanglesI_ptr = FunctionWrapper.Load<GdipFillRectanglesI_delegate>(s_gdipModule, \"GdipFillRectanglesI\", LibraryName);\n                GdipDrawString_ptr = FunctionWrapper.Load<GdipDrawString_delegate>(s_gdipModule, \"GdipDrawString\", LibraryName);\n                GdipGetDC_ptr = FunctionWrapper.Load<GdipGetDC_delegate>(s_gdipModule, \"GdipGetDC\", LibraryName);\n                GdipReleaseDC_ptr = FunctionWrapper.Load<GdipReleaseDC_delegate>(s_gdipModule, \"GdipReleaseDC\", LibraryName);\n                GdipDrawImageRectI_ptr = FunctionWrapper.Load<GdipDrawImageRectI_delegate>(s_gdipModule, \"GdipDrawImageRectI\", LibraryName);\n                GdipGetRenderingOrigin_ptr = FunctionWrapper.Load<GdipGetRenderingOrigin_delegate>(s_gdipModule, \"GdipGetRenderingOrigin\", LibraryName);\n                GdipSetRenderingOrigin_ptr = FunctionWrapper.Load<GdipSetRenderingOrigin_delegate>(s_gdipModule, \"GdipSetRenderingOrigin\", LibraryName);\n                GdipGraphicsClear_ptr = FunctionWrapper.Load<GdipGraphicsClear_delegate>(s_gdipModule, \"GdipGraphicsClear\", LibraryName);\n                GdipDrawClosedCurve_ptr = FunctionWrapper.Load<GdipDrawClosedCurve_delegate>(s_gdipModule, \"GdipDrawClosedCurve\", LibraryName);\n                GdipDrawClosedCurveI_ptr = FunctionWrapper.Load<GdipDrawClosedCurveI_delegate>(s_gdipModule, \"GdipDrawClosedCurveI\", LibraryName);\n                GdipDrawClosedCurve2_ptr = FunctionWrapper.Load<GdipDrawClosedCurve2_delegate>(s_gdipModule, \"GdipDrawClosedCurve2\", LibraryName);\n                GdipDrawClosedCurve2I_ptr = FunctionWrapper.Load<GdipDrawClosedCurve2I_delegate>(s_gdipModule, \"GdipDrawClosedCurve2I\", LibraryName);\n                GdipDrawCurve_ptr = FunctionWrapper.Load<GdipDrawCurve_delegate>(s_gdipModule, \"GdipDrawCurve\", LibraryName);\n                GdipDrawCurveI_ptr = FunctionWrapper.Load<GdipDrawCurveI_delegate>(s_gdipModule, \"GdipDrawCurveI\", LibraryName);\n                GdipDrawCurve2_ptr = FunctionWrapper.Load<GdipDrawCurve2_delegate>(s_gdipModule, \"GdipDrawCurve2\", LibraryName);\n                GdipDrawCurve2I_ptr = FunctionWrapper.Load<GdipDrawCurve2I_delegate>(s_gdipModule, \"GdipDrawCurve2I\", LibraryName);\n                GdipDrawCurve3_ptr = FunctionWrapper.Load<GdipDrawCurve3_delegate>(s_gdipModule, \"GdipDrawCurve3\", LibraryName);\n                GdipDrawCurve3I_ptr = FunctionWrapper.Load<GdipDrawCurve3I_delegate>(s_gdipModule, \"GdipDrawCurve3I\", LibraryName);\n                GdipFillClosedCurve_ptr = FunctionWrapper.Load<GdipFillClosedCurve_delegate>(s_gdipModule, \"GdipFillClosedCurve\", LibraryName);\n                GdipFillClosedCurveI_ptr = FunctionWrapper.Load<GdipFillClosedCurveI_delegate>(s_gdipModule, \"GdipFillClosedCurveI\", LibraryName);\n                GdipFillClosedCurve2_ptr = FunctionWrapper.Load<GdipFillClosedCurve2_delegate>(s_gdipModule, \"GdipFillClosedCurve2\", LibraryName);\n                GdipFillClosedCurve2I_ptr = FunctionWrapper.Load<GdipFillClosedCurve2I_delegate>(s_gdipModule, \"GdipFillClosedCurve2I\", LibraryName);\n                GdipFillPie_ptr = FunctionWrapper.Load<GdipFillPie_delegate>(s_gdipModule, \"GdipFillPie\", LibraryName);\n                GdipFillPieI_ptr = FunctionWrapper.Load<GdipFillPieI_delegate>(s_gdipModule, \"GdipFillPieI\", LibraryName);\n                GdipFillPath_ptr = FunctionWrapper.Load<GdipFillPath_delegate>(s_gdipModule, \"GdipFillPath\", LibraryName);\n                GdipGetNearestColor_ptr = FunctionWrapper.Load<GdipGetNearestColor_delegate>(s_gdipModule, \"GdipGetNearestColor\", LibraryName);\n                GdipTransformPoints_ptr = FunctionWrapper.Load<GdipTransformPoints_delegate>(s_gdipModule, \"GdipTransformPoints\", LibraryName);\n                GdipTransformPointsI_ptr = FunctionWrapper.Load<GdipTransformPointsI_delegate>(s_gdipModule, \"GdipTransformPointsI\", LibraryName);\n                GdipSetCompositingMode_ptr = FunctionWrapper.Load<GdipSetCompositingMode_delegate>(s_gdipModule, \"GdipSetCompositingMode\", LibraryName);\n                GdipGetCompositingMode_ptr = FunctionWrapper.Load<GdipGetCompositingMode_delegate>(s_gdipModule, \"GdipGetCompositingMode\", LibraryName);\n                GdipSetCompositingQuality_ptr = FunctionWrapper.Load<GdipSetCompositingQuality_delegate>(s_gdipModule, \"GdipSetCompositingQuality\", LibraryName);\n                GdipGetCompositingQuality_ptr = FunctionWrapper.Load<GdipGetCompositingQuality_delegate>(s_gdipModule, \"GdipGetCompositingQuality\", LibraryName);\n                GdipSetInterpolationMode_ptr = FunctionWrapper.Load<GdipSetInterpolationMode_delegate>(s_gdipModule, \"GdipSetInterpolationMode\", LibraryName);\n                GdipGetInterpolationMode_ptr = FunctionWrapper.Load<GdipGetInterpolationMode_delegate>(s_gdipModule, \"GdipGetInterpolationMode\", LibraryName);\n                GdipGetDpiX_ptr = FunctionWrapper.Load<GdipGetDpiX_delegate>(s_gdipModule, \"GdipGetDpiX\", LibraryName);\n                GdipGetDpiY_ptr = FunctionWrapper.Load<GdipGetDpiY_delegate>(s_gdipModule, \"GdipGetDpiY\", LibraryName);\n                GdipGetPageUnit_ptr = FunctionWrapper.Load<GdipGetPageUnit_delegate>(s_gdipModule, \"GdipGetPageUnit\", LibraryName);\n                GdipGetPageScale_ptr = FunctionWrapper.Load<GdipGetPageScale_delegate>(s_gdipModule, \"GdipGetPageScale\", LibraryName);\n                GdipSetPageUnit_ptr = FunctionWrapper.Load<GdipSetPageUnit_delegate>(s_gdipModule, \"GdipSetPageUnit\", LibraryName);\n                GdipSetPageScale_ptr = FunctionWrapper.Load<GdipSetPageScale_delegate>(s_gdipModule, \"GdipSetPageScale\", LibraryName);\n                GdipSetPixelOffsetMode_ptr = FunctionWrapper.Load<GdipSetPixelOffsetMode_delegate>(s_gdipModule, \"GdipSetPixelOffsetMode\", LibraryName);\n                GdipGetPixelOffsetMode_ptr = FunctionWrapper.Load<GdipGetPixelOffsetMode_delegate>(s_gdipModule, \"GdipGetPixelOffsetMode\", LibraryName);\n                GdipSetSmoothingMode_ptr = FunctionWrapper.Load<GdipSetSmoothingMode_delegate>(s_gdipModule, \"GdipSetSmoothingMode\", LibraryName);\n                GdipGetSmoothingMode_ptr = FunctionWrapper.Load<GdipGetSmoothingMode_delegate>(s_gdipModule, \"GdipGetSmoothingMode\", LibraryName);\n                GdipSetTextContrast_ptr = FunctionWrapper.Load<GdipSetTextContrast_delegate>(s_gdipModule, \"GdipSetTextContrast\", LibraryName);\n                GdipGetTextContrast_ptr = FunctionWrapper.Load<GdipGetTextContrast_delegate>(s_gdipModule, \"GdipGetTextContrast\", LibraryName);\n                GdipSetTextRenderingHint_ptr = FunctionWrapper.Load<GdipSetTextRenderingHint_delegate>(s_gdipModule, \"GdipSetTextRenderingHint\", LibraryName);\n                GdipGetTextRenderingHint_ptr = FunctionWrapper.Load<GdipGetTextRenderingHint_delegate>(s_gdipModule, \"GdipGetTextRenderingHint\", LibraryName);\n                GdipFlush_ptr = FunctionWrapper.Load<GdipFlush_delegate>(s_gdipModule, \"GdipFlush\", LibraryName);\n                GdipAddPathString_ptr = FunctionWrapper.Load<GdipAddPathString_delegate>(s_gdipModule, \"GdipAddPathString\", LibraryName);\n                GdipAddPathStringI_ptr = FunctionWrapper.Load<GdipAddPathStringI_delegate>(s_gdipModule, \"GdipAddPathStringI\", LibraryName);\n                GdipCreateFromHWND_ptr = FunctionWrapper.Load<GdipCreateFromHWND_delegate>(s_gdipModule, \"GdipCreateFromHWND\", LibraryName);\n                GdipMeasureString_ptr = FunctionWrapper.Load<GdipMeasureString_delegate>(s_gdipModule, \"GdipMeasureString\", LibraryName);\n                GdipMeasureCharacterRanges_ptr = FunctionWrapper.Load<GdipMeasureCharacterRanges_delegate>(s_gdipModule, \"GdipMeasureCharacterRanges\", LibraryName);\n                GdipLoadImageFromFile_ptr = FunctionWrapper.Load<GdipLoadImageFromFile_delegate>(s_gdipModule, \"GdipLoadImageFromFile\", LibraryName);\n                GdipCloneImage_ptr = FunctionWrapper.Load<GdipCloneImage_delegate>(s_gdipModule, \"GdipCloneImage\", LibraryName);\n                GdipLoadImageFromFileICM_ptr = FunctionWrapper.Load<GdipLoadImageFromFileICM_delegate>(s_gdipModule, \"GdipLoadImageFromFileICM\", LibraryName);\n                GdipCreateBitmapFromHBITMAP_ptr = FunctionWrapper.Load<GdipCreateBitmapFromHBITMAP_delegate>(s_gdipModule, \"GdipCreateBitmapFromHBITMAP\", LibraryName);\n                GdipDisposeImage_ptr = FunctionWrapper.Load<GdipDisposeImage_delegate>(s_gdipModule, \"GdipDisposeImage\", LibraryName);\n                GdipGetImageFlags_ptr = FunctionWrapper.Load<GdipGetImageFlags_delegate>(s_gdipModule, \"GdipGetImageFlags\", LibraryName);\n                GdipGetImageType_ptr = FunctionWrapper.Load<GdipGetImageType_delegate>(s_gdipModule, \"GdipGetImageType\", LibraryName);\n                GdipImageGetFrameDimensionsCount_ptr = FunctionWrapper.Load<GdipImageGetFrameDimensionsCount_delegate>(s_gdipModule, \"GdipImageGetFrameDimensionsCount\", LibraryName);\n                GdipImageGetFrameDimensionsList_ptr = FunctionWrapper.Load<GdipImageGetFrameDimensionsList_delegate>(s_gdipModule, \"GdipImageGetFrameDimensionsList\", LibraryName);\n                GdipGetImageHeight_ptr = FunctionWrapper.Load<GdipGetImageHeight_delegate>(s_gdipModule, \"GdipGetImageHeight\", LibraryName);\n                GdipGetImageHorizontalResolution_ptr = FunctionWrapper.Load<GdipGetImageHorizontalResolution_delegate>(s_gdipModule, \"GdipGetImageHorizontalResolution\", LibraryName);\n                GdipGetImagePaletteSize_ptr = FunctionWrapper.Load<GdipGetImagePaletteSize_delegate>(s_gdipModule, \"GdipGetImagePaletteSize\", LibraryName);\n                GdipGetImagePalette_ptr = FunctionWrapper.Load<GdipGetImagePalette_delegate>(s_gdipModule, \"GdipGetImagePalette\", LibraryName);\n                GdipSetImagePalette_ptr = FunctionWrapper.Load<GdipSetImagePalette_delegate>(s_gdipModule, \"GdipSetImagePalette\", LibraryName);\n                GdipGetImageDimension_ptr = FunctionWrapper.Load<GdipGetImageDimension_delegate>(s_gdipModule, \"GdipGetImageDimension\", LibraryName);\n                GdipGetImagePixelFormat_ptr = FunctionWrapper.Load<GdipGetImagePixelFormat_delegate>(s_gdipModule, \"GdipGetImagePixelFormat\", LibraryName);\n                GdipGetPropertyCount_ptr = FunctionWrapper.Load<GdipGetPropertyCount_delegate>(s_gdipModule, \"GdipGetPropertyCount\", LibraryName);\n                GdipGetPropertyIdList_ptr = FunctionWrapper.Load<GdipGetPropertyIdList_delegate>(s_gdipModule, \"GdipGetPropertyIdList\", LibraryName);\n                GdipGetPropertySize_ptr = FunctionWrapper.Load<GdipGetPropertySize_delegate>(s_gdipModule, \"GdipGetPropertySize\", LibraryName);\n                GdipGetAllPropertyItems_ptr = FunctionWrapper.Load<GdipGetAllPropertyItems_delegate>(s_gdipModule, \"GdipGetAllPropertyItems\", LibraryName);\n                GdipGetImageRawFormat_ptr = FunctionWrapper.Load<GdipGetImageRawFormat_delegate>(s_gdipModule, \"GdipGetImageRawFormat\", LibraryName);\n                GdipGetImageVerticalResolution_ptr = FunctionWrapper.Load<GdipGetImageVerticalResolution_delegate>(s_gdipModule, \"GdipGetImageVerticalResolution\", LibraryName);\n                GdipGetImageWidth_ptr = FunctionWrapper.Load<GdipGetImageWidth_delegate>(s_gdipModule, \"GdipGetImageWidth\", LibraryName);\n                GdipGetImageBounds_ptr = FunctionWrapper.Load<GdipGetImageBounds_delegate>(s_gdipModule, \"GdipGetImageBounds\", LibraryName);\n                GdipGetEncoderParameterListSize_ptr = FunctionWrapper.Load<GdipGetEncoderParameterListSize_delegate>(s_gdipModule, \"GdipGetEncoderParameterListSize\", LibraryName);\n                GdipGetEncoderParameterList_ptr = FunctionWrapper.Load<GdipGetEncoderParameterList_delegate>(s_gdipModule, \"GdipGetEncoderParameterList\", LibraryName);\n                GdipImageGetFrameCount_ptr = FunctionWrapper.Load<GdipImageGetFrameCount_delegate>(s_gdipModule, \"GdipImageGetFrameCount\", LibraryName);\n                GdipImageSelectActiveFrame_ptr = FunctionWrapper.Load<GdipImageSelectActiveFrame_delegate>(s_gdipModule, \"GdipImageSelectActiveFrame\", LibraryName);\n                GdipGetPropertyItemSize_ptr = FunctionWrapper.Load<GdipGetPropertyItemSize_delegate>(s_gdipModule, \"GdipGetPropertyItemSize\", LibraryName);\n                GdipGetPropertyItem_ptr = FunctionWrapper.Load<GdipGetPropertyItem_delegate>(s_gdipModule, \"GdipGetPropertyItem\", LibraryName);\n                GdipRemovePropertyItem_ptr = FunctionWrapper.Load<GdipRemovePropertyItem_delegate>(s_gdipModule, \"GdipRemovePropertyItem\", LibraryName);\n                GdipSetPropertyItem_ptr = FunctionWrapper.Load<GdipSetPropertyItem_delegate>(s_gdipModule, \"GdipSetPropertyItem\", LibraryName);\n                GdipGetImageThumbnail_ptr = FunctionWrapper.Load<GdipGetImageThumbnail_delegate>(s_gdipModule, \"GdipGetImageThumbnail\", LibraryName);\n                GdipImageRotateFlip_ptr = FunctionWrapper.Load<GdipImageRotateFlip_delegate>(s_gdipModule, \"GdipImageRotateFlip\", LibraryName);\n                GdipSaveImageToFile_ptr = FunctionWrapper.Load<GdipSaveImageToFile_delegate>(s_gdipModule, \"GdipSaveImageToFile\", LibraryName);\n                GdipSaveAdd_ptr = FunctionWrapper.Load<GdipSaveAdd_delegate>(s_gdipModule, \"GdipSaveAdd\", LibraryName);\n                GdipSaveAddImage_ptr = FunctionWrapper.Load<GdipSaveAddImage_delegate>(s_gdipModule, \"GdipSaveAddImage\", LibraryName);\n                GdipDrawImageI_ptr = FunctionWrapper.Load<GdipDrawImageI_delegate>(s_gdipModule, \"GdipDrawImageI\", LibraryName);\n                GdipGetImageGraphicsContext_ptr = FunctionWrapper.Load<GdipGetImageGraphicsContext_delegate>(s_gdipModule, \"GdipGetImageGraphicsContext\", LibraryName);\n                GdipDrawImage_ptr = FunctionWrapper.Load<GdipDrawImage_delegate>(s_gdipModule, \"GdipDrawImage\", LibraryName);\n                GdipDrawImagePoints_ptr = FunctionWrapper.Load<GdipDrawImagePoints_delegate>(s_gdipModule, \"GdipDrawImagePoints\", LibraryName);\n                GdipDrawImagePointsI_ptr = FunctionWrapper.Load<GdipDrawImagePointsI_delegate>(s_gdipModule, \"GdipDrawImagePointsI\", LibraryName);\n                GdipDrawImageRectRectI_ptr = FunctionWrapper.Load<GdipDrawImageRectRectI_delegate>(s_gdipModule, \"GdipDrawImageRectRectI\", LibraryName);\n                GdipDrawImageRectRect_ptr = FunctionWrapper.Load<GdipDrawImageRectRect_delegate>(s_gdipModule, \"GdipDrawImageRectRect\", LibraryName);\n                GdipDrawImagePointsRectI_ptr = FunctionWrapper.Load<GdipDrawImagePointsRectI_delegate>(s_gdipModule, \"GdipDrawImagePointsRectI\", LibraryName);\n                GdipDrawImagePointsRect_ptr = FunctionWrapper.Load<GdipDrawImagePointsRect_delegate>(s_gdipModule, \"GdipDrawImagePointsRect\", LibraryName);\n                GdipDrawImageRect_ptr = FunctionWrapper.Load<GdipDrawImageRect_delegate>(s_gdipModule, \"GdipDrawImageRect\", LibraryName);\n                GdipDrawImagePointRect_ptr = FunctionWrapper.Load<GdipDrawImagePointRect_delegate>(s_gdipModule, \"GdipDrawImagePointRect\", LibraryName);\n                GdipDrawImagePointRectI_ptr = FunctionWrapper.Load<GdipDrawImagePointRectI_delegate>(s_gdipModule, \"GdipDrawImagePointRectI\", LibraryName);\n                GdipCreatePath_ptr = FunctionWrapper.Load<GdipCreatePath_delegate>(s_gdipModule, \"GdipCreatePath\", LibraryName);\n                GdipCreatePath2_ptr = FunctionWrapper.Load<GdipCreatePath2_delegate>(s_gdipModule, \"GdipCreatePath2\", LibraryName);\n                GdipCreatePath2I_ptr = FunctionWrapper.Load<GdipCreatePath2I_delegate>(s_gdipModule, \"GdipCreatePath2I\", LibraryName);\n                GdipClonePath_ptr = FunctionWrapper.Load<GdipClonePath_delegate>(s_gdipModule, \"GdipClonePath\", LibraryName);\n                GdipDeletePath_ptr = FunctionWrapper.Load<GdipDeletePath_delegate>(s_gdipModule, \"GdipDeletePath\", LibraryName);\n                GdipResetPath_ptr = FunctionWrapper.Load<GdipResetPath_delegate>(s_gdipModule, \"GdipResetPath\", LibraryName);\n                GdipGetPointCount_ptr = FunctionWrapper.Load<GdipGetPointCount_delegate>(s_gdipModule, \"GdipGetPointCount\", LibraryName);\n                GdipGetPathTypes_ptr = FunctionWrapper.Load<GdipGetPathTypes_delegate>(s_gdipModule, \"GdipGetPathTypes\", LibraryName);\n                GdipGetPathPoints_ptr = FunctionWrapper.Load<GdipGetPathPoints_delegate>(s_gdipModule, \"GdipGetPathPoints\", LibraryName);\n                GdipGetPathPointsI_ptr = FunctionWrapper.Load<GdipGetPathPointsI_delegate>(s_gdipModule, \"GdipGetPathPointsI\", LibraryName);\n                GdipGetPathFillMode_ptr = FunctionWrapper.Load<GdipGetPathFillMode_delegate>(s_gdipModule, \"GdipGetPathFillMode\", LibraryName);\n                GdipSetPathFillMode_ptr = FunctionWrapper.Load<GdipSetPathFillMode_delegate>(s_gdipModule, \"GdipSetPathFillMode\", LibraryName);\n                GdipStartPathFigure_ptr = FunctionWrapper.Load<GdipStartPathFigure_delegate>(s_gdipModule, \"GdipStartPathFigure\", LibraryName);\n                GdipClosePathFigure_ptr = FunctionWrapper.Load<GdipClosePathFigure_delegate>(s_gdipModule, \"GdipClosePathFigure\", LibraryName);\n                GdipClosePathFigures_ptr = FunctionWrapper.Load<GdipClosePathFigures_delegate>(s_gdipModule, \"GdipClosePathFigures\", LibraryName);\n                GdipSetPathMarker_ptr = FunctionWrapper.Load<GdipSetPathMarker_delegate>(s_gdipModule, \"GdipSetPathMarker\", LibraryName);\n                GdipClearPathMarkers_ptr = FunctionWrapper.Load<GdipClearPathMarkers_delegate>(s_gdipModule, \"GdipClearPathMarkers\", LibraryName);\n                GdipReversePath_ptr = FunctionWrapper.Load<GdipReversePath_delegate>(s_gdipModule, \"GdipReversePath\", LibraryName);\n                GdipGetPathLastPoint_ptr = FunctionWrapper.Load<GdipGetPathLastPoint_delegate>(s_gdipModule, \"GdipGetPathLastPoint\", LibraryName);\n                GdipAddPathLine_ptr = FunctionWrapper.Load<GdipAddPathLine_delegate>(s_gdipModule, \"GdipAddPathLine\", LibraryName);\n                GdipAddPathLine2_ptr = FunctionWrapper.Load<GdipAddPathLine2_delegate>(s_gdipModule, \"GdipAddPathLine2\", LibraryName);\n                GdipAddPathLine2I_ptr = FunctionWrapper.Load<GdipAddPathLine2I_delegate>(s_gdipModule, \"GdipAddPathLine2I\", LibraryName);\n                GdipAddPathArc_ptr = FunctionWrapper.Load<GdipAddPathArc_delegate>(s_gdipModule, \"GdipAddPathArc\", LibraryName);\n                GdipAddPathBezier_ptr = FunctionWrapper.Load<GdipAddPathBezier_delegate>(s_gdipModule, \"GdipAddPathBezier\", LibraryName);\n                GdipAddPathBeziers_ptr = FunctionWrapper.Load<GdipAddPathBeziers_delegate>(s_gdipModule, \"GdipAddPathBeziers\", LibraryName);\n                GdipAddPathCurve_ptr = FunctionWrapper.Load<GdipAddPathCurve_delegate>(s_gdipModule, \"GdipAddPathCurve\", LibraryName);\n                GdipAddPathCurveI_ptr = FunctionWrapper.Load<GdipAddPathCurveI_delegate>(s_gdipModule, \"GdipAddPathCurveI\", LibraryName);\n                GdipAddPathCurve2_ptr = FunctionWrapper.Load<GdipAddPathCurve2_delegate>(s_gdipModule, \"GdipAddPathCurve2\", LibraryName);\n                GdipAddPathCurve2I_ptr = FunctionWrapper.Load<GdipAddPathCurve2I_delegate>(s_gdipModule, \"GdipAddPathCurve2I\", LibraryName);\n                GdipAddPathCurve3_ptr = FunctionWrapper.Load<GdipAddPathCurve3_delegate>(s_gdipModule, \"GdipAddPathCurve3\", LibraryName);\n                GdipAddPathCurve3I_ptr = FunctionWrapper.Load<GdipAddPathCurve3I_delegate>(s_gdipModule, \"GdipAddPathCurve3I\", LibraryName);\n                GdipAddPathClosedCurve_ptr = FunctionWrapper.Load<GdipAddPathClosedCurve_delegate>(s_gdipModule, \"GdipAddPathClosedCurve\", LibraryName);\n                GdipAddPathClosedCurveI_ptr = FunctionWrapper.Load<GdipAddPathClosedCurveI_delegate>(s_gdipModule, \"GdipAddPathClosedCurveI\", LibraryName);\n                GdipAddPathClosedCurve2_ptr = FunctionWrapper.Load<GdipAddPathClosedCurve2_delegate>(s_gdipModule, \"GdipAddPathClosedCurve2\", LibraryName);\n                GdipAddPathClosedCurve2I_ptr = FunctionWrapper.Load<GdipAddPathClosedCurve2I_delegate>(s_gdipModule, \"GdipAddPathClosedCurve2I\", LibraryName);\n                GdipAddPathRectangle_ptr = FunctionWrapper.Load<GdipAddPathRectangle_delegate>(s_gdipModule, \"GdipAddPathRectangle\", LibraryName);\n                GdipAddPathRectangles_ptr = FunctionWrapper.Load<GdipAddPathRectangles_delegate>(s_gdipModule, \"GdipAddPathRectangles\", LibraryName);\n                GdipAddPathEllipse_ptr = FunctionWrapper.Load<GdipAddPathEllipse_delegate>(s_gdipModule, \"GdipAddPathEllipse\", LibraryName);\n                GdipAddPathEllipseI_ptr = FunctionWrapper.Load<GdipAddPathEllipseI_delegate>(s_gdipModule, \"GdipAddPathEllipseI\", LibraryName);\n                GdipAddPathPie_ptr = FunctionWrapper.Load<GdipAddPathPie_delegate>(s_gdipModule, \"GdipAddPathPie\", LibraryName);\n                GdipAddPathPieI_ptr = FunctionWrapper.Load<GdipAddPathPieI_delegate>(s_gdipModule, \"GdipAddPathPieI\", LibraryName);\n                GdipAddPathPolygon_ptr = FunctionWrapper.Load<GdipAddPathPolygon_delegate>(s_gdipModule, \"GdipAddPathPolygon\", LibraryName);\n                GdipAddPathPath_ptr = FunctionWrapper.Load<GdipAddPathPath_delegate>(s_gdipModule, \"GdipAddPathPath\", LibraryName);\n                GdipAddPathLineI_ptr = FunctionWrapper.Load<GdipAddPathLineI_delegate>(s_gdipModule, \"GdipAddPathLineI\", LibraryName);\n                GdipAddPathArcI_ptr = FunctionWrapper.Load<GdipAddPathArcI_delegate>(s_gdipModule, \"GdipAddPathArcI\", LibraryName);\n                GdipAddPathBezierI_ptr = FunctionWrapper.Load<GdipAddPathBezierI_delegate>(s_gdipModule, \"GdipAddPathBezierI\", LibraryName);\n                GdipAddPathBeziersI_ptr = FunctionWrapper.Load<GdipAddPathBeziersI_delegate>(s_gdipModule, \"GdipAddPathBeziersI\", LibraryName);\n                GdipAddPathPolygonI_ptr = FunctionWrapper.Load<GdipAddPathPolygonI_delegate>(s_gdipModule, \"GdipAddPathPolygonI\", LibraryName);\n                GdipAddPathRectangleI_ptr = FunctionWrapper.Load<GdipAddPathRectangleI_delegate>(s_gdipModule, \"GdipAddPathRectangleI\", LibraryName);\n                GdipAddPathRectanglesI_ptr = FunctionWrapper.Load<GdipAddPathRectanglesI_delegate>(s_gdipModule, \"GdipAddPathRectanglesI\", LibraryName);\n                GdipFlattenPath_ptr = FunctionWrapper.Load<GdipFlattenPath_delegate>(s_gdipModule, \"GdipFlattenPath\", LibraryName);\n                GdipTransformPath_ptr = FunctionWrapper.Load<GdipTransformPath_delegate>(s_gdipModule, \"GdipTransformPath\", LibraryName);\n                GdipWarpPath_ptr = FunctionWrapper.Load<GdipWarpPath_delegate>(s_gdipModule, \"GdipWarpPath\", LibraryName);\n                GdipWidenPath_ptr = FunctionWrapper.Load<GdipWidenPath_delegate>(s_gdipModule, \"GdipWidenPath\", LibraryName);\n                GdipGetPathWorldBounds_ptr = FunctionWrapper.Load<GdipGetPathWorldBounds_delegate>(s_gdipModule, \"GdipGetPathWorldBounds\", LibraryName);\n                GdipGetPathWorldBoundsI_ptr = FunctionWrapper.Load<GdipGetPathWorldBoundsI_delegate>(s_gdipModule, \"GdipGetPathWorldBoundsI\", LibraryName);\n                GdipIsVisiblePathPoint_ptr = FunctionWrapper.Load<GdipIsVisiblePathPoint_delegate>(s_gdipModule, \"GdipIsVisiblePathPoint\", LibraryName);\n                GdipIsVisiblePathPointI_ptr = FunctionWrapper.Load<GdipIsVisiblePathPointI_delegate>(s_gdipModule, \"GdipIsVisiblePathPointI\", LibraryName);\n                GdipIsOutlineVisiblePathPoint_ptr = FunctionWrapper.Load<GdipIsOutlineVisiblePathPoint_delegate>(s_gdipModule, \"GdipIsOutlineVisiblePathPoint\", LibraryName);\n                GdipIsOutlineVisiblePathPointI_ptr = FunctionWrapper.Load<GdipIsOutlineVisiblePathPointI_delegate>(s_gdipModule, \"GdipIsOutlineVisiblePathPointI\", LibraryName);\n                GdipCreateFont_ptr = FunctionWrapper.Load<GdipCreateFont_delegate>(s_gdipModule, \"GdipCreateFont\", LibraryName);\n                GdipDeleteFont_ptr = FunctionWrapper.Load<GdipDeleteFont_delegate>(s_gdipModule, \"GdipDeleteFont\", LibraryName);\n                GdipGetLogFont_ptr = FunctionWrapper.Load<GdipGetLogFont_delegate>(s_gdipModule, \"GdipGetLogFontW\", LibraryName);\n                GdipCreateFontFromDC_ptr = FunctionWrapper.Load<GdipCreateFontFromDC_delegate>(s_gdipModule, \"GdipCreateFontFromDC\", LibraryName);\n                GdipCreateFontFromLogfont_ptr = FunctionWrapper.Load<GdipCreateFontFromLogfont_delegate>(s_gdipModule, \"GdipCreateFontFromLogfontW\", LibraryName);\n                GdipCreateFontFromHfont_ptr = FunctionWrapper.Load<GdipCreateFontFromHfont_delegate>(s_gdipModule, \"GdipCreateFontFromHfontA\", LibraryName);\n                GdipGetFontSize_ptr = FunctionWrapper.Load<GdipGetFontSize_delegate>(s_gdipModule, \"GdipGetFontSize\", LibraryName);\n                GdipGetFontHeight_ptr = FunctionWrapper.Load<GdipGetFontHeight_delegate>(s_gdipModule, \"GdipGetFontHeight\", LibraryName);\n                GdipGetFontHeightGivenDPI_ptr = FunctionWrapper.Load<GdipGetFontHeightGivenDPI_delegate>(s_gdipModule, \"GdipGetFontHeightGivenDPI\", LibraryName);\n                GdipCreateMetafileFromFile_ptr = FunctionWrapper.Load<GdipCreateMetafileFromFile_delegate>(s_gdipModule, \"GdipCreateMetafileFromFile\", LibraryName);\n                GdipCreateMetafileFromEmf_ptr = FunctionWrapper.Load<GdipCreateMetafileFromEmf_delegate>(s_gdipModule, \"GdipCreateMetafileFromEmf\", LibraryName);\n                GdipCreateMetafileFromWmf_ptr = FunctionWrapper.Load<GdipCreateMetafileFromWmf_delegate>(s_gdipModule, \"GdipCreateMetafileFromWmf\", LibraryName);\n                GdipGetMetafileHeaderFromFile_ptr = FunctionWrapper.Load<GdipGetMetafileHeaderFromFile_delegate>(s_gdipModule, \"GdipGetMetafileHeaderFromFile\", LibraryName);\n                GdipGetMetafileHeaderFromMetafile_ptr = FunctionWrapper.Load<GdipGetMetafileHeaderFromMetafile_delegate>(s_gdipModule, \"GdipGetMetafileHeaderFromMetafile\", LibraryName);\n                GdipGetMetafileHeaderFromEmf_ptr = FunctionWrapper.Load<GdipGetMetafileHeaderFromEmf_delegate>(s_gdipModule, \"GdipGetMetafileHeaderFromEmf\", LibraryName);\n                GdipGetMetafileHeaderFromWmf_ptr = FunctionWrapper.Load<GdipGetMetafileHeaderFromWmf_delegate>(s_gdipModule, \"GdipGetMetafileHeaderFromWmf\", LibraryName);\n                GdipGetHemfFromMetafile_ptr = FunctionWrapper.Load<GdipGetHemfFromMetafile_delegate>(s_gdipModule, \"GdipGetHemfFromMetafile\", LibraryName);\n                GdipGetMetafileDownLevelRasterizationLimit_ptr = FunctionWrapper.Load<GdipGetMetafileDownLevelRasterizationLimit_delegate>(s_gdipModule, \"GdipGetMetafileDownLevelRasterizationLimit\", LibraryName);\n                GdipSetMetafileDownLevelRasterizationLimit_ptr = FunctionWrapper.Load<GdipSetMetafileDownLevelRasterizationLimit_delegate>(s_gdipModule, \"GdipSetMetafileDownLevelRasterizationLimit\", LibraryName);\n                GdipPlayMetafileRecord_ptr = FunctionWrapper.Load<GdipPlayMetafileRecord_delegate>(s_gdipModule, \"GdipPlayMetafileRecord\", LibraryName);\n                GdipRecordMetafile_ptr = FunctionWrapper.Load<GdipRecordMetafile_delegate>(s_gdipModule, \"GdipRecordMetafile\", LibraryName);\n                GdipRecordMetafileI_ptr = FunctionWrapper.Load<GdipRecordMetafileI_delegate>(s_gdipModule, \"GdipRecordMetafileI\", LibraryName);\n                GdipRecordMetafileFileName_ptr = FunctionWrapper.Load<GdipRecordMetafileFileName_delegate>(s_gdipModule, \"GdipRecordMetafileFileName\", LibraryName);\n                GdipRecordMetafileFileNameI_ptr = FunctionWrapper.Load<GdipRecordMetafileFileNameI_delegate>(s_gdipModule, \"GdipRecordMetafileFileNameI\", LibraryName);\n                GdipCreateFromContext_macosx_ptr = FunctionWrapper.Load<GdipCreateFromContext_macosx_delegate>(s_gdipModule, \"GdipCreateFromContext_macosx\", LibraryName);\n                GdipSetVisibleClip_linux_ptr = FunctionWrapper.Load<GdipSetVisibleClip_linux_delegate>(s_gdipModule, \"GdipSetVisibleClip_linux\", LibraryName);\n                GdipCreateFromXDrawable_linux_ptr = FunctionWrapper.Load<GdipCreateFromXDrawable_linux_delegate>(s_gdipModule, \"GdipCreateFromXDrawable_linux\", LibraryName);\n                GdipLoadImageFromDelegate_linux_ptr = FunctionWrapper.Load<GdipLoadImageFromDelegate_linux_delegate>(s_gdipModule, \"GdipLoadImageFromDelegate_linux\", LibraryName);\n                GdipSaveImageToDelegate_linux_ptr = FunctionWrapper.Load<GdipSaveImageToDelegate_linux_delegate>(s_gdipModule, \"GdipSaveImageToDelegate_linux\", LibraryName);\n                GdipCreateMetafileFromDelegate_linux_ptr = FunctionWrapper.Load<GdipCreateMetafileFromDelegate_linux_delegate>(s_gdipModule, \"GdipCreateMetafileFromDelegate_linux\", LibraryName);\n                GdipGetMetafileHeaderFromDelegate_linux_ptr = FunctionWrapper.Load<GdipGetMetafileHeaderFromDelegate_linux_delegate>(s_gdipModule, \"GdipGetMetafileHeaderFromDelegate_linux\", LibraryName);\n                GdipRecordMetafileFromDelegate_linux_ptr = FunctionWrapper.Load<GdipRecordMetafileFromDelegate_linux_delegate>(s_gdipModule, \"GdipRecordMetafileFromDelegate_linux\", LibraryName);\n                GdipRecordMetafileFromDelegateI_linux_ptr = FunctionWrapper.Load<GdipRecordMetafileFromDelegateI_linux_delegate>(s_gdipModule, \"GdipRecordMetafileFromDelegateI_linux\", LibraryName);\n                GdipGetPostScriptSavePage_ptr = FunctionWrapper.Load<GdipGetPostScriptSavePage_delegate>(s_gdipModule, \"GdipGetPostScriptSavePage\", LibraryName);\n                GdipGetPostScriptGraphicsContext_ptr = FunctionWrapper.Load<GdipGetPostScriptGraphicsContext_delegate>(s_gdipModule, \"GdipGetPostScriptGraphicsContext\", LibraryName);\n            }\n\n            // Imported functions\n\n            private delegate int GdiplusStartup_delegate(out IntPtr token, ref StartupInput input, out StartupOutput output);\n            private static FunctionWrapper<GdiplusStartup_delegate> GdiplusStartup_ptr;\n            internal static int GdiplusStartup(out IntPtr token, ref StartupInput input, out StartupOutput output) => (int)GdiplusStartup_ptr.Delegate(out token, ref input, out output);\n\n            private delegate void GdiplusShutdown_delegate(ref ulong token);\n            private static FunctionWrapper<GdiplusShutdown_delegate> GdiplusShutdown_ptr;\n            internal static void GdiplusShutdown(ref ulong token) => GdiplusShutdown_ptr.Delegate(ref token);\n\n            private delegate IntPtr GdipAlloc_delegate(int size);\n            private static FunctionWrapper<GdipAlloc_delegate> GdipAlloc_ptr;\n            internal static IntPtr GdipAlloc(int size) => GdipAlloc_ptr.Delegate(size);\n\n            private delegate void GdipFree_delegate(IntPtr ptr);\n            private static FunctionWrapper<GdipFree_delegate> GdipFree_ptr;\n            internal static void GdipFree(IntPtr ptr) => GdipFree_ptr.Delegate(ptr);\n\n            private delegate int GdipDeleteBrush_delegate(IntPtr brush);\n            private static FunctionWrapper<GdipDeleteBrush_delegate> GdipDeleteBrush_ptr;\n            internal static int GdipDeleteBrush(IntPtr brush) => GdipDeleteBrush_ptr.Delegate(brush);\n            internal static int IntGdipDeleteBrush(HandleRef brush) => (int)GdipDeleteBrush_ptr.Delegate(brush.Handle);\n\n            private delegate int GdipGetBrushType_delegate(IntPtr brush, out BrushType type);\n            private static FunctionWrapper<GdipGetBrushType_delegate> GdipGetBrushType_ptr;\n            internal static int GdipGetBrushType(IntPtr brush, out BrushType type) => GdipGetBrushType_ptr.Delegate(brush, out type);\n\n            private delegate int GdipCreateFromHDC_delegate(IntPtr hDC, out IntPtr graphics);\n            private static FunctionWrapper<GdipCreateFromHDC_delegate> GdipCreateFromHDC_ptr;\n            internal static int GdipCreateFromHDC(IntPtr hDC, out IntPtr graphics) => GdipCreateFromHDC_ptr.Delegate(hDC, out graphics);\n\n            private delegate int GdipDeleteGraphics_delegate(IntPtr graphics);\n            private static FunctionWrapper<GdipDeleteGraphics_delegate> GdipDeleteGraphics_ptr;\n            internal static int GdipDeleteGraphics(IntPtr graphics) => GdipDeleteGraphics_ptr.Delegate(graphics);\n            internal static int IntGdipDeleteGraphics(HandleRef graphics) => (int)GdipDeleteGraphics_ptr.Delegate(graphics.Handle);\n\n            private delegate int GdipRestoreGraphics_delegate(IntPtr graphics, uint graphicsState);\n            private static FunctionWrapper<GdipRestoreGraphics_delegate> GdipRestoreGraphics_ptr;\n            internal static int GdipRestoreGraphics(IntPtr graphics, uint graphicsState) => GdipRestoreGraphics_ptr.Delegate(graphics, graphicsState);\n\n            private delegate int GdipSaveGraphics_delegate(IntPtr graphics, out uint state);\n            private static FunctionWrapper<GdipSaveGraphics_delegate> GdipSaveGraphics_ptr;\n            internal static int GdipSaveGraphics(IntPtr graphics, out uint state) => GdipSaveGraphics_ptr.Delegate(graphics, out state);\n\n            private delegate int GdipDrawArc_delegate(IntPtr graphics, IntPtr pen, float x, float y, float width, float height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipDrawArc_delegate> GdipDrawArc_ptr;\n            internal static int GdipDrawArc(IntPtr graphics, IntPtr pen, float x, float y, float width, float height, float startAngle, float sweepAngle) => GdipDrawArc_ptr.Delegate(graphics, pen, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipDrawArcI_delegate(IntPtr graphics, IntPtr pen, int x, int y, int width, int height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipDrawArcI_delegate> GdipDrawArcI_ptr;\n            internal static int GdipDrawArcI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height, float startAngle, float sweepAngle) => GdipDrawArcI_ptr.Delegate(graphics, pen, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipDrawBezier_delegate(IntPtr graphics, IntPtr pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);\n            private static FunctionWrapper<GdipDrawBezier_delegate> GdipDrawBezier_ptr;\n            internal static int GdipDrawBezier(IntPtr graphics, IntPtr pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4) => GdipDrawBezier_ptr.Delegate(graphics, pen, x1, y1, x2, y2, x3, y3, x4, y4);\n\n            private delegate int GdipDrawBezierI_delegate(IntPtr graphics, IntPtr pen, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);\n            private static FunctionWrapper<GdipDrawBezierI_delegate> GdipDrawBezierI_ptr;\n            internal static int GdipDrawBezierI(IntPtr graphics, IntPtr pen, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) => GdipDrawBezierI_ptr.Delegate(graphics, pen, x1, y1, x2, y2, x3, y3, x4, y4);\n\n            private delegate int GdipDrawEllipseI_delegate(IntPtr graphics, IntPtr pen, int x, int y, int width, int height);\n            private static FunctionWrapper<GdipDrawEllipseI_delegate> GdipDrawEllipseI_ptr;\n            internal static int GdipDrawEllipseI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height) => GdipDrawEllipseI_ptr.Delegate(graphics, pen, x, y, width, height);\n\n            private delegate int GdipDrawEllipse_delegate(IntPtr graphics, IntPtr pen, float x, float y, float width, float height);\n            private static FunctionWrapper<GdipDrawEllipse_delegate> GdipDrawEllipse_ptr;\n            internal static int GdipDrawEllipse(IntPtr graphics, IntPtr pen, float x, float y, float width, float height) => GdipDrawEllipse_ptr.Delegate(graphics, pen, x, y, width, height);\n\n            private delegate int GdipDrawLine_delegate(IntPtr graphics, IntPtr pen, float x1, float y1, float x2, float y2);\n            private static FunctionWrapper<GdipDrawLine_delegate> GdipDrawLine_ptr;\n            internal static int GdipDrawLine(IntPtr graphics, IntPtr pen, float x1, float y1, float x2, float y2) => GdipDrawLine_ptr.Delegate(graphics, pen, x1, y1, x2, y2);\n\n            private delegate int GdipDrawLineI_delegate(IntPtr graphics, IntPtr pen, int x1, int y1, int x2, int y2);\n            private static FunctionWrapper<GdipDrawLineI_delegate> GdipDrawLineI_ptr;\n            internal static int GdipDrawLineI(IntPtr graphics, IntPtr pen, int x1, int y1, int x2, int y2) => GdipDrawLineI_ptr.Delegate(graphics, pen, x1, y1, x2, y2);\n\n            private delegate int GdipDrawLines_delegate(IntPtr graphics, IntPtr pen, PointF[] points, int count);\n            private static FunctionWrapper<GdipDrawLines_delegate> GdipDrawLines_ptr;\n            internal static int GdipDrawLines(IntPtr graphics, IntPtr pen, PointF[] points, int count) => GdipDrawLines_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawLinesI_delegate(IntPtr graphics, IntPtr pen, Point[] points, int count);\n            private static FunctionWrapper<GdipDrawLinesI_delegate> GdipDrawLinesI_ptr;\n            internal static int GdipDrawLinesI(IntPtr graphics, IntPtr pen, Point[] points, int count) => GdipDrawLinesI_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawPath_delegate(IntPtr graphics, IntPtr pen, IntPtr path);\n            private static FunctionWrapper<GdipDrawPath_delegate> GdipDrawPath_ptr;\n            internal static int GdipDrawPath(IntPtr graphics, IntPtr pen, IntPtr path) => GdipDrawPath_ptr.Delegate(graphics, pen, path);\n\n            private delegate int GdipDrawPie_delegate(IntPtr graphics, IntPtr pen, float x, float y, float width, float height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipDrawPie_delegate> GdipDrawPie_ptr;\n            internal static int GdipDrawPie(IntPtr graphics, IntPtr pen, float x, float y, float width, float height, float startAngle, float sweepAngle) => GdipDrawPie_ptr.Delegate(graphics, pen, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipDrawPieI_delegate(IntPtr graphics, IntPtr pen, int x, int y, int width, int height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipDrawPieI_delegate> GdipDrawPieI_ptr;\n            internal static int GdipDrawPieI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height, float startAngle, float sweepAngle) => GdipDrawPieI_ptr.Delegate(graphics, pen, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipDrawPolygon_delegate(IntPtr graphics, IntPtr pen, PointF[] points, int count);\n            private static FunctionWrapper<GdipDrawPolygon_delegate> GdipDrawPolygon_ptr;\n            internal static int GdipDrawPolygon(IntPtr graphics, IntPtr pen, PointF[] points, int count) => GdipDrawPolygon_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawPolygonI_delegate(IntPtr graphics, IntPtr pen, Point[] points, int count);\n            private static FunctionWrapper<GdipDrawPolygonI_delegate> GdipDrawPolygonI_ptr;\n            internal static int GdipDrawPolygonI(IntPtr graphics, IntPtr pen, Point[] points, int count) => GdipDrawPolygonI_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawRectangle_delegate(IntPtr graphics, IntPtr pen, float x, float y, float width, float height);\n            private static FunctionWrapper<GdipDrawRectangle_delegate> GdipDrawRectangle_ptr;\n            internal static int GdipDrawRectangle(IntPtr graphics, IntPtr pen, float x, float y, float width, float height) => GdipDrawRectangle_ptr.Delegate(graphics, pen, x, y, width, height);\n\n            private delegate int GdipDrawRectangleI_delegate(IntPtr graphics, IntPtr pen, int x, int y, int width, int height);\n            private static FunctionWrapper<GdipDrawRectangleI_delegate> GdipDrawRectangleI_ptr;\n            internal static int GdipDrawRectangleI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height) => GdipDrawRectangleI_ptr.Delegate(graphics, pen, x, y, width, height);\n\n            private delegate int GdipDrawRectangles_delegate(IntPtr graphics, IntPtr pen, RectangleF[] rects, int count);\n            private static FunctionWrapper<GdipDrawRectangles_delegate> GdipDrawRectangles_ptr;\n            internal static int GdipDrawRectangles(IntPtr graphics, IntPtr pen, RectangleF[] rects, int count) => GdipDrawRectangles_ptr.Delegate(graphics, pen, rects, count);\n\n            private delegate int GdipDrawRectanglesI_delegate(IntPtr graphics, IntPtr pen, Rectangle[] rects, int count);\n            private static FunctionWrapper<GdipDrawRectanglesI_delegate> GdipDrawRectanglesI_ptr;\n            internal static int GdipDrawRectanglesI(IntPtr graphics, IntPtr pen, Rectangle[] rects, int count) => GdipDrawRectanglesI_ptr.Delegate(graphics, pen, rects, count);\n\n            private delegate int GdipFillEllipseI_delegate(IntPtr graphics, IntPtr pen, int x, int y, int width, int height);\n            private static FunctionWrapper<GdipFillEllipseI_delegate> GdipFillEllipseI_ptr;\n            internal static int GdipFillEllipseI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height) => GdipFillEllipseI_ptr.Delegate(graphics, pen, x, y, width, height);\n\n            private delegate int GdipFillEllipse_delegate(IntPtr graphics, IntPtr pen, float x, float y, float width, float height);\n            private static FunctionWrapper<GdipFillEllipse_delegate> GdipFillEllipse_ptr;\n            internal static int GdipFillEllipse(IntPtr graphics, IntPtr pen, float x, float y, float width, float height) => GdipFillEllipse_ptr.Delegate(graphics, pen, x, y, width, height);\n\n            private delegate int GdipFillPolygon_delegate(IntPtr graphics, IntPtr brush, PointF[] points, int count, FillMode fillMode);\n            private static FunctionWrapper<GdipFillPolygon_delegate> GdipFillPolygon_ptr;\n            internal static int GdipFillPolygon(IntPtr graphics, IntPtr brush, PointF[] points, int count, FillMode fillMode) => GdipFillPolygon_ptr.Delegate(graphics, brush, points, count, fillMode);\n\n            private delegate int GdipFillPolygonI_delegate(IntPtr graphics, IntPtr brush, Point[] points, int count, FillMode fillMode);\n            private static FunctionWrapper<GdipFillPolygonI_delegate> GdipFillPolygonI_ptr;\n            internal static int GdipFillPolygonI(IntPtr graphics, IntPtr brush, Point[] points, int count, FillMode fillMode) => GdipFillPolygonI_ptr.Delegate(graphics, brush, points, count, fillMode);\n\n            private delegate int GdipFillPolygon2_delegate(IntPtr graphics, IntPtr brush, PointF[] points, int count);\n            private static FunctionWrapper<GdipFillPolygon2_delegate> GdipFillPolygon2_ptr;\n            internal static int GdipFillPolygon2(IntPtr graphics, IntPtr brush, PointF[] points, int count) => GdipFillPolygon2_ptr.Delegate(graphics, brush, points, count);\n\n            private delegate int GdipFillPolygon2I_delegate(IntPtr graphics, IntPtr brush, Point[] points, int count);\n            private static FunctionWrapper<GdipFillPolygon2I_delegate> GdipFillPolygon2I_ptr;\n            internal static int GdipFillPolygon2I(IntPtr graphics, IntPtr brush, Point[] points, int count) => GdipFillPolygon2I_ptr.Delegate(graphics, brush, points, count);\n\n            private delegate int GdipFillRectangle_delegate(IntPtr graphics, IntPtr brush, float x1, float y1, float x2, float y2);\n            private static FunctionWrapper<GdipFillRectangle_delegate> GdipFillRectangle_ptr;\n            internal static int GdipFillRectangle(IntPtr graphics, IntPtr brush, float x1, float y1, float x2, float y2) => GdipFillRectangle_ptr.Delegate(graphics, brush, x1, y1, x2, y2);\n\n            private delegate int GdipFillRectangleI_delegate(IntPtr graphics, IntPtr brush, int x1, int y1, int x2, int y2);\n            private static FunctionWrapper<GdipFillRectangleI_delegate> GdipFillRectangleI_ptr;\n            internal static int GdipFillRectangleI(IntPtr graphics, IntPtr brush, int x1, int y1, int x2, int y2) => GdipFillRectangleI_ptr.Delegate(graphics, brush, x1, y1, x2, y2);\n\n            private delegate int GdipFillRectangles_delegate(IntPtr graphics, IntPtr brush, RectangleF[] rects, int count);\n            private static FunctionWrapper<GdipFillRectangles_delegate> GdipFillRectangles_ptr;\n            internal static int GdipFillRectangles(IntPtr graphics, IntPtr brush, RectangleF[] rects, int count) => GdipFillRectangles_ptr.Delegate(graphics, brush, rects, count);\n\n            private delegate int GdipFillRectanglesI_delegate(IntPtr graphics, IntPtr brush, Rectangle[] rects, int count);\n            private static FunctionWrapper<GdipFillRectanglesI_delegate> GdipFillRectanglesI_ptr;\n            internal static int GdipFillRectanglesI(IntPtr graphics, IntPtr brush, Rectangle[] rects, int count) => GdipFillRectanglesI_ptr.Delegate(graphics, brush, rects, count);\n\n            private delegate int GdipDrawString_delegate(IntPtr graphics, [MarshalAs(UnmanagedType.LPWStr)]string text, int len, IntPtr font, ref RectangleF rc, IntPtr format, IntPtr brush);\n            private static FunctionWrapper<GdipDrawString_delegate> GdipDrawString_ptr;\n            internal static int GdipDrawString(IntPtr graphics, string text, int len, IntPtr font, ref RectangleF rc, IntPtr format, IntPtr brush) => GdipDrawString_ptr.Delegate(graphics, text, len, font, ref rc, format, brush);\n\n            private delegate int GdipGetDC_delegate(IntPtr graphics, out IntPtr hdc);\n            private static FunctionWrapper<GdipGetDC_delegate> GdipGetDC_ptr;\n            internal static int GdipGetDC(IntPtr graphics, out IntPtr hdc) => GdipGetDC_ptr.Delegate(graphics, out hdc);\n\n            private delegate int GdipReleaseDC_delegate(IntPtr graphics, IntPtr hdc);\n            private static FunctionWrapper<GdipReleaseDC_delegate> GdipReleaseDC_ptr;\n            internal static int GdipReleaseDC(IntPtr graphics, IntPtr hdc) => GdipReleaseDC_ptr.Delegate(graphics, hdc);\n            internal static int IntGdipReleaseDC(HandleRef graphics, HandleRef hdc) => (int)GdipReleaseDC_ptr.Delegate(graphics.Handle, hdc.Handle);\n\n            private delegate int GdipDrawImageRectI_delegate(IntPtr graphics, IntPtr image, int x, int y, int width, int height);\n            private static FunctionWrapper<GdipDrawImageRectI_delegate> GdipDrawImageRectI_ptr;\n            internal static int GdipDrawImageRectI(IntPtr graphics, IntPtr image, int x, int y, int width, int height) => GdipDrawImageRectI_ptr.Delegate(graphics, image, x, y, width, height);\n\n            private delegate int GdipGetRenderingOrigin_delegate(IntPtr graphics, out int x, out int y);\n            private static FunctionWrapper<GdipGetRenderingOrigin_delegate> GdipGetRenderingOrigin_ptr;\n            internal static int GdipGetRenderingOrigin(IntPtr graphics, out int x, out int y) => GdipGetRenderingOrigin_ptr.Delegate(graphics, out x, out y);\n\n            private delegate int GdipSetRenderingOrigin_delegate(IntPtr graphics, int x, int y);\n            private static FunctionWrapper<GdipSetRenderingOrigin_delegate> GdipSetRenderingOrigin_ptr;\n            internal static int GdipSetRenderingOrigin(IntPtr graphics, int x, int y) => GdipSetRenderingOrigin_ptr.Delegate(graphics, x, y);\n\n            private delegate int GdipGraphicsClear_delegate(IntPtr graphics, int argb);\n            private static FunctionWrapper<GdipGraphicsClear_delegate> GdipGraphicsClear_ptr;\n            internal static int GdipGraphicsClear(IntPtr graphics, int argb) => GdipGraphicsClear_ptr.Delegate(graphics, argb);\n\n            private delegate int GdipDrawClosedCurve_delegate(IntPtr graphics, IntPtr pen, PointF[] points, int count);\n            private static FunctionWrapper<GdipDrawClosedCurve_delegate> GdipDrawClosedCurve_ptr;\n            internal static int GdipDrawClosedCurve(IntPtr graphics, IntPtr pen, PointF[] points, int count) => GdipDrawClosedCurve_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawClosedCurveI_delegate(IntPtr graphics, IntPtr pen, Point[] points, int count);\n            private static FunctionWrapper<GdipDrawClosedCurveI_delegate> GdipDrawClosedCurveI_ptr;\n            internal static int GdipDrawClosedCurveI(IntPtr graphics, IntPtr pen, Point[] points, int count) => GdipDrawClosedCurveI_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawClosedCurve2_delegate(IntPtr graphics, IntPtr pen, PointF[] points, int count, float tension);\n            private static FunctionWrapper<GdipDrawClosedCurve2_delegate> GdipDrawClosedCurve2_ptr;\n            internal static int GdipDrawClosedCurve2(IntPtr graphics, IntPtr pen, PointF[] points, int count, float tension) => GdipDrawClosedCurve2_ptr.Delegate(graphics, pen, points, count, tension);\n\n            private delegate int GdipDrawClosedCurve2I_delegate(IntPtr graphics, IntPtr pen, Point[] points, int count, float tension);\n            private static FunctionWrapper<GdipDrawClosedCurve2I_delegate> GdipDrawClosedCurve2I_ptr;\n            internal static int GdipDrawClosedCurve2I(IntPtr graphics, IntPtr pen, Point[] points, int count, float tension) => GdipDrawClosedCurve2I_ptr.Delegate(graphics, pen, points, count, tension);\n\n            private delegate int GdipDrawCurve_delegate(IntPtr graphics, IntPtr pen, PointF[] points, int count);\n            private static FunctionWrapper<GdipDrawCurve_delegate> GdipDrawCurve_ptr;\n            internal static int GdipDrawCurve(IntPtr graphics, IntPtr pen, PointF[] points, int count) => GdipDrawCurve_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawCurveI_delegate(IntPtr graphics, IntPtr pen, Point[] points, int count);\n            private static FunctionWrapper<GdipDrawCurveI_delegate> GdipDrawCurveI_ptr;\n            internal static int GdipDrawCurveI(IntPtr graphics, IntPtr pen, Point[] points, int count) => GdipDrawCurveI_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawCurve2_delegate(IntPtr graphics, IntPtr pen, PointF[] points, int count, float tension);\n            private static FunctionWrapper<GdipDrawCurve2_delegate> GdipDrawCurve2_ptr;\n            internal static int GdipDrawCurve2(IntPtr graphics, IntPtr pen, PointF[] points, int count, float tension) => GdipDrawCurve2_ptr.Delegate(graphics, pen, points, count, tension);\n\n            private delegate int GdipDrawCurve2I_delegate(IntPtr graphics, IntPtr pen, Point[] points, int count, float tension);\n            private static FunctionWrapper<GdipDrawCurve2I_delegate> GdipDrawCurve2I_ptr;\n            internal static int GdipDrawCurve2I(IntPtr graphics, IntPtr pen, Point[] points, int count, float tension) => GdipDrawCurve2I_ptr.Delegate(graphics, pen, points, count, tension);\n\n            private delegate int GdipDrawCurve3_delegate(IntPtr graphics, IntPtr pen, PointF[] points, int count, int offset, int numberOfSegments, float tension);\n            private static FunctionWrapper<GdipDrawCurve3_delegate> GdipDrawCurve3_ptr;\n            internal static int GdipDrawCurve3(IntPtr graphics, IntPtr pen, PointF[] points, int count, int offset, int numberOfSegments, float tension) => GdipDrawCurve3_ptr.Delegate(graphics, pen, points, count, offset, numberOfSegments, tension);\n\n            private delegate int GdipDrawCurve3I_delegate(IntPtr graphics, IntPtr pen, Point[] points, int count, int offset, int numberOfSegments, float tension);\n            private static FunctionWrapper<GdipDrawCurve3I_delegate> GdipDrawCurve3I_ptr;\n            internal static int GdipDrawCurve3I(IntPtr graphics, IntPtr pen, Point[] points, int count, int offset, int numberOfSegments, float tension) => GdipDrawCurve3I_ptr.Delegate(graphics, pen, points, count, offset, numberOfSegments, tension);\n\n            private delegate int GdipFillClosedCurve_delegate(IntPtr graphics, IntPtr brush, PointF[] points, int count);\n            private static FunctionWrapper<GdipFillClosedCurve_delegate> GdipFillClosedCurve_ptr;\n            internal static int GdipFillClosedCurve(IntPtr graphics, IntPtr brush, PointF[] points, int count) => GdipFillClosedCurve_ptr.Delegate(graphics, brush, points, count);\n\n            private delegate int GdipFillClosedCurveI_delegate(IntPtr graphics, IntPtr brush, Point[] points, int count);\n            private static FunctionWrapper<GdipFillClosedCurveI_delegate> GdipFillClosedCurveI_ptr;\n            internal static int GdipFillClosedCurveI(IntPtr graphics, IntPtr brush, Point[] points, int count) => GdipFillClosedCurveI_ptr.Delegate(graphics, brush, points, count);\n\n            private delegate int GdipFillClosedCurve2_delegate(IntPtr graphics, IntPtr brush, PointF[] points, int count, float tension, FillMode fillMode);\n            private static FunctionWrapper<GdipFillClosedCurve2_delegate> GdipFillClosedCurve2_ptr;\n            internal static int GdipFillClosedCurve2(IntPtr graphics, IntPtr brush, PointF[] points, int count, float tension, FillMode fillMode) => GdipFillClosedCurve2_ptr.Delegate(graphics, brush, points, count, tension, fillMode);\n\n            private delegate int GdipFillClosedCurve2I_delegate(IntPtr graphics, IntPtr brush, Point[] points, int count, float tension, FillMode fillMode);\n            private static FunctionWrapper<GdipFillClosedCurve2I_delegate> GdipFillClosedCurve2I_ptr;\n            internal static int GdipFillClosedCurve2I(IntPtr graphics, IntPtr brush, Point[] points, int count, float tension, FillMode fillMode) => GdipFillClosedCurve2I_ptr.Delegate(graphics, brush, points, count, tension, fillMode);\n\n            private delegate int GdipFillPie_delegate(IntPtr graphics, IntPtr brush, float x, float y, float width, float height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipFillPie_delegate> GdipFillPie_ptr;\n            internal static int GdipFillPie(IntPtr graphics, IntPtr brush, float x, float y, float width, float height, float startAngle, float sweepAngle) => GdipFillPie_ptr.Delegate(graphics, brush, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipFillPieI_delegate(IntPtr graphics, IntPtr brush, int x, int y, int width, int height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipFillPieI_delegate> GdipFillPieI_ptr;\n            internal static int GdipFillPieI(IntPtr graphics, IntPtr brush, int x, int y, int width, int height, float startAngle, float sweepAngle) => GdipFillPieI_ptr.Delegate(graphics, brush, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipFillPath_delegate(IntPtr graphics, IntPtr brush, IntPtr path);\n            private static FunctionWrapper<GdipFillPath_delegate> GdipFillPath_ptr;\n            internal static int GdipFillPath(IntPtr graphics, IntPtr brush, IntPtr path) => GdipFillPath_ptr.Delegate(graphics, brush, path);\n\n            private delegate int GdipGetNearestColor_delegate(IntPtr graphics, out int argb);\n            private static FunctionWrapper<GdipGetNearestColor_delegate> GdipGetNearestColor_ptr;\n            internal static int GdipGetNearestColor(IntPtr graphics, out int argb) => GdipGetNearestColor_ptr.Delegate(graphics, out argb);\n\n            private delegate int GdipTransformPoints_delegate(IntPtr graphics, CoordinateSpace destSpace, CoordinateSpace srcSpace, IntPtr points, int count);\n            private static FunctionWrapper<GdipTransformPoints_delegate> GdipTransformPoints_ptr;\n            internal static int GdipTransformPoints(IntPtr graphics, CoordinateSpace destSpace, CoordinateSpace srcSpace, IntPtr points, int count) => GdipTransformPoints_ptr.Delegate(graphics, destSpace, srcSpace, points, count);\n\n            private delegate int GdipTransformPointsI_delegate(IntPtr graphics, CoordinateSpace destSpace, CoordinateSpace srcSpace, IntPtr points, int count);\n            private static FunctionWrapper<GdipTransformPointsI_delegate> GdipTransformPointsI_ptr;\n            internal static int GdipTransformPointsI(IntPtr graphics, CoordinateSpace destSpace, CoordinateSpace srcSpace, IntPtr points, int count) => GdipTransformPointsI_ptr.Delegate(graphics, destSpace, srcSpace, points, count);\n\n            private delegate int GdipSetCompositingMode_delegate(IntPtr graphics, CompositingMode compositingMode);\n            private static FunctionWrapper<GdipSetCompositingMode_delegate> GdipSetCompositingMode_ptr;\n            internal static int GdipSetCompositingMode(IntPtr graphics, CompositingMode compositingMode) => GdipSetCompositingMode_ptr.Delegate(graphics, compositingMode);\n\n            private delegate int GdipGetCompositingMode_delegate(IntPtr graphics, out CompositingMode compositingMode);\n            private static FunctionWrapper<GdipGetCompositingMode_delegate> GdipGetCompositingMode_ptr;\n            internal static int GdipGetCompositingMode(IntPtr graphics, out CompositingMode compositingMode) => GdipGetCompositingMode_ptr.Delegate(graphics, out compositingMode);\n\n            private delegate int GdipSetCompositingQuality_delegate(IntPtr graphics, CompositingQuality compositingQuality);\n            private static FunctionWrapper<GdipSetCompositingQuality_delegate> GdipSetCompositingQuality_ptr;\n            internal static int GdipSetCompositingQuality(IntPtr graphics, CompositingQuality compositingQuality) => GdipSetCompositingQuality_ptr.Delegate(graphics, compositingQuality);\n\n            private delegate int GdipGetCompositingQuality_delegate(IntPtr graphics, out CompositingQuality compositingQuality);\n            private static FunctionWrapper<GdipGetCompositingQuality_delegate> GdipGetCompositingQuality_ptr;\n            internal static int GdipGetCompositingQuality(IntPtr graphics, out CompositingQuality compositingQuality) => GdipGetCompositingQuality_ptr.Delegate(graphics, out compositingQuality);\n\n            private delegate int GdipSetInterpolationMode_delegate(IntPtr graphics, InterpolationMode interpolationMode);\n            private static FunctionWrapper<GdipSetInterpolationMode_delegate> GdipSetInterpolationMode_ptr;\n            internal static int GdipSetInterpolationMode(IntPtr graphics, InterpolationMode interpolationMode) => GdipSetInterpolationMode_ptr.Delegate(graphics, interpolationMode);\n\n            private delegate int GdipGetInterpolationMode_delegate(IntPtr graphics, out InterpolationMode interpolationMode);\n            private static FunctionWrapper<GdipGetInterpolationMode_delegate> GdipGetInterpolationMode_ptr;\n            internal static int GdipGetInterpolationMode(IntPtr graphics, out InterpolationMode interpolationMode) => GdipGetInterpolationMode_ptr.Delegate(graphics, out interpolationMode);\n\n            private delegate int GdipGetDpiX_delegate(IntPtr graphics, out float dpi);\n            private static FunctionWrapper<GdipGetDpiX_delegate> GdipGetDpiX_ptr;\n            internal static int GdipGetDpiX(IntPtr graphics, out float dpi) => GdipGetDpiX_ptr.Delegate(graphics, out dpi);\n\n            private delegate int GdipGetDpiY_delegate(IntPtr graphics, out float dpi);\n            private static FunctionWrapper<GdipGetDpiY_delegate> GdipGetDpiY_ptr;\n            internal static int GdipGetDpiY(IntPtr graphics, out float dpi) => GdipGetDpiY_ptr.Delegate(graphics, out dpi);\n\n            private delegate int GdipGetPageUnit_delegate(IntPtr graphics, out GraphicsUnit unit);\n            private static FunctionWrapper<GdipGetPageUnit_delegate> GdipGetPageUnit_ptr;\n            internal static int GdipGetPageUnit(IntPtr graphics, out GraphicsUnit unit) => GdipGetPageUnit_ptr.Delegate(graphics, out unit);\n\n            private delegate int GdipGetPageScale_delegate(IntPtr graphics, out float scale);\n            private static FunctionWrapper<GdipGetPageScale_delegate> GdipGetPageScale_ptr;\n            internal static int GdipGetPageScale(IntPtr graphics, out float scale) => GdipGetPageScale_ptr.Delegate(graphics, out scale);\n\n            private delegate int GdipSetPageUnit_delegate(IntPtr graphics, GraphicsUnit unit);\n            private static FunctionWrapper<GdipSetPageUnit_delegate> GdipSetPageUnit_ptr;\n            internal static int GdipSetPageUnit(IntPtr graphics, GraphicsUnit unit) => GdipSetPageUnit_ptr.Delegate(graphics, unit);\n\n            private delegate int GdipSetPageScale_delegate(IntPtr graphics, float scale);\n            private static FunctionWrapper<GdipSetPageScale_delegate> GdipSetPageScale_ptr;\n            internal static int GdipSetPageScale(IntPtr graphics, float scale) => GdipSetPageScale_ptr.Delegate(graphics, scale);\n\n            private delegate int GdipSetPixelOffsetMode_delegate(IntPtr graphics, PixelOffsetMode pixelOffsetMode);\n            private static FunctionWrapper<GdipSetPixelOffsetMode_delegate> GdipSetPixelOffsetMode_ptr;\n            internal static int GdipSetPixelOffsetMode(IntPtr graphics, PixelOffsetMode pixelOffsetMode) => GdipSetPixelOffsetMode_ptr.Delegate(graphics, pixelOffsetMode);\n\n            private delegate int GdipGetPixelOffsetMode_delegate(IntPtr graphics, out PixelOffsetMode pixelOffsetMode);\n            private static FunctionWrapper<GdipGetPixelOffsetMode_delegate> GdipGetPixelOffsetMode_ptr;\n            internal static int GdipGetPixelOffsetMode(IntPtr graphics, out PixelOffsetMode pixelOffsetMode) => GdipGetPixelOffsetMode_ptr.Delegate(graphics, out pixelOffsetMode);\n\n            private delegate int GdipSetSmoothingMode_delegate(IntPtr graphics, SmoothingMode smoothingMode);\n            private static FunctionWrapper<GdipSetSmoothingMode_delegate> GdipSetSmoothingMode_ptr;\n            internal static int GdipSetSmoothingMode(IntPtr graphics, SmoothingMode smoothingMode) => GdipSetSmoothingMode_ptr.Delegate(graphics, smoothingMode);\n\n            private delegate int GdipGetSmoothingMode_delegate(IntPtr graphics, out SmoothingMode smoothingMode);\n            private static FunctionWrapper<GdipGetSmoothingMode_delegate> GdipGetSmoothingMode_ptr;\n            internal static int GdipGetSmoothingMode(IntPtr graphics, out SmoothingMode smoothingMode) => GdipGetSmoothingMode_ptr.Delegate(graphics, out smoothingMode);\n\n            private delegate int GdipSetTextContrast_delegate(IntPtr graphics, int contrast);\n            private static FunctionWrapper<GdipSetTextContrast_delegate> GdipSetTextContrast_ptr;\n            internal static int GdipSetTextContrast(IntPtr graphics, int contrast) => GdipSetTextContrast_ptr.Delegate(graphics, contrast);\n\n            private delegate int GdipGetTextContrast_delegate(IntPtr graphics, out int contrast);\n            private static FunctionWrapper<GdipGetTextContrast_delegate> GdipGetTextContrast_ptr;\n            internal static int GdipGetTextContrast(IntPtr graphics, out int contrast) => GdipGetTextContrast_ptr.Delegate(graphics, out contrast);\n\n            private delegate int GdipSetTextRenderingHint_delegate(IntPtr graphics, TextRenderingHint mode);\n            private static FunctionWrapper<GdipSetTextRenderingHint_delegate> GdipSetTextRenderingHint_ptr;\n            internal static int GdipSetTextRenderingHint(IntPtr graphics, TextRenderingHint mode) => GdipSetTextRenderingHint_ptr.Delegate(graphics, mode);\n\n            private delegate int GdipGetTextRenderingHint_delegate(IntPtr graphics, out TextRenderingHint mode);\n            private static FunctionWrapper<GdipGetTextRenderingHint_delegate> GdipGetTextRenderingHint_ptr;\n            internal static int GdipGetTextRenderingHint(IntPtr graphics, out TextRenderingHint mode) => GdipGetTextRenderingHint_ptr.Delegate(graphics, out mode);\n\n            private delegate int GdipFlush_delegate(IntPtr graphics, FlushIntention intention);\n            private static FunctionWrapper<GdipFlush_delegate> GdipFlush_ptr;\n            internal static int GdipFlush(IntPtr graphics, FlushIntention intention) => GdipFlush_ptr.Delegate(graphics, intention);\n\n            private delegate int GdipAddPathString_delegate(IntPtr path, [MarshalAs(UnmanagedType.LPWStr)]string s, int lenght, IntPtr family, int style, float emSize, ref RectangleF layoutRect, IntPtr format);\n            private static FunctionWrapper<GdipAddPathString_delegate> GdipAddPathString_ptr;\n            internal static int GdipAddPathString(IntPtr path, string s, int lenght, IntPtr family, int style, float emSize, ref RectangleF layoutRect, IntPtr format) => GdipAddPathString_ptr.Delegate(path, s, lenght, family, style, emSize, ref layoutRect, format);\n\n            private delegate int GdipAddPathStringI_delegate(IntPtr path, [MarshalAs(UnmanagedType.LPWStr)]string s, int lenght, IntPtr family, int style, float emSize, ref Rectangle layoutRect, IntPtr format);\n            private static FunctionWrapper<GdipAddPathStringI_delegate> GdipAddPathStringI_ptr;\n            internal static int GdipAddPathStringI(IntPtr path, string s, int lenght, IntPtr family, int style, float emSize, ref Rectangle layoutRect, IntPtr format) => GdipAddPathStringI_ptr.Delegate(path, s, lenght, family, style, emSize, ref layoutRect, format);\n\n            private delegate int GdipCreateFromHWND_delegate(IntPtr hwnd, out IntPtr graphics);\n            private static FunctionWrapper<GdipCreateFromHWND_delegate> GdipCreateFromHWND_ptr;\n            internal static int GdipCreateFromHWND(IntPtr hwnd, out IntPtr graphics) => GdipCreateFromHWND_ptr.Delegate(hwnd, out graphics);\n\n            private delegate int GdipMeasureString_delegate(IntPtr graphics, [MarshalAs(UnmanagedType.LPWStr)]string str, int length, IntPtr font, ref RectangleF layoutRect, IntPtr stringFormat, out RectangleF boundingBox, int* codepointsFitted, int* linesFilled);\n            private static FunctionWrapper<GdipMeasureString_delegate> GdipMeasureString_ptr;\n            internal static int GdipMeasureString(IntPtr graphics, string str, int length, IntPtr font, ref RectangleF layoutRect, IntPtr stringFormat, out RectangleF boundingBox, int* codepointsFitted, int* linesFilled) => GdipMeasureString_ptr.Delegate(graphics, str, length, font, ref layoutRect, stringFormat, out boundingBox, codepointsFitted, linesFilled);\n\n            private delegate int GdipMeasureCharacterRanges_delegate(IntPtr graphics, [MarshalAs(UnmanagedType.LPWStr)]string str, int length, IntPtr font, ref RectangleF layoutRect, IntPtr stringFormat, int regcount, out IntPtr regions);\n            private static FunctionWrapper<GdipMeasureCharacterRanges_delegate> GdipMeasureCharacterRanges_ptr;\n            internal static int GdipMeasureCharacterRanges(IntPtr graphics, string str, int length, IntPtr font, ref RectangleF layoutRect, IntPtr stringFormat, int regcount, out IntPtr regions) => GdipMeasureCharacterRanges_ptr.Delegate(graphics, str, length, font, ref layoutRect, stringFormat, regcount, out regions);\n\n            private delegate int GdipLoadImageFromFile_delegate([MarshalAs(UnmanagedType.LPWStr)]string filename, out IntPtr image);\n            private static FunctionWrapper<GdipLoadImageFromFile_delegate> GdipLoadImageFromFile_ptr;\n            internal static int GdipLoadImageFromFile(string filename, out IntPtr image) => GdipLoadImageFromFile_ptr.Delegate(filename, out image);\n\n            private delegate int GdipCloneImage_delegate(IntPtr image, out IntPtr imageclone);\n            private static FunctionWrapper<GdipCloneImage_delegate> GdipCloneImage_ptr;\n            internal static int GdipCloneImage(IntPtr image, out IntPtr imageclone) => GdipCloneImage_ptr.Delegate(image, out imageclone);\n\n            private delegate int GdipLoadImageFromFileICM_delegate([MarshalAs(UnmanagedType.LPWStr)]string filename, out IntPtr image);\n            private static FunctionWrapper<GdipLoadImageFromFileICM_delegate> GdipLoadImageFromFileICM_ptr;\n            internal static int GdipLoadImageFromFileICM(string filename, out IntPtr image) => GdipLoadImageFromFileICM_ptr.Delegate(filename, out image);\n\n            private delegate int GdipDisposeImage_delegate(IntPtr image);\n            private static FunctionWrapper<GdipDisposeImage_delegate> GdipDisposeImage_ptr;\n            internal static int GdipDisposeImage(IntPtr image) => GdipDisposeImage_ptr.Delegate(image);\n            internal static int IntGdipDisposeImage(HandleRef image) => (int)GdipDisposeImage_ptr.Delegate(image.Handle);\n\n            private delegate int GdipGetImageFlags_delegate(IntPtr image, out int flag);\n            private static FunctionWrapper<GdipGetImageFlags_delegate> GdipGetImageFlags_ptr;\n            internal static int GdipGetImageFlags(IntPtr image, out int flag) => GdipGetImageFlags_ptr.Delegate(image, out flag);\n\n            private delegate int GdipGetImageType_delegate(IntPtr image, out ImageType type);\n            private static FunctionWrapper<GdipGetImageType_delegate> GdipGetImageType_ptr;\n            internal static int GdipGetImageType(IntPtr image, out ImageType type) => GdipGetImageType_ptr.Delegate(image, out type);\n\n            private delegate int GdipImageGetFrameDimensionsCount_delegate(IntPtr image, out uint count);\n            private static FunctionWrapper<GdipImageGetFrameDimensionsCount_delegate> GdipImageGetFrameDimensionsCount_ptr;\n            internal static int GdipImageGetFrameDimensionsCount(IntPtr image, out uint count) => GdipImageGetFrameDimensionsCount_ptr.Delegate(image, out count);\n\n            private delegate int GdipImageGetFrameDimensionsList_delegate(IntPtr image, [Out] Guid[] dimensionIDs, uint count);\n            private static FunctionWrapper<GdipImageGetFrameDimensionsList_delegate> GdipImageGetFrameDimensionsList_ptr;\n            internal static int GdipImageGetFrameDimensionsList(IntPtr image, [Out] Guid[] dimensionIDs, uint count) => GdipImageGetFrameDimensionsList_ptr.Delegate(image, dimensionIDs, count);\n\n            private delegate int GdipGetImageHeight_delegate(IntPtr image, out uint height);\n            private static FunctionWrapper<GdipGetImageHeight_delegate> GdipGetImageHeight_ptr;\n            internal static int GdipGetImageHeight(IntPtr image, out uint height) => GdipGetImageHeight_ptr.Delegate(image, out height);\n\n            private delegate int GdipGetImageHorizontalResolution_delegate(IntPtr image, out float resolution);\n            private static FunctionWrapper<GdipGetImageHorizontalResolution_delegate> GdipGetImageHorizontalResolution_ptr;\n            internal static int GdipGetImageHorizontalResolution(IntPtr image, out float resolution) => GdipGetImageHorizontalResolution_ptr.Delegate(image, out resolution);\n\n            private delegate int GdipGetImagePaletteSize_delegate(IntPtr image, out int size);\n            private static FunctionWrapper<GdipGetImagePaletteSize_delegate> GdipGetImagePaletteSize_ptr;\n            internal static int GdipGetImagePaletteSize(IntPtr image, out int size) => GdipGetImagePaletteSize_ptr.Delegate(image, out size);\n\n            private delegate int GdipGetImagePalette_delegate(IntPtr image, IntPtr palette, int size);\n            private static FunctionWrapper<GdipGetImagePalette_delegate> GdipGetImagePalette_ptr;\n            internal static int GdipGetImagePalette(IntPtr image, IntPtr palette, int size) => GdipGetImagePalette_ptr.Delegate(image, palette, size);\n\n            private delegate int GdipSetImagePalette_delegate(IntPtr image, IntPtr palette);\n            private static FunctionWrapper<GdipSetImagePalette_delegate> GdipSetImagePalette_ptr;\n            internal static int GdipSetImagePalette(IntPtr image, IntPtr palette) => GdipSetImagePalette_ptr.Delegate(image, palette);\n\n            private delegate int GdipGetImageDimension_delegate(IntPtr image, out float width, out float height);\n            private static FunctionWrapper<GdipGetImageDimension_delegate> GdipGetImageDimension_ptr;\n            internal static int GdipGetImageDimension(IntPtr image, out float width, out float height) => GdipGetImageDimension_ptr.Delegate(image, out width, out height);\n\n            private delegate int GdipGetImagePixelFormat_delegate(IntPtr image, out PixelFormat format);\n            private static FunctionWrapper<GdipGetImagePixelFormat_delegate> GdipGetImagePixelFormat_ptr;\n            internal static int GdipGetImagePixelFormat(IntPtr image, out PixelFormat format) => GdipGetImagePixelFormat_ptr.Delegate(image, out format);\n\n            private delegate int GdipGetPropertyCount_delegate(IntPtr image, out uint propNumbers);\n            private static FunctionWrapper<GdipGetPropertyCount_delegate> GdipGetPropertyCount_ptr;\n            internal static int GdipGetPropertyCount(IntPtr image, out uint propNumbers) => GdipGetPropertyCount_ptr.Delegate(image, out propNumbers);\n\n            private delegate int GdipGetPropertyIdList_delegate(IntPtr image, uint propNumbers, [Out] int[] list);\n            private static FunctionWrapper<GdipGetPropertyIdList_delegate> GdipGetPropertyIdList_ptr;\n            internal static int GdipGetPropertyIdList(IntPtr image, uint propNumbers, [Out] int[] list) => GdipGetPropertyIdList_ptr.Delegate(image, propNumbers, list);\n\n            private delegate int GdipGetPropertySize_delegate(IntPtr image, out int bufferSize, out int propNumbers);\n            private static FunctionWrapper<GdipGetPropertySize_delegate> GdipGetPropertySize_ptr;\n            internal static int GdipGetPropertySize(IntPtr image, out int bufferSize, out int propNumbers) => GdipGetPropertySize_ptr.Delegate(image, out bufferSize, out propNumbers);\n\n            private delegate int GdipGetAllPropertyItems_delegate(IntPtr image, int bufferSize, int propNumbers, IntPtr items);\n            private static FunctionWrapper<GdipGetAllPropertyItems_delegate> GdipGetAllPropertyItems_ptr;\n            internal static int GdipGetAllPropertyItems(IntPtr image, int bufferSize, int propNumbers, IntPtr items) => GdipGetAllPropertyItems_ptr.Delegate(image, bufferSize, propNumbers, items);\n\n            private delegate int GdipGetImageRawFormat_delegate(IntPtr image, out Guid format);\n            private static FunctionWrapper<GdipGetImageRawFormat_delegate> GdipGetImageRawFormat_ptr;\n            internal static int GdipGetImageRawFormat(IntPtr image, out Guid format) => GdipGetImageRawFormat_ptr.Delegate(image, out format);\n\n            private delegate int GdipGetImageVerticalResolution_delegate(IntPtr image, out float resolution);\n            private static FunctionWrapper<GdipGetImageVerticalResolution_delegate> GdipGetImageVerticalResolution_ptr;\n            internal static int GdipGetImageVerticalResolution(IntPtr image, out float resolution) => GdipGetImageVerticalResolution_ptr.Delegate(image, out resolution);\n\n            private delegate int GdipGetImageWidth_delegate(IntPtr image, out uint width);\n            private static FunctionWrapper<GdipGetImageWidth_delegate> GdipGetImageWidth_ptr;\n            internal static int GdipGetImageWidth(IntPtr image, out uint width) => GdipGetImageWidth_ptr.Delegate(image, out width);\n\n            private delegate int GdipGetImageBounds_delegate(IntPtr image, out RectangleF source, ref GraphicsUnit unit);\n            private static FunctionWrapper<GdipGetImageBounds_delegate> GdipGetImageBounds_ptr;\n            internal static int GdipGetImageBounds(IntPtr image, out RectangleF source, ref GraphicsUnit unit) => GdipGetImageBounds_ptr.Delegate(image, out source, ref unit);\n\n            private delegate int GdipGetEncoderParameterListSize_delegate(IntPtr image, ref Guid encoder, out uint size);\n            private static FunctionWrapper<GdipGetEncoderParameterListSize_delegate> GdipGetEncoderParameterListSize_ptr;\n            internal static int GdipGetEncoderParameterListSize(IntPtr image, ref Guid encoder, out uint size) => GdipGetEncoderParameterListSize_ptr.Delegate(image, ref encoder, out size);\n\n            private delegate int GdipGetEncoderParameterList_delegate(IntPtr image, ref Guid encoder, uint size, IntPtr buffer);\n            private static FunctionWrapper<GdipGetEncoderParameterList_delegate> GdipGetEncoderParameterList_ptr;\n            internal static int GdipGetEncoderParameterList(IntPtr image, ref Guid encoder, uint size, IntPtr buffer) => GdipGetEncoderParameterList_ptr.Delegate(image, ref encoder, size, buffer);\n\n            private delegate int GdipImageGetFrameCount_delegate(IntPtr image, ref Guid guidDimension, out uint count);\n            private static FunctionWrapper<GdipImageGetFrameCount_delegate> GdipImageGetFrameCount_ptr;\n            internal static int GdipImageGetFrameCount(IntPtr image, ref Guid guidDimension, out uint count) => GdipImageGetFrameCount_ptr.Delegate(image, ref guidDimension, out count);\n\n            private delegate int GdipImageSelectActiveFrame_delegate(IntPtr image, ref Guid guidDimension, int frameIndex);\n            private static FunctionWrapper<GdipImageSelectActiveFrame_delegate> GdipImageSelectActiveFrame_ptr;\n            internal static int GdipImageSelectActiveFrame(IntPtr image, ref Guid guidDimension, int frameIndex) => GdipImageSelectActiveFrame_ptr.Delegate(image, ref guidDimension, frameIndex);\n\n            private delegate int GdipGetPropertyItemSize_delegate(IntPtr image, int propertyID, out int propertySize);\n            private static FunctionWrapper<GdipGetPropertyItemSize_delegate> GdipGetPropertyItemSize_ptr;\n            internal static int GdipGetPropertyItemSize(IntPtr image, int propertyID, out int propertySize) => GdipGetPropertyItemSize_ptr.Delegate(image, propertyID, out propertySize);\n\n            private delegate int GdipGetPropertyItem_delegate(IntPtr image, int propertyID, int propertySize, IntPtr buffer);\n            private static FunctionWrapper<GdipGetPropertyItem_delegate> GdipGetPropertyItem_ptr;\n            internal static int GdipGetPropertyItem(IntPtr image, int propertyID, int propertySize, IntPtr buffer) => GdipGetPropertyItem_ptr.Delegate(image, propertyID, propertySize, buffer);\n\n            private delegate int GdipRemovePropertyItem_delegate(IntPtr image, int propertyId);\n            private static FunctionWrapper<GdipRemovePropertyItem_delegate> GdipRemovePropertyItem_ptr;\n            internal static int GdipRemovePropertyItem(IntPtr image, int propertyId) => GdipRemovePropertyItem_ptr.Delegate(image, propertyId);\n\n            private delegate int GdipSetPropertyItem_delegate(IntPtr image, GdipPropertyItem* propertyItem);\n            private static FunctionWrapper<GdipSetPropertyItem_delegate> GdipSetPropertyItem_ptr;\n            internal static int GdipSetPropertyItem(IntPtr image, GdipPropertyItem* propertyItem) => GdipSetPropertyItem_ptr.Delegate(image, propertyItem);\n\n            private delegate int GdipGetImageThumbnail_delegate(IntPtr image, uint width, uint height, out IntPtr thumbImage, IntPtr callback, IntPtr callBackData);\n            private static FunctionWrapper<GdipGetImageThumbnail_delegate> GdipGetImageThumbnail_ptr;\n            internal static int GdipGetImageThumbnail(IntPtr image, uint width, uint height, out IntPtr thumbImage, IntPtr callback, IntPtr callBackData) => GdipGetImageThumbnail_ptr.Delegate(image, width, height, out thumbImage, callback, callBackData);\n\n            private delegate int GdipImageRotateFlip_delegate(IntPtr image, RotateFlipType rotateFlipType);\n            private static FunctionWrapper<GdipImageRotateFlip_delegate> GdipImageRotateFlip_ptr;\n            internal static int GdipImageRotateFlip(IntPtr image, RotateFlipType rotateFlipType) => GdipImageRotateFlip_ptr.Delegate(image, rotateFlipType);\n\n            private delegate int GdipSaveImageToFile_delegate(IntPtr image, [MarshalAs(UnmanagedType.LPWStr)]string filename, ref Guid encoderClsID, IntPtr encoderParameters);\n            private static FunctionWrapper<GdipSaveImageToFile_delegate> GdipSaveImageToFile_ptr;\n            internal static int GdipSaveImageToFile(IntPtr image, string filename, ref Guid encoderClsID, IntPtr encoderParameters) => GdipSaveImageToFile_ptr.Delegate(image, filename, ref encoderClsID, encoderParameters);\n\n            private delegate int GdipSaveAdd_delegate(IntPtr image, IntPtr encoderParameters);\n            private static FunctionWrapper<GdipSaveAdd_delegate> GdipSaveAdd_ptr;\n            internal static int GdipSaveAdd(IntPtr image, IntPtr encoderParameters) => GdipSaveAdd_ptr.Delegate(image, encoderParameters);\n\n            private delegate int GdipSaveAddImage_delegate(IntPtr image, IntPtr imagenew, IntPtr encoderParameters);\n            private static FunctionWrapper<GdipSaveAddImage_delegate> GdipSaveAddImage_ptr;\n            internal static int GdipSaveAddImage(IntPtr image, IntPtr imagenew, IntPtr encoderParameters) => GdipSaveAddImage_ptr.Delegate(image, imagenew, encoderParameters);\n\n            private delegate int GdipDrawImageI_delegate(IntPtr graphics, IntPtr image, int x, int y);\n            private static FunctionWrapper<GdipDrawImageI_delegate> GdipDrawImageI_ptr;\n            internal static int GdipDrawImageI(IntPtr graphics, IntPtr image, int x, int y) => GdipDrawImageI_ptr.Delegate(graphics, image, x, y);\n\n            private delegate int GdipGetImageGraphicsContext_delegate(IntPtr image, out IntPtr graphics);\n            private static FunctionWrapper<GdipGetImageGraphicsContext_delegate> GdipGetImageGraphicsContext_ptr;\n            internal static int GdipGetImageGraphicsContext(IntPtr image, out IntPtr graphics) => GdipGetImageGraphicsContext_ptr.Delegate(image, out graphics);\n\n            private delegate int GdipDrawImage_delegate(IntPtr graphics, IntPtr image, float x, float y);\n            private static FunctionWrapper<GdipDrawImage_delegate> GdipDrawImage_ptr;\n            internal static int GdipDrawImage(IntPtr graphics, IntPtr image, float x, float y) => GdipDrawImage_ptr.Delegate(graphics, image, x, y);\n\n            private delegate int GdipDrawImagePoints_delegate(IntPtr graphics, IntPtr image, PointF[] destPoints, int count);\n            private static FunctionWrapper<GdipDrawImagePoints_delegate> GdipDrawImagePoints_ptr;\n            internal static int GdipDrawImagePoints(IntPtr graphics, IntPtr image, PointF[] destPoints, int count) => GdipDrawImagePoints_ptr.Delegate(graphics, image, destPoints, count);\n\n            private delegate int GdipDrawImagePointsI_delegate(IntPtr graphics, IntPtr image, Point[] destPoints, int count);\n            private static FunctionWrapper<GdipDrawImagePointsI_delegate> GdipDrawImagePointsI_ptr;\n            internal static int GdipDrawImagePointsI(IntPtr graphics, IntPtr image, Point[] destPoints, int count) => GdipDrawImagePointsI_ptr.Delegate(graphics, image, destPoints, count);\n\n            private delegate int GdipDrawImageRectRectI_delegate(IntPtr graphics, IntPtr image, int dstx, int dsty, int dstwidth, int dstheight, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData);\n            private static FunctionWrapper<GdipDrawImageRectRectI_delegate> GdipDrawImageRectRectI_ptr;\n            internal static int GdipDrawImageRectRectI(IntPtr graphics, IntPtr image, int dstx, int dsty, int dstwidth, int dstheight, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData) => GdipDrawImageRectRectI_ptr.Delegate(graphics, image, dstx, dsty, dstwidth, dstheight, srcx, srcy, srcwidth, srcheight, srcUnit, imageattr, callback, callbackData);\n\n            private delegate int GdipDrawImageRectRect_delegate(IntPtr graphics, IntPtr image, float dstx, float dsty, float dstwidth, float dstheight, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData);\n            private static FunctionWrapper<GdipDrawImageRectRect_delegate> GdipDrawImageRectRect_ptr;\n            internal static int GdipDrawImageRectRect(IntPtr graphics, IntPtr image, float dstx, float dsty, float dstwidth, float dstheight, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData) => GdipDrawImageRectRect_ptr.Delegate(graphics, image, dstx, dsty, dstwidth, dstheight, srcx, srcy, srcwidth, srcheight, srcUnit, imageattr, callback, callbackData);\n\n            private delegate int GdipDrawImagePointsRectI_delegate(IntPtr graphics, IntPtr image, Point[] destPoints, int count, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData);\n            private static FunctionWrapper<GdipDrawImagePointsRectI_delegate> GdipDrawImagePointsRectI_ptr;\n            internal static int GdipDrawImagePointsRectI(IntPtr graphics, IntPtr image, Point[] destPoints, int count, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData) => GdipDrawImagePointsRectI_ptr.Delegate(graphics, image, destPoints, count, srcx, srcy, srcwidth, srcheight, srcUnit, imageattr, callback, callbackData);\n\n            private delegate int GdipDrawImagePointsRect_delegate(IntPtr graphics, IntPtr image, PointF[] destPoints, int count, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData);\n            private static FunctionWrapper<GdipDrawImagePointsRect_delegate> GdipDrawImagePointsRect_ptr;\n            internal static int GdipDrawImagePointsRect(IntPtr graphics, IntPtr image, PointF[] destPoints, int count, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData) => GdipDrawImagePointsRect_ptr.Delegate(graphics, image, destPoints, count, srcx, srcy, srcwidth, srcheight, srcUnit, imageattr, callback, callbackData);\n\n            private delegate int GdipDrawImageRect_delegate(IntPtr graphics, IntPtr image, float x, float y, float width, float height);\n            private static FunctionWrapper<GdipDrawImageRect_delegate> GdipDrawImageRect_ptr;\n            internal static int GdipDrawImageRect(IntPtr graphics, IntPtr image, float x, float y, float width, float height) => GdipDrawImageRect_ptr.Delegate(graphics, image, x, y, width, height);\n\n            private delegate int GdipDrawImagePointRect_delegate(IntPtr graphics, IntPtr image, float x, float y, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit);\n            private static FunctionWrapper<GdipDrawImagePointRect_delegate> GdipDrawImagePointRect_ptr;\n            internal static int GdipDrawImagePointRect(IntPtr graphics, IntPtr image, float x, float y, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit) => GdipDrawImagePointRect_ptr.Delegate(graphics, image, x, y, srcx, srcy, srcwidth, srcheight, srcUnit);\n\n            private delegate int GdipDrawImagePointRectI_delegate(IntPtr graphics, IntPtr image, int x, int y, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit);\n            private static FunctionWrapper<GdipDrawImagePointRectI_delegate> GdipDrawImagePointRectI_ptr;\n            internal static int GdipDrawImagePointRectI(IntPtr graphics, IntPtr image, int x, int y, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit) => GdipDrawImagePointRectI_ptr.Delegate(graphics, image, x, y, srcx, srcy, srcwidth, srcheight, srcUnit);\n\n            private delegate int GdipCreatePath_delegate(FillMode brushMode, out IntPtr path);\n            private static FunctionWrapper<GdipCreatePath_delegate> GdipCreatePath_ptr;\n            internal static int GdipCreatePath(FillMode brushMode, out IntPtr path) => GdipCreatePath_ptr.Delegate(brushMode, out path);\n\n            private delegate int GdipCreatePath2_delegate(PointF[] points, byte[] types, int count, FillMode brushMode, out IntPtr path);\n            private static FunctionWrapper<GdipCreatePath2_delegate> GdipCreatePath2_ptr;\n            internal static int GdipCreatePath2(PointF[] points, byte[] types, int count, FillMode brushMode, out IntPtr path) => GdipCreatePath2_ptr.Delegate(points, types, count, brushMode, out path);\n\n            private delegate int GdipCreatePath2I_delegate(Point[] points, byte[] types, int count, FillMode brushMode, out IntPtr path);\n            private static FunctionWrapper<GdipCreatePath2I_delegate> GdipCreatePath2I_ptr;\n            internal static int GdipCreatePath2I(Point[] points, byte[] types, int count, FillMode brushMode, out IntPtr path) => GdipCreatePath2I_ptr.Delegate(points, types, count, brushMode, out path);\n\n            private delegate int GdipClonePath_delegate(IntPtr path, out IntPtr clonePath);\n            private static FunctionWrapper<GdipClonePath_delegate> GdipClonePath_ptr;\n            internal static int GdipClonePath(IntPtr path, out IntPtr clonePath) => GdipClonePath_ptr.Delegate(path, out clonePath);\n\n            private delegate int GdipDeletePath_delegate(IntPtr path);\n            private static FunctionWrapper<GdipDeletePath_delegate> GdipDeletePath_ptr;\n            internal static int GdipDeletePath(IntPtr path) => GdipDeletePath_ptr.Delegate(path);\n            internal static int IntGdipDeletePath(HandleRef path) => (int)GdipDeletePath_ptr.Delegate(path.Handle);\n\n            private delegate int GdipResetPath_delegate(IntPtr path);\n            private static FunctionWrapper<GdipResetPath_delegate> GdipResetPath_ptr;\n            internal static int GdipResetPath(IntPtr path) => GdipResetPath_ptr.Delegate(path);\n\n            private delegate int GdipGetPointCount_delegate(IntPtr path, out int count);\n            private static FunctionWrapper<GdipGetPointCount_delegate> GdipGetPointCount_ptr;\n            internal static int GdipGetPointCount(IntPtr path, out int count) => GdipGetPointCount_ptr.Delegate(path, out count);\n\n            private delegate int GdipGetPathTypes_delegate(IntPtr path, [Out] byte[] types, int count);\n            private static FunctionWrapper<GdipGetPathTypes_delegate> GdipGetPathTypes_ptr;\n            internal static int GdipGetPathTypes(IntPtr path, [Out] byte[] types, int count) => GdipGetPathTypes_ptr.Delegate(path, types, count);\n\n            private delegate int GdipGetPathPoints_delegate(IntPtr path, [Out] PointF[] points, int count);\n            private static FunctionWrapper<GdipGetPathPoints_delegate> GdipGetPathPoints_ptr;\n            internal static int GdipGetPathPoints(IntPtr path, [Out] PointF[] points, int count) => GdipGetPathPoints_ptr.Delegate(path, points, count);\n\n            private delegate int GdipGetPathPointsI_delegate(IntPtr path, [Out] Point[] points, int count);\n            private static FunctionWrapper<GdipGetPathPointsI_delegate> GdipGetPathPointsI_ptr;\n            internal static int GdipGetPathPointsI(IntPtr path, [Out] Point[] points, int count) => GdipGetPathPointsI_ptr.Delegate(path, points, count);\n\n            private delegate int GdipGetPathFillMode_delegate(IntPtr path, out FillMode fillMode);\n            private static FunctionWrapper<GdipGetPathFillMode_delegate> GdipGetPathFillMode_ptr;\n            internal static int GdipGetPathFillMode(IntPtr path, out FillMode fillMode) => GdipGetPathFillMode_ptr.Delegate(path, out fillMode);\n\n            private delegate int GdipSetPathFillMode_delegate(IntPtr path, FillMode fillMode);\n            private static FunctionWrapper<GdipSetPathFillMode_delegate> GdipSetPathFillMode_ptr;\n            internal static int GdipSetPathFillMode(IntPtr path, FillMode fillMode) => GdipSetPathFillMode_ptr.Delegate(path, fillMode);\n\n            private delegate int GdipStartPathFigure_delegate(IntPtr path);\n            private static FunctionWrapper<GdipStartPathFigure_delegate> GdipStartPathFigure_ptr;\n            internal static int GdipStartPathFigure(IntPtr path) => GdipStartPathFigure_ptr.Delegate(path);\n\n            private delegate int GdipClosePathFigure_delegate(IntPtr path);\n            private static FunctionWrapper<GdipClosePathFigure_delegate> GdipClosePathFigure_ptr;\n            internal static int GdipClosePathFigure(IntPtr path) => GdipClosePathFigure_ptr.Delegate(path);\n\n            private delegate int GdipClosePathFigures_delegate(IntPtr path);\n            private static FunctionWrapper<GdipClosePathFigures_delegate> GdipClosePathFigures_ptr;\n            internal static int GdipClosePathFigures(IntPtr path) => GdipClosePathFigures_ptr.Delegate(path);\n\n            private delegate int GdipSetPathMarker_delegate(IntPtr path);\n            private static FunctionWrapper<GdipSetPathMarker_delegate> GdipSetPathMarker_ptr;\n            internal static int GdipSetPathMarker(IntPtr path) => GdipSetPathMarker_ptr.Delegate(path);\n\n            private delegate int GdipClearPathMarkers_delegate(IntPtr path);\n            private static FunctionWrapper<GdipClearPathMarkers_delegate> GdipClearPathMarkers_ptr;\n            internal static int GdipClearPathMarkers(IntPtr path) => GdipClearPathMarkers_ptr.Delegate(path);\n\n            private delegate int GdipReversePath_delegate(IntPtr path);\n            private static FunctionWrapper<GdipReversePath_delegate> GdipReversePath_ptr;\n            internal static int GdipReversePath(IntPtr path) => GdipReversePath_ptr.Delegate(path);\n\n            private delegate int GdipGetPathLastPoint_delegate(IntPtr path, out PointF lastPoint);\n            private static FunctionWrapper<GdipGetPathLastPoint_delegate> GdipGetPathLastPoint_ptr;\n            internal static int GdipGetPathLastPoint(IntPtr path, out PointF lastPoint) => GdipGetPathLastPoint_ptr.Delegate(path, out lastPoint);\n\n            private delegate int GdipAddPathLine_delegate(IntPtr path, float x1, float y1, float x2, float y2);\n            private static FunctionWrapper<GdipAddPathLine_delegate> GdipAddPathLine_ptr;\n            internal static int GdipAddPathLine(IntPtr path, float x1, float y1, float x2, float y2) => GdipAddPathLine_ptr.Delegate(path, x1, y1, x2, y2);\n\n            private delegate int GdipAddPathLine2_delegate(IntPtr path, PointF[] points, int count);\n            private static FunctionWrapper<GdipAddPathLine2_delegate> GdipAddPathLine2_ptr;\n            internal static int GdipAddPathLine2(IntPtr path, PointF[] points, int count) => GdipAddPathLine2_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathLine2I_delegate(IntPtr path, Point[] points, int count);\n            private static FunctionWrapper<GdipAddPathLine2I_delegate> GdipAddPathLine2I_ptr;\n            internal static int GdipAddPathLine2I(IntPtr path, Point[] points, int count) => GdipAddPathLine2I_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathArc_delegate(IntPtr path, float x, float y, float width, float height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipAddPathArc_delegate> GdipAddPathArc_ptr;\n            internal static int GdipAddPathArc(IntPtr path, float x, float y, float width, float height, float startAngle, float sweepAngle) => GdipAddPathArc_ptr.Delegate(path, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipAddPathBezier_delegate(IntPtr path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);\n            private static FunctionWrapper<GdipAddPathBezier_delegate> GdipAddPathBezier_ptr;\n            internal static int GdipAddPathBezier(IntPtr path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4) => GdipAddPathBezier_ptr.Delegate(path, x1, y1, x2, y2, x3, y3, x4, y4);\n\n            private delegate int GdipAddPathBeziers_delegate(IntPtr path, PointF[] points, int count);\n            private static FunctionWrapper<GdipAddPathBeziers_delegate> GdipAddPathBeziers_ptr;\n            internal static int GdipAddPathBeziers(IntPtr path, PointF[] points, int count) => GdipAddPathBeziers_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathCurve_delegate(IntPtr path, PointF[] points, int count);\n            private static FunctionWrapper<GdipAddPathCurve_delegate> GdipAddPathCurve_ptr;\n            internal static int GdipAddPathCurve(IntPtr path, PointF[] points, int count) => GdipAddPathCurve_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathCurveI_delegate(IntPtr path, Point[] points, int count);\n            private static FunctionWrapper<GdipAddPathCurveI_delegate> GdipAddPathCurveI_ptr;\n            internal static int GdipAddPathCurveI(IntPtr path, Point[] points, int count) => GdipAddPathCurveI_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathCurve2_delegate(IntPtr path, PointF[] points, int count, float tension);\n            private static FunctionWrapper<GdipAddPathCurve2_delegate> GdipAddPathCurve2_ptr;\n            internal static int GdipAddPathCurve2(IntPtr path, PointF[] points, int count, float tension) => GdipAddPathCurve2_ptr.Delegate(path, points, count, tension);\n\n            private delegate int GdipAddPathCurve2I_delegate(IntPtr path, Point[] points, int count, float tension);\n            private static FunctionWrapper<GdipAddPathCurve2I_delegate> GdipAddPathCurve2I_ptr;\n            internal static int GdipAddPathCurve2I(IntPtr path, Point[] points, int count, float tension) => GdipAddPathCurve2I_ptr.Delegate(path, points, count, tension);\n\n            private delegate int GdipAddPathCurve3_delegate(IntPtr path, PointF[] points, int count, int offset, int numberOfSegments, float tension);\n            private static FunctionWrapper<GdipAddPathCurve3_delegate> GdipAddPathCurve3_ptr;\n            internal static int GdipAddPathCurve3(IntPtr path, PointF[] points, int count, int offset, int numberOfSegments, float tension) => GdipAddPathCurve3_ptr.Delegate(path, points, count, offset, numberOfSegments, tension);\n\n            private delegate int GdipAddPathCurve3I_delegate(IntPtr path, Point[] points, int count, int offset, int numberOfSegments, float tension);\n            private static FunctionWrapper<GdipAddPathCurve3I_delegate> GdipAddPathCurve3I_ptr;\n            internal static int GdipAddPathCurve3I(IntPtr path, Point[] points, int count, int offset, int numberOfSegments, float tension) => GdipAddPathCurve3I_ptr.Delegate(path, points, count, offset, numberOfSegments, tension);\n\n            private delegate int GdipAddPathClosedCurve_delegate(IntPtr path, PointF[] points, int count);\n            private static FunctionWrapper<GdipAddPathClosedCurve_delegate> GdipAddPathClosedCurve_ptr;\n            internal static int GdipAddPathClosedCurve(IntPtr path, PointF[] points, int count) => GdipAddPathClosedCurve_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathClosedCurveI_delegate(IntPtr path, Point[] points, int count);\n            private static FunctionWrapper<GdipAddPathClosedCurveI_delegate> GdipAddPathClosedCurveI_ptr;\n            internal static int GdipAddPathClosedCurveI(IntPtr path, Point[] points, int count) => GdipAddPathClosedCurveI_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathClosedCurve2_delegate(IntPtr path, PointF[] points, int count, float tension);\n            private static FunctionWrapper<GdipAddPathClosedCurve2_delegate> GdipAddPathClosedCurve2_ptr;\n            internal static int GdipAddPathClosedCurve2(IntPtr path, PointF[] points, int count, float tension) => GdipAddPathClosedCurve2_ptr.Delegate(path, points, count, tension);\n\n            private delegate int GdipAddPathClosedCurve2I_delegate(IntPtr path, Point[] points, int count, float tension);\n            private static FunctionWrapper<GdipAddPathClosedCurve2I_delegate> GdipAddPathClosedCurve2I_ptr;\n            internal static int GdipAddPathClosedCurve2I(IntPtr path, Point[] points, int count, float tension) => GdipAddPathClosedCurve2I_ptr.Delegate(path, points, count, tension);\n\n            private delegate int GdipAddPathRectangle_delegate(IntPtr path, float x, float y, float width, float height);\n            private static FunctionWrapper<GdipAddPathRectangle_delegate> GdipAddPathRectangle_ptr;\n            internal static int GdipAddPathRectangle(IntPtr path, float x, float y, float width, float height) => GdipAddPathRectangle_ptr.Delegate(path, x, y, width, height);\n\n            private delegate int GdipAddPathRectangles_delegate(IntPtr path, RectangleF[] rects, int count);\n            private static FunctionWrapper<GdipAddPathRectangles_delegate> GdipAddPathRectangles_ptr;\n            internal static int GdipAddPathRectangles(IntPtr path, RectangleF[] rects, int count) => GdipAddPathRectangles_ptr.Delegate(path, rects, count);\n\n            private delegate int GdipAddPathEllipse_delegate(IntPtr path, float x, float y, float width, float height);\n            private static FunctionWrapper<GdipAddPathEllipse_delegate> GdipAddPathEllipse_ptr;\n            internal static int GdipAddPathEllipse(IntPtr path, float x, float y, float width, float height) => GdipAddPathEllipse_ptr.Delegate(path, x, y, width, height);\n\n            private delegate int GdipAddPathEllipseI_delegate(IntPtr path, int x, int y, int width, int height);\n            private static FunctionWrapper<GdipAddPathEllipseI_delegate> GdipAddPathEllipseI_ptr;\n            internal static int GdipAddPathEllipseI(IntPtr path, int x, int y, int width, int height) => GdipAddPathEllipseI_ptr.Delegate(path, x, y, width, height);\n\n            private delegate int GdipAddPathPie_delegate(IntPtr path, float x, float y, float width, float height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipAddPathPie_delegate> GdipAddPathPie_ptr;\n            internal static int GdipAddPathPie(IntPtr path, float x, float y, float width, float height, float startAngle, float sweepAngle) => GdipAddPathPie_ptr.Delegate(path, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipAddPathPieI_delegate(IntPtr path, int x, int y, int width, int height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipAddPathPieI_delegate> GdipAddPathPieI_ptr;\n            internal static int GdipAddPathPieI(IntPtr path, int x, int y, int width, int height, float startAngle, float sweepAngle) => GdipAddPathPieI_ptr.Delegate(path, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipAddPathPolygon_delegate(IntPtr path, PointF[] points, int count);\n            private static FunctionWrapper<GdipAddPathPolygon_delegate> GdipAddPathPolygon_ptr;\n            internal static int GdipAddPathPolygon(IntPtr path, PointF[] points, int count) => GdipAddPathPolygon_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathPath_delegate(IntPtr path, IntPtr addingPath, bool connect);\n            private static FunctionWrapper<GdipAddPathPath_delegate> GdipAddPathPath_ptr;\n            internal static int GdipAddPathPath(IntPtr path, IntPtr addingPath, bool connect) => GdipAddPathPath_ptr.Delegate(path, addingPath, connect);\n\n            private delegate int GdipAddPathLineI_delegate(IntPtr path, int x1, int y1, int x2, int y2);\n            private static FunctionWrapper<GdipAddPathLineI_delegate> GdipAddPathLineI_ptr;\n            internal static int GdipAddPathLineI(IntPtr path, int x1, int y1, int x2, int y2) => GdipAddPathLineI_ptr.Delegate(path, x1, y1, x2, y2);\n\n            private delegate int GdipAddPathArcI_delegate(IntPtr path, int x, int y, int width, int height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipAddPathArcI_delegate> GdipAddPathArcI_ptr;\n            internal static int GdipAddPathArcI(IntPtr path, int x, int y, int width, int height, float startAngle, float sweepAngle) => GdipAddPathArcI_ptr.Delegate(path, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipAddPathBezierI_delegate(IntPtr path, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);\n            private static FunctionWrapper<GdipAddPathBezierI_delegate> GdipAddPathBezierI_ptr;\n            internal static int GdipAddPathBezierI(IntPtr path, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) => GdipAddPathBezierI_ptr.Delegate(path, x1, y1, x2, y2, x3, y3, x4, y4);\n\n            private delegate int GdipAddPathBeziersI_delegate(IntPtr path, Point[] points, int count);\n            private static FunctionWrapper<GdipAddPathBeziersI_delegate> GdipAddPathBeziersI_ptr;\n            internal static int GdipAddPathBeziersI(IntPtr path, Point[] points, int count) => GdipAddPathBeziersI_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathPolygonI_delegate(IntPtr path, Point[] points, int count);\n            private static FunctionWrapper<GdipAddPathPolygonI_delegate> GdipAddPathPolygonI_ptr;\n            internal static int GdipAddPathPolygonI(IntPtr path, Point[] points, int count) => GdipAddPathPolygonI_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathRectangleI_delegate(IntPtr path, int x, int y, int width, int height);\n            private static FunctionWrapper<GdipAddPathRectangleI_delegate> GdipAddPathRectangleI_ptr;\n            internal static int GdipAddPathRectangleI(IntPtr path, int x, int y, int width, int height) => GdipAddPathRectangleI_ptr.Delegate(path, x, y, width, height);\n\n            private delegate int GdipAddPathRectanglesI_delegate(IntPtr path, Rectangle[] rects, int count);\n            private static FunctionWrapper<GdipAddPathRectanglesI_delegate> GdipAddPathRectanglesI_ptr;\n            internal static int GdipAddPathRectanglesI(IntPtr path, Rectangle[] rects, int count) => GdipAddPathRectanglesI_ptr.Delegate(path, rects, count);\n\n            private delegate int GdipFlattenPath_delegate(IntPtr path, IntPtr matrix, float floatness);\n            private static FunctionWrapper<GdipFlattenPath_delegate> GdipFlattenPath_ptr;\n            internal static int GdipFlattenPath(IntPtr path, IntPtr matrix, float floatness) => GdipFlattenPath_ptr.Delegate(path, matrix, floatness);\n\n            private delegate int GdipTransformPath_delegate(IntPtr path, IntPtr matrix);\n            private static FunctionWrapper<GdipTransformPath_delegate> GdipTransformPath_ptr;\n            internal static int GdipTransformPath(IntPtr path, IntPtr matrix) => GdipTransformPath_ptr.Delegate(path, matrix);\n\n            private delegate int GdipWarpPath_delegate(IntPtr path, IntPtr matrix, PointF[] points, int count, float srcx, float srcy, float srcwidth, float srcheight, WarpMode mode, float flatness);\n            private static FunctionWrapper<GdipWarpPath_delegate> GdipWarpPath_ptr;\n            internal static int GdipWarpPath(IntPtr path, IntPtr matrix, PointF[] points, int count, float srcx, float srcy, float srcwidth, float srcheight, WarpMode mode, float flatness) => GdipWarpPath_ptr.Delegate(path, matrix, points, count, srcx, srcy, srcwidth, srcheight, mode, flatness);\n\n            private delegate int GdipWidenPath_delegate(IntPtr path, IntPtr pen, IntPtr matrix, float flatness);\n            private static FunctionWrapper<GdipWidenPath_delegate> GdipWidenPath_ptr;\n            internal static int GdipWidenPath(IntPtr path, IntPtr pen, IntPtr matrix, float flatness) => GdipWidenPath_ptr.Delegate(path, pen, matrix, flatness);\n\n            private delegate int GdipGetPathWorldBounds_delegate(IntPtr path, out RectangleF bounds, IntPtr matrix, IntPtr pen);\n            private static FunctionWrapper<GdipGetPathWorldBounds_delegate> GdipGetPathWorldBounds_ptr;\n            internal static int GdipGetPathWorldBounds(IntPtr path, out RectangleF bounds, IntPtr matrix, IntPtr pen) => GdipGetPathWorldBounds_ptr.Delegate(path, out bounds, matrix, pen);\n\n            private delegate int GdipGetPathWorldBoundsI_delegate(IntPtr path, out Rectangle bounds, IntPtr matrix, IntPtr pen);\n            private static FunctionWrapper<GdipGetPathWorldBoundsI_delegate> GdipGetPathWorldBoundsI_ptr;\n            internal static int GdipGetPathWorldBoundsI(IntPtr path, out Rectangle bounds, IntPtr matrix, IntPtr pen) => GdipGetPathWorldBoundsI_ptr.Delegate(path, out bounds, matrix, pen);\n\n            private delegate int GdipIsVisiblePathPoint_delegate(IntPtr path, float x, float y, IntPtr graphics, out bool result);\n            private static FunctionWrapper<GdipIsVisiblePathPoint_delegate> GdipIsVisiblePathPoint_ptr;\n            internal static int GdipIsVisiblePathPoint(IntPtr path, float x, float y, IntPtr graphics, out bool result) => GdipIsVisiblePathPoint_ptr.Delegate(path, x, y, graphics, out result);\n\n            private delegate int GdipIsVisiblePathPointI_delegate(IntPtr path, int x, int y, IntPtr graphics, out bool result);\n            private static FunctionWrapper<GdipIsVisiblePathPointI_delegate> GdipIsVisiblePathPointI_ptr;\n            internal static int GdipIsVisiblePathPointI(IntPtr path, int x, int y, IntPtr graphics, out bool result) => GdipIsVisiblePathPointI_ptr.Delegate(path, x, y, graphics, out result);\n\n            private delegate int GdipIsOutlineVisiblePathPoint_delegate(IntPtr path, float x, float y, IntPtr pen, IntPtr graphics, out bool result);\n            private static FunctionWrapper<GdipIsOutlineVisiblePathPoint_delegate> GdipIsOutlineVisiblePathPoint_ptr;\n            internal static int GdipIsOutlineVisiblePathPoint(IntPtr path, float x, float y, IntPtr pen, IntPtr graphics, out bool result) => GdipIsOutlineVisiblePathPoint_ptr.Delegate(path, x, y, pen, graphics, out result);\n\n            private delegate int GdipIsOutlineVisiblePathPointI_delegate(IntPtr path, int x, int y, IntPtr pen, IntPtr graphics, out bool result);\n            private static FunctionWrapper<GdipIsOutlineVisiblePathPointI_delegate> GdipIsOutlineVisiblePathPointI_ptr;\n            internal static int GdipIsOutlineVisiblePathPointI(IntPtr path, int x, int y, IntPtr pen, IntPtr graphics, out bool result) => GdipIsOutlineVisiblePathPointI_ptr.Delegate(path, x, y, pen, graphics, out result);\n\n            private delegate int GdipCreateFont_delegate(IntPtr fontFamily, float emSize, FontStyle style, GraphicsUnit unit, out IntPtr font);\n            private static FunctionWrapper<GdipCreateFont_delegate> GdipCreateFont_ptr;\n            internal static int GdipCreateFont(IntPtr fontFamily, float emSize, FontStyle style, GraphicsUnit unit, out IntPtr font) => GdipCreateFont_ptr.Delegate(fontFamily, emSize, style, unit, out font);\n\n            private delegate int GdipDeleteFont_delegate(IntPtr font);\n            private static FunctionWrapper<GdipDeleteFont_delegate> GdipDeleteFont_ptr;\n            internal static int GdipDeleteFont(IntPtr font) => GdipDeleteFont_ptr.Delegate(font);\n            internal static int IntGdipDeleteFont(HandleRef font) => (int)GdipDeleteFont_ptr.Delegate(font.Handle);\n\n#pragma warning disable CS0618 // Legacy code: We don't care about using obsolete API's.\n            private delegate int GdipGetLogFont_delegate(IntPtr font, IntPtr graphics, [MarshalAs(UnmanagedType.AsAny), Out] object logfontA);\n#pragma warning restore CS0618\n            private static FunctionWrapper<GdipGetLogFont_delegate> GdipGetLogFont_ptr;\n            internal static int GdipGetLogFont(IntPtr font, IntPtr graphics, [Out] object logfontA) => GdipGetLogFont_ptr.Delegate(font, graphics, logfontA);\n\n            private delegate int GdipCreateFontFromDC_delegate(IntPtr hdc, out IntPtr font);\n            private static FunctionWrapper<GdipCreateFontFromDC_delegate> GdipCreateFontFromDC_ptr;\n            internal static int GdipCreateFontFromDC(IntPtr hdc, out IntPtr font) => GdipCreateFontFromDC_ptr.Delegate(hdc, out font);\n\n            private delegate int GdipCreateFontFromLogfont_delegate(IntPtr hdc, ref LOGFONT lf, out IntPtr ptr);\n            private static FunctionWrapper<GdipCreateFontFromLogfont_delegate> GdipCreateFontFromLogfont_ptr;\n            internal static int GdipCreateFontFromLogfont(IntPtr hdc, ref LOGFONT lf, out IntPtr ptr) => GdipCreateFontFromLogfont_ptr.Delegate(hdc, ref lf, out ptr);\n\n            private delegate int GdipCreateFontFromHfont_delegate(IntPtr hdc, out IntPtr font, ref LOGFONT lf);\n            private static FunctionWrapper<GdipCreateFontFromHfont_delegate> GdipCreateFontFromHfont_ptr;\n            internal static int GdipCreateFontFromHfont(IntPtr hdc, out IntPtr font, ref LOGFONT lf) => GdipCreateFontFromHfont_ptr.Delegate(hdc, out font, ref lf);\n\n            private delegate int GdipGetFontSize_delegate(IntPtr font, out float size);\n            private static FunctionWrapper<GdipGetFontSize_delegate> GdipGetFontSize_ptr;\n            internal static int GdipGetFontSize(IntPtr font, out float size) => GdipGetFontSize_ptr.Delegate(font, out size);\n\n            private delegate int GdipGetFontHeight_delegate(IntPtr font, IntPtr graphics, out float height);\n            private static FunctionWrapper<GdipGetFontHeight_delegate> GdipGetFontHeight_ptr;\n            internal static int GdipGetFontHeight(IntPtr font, IntPtr graphics, out float height) => GdipGetFontHeight_ptr.Delegate(font, graphics, out height);\n\n            private delegate int GdipGetFontHeightGivenDPI_delegate(IntPtr font, float dpi, out float height);\n            private static FunctionWrapper<GdipGetFontHeightGivenDPI_delegate> GdipGetFontHeightGivenDPI_ptr;\n            internal static int GdipGetFontHeightGivenDPI(IntPtr font, float dpi, out float height) => GdipGetFontHeightGivenDPI_ptr.Delegate(font, dpi, out height);\n\n            private delegate int GdipCreateMetafileFromFile_delegate([MarshalAs(UnmanagedType.LPWStr)]string filename, out IntPtr metafile);\n            private static FunctionWrapper<GdipCreateMetafileFromFile_delegate> GdipCreateMetafileFromFile_ptr;\n            internal static int GdipCreateMetafileFromFile(string filename, out IntPtr metafile) => GdipCreateMetafileFromFile_ptr.Delegate(filename, out metafile);\n\n            private delegate int GdipCreateMetafileFromEmf_delegate(IntPtr hEmf, bool deleteEmf, out IntPtr metafile);\n            private static FunctionWrapper<GdipCreateMetafileFromEmf_delegate> GdipCreateMetafileFromEmf_ptr;\n            internal static int GdipCreateMetafileFromEmf(IntPtr hEmf, bool deleteEmf, out IntPtr metafile) => GdipCreateMetafileFromEmf_ptr.Delegate(hEmf, deleteEmf, out metafile);\n\n            private delegate int GdipCreateMetafileFromWmf_delegate(IntPtr hWmf, bool deleteWmf, WmfPlaceableFileHeader wmfPlaceableFileHeader, out IntPtr metafile);\n            private static FunctionWrapper<GdipCreateMetafileFromWmf_delegate> GdipCreateMetafileFromWmf_ptr;\n            internal static int GdipCreateMetafileFromWmf(IntPtr hWmf, bool deleteWmf, WmfPlaceableFileHeader wmfPlaceableFileHeader, out IntPtr metafile) => GdipCreateMetafileFromWmf_ptr.Delegate(hWmf, deleteWmf, wmfPlaceableFileHeader, out metafile);\n\n            private delegate int GdipGetMetafileHeaderFromFile_delegate([MarshalAs(UnmanagedType.LPWStr)]string filename, IntPtr header);\n            private static FunctionWrapper<GdipGetMetafileHeaderFromFile_delegate> GdipGetMetafileHeaderFromFile_ptr;\n            internal static int GdipGetMetafileHeaderFromFile(string filename, IntPtr header) => GdipGetMetafileHeaderFromFile_ptr.Delegate(filename, header);\n\n            private delegate int GdipGetMetafileHeaderFromMetafile_delegate(IntPtr metafile, IntPtr header);\n            private static FunctionWrapper<GdipGetMetafileHeaderFromMetafile_delegate> GdipGetMetafileHeaderFromMetafile_ptr;\n            internal static int GdipGetMetafileHeaderFromMetafile(IntPtr metafile, IntPtr header) => GdipGetMetafileHeaderFromMetafile_ptr.Delegate(metafile, header);\n\n            private delegate int GdipGetMetafileHeaderFromEmf_delegate(IntPtr hEmf, IntPtr header);\n            private static FunctionWrapper<GdipGetMetafileHeaderFromEmf_delegate> GdipGetMetafileHeaderFromEmf_ptr;\n            internal static int GdipGetMetafileHeaderFromEmf(IntPtr hEmf, IntPtr header) => GdipGetMetafileHeaderFromEmf_ptr.Delegate(hEmf, header);\n\n            private delegate int GdipGetMetafileHeaderFromWmf_delegate(IntPtr hWmf, IntPtr wmfPlaceableFileHeader, IntPtr header);\n            private static FunctionWrapper<GdipGetMetafileHeaderFromWmf_delegate> GdipGetMetafileHeaderFromWmf_ptr;\n            internal static int GdipGetMetafileHeaderFromWmf(IntPtr hWmf, IntPtr wmfPlaceableFileHeader, IntPtr header) => GdipGetMetafileHeaderFromWmf_ptr.Delegate(hWmf, wmfPlaceableFileHeader, header);\n\n            private delegate int GdipGetHemfFromMetafile_delegate(IntPtr metafile, out IntPtr hEmf);\n            private static FunctionWrapper<GdipGetHemfFromMetafile_delegate> GdipGetHemfFromMetafile_ptr;\n            internal static int GdipGetHemfFromMetafile(IntPtr metafile, out IntPtr hEmf) => GdipGetHemfFromMetafile_ptr.Delegate(metafile, out hEmf);\n\n            private delegate int GdipGetMetafileDownLevelRasterizationLimit_delegate(IntPtr metafile, ref uint metafileRasterizationLimitDpi);\n            private static FunctionWrapper<GdipGetMetafileDownLevelRasterizationLimit_delegate> GdipGetMetafileDownLevelRasterizationLimit_ptr;\n            internal static int GdipGetMetafileDownLevelRasterizationLimit(IntPtr metafile, ref uint metafileRasterizationLimitDpi) => GdipGetMetafileDownLevelRasterizationLimit_ptr.Delegate(metafile, ref metafileRasterizationLimitDpi);\n\n            private delegate int GdipSetMetafileDownLevelRasterizationLimit_delegate(IntPtr metafile, uint metafileRasterizationLimitDpi);\n            private static FunctionWrapper<GdipSetMetafileDownLevelRasterizationLimit_delegate> GdipSetMetafileDownLevelRasterizationLimit_ptr;\n            internal static int GdipSetMetafileDownLevelRasterizationLimit(IntPtr metafile, uint metafileRasterizationLimitDpi) => GdipSetMetafileDownLevelRasterizationLimit_ptr.Delegate(metafile, metafileRasterizationLimitDpi);\n\n            private delegate int GdipPlayMetafileRecord_delegate(IntPtr metafile, EmfPlusRecordType recordType, int flags, int dataSize, byte[] data);\n            private static FunctionWrapper<GdipPlayMetafileRecord_delegate> GdipPlayMetafileRecord_ptr;\n            internal static int GdipPlayMetafileRecord(IntPtr metafile, EmfPlusRecordType recordType, int flags, int dataSize, byte[] data) => GdipPlayMetafileRecord_ptr.Delegate(metafile, recordType, flags, dataSize, data);\n\n            private delegate int GdipRecordMetafile_delegate(IntPtr hdc, EmfType type, ref RectangleF frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)]string description, out IntPtr metafile);\n            private static FunctionWrapper<GdipRecordMetafile_delegate> GdipRecordMetafile_ptr;\n            internal static int GdipRecordMetafile(IntPtr hdc, EmfType type, ref RectangleF frameRect, MetafileFrameUnit frameUnit, string description, out IntPtr metafile) => GdipRecordMetafile_ptr.Delegate(hdc, type, ref frameRect, frameUnit, description, out metafile);\n\n            private delegate int GdipRecordMetafileI_delegate(IntPtr hdc, EmfType type, ref Rectangle frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)]string description, out IntPtr metafile);\n            private static FunctionWrapper<GdipRecordMetafileI_delegate> GdipRecordMetafileI_ptr;\n            internal static int GdipRecordMetafileI(IntPtr hdc, EmfType type, ref Rectangle frameRect, MetafileFrameUnit frameUnit, string description, out IntPtr metafile) => GdipRecordMetafileI_ptr.Delegate(hdc, type, ref frameRect, frameUnit, description, out metafile);\n\n            private delegate int GdipRecordMetafileFileName_delegate([MarshalAs(UnmanagedType.LPWStr)]string filename, IntPtr hdc, EmfType type, ref RectangleF frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)]string description, out IntPtr metafile);\n            private static FunctionWrapper<GdipRecordMetafileFileName_delegate> GdipRecordMetafileFileName_ptr;\n            internal static int GdipRecordMetafileFileName(string filename, IntPtr hdc, EmfType type, ref RectangleF frameRect, MetafileFrameUnit frameUnit, string description, out IntPtr metafile) => GdipRecordMetafileFileName_ptr.Delegate(filename, hdc, type, ref frameRect, frameUnit, description, out metafile);\n\n            private delegate int GdipRecordMetafileFileNameI_delegate([MarshalAs(UnmanagedType.LPWStr)]string filename, IntPtr hdc, EmfType type, ref Rectangle frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)]string description, out IntPtr metafile);\n            private static FunctionWrapper<GdipRecordMetafileFileNameI_delegate> GdipRecordMetafileFileNameI_ptr;\n            internal static int GdipRecordMetafileFileNameI(string filename, IntPtr hdc, EmfType type, ref Rectangle frameRect, MetafileFrameUnit frameUnit, string description, out IntPtr metafile) => GdipRecordMetafileFileNameI_ptr.Delegate(filename, hdc, type, ref frameRect, frameUnit, description, out metafile);\n\n            private delegate int GdipCreateFromContext_macosx_delegate(IntPtr cgref, int width, int height, out IntPtr graphics);\n            private static FunctionWrapper<GdipCreateFromContext_macosx_delegate> GdipCreateFromContext_macosx_ptr;\n            internal static int GdipCreateFromContext_macosx(IntPtr cgref, int width, int height, out IntPtr graphics) => GdipCreateFromContext_macosx_ptr.Delegate(cgref, width, height, out graphics);\n\n            private delegate int GdipSetVisibleClip_linux_delegate(IntPtr graphics, ref Rectangle rect);\n            private static FunctionWrapper<GdipSetVisibleClip_linux_delegate> GdipSetVisibleClip_linux_ptr;\n            internal static int GdipSetVisibleClip_linux(IntPtr graphics, ref Rectangle rect) => GdipSetVisibleClip_linux_ptr.Delegate(graphics, ref rect);\n\n            private delegate int GdipCreateFromXDrawable_linux_delegate(IntPtr drawable, IntPtr display, out IntPtr graphics);\n            private static FunctionWrapper<GdipCreateFromXDrawable_linux_delegate> GdipCreateFromXDrawable_linux_ptr;\n            internal static int GdipCreateFromXDrawable_linux(IntPtr drawable, IntPtr display, out IntPtr graphics) => GdipCreateFromXDrawable_linux_ptr.Delegate(drawable, display, out graphics);\n\n            // Stream functions for non-Win32 (libgdiplus specific)\n            private delegate int GdipLoadImageFromDelegate_linux_delegate(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, out IntPtr image);\n            private static FunctionWrapper<GdipLoadImageFromDelegate_linux_delegate> GdipLoadImageFromDelegate_linux_ptr;\n            internal static int GdipLoadImageFromDelegate_linux(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, out IntPtr image)\n                => GdipLoadImageFromDelegate_linux_ptr.Delegate(getHeader, getBytes, putBytes, doSeek, close, size, out image);\n\n            private delegate int GdipSaveImageToDelegate_linux_delegate(IntPtr image, StreamGetBytesDelegate getBytes,\n                StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close,\n                StreamSizeDelegate size, ref Guid encoderClsID, IntPtr encoderParameters);\n            private static FunctionWrapper<GdipSaveImageToDelegate_linux_delegate> GdipSaveImageToDelegate_linux_ptr;\n            internal static int GdipSaveImageToDelegate_linux(IntPtr image, StreamGetBytesDelegate getBytes,\n                StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close,\n                StreamSizeDelegate size, ref Guid encoderClsID, IntPtr encoderParameters)\n                => GdipSaveImageToDelegate_linux_ptr.Delegate(image, getBytes, putBytes, doSeek, close, size, ref encoderClsID, encoderParameters);\n\n            private delegate int GdipCreateMetafileFromDelegate_linux_delegate(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, out IntPtr metafile);\n            private static FunctionWrapper<GdipCreateMetafileFromDelegate_linux_delegate> GdipCreateMetafileFromDelegate_linux_ptr;\n            internal static int GdipCreateMetafileFromDelegate_linux(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, out IntPtr metafile)\n                => GdipCreateMetafileFromDelegate_linux_ptr.Delegate(getHeader, getBytes, putBytes, doSeek, close, size, out metafile);\n\n            private delegate int GdipGetMetafileHeaderFromDelegate_linux_delegate(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, IntPtr header);\n            private static FunctionWrapper<GdipGetMetafileHeaderFromDelegate_linux_delegate> GdipGetMetafileHeaderFromDelegate_linux_ptr;\n            internal static int GdipGetMetafileHeaderFromDelegate_linux(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, IntPtr header)\n                => GdipGetMetafileHeaderFromDelegate_linux_ptr.Delegate(getHeader, getBytes, putBytes, doSeek, close, size, header);\n\n            private delegate int GdipRecordMetafileFromDelegate_linux_delegate(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, IntPtr hdc, EmfType type, ref RectangleF frameRect,\n                MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)] string description, out IntPtr metafile);\n            private static FunctionWrapper<GdipRecordMetafileFromDelegate_linux_delegate> GdipRecordMetafileFromDelegate_linux_ptr;\n            internal static int GdipRecordMetafileFromDelegate_linux(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, IntPtr hdc, EmfType type, ref RectangleF frameRect,\n                MetafileFrameUnit frameUnit, string description, out IntPtr metafile)\n                => GdipRecordMetafileFromDelegate_linux_ptr.Delegate(getHeader, getBytes, putBytes, doSeek, close, size, hdc, type, ref frameRect, frameUnit, description, out metafile);\n\n            private delegate int GdipRecordMetafileFromDelegateI_linux_delegate(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, IntPtr hdc, EmfType type, ref Rectangle frameRect,\n                MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)] string description, out IntPtr metafile);\n            private static FunctionWrapper<GdipRecordMetafileFromDelegateI_linux_delegate> GdipRecordMetafileFromDelegateI_linux_ptr;\n            internal static int GdipRecordMetafileFromDelegateI_linux(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, IntPtr hdc, EmfType type, ref Rectangle frameRect,\n                MetafileFrameUnit frameUnit, string description, out IntPtr metafile)\n                => GdipRecordMetafileFromDelegateI_linux_ptr.Delegate(getHeader, getBytes, putBytes, doSeek, close, size, hdc, type, ref frameRect, frameUnit, description, out metafile);\n\n            private delegate int GdipGetPostScriptGraphicsContext_delegate(string filename, int width, int height, double dpix, double dpiy, ref IntPtr graphics);\n            private static FunctionWrapper<GdipGetPostScriptGraphicsContext_delegate> GdipGetPostScriptGraphicsContext_ptr;\n            internal static int GdipGetPostScriptGraphicsContext([MarshalAs(UnmanagedType.LPStr)]string filename, int width, int height, double dpix, double dpiy, ref IntPtr graphics)\n                => GdipGetPostScriptGraphicsContext_ptr.Delegate(filename, width, height, dpix, dpiy, ref graphics);\n\n            private delegate int GdipGetPostScriptSavePage_delegate(IntPtr graphics);\n            private static FunctionWrapper<GdipGetPostScriptSavePage_delegate> GdipGetPostScriptSavePage_ptr;\n            internal static int GdipGetPostScriptSavePage(IntPtr graphics) => GdipGetPostScriptSavePage_ptr.Delegate(graphics);\n        }\n    }\n\n    // These are unix-only\n    internal delegate int StreamGetHeaderDelegate(IntPtr buf, int bufsz);\n    internal delegate int StreamGetBytesDelegate(IntPtr buf, int bufsz, bool peek);\n    internal delegate long StreamSeekDelegate(int offset, int whence);\n    internal delegate int StreamPutBytesDelegate(IntPtr buf, int bufsz);\n    internal delegate void StreamCloseDelegate();\n    internal delegate long StreamSizeDelegate();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Drawing.Common/src/System/Drawing/Printing/LibcupsNative.cs": "\ufeff// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System.Runtime.InteropServices;\nusing System.Text;\n\nnamespace System.Drawing.Printing\n{\n    internal static class LibcupsNative\n    {\n        private const string LibraryName = \"libcups\";\n        private static IntPtr s_libcupsHandle = LoadLibcups();\n\n        private static IntPtr LoadLibcups()\n        {\n            // We allow both \"libcups.so\" and \"libcups.so.2\" to be loaded.\n            IntPtr lib = Interop.Libdl.dlopen(\"libcups.so\", Interop.Libdl.RTLD_NOW);\n            if (lib == IntPtr.Zero)\n            {\n                lib = Interop.Libdl.dlopen(\"libcups.so.2\", Interop.Libdl.RTLD_NOW);\n            }\n\n            return lib;\n        }\n\n        private delegate int cupsGetDests_delegate(ref IntPtr dests);\n        private static FunctionWrapper<cupsGetDests_delegate> cupsGetDests_ptr\n            = FunctionWrapper.Load<cupsGetDests_delegate>(s_libcupsHandle, \"cupsGetDests\", LibraryName);\n        internal static int cupsGetDests(ref IntPtr dests) => cupsGetDests_ptr.Delegate(ref dests);\n\n        private delegate int cupsFreeDests_delegate(int num_dests, IntPtr dests);\n        private static FunctionWrapper<cupsFreeDests_delegate> cupsFreeDests_ptr\n            = FunctionWrapper.Load<cupsFreeDests_delegate>(s_libcupsHandle, \"cupsFreeDests\", LibraryName);\n        internal static void cupsFreeDests(int num_dests, IntPtr dests) => cupsFreeDests_ptr.Delegate(num_dests, dests);\n\n        private delegate IntPtr cupsTempFd_delegate([MarshalAs(UnmanagedType.LPStr)]StringBuilder sb, int len);\n        private static FunctionWrapper<cupsTempFd_delegate> cupsTempFd_ptr\n            = FunctionWrapper.Load<cupsTempFd_delegate>(s_libcupsHandle, \"cupsTempFd\", LibraryName);\n        internal static IntPtr cupsTempFd(StringBuilder sb, int len) => cupsTempFd_ptr.Delegate(sb, len);\n\n        private delegate IntPtr cupsGetDefault_delegate();\n        private static FunctionWrapper<cupsGetDefault_delegate> cupsGetDefault_ptr\n            = FunctionWrapper.Load<cupsGetDefault_delegate>(s_libcupsHandle, \"cupsGetDefault\", LibraryName);\n        internal static IntPtr cupsGetDefault() => cupsGetDefault_ptr.Delegate();\n\n        private delegate int cupsPrintFile_delegate(\n            [MarshalAs(UnmanagedType.LPStr)]string printer,\n            [MarshalAs(UnmanagedType.LPStr)]string filename,\n            [MarshalAs(UnmanagedType.LPStr)]string title,\n            int num_options,\n            IntPtr options);\n        private static FunctionWrapper<cupsPrintFile_delegate> cupsPrintFile_ptr\n            = FunctionWrapper.Load<cupsPrintFile_delegate>(s_libcupsHandle, \"cupsPrintFile\", LibraryName);\n        internal static int cupsPrintFile(string printer, string filename, string title, int num_options, IntPtr options)\n            => cupsPrintFile_ptr.Delegate(printer, filename, title, num_options, options);\n\n        private delegate IntPtr cupsGetPPD_delegate([MarshalAs(UnmanagedType.LPStr)]string printer);\n        private static FunctionWrapper<cupsGetPPD_delegate> cupsGetPPD_ptr\n            = FunctionWrapper.Load<cupsGetPPD_delegate>(s_libcupsHandle, \"cupsGetPPD\", LibraryName);\n        internal static IntPtr cupsGetPPD(string printer) => cupsGetPPD_ptr.Delegate(printer);\n\n        private delegate IntPtr ppdOpenFile_delegate([MarshalAs(UnmanagedType.LPStr)]string filename);\n        private static FunctionWrapper<ppdOpenFile_delegate> ppdOpenFile_ptr\n            = FunctionWrapper.Load<ppdOpenFile_delegate>(s_libcupsHandle, \"ppdOpenFile\", LibraryName);\n        internal static IntPtr ppdOpenFile(string filename) => ppdOpenFile_ptr.Delegate(filename);\n\n        private delegate IntPtr ppdFindOption_delegate(IntPtr ppd_file, [MarshalAs(UnmanagedType.LPStr)]string keyword);\n        private static FunctionWrapper<ppdFindOption_delegate> ppdFindOption_ptr\n            = FunctionWrapper.Load<ppdFindOption_delegate>(s_libcupsHandle, \"ppdFindOption\", LibraryName);\n        internal static IntPtr ppdFindOption(IntPtr ppd_file, string keyword) => ppdFindOption_ptr.Delegate(ppd_file, keyword);\n\n        private delegate void ppdClose_delegate(IntPtr ppd);\n        private static FunctionWrapper<ppdClose_delegate> ppdClose_ptr\n            = FunctionWrapper.Load<ppdClose_delegate>(s_libcupsHandle, \"ppdClose\", LibraryName);\n        internal static void ppdClose(IntPtr ppd) => ppdClose_ptr.Delegate(ppd);\n\n        private delegate int cupsParseOptions_delegate([MarshalAs(UnmanagedType.LPStr)]string arg, int number_of_options, ref IntPtr options);\n        private static FunctionWrapper<cupsParseOptions_delegate> cupsParseOptions_ptr\n            = FunctionWrapper.Load<cupsParseOptions_delegate>(s_libcupsHandle, \"cupsParseOptions\", LibraryName);\n        internal static int cupsParseOptions(string arg, int number_of_options, ref IntPtr options)\n            => cupsParseOptions_ptr.Delegate(arg, number_of_options, ref options);\n\n        private delegate void cupsFreeOptions_delegate(int number_options, IntPtr options);\n        private static FunctionWrapper<cupsFreeOptions_delegate> cupsFreeOptions_ptr\n            = FunctionWrapper.Load<cupsFreeOptions_delegate>(s_libcupsHandle, \"cupsFreeOptions\", LibraryName);\n        internal static void cupsFreeOptions(int number_options, IntPtr options) => cupsFreeOptions_ptr.Delegate(number_options, options);\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Drawing.Common/tests/Helpers.cs": "\ufeff// Licensed to the .NET Foundation under one or more agreements.\n// See the LICENSE file in the project root for more information.\n\nusing System.Drawing.Printing;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing Xunit;\nusing Xunit.Sdk;\n\nnamespace System.Drawing\n{\n    public static class Helpers\n    {\n        public const string GdiplusIsAvailable = nameof(Helpers) + \".\" + nameof(GetGdiplusIsAvailable);\n        public const string RecentGdiplusIsAvailable = nameof(Helpers) + \".\" + nameof(GetRecentGdiPlusIsAvailable);\n        public const string RecentGdiplusIsAvailable2 = nameof(Helpers) + \".\" + nameof(GetRecentGdiPlusIsAvailable2);\n        public const string GdiPlusIsAvailableNotRedhat73 = nameof(Helpers) + \".\" + nameof(GetGdiPlusIsAvailableNotRedhat73);\n        public const string GdiPlusIsAvailableNotWindows7 = nameof(Helpers) + \".\" + nameof(GetGdiPlusIsAvailableNotWindows7);\n        public const string AnyInstalledPrinters = nameof(Helpers) + \".\" + nameof(IsAnyInstalledPrinters);\n\n        public static bool GetGdiplusIsAvailable()\n        {\n            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n            {\n                return PlatformDetection.IsNotWindowsNanoServer && PlatformDetection.IsNotWindowsServerCore;\n            }\n            else\n            {\n#if MONO\n                return true;\n#else\n                IntPtr nativeLib;\n                if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))\n                {\n                    nativeLib = dlopen(\"libgdiplus.dylib\", RTLD_NOW);\n                }\n                else\n                {\n                    nativeLib = dlopen(\"libgdiplus.so\", RTLD_NOW);\n                    if (nativeLib == IntPtr.Zero)\n                    {\n                        nativeLib = dlopen(\"libgdiplus.so.0\", RTLD_NOW);\n                    }\n                }\n\n                return nativeLib != IntPtr.Zero;\n#endif\n            }\n        }\n\n        public static bool GetRecentGdiPlusIsAvailable2()\n        {\n            // RedHat and Ubuntu 14.04, as well as Fedora 25 and OpenSUSE 4.22 are running outdated versions of libgdiplus\n            if (PlatformDetection.IsRedHatFamily || PlatformDetection.IsUbuntu1404 || PlatformDetection.IsFedora || PlatformDetection.IsOpenSUSE)\n            {\n                return false;\n            }\n\n            return GetGdiplusIsAvailable();\n        }\n\n        public static bool GetGdiPlusIsAvailableNotRedhat73()\n        {\n            if (PlatformDetection.IsRedHatFamily)\n            {\n                return false;\n            }\n\n            return GetGdiplusIsAvailable();\n        }\n\n        public static bool GetGdiPlusIsAvailableNotWindows7()\n        {\n            if (PlatformDetection.IsWindows7)\n            {\n                return false;\n            }\n\n            return GetGdiplusIsAvailable();\n        }\n\n        public static bool GetRecentGdiPlusIsAvailable()\n        {\n            // RedHat and Ubuntu 14.04 are running outdated versions of libgdiplus\n            if (PlatformDetection.IsRedHatFamily || PlatformDetection.IsUbuntu1404)\n            {\n                return false;\n            }\n\n            return GetGdiplusIsAvailable();\n        }\n\n        public static bool IsAnyInstalledPrinters()\n        {\n            return PrinterSettings.InstalledPrinters.Count > 0;\n        }\n\n        [DllImport(\"libdl\")]\n        private static extern IntPtr dlopen(string libName, int flags);\n        public const int RTLD_NOW = 0x002;\n\n        public static string GetTestBitmapPath(string fileName) => GetTestPath(\"bitmaps\", fileName);\n        public static string GetTestFontPath(string fileName) => GetTestPath(\"fonts\", fileName);\n        public static string GetTestColorProfilePath(string fileName) => GetTestPath(\"colorProfiles\", fileName);\n\n        private static string GetTestPath(string directoryName, string fileName) => Path.Combine(AppContext.BaseDirectory, directoryName, fileName);\n\n        public static void VerifyBitmap(Bitmap bitmap, Color[][] colors)\n        {\n            for (int y = 0; y < colors.Length; y++)\n            {\n                for (int x = 0; x < colors[y].Length; x++)\n                {\n                    Color expectedColor = Color.FromArgb(colors[y][x].ToArgb());\n                    Color actualColor = bitmap.GetPixel(x, y);\n\n                    if (expectedColor != actualColor)\n                    {\n                        throw GetBitmapEqualFailureException(bitmap, colors, x, y);\n                    }\n                }\n            }\n        }\n\n        private static Exception GetBitmapEqualFailureException(Bitmap bitmap, Color[][] colors, int firstFailureX, int firstFailureY)\n        {\n            // Print out the whole bitmap to provide a view of the whole image, rather than just the difference between\n            // a single pixel.\n            var actualStringBuilder = new StringBuilder();\n            var expectedStringBuilder = new StringBuilder();\n\n            actualStringBuilder.AppendLine();\n            expectedStringBuilder.AppendLine();\n\n            for (int y = 0; y < bitmap.Height; y++)\n            {\n                for (int x = 0; x < bitmap.Width; x++)\n                {\n                    PrintColor(actualStringBuilder, bitmap.GetPixel(x, y));\n                    PrintColor(expectedStringBuilder, colors[y][x]);\n                    if (x != bitmap.Width - 1)\n                    {\n                        actualStringBuilder.Append(\", \");\n                        expectedStringBuilder.Append(\", \");\n                    }\n                }\n                actualStringBuilder.AppendLine();\n                expectedStringBuilder.AppendLine();\n            }\n\n            return new AssertActualExpectedException(expectedStringBuilder.ToString(), actualStringBuilder.ToString(), $\"Bitmaps were different at {firstFailureX}, {firstFailureY}.\");\n        }\n\n        private static void PrintColor(StringBuilder stringBuilder, Color color)\n        {\n            stringBuilder.Append($\"Color.FromArgb({color.A}, {color.R}, {color.G}, {color.B})\");\n        }\n\n        public static Color EmptyColor => Color.FromArgb(0, 0, 0, 0);\n\n        private static Rectangle GetRectangle(RECT rect)\n        {\n            return new Rectangle(rect.Left, rect.Top, rect.Right - rect.Left, rect.Bottom - rect.Top);\n        }\n\n        private const int MONITOR_DEFAULTTOPRIMARY = 1;\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        private static extern IntPtr MonitorFromWindow(IntPtr hWnd, int dwFlags);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        private static extern int GetMonitorInfo(IntPtr hMonitor, ref MONITORINFO monitorInfo);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern IntPtr GetForegroundWindow();\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern IntPtr GetDC(IntPtr hWnd);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern IntPtr GetWindowDC(IntPtr hWnd);\n\n        public static Rectangle GetWindowDCRect(IntPtr hdc) => GetHWndRect(WindowFromDC(hdc));\n\n        public static Rectangle GetHWndRect(IntPtr hWnd)\n        {\n            if (hWnd == IntPtr.Zero)\n            {\n                return GetMonitorRectForWindow(hWnd);\n            }\n\n            var rect = new RECT();\n            GetClientRect(hWnd, ref rect);\n\n            return GetRectangle(rect);\n        }\n\n        private static Rectangle GetMonitorRectForWindow(IntPtr hWnd)\n        {\n            IntPtr hMonitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTOPRIMARY);\n            Assert.NotEqual(IntPtr.Zero, hMonitor);\n\n            var info = new MONITORINFO();\n            info.cbSize = Marshal.SizeOf(info);\n            int result = GetMonitorInfo(hMonitor, ref info);\n            Assert.NotEqual(0, result);\n\n            return GetRectangle(info.rcMonitor);\n        }\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        private static extern int GetClientRect(IntPtr hWnd, ref RECT lpRect);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        private static extern IntPtr WindowFromDC(IntPtr hdc);\n\n        [StructLayout(LayoutKind.Sequential)]\n        private struct MONITORINFO\n        {\n            public int cbSize;\n            public RECT rcMonitor;\n            public RECT rcWork;\n            public int dwFlags;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        private struct RECT\n        {\n            public int Left;\n            public int Top;\n            public int Right;\n            public int Bottom;\n        }\n\n        public static void VerifyBitmapNotBlank(Bitmap bmp)\n        {\n            Color emptyColor = Color.FromArgb(0);\n            for (int y = 0; y < bmp.Height; y++)\n            {\n                for (int x = 0; x < bmp.Width; x++)\n                {\n                    Color pixel = bmp.GetPixel(x, y);\n                    if (!pixel.Equals(emptyColor))\n                    {\n                        return;\n                    }\n                }\n            }\n\n            throw new XunitException(\"The entire image was blank.\");\n        }\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/unittests/Support/DynamicLibrary/DynamicLibraryTest.cpp": "//===- llvm/unittest/Support/DynamicLibrary/DynamicLibraryTest.cpp --------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Support/DynamicLibrary.h\"\n#include \"llvm/Config/config.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/ManagedStatic.h\"\n#include \"llvm/Support/Path.h\"\n#include \"gtest/gtest.h\"\n\n#include \"PipSqueak.h\"\n\nusing namespace llvm;\nusing namespace llvm::sys;\n\nstd::string LibPath(const std::string Name = \"PipSqueak\") {\n  const std::vector<testing::internal::string>& Argvs = testing::internal::GetArgvs();\n  const char *Argv0 = Argvs.size() > 0 ? Argvs[0].c_str() : \"DynamicLibraryTests\";\n  void *Ptr = (void*)(intptr_t)TestA;\n  std::string Path = fs::getMainExecutable(Argv0, Ptr);\n  llvm::SmallString<256> Buf(path::parent_path(Path));\n  path::append(Buf, (Name+\".so\").c_str());\n  return Buf.str();\n}\n\n#if defined(_WIN32) || (defined(HAVE_DLFCN_H) && defined(HAVE_DLOPEN))\n\ntypedef void (*SetStrings)(std::string &GStr, std::string &LStr);\ntypedef void (*TestOrder)(std::vector<std::string> &V);\ntypedef const char *(*GetString)();\n\ntemplate <class T> static T FuncPtr(void *Ptr) {\n  union {\n    T F;\n    void *P;\n  } Tmp;\n  Tmp.P = Ptr;\n  return Tmp.F;\n}\ntemplate <class T> static void* PtrFunc(T *Func) {\n  union {\n    T *F;\n    void *P;\n  } Tmp;\n  Tmp.F = Func;\n  return Tmp.P;\n}\n\nstatic const char *OverloadTestA() { return \"OverloadCall\"; }\n\nstd::string StdString(const char *Ptr) { return Ptr ? Ptr : \"\"; }\n\nTEST(DynamicLibrary, Overload) {\n  {\n    std::string Err;\n    llvm_shutdown_obj Shutdown;\n    DynamicLibrary DL =\n        DynamicLibrary::getPermanentLibrary(LibPath().c_str(), &Err);\n    EXPECT_TRUE(DL.isValid());\n    EXPECT_TRUE(Err.empty());\n\n    GetString GS = FuncPtr<GetString>(DL.getAddressOfSymbol(\"TestA\"));\n    EXPECT_TRUE(GS != nullptr && GS != &TestA);\n    EXPECT_EQ(StdString(GS()), \"LibCall\");\n\n    GS = FuncPtr<GetString>(DynamicLibrary::SearchForAddressOfSymbol(\"TestA\"));\n    EXPECT_TRUE(GS != nullptr && GS != &TestA);\n    EXPECT_EQ(StdString(GS()), \"LibCall\");\n\n    DL = DynamicLibrary::getPermanentLibrary(nullptr, &Err);\n    EXPECT_TRUE(DL.isValid());\n    EXPECT_TRUE(Err.empty());\n\n    // Test overloading local symbols does not occur by default\n    GS = FuncPtr<GetString>(DynamicLibrary::SearchForAddressOfSymbol(\"TestA\"));\n    EXPECT_TRUE(GS != nullptr && GS == &TestA);\n    EXPECT_EQ(StdString(GS()), \"ProcessCall\");\n\n    GS = FuncPtr<GetString>(DL.getAddressOfSymbol(\"TestA\"));\n    EXPECT_TRUE(GS != nullptr && GS == &TestA);\n    EXPECT_EQ(StdString(GS()), \"ProcessCall\");\n\n    // Test overloading by forcing library priority when searching for a symbol\n    DynamicLibrary::SearchOrder = DynamicLibrary::SO_LoadedFirst;\n    GS = FuncPtr<GetString>(DynamicLibrary::SearchForAddressOfSymbol(\"TestA\"));\n    EXPECT_TRUE(GS != nullptr && GS != &TestA);\n    EXPECT_EQ(StdString(GS()), \"LibCall\");\n\n    DynamicLibrary::AddSymbol(\"TestA\", PtrFunc(&OverloadTestA));\n    GS = FuncPtr<GetString>(DL.getAddressOfSymbol(\"TestA\"));\n    EXPECT_TRUE(GS != nullptr && GS != &OverloadTestA);\n\n    GS = FuncPtr<GetString>(DynamicLibrary::SearchForAddressOfSymbol(\"TestA\"));\n    EXPECT_TRUE(GS != nullptr && GS == &OverloadTestA);\n    EXPECT_EQ(StdString(GS()), \"OverloadCall\");\n  }\n  EXPECT_TRUE(FuncPtr<GetString>(DynamicLibrary::SearchForAddressOfSymbol(\n                  \"TestA\")) == nullptr);\n\n  // Check serach ordering is reset to default after call to llvm_shutdown\n  EXPECT_TRUE(DynamicLibrary::SearchOrder == DynamicLibrary::SO_Linker);\n}\n\nTEST(DynamicLibrary, Shutdown) {\n  std::string A(\"PipSqueak\"), B, C(\"SecondLib\");\n  std::vector<std::string> Order;\n  {\n    std::string Err;\n    llvm_shutdown_obj Shutdown;\n    DynamicLibrary DL =\n        DynamicLibrary::getPermanentLibrary(LibPath(A).c_str(), &Err);\n    EXPECT_TRUE(DL.isValid());\n    EXPECT_TRUE(Err.empty());\n\n    SetStrings SS_0 = FuncPtr<SetStrings>(\n        DynamicLibrary::SearchForAddressOfSymbol(\"SetStrings\"));\n    EXPECT_TRUE(SS_0 != nullptr);\n\n    SS_0(A, B);\n    EXPECT_EQ(B, \"Local::Local(PipSqueak)\");\n\n    TestOrder TO_0 = FuncPtr<TestOrder>(\n        DynamicLibrary::SearchForAddressOfSymbol(\"TestOrder\"));\n    EXPECT_TRUE(TO_0 != nullptr);\n    \n    DynamicLibrary DL2 =\n        DynamicLibrary::getPermanentLibrary(LibPath(C).c_str(), &Err);\n    EXPECT_TRUE(DL2.isValid());\n    EXPECT_TRUE(Err.empty());\n\n    // Should find latest version of symbols in SecondLib\n    SetStrings SS_1 = FuncPtr<SetStrings>(\n        DynamicLibrary::SearchForAddressOfSymbol(\"SetStrings\"));\n    EXPECT_TRUE(SS_1 != nullptr);\n    EXPECT_TRUE(SS_0 != SS_1);\n\n    TestOrder TO_1 = FuncPtr<TestOrder>(\n        DynamicLibrary::SearchForAddressOfSymbol(\"TestOrder\"));\n    EXPECT_TRUE(TO_1 != nullptr);\n    EXPECT_TRUE(TO_0 != TO_1);\n\n    B.clear();\n    SS_1(C, B);\n    EXPECT_EQ(B, \"Local::Local(SecondLib)\");\n\n    TO_0(Order);\n    TO_1(Order);\n  }\n  EXPECT_EQ(A, \"Global::~Global\");\n  EXPECT_EQ(B, \"Local::~Local\");\n  EXPECT_TRUE(FuncPtr<SetStrings>(DynamicLibrary::SearchForAddressOfSymbol(\n                  \"SetStrings\")) == nullptr);\n\n  // Test unload/destruction ordering\n  EXPECT_EQ(Order.size(), 2UL);\n  EXPECT_EQ(Order.front(), \"SecondLib\");\n  EXPECT_EQ(Order.back(), \"PipSqueak\");\n}\n\n#else\n\nTEST(DynamicLibrary, Unsupported) {\n  std::string Err;\n  DynamicLibrary DL =\n      DynamicLibrary::getPermanentLibrary(LibPath().c_str(), &Err);\n  EXPECT_FALSE(DL.isValid());\n  EXPECT_EQ(Err, \"dlopen() not supported on this platform\");\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c": "/*===-- jitprofiling.c - JIT (Just-In-Time) Profiling API----------*- C -*-===*\n *\n *                     The LLVM Compiler Infrastructure\n *\n * This file is distributed under the University of Illinois Open Source\n * License. See LICENSE.TXT for details.\n *\n *===----------------------------------------------------------------------===*\n *\n * This file provides Intel(R) Performance Analyzer JIT (Just-In-Time) \n * Profiling API implementation. \n *\n * NOTE: This file comes in a style different from the rest of LLVM\n * source base since  this is a piece of code shared from Intel(R)\n * products.  Please do not reformat / re-style this code to make\n * subsequent merges and contributions from the original source base eaiser.\n *\n *===----------------------------------------------------------------------===*/\n#include \"ittnotify_config.h\"\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <windows.h>\n#pragma optimize(\"\", off)\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <dlfcn.h>\n#include <pthread.h>\n#include <stdint.h>\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <malloc.h>\n#include <stdlib.h>\n\n#include \"jitprofiling.h\"\n\nstatic const char rcsid[] = \"\\n@(#) $Revision: 243501 $\\n\";\n\n#define DLL_ENVIRONMENT_VAR             \"VS_PROFILER\"\n\n#ifndef NEW_DLL_ENVIRONMENT_VAR\n#if ITT_ARCH==ITT_ARCH_IA32\n#define NEW_DLL_ENVIRONMENT_VAR\t        \"INTEL_JIT_PROFILER32\"\n#else\n#define NEW_DLL_ENVIRONMENT_VAR\t        \"INTEL_JIT_PROFILER64\"\n#endif\n#endif /* NEW_DLL_ENVIRONMENT_VAR */\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#define DEFAULT_DLLNAME                 \"JitPI.dll\"\nHINSTANCE m_libHandle = NULL;\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define DEFAULT_DLLNAME                 \"libJitPI.so\"\nvoid* m_libHandle = NULL;\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/* default location of JIT profiling agent on Android */\n#define ANDROID_JIT_AGENT_PATH  \"/data/intel/libittnotify.so\"\n\n/* the function pointers */\ntypedef unsigned int(*TPInitialize)(void);\nstatic TPInitialize FUNC_Initialize=NULL;\n\ntypedef unsigned int(*TPNotify)(unsigned int, void*);\nstatic TPNotify FUNC_NotifyEvent=NULL;\n\nstatic iJIT_IsProfilingActiveFlags executionMode = iJIT_NOTHING_RUNNING;\n\n/* end collector dll part. */\n\n/* loadiJIT_Funcs() : this function is called just in the beginning \n *  and is responsible to load the functions from BistroJavaCollector.dll\n * result:\n *  on success: the functions loads, iJIT_DLL_is_missing=0, return value = 1\n *  on failure: the functions are NULL, iJIT_DLL_is_missing=1, return value = 0\n */ \nstatic int loadiJIT_Funcs(void);\n\n/* global representing whether the BistroJavaCollector can't be loaded */\nstatic int iJIT_DLL_is_missing = 0;\n\n/* Virtual stack - the struct is used as a virtual stack for each thread.\n * Every thread initializes with a stack of size INIT_TOP_STACK.\n * Every method entry decreases from the current stack point,\n * and when a thread stack reaches its top of stack (return from the global \n * function), the top of stack and the current stack increase. Notice that \n * when returning from a function the stack pointer is the address of \n * the function return.\n*/\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\nstatic DWORD threadLocalStorageHandle = 0;\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nstatic pthread_key_t threadLocalStorageHandle = (pthread_key_t)0;\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#define INIT_TOP_Stack 10000\n\ntypedef struct \n{\n    unsigned int TopStack;\n    unsigned int CurrentStack;\n} ThreadStack, *pThreadStack;\n\n/* end of virtual stack. */\n\n/*\n * The function for reporting virtual-machine related events to VTune.\n * Note: when reporting iJVM_EVENT_TYPE_ENTER_NIDS, there is no need to fill \n * in the stack_id field in the iJIT_Method_NIDS structure, as VTune fills it.\n * The return value in iJVM_EVENT_TYPE_ENTER_NIDS && \n * iJVM_EVENT_TYPE_LEAVE_NIDS events will be 0 in case of failure.\n * in iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED event \n * it will be -1 if EventSpecificData == 0 otherwise it will be 0.\n*/\n\nITT_EXTERN_C int JITAPI \niJIT_NotifyEvent(iJIT_JVM_EVENT event_type, void *EventSpecificData)\n{\n    int ReturnValue;\n\n    /*\n     * This section is for debugging outside of VTune. \n     * It creates the environment variables that indicates call graph mode.\n     * If running outside of VTune remove the remark.\n     *\n     *\n     * static int firstTime = 1;\n     * char DoCallGraph[12] = \"DoCallGraph\";\n     * if (firstTime)\n     * {\n     * firstTime = 0;\n     * SetEnvironmentVariable( \"BISTRO_COLLECTORS_DO_CALLGRAPH\", DoCallGraph);\n     * }\n     *\n     * end of section.\n    */\n\n    /* initialization part - the functions have not been loaded yet. This part\n     *        will load the functions, and check if we are in Call Graph mode. \n     *        (for special treatment).\n     */\n    if (!FUNC_NotifyEvent) \n    {\n        if (iJIT_DLL_is_missing) \n            return 0;\n\n        /* load the Function from the DLL */\n        if (!loadiJIT_Funcs()) \n            return 0;\n\n        /* Call Graph initialization. */\n    }\n\n    /* If the event is method entry/exit, check that in the current mode \n     * VTune is allowed to receive it\n     */\n    if ((event_type == iJVM_EVENT_TYPE_ENTER_NIDS || \n         event_type == iJVM_EVENT_TYPE_LEAVE_NIDS) &&\n        (executionMode != iJIT_CALLGRAPH_ON))\n    {\n        return 0;\n    }\n    /* This section is performed when method enter event occurs.\n     * It updates the virtual stack, or creates it if this is the first \n     * method entry in the thread. The stack pointer is decreased.\n     */\n    if (event_type == iJVM_EVENT_TYPE_ENTER_NIDS)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        pThreadStack threadStack = \n            (pThreadStack)TlsGetValue (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pThreadStack threadStack = \n            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n        /* check for use of reserved method IDs */\n        if ( ((piJIT_Method_NIDS) EventSpecificData)->method_id <= 999 )\n            return 0;\n\n        if (!threadStack)\n        {\n            /* initialize the stack. */\n            threadStack = (pThreadStack) calloc (sizeof(ThreadStack), 1);\n            threadStack->TopStack = INIT_TOP_Stack;\n            threadStack->CurrentStack = INIT_TOP_Stack;\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n            TlsSetValue(threadLocalStorageHandle,(void*)threadStack);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n            pthread_setspecific(threadLocalStorageHandle,(void*)threadStack);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        }\n\n        /* decrease the stack. */\n        ((piJIT_Method_NIDS) EventSpecificData)->stack_id = \n            (threadStack->CurrentStack)--;\n    }\n\n    /* This section is performed when method leave event occurs\n     * It updates the virtual stack.\n     *    Increases the stack pointer.\n     *    If the stack pointer reached the top (left the global function)\n     *        increase the pointer and the top pointer.\n     */\n    if (event_type == iJVM_EVENT_TYPE_LEAVE_NIDS)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        pThreadStack threadStack = \n           (pThreadStack)TlsGetValue (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pThreadStack threadStack = \n            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n        /* check for use of reserved method IDs */\n        if ( ((piJIT_Method_NIDS) EventSpecificData)->method_id <= 999 )\n            return 0;\n\n        if (!threadStack)\n        {\n            /* Error: first report in this thread is method exit */\n            exit (1);\n        }\n\n        ((piJIT_Method_NIDS) EventSpecificData)->stack_id = \n            ++(threadStack->CurrentStack) + 1;\n\n        if (((piJIT_Method_NIDS) EventSpecificData)->stack_id \n               > threadStack->TopStack)\n            ((piJIT_Method_NIDS) EventSpecificData)->stack_id = \n                (unsigned int)-1;\n    }\n\n    if (event_type == iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED)\n    {\n        /* check for use of reserved method IDs */\n        if ( ((piJIT_Method_Load) EventSpecificData)->method_id <= 999 )\n            return 0;\n    }\n\n    ReturnValue = (int)FUNC_NotifyEvent(event_type, EventSpecificData);   \n\n    return ReturnValue;\n}\n\n/* The new mode call back routine */\nITT_EXTERN_C void JITAPI \niJIT_RegisterCallbackEx(void *userdata, iJIT_ModeChangedEx \n                        NewModeCallBackFuncEx) \n{\n    /* is it already missing... or the load of functions from the DLL failed */\n    if (iJIT_DLL_is_missing || !loadiJIT_Funcs())\n    {\n        /* then do not bother with notifications */\n        NewModeCallBackFuncEx(userdata, iJIT_NO_NOTIFICATIONS);  \n        /* Error: could not load JIT functions. */\n        return;\n    }\n    /* nothing to do with the callback */\n}\n\n/*\n * This function allows the user to query in which mode, if at all, \n *VTune is running\n */\nITT_EXTERN_C iJIT_IsProfilingActiveFlags JITAPI iJIT_IsProfilingActive()\n{\n    if (!iJIT_DLL_is_missing)\n    {\n        loadiJIT_Funcs();\n    }\n\n    return executionMode;\n}\n\n/* this function loads the collector dll (BistroJavaCollector) \n * and the relevant functions.\n * on success: all functions load,     iJIT_DLL_is_missing = 0, return value = 1\n * on failure: all functions are NULL, iJIT_DLL_is_missing = 1, return value = 0\n */ \nstatic int loadiJIT_Funcs()\n{\n    static int bDllWasLoaded = 0;\n    char *dllName = (char*)rcsid; /* !! Just to avoid unused code elimination */\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    DWORD dNameLength = 0;\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n    if(bDllWasLoaded)\n    {\n        /* dll was already loaded, no need to do it for the second time */\n        return 1;\n    }\n\n    /* Assumes that the DLL will not be found */\n    iJIT_DLL_is_missing = 1;\n    FUNC_NotifyEvent = NULL;\n\n    if (m_libHandle) \n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        FreeLibrary(m_libHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        dlclose(m_libHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        m_libHandle = NULL;\n    }\n\n    /* Try to get the dll name from the environment */\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    dNameLength = GetEnvironmentVariableA(NEW_DLL_ENVIRONMENT_VAR, NULL, 0);\n    if (dNameLength)\n    {\n        DWORD envret = 0;\n        dllName = (char*)malloc(sizeof(char) * (dNameLength + 1));\n        envret = GetEnvironmentVariableA(NEW_DLL_ENVIRONMENT_VAR, \n                                         dllName, dNameLength);\n        if (envret)\n        {\n            /* Try to load the dll from the PATH... */\n            m_libHandle = LoadLibraryExA(dllName, \n                                         NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n        }\n        free(dllName);\n    } else {\n        /* Try to use old VS_PROFILER variable */\n        dNameLength = GetEnvironmentVariableA(DLL_ENVIRONMENT_VAR, NULL, 0);\n        if (dNameLength)\n        {\n            DWORD envret = 0;\n            dllName = (char*)malloc(sizeof(char) * (dNameLength + 1));\n            envret = GetEnvironmentVariableA(DLL_ENVIRONMENT_VAR, \n                                             dllName, dNameLength);\n            if (envret)\n            {\n                /* Try to load the dll from the PATH... */\n                m_libHandle = LoadLibraryA(dllName);\n            }\n            free(dllName);\n        }\n    }\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    dllName = getenv(NEW_DLL_ENVIRONMENT_VAR);\n    if (!dllName)\n        dllName = getenv(DLL_ENVIRONMENT_VAR);\n#ifdef ANDROID\n    if (!dllName)\n        dllName = ANDROID_JIT_AGENT_PATH;\n#endif\n    if (dllName)\n    {\n        /* Try to load the dll from the PATH... */\n        m_libHandle = dlopen(dllName, RTLD_LAZY);\n    }\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n    if (!m_libHandle)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        m_libHandle = LoadLibraryA(DEFAULT_DLLNAME);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        m_libHandle = dlopen(DEFAULT_DLLNAME, RTLD_LAZY);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    }\n\n    /* if the dll wasn't loaded - exit. */\n    if (!m_libHandle)\n    {\n        iJIT_DLL_is_missing = 1; /* don't try to initialize \n                                  * JIT agent the second time \n                                  */\n        return 0;\n    }\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    FUNC_NotifyEvent = (TPNotify)GetProcAddress(m_libHandle, \"NotifyEvent\");\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    FUNC_NotifyEvent = (TPNotify)(intptr_t)dlsym(m_libHandle, \"NotifyEvent\");\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    if (!FUNC_NotifyEvent) \n    {\n        FUNC_Initialize = NULL;\n        return 0;\n    }\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    FUNC_Initialize = (TPInitialize)GetProcAddress(m_libHandle, \"Initialize\");\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    FUNC_Initialize = (TPInitialize)(intptr_t)dlsym(m_libHandle, \"Initialize\");\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    if (!FUNC_Initialize) \n    {\n        FUNC_NotifyEvent = NULL;\n        return 0;\n    }\n\n    executionMode = (iJIT_IsProfilingActiveFlags)FUNC_Initialize();\n\n    bDllWasLoaded = 1;\n    iJIT_DLL_is_missing = 0; /* DLL is ok. */\n\n    /*\n     * Call Graph mode: init the thread local storage\n     * (need to store the virtual stack there).\n     */\n    if ( executionMode == iJIT_CALLGRAPH_ON )\n    {\n        /* Allocate a thread local storage slot for the thread \"stack\" */\n        if (!threadLocalStorageHandle)\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n            threadLocalStorageHandle = TlsAlloc();\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pthread_key_create(&threadLocalStorageHandle, NULL);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    }\n\n    return 1;\n}\n\n/*\n * This function should be called by the user whenever a thread ends, \n * to free the thread \"virtual stack\" storage\n */\nITT_EXTERN_C void JITAPI FinalizeThread()\n{\n    if (threadLocalStorageHandle)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        pThreadStack threadStack = \n            (pThreadStack)TlsGetValue (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pThreadStack threadStack = \n            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        if (threadStack)\n        {\n            free (threadStack);\n            threadStack = NULL;\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n            TlsSetValue (threadLocalStorageHandle, threadStack);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n            pthread_setspecific(threadLocalStorageHandle, threadStack);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        }\n    }\n}\n\n/*\n * This function should be called by the user when the process ends, \n * to free the local storage index\n*/\nITT_EXTERN_C void JITAPI FinalizeProcess()\n{\n    if (m_libHandle) \n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        FreeLibrary(m_libHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        dlclose(m_libHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        m_libHandle = NULL;\n    }\n\n    if (threadLocalStorageHandle)\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        TlsFree (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    pthread_key_delete(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n}\n\n/*\n * This function should be called by the user for any method once.\n * The function will return a unique method ID, the user should maintain \n * the ID for each method\n */\nITT_EXTERN_C unsigned int JITAPI iJIT_GetNewMethodID()\n{\n    static unsigned int methodID = 0x100000;\n\n    if (methodID == 0)\n        return 0;  /* ERROR : this is not a valid value */\n\n    return methodID++;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h": "/*===-- ittnotify_config.h - JIT Profiling API internal config-----*- C -*-===*\n *\n *                     The LLVM Compiler Infrastructure\n *\n * This file is distributed under the University of Illinois Open Source\n * License. See LICENSE.TXT for details.\n *\n *===----------------------------------------------------------------------===*\n *\n * This file provides Intel(R) Performance Analyzer JIT (Just-In-Time) \n * Profiling API internal config.\n *\n * NOTE: This file comes in a style different from the rest of LLVM\n * source base since  this is a piece of code shared from Intel(R)\n * products.  Please do not reformat / re-style this code to make\n * subsequent merges and contributions from the original source base eaiser.\n *\n *===----------------------------------------------------------------------===*/\n#ifndef _ITTNOTIFY_CONFIG_H_\n#define _ITTNOTIFY_CONFIG_H_\n\n/** @cond exclude_from_documentation */\n#ifndef ITT_OS_WIN\n#  define ITT_OS_WIN   1\n#endif /* ITT_OS_WIN */\n\n#ifndef ITT_OS_LINUX\n#  define ITT_OS_LINUX 2\n#endif /* ITT_OS_LINUX */\n\n#ifndef ITT_OS_MAC\n#  define ITT_OS_MAC   3\n#endif /* ITT_OS_MAC */\n\n#ifndef ITT_OS\n#  if defined WIN32 || defined _WIN32\n#    define ITT_OS ITT_OS_WIN\n#  elif defined( __APPLE__ ) && defined( __MACH__ )\n#    define ITT_OS ITT_OS_MAC\n#  else\n#    define ITT_OS ITT_OS_LINUX\n#  endif\n#endif /* ITT_OS */\n\n#ifndef ITT_PLATFORM_WIN\n#  define ITT_PLATFORM_WIN 1\n#endif /* ITT_PLATFORM_WIN */\n\n#ifndef ITT_PLATFORM_POSIX\n#  define ITT_PLATFORM_POSIX 2\n#endif /* ITT_PLATFORM_POSIX */\n\n#ifndef ITT_PLATFORM\n#  if ITT_OS==ITT_OS_WIN\n#    define ITT_PLATFORM ITT_PLATFORM_WIN\n#  else\n#    define ITT_PLATFORM ITT_PLATFORM_POSIX\n#  endif /* _WIN32 */\n#endif /* ITT_PLATFORM */\n\n#if defined(_UNICODE) && !defined(UNICODE)\n#define UNICODE\n#endif\n\n#include <stddef.h>\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <tchar.h>\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <stdint.h>\n#if defined(UNICODE) || defined(_UNICODE)\n#include <wchar.h>\n#endif /* UNICODE || _UNICODE */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#ifndef CDECL\n#  if ITT_PLATFORM==ITT_PLATFORM_WIN\n#    define CDECL __cdecl\n#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#    if defined _M_X64 || defined _M_AMD64 || defined __x86_64__\n#      define CDECL /* not actual on x86_64 platform */\n#    else  /* _M_X64 || _M_AMD64 || __x86_64__ */\n#      define CDECL __attribute__ ((cdecl))\n#    endif /* _M_X64 || _M_AMD64 || __x86_64__ */\n#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* CDECL */\n\n#ifndef STDCALL\n#  if ITT_PLATFORM==ITT_PLATFORM_WIN\n#    define STDCALL __stdcall\n#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#    if defined _M_X64 || defined _M_AMD64 || defined __x86_64__\n#      define STDCALL /* not supported on x86_64 platform */\n#    else  /* _M_X64 || _M_AMD64 || __x86_64__ */\n#      define STDCALL __attribute__ ((stdcall))\n#    endif /* _M_X64 || _M_AMD64 || __x86_64__ */\n#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* STDCALL */\n\n#define ITTAPI    CDECL\n#define LIBITTAPI CDECL\n\n/* TODO: Temporary for compatibility! */\n#define ITTAPI_CALL    CDECL\n#define LIBITTAPI_CALL CDECL\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n/* use __forceinline (VC++ specific) */\n#define ITT_INLINE           __forceinline\n#define ITT_INLINE_ATTRIBUTE /* nothing */\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/*\n * Generally, functions are not inlined unless optimization is specified.\n * For functions declared inline, this attribute inlines the function even\n * if no optimization level was specified.\n */\n#ifdef __STRICT_ANSI__\n#define ITT_INLINE           static\n#else  /* __STRICT_ANSI__ */\n#define ITT_INLINE           static inline\n#endif /* __STRICT_ANSI__ */\n#define ITT_INLINE_ATTRIBUTE __attribute__ ((always_inline))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/** @endcond */\n\n#ifndef ITT_ARCH_IA32\n#  define ITT_ARCH_IA32  1\n#endif /* ITT_ARCH_IA32 */\n\n#ifndef ITT_ARCH_IA32E\n#  define ITT_ARCH_IA32E 2\n#endif /* ITT_ARCH_IA32E */\n\n#ifndef ITT_ARCH_IA64\n#  define ITT_ARCH_IA64  3\n#endif /* ITT_ARCH_IA64 */\n\n#ifndef ITT_ARCH\n#  if defined _M_X64 || defined _M_AMD64 || defined __x86_64__\n#    define ITT_ARCH ITT_ARCH_IA32E\n#  elif defined _M_IA64 || defined __ia64\n#    define ITT_ARCH ITT_ARCH_IA64\n#  else\n#    define ITT_ARCH ITT_ARCH_IA32\n#  endif\n#endif\n\n#ifdef __cplusplus\n#  define ITT_EXTERN_C extern \"C\"\n#else\n#  define ITT_EXTERN_C /* nothing */\n#endif /* __cplusplus */\n\n#define ITT_TO_STR_AUX(x) #x\n#define ITT_TO_STR(x)     ITT_TO_STR_AUX(x)\n\n#define __ITT_BUILD_ASSERT(expr, suffix) do { \\\n    static char __itt_build_check_##suffix[(expr) ? 1 : -1]; \\\n    __itt_build_check_##suffix[0] = 0; \\\n} while(0)\n#define _ITT_BUILD_ASSERT(expr, suffix)  __ITT_BUILD_ASSERT((expr), suffix)\n#define ITT_BUILD_ASSERT(expr)           _ITT_BUILD_ASSERT((expr), __LINE__)\n\n#define ITT_MAGIC { 0xED, 0xAB, 0xAB, 0xEC, 0x0D, 0xEE, 0xDA, 0x30 }\n\n/* Replace with snapshot date YYYYMMDD for promotion build. */\n#define API_VERSION_BUILD    20111111\n\n#ifndef API_VERSION_NUM\n#define API_VERSION_NUM 0.0.0\n#endif /* API_VERSION_NUM */\n\n#define API_VERSION \"ITT-API-Version \" ITT_TO_STR(API_VERSION_NUM) \\\n                                \" (\" ITT_TO_STR(API_VERSION_BUILD) \")\"\n\n/* OS communication functions */\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <windows.h>\ntypedef HMODULE           lib_t;\ntypedef DWORD             TIDT;\ntypedef CRITICAL_SECTION  mutex_t;\n#define MUTEX_INITIALIZER { 0 }\n#define strong_alias(name, aliasname) /* empty for Windows */\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <dlfcn.h>\n#if defined(UNICODE) || defined(_UNICODE)\n#include <wchar.h>\n#endif /* UNICODE */\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE 1 /* need for PTHREAD_MUTEX_RECURSIVE */\n#endif /* _GNU_SOURCE */\n#include <pthread.h>\ntypedef void*             lib_t;\ntypedef pthread_t         TIDT;\ntypedef pthread_mutex_t   mutex_t;\n#define MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER\n#define _strong_alias(name, aliasname) \\\n            extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n#define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#define __itt_get_proc(lib, name) GetProcAddress(lib, name)\n#define __itt_mutex_init(mutex)   InitializeCriticalSection(mutex)\n#define __itt_mutex_lock(mutex)   EnterCriticalSection(mutex)\n#define __itt_mutex_unlock(mutex) LeaveCriticalSection(mutex)\n#define __itt_load_lib(name)      LoadLibraryA(name)\n#define __itt_unload_lib(handle)  FreeLibrary(handle)\n#define __itt_system_error()      (int)GetLastError()\n#define __itt_fstrcmp(s1, s2)     lstrcmpA(s1, s2)\n#define __itt_fstrlen(s)          lstrlenA(s)\n#define __itt_fstrcpyn(s1, s2, l) lstrcpynA(s1, s2, l)\n#define __itt_fstrdup(s)          _strdup(s)\n#define __itt_thread_id()         GetCurrentThreadId()\n#define __itt_thread_yield()      SwitchToThread()\n#ifndef ITT_SIMPLE_INIT\nITT_INLINE long \n__itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __itt_interlocked_increment(volatile long* ptr)\n{\n    return InterlockedIncrement(ptr);\n}\n#endif /* ITT_SIMPLE_INIT */\n#else /* ITT_PLATFORM!=ITT_PLATFORM_WIN */\n#define __itt_get_proc(lib, name) dlsym(lib, name)\n#define __itt_mutex_init(mutex)   {\\\n    pthread_mutexattr_t mutex_attr;                                         \\\n    int error_code = pthread_mutexattr_init(&mutex_attr);                   \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_init\",    \\\n                           error_code);                                     \\\n    error_code = pthread_mutexattr_settype(&mutex_attr,                     \\\n                                           PTHREAD_MUTEX_RECURSIVE);        \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_settype\", \\\n                           error_code);                                     \\\n    error_code = pthread_mutex_init(mutex, &mutex_attr);                    \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutex_init\",        \\\n                           error_code);                                     \\\n    error_code = pthread_mutexattr_destroy(&mutex_attr);                    \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_destroy\", \\\n                           error_code);                                     \\\n}\n#define __itt_mutex_lock(mutex)   pthread_mutex_lock(mutex)\n#define __itt_mutex_unlock(mutex) pthread_mutex_unlock(mutex)\n#define __itt_load_lib(name)      dlopen(name, RTLD_LAZY)\n#define __itt_unload_lib(handle)  dlclose(handle)\n#define __itt_system_error()      errno\n#define __itt_fstrcmp(s1, s2)     strcmp(s1, s2)\n#define __itt_fstrlen(s)          strlen(s)\n#define __itt_fstrcpyn(s1, s2, l) strncpy(s1, s2, l)\n#define __itt_fstrdup(s)          strdup(s)\n#define __itt_thread_id()         pthread_self()\n#define __itt_thread_yield()      sched_yield()\n#if ITT_ARCH==ITT_ARCH_IA64\n#ifdef __INTEL_COMPILER\n#define __TBB_machine_fetchadd4(addr, val) __fetchadd4_acq((void *)addr, val)\n#else  /* __INTEL_COMPILER */\n/* TODO: Add Support for not Intel compilers for IA64 */\n#endif /* __INTEL_COMPILER */\n#else /* ITT_ARCH!=ITT_ARCH_IA64 */\nITT_INLINE long\n__TBB_machine_fetchadd4(volatile void* ptr, long addend) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __TBB_machine_fetchadd4(volatile void* ptr, long addend)\n{\n    long result;\n    __asm__ __volatile__(\"lock\\nxadd %0,%1\"\n                          : \"=r\"(result),\"=m\"(*(long*)ptr)\n                          : \"0\"(addend), \"m\"(*(long*)ptr)\n                          : \"memory\");\n    return result;\n}\n#endif /* ITT_ARCH==ITT_ARCH_IA64 */\n#ifndef ITT_SIMPLE_INIT\nITT_INLINE long \n__itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __itt_interlocked_increment(volatile long* ptr)\n{\n    return __TBB_machine_fetchadd4(ptr, 1) + 1L;\n}\n#endif /* ITT_SIMPLE_INIT */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\ntypedef enum {\n    __itt_collection_normal = 0,\n    __itt_collection_paused = 1\n} __itt_collection_state;\n\ntypedef enum {\n    __itt_thread_normal  = 0,\n    __itt_thread_ignored = 1\n} __itt_thread_state;\n\n#pragma pack(push, 8)\n\ntypedef struct ___itt_thread_info\n{\n    const char* nameA; /*!< Copy of original name in ASCII. */\n#if defined(UNICODE) || defined(_UNICODE)\n    const wchar_t* nameW; /*!< Copy of original name in UNICODE. */\n#else  /* UNICODE || _UNICODE */\n    void* nameW;\n#endif /* UNICODE || _UNICODE */\n    TIDT               tid;\n    __itt_thread_state state;   /*!< Thread state (paused or normal) */\n    int                extra1;  /*!< Reserved to the runtime */\n    void*              extra2;  /*!< Reserved to the runtime */\n    struct ___itt_thread_info* next;\n} __itt_thread_info;\n\n#include \"ittnotify_types.h\" /* For __itt_group_id definition */\n\ntypedef struct ___itt_api_info_20101001\n{\n    const char*    name;\n    void**         func_ptr;\n    void*          init_func;\n    __itt_group_id group;\n}  __itt_api_info_20101001;\n\ntypedef struct ___itt_api_info\n{\n    const char*    name;\n    void**         func_ptr;\n    void*          init_func;\n    void*          null_func;\n    __itt_group_id group;\n}  __itt_api_info;\n\nstruct ___itt_domain;\nstruct ___itt_string_handle;\n\ntypedef struct ___itt_global\n{\n    unsigned char          magic[8];\n    unsigned long          version_major;\n    unsigned long          version_minor;\n    unsigned long          version_build;\n    volatile long          api_initialized;\n    volatile long          mutex_initialized;\n    volatile long          atomic_counter;\n    mutex_t                mutex;\n    lib_t                  lib;\n    void*                  error_handler;\n    const char**           dll_path_ptr;\n    __itt_api_info*        api_list_ptr;\n    struct ___itt_global*  next;\n    /* Joinable structures below */\n    __itt_thread_info*     thread_list;\n    struct ___itt_domain*  domain_list;\n    struct ___itt_string_handle* string_list;\n    __itt_collection_state state;\n} __itt_global;\n\n#pragma pack(pop)\n\n#define NEW_THREAD_INFO_W(gptr,h,h_tail,t,s,n) { \\\n    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \\\n    if (h != NULL) { \\\n        h->tid    = t; \\\n        h->nameA  = NULL; \\\n        h->nameW  = n ? _wcsdup(n) : NULL; \\\n        h->state  = s; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->thread_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_THREAD_INFO_A(gptr,h,h_tail,t,s,n) { \\\n    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \\\n    if (h != NULL) { \\\n        h->tid    = t; \\\n        h->nameA  = n ? __itt_fstrdup(n) : NULL; \\\n        h->nameW  = NULL; \\\n        h->state  = s; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->thread_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_DOMAIN_W(gptr,h,h_tail,name) { \\\n    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \\\n    if (h != NULL) { \\\n        h->flags  = 0;    /* domain is disabled by default */ \\\n        h->nameA  = NULL; \\\n        h->nameW  = name ? _wcsdup(name) : NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->domain_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_DOMAIN_A(gptr,h,h_tail,name) { \\\n    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \\\n    if (h != NULL) { \\\n        h->flags  = 0;    /* domain is disabled by default */ \\\n        h->nameA  = name ? __itt_fstrdup(name) : NULL; \\\n        h->nameW  = NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->domain_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_STRING_HANDLE_W(gptr,h,h_tail,name) { \\\n    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \\\n    if (h != NULL) { \\\n        h->strA   = NULL; \\\n        h->strW   = name ? _wcsdup(name) : NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->string_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_STRING_HANDLE_A(gptr,h,h_tail,name) { \\\n    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \\\n    if (h != NULL) { \\\n        h->strA   = name ? __itt_fstrdup(name) : NULL; \\\n        h->strW   = NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->string_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#endif /* _ITTNOTIFY_CONFIG_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/lib/Support/Windows/DynamicLibrary.inc": "//===- Win32/DynamicLibrary.cpp - Win32 DL Implementation -------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides the Win32 specific implementation of DynamicLibrary.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"WindowsSupport.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\n#include <psapi.h>\n\n//===----------------------------------------------------------------------===//\n//=== WARNING: Implementation here must contain only Win32 specific code\n//===          and must not be UNIX code.\n//===----------------------------------------------------------------------===//\n\n\nDynamicLibrary::HandleSet::~HandleSet() {\n  for (void *Handle : llvm::reverse(Handles))\n    FreeLibrary(HMODULE(Handle));\n\n  // 'Process' should not be released on Windows.\n  assert((!Process || Process==this) && \"Bad Handle\");\n  // llvm_shutdown called, Return to default\n  DynamicLibrary::SearchOrder = DynamicLibrary::SO_Linker;\n}\n\nvoid *DynamicLibrary::HandleSet::DLOpen(const char *File, std::string *Err) {\n  // Create the instance and return it to be the *Process* handle\n  // simillar to dlopen(NULL, RTLD_LAZY|RTLD_GLOBAL)\n  if (!File)\n    return &(*OpenedHandles);\n\n  SmallVector<wchar_t, MAX_PATH> FileUnicode;\n  if (std::error_code ec = windows::UTF8ToUTF16(File, FileUnicode)) {\n    SetLastError(ec.value());\n    MakeErrMsg(Err, std::string(File) + \": Can't convert to UTF-16\");\n    return &DynamicLibrary::Invalid;\n  }\n\n  HMODULE Handle = LoadLibraryW(FileUnicode.data());\n  if (Handle == NULL) {\n    MakeErrMsg(Err, std::string(File) + \": Can't open\");\n    return &DynamicLibrary::Invalid;\n  }\n\n  return reinterpret_cast<void*>(Handle);\n}\n\nstatic DynamicLibrary::HandleSet *IsOpenedHandlesInstance(void *Handle) {\n  if (!OpenedHandles.isConstructed())\n    return nullptr;\n  DynamicLibrary::HandleSet &Inst = *OpenedHandles;\n  return Handle == &Inst ? &Inst : nullptr;\n}\n\nvoid DynamicLibrary::HandleSet::DLClose(void *Handle) {\n  if (HandleSet* HS = IsOpenedHandlesInstance(Handle))\n    HS->Process = nullptr; // Just drop the *Process* handle.\n  else\n    FreeLibrary((HMODULE)Handle);\n}\n\nstatic bool GetProcessModules(HANDLE H, DWORD &Bytes, HMODULE *Data = nullptr) {\n  // EnumProcessModules will fail on Windows 64 while some versions of\n  // MingW-32 don't have EnumProcessModulesEx.\n  if (\n#ifdef _WIN64\n      !EnumProcessModulesEx(H, Data, Bytes, &Bytes, LIST_MODULES_64BIT)\n#else\n      !EnumProcessModules(H, Data, Bytes, &Bytes)\n#endif\n     ) {\n    std::string Err;\n    if (MakeErrMsg(&Err, \"EnumProcessModules failure\"))\n      llvm::errs() << Err << \"\\n\";\n    return false;\n  }\n  return true;\n}\n\nvoid *DynamicLibrary::HandleSet::DLSym(void *Handle, const char *Symbol) {\n  HandleSet* HS = IsOpenedHandlesInstance(Handle);\n  if (!HS)\n    return (void *)uintptr_t(GetProcAddress((HMODULE)Handle, Symbol));\n\n  // Could have done a dlclose on the *Process* handle\n  if (!HS->Process)\n    return nullptr;\n\n  // Trials indicate EnumProcessModulesEx is consistantly faster than using\n  // EnumerateLoadedModules64 or CreateToolhelp32Snapshot.\n  //\n  // | Handles | DbgHelp.dll | CreateSnapshot | EnumProcessModulesEx\n  // |=========|=============|========================================\n  // | 37      | 0.0000585 * | 0.0003031      | 0.0000152\n  // | 1020    | 0.0026310 * | 0.0121598      | 0.0002683\n  // | 2084    | 0.0149418 * | 0.0369936      | 0.0005610\n  //\n  // * Not including the load time of Dbghelp.dll (~.005 sec)\n  //\n  // There's still a case to somehow cache the result of EnumProcessModulesEx\n  // across invocations, but the complication of doing that properly...\n  // Possibly using LdrRegisterDllNotification to invalidate the cache?\n\n  DWORD Bytes = 0;\n  HMODULE Self = HMODULE(GetCurrentProcess());\n  if (!GetProcessModules(Self, Bytes))\n    return nullptr;\n\n  // Get the most recent list in case any modules added/removed between calls\n  // to EnumProcessModulesEx that gets the amount of, then copies the HMODULES.\n  // MSDN is pretty clear that if the module list changes during the call to\n  // EnumProcessModulesEx the results should not be used.\n  std::vector<HMODULE> Handles;\n  do {\n    assert(Bytes && ((Bytes % sizeof(HMODULE)) == 0) &&\n           \"Should have at least one module and be aligned\");\n    Handles.resize(Bytes / sizeof(HMODULE));\n    if (!GetProcessModules(Self, Bytes, Handles.data()))\n      return nullptr;\n  } while (Bytes != (Handles.size() * sizeof(HMODULE)));\n\n  // Try EXE first, mirroring what dlsym(dlopen(NULL)) does.\n  if (FARPROC Ptr = GetProcAddress(HMODULE(Handles.front()), Symbol))\n    return (void *) uintptr_t(Ptr);\n\n  if (Handles.size() > 1) {\n    // This is different behaviour than what Posix dlsym(dlopen(NULL)) does.\n    // Doing that here is causing real problems for the JIT where msvc.dll\n    // and ucrt.dll can define the same symbols. The runtime linker will choose\n    // symbols from ucrt.dll first, but iterating NOT in reverse here would\n    // mean that the msvc.dll versions would be returned.\n\n    for (auto I = Handles.rbegin(), E = Handles.rend()-1; I != E; ++I) {\n      if (FARPROC Ptr = GetProcAddress(HMODULE(*I), Symbol))\n        return (void *) uintptr_t(Ptr);\n    }\n  }\n  return nullptr;\n}\n\n\n// Stack probing routines are in the support library (e.g. libgcc), but we don't\n// have dynamic linking on windows. Provide a hook.\n#define EXPLICIT_SYMBOL(SYM)                    \\\n  extern \"C\" { extern void *SYM; }\n#define EXPLICIT_SYMBOL2(SYMFROM, SYMTO) EXPLICIT_SYMBOL(SYMTO)\n\n#ifdef _M_IX86\n// Win32 on x86 implements certain single-precision math functions as macros.\n// These functions are not exported by the DLL, but will still be needed\n// for symbol-resolution by the JIT loader. Therefore, this Support libray\n// provides helper functions with the same implementation.\n\n#define INLINE_DEF_SYMBOL1(TYP, SYM)                                           \\\n  extern \"C\" TYP inline_##SYM(TYP _X) { return SYM(_X); }\n#define INLINE_DEF_SYMBOL2(TYP, SYM)                                           \\\n  extern \"C\" TYP inline_##SYM(TYP _X, TYP _Y) { return SYM(_X, _Y); }\n#endif\n\n#include \"explicit_symbols.inc\"\n\n#undef EXPLICIT_SYMBOL\n#undef EXPLICIT_SYMBOL2\n#undef INLINE_DEF_SYMBOL1\n#undef INLINE_DEF_SYMBOL2\n\nstatic void *DoSearch(const char *SymbolName) {\n\n#define EXPLICIT_SYMBOL(SYM)                                                   \\\n  if (!strcmp(SymbolName, #SYM))                                               \\\n    return (void *)&SYM;\n#define EXPLICIT_SYMBOL2(SYMFROM, SYMTO)                                       \\\n  if (!strcmp(SymbolName, #SYMFROM))                                           \\\n    return (void *)&SYMTO;\n\n#ifdef _M_IX86\n#define INLINE_DEF_SYMBOL1(TYP, SYM)                                           \\\n  if (!strcmp(SymbolName, #SYM))                                               \\\n    return (void *)&inline_##SYM;\n#define INLINE_DEF_SYMBOL2(TYP, SYM) INLINE_DEF_SYMBOL1(TYP, SYM)\n#endif\n\n  {\n#include \"explicit_symbols.inc\"\n  }\n\n#undef EXPLICIT_SYMBOL\n#undef EXPLICIT_SYMBOL2\n#undef INLINE_DEF_SYMBOL1\n#undef INLINE_DEF_SYMBOL2\n\n  return nullptr;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/lib/Support/Unix/DynamicLibrary.inc": "//===- Unix/DynamicLibrary.cpp - Unix DL Implementation ---------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides the UNIX specific implementation of DynamicLibrary.\n//\n//===----------------------------------------------------------------------===//\n\n#if defined(HAVE_DLFCN_H) && defined(HAVE_DLOPEN)\n#include <dlfcn.h>\n\nDynamicLibrary::HandleSet::~HandleSet() {\n  // Close the libraries in reverse order.\n  for (void *Handle : llvm::reverse(Handles))\n    ::dlclose(Handle);\n  if (Process)\n    ::dlclose(Process);\n\n  // llvm_shutdown called, Return to default\n  DynamicLibrary::SearchOrder = DynamicLibrary::SO_Linker;\n}\n\nvoid *DynamicLibrary::HandleSet::DLOpen(const char *File, std::string *Err) {\n  void *Handle = ::dlopen(File, RTLD_LAZY|RTLD_GLOBAL);\n  if (!Handle) {\n    if (Err) *Err = ::dlerror();\n    return &DynamicLibrary::Invalid;\n  }\n\n#ifdef __CYGWIN__\n  // Cygwin searches symbols only in the main\n  // with the handle of dlopen(NULL, RTLD_GLOBAL).\n  if (!File)\n    Handle = RTLD_DEFAULT;\n#endif\n\n  return Handle;\n}\n\nvoid DynamicLibrary::HandleSet::DLClose(void *Handle) {\n  ::dlclose(Handle);\n}\n\nvoid *DynamicLibrary::HandleSet::DLSym(void *Handle, const char *Symbol) {\n  return ::dlsym(Handle, Symbol);\n}\n\n#else // !HAVE_DLOPEN\n\nDynamicLibrary::HandleSet::~HandleSet() {}\n\nvoid *DynamicLibrary::HandleSet::DLOpen(const char *File, std::string *Err) {\n  if (Err) *Err = \"dlopen() not supported on this platform\";\n  return &Invalid;\n}\n\nvoid DynamicLibrary::HandleSet::DLClose(void *Handle) {\n}\n\nvoid *DynamicLibrary::HandleSet::DLSym(void *Handle, const char *Symbol) {\n  return nullptr;\n}\n\n#endif\n\n// Must declare the symbols in the global namespace.\nstatic void *DoSearch(const char* SymbolName) {\n#define EXPLICIT_SYMBOL(SYM) \\\n   extern void *SYM; if (!strcmp(SymbolName, #SYM)) return (void*)&SYM\n\n  // If this is darwin, it has some funky issues, try to solve them here.  Some\n  // important symbols are marked 'private external' which doesn't allow\n  // SearchForAddressOfSymbol to find them.  As such, we special case them here,\n  // there is only a small handful of them.\n\n#ifdef __APPLE__\n  {\n    // __eprintf is sometimes used for assert() handling on x86.\n    //\n    // FIXME: Currently disabled when using Clang, as we don't always have our\n    // runtime support libraries available.\n#ifndef __clang__\n#ifdef __i386__\n    EXPLICIT_SYMBOL(__eprintf);\n#endif\n#endif\n  }\n#endif\n\n#ifdef __CYGWIN__\n  {\n    EXPLICIT_SYMBOL(_alloca);\n    EXPLICIT_SYMBOL(__main);\n  }\n#endif\n\n#undef EXPLICIT_SYMBOL\n\n// This macro returns the address of a well-known, explicit symbol\n#define EXPLICIT_SYMBOL(SYM) \\\n   if (!strcmp(SymbolName, #SYM)) return &SYM\n\n// Under glibc we have a weird situation. The stderr/out/in symbols are both\n// macros and global variables because of standards requirements. So, we\n// boldly use the EXPLICIT_SYMBOL macro without checking for a #define first.\n#if defined(__GLIBC__)\n  {\n    EXPLICIT_SYMBOL(stderr);\n    EXPLICIT_SYMBOL(stdout);\n    EXPLICIT_SYMBOL(stdin);\n  }\n#else\n  // For everything else, we want to check to make sure the symbol isn't defined\n  // as a macro before using EXPLICIT_SYMBOL.\n  {\n#ifndef stdin\n    EXPLICIT_SYMBOL(stdin);\n#endif\n#ifndef stdout\n    EXPLICIT_SYMBOL(stdout);\n#endif\n#ifndef stderr\n    EXPLICIT_SYMBOL(stderr);\n#endif\n  }\n#endif\n#undef EXPLICIT_SYMBOL\n\n  return nullptr;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/include/llvm/Config/config.h.cmake": "#ifndef CONFIG_H\n#define CONFIG_H\n\n/* Exported configuration */\n#include \"llvm/Config/llvm-config.h\"\n\n/* Bug report URL. */\n#define BUG_REPORT_URL \"${BUG_REPORT_URL}\"\n\n/* Define to 1 to enable backtraces, and to 0 otherwise. */\n#cmakedefine01 ENABLE_BACKTRACES\n\n/* Define to 1 to enable crash overrides, and to 0 otherwise. */\n#cmakedefine01 ENABLE_CRASH_OVERRIDES\n\n/* Define to 1 if you have the `backtrace' function. */\n#cmakedefine HAVE_BACKTRACE ${HAVE_BACKTRACE}\n\n#define BACKTRACE_HEADER <${BACKTRACE_HEADER}>\n\n/* Define to 1 if you have the <CrashReporterClient.h> header file. */\n#cmakedefine HAVE_CRASHREPORTERCLIENT_H\n\n/* can use __crashreporter_info__ */\n#cmakedefine01 HAVE_CRASHREPORTER_INFO\n\n/* Define to 1 if you have the declaration of `arc4random', and to 0 if you\n   don't. */\n#cmakedefine01 HAVE_DECL_ARC4RANDOM\n\n/* Define to 1 if you have the declaration of `FE_ALL_EXCEPT', and to 0 if you\n   don't. */\n#cmakedefine01 HAVE_DECL_FE_ALL_EXCEPT\n\n/* Define to 1 if you have the declaration of `FE_INEXACT', and to 0 if you\n   don't. */\n#cmakedefine01 HAVE_DECL_FE_INEXACT\n\n/* Define to 1 if you have the declaration of `strerror_s', and to 0 if you\n   don't. */\n#cmakedefine01 HAVE_DECL_STRERROR_S\n\n/* Define to 1 if you have the DIA SDK installed, and to 0 if you don't. */\n#cmakedefine01 LLVM_ENABLE_DIA_SDK\n\n/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.\n   */\n#cmakedefine HAVE_DIRENT_H ${HAVE_DIRENT_H}\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#cmakedefine HAVE_DLFCN_H ${HAVE_DLFCN_H}\n\n/* Define if dlopen() is available on this platform. */\n#cmakedefine HAVE_DLOPEN ${HAVE_DLOPEN}\n\n/* Define if dladdr() is available on this platform. */\n#cmakedefine HAVE_DLADDR ${HAVE_DLADDR}\n\n/* Define to 1 if you have the <errno.h> header file. */\n#cmakedefine HAVE_ERRNO_H ${HAVE_ERRNO_H}\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n#cmakedefine HAVE_FCNTL_H ${HAVE_FCNTL_H}\n\n/* Define to 1 if you have the <fenv.h> header file. */\n#cmakedefine HAVE_FENV_H ${HAVE_FENV_H}\n\n/* Define if libffi is available on this platform. */\n#cmakedefine HAVE_FFI_CALL ${HAVE_FFI_CALL}\n\n/* Define to 1 if you have the <ffi/ffi.h> header file. */\n#cmakedefine HAVE_FFI_FFI_H ${HAVE_FFI_FFI_H}\n\n/* Define to 1 if you have the <ffi.h> header file. */\n#cmakedefine HAVE_FFI_H ${HAVE_FFI_H}\n\n/* Define to 1 if you have the `futimens' function. */\n#cmakedefine HAVE_FUTIMENS ${HAVE_FUTIMENS}\n\n/* Define to 1 if you have the `futimes' function. */\n#cmakedefine HAVE_FUTIMES ${HAVE_FUTIMES}\n\n/* Define to 1 if you have the `getcwd' function. */\n#cmakedefine HAVE_GETCWD ${HAVE_GETCWD}\n\n/* Define to 1 if you have the `getpagesize' function. */\n#cmakedefine HAVE_GETPAGESIZE ${HAVE_GETPAGESIZE}\n\n/* Define to 1 if you have the `getrlimit' function. */\n#cmakedefine HAVE_GETRLIMIT ${HAVE_GETRLIMIT}\n\n/* Define to 1 if you have the `getrusage' function. */\n#cmakedefine HAVE_GETRUSAGE ${HAVE_GETRUSAGE}\n\n/* Define to 1 if you have the `gettimeofday' function. */\n#cmakedefine HAVE_GETTIMEOFDAY ${HAVE_GETTIMEOFDAY}\n\n/* Define to 1 if the system has the type `int64_t'. */\n#cmakedefine HAVE_INT64_T ${HAVE_INT64_T}\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#cmakedefine HAVE_INTTYPES_H ${HAVE_INTTYPES_H}\n\n/* Define to 1 if you have the `isatty' function. */\n#cmakedefine HAVE_ISATTY 1\n\n/* Define to 1 if you have the `edit' library (-ledit). */\n#cmakedefine HAVE_LIBEDIT ${HAVE_LIBEDIT}\n\n/* Define to 1 if you have the `psapi' library (-lpsapi). */\n#cmakedefine HAVE_LIBPSAPI ${HAVE_LIBPSAPI}\n\n/* Define to 1 if you have the `pthread' library (-lpthread). */\n#cmakedefine HAVE_LIBPTHREAD ${HAVE_LIBPTHREAD}\n\n/* Define to 1 if you have the `pthread_getname_np' function. */\n#cmakedefine HAVE_PTHREAD_GETNAME_NP ${HAVE_PTHREAD_GETNAME_NP}\n\n/* Define to 1 if you have the `pthread_setname_np' function. */\n#cmakedefine HAVE_PTHREAD_SETNAME_NP ${HAVE_PTHREAD_SETNAME_NP}\n\n/* Define to 1 if you have the `shell32' library (-lshell32). */\n#cmakedefine HAVE_LIBSHELL32 ${HAVE_LIBSHELL32}\n\n/* Define to 1 if you have the `z' library (-lz). */\n#cmakedefine HAVE_LIBZ ${HAVE_LIBZ}\n\n/* Define to 1 if you have the <link.h> header file. */\n#cmakedefine HAVE_LINK_H ${HAVE_LINK_H}\n\n/* Define to 1 if you have the `lseek64' function. */\n#cmakedefine HAVE_LSEEK64 ${HAVE_LSEEK64}\n\n/* Define to 1 if you have the <mach/mach.h> header file. */\n#cmakedefine HAVE_MACH_MACH_H ${HAVE_MACH_MACH_H}\n\n/* Define to 1 if you have the `mallctl' function. */\n#cmakedefine HAVE_MALLCTL ${HAVE_MALLCTL}\n\n/* Define to 1 if you have the `mallinfo' function. */\n#cmakedefine HAVE_MALLINFO ${HAVE_MALLINFO}\n\n/* Define to 1 if you have the <malloc.h> header file. */\n#cmakedefine HAVE_MALLOC_H ${HAVE_MALLOC_H}\n\n/* Define to 1 if you have the <malloc/malloc.h> header file. */\n#cmakedefine HAVE_MALLOC_MALLOC_H ${HAVE_MALLOC_MALLOC_H}\n\n/* Define to 1 if you have the `malloc_zone_statistics' function. */\n#cmakedefine HAVE_MALLOC_ZONE_STATISTICS ${HAVE_MALLOC_ZONE_STATISTICS}\n\n/* Define to 1 if you have the `mkdtemp' function. */\n#cmakedefine HAVE_MKDTEMP ${HAVE_MKDTEMP}\n\n/* Define to 1 if you have the `mkstemp' function. */\n#cmakedefine HAVE_MKSTEMP ${HAVE_MKSTEMP}\n\n/* Define to 1 if you have the `mktemp' function. */\n#cmakedefine HAVE_MKTEMP ${HAVE_MKTEMP}\n\n/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */\n#cmakedefine HAVE_NDIR_H ${HAVE_NDIR_H}\n\n/* Define to 1 if you have the `posix_fallocate' function. */\n#cmakedefine HAVE_POSIX_FALLOCATE ${HAVE_POSIX_FALLOCATE}\n\n/* Define to 1 if you have the `posix_spawn' function. */\n#cmakedefine HAVE_POSIX_SPAWN ${HAVE_POSIX_SPAWN}\n\n/* Define to 1 if you have the `pread' function. */\n#cmakedefine HAVE_PREAD ${HAVE_PREAD}\n\n/* Have pthread_getspecific */\n#cmakedefine HAVE_PTHREAD_GETSPECIFIC ${HAVE_PTHREAD_GETSPECIFIC}\n\n/* Define to 1 if you have the <pthread.h> header file. */\n#cmakedefine HAVE_PTHREAD_H ${HAVE_PTHREAD_H}\n\n/* Have pthread_mutex_lock */\n#cmakedefine HAVE_PTHREAD_MUTEX_LOCK ${HAVE_PTHREAD_MUTEX_LOCK}\n\n/* Have pthread_rwlock_init */\n#cmakedefine HAVE_PTHREAD_RWLOCK_INIT ${HAVE_PTHREAD_RWLOCK_INIT}\n\n/* Define to 1 if you have the `realpath' function. */\n#cmakedefine HAVE_REALPATH ${HAVE_REALPATH}\n\n/* Define to 1 if you have the `sbrk' function. */\n#cmakedefine HAVE_SBRK ${HAVE_SBRK}\n\n/* Define to 1 if you have the `setenv' function. */\n#cmakedefine HAVE_SETENV ${HAVE_SETENV}\n\n/* Define to 1 if you have the `sched_getaffinity' function. */\n#cmakedefine HAVE_SCHED_GETAFFINITY ${HAVE_SCHED_GETAFFINITY}\n\n/* Define to 1 if you have the `CPU_COUNT' macro. */\n#cmakedefine HAVE_CPU_COUNT ${HAVE_CPU_COUNT}\n\n/* Define to 1 if you have the `setrlimit' function. */\n#cmakedefine HAVE_SETRLIMIT ${HAVE_SETRLIMIT}\n\n/* Define to 1 if you have the `sigaltstack' function. */\n#cmakedefine HAVE_SIGALTSTACK ${HAVE_SIGALTSTACK}\n\n/* Define to 1 if you have the <signal.h> header file. */\n#cmakedefine HAVE_SIGNAL_H ${HAVE_SIGNAL_H}\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#cmakedefine HAVE_STDINT_H ${HAVE_STDINT_H}\n\n/* Define to 1 if you have the `strerror' function. */\n#cmakedefine HAVE_STRERROR ${HAVE_STRERROR}\n\n/* Define to 1 if you have the `strerror_r' function. */\n#cmakedefine HAVE_STRERROR_R ${HAVE_STRERROR_R}\n\n/* Define to 1 if you have the `strtoll' function. */\n#cmakedefine HAVE_STRTOLL ${HAVE_STRTOLL}\n\n/* Define to 1 if you have the `sysconf' function. */\n#cmakedefine HAVE_SYSCONF ${HAVE_SYSCONF}\n\n/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.\n   */\n#cmakedefine HAVE_SYS_DIR_H ${HAVE_SYS_DIR_H}\n\n/* Define to 1 if you have the <sys/ioctl.h> header file. */\n#cmakedefine HAVE_SYS_IOCTL_H ${HAVE_SYS_IOCTL_H}\n\n/* Define to 1 if you have the <sys/mman.h> header file. */\n#cmakedefine HAVE_SYS_MMAN_H ${HAVE_SYS_MMAN_H}\n\n/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.\n   */\n#cmakedefine HAVE_SYS_NDIR_H ${HAVE_SYS_NDIR_H}\n\n/* Define to 1 if you have the <sys/param.h> header file. */\n#cmakedefine HAVE_SYS_PARAM_H ${HAVE_SYS_PARAM_H}\n\n/* Define to 1 if you have the <sys/resource.h> header file. */\n#cmakedefine HAVE_SYS_RESOURCE_H ${HAVE_SYS_RESOURCE_H}\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#cmakedefine HAVE_SYS_STAT_H ${HAVE_SYS_STAT_H}\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#cmakedefine HAVE_SYS_TIME_H ${HAVE_SYS_TIME_H}\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#cmakedefine HAVE_SYS_TYPES_H ${HAVE_SYS_TYPES_H}\n\n/* Define to 1 if you have the <sys/uio.h> header file. */\n#cmakedefine HAVE_SYS_UIO_H ${HAVE_SYS_UIO_H}\n\n/* Define if the setupterm() function is supported this platform. */\n#cmakedefine HAVE_TERMINFO ${HAVE_TERMINFO}\n\n/* Define if the xar_open() function is supported this platform. */\n#cmakedefine HAVE_LIBXAR ${HAVE_LIBXAR}\n\n/* Define to 1 if you have the <termios.h> header file. */\n#cmakedefine HAVE_TERMIOS_H ${HAVE_TERMIOS_H}\n\n/* Define to 1 if the system has the type `uint64_t'. */\n#cmakedefine HAVE_UINT64_T ${HAVE_UINT64_T}\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#cmakedefine HAVE_UNISTD_H ${HAVE_UNISTD_H}\n\n/* Define to 1 if the system has the type `u_int64_t'. */\n#cmakedefine HAVE_U_INT64_T ${HAVE_U_INT64_T}\n\n/* Define to 1 if you have the <valgrind/valgrind.h> header file. */\n#cmakedefine HAVE_VALGRIND_VALGRIND_H ${HAVE_VALGRIND_VALGRIND_H}\n\n/* Define to 1 if you have the `writev' function. */\n#cmakedefine HAVE_WRITEV ${HAVE_WRITEV}\n\n/* Define to 1 if you have the <zlib.h> header file. */\n#cmakedefine HAVE_ZLIB_H ${HAVE_ZLIB_H}\n\n/* Have host's _alloca */\n#cmakedefine HAVE__ALLOCA ${HAVE__ALLOCA}\n\n/* Define to 1 if you have the `_chsize_s' function. */\n#cmakedefine HAVE__CHSIZE_S ${HAVE__CHSIZE_S}\n\n/* Define to 1 if you have the `_Unwind_Backtrace' function. */\n#cmakedefine HAVE__UNWIND_BACKTRACE ${HAVE__UNWIND_BACKTRACE}\n\n/* Have host's __alloca */\n#cmakedefine HAVE___ALLOCA ${HAVE___ALLOCA}\n\n/* Have host's __ashldi3 */\n#cmakedefine HAVE___ASHLDI3 ${HAVE___ASHLDI3}\n\n/* Have host's __ashrdi3 */\n#cmakedefine HAVE___ASHRDI3 ${HAVE___ASHRDI3}\n\n/* Have host's __chkstk */\n#cmakedefine HAVE___CHKSTK ${HAVE___CHKSTK}\n\n/* Have host's __chkstk_ms */\n#cmakedefine HAVE___CHKSTK_MS ${HAVE___CHKSTK_MS}\n\n/* Have host's __cmpdi2 */\n#cmakedefine HAVE___CMPDI2 ${HAVE___CMPDI2}\n\n/* Have host's __divdi3 */\n#cmakedefine HAVE___DIVDI3 ${HAVE___DIVDI3}\n\n/* Have host's __fixdfdi */\n#cmakedefine HAVE___FIXDFDI ${HAVE___FIXDFDI}\n\n/* Have host's __fixsfdi */\n#cmakedefine HAVE___FIXSFDI ${HAVE___FIXSFDI}\n\n/* Have host's __floatdidf */\n#cmakedefine HAVE___FLOATDIDF ${HAVE___FLOATDIDF}\n\n/* Have host's __lshrdi3 */\n#cmakedefine HAVE___LSHRDI3 ${HAVE___LSHRDI3}\n\n/* Have host's __main */\n#cmakedefine HAVE___MAIN ${HAVE___MAIN}\n\n/* Have host's __moddi3 */\n#cmakedefine HAVE___MODDI3 ${HAVE___MODDI3}\n\n/* Have host's __udivdi3 */\n#cmakedefine HAVE___UDIVDI3 ${HAVE___UDIVDI3}\n\n/* Have host's __umoddi3 */\n#cmakedefine HAVE___UMODDI3 ${HAVE___UMODDI3}\n\n/* Have host's ___chkstk */\n#cmakedefine HAVE____CHKSTK ${HAVE____CHKSTK}\n\n/* Have host's ___chkstk_ms */\n#cmakedefine HAVE____CHKSTK_MS ${HAVE____CHKSTK_MS}\n\n/* Linker version detected at compile time. */\n#cmakedefine HOST_LINK_VERSION \"${HOST_LINK_VERSION}\"\n\n/* Define if we link Polly to the tools */\n#cmakedefine LINK_POLLY_INTO_TOOLS\n\n/* Target triple LLVM will generate code for by default */\n/* Doesn't use `cmakedefine` because it is allowed to be empty. */\n#define LLVM_DEFAULT_TARGET_TRIPLE \"${LLVM_DEFAULT_TARGET_TRIPLE}\"\n\n/* Define if threads enabled */\n#cmakedefine01 LLVM_ENABLE_THREADS\n\n/* Define if zlib compression is available */\n#cmakedefine01 LLVM_ENABLE_ZLIB\n\n/* Has gcc/MSVC atomic intrinsics */\n#cmakedefine01 LLVM_HAS_ATOMICS\n\n/* Host triple LLVM will be executed on */\n#cmakedefine LLVM_HOST_TRIPLE \"${LLVM_HOST_TRIPLE}\"\n\n/* Define if this is Unixish platform */\n#cmakedefine LLVM_ON_UNIX ${LLVM_ON_UNIX}\n\n/* Define if this is Win32ish platform */\n#cmakedefine LLVM_ON_WIN32 ${LLVM_ON_WIN32}\n\n/* Define if overriding target triple is enabled */\n#cmakedefine LLVM_TARGET_TRIPLE_ENV \"${LLVM_TARGET_TRIPLE_ENV}\"\n\n/* Define if we have the Intel JIT API runtime support library */\n#cmakedefine01 LLVM_USE_INTEL_JITEVENTS\n\n/* Define if we have the oprofile JIT-support library */\n#cmakedefine01 LLVM_USE_OPROFILE\n\n/* LLVM version information */\n#cmakedefine LLVM_VERSION_INFO \"${LLVM_VERSION_INFO}\"\n\n/* Whether tools show host and target info when invoked with --version */\n#cmakedefine01 LLVM_VERSION_PRINTER_SHOW_HOST_TARGET_INFO\n\n/* Major version of the LLVM API */\n#define LLVM_VERSION_MAJOR ${LLVM_VERSION_MAJOR}\n\n/* Minor version of the LLVM API */\n#define LLVM_VERSION_MINOR ${LLVM_VERSION_MINOR}\n\n/* Patch version of the LLVM API */\n#define LLVM_VERSION_PATCH ${LLVM_VERSION_PATCH}\n\n/* LLVM version string */\n#define LLVM_VERSION_STRING \"${PACKAGE_VERSION}\"\n\n/* Define if libxml2 is supported on this platform. */\n#cmakedefine LLVM_LIBXML2_ENABLED ${LLVM_LIBXML2_ENABLED}\n\n/* Define to the extension used for shared libraries, say, \".so\". */\n#cmakedefine LTDL_SHLIB_EXT \"${LTDL_SHLIB_EXT}\"\n\n/* Define to the address where bug reports for this package should be sent. */\n#cmakedefine PACKAGE_BUGREPORT \"${PACKAGE_BUGREPORT}\"\n\n/* Define to the full name of this package. */\n#cmakedefine PACKAGE_NAME \"${PACKAGE_NAME}\"\n\n/* Define to the full name and version of this package. */\n#cmakedefine PACKAGE_STRING \"${PACKAGE_STRING}\"\n\n/* Define to the one symbol short name of this package. */\n#undef PACKAGE_TARNAME\n\n/* Define to the version of this package. */\n#cmakedefine PACKAGE_VERSION \"${PACKAGE_VERSION}\"\n\n/* Define to the vendor of this package. */\n#cmakedefine PACKAGE_VENDOR \"${PACKAGE_VENDOR}\"\n\n/* Define as the return type of signal handlers (`int' or `void'). */\n#cmakedefine RETSIGTYPE ${RETSIGTYPE}\n\n/* Define to a function replacing strtoll */\n#cmakedefine strtoll ${strtoll}\n\n/* Define to a function implementing strtoull */\n#cmakedefine strtoull ${strtoull}\n\n/* Define to a function implementing stricmp */\n#cmakedefine stricmp ${stricmp}\n\n/* Define to a function implementing strdup */\n#cmakedefine strdup ${strdup}\n\n/* Whether GlobalISel rule coverage is being collected */\n#cmakedefine01 LLVM_GISEL_COV_ENABLED\n\n/* Define to the default GlobalISel coverage file prefix */\n#cmakedefine LLVM_GISEL_COV_PREFIX \"${LLVM_GISEL_COV_PREFIX}\"\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/include/llvm/BinaryFormat/ELF.h": "//===- llvm/BinaryFormat/ELF.h - ELF constants and structures ---*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This header contains common, non-processor-specific data structures and\n// constants for the ELF file format.\n//\n// The details of the ELF32 bits in this file are largely based on the Tool\n// Interface Standard (TIS) Executable and Linking Format (ELF) Specification\n// Version 1.2, May 1995. The ELF64 stuff is based on ELF-64 Object File Format\n// Version 1.5, Draft 2, May 1998 as well as OpenBSD header files.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_BINARYFORMAT_ELF_H\n#define LLVM_BINARYFORMAT_ELF_H\n\n#include <cstdint>\n#include <cstring>\n\nnamespace llvm {\nnamespace ELF {\n\nusing Elf32_Addr = uint32_t; // Program address\nusing Elf32_Off = uint32_t;  // File offset\nusing Elf32_Half = uint16_t;\nusing Elf32_Word = uint32_t;\nusing Elf32_Sword = int32_t;\n\nusing Elf64_Addr = uint64_t;\nusing Elf64_Off = uint64_t;\nusing Elf64_Half = uint16_t;\nusing Elf64_Word = uint32_t;\nusing Elf64_Sword = int32_t;\nusing Elf64_Xword = uint64_t;\nusing Elf64_Sxword = int64_t;\n\n// Object file magic string.\nstatic const char ElfMagic[] = {0x7f, 'E', 'L', 'F', '\\0'};\n\n// e_ident size and indices.\nenum {\n  EI_MAG0 = 0,       // File identification index.\n  EI_MAG1 = 1,       // File identification index.\n  EI_MAG2 = 2,       // File identification index.\n  EI_MAG3 = 3,       // File identification index.\n  EI_CLASS = 4,      // File class.\n  EI_DATA = 5,       // Data encoding.\n  EI_VERSION = 6,    // File version.\n  EI_OSABI = 7,      // OS/ABI identification.\n  EI_ABIVERSION = 8, // ABI version.\n  EI_PAD = 9,        // Start of padding bytes.\n  EI_NIDENT = 16     // Number of bytes in e_ident.\n};\n\nstruct Elf32_Ehdr {\n  unsigned char e_ident[EI_NIDENT]; // ELF Identification bytes\n  Elf32_Half e_type;                // Type of file (see ET_* below)\n  Elf32_Half e_machine;   // Required architecture for this file (see EM_*)\n  Elf32_Word e_version;   // Must be equal to 1\n  Elf32_Addr e_entry;     // Address to jump to in order to start program\n  Elf32_Off e_phoff;      // Program header table's file offset, in bytes\n  Elf32_Off e_shoff;      // Section header table's file offset, in bytes\n  Elf32_Word e_flags;     // Processor-specific flags\n  Elf32_Half e_ehsize;    // Size of ELF header, in bytes\n  Elf32_Half e_phentsize; // Size of an entry in the program header table\n  Elf32_Half e_phnum;     // Number of entries in the program header table\n  Elf32_Half e_shentsize; // Size of an entry in the section header table\n  Elf32_Half e_shnum;     // Number of entries in the section header table\n  Elf32_Half e_shstrndx;  // Sect hdr table index of sect name string table\n\n  bool checkMagic() const {\n    return (memcmp(e_ident, ElfMagic, strlen(ElfMagic))) == 0;\n  }\n\n  unsigned char getFileClass() const { return e_ident[EI_CLASS]; }\n  unsigned char getDataEncoding() const { return e_ident[EI_DATA]; }\n};\n\n// 64-bit ELF header. Fields are the same as for ELF32, but with different\n// types (see above).\nstruct Elf64_Ehdr {\n  unsigned char e_ident[EI_NIDENT];\n  Elf64_Half e_type;\n  Elf64_Half e_machine;\n  Elf64_Word e_version;\n  Elf64_Addr e_entry;\n  Elf64_Off e_phoff;\n  Elf64_Off e_shoff;\n  Elf64_Word e_flags;\n  Elf64_Half e_ehsize;\n  Elf64_Half e_phentsize;\n  Elf64_Half e_phnum;\n  Elf64_Half e_shentsize;\n  Elf64_Half e_shnum;\n  Elf64_Half e_shstrndx;\n\n  bool checkMagic() const {\n    return (memcmp(e_ident, ElfMagic, strlen(ElfMagic))) == 0;\n  }\n\n  unsigned char getFileClass() const { return e_ident[EI_CLASS]; }\n  unsigned char getDataEncoding() const { return e_ident[EI_DATA]; }\n};\n\n// File types\nenum {\n  ET_NONE = 0,        // No file type\n  ET_REL = 1,         // Relocatable file\n  ET_EXEC = 2,        // Executable file\n  ET_DYN = 3,         // Shared object file\n  ET_CORE = 4,        // Core file\n  ET_LOPROC = 0xff00, // Beginning of processor-specific codes\n  ET_HIPROC = 0xffff  // Processor-specific\n};\n\n// Versioning\nenum { EV_NONE = 0, EV_CURRENT = 1 };\n\n// Machine architectures\n// See current registered ELF machine architectures at:\n//    http://www.uxsglobal.com/developers/gabi/latest/ch4.eheader.html\nenum {\n  EM_NONE = 0,           // No machine\n  EM_M32 = 1,            // AT&T WE 32100\n  EM_SPARC = 2,          // SPARC\n  EM_386 = 3,            // Intel 386\n  EM_68K = 4,            // Motorola 68000\n  EM_88K = 5,            // Motorola 88000\n  EM_IAMCU = 6,          // Intel MCU\n  EM_860 = 7,            // Intel 80860\n  EM_MIPS = 8,           // MIPS R3000\n  EM_S370 = 9,           // IBM System/370\n  EM_MIPS_RS3_LE = 10,   // MIPS RS3000 Little-endian\n  EM_PARISC = 15,        // Hewlett-Packard PA-RISC\n  EM_VPP500 = 17,        // Fujitsu VPP500\n  EM_SPARC32PLUS = 18,   // Enhanced instruction set SPARC\n  EM_960 = 19,           // Intel 80960\n  EM_PPC = 20,           // PowerPC\n  EM_PPC64 = 21,         // PowerPC64\n  EM_S390 = 22,          // IBM System/390\n  EM_SPU = 23,           // IBM SPU/SPC\n  EM_V800 = 36,          // NEC V800\n  EM_FR20 = 37,          // Fujitsu FR20\n  EM_RH32 = 38,          // TRW RH-32\n  EM_RCE = 39,           // Motorola RCE\n  EM_ARM = 40,           // ARM\n  EM_ALPHA = 41,         // DEC Alpha\n  EM_SH = 42,            // Hitachi SH\n  EM_SPARCV9 = 43,       // SPARC V9\n  EM_TRICORE = 44,       // Siemens TriCore\n  EM_ARC = 45,           // Argonaut RISC Core\n  EM_H8_300 = 46,        // Hitachi H8/300\n  EM_H8_300H = 47,       // Hitachi H8/300H\n  EM_H8S = 48,           // Hitachi H8S\n  EM_H8_500 = 49,        // Hitachi H8/500\n  EM_IA_64 = 50,         // Intel IA-64 processor architecture\n  EM_MIPS_X = 51,        // Stanford MIPS-X\n  EM_COLDFIRE = 52,      // Motorola ColdFire\n  EM_68HC12 = 53,        // Motorola M68HC12\n  EM_MMA = 54,           // Fujitsu MMA Multimedia Accelerator\n  EM_PCP = 55,           // Siemens PCP\n  EM_NCPU = 56,          // Sony nCPU embedded RISC processor\n  EM_NDR1 = 57,          // Denso NDR1 microprocessor\n  EM_STARCORE = 58,      // Motorola Star*Core processor\n  EM_ME16 = 59,          // Toyota ME16 processor\n  EM_ST100 = 60,         // STMicroelectronics ST100 processor\n  EM_TINYJ = 61,         // Advanced Logic Corp. TinyJ embedded processor family\n  EM_X86_64 = 62,        // AMD x86-64 architecture\n  EM_PDSP = 63,          // Sony DSP Processor\n  EM_PDP10 = 64,         // Digital Equipment Corp. PDP-10\n  EM_PDP11 = 65,         // Digital Equipment Corp. PDP-11\n  EM_FX66 = 66,          // Siemens FX66 microcontroller\n  EM_ST9PLUS = 67,       // STMicroelectronics ST9+ 8/16 bit microcontroller\n  EM_ST7 = 68,           // STMicroelectronics ST7 8-bit microcontroller\n  EM_68HC16 = 69,        // Motorola MC68HC16 Microcontroller\n  EM_68HC11 = 70,        // Motorola MC68HC11 Microcontroller\n  EM_68HC08 = 71,        // Motorola MC68HC08 Microcontroller\n  EM_68HC05 = 72,        // Motorola MC68HC05 Microcontroller\n  EM_SVX = 73,           // Silicon Graphics SVx\n  EM_ST19 = 74,          // STMicroelectronics ST19 8-bit microcontroller\n  EM_VAX = 75,           // Digital VAX\n  EM_CRIS = 76,          // Axis Communications 32-bit embedded processor\n  EM_JAVELIN = 77,       // Infineon Technologies 32-bit embedded processor\n  EM_FIREPATH = 78,      // Element 14 64-bit DSP Processor\n  EM_ZSP = 79,           // LSI Logic 16-bit DSP Processor\n  EM_MMIX = 80,          // Donald Knuth's educational 64-bit processor\n  EM_HUANY = 81,         // Harvard University machine-independent object files\n  EM_PRISM = 82,         // SiTera Prism\n  EM_AVR = 83,           // Atmel AVR 8-bit microcontroller\n  EM_FR30 = 84,          // Fujitsu FR30\n  EM_D10V = 85,          // Mitsubishi D10V\n  EM_D30V = 86,          // Mitsubishi D30V\n  EM_V850 = 87,          // NEC v850\n  EM_M32R = 88,          // Mitsubishi M32R\n  EM_MN10300 = 89,       // Matsushita MN10300\n  EM_MN10200 = 90,       // Matsushita MN10200\n  EM_PJ = 91,            // picoJava\n  EM_OPENRISC = 92,      // OpenRISC 32-bit embedded processor\n  EM_ARC_COMPACT = 93,   // ARC International ARCompact processor (old\n                         // spelling/synonym: EM_ARC_A5)\n  EM_XTENSA = 94,        // Tensilica Xtensa Architecture\n  EM_VIDEOCORE = 95,     // Alphamosaic VideoCore processor\n  EM_TMM_GPP = 96,       // Thompson Multimedia General Purpose Processor\n  EM_NS32K = 97,         // National Semiconductor 32000 series\n  EM_TPC = 98,           // Tenor Network TPC processor\n  EM_SNP1K = 99,         // Trebia SNP 1000 processor\n  EM_ST200 = 100,        // STMicroelectronics (www.st.com) ST200\n  EM_IP2K = 101,         // Ubicom IP2xxx microcontroller family\n  EM_MAX = 102,          // MAX Processor\n  EM_CR = 103,           // National Semiconductor CompactRISC microprocessor\n  EM_F2MC16 = 104,       // Fujitsu F2MC16\n  EM_MSP430 = 105,       // Texas Instruments embedded microcontroller msp430\n  EM_BLACKFIN = 106,     // Analog Devices Blackfin (DSP) processor\n  EM_SE_C33 = 107,       // S1C33 Family of Seiko Epson processors\n  EM_SEP = 108,          // Sharp embedded microprocessor\n  EM_ARCA = 109,         // Arca RISC Microprocessor\n  EM_UNICORE = 110,      // Microprocessor series from PKU-Unity Ltd. and MPRC\n                         // of Peking University\n  EM_EXCESS = 111,       // eXcess: 16/32/64-bit configurable embedded CPU\n  EM_DXP = 112,          // Icera Semiconductor Inc. Deep Execution Processor\n  EM_ALTERA_NIOS2 = 113, // Altera Nios II soft-core processor\n  EM_CRX = 114,          // National Semiconductor CompactRISC CRX\n  EM_XGATE = 115,        // Motorola XGATE embedded processor\n  EM_C166 = 116,         // Infineon C16x/XC16x processor\n  EM_M16C = 117,         // Renesas M16C series microprocessors\n  EM_DSPIC30F = 118,     // Microchip Technology dsPIC30F Digital Signal\n                         // Controller\n  EM_CE = 119,           // Freescale Communication Engine RISC core\n  EM_M32C = 120,         // Renesas M32C series microprocessors\n  EM_TSK3000 = 131,      // Altium TSK3000 core\n  EM_RS08 = 132,         // Freescale RS08 embedded processor\n  EM_SHARC = 133,        // Analog Devices SHARC family of 32-bit DSP\n                         // processors\n  EM_ECOG2 = 134,        // Cyan Technology eCOG2 microprocessor\n  EM_SCORE7 = 135,       // Sunplus S+core7 RISC processor\n  EM_DSP24 = 136,        // New Japan Radio (NJR) 24-bit DSP Processor\n  EM_VIDEOCORE3 = 137,   // Broadcom VideoCore III processor\n  EM_LATTICEMICO32 = 138, // RISC processor for Lattice FPGA architecture\n  EM_SE_C17 = 139,        // Seiko Epson C17 family\n  EM_TI_C6000 = 140,      // The Texas Instruments TMS320C6000 DSP family\n  EM_TI_C2000 = 141,      // The Texas Instruments TMS320C2000 DSP family\n  EM_TI_C5500 = 142,      // The Texas Instruments TMS320C55x DSP family\n  EM_MMDSP_PLUS = 160,    // STMicroelectronics 64bit VLIW Data Signal Processor\n  EM_CYPRESS_M8C = 161,   // Cypress M8C microprocessor\n  EM_R32C = 162,          // Renesas R32C series microprocessors\n  EM_TRIMEDIA = 163,      // NXP Semiconductors TriMedia architecture family\n  EM_HEXAGON = 164,       // Qualcomm Hexagon processor\n  EM_8051 = 165,          // Intel 8051 and variants\n  EM_STXP7X = 166,        // STMicroelectronics STxP7x family of configurable\n                          // and extensible RISC processors\n  EM_NDS32 = 167,         // Andes Technology compact code size embedded RISC\n                          // processor family\n  EM_ECOG1 = 168,         // Cyan Technology eCOG1X family\n  EM_ECOG1X = 168,        // Cyan Technology eCOG1X family\n  EM_MAXQ30 = 169,        // Dallas Semiconductor MAXQ30 Core Micro-controllers\n  EM_XIMO16 = 170,        // New Japan Radio (NJR) 16-bit DSP Processor\n  EM_MANIK = 171,         // M2000 Reconfigurable RISC Microprocessor\n  EM_CRAYNV2 = 172,       // Cray Inc. NV2 vector architecture\n  EM_RX = 173,            // Renesas RX family\n  EM_METAG = 174,         // Imagination Technologies META processor\n                          // architecture\n  EM_MCST_ELBRUS = 175,   // MCST Elbrus general purpose hardware architecture\n  EM_ECOG16 = 176,        // Cyan Technology eCOG16 family\n  EM_CR16 = 177,          // National Semiconductor CompactRISC CR16 16-bit\n                          // microprocessor\n  EM_ETPU = 178,          // Freescale Extended Time Processing Unit\n  EM_SLE9X = 179,         // Infineon Technologies SLE9X core\n  EM_L10M = 180,          // Intel L10M\n  EM_K10M = 181,          // Intel K10M\n  EM_AARCH64 = 183,       // ARM AArch64\n  EM_AVR32 = 185,         // Atmel Corporation 32-bit microprocessor family\n  EM_STM8 = 186,          // STMicroeletronics STM8 8-bit microcontroller\n  EM_TILE64 = 187,        // Tilera TILE64 multicore architecture family\n  EM_TILEPRO = 188,       // Tilera TILEPro multicore architecture family\n  EM_CUDA = 190,          // NVIDIA CUDA architecture\n  EM_TILEGX = 191,        // Tilera TILE-Gx multicore architecture family\n  EM_CLOUDSHIELD = 192,   // CloudShield architecture family\n  EM_COREA_1ST = 193,     // KIPO-KAIST Core-A 1st generation processor family\n  EM_COREA_2ND = 194,     // KIPO-KAIST Core-A 2nd generation processor family\n  EM_ARC_COMPACT2 = 195,  // Synopsys ARCompact V2\n  EM_OPEN8 = 196,         // Open8 8-bit RISC soft processor core\n  EM_RL78 = 197,          // Renesas RL78 family\n  EM_VIDEOCORE5 = 198,    // Broadcom VideoCore V processor\n  EM_78KOR = 199,         // Renesas 78KOR family\n  EM_56800EX = 200,       // Freescale 56800EX Digital Signal Controller (DSC)\n  EM_BA1 = 201,           // Beyond BA1 CPU architecture\n  EM_BA2 = 202,           // Beyond BA2 CPU architecture\n  EM_XCORE = 203,         // XMOS xCORE processor family\n  EM_MCHP_PIC = 204,      // Microchip 8-bit PIC(r) family\n  EM_INTEL205 = 205,      // Reserved by Intel\n  EM_INTEL206 = 206,      // Reserved by Intel\n  EM_INTEL207 = 207,      // Reserved by Intel\n  EM_INTEL208 = 208,      // Reserved by Intel\n  EM_INTEL209 = 209,      // Reserved by Intel\n  EM_KM32 = 210,          // KM211 KM32 32-bit processor\n  EM_KMX32 = 211,         // KM211 KMX32 32-bit processor\n  EM_KMX16 = 212,         // KM211 KMX16 16-bit processor\n  EM_KMX8 = 213,          // KM211 KMX8 8-bit processor\n  EM_KVARC = 214,         // KM211 KVARC processor\n  EM_CDP = 215,           // Paneve CDP architecture family\n  EM_COGE = 216,          // Cognitive Smart Memory Processor\n  EM_COOL = 217,          // iCelero CoolEngine\n  EM_NORC = 218,          // Nanoradio Optimized RISC\n  EM_CSR_KALIMBA = 219,   // CSR Kalimba architecture family\n  EM_AMDGPU = 224,        // AMD GPU architecture\n  EM_RISCV = 243,         // RISC-V\n  EM_LANAI = 244,         // Lanai 32-bit processor\n  EM_BPF = 247,           // Linux kernel bpf virtual machine\n\n  // A request has been made to the maintainer of the official registry for\n  // such numbers for an official value for WebAssembly. As soon as one is\n  // allocated, this enum will be updated to use it.\n  EM_WEBASSEMBLY = 0x4157, // WebAssembly architecture\n};\n\n// Object file classes.\nenum {\n  ELFCLASSNONE = 0,\n  ELFCLASS32 = 1, // 32-bit object file\n  ELFCLASS64 = 2  // 64-bit object file\n};\n\n// Object file byte orderings.\nenum {\n  ELFDATANONE = 0, // Invalid data encoding.\n  ELFDATA2LSB = 1, // Little-endian object file\n  ELFDATA2MSB = 2  // Big-endian object file\n};\n\n// OS ABI identification.\nenum {\n  ELFOSABI_NONE = 0,           // UNIX System V ABI\n  ELFOSABI_HPUX = 1,           // HP-UX operating system\n  ELFOSABI_NETBSD = 2,         // NetBSD\n  ELFOSABI_GNU = 3,            // GNU/Linux\n  ELFOSABI_LINUX = 3,          // Historical alias for ELFOSABI_GNU.\n  ELFOSABI_HURD = 4,           // GNU/Hurd\n  ELFOSABI_SOLARIS = 6,        // Solaris\n  ELFOSABI_AIX = 7,            // AIX\n  ELFOSABI_IRIX = 8,           // IRIX\n  ELFOSABI_FREEBSD = 9,        // FreeBSD\n  ELFOSABI_TRU64 = 10,         // TRU64 UNIX\n  ELFOSABI_MODESTO = 11,       // Novell Modesto\n  ELFOSABI_OPENBSD = 12,       // OpenBSD\n  ELFOSABI_OPENVMS = 13,       // OpenVMS\n  ELFOSABI_NSK = 14,           // Hewlett-Packard Non-Stop Kernel\n  ELFOSABI_AROS = 15,          // AROS\n  ELFOSABI_FENIXOS = 16,       // FenixOS\n  ELFOSABI_CLOUDABI = 17,      // Nuxi CloudABI\n  ELFOSABI_FIRST_ARCH = 64,    // First architecture-specific OS ABI\n  ELFOSABI_AMDGPU_HSA = 64,    // AMD HSA runtime\n  ELFOSABI_AMDGPU_PAL = 65,    // AMD PAL runtime\n  ELFOSABI_AMDGPU_MESA3D = 66, // AMD GCN GPUs (GFX6+) for MESA runtime\n  ELFOSABI_ARM = 97,           // ARM\n  ELFOSABI_C6000_ELFABI = 64,  // Bare-metal TMS320C6000\n  ELFOSABI_C6000_LINUX = 65,   // Linux TMS320C6000\n  ELFOSABI_STANDALONE = 255,   // Standalone (embedded) application\n  ELFOSABI_LAST_ARCH = 255     // Last Architecture-specific OS ABI\n};\n\n#define ELF_RELOC(name, value) name = value,\n\n// X86_64 relocations.\nenum {\n#include \"ELFRelocs/x86_64.def\"\n};\n\n// i386 relocations.\nenum {\n#include \"ELFRelocs/i386.def\"\n};\n\n// ELF Relocation types for PPC32\nenum {\n#include \"ELFRelocs/PowerPC.def\"\n};\n\n// Specific e_flags for PPC64\nenum {\n  // e_flags bits specifying ABI:\n  // 1 for original ABI using function descriptors,\n  // 2 for revised ABI without function descriptors,\n  // 0 for unspecified or not using any features affected by the differences.\n  EF_PPC64_ABI = 3\n};\n\n// Special values for the st_other field in the symbol table entry for PPC64.\nenum {\n  STO_PPC64_LOCAL_BIT = 5,\n  STO_PPC64_LOCAL_MASK = (7 << STO_PPC64_LOCAL_BIT)\n};\nstatic inline int64_t decodePPC64LocalEntryOffset(unsigned Other) {\n  unsigned Val = (Other & STO_PPC64_LOCAL_MASK) >> STO_PPC64_LOCAL_BIT;\n  return ((1 << Val) >> 2) << 2;\n}\nstatic inline unsigned encodePPC64LocalEntryOffset(int64_t Offset) {\n  unsigned Val =\n      (Offset >= 4 * 4 ? (Offset >= 8 * 4 ? (Offset >= 16 * 4 ? 6 : 5) : 4)\n                       : (Offset >= 2 * 4 ? 3 : (Offset >= 1 * 4 ? 2 : 0)));\n  return Val << STO_PPC64_LOCAL_BIT;\n}\n\n// ELF Relocation types for PPC64\nenum {\n#include \"ELFRelocs/PowerPC64.def\"\n};\n\n// ELF Relocation types for AArch64\nenum {\n#include \"ELFRelocs/AArch64.def\"\n};\n\n// ARM Specific e_flags\nenum : unsigned {\n  EF_ARM_SOFT_FLOAT = 0x00000200U,\n  EF_ARM_VFP_FLOAT = 0x00000400U,\n  EF_ARM_EABI_UNKNOWN = 0x00000000U,\n  EF_ARM_EABI_VER1 = 0x01000000U,\n  EF_ARM_EABI_VER2 = 0x02000000U,\n  EF_ARM_EABI_VER3 = 0x03000000U,\n  EF_ARM_EABI_VER4 = 0x04000000U,\n  EF_ARM_EABI_VER5 = 0x05000000U,\n  EF_ARM_EABIMASK = 0xFF000000U\n};\n\n// ELF Relocation types for ARM\nenum {\n#include \"ELFRelocs/ARM.def\"\n};\n\n// ARC Specific e_flags\nenum : unsigned {\n  EF_ARC_MACH_MSK = 0x000000ff,\n  EF_ARC_OSABI_MSK = 0x00000f00,\n  E_ARC_MACH_ARC600 = 0x00000002,\n  E_ARC_MACH_ARC601 = 0x00000004,\n  E_ARC_MACH_ARC700 = 0x00000003,\n  EF_ARC_CPU_ARCV2EM = 0x00000005,\n  EF_ARC_CPU_ARCV2HS = 0x00000006,\n  E_ARC_OSABI_ORIG = 0x00000000,\n  E_ARC_OSABI_V2 = 0x00000200,\n  E_ARC_OSABI_V3 = 0x00000300,\n  E_ARC_OSABI_V4 = 0x00000400,\n  EF_ARC_PIC = 0x00000100\n};\n\n// ELF Relocation types for ARC\nenum {\n#include \"ELFRelocs/ARC.def\"\n};\n\n// AVR specific e_flags\nenum : unsigned {\n  EF_AVR_ARCH_AVR1 = 1,\n  EF_AVR_ARCH_AVR2 = 2,\n  EF_AVR_ARCH_AVR25 = 25,\n  EF_AVR_ARCH_AVR3 = 3,\n  EF_AVR_ARCH_AVR31 = 31,\n  EF_AVR_ARCH_AVR35 = 35,\n  EF_AVR_ARCH_AVR4 = 4,\n  EF_AVR_ARCH_AVR5 = 5,\n  EF_AVR_ARCH_AVR51 = 51,\n  EF_AVR_ARCH_AVR6 = 6,\n  EF_AVR_ARCH_AVRTINY = 100,\n  EF_AVR_ARCH_XMEGA1 = 101,\n  EF_AVR_ARCH_XMEGA2 = 102,\n  EF_AVR_ARCH_XMEGA3 = 103,\n  EF_AVR_ARCH_XMEGA4 = 104,\n  EF_AVR_ARCH_XMEGA5 = 105,\n  EF_AVR_ARCH_XMEGA6 = 106,\n  EF_AVR_ARCH_XMEGA7 = 107\n};\n\n// ELF Relocation types for AVR\nenum {\n#include \"ELFRelocs/AVR.def\"\n};\n\n// Mips Specific e_flags\nenum : unsigned {\n  EF_MIPS_NOREORDER = 0x00000001, // Don't reorder instructions\n  EF_MIPS_PIC = 0x00000002,       // Position independent code\n  EF_MIPS_CPIC = 0x00000004,      // Call object with Position independent code\n  EF_MIPS_ABI2 = 0x00000020,      // File uses N32 ABI\n  EF_MIPS_32BITMODE = 0x00000100, // Code compiled for a 64-bit machine\n                                  // in 32-bit mode\n  EF_MIPS_FP64 = 0x00000200,      // Code compiled for a 32-bit machine\n                                  // but uses 64-bit FP registers\n  EF_MIPS_NAN2008 = 0x00000400,   // Uses IEE 754-2008 NaN encoding\n\n  // ABI flags\n  EF_MIPS_ABI_O32 = 0x00001000, // This file follows the first MIPS 32 bit ABI\n  EF_MIPS_ABI_O64 = 0x00002000, // O32 ABI extended for 64-bit architecture.\n  EF_MIPS_ABI_EABI32 = 0x00003000, // EABI in 32 bit mode.\n  EF_MIPS_ABI_EABI64 = 0x00004000, // EABI in 64 bit mode.\n  EF_MIPS_ABI = 0x0000f000,        // Mask for selecting EF_MIPS_ABI_ variant.\n\n  // MIPS machine variant\n  EF_MIPS_MACH_NONE = 0x00000000,    // A standard MIPS implementation.\n  EF_MIPS_MACH_3900 = 0x00810000,    // Toshiba R3900\n  EF_MIPS_MACH_4010 = 0x00820000,    // LSI R4010\n  EF_MIPS_MACH_4100 = 0x00830000,    // NEC VR4100\n  EF_MIPS_MACH_4650 = 0x00850000,    // MIPS R4650\n  EF_MIPS_MACH_4120 = 0x00870000,    // NEC VR4120\n  EF_MIPS_MACH_4111 = 0x00880000,    // NEC VR4111/VR4181\n  EF_MIPS_MACH_SB1 = 0x008a0000,     // Broadcom SB-1\n  EF_MIPS_MACH_OCTEON = 0x008b0000,  // Cavium Networks Octeon\n  EF_MIPS_MACH_XLR = 0x008c0000,     // RMI Xlr\n  EF_MIPS_MACH_OCTEON2 = 0x008d0000, // Cavium Networks Octeon2\n  EF_MIPS_MACH_OCTEON3 = 0x008e0000, // Cavium Networks Octeon3\n  EF_MIPS_MACH_5400 = 0x00910000,    // NEC VR5400\n  EF_MIPS_MACH_5900 = 0x00920000,    // MIPS R5900\n  EF_MIPS_MACH_5500 = 0x00980000,    // NEC VR5500\n  EF_MIPS_MACH_9000 = 0x00990000,    // Unknown\n  EF_MIPS_MACH_LS2E = 0x00a00000,    // ST Microelectronics Loongson 2E\n  EF_MIPS_MACH_LS2F = 0x00a10000,    // ST Microelectronics Loongson 2F\n  EF_MIPS_MACH_LS3A = 0x00a20000,    // Loongson 3A\n  EF_MIPS_MACH = 0x00ff0000,         // EF_MIPS_MACH_xxx selection mask\n\n  // ARCH_ASE\n  EF_MIPS_MICROMIPS = 0x02000000,     // microMIPS\n  EF_MIPS_ARCH_ASE_M16 = 0x04000000,  // Has Mips-16 ISA extensions\n  EF_MIPS_ARCH_ASE_MDMX = 0x08000000, // Has MDMX multimedia extensions\n  EF_MIPS_ARCH_ASE = 0x0f000000,      // Mask for EF_MIPS_ARCH_ASE_xxx flags\n\n  // ARCH\n  EF_MIPS_ARCH_1 = 0x00000000,    // MIPS1 instruction set\n  EF_MIPS_ARCH_2 = 0x10000000,    // MIPS2 instruction set\n  EF_MIPS_ARCH_3 = 0x20000000,    // MIPS3 instruction set\n  EF_MIPS_ARCH_4 = 0x30000000,    // MIPS4 instruction set\n  EF_MIPS_ARCH_5 = 0x40000000,    // MIPS5 instruction set\n  EF_MIPS_ARCH_32 = 0x50000000,   // MIPS32 instruction set per linux not elf.h\n  EF_MIPS_ARCH_64 = 0x60000000,   // MIPS64 instruction set per linux not elf.h\n  EF_MIPS_ARCH_32R2 = 0x70000000, // mips32r2, mips32r3, mips32r5\n  EF_MIPS_ARCH_64R2 = 0x80000000, // mips64r2, mips64r3, mips64r5\n  EF_MIPS_ARCH_32R6 = 0x90000000, // mips32r6\n  EF_MIPS_ARCH_64R6 = 0xa0000000, // mips64r6\n  EF_MIPS_ARCH = 0xf0000000       // Mask for applying EF_MIPS_ARCH_ variant\n};\n\n// ELF Relocation types for Mips\nenum {\n#include \"ELFRelocs/Mips.def\"\n};\n\n// Special values for the st_other field in the symbol table entry for MIPS.\nenum {\n  STO_MIPS_OPTIONAL = 0x04,  // Symbol whose definition is optional\n  STO_MIPS_PLT = 0x08,       // PLT entry related dynamic table record\n  STO_MIPS_PIC = 0x20,       // PIC func in an object mixes PIC/non-PIC\n  STO_MIPS_MICROMIPS = 0x80, // MIPS Specific ISA for MicroMips\n  STO_MIPS_MIPS16 = 0xf0     // MIPS Specific ISA for Mips16\n};\n\n// .MIPS.options section descriptor kinds\nenum {\n  ODK_NULL = 0,       // Undefined\n  ODK_REGINFO = 1,    // Register usage information\n  ODK_EXCEPTIONS = 2, // Exception processing options\n  ODK_PAD = 3,        // Section padding options\n  ODK_HWPATCH = 4,    // Hardware patches applied\n  ODK_FILL = 5,       // Linker fill value\n  ODK_TAGS = 6,       // Space for tool identification\n  ODK_HWAND = 7,      // Hardware AND patches applied\n  ODK_HWOR = 8,       // Hardware OR patches applied\n  ODK_GP_GROUP = 9,   // GP group to use for text/data sections\n  ODK_IDENT = 10,     // ID information\n  ODK_PAGESIZE = 11   // Page size information\n};\n\n// Hexagon-specific e_flags\nenum {\n  // Object processor version flags, bits[11:0]\n  EF_HEXAGON_MACH_V2 = 0x00000001,  // Hexagon V2\n  EF_HEXAGON_MACH_V3 = 0x00000002,  // Hexagon V3\n  EF_HEXAGON_MACH_V4 = 0x00000003,  // Hexagon V4\n  EF_HEXAGON_MACH_V5 = 0x00000004,  // Hexagon V5\n  EF_HEXAGON_MACH_V55 = 0x00000005, // Hexagon V55\n  EF_HEXAGON_MACH_V60 = 0x00000060, // Hexagon V60\n  EF_HEXAGON_MACH_V62 = 0x00000062, // Hexagon V62\n  EF_HEXAGON_MACH_V65 = 0x00000065, // Hexagon V65\n\n  // Highest ISA version flags\n  EF_HEXAGON_ISA_MACH = 0x00000000, // Same as specified in bits[11:0]\n                                    // of e_flags\n  EF_HEXAGON_ISA_V2 = 0x00000010,   // Hexagon V2 ISA\n  EF_HEXAGON_ISA_V3 = 0x00000020,   // Hexagon V3 ISA\n  EF_HEXAGON_ISA_V4 = 0x00000030,   // Hexagon V4 ISA\n  EF_HEXAGON_ISA_V5 = 0x00000040,   // Hexagon V5 ISA\n  EF_HEXAGON_ISA_V55 = 0x00000050,  // Hexagon V55 ISA\n  EF_HEXAGON_ISA_V60 = 0x00000060,  // Hexagon V60 ISA\n  EF_HEXAGON_ISA_V62 = 0x00000062,  // Hexagon V62 ISA\n  EF_HEXAGON_ISA_V65 = 0x00000065,  // Hexagon V65 ISA\n};\n\n// Hexagon-specific section indexes for common small data\nenum {\n  SHN_HEXAGON_SCOMMON = 0xff00,   // Other access sizes\n  SHN_HEXAGON_SCOMMON_1 = 0xff01, // Byte-sized access\n  SHN_HEXAGON_SCOMMON_2 = 0xff02, // Half-word-sized access\n  SHN_HEXAGON_SCOMMON_4 = 0xff03, // Word-sized access\n  SHN_HEXAGON_SCOMMON_8 = 0xff04  // Double-word-size access\n};\n\n// ELF Relocation types for Hexagon\nenum {\n#include \"ELFRelocs/Hexagon.def\"\n};\n\n// ELF Relocation type for Lanai.\nenum {\n#include \"ELFRelocs/Lanai.def\"\n};\n\n// RISCV Specific e_flags\nenum : unsigned {\n  EF_RISCV_RVC = 0x0001,\n  EF_RISCV_FLOAT_ABI = 0x0006,\n  EF_RISCV_FLOAT_ABI_SOFT = 0x0000,\n  EF_RISCV_FLOAT_ABI_SINGLE = 0x0002,\n  EF_RISCV_FLOAT_ABI_DOUBLE = 0x0004,\n  EF_RISCV_FLOAT_ABI_QUAD = 0x0006,\n  EF_RISCV_RVE = 0x0008\n};\n\n// ELF Relocation types for RISC-V\nenum {\n#include \"ELFRelocs/RISCV.def\"\n};\n\n// ELF Relocation types for S390/zSeries\nenum {\n#include \"ELFRelocs/SystemZ.def\"\n};\n\n// ELF Relocation type for Sparc.\nenum {\n#include \"ELFRelocs/Sparc.def\"\n};\n\n// ELF Relocation types for WebAssembly\nenum {\n#include \"ELFRelocs/WebAssembly.def\"\n};\n\n// AMDGPU specific e_flags.\nenum : unsigned {\n  // AMDGPU machine architectures.\n  EF_AMDGPU_ARCH_NONE = 0x00000000, // None/unknown.\n  EF_AMDGPU_ARCH_R600 = 0x00000001, // AMD HD2XXX-HD6XXX GPUs.\n  EF_AMDGPU_ARCH_GCN = 0x00000002,  // AMD GCN GFX6+ GPUs.\n  EF_AMDGPU_ARCH = 0x0000000f       // EF_AMDGPU_ARCH_XXX selection mask.\n};\n\n// ELF Relocation types for AMDGPU\nenum {\n#include \"ELFRelocs/AMDGPU.def\"\n};\n\n// ELF Relocation types for BPF\nenum {\n#include \"ELFRelocs/BPF.def\"\n};\n\n#undef ELF_RELOC\n\n// Section header.\nstruct Elf32_Shdr {\n  Elf32_Word sh_name;      // Section name (index into string table)\n  Elf32_Word sh_type;      // Section type (SHT_*)\n  Elf32_Word sh_flags;     // Section flags (SHF_*)\n  Elf32_Addr sh_addr;      // Address where section is to be loaded\n  Elf32_Off sh_offset;     // File offset of section data, in bytes\n  Elf32_Word sh_size;      // Size of section, in bytes\n  Elf32_Word sh_link;      // Section type-specific header table index link\n  Elf32_Word sh_info;      // Section type-specific extra information\n  Elf32_Word sh_addralign; // Section address alignment\n  Elf32_Word sh_entsize;   // Size of records contained within the section\n};\n\n// Section header for ELF64 - same fields as ELF32, different types.\nstruct Elf64_Shdr {\n  Elf64_Word sh_name;\n  Elf64_Word sh_type;\n  Elf64_Xword sh_flags;\n  Elf64_Addr sh_addr;\n  Elf64_Off sh_offset;\n  Elf64_Xword sh_size;\n  Elf64_Word sh_link;\n  Elf64_Word sh_info;\n  Elf64_Xword sh_addralign;\n  Elf64_Xword sh_entsize;\n};\n\n// Special section indices.\nenum {\n  SHN_UNDEF = 0,          // Undefined, missing, irrelevant, or meaningless\n  SHN_LORESERVE = 0xff00, // Lowest reserved index\n  SHN_LOPROC = 0xff00,    // Lowest processor-specific index\n  SHN_HIPROC = 0xff1f,    // Highest processor-specific index\n  SHN_LOOS = 0xff20,      // Lowest operating system-specific index\n  SHN_HIOS = 0xff3f,      // Highest operating system-specific index\n  SHN_ABS = 0xfff1,       // Symbol has absolute value; does not need relocation\n  SHN_COMMON = 0xfff2,    // FORTRAN COMMON or C external global variables\n  SHN_XINDEX = 0xffff,    // Mark that the index is >= SHN_LORESERVE\n  SHN_HIRESERVE = 0xffff  // Highest reserved index\n};\n\n// Section types.\nenum : unsigned {\n  SHT_NULL = 0,                    // No associated section (inactive entry).\n  SHT_PROGBITS = 1,                // Program-defined contents.\n  SHT_SYMTAB = 2,                  // Symbol table.\n  SHT_STRTAB = 3,                  // String table.\n  SHT_RELA = 4,                    // Relocation entries; explicit addends.\n  SHT_HASH = 5,                    // Symbol hash table.\n  SHT_DYNAMIC = 6,                 // Information for dynamic linking.\n  SHT_NOTE = 7,                    // Information about the file.\n  SHT_NOBITS = 8,                  // Data occupies no space in the file.\n  SHT_REL = 9,                     // Relocation entries; no explicit addends.\n  SHT_SHLIB = 10,                  // Reserved.\n  SHT_DYNSYM = 11,                 // Symbol table.\n  SHT_INIT_ARRAY = 14,             // Pointers to initialization functions.\n  SHT_FINI_ARRAY = 15,             // Pointers to termination functions.\n  SHT_PREINIT_ARRAY = 16,          // Pointers to pre-init functions.\n  SHT_GROUP = 17,                  // Section group.\n  SHT_SYMTAB_SHNDX = 18,           // Indices for SHN_XINDEX entries.\n  SHT_LOOS = 0x60000000,           // Lowest operating system-specific type.\n  // Android packed relocation section types.\n  // https://android.googlesource.com/platform/bionic/+/6f12bfece5dcc01325e0abba56a46b1bcf991c69/tools/relocation_packer/src/elf_file.cc#37\n  SHT_ANDROID_REL = 0x60000001,\n  SHT_ANDROID_RELA = 0x60000002,\n  SHT_LLVM_ODRTAB = 0x6fff4c00,    // LLVM ODR table.\n  SHT_GNU_ATTRIBUTES = 0x6ffffff5, // Object attributes.\n  SHT_GNU_HASH = 0x6ffffff6,       // GNU-style hash table.\n  SHT_GNU_verdef = 0x6ffffffd,     // GNU version definitions.\n  SHT_GNU_verneed = 0x6ffffffe,    // GNU version references.\n  SHT_GNU_versym = 0x6fffffff,     // GNU symbol versions table.\n  SHT_HIOS = 0x6fffffff,           // Highest operating system-specific type.\n  SHT_LOPROC = 0x70000000,         // Lowest processor arch-specific type.\n  // Fixme: All this is duplicated in MCSectionELF. Why??\n  // Exception Index table\n  SHT_ARM_EXIDX = 0x70000001U,\n  // BPABI DLL dynamic linking pre-emption map\n  SHT_ARM_PREEMPTMAP = 0x70000002U,\n  //  Object file compatibility attributes\n  SHT_ARM_ATTRIBUTES = 0x70000003U,\n  SHT_ARM_DEBUGOVERLAY = 0x70000004U,\n  SHT_ARM_OVERLAYSECTION = 0x70000005U,\n  SHT_HEX_ORDERED = 0x70000000,   // Link editor is to sort the entries in\n                                  // this section based on their sizes\n  SHT_X86_64_UNWIND = 0x70000001, // Unwind information\n\n  SHT_MIPS_REGINFO = 0x70000006,  // Register usage information\n  SHT_MIPS_OPTIONS = 0x7000000d,  // General options\n  SHT_MIPS_DWARF = 0x7000001e,    // DWARF debugging section.\n  SHT_MIPS_ABIFLAGS = 0x7000002a, // ABI information.\n\n  SHT_HIPROC = 0x7fffffff, // Highest processor arch-specific type.\n  SHT_LOUSER = 0x80000000, // Lowest type reserved for applications.\n  SHT_HIUSER = 0xffffffff  // Highest type reserved for applications.\n};\n\n// Section flags.\nenum : unsigned {\n  // Section data should be writable during execution.\n  SHF_WRITE = 0x1,\n\n  // Section occupies memory during program execution.\n  SHF_ALLOC = 0x2,\n\n  // Section contains executable machine instructions.\n  SHF_EXECINSTR = 0x4,\n\n  // The data in this section may be merged.\n  SHF_MERGE = 0x10,\n\n  // The data in this section is null-terminated strings.\n  SHF_STRINGS = 0x20,\n\n  // A field in this section holds a section header table index.\n  SHF_INFO_LINK = 0x40U,\n\n  // Adds special ordering requirements for link editors.\n  SHF_LINK_ORDER = 0x80U,\n\n  // This section requires special OS-specific processing to avoid incorrect\n  // behavior.\n  SHF_OS_NONCONFORMING = 0x100U,\n\n  // This section is a member of a section group.\n  SHF_GROUP = 0x200U,\n\n  // This section holds Thread-Local Storage.\n  SHF_TLS = 0x400U,\n\n  // Identifies a section containing compressed data.\n  SHF_COMPRESSED = 0x800U,\n\n  // This section is excluded from the final executable or shared library.\n  SHF_EXCLUDE = 0x80000000U,\n\n  // Start of target-specific flags.\n\n  SHF_MASKOS = 0x0ff00000,\n\n  // Bits indicating processor-specific flags.\n  SHF_MASKPROC = 0xf0000000,\n\n  /// All sections with the \"d\" flag are grouped together by the linker to form\n  /// the data section and the dp register is set to the start of the section by\n  /// the boot code.\n  XCORE_SHF_DP_SECTION = 0x10000000,\n\n  /// All sections with the \"c\" flag are grouped together by the linker to form\n  /// the constant pool and the cp register is set to the start of the constant\n  /// pool by the boot code.\n  XCORE_SHF_CP_SECTION = 0x20000000,\n\n  // If an object file section does not have this flag set, then it may not hold\n  // more than 2GB and can be freely referred to in objects using smaller code\n  // models. Otherwise, only objects using larger code models can refer to them.\n  // For example, a medium code model object can refer to data in a section that\n  // sets this flag besides being able to refer to data in a section that does\n  // not set it; likewise, a small code model object can refer only to code in a\n  // section that does not set this flag.\n  SHF_X86_64_LARGE = 0x10000000,\n\n  // All sections with the GPREL flag are grouped into a global data area\n  // for faster accesses\n  SHF_HEX_GPREL = 0x10000000,\n\n  // Section contains text/data which may be replicated in other sections.\n  // Linker must retain only one copy.\n  SHF_MIPS_NODUPES = 0x01000000,\n\n  // Linker must generate implicit hidden weak names.\n  SHF_MIPS_NAMES = 0x02000000,\n\n  // Section data local to process.\n  SHF_MIPS_LOCAL = 0x04000000,\n\n  // Do not strip this section.\n  SHF_MIPS_NOSTRIP = 0x08000000,\n\n  // Section must be part of global data area.\n  SHF_MIPS_GPREL = 0x10000000,\n\n  // This section should be merged.\n  SHF_MIPS_MERGE = 0x20000000,\n\n  // Address size to be inferred from section entry size.\n  SHF_MIPS_ADDR = 0x40000000,\n\n  // Section data is string data by default.\n  SHF_MIPS_STRING = 0x80000000,\n\n  // Make code section unreadable when in execute-only mode\n  SHF_ARM_PURECODE = 0x20000000\n};\n\n// Section Group Flags\nenum : unsigned {\n  GRP_COMDAT = 0x1,\n  GRP_MASKOS = 0x0ff00000,\n  GRP_MASKPROC = 0xf0000000\n};\n\n// Symbol table entries for ELF32.\nstruct Elf32_Sym {\n  Elf32_Word st_name;     // Symbol name (index into string table)\n  Elf32_Addr st_value;    // Value or address associated with the symbol\n  Elf32_Word st_size;     // Size of the symbol\n  unsigned char st_info;  // Symbol's type and binding attributes\n  unsigned char st_other; // Must be zero; reserved\n  Elf32_Half st_shndx;    // Which section (header table index) it's defined in\n\n  // These accessors and mutators correspond to the ELF32_ST_BIND,\n  // ELF32_ST_TYPE, and ELF32_ST_INFO macros defined in the ELF specification:\n  unsigned char getBinding() const { return st_info >> 4; }\n  unsigned char getType() const { return st_info & 0x0f; }\n  void setBinding(unsigned char b) { setBindingAndType(b, getType()); }\n  void setType(unsigned char t) { setBindingAndType(getBinding(), t); }\n  void setBindingAndType(unsigned char b, unsigned char t) {\n    st_info = (b << 4) + (t & 0x0f);\n  }\n};\n\n// Symbol table entries for ELF64.\nstruct Elf64_Sym {\n  Elf64_Word st_name;     // Symbol name (index into string table)\n  unsigned char st_info;  // Symbol's type and binding attributes\n  unsigned char st_other; // Must be zero; reserved\n  Elf64_Half st_shndx;    // Which section (header tbl index) it's defined in\n  Elf64_Addr st_value;    // Value or address associated with the symbol\n  Elf64_Xword st_size;    // Size of the symbol\n\n  // These accessors and mutators are identical to those defined for ELF32\n  // symbol table entries.\n  unsigned char getBinding() const { return st_info >> 4; }\n  unsigned char getType() const { return st_info & 0x0f; }\n  void setBinding(unsigned char b) { setBindingAndType(b, getType()); }\n  void setType(unsigned char t) { setBindingAndType(getBinding(), t); }\n  void setBindingAndType(unsigned char b, unsigned char t) {\n    st_info = (b << 4) + (t & 0x0f);\n  }\n};\n\n// The size (in bytes) of symbol table entries.\nenum {\n  SYMENTRY_SIZE32 = 16, // 32-bit symbol entry size\n  SYMENTRY_SIZE64 = 24  // 64-bit symbol entry size.\n};\n\n// Symbol bindings.\nenum {\n  STB_LOCAL = 0,  // Local symbol, not visible outside obj file containing def\n  STB_GLOBAL = 1, // Global symbol, visible to all object files being combined\n  STB_WEAK = 2,   // Weak symbol, like global but lower-precedence\n  STB_GNU_UNIQUE = 10,\n  STB_LOOS = 10,   // Lowest operating system-specific binding type\n  STB_HIOS = 12,   // Highest operating system-specific binding type\n  STB_LOPROC = 13, // Lowest processor-specific binding type\n  STB_HIPROC = 15  // Highest processor-specific binding type\n};\n\n// Symbol types.\nenum {\n  STT_NOTYPE = 0,     // Symbol's type is not specified\n  STT_OBJECT = 1,     // Symbol is a data object (variable, array, etc.)\n  STT_FUNC = 2,       // Symbol is executable code (function, etc.)\n  STT_SECTION = 3,    // Symbol refers to a section\n  STT_FILE = 4,       // Local, absolute symbol that refers to a file\n  STT_COMMON = 5,     // An uninitialized common block\n  STT_TLS = 6,        // Thread local data object\n  STT_GNU_IFUNC = 10, // GNU indirect function\n  STT_LOOS = 10,      // Lowest operating system-specific symbol type\n  STT_HIOS = 12,      // Highest operating system-specific symbol type\n  STT_LOPROC = 13,    // Lowest processor-specific symbol type\n  STT_HIPROC = 15,    // Highest processor-specific symbol type\n\n  // AMDGPU symbol types\n  STT_AMDGPU_HSA_KERNEL = 10\n};\n\nenum {\n  STV_DEFAULT = 0,  // Visibility is specified by binding type\n  STV_INTERNAL = 1, // Defined by processor supplements\n  STV_HIDDEN = 2,   // Not visible to other components\n  STV_PROTECTED = 3 // Visible in other components but not preemptable\n};\n\n// Symbol number.\nenum { STN_UNDEF = 0 };\n\n// Special relocation symbols used in the MIPS64 ELF relocation entries\nenum {\n  RSS_UNDEF = 0, // None\n  RSS_GP = 1,    // Value of gp\n  RSS_GP0 = 2,   // Value of gp used to create object being relocated\n  RSS_LOC = 3    // Address of location being relocated\n};\n\n// Relocation entry, without explicit addend.\nstruct Elf32_Rel {\n  Elf32_Addr r_offset; // Location (file byte offset, or program virtual addr)\n  Elf32_Word r_info;   // Symbol table index and type of relocation to apply\n\n  // These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,\n  // and ELF32_R_INFO macros defined in the ELF specification:\n  Elf32_Word getSymbol() const { return (r_info >> 8); }\n  unsigned char getType() const { return (unsigned char)(r_info & 0x0ff); }\n  void setSymbol(Elf32_Word s) { setSymbolAndType(s, getType()); }\n  void setType(unsigned char t) { setSymbolAndType(getSymbol(), t); }\n  void setSymbolAndType(Elf32_Word s, unsigned char t) {\n    r_info = (s << 8) + t;\n  }\n};\n\n// Relocation entry with explicit addend.\nstruct Elf32_Rela {\n  Elf32_Addr r_offset;  // Location (file byte offset, or program virtual addr)\n  Elf32_Word r_info;    // Symbol table index and type of relocation to apply\n  Elf32_Sword r_addend; // Compute value for relocatable field by adding this\n\n  // These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,\n  // and ELF32_R_INFO macros defined in the ELF specification:\n  Elf32_Word getSymbol() const { return (r_info >> 8); }\n  unsigned char getType() const { return (unsigned char)(r_info & 0x0ff); }\n  void setSymbol(Elf32_Word s) { setSymbolAndType(s, getType()); }\n  void setType(unsigned char t) { setSymbolAndType(getSymbol(), t); }\n  void setSymbolAndType(Elf32_Word s, unsigned char t) {\n    r_info = (s << 8) + t;\n  }\n};\n\n// Relocation entry, without explicit addend.\nstruct Elf64_Rel {\n  Elf64_Addr r_offset; // Location (file byte offset, or program virtual addr).\n  Elf64_Xword r_info;  // Symbol table index and type of relocation to apply.\n\n  // These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,\n  // and ELF64_R_INFO macros defined in the ELF specification:\n  Elf64_Word getSymbol() const { return (r_info >> 32); }\n  Elf64_Word getType() const { return (Elf64_Word)(r_info & 0xffffffffL); }\n  void setSymbol(Elf64_Word s) { setSymbolAndType(s, getType()); }\n  void setType(Elf64_Word t) { setSymbolAndType(getSymbol(), t); }\n  void setSymbolAndType(Elf64_Word s, Elf64_Word t) {\n    r_info = ((Elf64_Xword)s << 32) + (t & 0xffffffffL);\n  }\n};\n\n// Relocation entry with explicit addend.\nstruct Elf64_Rela {\n  Elf64_Addr r_offset; // Location (file byte offset, or program virtual addr).\n  Elf64_Xword r_info;  // Symbol table index and type of relocation to apply.\n  Elf64_Sxword r_addend; // Compute value for relocatable field by adding this.\n\n  // These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,\n  // and ELF64_R_INFO macros defined in the ELF specification:\n  Elf64_Word getSymbol() const { return (r_info >> 32); }\n  Elf64_Word getType() const { return (Elf64_Word)(r_info & 0xffffffffL); }\n  void setSymbol(Elf64_Word s) { setSymbolAndType(s, getType()); }\n  void setType(Elf64_Word t) { setSymbolAndType(getSymbol(), t); }\n  void setSymbolAndType(Elf64_Word s, Elf64_Word t) {\n    r_info = ((Elf64_Xword)s << 32) + (t & 0xffffffffL);\n  }\n};\n\n// Program header for ELF32.\nstruct Elf32_Phdr {\n  Elf32_Word p_type;   // Type of segment\n  Elf32_Off p_offset;  // File offset where segment is located, in bytes\n  Elf32_Addr p_vaddr;  // Virtual address of beginning of segment\n  Elf32_Addr p_paddr;  // Physical address of beginning of segment (OS-specific)\n  Elf32_Word p_filesz; // Num. of bytes in file image of segment (may be zero)\n  Elf32_Word p_memsz;  // Num. of bytes in mem image of segment (may be zero)\n  Elf32_Word p_flags;  // Segment flags\n  Elf32_Word p_align;  // Segment alignment constraint\n};\n\n// Program header for ELF64.\nstruct Elf64_Phdr {\n  Elf64_Word p_type;    // Type of segment\n  Elf64_Word p_flags;   // Segment flags\n  Elf64_Off p_offset;   // File offset where segment is located, in bytes\n  Elf64_Addr p_vaddr;   // Virtual address of beginning of segment\n  Elf64_Addr p_paddr;   // Physical addr of beginning of segment (OS-specific)\n  Elf64_Xword p_filesz; // Num. of bytes in file image of segment (may be zero)\n  Elf64_Xword p_memsz;  // Num. of bytes in mem image of segment (may be zero)\n  Elf64_Xword p_align;  // Segment alignment constraint\n};\n\n// Segment types.\nenum {\n  PT_NULL = 0,            // Unused segment.\n  PT_LOAD = 1,            // Loadable segment.\n  PT_DYNAMIC = 2,         // Dynamic linking information.\n  PT_INTERP = 3,          // Interpreter pathname.\n  PT_NOTE = 4,            // Auxiliary information.\n  PT_SHLIB = 5,           // Reserved.\n  PT_PHDR = 6,            // The program header table itself.\n  PT_TLS = 7,             // The thread-local storage template.\n  PT_LOOS = 0x60000000,   // Lowest operating system-specific pt entry type.\n  PT_HIOS = 0x6fffffff,   // Highest operating system-specific pt entry type.\n  PT_LOPROC = 0x70000000, // Lowest processor-specific program hdr entry type.\n  PT_HIPROC = 0x7fffffff, // Highest processor-specific program hdr entry type.\n\n  // x86-64 program header types.\n  // These all contain stack unwind tables.\n  PT_GNU_EH_FRAME = 0x6474e550,\n  PT_SUNW_EH_FRAME = 0x6474e550,\n  PT_SUNW_UNWIND = 0x6464e550,\n\n  PT_GNU_STACK = 0x6474e551, // Indicates stack executability.\n  PT_GNU_RELRO = 0x6474e552, // Read-only after relocation.\n\n  PT_OPENBSD_RANDOMIZE = 0x65a3dbe6, // Fill with random data.\n  PT_OPENBSD_WXNEEDED = 0x65a3dbe7,  // Program does W^X violations.\n  PT_OPENBSD_BOOTDATA = 0x65a41be6,  // Section for boot arguments.\n\n  // ARM program header types.\n  PT_ARM_ARCHEXT = 0x70000000, // Platform architecture compatibility info\n  // These all contain stack unwind tables.\n  PT_ARM_EXIDX = 0x70000001,\n  PT_ARM_UNWIND = 0x70000001,\n\n  // MIPS program header types.\n  PT_MIPS_REGINFO = 0x70000000,  // Register usage information.\n  PT_MIPS_RTPROC = 0x70000001,   // Runtime procedure table.\n  PT_MIPS_OPTIONS = 0x70000002,  // Options segment.\n  PT_MIPS_ABIFLAGS = 0x70000003, // Abiflags segment.\n\n  // WebAssembly program header types.\n  PT_WEBASSEMBLY_FUNCTIONS = PT_LOPROC + 0, // Function definitions.\n};\n\n// Segment flag bits.\nenum : unsigned {\n  PF_X = 1,                // Execute\n  PF_W = 2,                // Write\n  PF_R = 4,                // Read\n  PF_MASKOS = 0x0ff00000,  // Bits for operating system-specific semantics.\n  PF_MASKPROC = 0xf0000000 // Bits for processor-specific semantics.\n};\n\n// Dynamic table entry for ELF32.\nstruct Elf32_Dyn {\n  Elf32_Sword d_tag; // Type of dynamic table entry.\n  union {\n    Elf32_Word d_val; // Integer value of entry.\n    Elf32_Addr d_ptr; // Pointer value of entry.\n  } d_un;\n};\n\n// Dynamic table entry for ELF64.\nstruct Elf64_Dyn {\n  Elf64_Sxword d_tag; // Type of dynamic table entry.\n  union {\n    Elf64_Xword d_val; // Integer value of entry.\n    Elf64_Addr d_ptr;  // Pointer value of entry.\n  } d_un;\n};\n\n// Dynamic table entry tags.\nenum {\n  DT_NULL = 0,          // Marks end of dynamic array.\n  DT_NEEDED = 1,        // String table offset of needed library.\n  DT_PLTRELSZ = 2,      // Size of relocation entries in PLT.\n  DT_PLTGOT = 3,        // Address associated with linkage table.\n  DT_HASH = 4,          // Address of symbolic hash table.\n  DT_STRTAB = 5,        // Address of dynamic string table.\n  DT_SYMTAB = 6,        // Address of dynamic symbol table.\n  DT_RELA = 7,          // Address of relocation table (Rela entries).\n  DT_RELASZ = 8,        // Size of Rela relocation table.\n  DT_RELAENT = 9,       // Size of a Rela relocation entry.\n  DT_STRSZ = 10,        // Total size of the string table.\n  DT_SYMENT = 11,       // Size of a symbol table entry.\n  DT_INIT = 12,         // Address of initialization function.\n  DT_FINI = 13,         // Address of termination function.\n  DT_SONAME = 14,       // String table offset of a shared objects name.\n  DT_RPATH = 15,        // String table offset of library search path.\n  DT_SYMBOLIC = 16,     // Changes symbol resolution algorithm.\n  DT_REL = 17,          // Address of relocation table (Rel entries).\n  DT_RELSZ = 18,        // Size of Rel relocation table.\n  DT_RELENT = 19,       // Size of a Rel relocation entry.\n  DT_PLTREL = 20,       // Type of relocation entry used for linking.\n  DT_DEBUG = 21,        // Reserved for debugger.\n  DT_TEXTREL = 22,      // Relocations exist for non-writable segments.\n  DT_JMPREL = 23,       // Address of relocations associated with PLT.\n  DT_BIND_NOW = 24,     // Process all relocations before execution.\n  DT_INIT_ARRAY = 25,   // Pointer to array of initialization functions.\n  DT_FINI_ARRAY = 26,   // Pointer to array of termination functions.\n  DT_INIT_ARRAYSZ = 27, // Size of DT_INIT_ARRAY.\n  DT_FINI_ARRAYSZ = 28, // Size of DT_FINI_ARRAY.\n  DT_RUNPATH = 29,      // String table offset of lib search path.\n  DT_FLAGS = 30,        // Flags.\n  DT_ENCODING = 32,     // Values from here to DT_LOOS follow the rules\n                        // for the interpretation of the d_un union.\n\n  DT_PREINIT_ARRAY = 32,   // Pointer to array of preinit functions.\n  DT_PREINIT_ARRAYSZ = 33, // Size of the DT_PREINIT_ARRAY array.\n\n  DT_LOOS = 0x60000000,   // Start of environment specific tags.\n  DT_HIOS = 0x6FFFFFFF,   // End of environment specific tags.\n  DT_LOPROC = 0x70000000, // Start of processor specific tags.\n  DT_HIPROC = 0x7FFFFFFF, // End of processor specific tags.\n\n  // Android packed relocation section tags.\n  // https://android.googlesource.com/platform/bionic/+/6f12bfece5dcc01325e0abba56a46b1bcf991c69/tools/relocation_packer/src/elf_file.cc#31\n  DT_ANDROID_REL = 0x6000000F,\n  DT_ANDROID_RELSZ = 0x60000010,\n  DT_ANDROID_RELA = 0x60000011,\n  DT_ANDROID_RELASZ = 0x60000012,\n\n  DT_GNU_HASH = 0x6FFFFEF5, // Reference to the GNU hash table.\n  DT_TLSDESC_PLT =\n      0x6FFFFEF6, // Location of PLT entry for TLS descriptor resolver calls.\n  DT_TLSDESC_GOT = 0x6FFFFEF7, // Location of GOT entry used by TLS descriptor\n                               // resolver PLT entry.\n  DT_RELACOUNT = 0x6FFFFFF9,   // ELF32_Rela count.\n  DT_RELCOUNT = 0x6FFFFFFA,    // ELF32_Rel count.\n\n  DT_FLAGS_1 = 0X6FFFFFFB,    // Flags_1.\n  DT_VERSYM = 0x6FFFFFF0,     // The address of .gnu.version section.\n  DT_VERDEF = 0X6FFFFFFC,     // The address of the version definition table.\n  DT_VERDEFNUM = 0X6FFFFFFD,  // The number of entries in DT_VERDEF.\n  DT_VERNEED = 0X6FFFFFFE,    // The address of the version Dependency table.\n  DT_VERNEEDNUM = 0X6FFFFFFF, // The number of entries in DT_VERNEED.\n\n  // Hexagon specific dynamic table entries\n  DT_HEXAGON_SYMSZ = 0x70000000,\n  DT_HEXAGON_VER = 0x70000001,\n  DT_HEXAGON_PLT = 0x70000002,\n\n  // Mips specific dynamic table entry tags.\n  DT_MIPS_RLD_VERSION = 0x70000001,    // 32 bit version number for runtime\n                                       // linker interface.\n  DT_MIPS_TIME_STAMP = 0x70000002,     // Time stamp.\n  DT_MIPS_ICHECKSUM = 0x70000003,      // Checksum of external strings\n                                       // and common sizes.\n  DT_MIPS_IVERSION = 0x70000004,       // Index of version string\n                                       // in string table.\n  DT_MIPS_FLAGS = 0x70000005,          // 32 bits of flags.\n  DT_MIPS_BASE_ADDRESS = 0x70000006,   // Base address of the segment.\n  DT_MIPS_MSYM = 0x70000007,           // Address of .msym section.\n  DT_MIPS_CONFLICT = 0x70000008,       // Address of .conflict section.\n  DT_MIPS_LIBLIST = 0x70000009,        // Address of .liblist section.\n  DT_MIPS_LOCAL_GOTNO = 0x7000000a,    // Number of local global offset\n                                       // table entries.\n  DT_MIPS_CONFLICTNO = 0x7000000b,     // Number of entries\n                                       // in the .conflict section.\n  DT_MIPS_LIBLISTNO = 0x70000010,      // Number of entries\n                                       // in the .liblist section.\n  DT_MIPS_SYMTABNO = 0x70000011,       // Number of entries\n                                       // in the .dynsym section.\n  DT_MIPS_UNREFEXTNO = 0x70000012,     // Index of first external dynamic symbol\n                                       // not referenced locally.\n  DT_MIPS_GOTSYM = 0x70000013,         // Index of first dynamic symbol\n                                       // in global offset table.\n  DT_MIPS_HIPAGENO = 0x70000014,       // Number of page table entries\n                                       // in global offset table.\n  DT_MIPS_RLD_MAP = 0x70000016,        // Address of run time loader map,\n                                       // used for debugging.\n  DT_MIPS_DELTA_CLASS = 0x70000017,    // Delta C++ class definition.\n  DT_MIPS_DELTA_CLASS_NO = 0x70000018, // Number of entries\n                                       // in DT_MIPS_DELTA_CLASS.\n  DT_MIPS_DELTA_INSTANCE = 0x70000019, // Delta C++ class instances.\n  DT_MIPS_DELTA_INSTANCE_NO = 0x7000001A,     // Number of entries\n                                              // in DT_MIPS_DELTA_INSTANCE.\n  DT_MIPS_DELTA_RELOC = 0x7000001B,           // Delta relocations.\n  DT_MIPS_DELTA_RELOC_NO = 0x7000001C,        // Number of entries\n                                              // in DT_MIPS_DELTA_RELOC.\n  DT_MIPS_DELTA_SYM = 0x7000001D,             // Delta symbols that Delta\n                                              // relocations refer to.\n  DT_MIPS_DELTA_SYM_NO = 0x7000001E,          // Number of entries\n                                              // in DT_MIPS_DELTA_SYM.\n  DT_MIPS_DELTA_CLASSSYM = 0x70000020,        // Delta symbols that hold\n                                              // class declarations.\n  DT_MIPS_DELTA_CLASSSYM_NO = 0x70000021,     // Number of entries\n                                              // in DT_MIPS_DELTA_CLASSSYM.\n  DT_MIPS_CXX_FLAGS = 0x70000022,             // Flags indicating information\n                                              // about C++ flavor.\n  DT_MIPS_PIXIE_INIT = 0x70000023,            // Pixie information.\n  DT_MIPS_SYMBOL_LIB = 0x70000024,            // Address of .MIPS.symlib\n  DT_MIPS_LOCALPAGE_GOTIDX = 0x70000025,      // The GOT index of the first PTE\n                                              // for a segment\n  DT_MIPS_LOCAL_GOTIDX = 0x70000026,          // The GOT index of the first PTE\n                                              // for a local symbol\n  DT_MIPS_HIDDEN_GOTIDX = 0x70000027,         // The GOT index of the first PTE\n                                              // for a hidden symbol\n  DT_MIPS_PROTECTED_GOTIDX = 0x70000028,      // The GOT index of the first PTE\n                                              // for a protected symbol\n  DT_MIPS_OPTIONS = 0x70000029,               // Address of `.MIPS.options'.\n  DT_MIPS_INTERFACE = 0x7000002A,             // Address of `.interface'.\n  DT_MIPS_DYNSTR_ALIGN = 0x7000002B,          // Unknown.\n  DT_MIPS_INTERFACE_SIZE = 0x7000002C,        // Size of the .interface section.\n  DT_MIPS_RLD_TEXT_RESOLVE_ADDR = 0x7000002D, // Size of rld_text_resolve\n                                              // function stored in the GOT.\n  DT_MIPS_PERF_SUFFIX = 0x7000002E,  // Default suffix of DSO to be added\n                                     // by rld on dlopen() calls.\n  DT_MIPS_COMPACT_SIZE = 0x7000002F, // Size of compact relocation\n                                     // section (O32).\n  DT_MIPS_GP_VALUE = 0x70000030,     // GP value for auxiliary GOTs.\n  DT_MIPS_AUX_DYNAMIC = 0x70000031,  // Address of auxiliary .dynamic.\n  DT_MIPS_PLTGOT = 0x70000032,       // Address of the base of the PLTGOT.\n  DT_MIPS_RWPLT = 0x70000034,        // Points to the base\n                                     // of a writable PLT.\n  DT_MIPS_RLD_MAP_REL = 0x70000035,  // Relative offset of run time loader\n                                     // map, used for debugging.\n\n  // Sun machine-independent extensions.\n  DT_AUXILIARY = 0x7FFFFFFD, // Shared object to load before self\n  DT_FILTER = 0x7FFFFFFF     // Shared object to get values from\n};\n\n// DT_FLAGS values.\nenum {\n  DF_ORIGIN = 0x01,    // The object may reference $ORIGIN.\n  DF_SYMBOLIC = 0x02,  // Search the shared lib before searching the exe.\n  DF_TEXTREL = 0x04,   // Relocations may modify a non-writable segment.\n  DF_BIND_NOW = 0x08,  // Process all relocations on load.\n  DF_STATIC_TLS = 0x10 // Reject attempts to load dynamically.\n};\n\n// State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1 entry.\nenum {\n  DF_1_NOW = 0x00000001,       // Set RTLD_NOW for this object.\n  DF_1_GLOBAL = 0x00000002,    // Set RTLD_GLOBAL for this object.\n  DF_1_GROUP = 0x00000004,     // Set RTLD_GROUP for this object.\n  DF_1_NODELETE = 0x00000008,  // Set RTLD_NODELETE for this object.\n  DF_1_LOADFLTR = 0x00000010,  // Trigger filtee loading at runtime.\n  DF_1_INITFIRST = 0x00000020, // Set RTLD_INITFIRST for this object.\n  DF_1_NOOPEN = 0x00000040,    // Set RTLD_NOOPEN for this object.\n  DF_1_ORIGIN = 0x00000080,    // $ORIGIN must be handled.\n  DF_1_DIRECT = 0x00000100,    // Direct binding enabled.\n  DF_1_TRANS = 0x00000200,\n  DF_1_INTERPOSE = 0x00000400,  // Object is used to interpose.\n  DF_1_NODEFLIB = 0x00000800,   // Ignore default lib search path.\n  DF_1_NODUMP = 0x00001000,     // Object can't be dldump'ed.\n  DF_1_CONFALT = 0x00002000,    // Configuration alternative created.\n  DF_1_ENDFILTEE = 0x00004000,  // Filtee terminates filters search.\n  DF_1_DISPRELDNE = 0x00008000, // Disp reloc applied at build time.\n  DF_1_DISPRELPND = 0x00010000, // Disp reloc applied at run-time.\n  DF_1_NODIRECT = 0x00020000,   // Object has no-direct binding.\n  DF_1_IGNMULDEF = 0x00040000,\n  DF_1_NOKSYMS = 0x00080000,\n  DF_1_NOHDR = 0x00100000,\n  DF_1_EDITED = 0x00200000, // Object is modified after built.\n  DF_1_NORELOC = 0x00400000,\n  DF_1_SYMINTPOSE = 0x00800000, // Object has individual interposers.\n  DF_1_GLOBAUDIT = 0x01000000,  // Global auditing required.\n  DF_1_SINGLETON = 0x02000000   // Singleton symbols are used.\n};\n\n// DT_MIPS_FLAGS values.\nenum {\n  RHF_NONE = 0x00000000,                   // No flags.\n  RHF_QUICKSTART = 0x00000001,             // Uses shortcut pointers.\n  RHF_NOTPOT = 0x00000002,                 // Hash size is not a power of two.\n  RHS_NO_LIBRARY_REPLACEMENT = 0x00000004, // Ignore LD_LIBRARY_PATH.\n  RHF_NO_MOVE = 0x00000008,                // DSO address may not be relocated.\n  RHF_SGI_ONLY = 0x00000010,               // SGI specific features.\n  RHF_GUARANTEE_INIT = 0x00000020,         // Guarantee that .init will finish\n                                           // executing before any non-init\n                                           // code in DSO is called.\n  RHF_DELTA_C_PLUS_PLUS = 0x00000040,      // Contains Delta C++ code.\n  RHF_GUARANTEE_START_INIT = 0x00000080,   // Guarantee that .init will start\n                                           // executing before any non-init\n                                           // code in DSO is called.\n  RHF_PIXIE = 0x00000100,                  // Generated by pixie.\n  RHF_DEFAULT_DELAY_LOAD = 0x00000200,     // Delay-load DSO by default.\n  RHF_REQUICKSTART = 0x00000400,           // Object may be requickstarted\n  RHF_REQUICKSTARTED = 0x00000800,         // Object has been requickstarted\n  RHF_CORD = 0x00001000,                   // Generated by cord.\n  RHF_NO_UNRES_UNDEF = 0x00002000,         // Object contains no unresolved\n                                           // undef symbols.\n  RHF_RLD_ORDER_SAFE = 0x00004000          // Symbol table is in a safe order.\n};\n\n// ElfXX_VerDef structure version (GNU versioning)\nenum { VER_DEF_NONE = 0, VER_DEF_CURRENT = 1 };\n\n// VerDef Flags (ElfXX_VerDef::vd_flags)\nenum { VER_FLG_BASE = 0x1, VER_FLG_WEAK = 0x2, VER_FLG_INFO = 0x4 };\n\n// Special constants for the version table. (SHT_GNU_versym/.gnu.version)\nenum {\n  VER_NDX_LOCAL = 0,       // Unversioned local symbol\n  VER_NDX_GLOBAL = 1,      // Unversioned global symbol\n  VERSYM_VERSION = 0x7fff, // Version Index mask\n  VERSYM_HIDDEN = 0x8000   // Hidden bit (non-default version)\n};\n\n// ElfXX_VerNeed structure version (GNU versioning)\nenum { VER_NEED_NONE = 0, VER_NEED_CURRENT = 1 };\n\n// SHT_NOTE section types\nenum {\n  NT_FREEBSD_THRMISC = 7,\n  NT_FREEBSD_PROCSTAT_PROC = 8,\n  NT_FREEBSD_PROCSTAT_FILES = 9,\n  NT_FREEBSD_PROCSTAT_VMMAP = 10,\n  NT_FREEBSD_PROCSTAT_GROUPS = 11,\n  NT_FREEBSD_PROCSTAT_UMASK = 12,\n  NT_FREEBSD_PROCSTAT_RLIMIT = 13,\n  NT_FREEBSD_PROCSTAT_OSREL = 14,\n  NT_FREEBSD_PROCSTAT_PSSTRINGS = 15,\n  NT_FREEBSD_PROCSTAT_AUXV = 16,\n};\n\nenum {\n  NT_GNU_ABI_TAG = 1,\n  NT_GNU_HWCAP = 2,\n  NT_GNU_BUILD_ID = 3,\n  NT_GNU_GOLD_VERSION = 4,\n};\n\n// AMDGPU specific notes.\nenum {\n  // Note types with values between 0 and 9 (inclusive) are reserved.\n  NT_AMD_AMDGPU_HSA_METADATA = 10,\n  NT_AMD_AMDGPU_ISA = 11,\n  NT_AMD_AMDGPU_PAL_METADATA = 12\n};\n\nenum {\n  GNU_ABI_TAG_LINUX = 0,\n  GNU_ABI_TAG_HURD = 1,\n  GNU_ABI_TAG_SOLARIS = 2,\n  GNU_ABI_TAG_FREEBSD = 3,\n  GNU_ABI_TAG_NETBSD = 4,\n  GNU_ABI_TAG_SYLLABLE = 5,\n  GNU_ABI_TAG_NACL = 6,\n};\n\n// Android packed relocation group flags.\nenum {\n  RELOCATION_GROUPED_BY_INFO_FLAG = 1,\n  RELOCATION_GROUPED_BY_OFFSET_DELTA_FLAG = 2,\n  RELOCATION_GROUPED_BY_ADDEND_FLAG = 4,\n  RELOCATION_GROUP_HAS_ADDEND_FLAG = 8,\n};\n\n// Compressed section header for ELF32.\nstruct Elf32_Chdr {\n  Elf32_Word ch_type;\n  Elf32_Word ch_size;\n  Elf32_Word ch_addralign;\n};\n\n// Compressed section header for ELF64.\nstruct Elf64_Chdr {\n  Elf64_Word ch_type;\n  Elf64_Word ch_reserved;\n  Elf64_Xword ch_size;\n  Elf64_Xword ch_addralign;\n};\n\n// Legal values for ch_type field of compressed section header.\nenum {\n  ELFCOMPRESS_ZLIB = 1,            // ZLIB/DEFLATE algorithm.\n  ELFCOMPRESS_LOOS = 0x60000000,   // Start of OS-specific.\n  ELFCOMPRESS_HIOS = 0x6fffffff,   // End of OS-specific.\n  ELFCOMPRESS_LOPROC = 0x70000000, // Start of processor-specific.\n  ELFCOMPRESS_HIPROC = 0x7fffffff  // End of processor-specific.\n};\n\n} // end namespace ELF\n} // end namespace llvm\n\n#endif // LLVM_BINARYFORMAT_ELF_H\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/include/llvm/Support/DynamicLibrary.h": "//===-- llvm/Support/DynamicLibrary.h - Portable Dynamic Library -*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the sys::DynamicLibrary class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_DYNAMICLIBRARY_H\n#define LLVM_SUPPORT_DYNAMICLIBRARY_H\n\n#include <string>\n\nnamespace llvm {\n\nclass StringRef;\n\nnamespace sys {\n\n  /// This class provides a portable interface to dynamic libraries which also\n  /// might be known as shared libraries, shared objects, dynamic shared\n  /// objects, or dynamic link libraries. Regardless of the terminology or the\n  /// operating system interface, this class provides a portable interface that\n  /// allows dynamic libraries to be loaded and searched for externally\n  /// defined symbols. This is typically used to provide \"plug-in\" support.\n  /// It also allows for symbols to be defined which don't live in any library,\n  /// but rather the main program itself, useful on Windows where the main\n  /// executable cannot be searched.\n  ///\n  /// Note: there is currently no interface for temporarily loading a library,\n  /// or for unloading libraries when the LLVM library is unloaded.\n  class DynamicLibrary {\n    // Placeholder whose address represents an invalid library.\n    // We use this instead of NULL or a pointer-int pair because the OS library\n    // might define 0 or 1 to be \"special\" handles, such as \"search all\".\n    static char Invalid;\n\n    // Opaque data used to interface with OS-specific dynamic library handling.\n    void *Data;\n\n  public:\n    explicit DynamicLibrary(void *data = &Invalid) : Data(data) {}\n\n    /// Returns true if the object refers to a valid library.\n    bool isValid() const { return Data != &Invalid; }\n\n    /// Searches through the library for the symbol \\p symbolName. If it is\n    /// found, the address of that symbol is returned. If not, NULL is returned.\n    /// Note that NULL will also be returned if the library failed to load.\n    /// Use isValid() to distinguish these cases if it is important.\n    /// Note that this will \\e not search symbols explicitly registered by\n    /// AddSymbol().\n    void *getAddressOfSymbol(const char *symbolName);\n\n    /// This function permanently loads the dynamic library at the given path.\n    /// The library will only be unloaded when llvm_shutdown() is called.\n    /// This returns a valid DynamicLibrary instance on success and an invalid\n    /// instance on failure (see isValid()). \\p *errMsg will only be modified\n    /// if the library fails to load.\n    ///\n    /// It is safe to call this function multiple times for the same library.\n    /// @brief Open a dynamic library permanently.\n    static DynamicLibrary getPermanentLibrary(const char *filename,\n                                              std::string *errMsg = nullptr);\n\n    /// Registers an externally loaded library. The library will be unloaded\n    /// when the program terminates.\n    ///\n    /// It is safe to call this function multiple times for the same library,\n    /// though ownership is only taken if there was no error.\n    ///\n    /// \\returns An empty \\p DynamicLibrary if the library was already loaded.\n    static DynamicLibrary addPermanentLibrary(void *handle,\n                                              std::string *errMsg = nullptr);\n\n    /// This function permanently loads the dynamic library at the given path.\n    /// Use this instead of getPermanentLibrary() when you won't need to get\n    /// symbols from the library itself.\n    ///\n    /// It is safe to call this function multiple times for the same library.\n    static bool LoadLibraryPermanently(const char *Filename,\n                                       std::string *ErrMsg = nullptr) {\n      return !getPermanentLibrary(Filename, ErrMsg).isValid();\n    }\n\n    enum SearchOrdering {\n      /// SO_Linker - Search as a call to dlsym(dlopen(NULL)) would when\n      /// DynamicLibrary::getPermanentLibrary(NULL) has been called or\n      /// search the list of explcitly loaded symbols if not.\n      SO_Linker,\n      /// SO_LoadedFirst - Search all loaded libraries, then as SO_Linker would.\n      SO_LoadedFirst,\n      /// SO_LoadedLast - Search as SO_Linker would, then loaded libraries.\n      /// Only useful to search if libraries with RTLD_LOCAL have been added.\n      SO_LoadedLast,\n      /// SO_LoadOrder - Or this in to search libraries in the ordered loaded.\n      /// The default bahaviour is to search loaded libraries in reverse.\n      SO_LoadOrder = 4\n    };\n    static SearchOrdering SearchOrder; // = SO_Linker\n\n    /// This function will search through all previously loaded dynamic\n    /// libraries for the symbol \\p symbolName. If it is found, the address of\n    /// that symbol is returned. If not, null is returned. Note that this will\n    /// search permanently loaded libraries (getPermanentLibrary()) as well\n    /// as explicitly registered symbols (AddSymbol()).\n    /// @throws std::string on error.\n    /// @brief Search through libraries for address of a symbol\n    static void *SearchForAddressOfSymbol(const char *symbolName);\n\n    /// @brief Convenience function for C++ophiles.\n    static void *SearchForAddressOfSymbol(const std::string &symbolName) {\n      return SearchForAddressOfSymbol(symbolName.c_str());\n    }\n\n    /// This functions permanently adds the symbol \\p symbolName with the\n    /// value \\p symbolValue.  These symbols are searched before any\n    /// libraries.\n    /// @brief Add searchable symbol/value pair.\n    static void AddSymbol(StringRef symbolName, void *symbolValue);\n\n    class HandleSet;\n  };\n\n} // End sys namespace\n} // End llvm namespace\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/include/llvm-c/LinkTimeOptimizer.h": "//===-- llvm/LinkTimeOptimizer.h - LTO Public C Interface -------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This header provides a C API to use the LLVM link time optimization\n// library. This is intended to be used by linkers which are C-only in\n// their implementation for performing LTO.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_C_LINKTIMEOPTIMIZER_H\n#define LLVM_C_LINKTIMEOPTIMIZER_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * @defgroup LLVMCLinkTimeOptimizer Link Time Optimization\n * @ingroup LLVMC\n *\n * @{\n */\n\n  /// This provides a dummy type for pointers to the LTO object.\n  typedef void* llvm_lto_t;\n\n  /// This provides a C-visible enumerator to manage status codes.\n  /// This should map exactly onto the C++ enumerator LTOStatus.\n  typedef enum llvm_lto_status {\n    LLVM_LTO_UNKNOWN,\n    LLVM_LTO_OPT_SUCCESS,\n    LLVM_LTO_READ_SUCCESS,\n    LLVM_LTO_READ_FAILURE,\n    LLVM_LTO_WRITE_FAILURE,\n    LLVM_LTO_NO_TARGET,\n    LLVM_LTO_NO_WORK,\n    LLVM_LTO_MODULE_MERGE_FAILURE,\n    LLVM_LTO_ASM_FAILURE,\n\n    //  Added C-specific error codes\n    LLVM_LTO_NULL_OBJECT\n  } llvm_lto_status_t;\n\n  /// This provides C interface to initialize link time optimizer. This allows\n  /// linker to use dlopen() interface to dynamically load LinkTimeOptimizer.\n  /// extern \"C\" helps, because dlopen() interface uses name to find the symbol.\n  extern llvm_lto_t llvm_create_optimizer(void);\n  extern void llvm_destroy_optimizer(llvm_lto_t lto);\n\n  extern llvm_lto_status_t llvm_read_object_file\n    (llvm_lto_t lto, const char* input_filename);\n  extern llvm_lto_status_t llvm_optimize_modules\n    (llvm_lto_t lto, const char* output_filename);\n\n/**\n * @}\n */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/cmake/config-ix.cmake": "if( WIN32 AND NOT CYGWIN )\n  # We consider Cygwin as another Unix\n  set(PURE_WINDOWS 1)\nendif()\n\ninclude(CheckIncludeFile)\ninclude(CheckIncludeFileCXX)\ninclude(CheckLibraryExists)\ninclude(CheckSymbolExists)\ninclude(CheckFunctionExists)\ninclude(CheckCCompilerFlag)\ninclude(CheckCXXSourceCompiles)\ninclude(TestBigEndian)\n\ninclude(CheckCompilerVersion)\ninclude(HandleLLVMStdlib)\n\nif( UNIX AND NOT (BEOS OR HAIKU) )\n  # Used by check_symbol_exists:\n  list(APPEND CMAKE_REQUIRED_LIBRARIES \"m\")\nendif()\n# x86_64 FreeBSD 9.2 requires libcxxrt to be specified explicitly.\nif( CMAKE_SYSTEM MATCHES \"FreeBSD-9.2-RELEASE\" AND\n    CMAKE_SIZEOF_VOID_P EQUAL 8 )\n  list(APPEND CMAKE_REQUIRED_LIBRARIES \"cxxrt\")\nendif()\n\n# Helper macros and functions\nmacro(add_cxx_include result files)\n  set(${result} \"\")\n  foreach (file_name ${files})\n     set(${result} \"${${result}}#include<${file_name}>\\n\")\n  endforeach()\nendmacro(add_cxx_include files result)\n\nfunction(check_type_exists type files variable)\n  add_cxx_include(includes \"${files}\")\n  CHECK_CXX_SOURCE_COMPILES(\"\n    ${includes} ${type} typeVar;\n    int main() {\n        return 0;\n    }\n    \" ${variable})\nendfunction()\n\n# include checks\ncheck_include_file(dirent.h HAVE_DIRENT_H)\ncheck_include_file(dlfcn.h HAVE_DLFCN_H)\ncheck_include_file(errno.h HAVE_ERRNO_H)\ncheck_include_file(fcntl.h HAVE_FCNTL_H)\ncheck_include_file(inttypes.h HAVE_INTTYPES_H)\ncheck_include_file(link.h HAVE_LINK_H)\ncheck_include_file(malloc.h HAVE_MALLOC_H)\ncheck_include_file(malloc/malloc.h HAVE_MALLOC_MALLOC_H)\ncheck_include_file(ndir.h HAVE_NDIR_H)\nif( NOT PURE_WINDOWS )\n  check_include_file(pthread.h HAVE_PTHREAD_H)\nendif()\ncheck_include_file(signal.h HAVE_SIGNAL_H)\ncheck_include_file(stdint.h HAVE_STDINT_H)\ncheck_include_file(sys/dir.h HAVE_SYS_DIR_H)\ncheck_include_file(sys/ioctl.h HAVE_SYS_IOCTL_H)\ncheck_include_file(sys/mman.h HAVE_SYS_MMAN_H)\ncheck_include_file(sys/ndir.h HAVE_SYS_NDIR_H)\ncheck_include_file(sys/param.h HAVE_SYS_PARAM_H)\ncheck_include_file(sys/resource.h HAVE_SYS_RESOURCE_H)\ncheck_include_file(sys/stat.h HAVE_SYS_STAT_H)\ncheck_include_file(sys/time.h HAVE_SYS_TIME_H)\ncheck_include_file(sys/types.h HAVE_SYS_TYPES_H)\ncheck_include_file(sys/uio.h HAVE_SYS_UIO_H)\ncheck_include_file(termios.h HAVE_TERMIOS_H)\ncheck_include_file(unistd.h HAVE_UNISTD_H)\ncheck_include_file(valgrind/valgrind.h HAVE_VALGRIND_VALGRIND_H)\ncheck_include_file(zlib.h HAVE_ZLIB_H)\ncheck_include_file(fenv.h HAVE_FENV_H)\ncheck_symbol_exists(FE_ALL_EXCEPT \"fenv.h\" HAVE_DECL_FE_ALL_EXCEPT)\ncheck_symbol_exists(FE_INEXACT \"fenv.h\" HAVE_DECL_FE_INEXACT)\n\ncheck_include_file(mach/mach.h HAVE_MACH_MACH_H)\ncheck_include_file(histedit.h HAVE_HISTEDIT_H)\ncheck_include_file(CrashReporterClient.h HAVE_CRASHREPORTERCLIENT_H)\nif(APPLE)\n  include(CheckCSourceCompiles)\n  CHECK_C_SOURCE_COMPILES(\"\n     static const char *__crashreporter_info__ = 0;\n     asm(\\\".desc ___crashreporter_info__, 0x10\\\");\n     int main() { return 0; }\"\n    HAVE_CRASHREPORTER_INFO)\nendif()\n\nif(${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\n  check_include_file(linux/magic.h HAVE_LINUX_MAGIC_H)\n  if(NOT HAVE_LINUX_MAGIC_H)\n    # older kernels use split files\n    check_include_file(linux/nfs_fs.h HAVE_LINUX_NFS_FS_H)\n    check_include_file(linux/smb.h HAVE_LINUX_SMB_H)\n  endif()\nendif()\n\n# library checks\nif( NOT PURE_WINDOWS )\n  check_library_exists(pthread pthread_create \"\" HAVE_LIBPTHREAD)\n  if (HAVE_LIBPTHREAD)\n    check_library_exists(pthread pthread_getspecific \"\" HAVE_PTHREAD_GETSPECIFIC)\n    check_library_exists(pthread pthread_rwlock_init \"\" HAVE_PTHREAD_RWLOCK_INIT)\n    check_library_exists(pthread pthread_mutex_lock \"\" HAVE_PTHREAD_MUTEX_LOCK)\n  else()\n    # this could be Android\n    check_library_exists(c pthread_create \"\" PTHREAD_IN_LIBC)\n    if (PTHREAD_IN_LIBC)\n      check_library_exists(c pthread_getspecific \"\" HAVE_PTHREAD_GETSPECIFIC)\n      check_library_exists(c pthread_rwlock_init \"\" HAVE_PTHREAD_RWLOCK_INIT)\n      check_library_exists(c pthread_mutex_lock \"\" HAVE_PTHREAD_MUTEX_LOCK)\n    endif()\n  endif()\n  check_library_exists(dl dlopen \"\" HAVE_LIBDL)\n  check_library_exists(rt clock_gettime \"\" HAVE_LIBRT)\nendif()\n\nif(HAVE_LIBPTHREAD)\n  # We want to find pthreads library and at the moment we do want to\n  # have it reported as '-l<lib>' instead of '-pthread'.\n  # TODO: switch to -pthread once the rest of the build system can deal with it.\n  set(CMAKE_THREAD_PREFER_PTHREAD TRUE)\n  set(THREADS_HAVE_PTHREAD_ARG Off)\n  find_package(Threads REQUIRED)\n  set(LLVM_PTHREAD_LIB ${CMAKE_THREAD_LIBS_INIT})\nendif()\n\n# Don't look for these libraries if we're using MSan, since uninstrumented third\n# party code may call MSan interceptors like strlen, leading to false positives.\nif(NOT LLVM_USE_SANITIZER MATCHES \"Memory.*\")\n  set(HAVE_LIBZ 0)\n  if(LLVM_ENABLE_ZLIB)\n    foreach(library z zlib_static zlib)\n      string(TOUPPER ${library} library_suffix)\n      check_library_exists(${library} compress2 \"\" HAVE_LIBZ_${library_suffix})\n      if(HAVE_LIBZ_${library_suffix})\n        set(HAVE_LIBZ 1)\n        set(ZLIB_LIBRARIES \"${library}\")\n        break()\n      endif()\n    endforeach()\n  endif()\n\n  # Don't look for these libraries on Windows.\n  if (NOT PURE_WINDOWS)\n    # Skip libedit if using ASan as it contains memory leaks.\n    if (LLVM_ENABLE_LIBEDIT AND HAVE_HISTEDIT_H AND NOT LLVM_USE_SANITIZER MATCHES \".*Address.*\")\n      check_library_exists(edit el_init \"\" HAVE_LIBEDIT)\n    else()\n      set(HAVE_LIBEDIT 0)\n    endif()\n    if(LLVM_ENABLE_TERMINFO)\n      set(HAVE_TERMINFO 0)\n      foreach(library tinfo terminfo curses ncurses ncursesw)\n        string(TOUPPER ${library} library_suffix)\n        check_library_exists(${library} setupterm \"\" HAVE_TERMINFO_${library_suffix})\n        if(HAVE_TERMINFO_${library_suffix})\n          set(HAVE_TERMINFO 1)\n          set(TERMINFO_LIBS \"${library}\")\n          break()\n        endif()\n      endforeach()\n    else()\n      set(HAVE_TERMINFO 0)\n    endif()\n\n    find_library(ICONV_LIBRARY_PATH NAMES iconv libiconv libiconv-2 c)\n    set(LLVM_LIBXML2_ENABLED 0)\n    set(LIBXML2_FOUND 0)\n    if((LLVM_ENABLE_LIBXML2) AND ((CMAKE_SYSTEM_NAME MATCHES \"Linux\") AND (ICONV_LIBRARY_PATH) OR APPLE))\n      find_package(LibXml2)\n      if (LIBXML2_FOUND)\n        set(LLVM_LIBXML2_ENABLED 1)\n        include_directories(${LIBXML2_INCLUDE_DIR})\n        set(LIBXML2_LIBS \"xml2\")\n      endif()\n    endif()\n  endif()\nendif()\n\nif (LLVM_ENABLE_LIBXML2 STREQUAL \"FORCE_ON\" AND NOT LLVM_LIBXML2_ENABLED)\n  message(FATAL_ERROR \"Failed to congifure libxml2\")\nendif()\n\ncheck_library_exists(xar xar_open \"\" HAVE_LIBXAR)\nif(HAVE_LIBXAR)\n  set(XAR_LIB xar)\nendif()\n\n# function checks\ncheck_symbol_exists(arc4random \"stdlib.h\" HAVE_DECL_ARC4RANDOM)\nfind_package(Backtrace)\nset(HAVE_BACKTRACE ${Backtrace_FOUND})\nset(BACKTRACE_HEADER ${Backtrace_HEADER})\n\n# Prevent check_symbol_exists from using API that is not supported for a given\n# deployment target.\ncheck_c_compiler_flag(\"-Werror=unguarded-availability-new\" \"C_SUPPORTS_WERROR_UNGUARDED_AVAILABILITY_NEW\")\nif(C_SUPPORTS_WERROR_UNGUARDED_AVAILABILITY_NEW)\n  set(CMAKE_REQUIRED_FLAGS \"${CMAKE_REQUIRED_FLAGS} -Werror=unguarded-availability-new\")\nendif()\n\ncheck_symbol_exists(_Unwind_Backtrace \"unwind.h\" HAVE__UNWIND_BACKTRACE)\ncheck_symbol_exists(getpagesize unistd.h HAVE_GETPAGESIZE)\ncheck_symbol_exists(sysconf unistd.h HAVE_SYSCONF)\ncheck_symbol_exists(getrusage sys/resource.h HAVE_GETRUSAGE)\ncheck_symbol_exists(setrlimit sys/resource.h HAVE_SETRLIMIT)\ncheck_symbol_exists(isatty unistd.h HAVE_ISATTY)\ncheck_symbol_exists(futimens sys/stat.h HAVE_FUTIMENS)\ncheck_symbol_exists(futimes sys/time.h HAVE_FUTIMES)\ncheck_symbol_exists(posix_fallocate fcntl.h HAVE_POSIX_FALLOCATE)\n# AddressSanitizer conflicts with lib/Support/Unix/Signals.inc\n# Avoid sigaltstack on Apple platforms, where backtrace() cannot handle it\n# (rdar://7089625) and _Unwind_Backtrace is unusable because it cannot unwind\n# past the signal handler after an assertion failure (rdar://29866587).\nif( HAVE_SIGNAL_H AND NOT LLVM_USE_SANITIZER MATCHES \".*Address.*\" AND NOT APPLE )\n  check_symbol_exists(sigaltstack signal.h HAVE_SIGALTSTACK)\nendif()\nif( HAVE_SYS_UIO_H )\n  check_symbol_exists(writev sys/uio.h HAVE_WRITEV)\nendif()\nset(CMAKE_REQUIRED_DEFINITIONS \"-D_LARGEFILE64_SOURCE\")\ncheck_symbol_exists(lseek64 \"sys/types.h;unistd.h\" HAVE_LSEEK64)\nset(CMAKE_REQUIRED_DEFINITIONS \"\")\ncheck_symbol_exists(mallctl malloc_np.h HAVE_MALLCTL)\ncheck_symbol_exists(mallinfo malloc.h HAVE_MALLINFO)\ncheck_symbol_exists(malloc_zone_statistics malloc/malloc.h\n                    HAVE_MALLOC_ZONE_STATISTICS)\ncheck_symbol_exists(mkdtemp \"stdlib.h;unistd.h\" HAVE_MKDTEMP)\ncheck_symbol_exists(mkstemp \"stdlib.h;unistd.h\" HAVE_MKSTEMP)\ncheck_symbol_exists(mktemp \"stdlib.h;unistd.h\" HAVE_MKTEMP)\ncheck_symbol_exists(getcwd unistd.h HAVE_GETCWD)\ncheck_symbol_exists(gettimeofday sys/time.h HAVE_GETTIMEOFDAY)\ncheck_symbol_exists(getrlimit \"sys/types.h;sys/time.h;sys/resource.h\" HAVE_GETRLIMIT)\ncheck_symbol_exists(posix_spawn spawn.h HAVE_POSIX_SPAWN)\ncheck_symbol_exists(pread unistd.h HAVE_PREAD)\ncheck_symbol_exists(realpath stdlib.h HAVE_REALPATH)\ncheck_symbol_exists(sbrk unistd.h HAVE_SBRK)\ncheck_symbol_exists(strtoll stdlib.h HAVE_STRTOLL)\ncheck_symbol_exists(strerror string.h HAVE_STRERROR)\ncheck_symbol_exists(strerror_r string.h HAVE_STRERROR_R)\ncheck_symbol_exists(strerror_s string.h HAVE_DECL_STRERROR_S)\ncheck_symbol_exists(setenv stdlib.h HAVE_SETENV)\nif( PURE_WINDOWS )\n  check_symbol_exists(_chsize_s io.h HAVE__CHSIZE_S)\n\n  check_function_exists(_alloca HAVE__ALLOCA)\n  check_function_exists(__alloca HAVE___ALLOCA)\n  check_function_exists(__chkstk HAVE___CHKSTK)\n  check_function_exists(__chkstk_ms HAVE___CHKSTK_MS)\n  check_function_exists(___chkstk HAVE____CHKSTK)\n  check_function_exists(___chkstk_ms HAVE____CHKSTK_MS)\n\n  check_function_exists(__ashldi3 HAVE___ASHLDI3)\n  check_function_exists(__ashrdi3 HAVE___ASHRDI3)\n  check_function_exists(__divdi3 HAVE___DIVDI3)\n  check_function_exists(__fixdfdi HAVE___FIXDFDI)\n  check_function_exists(__fixsfdi HAVE___FIXSFDI)\n  check_function_exists(__floatdidf HAVE___FLOATDIDF)\n  check_function_exists(__lshrdi3 HAVE___LSHRDI3)\n  check_function_exists(__moddi3 HAVE___MODDI3)\n  check_function_exists(__udivdi3 HAVE___UDIVDI3)\n  check_function_exists(__umoddi3 HAVE___UMODDI3)\n\n  check_function_exists(__main HAVE___MAIN)\n  check_function_exists(__cmpdi2 HAVE___CMPDI2)\nendif()\nif( HAVE_DLFCN_H )\n  if( HAVE_LIBDL )\n    list(APPEND CMAKE_REQUIRED_LIBRARIES dl)\n  endif()\n  check_symbol_exists(dlopen dlfcn.h HAVE_DLOPEN)\n  check_symbol_exists(dladdr dlfcn.h HAVE_DLADDR)\n  if( HAVE_LIBDL )\n    list(REMOVE_ITEM CMAKE_REQUIRED_LIBRARIES dl)\n  endif()\nendif()\n\ncheck_symbol_exists(__GLIBC__ stdio.h LLVM_USING_GLIBC)\nif( LLVM_USING_GLIBC )\n  add_definitions( -D_GNU_SOURCE )\n  list(APPEND CMAKE_REQUIRED_DEFINITIONS \"-D_GNU_SOURCE\")\nendif()\n# This check requires _GNU_SOURCE\ncheck_symbol_exists(sched_getaffinity sched.h HAVE_SCHED_GETAFFINITY)\ncheck_symbol_exists(CPU_COUNT sched.h HAVE_CPU_COUNT)\nif(HAVE_LIBPTHREAD)\n  check_library_exists(pthread pthread_getname_np \"\" HAVE_PTHREAD_GETNAME_NP)\n  check_library_exists(pthread pthread_setname_np \"\" HAVE_PTHREAD_SETNAME_NP)\nelseif(PTHREAD_IN_LIBC)\n  check_library_exists(c pthread_getname_np \"\" HAVE_PTHREAD_GETNAME_NP)\n  check_library_exists(c pthread_setname_np \"\" HAVE_PTHREAD_SETNAME_NP)\nendif()\n\nset(headers \"sys/types.h\")\n\nif (HAVE_INTTYPES_H)\n  set(headers ${headers} \"inttypes.h\")\nendif()\n\nif (HAVE_STDINT_H)\n  set(headers ${headers} \"stdint.h\")\nendif()\n\ncheck_type_exists(int64_t \"${headers}\" HAVE_INT64_T)\ncheck_type_exists(uint64_t \"${headers}\" HAVE_UINT64_T)\ncheck_type_exists(u_int64_t \"${headers}\" HAVE_U_INT64_T)\n\n# available programs checks\nfunction(llvm_find_program name)\n  string(TOUPPER ${name} NAME)\n  string(REGEX REPLACE \"\\\\.\" \"_\" NAME ${NAME})\n\n  find_program(LLVM_PATH_${NAME} NAMES ${ARGV})\n  mark_as_advanced(LLVM_PATH_${NAME})\n  if(LLVM_PATH_${NAME})\n    set(HAVE_${NAME} 1 CACHE INTERNAL \"Is ${name} available ?\")\n    mark_as_advanced(HAVE_${NAME})\n  else(LLVM_PATH_${NAME})\n    set(HAVE_${NAME} \"\" CACHE INTERNAL \"Is ${name} available ?\")\n  endif(LLVM_PATH_${NAME})\nendfunction()\n\nif (LLVM_ENABLE_DOXYGEN)\n  llvm_find_program(dot)\nendif ()\n\nif( LLVM_ENABLE_FFI )\n  find_path(FFI_INCLUDE_PATH ffi.h PATHS ${FFI_INCLUDE_DIR})\n  if( EXISTS \"${FFI_INCLUDE_PATH}/ffi.h\" )\n    set(FFI_HEADER ffi.h CACHE INTERNAL \"\")\n    set(HAVE_FFI_H 1 CACHE INTERNAL \"\")\n  else()\n    find_path(FFI_INCLUDE_PATH ffi/ffi.h PATHS ${FFI_INCLUDE_DIR})\n    if( EXISTS \"${FFI_INCLUDE_PATH}/ffi/ffi.h\" )\n      set(FFI_HEADER ffi/ffi.h CACHE INTERNAL \"\")\n      set(HAVE_FFI_FFI_H 1 CACHE INTERNAL \"\")\n    endif()\n  endif()\n\n  if( NOT FFI_HEADER )\n    message(FATAL_ERROR \"libffi includes are not found.\")\n  endif()\n\n  find_library(FFI_LIBRARY_PATH ffi PATHS ${FFI_LIBRARY_DIR})\n  if( NOT FFI_LIBRARY_PATH )\n    message(FATAL_ERROR \"libffi is not found.\")\n  endif()\n\n  list(APPEND CMAKE_REQUIRED_LIBRARIES ${FFI_LIBRARY_PATH})\n  list(APPEND CMAKE_REQUIRED_INCLUDES ${FFI_INCLUDE_PATH})\n  check_symbol_exists(ffi_call ${FFI_HEADER} HAVE_FFI_CALL)\n  list(REMOVE_ITEM CMAKE_REQUIRED_INCLUDES ${FFI_INCLUDE_PATH})\n  list(REMOVE_ITEM CMAKE_REQUIRED_LIBRARIES ${FFI_LIBRARY_PATH})\nelse()\n  unset(HAVE_FFI_FFI_H CACHE)\n  unset(HAVE_FFI_H CACHE)\n  unset(HAVE_FFI_CALL CACHE)\nendif( LLVM_ENABLE_FFI )\n\n# Define LLVM_HAS_ATOMICS if gcc or MSVC atomic builtins are supported.\ninclude(CheckAtomic)\n\nif( LLVM_ENABLE_PIC )\n  set(ENABLE_PIC 1)\nelse()\n  set(ENABLE_PIC 0)\n  check_cxx_compiler_flag(\"-fno-pie\" SUPPORTS_NO_PIE_FLAG)\n  if(SUPPORTS_NO_PIE_FLAG)\n    set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -fno-pie\")\n  endif()\nendif()\n\ncheck_cxx_compiler_flag(\"-Wvariadic-macros\" SUPPORTS_VARIADIC_MACROS_FLAG)\ncheck_cxx_compiler_flag(\"-Wgnu-zero-variadic-macro-arguments\"\n                        SUPPORTS_GNU_ZERO_VARIADIC_MACRO_ARGUMENTS_FLAG)\n\nset(USE_NO_MAYBE_UNINITIALIZED 0)\nset(USE_NO_UNINITIALIZED 0)\n\n# Disable gcc's potentially uninitialized use analysis as it presents lots of\n# false positives.\nif (CMAKE_COMPILER_IS_GNUCXX)\n  check_cxx_compiler_flag(\"-Wmaybe-uninitialized\" HAS_MAYBE_UNINITIALIZED)\n  if (HAS_MAYBE_UNINITIALIZED)\n    set(USE_NO_MAYBE_UNINITIALIZED 1)\n  else()\n    # Only recent versions of gcc make the distinction between -Wuninitialized\n    # and -Wmaybe-uninitialized. If -Wmaybe-uninitialized isn't supported, just\n    # turn off all uninitialized use warnings.\n    check_cxx_compiler_flag(\"-Wuninitialized\" HAS_UNINITIALIZED)\n    set(USE_NO_UNINITIALIZED ${HAS_UNINITIALIZED})\n  endif()\nendif()\n\n# By default, we target the host, but this can be overridden at CMake\n# invocation time.\ninclude(GetHostTriple)\nget_host_triple(LLVM_INFERRED_HOST_TRIPLE)\n\nset(LLVM_HOST_TRIPLE \"${LLVM_INFERRED_HOST_TRIPLE}\" CACHE STRING\n    \"Host on which LLVM binaries will run\")\n\n# Determine the native architecture.\nstring(TOLOWER \"${LLVM_TARGET_ARCH}\" LLVM_NATIVE_ARCH)\nif( LLVM_NATIVE_ARCH STREQUAL \"host\" )\n  string(REGEX MATCH \"^[^-]*\" LLVM_NATIVE_ARCH ${LLVM_HOST_TRIPLE})\nendif ()\n\nif (LLVM_NATIVE_ARCH MATCHES \"i[2-6]86\")\n  set(LLVM_NATIVE_ARCH X86)\nelseif (LLVM_NATIVE_ARCH STREQUAL \"x86\")\n  set(LLVM_NATIVE_ARCH X86)\nelseif (LLVM_NATIVE_ARCH STREQUAL \"amd64\")\n  set(LLVM_NATIVE_ARCH X86)\nelseif (LLVM_NATIVE_ARCH STREQUAL \"x86_64\")\n  set(LLVM_NATIVE_ARCH X86)\nelseif (LLVM_NATIVE_ARCH MATCHES \"sparc\")\n  set(LLVM_NATIVE_ARCH Sparc)\nelseif (LLVM_NATIVE_ARCH MATCHES \"powerpc\")\n  set(LLVM_NATIVE_ARCH PowerPC)\nelseif (LLVM_NATIVE_ARCH MATCHES \"aarch64\")\n  set(LLVM_NATIVE_ARCH AArch64)\nelseif (LLVM_NATIVE_ARCH MATCHES \"arm64\")\n  set(LLVM_NATIVE_ARCH AArch64)\nelseif (LLVM_NATIVE_ARCH MATCHES \"arm\")\n  set(LLVM_NATIVE_ARCH ARM)\nelseif (LLVM_NATIVE_ARCH MATCHES \"mips\")\n  set(LLVM_NATIVE_ARCH Mips)\nelseif (LLVM_NATIVE_ARCH MATCHES \"xcore\")\n  set(LLVM_NATIVE_ARCH XCore)\nelseif (LLVM_NATIVE_ARCH MATCHES \"msp430\")\n  set(LLVM_NATIVE_ARCH MSP430)\nelseif (LLVM_NATIVE_ARCH MATCHES \"hexagon\")\n  set(LLVM_NATIVE_ARCH Hexagon)\nelseif (LLVM_NATIVE_ARCH MATCHES \"s390x\")\n  set(LLVM_NATIVE_ARCH SystemZ)\nelseif (LLVM_NATIVE_ARCH MATCHES \"wasm32\")\n  set(LLVM_NATIVE_ARCH WebAssembly)\nelseif (LLVM_NATIVE_ARCH MATCHES \"wasm64\")\n  set(LLVM_NATIVE_ARCH WebAssembly)\nelse ()\n  message(FATAL_ERROR \"Unknown architecture ${LLVM_NATIVE_ARCH}\")\nendif ()\n\n# If build targets includes \"host\", then replace with native architecture.\nlist(FIND LLVM_TARGETS_TO_BUILD \"host\" idx)\nif( NOT idx LESS 0 )\n  list(REMOVE_AT LLVM_TARGETS_TO_BUILD ${idx})\n  list(APPEND LLVM_TARGETS_TO_BUILD ${LLVM_NATIVE_ARCH})\n  list(REMOVE_DUPLICATES LLVM_TARGETS_TO_BUILD)\nendif()\n\nlist(FIND LLVM_TARGETS_TO_BUILD ${LLVM_NATIVE_ARCH} NATIVE_ARCH_IDX)\nif (NATIVE_ARCH_IDX EQUAL -1)\n  message(STATUS\n    \"Native target ${LLVM_NATIVE_ARCH} is not selected; lli will not JIT code\")\nelse ()\n  message(STATUS \"Native target architecture is ${LLVM_NATIVE_ARCH}\")\n  set(LLVM_NATIVE_TARGET LLVMInitialize${LLVM_NATIVE_ARCH}Target)\n  set(LLVM_NATIVE_TARGETINFO LLVMInitialize${LLVM_NATIVE_ARCH}TargetInfo)\n  set(LLVM_NATIVE_TARGETMC LLVMInitialize${LLVM_NATIVE_ARCH}TargetMC)\n  set(LLVM_NATIVE_ASMPRINTER LLVMInitialize${LLVM_NATIVE_ARCH}AsmPrinter)\n\n  # We don't have an ASM parser for all architectures yet.\n  if (EXISTS ${PROJECT_SOURCE_DIR}/lib/Target/${LLVM_NATIVE_ARCH}/AsmParser/CMakeLists.txt)\n    set(LLVM_NATIVE_ASMPARSER LLVMInitialize${LLVM_NATIVE_ARCH}AsmParser)\n  endif ()\n\n  # We don't have an disassembler for all architectures yet.\n  if (EXISTS ${PROJECT_SOURCE_DIR}/lib/Target/${LLVM_NATIVE_ARCH}/Disassembler/CMakeLists.txt)\n    set(LLVM_NATIVE_DISASSEMBLER LLVMInitialize${LLVM_NATIVE_ARCH}Disassembler)\n  endif ()\nendif ()\n\nif( MINGW )\n  set(HAVE_LIBPSAPI 1)\n  set(HAVE_LIBSHELL32 1)\n  # TODO: Check existence of libraries.\n  #   include(CheckLibraryExists)\nendif( MINGW )\n\nif (NOT HAVE_STRTOLL)\n  # Use _strtoi64 if strtoll is not available.\n  check_symbol_exists(_strtoi64 stdlib.h have_strtoi64)\n  if (have_strtoi64)\n    set(HAVE_STRTOLL 1)\n    set(strtoll \"_strtoi64\")\n    set(strtoull \"_strtoui64\")\n  endif ()\nendif ()\n\nif( MSVC )\n  set(SHLIBEXT \".lib\")\n  set(stricmp \"_stricmp\")\n  set(strdup \"_strdup\")\n\n  # See if the DIA SDK is available and usable.\n  set(MSVC_DIA_SDK_DIR \"$ENV{VSINSTALLDIR}DIA SDK\")\n\n  # Due to a bug in MSVC 2013's installation software, it is possible\n  # for MSVC 2013 to write the DIA SDK into the Visual Studio 2012\n  # install directory.  If this happens, the installation is corrupt\n  # and there's nothing we can do.  It happens with enough frequency\n  # though that we should handle it.  We do so by simply checking that\n  # the DIA SDK folder exists.  Should this happen you will need to\n  # uninstall VS 2012 and then re-install VS 2013.\n  if (IS_DIRECTORY ${MSVC_DIA_SDK_DIR})\n    set(HAVE_DIA_SDK 1)\n  else()\n    set(HAVE_DIA_SDK 0)\n  endif()\n\n  option(LLVM_ENABLE_DIA_SDK \"Use MSVC DIA SDK for debugging if available.\"\n                             ${HAVE_DIA_SDK})\n\n  if(LLVM_ENABLE_DIA_SDK AND NOT HAVE_DIA_SDK)\n    message(FATAL_ERROR \"DIA SDK not found. If you have both VS 2012 and 2013 installed, you may need to uninstall the former and re-install the latter afterwards.\")\n  endif()\nelse()\n  set(LLVM_ENABLE_DIA_SDK 0)\nendif( MSVC )\n\n# FIXME: Signal handler return type, currently hardcoded to 'void'\nset(RETSIGTYPE void)\n\nif( LLVM_ENABLE_THREADS )\n  # Check if threading primitives aren't supported on this platform\n  if( NOT HAVE_PTHREAD_H AND NOT WIN32 )\n    set(LLVM_ENABLE_THREADS 0)\n  endif()\nendif()\n\nif( LLVM_ENABLE_THREADS )\n  message(STATUS \"Threads enabled.\")\nelse( LLVM_ENABLE_THREADS )\n  message(STATUS \"Threads disabled.\")\nendif()\n\nif (LLVM_ENABLE_ZLIB )\n  # Check if zlib is available in the system.\n  if ( NOT HAVE_ZLIB_H OR NOT HAVE_LIBZ )\n    set(LLVM_ENABLE_ZLIB 0)\n  endif()\nendif()\n\nif (LLVM_ENABLE_DOXYGEN)\n  message(STATUS \"Doxygen enabled.\")\n  find_package(Doxygen REQUIRED)\n\n  if (DOXYGEN_FOUND)\n    # If we find doxygen and we want to enable doxygen by default create a\n    # global aggregate doxygen target for generating llvm and any/all\n    # subprojects doxygen documentation.\n    if (LLVM_BUILD_DOCS)\n      add_custom_target(doxygen ALL)\n    endif()\n\n    option(LLVM_DOXYGEN_EXTERNAL_SEARCH \"Enable doxygen external search.\" OFF)\n    if (LLVM_DOXYGEN_EXTERNAL_SEARCH)\n      set(LLVM_DOXYGEN_SEARCHENGINE_URL \"\" CACHE STRING \"URL to use for external search.\")\n      set(LLVM_DOXYGEN_SEARCH_MAPPINGS \"\" CACHE STRING \"Doxygen Search Mappings\")\n    endif()\n  endif()\nelse()\n  message(STATUS \"Doxygen disabled.\")\nendif()\n\nset(LLVM_BINDINGS \"\")\nif(WIN32)\n  message(STATUS \"Go bindings disabled.\")\nelse()\n  find_program(GO_EXECUTABLE NAMES go DOC \"go executable\")\n  if(GO_EXECUTABLE STREQUAL \"GO_EXECUTABLE-NOTFOUND\")\n    message(STATUS \"Go bindings disabled.\")\n  else()\n    execute_process(COMMAND ${GO_EXECUTABLE} run ${PROJECT_SOURCE_DIR}/bindings/go/conftest.go\n                    RESULT_VARIABLE GO_CONFTEST)\n    if(GO_CONFTEST STREQUAL \"0\")\n      set(LLVM_BINDINGS \"${LLVM_BINDINGS} go\")\n      message(STATUS \"Go bindings enabled.\")\n    else()\n      message(STATUS \"Go bindings disabled, need at least Go 1.2.\")\n    endif()\n  endif()\nendif()\n\nfind_program(GOLD_EXECUTABLE NAMES ${LLVM_DEFAULT_TARGET_TRIPLE}-ld.gold ld.gold ${LLVM_DEFAULT_TARGET_TRIPLE}-ld ld DOC \"The gold linker\")\nset(LLVM_BINUTILS_INCDIR \"\" CACHE PATH\n\t\"PATH to binutils/include containing plugin-api.h for gold plugin.\")\n\nif(CMAKE_HOST_APPLE AND APPLE)\n  if(NOT CMAKE_XCRUN)\n    find_program(CMAKE_XCRUN NAMES xcrun)\n  endif()\n  if(CMAKE_XCRUN)\n    execute_process(COMMAND ${CMAKE_XCRUN} -find ld\n      OUTPUT_VARIABLE LD64_EXECUTABLE\n      OUTPUT_STRIP_TRAILING_WHITESPACE)\n  else()\n    find_program(LD64_EXECUTABLE NAMES ld DOC \"The ld64 linker\")\n  endif()\n\n  if(LD64_EXECUTABLE)\n    set(LD64_EXECUTABLE ${LD64_EXECUTABLE} CACHE PATH \"ld64 executable\")\n    message(STATUS \"Found ld64 - ${LD64_EXECUTABLE}\")\n  endif()\nendif()\n\n# Keep the version requirements in sync with bindings/ocaml/README.txt.\ninclude(FindOCaml)\ninclude(AddOCaml)\nif(WIN32)\n  message(STATUS \"OCaml bindings disabled.\")\nelse()\n  find_package(OCaml)\n  if( NOT OCAML_FOUND )\n    message(STATUS \"OCaml bindings disabled.\")\n  else()\n    if( OCAML_VERSION VERSION_LESS \"4.00.0\" )\n      message(STATUS \"OCaml bindings disabled, need OCaml >=4.00.0.\")\n    else()\n      find_ocamlfind_package(ctypes VERSION 0.4 OPTIONAL)\n      if( HAVE_OCAML_CTYPES )\n        message(STATUS \"OCaml bindings enabled.\")\n        find_ocamlfind_package(oUnit VERSION 2 OPTIONAL)\n        set(LLVM_BINDINGS \"${LLVM_BINDINGS} ocaml\")\n\n        set(LLVM_OCAML_INSTALL_PATH \"${OCAML_STDLIB_PATH}\" CACHE STRING\n            \"Install directory for LLVM OCaml packages\")\n      else()\n        message(STATUS \"OCaml bindings disabled, need ctypes >=0.4.\")\n      endif()\n    endif()\n  endif()\nendif()\n\nstring(REPLACE \" \" \";\" LLVM_BINDINGS_LIST \"${LLVM_BINDINGS}\")\n\nfunction(find_python_module module)\n  string(REPLACE \".\" \"_\" module_name ${module})\n  string(TOUPPER ${module_name} module_upper)\n  set(FOUND_VAR PY_${module_upper}_FOUND)\n\n  execute_process(COMMAND \"${PYTHON_EXECUTABLE}\" \"-c\" \"import ${module}\"\n    RESULT_VARIABLE status\n    ERROR_QUIET)\n\n  if(status)\n    set(${FOUND_VAR} 0 PARENT_SCOPE)\n    message(STATUS \"Could NOT find Python module ${module}\")\n  else()\n    set(${FOUND_VAR} 1 PARENT_SCOPE)\n    message(STATUS \"Found Python module ${module}\")\n  endif()\nendfunction()\n\nset (PYTHON_MODULES\n  pygments\n  # Some systems still don't have pygments.lexers.c_cpp which was introduced in\n  # version 2.0 in 2014...\n  pygments.lexers.c_cpp\n  yaml\n  )\nforeach(module ${PYTHON_MODULES})\n  find_python_module(${module})\nendforeach()\n\nif(PY_PYGMENTS_FOUND AND PY_PYGMENTS_LEXERS_C_CPP_FOUND AND PY_YAML_FOUND)\n  set (LLVM_HAVE_OPT_VIEWER_MODULES 1)\nelse()\n  set (LLVM_HAVE_OPT_VIEWER_MODULES 0)\nendif()\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corert/src/Native/System.Private.CoreLib.Native/pal_dynamicload.cpp": "// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\n#include \"pal_common.h\"\n#include <dlfcn.h>\n#include <string.h>\n\n#if HAVE_GNU_LIBNAMES_H\n#include <gnu/lib-names.h>\n#endif\n\nextern \"C\" void* CoreLibNative_LoadLibrary(const char* filename)\n{\n    // Check whether we have been requested to load 'libc'. If that's the case, then:\n    // * For Linux, use the full name of the library that is defined in <gnu/lib-names.h> by the\n    //   LIBC_SO constant. The problem is that calling dlopen(\"libc.so\") will fail for libc even\n    //   though it works for other libraries. The reason is that libc.so is just linker script\n    //   (i.e. a test file).\n    //   As a result, we have to use the full name (i.e. lib.so.6) that is defined by LIBC_SO.\n    // * For macOS, use constant value absolute path \"/usr/lib/libc.dylib\".\n    // * For FreeBSD, use constant value \"libc.so.7\".\n    // * For rest of Unices, use constant value \"libc.so\".\n    if (strcmp(filename, \"libc\") == 0)\n    {\n#if defined(__APPLE__)\n        filename = \"/usr/lib/libc.dylib\";\n#elif defined(__FreeBSD__)\n        filename = \"libc.so.7\";\n#elif defined(LIBC_SO)\n        filename = LIBC_SO;\n#else\n        filename = \"libc.so\";\n#endif\n    }\n\n    return dlopen(filename, RTLD_LAZY);\n}\n\nextern \"C\" void* CoreLibNative_GetProcAddress(void* handle, const char* symbol)\n{\n    // We're not trying to disambiguate between \"symbol was not found\" and \"symbol found, but\n    // the value is null\". .NET does not define a behavior for DllImports of null entrypoints,\n    // so we might as well take the \"not found\" path on the managed side.\n    return dlsym(handle, symbol);\n}\n\nextern \"C\" void CoreLibNative_FreeLibrary(void* handle)\n{\n    dlclose(handle);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corert/tests/src/Simple/SharedLibrary/SharedLibrary.cpp": "// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\n#ifdef _WIN32\n#include \"windows.h\"\n#else\n#include \"dlfcn.h\"\n#endif\n#include \"stdio.h\"\n#include \"string.h\"\n\n#ifndef _WIN32\n#define __stdcall\n#endif\n\n// typedef for shared lib exported methods\ntypedef int(__stdcall *f_ReturnsPrimitiveInt)();\ntypedef bool(__stdcall *f_ReturnsPrimitiveBool)();\ntypedef char(__stdcall *f_ReturnsPrimitiveChar)();\ntypedef void(__stdcall *f_EnsureManagedClassLoaders)();\n\n#ifdef _WIN32\nint main()\n#else\nint main(int argc, char* argv[])\n#endif\n{\n#ifdef _WIN32\n    HINSTANCE handle = LoadLibrary(\"SharedLibrary.dll\");\n#elif __APPLE__\n    void *handle = dlopen(strcat(argv[0], \".dylib\"), RTLD_LAZY);\n#else\n    void *handle = dlopen(strcat(argv[0], \".so\"), RTLD_LAZY);\n#endif\n\n    if (!handle)\n        return 1;\n\n#ifdef _WIN32\n    f_ReturnsPrimitiveInt returnsPrimitiveInt = (f_ReturnsPrimitiveInt)GetProcAddress(handle, \"ReturnsPrimitiveInt\");\n    f_ReturnsPrimitiveBool returnsPrimitiveBool = (f_ReturnsPrimitiveBool)GetProcAddress(handle, \"ReturnsPrimitiveBool\");\n    f_ReturnsPrimitiveChar returnsPrimitiveChar = (f_ReturnsPrimitiveChar)GetProcAddress(handle, \"ReturnsPrimitiveChar\");\n    f_EnsureManagedClassLoaders ensureManagedClassLoaders = (f_EnsureManagedClassLoaders)GetProcAddress(handle, \"EnsureManagedClassLoaders\");\n#else\n    f_ReturnsPrimitiveInt returnsPrimitiveInt = (f_ReturnsPrimitiveInt)dlsym(handle, \"ReturnsPrimitiveInt\");\n    f_ReturnsPrimitiveBool returnsPrimitiveBool = (f_ReturnsPrimitiveBool)dlsym(handle, \"ReturnsPrimitiveBool\");\n    f_ReturnsPrimitiveChar returnsPrimitiveChar = (f_ReturnsPrimitiveChar)dlsym(handle, \"ReturnsPrimitiveChar\");\n    f_EnsureManagedClassLoaders ensureManagedClassLoaders = (f_EnsureManagedClassLoaders)dlsym(handle, \"EnsureManagedClassLoaders\");\n#endif\n\n    if (returnsPrimitiveInt() != 10)\n        return 1;\n\n    if (!returnsPrimitiveBool())\n        return 1;\n\n    if (returnsPrimitiveChar() != 'a')\n        return 1;\n\n    // As long as no unmanaged exception is thrown\n    // managed class loaders were initialized successfully\n    ensureManagedClassLoaders();\n\n    return 100;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/man/mono-config.5": ".\\\" \n.\\\" mono-config configuration page.\n.\\\" (C) Ximian, Inc. \n.\\\" Author:\n.\\\"   Miguel de Icaza (miguel@gnu.org)\n.\\\"   Paolo Molaro (lupus@ximian.com)\n.\\\"\n.TH Mono \"mono-config\"\n.SH NAME\nmono-config \\- Mono runtime file format configuration\n.SH DESCRIPTION\nThe Mono runtime will load configuration data from the\ninstallation prefix /etc/mono/config file, the ~/.mono/config or from\nthe file pointed by the MONO_CONFIG environment variable.\n.PP\nFor each assembly loaded a config file with the name:\n/path/to/the/assembly.exe.config is loaded as well as the\n~/.mono/assemblies/ASSEMBLY/ASSEMBLY.EXT.config file. \n.PP\nThis file controls the behavior of the runtime.\n.PP\nThe file contains an XML-like file with various sections, all of them\ncontained inside a \n.B<configuration> \nsection (It actually uses GMarkup\nto parse the file).\n.PP\nThis page describes the Unix-specific and Mono-specific extensions to\nthe configuration file;   For complete details, see the\nhttp://www.mono-project.com/Config web page.\n.SH <dllmap> directive\nYou use the dllmap directive to map shared libraries referenced by\nP/Invoke in your assemblies to a different shared library.\n.PP\nThis is typically used to map Windows libraries to Unix library names.\nThe \n.B dllmap\nelement takes two attributes:\n.TP\n.I dll\nThis should be the same string used in the DllImport attribute, optionally\nprefixed with \"i:\" to indicate that the string must be matched in a\ncase-insensitive way\n.TP\n.I target\nThis should be the name of the library where the function can be found: \nthis name should be suitable for use with the platform native shared library \nloading routines (dlopen etc.), so you may want to check the manpages for that, too.\n.SH <dllentry> directive\nThis directive can be used to map a specific dll/function pair to a different\nlibrary and also a different function name. It should appear inside a\n.B dllmap\nelement with only the dll attribute specified.\n.PP\nThe\n.B dllentry\nelement takes 3 attributes:\n.TP\n.I dll\nThis is the target library, where the function can be found.\n.TP\n.I name\nThis is the name of the function as it appears in the metadata: it is the name \nof the P/Invoke method.\n.TP\n.I target\nThis is the name of the function to lookup instead of the name specified in the \nP/Invoke method.\n.SH Mapping based on operating system and cpu\nBoth the\n.B dllmap\nand the\n.B dllentry\nelements allow the following two attributes which make it easy to use a single\nconfiguration file and support multiple operating systems and architectures with\ndifferent mapping requirements:\n.TP\n.I os\nThis is the name of the operating system for which the mapping should be applied.\nAllowed values are: linux, osx, solaris, freebsd, openbsd, netbsd, windows, aix, hpux.\n.TP\n.I cpu\nThis is the name of the architecture for which the mapping should be applied.\nAllowed values are: x86, x86-64, sparc, ppc, s390, s390x, arm, mips,\nalpha, hppa, ia64.\n.TP\n.I wordsize\nThis is the size of registers on the target architecture, it can be\neither 32 or 64.  \n.PP\nThe attribute value for both attributes can be a comma-separated list of the allowed\nvalues. Additionally, the first character may be a\n.I '!'\nto reverse the meaning. An attribute value of \"!windows,osx\", for example, would mean\nthat the entry is considered on all operating systems, except on Windows and OS X.\nNo spaces are allowed in any part of the value.\n.PP\nNote that later entries will override the entries defined earlier in the file.\n.SH EXAMPLES\nThe following example maps references to the `cygwin1.dll' shared\nlibrary to the `libc.so.6' file.  \n.nf\n<configuration>\n\t<dllmap dll=\"i:cygwin1.dll\" target=\"libc.so.6\"/>\n</configuration>\n.fi\nThe library name in the DllImport attribute is allowed to be in any\ncase variant, like the following examples:\n.nf\n.nf\n\t[DllImport (\"cygwin1.dll\")]\n\t[DllImport (\"Cygwin1.dll\")]\n\t[DllImport (\"cygwiN1.Dll\")]\n.fi\n.PP\nThis one maps the following C# method:\n.nf\n\t[DllImport (\"libc\")]\n\tstatic extern void somefunction ();\n.fi\nto\n.B differentfunction\nin\n.B libdifferent.so\n, but to the same function in the library\n.B libanother.so\nwhen running under the Solaris and FreeBSD operating systems.\n.nf\n<configuration>\n\t<dllmap dll=\"libc\">\n\t\t<dllentry dll=\"libdifferent.so\" name=\"somefunction\" target=\"differentfunction\" />\n\t\t<dllentry os=\"solaris,freebsd\" dll=\"libanother.so\" name=\"somefunction\" target=\"differentfunction\" />\n\t</dllmap>\n</configuration>\n.fi\n\n.SH SEE ALSO\n.BR mono(1), monodis(1), mint(1)\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System/Mono.AppleTls/MonoCertificatePal.Mobile.cs": "//\n// MonoCertificatePal.Mobile.cs\n//\n// Authors:\n//       Miguel de Icaza\n//       Sebastien Pouliot <sebastien@xamarin.com>\n//       Martin Baulig <mabaul@microsoft.com>\n//\n// Copyright 2010 Novell, Inc\n// Copyright 2011-2014 Xamarin Inc.\n// Copyright (c) 2018 Xamarin Inc. (http://www.xamarin.com)\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nusing System;\nusing System.Threading;\nusing System.Runtime.InteropServices;\nusing System.Security.Cryptography.Apple;\nusing System.Security.Cryptography.X509Certificates;\nusing Microsoft.Win32.SafeHandles;\n\nnamespace Mono.AppleTls\n{\n\tstatic partial class MonoCertificatePal\n\t{\n\t\tstatic int initialized;\n\t\tstatic CFString ImportExportPassphase;\n\t\tstatic CFString ImportItemIdentity;\n\t\tstatic IntPtr MatchLimitAll;\n\t\tstatic IntPtr MatchLimitOne;\n\t\tstatic IntPtr MatchLimit;\n\t\tstatic IntPtr SecClassKey;\n\t\tstatic IntPtr SecClassIdentity;\n\t\tstatic IntPtr SecClassCertificate;\n\t\tstatic IntPtr ReturnRef;\n\t\tstatic IntPtr MatchSearchList;\n\n\t\tstatic void Initialize ()\n\t\t{\n\t\t\tif (Interlocked.CompareExchange (ref initialized, 1, 0) != 0)\n\t\t\t\treturn;\n\n\t\t\tvar handle = CFObject.dlopen (SecurityLibrary, 0);\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn;\n\n\t\t\ttry {\n\t\t\t\tImportExportPassphase = CFObject.GetStringConstant (handle, \"kSecImportExportPassphrase\");\n\t\t\t\tImportItemIdentity = CFObject.GetStringConstant (handle, \"kSecImportItemIdentity\");\n\t\t\t\tMatchLimit = CFObject.GetIntPtr (handle, \"kSecMatchLimit\");\n\t\t\t\tMatchLimitAll = CFObject.GetIntPtr (handle, \"kSecMatchLimitAll\");\n\t\t\t\tMatchLimitOne = CFObject.GetIntPtr (handle, \"kSecMatchLimitOne\");\n\t\t\t\tSecClassKey = CFObject.GetIntPtr (handle, \"kSecClass\");\n\t\t\t\tSecClassIdentity = CFObject.GetIntPtr (handle, \"kSecClassIdentity\");\n\t\t\t\tSecClassCertificate = CFObject.GetIntPtr (handle, \"kSecClassCertificate\");\n\t\t\t\tReturnRef = CFObject.GetIntPtr (handle, \"kSecReturnRef\");\n\t\t\t\tMatchSearchList = CFObject.GetIntPtr (handle, \"kSecMatchSearchList\");\n\t\t\t} finally {\n\t\t\t\tCFObject.dlclose (handle);\n\t\t\t}\n\t\t}\n\n\t\tstatic SafeSecIdentityHandle ImportIdentity (byte[] data, string password)\n\t\t{\n\t\t\tif (data == null)\n\t\t\t\tthrow new ArgumentNullException (nameof (data));\n\t\t\tif (string.IsNullOrEmpty (password)) // SecPKCS12Import() doesn't allow empty passwords.\n\t\t\t\tthrow new ArgumentException (nameof (password));\n\t\t\tInitialize ();\n\t\t\tusing (var pwstring = CFString.Create (password))\n\t\t\tusing (var optionDict = CFDictionary.FromObjectAndKey (pwstring.Handle, ImportExportPassphase.Handle)) {\n\t\t\t\tvar result = ImportPkcs12 (data, optionDict, out var array);\n\t\t\t\tif (result != SecStatusCode.Success)\n\t\t\t\t\tthrow new InvalidOperationException (result.ToString ());\n\n\t\t\t\treturn new SafeSecIdentityHandle (array [0].GetValue (ImportItemIdentity.Handle));\n\t\t\t}\n\t\t}\n\n\t\t[DllImport (SecurityLibrary)]\n\t\textern static SecStatusCode SecPKCS12Import (IntPtr pkcs12_data, IntPtr options, out IntPtr items);\n\n\t\tstatic SecStatusCode ImportPkcs12 (byte[] buffer, CFDictionary options, out CFDictionary[] array)\n\t\t{\n\t\t\tusing (CFData data = CFData.FromData (buffer)) {\n\t\t\t\treturn ImportPkcs12 (data, options, out array);\n\t\t\t}\n\t\t}\n\n\t\tstatic SecStatusCode ImportPkcs12 (CFData data, CFDictionary options, out CFDictionary[] array)\n\t\t{\n\t\t\tif (options == null)\n\t\t\t\tthrow new ArgumentNullException (nameof (options));\n\n\t\t\tvar code = SecPKCS12Import (data.Handle, options.Handle, out var handle);\n\t\t\tarray = CFArray.ArrayFromHandle<CFDictionary> (handle, h => new CFDictionary (h, false));\n\t\t\tif (handle != IntPtr.Zero)\n\t\t\t\tCFObject.CFRelease (handle);\n\t\t\treturn code;\n\t\t}\n\n\t\tpublic static SafeSecIdentityHandle ImportIdentity (X509Certificate2 certificate)\n\t\t{\n\t\t\tif (certificate == null)\n\t\t\t\tthrow new ArgumentNullException (nameof (certificate));\n\t\t\tif (!certificate.HasPrivateKey)\n\t\t\t\tthrow new InvalidOperationException (\"Need X509Certificate2 with a private key.\");\n\n\t\t\tSafeSecIdentityHandle identity;\n\t\t\t/*\n\t\t\t * SecPSK12Import does not allow any empty passwords, so let's generate\n\t\t\t * a semi-random one here.\n\t\t\t */\n\t\t\tInitialize ();\n\t\t\tvar password = Guid.NewGuid ().ToString ();\n\t\t\tvar pkcs12 = certificate.Export (X509ContentType.Pfx, password);\n\t\t\tidentity = ImportIdentity (pkcs12, password);\n\t\t\treturn identity ?? new SafeSecIdentityHandle ();\n\t\t}\n\n\t\t[DllImport (SecurityLibrary)]\n\t\textern static SecStatusCode SecItemCopyMatching (/* CFDictionaryRef */ IntPtr query, /* CFTypeRef* */ out IntPtr result);\n\n\t\tpublic static SafeSecIdentityHandle FindIdentity (SafeSecCertificateHandle certificate, bool throwOnError = false)\n\t\t{\n\t\t\tif (certificate == null || certificate.IsInvalid)\n\t\t\t\tthrow new ObjectDisposedException (nameof (certificate));\n\t\t\tvar identity = FindIdentity (cert => MonoCertificatePal.Equals (certificate, cert)) ?? new SafeSecIdentityHandle ();\n\t\t\tif (!throwOnError || identity.IsInvalid)\n\t\t\t\treturn identity;\n\n\t\t\tvar subject = MonoCertificatePal.GetSubjectSummary (certificate);\n\t\t\tthrow new InvalidOperationException ($\"Could not find SecIdentity for certificate '{subject}' in keychain.\");\n\t\t}\n\n\t\tstatic SafeSecIdentityHandle FindIdentity (Predicate<SafeSecCertificateHandle> filter)\n\t\t{\n\t\t\tInitialize ();\n\n\t\t\t/*\n\t\t\t * Unfortunately, SecItemCopyMatching() does not allow any search\n\t\t\t * filters when looking up an identity.\n\t\t\t * \n\t\t\t * The following lookup will return all identities from the keychain -\n\t\t\t * we then need need to find the right one.\n\t\t\t */\n\t\t\tusing (var query = CFMutableDictionary.Create ()) {\n\t\t\t\tquery.SetValue (SecClassKey, SecClassIdentity);\n\t\t\t\tquery.SetValue (CFBoolean.True.Handle, ReturnRef);\n\t\t\t\tquery.SetValue (MatchLimitAll, MatchLimit);\n\n\t\t\t\tvar status = SecItemCopyMatching (query.Handle, out var ptr);\n\t\t\t\tif (status != SecStatusCode.Success || ptr == IntPtr.Zero)\n\t\t\t\t\treturn null;\n\n\t\t\t\tusing (var array = new CFArray (ptr, false)) {\n\t\t\t\t\tfor (int i = 0; i < array.Count; i++) {\n\t\t\t\t\t\tvar item = array[i];\n\t\t\t\t\t\tif (!MonoCertificatePal.IsSecIdentity (item))\n\t\t\t\t\t\t\tthrow new InvalidOperationException ();\n\t\t\t\t\t\tusing (var identity = new SafeSecIdentityHandle (item))\n\t\t\t\t\t\tusing (var certificate = MonoCertificatePal.GetCertificate (identity)) {\n\t\t\t\t\t\t\tif (filter (certificate))\n\t\t\t\t\t\t\t\treturn new SafeSecIdentityHandle (item);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System/Mono/AppleTypes.cs": "// \n// MacProxy.cs\n//  \n// Author: Jeffrey Stedfast <jeff@xamarin.com>\n// \n// Copyright (c) 2012-2014 Xamarin Inc.\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// \n\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Threading;\nusing ObjCRuntimeInternal;\n\nnamespace Mono\n{\n\tinternal class CFType {\n\t\t[DllImport (CFObject.CoreFoundationLibrary, EntryPoint=\"CFGetTypeID\")]\n\t\tpublic static extern IntPtr GetTypeID (IntPtr typeRef);\n\t}\n\n\tinternal class CFObject : IDisposable, INativeObject\n\t{\n\t\tpublic const string CoreFoundationLibrary = \"/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\";\n\t\tconst string SystemLibrary = \"/usr/lib/libSystem.dylib\";\n\n\t\t[DllImport (SystemLibrary)]\n\t\tpublic static extern IntPtr dlopen (string path, int mode);\n\n\t\t[DllImport (SystemLibrary)]\n\t\tstatic extern IntPtr dlsym (IntPtr handle, string symbol);\n\n\t\t[DllImport (SystemLibrary)]\n\t\tpublic static extern void dlclose (IntPtr handle);\n\n\t\tpublic static IntPtr GetIndirect (IntPtr handle, string symbol)\n\t\t{\n\t\t\treturn dlsym (handle, symbol);\n\t\t}\n\n\t\tpublic static CFString GetStringConstant (IntPtr handle, string symbol)\n\t\t{\n\t\t\tvar indirect = dlsym (handle, symbol);\n\t\t\tif (indirect == IntPtr.Zero)\n\t\t\t\treturn null;\n\t\t\tvar actual = Marshal.ReadIntPtr (indirect);\n\t\t\tif (actual == IntPtr.Zero)\n\t\t\t\treturn null;\n\t\t\treturn new CFString (actual, false);\n\t\t}\n\n\t\tpublic static IntPtr GetIntPtr (IntPtr handle, string symbol)\n\t\t{\n\t\t\tvar indirect = dlsym (handle, symbol);\n\t\t\tif (indirect == IntPtr.Zero)\n\t\t\t\treturn IntPtr.Zero;\n\t\t\treturn Marshal.ReadIntPtr (indirect);\n\t\t}\n\n\t\tpublic static IntPtr GetCFObjectHandle (IntPtr handle, string symbol)\n\t\t{\n\t\t\tvar indirect = dlsym (handle, symbol);\n\t\t\tif (indirect == IntPtr.Zero)\n\t\t\t\treturn IntPtr.Zero;\n\n\t\t\treturn Marshal.ReadIntPtr (indirect);\n\t\t}\n\n\t\tpublic CFObject (IntPtr handle, bool own)\n\t\t{\n\t\t\tHandle = handle;\n\n\t\t\tif (!own)\n\t\t\t\tRetain ();\n\t\t}\n\n\t\t~CFObject ()\n\t\t{\n\t\t\tDispose (false);\n\t\t}\n\n\t\tpublic IntPtr Handle { get; private set; }\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\tinternal extern static IntPtr CFRetain (IntPtr handle);\n\n\t\tvoid Retain ()\n\t\t{\n\t\t\tCFRetain (Handle);\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\tinternal extern static void CFRelease (IntPtr handle);\n\n\t\tvoid Release ()\n\t\t{\n\t\t\tCFRelease (Handle);\n\t\t}\n\n\t\tprotected virtual void Dispose (bool disposing)\n\t\t{\n\t\t\tif (Handle != IntPtr.Zero) {\n\t\t\t\tRelease ();\n\t\t\t\tHandle = IntPtr.Zero;\n\t\t\t}\n\t\t}\n\n\t\tpublic void Dispose ()\n\t\t{\n\t\t\tDispose (true);\n\t\t\tGC.SuppressFinalize (this);\n\t\t}\n\t}\n\n\tinternal class CFArray : CFObject\n\t{\n\t\tpublic CFArray (IntPtr handle, bool own) : base (handle, own) { }\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFArrayCreate (IntPtr allocator, IntPtr values, /* CFIndex */ IntPtr numValues, IntPtr callbacks);\n\t\tstatic readonly IntPtr kCFTypeArrayCallbacks;\n\n\t\tstatic CFArray ()\n\t\t{\n\t\t\tvar handle = dlopen (CoreFoundationLibrary, 0);\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn;\n\n\t\t\ttry {\n\t\t\t\tkCFTypeArrayCallbacks = GetIndirect (handle, \"kCFTypeArrayCallBacks\");\n\t\t\t} finally {\n\t\t\t\tdlclose (handle);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static CFArray FromNativeObjects (params INativeObject[] values)\n\t\t{\n\t\t\treturn new CFArray (Create (values), true);\n\t\t}\n\n\t\tpublic static unsafe IntPtr Create (params IntPtr[] values)\n\t\t{\n\t\t\tif (values == null)\n\t\t\t\tthrow new ArgumentNullException (\"values\");\n\t\t\tfixed (IntPtr* pv = values) {\n\t\t\t\treturn CFArrayCreate (IntPtr.Zero, (IntPtr) pv, (IntPtr)values.Length, kCFTypeArrayCallbacks);\n\t\t\t}\n\t\t}\n\n\t\tinternal static unsafe CFArray CreateArray (params IntPtr[] values)\n\t\t{\n\t\t\tif (values == null)\n\t\t\t\tthrow new ArgumentNullException (\"values\");\n\n\t\t\tfixed (IntPtr *pv = values) {\n\t\t\t\tIntPtr handle = CFArrayCreate (IntPtr.Zero, (IntPtr) pv, (IntPtr) values.Length, kCFTypeArrayCallbacks);\n\n\t\t\t\treturn new CFArray (handle, false);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static CFArray CreateArray (params INativeObject[] values)\n\t\t{\n\t\t\treturn new CFArray (Create (values), true);\n\t\t}\n\n\t\tpublic static IntPtr Create (params INativeObject[] values)\n\t\t{\n\t\t\tif (values == null)\n\t\t\t\tthrow new ArgumentNullException (\"values\");\n\t\t\tIntPtr[] _values = new IntPtr [values.Length];\n\t\t\tfor (int i = 0; i < _values.Length; ++i)\n\t\t\t\t_values [i] = values [i].Handle;\n\t\t\treturn Create (_values);\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static /* CFIndex */ IntPtr CFArrayGetCount (IntPtr handle);\n\n\t\tpublic int Count {\n\t\t\tget { return (int) CFArrayGetCount (Handle); }\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFArrayGetValueAtIndex (IntPtr handle, /* CFIndex */ IntPtr index);\n\n\t\tpublic IntPtr this[int index] {\n\t\t\tget {\n\t\t\t\treturn CFArrayGetValueAtIndex (Handle, (IntPtr) index);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic public T [] ArrayFromHandle<T> (IntPtr handle, Func<IntPtr, T> creation) where T : class, INativeObject\n\t\t{\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn null;\n\n\t\t\tvar c = CFArrayGetCount (handle);\n\t\t\tT [] ret = new T [(int)c];\n\n\t\t\tfor (uint i = 0; i < (uint)c; i++) {\n\t\t\t\tret [i] = creation (CFArrayGetValueAtIndex (handle, (IntPtr)i));\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tinternal class CFNumber : CFObject\n\t{\n\t\tpublic CFNumber (IntPtr handle, bool own) : base (handle, own) { }\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\t[return: MarshalAs (UnmanagedType.I1)]\n\t\textern static bool CFNumberGetValue (IntPtr handle, /* CFNumberType */ IntPtr type, [MarshalAs (UnmanagedType.I1)] out bool value);\n\n\t\tpublic static bool AsBool (IntPtr handle)\n\t\t{\n\t\t\tbool value;\n\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn false;\n\n\t\t\tCFNumberGetValue (handle, (IntPtr) 1, out value);\n\n\t\t\treturn value;\n\t\t}\n\n\t\tpublic static implicit operator bool (CFNumber number)\n\t\t{\n\t\t\treturn AsBool (number.Handle);\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\t[return: MarshalAs (UnmanagedType.I1)]\n\t\textern static bool CFNumberGetValue (IntPtr handle, /* CFNumberType */ IntPtr type, out int value);\n\n\t\tpublic static int AsInt32 (IntPtr handle)\n\t\t{\n\t\t\tint value;\n\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn 0;\n\n\t\t\t// 9 == kCFNumberIntType == C int\n\t\t\tCFNumberGetValue (handle, (IntPtr) 9, out value);\n\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFNumberCreate (IntPtr allocator, IntPtr theType, IntPtr valuePtr);\t\n\n\t\tpublic static CFNumber FromInt32 (int number)\n\t\t{\n\t\t\t// 9 == kCFNumberIntType == C int\n\t\t\treturn new CFNumber (CFNumberCreate (IntPtr.Zero, (IntPtr)9, (IntPtr)number), true);\n\t\t}\n\n\t\tpublic static implicit operator int (CFNumber number)\n\t\t{\n\t\t\treturn AsInt32 (number.Handle);\n\t\t}\n\t}\n\n\tinternal struct CFRange {\n\t\tpublic IntPtr Location, Length;\n\t\t\n\t\tpublic CFRange (int loc, int len)\n\t\t{\n\t\t\tLocation = (IntPtr) loc;\n\t\t\tLength = (IntPtr) len;\n\t\t}\n\t}\n\n\tinternal class CFString : CFObject\n\t{\n\t\tstring str;\n\n\t\tpublic CFString (IntPtr handle, bool own) : base (handle, own) { }\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFStringCreateWithCharacters (IntPtr alloc, IntPtr chars, /* CFIndex */ IntPtr length);\n\n\t\tpublic static CFString Create (string value)\n\t\t{\n\t\t\tIntPtr handle;\n\n\t\t\tunsafe {\n\t\t\t\tfixed (char *ptr = value) {\n\t\t\t\t\thandle = CFStringCreateWithCharacters (IntPtr.Zero, (IntPtr) ptr, (IntPtr) value.Length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn null;\n\n\t\t\treturn new CFString (handle, true);\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static /* CFIndex */ IntPtr CFStringGetLength (IntPtr handle);\n\n\t\tpublic int Length {\n\t\t\tget {\n\t\t\t\tif (str != null)\n\t\t\t\t\treturn str.Length;\n\n\t\t\t\treturn (int) CFStringGetLength (Handle);\n\t\t\t}\n\t\t}\n\t\t\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static int CFStringCompare (IntPtr theString1, IntPtr theString2, int compareOptions);\n\t\t\n\t\tpublic static int Compare (IntPtr string1, IntPtr string2, int compareOptions = 0)\n\t\t{\n\t\t\treturn CFStringCompare (string1, string2, compareOptions);\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFStringGetCharactersPtr (IntPtr handle);\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFStringGetCharacters (IntPtr handle, CFRange range, IntPtr buffer);\n\n\t\tpublic static string AsString (IntPtr handle)\n\t\t{\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tint len = (int) CFStringGetLength (handle);\n\t\t\t\n\t\t\tif (len == 0)\n\t\t\t\treturn string.Empty;\n\t\t\t\n\t\t\tIntPtr chars = CFStringGetCharactersPtr (handle);\n\t\t\tIntPtr buffer = IntPtr.Zero;\n\t\t\t\n\t\t\tif (chars == IntPtr.Zero) {\n\t\t\t\tCFRange range = new CFRange (0, len);\n\t\t\t\tbuffer = Marshal.AllocHGlobal (len * 2);\n\t\t\t\tCFStringGetCharacters (handle, range, buffer);\n\t\t\t\tchars = buffer;\n\t\t\t}\n\n\t\t\tstring str;\n\n\t\t\tunsafe {\n\t\t\t\tstr = new string ((char *) chars, 0, len);\n\t\t\t}\n\t\t\t\n\t\t\tif (buffer != IntPtr.Zero)\n\t\t\t\tMarshal.FreeHGlobal (buffer);\n\n\t\t\treturn str;\n\t\t}\n\n\t\tpublic override string ToString ()\n\t\t{\n\t\t\tif (str == null)\n\t\t\t\tstr = AsString (Handle);\n\n\t\t\treturn str;\n\t\t}\n\n\t\tpublic static implicit operator string (CFString str)\n\t\t{\n\t\t\treturn str.ToString ();\n\t\t}\n\n\t\tpublic static implicit operator CFString (string str)\n\t\t{\n\t\t\treturn Create (str);\n\t\t}\n\t}\n\n\t\n\tinternal class CFData : CFObject\n\t{\n\t\tpublic CFData (IntPtr handle, bool own) : base (handle, own) { }\n\t\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static /* CFDataRef */ IntPtr CFDataCreate (/* CFAllocatorRef */ IntPtr allocator, /* UInt8* */ IntPtr bytes, /* CFIndex */ IntPtr length);\n\t\tpublic unsafe static CFData FromData (byte [] buffer)\n\t\t{\n\t\t\tfixed (byte* p = buffer)\n\t\t\t{\n\t\t\t\treturn FromData ((IntPtr)p, (IntPtr)buffer.Length);\n\t\t\t}\n\t\t}\n\n\t\tpublic static CFData FromData (IntPtr buffer, IntPtr length)\n\t\t{\n\t\t\treturn new CFData (CFDataCreate (IntPtr.Zero, buffer, length), true);\n\t\t}\n\t\t\n\t\tpublic IntPtr Length {\n\t\t\tget { return CFDataGetLength (Handle); }\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\tinternal extern static /* CFIndex */ IntPtr CFDataGetLength (/* CFDataRef */ IntPtr theData);\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\tinternal extern static /* UInt8* */ IntPtr CFDataGetBytePtr (/* CFDataRef */ IntPtr theData);\n\n\t\t/*\n\t\t * Exposes a read-only pointer to the underlying storage.\n\t\t */\n\t\tpublic IntPtr Bytes {\n\t\t\tget { return CFDataGetBytePtr (Handle); }\n\t\t}\n\n\t\tpublic byte this [long idx] {\n\t\t\tget {\n\t\t\t\tif (idx < 0 || (ulong) idx > (ulong) Length)\n\t\t\t\t\tthrow new ArgumentException (\"idx\");\n\t\t\t\treturn Marshal.ReadByte (new IntPtr (Bytes.ToInt64 () + idx));\n\t\t\t}\n\n\t\t\tset {\n\t\t\t\tthrow new NotImplementedException (\"NSData arrays can not be modified, use an NSMutableData instead\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\tinternal class CFDictionary : CFObject\n\t{\n\t\tstatic readonly IntPtr KeyCallbacks;\n\t\tstatic readonly IntPtr ValueCallbacks;\n\t\t\n\t\tstatic CFDictionary ()\n\t\t{\n\t\t\tvar handle = dlopen (CoreFoundationLibrary, 0);\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn;\n\n\t\t\ttry {\t\t\n\t\t\t\tKeyCallbacks = GetIndirect (handle, \"kCFTypeDictionaryKeyCallBacks\");\n\t\t\t\tValueCallbacks = GetIndirect (handle, \"kCFTypeDictionaryValueCallBacks\");\n\t\t\t} finally {\n\t\t\t\tdlclose (handle);\n\t\t\t}\n\t\t}\n\n\t\tpublic CFDictionary (IntPtr handle, bool own) : base (handle, own) { }\n\n\t\tpublic static CFDictionary FromObjectAndKey (IntPtr obj, IntPtr key)\n\t\t{\n\t\t\treturn new CFDictionary (CFDictionaryCreate (IntPtr.Zero, new IntPtr[] { key }, new IntPtr [] { obj }, (IntPtr)1, KeyCallbacks, ValueCallbacks), true);\n\t\t}\n\n\t\tpublic static CFDictionary FromKeysAndObjects (IList<Tuple<IntPtr,IntPtr>> items)\n\t\t{\n\t\t\tvar keys = new IntPtr [items.Count];\n\t\t\tvar values = new IntPtr [items.Count];\n\t\t\tfor (int i = 0; i < items.Count; i++) {\n\t\t\t\tkeys [i] = items [i].Item1;\n\t\t\t\tvalues [i] = items [i].Item2;\n\t\t\t}\n\t\t\treturn new CFDictionary (CFDictionaryCreate (IntPtr.Zero, keys, values, (IntPtr)items.Count, KeyCallbacks, ValueCallbacks), true);\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFDictionaryCreate (IntPtr allocator, IntPtr[] keys, IntPtr[] vals, IntPtr len, IntPtr keyCallbacks, IntPtr valCallbacks);\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFDictionaryGetValue (IntPtr handle, IntPtr key);\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFDictionaryCreateCopy (IntPtr allocator, IntPtr handle);\n\n\t\tpublic CFDictionary Copy ()\n\t\t{\n\t\t\treturn new CFDictionary (CFDictionaryCreateCopy (IntPtr.Zero, Handle), true);\n\t\t}\n\t\t\n\t\tpublic CFMutableDictionary MutableCopy ()\n\t\t{\n\t\t\treturn new CFMutableDictionary (CFDictionaryCreateMutableCopy (IntPtr.Zero, IntPtr.Zero, Handle), true);\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFDictionaryCreateMutableCopy (IntPtr allocator, IntPtr capacity, IntPtr theDict);\n\n\t\tpublic IntPtr GetValue (IntPtr key)\n\t\t{\n\t\t\treturn CFDictionaryGetValue (Handle, key);\n\t\t}\n\n\t\tpublic IntPtr this[IntPtr key] {\n\t\t\tget {\n\t\t\t\treturn GetValue (key);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinternal class CFMutableDictionary : CFDictionary\n\t{\n\t\tpublic CFMutableDictionary (IntPtr handle, bool own) : base (handle, own) { }\n\n\t\tpublic void SetValue (IntPtr key, IntPtr val)\n\t\t{\n\t\t\tCFDictionarySetValue (Handle, key, val);\n\t\t}\n\n\t\tpublic static CFMutableDictionary Create ()\n\t\t{\n\t\t\tvar handle = CFDictionaryCreateMutable (IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\tthrow new InvalidOperationException ();\n\t\t\treturn new CFMutableDictionary (handle, true);\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static void CFDictionarySetValue (IntPtr handle, IntPtr key, IntPtr val);\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFDictionaryCreateMutable (IntPtr allocator, IntPtr capacity, IntPtr keyCallback, IntPtr valueCallbacks);\n\n\t}\n\n\tclass CFBoolean : INativeObject, IDisposable {\n\t\tIntPtr handle;\n\n\t\tpublic static readonly CFBoolean True;\n\t\tpublic static readonly CFBoolean False;\n\n\t\tstatic CFBoolean ()\n\t\t{\n\t\t\tvar handle = CFObject.dlopen (CFObject.CoreFoundationLibrary, 0);\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn;\n\t\t\ttry {\n\t\t\t\tTrue  = new CFBoolean (CFObject.GetCFObjectHandle (handle, \"kCFBooleanTrue\"), false);\n\t\t\t\tFalse = new CFBoolean (CFObject.GetCFObjectHandle (handle, \"kCFBooleanFalse\"), false);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tCFObject.dlclose (handle);\n\t\t\t}\n\t\t}\n\n\t\tinternal CFBoolean (IntPtr handle, bool owns)\n\t\t{\n\t\t\tthis.handle = handle;\n\t\t\tif (!owns)\n\t\t\t\tCFObject.CFRetain (handle);\n\t\t}\n\n\t\t~CFBoolean ()\n\t\t{\n\t\t\tDispose (false);\n\t\t}\n\n\t\tpublic IntPtr Handle {\n\t\t\tget {\n\t\t\t\treturn handle;\n\t\t\t}\n\t\t}\n\n\t\tpublic void Dispose ()\n\t\t{\n\t\t\tDispose (true);\n\t\t\tGC.SuppressFinalize (this);\n\t\t}\n\n\t\tprotected virtual void Dispose (bool disposing)\n\t\t{\n\t\t\tif (handle != IntPtr.Zero){\n\t\t\t\tCFObject.CFRelease (handle);\n\t\t\t\thandle = IntPtr.Zero;\n\t\t\t}\n\t\t}\n\n\t\tpublic static implicit operator bool (CFBoolean value)\n\t\t{\n\t\t\treturn value.Value;\n\t\t}\n\n\t\tpublic static explicit operator CFBoolean (bool value)\n\t\t{\n\t\t\treturn FromBoolean (value);\n\t\t}\n\n\t\tpublic static CFBoolean FromBoolean (bool value)\n\t\t{\n\t\t\treturn value ? True : False;\n\t\t}\n\n\t\t[DllImport (CFObject.CoreFoundationLibrary)]\n\t\t[return: MarshalAs (UnmanagedType.I1)]\n\t\textern static /* Boolean */ bool CFBooleanGetValue (/* CFBooleanRef */ IntPtr boolean);\n\n\t\tpublic bool Value {\n\t\t\tget {return CFBooleanGetValue (handle);}\n\t\t}\n\n\t\tpublic static bool GetValue (IntPtr boolean)\n\t\t{\n\t\t\treturn CFBooleanGetValue (boolean);\n\t\t}\n\t}\n\n\tinternal class CFDate : INativeObject, IDisposable {\n\t\tIntPtr handle;\n\n\t\tinternal CFDate (IntPtr handle, bool owns)\n\t\t{\n\t\t\tthis.handle = handle;\n\t\t\tif (!owns)\n\t\t\t\tCFObject.CFRetain (handle);\n\t\t}\n\n\t\t~CFDate ()\n\t\t{\n\t\t\tDispose (false);\n\t\t}\n\n\t\t[DllImport (CFObject.CoreFoundationLibrary)]\n\t\textern static IntPtr CFDateCreate (IntPtr allocator, /* CFAbsoluteTime */ double at);\n\n\t\tpublic static CFDate Create (DateTime date)\n\t\t{\n\t\t\tvar referenceTime = new DateTime (2001, 1, 1);\n\t\t\tvar difference = (date - referenceTime).TotalSeconds;\n\t\t\tvar handle = CFDateCreate (IntPtr.Zero, difference);\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\tthrow new NotSupportedException ();\n\t\t\treturn new CFDate (handle, true);\n\t\t}\n\n\t\tpublic IntPtr Handle {\n\t\t\tget {\n\t\t\t\treturn handle;\n\t\t\t}\n\t\t}\n\n\t\tpublic void Dispose ()\n\t\t{\n\t\t\tDispose (true);\n\t\t\tGC.SuppressFinalize (this);\n\t\t}\n\n\t\tprotected virtual void Dispose (bool disposing)\n\t\t{\n\t\t\tif (handle != IntPtr.Zero) {\n\t\t\t\tCFObject.CFRelease (handle);\n\t\t\t\thandle = IntPtr.Zero;\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System/System.Net/MacProxy.cs": "// \n// MacProxy.cs\n//  \n// Author: Jeffrey Stedfast <jeff@xamarin.com>\n// \n// Copyright (c) 2012-2014 Xamarin Inc.\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// \n\nusing System;\nusing System.Net;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Threading;\nusing ObjCRuntimeInternal;\n\nnamespace Mono.Net\n{\n\tinternal struct CFStreamClientContext {\n\t\tpublic IntPtr Version;\n\t\tpublic IntPtr Info;\n\t\tpublic IntPtr Retain;\n\t\tpublic IntPtr Release;\n\t\tpublic IntPtr CopyDescription;\n\t}\n\n\tinternal class CFUrl : CFObject\n\t{\n\t\tpublic CFUrl (IntPtr handle, bool own) : base (handle, own) { }\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFURLCreateWithString (IntPtr allocator, IntPtr str, IntPtr baseURL);\n\n\t\tpublic static CFUrl Create (string absolute)\n\t\t{\n\t\t\tif (string.IsNullOrEmpty (absolute))\n\t\t\t\treturn null;\n\n\t\t\tCFString str = CFString.Create (absolute);\n\t\t\tIntPtr handle = CFURLCreateWithString (IntPtr.Zero, str.Handle, IntPtr.Zero);\n\t\t\tstr.Dispose ();\n\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn null;\n\n\t\t\treturn new CFUrl (handle, true);\n\t\t}\n\t}\n\n\tinternal class CFRunLoop : CFObject\n\t{\n\t\t[DllImport (CFObject.CoreFoundationLibrary)]\n\t\tstatic extern void CFRunLoopAddSource (IntPtr rl, IntPtr source, IntPtr mode);\n\n\t\t[DllImport (CFObject.CoreFoundationLibrary)]\n\t\tstatic extern void CFRunLoopRemoveSource (IntPtr rl, IntPtr source, IntPtr mode);\n\n\t\t[DllImport (CFObject.CoreFoundationLibrary)]\n\t\tstatic extern int CFRunLoopRunInMode (IntPtr mode, double seconds, bool returnAfterSourceHandled);\n\n\t\t[DllImport (CFObject.CoreFoundationLibrary)]\n\t\tstatic extern IntPtr CFRunLoopGetCurrent ();\n\n\t\t[DllImport (CFObject.CoreFoundationLibrary)]\n\t\tstatic extern void CFRunLoopStop (IntPtr rl);\n\n\t\tpublic CFRunLoop (IntPtr handle, bool own): base (handle, own)\n\t\t{\n\t\t}\n\n\t\tpublic static CFRunLoop CurrentRunLoop {\n\t\t\tget { return new CFRunLoop (CFRunLoopGetCurrent (), false); }\n\t\t}\n\n\t\tpublic void AddSource (IntPtr source, CFString mode)\n\t\t{\n\t\t\tCFRunLoopAddSource (Handle, source, mode.Handle);\n\t\t}\n\n\t\tpublic void RemoveSource (IntPtr source, CFString mode)\n\t\t{\n\t\t\tCFRunLoopRemoveSource (Handle, source, mode.Handle);\n\t\t}\n\n\t\tpublic int RunInMode (CFString mode, double seconds, bool returnAfterSourceHandled)\n\t\t{\n\t\t\treturn CFRunLoopRunInMode (mode.Handle, seconds, returnAfterSourceHandled);\n\t\t}\n\n\t\tpublic void Stop ()\n\t\t{\n\t\t\tCFRunLoopStop (Handle);\n\t\t}\n\t}\n\n\tinternal enum CFProxyType {\n\t\tNone,\n\t\tAutoConfigurationUrl,\n\t\tAutoConfigurationJavaScript,\n\t\tFTP,\n\t\tHTTP,\n\t\tHTTPS,\n\t\tSOCKS\n\t}\n\t\n\tinternal class CFProxy {\n\t\t//static IntPtr kCFProxyAutoConfigurationHTTPResponseKey;\n\t\tstatic IntPtr kCFProxyAutoConfigurationJavaScriptKey;\n\t\tstatic IntPtr kCFProxyAutoConfigurationURLKey;\n\t\tstatic IntPtr kCFProxyHostNameKey;\n\t\tstatic IntPtr kCFProxyPasswordKey;\n\t\tstatic IntPtr kCFProxyPortNumberKey;\n\t\tstatic IntPtr kCFProxyTypeKey;\n\t\tstatic IntPtr kCFProxyUsernameKey;\n\n\t\t//static IntPtr kCFProxyTypeNone;\n\t\tstatic IntPtr kCFProxyTypeAutoConfigurationURL;\n\t\tstatic IntPtr kCFProxyTypeAutoConfigurationJavaScript;\n\t\tstatic IntPtr kCFProxyTypeFTP;\n\t\tstatic IntPtr kCFProxyTypeHTTP;\n\t\tstatic IntPtr kCFProxyTypeHTTPS;\n\t\tstatic IntPtr kCFProxyTypeSOCKS;\n\n\t\tstatic CFProxy ()\n\t\t{\n\t\t\tIntPtr handle = CFObject.dlopen (CFNetwork.CFNetworkLibrary, 0);\n\n\t\t\t//kCFProxyAutoConfigurationHTTPResponseKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyAutoConfigurationHTTPResponseKey\");\n\t\t\tkCFProxyAutoConfigurationJavaScriptKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyAutoConfigurationJavaScriptKey\");\n\t\t\tkCFProxyAutoConfigurationURLKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyAutoConfigurationURLKey\");\n\t\t\tkCFProxyHostNameKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyHostNameKey\");\n\t\t\tkCFProxyPasswordKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyPasswordKey\");\n\t\t\tkCFProxyPortNumberKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyPortNumberKey\");\n\t\t\tkCFProxyTypeKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeKey\");\n\t\t\tkCFProxyUsernameKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyUsernameKey\");\n\n\t\t\t//kCFProxyTypeNone = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeNone\");\n\t\t\tkCFProxyTypeAutoConfigurationURL = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeAutoConfigurationURL\");\n\t\t\tkCFProxyTypeAutoConfigurationJavaScript = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeAutoConfigurationJavaScript\");\n\t\t\tkCFProxyTypeFTP = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeFTP\");\n\t\t\tkCFProxyTypeHTTP = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeHTTP\");\n\t\t\tkCFProxyTypeHTTPS = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeHTTPS\");\n\t\t\tkCFProxyTypeSOCKS = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeSOCKS\");\n\n\t\t\tCFObject.dlclose (handle);\n\t\t}\n\n\t\tCFDictionary settings;\n\t\t\n\t\tinternal CFProxy (CFDictionary settings)\n\t\t{\n\t\t\tthis.settings = settings;\n\t\t}\n\t\t\n\t\tstatic CFProxyType CFProxyTypeToEnum (IntPtr type)\n\t\t{\n\t\t\tif (type == kCFProxyTypeAutoConfigurationJavaScript)\n\t\t\t\treturn CFProxyType.AutoConfigurationJavaScript;\n\n\t\t\tif (type == kCFProxyTypeAutoConfigurationURL)\n\t\t\t\treturn CFProxyType.AutoConfigurationUrl;\n\n\t\t\tif (type == kCFProxyTypeFTP)\n\t\t\t\treturn CFProxyType.FTP;\n\n\t\t\tif (type == kCFProxyTypeHTTP)\n\t\t\t\treturn CFProxyType.HTTP;\n\n\t\t\tif (type == kCFProxyTypeHTTPS)\n\t\t\t\treturn CFProxyType.HTTPS;\n\n\t\t\tif (type == kCFProxyTypeSOCKS)\n\t\t\t\treturn CFProxyType.SOCKS;\n\t\t\t\n\t\t\t//in OSX 10.13 pointer comparison didn't work for kCFProxyTypeAutoConfigurationURL\n\t\t\tif (CFString.Compare (type, kCFProxyTypeAutoConfigurationJavaScript) == 0)\n\t\t\t\treturn CFProxyType.AutoConfigurationJavaScript;\n\n\t\t\tif (CFString.Compare (type, kCFProxyTypeAutoConfigurationURL) == 0)\n\t\t\t\treturn CFProxyType.AutoConfigurationUrl;\n\n\t\t\tif (CFString.Compare (type, kCFProxyTypeFTP) == 0)\n\t\t\t\treturn CFProxyType.FTP;\n\n\t\t\tif (CFString.Compare (type, kCFProxyTypeHTTP) == 0)\n\t\t\t\treturn CFProxyType.HTTP;\n\n\t\t\tif (CFString.Compare (type, kCFProxyTypeHTTPS) == 0)\n\t\t\t\treturn CFProxyType.HTTPS;\n\n\t\t\tif (CFString.Compare (type, kCFProxyTypeSOCKS) == 0)\n\t\t\t\treturn CFProxyType.SOCKS;\n\t\t\t\n\t\t\treturn CFProxyType.None;\n\t\t}\n\t\t\n#if false\n\t\t// AFAICT these get used with CFNetworkExecuteProxyAutoConfiguration*()\n\t\t\n\t\t// TODO: bind CFHTTPMessage so we can return the proper type here.\n\t\tpublic IntPtr AutoConfigurationHTTPResponse {\n\t\t\tget { return settings[kCFProxyAutoConfigurationHTTPResponseKey]; }\n\t\t}\n#endif\n\n\t\tpublic IntPtr AutoConfigurationJavaScript {\n\t\t\tget {\n\t\t\t\tif (kCFProxyAutoConfigurationJavaScriptKey == IntPtr.Zero)\n\t\t\t\t\treturn IntPtr.Zero;\n\t\t\t\t\n\t\t\t\treturn settings[kCFProxyAutoConfigurationJavaScriptKey];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic IntPtr AutoConfigurationUrl {\n\t\t\tget {\n\t\t\t\tif (kCFProxyAutoConfigurationURLKey == IntPtr.Zero)\n\t\t\t\t\treturn IntPtr.Zero;\n\t\t\t\t\n\t\t\t\treturn settings[kCFProxyAutoConfigurationURLKey];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string HostName {\n\t\t\tget {\n\t\t\t\tif (kCFProxyHostNameKey == IntPtr.Zero)\n\t\t\t\t\treturn null;\n\t\t\t\t\n\t\t\t\treturn CFString.AsString (settings[kCFProxyHostNameKey]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string Password {\n\t\t\tget {\n\t\t\t\tif (kCFProxyPasswordKey == IntPtr.Zero)\n\t\t\t\t\treturn null;\n\n\t\t\t\treturn CFString.AsString (settings[kCFProxyPasswordKey]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int Port {\n\t\t\tget {\n\t\t\t\tif (kCFProxyPortNumberKey == IntPtr.Zero)\n\t\t\t\t\treturn 0;\n\t\t\t\t\n\t\t\t\treturn CFNumber.AsInt32 (settings[kCFProxyPortNumberKey]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic CFProxyType ProxyType {\n\t\t\tget {\n\t\t\t\tif (kCFProxyTypeKey == IntPtr.Zero)\n\t\t\t\t\treturn CFProxyType.None;\n\t\t\t\t\n\t\t\t\treturn CFProxyTypeToEnum (settings[kCFProxyTypeKey]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string Username {\n\t\t\tget {\n\t\t\t\tif (kCFProxyUsernameKey == IntPtr.Zero)\n\t\t\t\t\treturn null;\n\n\t\t\t\treturn CFString.AsString (settings[kCFProxyUsernameKey]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinternal class CFProxySettings {\n\t\tstatic IntPtr kCFNetworkProxiesHTTPEnable;\n\t\tstatic IntPtr kCFNetworkProxiesHTTPPort;\n\t\tstatic IntPtr kCFNetworkProxiesHTTPProxy;\n\t\tstatic IntPtr kCFNetworkProxiesProxyAutoConfigEnable;\n\t\tstatic IntPtr kCFNetworkProxiesProxyAutoConfigJavaScript;\n\t\tstatic IntPtr kCFNetworkProxiesProxyAutoConfigURLString;\n\n\t\tstatic CFProxySettings ()\n\t\t{\n\t\t\tIntPtr handle = CFObject.dlopen (CFNetwork.CFNetworkLibrary, 0);\n\n\t\t\tkCFNetworkProxiesHTTPEnable = CFObject.GetCFObjectHandle (handle, \"kCFNetworkProxiesHTTPEnable\");\n\t\t\tkCFNetworkProxiesHTTPPort = CFObject.GetCFObjectHandle (handle, \"kCFNetworkProxiesHTTPPort\");\n\t\t\tkCFNetworkProxiesHTTPProxy = CFObject.GetCFObjectHandle (handle, \"kCFNetworkProxiesHTTPProxy\");\n\t\t\tkCFNetworkProxiesProxyAutoConfigEnable = CFObject.GetCFObjectHandle (handle, \"kCFNetworkProxiesProxyAutoConfigEnable\");\n\t\t\tkCFNetworkProxiesProxyAutoConfigJavaScript = CFObject.GetCFObjectHandle (handle, \"kCFNetworkProxiesProxyAutoConfigJavaScript\");\n\t\t\tkCFNetworkProxiesProxyAutoConfigURLString = CFObject.GetCFObjectHandle (handle, \"kCFNetworkProxiesProxyAutoConfigURLString\");\n\n\t\t\tCFObject.dlclose (handle);\n\t\t}\n\n\t\tCFDictionary settings;\n\t\t\n\t\tpublic CFProxySettings (CFDictionary settings)\n\t\t{\n\t\t\tthis.settings = settings;\n\t\t}\n\t\t\n\t\tpublic CFDictionary Dictionary {\n\t\t\tget { return settings; }\n\t\t}\n\t\t\n\t\tpublic bool HTTPEnable {\n\t\t\tget {\n\t\t\t\tif (kCFNetworkProxiesHTTPEnable == IntPtr.Zero)\n\t\t\t\t\treturn false;\n\n\t\t\t\treturn CFNumber.AsBool (settings[kCFNetworkProxiesHTTPEnable]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int HTTPPort {\n\t\t\tget {\n\t\t\t\tif (kCFNetworkProxiesHTTPPort == IntPtr.Zero)\n\t\t\t\t\treturn 0;\n\t\t\t\t\n\t\t\t\treturn CFNumber.AsInt32 (settings[kCFNetworkProxiesHTTPPort]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string HTTPProxy {\n\t\t\tget {\n\t\t\t\tif (kCFNetworkProxiesHTTPProxy == IntPtr.Zero)\n\t\t\t\t\treturn null;\n\t\t\t\t\n\t\t\t\treturn CFString.AsString (settings[kCFNetworkProxiesHTTPProxy]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic bool ProxyAutoConfigEnable {\n\t\t\tget {\n\t\t\t\tif (kCFNetworkProxiesProxyAutoConfigEnable == IntPtr.Zero)\n\t\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t\treturn CFNumber.AsBool (settings[kCFNetworkProxiesProxyAutoConfigEnable]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string ProxyAutoConfigJavaScript {\n\t\t\tget {\n\t\t\t\tif (kCFNetworkProxiesProxyAutoConfigJavaScript == IntPtr.Zero)\n\t\t\t\t\treturn null;\n\t\t\t\t\n\t\t\t\treturn CFString.AsString (settings[kCFNetworkProxiesProxyAutoConfigJavaScript]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string ProxyAutoConfigURLString {\n\t\t\tget {\n\t\t\t\tif (kCFNetworkProxiesProxyAutoConfigURLString == IntPtr.Zero)\n\t\t\t\t\treturn null;\n\t\t\t\t\n\t\t\t\treturn CFString.AsString (settings[kCFNetworkProxiesProxyAutoConfigURLString]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinternal static class CFNetwork {\n#if !MONOTOUCH\n\t\tpublic const string CFNetworkLibrary = \"/System/Library/Frameworks/CoreServices.framework/Frameworks/CFNetwork.framework/CFNetwork\";\n#else\n\t\tpublic const string CFNetworkLibrary = \"/System/Library/Frameworks/CFNetwork.framework/CFNetwork\";\n#endif\n\t\t\n\t\t[DllImport (CFNetworkLibrary, EntryPoint = \"CFNetworkCopyProxiesForAutoConfigurationScript\")]\n\t\t// CFArrayRef CFNetworkCopyProxiesForAutoConfigurationScript (CFStringRef proxyAutoConfigurationScript, CFURLRef targetURL, CFErrorRef* error);\n\t\textern static IntPtr CFNetworkCopyProxiesForAutoConfigurationScriptSequential (IntPtr proxyAutoConfigurationScript, IntPtr targetURL, out IntPtr error);\n\n\t\t[DllImport (CFNetworkLibrary)]\n\t\textern static IntPtr CFNetworkExecuteProxyAutoConfigurationURL (IntPtr proxyAutoConfigURL, IntPtr targetURL, CFProxyAutoConfigurationResultCallback cb, ref CFStreamClientContext clientContext);\n\n\n\t\tclass GetProxyData : IDisposable {\n\t\t\tpublic IntPtr script;\n\t\t\tpublic IntPtr targetUri;\n\t\t\tpublic IntPtr error;\n\t\t\tpublic IntPtr result;\n\t\t\tpublic ManualResetEvent evt = new ManualResetEvent (false);\n\n\t\t\tpublic void Dispose ()\n\t\t\t{\n\t\t\t\tevt.Close ();\n\t\t\t}\n\t\t}\n\n\t\tstatic object lock_obj = new object ();\n\t\tstatic Queue<GetProxyData> get_proxy_queue;\n\t\tstatic AutoResetEvent proxy_event;\n\n\t\tstatic void CFNetworkCopyProxiesForAutoConfigurationScriptThread ()\n\t\t{\n\t\t\tGetProxyData data;\n\t\t\tvar data_left = true;\n\n\t\t\twhile (true) {\n\t\t\t\tproxy_event.WaitOne ();\n\n\t\t\t\tdo {\n\t\t\t\t\tlock (lock_obj) {\n\t\t\t\t\t\tif (get_proxy_queue.Count == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdata = get_proxy_queue.Dequeue ();\n\t\t\t\t\t\tdata_left = get_proxy_queue.Count > 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.result = CFNetworkCopyProxiesForAutoConfigurationScriptSequential (data.script, data.targetUri, out data.error);\n\t\t\t\t\tdata.evt.Set ();\n\t\t\t\t} while (data_left);\n\t\t\t}\n\t\t}\n\n\t\tstatic IntPtr CFNetworkCopyProxiesForAutoConfigurationScript (IntPtr proxyAutoConfigurationScript, IntPtr targetURL, out IntPtr error)\n\t\t{\n\t\t\t// This method must only be called on only one thread during an application's life time.\n\t\t\t// Note that it's not enough to use a lock to make calls sequential across different threads,\n\t\t\t// it has to be one thread. Also note that that thread can't be the main thread, because the\n\t\t\t// main thread might be blocking waiting for this network request to finish.\n\t\t\t// Another possibility would be to use JavaScriptCore to execute this piece of\n\t\t\t// javascript ourselves, but unfortunately it's not available before iOS7.\n\t\t\t// See bug #7923 comment #21+.\n\n\t\t\tusing (var data = new GetProxyData ()) {\n\t\t\t\tdata.script = proxyAutoConfigurationScript;\n\t\t\t\tdata.targetUri = targetURL;\n\n\t\t\t\tlock (lock_obj) {\n\t\t\t\t\tif (get_proxy_queue == null) {\n\t\t\t\t\t\tget_proxy_queue = new Queue<GetProxyData> ();\n\t\t\t\t\t\tproxy_event = new AutoResetEvent (false);\n\t\t\t\t\t\tnew Thread (CFNetworkCopyProxiesForAutoConfigurationScriptThread) {\n\t\t\t\t\t\t\tIsBackground = true,\n\t\t\t\t\t\t}.Start ();\n\t\t\t\t\t}\n\t\t\t\t\tget_proxy_queue.Enqueue (data);\n\t\t\t\t\tproxy_event.Set ();\n\t\t\t\t}\n\n\t\t\t\tdata.evt.WaitOne ();\n\n\t\t\t\terror = data.error;\n\n\t\t\t\treturn data.result;\n\t\t\t}\n\t\t}\n\n\t\tstatic CFArray CopyProxiesForAutoConfigurationScript (IntPtr proxyAutoConfigurationScript, CFUrl targetURL)\n\t\t{\n\t\t\tIntPtr err = IntPtr.Zero;\n\t\t\tIntPtr native = CFNetworkCopyProxiesForAutoConfigurationScript (proxyAutoConfigurationScript, targetURL.Handle, out err);\n\t\t\t\n\t\t\tif (native == IntPtr.Zero)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\treturn new CFArray (native, true);\n\t\t}\n\t\t\n\t\tpublic static CFProxy[] GetProxiesForAutoConfigurationScript (IntPtr proxyAutoConfigurationScript, CFUrl targetURL)\n\t\t{\n\t\t\tif (proxyAutoConfigurationScript == IntPtr.Zero)\n\t\t\t\tthrow new ArgumentNullException (\"proxyAutoConfigurationScript\");\n\t\t\t\n\t\t\tif (targetURL == null)\n\t\t\t\tthrow new ArgumentNullException (\"targetURL\");\n\t\t\t\n\t\t\tCFArray array = CopyProxiesForAutoConfigurationScript (proxyAutoConfigurationScript, targetURL);\n\t\t\t\n\t\t\tif (array == null)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tCFProxy[] proxies = new CFProxy [array.Count];\n\t\t\tfor (int i = 0; i < proxies.Length; i++) {\n\t\t\t\tCFDictionary dict = new CFDictionary (array[i], false);\n\t\t\t\tproxies[i] = new CFProxy (dict);\n\t\t\t}\n\n\t\t\tarray.Dispose ();\n\t\t\t\n\t\t\treturn proxies;\n\t\t}\n\t\t\n\t\tpublic static CFProxy[] GetProxiesForAutoConfigurationScript (IntPtr proxyAutoConfigurationScript, Uri targetUri)\n\t\t{\n\t\t\tif (proxyAutoConfigurationScript == IntPtr.Zero)\n\t\t\t\tthrow new ArgumentNullException (\"proxyAutoConfigurationScript\");\n\t\t\t\n\t\t\tif (targetUri == null)\n\t\t\t\tthrow new ArgumentNullException (\"targetUri\");\n\t\t\t\n\t\t\tCFUrl targetURL = CFUrl.Create (targetUri.AbsoluteUri);\n\t\t\tCFProxy[] proxies = GetProxiesForAutoConfigurationScript (proxyAutoConfigurationScript, targetURL);\n\t\t\ttargetURL.Dispose ();\n\t\t\t\n\t\t\treturn proxies;\n\t\t}\n\n\t\tdelegate void CFProxyAutoConfigurationResultCallback (IntPtr client, IntPtr proxyList, IntPtr error);\n\n\t\tpublic static CFProxy[] ExecuteProxyAutoConfigurationURL (IntPtr proxyAutoConfigURL, Uri targetURL)\n\t\t{\n\t\t\tCFUrl url = CFUrl.Create (targetURL.AbsoluteUri);\n\t\t\tif (url == null)\n\t\t\t\treturn null;\n\n\t\t\tCFProxy[] proxies = null;\n\n\t\t\tvar runLoop = CFRunLoop.CurrentRunLoop;\n\n\t\t\t// Callback that will be called after executing the configuration script\n\t\t\tCFProxyAutoConfigurationResultCallback cb = delegate (IntPtr client, IntPtr proxyList, IntPtr error) {\n\t\t\t\tif (proxyList != IntPtr.Zero) {\n\t\t\t\t\tvar array = new CFArray (proxyList, false);\n\t\t\t\t\tproxies = new CFProxy [array.Count];\n\t\t\t\t\tfor (int i = 0; i < proxies.Length; i++) {\n\t\t\t\t\t\tCFDictionary dict = new CFDictionary (array[i], false);\n\t\t\t\t\t\tproxies[i] = new CFProxy (dict);\n\t\t\t\t\t}\n\t\t\t\t\tarray.Dispose ();\n\t\t\t\t}\n\t\t\t\trunLoop.Stop ();\n\t\t\t};\n\n\t\t\tvar clientContext = new CFStreamClientContext ();\n\t\t\tvar loopSource = CFNetworkExecuteProxyAutoConfigurationURL (proxyAutoConfigURL, url.Handle, cb, ref clientContext);\n\n\t\t\t// Create a private mode\n\t\t\tvar mode = CFString.Create (\"Mono.MacProxy\");\n\n\t\t\trunLoop.AddSource (loopSource, mode);\n\t\t\trunLoop.RunInMode (mode, double.MaxValue, false);\n\t\t\trunLoop.RemoveSource (loopSource, mode);\n\n\t\t\treturn proxies;\n\t\t}\n\t\t\n\t\t[DllImport (CFNetworkLibrary)]\n\t\t// CFArrayRef CFNetworkCopyProxiesForURL (CFURLRef url, CFDictionaryRef proxySettings);\n\t\textern static IntPtr CFNetworkCopyProxiesForURL (IntPtr url, IntPtr proxySettings);\n\t\t\n\t\tstatic CFArray CopyProxiesForURL (CFUrl url, CFDictionary proxySettings)\n\t\t{\n\t\t\tIntPtr native = CFNetworkCopyProxiesForURL (url.Handle, proxySettings != null ? proxySettings.Handle : IntPtr.Zero);\n\t\t\t\n\t\t\tif (native == IntPtr.Zero)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\treturn new CFArray (native, true);\n\t\t}\n\t\t\n\t\tpublic static CFProxy[] GetProxiesForURL (CFUrl url, CFProxySettings proxySettings)\n\t\t{\n\t\t\tif (url == null || url.Handle == IntPtr.Zero)\n\t\t\t\tthrow new ArgumentNullException (\"url\");\n\t\t\t\n\t\t\tif (proxySettings == null)\n\t\t\t\tproxySettings = GetSystemProxySettings ();\n\t\t\t\n\t\t\tCFArray array = CopyProxiesForURL (url, proxySettings.Dictionary);\n\t\t\t\n\t\t\tif (array == null)\n\t\t\t\treturn null;\n\n\t\t\tCFProxy[] proxies = new CFProxy [array.Count];\n\t\t\tfor (int i = 0; i < proxies.Length; i++) {\n\t\t\t\tCFDictionary dict = new CFDictionary (array[i], false);\n\t\t\t\tproxies[i] = new CFProxy (dict);\n\t\t\t}\n\n\t\t\tarray.Dispose ();\n\t\t\t\n\t\t\treturn proxies;\n\t\t}\n\t\t\n\t\tpublic static CFProxy[] GetProxiesForUri (Uri uri, CFProxySettings proxySettings)\n\t\t{\n\t\t\tif (uri == null)\n\t\t\t\tthrow new ArgumentNullException (\"uri\");\n\t\t\t\n\t\t\tCFUrl url = CFUrl.Create (uri.AbsoluteUri);\n\t\t\tif (url == null)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tCFProxy[] proxies = GetProxiesForURL (url, proxySettings);\n\t\t\turl.Dispose ();\n\t\t\t\n\t\t\treturn proxies;\n\t\t}\n\t\t\n\t\t[DllImport (CFNetworkLibrary)]\n\t\t// CFDictionaryRef CFNetworkCopySystemProxySettings (void);\n\t\textern static IntPtr CFNetworkCopySystemProxySettings ();\n\t\t\n\t\tpublic static CFProxySettings GetSystemProxySettings ()\n\t\t{\n\t\t\tIntPtr native = CFNetworkCopySystemProxySettings ();\n\t\t\t\n\t\t\tif (native == IntPtr.Zero)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tvar dict = new CFDictionary (native, true);\n\n\t\t\treturn new CFProxySettings (dict);\n\t\t}\n\t\t\n\t\tclass CFWebProxy : IWebProxy {\n\t\t\tICredentials credentials;\n\t\t\tbool userSpecified;\n\t\t\t\n\t\t\tpublic CFWebProxy ()\n\t\t\t{\n\t\t\t}\n\t\t\t\n\t\t\tpublic ICredentials Credentials {\n\t\t\t\tget { return credentials; }\n\t\t\t\tset {\n\t\t\t\t\tuserSpecified = true;\n\t\t\t\t\tcredentials = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tstatic Uri GetProxyUri (CFProxy proxy, out NetworkCredential credentials)\n\t\t\t{\n\t\t\t\tstring protocol;\n\t\t\t\t\n\t\t\t\tswitch (proxy.ProxyType) {\n\t\t\t\tcase CFProxyType.FTP:\n\t\t\t\t\tprotocol = \"ftp://\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFProxyType.HTTP:\n\t\t\t\tcase CFProxyType.HTTPS:\n\t\t\t\t\tprotocol = \"http://\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcredentials = null;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstring username = proxy.Username;\n\t\t\t\tstring password = proxy.Password;\n\t\t\t\tstring hostname = proxy.HostName;\n\t\t\t\tint port = proxy.Port;\n\t\t\t\tstring uri;\n\t\t\t\t\n\t\t\t\tif (username != null)\n\t\t\t\t\tcredentials = new NetworkCredential (username, password);\n\t\t\t\telse\n\t\t\t\t\tcredentials = null;\n\t\t\t\t\n\t\t\t\turi = protocol + hostname + (port != 0 ? ':' + port.ToString () : string.Empty);\n\t\t\t\t\n\t\t\t\treturn new Uri (uri, UriKind.Absolute);\n\t\t\t}\n\t\t\t\n\t\t\tstatic Uri GetProxyUriFromScript (IntPtr script, Uri targetUri, out NetworkCredential credentials)\n\t\t\t{\n\t\t\t\tCFProxy[] proxies = CFNetwork.GetProxiesForAutoConfigurationScript (script, targetUri);\n\t\t\t\treturn SelectProxy (proxies, targetUri, out credentials);\n\t\t\t}\n\n\t\t\tstatic Uri ExecuteProxyAutoConfigurationURL (IntPtr proxyAutoConfigURL, Uri targetUri, out NetworkCredential credentials)\n\t\t\t{\n\t\t\t\tCFProxy[] proxies = CFNetwork.ExecuteProxyAutoConfigurationURL (proxyAutoConfigURL, targetUri);\n\t\t\t\treturn SelectProxy (proxies, targetUri, out credentials);\n\t\t\t}\n\n\n\t\t\tstatic Uri SelectProxy (CFProxy[] proxies, Uri targetUri, out NetworkCredential credentials)\n\t\t\t{\n\t\t\t\tif (proxies == null) {\n\t\t\t\t\tcredentials = null;\n\t\t\t\t\treturn targetUri;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < proxies.Length; i++) {\n\t\t\t\t\tswitch (proxies[i].ProxyType) {\n\t\t\t\t\tcase CFProxyType.HTTPS:\n\t\t\t\t\tcase CFProxyType.HTTP:\n\t\t\t\t\tcase CFProxyType.FTP:\n\t\t\t\t\t\t// create a Uri based on the hostname/port/etc info\n\t\t\t\t\t\treturn GetProxyUri (proxies[i], out credentials);\n\t\t\t\t\tcase CFProxyType.SOCKS:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// unsupported proxy type, try the next one\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CFProxyType.None:\n\t\t\t\t\t\t// no proxy should be used\n\t\t\t\t\t\tcredentials = null;\n\t\t\t\t\t\treturn targetUri;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcredentials = null;\n\t\t\t\t\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tpublic Uri GetProxy (Uri targetUri)\n\t\t\t{\n\t\t\t\tNetworkCredential credentials = null;\n\t\t\t\tUri proxy = null;\n\t\t\t\t\n\t\t\t\tif (targetUri == null)\n\t\t\t\t\tthrow new ArgumentNullException (\"targetUri\");\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tCFProxySettings settings = CFNetwork.GetSystemProxySettings ();\n\t\t\t\t\tCFProxy[] proxies = CFNetwork.GetProxiesForUri (targetUri, settings);\n\t\t\t\t\t\n\t\t\t\t\tif (proxies != null) {\n\t\t\t\t\t\tfor (int i = 0; i < proxies.Length && proxy == null; i++) {\n\t\t\t\t\t\t\tswitch (proxies[i].ProxyType) {\n\t\t\t\t\t\t\tcase CFProxyType.AutoConfigurationJavaScript:\n\t\t\t\t\t\t\t\tproxy = GetProxyUriFromScript (proxies[i].AutoConfigurationJavaScript, targetUri, out credentials);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase CFProxyType.AutoConfigurationUrl:\n\t\t\t\t\t\t\t\tproxy = ExecuteProxyAutoConfigurationURL (proxies[i].AutoConfigurationUrl, targetUri, out credentials);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase CFProxyType.HTTPS:\n\t\t\t\t\t\t\tcase CFProxyType.HTTP:\n\t\t\t\t\t\t\tcase CFProxyType.FTP:\n\t\t\t\t\t\t\t\t// create a Uri based on the hostname/port/etc info\n\t\t\t\t\t\t\t\tproxy = GetProxyUri (proxies[i], out credentials);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase CFProxyType.SOCKS:\n\t\t\t\t\t\t\t\t// unsupported proxy type, try the next one\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase CFProxyType.None:\n\t\t\t\t\t\t\t\t// no proxy should be used\n\t\t\t\t\t\t\t\tproxy = targetUri;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (proxy == null) {\n\t\t\t\t\t\t\t// no supported proxies for this Uri, fall back to trying to connect to targetUri directly\n\t\t\t\t\t\t\tproxy = targetUri;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tproxy = targetUri;\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\t// ignore errors while retrieving proxy data\n\t\t\t\t\tproxy = targetUri;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!userSpecified)\n\t\t\t\t\tthis.credentials = credentials;\n\t\t\t\t\n\t\t\t\treturn proxy;\n\t\t\t}\n\t\t\t\n\t\t\tpublic bool IsBypassed (Uri targetUri)\n\t\t\t{\n\t\t\t\tif (targetUri == null)\n\t\t\t\t\tthrow new ArgumentNullException (\"targetUri\");\n\t\t\t\t\n\t\t\t\treturn GetProxy (targetUri) == targetUri;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static IWebProxy GetDefaultProxy ()\n\t\t{\n\t\t\treturn new CFWebProxy ();\n\t\t}\n\t}\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System/System.Net.NetworkInformation/NetworkChange.cs": "//\n// System.Net.NetworkInformation.NetworkChange\n//\n// Authors:\n//   Gonzalo Paniagua Javier (LinuxNetworkChange) (gonzalo@novell.com)\n//   Aaron Bockover (MacNetworkChange) (abock@xamarin.com)\n//\n// Copyright (c) 2006,2011 Novell, Inc. (http://www.novell.com)\n// Copyright (c) 2013 Xamarin, Inc. (http://www.xamarin.com)\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\nusing System;\nusing System.Net.Sockets;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\nusing System.Threading;\n\n#if NETWORK_CHANGE_STANDALONE\nnamespace NetworkInformation {\n\n\tpublic class NetworkAvailabilityEventArgs : EventArgs\n\t{\n\t\tpublic bool IsAvailable { get; set; }\n\n\t\tpublic NetworkAvailabilityEventArgs (bool available)\n\t\t{\n\t\t\tIsAvailable = available;\n\t\t}\n\t}\n\n\tpublic delegate void NetworkAddressChangedEventHandler (object sender, EventArgs args);\n\tpublic delegate void NetworkAvailabilityChangedEventHandler (object sender, NetworkAvailabilityEventArgs args);\n#else\nnamespace System.Net.NetworkInformation {\n#endif\n\n\tinternal interface INetworkChange : IDisposable {\n\t\tevent NetworkAddressChangedEventHandler NetworkAddressChanged;\n\t\tevent NetworkAvailabilityChangedEventHandler NetworkAvailabilityChanged;\n\t\tbool HasRegisteredEvents { get; }\n\t}\n\n\tpublic sealed class NetworkChange {\n\t\tstatic INetworkChange networkChange;\n\n\t\tpublic static event NetworkAddressChangedEventHandler NetworkAddressChanged {\n\t\t\tadd {\n\t\t\t\tlock (typeof (INetworkChange)) {\n\t\t\t\t\tMaybeCreate ();\n\t\t\t\t\tif (networkChange != null)\n\t\t\t\t\t\tnetworkChange.NetworkAddressChanged += value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremove {\n\t\t\t\tlock (typeof (INetworkChange)) {\n\t\t\t\t\tif (networkChange != null) {\n\t\t\t\t\t\tnetworkChange.NetworkAddressChanged -= value;\n\t\t\t\t\t\tMaybeDispose ();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic static event NetworkAvailabilityChangedEventHandler NetworkAvailabilityChanged {\n\t\t\tadd {\n\t\t\t\tlock (typeof (INetworkChange)) {\n\t\t\t\t\tMaybeCreate ();\n\t\t\t\t\tif (networkChange != null)\n\t\t\t\t\t\tnetworkChange.NetworkAvailabilityChanged += value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremove {\n\t\t\t\tlock (typeof (INetworkChange)) {\n\t\t\t\t\tif (networkChange != null) {\n\t\t\t\t\t\tnetworkChange.NetworkAvailabilityChanged -= value;\n\t\t\t\t\t\tMaybeDispose ();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstatic void MaybeCreate ()\n\t\t{\n#if MONOTOUCH_WATCH || ORBIS\n\t\t\tthrow new PlatformNotSupportedException (\"NetworkInformation.NetworkChange is not supported on the current platform.\");\n#else\n\t\t\tif (networkChange != null)\n\t\t\t\treturn;\n\n\t\t\ttry {\n\t\t\t\tnetworkChange = new MacNetworkChange ();\n\t\t\t} catch {\n#if !NETWORK_CHANGE_STANDALONE && !MONOTOUCH\n\t\t\t\tnetworkChange = new LinuxNetworkChange ();\n#endif\n\t\t\t}\n#endif // MONOTOUCH_WATCH\n\t\t}\n\n\t\tstatic void MaybeDispose ()\n\t\t{\n\t\t\tif (networkChange != null && networkChange.HasRegisteredEvents) {\n\t\t\t\tnetworkChange.Dispose ();\n\t\t\t\tnetworkChange = null;\n\t\t\t}\n\t\t}\n\t}\n\n#if !MONOTOUCH_WATCH && !ORBIS\n\tinternal sealed class MacNetworkChange : INetworkChange\n\t{\n\t\tconst string DL_LIB = \"/usr/lib/libSystem.dylib\";\n\t\tconst string CORE_SERVICES_LIB = \"/System/Library/Frameworks/SystemConfiguration.framework/SystemConfiguration\";\n\t\tconst string CORE_FOUNDATION_LIB = \"/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\";\n\n\t\t[UnmanagedFunctionPointerAttribute (CallingConvention.Cdecl)]\n\t\tdelegate void SCNetworkReachabilityCallback (IntPtr target, NetworkReachabilityFlags flags, IntPtr info);\n\n\t\t[DllImport (DL_LIB)]\n\t\tstatic extern IntPtr dlopen (string path, int mode);\n\n\t\t[DllImport (DL_LIB)]\n\t\tstatic extern IntPtr dlsym (IntPtr handle, string symbol);\n\n\t\t[DllImport (DL_LIB)]\n\t\tstatic extern int dlclose (IntPtr handle);\n\n\t\t[DllImport (CORE_FOUNDATION_LIB)]\n\t\tstatic extern void CFRelease (IntPtr handle);\n\n\t\t[DllImport (CORE_FOUNDATION_LIB)]\n\t\tstatic extern IntPtr CFRunLoopGetMain ();\n\n\t\t[DllImport (CORE_SERVICES_LIB)]\n\t\tstatic extern IntPtr SCNetworkReachabilityCreateWithAddress (IntPtr allocator, ref sockaddr_in sockaddr);\n\n\t\t[DllImport (CORE_SERVICES_LIB)]\n\t\tstatic extern bool SCNetworkReachabilityGetFlags (IntPtr reachability, out NetworkReachabilityFlags flags);\n\n\t\t[DllImport (CORE_SERVICES_LIB)]\n\t\tstatic extern bool SCNetworkReachabilitySetCallback (IntPtr reachability, SCNetworkReachabilityCallback callback, ref SCNetworkReachabilityContext context);\n\n\t\t[DllImport (CORE_SERVICES_LIB)]\n\t\tstatic extern bool SCNetworkReachabilityScheduleWithRunLoop (IntPtr reachability, IntPtr runLoop, IntPtr runLoopMode);\n\n\t\t[DllImport (CORE_SERVICES_LIB)]\n\t\tstatic extern bool SCNetworkReachabilityUnscheduleFromRunLoop (IntPtr reachability, IntPtr runLoop, IntPtr runLoopMode);\n\n\t\t[StructLayout (LayoutKind.Explicit, Size = 28)]\n\t\tstruct sockaddr_in {\n\t\t\t[FieldOffset (0)] public byte sin_len;\n\t\t\t[FieldOffset (1)] public byte sin_family;\n\n\t\t\tpublic static sockaddr_in Create ()\n\t\t\t{\n\t\t\t\treturn new sockaddr_in {\n\t\t\t\t\tsin_len = 28,\n\t\t\t\t\tsin_family = 2 // AF_INET\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t[StructLayout (LayoutKind.Sequential)]\n\t\tstruct SCNetworkReachabilityContext {\n\t\t\tpublic IntPtr version;\n\t\t\tpublic IntPtr info;\n\t\t\tpublic IntPtr retain;\n\t\t\tpublic IntPtr release;\n\t\t\tpublic IntPtr copyDescription;\n\t\t}\n\n\t\t[Flags]\n\t\tenum NetworkReachabilityFlags {\n\t\t\tNone = 0,\n\t\t\tTransientConnection = 1 << 0,\n\t\t\tReachable = 1 << 1,\n\t\t\tConnectionRequired = 1 << 2,\n\t\t\tConnectionOnTraffic = 1 << 3,\n\t\t\tInterventionRequired = 1 << 4,\n\t\t\tConnectionOnDemand = 1 << 5,\n\t\t\tIsLocalAddress = 1 << 16,\n\t\t\tIsDirect = 1 << 17,\n\t\t\tIsWWAN = 1 << 18,\n\t\t\tConnectionAutomatic = ConnectionOnTraffic\n\t\t}\n\n\t\tIntPtr handle;\n\t\tIntPtr runLoopMode;\n\t\tSCNetworkReachabilityCallback callback;\n\t\tbool scheduledWithRunLoop;\n\t\tNetworkReachabilityFlags flags;\n\n\t\tevent NetworkAddressChangedEventHandler networkAddressChanged;\n\t\tevent NetworkAvailabilityChangedEventHandler networkAvailabilityChanged;\n\n\t\tpublic event NetworkAddressChangedEventHandler NetworkAddressChanged {\n\t\t\tadd {\n\t\t\t\tvalue (null, EventArgs.Empty);\n\t\t\t\tnetworkAddressChanged += value;\n\t\t\t}\n\n\t\t\tremove { networkAddressChanged -= value; }\n\t\t}\n\n\t\tpublic event NetworkAvailabilityChangedEventHandler NetworkAvailabilityChanged {\n\t\t\tadd {\n\t\t\t\tvalue (null, new NetworkAvailabilityEventArgs (IsAvailable));\n\t\t\t\tnetworkAvailabilityChanged += value;\n\t\t\t}\n\n\t\t\tremove { networkAvailabilityChanged -= value; }\n\t\t}\n\n\t\tbool IsAvailable {\n\t\t\tget {\n\t\t\t\treturn (flags & NetworkReachabilityFlags.Reachable) != 0 &&\n\t\t\t\t\t(flags & NetworkReachabilityFlags.ConnectionRequired) == 0;\n\t\t\t}\n\t\t}\n\n\t\tpublic bool HasRegisteredEvents {\n\t\t\tget { return networkAddressChanged != null || networkAvailabilityChanged != null; }\n\t\t}\n\n\t\tpublic MacNetworkChange ()\n\t\t{\n\t\t\tvar sockaddr = sockaddr_in.Create ();\n\t\t\thandle = SCNetworkReachabilityCreateWithAddress (IntPtr.Zero, ref sockaddr);\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\tthrow new Exception (\"SCNetworkReachabilityCreateWithAddress returned NULL\");\n\n\t\t\tcallback = new SCNetworkReachabilityCallback (HandleCallback);\n\t\t\tvar info = new SCNetworkReachabilityContext {\n\t\t\t\tinfo = GCHandle.ToIntPtr (GCHandle.Alloc (this))\n\t\t\t};\n\n\t\t\tSCNetworkReachabilitySetCallback (handle, callback, ref info);\n\n\t\t\tscheduledWithRunLoop =\n\t\t\tLoadRunLoopMode () &&\n\t\t\t\tSCNetworkReachabilityScheduleWithRunLoop (handle, CFRunLoopGetMain (), runLoopMode);\n\n\t\t\tSCNetworkReachabilityGetFlags (handle, out flags);\n\t\t}\n\n\t\tbool LoadRunLoopMode ()\n\t\t{\n\t\t\tvar cfLibHandle = dlopen (CORE_FOUNDATION_LIB, 0);\n\t\t\tif (cfLibHandle == IntPtr.Zero)\n\t\t\t\treturn false;\n\n\t\t\ttry {\n\t\t\t\trunLoopMode = dlsym (cfLibHandle, \"kCFRunLoopDefaultMode\");\n\t\t\t\tif (runLoopMode != IntPtr.Zero) {\n\t\t\t\t\trunLoopMode = Marshal.ReadIntPtr (runLoopMode);\n\t\t\t\t\treturn runLoopMode != IntPtr.Zero;\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tdlclose (cfLibHandle);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic void Dispose ()\n\t\t{\n\t\t\tlock (this) {\n\t\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (scheduledWithRunLoop)\n\t\t\t\t\tSCNetworkReachabilityUnscheduleFromRunLoop (handle, CFRunLoopGetMain (), runLoopMode);\n\n\t\t\t\tCFRelease (handle);\n\t\t\t\thandle = IntPtr.Zero;\n\t\t\t\tcallback = null;\n\t\t\t\tflags = NetworkReachabilityFlags.None;\n\t\t\t\tscheduledWithRunLoop = false;\n\t\t\t}\n\t\t}\n\n\t\t[Mono.Util.MonoPInvokeCallback (typeof (SCNetworkReachabilityCallback))]\n\t\tstatic void HandleCallback (IntPtr reachability, NetworkReachabilityFlags flags, IntPtr info)\n\t\t{\n\t\t\tif (info == IntPtr.Zero)\n\t\t\t\treturn;\n\n\t\t\tvar instance = GCHandle.FromIntPtr (info).Target as MacNetworkChange;\n\t\t\tif (instance == null || instance.flags == flags)\n\t\t\t\treturn;\n\n\t\t\tinstance.flags = flags;\n\n\t\t\tvar addressChanged = instance.networkAddressChanged;\n\t\t\tif (addressChanged != null)\n\t\t\t\taddressChanged (null, EventArgs.Empty);\n\n\t\t\tvar availabilityChanged = instance.networkAvailabilityChanged;\n\t\t\tif (availabilityChanged != null)\n\t\t\t\tavailabilityChanged (null, new NetworkAvailabilityEventArgs (instance.IsAvailable));\n\t\t}\n\t}\n#endif // !MONOTOUCH_WATCH\n\n#if !NETWORK_CHANGE_STANDALONE && !MONOTOUCH && !ORBIS\n\n\tinternal sealed class LinuxNetworkChange : INetworkChange {\n\t\t[Flags]\n\t\tenum EventType : int {\n\t\t\tAvailability = 1 << 0,\n\t\t\tAddress = 1 << 1,\n\t\t}\n\n\t\tobject _lock = new object ();\n\t\tSocket nl_sock;\n\t\tSocketAsyncEventArgs nl_args;\n\t\tEventType pending_events;\n\t\tTimer timer;\n\n\t\tNetworkAddressChangedEventHandler AddressChanged;\n\t\tNetworkAvailabilityChangedEventHandler AvailabilityChanged;\n\n\t\tpublic event NetworkAddressChangedEventHandler NetworkAddressChanged {\n\t\t\tadd { Register (value); }\n\t\t\tremove { Unregister (value); }\n\t\t}\n\n\t\tpublic event NetworkAvailabilityChangedEventHandler NetworkAvailabilityChanged {\n\t\t\tadd { Register (value); }\n\t\t\tremove { Unregister (value); }\n\t\t}\n\n\t\tpublic bool HasRegisteredEvents {\n\t\t\tget { return AddressChanged != null || AvailabilityChanged != null; }\n\t\t}\n\n\t\tpublic void Dispose ()\n\t\t{\n\t\t}\n\n\t\t//internal Socket (AddressFamily family, SocketType type, ProtocolType proto, IntPtr sock)\n\n\t\tbool EnsureSocket ()\n\t\t{\n\t\t\tlock (_lock) {\n\t\t\t\tif (nl_sock != null)\n\t\t\t\t\treturn true;\n\t\t\t\tIntPtr fd = CreateNLSocket ();\n\t\t\t\tif (fd.ToInt64 () == -1)\n\t\t\t\t\treturn false;\n\n\t\t\t\tvar safeHandle = new SafeSocketHandle (fd, true);\n\n\t\t\t\tnl_sock = new Socket (0, SocketType.Raw, ProtocolType.Udp, safeHandle);\n\t\t\t\tnl_args = new SocketAsyncEventArgs ();\n\t\t\t\tnl_args.SetBuffer (new byte [8192], 0, 8192);\n\t\t\t\tnl_args.Completed += OnDataAvailable;\n\t\t\t\tnl_sock.ReceiveAsync (nl_args);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t// _lock is held by the caller\n\t\tvoid MaybeCloseSocket ()\n\t\t{\n\t\t\tif (nl_sock == null || AvailabilityChanged != null || AddressChanged != null)\n\t\t\t\treturn;\n\n\t\t\tCloseNLSocket (nl_sock.Handle);\n\t\t\tGC.SuppressFinalize (nl_sock);\n\t\t\tnl_sock = null;\n\t\t\tnl_args = null;\n\t\t}\n\n\t\tbool GetAvailability ()\n\t\t{\n\t\t\tNetworkInterface [] adapters = NetworkInterface.GetAllNetworkInterfaces ();\n\t\t\tforeach (NetworkInterface n in adapters) {\n\t\t\t\t// TODO: also check for a default route present?\n\t\t\t\tif (n.NetworkInterfaceType == NetworkInterfaceType.Loopback)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (n.OperationalStatus == OperationalStatus.Up)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tvoid OnAvailabilityChanged (object unused)\n\t\t{\n\t\t\tNetworkAvailabilityChangedEventHandler d = AvailabilityChanged;\n\t\t\tif (d != null)\n\t\t\t\td (null, new NetworkAvailabilityEventArgs (GetAvailability ()));\n\t\t}\n\n\t\tvoid OnAddressChanged (object unused)\n\t\t{\n\t\t\tNetworkAddressChangedEventHandler d = AddressChanged;\n\t\t\tif (d != null)\n\t\t\t\td (null, EventArgs.Empty);\n\t\t}\n\n\t\tvoid OnEventDue (object unused)\n\t\t{\n\t\t\tEventType evts;\n\t\t\tlock (_lock) {\n\t\t\t\tevts = pending_events;\n\t\t\t\tpending_events = 0;\n\t\t\t\ttimer.Change (-1, -1);\n\t\t\t}\n\t\t\tif ((evts & EventType.Availability) != 0)\n\t\t\t\tThreadPool.QueueUserWorkItem (OnAvailabilityChanged);\n\t\t\tif ((evts & EventType.Address) != 0)\n\t\t\t\tThreadPool.QueueUserWorkItem (OnAddressChanged);\n\t\t}\n\n\t\tvoid QueueEvent (EventType type)\n\t\t{\n\t\t\tlock (_lock) {\n\t\t\t\tif (timer == null)\n\t\t\t\t\ttimer = new Timer (OnEventDue);\n\t\t\t\tif (pending_events == 0)\n\t\t\t\t\ttimer.Change (150, -1);\n\t\t\t\tpending_events |= type;\n\t\t\t}\n\t\t}\n\n\t\tunsafe void OnDataAvailable (object sender, SocketAsyncEventArgs args)\n\t\t{\n\t\t\tif (nl_sock == null) // Recent changes in Mono cause MaybeCloseSocket to be called before OnDataAvailable\n\t\t\t\treturn;\n\t\t\tEventType type;\n\t\t\tfixed (byte *ptr = args.Buffer) {\n\t\t\t\ttype = ReadEvents (nl_sock.Handle, new IntPtr (ptr), args.BytesTransferred, 8192);\n\t\t\t}\n\t\t\tnl_sock.ReceiveAsync (nl_args);\n\t\t\tif (type != 0)\n\t\t\t\tQueueEvent (type);\n\t\t}\n\n\t\tvoid Register (NetworkAddressChangedEventHandler d)\n\t\t{\n\t\t\tEnsureSocket ();\n\t\t\tAddressChanged += d;\n\t\t}\n\n\t\tvoid Register (NetworkAvailabilityChangedEventHandler d)\n\t\t{\n\t\t\tEnsureSocket ();\n\t\t\tAvailabilityChanged += d;\n\t\t}\n\n\t\tvoid Unregister (NetworkAddressChangedEventHandler d)\n\t\t{\n\t\t\tlock (_lock) {\n\t\t\t\tAddressChanged -= d;\n\t\t\t\tMaybeCloseSocket ();\n\t\t\t}\n\t\t}\n\n\t\tvoid Unregister (NetworkAvailabilityChangedEventHandler d)\n\t\t{\n\t\t\tlock (_lock) {\n\t\t\t\tAvailabilityChanged -= d;\n\t\t\t\tMaybeCloseSocket ();\n\t\t\t}\n\t\t}\n\n#if MONODROID\n\t\t[MethodImplAttribute(MethodImplOptions.InternalCall)]\n\t\tstatic extern IntPtr CreateNLSocket ();\n\n\t\t[MethodImplAttribute(MethodImplOptions.InternalCall)]\n\t\tstatic extern EventType ReadEvents (IntPtr sock, IntPtr buffer, int count, int size);\n\n\t\t[MethodImplAttribute(MethodImplOptions.InternalCall)]\n\t\tstatic extern IntPtr CloseNLSocket (IntPtr sock);\n#else\n\t\t[DllImport (\"MonoPosixHelper\", CallingConvention=CallingConvention.Cdecl)]\n\t\tstatic extern IntPtr CreateNLSocket ();\n\n\t\t[DllImport (\"MonoPosixHelper\", CallingConvention=CallingConvention.Cdecl)]\n\t\tstatic extern EventType ReadEvents (IntPtr sock, IntPtr buffer, int count, int size);\n\n\t\t[DllImport (\"MonoPosixHelper\", CallingConvention=CallingConvention.Cdecl)]\n\t\tstatic extern IntPtr CloseNLSocket (IntPtr sock);\n#endif\n\t}\n\n#endif\n\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mono/tests/internalsvisibleto-2048.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mono/tests/testing_gac/testkey.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mono/eglib/test/UTF-32BE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mono/eglib/test/UTF-32LE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mono/eglib/test/UTF-16BE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mono/eglib/test/UTF-16LE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/cord/de_win.ICO",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/libgc/doc/README.Mac",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/data/browscap.ini",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/po/mcs/pt_BR.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/po/mcs/ja.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/po/mcs/de.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/po/mcs/es.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/Windows/Windows.WinMD",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/Windows/Windows.Foundation.UniversalApiContract.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/Windows/Windows.Foundation.FoundationContract.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/Test/UWPTestComponentCSharp.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/Test/UwpTestWinRtComponentCpp.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/ICSharpCode.SharpZipLib.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/SharpZipLib.mshc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/SharpZipLib.chm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch80.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch20.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch60.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch0.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch30.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_sortactive_asc.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch70.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_collapsed.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch90.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_sortactive_desc.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_pin_unpinned.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_pin_pinned.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_expanded.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch50.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch40.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch100.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_sortinactive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch10.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/specification/bzip2-manual-1.0.5.html",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/future/FILEFMTS.LST",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/ICSharpCode.SharpZipLib.Samples/vb/viewzipfile/MainForm.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/ICSharpCode.SharpZipLib.Samples/vb/minibzip2/MainForm.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/ICSharpCode.SharpZipLib.Samples/vb/CreateZipFile/CreateZipFile.MainForm.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/external/SharpZipLib/ICSharpCode.SharpZipLib.Samples/vb/CreateZipFile/MainForm.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/mdoc/Test/UwpTestWinRtComponentCpp.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/mdoc/mdoc.Test/cppcli/cppcli/app.rc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/mdoc/mdoc.Test/cppcli/cppcli/app.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Test/monodoc_test/trees/tree-from-3-0.tree",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Test/monodoc_test/trees/tree-from-3-0-old.tree",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Test/monodoc_test/sources/netdocs.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Test/monodoc_test/sources/netdocs.tree",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/creativecommons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/Lminus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/Lplus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/help.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/privevent.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/bc_separator.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/privdelegate.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/protmethod.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/error.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/protclass.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/house.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/namespace.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/privenumeration.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/headerbg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/members.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/protenumeration.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/pubenumeration.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/protinterface.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/pubmethod.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/privmethod.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/pubextension.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/protstructure.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/pubevent.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/pubproperty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/pubfield.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/protproperty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/pubclass.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/protfield.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/treebg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/protextension.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/pubinterface.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/bc_bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/pubstructure.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/pubdelegate.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/privfield.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/privstructure.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/protdelegate.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/privinterface.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/protevent.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/privextension.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/hatch.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/privclass.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/privproperty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/api-doc-tools/monodoc/Resources/images/reference.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/ikvm/ikvm-fork.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/src/System/Xml/XmlCharType.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/Xslt/TestFiles/TestData/xsltc/baseline/infft16---.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/Xslt/TestFiles/TestData/xsltc/baseline/infft2.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/Xslt/TestFiles/TestData/xsltc/precompiled/Scripting28.xsl",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/bug382035a.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/bug382035a1.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v4-2.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v5-2.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v6-1.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v6-1.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v6-2.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v5-2.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v5-1.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/b.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/a.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v5-1.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v6-2.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v4-1.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.DirectoryServices/src/Resources/System/DirectoryServices/DirectoryEntry.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.DirectoryServices/src/Resources/System/DirectoryServices/DirectorySearcher.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Text.Encodings.Web/src/Resources/unicode8definedcharacters.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Native/Windows/clrcompression/zlib/zlib.3.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Native/AnyOS/brotli/common/dictionary.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Reflection/tests/Resources/EmbeddedImage.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Reflection.Metadata/tests/Resources/WinRT/Lib.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Reflection.Metadata/tests/Resources/PortablePdbs/Documents.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Reflection.Metadata/tests/Resources/Misc/KeyPair.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Reflection.Metadata/tests/Resources/Misc/CPPClassLibrary2.obj",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Reflection.Metadata/tests/Resources/NetModule/ModuleCS00.mod",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Reflection.Metadata/tests/Resources/NetModule/ModuleCS01.mod",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Reflection.Metadata/tests/Resources/NetModule/ModuleVB01.mod",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Runtime/tests/System/Reflection/EmbeddedImage.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/KOR_problem_chars_b.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/Thai_risky_chars.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/Surrogates_1.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/Russian_problem_chars.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/JPN_problem_chars_2.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/JPN_problem_chars_1.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/test63682.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/xql_orders-flat-200a.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/turkish.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/XQL_Orders_j3.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/XQL_Orders_j1.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Runtime.Serialization.Xml/tests/Canonicalization/baselines/ReaderWriter_C14N_BaselineXML.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Runtime.Serialization.Xml/tests/Canonicalization/baselines/ReaderWriter_C14N_BaselineXML_NoCRLF.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Runtime.Serialization.Xml/tests/Canonicalization/baselines/ReaderWriter_C14N_BaselineXML_Binary.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Runtime.Serialization.Xml/tests/Canonicalization/baselines/ReaderWriter_C14N_BaselineXML_OnlyLF.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Data.SqlClient/tests/ManualTests/SQL/TransactionTest/TransactionTest.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Data.SqlClient/tests/Tools/TDS/TDS.Servers/TdsServerCertificate.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Text.Encoding.CodePages/src/Data/codepages.nlp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Diagnostics.Tracing/documentation/PerfViewCapture_Events.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Diagnostics.Tracing/documentation/PerfViewCapture_Counters.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Net.Sockets/tests/Scripts/SetReuseUnicastPort.ps1",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Net.Sockets/tests/Scripts/ClearReuseUnicastPort.ps1",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Drawing.Common/src/Resources/System/Drawing/ShieldIcon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Drawing.Common/src/Resources/System/Drawing/DefaultComponent.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Drawing.Common/src/Resources/System/Drawing/Error.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Drawing.Common/src/Resources/System/Drawing/Printing/PrintDocument.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/src/System.Drawing.Common/src/misc/GDI/WindowsGraphics.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/Documentation/images/portability_report.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/Documentation/images/portability_solution_explorer.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/Documentation/images/api-review-process.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/Documentation/images/portability_screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/Documentation/project-docs/pcl-targets-dialog-net46-aspnetcore10.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corefx/Documentation/debugging/perfview_example.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/utils/lit/tests/shtest-encoding.py",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/bindings/python/llvm/tests/test.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/LTO/X86/Inputs/invalid.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Verifier/non-integer-gep-index.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/ThinLTO/X86/Inputs/autoupgrade.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/ThinLTO/X86/Inputs/drop-debug-info.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Linker/Inputs/old_global_ctors.3.4.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Linker/Inputs/drop-debug.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/pr25877.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-universal-bad1.x86_64.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/phdrs.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-object-test.elf-mips64el",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/corrupt-invalid-dynamic-table-offset.elf.x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/hello-world.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-object-test.elf-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/relocatable-with-section-address.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/stackmap-test.macho-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/darwin-m-test3.macho-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-strtab-type.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-bad-rel-type.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/elf-versioning-test.x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/corrupt-version.elf-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/dext-test.elf-mips64r2",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/corrupt-archive.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-archive-x86_64.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-reloc.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/thin.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-universal-archive.x86_64.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-text-data-bss.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-section-index.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/no-sections.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-object-test.coff-arm64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-object-test.macho-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/liblong_filenames.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-object-test.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/thumb-symbols.elf.arm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/elf-versioning-test.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/darwin-m-test2.macho-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-universal-archive-bad1.x86_64.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/relocation-relocatable.elf-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/libsimple_archive.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-executable-test.macho-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/unwind-section.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-label-test.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-object-test.elf-hexagon",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/program-headers.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-universal64-archive.x86_64.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho64-invalid-too-small-load-command.1",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/GNU.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/xpg4.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-object-test2.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/elf-reloc-no-sym.x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/shared-object-test.elf-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-section-size2.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-object-test.macho-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/corrupt-invalid-dynamic-table-too-large.elf.x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-relocation-sec-sh_offset.elf-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-object-test2.macho-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/no-start-symbol.elf-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-phdr.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-universal.x86_64.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/coff_archive.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-universal-bad2.x86_64.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/micro-mips.elf-mipsel",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/archive-test.a-irix6-mips64el",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-universal64.x86_64.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-universal-archive-bad2.x86_64.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-ext-symtab-index.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-object-test.wasm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-rel-sym.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/dyn-rel.so.elf-mips",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-bad-archive2.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/shndx.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/corrupt-invalid-strtab.elf.x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-hello-g.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/hello-world.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/common.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/program-headers.mips64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho64-invalid-incomplete-load-command.1",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/corrupt-invalid-phentsize.elf.x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-strtab-non-null.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/MacOSX.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/very_long_bytecode_file_name.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-strtab-zero-size.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/archive-test.a-corrupt-symbol-table",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-object-test.elf-mipsel",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/darwin-m-test1.mach0-armv7",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-section-size.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-bad-archive1.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/program-headers.elf-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/weak-global-symbol.macho-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-text.thumb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-strtab-size.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/phdr-note.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/SVR4.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/openbsd-phdrs.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-archive-unsorted-x86_64.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/corrupt.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/thin-path.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-object-test.coff-armnt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-invalid-fat.obj.elf-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/sectionGroup.elf.x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-text-sections.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-no-exports.dylib",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/no-section-header-string-table.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-object-test.coff-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-relocation-sec-sh_offset.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-toc64-archive-x86_64.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-object-test.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-sh_entsize.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/rel-no-sec-table.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-invalid-too-small-segment-load-command.1",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/program-headers.mips",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-xindex-size.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/corrupt-invalid-dynamic-table-size.elf.x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/archive-test.a-coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/corrupt-invalid-relocation-size.elf.x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-symbol-table-size.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/relocations.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/coff_archive_short.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/shared-object-test.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/absolute.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-bad-section-address.coff",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/macho-data-in-code.macho-thumbv7",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-sections-address-alignment.x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/corrupt-invalid-virtual-addr.elf.x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/invalid-sections-num.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/weak.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/trivial-object-test.elf-avr",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Object/Inputs/relocation-dynamic.elf-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/MC/AsmParser/Inputs/non-english-characters-comments.s",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/MC/AsmParser/Inputs/non-english-characters-section-name.s",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Transforms/SampleProfile/Inputs/gcc-simple.afdo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Transforms/SampleProfile/Inputs/fnptr.binprof",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Transforms/SampleProfile/Inputs/indirect-call.afdo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-ar/Inputs/absolute-paths.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-rc/Inputs/bitmap.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-rc/Inputs/nested/nested-bitmap.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/sancov/Inputs/test-linux_x86_64.0.sancov",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/sancov/Inputs/test-linux_x86_64.1.sancov",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-pdbdump/Inputs/ComplexPaddingTest.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-pdbdump/Inputs/FilterTest.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-pdbdump/Inputs/SimplePaddingTest.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-pdbdump/Inputs/ClassLayoutTest.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-pdbdump/Inputs/LoadAddressTest.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-nm/ARM/Inputs/print-size.macho-armv7m",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-nm/X86/Inputs/hello.obj.elf-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-nm/X86/Inputs/hello.obj.elf-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-nm/X86/Inputs/example.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-nm/X86/Inputs/weak.obj.elf-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-nm/X86/Inputs/init-fini.out.elf-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-nm/X86/Inputs/hello.obj.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-nm/X86/Inputs/Strip-ST.dylib.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-nm/X86/Inputs/test.IRobj-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-nm/X86/Inputs/libExample.a.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/malformedRegions.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/showExpansions.profdata",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/name_whitelist.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/binary-formats.v2.linux64l",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/binary-formats.v1.linux64l",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/test_paths.gcda",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/dir-with-filtering.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/gcov47_compatibility.gcda",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/regionMarkers.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/highlightedRanges.profdata",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/range_based_for.gcno",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/binary-formats.macho32b",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/showExpansions.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/prefer_used_to_unused.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/path_equivalence.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/showProjectSummary.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/multiple-files2.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/report.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/deferred-regions.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/prevent_false_instantiations.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/range_based_for.gcda",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/templateInstantiations.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/multiple-files.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/gcov47_compatibility.gcno",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/test_func_checksum_fail.gcda",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/test.gcno",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/combine_expansions.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/double_dots.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/copy_block_helper.gcno",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/deferred-regions.profdata",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/ifdef.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/zeroFunctionFile.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/test_paths.gcno",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/binary-formats.macho32l",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/binary-formats.v2.linux32l",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/binary-formats.macho64l",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/elf_binary_comdat.profdata",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/report.profdata",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/test_exit_block_arcs.gcno",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/test_file_checksum_fail.gcda",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/test_read_fail.gcno",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/highlightedRanges.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/native_separators.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/test_exit_block_arcs.gcda",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/templateInstantiations.profdata",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/copy_block_helper.gcda",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/test.gcda",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/lineExecutionCounts.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/ifdef.profdata",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/showTabsHTML.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/sources_specified/main.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/sources_specified/main.profdata",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/multiple_objects/use_2.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/multiple_objects/merged.profdata",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cov/Inputs/multiple_objects/use_1.covmapping",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cxxdump/Inputs/trivial.obj.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cxxdump/Inputs/trivial.obj.elf-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cxxdump/Inputs/mixed-archive.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cxxdump/Inputs/eh.obj.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-profdata/Inputs/weight-instr-foo.profdata",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-profdata/Inputs/text-format-errors.text.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-profdata/Inputs/c-general.profraw",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-profdata/Inputs/gcc-sample-profile.gcov",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-profdata/Inputs/weight-instr-bar.profdata",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-profdata/Inputs/compressed.profraw",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-profdata/Inputs/compat.profdata.v4",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-profdata/Inputs/compat.profdata.v2",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-profdata/Inputs/compat.profdata.v1",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/invalid_string_form.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/empty_compressed_section.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/non_cu_top_level.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/invalid_compressed.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/multiple_type_sections.dwp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/compress/a.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/duplicate/bc.dwp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/duplicate/ac.dwp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/duplicate/c.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/type_dedup/b.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/type_dedup/a.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/missing_tu_index/x.dwp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/gcc_type/a.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/duplicate_dwo_name/bc.dwp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/duplicate_dwo_name/ac.dwp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/duplicate_dwo_name/c.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/invalid_cu_index/x.dwp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/compressfail/compress.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/compressfail/a.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/dwos_list_from_exec/d.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/dwos_list_from_exec/b.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/dwos_list_from_exec/a.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/dwos_list_from_exec/c.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/dwos_list_from_exec/e.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/simple/notypes/b.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/simple/notypes/a.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/simple/types/b.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/simple/types/a.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/merge/notypes/ab.dwp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwp/Inputs/merge/notypes/c.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objcopy/Inputs/pt-phdr.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objcopy/Inputs/dynrel.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objcopy/Inputs/dwarf.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/absolute_sym.macho.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/thumb.armv7m",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/basic.macho.x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/swift-dwarf-loc.macho.x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/common.macho.x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/swift-ast.macho.x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/fat-test.arm.dylib",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/basic-lto-dw4.macho.x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/basic-lto.macho.x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/basic-with-libfat-test.macho.x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/basic.macho.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/libfat-test.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/libbasic.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/fat-test.dylib",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/basic-archive.macho.x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/submodules/Parent.pcm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/modules-empty/Empty.pcm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/mismatch/mismatch.pcm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/module-warnings/libstatic.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/module-warnings/Bar.pcm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/module-warnings/Foo.pcm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/modules/Bar.pcm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/dsymutil/Inputs/modules/Foo.pcm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cvtres/Inputs/cursor_small.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cvtres/Inputs/test_resource.obj.coff.x64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cvtres/Inputs/test_resource.res",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cvtres/Inputs/combined.obj.coff",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cvtres/Inputs/okay_small.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cvtres/Inputs/test_resource.obj.coff.arm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cvtres/Inputs/languages.res",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-cvtres/Inputs/test_resource.obj.coff",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-xray/X86/Inputs/fdr-log-version-1.xray",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-xray/X86/Inputs/naive-log-simple.xray",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-xray/X86/Inputs/elf64-sample-o2.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-xray/X86/Inputs/elf32-noxray.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-xray/X86/Inputs/naive-with-arg1-entries.xray",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-xray/X86/Inputs/elf64-noinstr-map.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-xray/X86/Inputs/elf64-example.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-xray/X86/Inputs/elf64-objcopied-instrmap.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-xray/X86/Inputs/elf64-badentrysizes.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-xray/X86/Inputs/fdr-log-arg1.xray",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/ARM/Inputs/hello.obj.macho-arm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/ARM/Inputs/thumb.armv7m",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/ARM/Inputs/hello.exe.macho-arm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/ARM/Inputs/mh_dylib_header.macho-arm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/ARM/Inputs/data-in-code.macho-arm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/ARM/Inputs/divs.macho-armv7s",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/ARM/Inputs/reloc-half.obj.macho-arm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/AArch64/Inputs/print-armv8crypto.obj.macho-aarch64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/AArch64/Inputs/ObjC.exe.macho-aarch64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/AArch64/Inputs/hello.exe.macho-aarch64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/AArch64/Inputs/reloc-addend.obj.macho-aarch64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/AArch64/Inputs/thread.macho-aarch64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/AArch64/Inputs/kextbundle.macho-aarch64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/AArch64/Inputs/ObjC.obj.macho-aarch64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/AArch64/Inputs/print-mrs.obj.macho-aarch64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/AArch64/Inputs/fat.macho-armv7s-arm64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/AArch64/Inputs/hello.obj.macho-aarch64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/AArch64/Inputs/link-opt-hints.macho-aarch64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/phdrs.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/Objc2.64bit.exe.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/hello.exe.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/dylibRoutines.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/codesig.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/linkerOption.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/disassemble.dll.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/stub-nosyms.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/Objc2.64bit.obj.dylib-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/truncated-section.dylib.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/Objc1.32bit.obj.macho-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/note.macho-x86",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/Objc1.32bit.exe.macho-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/Objc2.64bit.obj.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/stubbed.dylib.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/dylibLoadKinds.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/macho-universal-archive.x86_64.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/ObjC.exe.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/debug-info-fileinfo.exe.elf-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/dylibSubUmbrella.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/out-of-section-sym.elf-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/dylibSubClient.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/dylibSubFramework.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/trivial.obj.elf-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/disassemble-data.obj",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/macho-universal.x86_64.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/hello_cpp.exe.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/macho-universal64.x86_64.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/thread.macho-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/internal.exe.coff-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/hello.exe.macho-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/Objc2.32bit.exe.macho-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/dylibSubLibrary.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/Objc2.32bit.obj.macho-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/dylibModInit.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/hello.obj.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/exeThread.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/phdr-note.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/openbsd-phdrs.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/hello.exe.stripped.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/hello.obj.macho-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/nofirst-symbol.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/kextbundle.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/ObjC.obj.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/malformed-machos/mem-crup-0337.macho",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/malformed-machos/mem-crup-0261.macho",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/malformed-machos/mem-crup-0040.macho",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/malformed-machos/mem-crup-0006.macho",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/malformed-machos/mem-crup-0010.macho",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/malformed-machos/mem-crup-0001.macho",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/malformed-machos/mem-crup-0080.macho",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/X86/Inputs/malformed-machos/00000031.a",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/compact-unwind.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/empty.macho-armv7",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/bind.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/nop.exe.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/unwind-info.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/rebase.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/trivial.obj.wasm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/exports-trie.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/lazy-bind.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/eh_frame.macho-arm64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/bind2.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/win64-unwind.exe.coff-x86_64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/library.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/unwind-info.macho-arm64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/corrupt-section.wasm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/compact-unwind.macho-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/malformed-macho.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/weak-bind.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/eh_frame.elf-mipsel",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/section.macho-armv7",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/export.dll.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/bad-ordinal.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/unwind-info-no-relocs.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/large-bss.obj.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/malformed-unwind.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/file.obj.coff-arm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/LLVM-bundle.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/many-relocs.obj-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/section-filter.obj",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-objdump/Inputs/tls.exe.coff-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/gold/X86/Inputs/drop-debug.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/gold/X86/Inputs/invalid.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/symbols-proc-specific.elf-hexagon",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/multifile-linetables.obj.coff-2012-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/codeview-cycle.obj",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.obj.macho-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/compression.zlib.style.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/codeview-merging-2.obj",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/relocs.obj.elf-ppc64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/magic.coff-unknown",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/relocs.obj.coff-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/relocs.obj.elf-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/verdef.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.obj.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/needed-libs.obj.coff-am64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/multifunction-linetables.obj.coff-2013-i368",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/verneed.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/multifunction-linetables.obj.coff-2013-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/const-import.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/gnuhash.so.elf-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/got-static.exe.mips",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.obj.elf-mipsel",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/dtflags.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/relocs.obj.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/macho-universal-archive.x86_64.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/dynamic-table-exe.x86",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/gnuhash.so.elf-ppc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.obj.macho-ppc64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/basereloc.obj.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.obj.elf-amdhsa-gfx803",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/relocs.obj.elf-arm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/codeview-merging-anon.obj",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/relocs.obj.macho-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/got-over.exe.elf-mips",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.obj.coff-arm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.obj.macho-arm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/relocs.obj.elf-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/gnuhash.so.elf-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/abiflags.obj.elf-mips",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/relocs.obj.elf-mips",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/multifunction-linetables.obj.coff-2012-i368",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/magic.coff-importlib",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/dynamic-table-so.aarch64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/reginfo.obj.elf-mipsel",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/bigobj.coff-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/mips-rld-map-rel.elf-mipsel",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.obj.wasm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.obj.elf-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/phdrs-elf.exe-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/dynamic-table-so.mips",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/dynamic-table-exe.mips",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/cxx-cli-aux.obj.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/codeview-vftable.obj.coff",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/codeview-types.obj",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/codeview-label.obj",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.obj.coff-arm64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/comdat-function-linetables.obj.coff-2013-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/mips-options.elf-mips64el",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/macho-universal.x86_64.i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/codeview-unsorted.obj",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/got-plt.exe.elf-mipsel",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/gnuhash.so.elf-ppc64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/zero-string-table.obj.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.obj.coff-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/got-empty.exe.mipsel",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/nop.exe.coff-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.obj.macho-ppc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/options.obj.elf-mipsel",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/relocs.obj.elf-aarch64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/rpath.exe.elf-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.obj.elf-lanai",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/library.lib",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/multifile-linetables.obj.coff-2013-i368",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/phdrs-elf.exe-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/relocs.obj.elf-mips64el",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.obj.macho-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/multifile-linetables.obj.coff-2013-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.obj.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/got-tls.so.elf-mips64el",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/codeview-inlinees.obj",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/relocs.obj.elf-lanai",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/comdat-function-linetables.obj.coff-2012-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/relocs-no-symtab.obj.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/directives.obj.coff-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/imports.exe.coff-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/relocs.obj.macho-arm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/relocs.obj.macho-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/abiflags.obj.elf-mipsel",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/elf-groups.x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/bad-relocs.obj.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/st-other.obj.elf-mips16",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/multifunction-linetables.obj.coff-2012-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/multifile-linetables.obj.coff-2012-i368",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/codeview-merging-1.obj",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/dynamic-table-so.x86",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.exe.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/imports.exe.coff-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/codeview-inlining.obj.coff",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/trivial.exe.coff-arm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/resources/cursor_small.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/resources/test_resource.res",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/resources/okay_small.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-readobj/Inputs/resources/test_resource.obj.coff",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-symbolizer/pdb/Inputs/test.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-dwarfdump/X86/Inputs/empty.dSYM",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-lib/Inputs/cl-gl.obj",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/tools/llvm-lib/Inputs/resource.res",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Other/Inputs/has-block-info.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Other/Inputs/no-block-info.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Other/Inputs/block-info-only.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/upgrade-importedentity.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/DIExpression-deref.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/DIGlobalVariableExpression.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/weak-cmpxchg-upgrade.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/bitwiseInstructions.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/DISubprogram-distinct-definitions.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/upgrade-global-ctors.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/variableArgumentIntrinsic.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/auto_upgrade_intrinsics.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/vectorInstructions.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/local-linkage-default-visibility.3.4.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/attributes-3.3.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/standardCIntrinsic.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/upgrade-subprogram.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/dityperefs-3.8.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/linkage-types-3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/DILocalVariable-explicit-tags.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/cmpxchg-upgrade.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/diglobalvariable-3.8.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/DIExpression-aggresult.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/thinlto-summary-local-5.0.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/cmpxchg.3.6.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/upgrade-subprogram-this.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/upgrade-dbg-value.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/compatibility-3.9.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/compatibility-4.0.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/DICompileUnit-no-DWOId.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/atomic-no-syncscope.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/DINamespace.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/calling-conventions.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/null-type.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/memInstructions.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/DIGlobalVariableExpression2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/avr-calling-conventions.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/aggregateInstructions.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/global-variables.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/constantsTest.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/miscInstructions.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/old-aliases.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/pr18704.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/upgrade-debug-info-for-profiling.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/compatibility-3.7.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/metadata.3.5.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/DIExpression-minus-upgrade.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/visibility-styles.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/compatibility-5.0.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/dilocalvariable-3.9.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/DIExpression-4.0.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/upgrade-pointer-address-space.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/drop-debug-info.3.5.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/compatibility-3.8.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/weak-macho-3.5.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/case-ranges-3.3.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/invalid.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/function-local-metadata.3.5.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/conversionInstructions.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/compatibility-3.6.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/binaryFloatInstructions.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/terminatorInstructions.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/binaryIntInstructions.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/upgrade-loop-metadata.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/highLevelStructure.3.2.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-type-table-forward-ref.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-bad-abbrev-number.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-GCTable-overflow.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-unexpected-eof.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-align.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-non-vector-extractelement.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-function-argument-type.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/source-filename.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-abbrev-vbr-size-too-big.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-abbrev-fixed-size-too-big.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-vector-length.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-vector-element-type.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-no-function-block.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/thinlto-function-summary-callgraph-combined.1.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-extractval-struct-idx.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-too-big-fwdref.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-insertval-too-many-idxs.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-nonpointer-storeatomic.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/PR23310.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-inserted-value-type-mismatch.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-extractval-too-many-idxs.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-invoke-non-function-explicit-type.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-array-operand-encoding.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-abbrev-no-operands.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-fwdref-type-mismatch.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/padding.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-function-comdat-id.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-insertval-array-idx.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-void-constant.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-call-mismatched-explicit-type.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-invoke-mismatched-explicit-type.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-load-ptr-type.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-nonpointer-atomicrmw.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/thinlto-function-summary-callgraph.1.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-cast.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-pointer-element-type.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-no-proper-module.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/padding-garbage.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-extract-0-indices.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-call-non-function-explicit-type.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-alias-type-mismatch.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-gep-no-operands.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-abbrev.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-global-var-comdat-id.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-extractval-array-idx.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-insertval-struct-idx.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-code-len-width.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-name-with-0-byte.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-fwdref-type-mismatch-2.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-bitwidth.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-array-type.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-non-vector-shufflevector.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-metadata-not-followed-named-node.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-gep-operator-mismatched-explicit-type.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-fp-shift.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-non-vector-insertelement.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-gep-mismatched-explicit-type.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-insert-0-indices.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/thinlto-function-summary-callgraph-pgo-combined.1.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-array-op-not-2nd-to-last.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/thinlto-function-summary-callgraph-pgo.1.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-load-mismatched-explicit-type.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-pr20485.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-load-pointer-type.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bitcode/Inputs/invalid-array-element-type.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/PDB/Inputs/empty.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/PDB/Inputs/symbolformat.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/PDB/Inputs/every-type.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/PDB/Inputs/big-read.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/PDB/Inputs/pdbdump-globals-empty.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/split-dwarf-test.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-test-zlibgnu.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-ranges-baseaddr-exe.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-decompression-error.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-type-units.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/arm-relocs.elf-arm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/fission-ranges.elf-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/invalid.elf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-test4.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/llvm-symbolizer-test.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-test.elf-x86-64.debuglink",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/split-dwarf-multiple-cu.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-test-zlib.o.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/split-dwarf-addr-object-relocation.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/invalid.elf.3",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/typeunit-header.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-inl-test.high_pc.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-test3.elf-x86-64-space",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/invalid.elf.2",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-test.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-gdbindex-v7.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/split-dwarf-dwp.o.dwp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/split-dwarf-empty.dwo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/arange-overlap.elf-x86_64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump.elf-mips64-64-bit-dwarf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-pubnames.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-test2.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-inl-test.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-test-zlib.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/dwarfdump-decompression-corrupt.elf-x86-64",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/DebugInfo/Inputs/shared-object-stripped.elf-i386",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/test/Bindings/llvm-c/Inputs/invalid.ll.bc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/cmake/nsis_logo.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/cmake/nsis_icon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/MCJIT-load.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/ARM-BE-bitcastfail.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/MCJIT-dyld-load.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/MCJIT-engine-builder.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/MCJIT-creation.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/MCJIT-load-object.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/MCJIT-resolve-relocations.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/ARM-BE-ld1.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/gcc-loops.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/ARM-BE-bitcastsuccess.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/linpack-pc.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/ARM-BE-ldr.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/tutorial/LangImpl05-cfg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/_static/lines.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/_themes/llvm-theme/static/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/_themes/llvm-theme/static/contents.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/llvm/docs/_themes/llvm-theme/static/navigation.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Prototypes/DefaultInterfaceImplementation/System.Memory.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Prototypes/DefaultInterfaceImplementation/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Prototypes/DefaultInterfaceImplementation/System.Runtime.CompilerServices.Unsafe.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Prototypes/DefaultInterfaceImplementation/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Prototypes/DefaultInterfaceImplementation/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Prototypes/DefaultInterfaceImplementation/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Prototypes/DefaultInterfaceImplementation/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.2/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.2/tools/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.2/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.2/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.2/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.2/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.2/tools/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.2/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.2/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.2/tools/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.2/tools/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.2/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/System.Memory.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/System.Buffers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/System.Numerics.Vectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/System.Text.Encoding.CodePages.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/System.Runtime.CompilerServices.Unsafe.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/System.Threading.Tasks.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/Microsoft.DiaSymReader.Native.x86.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/Microsoft.DiaSymReader.Native.amd64.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.1/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/Microsoft.Net.Compilers.1.3.2.nupkg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/System.Diagnostics.StackTrace.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/System.AppContext.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/System.IO.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.DiaSymReader.Native.x86.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.DiaSymReader.Native.amd64.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/System.IO.FileSystem.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/System.Memory.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/System.Buffers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/System.Numerics.Vectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/System.Text.Encoding.CodePages.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/System.Runtime.CompilerServices.Unsafe.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/System.Threading.Tasks.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/Microsoft.DiaSymReader.Native.x86.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/Microsoft.DiaSymReader.Native.amd64.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.7.0/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.7.0/tools/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.7.0/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.7.0/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.7.0/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.7.0/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.7.0/tools/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.7.0/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.7.0/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.7.0/tools/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.7.0/tools/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.7.0/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.9.0/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.9.0/tools/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.9.0/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.9.0/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.9.0/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.9.0/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.9.0/tools/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.9.0/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.9.0/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.9.0/tools/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.9.0/tools/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.9.0/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/System.Memory.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/System.Buffers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/System.Numerics.Vectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/System.Text.Encoding.CodePages.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/System.Runtime.CompilerServices.Unsafe.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/System.Threading.Tasks.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/Microsoft.DiaSymReader.Native.x86.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/Microsoft.DiaSymReader.Native.amd64.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.3.0/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/System.Memory.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/System.Buffers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/System.Numerics.Vectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/System.Text.Encoding.CodePages.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/System.Runtime.CompilerServices.Unsafe.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/System.Threading.Tasks.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/Microsoft.DiaSymReader.Native.x86.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/Microsoft.DiaSymReader.Native.amd64.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.4.0/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.0/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.0/tools/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.0/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.0/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.0/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.0/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.0/tools/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.0/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.0/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.0/tools/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.0/tools/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.8.0/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/System.Memory.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/System.Buffers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/System.Numerics.Vectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/System.Text.Encoding.CodePages.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/Roslyn.Compilers.Extension.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/System.Runtime.CompilerServices.Unsafe.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/System.Threading.Tasks.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/Microsoft.DiaSymReader.Native.x86.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/Microsoft.DiaSymReader.Native.amd64.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/3.1.0/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/ValueTuple/bin/Xamarin.Android/ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/ValueTuple/bin/Xamarin.iOS/ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/ValueTuple/bin/Net45/ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/roslyn-binaries/ValueTuple/bin/Xamarin.Mac/ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil-legacy/mono.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil-legacy/symbols/pdb/Test/Resources/assemblies/test.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil-legacy/symbols/pdb/Test/Resources/assemblies/VBConsApp.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil-legacy/symbols/pdb/Test/Resources/assemblies/fsapp.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil-legacy/symbols/pdb/Microsoft.Cci.Pdb/IntHashTable.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil-legacy/symbols/pdb/Mono.Cecil.Pdb/AssemblyInfo.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil-legacy/symbols/mdb/Test/Resources/assemblies/hello.exe.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil-legacy/symbols/mdb/Mono.Cecil.Mdb/AssemblyInfo.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil-legacy/Test/libs/nunit-2.6.2/license.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil-legacy/Test/Resources/assemblies/moda.netmodule",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil-legacy/Test/Resources/assemblies/modb.netmodule",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/nuget-buildtasks/build/PublicKey.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/cecil.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/AVbTest.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/empty-iterator.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/EmptyRootNamespace.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/test.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/CecilTest.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/VBConsApp.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/fsapp.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/ComplexPdb.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/PdbTarget.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/symbols/pdb/Microsoft.Cci.Pdb/IntHashTable.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/symbols/mdb/Test/Resources/assemblies/mscorlib.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/symbols/mdb/Test/Resources/assemblies/BreakpointTest.Portable.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/symbols/mdb/Test/Resources/assemblies/simplemdb.exe.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/moda.netmodule",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/ExternalPdbDeterministic.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/xattr.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/TargetLib.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/embedcs.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/SQLite-net.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/libmdb.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/ManagedWinmd.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/mylib.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/cecil.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/line.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/Mono.Android.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/winrtcomp.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/modb.netmodule",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/EmptyPdb.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/PdbTarget.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/libpdb.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/mdb-mismatch.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/pdb-mismatch.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/cecil/Test/Resources/assemblies/NativeWinmd.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/nunit-lite/NUnitLite-1.0.0/.DS_Store",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/nunit-lite/NUnitLite-1.0.0/src/.DS_Store",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/nunit-lite/NUnitLite-1.0.0/src/framework/nunit.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/cecil.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/symbols/pdb/Test/Resources/assemblies/AVbTest.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/symbols/pdb/Test/Resources/assemblies/empty-iterator.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/symbols/pdb/Test/Resources/assemblies/EmptyRootNamespace.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/symbols/pdb/Test/Resources/assemblies/test.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/symbols/pdb/Test/Resources/assemblies/CecilTest.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/symbols/pdb/Test/Resources/assemblies/VBConsApp.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/symbols/pdb/Test/Resources/assemblies/fsapp.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/symbols/pdb/Test/Resources/assemblies/ComplexPdb.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/symbols/pdb/Test/Resources/assemblies/PdbTarget.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/symbols/pdb/Microsoft.Cci.Pdb/IntHashTable.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/symbols/mdb/Test/Resources/assemblies/mscorlib.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/symbols/mdb/Test/Resources/assemblies/BreakpointTest.Portable.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/symbols/mdb/Test/Resources/assemblies/simplemdb.exe.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/moda.netmodule",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/ExternalPdbDeterministic.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/xattr.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/TargetLib.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/embedcs.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/SQLite-net.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/libmdb.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/ManagedWinmd.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/mylib.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/cecil.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/line.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/Mono.Android.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/winrtcomp.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/modb.netmodule",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/EmptyPdb.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/PdbTarget.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/libpdb.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/mdb-mismatch.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/pdb-mismatch.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/linker/external/cecil/Test/Resources/assemblies/NativeWinmd.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/helix-binaries/Microsoft.DotNet.Helix.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/helix-binaries/System.Spatial.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/helix-binaries/Microsoft.Rest.ClientRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/helix-binaries/Microsoft.Data.Edm.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/helix-binaries/Microsoft.Data.OData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/helix-binaries/Microsoft.WindowsAzure.Storage.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/helix-binaries/Newtonsoft.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/helix-binaries/Microsoft.DotNet.Helix.JobSender.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.0/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monotouch/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monotouch/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monotouch/Xamarin.WatchOS.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monotouch/OpenTK.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monotouch/Xamarin.iOS.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monotouch/xi.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monotouch/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monotouch/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monotouch/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monotouch/Xamarin.Mac.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monotouch/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monotouch/OpenTK-1.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monotouch/Xamarin.TVOS.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monodroid/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monodroid/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monodroid/Mono.Android.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monodroid/xa.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monodroid/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monodroid/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monodroid/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/build/monodroid/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Workflow.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Workflow.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Reflection.Context.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Workflow.Activities.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Deployment.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.Mobile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Drawing.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ComponentModel.TypeConverter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Globalization.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.UnmanagedMemoryStream.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.Cryptography.X509Certificates.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.Sockets.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.Compression.ZipFile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.TraceSource.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Console.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ComponentModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/Microsoft.Win32.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Xml.XPath.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Resources.Reader.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.FileSystem.Watcher.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.FileVersionInfo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Threading.Timer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Collections.Specialized.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.WebHeaderCollection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.Process.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Xml.XmlDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.FileSystem.DriveInfo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.Handles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Globalization.Calendars.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.Claims.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.Serialization.Formatters.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.TextWriterTraceListener.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.WebSockets.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.IsolatedStorage.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.MemoryMappedFiles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.Pipes.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.WebSockets.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.NameResolution.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Xml.XPath.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.StackTrace.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Threading.ThreadPool.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.Cryptography.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.AppContext.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.Cryptography.Csp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Threading.Thread.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Threading.Overlapped.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Data.Common.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.Ping.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/netstandard.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.Cryptography.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.Http.Rtc.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.CompilerServices.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Resources.Writer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.InteropServices.RuntimeInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.FileSystem.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.Cryptography.Algorithms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.SecureString.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Collections.NonGeneric.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/I18N.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/I18N.Other.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Experimental.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/cscompmgd.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/RabbitMQ.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Web.WebPages.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Web.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.Posix.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Commons.Xml.Relaxng.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/ICSharpCode.SharpZipLib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Numerics.Vectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.Debugger.Soft.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Web.Http.SelfHost.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Web.Http.WebHost.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.Messaging.RabbitMQ.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/IBM.Data.DB2.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Microsoft.Web.Infrastructure.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/SMDiagnostics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/I18N.West.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Threading.Tasks.Dataflow.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/PEAPI.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.Simd.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.Cairo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.CompilerServices.SymbolWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.Security.Win32.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.WebBrowser.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/I18N.Rare.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Json.Microsoft.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Web.WebPages.Deployment.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Windows.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Observable.Aliases.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/WebMatrix.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Debugger.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.C5.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/I18N.MidEast.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Net.Http.Formatting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.CodeContracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Web.WebPages.Razor.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.Data.Sqlite.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.Tasklets.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/I18N.CJK.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Web.Mvc.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.Data.Tds.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.Options.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Novell.Directory.Ldap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Web.Razor.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Reactive.PlatformServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/Mono.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Providers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Interfaces.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Workflow.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.ServiceModel.Internals.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Workflow.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Reflection.Context.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Workflow.Activities.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Runtime.InteropServices.RuntimeInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Deployment.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.Mobile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Threading.Timer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Net.WebHeaderCollection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.Handles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.ServiceModel.Internals.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.ServiceModel.Internals.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.ServiceModel.Internals.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Workflow.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Workflow.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Reflection.Context.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Workflow.Activities.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Web.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Deployment.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Web.Mobile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Drawing.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.ComponentModel.TypeConverter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Globalization.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.IO.UnmanagedMemoryStream.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Security.Cryptography.X509Certificates.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Net.Sockets.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.IO.Compression.ZipFile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Diagnostics.TraceSource.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Console.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.ComponentModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/Microsoft.Win32.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Xml.XPath.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Resources.Reader.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.IO.FileSystem.Watcher.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Diagnostics.FileVersionInfo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Threading.Timer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Collections.Specialized.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Net.WebHeaderCollection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Diagnostics.Process.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Xml.XmlDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.IO.FileSystem.DriveInfo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Net.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Runtime.Handles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Globalization.Calendars.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Security.Claims.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Runtime.Serialization.Formatters.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Diagnostics.TextWriterTraceListener.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Net.WebSockets.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.IO.IsolatedStorage.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.IO.MemoryMappedFiles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.IO.Pipes.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Net.WebSockets.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Net.NameResolution.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Xml.XPath.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Diagnostics.StackTrace.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Threading.ThreadPool.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Security.Cryptography.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.AppContext.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Security.Cryptography.Csp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.IO.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Threading.Thread.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Threading.Overlapped.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Data.Common.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Net.Ping.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/netstandard.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Security.Cryptography.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Net.Http.Rtc.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Runtime.CompilerServices.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Resources.Writer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Runtime.InteropServices.RuntimeInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.IO.FileSystem.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Security.Cryptography.Algorithms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Security.SecureString.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Collections.NonGeneric.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7.2/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Workflow.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Workflow.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Reflection.Context.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Workflow.Activities.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Web.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Deployment.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Web.Mobile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Drawing.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.ComponentModel.TypeConverter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Globalization.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.IO.UnmanagedMemoryStream.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Security.Cryptography.X509Certificates.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Net.Sockets.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.IO.Compression.ZipFile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Diagnostics.TraceSource.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Console.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.ComponentModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/Microsoft.Win32.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Xml.XPath.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Resources.Reader.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.IO.FileSystem.Watcher.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Diagnostics.FileVersionInfo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Threading.Timer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Collections.Specialized.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Net.WebHeaderCollection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Diagnostics.Process.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Xml.XmlDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.IO.FileSystem.DriveInfo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Net.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Runtime.Handles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Globalization.Calendars.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Security.Claims.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Runtime.Serialization.Formatters.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Diagnostics.TextWriterTraceListener.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Net.WebSockets.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.IO.IsolatedStorage.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.IO.MemoryMappedFiles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.IO.Pipes.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Net.WebSockets.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Net.NameResolution.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Xml.XPath.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Diagnostics.StackTrace.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Threading.ThreadPool.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Security.Cryptography.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.AppContext.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Security.Cryptography.Csp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.IO.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Threading.Thread.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Threading.Overlapped.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Data.Common.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Net.Ping.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/netstandard.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Security.Cryptography.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Net.Http.Rtc.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Runtime.CompilerServices.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Resources.Writer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Runtime.InteropServices.RuntimeInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.IO.FileSystem.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Security.Cryptography.Algorithms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Security.SecureString.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Collections.NonGeneric.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.8/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Workflow.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.ServiceModel.Internals.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Workflow.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Reflection.Context.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Workflow.Activities.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Web.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Runtime.InteropServices.RuntimeInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Deployment.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Web.Mobile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Threading.Timer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Net.WebHeaderCollection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.Handles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Workflow.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.ServiceModel.Internals.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Workflow.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Reflection.Context.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Workflow.Activities.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Web.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Runtime.InteropServices.RuntimeInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Deployment.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Web.Mobile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Threading.Timer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Net.WebHeaderCollection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.Handles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Workflow.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.ServiceModel.Internals.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Workflow.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Reflection.Context.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Workflow.Activities.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Runtime.InteropServices.RuntimeInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Deployment.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.Mobile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Threading.Timer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Net.WebHeaderCollection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.Handles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v3.5/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v3.5/Microsoft.Build.Utilities.v3.5.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v3.5/Microsoft.Build.Tasks.v3.5.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v3.5/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/Microsoft.Build.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/Microsoft.Build.Utilities.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/binary-reference-assemblies/v2.0/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corert/src/System.Private.TypeLoader/src/Internal/Runtime/TypeLoader/ReferenceSource/callhelpers.h",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corert/src/ILVerification/StrongNameKeys/ILVerify.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/corert/Documentation/images/typesystem-hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Ix/NET/35MSSharedLib1024.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Test/Rx/WindowsStoreApp8_NuGet/WindowsStoreApp8_NuGet_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Test/Rx/WindowsStoreApp8_NuGet/Assets/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Test/Rx/WindowsStoreApp8_NuGet/Assets/SplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Test/Rx/WindowsStoreApp8_NuGet/Assets/SmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Test/Rx/WindowsStoreApp8_NuGet/Assets/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Test/Rx/WpfXbapApp45_NuGet/WpfXbapApp45_NuGet_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Resources/Artwork/Logo_Color.design",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Resources/Artwork/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Resources/Artwork/Logo_Color.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Resources/Artwork/Logo_Color_300x300.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Resources/Artwork/Logo_Color_2010x2000.psd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Resources/Artwork/Logo_Zip.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Resources/Artwork/Logo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Samples/HOL/Rx HOL .NET C#.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Samples/HOL/Rx HOL .NET VB.docx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Samples/HOL/Rx HOL .NET C#.docx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Samples/HOL/Rx HOL JavaScript.docx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/35MSSharedLib1024.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/reactive.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/android/ReactiveTestApplication/Resources/drawable/Icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/android/samples/GithubApiClientSample/Resources/drawable-ldpi/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/android/samples/GithubApiClientSample/Resources/drawable-mdpi/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/android/samples/GithubApiClientSample/Resources/drawable-hdpi/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/android/samples/GithubApiClientSample/Resources/drawable-xhdpi/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/android/samples/GithubApiClientSample/Resources/drawable-xxhdpi/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/android/samples/ReactiveAndroidSample/ReactiveAndroidSample/Resources/drawable/Icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/iOS/libs/System.Reactive.Experimental.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/iOS/libs/System.Reactive.Linq.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/iOS/libs/System.Reactive.Core.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/iOS/libs/System.Reactive.Debugger.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/iOS/libs/System.Reactive.Interfaces.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/iOS/libs/System.Reactive.PlatformServices.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/packages/Microsoft.Bcl.Build.1.0.4/Microsoft.Bcl.Build.1.0.4.nupkg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/packages/Microsoft.Bcl.Build.1.0.10/Microsoft.Bcl.Build.1.0.10.nupkg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/packages/Microsoft.Bcl.Async.1.0.16/Microsoft.Bcl.Async.1.0.16.nupkg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/Rx/NET/Source/packages/Microsoft.Bcl.1.0.19/Microsoft.Bcl.1.0.19.nupkg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/xpkg/RxForXamarin_128x128.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/xpkg/ProjectReferences.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/rx/component/rx_128x128.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/bunny_pancake.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/Newtonsoft.Json.Tests.Metro_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/TestObjects/Store.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/Properties/AssemblyInfo.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/Images/UnitTestLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/Images/UnitTestSmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/Images/UnitTestSplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/Images/UnitTestStoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json/Dynamic.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json/Properties/AssemblyInfo.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json/Utilities/CollectionUtils.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Tools/NUnit/lib/failure.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Tools/NUnit/lib/skipped.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Tools/NUnit/lib/inconclusive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Tools/NUnit/lib/ignored.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Tools/NUnit/lib/success.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Tools/7-zip/7-zip.chm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Doc/donate.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/Newtonsoft.Json/Doc/ReducingSerializedJSONSize.html",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/aspnetwebstack/src/System.Web.WebPages.Administration/images/package.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/aspnetwebstack/src/System.Web.WebPages.Administration/images/error.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/aspnetwebstack/src/System.Web.WebPages.Administration/images/aspLogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/aspnetwebstack/src/System.Web.WebPages.Administration/images/ok.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/aspnetwebstack/src/System.Web.WebPages.Administration/images/tabon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/aspnetwebstack/src/System.Web.WebPages.Administration/packages/images/package.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/aspnetwebstack/src/System.Web.WebPages.Administration/packages/images/error.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/aspnetwebstack/test/System.Web.Helpers.Test/TestFiles/logo.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/aspnetwebstack/test/System.Web.Helpers.Test/TestFiles/LambdaFinal.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/aspnetwebstack/test/System.Web.Helpers.Test/TestFiles/NETLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/aspnetwebstack/test/System.Web.Helpers.Test/TestFiles/HiRes.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/aspnetwebstack/tools/35MSSharedLib1024.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Newtonsoft/bin/Release/netstandard2.0/dist/_framework/wasm/mono.wasm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Newtonsoft/wwwroot/css/open-iconic/font/fonts/open-iconic.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Newtonsoft/wwwroot/css/open-iconic/font/fonts/open-iconic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Newtonsoft/wwwroot/css/open-iconic/font/fonts/open-iconic.otf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Newtonsoft/wwwroot/css/open-iconic/font/fonts/open-iconic.eot",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/HelloWorld/bin/Release/netstandard2.0/dist/_framework/wasm/mono.wasm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/HelloWorld/wwwroot/css/open-iconic/font/fonts/open-iconic.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/HelloWorld/wwwroot/css/open-iconic/font/fonts/open-iconic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/HelloWorld/wwwroot/css/open-iconic/font/fonts/open-iconic.otf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/HelloWorld/wwwroot/css/open-iconic/font/fonts/open-iconic.eot",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/bin/Release/netstandard2.0/dist/_framework/wasm/mono.wasm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/img/pizzas/mushroom.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/img/pizzas/pepperoni.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/img/pizzas/brit.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/img/pizzas/bacon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/img/pizzas/meaty.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/img/pizzas/salad.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/img/pizzas/margherita.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/img/pizzas/cheese.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/css/font/quicksand-v8-latin-700.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/css/font/quicksand-v8-latin-700.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/css/font/quicksand-v8-latin-regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/css/font/quicksand-v8-latin-500.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/css/font/quicksand-v8-latin-300.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/css/font/quicksand-v8-latin-300.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/css/font/quicksand-v8-latin-regular.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/BlazingPizza.Client/wwwroot/css/font/quicksand-v8-latin-500.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Debug/netstandard2.0/Microsoft.AspNetCore.Blazor.E2EPerformance.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Debug/netstandard2.0/Microsoft.AspNetCore.Components.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Debug/netstandard2.0/Microsoft.AspNetCore.Blazor.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Debug/netstandard2.0/Microsoft.AspNetCore.Components.Browser.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Debug/netstandard2.0/Microsoft.AspNetCore.Blazor.Build",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Debug/netstandard2.0/Microsoft.AspNetCore.Blazor.E2EPerformance.blazor.config",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Debug/netstandard2.0/dist/_framework/wasm/mono.wasm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Debug/netstandard2.0/dist/_framework/_bin/Microsoft.AspNetCore.Blazor.E2EPerformance.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Debug/netstandard2.0/dist/_framework/_bin/Microsoft.AspNetCore.Components.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Debug/netstandard2.0/dist/_framework/_bin/Microsoft.AspNetCore.Blazor.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Debug/netstandard2.0/dist/_framework/_bin/Microsoft.AspNetCore.Components.Browser.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Release/netstandard2.0/Microsoft.AspNetCore.Blazor.E2EPerformance.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Release/netstandard2.0/Microsoft.AspNetCore.Components.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Release/netstandard2.0/Microsoft.AspNetCore.Blazor.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Release/netstandard2.0/Microsoft.AspNetCore.Components.Browser.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Release/netstandard2.0/Microsoft.AspNetCore.Blazor.Build",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Release/netstandard2.0/Microsoft.AspNetCore.Blazor.E2EPerformance.blazor.config",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Release/netstandard2.0/dist/_framework/wasm/mono.wasm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Release/netstandard2.0/dist/_framework/_bin/Microsoft.AspNetCore.Blazor.E2EPerformance.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Release/netstandard2.0/dist/_framework/_bin/Microsoft.AspNetCore.Components.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Release/netstandard2.0/dist/_framework/_bin/Microsoft.AspNetCore.Blazor.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/external/illinker-test-assets/wasm/Microsoft.AspNetCore.Blazor.E2EPerformance/bin/Release/netstandard2.0/dist/_framework/_bin/Microsoft.AspNetCore.Components.Browser.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/MonoIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tests/InternalsVisibleTest2.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tests/test-715.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tests/key.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/errors/cs1577.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/errors/CS1616.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/errors/cs1548.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/errors/key.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/winfx.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/mono.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/mono.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/msfinal.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/reactive.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Open.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/winfx3.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/silverlight.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System/Test/compressed.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System/Test/System.Text.RegularExpressions/RegexMatchTests.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System/Test/TestData/testclienteku.contoso.com.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System/Test/TestData/testselfsignedservereku.contoso.com.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System/Test/TestData/testnoeku.contoso.com.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System/Test/TestData/testservereku.contoso.com.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System/resources/Asterisk.wav",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System/resources/Beep.wav",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System/resources/Exclamation.wav",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System/resources/Hand.wav",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System/resources/Question.wav",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Microsoft.Build.Tasks/Test/resources/binary/Testing.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Microsoft.Build.Tasks/Test/resources/binary/SimpleWrite.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Microsoft.Build.Tasks/Test/resources/binary/Testing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Microsoft.Build.Tasks/Test/resources/binary/FancyStuff.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Microsoft.Build.Tasks/Test/resources/binary/XbuildReferenceBugTest.exe.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Microsoft.Build.Tasks/Test/resources/binary/XbuildReferenceBugTest.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Microsoft.Build.Tasks/Test/resources/binary/SimpleWrite.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Microsoft.Build.Tasks/Test/resources/binary/XbuildReferenceBugTest2.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Microsoft.Build.Tasks/Test/resources/binary/FancyStuff.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Mono.Options/Documentation/en/examples/locale/es/LC_MESSAGES/localization.mo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Mono.Data.Sqlite/Test/test.db",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Mono.Data.Sqlite/resources/SQLiteConnection.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Mono.Data.Sqlite/resources/SQLiteCommand.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Mono.Data.Sqlite/resources/SQLiteDataAdapter.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Mono.Data.Sqlite/resources/SR.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.IdentityModel/Test/Resources/test.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.IdentityModel/Test/Resources/test_neg_serial.cer",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.IdentityModel/Test/Resources/test2.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.IdentityModel/Test/Resources/test.cer",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Data.Services.Client/Client/System/Data/Services/Client/DataServiceContext.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/System.Web.Security/SqliteMembershipProvider.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/System.Web.Security/SqliteRoleProvider.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/System.Web.Util/SerializationHelper.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/NunitWebResources/Bluehills.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableHeaderCell_TableHeaderCell_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_EditCommandColumn_EditCommandColumn_UpdateText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_ctor_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_MaxLength.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_Parent.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_Item_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_ProcessShutdownReason_ProcessShutdownReason_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_CssClass.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_DataTextFormatString.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_IsReadOnly.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_SelectedItem.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TableItemStyle_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_GetKey_I.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_HeaderTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DropDownList_DropDownList_SelectedIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_CellSpacing.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_DataTextField.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_BeginEventHandler_BeginEventHandler_ctor_OI.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Enabled.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlControl_HtmlControl_TagName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_ItemDataBound.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_Visible.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_FromString_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RepeatLayout_RepeatLayout_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Item_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DropDownList_DropDownList_BorderColor.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_FooterText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_Count.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_BackColor.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_SelectedIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_SeparatorTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_AlternatingItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ButtonColumn_ButtonColumn_InitializeCell_TIL.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_Pages_PageHyperLink.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputImage_HtmlInputImage_Src.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_HeaderStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_DataBind_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlGenericControl_HtmlGenericControl_TagName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_UnderLine.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_FooterStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_Items.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_RemoveAll_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_AccessKey.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Item_I.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_RemoveAll_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_UpdateCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_EditCommandColumn_EditCommandColumn_ButtonType.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_Count.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TableStyle_CellSpacing.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_Page.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_AllowSorting.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlTextArea_HtmlTextArea_Cols.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_PageCount.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_SelectedItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_Items.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_RemoveAt_I.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DayNameFormat_DayNameFormat_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_Pages_PageWControl2.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_PagerStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BoundColumn_BoundColumn_InitializeCell_TIL.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_BeginEventHandler_BeginEventHandler_BeginInvoke_OEAOAO.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_SortExpression.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RadioButtonList_RadioButtonList_TextAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Image_Image_AlternateText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_CancelCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_PageButtonCount.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_MergeStyle_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_IsReadOnly.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_EditItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_RemoveAt_I.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlTextArea_HtmlTextArea_Value.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TableItemStyle_VerticalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlAnchor_HtmlAnchor_Target.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Label_Label_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLinkColumn_HyperLinkColumn_Target.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_AutoPostBack.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_Clear_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_IsSynchronized.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_VerticalAlign_VerticalAlign_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Panel_Panel_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_EditCommandColumn_EditCommandColumn_InitializeCell_TIL.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_Init.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlAnchor_HtmlAnchor_Title.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_CopyTo_AI.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_CellPadding.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_Add_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_GetEnumerator_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_DataKeyField.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Keys.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_EditItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCell_TableCell_ColumnSpan.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_IsReadOnly2.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlControl_HtmlControl_Disabled.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRow_TableRow_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_SelectCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_IsSynchronized.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_NextPageText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_EditCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RadioButton_RadioButton_GroupName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_HeaderStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLink_HyperLink_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DropDownList_DropDownList_ToolTip.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_BeginEventHandler_BeginEventHandler_Invoke_OEAO.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCell_TableCell_Wrap.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_ClearSelection_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_ShowHeader.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_Load_wo_CodeBehind.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TemplateColumn_TemplateColumn_EditItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Table_Table_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_CellPadding.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_Reset_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ImageAlign_ImageAlign_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBox_CheckBox_AutoPostBack.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_DataMember.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLinkColumn_HyperLinkColumn_DataTextField.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataListItem_DataListItem_DataItem.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RepeaterItem_RepeaterItem_ItemType.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_SeparatorStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_UniqueID.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_ctor_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ValidationCompareOperator_ValidationCompareOperator_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_ApplyStyle_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Table_Table_GridLines.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_Items.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_Rows.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_Pages_PageWControl4.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_FontSize_FontSize_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BoundColumn_BoundColumn_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_AddAt_IT.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlTextArea_HtmlTextArea_ctor_2.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlGenericControl_HtmlGenericControl_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_ReadOnly.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Add_Nothing.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_Bold.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlControl_HtmlControl_Attributes.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Attributes.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_GridLines.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_RenderEndTag_H.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ImageButton_ImageButton_CausesValidation.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_CopyFrom_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_EditItemIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_CopyTo_AI.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBox_CheckBox_Enabled.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_CssClass.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_FooterStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlGenericControl_HtmlGenericControl_ctor_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Button_Button_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Contents.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ButtonColumn_ButtonColumn_ButtonType.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCell_TableCell_VerticalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListBox_ListBox_ToolTip.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCell_TableCell_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Add_SO.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_Attributes.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RadioButtonList_RadioButtonList_RepeatLayout.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_Clear_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_ToString_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_FooterTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Page_Page_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlContainerControl_HtmlContainerControl_InnerHtml.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_Item.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_Visible.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_IsCookieless.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextAlign_TextAlign_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RepeatDirection_RepeatDirection_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BoundColumn_BoundColumn_ReadOnly.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_Columns.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Timeout.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_BorderColor.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_BorderStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_ForeColor.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_BackImageUrl.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Clear_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_IsBindableType_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlTextArea_HtmlTextArea_Rows.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListBox_ListBox_BorderWidth.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_UnitType_UnitType_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_Wrap.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_ControlStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_Reset_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlTextArea_HtmlTextArea_Name.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_DataValueField.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_Item.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_CopyTo_AI.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_SelectedItem.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TableStyle_GridLines.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_GridLines_GridLines_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_HeaderStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_MergeWith_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_Items.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_VerticalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_UpdateCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Image_Image_Enabled.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_GridLines.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_RepeatColumns.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_MergeWith_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_DataSource.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputButton_HtmlInputButton_CausesValidation.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_AddRange_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCell_TableCell_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_CopyBaseAttributes_W.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListBox_ListBox_Rows.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_EditCommandColumn_EditCommandColumn_CancelText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListSelectionMode_ListSelectionMode_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Remove_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_EditCommandColumn_EditCommandColumn_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_DeleteCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlAnchor_HtmlAnchor_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridItem_DataGridItem_DataItem.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TableStyle_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_MergeWith_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_EditCommandColumn_EditCommandColumn_EditText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlTextWriterAttribute_HtmlTextWriterAttribute_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpRequest_HttpRequest_ContentEncoding.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_ControlStyleCreated.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_AutoPostBack.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_ProcessStatus_ProcessStatus_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_Remove_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_GetRowIndex_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_AddRange_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridItem_DataGridItem_ItemType.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRow_TableRow_Cells.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItemType_ListItemType_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_Pages_PageWMaster.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_Value.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TableItemStyle_Wrap.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_AlternatingItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_Controls.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRow_TableRow_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_DataKeys.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_Reset_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_TraceMode_TraceMode_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRow_TableRow_CreateControlStyle_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_SeparatorTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TitleFormat_TitleFormat_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_Pages_PageWOMaster.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CalendarSelectionMode_CalendarSelectionMode_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_Visible.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputImage_HtmlInputImage_Align.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_LinkButton_LinkButton_CausesValidation.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RepeaterItem_RepeaterItem_ItemIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpRequest_HttpRequest_AcceptTypes.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_NextPageCommandArgument.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_ShowHeader.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBoxList_CheckBoxList_RepeatColumns.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_ToolTip.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataListItem_DataListItem_ItemIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataListItem_DataListItem_ctor_IL.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_Contents.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Button_Button_CausesValidation.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_SelectedIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListBox_ListBox_SelectionMode.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCell_TableCell_RowSpan.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRow_TableRow_VerticalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLinkColumn_HyperLinkColumn_InitializeCell_TIL.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HorizontalAlign_HorizontalAlign_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_EditCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_ctor_H.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_Add_SO.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_RemoveAt_I.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataListItem_DataListItem_ItemType.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_HeaderText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RadioButtonList_RadioButtonList_CellPadding.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DropDownList_DropDownList_BorderWidth.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_CurrentPageIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBoxList_CheckBoxList_CellPadding.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RadioButtonList_RadioButtonList_CellSpacing.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListBox_ListBox_BorderColor.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_ItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_FirstDayOfWeek_FirstDayOfWeek_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_ViewState.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_ItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TemplateColumn_TemplateColumn_InitializeCell_TIL.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_DataMember.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_SelectedIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_FooterStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RepeaterItem_RepeaterItem_ItemType_Manual.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLinkColumn_HyperLinkColumn_DataTextFormatString.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Label_Label_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListBox_ListBox_BorderStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_OverLine.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBox_CheckBox_Checked.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlTextWriterTag_HtmlTextWriterTag_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_NextPrevFormat_NextPrevFormat_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_Mode.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_LinkButton_LinkButton_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlButton_HtmlButton_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_DeleteCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TableStyle_CellPadding.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_PrevPageText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlTextWriterStyle_HtmlTextWriterStyle_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpCacheRevalidation_HttpCacheRevalidation_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_VirtualItemCount.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBoxList_CheckBoxList_CellSpacing.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_SelectedValue.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BorderStyle_BorderStyle_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Image_Image_Font.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_Wrap.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TemplateColumn_TemplateColumn_ItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_DataSource.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_ShowFooter.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Table_Table_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Image_Image_ImageAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_Item.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlControl_HtmlControl_Style.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_ItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ValidationSummaryDisplayMode_ValidationSummaryDisplayMode_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_Clear_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputHidden_HtmlInputHidden_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_SyncRoot.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_Position.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Table_Table_CellPadding.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridItem_DataGridItem_ItemIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Width.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_ExtractTemplateRows.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_SelectedItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputImage_HtmlInputImage_Alt.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_Pages_PageWControl3.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_RemoveAt_I.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBoxList_CheckBoxList_TextAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_PrevPageCommandArgument.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_AlternatingItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridItem_DataGridItem_DataSetIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpRequest_HttpRequest_Browser.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ButtonColumn_ButtonColumn_DataTextFormatString.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_CopyFrom_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_SortCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBoxList_CheckBoxList_RepeatDirection.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_ItemCreated.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLink_HyperLink_Target.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_SelectCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_TextMode.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ButtonColumn_ButtonColumn_DataTextField.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RadioButtonList_RadioButtonList_RepeatColumns.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_CopyFrom_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_PageSize.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlButton_HtmlButton_CausesValidation.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlTextArea_HtmlTextArea_ctor_3.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ValidationDataType_ValidationDataType_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_ShowFooter.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlAnchor_HtmlAnchor_Name.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_ForeColor.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_ItemDataBound.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Font.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpValidationStatus_HttpValidationStatus_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_Name.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_PageCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_LCID.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_ClientID.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_AutoGenerateColumns.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_BackColor.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_Italic.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_BorderWidth.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_Equals_O.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRow_TableRow_CreateControlCollection_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_Remove_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_CodePage.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BoundColumn_BoundColumn_DataFormatString.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_HeaderImageUrl.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ButtonColumn_ButtonColumn_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Border.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_GridLines.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_PlaceHolder_PlaceHolder_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_UserPage.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCell_TableCell_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_Count.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBox_CheckBox_TextAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_Columns.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ButtonColumn_ButtonColumn_CommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RadioButtonList_RadioButtonList_RepeatDirection.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_ToString_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Table_Table_CellSpacing.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_RenderBeginTag_H.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Count.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputImage_HtmlInputImage_CausesValidation.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_DataSource.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TemplateColumn_TemplateColumn_HeaderTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_GetEnumerator_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBoxMode_TextBoxMode_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlContainerControl_HtmlContainerControl_InnerText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_ItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputImage_HtmlInputImage_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_Pages_PageWControl1.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BoundColumn_BoundColumn_DataField.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_CellSpacing.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_Dispose_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_AllowCustomPaging.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputImage_HtmlInputImage_Border.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RepeaterItem_RepeaterItem_DataItem.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLinkColumn_HyperLinkColumn_DataNavigateUrlField.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_SyncRoot.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBox_CheckBox_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_AllowPaging.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_CancelCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_ctor_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Height.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_ID.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_Size.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_GetEnumerator_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_SessionID.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpRequest_HttpRequest_ServerVariables.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_DataBind_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ButtonColumn_ButtonColumn_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLinkColumn_HyperLinkColumn_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_DataMember.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_Add_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_IsReadOnly.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Literal_Literal_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlTextArea_HtmlTextArea_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TemplateColumn_TemplateColumn_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TemplateColumn_TemplateColumn_FooterTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpRequest_HttpRequest_ClientCertificate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Panel_Panel_Wrap.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Item.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Table_Table_Rows.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_EditItemIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_HeaderTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpCacheability_HttpCacheability_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_ItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBoxList_CheckBoxList_RepeatLayout.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DropDownList_DropDownList_BorderStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_Selected.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TabIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ValidatorDisplay_ValidatorDisplay_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_SelectedItem.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_BackImageUrl.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_StrikeOut.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_SelectedItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_FooterTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_GetCellIndex_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_EditItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_ValidationPropertyAttribute_ValidationPropertyAttribute_ctor_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_Remove_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_Names.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_NamingContainer.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_ctor_SS.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_AlternatingItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_AllKeys.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_RepeatDirection.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/standalone/theme/PageLinks/App_Themes/Black/Images/button-login.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/tools/CachePQTestGenerator/Sequences/cache_pq_sequence_2011-04-07_02-03-02_25377827.seq.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/Test/tools/CachePQTestGenerator/Sequences/cache_pq_sequence_2010-11-18_01-38-13.seq.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/box_noexpand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/box_minus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_lplus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/box_plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_rplus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_dash.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_t.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/box_empty.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/contact.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_dashplus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/folder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/star_full.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_i.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/transparent.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_lminus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/box_full.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/computer.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/file.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/dot_full.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_dashminus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/dots.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/arrow_down.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/inbox.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/arrow_minus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/warning.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/star_empty.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_tminus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_rminus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/arrow_up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/dot_empty.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/arrow_noexpand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_minus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/arrow_plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_tplus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/resources/TreeView_noexpand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web/System.Web.Profile/SqliteProfileProvider.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Mono.Cecil.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/mcs.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Mono.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Text.Encoding.CodePages.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Diagnostics.FileVersionInfo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Security.Cryptography.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.IO.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/netstandard.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.IO.FileSystem.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Security.Cryptography.Algorithms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-win32/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Mono.Cecil.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/mcs.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Mono.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Text.Encoding.CodePages.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Diagnostics.FileVersionInfo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Security.Cryptography.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.IO.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/netstandard.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.IO.FileSystem.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Security.Cryptography.Algorithms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-unix/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Mono.Cecil.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/mcs.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Mono.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Text.Encoding.CodePages.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Diagnostics.FileVersionInfo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Security.Cryptography.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.IO.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/netstandard.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.IO.FileSystem.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Security.Cryptography.Algorithms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-linux/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Mono.Cecil.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/mcs.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Mono.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Text.Encoding.CodePages.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Diagnostics.FileVersionInfo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Security.Cryptography.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.IO.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/netstandard.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.IO.FileSystem.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Security.Cryptography.Algorithms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/lib/monolite-macos/ABB721D6-116A-4555-B4FD-9248146D2051/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Net.Http/Test/System.Net.Http/StringContentTest.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Commons.Xml.Relaxng/Test/XmlFiles/team.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System/compmod/system/componentmodel/CultureInfoConverter.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System/services/monitoring/system/diagnosticts/EventLogInternal.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System/InternalApis/NDP_FX/inc/ZLibNative.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System/net/System/Net/HttpListenerRequestUriBuilder.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System/net/System/Net/Configuration/DefaultProxySection.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web/HttpResponse.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.ServiceModel.Activation/System/ServiceModel/Activities/Activation/WorkflowServiceHostFactory.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.Services/System/Web/Services/Protocols/ServerProtocol.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/WebForm/ChartWebControl.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/WebForm/General/ChartHttpHandler.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/WebForm/Converters/MapAreaCoordinatesConverter.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/GroupAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/ArrowAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/RectangleAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/AnnotationBase.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/LineAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/TextAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/PolygonAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/ImageAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/AnnotationCollection.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/CalloutAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Constants.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Label.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/AxisScrollBar.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Matrix3D.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/DataManipulator.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/GdiGraphics.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/AxisScale.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Statistics.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/AxisScaleSegments.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/IChartRenderingEngine.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartArea.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartElement.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartAreaCollection.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Legend.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Chart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartAreaCircular.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartGraphics.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ImageMap.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/GridTickMarks.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/LegendColumns.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/AxisScrollZoom.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/NamedImageCollection.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/AxisLabels.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/CommonElements.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartAreaCursor.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Title.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartRenderingEngine.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/SubAxis.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartAreaAxes.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/StripLine.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Selection.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Axis.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/FormulaData.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/AxisScaleBreaks.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartGraphics3D.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/SmartLabels.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartSerializer.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/RenkoChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/DoughnutChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/PointChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/PieChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/ErrorBarChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/LineChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/BubbleChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/FastPointChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/RadarChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/BarChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/StepLineChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/StockChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/StackedAreaChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/PolarChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/ColumnChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/FastLineChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/ChartTypeRegistry.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/BoxPlotChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/AreaChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/StackedBarChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/StackedColumnChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/FunnelChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/PointAndFigureChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/ThreeLineBreakChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/KagiChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/RangeChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Converters/LegendConverters.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Converters/AnnotationConverters.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Converters/DataManagerConverters.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Converters/ElementPositionConverter.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Converters/AxisConverters.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Converters/AxesArrayConverter.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Converters/CustomAttributesConverters.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Utilities/ElementPosition.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Utilities/KeywordsRegistry.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Utilities/ColorPalette.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Utilities/ValueConverter.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Utilities/CustomAttributesRegistry.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Utilities/ImageLoader.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Utilities/XmlSerializer.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/DataManager/DataPoint.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/DataManager/DataSeries.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/DataManager/DataManager.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/PriceIndicators.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/FormulaRegistry.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/VolumeIndicator.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/GeneralFormulas.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/StatisticalAnalysis.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/TechGeneralIndicators.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/TimeSeriesAndForecasting.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/Oscillator.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Borders3D/EmbossBorder.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Borders3D/Borders3D.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.ServiceModel/System/ServiceModel/Dispatcher/SecurityValidationBehavior.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.ServiceModel/System/ServiceModel/Channels/TransportDefaults.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Core/System/IO/Pipes/PipeStream.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Core/System/Linq/Parallel/QueryOperators/Unary/TakeOrSkipQueryOperator.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Data.Entity/System/Data/Common/CommandTrees/ExpressionBuilder/Spatial/SpatialEdmFunctions.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Data.Entity/System/Data/Query/PlanCompiler/NestPullup.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Data.Entity/System/Data/Query/PlanCompiler/JoinGraph.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Data.Entity/System/Data/Query/PlanCompiler/TransformationRules.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Data.Entity/System/Data/Query/PlanCompiler/KeyPullup.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Data.Entity/System/Data/EntityModel/SchemaObjectModel/EntityContainerRelationshipSetEnd.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Data.DataSetExtensions/System/Data/DataRowExtensions.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Xml/System.Xml.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Xml/System/Xml/XmlConvert.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Runtime.Serialization/System/Xml/XmlUTF8TextReader.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.ServiceModel.Activities/System/ServiceModel/Activities/InternalSendMessage.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.ServiceModel.Activities/System/ServiceModel/Activities/InternalReceiveMessage.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/System.Data/System/Data/SqlClient/TdsEnums.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/mscorlib/system/convert.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/mscorlib/system/version.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/mscorlib/system/io/streamreader.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/mscorlib/system/threading/SpinWait.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/mscorlib/system/resources/resourcefallbackmanager.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/mscorlib/system/collections/hashtable.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/referencesource/mscorlib/system/collections/generic/equalitycomparer.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Reactive.Windows.Threading/Strings_WindowsThreading.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.ServiceModel/Test/Resources/test.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.ServiceModel/Test/Resources/binary-message.raw",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.ServiceModel/Test/Resources/test2.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.ServiceModel/Test/Resources/test.cer",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/West/Test/texts/nordic-865.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/West/Test/texts/icelandic-10079.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/West/Test/texts/italian-28593.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/West/Test/texts/latin-28605.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/West/Test/texts/polish-1250.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/West/Test/texts/portguese-860.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/West/Test/texts/greek-28597.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/West/Test/texts/hungarian-28592.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/West/Test/texts/french2-863.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/West/Test/texts/french-10000.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/West/Test/texts/latin-850.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/West/Test/texts/greek-1253.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/West/Test/texts/box-437.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/West/Test/texts/icelandic2-861.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/West/Test/texts/norwegian-1252.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/Common/ByteSafeEncoding.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/Common/MonoSafeEncoding.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/CJK/ks.table",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/CJK/big5.table",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/CJK/jis.table",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/CJK/gb2312.table",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/CJK/gb18030.table",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/CJK/Test/texts/japanese-51932.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/CJK/Test/texts/chinese4-950.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/CJK/Test/texts/japanese-932.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/CJK/Test/texts/korean-949.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/CJK/Test/texts/chinese3-936.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/CJK/Test/texts/chinese-936.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/CJK/Test/texts/chinese-54936.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/CJK/Test/texts/chinese2-950.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/MidEast/Test/texts/encoder-handlefallback-generic-utf8.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/I18N/MidEast/Test/texts/turkish-1254.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Reactive.Core/Strings_Core.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Reactive.Providers/Strings_Providers.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web.DynamicData/Test/WebPages/DynamicData/Content/Images/PgLast.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web.DynamicData/Test/WebPages/DynamicData/Content/Images/Back.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web.DynamicData/Test/WebPages/DynamicData/Content/Images/PgPrev.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web.DynamicData/Test/WebPages/DynamicData/Content/Images/PgNext.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web.DynamicData/Test/WebPages/DynamicData/Content/Images/plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web.DynamicData/Test/WebPages/DynamicData/Content/Images/PgFirst.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Web.DynamicData/Test/WebPages/DynamicData/Content/Images/header_back.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Novell.Directory.Ldap/Novell.Directory.Ldap.Extensions/LdapBackupResponse.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Security/Test/System.Security.Cryptography.Pkcs/detached.data",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Security/Test/System.Security.Cryptography.Pkcs/detached.p7",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Security/Test/System.Security.Cryptography.Xml/sample.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/WebMatrix.Data/Test/resources/testsqlite.db",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Mono.Cairo/Samples/x11/data/e.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Mono.Cairo/Samples/png/data/e.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Mono.Cairo/Samples/gtk/data/e.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/IBM.Data.DB2/ibm.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Reactive.PlatformServices/Strings_PlatformServices.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.IO.Compression/Test/resources/archive.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.IO.Compression/Test/resources/test.nupkg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/Test/resources/32x32.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/Test/resources/M.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/Test/resources/a.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/Test/System.Windows.Forms/bitmaps/a.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/errorProvider.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/SplitterWE.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/image-missing.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/document-open.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/16_user-home.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/16_dialog-warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/folder.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/nav_previous.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/image-x-generic.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/DnDNo.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/DnDLink.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/folder-remote.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/32_document-open.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/16_dialog-information.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/22_page-magnifier.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/nav_first.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/32_user-desktop.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/32_printer.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/NESW.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/16_computer.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/preferences-system-windows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/nav_plus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/3-up.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/DnDMove.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/NWSE.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/mono.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/System.Windows.Forms.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/folder-new.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/propertygrid-categorized.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/16_dialog-error.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/user-desktop.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/4-up.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/go-top.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/go-previous.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/16_user-desktop.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/nav_end.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/6-up.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/32_user-home.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/16_printer.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/keyboards.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/16_document-open.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/nav_next.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/computer.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/EventsTab.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/text-x-generic.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/propertygrid-alphabetical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/user-home.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/nav_delete.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/32_folder-remote.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/16_folder-remote.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/1-up.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/PropertiesTab.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/16_folder.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/DnDCopy.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/propertygrid-propertypages.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/2-up.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/SplitterNS.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/resources/32_computer.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Windows.Forms/System.Windows.Forms/PageSetupDialog.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/Test/System.Security/SecurityElementTest.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/Test/resources/MyResources.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/Test/resources/MyResources.de.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/Test/resources/Fergie.GED",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/Test/resources/bug81759.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/Test/resources/StreamTest.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/Test/resources/415628.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/Test/resources/StreamTest.ja.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/resources/charinfo.nlp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/resources/collation.cjkJA.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/resources/collation.cjkCHS.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/resources/collation.core.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/resources/collation.cjkCHT.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/resources/collation.cjkKOlv2.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/resources/collation.tailoring.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/corlib/resources/collation.cjkKO.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/resources/indexed.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/nature24bits.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/64x64x256.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/96x96x256.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/323511.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/almogaver32bits.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/4bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/nature24bits.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/almogaver1bit.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/32x32x16.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/almogaver24bits.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/almogaver32bits.tif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/only256.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/milkmateya01.emf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/48x48x1.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/almogaver8bits.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/81674-2bpp.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/telescope_01.wmf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/almogaver24bits1.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/32bpp.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/non-inverted.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/maketransparent.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/1bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/415581.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/nature24bits87.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/81773-interlaced.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/almogaver-os2.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/16x16x16.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/VisualPng1.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/smiley.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/80509.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/VisualPng.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/nature-greyscale.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Assembly/Exclamation.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Assembly/Warning.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Assembly/Information.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Assembly/Asterisk.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Assembly/Application.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Assembly/Shield.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Assembly/Error.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Assembly/WinLogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Assembly/Question.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Assembly/Mono.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Drawing/Assembly/Hand.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Data/Test/ProviderTests/sql/sqlserver7.sql",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Data/Test/System.Data.Common/SqliteTest.db",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Data/Test/System.Data/binserialize/BS-tb1.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Data/Test/System.Data/binserialize/BS-tb3.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Data/Test/System.Data/binserialize/BS-tb2.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Data/Test/System.Data/binserialize/BS-tb5.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Data/Test/System.Data/binserialize/BS-tb4.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Mono.C5/c5.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Mono.C5/c5.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/Mono.C5/Test/BasesTest.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/System.Reactive.Linq/Strings_Linq.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/ICSharpCode.SharpZipLib/SharpZipLib.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/class/ICSharpCode.SharpZipLib/SharpZipLib.key",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/System.Memory.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/System.Runtime.CompilerServices.Unsafe.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/System.Threading.Tasks.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/3.5.0/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/nunitreport/Media/backbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/nunitreport/Media/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/nunitreport/Media/fail.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/nunitreport/Media/bullet.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/nunitreport/Media/pass.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/nunitreport/Media/rupert.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/security/certview/v3.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/security/certview/mono.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/security/certview/v3critical.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/security/certview/v1.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/security/certview/wax-seal.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/security/certview/v2.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/security/certview/mono.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/security/certview/wax-seal-broken.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/sqlmetal/src/DbLinq.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/sqlmetal/src/DbMetal/Language/EnglishWords.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/sqlmetal/src/DbMetal/Language/GermanWords.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/sqlmetal/src/DbLinq/Data/Linq/EntityRef.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/tools/pdb2mdb/IntHashTable.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-6.8.0.105-g2cby7zpkxhnr6n3oc6v5z36lxq4knt4/spack-src/mcs/mcs/visit.cs"
    ],
    "total_files": 113515
}