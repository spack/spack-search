{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-psm-2017-04-28-by2c525gyvxhvpix4ridwmicpxiyhtm7/spack-src/ptl_ips/ips_opp_path_rec.c": "/*\n * Copyright (c) 2013. Intel Corporation. All rights reserved.\n * Copyright (c) 2006-2012. QLogic Corporation. All rights reserved.\n * Copyright (c) 2003-2006, PathScale, Inc. All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include \"psm_user.h\"\n#include \"ipserror.h\"\n#include \"ips_proto.h\"\n#include \"ips_proto_internal.h\"\n#include <dlfcn.h>\n\n#define DF_OPP_LIBRARY \"libofedplus.so\"\n#define DATA_VFABRIC_OFFSET 8\n\n/* SLID and DLID are in network byte order */\nstatic psm_error_t\nips_opp_get_path_rec(ips_path_type_t type, struct ips_proto *proto,\n\t\t     uint16_t slid, uint16_t dlid, uint16_t desthca_type,\n\t\t     ips_path_rec_t **path_rec)\n{\n  psm_error_t err = PSM_OK;\n  ibta_path_rec_t query;\n  ips_opp_path_rec_t *opp_path_rec;\n  int opp_err;\n  ENTRY elid, *epath = NULL;\n  char eplid[128];\n  uint64_t timeout_ack_ms;\n\n  /* Query path record query cache first */\n  bzero(&query, sizeof(query));\n  bzero(eplid, sizeof(eplid));\n  \n  /* Bulk service ID is control service id + 1 */\n  switch(type) {\n  case IPS_PATH_NORMAL_PRIORITY:\n  case IPS_PATH_LOW_PRIORITY:\n    query.service_id = \n\t__cpu_to_be64(proto->ep->service_id + DATA_VFABRIC_OFFSET);\n    break;\n  case IPS_PATH_HIGH_PRIORITY:\n  default:\n    query.service_id = __cpu_to_be64(proto->ep->service_id);\n  }\n\n  query.slid = slid;\n  query.dlid = dlid;\n\n  snprintf(eplid, sizeof(eplid), \"%s_%x_%x\", (type == IPS_PATH_HIGH_PRIORITY) ? \"HIGH\" : \"LOW\", query.slid,query.dlid);\n  elid.key = eplid;\n  hsearch_r(elid, FIND, &epath, &proto->ips_path_rec_hash);\n\n  if (!epath) { /* Unable to find path record in cache */\n    elid.key = psmi_calloc(proto->ep, UNDEFINED, 1, strlen(eplid) + 1);\n    opp_path_rec = (ips_opp_path_rec_t*) \n      psmi_calloc(proto->ep, UNDEFINED, 1, sizeof(ips_opp_path_rec_t));\n    if (!elid.key || !opp_path_rec) {\n\tif (elid.key) psmi_free(elid.key);\n\tif (opp_path_rec) psmi_free(opp_path_rec);\n\terr = PSM_NO_MEMORY;\n\tgoto fail;\n    }\n    \n    /* Get path record between local LID and remote */\n    opp_err = proto->opp_fn.op_path_get_path_by_rec(proto->opp_ctxt, &query,\n\t\t\t\t\t     &opp_path_rec->opp_response);\n    if (opp_err) {\n      psmi_free(opp_path_rec);\n      psmi_free(elid.key);\n      err = PSM_EPID_PATH_RESOLUTION;\n      goto fail;\n    }\n\n    /* Create path record */\n    opp_path_rec->ips.epr_slid = opp_path_rec->opp_response.slid;\n    opp_path_rec->ips.epr_dlid = opp_path_rec->opp_response.dlid;\n    opp_path_rec->ips.epr_mtu = \n      min(ibta_mtu_enum_to_int(opp_path_rec->opp_response.mtu & 0x3f), \n\t  proto->epinfo.ep_mtu);\n    opp_path_rec->ips.epr_pkey = ntohs(opp_path_rec->opp_response.pkey);\n    opp_path_rec->ips.epr_sl = ntohs(opp_path_rec->opp_response.qos_class_sl);\n    opp_path_rec->ips.epr_static_rate = opp_path_rec->opp_response.rate & 0x3f;\n    opp_path_rec->ips.epr_static_ipd = \n      proto->ips_ipd_delay[opp_path_rec->ips.epr_static_rate];\n    \n    /* Setup CCA parameters for path */\n    if (opp_path_rec->ips.epr_sl > 15) {\n        psmi_free(opp_path_rec);\n        psmi_free(elid.key);\n\terr = PSM_INTERNAL_ERR;\n\tgoto fail;\n    }\n    if (!(proto->ccti_ctrlmap&(1<<opp_path_rec->ips.epr_sl))) {\n\t_IPATH_CCADBG(\"No CCA for sl %d, disable CCA\\n\",\n\t\topp_path_rec->ips.epr_sl);\n\tproto->flags &= ~IPS_PROTO_FLAG_CCA;\n    }\n    opp_path_rec->ips.proto = proto;\n    opp_path_rec->ips.epr_ccti_min = proto->cace[opp_path_rec->ips.epr_sl].ccti_min;\n    opp_path_rec->ips.epr_ccti = opp_path_rec->ips.epr_ccti_min;\n    psmi_timer_entry_init(&opp_path_rec->ips.epr_timer_cca,\n\t\t\t  ips_cca_timer_callback, &opp_path_rec->ips);\n    \n    /* Determine active IPD for path. Is max of static rate and CCT table */\n    if ((opp_path_rec->ips.epr_static_ipd) && \n\t((opp_path_rec->ips.epr_static_ipd + 1) > \n\t (proto->cct[opp_path_rec->ips.epr_ccti] & CCA_IPD_MASK))) {\n      opp_path_rec->ips.epr_active_ipd = opp_path_rec->ips.epr_static_ipd + 1;\n      opp_path_rec->ips.epr_cca_divisor = 0; /*Static rate has no CCA divisor */\n    }\n    else {\n      /* Pick it from the CCT table */\n      opp_path_rec->ips.epr_active_ipd = \n\tproto->cct[opp_path_rec->ips.epr_ccti] & CCA_IPD_MASK;\n      opp_path_rec->ips.epr_cca_divisor = \n\tproto->cct[opp_path_rec->ips.epr_ccti] >> CCA_DIVISOR_SHIFT;\n    }\n        \n    /* Compute max timeout based on pkt life time for path */\n    timeout_ack_ms = ((4096UL * (1UL << (opp_path_rec->opp_response.pkt_life & 0x3f)))/ 1000000UL);\n    opp_path_rec->ips.epr_timeout_ack = \n      ms_2_cycles(IPS_PROTO_ERRCHK_MS_MIN_DEFAULT);\n    opp_path_rec->ips.epr_timeout_ack_max = \n      ms_2_cycles(IPS_PROTO_ERRCHK_MS_MIN_DEFAULT + timeout_ack_ms);\n    opp_path_rec->ips.epr_timeout_ack_factor = IPS_PROTO_ERRCHK_FACTOR_DEFAULT;\n\n    /* Add path record into cache */\n    strcpy(elid.key, eplid);\n    elid.data = (void*) opp_path_rec;\n    hsearch_r(elid, ENTER, &epath, &proto->ips_path_rec_hash);\n  }\n  else /* Path record found in cache */\n    opp_path_rec = (ips_opp_path_rec_t*) epath->data;\n  \n  /* Dump path record stats */\n  _IPATH_PRDBG(\"Path Record ServiceID: %\"PRIx64\" %x -----> %x\\n\", (uint64_t) __be64_to_cpu(query.service_id), __be16_to_cpu(slid), __be16_to_cpu(dlid));\n  _IPATH_PRDBG(\"MTU: %x, %x\\n\", (opp_path_rec->opp_response.mtu & 0x3f), opp_path_rec->ips.epr_mtu);\n  _IPATH_PRDBG(\"PKEY: 0x%04x\\n\", ntohs(opp_path_rec->opp_response.pkey));\n  _IPATH_PRDBG(\"SL: 0x%04x\\n\", ntohs(opp_path_rec->opp_response.qos_class_sl));\n  _IPATH_PRDBG(\"Rate: %x, IPD: %x\\n\", (opp_path_rec->opp_response.rate & 0x3f), opp_path_rec->ips.epr_static_ipd);\n  _IPATH_PRDBG(\"Timeout Init.: 0x%\"PRIx64\" Max: 0x%\"PRIx64\"\\n\", opp_path_rec->ips.epr_timeout_ack, opp_path_rec->ips.epr_timeout_ack_max);\n\n  /* Return the IPS path record */\n  *path_rec = &opp_path_rec->ips;\n  \n fail:  \n  return err;\n}\n\nstatic psm_error_t \nips_opp_path_rec(struct ips_proto *proto,\n\t\t uint16_t slid, uint16_t dlid, uint16_t desthca_type,\n\t\t unsigned long timeout, \n\t\t ips_epaddr_t *ipsaddr)\n{\n  psm_error_t err = PSM_OK;\n  uint16_t pidx, cpath, num_path = (1 << proto->epinfo.ep_lmc);\n  ips_path_type_t path_type = IPS_PATH_NORMAL_PRIORITY;\n  ips_path_rec_t *path;\n  uint16_t path_slid, path_dlid;\n  psmi_context_t *context = &proto->ep->context;\n  \n  /*\n   * High Priority Path\n   * ------------------\n   * \n   * Uses the \"base\" Service ID. For now there exists only 1 high priority\n   * path between nodes even for non zero LMC fabrics. \n   * TODO: Investigate if there are any benefits for using multiple high \n   * priority paths. Initial empirical data shows that this leads to worse\n   * performance as the bulk data can induce HOL blocking.\n   * Currently the normal and low priority paths are same but at some point\n   * we can create separate vFabrics to further distinguish/isolate those \n   * traffic flows.\n   *\n   * Normal/Low Priority Paths\n   * -------------------------\n   * \n   * Currently these paths are the same i.e. they are queried for the same\n   * Service ID/vFabric which is the Base Service ID for High Priority + 1.\n   * \n   * Use case Scenarios\n   * ------------------\n   *\n   * Since with vFabrics we have the capability to define different QoS \n   * parameters per vFabric it is envisioned that the IPS_PATH_HIGH_PRIORITY is\n   * setup in a separate vFabric for high priority traffic. The NORMAL paths\n   * are setup in a separate vFabric optimized for high bandwidth. This allows\n   * us to potentially have control traffic (RTS, CTS etc.) not be bottlenecked\n   * by bulk transfer data. All control messages (ACKs,NAKs, TID_GRANT etc.)\n   * also use the high priority control vFabric.\n   *\n   * NOTE: In order to distinguish between the different vFabrics the user\n   * specifies the service ID to use via mpirun (or environment variable). \n   * This is the service ID for the high priority control traffic. The bulk\n   * data vFabric is identified by service ID + 1. So for each MPI application\n   * one should specify two service IDs for the high priority and bulk data.\n   * Both these service IDs can be placed in the same vFabric which can be\n   * configured for high priority or bandwidth traffic giving us the default\n   * behavior upto Infinipath 2.5 release.\n   *\n   * NOTE: All of the above would have really helped if the S20 silicon could\n   * correctly support IBTA QoS features. Due to S20 design we can only have\n   * high priority VLarb table (low priority VLarb table results in round\n   * robin arbitration ignoring the weights!). But if this is fixed in a \n   * subsequent chip respin then this may potentially help our scalability\n   * on large fabrics.\n   *\n   * Mesh/Torus and DOR routed networks\n   * ----------------------------------\n   * \n   * In a mesh/torus fabric we always have a non zero LMC (atleast 1 can be \n   * more). We would like to take advantage of dispersive routing on these\n   * fabrics as well to obtain better \"worst case/congested\" bandwidth. For\n   * these networks currently the base LIDs are used for UPDN routing which \n   * is suboptimal on these networks. Higher order LIDs (+1 .. +N) use DOR\n   * routing (Dimension Ordered Routing) to avoid deadlocks and provide\n   * higher performance. If a fabric is disrupted then only the base UPDN\n   * routing is available. PSM should continue to operate in this environment\n   * albeit with degraded performance. In disrupted fabric the OPP path\n   * record queries may fail for some DOR routed LIDs i.e. no path exists\n   * PSM should hence ignore path record failures as they indicate a disrupted\n   * fabric and only use valid paths that are returned from the replica. This\n   * will degenerate to only using the UPDN paths on disrupted fabrics and DOR\n   * routes only for fully configured fabrics. Note: For a clean fabric the\n   * base LIDs that are configured for UPDN route will not exist in the replica\n   * as DOR routes are preferred. Hence we will only dispersively route across\n   * the DOR routes only using the UPDN route for disrupted fabrics.\n   *\n   * AS LONG AS ONE PATH EXISTS (for each of the priorities) COMMUNICATION CAN\n   * TAKE PLACE.\n   */\n  \n  /* If base lids are only used then reset num_path to 1 */\n  if (proto->flags & IPS_PROTO_FLAG_PPOLICY_STATIC_BASE)\n    num_path = 1;\n  \n  ipsaddr->epr.epr_num_paths[IPS_PATH_HIGH_PRIORITY] = \n  ipsaddr->epr.epr_num_paths[IPS_PATH_NORMAL_PRIORITY] =\n  ipsaddr->epr.epr_num_paths[IPS_PATH_LOW_PRIORITY] = 0;\n\n  /* For now there is always only one high priority path between nodes. */\n  for (pidx = 0,cpath = 0; pidx < num_path && cpath == 0; pidx++) {\n    path_slid = __cpu_to_be16(__be16_to_cpu(slid) + pidx);\n    path_dlid = __cpu_to_be16(__be16_to_cpu(dlid) + pidx);\n\n    err = ips_opp_get_path_rec(IPS_PATH_HIGH_PRIORITY, proto, \n\t\t\t       path_slid, path_dlid, \n\t\t\t       desthca_type, &path);\n    \n    if (err == PSM_OK) {  /* Valid high priority path found */      \n      /* Resolved high priority path successfully */\n      ipsaddr->epr.epr_num_paths[IPS_PATH_HIGH_PRIORITY]++;\n      ipsaddr->epr.epr_path[IPS_PATH_HIGH_PRIORITY][cpath] = path;\n      \n      /* Increment current path index */\n      cpath++;\n    }\n  }\n  \n  /* Make sure we have atleast 1 high priority path */\n  if (ipsaddr->epr.epr_num_paths[IPS_PATH_HIGH_PRIORITY] == 0) {\n    err = psmi_handle_error(NULL, PSM_EPID_PATH_RESOLUTION,\n\t\t\t    \"OFEF Plus path lookup failed. Unable to resolve high priority network path for LID 0x%x <---> 0x%x. Is the SM running or service ID %\"PRIx64\" defined?\", ntohs(slid), ntohs(dlid), (uint64_t) proto->ep->service_id);\n    goto fail;\n  }\n  \n  /* Next setup the bulk paths. If the subnet administrator has misconfigured\n   * or rather not configured two separate service IDs we place the bulk\n   * paths in the same vFabric as the control paths.\n   */\n  for (pidx = 0,cpath = 0; pidx < num_path; pidx++) {\n    path_slid = __cpu_to_be16(__be16_to_cpu(slid) + pidx);\n    path_dlid = __cpu_to_be16(__be16_to_cpu(dlid) + pidx);\n    \n  retry_path_res:\n    err = ips_opp_get_path_rec(path_type, proto, \n\t\t\t       path_slid, path_dlid, desthca_type,\n\t\t\t       &path);\n    if (err != PSM_OK) {\n      if (path_type == IPS_PATH_NORMAL_PRIORITY) {\n\t/* Subnet may only be configured for one service ID/vFabric. Default\n\t * to using the control vFabric/service ID for bulk data as well.\n\t */\n\tpath_type = IPS_PATH_HIGH_PRIORITY;\n\tgoto retry_path_res;\n      }\n      \n      /* Unable to resolve path for <path_slid, path_dline>. This is possible\n       * for disrupted fabrics using DOR routing so continue to acquire paths\n       */\n      err = PSM_OK;\n      continue;\n    }\n        \n    /* Valid path. For now both normal and low priority paths are the same */\n    ipsaddr->epr.epr_path[IPS_PATH_NORMAL_PRIORITY][cpath] = path;\n    ipsaddr->epr.epr_path[IPS_PATH_LOW_PRIORITY][cpath] = path;\n    ipsaddr->epr.epr_num_paths[IPS_PATH_NORMAL_PRIORITY]++;\n    ipsaddr->epr.epr_num_paths[IPS_PATH_LOW_PRIORITY]++;\n    cpath++;\n  }\n\n  /* Make sure we have atleast have a single bulk data transfer path */\n  if ((ipsaddr->epr.epr_num_paths[IPS_PATH_NORMAL_PRIORITY] == 0) ||\n      (ipsaddr->epr.epr_num_paths[IPS_PATH_LOW_PRIORITY] == 0)) {\n    err = psmi_handle_error(NULL, PSM_EPID_PATH_RESOLUTION,\n\t\t\t    \"OFEF Plus path lookup failed. Unable to resolve normal/low priority network path for LID 0x%x <---> 0x%x. Is the SM running or service ID %\"PRIx64\" defined?\", ntohs(slid), ntohs(dlid), (uint64_t) proto->ep->service_id);\n    goto fail;\n  }\n  \n  if (proto->flags & IPS_PROTO_FLAG_PPOLICY_ADAPTIVE) {\n    ipsaddr->epr.epr_hpp_index = 0; \n    ipsaddr->epr.epr_next_path[IPS_PATH_NORMAL_PRIORITY] = \n      context->base_info.spi_context % ipsaddr->epr.epr_num_paths[IPS_PATH_NORMAL_PRIORITY];\n    ipsaddr->epr.epr_next_path[IPS_PATH_LOW_PRIORITY] = \n      context->base_info.spi_context % ipsaddr->epr.epr_num_paths[IPS_PATH_LOW_PRIORITY];\n  }\n  else if (proto->flags & IPS_PROTO_FLAG_PPOLICY_STATIC_DST)\n    ipsaddr->epr.epr_hpp_index = \n      ipsaddr->epr.epr_context  % ipsaddr->epr.epr_num_paths[IPS_PATH_HIGH_PRIORITY];\n  else if (proto->flags & IPS_PROTO_FLAG_PPOLICY_STATIC_SRC)\n    ipsaddr->epr.epr_hpp_index = \n      context->base_info.spi_context % ipsaddr->epr.epr_num_paths[IPS_PATH_HIGH_PRIORITY];\n  else  /* Base LID  */\n    ipsaddr->epr.epr_hpp_index = 0;\n  \n fail:\n  if (err != PSM_OK) \n    _IPATH_PRDBG(\"Unable to get path record for LID 0x%x <---> DLID 0x%x.\\n\", slid, dlid);\n  return err;\n}\n\nstatic psm_error_t ips_opp_fini(struct ips_proto *proto)\n{\n  psm_error_t err = PSM_OK;\n  \n  if (proto->opp_lib)\n    dlclose(proto->opp_lib);\n  \n  return err;  \n}\n\npsm_error_t ips_opp_init(struct ips_proto *proto)\n{\n  psm_error_t err = PSM_OK;\n  struct ipath_base_info *base_info = &proto->ep->context.base_info;\n  char hcaName[32];\n\n  proto->opp_lib = dlopen(DF_OPP_LIBRARY, RTLD_NOW);\n  if (!proto->opp_lib) {\n    char *err = dlerror();\n    _IPATH_ERROR(\"Unable to open OFED Plus Plus library %s. Error: %s\\n\", DF_OPP_LIBRARY,\n\t\terr ? err : \"no dlerror()\");\n    goto fail;\n  }\n  \n  /* Resolve symbols that we require within opp library */\n  proto->opp_fn.op_path_find_hca = dlsym(proto->opp_lib, \"op_path_find_hca\");\n  proto->opp_fn.op_path_open = dlsym(proto->opp_lib, \"op_path_open\");\n  proto->opp_fn.op_path_close = dlsym(proto->opp_lib, \"op_path_close\");\n  proto->opp_fn. op_path_get_path_by_rec = dlsym(proto->opp_lib, \"op_path_get_path_by_rec\");\n  \n  /* If we can't resovle any symbol then fail to load opp module */  \n  if (!proto->opp_fn.op_path_find_hca || !proto->opp_fn.op_path_open ||\n  !proto->opp_fn.op_path_close || !proto->opp_fn.op_path_get_path_by_rec) {\n    _IPATH_PRDBG(\"Unable to resolve symbols in OPP library. Unloading.\\n\");\n    goto fail;\n  }\n  \n    /* If PSM_IDENTIFY is set display the OPP library location being used. */\n  if (getenv(\"PSM_IDENTIFY\")) {\n    Dl_info info_opp;\n    _IPATH_INFO(\"PSM path record queries using OFED Plus Plus (%s) from %s\\n\", \n\t\tDF_OPP_LIBRARY,\n\t\tdladdr(proto->opp_fn.op_path_open, &info_opp) ? info_opp.dli_fname : \n\t\t\"Unknown/unsupported version of OPP library found!\");\n  }\n\n  /* Obtain handle to hca (requires verbs on node) */\n  snprintf(hcaName, sizeof(hcaName), \"qib%d\", base_info->spi_unit);\n  proto->hndl = proto->opp_fn.op_path_find_hca(hcaName, &proto->device);\n  if (!proto->hndl) {\n    _IPATH_ERROR(\"OPP: Unable to find HCA %s. Disabling OPP interface for path record queries.\\n\", hcaName);\n    goto fail;\n  }\n  \n  /* Get OPP context */\n  proto->opp_ctxt = proto->opp_fn.op_path_open(proto->device, base_info->spi_port);\n  if (!proto->opp_ctxt) {\n    _IPATH_ERROR(\"OPP: Unable to optain OPP context. Disabling OPP interface for path record queries.\\n\");\n    goto fail;\n  }\n  \n  /* OPP initialized successfully */\n  proto->ibta.get_path_rec = ips_opp_path_rec;\n  proto->ibta.fini = ips_opp_fini;\n  proto->flags |= IPS_PROTO_FLAG_QUERY_PATH_REC;\n\n  return err;\n  \n fail:\n  _IPATH_ERROR(\"Make sure SM is running...\\n\");\n  _IPATH_ERROR(\"Make sure service dist_sa is running...\\n\");\n  _IPATH_ERROR(\"to start dist_sa: service dist_sa start\\n\");\n  _IPATH_ERROR(\"or enable it at boot time: iba_config -E dist_sa\\n\\n\");\n\n  err = psmi_handle_error(NULL, PSM_EPID_PATH_RESOLUTION,\n\t\t\t  \"Unable to initialize OFED Plus library successfully.\\n\");\n\n  if (proto->opp_lib)\n    dlclose(proto->opp_lib);\n  \n  return err;\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-psm-2017-04-28-by2c525gyvxhvpix4ridwmicpxiyhtm7/spack-src/.git/objects/pack/pack-23631a5066e597b89e870aefa6b13e1dd374fa34.idx",
        "/tmp/vanessa/spack-stage/spack-stage-psm-2017-04-28-by2c525gyvxhvpix4ridwmicpxiyhtm7/spack-src/.git/objects/pack/pack-23631a5066e597b89e870aefa6b13e1dd374fa34.pack"
    ],
    "total_files": 165
}