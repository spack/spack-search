{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-wrk-3.1.2-v6kya4mjms4qhhzqnfeqfrs4zjuixhrq/spack-src/deps/luajit/src/lib_package.c": "/*\n** Package library.\n** Copyright (C) 2005-2014 Mike Pall. See Copyright Notice in luajit.h\n**\n** Major portions taken verbatim or adapted from the Lua interpreter.\n** Copyright (C) 1994-2012 Lua.org, PUC-Rio. See Copyright Notice in lua.h\n*/\n\n#define lib_package_c\n#define LUA_LIB\n\n#include \"lua.h\"\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n#include \"lj_obj.h\"\n#include \"lj_err.h\"\n#include \"lj_lib.h\"\n\n/* ------------------------------------------------------------------------ */\n\n/* Error codes for ll_loadfunc. */\n#define PACKAGE_ERR_LIB\t\t1\n#define PACKAGE_ERR_FUNC\t2\n#define PACKAGE_ERR_LOAD\t3\n\n/* Redefined in platform specific part. */\n#define PACKAGE_LIB_FAIL\t\"open\"\n#define setprogdir(L)\t\t((void)0)\n\n/* Symbol name prefixes. */\n#define SYMPREFIX_CF\t\t\"luaopen_%s\"\n#define SYMPREFIX_BC\t\t\"luaJIT_BC_%s\"\n\n#if LJ_TARGET_DLOPEN\n\n#include <dlfcn.h>\n\nstatic void ll_unloadlib(void *lib)\n{\n  dlclose(lib);\n}\n\nstatic void *ll_load(lua_State *L, const char *path, int gl)\n{\n  void *lib = dlopen(path, RTLD_NOW | (gl ? RTLD_GLOBAL : RTLD_LOCAL));\n  if (lib == NULL) lua_pushstring(L, dlerror());\n  return lib;\n}\n\nstatic lua_CFunction ll_sym(lua_State *L, void *lib, const char *sym)\n{\n  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);\n  if (f == NULL) lua_pushstring(L, dlerror());\n  return f;\n}\n\nstatic const char *ll_bcsym(void *lib, const char *sym)\n{\n#if defined(RTLD_DEFAULT)\n  if (lib == NULL) lib = RTLD_DEFAULT;\n#elif LJ_TARGET_OSX || LJ_TARGET_BSD\n  if (lib == NULL) lib = (void *)(intptr_t)-2;\n#endif\n  return (const char *)dlsym(lib, sym);\n}\n\n#elif LJ_TARGET_WINDOWS\n\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n\n#ifndef GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS\n#define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS  4\n#define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT  2\nBOOL WINAPI GetModuleHandleExA(DWORD, LPCSTR, HMODULE*);\n#endif\n\n#undef setprogdir\n\nstatic void setprogdir(lua_State *L)\n{\n  char buff[MAX_PATH + 1];\n  char *lb;\n  DWORD nsize = sizeof(buff);\n  DWORD n = GetModuleFileNameA(NULL, buff, nsize);\n  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\\\')) == NULL) {\n    luaL_error(L, \"unable to get ModuleFileName\");\n  } else {\n    *lb = '\\0';\n    luaL_gsub(L, lua_tostring(L, -1), LUA_EXECDIR, buff);\n    lua_remove(L, -2);  /* remove original string */\n  }\n}\n\nstatic void pusherror(lua_State *L)\n{\n  DWORD error = GetLastError();\n  char buffer[128];\n  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, buffer, sizeof(buffer), NULL))\n    lua_pushstring(L, buffer);\n  else\n    lua_pushfstring(L, \"system error %d\\n\", error);\n}\n\nstatic void ll_unloadlib(void *lib)\n{\n  FreeLibrary((HINSTANCE)lib);\n}\n\nstatic void *ll_load(lua_State *L, const char *path, int gl)\n{\n  HINSTANCE lib = LoadLibraryA(path);\n  if (lib == NULL) pusherror(L);\n  UNUSED(gl);\n  return lib;\n}\n\nstatic lua_CFunction ll_sym(lua_State *L, void *lib, const char *sym)\n{\n  lua_CFunction f = (lua_CFunction)GetProcAddress((HINSTANCE)lib, sym);\n  if (f == NULL) pusherror(L);\n  return f;\n}\n\nstatic const char *ll_bcsym(void *lib, const char *sym)\n{\n  if (lib) {\n    return (const char *)GetProcAddress((HINSTANCE)lib, sym);\n  } else {\n    HINSTANCE h = GetModuleHandleA(NULL);\n    const char *p = (const char *)GetProcAddress(h, sym);\n    if (p == NULL && GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS|GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n\t\t\t\t\t(const char *)ll_bcsym, &h))\n      p = (const char *)GetProcAddress(h, sym);\n    return p;\n  }\n}\n\n#else\n\n#undef PACKAGE_LIB_FAIL\n#define PACKAGE_LIB_FAIL\t\"absent\"\n\n#define DLMSG\t\"dynamic libraries not enabled; no support for target OS\"\n\nstatic void ll_unloadlib(void *lib)\n{\n  UNUSED(lib);\n}\n\nstatic void *ll_load(lua_State *L, const char *path, int gl)\n{\n  UNUSED(path); UNUSED(gl);\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\nstatic lua_CFunction ll_sym(lua_State *L, void *lib, const char *sym)\n{\n  UNUSED(lib); UNUSED(sym);\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\nstatic const char *ll_bcsym(void *lib, const char *sym)\n{\n  UNUSED(lib); UNUSED(sym);\n  return NULL;\n}\n\n#endif\n\n/* ------------------------------------------------------------------------ */\n\nstatic void **ll_register(lua_State *L, const char *path)\n{\n  void **plib;\n  lua_pushfstring(L, \"LOADLIB: %s\", path);\n  lua_gettable(L, LUA_REGISTRYINDEX);  /* check library in registry? */\n  if (!lua_isnil(L, -1)) {  /* is there an entry? */\n    plib = (void **)lua_touserdata(L, -1);\n  } else {  /* no entry yet; create one */\n    lua_pop(L, 1);\n    plib = (void **)lua_newuserdata(L, sizeof(void *));\n    *plib = NULL;\n    luaL_getmetatable(L, \"_LOADLIB\");\n    lua_setmetatable(L, -2);\n    lua_pushfstring(L, \"LOADLIB: %s\", path);\n    lua_pushvalue(L, -2);\n    lua_settable(L, LUA_REGISTRYINDEX);\n  }\n  return plib;\n}\n\nstatic const char *mksymname(lua_State *L, const char *modname,\n\t\t\t     const char *prefix)\n{\n  const char *funcname;\n  const char *mark = strchr(modname, *LUA_IGMARK);\n  if (mark) modname = mark + 1;\n  funcname = luaL_gsub(L, modname, \".\", \"_\");\n  funcname = lua_pushfstring(L, prefix, funcname);\n  lua_remove(L, -2);  /* remove 'gsub' result */\n  return funcname;\n}\n\nstatic int ll_loadfunc(lua_State *L, const char *path, const char *name, int r)\n{\n  void **reg = ll_register(L, path);\n  if (*reg == NULL) *reg = ll_load(L, path, (*name == '*'));\n  if (*reg == NULL) {\n    return PACKAGE_ERR_LIB;  /* Unable to load library. */\n  } else if (*name == '*') {  /* Only load library into global namespace. */\n    lua_pushboolean(L, 1);\n    return 0;\n  } else {\n    const char *sym = r ? name : mksymname(L, name, SYMPREFIX_CF);\n    lua_CFunction f = ll_sym(L, *reg, sym);\n    if (f) {\n      lua_pushcfunction(L, f);\n      return 0;\n    }\n    if (!r) {\n      const char *bcdata = ll_bcsym(*reg, mksymname(L, name, SYMPREFIX_BC));\n      lua_pop(L, 1);\n      if (bcdata) {\n\tif (luaL_loadbuffer(L, bcdata, ~(size_t)0, name) != 0)\n\t  return PACKAGE_ERR_LOAD;\n\treturn 0;\n      }\n    }\n    return PACKAGE_ERR_FUNC;  /* Unable to find function. */\n  }\n}\n\nstatic int lj_cf_package_loadlib(lua_State *L)\n{\n  const char *path = luaL_checkstring(L, 1);\n  const char *init = luaL_checkstring(L, 2);\n  int st = ll_loadfunc(L, path, init, 1);\n  if (st == 0) {  /* no errors? */\n    return 1;  /* return the loaded function */\n  } else {  /* error; error message is on stack top */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    lua_pushstring(L, (st == PACKAGE_ERR_LIB) ?  PACKAGE_LIB_FAIL : \"init\");\n    return 3;  /* return nil, error message, and where */\n  }\n}\n\nstatic int lj_cf_package_unloadlib(lua_State *L)\n{\n  void **lib = (void **)luaL_checkudata(L, 1, \"_LOADLIB\");\n  if (*lib) ll_unloadlib(*lib);\n  *lib = NULL;  /* mark library as closed */\n  return 0;\n}\n\n/* ------------------------------------------------------------------------ */\n\nstatic int readable(const char *filename)\n{\n  FILE *f = fopen(filename, \"r\");  /* try to open file */\n  if (f == NULL) return 0;  /* open failed */\n  fclose(f);\n  return 1;\n}\n\nstatic const char *pushnexttemplate(lua_State *L, const char *path)\n{\n  const char *l;\n  while (*path == *LUA_PATHSEP) path++;  /* skip separators */\n  if (*path == '\\0') return NULL;  /* no more templates */\n  l = strchr(path, *LUA_PATHSEP);  /* find next separator */\n  if (l == NULL) l = path + strlen(path);\n  lua_pushlstring(L, path, (size_t)(l - path));  /* template */\n  return l;\n}\n\nstatic const char *searchpath (lua_State *L, const char *name,\n\t\t\t       const char *path, const char *sep,\n\t\t\t       const char *dirsep)\n{\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  if (*sep != '\\0')  /* non-empty separator? */\n    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */\n  while ((path = pushnexttemplate(L, path)) != NULL) {\n    const char *filename = luaL_gsub(L, lua_tostring(L, -1),\n\t\t\t\t     LUA_PATH_MARK, name);\n    lua_remove(L, -2);  /* remove path template */\n    if (readable(filename))  /* does file exist and is readable? */\n      return filename;  /* return that file name */\n    lua_pushfstring(L, \"\\n\\tno file \" LUA_QS, filename);\n    lua_remove(L, -2);  /* remove file name */\n    luaL_addvalue(&msg);  /* concatenate error msg. entry */\n  }\n  luaL_pushresult(&msg);  /* create error message */\n  return NULL;  /* not found */\n}\n\nstatic int lj_cf_package_searchpath(lua_State *L)\n{\n  const char *f = searchpath(L, luaL_checkstring(L, 1),\n\t\t\t\tluaL_checkstring(L, 2),\n\t\t\t\tluaL_optstring(L, 3, \".\"),\n\t\t\t\tluaL_optstring(L, 4, LUA_DIRSEP));\n  if (f != NULL) {\n    return 1;\n  } else {  /* error message is on top of the stack */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    return 2;  /* return nil + error message */\n  }\n}\n\nstatic const char *findfile(lua_State *L, const char *name,\n\t\t\t    const char *pname)\n{\n  const char *path;\n  lua_getfield(L, LUA_ENVIRONINDEX, pname);\n  path = lua_tostring(L, -1);\n  if (path == NULL)\n    luaL_error(L, LUA_QL(\"package.%s\") \" must be a string\", pname);\n  return searchpath(L, name, path, \".\", LUA_DIRSEP);\n}\n\nstatic void loaderror(lua_State *L, const char *filename)\n{\n  luaL_error(L, \"error loading module \" LUA_QS \" from file \" LUA_QS \":\\n\\t%s\",\n\t     lua_tostring(L, 1), filename, lua_tostring(L, -1));\n}\n\nstatic int lj_cf_package_loader_lua(lua_State *L)\n{\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  filename = findfile(L, name, \"path\");\n  if (filename == NULL) return 1;  /* library not found in this path */\n  if (luaL_loadfile(L, filename) != 0)\n    loaderror(L, filename);\n  return 1;  /* library loaded successfully */\n}\n\nstatic int lj_cf_package_loader_c(lua_State *L)\n{\n  const char *name = luaL_checkstring(L, 1);\n  const char *filename = findfile(L, name, \"cpath\");\n  if (filename == NULL) return 1;  /* library not found in this path */\n  if (ll_loadfunc(L, filename, name, 0) != 0)\n    loaderror(L, filename);\n  return 1;  /* library loaded successfully */\n}\n\nstatic int lj_cf_package_loader_croot(lua_State *L)\n{\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  const char *p = strchr(name, '.');\n  int st;\n  if (p == NULL) return 0;  /* is root */\n  lua_pushlstring(L, name, (size_t)(p - name));\n  filename = findfile(L, lua_tostring(L, -1), \"cpath\");\n  if (filename == NULL) return 1;  /* root not found */\n  if ((st = ll_loadfunc(L, filename, name, 0)) != 0) {\n    if (st != PACKAGE_ERR_FUNC) loaderror(L, filename);  /* real error */\n    lua_pushfstring(L, \"\\n\\tno module \" LUA_QS \" in file \" LUA_QS,\n\t\t    name, filename);\n    return 1;  /* function not found */\n  }\n  return 1;\n}\n\nstatic int lj_cf_package_loader_preload(lua_State *L)\n{\n  const char *name = luaL_checkstring(L, 1);\n  lua_getfield(L, LUA_ENVIRONINDEX, \"preload\");\n  if (!lua_istable(L, -1))\n    luaL_error(L, LUA_QL(\"package.preload\") \" must be a table\");\n  lua_getfield(L, -1, name);\n  if (lua_isnil(L, -1)) {  /* Not found? */\n    const char *bcname = mksymname(L, name, SYMPREFIX_BC);\n    const char *bcdata = ll_bcsym(NULL, bcname);\n    if (bcdata == NULL || luaL_loadbuffer(L, bcdata, ~(size_t)0, name) != 0)\n      lua_pushfstring(L, \"\\n\\tno field package.preload['%s']\", name);\n  }\n  return 1;\n}\n\n/* ------------------------------------------------------------------------ */\n\nstatic const int sentinel_ = 0;\n#define sentinel\t((void *)&sentinel_)\n\nstatic int lj_cf_package_require(lua_State *L)\n{\n  const char *name = luaL_checkstring(L, 1);\n  int i;\n  lua_settop(L, 1);  /* _LOADED table will be at index 2 */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, 2, name);\n  if (lua_toboolean(L, -1)) {  /* is it there? */\n    if (lua_touserdata(L, -1) == sentinel)  /* check loops */\n      luaL_error(L, \"loop or previous error loading module \" LUA_QS, name);\n    return 1;  /* package is already loaded */\n  }\n  /* else must load it; iterate over available loaders */\n  lua_getfield(L, LUA_ENVIRONINDEX, \"loaders\");\n  if (!lua_istable(L, -1))\n    luaL_error(L, LUA_QL(\"package.loaders\") \" must be a table\");\n  lua_pushliteral(L, \"\");  /* error message accumulator */\n  for (i = 1; ; i++) {\n    lua_rawgeti(L, -2, i);  /* get a loader */\n    if (lua_isnil(L, -1))\n      luaL_error(L, \"module \" LUA_QS \" not found:%s\",\n\t\t name, lua_tostring(L, -2));\n    lua_pushstring(L, name);\n    lua_call(L, 1, 1);  /* call it */\n    if (lua_isfunction(L, -1))  /* did it find module? */\n      break;  /* module loaded successfully */\n    else if (lua_isstring(L, -1))  /* loader returned error message? */\n      lua_concat(L, 2);  /* accumulate it */\n    else\n      lua_pop(L, 1);\n  }\n  lua_pushlightuserdata(L, sentinel);\n  lua_setfield(L, 2, name);  /* _LOADED[name] = sentinel */\n  lua_pushstring(L, name);  /* pass name as argument to module */\n  lua_call(L, 1, 1);  /* run loaded module */\n  if (!lua_isnil(L, -1))  /* non-nil return? */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */\n  lua_getfield(L, 2, name);\n  if (lua_touserdata(L, -1) == sentinel) {   /* module did not set a value? */\n    lua_pushboolean(L, 1);  /* use true as result */\n    lua_pushvalue(L, -1);  /* extra copy to be returned */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = true */\n  }\n  lj_lib_checkfpu(L);\n  return 1;\n}\n\n/* ------------------------------------------------------------------------ */\n\nstatic void setfenv(lua_State *L)\n{\n  lua_Debug ar;\n  if (lua_getstack(L, 1, &ar) == 0 ||\n      lua_getinfo(L, \"f\", &ar) == 0 ||  /* get calling function */\n      lua_iscfunction(L, -1))\n    luaL_error(L, LUA_QL(\"module\") \" not called from a Lua function\");\n  lua_pushvalue(L, -2);\n  lua_setfenv(L, -2);\n  lua_pop(L, 1);\n}\n\nstatic void dooptions(lua_State *L, int n)\n{\n  int i;\n  for (i = 2; i <= n; i++) {\n    lua_pushvalue(L, i);  /* get option (a function) */\n    lua_pushvalue(L, -2);  /* module */\n    lua_call(L, 1, 0);\n  }\n}\n\nstatic void modinit(lua_State *L, const char *modname)\n{\n  const char *dot;\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -2, \"_M\");  /* module._M = module */\n  lua_pushstring(L, modname);\n  lua_setfield(L, -2, \"_NAME\");\n  dot = strrchr(modname, '.');  /* look for last dot in module name */\n  if (dot == NULL) dot = modname; else dot++;\n  /* set _PACKAGE as package name (full module name minus last part) */\n  lua_pushlstring(L, modname, (size_t)(dot - modname));\n  lua_setfield(L, -2, \"_PACKAGE\");\n}\n\nstatic int lj_cf_package_module(lua_State *L)\n{\n  const char *modname = luaL_checkstring(L, 1);\n  int loaded = lua_gettop(L) + 1;  /* index of _LOADED table */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, loaded, modname);  /* get _LOADED[modname] */\n  if (!lua_istable(L, -1)) {  /* not found? */\n    lua_pop(L, 1);  /* remove previous result */\n    /* try global variable (and create one if it does not exist) */\n    if (luaL_findtable(L, LUA_GLOBALSINDEX, modname, 1) != NULL)\n      lj_err_callerv(L, LJ_ERR_BADMODN, modname);\n    lua_pushvalue(L, -1);\n    lua_setfield(L, loaded, modname);  /* _LOADED[modname] = new table */\n  }\n  /* check whether table already has a _NAME field */\n  lua_getfield(L, -1, \"_NAME\");\n  if (!lua_isnil(L, -1)) {  /* is table an initialized module? */\n    lua_pop(L, 1);\n  } else {  /* no; initialize it */\n    lua_pop(L, 1);\n    modinit(L, modname);\n  }\n  lua_pushvalue(L, -1);\n  setfenv(L);\n  dooptions(L, loaded - 1);\n  return 0;\n}\n\nstatic int lj_cf_package_seeall(lua_State *L)\n{\n  luaL_checktype(L, 1, LUA_TTABLE);\n  if (!lua_getmetatable(L, 1)) {\n    lua_createtable(L, 0, 1); /* create new metatable */\n    lua_pushvalue(L, -1);\n    lua_setmetatable(L, 1);\n  }\n  lua_pushvalue(L, LUA_GLOBALSINDEX);\n  lua_setfield(L, -2, \"__index\");  /* mt.__index = _G */\n  return 0;\n}\n\n/* ------------------------------------------------------------------------ */\n\n#define AUXMARK\t\t\"\\1\"\n\nstatic void setpath(lua_State *L, const char *fieldname, const char *envname,\n\t\t    const char *def, int noenv)\n{\n#if LJ_TARGET_CONSOLE\n  const char *path = NULL;\n  UNUSED(envname);\n#else\n  const char *path = getenv(envname);\n#endif\n  if (path == NULL || noenv) {\n    lua_pushstring(L, def);\n  } else {\n    path = luaL_gsub(L, path, LUA_PATHSEP LUA_PATHSEP,\n\t\t\t      LUA_PATHSEP AUXMARK LUA_PATHSEP);\n    luaL_gsub(L, path, AUXMARK, def);\n    lua_remove(L, -2);\n  }\n  setprogdir(L);\n  lua_setfield(L, -2, fieldname);\n}\n\nstatic const luaL_Reg package_lib[] = {\n  { \"loadlib\",\tlj_cf_package_loadlib },\n  { \"searchpath\",  lj_cf_package_searchpath },\n  { \"seeall\",\tlj_cf_package_seeall },\n  { NULL, NULL }\n};\n\nstatic const luaL_Reg package_global[] = {\n  { \"module\",\tlj_cf_package_module },\n  { \"require\",\tlj_cf_package_require },\n  { NULL, NULL }\n};\n\nstatic const lua_CFunction package_loaders[] =\n{\n  lj_cf_package_loader_preload,\n  lj_cf_package_loader_lua,\n  lj_cf_package_loader_c,\n  lj_cf_package_loader_croot,\n  NULL\n};\n\nLUALIB_API int luaopen_package(lua_State *L)\n{\n  int i;\n  int noenv;\n  luaL_newmetatable(L, \"_LOADLIB\");\n  lj_lib_pushcf(L, lj_cf_package_unloadlib, 1);\n  lua_setfield(L, -2, \"__gc\");\n  luaL_register(L, LUA_LOADLIBNAME, package_lib);\n  lua_pushvalue(L, -1);\n  lua_replace(L, LUA_ENVIRONINDEX);\n  lua_createtable(L, sizeof(package_loaders)/sizeof(package_loaders[0])-1, 0);\n  for (i = 0; package_loaders[i] != NULL; i++) {\n    lj_lib_pushcf(L, package_loaders[i], 1);\n    lua_rawseti(L, -2, i+1);\n  }\n  lua_setfield(L, -2, \"loaders\");\n  lua_getfield(L, LUA_REGISTRYINDEX, \"LUA_NOENV\");\n  noenv = lua_toboolean(L, -1);\n  lua_pop(L, 1);\n  setpath(L, \"path\", LUA_PATH, LUA_PATH_DEFAULT, noenv);\n  setpath(L, \"cpath\", LUA_CPATH, LUA_CPATH_DEFAULT, noenv);\n  lua_pushliteral(L, LUA_PATH_CONFIG);\n  lua_setfield(L, -2, \"config\");\n  luaL_findtable(L, LUA_REGISTRYINDEX, \"_LOADED\", 16);\n  lua_setfield(L, -2, \"loaded\");\n  luaL_findtable(L, LUA_REGISTRYINDEX, \"_PRELOAD\", 4);\n  lua_setfield(L, -2, \"preload\");\n  lua_pushvalue(L, LUA_GLOBALSINDEX);\n  luaL_register(L, NULL, package_global);\n  lua_pop(L, 1);\n  return 1;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-wrk-3.1.2-v6kya4mjms4qhhzqnfeqfrs4zjuixhrq/spack-src/deps/luajit/src/lj_clib.c": "/*\n** FFI C library loader.\n** Copyright (C) 2005-2014 Mike Pall. See Copyright Notice in luajit.h\n*/\n\n#include \"lj_obj.h\"\n\n#if LJ_HASFFI\n\n#include \"lj_gc.h\"\n#include \"lj_err.h\"\n#include \"lj_tab.h\"\n#include \"lj_str.h\"\n#include \"lj_udata.h\"\n#include \"lj_ctype.h\"\n#include \"lj_cconv.h\"\n#include \"lj_cdata.h\"\n#include \"lj_clib.h\"\n\n/* -- OS-specific functions ----------------------------------------------- */\n\n#if LJ_TARGET_DLOPEN\n\n#include <dlfcn.h>\n#include <stdio.h>\n\n#if defined(RTLD_DEFAULT)\n#define CLIB_DEFHANDLE\tRTLD_DEFAULT\n#elif LJ_TARGET_OSX || LJ_TARGET_BSD\n#define CLIB_DEFHANDLE\t((void *)(intptr_t)-2)\n#else\n#define CLIB_DEFHANDLE\tNULL\n#endif\n\nLJ_NORET LJ_NOINLINE static void clib_error_(lua_State *L)\n{\n  lj_err_callermsg(L, dlerror());\n}\n\n#define clib_error(L, fmt, name)\tclib_error_(L)\n\n#if defined(__CYGWIN__)\n#define CLIB_SOPREFIX\t\"cyg\"\n#else\n#define CLIB_SOPREFIX\t\"lib\"\n#endif\n\n#if LJ_TARGET_OSX\n#define CLIB_SOEXT\t\"%s.dylib\"\n#elif defined(__CYGWIN__)\n#define CLIB_SOEXT\t\"%s.dll\"\n#else\n#define CLIB_SOEXT\t\"%s.so\"\n#endif\n\nstatic const char *clib_extname(lua_State *L, const char *name)\n{\n  if (!strchr(name, '/')\n#ifdef __CYGWIN__\n      && !strchr(name, '\\\\')\n#endif\n     ) {\n    if (!strchr(name, '.')) {\n      name = lj_str_pushf(L, CLIB_SOEXT, name);\n      L->top--;\n#ifdef __CYGWIN__\n    } else {\n      return name;\n#endif\n    }\n    if (!(name[0] == CLIB_SOPREFIX[0] && name[1] == CLIB_SOPREFIX[1] &&\n\t  name[2] == CLIB_SOPREFIX[2])) {\n      name = lj_str_pushf(L, CLIB_SOPREFIX \"%s\", name);\n      L->top--;\n    }\n  }\n  return name;\n}\n\n/* Check for a recognized ld script line. */\nstatic const char *clib_check_lds(lua_State *L, const char *buf)\n{\n  char *p, *e;\n  if ((!strncmp(buf, \"GROUP\", 5) || !strncmp(buf, \"INPUT\", 5)) &&\n      (p = strchr(buf, '('))) {\n    while (*++p == ' ') ;\n    for (e = p; *e && *e != ' ' && *e != ')'; e++) ;\n    return strdata(lj_str_new(L, p, e-p));\n  }\n  return NULL;\n}\n\n/* Quick and dirty solution to resolve shared library name from ld script. */\nstatic const char *clib_resolve_lds(lua_State *L, const char *name)\n{\n  FILE *fp = fopen(name, \"r\");\n  const char *p = NULL;\n  if (fp) {\n    char buf[256];\n    if (fgets(buf, sizeof(buf), fp)) {\n      if (!strncmp(buf, \"/* GNU ld script\", 16)) {  /* ld script magic? */\n\twhile (fgets(buf, sizeof(buf), fp)) {  /* Check all lines. */\n\t  p = clib_check_lds(L, buf);\n\t  if (p) break;\n\t}\n      } else {  /* Otherwise check only the first line. */\n\tp = clib_check_lds(L, buf);\n      }\n    }\n    fclose(fp);\n  }\n  return p;\n}\n\nstatic void *clib_loadlib(lua_State *L, const char *name, int global)\n{\n  void *h = dlopen(clib_extname(L, name),\n\t\t   RTLD_LAZY | (global?RTLD_GLOBAL:RTLD_LOCAL));\n  if (!h) {\n    const char *e, *err = dlerror();\n    if (*err == '/' && (e = strchr(err, ':')) &&\n\t(name = clib_resolve_lds(L, strdata(lj_str_new(L, err, e-err))))) {\n      h = dlopen(name, RTLD_LAZY | (global?RTLD_GLOBAL:RTLD_LOCAL));\n      if (h) return h;\n      err = dlerror();\n    }\n    lj_err_callermsg(L, err);\n  }\n  return h;\n}\n\nstatic void clib_unloadlib(CLibrary *cl)\n{\n  if (cl->handle && cl->handle != CLIB_DEFHANDLE)\n    dlclose(cl->handle);\n}\n\nstatic void *clib_getsym(CLibrary *cl, const char *name)\n{\n  void *p = dlsym(cl->handle, name);\n  return p;\n}\n\n#elif LJ_TARGET_WINDOWS\n\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n\n#ifndef GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS\n#define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS\t4\n#define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT\t2\nBOOL WINAPI GetModuleHandleExA(DWORD, LPCSTR, HMODULE*);\n#endif\n\n#define CLIB_DEFHANDLE\t((void *)-1)\n\n/* Default libraries. */\nenum {\n  CLIB_HANDLE_EXE,\n  CLIB_HANDLE_DLL,\n  CLIB_HANDLE_CRT,\n  CLIB_HANDLE_KERNEL32,\n  CLIB_HANDLE_USER32,\n  CLIB_HANDLE_GDI32,\n  CLIB_HANDLE_MAX\n};\n\nstatic void *clib_def_handle[CLIB_HANDLE_MAX];\n\nLJ_NORET LJ_NOINLINE static void clib_error(lua_State *L, const char *fmt,\n\t\t\t\t\t    const char *name)\n{\n  DWORD err = GetLastError();\n  char buf[128];\n  if (!FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t      NULL, err, 0, buf, sizeof(buf), NULL))\n    buf[0] = '\\0';\n  lj_err_callermsg(L, lj_str_pushf(L, fmt, name, buf));\n}\n\nstatic int clib_needext(const char *s)\n{\n  while (*s) {\n    if (*s == '/' || *s == '\\\\' || *s == '.') return 0;\n    s++;\n  }\n  return 1;\n}\n\nstatic const char *clib_extname(lua_State *L, const char *name)\n{\n  if (clib_needext(name)) {\n    name = lj_str_pushf(L, \"%s.dll\", name);\n    L->top--;\n  }\n  return name;\n}\n\nstatic void *clib_loadlib(lua_State *L, const char *name, int global)\n{\n  DWORD oldwerr = GetLastError();\n  void *h = (void *)LoadLibraryA(clib_extname(L, name));\n  if (!h) clib_error(L, \"cannot load module \" LUA_QS \": %s\", name);\n  SetLastError(oldwerr);\n  UNUSED(global);\n  return h;\n}\n\nstatic void clib_unloadlib(CLibrary *cl)\n{\n  if (cl->handle == CLIB_DEFHANDLE) {\n    MSize i;\n    for (i = CLIB_HANDLE_KERNEL32; i < CLIB_HANDLE_MAX; i++) {\n      void *h = clib_def_handle[i];\n      if (h) {\n\tclib_def_handle[i] = NULL;\n\tFreeLibrary((HINSTANCE)h);\n      }\n    }\n  } else if (cl->handle) {\n    FreeLibrary((HINSTANCE)cl->handle);\n  }\n}\n\nstatic void *clib_getsym(CLibrary *cl, const char *name)\n{\n  void *p = NULL;\n  if (cl->handle == CLIB_DEFHANDLE) {  /* Search default libraries. */\n    MSize i;\n    for (i = 0; i < CLIB_HANDLE_MAX; i++) {\n      HINSTANCE h = (HINSTANCE)clib_def_handle[i];\n      if (!(void *)h) {  /* Resolve default library handles (once). */\n\tswitch (i) {\n\tcase CLIB_HANDLE_EXE: GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, NULL, &h); break;\n\tcase CLIB_HANDLE_DLL:\n\t  GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS|GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n\t\t\t     (const char *)clib_def_handle, &h);\n\t  break;\n\tcase CLIB_HANDLE_CRT:\n\t  GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS|GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n\t\t\t     (const char *)&_fmode, &h);\n\t  break;\n\tcase CLIB_HANDLE_KERNEL32: h = LoadLibraryA(\"kernel32.dll\"); break;\n\tcase CLIB_HANDLE_USER32: h = LoadLibraryA(\"user32.dll\"); break;\n\tcase CLIB_HANDLE_GDI32: h = LoadLibraryA(\"gdi32.dll\"); break;\n\t}\n\tif (!h) continue;\n\tclib_def_handle[i] = (void *)h;\n      }\n      p = (void *)GetProcAddress(h, name);\n      if (p) break;\n    }\n  } else {\n    p = (void *)GetProcAddress((HINSTANCE)cl->handle, name);\n  }\n  return p;\n}\n\n#else\n\n#define CLIB_DEFHANDLE\tNULL\n\nLJ_NORET LJ_NOINLINE static void clib_error(lua_State *L, const char *fmt,\n\t\t\t\t\t    const char *name)\n{\n  lj_err_callermsg(L, lj_str_pushf(L, fmt, name, \"no support for this OS\"));\n}\n\nstatic void *clib_loadlib(lua_State *L, const char *name, int global)\n{\n  lj_err_callermsg(L, \"no support for loading dynamic libraries for this OS\");\n  UNUSED(name); UNUSED(global);\n  return NULL;\n}\n\nstatic void clib_unloadlib(CLibrary *cl)\n{\n  UNUSED(cl);\n}\n\nstatic void *clib_getsym(CLibrary *cl, const char *name)\n{\n  UNUSED(cl); UNUSED(name);\n  return NULL;\n}\n\n#endif\n\n/* -- C library indexing -------------------------------------------------- */\n\n#if LJ_TARGET_X86 && LJ_ABI_WIN\n/* Compute argument size for fastcall/stdcall functions. */\nstatic CTSize clib_func_argsize(CTState *cts, CType *ct)\n{\n  CTSize n = 0;\n  while (ct->sib) {\n    CType *d;\n    ct = ctype_get(cts, ct->sib);\n    if (ctype_isfield(ct->info)) {\n      d = ctype_rawchild(cts, ct);\n      n += ((d->size + 3) & ~3);\n    }\n  }\n  return n;\n}\n#endif\n\n/* Get redirected or mangled external symbol. */\nstatic const char *clib_extsym(CTState *cts, CType *ct, GCstr *name)\n{\n  if (ct->sib) {\n    CType *ctf = ctype_get(cts, ct->sib);\n    if (ctype_isxattrib(ctf->info, CTA_REDIR))\n      return strdata(gco2str(gcref(ctf->name)));\n  }\n  return strdata(name);\n}\n\n/* Index a C library by name. */\nTValue *lj_clib_index(lua_State *L, CLibrary *cl, GCstr *name)\n{\n  TValue *tv = lj_tab_setstr(L, cl->cache, name);\n  if (LJ_UNLIKELY(tvisnil(tv))) {\n    CTState *cts = ctype_cts(L);\n    CType *ct;\n    CTypeID id = lj_ctype_getname(cts, &ct, name, CLNS_INDEX);\n    if (!id)\n      lj_err_callerv(L, LJ_ERR_FFI_NODECL, strdata(name));\n    if (ctype_isconstval(ct->info)) {\n      CType *ctt = ctype_child(cts, ct);\n      lua_assert(ctype_isinteger(ctt->info) && ctt->size <= 4);\n      if ((ctt->info & CTF_UNSIGNED) && (int32_t)ct->size < 0)\n\tsetnumV(tv, (lua_Number)(uint32_t)ct->size);\n      else\n\tsetintV(tv, (int32_t)ct->size);\n    } else {\n      const char *sym = clib_extsym(cts, ct, name);\n#if LJ_TARGET_WINDOWS\n      DWORD oldwerr = GetLastError();\n#endif\n      void *p = clib_getsym(cl, sym);\n      GCcdata *cd;\n      lua_assert(ctype_isfunc(ct->info) || ctype_isextern(ct->info));\n#if LJ_TARGET_X86 && LJ_ABI_WIN\n      /* Retry with decorated name for fastcall/stdcall functions. */\n      if (!p && ctype_isfunc(ct->info)) {\n\tCTInfo cconv = ctype_cconv(ct->info);\n\tif (cconv == CTCC_FASTCALL || cconv == CTCC_STDCALL) {\n\t  CTSize sz = clib_func_argsize(cts, ct);\n\t  const char *symd = lj_str_pushf(L,\n\t\t\t       cconv == CTCC_FASTCALL ? \"@%s@%d\" : \"_%s@%d\",\n\t\t\t       sym, sz);\n\t  L->top--;\n\t  p = clib_getsym(cl, symd);\n\t}\n      }\n#endif\n      if (!p)\n\tclib_error(L, \"cannot resolve symbol \" LUA_QS \": %s\", sym);\n#if LJ_TARGET_WINDOWS\n      SetLastError(oldwerr);\n#endif\n      cd = lj_cdata_new(cts, id, CTSIZE_PTR);\n      *(void **)cdataptr(cd) = p;\n      setcdataV(L, tv, cd);\n    }\n  }\n  return tv;\n}\n\n/* -- C library management ------------------------------------------------ */\n\n/* Create a new CLibrary object and push it on the stack. */\nstatic CLibrary *clib_new(lua_State *L, GCtab *mt)\n{\n  GCtab *t = lj_tab_new(L, 0, 0);\n  GCudata *ud = lj_udata_new(L, sizeof(CLibrary), t);\n  CLibrary *cl = (CLibrary *)uddata(ud);\n  cl->cache = t;\n  ud->udtype = UDTYPE_FFI_CLIB;\n  /* NOBARRIER: The GCudata is new (marked white). */\n  setgcref(ud->metatable, obj2gco(mt));\n  setudataV(L, L->top++, ud);\n  return cl;\n}\n\n/* Load a C library. */\nvoid lj_clib_load(lua_State *L, GCtab *mt, GCstr *name, int global)\n{\n  void *handle = clib_loadlib(L, strdata(name), global);\n  CLibrary *cl = clib_new(L, mt);\n  cl->handle = handle;\n}\n\n/* Unload a C library. */\nvoid lj_clib_unload(CLibrary *cl)\n{\n  clib_unloadlib(cl);\n  cl->handle = NULL;\n}\n\n/* Create the default C library object. */\nvoid lj_clib_default(lua_State *L, GCtab *mt)\n{\n  CLibrary *cl = clib_new(L, mt);\n  cl->handle = CLIB_DEFHANDLE;\n}\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-wrk-3.1.2-v6kya4mjms4qhhzqnfeqfrs4zjuixhrq/spack-src/deps/luajit/doc/img/contact.png"
    ],
    "total_files": 222
}