{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-pillow-simd-6.2.2.post1-2x3n5gloinbxykprpj47agf3tnwv33nc/spack-src/src/_imagingft.c": "/*\n * PIL FreeType Driver\n *\n * a FreeType 2.X driver for PIL\n *\n * history:\n * 2001-02-17 fl  Created (based on old experimental freetype 1.0 code)\n * 2001-04-18 fl  Fixed some egcs compiler nits\n * 2002-11-08 fl  Added unicode support; more font metrics, etc\n * 2003-05-20 fl  Fixed compilation under 1.5.2 and newer non-unicode builds\n * 2003-09-27 fl  Added charmap encoding support\n * 2004-05-15 fl  Fixed compilation for FreeType 2.1.8\n * 2004-09-10 fl  Added support for monochrome bitmaps\n * 2006-06-18 fl  Fixed glyph bearing calculation\n * 2007-12-23 fl  Fixed crash in family/style attribute fetch\n * 2008-01-02 fl  Handle Unicode filenames properly\n *\n * Copyright (c) 1998-2007 by Secret Labs AB\n */\n\n#define PY_SSIZE_T_CLEAN\n#include \"Python.h\"\n#include \"Imaging.h\"\n\n#include <ft2build.h>\n#include FT_FREETYPE_H\n#include FT_GLYPH_H\n#include FT_STROKER_H\n#include FT_MULTIPLE_MASTERS_H\n#include FT_SFNT_NAMES_H\n\n#define KEEP_PY_UNICODE\n#include \"py3.h\"\n\n#if !defined(_MSC_VER)\n#include <dlfcn.h>\n#endif\n\n#if !defined(FT_LOAD_TARGET_MONO)\n#define FT_LOAD_TARGET_MONO  FT_LOAD_MONOCHROME\n#endif\n\n/* -------------------------------------------------------------------- */\n/* error table */\n\n#undef FTERRORS_H\n#undef __FTERRORS_H__\n\n#define FT_ERRORDEF( e, v, s )  { e, s },\n#define FT_ERROR_START_LIST  {\n#define FT_ERROR_END_LIST    { 0, 0 } };\n\n#include <raqm.h>\n\n#define LAYOUT_FALLBACK 0\n#define LAYOUT_RAQM 1\n\ntypedef struct\n{\n  int index, x_offset, x_advance, y_offset, y_advance;\n  unsigned int cluster;\n} GlyphInfo;\n\nstruct {\n    int code;\n    const char* message;\n} ft_errors[] =\n\n#include FT_ERRORS_H\n\n/* -------------------------------------------------------------------- */\n/* font objects */\n\nstatic FT_Library library;\n\ntypedef struct {\n    PyObject_HEAD\n    FT_Face face;\n    unsigned char *font_bytes;\n    int layout_engine;\n} FontObject;\n\nstatic PyTypeObject Font_Type;\n\ntypedef bool (*t_raqm_version_atleast)(unsigned int major,\n                                       unsigned int minor,\n                                       unsigned int micro);\ntypedef raqm_t* (*t_raqm_create)(void);\ntypedef int (*t_raqm_set_text)(raqm_t         *rq,\n                               const uint32_t *text,\n                               size_t          len);\ntypedef bool (*t_raqm_set_text_utf8) (raqm_t     *rq,\n                                      const char *text,\n                                      size_t      len);\ntypedef bool (*t_raqm_set_par_direction) (raqm_t          *rq,\n                                          raqm_direction_t dir);\ntypedef bool (*t_raqm_set_language) (raqm_t     *rq,\n                                     const char *lang,\n                                     size_t      start,\n                                     size_t      len);\ntypedef bool (*t_raqm_add_font_feature)  (raqm_t     *rq,\n                                          const char *feature,\n                                          int         len);\ntypedef bool (*t_raqm_set_freetype_face) (raqm_t *rq,\n                                          FT_Face face);\ntypedef bool (*t_raqm_layout) (raqm_t *rq);\ntypedef raqm_glyph_t* (*t_raqm_get_glyphs) (raqm_t *rq,\n                                            size_t *length);\ntypedef raqm_glyph_t_01* (*t_raqm_get_glyphs_01) (raqm_t *rq,\n                                            size_t *length);\ntypedef void (*t_raqm_destroy) (raqm_t *rq);\n\ntypedef struct {\n    void* raqm;\n    int version;\n    t_raqm_version_atleast version_atleast;\n    t_raqm_create create;\n    t_raqm_set_text set_text;\n    t_raqm_set_text_utf8 set_text_utf8;\n    t_raqm_set_par_direction set_par_direction;\n    t_raqm_set_language set_language;\n    t_raqm_add_font_feature add_font_feature;\n    t_raqm_set_freetype_face set_freetype_face;\n    t_raqm_layout layout;\n    t_raqm_get_glyphs get_glyphs;\n    t_raqm_get_glyphs_01 get_glyphs_01;\n    t_raqm_destroy destroy;\n} p_raqm_func;\n\nstatic p_raqm_func p_raqm;\n\n\n/* round a 26.6 pixel coordinate to the nearest larger integer */\n#define PIXEL(x) ((((x)+63) & -64)>>6)\n\nstatic PyObject*\ngeterror(int code)\n{\n    int i;\n\n    for (i = 0; ft_errors[i].message; i++)\n        if (ft_errors[i].code == code) {\n            PyErr_SetString(PyExc_IOError, ft_errors[i].message);\n            return NULL;\n        }\n\n    PyErr_SetString(PyExc_IOError, \"unknown freetype error\");\n    return NULL;\n}\n\nstatic int\nsetraqm(void)\n{\n    /* set the static function pointers for dynamic raqm linking */\n    p_raqm.raqm = NULL;\n\n    /* Microsoft needs a totally different system */\n#if !defined(_MSC_VER)\n    p_raqm.raqm = dlopen(\"libraqm.so.0\", RTLD_LAZY);\n    if (!p_raqm.raqm) {\n        p_raqm.raqm = dlopen(\"libraqm.dylib\", RTLD_LAZY);\n    }\n#else\n    p_raqm.raqm = LoadLibrary(\"libraqm\");\n#endif\n\n    if (!p_raqm.raqm) {\n        return 1;\n    }\n\n#if !defined(_MSC_VER)\n    p_raqm.version_atleast = (t_raqm_version_atleast)dlsym(p_raqm.raqm, \"raqm_version_atleast\");\n    p_raqm.create = (t_raqm_create)dlsym(p_raqm.raqm, \"raqm_create\");\n    p_raqm.set_text = (t_raqm_set_text)dlsym(p_raqm.raqm, \"raqm_set_text\");\n    p_raqm.set_text_utf8 = (t_raqm_set_text_utf8)dlsym(p_raqm.raqm, \"raqm_set_text_utf8\");\n    p_raqm.set_par_direction = (t_raqm_set_par_direction)dlsym(p_raqm.raqm, \"raqm_set_par_direction\");\n    p_raqm.set_language = (t_raqm_set_language)dlsym(p_raqm.raqm, \"raqm_set_language\");\n    p_raqm.add_font_feature = (t_raqm_add_font_feature)dlsym(p_raqm.raqm, \"raqm_add_font_feature\");\n    p_raqm.set_freetype_face = (t_raqm_set_freetype_face)dlsym(p_raqm.raqm, \"raqm_set_freetype_face\");\n    p_raqm.layout = (t_raqm_layout)dlsym(p_raqm.raqm, \"raqm_layout\");\n    p_raqm.destroy = (t_raqm_destroy)dlsym(p_raqm.raqm, \"raqm_destroy\");\n    if(dlsym(p_raqm.raqm, \"raqm_index_to_position\")) {\n        p_raqm.get_glyphs = (t_raqm_get_glyphs)dlsym(p_raqm.raqm, \"raqm_get_glyphs\");\n        p_raqm.version = 2;\n    } else {\n        p_raqm.version = 1;\n        p_raqm.get_glyphs_01 = (t_raqm_get_glyphs_01)dlsym(p_raqm.raqm, \"raqm_get_glyphs\");\n    }\n    if (dlerror() ||\n        !(p_raqm.create &&\n          p_raqm.set_text &&\n          p_raqm.set_text_utf8 &&\n          p_raqm.set_par_direction &&\n          p_raqm.set_language &&\n          p_raqm.add_font_feature &&\n          p_raqm.set_freetype_face &&\n          p_raqm.layout &&\n          (p_raqm.get_glyphs || p_raqm.get_glyphs_01) &&\n          p_raqm.destroy)) {\n        dlclose(p_raqm.raqm);\n        p_raqm.raqm = NULL;\n        return 2;\n    }\n#else\n    p_raqm.version_atleast = (t_raqm_version_atleast)GetProcAddress(p_raqm.raqm, \"raqm_version_atleast\");\n    p_raqm.create = (t_raqm_create)GetProcAddress(p_raqm.raqm, \"raqm_create\");\n    p_raqm.set_text = (t_raqm_set_text)GetProcAddress(p_raqm.raqm, \"raqm_set_text\");\n    p_raqm.set_text_utf8 = (t_raqm_set_text_utf8)GetProcAddress(p_raqm.raqm, \"raqm_set_text_utf8\");\n    p_raqm.set_par_direction = (t_raqm_set_par_direction)GetProcAddress(p_raqm.raqm, \"raqm_set_par_direction\");\n    p_raqm.set_language = (t_raqm_set_language)GetProcAddress(p_raqm.raqm, \"raqm_set_language\");\n    p_raqm.add_font_feature = (t_raqm_add_font_feature)GetProcAddress(p_raqm.raqm, \"raqm_add_font_feature\");\n    p_raqm.set_freetype_face = (t_raqm_set_freetype_face)GetProcAddress(p_raqm.raqm, \"raqm_set_freetype_face\");\n    p_raqm.layout = (t_raqm_layout)GetProcAddress(p_raqm.raqm, \"raqm_layout\");\n    p_raqm.destroy = (t_raqm_destroy)GetProcAddress(p_raqm.raqm, \"raqm_destroy\");\n    if(GetProcAddress(p_raqm.raqm, \"raqm_index_to_position\")) {\n        p_raqm.get_glyphs = (t_raqm_get_glyphs)GetProcAddress(p_raqm.raqm, \"raqm_get_glyphs\");\n        p_raqm.version = 2;\n    } else {\n        p_raqm.version = 1;\n        p_raqm.get_glyphs_01 = (t_raqm_get_glyphs_01)GetProcAddress(p_raqm.raqm, \"raqm_get_glyphs\");\n    }\n    if (!(p_raqm.create &&\n          p_raqm.set_text &&\n          p_raqm.set_text_utf8 &&\n          p_raqm.set_par_direction &&\n          p_raqm.set_language &&\n          p_raqm.add_font_feature &&\n          p_raqm.set_freetype_face &&\n          p_raqm.layout &&\n          (p_raqm.get_glyphs || p_raqm.get_glyphs_01) &&\n          p_raqm.destroy)) {\n        FreeLibrary(p_raqm.raqm);\n        p_raqm.raqm = NULL;\n        return 2;\n    }\n#endif\n\n    return 0;\n}\n\nstatic PyObject*\ngetfont(PyObject* self_, PyObject* args, PyObject* kw)\n{\n    /* create a font object from a file name and a size (in pixels) */\n\n    FontObject* self;\n    int error = 0;\n\n    char* filename = NULL;\n    Py_ssize_t size;\n    Py_ssize_t index = 0;\n    Py_ssize_t layout_engine = 0;\n    unsigned char* encoding;\n    unsigned char* font_bytes;\n    Py_ssize_t font_bytes_size = 0;\n    static char* kwlist[] = {\n        \"filename\", \"size\", \"index\", \"encoding\", \"font_bytes\",\n        \"layout_engine\", NULL\n    };\n\n    if (!library) {\n        PyErr_SetString(\n            PyExc_IOError,\n            \"failed to initialize FreeType library\"\n            );\n        return NULL;\n    }\n\n    if (!PyArg_ParseTupleAndKeywords(args, kw, \"etn|ns\"PY_ARG_BYTES_LENGTH\"n\",\n                                     kwlist,\n                                     Py_FileSystemDefaultEncoding, &filename,\n                                     &size, &index, &encoding, &font_bytes,\n                                     &font_bytes_size, &layout_engine)) {\n        return NULL;\n    }\n\n    self = PyObject_New(FontObject, &Font_Type);\n    if (!self) {\n        if (filename)\n            PyMem_Free(filename);\n        return NULL;\n    }\n\n    self->face = NULL;\n    self->layout_engine = layout_engine;\n\n    if (filename && font_bytes_size <= 0) {\n        self->font_bytes = NULL;\n        error = FT_New_Face(library, filename, index, &self->face);\n    } else {\n        /* need to have allocated storage for font_bytes for the life of the object.*/\n        /* Don't free this before FT_Done_Face */\n        self->font_bytes = PyMem_Malloc(font_bytes_size);\n        if (!self->font_bytes) {\n            error = 65; // Out of Memory in Freetype.\n        }\n        if (!error) {\n            memcpy(self->font_bytes, font_bytes, (size_t)font_bytes_size);\n            error = FT_New_Memory_Face(library, (FT_Byte*)self->font_bytes,\n                                       font_bytes_size, index, &self->face);\n        }\n    }\n\n    if (!error)\n        error = FT_Set_Pixel_Sizes(self->face, 0, size);\n\n    if (!error && encoding && strlen((char*) encoding) == 4) {\n        FT_Encoding encoding_tag = FT_MAKE_TAG(\n            encoding[0], encoding[1], encoding[2], encoding[3]\n            );\n        error = FT_Select_Charmap(self->face, encoding_tag);\n    }\n    if (filename)\n      PyMem_Free(filename);\n\n    if (error) {\n        if (self->font_bytes) {\n            PyMem_Free(self->font_bytes);\n            self->font_bytes = NULL;\n        }\n        Py_DECREF(self);\n        return geterror(error);\n    }\n\n    return (PyObject*) self;\n}\n\nstatic int\nfont_getchar(PyObject* string, int index, FT_ULong* char_out)\n{\n#if (PY_VERSION_HEX < 0x03030000) || (defined(PYPY_VERSION_NUM))\n    if (PyUnicode_Check(string)) {\n        Py_UNICODE* p = PyUnicode_AS_UNICODE(string);\n        int size = PyUnicode_GET_SIZE(string);\n        if (index >= size)\n            return 0;\n        *char_out = p[index];\n        return 1;\n    }\n#if PY_VERSION_HEX < 0x03000000\n    if (PyString_Check(string)) {\n        unsigned char* p = (unsigned char*) PyString_AS_STRING(string);\n        int size = PyString_GET_SIZE(string);\n        if (index >= size)\n            return 0;\n        *char_out = (unsigned char) p[index];\n        return 1;\n    }\n#endif\n#else\n    if (PyUnicode_Check(string)) {\n        if (index >= PyUnicode_GET_LENGTH(string))\n            return 0;\n        *char_out = PyUnicode_READ_CHAR(string, index);\n        return 1;\n    }\n#endif\n\n    return 0;\n}\n\nstatic size_t\ntext_layout_raqm(PyObject* string, FontObject* self, const char* dir, PyObject *features,\n                 const char* lang, GlyphInfo **glyph_info, int mask)\n{\n    size_t i = 0, count = 0, start = 0;\n    raqm_t *rq;\n    raqm_glyph_t *glyphs = NULL;\n    raqm_glyph_t_01 *glyphs_01 = NULL;\n    raqm_direction_t direction;\n\n    rq = (*p_raqm.create)();\n    if (rq == NULL) {\n        PyErr_SetString(PyExc_ValueError, \"raqm_create() failed.\");\n        goto failed;\n    }\n\n#if (PY_VERSION_HEX < 0x03030000) || (defined(PYPY_VERSION_NUM))\n    if (PyUnicode_Check(string)) {\n        Py_UNICODE *text = PyUnicode_AS_UNICODE(string);\n        Py_ssize_t size = PyUnicode_GET_SIZE(string);\n        if (! size) {\n            /* return 0 and clean up, no glyphs==no size,\n               and raqm fails with empty strings */\n            goto failed;\n        }\n        if (!(*p_raqm.set_text)(rq, (const uint32_t *)(text), size)) {\n            PyErr_SetString(PyExc_ValueError, \"raqm_set_text() failed\");\n            goto failed;\n        }\n        if (lang) {\n            if (!(*p_raqm.set_language)(rq, lang, start, size)) {\n                PyErr_SetString(PyExc_ValueError, \"raqm_set_language() failed\");\n                goto failed;\n            }\n        }\n    }\n#if PY_VERSION_HEX < 0x03000000\n    else if (PyString_Check(string)) {\n        char *text = PyString_AS_STRING(string);\n        int size = PyString_GET_SIZE(string);\n        if (! size) {\n            goto failed;\n        }\n        if (!(*p_raqm.set_text_utf8)(rq, text, size)) {\n            PyErr_SetString(PyExc_ValueError, \"raqm_set_text_utf8() failed\");\n            goto failed;\n        }\n        if (lang) {\n            if (!(*p_raqm.set_language)(rq, lang, start, size)) {\n                PyErr_SetString(PyExc_ValueError, \"raqm_set_language() failed\");\n                goto failed;\n            }\n        }\n    }\n#endif\n#else\n    if (PyUnicode_Check(string)) {\n        Py_UCS4 *text = PyUnicode_AsUCS4Copy(string);\n        Py_ssize_t size = PyUnicode_GET_LENGTH(string);\n        if (!text || !size) {\n            /* return 0 and clean up, no glyphs==no size,\n               and raqm fails with empty strings */\n            goto failed;\n        }\n        int set_text = (*p_raqm.set_text)(rq, (const uint32_t *)(text), size);\n        PyMem_Free(text);\n        if (!set_text) {\n            PyErr_SetString(PyExc_ValueError, \"raqm_set_text() failed\");\n            goto failed;\n        }\n        if (lang) {\n            if (!(*p_raqm.set_language)(rq, lang, start, size)) {\n                PyErr_SetString(PyExc_ValueError, \"raqm_set_language() failed\");\n                goto failed;\n            }\n        }\n    }\n#endif\n    else {\n        PyErr_SetString(PyExc_TypeError, \"expected string\");\n        goto failed;\n    }\n\n    direction = RAQM_DIRECTION_DEFAULT;\n    if (dir) {\n        if (strcmp(dir, \"rtl\") == 0)\n            direction = RAQM_DIRECTION_RTL;\n        else if (strcmp(dir, \"ltr\") == 0)\n            direction = RAQM_DIRECTION_LTR;\n        else if (strcmp(dir, \"ttb\") == 0) {\n            direction = RAQM_DIRECTION_TTB;\n            if (p_raqm.version_atleast == NULL || !(*p_raqm.version_atleast)(0, 7, 0)) {\n                PyErr_SetString(PyExc_ValueError, \"libraqm 0.7 or greater required for 'ttb' direction\");\n                goto failed;\n            }\n        } else {\n            PyErr_SetString(PyExc_ValueError, \"direction must be either 'rtl', 'ltr' or 'ttb'\");\n            goto failed;\n        }\n    }\n\n    if (!(*p_raqm.set_par_direction)(rq, direction)) {\n        PyErr_SetString(PyExc_ValueError, \"raqm_set_par_direction() failed\");\n        goto failed;\n    }\n\n    if (features != Py_None) {\n        int j, len;\n        PyObject *seq = PySequence_Fast(features, \"expected a sequence\");\n        if (!seq) {\n            goto failed;\n        }\n\n        len = PySequence_Size(seq);\n        for (j = 0; j < len; j++) {\n            PyObject *item = PySequence_Fast_GET_ITEM(seq, j);\n            char *feature = NULL;\n            Py_ssize_t size = 0;\n            PyObject *bytes;\n\n#if PY_VERSION_HEX >= 0x03000000\n            if (!PyUnicode_Check(item)) {\n#else\n            if (!PyUnicode_Check(item) && !PyString_Check(item)) {\n#endif\n                PyErr_SetString(PyExc_TypeError, \"expected a string\");\n                goto failed;\n            }\n\n            if (PyUnicode_Check(item)) {\n                bytes = PyUnicode_AsUTF8String(item);\n                if (bytes == NULL)\n                    goto failed;\n                feature = PyBytes_AS_STRING(bytes);\n                size = PyBytes_GET_SIZE(bytes);\n            }\n#if PY_VERSION_HEX < 0x03000000\n            else {\n                feature = PyString_AsString(item);\n                size = PyString_GET_SIZE(item);\n            }\n#endif\n            if (!(*p_raqm.add_font_feature)(rq, feature, size)) {\n                PyErr_SetString(PyExc_ValueError, \"raqm_add_font_feature() failed\");\n                goto failed;\n            }\n        }\n    }\n\n    if (!(*p_raqm.set_freetype_face)(rq, self->face)) {\n        PyErr_SetString(PyExc_RuntimeError, \"raqm_set_freetype_face() failed.\");\n        goto failed;\n    }\n\n    if (!(*p_raqm.layout)(rq)) {\n        PyErr_SetString(PyExc_RuntimeError, \"raqm_layout() failed.\");\n        goto failed;\n    }\n\n    if (p_raqm.version == 1) {\n        glyphs_01 = (*p_raqm.get_glyphs_01)(rq, &count);\n        if (glyphs_01 == NULL) {\n            PyErr_SetString(PyExc_ValueError, \"raqm_get_glyphs() failed.\");\n            count = 0;\n            goto failed;\n        }\n    } else { /* version == 2 */\n        glyphs = (*p_raqm.get_glyphs)(rq, &count);\n        if (glyphs == NULL) {\n            PyErr_SetString(PyExc_ValueError, \"raqm_get_glyphs() failed.\");\n            count = 0;\n            goto failed;\n        }\n    }\n\n    (*glyph_info) = PyMem_New(GlyphInfo, count);\n    if ((*glyph_info) == NULL) {\n        PyErr_SetString(PyExc_MemoryError, \"PyMem_New() failed\");\n        count = 0;\n        goto failed;\n    }\n\n    if (p_raqm.version == 1) {\n        for (i = 0; i < count; i++) {\n            (*glyph_info)[i].index = glyphs_01[i].index;\n            (*glyph_info)[i].x_offset = glyphs_01[i].x_offset;\n            (*glyph_info)[i].x_advance = glyphs_01[i].x_advance;\n            (*glyph_info)[i].y_offset = glyphs_01[i].y_offset;\n            (*glyph_info)[i].y_advance = glyphs_01[i].y_advance;\n            (*glyph_info)[i].cluster = glyphs_01[i].cluster;\n        }\n    } else {\n        for (i = 0; i < count; i++) {\n            (*glyph_info)[i].index = glyphs[i].index;\n            (*glyph_info)[i].x_offset = glyphs[i].x_offset;\n            (*glyph_info)[i].x_advance = glyphs[i].x_advance;\n            (*glyph_info)[i].y_offset = glyphs[i].y_offset;\n            (*glyph_info)[i].y_advance = glyphs[i].y_advance;\n            (*glyph_info)[i].cluster = glyphs[i].cluster;\n        }\n    }\n\nfailed:\n    (*p_raqm.destroy)(rq);\n    return count;\n}\n\nstatic size_t\ntext_layout_fallback(PyObject* string, FontObject* self, const char* dir, PyObject *features,\n                     const char* lang, GlyphInfo **glyph_info, int mask)\n{\n    int error, load_flags;\n    FT_ULong ch;\n    Py_ssize_t count;\n    FT_GlyphSlot glyph;\n    FT_Bool kerning = FT_HAS_KERNING(self->face);\n    FT_UInt last_index = 0;\n    int i;\n\n    if (features != Py_None || dir != NULL || lang != NULL) {\n      PyErr_SetString(PyExc_KeyError, \"setting text direction, language or font features is not supported without libraqm\");\n    }\n#if PY_VERSION_HEX >= 0x03000000\n    if (!PyUnicode_Check(string)) {\n#else\n    if (!PyUnicode_Check(string) && !PyString_Check(string)) {\n#endif\n        PyErr_SetString(PyExc_TypeError, \"expected string\");\n        return 0;\n    }\n\n    count = 0;\n    while (font_getchar(string, count, &ch)) {\n       count++;\n    }\n    if (count == 0) {\n        return 0;\n    }\n\n    (*glyph_info) = PyMem_New(GlyphInfo, count);\n    if ((*glyph_info) == NULL) {\n        PyErr_SetString(PyExc_MemoryError, \"PyMem_New() failed\");\n        return 0;\n    }\n\n    load_flags = FT_LOAD_RENDER|FT_LOAD_NO_BITMAP;\n    if (mask) {\n        load_flags |= FT_LOAD_TARGET_MONO;\n    }\n    for (i = 0; font_getchar(string, i, &ch); i++) {\n        (*glyph_info)[i].index = FT_Get_Char_Index(self->face, ch);\n        error = FT_Load_Glyph(self->face, (*glyph_info)[i].index, load_flags);\n        if (error) {\n            geterror(error);\n            return 0;\n        }\n        glyph = self->face->glyph;\n        (*glyph_info)[i].x_offset=0;\n        (*glyph_info)[i].y_offset=0;\n        if (kerning && last_index && (*glyph_info)[i].index) {\n            FT_Vector delta;\n            if (FT_Get_Kerning(self->face, last_index, (*glyph_info)[i].index,\n                           ft_kerning_default,&delta) == 0)\n            (*glyph_info)[i-1].x_advance += PIXEL(delta.x);\n            (*glyph_info)[i-1].y_advance += PIXEL(delta.y);\n        }\n\n        (*glyph_info)[i].x_advance = glyph->metrics.horiAdvance;\n        (*glyph_info)[i].y_advance = glyph->metrics.vertAdvance;\n        last_index = (*glyph_info)[i].index;\n        (*glyph_info)[i].cluster = ch;\n    }\n    return count;\n}\n\nstatic size_t\ntext_layout(PyObject* string, FontObject* self, const char* dir, PyObject *features,\n            const char* lang, GlyphInfo **glyph_info, int mask)\n{\n    size_t count;\n\n    if (p_raqm.raqm && self->layout_engine == LAYOUT_RAQM) {\n        count = text_layout_raqm(string, self, dir, features, lang, glyph_info,  mask);\n    } else {\n        count = text_layout_fallback(string, self, dir, features, lang, glyph_info, mask);\n    }\n    return count;\n}\n\nstatic PyObject*\nfont_getsize(FontObject* self, PyObject* args)\n{\n    int x_position, x_max, x_min, y_max, y_min;\n    FT_Face face;\n    int xoffset, yoffset;\n    int horizontal_dir;\n    const char *dir = NULL;\n    const char *lang = NULL;\n    size_t i, count;\n    GlyphInfo *glyph_info = NULL;\n    PyObject *features = Py_None;\n\n    /* calculate size and bearing for a given string */\n\n    PyObject* string;\n    if (!PyArg_ParseTuple(args, \"O|zOz:getsize\", &string, &dir, &features, &lang))\n        return NULL;\n\n    count = text_layout(string, self, dir, features, lang, &glyph_info, 0);\n    if (PyErr_Occurred()) {\n        return NULL;\n    }\n\n    face = NULL;\n    xoffset = yoffset = 0;\n    x_position = x_max = x_min = y_max = y_min = 0;\n\n    horizontal_dir = dir && strcmp(dir, \"ttb\") == 0 ? 0 : 1;\n    for (i = 0; i < count; i++) {\n        int index, error, offset, x_advanced;\n        FT_BBox bbox;\n        FT_Glyph glyph;\n        face = self->face;\n        index = glyph_info[i].index;\n        /* Note: bitmap fonts within ttf fonts do not work, see #891/pr#960\n         *   Yifu Yu<root@jackyyf.com>, 2014-10-15\n         */\n        error = FT_Load_Glyph(face, index, FT_LOAD_DEFAULT|FT_LOAD_NO_BITMAP);\n        if (error)\n            return geterror(error);\n\n        if (i == 0) {\n            if (horizontal_dir) {\n                if (face->glyph->metrics.horiBearingX < 0) {\n                    xoffset = face->glyph->metrics.horiBearingX;\n                    x_position -= xoffset;\n                }\n            } else {\n                if (face->glyph->metrics.vertBearingY < 0) {\n                    yoffset = face->glyph->metrics.vertBearingY;\n                    y_max -= yoffset;\n                }\n            }\n        }\n\n        FT_Get_Glyph(face->glyph, &glyph);\n        FT_Glyph_Get_CBox(glyph, FT_GLYPH_BBOX_SUBPIXELS, &bbox);\n        if (horizontal_dir) {\n            x_position += glyph_info[i].x_advance;\n\n            x_advanced = x_position;\n            offset = glyph_info[i].x_advance -\n                    face->glyph->metrics.width -\n                    face->glyph->metrics.horiBearingX;\n            if (offset < 0)\n                x_advanced -= offset;\n            if (x_advanced > x_max)\n                x_max = x_advanced;\n\n            bbox.yMax += glyph_info[i].y_offset;\n            bbox.yMin += glyph_info[i].y_offset;\n            if (bbox.yMax > y_max)\n                y_max = bbox.yMax;\n            if (bbox.yMin < y_min)\n                y_min = bbox.yMin;\n\n            // find max distance of baseline from top\n            if (face->glyph->metrics.horiBearingY > yoffset)\n                yoffset = face->glyph->metrics.horiBearingY;\n        } else {\n            y_max -= glyph_info[i].y_advance;\n\n            if (i == count - 1) {\n                // trim end gap from final glyph\n                int offset;\n                offset = -glyph_info[i].y_advance -\n                        face->glyph->metrics.height -\n                        face->glyph->metrics.vertBearingY;\n                if (offset < 0)\n                    y_max -= offset;\n            }\n\n            if (bbox.xMax > x_max)\n                x_max = bbox.xMax;\n            if (i == 0 || bbox.xMin < x_min)\n                x_min = bbox.xMin;\n        }\n\n        FT_Done_Glyph(glyph);\n    }\n\n    if (glyph_info) {\n        PyMem_Free(glyph_info);\n        glyph_info = NULL;\n    }\n\n    if (face) {\n        if (horizontal_dir) {\n            // left bearing\n            if (xoffset < 0)\n                x_max -= xoffset;\n            else\n                xoffset = 0;\n\n            /* difference between the font ascender and the distance of\n             * the baseline from the top */\n            yoffset = PIXEL(self->face->size->metrics.ascender - yoffset);\n        } else {\n            // top bearing\n            if (yoffset < 0)\n                y_max -= yoffset;\n            else\n                yoffset = 0;\n        }\n    }\n\n    return Py_BuildValue(\n        \"(ii)(ii)\",\n        PIXEL(x_max - x_min), PIXEL(y_max - y_min),\n        PIXEL(xoffset), yoffset\n        );\n}\n\nstatic PyObject*\nfont_render(FontObject* self, PyObject* args)\n{\n    int x;\n    unsigned int y;\n    Imaging im;\n    int index, error, ascender, horizontal_dir;\n    int load_flags;\n    unsigned char *source;\n    FT_Glyph glyph;\n    FT_GlyphSlot glyph_slot;\n    FT_Bitmap bitmap;\n    FT_BitmapGlyph bitmap_glyph;\n    int stroke_width = 0;\n    FT_Stroker stroker = NULL;\n    FT_Int left;\n    /* render string into given buffer (the buffer *must* have\n       the right size, or this will crash) */\n    PyObject* string;\n    Py_ssize_t id;\n    int mask = 0;\n    int temp;\n    int xx, x0, x1;\n    int yy;\n    unsigned int bitmap_y;\n    const char *dir = NULL;\n    const char *lang = NULL;\n    size_t i, count;\n    GlyphInfo *glyph_info;\n    PyObject *features = NULL;\n\n    if (!PyArg_ParseTuple(args, \"On|izOzi:render\", &string,  &id, &mask, &dir, &features, &lang,\n                                                   &stroke_width)) {\n        return NULL;\n    }\n\n    glyph_info = NULL;\n    count = text_layout(string, self, dir, features, lang, &glyph_info, mask);\n    if (PyErr_Occurred()) {\n        return NULL;\n    }\n    if (count == 0) {\n        Py_RETURN_NONE;\n    }\n\n    if (stroke_width) {\n        error = FT_Stroker_New(library, &stroker);\n        if (error) {\n            return geterror(error);\n        }\n\n        FT_Stroker_Set(stroker, (FT_Fixed)stroke_width*64, FT_STROKER_LINECAP_ROUND, FT_STROKER_LINEJOIN_ROUND, 0);\n    }\n\n    im = (Imaging) id;\n    /* Note: bitmap fonts within ttf fonts do not work, see #891/pr#960 */\n    load_flags = FT_LOAD_NO_BITMAP;\n    if (stroker == NULL) {\n        load_flags |= FT_LOAD_RENDER;\n    }\n    if (mask) {\n        load_flags |= FT_LOAD_TARGET_MONO;\n    }\n\n    ascender = 0;\n    for (i = 0; i < count; i++) {\n        index = glyph_info[i].index;\n        error = FT_Load_Glyph(self->face, index, load_flags);\n        if (error) {\n            return geterror(error);\n        }\n\n        glyph_slot = self->face->glyph;\n        bitmap = glyph_slot->bitmap;\n\n        temp = bitmap.rows - glyph_slot->bitmap_top;\n        temp -= PIXEL(glyph_info[i].y_offset);\n        if (temp > ascender)\n            ascender = temp;\n    }\n\n    x = y = 0;\n    horizontal_dir = dir && strcmp(dir, \"ttb\") == 0 ? 0 : 1;\n    for (i = 0; i < count; i++) {\n        index = glyph_info[i].index;\n        error = FT_Load_Glyph(self->face, index, load_flags);\n        if (error) {\n            return geterror(error);\n        }\n\n        glyph_slot = self->face->glyph;\n        if (stroker != NULL) {\n            error = FT_Get_Glyph(glyph_slot, &glyph);\n            if (!error) {\n                error = FT_Glyph_Stroke(&glyph, stroker, 1);\n            }\n            if (!error) {\n                FT_Vector origin = {0, 0};\n                error = FT_Glyph_To_Bitmap(&glyph, FT_RENDER_MODE_NORMAL, &origin, 1);\n            }\n            if (error) {\n                return geterror(error);\n            }\n\n            bitmap_glyph = (FT_BitmapGlyph)glyph;\n\n            bitmap = bitmap_glyph->bitmap;\n            left = bitmap_glyph->left;\n\n            FT_Done_Glyph(glyph);\n        } else {\n            bitmap = glyph_slot->bitmap;\n            left = glyph_slot->bitmap_left;\n        }\n\n        if (horizontal_dir) {\n            if (i == 0 && glyph_slot->metrics.horiBearingX < 0) {\n                x = -glyph_slot->metrics.horiBearingX;\n            }\n            xx = PIXEL(x) + left;\n            xx += PIXEL(glyph_info[i].x_offset) + stroke_width;\n        } else {\n            if (glyph_slot->metrics.vertBearingX < 0) {\n                x = -glyph_slot->metrics.vertBearingX;\n            }\n            xx = im->xsize / 2 - bitmap.width / 2;\n        }\n\n        x0 = 0;\n        x1 = bitmap.width;\n        if (xx < 0)\n            x0 = -xx;\n        if (xx + x1 > im->xsize)\n            x1 = im->xsize - xx;\n\n        source = (unsigned char*) bitmap.buffer;\n        for (bitmap_y = 0; bitmap_y < bitmap.rows; bitmap_y++) {\n            if (horizontal_dir) {\n                yy = bitmap_y + im->ysize - (PIXEL(glyph_slot->metrics.horiBearingY) + ascender);\n                yy -= PIXEL(glyph_info[i].y_offset) + stroke_width * 2;\n            } else {\n                yy = bitmap_y + PIXEL(y + glyph_slot->metrics.vertBearingY) + ascender;\n                yy += PIXEL(glyph_info[i].y_offset);\n            }\n            if (yy >= 0 && yy < im->ysize) {\n                // blend this glyph into the buffer\n                unsigned char *target = im->image8[yy] + xx;\n                if (mask) {\n                    // use monochrome mask (on palette images, etc)\n                    int j, k, m = 128;\n                    for (j = k = 0; j < x1; j++) {\n                        if (j >= x0 && (source[k] & m))\n                            target[j] = 255;\n                        if (!(m >>= 1)) {\n                            m = 128;\n                            k++;\n                        }\n                    }\n                } else {\n                    // use antialiased rendering\n                    int k;\n                    for (k = x0; k < x1; k++) {\n                        if (target[k] < source[k])\n                            target[k] = source[k];\n                    }\n                }\n            }\n            source += bitmap.pitch;\n        }\n        x += glyph_info[i].x_advance;\n        y -= glyph_info[i].y_advance;\n    }\n\n    FT_Stroker_Done(stroker);\n    PyMem_Del(glyph_info);\n    Py_RETURN_NONE;\n}\n\n#if FREETYPE_MAJOR > 2 ||\\\n    (FREETYPE_MAJOR == 2 && FREETYPE_MINOR > 9) ||\\\n    (FREETYPE_MAJOR == 2 && FREETYPE_MINOR == 9 && FREETYPE_PATCH == 1)\n    static PyObject*\n    font_getvarnames(FontObject* self, PyObject* args)\n    {\n        int error;\n        FT_UInt i, j, num_namedstyles, name_count;\n        FT_MM_Var *master;\n        FT_SfntName name;\n        PyObject *list_names, *list_name;\n\n        error = FT_Get_MM_Var(self->face, &master);\n        if (error)\n            return geterror(error);\n\n        num_namedstyles = master->num_namedstyles;\n        list_names = PyList_New(num_namedstyles);\n\n        name_count = FT_Get_Sfnt_Name_Count(self->face);\n        for (i = 0; i < name_count; i++) {\n            error = FT_Get_Sfnt_Name(self->face, i, &name);\n            if (error)\n                return geterror(error);\n\n            for (j = 0; j < num_namedstyles; j++) {\n                if (PyList_GetItem(list_names, j) != NULL)\n                    continue;\n\n                if (master->namedstyle[j].strid == name.name_id) {\n                    list_name = Py_BuildValue(PY_ARG_BYTES_LENGTH,\n                                              name.string, name.string_len);\n                    PyList_SetItem(list_names, j, list_name);\n                    break;\n                }\n            }\n        }\n\n        FT_Done_MM_Var(library, master);\n\n        return list_names;\n    }\n\n    static PyObject*\n    font_getvaraxes(FontObject* self, PyObject* args)\n    {\n        int error;\n        FT_UInt i, j, num_axis, name_count;\n        FT_MM_Var* master;\n        FT_Var_Axis axis;\n        FT_SfntName name;\n        PyObject *list_axes, *list_axis, *axis_name;\n        error = FT_Get_MM_Var(self->face, &master);\n        if (error)\n            return geterror(error);\n\n        num_axis = master->num_axis;\n        name_count = FT_Get_Sfnt_Name_Count(self->face);\n\n        list_axes = PyList_New(num_axis);\n        for (i = 0; i < num_axis; i++) {\n            axis = master->axis[i];\n\n            list_axis = PyDict_New();\n            PyDict_SetItemString(list_axis, \"minimum\",\n                                 PyInt_FromLong(axis.minimum / 65536));\n            PyDict_SetItemString(list_axis, \"default\",\n                                 PyInt_FromLong(axis.def / 65536));\n            PyDict_SetItemString(list_axis, \"maximum\",\n                                 PyInt_FromLong(axis.maximum / 65536));\n\n            for (j = 0; j < name_count; j++) {\n                error = FT_Get_Sfnt_Name(self->face, j, &name);\n                if (error)\n                    return geterror(error);\n\n                if (name.name_id == axis.strid) {\n                    axis_name = Py_BuildValue(PY_ARG_BYTES_LENGTH,\n                                              name.string, name.string_len);\n                    PyDict_SetItemString(list_axis, \"name\", axis_name);\n                    break;\n                }\n            }\n\n            PyList_SetItem(list_axes, i, list_axis);\n        }\n\n        FT_Done_MM_Var(library, master);\n\n        return list_axes;\n    }\n\n    static PyObject*\n    font_setvarname(FontObject* self, PyObject* args)\n    {\n        int error;\n\n        int instance_index;\n        if (!PyArg_ParseTuple(args, \"i\", &instance_index))\n            return NULL;\n\n        error = FT_Set_Named_Instance(self->face, instance_index);\n        if (error)\n            return geterror(error);\n\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    static PyObject*\n    font_setvaraxes(FontObject* self, PyObject* args)\n    {\n        int error;\n\n        PyObject *axes, *item;\n        Py_ssize_t i, num_coords;\n        FT_Fixed *coords;\n        FT_Fixed coord;\n        if (!PyArg_ParseTuple(args, \"O\", &axes))\n            return NULL;\n\n        if (!PyList_Check(axes)) {\n            PyErr_SetString(PyExc_TypeError, \"argument must be a list\");\n            return NULL;\n        }\n\n        num_coords = PyObject_Length(axes);\n        coords = malloc(2 * sizeof(coords));\n        if (coords == NULL) {\n            return PyErr_NoMemory();\n        }\n        for (i = 0; i < num_coords; i++) {\n            item = PyList_GET_ITEM(axes, i);\n            if (PyFloat_Check(item))\n                coord = PyFloat_AS_DOUBLE(item);\n            else if (PyInt_Check(item))\n                coord = (float) PyInt_AS_LONG(item);\n            else if (PyNumber_Check(item))\n                coord = PyFloat_AsDouble(item);\n            else {\n                free(coords);\n                PyErr_SetString(PyExc_TypeError, \"list must contain numbers\");\n                return NULL;\n            }\n            coords[i] = coord * 65536;\n        }\n\n        error = FT_Set_Var_Design_Coordinates(self->face, num_coords, coords);\n        free(coords);\n        if (error)\n            return geterror(error);\n\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n#endif\n\nstatic void\nfont_dealloc(FontObject* self)\n{\n    if (self->face) {\n        FT_Done_Face(self->face);\n    }\n    if (self->font_bytes) {\n        PyMem_Free(self->font_bytes);\n    }\n    PyObject_Del(self);\n}\n\nstatic PyMethodDef font_methods[] = {\n    {\"render\", (PyCFunction) font_render, METH_VARARGS},\n    {\"getsize\", (PyCFunction) font_getsize, METH_VARARGS},\n#if FREETYPE_MAJOR > 2 ||\\\n    (FREETYPE_MAJOR == 2 && FREETYPE_MINOR > 9) ||\\\n    (FREETYPE_MAJOR == 2 && FREETYPE_MINOR == 9 && FREETYPE_PATCH == 1)\n    {\"getvarnames\", (PyCFunction) font_getvarnames, METH_VARARGS },\n    {\"getvaraxes\", (PyCFunction) font_getvaraxes, METH_VARARGS },\n    {\"setvarname\", (PyCFunction) font_setvarname, METH_VARARGS},\n    {\"setvaraxes\", (PyCFunction) font_setvaraxes, METH_VARARGS},\n#endif\n    {NULL, NULL}\n};\n\nstatic PyObject*\nfont_getattr_family(FontObject* self, void* closure)\n{\n#if PY_VERSION_HEX >= 0x03000000\n    if (self->face->family_name)\n        return PyUnicode_FromString(self->face->family_name);\n#else\n    if (self->face->family_name)\n        return PyString_FromString(self->face->family_name);\n#endif\n    Py_RETURN_NONE;\n}\n\nstatic PyObject*\nfont_getattr_style(FontObject* self, void* closure)\n{\n#if PY_VERSION_HEX >= 0x03000000\n    if (self->face->style_name)\n        return PyUnicode_FromString(self->face->style_name);\n#else\n    if (self->face->style_name)\n        return PyString_FromString(self->face->style_name);\n#endif\n    Py_RETURN_NONE;\n}\n\nstatic PyObject*\nfont_getattr_ascent(FontObject* self, void* closure)\n{\n    return PyInt_FromLong(PIXEL(self->face->size->metrics.ascender));\n}\n\nstatic PyObject*\nfont_getattr_descent(FontObject* self, void* closure)\n{\n    return PyInt_FromLong(-PIXEL(self->face->size->metrics.descender));\n}\n\nstatic PyObject*\nfont_getattr_height(FontObject* self, void* closure)\n{\n    return PyInt_FromLong(PIXEL(self->face->size->metrics.height));\n}\n\nstatic PyObject*\nfont_getattr_x_ppem(FontObject* self, void* closure)\n{\n    return PyInt_FromLong(self->face->size->metrics.x_ppem);\n}\n\nstatic PyObject*\nfont_getattr_y_ppem(FontObject* self, void* closure)\n{\n    return PyInt_FromLong(self->face->size->metrics.y_ppem);\n}\n\n\nstatic PyObject*\nfont_getattr_glyphs(FontObject* self, void* closure)\n{\n    return PyInt_FromLong(self->face->num_glyphs);\n}\n\nstatic struct PyGetSetDef font_getsetters[] = {\n    { \"family\",     (getter) font_getattr_family },\n    { \"style\",      (getter) font_getattr_style },\n    { \"ascent\",     (getter) font_getattr_ascent },\n    { \"descent\",    (getter) font_getattr_descent },\n    { \"height\",     (getter) font_getattr_height },\n    { \"x_ppem\",     (getter) font_getattr_x_ppem },\n    { \"y_ppem\",     (getter) font_getattr_y_ppem },\n    { \"glyphs\",     (getter) font_getattr_glyphs },\n    { NULL }\n};\n\nstatic PyTypeObject Font_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"Font\", sizeof(FontObject), 0,\n    /* methods */\n    (destructor)font_dealloc, /* tp_dealloc */\n    0, /* tp_print */\n    0,                          /*tp_getattr*/\n    0,                          /*tp_setattr*/\n    0,                          /*tp_compare*/\n    0,                          /*tp_repr*/\n    0,                          /*tp_as_number */\n    0,                          /*tp_as_sequence */\n    0,                          /*tp_as_mapping */\n    0,                          /*tp_hash*/\n    0,                          /*tp_call*/\n    0,                          /*tp_str*/\n    0,                          /*tp_getattro*/\n    0,                          /*tp_setattro*/\n    0,                          /*tp_as_buffer*/\n    Py_TPFLAGS_DEFAULT,         /*tp_flags*/\n    0,                          /*tp_doc*/\n    0,                          /*tp_traverse*/\n    0,                          /*tp_clear*/\n    0,                          /*tp_richcompare*/\n    0,                          /*tp_weaklistoffset*/\n    0,                          /*tp_iter*/\n    0,                          /*tp_iternext*/\n    font_methods,               /*tp_methods*/\n    0,                          /*tp_members*/\n    font_getsetters,            /*tp_getset*/\n};\n\nstatic PyMethodDef _functions[] = {\n    {\"getfont\", (PyCFunction) getfont, METH_VARARGS|METH_KEYWORDS},\n    {NULL, NULL}\n};\n\nstatic int\nsetup_module(PyObject* m) {\n    PyObject* d;\n    PyObject* v;\n    int major, minor, patch;\n\n    d = PyModule_GetDict(m);\n\n    /* Ready object type */\n    PyType_Ready(&Font_Type);\n\n    if (FT_Init_FreeType(&library))\n        return 0; /* leave it uninitialized */\n\n    FT_Library_Version(library, &major, &minor, &patch);\n\n#if PY_VERSION_HEX >= 0x03000000\n    v = PyUnicode_FromFormat(\"%d.%d.%d\", major, minor, patch);\n#else\n    v = PyString_FromFormat(\"%d.%d.%d\", major, minor, patch);\n#endif\n    PyDict_SetItemString(d, \"freetype2_version\", v);\n\n\n    setraqm();\n    v = PyBool_FromLong(!!p_raqm.raqm);\n    PyDict_SetItemString(d, \"HAVE_RAQM\", v);\n\n    return 0;\n}\n\n#if PY_VERSION_HEX >= 0x03000000\nPyMODINIT_FUNC\nPyInit__imagingft(void) {\n    PyObject* m;\n\n    static PyModuleDef module_def = {\n        PyModuleDef_HEAD_INIT,\n        \"_imagingft\",       /* m_name */\n        NULL,               /* m_doc */\n        -1,                 /* m_size */\n        _functions,         /* m_methods */\n    };\n\n    m = PyModule_Create(&module_def);\n\n    if (setup_module(m) < 0)\n        return NULL;\n\n    return m;\n}\n#else\nPyMODINIT_FUNC\ninit_imagingft(void)\n{\n    PyObject* m = Py_InitModule(\"_imagingft\", _functions);\n    setup_module(m);\n}\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-pillow-simd-6.2.2.post1-2x3n5gloinbxykprpj47agf3tnwv33nc/spack-src/src/Tk/tkImaging.c": "/*\n * The Python Imaging Library.\n * $Id$\n *\n * TK interface for Python Imaging objects\n *\n * Copies (parts of) a named display memory to a photo image object.\n * Also contains code to create an display memory.  Under Tk, a\n * display memory is simply an \"L\" or \"RGB\" image memory that is\n * allocated in a single block.\n *\n * To use this module, import the _imagingtk module (ImageTk does\n * this for you).\n *\n * If you're using Python in an embedded context, you can add the\n * following lines to your Tcl_AppInit function (in tkappinit.c)\n * instead.  Put them after the calls to Tcl_Init and Tk_Init:\n *\n *      {\n *          extern void TkImaging_Init(Tcl_Interp* interp);\n *          TkImaging_Init(interp);\n *      }\n *\n * This registers a Tcl command called \"PyImagingPhoto\", which is used\n * to communicate between PIL and Tk's PhotoImage handler.\n *\n\n * History:\n * 1995-09-12 fl  Created\n * 1996-04-08 fl  Ready for release\n * 1997-05-09 fl  Use command instead of image type\n * 2001-03-18 fl  Initialize alpha layer pointer (struct changed in 8.3)\n * 2003-04-23 fl  Fixed building for Tk 8.4.1 and later (Jack Jansen)\n * 2004-06-24 fl  Fixed building for Tk 8.4.6 and later.\n *\n * Copyright (c) 1997-2004 by Secret Labs AB\n * Copyright (c) 1995-2004 by Fredrik Lundh\n *\n * See the README file for information on usage and redistribution.\n */\n\n#include \"Imaging.h\"\n#include \"_tkmini.h\"\n\n#include <stdlib.h>\n\n/*\n * Global vars for Tcl / Tk functions.  We load these symbols from the tkinter\n * extension module or loaded Tcl / Tk libraries at run-time.\n */\nstatic int TK_LT_85 = 0;\nstatic Tcl_CreateCommand_t TCL_CREATE_COMMAND;\nstatic Tcl_AppendResult_t TCL_APPEND_RESULT;\nstatic Tk_FindPhoto_t TK_FIND_PHOTO;\nstatic Tk_PhotoGetImage_t TK_PHOTO_GET_IMAGE;\nstatic Tk_PhotoPutBlock_84_t TK_PHOTO_PUT_BLOCK_84;\nstatic Tk_PhotoSetSize_84_t TK_PHOTO_SET_SIZE_84;\nstatic Tk_PhotoPutBlock_85_t TK_PHOTO_PUT_BLOCK_85;\n\nstatic Imaging\nImagingFind(const char* name)\n{\n    Py_ssize_t id;\n\n    /* FIXME: use CObject instead? */\n#if defined(_MSC_VER) && defined(_WIN64)\n    id = _atoi64(name);\n#else\n    id = atol(name);\n#endif\n    if (!id)\n        return NULL;\n\n    return (Imaging) id;\n}\n\n\nstatic int\nPyImagingPhotoPut(ClientData clientdata, Tcl_Interp* interp,\n               int argc, const char **argv)\n{\n    Imaging im;\n    Tk_PhotoHandle photo;\n    Tk_PhotoImageBlock block;\n\n    if (argc != 3) {\n        TCL_APPEND_RESULT(interp, \"usage: \", argv[0],\n                         \" destPhoto srcImage\", (char *) NULL);\n        return TCL_ERROR;\n    }\n\n    /* get Tcl PhotoImage handle */\n    photo = TK_FIND_PHOTO(interp, argv[1]);\n    if (photo == NULL) {\n        TCL_APPEND_RESULT(\n            interp, \"destination photo must exist\", (char *) NULL\n            );\n        return TCL_ERROR;\n    }\n\n    /* get PIL Image handle */\n    im = ImagingFind(argv[2]);\n    if (!im) {\n        TCL_APPEND_RESULT(interp, \"bad name\", (char*) NULL);\n        return TCL_ERROR;\n    }\n    if (!im->block) {\n        TCL_APPEND_RESULT(interp, \"bad display memory\", (char*) NULL);\n        return TCL_ERROR;\n    }\n\n    /* Mode */\n\n    if (strcmp(im->mode, \"1\") == 0 || strcmp(im->mode, \"L\") == 0) {\n        block.pixelSize = 1;\n        block.offset[0] = block.offset[1] = block.offset[2] = 0;\n    } else if (strncmp(im->mode, \"RGB\", 3) == 0) {\n        block.pixelSize = 4;\n        block.offset[0] = 0;\n        block.offset[1] = 1;\n        block.offset[2] = 2;\n        if (strcmp(im->mode, \"RGBA\") == 0)\n            block.offset[3] = 3; /* alpha (or reserved, under 8.2) */\n        else\n            block.offset[3] = 0; /* no alpha */\n    } else {\n        TCL_APPEND_RESULT(interp, \"Bad mode\", (char*) NULL);\n        return TCL_ERROR;\n    }\n\n    block.width = im->xsize;\n    block.height = im->ysize;\n    block.pitch = im->linesize;\n    block.pixelPtr = (unsigned char*) im->block;\n\n    if (TK_LT_85) { /* Tk 8.4 */\n        TK_PHOTO_PUT_BLOCK_84(photo, &block, 0, 0, block.width, block.height,\n                TK_PHOTO_COMPOSITE_SET);\n        if (strcmp(im->mode, \"RGBA\") == 0)\n            /* Tk workaround: we need apply ToggleComplexAlphaIfNeeded */\n            /* (fixed in Tk 8.5a3) */\n            TK_PHOTO_SET_SIZE_84(photo, block.width, block.height);\n    } else {\n        /* Tk >=8.5 */\n        TK_PHOTO_PUT_BLOCK_85(interp, photo, &block, 0, 0, block.width,\n                block.height, TK_PHOTO_COMPOSITE_SET);\n    }\n\n    return TCL_OK;\n}\n\nstatic int\nPyImagingPhotoGet(ClientData clientdata, Tcl_Interp* interp,\n               int argc, const char **argv)\n{\n    Imaging im;\n    Tk_PhotoHandle photo;\n    Tk_PhotoImageBlock block;\n    int x, y, z;\n\n    if (argc != 3) {\n        TCL_APPEND_RESULT(interp, \"usage: \", argv[0],\n                         \" srcPhoto destImage\", (char *) NULL);\n        return TCL_ERROR;\n    }\n\n    /* get Tcl PhotoImage handle */\n    photo = TK_FIND_PHOTO(interp, argv[1]);\n    if (photo == NULL) {\n        TCL_APPEND_RESULT(\n            interp, \"source photo must exist\", (char *) NULL\n            );\n        return TCL_ERROR;\n    }\n\n    /* get PIL Image handle */\n    im = ImagingFind(argv[2]);\n    if (!im) {\n        TCL_APPEND_RESULT(interp, \"bad name\", (char*) NULL);\n        return TCL_ERROR;\n    }\n\n    TK_PHOTO_GET_IMAGE(photo, &block);\n\n    for (y = 0; y < block.height; y++) {\n        UINT8* out = (UINT8*)im->image32[y];\n        for (x = 0; x < block.pitch; x += block.pixelSize) {\n            for (z=0; z < block.pixelSize; z++) {\n                int offset = block.offset[z];\n                out[x + offset] = block.pixelPtr[y * block.pitch + x + offset];\n            }\n        }\n    }\n\n    return TCL_OK;\n}\n\n\nvoid\nTkImaging_Init(Tcl_Interp* interp)\n{\n    TCL_CREATE_COMMAND(interp, \"PyImagingPhoto\", PyImagingPhotoPut,\n                      (ClientData) 0, (Tcl_CmdDeleteProc*) NULL);\n    TCL_CREATE_COMMAND(interp, \"PyImagingPhotoGet\", PyImagingPhotoGet,\n                      (ClientData) 0, (Tcl_CmdDeleteProc*) NULL);\n}\n\n/*\n * Functions to fill global Tcl / Tk function pointers by dynamic loading\n */\n\n#define TKINTER_FINDER \"PIL._tkinter_finder\"\n\n#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)\n\n/*\n * On Windows, we can't load the tkinter module to get the Tcl or Tk symbols,\n * because Windows does not load symbols into the library name-space of\n * importing modules. So, knowing that tkinter has already been imported by\n * Python, we scan all modules in the running process for the Tcl and Tk\n * function names.\n */\n#include <windows.h>\n#define PSAPI_VERSION 1\n#include <psapi.h>\n/* Must be linked with 'psapi' library */\n\n#if PY_VERSION_HEX >= 0x03000000\n#define TKINTER_PKG \"tkinter\"\n#else\n#define TKINTER_PKG \"Tkinter\"\n#endif\n\nFARPROC _dfunc(HMODULE lib_handle, const char *func_name)\n{\n    /*\n     * Load function `func_name` from `lib_handle`.\n     * Set Python exception if we can't find `func_name` in `lib_handle`.\n     * Returns function pointer or NULL if not present.\n    */\n\n    char message[100];\n\n    FARPROC func = GetProcAddress(lib_handle, func_name);\n    if (func == NULL) {\n        sprintf(message, \"Cannot load function %s\", func_name);\n        PyErr_SetString(PyExc_RuntimeError, message);\n    }\n    return func;\n}\n\nint get_tcl(HMODULE hMod)\n{\n    /*\n     * Try to fill Tcl global vars with function pointers. Return 0 for no\n     * functions found, 1 for all functions found, -1 for some but not all\n     * functions found.\n     */\n\n    if ((TCL_CREATE_COMMAND = (Tcl_CreateCommand_t)\n        GetProcAddress(hMod, \"Tcl_CreateCommand\")) == NULL) {\n        return 0; /* Maybe not Tcl module */\n    }\n    return ((TCL_APPEND_RESULT = (Tcl_AppendResult_t) _dfunc(hMod,\n            \"Tcl_AppendResult\")) == NULL) ? -1 : 1;\n}\n\nint get_tk(HMODULE hMod)\n{\n    /*\n     * Try to fill Tk global vars with function pointers. Return 0 for no\n     * functions found, 1 for all functions found, -1 for some but not all\n     * functions found.\n     */\n\n    FARPROC func = GetProcAddress(hMod, \"Tk_PhotoPutBlock\");\n    if (func == NULL) {  /* Maybe not Tk module */\n        return 0;\n    }\n    if ((TK_PHOTO_GET_IMAGE = (Tk_PhotoGetImage_t)\n                _dfunc(hMod, \"Tk_PhotoGetImage\")) == NULL) { return -1; };\n    if ((TK_FIND_PHOTO = (Tk_FindPhoto_t)\n                _dfunc(hMod, \"Tk_FindPhoto\")) == NULL) { return -1; };\n    TK_LT_85 = GetProcAddress(hMod, \"Tk_PhotoPutBlock_Panic\") == NULL;\n    /* Tk_PhotoPutBlock_Panic defined as of 8.5.0 */\n    if (TK_LT_85) {\n        TK_PHOTO_PUT_BLOCK_84 = (Tk_PhotoPutBlock_84_t) func;\n        return ((TK_PHOTO_SET_SIZE_84 = (Tk_PhotoSetSize_84_t)\n                    _dfunc(hMod, \"Tk_PhotoSetSize\")) == NULL) ? -1 : 1;\n    }\n    TK_PHOTO_PUT_BLOCK_85 = (Tk_PhotoPutBlock_85_t) func;\n    return 1;\n}\n\nint load_tkinter_funcs(void)\n{\n    /*\n     * Load Tcl and Tk functions by searching all modules in current process.\n     * Return 0 for success, non-zero for failure.\n     */\n\n    HMODULE hMods[1024];\n    HANDLE hProcess;\n    DWORD cbNeeded;\n    unsigned int i;\n    int found_tcl = 0;\n    int found_tk = 0;\n\n    /* First load tkinter module to make sure libraries are loaded */\n    PyObject *pModule = PyImport_ImportModule(TKINTER_PKG);\n    if (pModule == NULL) {\n        return 1;\n    }\n    Py_DECREF(pModule);\n\n    /* Returns pseudo-handle that does not need to be closed */\n    hProcess = GetCurrentProcess();\n\n    /* Iterate through modules in this process looking for Tcl / Tk names */\n    if (EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded)) {\n        for (i = 0; i < (cbNeeded / sizeof(HMODULE)); i++) {\n            if (!found_tcl) {\n                found_tcl = get_tcl(hMods[i]);\n                if (found_tcl == -1) {\n                    return 1;\n                }\n            }\n            if (!found_tk) {\n                found_tk = get_tk(hMods[i]);\n                if (found_tk == -1) {\n                    return 1;\n                }\n            }\n            if (found_tcl && found_tk) {\n                return 0;\n            }\n        }\n    }\n\n    if (found_tcl == 0) {\n        PyErr_SetString(PyExc_RuntimeError, \"Could not find Tcl routines\");\n    } else {\n        PyErr_SetString(PyExc_RuntimeError, \"Could not find Tk routines\");\n    }\n    return 1;\n}\n\n#else  /* not Windows */\n\n/*\n * On Unix, we can get the Tcl and Tk symbols from the tkinter module, because\n * tkinter uses these symbols, and the symbols are therefore visible in the\n * tkinter dynamic library (module).\n */\n\n/* From module __file__ attribute to char *string for dlopen. */\n#if PY_VERSION_HEX >= 0x03000000\nchar *fname2char(PyObject *fname)\n{\n    PyObject* bytes;\n    bytes = PyUnicode_EncodeFSDefault(fname);\n    if (bytes == NULL) {\n        return NULL;\n    }\n    return PyBytes_AsString(bytes);\n}\n#else\n#define fname2char(s) (PyString_AsString(s))\n#endif\n\n#include <dlfcn.h>\n\nvoid *_dfunc(void *lib_handle, const char *func_name)\n{\n    /*\n     * Load function `func_name` from `lib_handle`.\n     * Set Python exception if we can't find `func_name` in `lib_handle`.\n     * Returns function pointer or NULL if not present.\n     */\n\n    void* func;\n    /* Reset errors. */\n    dlerror();\n    func = dlsym(lib_handle, func_name);\n    if (func == NULL) {\n        const char *error = dlerror();\n        PyErr_SetString(PyExc_RuntimeError, error);\n    }\n    return func;\n}\n\nint _func_loader(void *lib)\n{\n    /*\n     * Fill global function pointers from dynamic lib.\n     * Return 1 if any pointer is NULL, 0 otherwise.\n     */\n\n    if ((TCL_CREATE_COMMAND = (Tcl_CreateCommand_t)\n            _dfunc(lib, \"Tcl_CreateCommand\")) == NULL) { return 1; }\n    if ((TCL_APPEND_RESULT = (Tcl_AppendResult_t) _dfunc(lib,\n                \"Tcl_AppendResult\")) == NULL) { return 1; }\n    if ((TK_PHOTO_GET_IMAGE = (Tk_PhotoGetImage_t)\n                _dfunc(lib, \"Tk_PhotoGetImage\")) == NULL) { return 1; }\n    if ((TK_FIND_PHOTO = (Tk_FindPhoto_t)\n                _dfunc(lib, \"Tk_FindPhoto\")) == NULL) { return 1; }\n    /* Tk_PhotoPutBlock_Panic defined as of 8.5.0 */\n    TK_LT_85 = (dlsym(lib, \"Tk_PhotoPutBlock_Panic\") == NULL);\n    if (TK_LT_85) {\n        return (((TK_PHOTO_PUT_BLOCK_84 = (Tk_PhotoPutBlock_84_t)\n                        _dfunc(lib, \"Tk_PhotoPutBlock\")) == NULL) ||\n                ((TK_PHOTO_SET_SIZE_84 = (Tk_PhotoSetSize_84_t)\n                  _dfunc(lib, \"Tk_PhotoSetSize\")) == NULL));\n    }\n    return ((TK_PHOTO_PUT_BLOCK_85 = (Tk_PhotoPutBlock_85_t)\n                _dfunc(lib, \"Tk_PhotoPutBlock\")) == NULL);\n}\n\nint load_tkinter_funcs(void)\n{\n    /*\n     * Load tkinter global funcs from tkinter compiled module.\n     * Return 0 for success, non-zero for failure.\n     */\n\n    int ret = -1;\n    void *main_program, *tkinter_lib;\n    char *tkinter_libname;\n    PyObject *pModule = NULL, *pString = NULL;\n\n    /* Try loading from the main program namespace first */\n    main_program = dlopen(NULL, RTLD_LAZY);\n    if (_func_loader(main_program) == 0) {\n        dlclose(main_program);\n        return 0;\n    }\n    /* Clear exception triggered when we didn't find symbols above */\n    PyErr_Clear();\n\n    /* Now try finding the tkinter compiled module */\n    pModule = PyImport_ImportModule(TKINTER_FINDER);\n    if (pModule == NULL) {\n        goto exit;\n    }\n    pString = PyObject_GetAttrString(pModule, \"TKINTER_LIB\");\n    if (pString == NULL) {\n        goto exit;\n    }\n    tkinter_libname = fname2char(pString);\n    if (tkinter_libname == NULL) {\n        goto exit;\n    }\n    tkinter_lib = dlopen(tkinter_libname, RTLD_LAZY);\n    if (tkinter_lib == NULL) {\n        PyErr_SetString(PyExc_RuntimeError,\n                \"Cannot dlopen tkinter module file\");\n        goto exit;\n    }\n    ret = _func_loader(tkinter_lib);\n    /* dlclose probably safe because tkinter has been imported. */\n    dlclose(tkinter_lib);\nexit:\n    dlclose(main_program);\n    Py_XDECREF(pModule);\n    Py_XDECREF(pString);\n    return ret;\n}\n#endif /* end not Windows */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-pillow-simd-6.2.2.post1-2x3n5gloinbxykprpj47agf3tnwv33nc/spack-src/depends/.DS_Store",
        "/tmp/vanessa/spack-stage/spack-stage-py-pillow-simd-6.2.2.post1-2x3n5gloinbxykprpj47agf3tnwv33nc/spack-src/docs/.DS_Store"
    ],
    "total_files": 329
}