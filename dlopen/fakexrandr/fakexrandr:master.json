{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-fakexrandr-master-spo3ptp7xoac3o56hy74o37utdt5ncb6/spack-src/libXrandr.c": "/*\n\tFakeXRandR\n\tCopyright (c) 2015, Phillip Berndt\n\n\tThis is a replacement library for libXrandr.so and, optionally,\n\tlibXinerama.so. It replaces configurable outputs with multiple\n\tsub-outputs.\n*/\n\n#include <unistd.h>\n#include <fcntl.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <X11/extensions/Xrandr.h>\n#include <X11/extensions/Xinerama.h>\n#include <X11/Xlib.h>\n#include <X11/Xlibint.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n#include <string.h>\n\n\n/*\n\tThe management script uses this symbol to identify the fake libXrandr version\n*/\nint _is_fake_xrandr = 1;\n\n/*\n\tWe use this XID modifier to flag outputs and CRTCs as\n\tfake by adding a counter in the first few bits:\n\t \u00b7 xid & ~XID_SPLIT_MASK is the xid of the original output\n\t \u00b7 xid >> XID_SPLIT_SHIFT is the counter identifying a virtual, split screen\n\n\tOn the choice: A typical XID is of the form\n\t client_id | (xid_mask & arbitrary value),\n\taccording to the documentation of the X-Resource extension. On my system,\n\t xid_mask = 0x001FFFFF\n\tand client_id == 0 for all reources mentioned in the RandR protocol.\n\tAll we need to do is to choose XID_SPLIT_MASK such that\n\tXID_SPLIT_MASK & xid_mask == 0.\n*/\n#define XID_SPLIT_SHIFT 21\n#define XID_SPLIT_MASK  0x7FE00000\n\n/*\n\tGenerated by ./configure:\n*/\n#include \"config.h\"\n\n/*\n\tThe skeleton file is created by ./make_skeleton.py\n\n\tIt contains wrappers around all Xrandr functions which are not\n\texplicitly defined in this C file, replacing all references to\n\tcrtcs and outputs which are fake with the real ones.\n*/\n#include \"skeleton.h\"\n\n/*\n\tWe use an augmented version of the screen resources to store all our\n\tinformation: We preallocate all XRROutputInfo and XRRCrtcInfo structures\n\tfor the fake screens upon a request for screen resources and only return\n\tpointers in the functions that return them.\n*/\nstruct FakeInfo {\n\tXID xid;\n\tXID parent_xid;\n\tvoid *info;\n\tstruct FakeInfo *next;\n};\n\nstruct FakeScreenResources {\n\t// This is crafted to look like a XRRScreenResources to an unaware user\n\tXRRScreenResources res;\n\n\t// This points to the original screen resources. We don't free them to\n\t// be able to use the original strings/lists without having to copy them.\n\tXRRScreenResources *parent_res;\n\n\t// These lists point to the fake OutputInfo/CrtcInfo/Mode structures\n\tstruct FakeInfo *fake_crtcs;\n\tstruct FakeInfo *fake_outputs;\n\tstruct FakeInfo *fake_modes;\n};\n\n/*\n\tConfiguration management\n\n\tThe configuration file format is documented in the management script. These\n\tfunctions load the configuration file and fill the FakeInfo lists with\n\tinformation on the fake outputs.\n*/\nstatic char *config_file;\nstatic int config_file_fd;\nstatic size_t config_file_size;\n\nstatic char *_config_foreach_split(char *config, unsigned int *n, unsigned int x, unsigned int y, unsigned int width, unsigned int height, XRRScreenResources *resources, RROutput output, XRROutputInfo *output_info,\n\t\tXRRCrtcInfo *crtc_info, struct FakeInfo ***fake_crtcs, struct FakeInfo ***fake_outputs, struct FakeInfo ***fake_modes) {\n\n\tif(config[0] == 'N') {\n\t\t// Define a new output info\n\t\t**fake_outputs = Xmalloc(sizeof(struct FakeInfo) + sizeof(XRROutputInfo) + output_info->nameLen + sizeof(\"~NNN \") + sizeof(RRCrtc) + sizeof(RROutput) * output_info->nclone + (1 + output_info->nmode) * sizeof(RRMode));\n\t\t(**fake_outputs)->xid = (output & ~XID_SPLIT_MASK) | ((++(*n)) << XID_SPLIT_SHIFT);\n\t\t(**fake_outputs)->parent_xid = output;\n\t\tXRROutputInfo *fake_info = (**fake_outputs)->info = (void*)**fake_outputs + sizeof(struct FakeInfo);\n\t\tfake_info->timestamp = output_info->timestamp;\n\t\tfake_info->name = (void*)fake_info + sizeof(XRROutputInfo);\n\t\tfake_info->nameLen = sprintf(fake_info->name, \"%s~%d\", output_info->name, (*n));\n\t\tfake_info->mm_width = output_info->mm_width * width / crtc_info->width;\n\t\tfake_info->mm_height = output_info->mm_height * height / crtc_info->height;\n\t\tfake_info->connection = output_info->connection;\n\t\tfake_info->subpixel_order = output_info->subpixel_order;\n\t\tfake_info->ncrtc = 1;\n\t\tfake_info->crtcs = (void*)fake_info->name + output_info->nameLen + sizeof(\"~NNN \");\n\t\tfake_info->nclone = output_info->nclone;\n\t\tfake_info->clones = (void*)fake_info->crtcs + sizeof(RRCrtc);\n\t\tint i;\n\t\tfor(i=0; i<fake_info->nclone; i++) {\n\t\t\tfake_info->clones[i] = (output_info->clones[i] & ~XID_SPLIT_MASK) | ((*n) << XID_SPLIT_SHIFT);\n\t\t}\n\t\tfake_info->nmode = 1 + output_info->nmode;\n\t\tfake_info->npreferred = 0;\n\t\tfake_info->modes = (void*)fake_info->clones + fake_info->nclone * sizeof(RROutput);\n\t\tfake_info->crtc = *fake_info->crtcs = *fake_info->modes = (output_info->crtc & ~XID_SPLIT_MASK) | ((*n) << XID_SPLIT_SHIFT);\n\t\tmemcpy(fake_info->modes + 1, output_info->modes, sizeof(RRMode) * output_info->nmode);\n\n\t\t*fake_outputs = &(**fake_outputs)->next;\n\t\t**fake_outputs = NULL;\n\n\t\t// Define a new CRTC info\n\t\t**fake_crtcs = Xmalloc(sizeof(struct FakeInfo) + sizeof(XRRCrtcInfo) + sizeof(RROutput));\n\t\t(**fake_crtcs)->xid = (output_info->crtc & ~XID_SPLIT_MASK) | ((*n) << XID_SPLIT_SHIFT);\n\t\t(**fake_crtcs)->parent_xid = output_info->crtc;\n\t\tXRRCrtcInfo *fake_crtc_info = (**fake_crtcs)->info = ((void*)**fake_crtcs) + sizeof(struct FakeInfo);\n\t\t*fake_crtc_info = *crtc_info;\n\t\tfake_crtc_info->x = crtc_info->x + x;\n\t\tfake_crtc_info->y = crtc_info->y + y;\n\t\tfake_crtc_info->width = width;\n\t\tfake_crtc_info->height = height;\n\t\tfake_crtc_info->mode = *(fake_info->modes);\n\t\tfake_crtc_info->noutput = 1;\n\t\tfake_crtc_info->outputs = (void*)fake_crtc_info + sizeof(XRRCrtcInfo);\n\t\t*(fake_crtc_info->outputs) = (output & ~XID_SPLIT_MASK) | (((*n)) << XID_SPLIT_SHIFT);\n\t\tfake_crtc_info->npossible = 1;\n\t\tfake_crtc_info->possible = fake_crtc_info->outputs;\n\n\t\t*fake_crtcs = &(**fake_crtcs)->next;\n\t\t**fake_crtcs = NULL;\n\n\t\t// Define a new fake mode\n\t\t**fake_modes = Xcalloc(1, sizeof(struct FakeInfo) + sizeof(XRRModeInfo) + sizeof(\"XXXXxXXXX\"));\n\t\t(**fake_modes)->xid = (output_info->crtc & ~XID_SPLIT_MASK) | ((*n) << XID_SPLIT_SHIFT);\n\t\t(**fake_modes)->parent_xid = 0;\n\t\tXRRModeInfo *fake_mode_info = (**fake_modes)->info = (void*)**fake_modes + sizeof(struct FakeInfo);\n\t\tfor(i=0; i<resources->nmode; i++) {\n\t\t\tif(resources->modes[i].id == crtc_info->mode) {\n\t\t\t\t*fake_mode_info = resources->modes[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfake_mode_info->id = (**fake_modes)->xid;\n\t\tfake_mode_info->width = width;\n\t\tfake_mode_info->height = height;\n\t\tfake_mode_info->name = (void*)fake_mode_info + sizeof(XRRModeInfo);\n\t\tfake_mode_info->nameLength = sprintf(fake_mode_info->name, \"%dx%d\", width, height);\n\n\t\t*fake_modes = &(**fake_modes)->next;\n\t\t**fake_modes = NULL;\n\n\t\treturn config + 1;\n\t}\n\tunsigned int split_pos = *(unsigned int *)&config[1];\n\tif(config[0] == 'H') {\n\t\tconfig = _config_foreach_split(config + 1 + 4, n, x, y, width, split_pos, resources, output, output_info, crtc_info, fake_crtcs, fake_outputs, fake_modes);\n\t\treturn _config_foreach_split(config, n, x, y + split_pos, width, height - split_pos, resources, output, output_info, crtc_info, fake_crtcs, fake_outputs, fake_modes);\n\t}\n\telse {\n\t\tassert(config[0] == 'V');\n\n\t\tconfig = _config_foreach_split(config + 1 + 4, n, x, y, split_pos, height, resources, output, output_info, crtc_info, fake_crtcs, fake_outputs, fake_modes);\n\t\treturn _config_foreach_split(config, n, x + split_pos, y, width - split_pos, height, resources, output, output_info, crtc_info, fake_crtcs, fake_outputs, fake_modes);\n\t}\n}\n\nstatic int config_handle_output(Display *dpy, XRRScreenResources *resources, RROutput output, char *target_edid, struct FakeInfo ***fake_crtcs, struct FakeInfo ***fake_outputs, struct FakeInfo ***fake_modes) {\n\tchar *config;\n\tfor(config = config_file; (int)(config - config_file) <= (int)config_file_size; ) {\n\t\t// Walk through the configuration file and search for the target_edid\n\t\tunsigned int size = *(unsigned int *)config;\n\t\t// char *name = &config[4];\n\t\tchar *edid = &config[4 + 128];\n\t\tunsigned int width = *(unsigned int *)&config[4 + 128 + 768];\n\t\tunsigned int height = *(unsigned int *)&config[4 + 128 + 768 + 4];\n\t\t// unsigned int count = *(unsigned int *)&config[4 + 128 + 768 + 4 + 4];\n\n\t\tif(strncmp(edid, target_edid, 768) == 0) {\n\t\t\tXRROutputInfo *output_info = _XRRGetOutputInfo(dpy, resources, output);\n\t\t\tif(!output_info || output_info->crtc == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tXRRCrtcInfo *output_crtc = _XRRGetCrtcInfo(dpy, resources, output_info->crtc);\n\t\t\tif(!output_crtc) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif(output_crtc->width == (unsigned)width && output_crtc->height == (unsigned)height) {\n\t\t\t\t// If it is found and the size matches, add fake outputs/crtcs to the list\n\t\t\t\tunsigned n = 0;\n\t\t\t\t_config_foreach_split(config + 4 + 128 + 768 + 4 + 4 + 4, &n, 0, 0, width, height, resources, output, output_info, output_crtc, fake_crtcs, fake_outputs, fake_modes);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tconfig += 4 + size;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void close_configuration() {\n\tmunmap(config_file, config_file_size);\n\tclose(config_file_fd);\n\tconfig_file = NULL;\n}\n\nstatic int open_configuration() {\n\t// Load the configuration from ${XDG_CONFIG_HOME:-$HOME/.config}/fakexrandr.bin\n\tif(config_file) {\n\t\tclose_configuration();\n\t}\n\n\tchar *config_dir = getenv(\"XDG_CONFIG_HOME\");\n\tif(!config_dir) {\n\t\tchar *home_dir = getenv(\"HOME\");\n\t\tif(!home_dir) {\n\t\t\treturn 1;\n\t\t}\n\t\tconfig_dir = alloca(512);\n\t\tif(snprintf(config_dir, 512, \"%s/.config\", home_dir) >= 512) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tchar config_file_path[512];\n\tif(snprintf(config_file_path, 512, \"%s/fakexrandr.bin\", config_dir) >= 512) {\n\t\treturn 1;\n\t}\n\tif(access(config_file_path, R_OK)) {\n\t\treturn 1;\n\t}\n\n\tconfig_file_fd = open(config_file_path, O_RDONLY);\n\tif(config_file_fd < 0) {\n\t\tperror(\"fakexrandr/open()\");\n\t\treturn 1;\n\t}\n\tstruct stat config_stat;\n\tfstat(config_file_fd, &config_stat);\n\tconfig_file_size = config_stat.st_size;\n\tconfig_file = mmap(NULL, config_file_size, PROT_READ, MAP_SHARED, config_file_fd, 0);\n\tif(config_file == MAP_FAILED) {\n\t\tperror(\"fakexrandr/mmap()\");\n\t\tconfig_file = NULL;\n\t\tclose(config_file_fd);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/*\n\tHelper function to return a hex-coded EDID string for a given output\n\n\tedid must point to a sufficiently large (768 bytes) buffer.\n*/\nstatic int get_output_edid(Display *dpy, RROutput output, char *edid) {\n\tAtom actual_type;\n\tint actual_format;\n\tunsigned long nitems;\n\tunsigned long bytes_after;\n\tunsigned char *prop;\n\n\t_XRRGetOutputProperty(dpy, output, XInternAtom(dpy, \"EDID\", 1), 0, 384,\n\t\t\t0, 0, 0, &actual_type, &actual_format, &nitems, &bytes_after, &prop);\n\n\tif(nitems > 0) {\n\t\tunsigned i;\n\t\tfor(i=0; i<nitems; i++) {\n\t\t\tedid[2*i] = ((prop[i] >> 4) & 0xf) + '0';\n\t\t\tif(edid[2*i] > '9') {\n\t\t\t\tedid[2*i] += 'a' - '0' - 10;\n\t\t\t}\n\n\t\t\tedid[2*i+1] = (prop[i] & 0xf) + '0';\n\t\t\tif(edid[2*i+1] > '9') {\n\t\t\t\tedid[2*i+1] += 'a' - '0' - 10;\n\t\t\t}\n\t\t}\n\t\tedid[nitems*2] = 0;\n\n\t\tXFree(prop);\n\t}\n\n\treturn nitems * 2;\n}\n\n/*\n\tHelper functions for the FakeInfo list structure\n*/\nstatic int list_length(struct FakeInfo *list) {\n\tint i = 0;\n\twhile(list) {\n\t\tlist = list->next;\n\t\ti += 1;\n\t}\n\treturn i;\n}\n\nstatic void free_list(struct FakeInfo *list) {\n\twhile(list) {\n\t\tstruct FakeInfo *last = list;\n\t\tlist = list->next;\n\t\tXfree(last);\n\t}\n}\n\nstatic struct FakeInfo *xid_in_list(struct FakeInfo *list, XID xid) {\n\twhile(list) {\n\t\tif(list->xid == xid || list->parent_xid == xid) return list;\n\t\tlist = list->next;\n\t}\n\treturn NULL;\n}\n\n/*\n\tThe following function augments the original XRRScreenResources with the\n\tfake outputs\n*/\nstatic struct FakeScreenResources *augment_resources(Display *dpy, XRRScreenResources *res) {\n\tstruct FakeInfo *outputs = NULL;\n\tstruct FakeInfo *crtcs = NULL;\n\tstruct FakeInfo *modes = NULL;\n\n\tstruct FakeInfo **outputs_end = &outputs;\n\tstruct FakeInfo **crtcs_end = &crtcs;\n\tstruct FakeInfo **modes_end = &modes;\n\n\t// Fill the FakeInfo structures\n\tif(open_configuration()) {\n\t\tstruct FakeScreenResources *retval = Xcalloc(1, sizeof(struct FakeScreenResources));\n\t\tretval->res = *res;\n\t\tretval->parent_res = res;\n\t\treturn retval;\n\t}\n\n\tint i;\n\tfor(i=0; i<res->noutput; i++) {\n\t\tchar output_edid[768];\n\t\tif(get_output_edid(dpy, res->outputs[i], output_edid) > 0) {\n\t\t\tconfig_handle_output(dpy, res, res->outputs[i], output_edid, &crtcs_end, &outputs_end, &modes_end);\n\t\t}\n\t}\n\n\tint ncrtc = res->ncrtc + list_length(crtcs);\n\tint noutput = res->noutput + list_length(outputs);\n\tint nmodes = res->nmode + list_length(modes);\n\n\t// Create a new XRRScreenResources with the fake information in place\n\tstruct FakeScreenResources *retval = Xmalloc(sizeof(struct FakeScreenResources) + ncrtc * sizeof(RRCrtc) + noutput * sizeof(RROutput) + nmodes * sizeof(XRRModeInfo));\n\n\tretval->res = *res;\n\tretval->parent_res = res;\n\tretval->fake_crtcs = crtcs;\n\tretval->fake_outputs = outputs;\n\n\t// We copy all the original CRTCs and add our fake ones\n\tretval->res.ncrtc = ncrtc;\n\tretval->res.crtcs = (void*)retval + sizeof(struct FakeScreenResources);\n\tmemcpy(retval->res.crtcs, res->crtcs, sizeof(RRCrtc) * res->ncrtc);\n\tRRCrtc *next_crtc = (void*)retval->res.crtcs + sizeof(RRCrtc) * res->ncrtc;\n\tstruct FakeInfo *tcrtc;\n\tfor(tcrtc = crtcs; tcrtc; tcrtc = tcrtc->next) {\n\t\t*next_crtc = tcrtc->xid;\n\t\tnext_crtc++;\n\t}\n\n\t// We copy the outputs that were not overridden and add our fake ones\n\tretval->res.noutput = 0;\n\tretval->res.outputs = (void*)retval->res.crtcs + sizeof(RRCrtc) * ncrtc;\n\tRROutput *next_output = retval->res.outputs;\n\tfor(i=0; i<res->noutput; i++) {\n\t\tif(xid_in_list(outputs, res->outputs[i])) {\n\t\t\tstruct FakeInfo *toutput;\n\t\t\tfor(toutput=outputs; toutput; toutput = toutput->next) {\n\t\t\t\tif((toutput->xid & ~XID_SPLIT_MASK) == res->outputs[i]) {\n\t\t\t\t\t*next_output = toutput->xid;\n\t\t\t\t\tnext_output++;\n\t\t\t\t\tretval->res.noutput++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t*next_output = res->outputs[i];\n\t\t\tnext_output++;\n\t\t\tretval->res.noutput++;\n\t\t}\n\t}\n\n\t// We copy all the original modes and add our fake ones\n\tretval->res.nmode = nmodes;\n\tretval->res.modes = (void*)retval->res.outputs + sizeof(RROutput) * noutput;\n\tmemcpy(retval->res.modes, res->modes, res->nmode * sizeof(XRRModeInfo));\n\tXRRModeInfo *next_mode = (void*)retval->res.modes + res->nmode * (sizeof(XRRModeInfo));\n\tstruct FakeInfo *tmode;\n\tfor(tmode = modes; tmode; tmode = tmode->next) {\n\t\t*next_mode = *(XRRModeInfo *)tmode->info;\n\t\tnext_mode++;\n\t}\n\tretval->fake_modes = modes;\n\n\treturn retval;\n}\n\nstatic void _init() __attribute__((constructor));\nstatic void _init() {\n\tvoid *xrandr_lib = dlopen(REAL_XRANDR_LIB, RTLD_LAZY | RTLD_GLOBAL);\n\n\t/*\n\t\tThe following macro is defined by the skeleton header. It initializes\n\t\tstatic variables called _XRRfn with references to the real XRRfn\n\t\tfunctions.\n\t*/\n\tFUNCTION_POINTER_INITIALIZATIONS;\n}\n\n/*\n\tOverridden library functions to add the fake output\n*/\n\nXRRScreenResources *XRRGetScreenResources(Display *dpy, Window window) {\n\t// Create a screen resources copy augmented with fake outputs & crtcs\n\tXRRScreenResources *res = _XRRGetScreenResources(dpy, window);\n\tstruct FakeScreenResources *retval = augment_resources(dpy, res);\n\treturn (XRRScreenResources *)retval;\n}\n\nvoid XRRFreeScreenResources(XRRScreenResources *resources) {\n\tstruct FakeScreenResources *res = (void *)resources;\n\n\t_XRRFreeScreenResources(res->parent_res);\n\tfree_list(res->fake_crtcs);\n\tfree_list(res->fake_outputs);\n\tfree_list(res->fake_modes);\n\tXfree(resources);\n}\n\nXRRScreenResources *XRRGetScreenResourcesCurrent(Display *dpy, Window window) {\n\tXRRScreenResources *res = _XRRGetScreenResourcesCurrent(dpy, window);\n\tstruct FakeScreenResources *retval = augment_resources(dpy, res);\n\treturn (XRRScreenResources *)retval;\n}\n\nXRROutputInfo *XRRGetOutputInfo(Display *dpy, XRRScreenResources *resources, RROutput output) {\n\tstruct FakeInfo *fake = xid_in_list(((struct FakeScreenResources *)resources)->fake_outputs, output);\n\tif(fake) {\n\t\t// We have to *clone* this here to mitigate issues due to the Gnome folks misusing the API, see\n\t\t// gnome bugzilla #755934\n\t\tXRROutputInfo *retval = Xmalloc(sizeof(XRROutputInfo));\n\t\tmemcpy(retval, fake->info, sizeof(XRROutputInfo));\n\t\treturn retval;\n\t}\n\n\tXRROutputInfo *retval = _XRRGetOutputInfo(dpy, resources, output & ~XID_SPLIT_MASK);\n\treturn retval;\n}\n\nvoid XRRFreeOutputInfo(XRROutputInfo *outputInfo) {\n\t// Note: If I can ever remove the cloning of the XRROutputInfo above, this won't work anymore!\n\t_XRRFreeOutputInfo(outputInfo);\n}\n\nXRRCrtcInfo *XRRGetCrtcInfo(Display *dpy, XRRScreenResources *resources, RRCrtc crtc) {\n\tstruct FakeInfo *fake = xid_in_list(((struct FakeScreenResources *)resources)->fake_crtcs, crtc);\n\tif(fake) {\n\t\t// We have to *clone* this here to mitigate issues due to the Gnome folks misusing the API, see\n\t\t// gnome bugzilla #755934\n\t\tXRRCrtcInfo *retval = Xmalloc(sizeof(XRRCrtcInfo));\n\t\tmemcpy(retval, fake->info, sizeof(XRRCrtcInfo));\n\t\treturn retval;\n\t}\n\n\tXRRCrtcInfo *retval = _XRRGetCrtcInfo(dpy, resources, crtc & ~XID_SPLIT_MASK);\n\treturn retval;\n}\n\nvoid XRRFreeCrtcInfo(XRRCrtcInfo *crtcInfo) {\n\t// Note: If I can ever remove the cloning of the XRROutputInfo above, this won't work anymore!\n\t_XRRFreeCrtcInfo(crtcInfo);\n}\n\nint XRRSetCrtcConfig(Display *dpy, XRRScreenResources *resources, RRCrtc crtc, Time timestamp, int x, int y, RRMode mode, Rotation rotation, RROutput *outputs, int noutputs) {\n\tif(crtc & XID_SPLIT_MASK) {\n\t\treturn 0;\n\t}\n\tint i;\n\tfor(i=0; i<noutputs; i++) {\n\t\tif(outputs[i] & XID_SPLIT_MASK) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn _XRRSetCrtcConfig(dpy, resources, crtc, timestamp, x, y, mode, rotation, outputs, noutputs);\n}\n\n/*\n\tFake Xinerama\n\n\tThis is little overhead with all the work we already did above..\n*/\n#ifndef NO_FAKE_XINERAMA\nBool XineramaQueryExtension(Display *dpy, int *event_base, int *error_base) {\n\treturn xTrue;\n}\nBool XineramaIsActive(Display *dpy) {\n\treturn xTrue;\n}\nStatus XineramaQueryVersion(Display *dpy, int *major, int *minor) {\n\t*major = 1;\n\t*minor = 0;\n\treturn xTrue;\n}\n\nXineramaScreenInfo* XineramaQueryScreens(Display *dpy, int *number) {\n\tXRRScreenResources *res = XRRGetScreenResources(dpy, XDefaultRootWindow(dpy));\n\n\tXineramaScreenInfo *retval = Xmalloc(res->noutput * sizeof(XineramaScreenInfo));\n\tint i;\n\t*number = 0;\n\tfor(i=0; i<res->noutput; i++) {\n\t\tXRROutputInfo *output = XRRGetOutputInfo(dpy, res, res->outputs[i]);\n\t\tif(output->crtc) {\n\t\t\tXRRCrtcInfo *crtc = XRRGetCrtcInfo(dpy, res, output->crtc);\n\n\t\t\tretval[*number].screen_number = *number;\n\t\t\tretval[*number].x_org = crtc->x;\n\t\t\tretval[*number].y_org = crtc->y;\n\t\t\tretval[*number].width = crtc->width;\n\t\t\tretval[*number].height = crtc->height;\n\t\t\t(*number)++;\n\t\t\tXRRFreeCrtcInfo(crtc);\n\t\t}\n\n\t\tXRRFreeOutputInfo(output);\n\t}\n\n\tXRRFreeScreenResources(res);\n\n    return retval;\n}\n#endif\n"
    },
    "skipped": [],
    "total_files": 16
}