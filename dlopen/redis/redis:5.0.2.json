{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.2-kgnq7exerr43idfj34trfbqmeiidhb7d/spack-src/src/module.c": "/*\n * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"cluster.h\"\n#include <dlfcn.h>\n\n#define REDISMODULE_CORE 1\n#include \"redismodule.h\"\n\n/* --------------------------------------------------------------------------\n * Private data structures used by the modules system. Those are data\n * structures that are never exposed to Redis Modules, if not as void\n * pointers that have an API the module can call with them)\n * -------------------------------------------------------------------------- */\n\n/* This structure represents a module inside the system. */\nstruct RedisModule {\n    void *handle;   /* Module dlopen() handle. */\n    char *name;     /* Module name. */\n    int ver;        /* Module version. We use just progressive integers. */\n    int apiver;     /* Module API version as requested during initialization.*/\n    list *types;    /* Module data types. */\n};\ntypedef struct RedisModule RedisModule;\n\nstatic dict *modules; /* Hash table of modules. SDS -> RedisModule ptr.*/\n\n/* Entries in the context->amqueue array, representing objects to free\n * when the callback returns. */\nstruct AutoMemEntry {\n    void *ptr;\n    int type;\n};\n\n/* AutMemEntry type field values. */\n#define REDISMODULE_AM_KEY 0\n#define REDISMODULE_AM_STRING 1\n#define REDISMODULE_AM_REPLY 2\n#define REDISMODULE_AM_FREED 3 /* Explicitly freed by user already. */\n#define REDISMODULE_AM_DICT 4\n\n/* The pool allocator block. Redis Modules can allocate memory via this special\n * allocator that will automatically release it all once the callback returns.\n * This means that it can only be used for ephemeral allocations. However\n * there are two advantages for modules to use this API:\n *\n * 1) The memory is automatically released when the callback returns.\n * 2) This allocator is faster for many small allocations since whole blocks\n *    are allocated, and small pieces returned to the caller just advancing\n *    the index of the allocation.\n *\n * Allocations are always rounded to the size of the void pointer in order\n * to always return aligned memory chunks. */\n\n#define REDISMODULE_POOL_ALLOC_MIN_SIZE (1024*8)\n#define REDISMODULE_POOL_ALLOC_ALIGN (sizeof(void*))\n\ntypedef struct RedisModulePoolAllocBlock {\n    uint32_t size;\n    uint32_t used;\n    struct RedisModulePoolAllocBlock *next;\n    char memory[];\n} RedisModulePoolAllocBlock;\n\n/* This structure represents the context in which Redis modules operate.\n * Most APIs module can access, get a pointer to the context, so that the API\n * implementation can hold state across calls, or remember what to free after\n * the call and so forth.\n *\n * Note that not all the context structure is always filled with actual values\n * but only the fields needed in a given context. */\n\nstruct RedisModuleBlockedClient;\n\nstruct RedisModuleCtx {\n    void *getapifuncptr;            /* NOTE: Must be the first field. */\n    struct RedisModule *module;     /* Module reference. */\n    client *client;                 /* Client calling a command. */\n    struct RedisModuleBlockedClient *blocked_client; /* Blocked client for\n                                                        thread safe context. */\n    struct AutoMemEntry *amqueue;   /* Auto memory queue of objects to free. */\n    int amqueue_len;                /* Number of slots in amqueue. */\n    int amqueue_used;               /* Number of used slots in amqueue. */\n    int flags;                      /* REDISMODULE_CTX_... flags. */\n    void **postponed_arrays;        /* To set with RM_ReplySetArrayLength(). */\n    int postponed_arrays_count;     /* Number of entries in postponed_arrays. */\n    void *blocked_privdata;         /* Privdata set when unblocking a client. */\n\n    /* Used if there is the REDISMODULE_CTX_KEYS_POS_REQUEST flag set. */\n    int *keys_pos;\n    int keys_count;\n\n    struct RedisModulePoolAllocBlock *pa_head;\n};\ntypedef struct RedisModuleCtx RedisModuleCtx;\n\n#define REDISMODULE_CTX_INIT {(void*)(unsigned long)&RM_GetApi, NULL, NULL, NULL, NULL, 0, 0, 0, NULL, 0, NULL, NULL, 0, NULL}\n#define REDISMODULE_CTX_MULTI_EMITTED (1<<0)\n#define REDISMODULE_CTX_AUTO_MEMORY (1<<1)\n#define REDISMODULE_CTX_KEYS_POS_REQUEST (1<<2)\n#define REDISMODULE_CTX_BLOCKED_REPLY (1<<3)\n#define REDISMODULE_CTX_BLOCKED_TIMEOUT (1<<4)\n#define REDISMODULE_CTX_THREAD_SAFE (1<<5)\n#define REDISMODULE_CTX_BLOCKED_DISCONNECTED (1<<6)\n\n/* This represents a Redis key opened with RM_OpenKey(). */\nstruct RedisModuleKey {\n    RedisModuleCtx *ctx;\n    redisDb *db;\n    robj *key;      /* Key name object. */\n    robj *value;    /* Value object, or NULL if the key was not found. */\n    void *iter;     /* Iterator. */\n    int mode;       /* Opening mode. */\n\n    /* Zset iterator. */\n    uint32_t ztype;         /* REDISMODULE_ZSET_RANGE_* */\n    zrangespec zrs;         /* Score range. */\n    zlexrangespec zlrs;     /* Lex range. */\n    uint32_t zstart;        /* Start pos for positional ranges. */\n    uint32_t zend;          /* End pos for positional ranges. */\n    void *zcurrent;         /* Zset iterator current node. */\n    int zer;                /* Zset iterator end reached flag\n                               (true if end was reached). */\n};\ntypedef struct RedisModuleKey RedisModuleKey;\n\n/* RedisModuleKey 'ztype' values. */\n#define REDISMODULE_ZSET_RANGE_NONE 0       /* This must always be 0. */\n#define REDISMODULE_ZSET_RANGE_LEX 1\n#define REDISMODULE_ZSET_RANGE_SCORE 2\n#define REDISMODULE_ZSET_RANGE_POS 3\n\n/* Function pointer type of a function representing a command inside\n * a Redis module. */\nstruct RedisModuleBlockedClient;\ntypedef int (*RedisModuleCmdFunc) (RedisModuleCtx *ctx, void **argv, int argc);\ntypedef void (*RedisModuleDisconnectFunc) (RedisModuleCtx *ctx, struct RedisModuleBlockedClient *bc);\n\n/* This struct holds the information about a command registered by a module.*/\nstruct RedisModuleCommandProxy {\n    struct RedisModule *module;\n    RedisModuleCmdFunc func;\n    struct redisCommand *rediscmd;\n};\ntypedef struct RedisModuleCommandProxy RedisModuleCommandProxy;\n\n#define REDISMODULE_REPLYFLAG_NONE 0\n#define REDISMODULE_REPLYFLAG_TOPARSE (1<<0) /* Protocol must be parsed. */\n#define REDISMODULE_REPLYFLAG_NESTED (1<<1)  /* Nested reply object. No proto\n                                                or struct free. */\n\n/* Reply of RM_Call() function. The function is filled in a lazy\n * way depending on the function called on the reply structure. By default\n * only the type, proto and protolen are filled. */\ntypedef struct RedisModuleCallReply {\n    RedisModuleCtx *ctx;\n    int type;       /* REDISMODULE_REPLY_... */\n    int flags;      /* REDISMODULE_REPLYFLAG_...  */\n    size_t len;     /* Len of strings or num of elements of arrays. */\n    char *proto;    /* Raw reply protocol. An SDS string at top-level object. */\n    size_t protolen;/* Length of protocol. */\n    union {\n        const char *str; /* String pointer for string and error replies. This\n                            does not need to be freed, always points inside\n                            a reply->proto buffer of the reply object or, in\n                            case of array elements, of parent reply objects. */\n        long long ll;    /* Reply value for integer reply. */\n        struct RedisModuleCallReply *array; /* Array of sub-reply elements. */\n    } val;\n} RedisModuleCallReply;\n\n/* Structure representing a blocked client. We get a pointer to such\n * an object when blocking from modules. */\ntypedef struct RedisModuleBlockedClient {\n    client *client;  /* Pointer to the blocked client. or NULL if the client\n                        was destroyed during the life of this object. */\n    RedisModule *module;    /* Module blocking the client. */\n    RedisModuleCmdFunc reply_callback; /* Reply callback on normal completion.*/\n    RedisModuleCmdFunc timeout_callback; /* Reply callback on timeout. */\n    RedisModuleDisconnectFunc disconnect_callback; /* Called on disconnection.*/\n    void (*free_privdata)(RedisModuleCtx*,void*);/* privdata cleanup callback.*/\n    void *privdata;     /* Module private data that may be used by the reply\n                           or timeout callback. It is set via the\n                           RedisModule_UnblockClient() API. */\n    client *reply_client;           /* Fake client used to accumulate replies\n                                       in thread safe contexts. */\n    int dbid;           /* Database number selected by the original client. */\n} RedisModuleBlockedClient;\n\nstatic pthread_mutex_t moduleUnblockedClientsMutex = PTHREAD_MUTEX_INITIALIZER;\nstatic list *moduleUnblockedClients;\n\n/* We need a mutex that is unlocked / relocked in beforeSleep() in order to\n * allow thread safe contexts to execute commands at a safe moment. */\nstatic pthread_mutex_t moduleGIL = PTHREAD_MUTEX_INITIALIZER;\n\n\n/* Function pointer type for keyspace event notification subscriptions from modules. */\ntypedef int (*RedisModuleNotificationFunc) (RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key);\n\n/* Keyspace notification subscriber information.\n * See RM_SubscribeToKeyspaceEvents() for more information. */\ntypedef struct RedisModuleKeyspaceSubscriber {\n    /* The module subscribed to the event */\n    RedisModule *module;\n    /* Notification callback in the module*/\n    RedisModuleNotificationFunc notify_callback;\n    /* A bit mask of the events the module is interested in */\n    int event_mask;\n    /* Active flag set on entry, to avoid reentrant subscribers\n     * calling themselves */\n    int active;\n} RedisModuleKeyspaceSubscriber;\n\n/* The module keyspace notification subscribers list */\nstatic list *moduleKeyspaceSubscribers;\n\n/* Static client recycled for when we need to provide a context with a client\n * in a situation where there is no client to provide. This avoidsallocating\n * a new client per round. For instance this is used in the keyspace\n * notifications, timers and cluster messages callbacks. */\nstatic client *moduleFreeContextReusedClient;\n\n/* Data structures related to the exported dictionary data structure. */\ntypedef struct RedisModuleDict {\n    rax *rax;                       /* The radix tree. */\n} RedisModuleDict;\n\ntypedef struct RedisModuleDictIter {\n    RedisModuleDict *dict;\n    raxIterator ri;\n} RedisModuleDictIter;\n\n/* --------------------------------------------------------------------------\n * Prototypes\n * -------------------------------------------------------------------------- */\n\nvoid RM_FreeCallReply(RedisModuleCallReply *reply);\nvoid RM_CloseKey(RedisModuleKey *key);\nvoid autoMemoryCollect(RedisModuleCtx *ctx);\nrobj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap);\nvoid moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx);\nvoid RM_ZsetRangeStop(RedisModuleKey *kp);\nstatic void zsetKeyReset(RedisModuleKey *key);\nvoid RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d);\n\n/* --------------------------------------------------------------------------\n * Heap allocation raw functions\n * -------------------------------------------------------------------------- */\n\n/* Use like malloc(). Memory allocated with this function is reported in\n * Redis INFO memory, used for keys eviction according to maxmemory settings\n * and in general is taken into account as memory allocated by Redis.\n * You should avoid using malloc(). */\nvoid *RM_Alloc(size_t bytes) {\n    return zmalloc(bytes);\n}\n\n/* Use like calloc(). Memory allocated with this function is reported in\n * Redis INFO memory, used for keys eviction according to maxmemory settings\n * and in general is taken into account as memory allocated by Redis.\n * You should avoid using calloc() directly. */\nvoid *RM_Calloc(size_t nmemb, size_t size) {\n    return zcalloc(nmemb*size);\n}\n\n/* Use like realloc() for memory obtained with RedisModule_Alloc(). */\nvoid* RM_Realloc(void *ptr, size_t bytes) {\n    return zrealloc(ptr,bytes);\n}\n\n/* Use like free() for memory obtained by RedisModule_Alloc() and\n * RedisModule_Realloc(). However you should never try to free with\n * RedisModule_Free() memory allocated with malloc() inside your module. */\nvoid RM_Free(void *ptr) {\n    zfree(ptr);\n}\n\n/* Like strdup() but returns memory allocated with RedisModule_Alloc(). */\nchar *RM_Strdup(const char *str) {\n    return zstrdup(str);\n}\n\n/* --------------------------------------------------------------------------\n * Pool allocator\n * -------------------------------------------------------------------------- */\n\n/* Release the chain of blocks used for pool allocations. */\nvoid poolAllocRelease(RedisModuleCtx *ctx) {\n    RedisModulePoolAllocBlock *head = ctx->pa_head, *next;\n\n    while(head != NULL) {\n        next = head->next;\n        zfree(head);\n        head = next;\n    }\n    ctx->pa_head = NULL;\n}\n\n/* Return heap allocated memory that will be freed automatically when the\n * module callback function returns. Mostly suitable for small allocations\n * that are short living and must be released when the callback returns\n * anyway. The returned memory is aligned to the architecture word size\n * if at least word size bytes are requested, otherwise it is just\n * aligned to the next power of two, so for example a 3 bytes request is\n * 4 bytes aligned while a 2 bytes request is 2 bytes aligned.\n *\n * There is no realloc style function since when this is needed to use the\n * pool allocator is not a good idea.\n *\n * The function returns NULL if `bytes` is 0. */\nvoid *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes) {\n    if (bytes == 0) return NULL;\n    RedisModulePoolAllocBlock *b = ctx->pa_head;\n    size_t left = b ? b->size - b->used : 0;\n\n    /* Fix alignment. */\n    if (left >= bytes) {\n        size_t alignment = REDISMODULE_POOL_ALLOC_ALIGN;\n        while (bytes < alignment && alignment/2 >= bytes) alignment /= 2;\n        if (b->used % alignment)\n            b->used += alignment - (b->used % alignment);\n        left = (b->used > b->size) ? 0 : b->size - b->used;\n    }\n\n    /* Create a new block if needed. */\n    if (left < bytes) {\n        size_t blocksize = REDISMODULE_POOL_ALLOC_MIN_SIZE;\n        if (blocksize < bytes) blocksize = bytes;\n        b = zmalloc(sizeof(*b) + blocksize);\n        b->size = blocksize;\n        b->used = 0;\n        b->next = ctx->pa_head;\n        ctx->pa_head = b;\n    }\n\n    char *retval = b->memory + b->used;\n    b->used += bytes;\n    return retval;\n}\n\n/* --------------------------------------------------------------------------\n * Helpers for modules API implementation\n * -------------------------------------------------------------------------- */\n\n/* Create an empty key of the specified type. 'kp' must point to a key object\n * opened for writing where the .value member is set to NULL because the\n * key was found to be non existing.\n *\n * On success REDISMODULE_OK is returned and the key is populated with\n * the value of the specified type. The function fails and returns\n * REDISMODULE_ERR if:\n *\n * 1) The key is not open for writing.\n * 2) The key is not empty.\n * 3) The specified type is unknown.\n */\nint moduleCreateEmptyKey(RedisModuleKey *key, int type) {\n    robj *obj;\n\n    /* The key must be open for writing and non existing to proceed. */\n    if (!(key->mode & REDISMODULE_WRITE) || key->value)\n        return REDISMODULE_ERR;\n\n    switch(type) {\n    case REDISMODULE_KEYTYPE_LIST:\n        obj = createQuicklistObject();\n        quicklistSetOptions(obj->ptr, server.list_max_ziplist_size,\n                            server.list_compress_depth);\n        break;\n    case REDISMODULE_KEYTYPE_ZSET:\n        obj = createZsetZiplistObject();\n        break;\n    case REDISMODULE_KEYTYPE_HASH:\n        obj = createHashObject();\n        break;\n    default: return REDISMODULE_ERR;\n    }\n    dbAdd(key->db,key->key,obj);\n    key->value = obj;\n    return REDISMODULE_OK;\n}\n\n/* This function is called in low-level API implementation functions in order\n * to check if the value associated with the key remained empty after an\n * operation that removed elements from an aggregate data type.\n *\n * If this happens, the key is deleted from the DB and the key object state\n * is set to the right one in order to be targeted again by write operations\n * possibly recreating the key if needed.\n *\n * The function returns 1 if the key value object is found empty and is\n * deleted, otherwise 0 is returned. */\nint moduleDelKeyIfEmpty(RedisModuleKey *key) {\n    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL) return 0;\n    int isempty;\n    robj *o = key->value;\n\n    switch(o->type) {\n    case OBJ_LIST: isempty = listTypeLength(o) == 0; break;\n    case OBJ_SET: isempty = setTypeSize(o) == 0; break;\n    case OBJ_ZSET: isempty = zsetLength(o) == 0; break;\n    case OBJ_HASH : isempty = hashTypeLength(o) == 0; break;\n    default: isempty = 0;\n    }\n\n    if (isempty) {\n        dbDelete(key->db,key->key);\n        key->value = NULL;\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n/* --------------------------------------------------------------------------\n * Service API exported to modules\n *\n * Note that all the exported APIs are called RM_<funcname> in the core\n * and RedisModule_<funcname> in the module side (defined as function\n * pointers in redismodule.h). In this way the dynamic linker does not\n * mess with our global function pointers, overriding it with the symbols\n * defined in the main executable having the same names.\n * -------------------------------------------------------------------------- */\n\n/* Lookup the requested module API and store the function pointer into the\n * target pointer. The function returns REDISMODULE_ERR if there is no such\n * named API, otherwise REDISMODULE_OK.\n *\n * This function is not meant to be used by modules developer, it is only\n * used implicitly by including redismodule.h. */\nint RM_GetApi(const char *funcname, void **targetPtrPtr) {\n    dictEntry *he = dictFind(server.moduleapi, funcname);\n    if (!he) return REDISMODULE_ERR;\n    *targetPtrPtr = dictGetVal(he);\n    return REDISMODULE_OK;\n}\n\n/* Free the context after the user function was called. */\nvoid moduleFreeContext(RedisModuleCtx *ctx) {\n    autoMemoryCollect(ctx);\n    poolAllocRelease(ctx);\n    if (ctx->postponed_arrays) {\n        zfree(ctx->postponed_arrays);\n        ctx->postponed_arrays_count = 0;\n        serverLog(LL_WARNING,\n            \"API misuse detected in module %s: \"\n            \"RedisModule_ReplyWithArray(REDISMODULE_POSTPONED_ARRAY_LEN) \"\n            \"not matched by the same number of RedisModule_SetReplyArrayLen() \"\n            \"calls.\",\n            ctx->module->name);\n    }\n    if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) freeClient(ctx->client);\n}\n\n/* Helper function for when a command callback is called, in order to handle\n * details needed to correctly replicate commands. */\nvoid moduleHandlePropagationAfterCommandCallback(RedisModuleCtx *ctx) {\n    client *c = ctx->client;\n\n    if (c->flags & CLIENT_LUA) return;\n\n    /* Handle the replication of the final EXEC, since whatever a command\n     * emits is always wrapped around MULTI/EXEC. */\n    if (ctx->flags & REDISMODULE_CTX_MULTI_EMITTED) {\n        robj *propargv[1];\n        propargv[0] = createStringObject(\"EXEC\",4);\n        alsoPropagate(server.execCommand,c->db->id,propargv,1,\n            PROPAGATE_AOF|PROPAGATE_REPL);\n        decrRefCount(propargv[0]);\n    }\n}\n\n/* This Redis command binds the normal Redis command invocation with commands\n * exported by modules. */\nvoid RedisModuleCommandDispatcher(client *c) {\n    RedisModuleCommandProxy *cp = (void*)(unsigned long)c->cmd->getkeys_proc;\n    RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n\n    ctx.module = cp->module;\n    ctx.client = c;\n    cp->func(&ctx,(void**)c->argv,c->argc);\n    moduleHandlePropagationAfterCommandCallback(&ctx);\n    moduleFreeContext(&ctx);\n}\n\n/* This function returns the list of keys, with the same interface as the\n * 'getkeys' function of the native commands, for module commands that exported\n * the \"getkeys-api\" flag during the registration. This is done when the\n * list of keys are not at fixed positions, so that first/last/step cannot\n * be used.\n *\n * In order to accomplish its work, the module command is called, flagging\n * the context in a way that the command can recognize this is a special\n * \"get keys\" call by calling RedisModule_IsKeysPositionRequest(ctx). */\nint *moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {\n    RedisModuleCommandProxy *cp = (void*)(unsigned long)cmd->getkeys_proc;\n    RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n\n    ctx.module = cp->module;\n    ctx.client = NULL;\n    ctx.flags |= REDISMODULE_CTX_KEYS_POS_REQUEST;\n    cp->func(&ctx,(void**)argv,argc);\n    int *res = ctx.keys_pos;\n    if (numkeys) *numkeys = ctx.keys_count;\n    moduleFreeContext(&ctx);\n    return res;\n}\n\n/* Return non-zero if a module command, that was declared with the\n * flag \"getkeys-api\", is called in a special way to get the keys positions\n * and not to get executed. Otherwise zero is returned. */\nint RM_IsKeysPositionRequest(RedisModuleCtx *ctx) {\n    return (ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST) != 0;\n}\n\n/* When a module command is called in order to obtain the position of\n * keys, since it was flagged as \"getkeys-api\" during the registration,\n * the command implementation checks for this special call using the\n * RedisModule_IsKeysPositionRequest() API and uses this function in\n * order to report keys, like in the following example:\n *\n *     if (RedisModule_IsKeysPositionRequest(ctx)) {\n *         RedisModule_KeyAtPos(ctx,1);\n *         RedisModule_KeyAtPos(ctx,2);\n *     }\n *\n *  Note: in the example below the get keys API would not be needed since\n *  keys are at fixed positions. This interface is only used for commands\n *  with a more complex structure. */\nvoid RM_KeyAtPos(RedisModuleCtx *ctx, int pos) {\n    if (!(ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST)) return;\n    if (pos <= 0) return;\n    ctx->keys_pos = zrealloc(ctx->keys_pos,sizeof(int)*(ctx->keys_count+1));\n    ctx->keys_pos[ctx->keys_count++] = pos;\n}\n\n/* Helper for RM_CreateCommand(). Turns a string representing command\n * flags into the command flags used by the Redis core.\n *\n * It returns the set of flags, or -1 if unknown flags are found. */\nint commandFlagsFromString(char *s) {\n    int count, j;\n    int flags = 0;\n    sds *tokens = sdssplitlen(s,strlen(s),\" \",1,&count);\n    for (j = 0; j < count; j++) {\n        char *t = tokens[j];\n        if (!strcasecmp(t,\"write\")) flags |= CMD_WRITE;\n        else if (!strcasecmp(t,\"readonly\")) flags |= CMD_READONLY;\n        else if (!strcasecmp(t,\"admin\")) flags |= CMD_ADMIN;\n        else if (!strcasecmp(t,\"deny-oom\")) flags |= CMD_DENYOOM;\n        else if (!strcasecmp(t,\"deny-script\")) flags |= CMD_NOSCRIPT;\n        else if (!strcasecmp(t,\"allow-loading\")) flags |= CMD_LOADING;\n        else if (!strcasecmp(t,\"pubsub\")) flags |= CMD_PUBSUB;\n        else if (!strcasecmp(t,\"random\")) flags |= CMD_RANDOM;\n        else if (!strcasecmp(t,\"allow-stale\")) flags |= CMD_STALE;\n        else if (!strcasecmp(t,\"no-monitor\")) flags |= CMD_SKIP_MONITOR;\n        else if (!strcasecmp(t,\"fast\")) flags |= CMD_FAST;\n        else if (!strcasecmp(t,\"getkeys-api\")) flags |= CMD_MODULE_GETKEYS;\n        else if (!strcasecmp(t,\"no-cluster\")) flags |= CMD_MODULE_NO_CLUSTER;\n        else break;\n    }\n    sdsfreesplitres(tokens,count);\n    if (j != count) return -1; /* Some token not processed correctly. */\n    return flags;\n}\n\n/* Register a new command in the Redis server, that will be handled by\n * calling the function pointer 'func' using the RedisModule calling\n * convention. The function returns REDISMODULE_ERR if the specified command\n * name is already busy or a set of invalid flags were passed, otherwise\n * REDISMODULE_OK is returned and the new command is registered.\n *\n * This function must be called during the initialization of the module\n * inside the RedisModule_OnLoad() function. Calling this function outside\n * of the initialization function is not defined.\n *\n * The command function type is the following:\n *\n *      int MyCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);\n *\n * And is supposed to always return REDISMODULE_OK.\n *\n * The set of flags 'strflags' specify the behavior of the command, and should\n * be passed as a C string composed of space separated words, like for\n * example \"write deny-oom\". The set of flags are:\n *\n * * **\"write\"**:     The command may modify the data set (it may also read\n *                    from it).\n * * **\"readonly\"**:  The command returns data from keys but never writes.\n * * **\"admin\"**:     The command is an administrative command (may change\n *                    replication or perform similar tasks).\n * * **\"deny-oom\"**:  The command may use additional memory and should be\n *                    denied during out of memory conditions.\n * * **\"deny-script\"**:   Don't allow this command in Lua scripts.\n * * **\"allow-loading\"**: Allow this command while the server is loading data.\n *                        Only commands not interacting with the data set\n *                        should be allowed to run in this mode. If not sure\n *                        don't use this flag.\n * * **\"pubsub\"**:    The command publishes things on Pub/Sub channels.\n * * **\"random\"**:    The command may have different outputs even starting\n *                    from the same input arguments and key values.\n * * **\"allow-stale\"**: The command is allowed to run on slaves that don't\n *                      serve stale data. Don't use if you don't know what\n *                      this means.\n * * **\"no-monitor\"**: Don't propagate the command on monitor. Use this if\n *                     the command has sensible data among the arguments.\n * * **\"fast\"**:      The command time complexity is not greater\n *                    than O(log(N)) where N is the size of the collection or\n *                    anything else representing the normal scalability\n *                    issue with the command.\n * * **\"getkeys-api\"**: The command implements the interface to return\n *                      the arguments that are keys. Used when start/stop/step\n *                      is not enough because of the command syntax.\n * * **\"no-cluster\"**: The command should not register in Redis Cluster\n *                     since is not designed to work with it because, for\n *                     example, is unable to report the position of the\n *                     keys, programmatically creates key names, or any\n *                     other reason.\n */\nint RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) {\n    int flags = strflags ? commandFlagsFromString((char*)strflags) : 0;\n    if (flags == -1) return REDISMODULE_ERR;\n    if ((flags & CMD_MODULE_NO_CLUSTER) && server.cluster_enabled)\n        return REDISMODULE_ERR;\n\n    struct redisCommand *rediscmd;\n    RedisModuleCommandProxy *cp;\n    sds cmdname = sdsnew(name);\n\n    /* Check if the command name is busy. */\n    if (lookupCommand(cmdname) != NULL) {\n        sdsfree(cmdname);\n        return REDISMODULE_ERR;\n    }\n\n    /* Create a command \"proxy\", which is a structure that is referenced\n     * in the command table, so that the generic command that works as\n     * binding between modules and Redis, can know what function to call\n     * and what the module is.\n     *\n     * Note that we use the Redis command table 'getkeys_proc' in order to\n     * pass a reference to the command proxy structure. */\n    cp = zmalloc(sizeof(*cp));\n    cp->module = ctx->module;\n    cp->func = cmdfunc;\n    cp->rediscmd = zmalloc(sizeof(*rediscmd));\n    cp->rediscmd->name = cmdname;\n    cp->rediscmd->proc = RedisModuleCommandDispatcher;\n    cp->rediscmd->arity = -1;\n    cp->rediscmd->flags = flags | CMD_MODULE;\n    cp->rediscmd->getkeys_proc = (redisGetKeysProc*)(unsigned long)cp;\n    cp->rediscmd->firstkey = firstkey;\n    cp->rediscmd->lastkey = lastkey;\n    cp->rediscmd->keystep = keystep;\n    cp->rediscmd->microseconds = 0;\n    cp->rediscmd->calls = 0;\n    dictAdd(server.commands,sdsdup(cmdname),cp->rediscmd);\n    dictAdd(server.orig_commands,sdsdup(cmdname),cp->rediscmd);\n    return REDISMODULE_OK;\n}\n\n/* Called by RM_Init() to setup the `ctx->module` structure.\n *\n * This is an internal function, Redis modules developers don't need\n * to use it. */\nvoid RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {\n    RedisModule *module;\n\n    if (ctx->module != NULL) return;\n    module = zmalloc(sizeof(*module));\n    module->name = sdsnew((char*)name);\n    module->ver = ver;\n    module->apiver = apiver;\n    module->types = listCreate();\n    ctx->module = module;\n}\n\n/* Return non-zero if the module name is busy.\n * Otherwise zero is returned. */\nint RM_IsModuleNameBusy(const char *name) {\n    sds modulename = sdsnew(name);\n    dictEntry *de = dictFind(modules,modulename);\n    sdsfree(modulename);\n    return de != NULL;\n}\n\n/* Return the current UNIX time in milliseconds. */\nlong long RM_Milliseconds(void) {\n    return mstime();\n}\n\n/* --------------------------------------------------------------------------\n * Automatic memory management for modules\n * -------------------------------------------------------------------------- */\n\n/* Enable automatic memory management. See API.md for more information.\n *\n * The function must be called as the first function of a command implementation\n * that wants to use automatic memory. */\nvoid RM_AutoMemory(RedisModuleCtx *ctx) {\n    ctx->flags |= REDISMODULE_CTX_AUTO_MEMORY;\n}\n\n/* Add a new object to release automatically when the callback returns. */\nvoid autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {\n    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;\n    if (ctx->amqueue_used == ctx->amqueue_len) {\n        ctx->amqueue_len *= 2;\n        if (ctx->amqueue_len < 16) ctx->amqueue_len = 16;\n        ctx->amqueue = zrealloc(ctx->amqueue,sizeof(struct AutoMemEntry)*ctx->amqueue_len);\n    }\n    ctx->amqueue[ctx->amqueue_used].type = type;\n    ctx->amqueue[ctx->amqueue_used].ptr = ptr;\n    ctx->amqueue_used++;\n}\n\n/* Mark an object as freed in the auto release queue, so that users can still\n * free things manually if they want.\n *\n * The function returns 1 if the object was actually found in the auto memory\n * pool, otherwise 0 is returned. */\nint autoMemoryFreed(RedisModuleCtx *ctx, int type, void *ptr) {\n    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return 0;\n\n    int count = (ctx->amqueue_used+1)/2;\n    for (int j = 0; j < count; j++) {\n        for (int side = 0; side < 2; side++) {\n            /* For side = 0 check right side of the array, for\n             * side = 1 check the left side instead (zig-zag scanning). */\n            int i = (side == 0) ? (ctx->amqueue_used - 1 - j) : j;\n            if (ctx->amqueue[i].type == type &&\n                ctx->amqueue[i].ptr == ptr)\n            {\n                ctx->amqueue[i].type = REDISMODULE_AM_FREED;\n\n                /* Switch the freed element and the last element, to avoid growing\n                 * the queue unnecessarily if we allocate/free in a loop */\n                if (i != ctx->amqueue_used-1) {\n                    ctx->amqueue[i] = ctx->amqueue[ctx->amqueue_used-1];\n                }\n\n                /* Reduce the size of the queue because we either moved the top\n                 * element elsewhere or freed it */\n                ctx->amqueue_used--;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\n/* Release all the objects in queue. */\nvoid autoMemoryCollect(RedisModuleCtx *ctx) {\n    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;\n    /* Clear the AUTO_MEMORY flag from the context, otherwise the functions\n     * we call to free the resources, will try to scan the auto release\n     * queue to mark the entries as freed. */\n    ctx->flags &= ~REDISMODULE_CTX_AUTO_MEMORY;\n    int j;\n    for (j = 0; j < ctx->amqueue_used; j++) {\n        void *ptr = ctx->amqueue[j].ptr;\n        switch(ctx->amqueue[j].type) {\n        case REDISMODULE_AM_STRING: decrRefCount(ptr); break;\n        case REDISMODULE_AM_REPLY: RM_FreeCallReply(ptr); break;\n        case REDISMODULE_AM_KEY: RM_CloseKey(ptr); break;\n        case REDISMODULE_AM_DICT: RM_FreeDict(NULL,ptr); break;\n        }\n    }\n    ctx->flags |= REDISMODULE_CTX_AUTO_MEMORY;\n    zfree(ctx->amqueue);\n    ctx->amqueue = NULL;\n    ctx->amqueue_len = 0;\n    ctx->amqueue_used = 0;\n}\n\n/* --------------------------------------------------------------------------\n * String objects APIs\n * -------------------------------------------------------------------------- */\n\n/* Create a new module string object. The returned string must be freed\n * with RedisModule_FreeString(), unless automatic memory is enabled.\n *\n * The string is created by copying the `len` bytes starting\n * at `ptr`. No reference is retained to the passed buffer.\n *\n * The module context 'ctx' is optional and may be NULL if you want to create\n * a string out of the context scope. However in that case, the automatic\n * memory management will not be available, and the string memory must be\n * managed manually. */\nRedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len) {\n    RedisModuleString *o = createStringObject(ptr,len);\n    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);\n    return o;\n}\n\n/* Create a new module string object from a printf format and arguments.\n * The returned string must be freed with RedisModule_FreeString(), unless\n * automatic memory is enabled.\n *\n * The string is created using the sds formatter function sdscatvprintf().\n *\n * The passed context 'ctx' may be NULL if necessary, see the\n * RedisModule_CreateString() documentation for more info. */\nRedisModuleString *RM_CreateStringPrintf(RedisModuleCtx *ctx, const char *fmt, ...) {\n    sds s = sdsempty();\n\n    va_list ap;\n    va_start(ap, fmt);\n    s = sdscatvprintf(s, fmt, ap);\n    va_end(ap);\n\n    RedisModuleString *o = createObject(OBJ_STRING, s);\n    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);\n\n    return o;\n}\n\n\n/* Like RedisModule_CreatString(), but creates a string starting from a long long\n * integer instead of taking a buffer and its length.\n *\n * The returned string must be released with RedisModule_FreeString() or by\n * enabling automatic memory management.\n *\n * The passed context 'ctx' may be NULL if necessary, see the\n * RedisModule_CreateString() documentation for more info. */\nRedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll) {\n    char buf[LONG_STR_SIZE];\n    size_t len = ll2string(buf,sizeof(buf),ll);\n    return RM_CreateString(ctx,buf,len);\n}\n\n/* Like RedisModule_CreatString(), but creates a string starting from another\n * RedisModuleString.\n *\n * The returned string must be released with RedisModule_FreeString() or by\n * enabling automatic memory management.\n *\n * The passed context 'ctx' may be NULL if necessary, see the\n * RedisModule_CreateString() documentation for more info. */\nRedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str) {\n    RedisModuleString *o = dupStringObject(str);\n    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);\n    return o;\n}\n\n/* Free a module string object obtained with one of the Redis modules API calls\n * that return new string objects.\n *\n * It is possible to call this function even when automatic memory management\n * is enabled. In that case the string will be released ASAP and removed\n * from the pool of string to release at the end.\n *\n * If the string was created with a NULL context 'ctx', it is also possible to\n * pass ctx as NULL when releasing the string (but passing a context will not\n * create any issue). Strings created with a context should be freed also passing\n * the context, so if you want to free a string out of context later, make sure\n * to create it using a NULL context. */\nvoid RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str) {\n    decrRefCount(str);\n    if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str);\n}\n\n/* Every call to this function, will make the string 'str' requiring\n * an additional call to RedisModule_FreeString() in order to really\n * free the string. Note that the automatic freeing of the string obtained\n * enabling modules automatic memory management counts for one\n * RedisModule_FreeString() call (it is just executed automatically).\n *\n * Normally you want to call this function when, at the same time\n * the following conditions are true:\n *\n * 1) You have automatic memory management enabled.\n * 2) You want to create string objects.\n * 3) Those string objects you create need to live *after* the callback\n *    function(for example a command implementation) creating them returns.\n *\n * Usually you want this in order to store the created string object\n * into your own data structure, for example when implementing a new data\n * type.\n *\n * Note that when memory management is turned off, you don't need\n * any call to RetainString() since creating a string will always result\n * into a string that lives after the callback function returns, if\n * no FreeString() call is performed.\n *\n * It is possible to call this function with a NULL context. */\nvoid RM_RetainString(RedisModuleCtx *ctx, RedisModuleString *str) {\n    if (ctx == NULL || !autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str)) {\n        /* Increment the string reference counting only if we can't\n         * just remove the object from the list of objects that should\n         * be reclaimed. Why we do that, instead of just incrementing\n         * the refcount in any case, and let the automatic FreeString()\n         * call at the end to bring the refcount back at the desired\n         * value? Because this way we ensure that the object refcount\n         * value is 1 (instead of going to 2 to be dropped later to 1)\n         * after the call to this function. This is needed for functions\n         * like RedisModule_StringAppendBuffer() to work. */\n        incrRefCount(str);\n    }\n}\n\n/* Given a string module object, this function returns the string pointer\n * and length of the string. The returned pointer and length should only\n * be used for read only accesses and never modified. */\nconst char *RM_StringPtrLen(const RedisModuleString *str, size_t *len) {\n    if (str == NULL) {\n        const char *errmsg = \"(NULL string reply referenced in module)\";\n        if (len) *len = strlen(errmsg);\n        return errmsg;\n    }\n    if (len) *len = sdslen(str->ptr);\n    return str->ptr;\n}\n\n/* --------------------------------------------------------------------------\n * Higher level string operations\n * ------------------------------------------------------------------------- */\n\n/* Convert the string into a long long integer, storing it at `*ll`.\n * Returns REDISMODULE_OK on success. If the string can't be parsed\n * as a valid, strict long long (no spaces before/after), REDISMODULE_ERR\n * is returned. */\nint RM_StringToLongLong(const RedisModuleString *str, long long *ll) {\n    return string2ll(str->ptr,sdslen(str->ptr),ll) ? REDISMODULE_OK :\n                                                     REDISMODULE_ERR;\n}\n\n/* Convert the string into a double, storing it at `*d`.\n * Returns REDISMODULE_OK on success or REDISMODULE_ERR if the string is\n * not a valid string representation of a double value. */\nint RM_StringToDouble(const RedisModuleString *str, double *d) {\n    int retval = getDoubleFromObject(str,d);\n    return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* Compare two string objects, returning -1, 0 or 1 respectively if\n * a < b, a == b, a > b. Strings are compared byte by byte as two\n * binary blobs without any encoding care / collation attempt. */\nint RM_StringCompare(RedisModuleString *a, RedisModuleString *b) {\n    return compareStringObjects(a,b);\n}\n\n/* Return the (possibly modified in encoding) input 'str' object if\n * the string is unshared, otherwise NULL is returned. */\nRedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {\n    if (str->refcount != 1) {\n        serverLog(LL_WARNING,\n            \"Module attempted to use an in-place string modify operation \"\n            \"with a string referenced multiple times. Please check the code \"\n            \"for API usage correctness.\");\n        return NULL;\n    }\n    if (str->encoding == OBJ_ENCODING_EMBSTR) {\n        /* Note: here we \"leak\" the additional allocation that was\n         * used in order to store the embedded string in the object. */\n        str->ptr = sdsnewlen(str->ptr,sdslen(str->ptr));\n        str->encoding = OBJ_ENCODING_RAW;\n    } else if (str->encoding == OBJ_ENCODING_INT) {\n        /* Convert the string from integer to raw encoding. */\n        str->ptr = sdsfromlonglong((long)str->ptr);\n        str->encoding = OBJ_ENCODING_RAW;\n    }\n    return str;\n}\n\n/* Append the specified buffer to the string 'str'. The string must be a\n * string created by the user that is referenced only a single time, otherwise\n * REDISMODULE_ERR is returned and the operation is not performed. */\nint RM_StringAppendBuffer(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len) {\n    UNUSED(ctx);\n    str = moduleAssertUnsharedString(str);\n    if (str == NULL) return REDISMODULE_ERR;\n    str->ptr = sdscatlen(str->ptr,buf,len);\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Reply APIs\n *\n * Most functions always return REDISMODULE_OK so you can use it with\n * 'return' in order to return from the command implementation with:\n *\n *     if (... some condition ...)\n *         return RM_ReplyWithLongLong(ctx,mycount);\n * -------------------------------------------------------------------------- */\n\n/* Send an error about the number of arguments given to the command,\n * citing the command name in the error message.\n *\n * Example:\n *\n *     if (argc != 3) return RedisModule_WrongArity(ctx);\n */\nint RM_WrongArity(RedisModuleCtx *ctx) {\n    addReplyErrorFormat(ctx->client,\n        \"wrong number of arguments for '%s' command\",\n        (char*)ctx->client->argv[0]->ptr);\n    return REDISMODULE_OK;\n}\n\n/* Return the client object the `RM_Reply*` functions should target.\n * Normally this is just `ctx->client`, that is the client that called\n * the module command, however in the case of thread safe contexts there\n * is no directly associated client (since it would not be safe to access\n * the client from a thread), so instead the blocked client object referenced\n * in the thread safe context, has a fake client that we just use to accumulate\n * the replies. Later, when the client is unblocked, the accumulated replies\n * are appended to the actual client.\n *\n * The function returns the client pointer depending on the context, or\n * NULL if there is no potential client. This happens when we are in the\n * context of a thread safe context that was not initialized with a blocked\n * client object. Other contexts without associated clients are the ones\n * initialized to run the timers callbacks. */\nclient *moduleGetReplyClient(RedisModuleCtx *ctx) {\n    if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) {\n        if (ctx->blocked_client)\n            return ctx->blocked_client->reply_client;\n        else\n            return NULL;\n    } else {\n        /* If this is a non thread safe context, just return the client\n         * that is running the command if any. This may be NULL as well\n         * in the case of contexts that are not executed with associated\n         * clients, like timer contexts. */\n        return ctx->client;\n    }\n}\n\n/* Send an integer reply to the client, with the specified long long value.\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    addReplyLongLong(c,ll);\n    return REDISMODULE_OK;\n}\n\n/* Reply with an error or simple string (status message). Used to implement\n * ReplyWithSimpleString() and ReplyWithError().\n * The function always returns REDISMODULE_OK. */\nint replyWithStatus(RedisModuleCtx *ctx, const char *msg, char *prefix) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    sds strmsg = sdsnewlen(prefix,1);\n    strmsg = sdscat(strmsg,msg);\n    strmsg = sdscatlen(strmsg,\"\\r\\n\",2);\n    addReplySds(c,strmsg);\n    return REDISMODULE_OK;\n}\n\n/* Reply with the error 'err'.\n *\n * Note that 'err' must contain all the error, including\n * the initial error code. The function only provides the initial \"-\", so\n * the usage is, for example:\n *\n *     RedisModule_ReplyWithError(ctx,\"ERR Wrong Type\");\n *\n * and not just:\n *\n *     RedisModule_ReplyWithError(ctx,\"Wrong Type\");\n *\n * The function always returns REDISMODULE_OK.\n */\nint RM_ReplyWithError(RedisModuleCtx *ctx, const char *err) {\n    return replyWithStatus(ctx,err,\"-\");\n}\n\n/* Reply with a simple string (+... \\r\\n in RESP protocol). This replies\n * are suitable only when sending a small non-binary string with small\n * overhead, like \"OK\" or similar replies.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg) {\n    return replyWithStatus(ctx,msg,\"+\");\n}\n\n/* Reply with an array type of 'len' elements. However 'len' other calls\n * to `ReplyWith*` style functions must follow in order to emit the elements\n * of the array.\n *\n * When producing arrays with a number of element that is not known beforehand\n * the function can be called with the special count\n * REDISMODULE_POSTPONED_ARRAY_LEN, and the actual number of elements can be\n * later set with RedisModule_ReplySetArrayLength() (which will set the\n * latest \"open\" count if there are multiple ones).\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithArray(RedisModuleCtx *ctx, long len) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    if (len == REDISMODULE_POSTPONED_ARRAY_LEN) {\n        ctx->postponed_arrays = zrealloc(ctx->postponed_arrays,sizeof(void*)*\n                (ctx->postponed_arrays_count+1));\n        ctx->postponed_arrays[ctx->postponed_arrays_count] =\n            addDeferredMultiBulkLength(c);\n        ctx->postponed_arrays_count++;\n    } else {\n        addReplyMultiBulkLen(c,len);\n    }\n    return REDISMODULE_OK;\n}\n\n/* When RedisModule_ReplyWithArray() is used with the argument\n * REDISMODULE_POSTPONED_ARRAY_LEN, because we don't know beforehand the number\n * of items we are going to output as elements of the array, this function\n * will take care to set the array length.\n *\n * Since it is possible to have multiple array replies pending with unknown\n * length, this function guarantees to always set the latest array length\n * that was created in a postponed way.\n *\n * For example in order to output an array like [1,[10,20,30]] we\n * could write:\n *\n *      RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN);\n *      RedisModule_ReplyWithLongLong(ctx,1);\n *      RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN);\n *      RedisModule_ReplyWithLongLong(ctx,10);\n *      RedisModule_ReplyWithLongLong(ctx,20);\n *      RedisModule_ReplyWithLongLong(ctx,30);\n *      RedisModule_ReplySetArrayLength(ctx,3); // Set len of 10,20,30 array.\n *      RedisModule_ReplySetArrayLength(ctx,2); // Set len of top array\n *\n * Note that in the above example there is no reason to postpone the array\n * length, since we produce a fixed number of elements, but in the practice\n * the code may use an iterator or other ways of creating the output so\n * that is not easy to calculate in advance the number of elements.\n */\nvoid RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return;\n    if (ctx->postponed_arrays_count == 0) {\n        serverLog(LL_WARNING,\n            \"API misuse detected in module %s: \"\n            \"RedisModule_ReplySetArrayLength() called without previous \"\n            \"RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN) \"\n            \"call.\", ctx->module->name);\n            return;\n    }\n    ctx->postponed_arrays_count--;\n    setDeferredMultiBulkLength(c,\n            ctx->postponed_arrays[ctx->postponed_arrays_count],\n            len);\n    if (ctx->postponed_arrays_count == 0) {\n        zfree(ctx->postponed_arrays);\n        ctx->postponed_arrays = NULL;\n    }\n}\n\n/* Reply with a bulk string, taking in input a C buffer pointer and length.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    addReplyBulkCBuffer(c,(char*)buf,len);\n    return REDISMODULE_OK;\n}\n\n/* Reply with a bulk string, taking in input a RedisModuleString object.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    addReplyBulk(c,str);\n    return REDISMODULE_OK;\n}\n\n/* Reply to the client with a NULL. In the RESP protocol a NULL is encoded\n * as the string \"$-1\\r\\n\".\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithNull(RedisModuleCtx *ctx) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    addReply(c,shared.nullbulk);\n    return REDISMODULE_OK;\n}\n\n/* Reply exactly what a Redis command returned us with RedisModule_Call().\n * This function is useful when we use RedisModule_Call() in order to\n * execute some command, as we want to reply to the client exactly the\n * same reply we obtained by the command.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    sds proto = sdsnewlen(reply->proto, reply->protolen);\n    addReplySds(c,proto);\n    return REDISMODULE_OK;\n}\n\n/* Send a string reply obtained converting the double 'd' into a bulk string.\n * This function is basically equivalent to converting a double into\n * a string into a C buffer, and then calling the function\n * RedisModule_ReplyWithStringBuffer() with the buffer and length.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithDouble(RedisModuleCtx *ctx, double d) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    addReplyDouble(c,d);\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Commands replication API\n * -------------------------------------------------------------------------- */\n\n/* Helper function to replicate MULTI the first time we replicate something\n * in the context of a command execution. EXEC will be handled by the\n * RedisModuleCommandDispatcher() function. */\nvoid moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx) {\n    /* Skip this if client explicitly wrap the command with MULTI, or if\n     * the module command was called by a script. */\n    if (ctx->client->flags & (CLIENT_MULTI|CLIENT_LUA)) return;\n    /* If we already emitted MULTI return ASAP. */\n    if (ctx->flags & REDISMODULE_CTX_MULTI_EMITTED) return;\n    /* If this is a thread safe context, we do not want to wrap commands\n     * executed into MUTLI/EXEC, they are executed as single commands\n     * from an external client in essence. */\n    if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) return;\n    execCommandPropagateMulti(ctx->client);\n    ctx->flags |= REDISMODULE_CTX_MULTI_EMITTED;\n}\n\n/* Replicate the specified command and arguments to slaves and AOF, as effect\n * of execution of the calling command implementation.\n *\n * The replicated commands are always wrapped into the MULTI/EXEC that\n * contains all the commands replicated in a given module command\n * execution. However the commands replicated with RedisModule_Call()\n * are the first items, the ones replicated with RedisModule_Replicate()\n * will all follow before the EXEC.\n *\n * Modules should try to use one interface or the other.\n *\n * This command follows exactly the same interface of RedisModule_Call(),\n * so a set of format specifiers must be passed, followed by arguments\n * matching the provided format specifiers.\n *\n * Please refer to RedisModule_Call() for more information.\n *\n * The command returns REDISMODULE_ERR if the format specifiers are invalid\n * or the command name does not belong to a known command. */\nint RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {\n    struct redisCommand *cmd;\n    robj **argv = NULL;\n    int argc = 0, flags = 0, j;\n    va_list ap;\n\n    cmd = lookupCommandByCString((char*)cmdname);\n    if (!cmd) return REDISMODULE_ERR;\n\n    /* Create the client and dispatch the command. */\n    va_start(ap, fmt);\n    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);\n    va_end(ap);\n    if (argv == NULL) return REDISMODULE_ERR;\n\n    /* Replicate! */\n    moduleReplicateMultiIfNeeded(ctx);\n    alsoPropagate(cmd,ctx->client->db->id,argv,argc,\n        PROPAGATE_AOF|PROPAGATE_REPL);\n\n    /* Release the argv. */\n    for (j = 0; j < argc; j++) decrRefCount(argv[j]);\n    zfree(argv);\n    server.dirty++;\n    return REDISMODULE_OK;\n}\n\n/* This function will replicate the command exactly as it was invoked\n * by the client. Note that this function will not wrap the command into\n * a MULTI/EXEC stanza, so it should not be mixed with other replication\n * commands.\n *\n * Basically this form of replication is useful when you want to propagate\n * the command to the slaves and AOF file exactly as it was called, since\n * the command can just be re-executed to deterministically re-create the\n * new state starting from the old one.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplicateVerbatim(RedisModuleCtx *ctx) {\n    alsoPropagate(ctx->client->cmd,ctx->client->db->id,\n        ctx->client->argv,ctx->client->argc,\n        PROPAGATE_AOF|PROPAGATE_REPL);\n    server.dirty++;\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * DB and Key APIs -- Generic API\n * -------------------------------------------------------------------------- */\n\n/* Return the ID of the current client calling the currently active module\n * command. The returned ID has a few guarantees:\n *\n * 1. The ID is different for each different client, so if the same client\n *    executes a module command multiple times, it can be recognized as\n *    having the same ID, otherwise the ID will be different.\n * 2. The ID increases monotonically. Clients connecting to the server later\n *    are guaranteed to get IDs greater than any past ID previously seen.\n *\n * Valid IDs are from 1 to 2^64-1. If 0 is returned it means there is no way\n * to fetch the ID in the context the function was currently called. */\nunsigned long long RM_GetClientId(RedisModuleCtx *ctx) {\n    if (ctx->client == NULL) return 0;\n    return ctx->client->id;\n}\n\n/* Return the currently selected DB. */\nint RM_GetSelectedDb(RedisModuleCtx *ctx) {\n    return ctx->client->db->id;\n}\n\n\n/* Return the current context's flags. The flags provide information on the\n * current request context (whether the client is a Lua script or in a MULTI),\n * and about the Redis instance in general, i.e replication and persistence.\n *\n * The available flags are:\n *\n *  * REDISMODULE_CTX_FLAGS_LUA: The command is running in a Lua script\n *\n *  * REDISMODULE_CTX_FLAGS_MULTI: The command is running inside a transaction\n *\n *  * REDISMODULE_CTX_FLAGS_MASTER: The Redis instance is a master\n *\n *  * REDISMODULE_CTX_FLAGS_SLAVE: The Redis instance is a slave\n *\n *  * REDISMODULE_CTX_FLAGS_READONLY: The Redis instance is read-only\n *\n *  * REDISMODULE_CTX_FLAGS_CLUSTER: The Redis instance is in cluster mode\n *\n *  * REDISMODULE_CTX_FLAGS_AOF: The Redis instance has AOF enabled\n *\n *  * REDISMODULE_CTX_FLAGS_RDB: The instance has RDB enabled\n *\n *  * REDISMODULE_CTX_FLAGS_MAXMEMORY:  The instance has Maxmemory set\n *\n *  * REDISMODULE_CTX_FLAGS_EVICT:  Maxmemory is set and has an eviction\n *    policy that may delete keys\n *\n *  * REDISMODULE_CTX_FLAGS_OOM: Redis is out of memory according to the\n *    maxmemory setting.\n *\n *  * REDISMODULE_CTX_FLAGS_OOM_WARNING: Less than 25% of memory remains before\n *                                       reaching the maxmemory level.\n */\nint RM_GetContextFlags(RedisModuleCtx *ctx) {\n\n    int flags = 0;\n    /* Client specific flags */\n    if (ctx->client) {\n        if (ctx->client->flags & CLIENT_LUA)\n         flags |= REDISMODULE_CTX_FLAGS_LUA;\n        if (ctx->client->flags & CLIENT_MULTI)\n         flags |= REDISMODULE_CTX_FLAGS_MULTI;\n    }\n\n    if (server.cluster_enabled)\n        flags |= REDISMODULE_CTX_FLAGS_CLUSTER;\n\n    /* Maxmemory and eviction policy */\n    if (server.maxmemory > 0) {\n        flags |= REDISMODULE_CTX_FLAGS_MAXMEMORY;\n\n        if (server.maxmemory_policy != MAXMEMORY_NO_EVICTION)\n            flags |= REDISMODULE_CTX_FLAGS_EVICT;\n    }\n\n    /* Persistence flags */\n    if (server.aof_state != AOF_OFF)\n        flags |= REDISMODULE_CTX_FLAGS_AOF;\n    if (server.saveparamslen > 0)\n        flags |= REDISMODULE_CTX_FLAGS_RDB;\n\n    /* Replication flags */\n    if (server.masterhost == NULL) {\n        flags |= REDISMODULE_CTX_FLAGS_MASTER;\n    } else {\n        flags |= REDISMODULE_CTX_FLAGS_SLAVE;\n        if (server.repl_slave_ro)\n            flags |= REDISMODULE_CTX_FLAGS_READONLY;\n    }\n\n    /* OOM flag. */\n    float level;\n    int retval = getMaxmemoryState(NULL,NULL,NULL,&level);\n    if (retval == C_ERR) flags |= REDISMODULE_CTX_FLAGS_OOM;\n    if (level > 0.75) flags |= REDISMODULE_CTX_FLAGS_OOM_WARNING;\n\n    return flags;\n}\n\n/* Change the currently selected DB. Returns an error if the id\n * is out of range.\n *\n * Note that the client will retain the currently selected DB even after\n * the Redis command implemented by the module calling this function\n * returns.\n *\n * If the module command wishes to change something in a different DB and\n * returns back to the original one, it should call RedisModule_GetSelectedDb()\n * before in order to restore the old DB number before returning. */\nint RM_SelectDb(RedisModuleCtx *ctx, int newid) {\n    int retval = selectDb(ctx->client,newid);\n    return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* Return an handle representing a Redis key, so that it is possible\n * to call other APIs with the key handle as argument to perform\n * operations on the key.\n *\n * The return value is the handle representing the key, that must be\n * closed with RM_CloseKey().\n *\n * If the key does not exist and WRITE mode is requested, the handle\n * is still returned, since it is possible to perform operations on\n * a yet not existing key (that will be created, for example, after\n * a list push operation). If the mode is just READ instead, and the\n * key does not exist, NULL is returned. However it is still safe to\n * call RedisModule_CloseKey() and RedisModule_KeyType() on a NULL\n * value. */\nvoid *RM_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode) {\n    RedisModuleKey *kp;\n    robj *value;\n\n    if (mode & REDISMODULE_WRITE) {\n        value = lookupKeyWrite(ctx->client->db,keyname);\n    } else {\n        value = lookupKeyRead(ctx->client->db,keyname);\n        if (value == NULL) {\n            return NULL;\n        }\n    }\n\n    /* Setup the key handle. */\n    kp = zmalloc(sizeof(*kp));\n    kp->ctx = ctx;\n    kp->db = ctx->client->db;\n    kp->key = keyname;\n    incrRefCount(keyname);\n    kp->value = value;\n    kp->iter = NULL;\n    kp->mode = mode;\n    zsetKeyReset(kp);\n    autoMemoryAdd(ctx,REDISMODULE_AM_KEY,kp);\n    return (void*)kp;\n}\n\n/* Close a key handle. */\nvoid RM_CloseKey(RedisModuleKey *key) {\n    if (key == NULL) return;\n    if (key->mode & REDISMODULE_WRITE) signalModifiedKey(key->db,key->key);\n    /* TODO: if (key->iter) RM_KeyIteratorStop(kp); */\n    RM_ZsetRangeStop(key);\n    decrRefCount(key->key);\n    autoMemoryFreed(key->ctx,REDISMODULE_AM_KEY,key);\n    zfree(key);\n}\n\n/* Return the type of the key. If the key pointer is NULL then\n * REDISMODULE_KEYTYPE_EMPTY is returned. */\nint RM_KeyType(RedisModuleKey *key) {\n    if (key == NULL || key->value ==  NULL) return REDISMODULE_KEYTYPE_EMPTY;\n    /* We map between defines so that we are free to change the internal\n     * defines as desired. */\n    switch(key->value->type) {\n    case OBJ_STRING: return REDISMODULE_KEYTYPE_STRING;\n    case OBJ_LIST: return REDISMODULE_KEYTYPE_LIST;\n    case OBJ_SET: return REDISMODULE_KEYTYPE_SET;\n    case OBJ_ZSET: return REDISMODULE_KEYTYPE_ZSET;\n    case OBJ_HASH: return REDISMODULE_KEYTYPE_HASH;\n    case OBJ_MODULE: return REDISMODULE_KEYTYPE_MODULE;\n    default: return 0;\n    }\n}\n\n/* Return the length of the value associated with the key.\n * For strings this is the length of the string. For all the other types\n * is the number of elements (just counting keys for hashes).\n *\n * If the key pointer is NULL or the key is empty, zero is returned. */\nsize_t RM_ValueLength(RedisModuleKey *key) {\n    if (key == NULL || key->value == NULL) return 0;\n    switch(key->value->type) {\n    case OBJ_STRING: return stringObjectLen(key->value);\n    case OBJ_LIST: return listTypeLength(key->value);\n    case OBJ_SET: return setTypeSize(key->value);\n    case OBJ_ZSET: return zsetLength(key->value);\n    case OBJ_HASH: return hashTypeLength(key->value);\n    default: return 0;\n    }\n}\n\n/* If the key is open for writing, remove it, and setup the key to\n * accept new writes as an empty key (that will be created on demand).\n * On success REDISMODULE_OK is returned. If the key is not open for\n * writing REDISMODULE_ERR is returned. */\nint RM_DeleteKey(RedisModuleKey *key) {\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value) {\n        dbDelete(key->db,key->key);\n        key->value = NULL;\n    }\n    return REDISMODULE_OK;\n}\n\n/* If the key is open for writing, unlink it (that is delete it in a \n * non-blocking way, not reclaiming memory immediately) and setup the key to\n * accept new writes as an empty key (that will be created on demand).\n * On success REDISMODULE_OK is returned. If the key is not open for\n * writing REDISMODULE_ERR is returned. */\nint RM_UnlinkKey(RedisModuleKey *key) {\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value) {\n        dbAsyncDelete(key->db,key->key);\n        key->value = NULL;\n    }\n    return REDISMODULE_OK;\n}\n\n/* Return the key expire value, as milliseconds of remaining TTL.\n * If no TTL is associated with the key or if the key is empty,\n * REDISMODULE_NO_EXPIRE is returned. */\nmstime_t RM_GetExpire(RedisModuleKey *key) {\n    mstime_t expire = getExpire(key->db,key->key);\n    if (expire == -1 || key->value == NULL) return -1;\n    expire -= mstime();\n    return expire >= 0 ? expire : 0;\n}\n\n/* Set a new expire for the key. If the special expire\n * REDISMODULE_NO_EXPIRE is set, the expire is cancelled if there was\n * one (the same as the PERSIST command).\n *\n * Note that the expire must be provided as a positive integer representing\n * the number of milliseconds of TTL the key should have.\n *\n * The function returns REDISMODULE_OK on success or REDISMODULE_ERR if\n * the key was not open for writing or is an empty key. */\nint RM_SetExpire(RedisModuleKey *key, mstime_t expire) {\n    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL)\n        return REDISMODULE_ERR;\n    if (expire != REDISMODULE_NO_EXPIRE) {\n        expire += mstime();\n        setExpire(key->ctx->client,key->db,key->key,expire);\n    } else {\n        removeExpire(key->db,key->key);\n    }\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Key API for String type\n * -------------------------------------------------------------------------- */\n\n/* If the key is open for writing, set the specified string 'str' as the\n * value of the key, deleting the old value if any.\n * On success REDISMODULE_OK is returned. If the key is not open for\n * writing or there is an active iterator, REDISMODULE_ERR is returned. */\nint RM_StringSet(RedisModuleKey *key, RedisModuleString *str) {\n    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;\n    RM_DeleteKey(key);\n    setKey(key->db,key->key,str);\n    key->value = str;\n    return REDISMODULE_OK;\n}\n\n/* Prepare the key associated string value for DMA access, and returns\n * a pointer and size (by reference), that the user can use to read or\n * modify the string in-place accessing it directly via pointer.\n *\n * The 'mode' is composed by bitwise OR-ing the following flags:\n *\n *     REDISMODULE_READ -- Read access\n *     REDISMODULE_WRITE -- Write access\n *\n * If the DMA is not requested for writing, the pointer returned should\n * only be accessed in a read-only fashion.\n *\n * On error (wrong type) NULL is returned.\n *\n * DMA access rules:\n *\n * 1. No other key writing function should be called since the moment\n * the pointer is obtained, for all the time we want to use DMA access\n * to read or modify the string.\n *\n * 2. Each time RM_StringTruncate() is called, to continue with the DMA\n * access, RM_StringDMA() should be called again to re-obtain\n * a new pointer and length.\n *\n * 3. If the returned pointer is not NULL, but the length is zero, no\n * byte can be touched (the string is empty, or the key itself is empty)\n * so a RM_StringTruncate() call should be used if there is to enlarge\n * the string, and later call StringDMA() again to get the pointer.\n */\nchar *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {\n    /* We need to return *some* pointer for empty keys, we just return\n     * a string literal pointer, that is the advantage to be mapped into\n     * a read only memory page, so the module will segfault if a write\n     * attempt is performed. */\n    char *emptystring = \"<dma-empty-string>\";\n    if (key->value == NULL) {\n        *len = 0;\n        return emptystring;\n    }\n\n    if (key->value->type != OBJ_STRING) return NULL;\n\n    /* For write access, and even for read access if the object is encoded,\n     * we unshare the string (that has the side effect of decoding it). */\n    if ((mode & REDISMODULE_WRITE) || key->value->encoding != OBJ_ENCODING_RAW)\n        key->value = dbUnshareStringValue(key->db, key->key, key->value);\n\n    *len = sdslen(key->value->ptr);\n    return key->value->ptr;\n}\n\n/* If the string is open for writing and is of string type, resize it, padding\n * with zero bytes if the new length is greater than the old one.\n *\n * After this call, RM_StringDMA() must be called again to continue\n * DMA access with the new pointer.\n *\n * The function returns REDISMODULE_OK on success, and REDISMODULE_ERR on\n * error, that is, the key is not open for writing, is not a string\n * or resizing for more than 512 MB is requested.\n *\n * If the key is empty, a string key is created with the new string value\n * unless the new length value requested is zero. */\nint RM_StringTruncate(RedisModuleKey *key, size_t newlen) {\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value && key->value->type != OBJ_STRING) return REDISMODULE_ERR;\n    if (newlen > 512*1024*1024) return REDISMODULE_ERR;\n\n    /* Empty key and new len set to 0. Just return REDISMODULE_OK without\n     * doing anything. */\n    if (key->value == NULL && newlen == 0) return REDISMODULE_OK;\n\n    if (key->value == NULL) {\n        /* Empty key: create it with the new size. */\n        robj *o = createObject(OBJ_STRING,sdsnewlen(NULL, newlen));\n        setKey(key->db,key->key,o);\n        key->value = o;\n        decrRefCount(o);\n    } else {\n        /* Unshare and resize. */\n        key->value = dbUnshareStringValue(key->db, key->key, key->value);\n        size_t curlen = sdslen(key->value->ptr);\n        if (newlen > curlen) {\n            key->value->ptr = sdsgrowzero(key->value->ptr,newlen);\n        } else if (newlen < curlen) {\n            sdsrange(key->value->ptr,0,newlen-1);\n            /* If the string is too wasteful, reallocate it. */\n            if (sdslen(key->value->ptr) < sdsavail(key->value->ptr))\n                key->value->ptr = sdsRemoveFreeSpace(key->value->ptr);\n        }\n    }\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Key API for List type\n * -------------------------------------------------------------------------- */\n\n/* Push an element into a list, on head or tail depending on 'where' argument.\n * If the key pointer is about an empty key opened for writing, the key\n * is created. On error (key opened for read-only operations or of the wrong\n * type) REDISMODULE_ERR is returned, otherwise REDISMODULE_OK is returned. */\nint RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele) {\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value && key->value->type != OBJ_LIST) return REDISMODULE_ERR;\n    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_LIST);\n    listTypePush(key->value, ele,\n        (where == REDISMODULE_LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL);\n    return REDISMODULE_OK;\n}\n\n/* Pop an element from the list, and returns it as a module string object\n * that the user should be free with RM_FreeString() or by enabling\n * automatic memory. 'where' specifies if the element should be popped from\n * head or tail. The command returns NULL if:\n * 1) The list is empty.\n * 2) The key was not open for writing.\n * 3) The key is not a list. */\nRedisModuleString *RM_ListPop(RedisModuleKey *key, int where) {\n    if (!(key->mode & REDISMODULE_WRITE) ||\n        key->value == NULL ||\n        key->value->type != OBJ_LIST) return NULL;\n    robj *ele = listTypePop(key->value,\n        (where == REDISMODULE_LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL);\n    robj *decoded = getDecodedObject(ele);\n    decrRefCount(ele);\n    moduleDelKeyIfEmpty(key);\n    autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,decoded);\n    return decoded;\n}\n\n/* --------------------------------------------------------------------------\n * Key API for Sorted Set type\n * -------------------------------------------------------------------------- */\n\n/* Conversion from/to public flags of the Modules API and our private flags,\n * so that we have everything decoupled. */\nint RM_ZsetAddFlagsToCoreFlags(int flags) {\n    int retflags = 0;\n    if (flags & REDISMODULE_ZADD_XX) retflags |= ZADD_XX;\n    if (flags & REDISMODULE_ZADD_NX) retflags |= ZADD_NX;\n    return retflags;\n}\n\n/* See previous function comment. */\nint RM_ZsetAddFlagsFromCoreFlags(int flags) {\n    int retflags = 0;\n    if (flags & ZADD_ADDED) retflags |= REDISMODULE_ZADD_ADDED;\n    if (flags & ZADD_UPDATED) retflags |= REDISMODULE_ZADD_UPDATED;\n    if (flags & ZADD_NOP) retflags |= REDISMODULE_ZADD_NOP;\n    return retflags;\n}\n\n/* Add a new element into a sorted set, with the specified 'score'.\n * If the element already exists, the score is updated.\n *\n * A new sorted set is created at value if the key is an empty open key\n * setup for writing.\n *\n * Additional flags can be passed to the function via a pointer, the flags\n * are both used to receive input and to communicate state when the function\n * returns. 'flagsptr' can be NULL if no special flags are used.\n *\n * The input flags are:\n *\n *     REDISMODULE_ZADD_XX: Element must already exist. Do nothing otherwise.\n *     REDISMODULE_ZADD_NX: Element must not exist. Do nothing otherwise.\n *\n * The output flags are:\n *\n *     REDISMODULE_ZADD_ADDED: The new element was added to the sorted set.\n *     REDISMODULE_ZADD_UPDATED: The score of the element was updated.\n *     REDISMODULE_ZADD_NOP: No operation was performed because XX or NX flags.\n *\n * On success the function returns REDISMODULE_OK. On the following errors\n * REDISMODULE_ERR is returned:\n *\n * * The key was not opened for writing.\n * * The key is of the wrong type.\n * * 'score' double value is not a number (NaN).\n */\nint RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr) {\n    int flags = 0;\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);\n    if (flagsptr) flags = RM_ZsetAddFlagsToCoreFlags(*flagsptr);\n    if (zsetAdd(key->value,score,ele->ptr,&flags,NULL) == 0) {\n        if (flagsptr) *flagsptr = 0;\n        return REDISMODULE_ERR;\n    }\n    if (flagsptr) *flagsptr = RM_ZsetAddFlagsFromCoreFlags(flags);\n    return REDISMODULE_OK;\n}\n\n/* This function works exactly like RM_ZsetAdd(), but instead of setting\n * a new score, the score of the existing element is incremented, or if the\n * element does not already exist, it is added assuming the old score was\n * zero.\n *\n * The input and output flags, and the return value, have the same exact\n * meaning, with the only difference that this function will return\n * REDISMODULE_ERR even when 'score' is a valid double number, but adding it\n * to the existing score results into a NaN (not a number) condition.\n *\n * This function has an additional field 'newscore', if not NULL is filled\n * with the new score of the element after the increment, if no error\n * is returned. */\nint RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore) {\n    int flags = 0;\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);\n    if (flagsptr) flags = RM_ZsetAddFlagsToCoreFlags(*flagsptr);\n    flags |= ZADD_INCR;\n    if (zsetAdd(key->value,score,ele->ptr,&flags,newscore) == 0) {\n        if (flagsptr) *flagsptr = 0;\n        return REDISMODULE_ERR;\n    }\n    /* zsetAdd() may signal back that the resulting score is not a number. */\n    if (flagsptr && (*flagsptr & ZADD_NAN)) {\n        *flagsptr = 0;\n        return REDISMODULE_ERR;\n    }\n    if (flagsptr) *flagsptr = RM_ZsetAddFlagsFromCoreFlags(flags);\n    return REDISMODULE_OK;\n}\n\n/* Remove the specified element from the sorted set.\n * The function returns REDISMODULE_OK on success, and REDISMODULE_ERR\n * on one of the following conditions:\n *\n * * The key was not opened for writing.\n * * The key is of the wrong type.\n *\n * The return value does NOT indicate the fact the element was really\n * removed (since it existed) or not, just if the function was executed\n * with success.\n *\n * In order to know if the element was removed, the additional argument\n * 'deleted' must be passed, that populates the integer by reference\n * setting it to 1 or 0 depending on the outcome of the operation.\n * The 'deleted' argument can be NULL if the caller is not interested\n * to know if the element was really removed.\n *\n * Empty keys will be handled correctly by doing nothing. */\nint RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted) {\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n    if (key->value != NULL && zsetDel(key->value,ele->ptr)) {\n        if (deleted) *deleted = 1;\n    } else {\n        if (deleted) *deleted = 0;\n    }\n    return REDISMODULE_OK;\n}\n\n/* On success retrieve the double score associated at the sorted set element\n * 'ele' and returns REDISMODULE_OK. Otherwise REDISMODULE_ERR is returned\n * to signal one of the following conditions:\n *\n * * There is no such element 'ele' in the sorted set.\n * * The key is not a sorted set.\n * * The key is an open empty key.\n */\nint RM_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score) {\n    if (key->value == NULL) return REDISMODULE_ERR;\n    if (key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n    if (zsetScore(key->value,ele->ptr,score) == C_ERR) return REDISMODULE_ERR;\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Key API for Sorted Set iterator\n * -------------------------------------------------------------------------- */\n\nvoid zsetKeyReset(RedisModuleKey *key) {\n    key->ztype = REDISMODULE_ZSET_RANGE_NONE;\n    key->zcurrent = NULL;\n    key->zer = 1;\n}\n\n/* Stop a sorted set iteration. */\nvoid RM_ZsetRangeStop(RedisModuleKey *key) {\n    /* Free resources if needed. */\n    if (key->ztype == REDISMODULE_ZSET_RANGE_LEX)\n        zslFreeLexRange(&key->zlrs);\n    /* Setup sensible values so that misused iteration API calls when an\n     * iterator is not active will result into something more sensible\n     * than crashing. */\n    zsetKeyReset(key);\n}\n\n/* Return the \"End of range\" flag value to signal the end of the iteration. */\nint RM_ZsetRangeEndReached(RedisModuleKey *key) {\n    return key->zer;\n}\n\n/* Helper function for RM_ZsetFirstInScoreRange() and RM_ZsetLastInScoreRange().\n * Setup the sorted set iteration according to the specified score range\n * (see the functions calling it for more info). If 'first' is true the\n * first element in the range is used as a starting point for the iterator\n * otherwise the last. Return REDISMODULE_OK on success otherwise\n * REDISMODULE_ERR. */\nint zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex, int first) {\n    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n\n    RM_ZsetRangeStop(key);\n    key->ztype = REDISMODULE_ZSET_RANGE_SCORE;\n    key->zer = 0;\n\n    /* Setup the range structure used by the sorted set core implementation\n     * in order to seek at the specified element. */\n    zrangespec *zrs = &key->zrs;\n    zrs->min = min;\n    zrs->max = max;\n    zrs->minex = minex;\n    zrs->maxex = maxex;\n\n    if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {\n        key->zcurrent = first ? zzlFirstInRange(key->value->ptr,zrs) :\n                                zzlLastInRange(key->value->ptr,zrs);\n    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = key->value->ptr;\n        zskiplist *zsl = zs->zsl;\n        key->zcurrent = first ? zslFirstInRange(zsl,zrs) :\n                                zslLastInRange(zsl,zrs);\n    } else {\n        serverPanic(\"Unsupported zset encoding\");\n    }\n    if (key->zcurrent == NULL) key->zer = 1;\n    return REDISMODULE_OK;\n}\n\n/* Setup a sorted set iterator seeking the first element in the specified\n * range. Returns REDISMODULE_OK if the iterator was correctly initialized\n * otherwise REDISMODULE_ERR is returned in the following conditions:\n *\n * 1. The value stored at key is not a sorted set or the key is empty.\n *\n * The range is specified according to the two double values 'min' and 'max'.\n * Both can be infinite using the following two macros:\n *\n * REDISMODULE_POSITIVE_INFINITE for positive infinite value\n * REDISMODULE_NEGATIVE_INFINITE for negative infinite value\n *\n * 'minex' and 'maxex' parameters, if true, respectively setup a range\n * where the min and max value are exclusive (not included) instead of\n * inclusive. */\nint RM_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {\n    return zsetInitScoreRange(key,min,max,minex,maxex,1);\n}\n\n/* Exactly like RedisModule_ZsetFirstInScoreRange() but the last element of\n * the range is selected for the start of the iteration instead. */\nint RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {\n    return zsetInitScoreRange(key,min,max,minex,maxex,0);\n}\n\n/* Helper function for RM_ZsetFirstInLexRange() and RM_ZsetLastInLexRange().\n * Setup the sorted set iteration according to the specified lexicographical\n * range (see the functions calling it for more info). If 'first' is true the\n * first element in the range is used as a starting point for the iterator\n * otherwise the last. Return REDISMODULE_OK on success otherwise\n * REDISMODULE_ERR.\n *\n * Note that this function takes 'min' and 'max' in the same form of the\n * Redis ZRANGEBYLEX command. */\nint zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max, int first) {\n    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n\n    RM_ZsetRangeStop(key);\n    key->zer = 0;\n\n    /* Setup the range structure used by the sorted set core implementation\n     * in order to seek at the specified element. */\n    zlexrangespec *zlrs = &key->zlrs;\n    if (zslParseLexRange(min, max, zlrs) == C_ERR) return REDISMODULE_ERR;\n\n    /* Set the range type to lex only after successfully parsing the range,\n     * otherwise we don't want the zlexrangespec to be freed. */\n    key->ztype = REDISMODULE_ZSET_RANGE_LEX;\n\n    if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {\n        key->zcurrent = first ? zzlFirstInLexRange(key->value->ptr,zlrs) :\n                                zzlLastInLexRange(key->value->ptr,zlrs);\n    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = key->value->ptr;\n        zskiplist *zsl = zs->zsl;\n        key->zcurrent = first ? zslFirstInLexRange(zsl,zlrs) :\n                                zslLastInLexRange(zsl,zlrs);\n    } else {\n        serverPanic(\"Unsupported zset encoding\");\n    }\n    if (key->zcurrent == NULL) key->zer = 1;\n\n    return REDISMODULE_OK;\n}\n\n/* Setup a sorted set iterator seeking the first element in the specified\n * lexicographical range. Returns REDISMODULE_OK if the iterator was correctly\n * initialized otherwise REDISMODULE_ERR is returned in the\n * following conditions:\n *\n * 1. The value stored at key is not a sorted set or the key is empty.\n * 2. The lexicographical range 'min' and 'max' format is invalid.\n *\n * 'min' and 'max' should be provided as two RedisModuleString objects\n * in the same format as the parameters passed to the ZRANGEBYLEX command.\n * The function does not take ownership of the objects, so they can be released\n * ASAP after the iterator is setup. */\nint RM_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {\n    return zsetInitLexRange(key,min,max,1);\n}\n\n/* Exactly like RedisModule_ZsetFirstInLexRange() but the last element of\n * the range is selected for the start of the iteration instead. */\nint RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {\n    return zsetInitLexRange(key,min,max,0);\n}\n\n/* Return the current sorted set element of an active sorted set iterator\n * or NULL if the range specified in the iterator does not include any\n * element. */\nRedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score) {\n    RedisModuleString *str;\n\n    if (key->zcurrent == NULL) return NULL;\n    if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *eptr, *sptr;\n        eptr = key->zcurrent;\n        sds ele = ziplistGetObject(eptr);\n        if (score) {\n            sptr = ziplistNext(key->value->ptr,eptr);\n            *score = zzlGetScore(sptr);\n        }\n        str = createObject(OBJ_STRING,ele);\n    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {\n        zskiplistNode *ln = key->zcurrent;\n        if (score) *score = ln->score;\n        str = createStringObject(ln->ele,sdslen(ln->ele));\n    } else {\n        serverPanic(\"Unsupported zset encoding\");\n    }\n    autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,str);\n    return str;\n}\n\n/* Go to the next element of the sorted set iterator. Returns 1 if there was\n * a next element, 0 if we are already at the latest element or the range\n * does not include any item at all. */\nint RM_ZsetRangeNext(RedisModuleKey *key) {\n    if (!key->ztype || !key->zcurrent) return 0; /* No active iterator. */\n\n    if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *zl = key->value->ptr;\n        unsigned char *eptr = key->zcurrent;\n        unsigned char *next;\n        next = ziplistNext(zl,eptr); /* Skip element. */\n        if (next) next = ziplistNext(zl,next); /* Skip score. */\n        if (next == NULL) {\n            key->zer = 1;\n            return 0;\n        } else {\n            /* Are we still within the range? */\n            if (key->ztype == REDISMODULE_ZSET_RANGE_SCORE) {\n                /* Fetch the next element score for the\n                 * range check. */\n                unsigned char *saved_next = next;\n                next = ziplistNext(zl,next); /* Skip next element. */\n                double score = zzlGetScore(next); /* Obtain the next score. */\n                if (!zslValueLteMax(score,&key->zrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n                next = saved_next;\n            } else if (key->ztype == REDISMODULE_ZSET_RANGE_LEX) {\n                if (!zzlLexValueLteMax(next,&key->zlrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n            }\n            key->zcurrent = next;\n            return 1;\n        }\n    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {\n        zskiplistNode *ln = key->zcurrent, *next = ln->level[0].forward;\n        if (next == NULL) {\n            key->zer = 1;\n            return 0;\n        } else {\n            /* Are we still within the range? */\n            if (key->ztype == REDISMODULE_ZSET_RANGE_SCORE &&\n                !zslValueLteMax(next->score,&key->zrs))\n            {\n                key->zer = 1;\n                return 0;\n            } else if (key->ztype == REDISMODULE_ZSET_RANGE_LEX) {\n                if (!zslLexValueLteMax(next->ele,&key->zlrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n            }\n            key->zcurrent = next;\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unsupported zset encoding\");\n    }\n}\n\n/* Go to the previous element of the sorted set iterator. Returns 1 if there was\n * a previous element, 0 if we are already at the first element or the range\n * does not include any item at all. */\nint RM_ZsetRangePrev(RedisModuleKey *key) {\n    if (!key->ztype || !key->zcurrent) return 0; /* No active iterator. */\n\n    if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *zl = key->value->ptr;\n        unsigned char *eptr = key->zcurrent;\n        unsigned char *prev;\n        prev = ziplistPrev(zl,eptr); /* Go back to previous score. */\n        if (prev) prev = ziplistPrev(zl,prev); /* Back to previous ele. */\n        if (prev == NULL) {\n            key->zer = 1;\n            return 0;\n        } else {\n            /* Are we still within the range? */\n            if (key->ztype == REDISMODULE_ZSET_RANGE_SCORE) {\n                /* Fetch the previous element score for the\n                 * range check. */\n                unsigned char *saved_prev = prev;\n                prev = ziplistNext(zl,prev); /* Skip element to get the score.*/\n                double score = zzlGetScore(prev); /* Obtain the prev score. */\n                if (!zslValueGteMin(score,&key->zrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n                prev = saved_prev;\n            } else if (key->ztype == REDISMODULE_ZSET_RANGE_LEX) {\n                if (!zzlLexValueGteMin(prev,&key->zlrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n            }\n            key->zcurrent = prev;\n            return 1;\n        }\n    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {\n        zskiplistNode *ln = key->zcurrent, *prev = ln->backward;\n        if (prev == NULL) {\n            key->zer = 1;\n            return 0;\n        } else {\n            /* Are we still within the range? */\n            if (key->ztype == REDISMODULE_ZSET_RANGE_SCORE &&\n                !zslValueGteMin(prev->score,&key->zrs))\n            {\n                key->zer = 1;\n                return 0;\n            } else if (key->ztype == REDISMODULE_ZSET_RANGE_LEX) {\n                if (!zslLexValueGteMin(prev->ele,&key->zlrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n            }\n            key->zcurrent = prev;\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unsupported zset encoding\");\n    }\n}\n\n/* --------------------------------------------------------------------------\n * Key API for Hash type\n * -------------------------------------------------------------------------- */\n\n/* Set the field of the specified hash field to the specified value.\n * If the key is an empty key open for writing, it is created with an empty\n * hash value, in order to set the specified field.\n *\n * The function is variadic and the user must specify pairs of field\n * names and values, both as RedisModuleString pointers (unless the\n * CFIELD option is set, see later). At the end of the field/value-ptr pairs, \n * NULL must be specified as last argument to signal the end of the arguments \n * in the variadic function.\n *\n * Example to set the hash argv[1] to the value argv[2]:\n *\n *      RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],argv[2],NULL);\n *\n * The function can also be used in order to delete fields (if they exist)\n * by setting them to the specified value of REDISMODULE_HASH_DELETE:\n *\n *      RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],\n *                          REDISMODULE_HASH_DELETE,NULL);\n *\n * The behavior of the command changes with the specified flags, that can be\n * set to REDISMODULE_HASH_NONE if no special behavior is needed.\n *\n *     REDISMODULE_HASH_NX: The operation is performed only if the field was not\n *                          already existing in the hash.\n *     REDISMODULE_HASH_XX: The operation is performed only if the field was\n *                          already existing, so that a new value could be\n *                          associated to an existing filed, but no new fields\n *                          are created.\n *     REDISMODULE_HASH_CFIELDS: The field names passed are null terminated C\n *                               strings instead of RedisModuleString objects.\n *\n * Unless NX is specified, the command overwrites the old field value with\n * the new one.\n *\n * When using REDISMODULE_HASH_CFIELDS, field names are reported using\n * normal C strings, so for example to delete the field \"foo\" the following\n * code can be used:\n *\n *      RedisModule_HashSet(key,REDISMODULE_HASH_CFIELDS,\"foo\",\n *                          REDISMODULE_HASH_DELETE,NULL);\n *\n * Return value:\n *\n * The number of fields updated (that may be less than the number of fields\n * specified because of the XX or NX options).\n *\n * In the following case the return value is always zero:\n *\n * * The key was not open for writing.\n * * The key was associated with a non Hash value.\n */\nint RM_HashSet(RedisModuleKey *key, int flags, ...) {\n    va_list ap;\n    if (!(key->mode & REDISMODULE_WRITE)) return 0;\n    if (key->value && key->value->type != OBJ_HASH) return 0;\n    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_HASH);\n\n    int updated = 0;\n    va_start(ap, flags);\n    while(1) {\n        RedisModuleString *field, *value;\n        /* Get the field and value objects. */\n        if (flags & REDISMODULE_HASH_CFIELDS) {\n            char *cfield = va_arg(ap,char*);\n            if (cfield == NULL) break;\n            field = createRawStringObject(cfield,strlen(cfield));\n        } else {\n            field = va_arg(ap,RedisModuleString*);\n            if (field == NULL) break;\n        }\n        value = va_arg(ap,RedisModuleString*);\n\n        /* Handle XX and NX */\n        if (flags & (REDISMODULE_HASH_XX|REDISMODULE_HASH_NX)) {\n            int exists = hashTypeExists(key->value, field->ptr);\n            if (((flags & REDISMODULE_HASH_XX) && !exists) ||\n                ((flags & REDISMODULE_HASH_NX) && exists))\n            {\n                if (flags & REDISMODULE_HASH_CFIELDS) decrRefCount(field);\n                continue;\n            }\n        }\n\n        /* Handle deletion if value is REDISMODULE_HASH_DELETE. */\n        if (value == REDISMODULE_HASH_DELETE) {\n            updated += hashTypeDelete(key->value, field->ptr);\n            if (flags & REDISMODULE_HASH_CFIELDS) decrRefCount(field);\n            continue;\n        }\n\n        int low_flags = HASH_SET_COPY;\n        /* If CFIELDS is active, we can pass the ownership of the\n         * SDS object to the low level function that sets the field\n         * to avoid a useless copy. */\n        if (flags & REDISMODULE_HASH_CFIELDS)\n            low_flags |= HASH_SET_TAKE_FIELD;\n\n        robj *argv[2] = {field,value};\n        hashTypeTryConversion(key->value,argv,0,1);\n        updated += hashTypeSet(key->value, field->ptr, value->ptr, low_flags);\n\n        /* If CFIELDS is active, SDS string ownership is now of hashTypeSet(),\n         * however we still have to release the 'field' object shell. */\n        if (flags & REDISMODULE_HASH_CFIELDS) {\n           field->ptr = NULL; /* Prevent the SDS string from being freed. */\n           decrRefCount(field);\n        }\n    }\n    va_end(ap);\n    moduleDelKeyIfEmpty(key);\n    return updated;\n}\n\n/* Get fields from an hash value. This function is called using a variable\n * number of arguments, alternating a field name (as a StringRedisModule\n * pointer) with a pointer to a StringRedisModule pointer, that is set to the\n * value of the field if the field exist, or NULL if the field did not exist.\n * At the end of the field/value-ptr pairs, NULL must be specified as last\n * argument to signal the end of the arguments in the variadic function.\n *\n * This is an example usage:\n *\n *      RedisModuleString *first, *second;\n *      RedisModule_HashGet(mykey,REDISMODULE_HASH_NONE,argv[1],&first,\n *                      argv[2],&second,NULL);\n *\n * As with RedisModule_HashSet() the behavior of the command can be specified\n * passing flags different than REDISMODULE_HASH_NONE:\n *\n * REDISMODULE_HASH_CFIELD: field names as null terminated C strings.\n *\n * REDISMODULE_HASH_EXISTS: instead of setting the value of the field\n * expecting a RedisModuleString pointer to pointer, the function just\n * reports if the field esists or not and expects an integer pointer\n * as the second element of each pair.\n *\n * Example of REDISMODULE_HASH_CFIELD:\n *\n *      RedisModuleString *username, *hashedpass;\n *      RedisModule_HashGet(mykey,\"username\",&username,\"hp\",&hashedpass, NULL);\n *\n * Example of REDISMODULE_HASH_EXISTS:\n *\n *      int exists;\n *      RedisModule_HashGet(mykey,argv[1],&exists,NULL);\n *\n * The function returns REDISMODULE_OK on success and REDISMODULE_ERR if\n * the key is not an hash value.\n *\n * Memory management:\n *\n * The returned RedisModuleString objects should be released with\n * RedisModule_FreeString(), or by enabling automatic memory management.\n */\nint RM_HashGet(RedisModuleKey *key, int flags, ...) {\n    va_list ap;\n    if (key->value && key->value->type != OBJ_HASH) return REDISMODULE_ERR;\n\n    va_start(ap, flags);\n    while(1) {\n        RedisModuleString *field, **valueptr;\n        int *existsptr;\n        /* Get the field object and the value pointer to pointer. */\n        if (flags & REDISMODULE_HASH_CFIELDS) {\n            char *cfield = va_arg(ap,char*);\n            if (cfield == NULL) break;\n            field = createRawStringObject(cfield,strlen(cfield));\n        } else {\n            field = va_arg(ap,RedisModuleString*);\n            if (field == NULL) break;\n        }\n\n        /* Query the hash for existence or value object. */\n        if (flags & REDISMODULE_HASH_EXISTS) {\n            existsptr = va_arg(ap,int*);\n            if (key->value)\n                *existsptr = hashTypeExists(key->value,field->ptr);\n            else\n                *existsptr = 0;\n        } else {\n            valueptr = va_arg(ap,RedisModuleString**);\n            if (key->value) {\n                *valueptr = hashTypeGetValueObject(key->value,field->ptr);\n                if (*valueptr) {\n                    robj *decoded = getDecodedObject(*valueptr);\n                    decrRefCount(*valueptr);\n                    *valueptr = decoded;\n                }\n                if (*valueptr)\n                    autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,*valueptr);\n            } else {\n                *valueptr = NULL;\n            }\n        }\n\n        /* Cleanup */\n        if (flags & REDISMODULE_HASH_CFIELDS) decrRefCount(field);\n    }\n    va_end(ap);\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Redis <-> Modules generic Call() API\n * -------------------------------------------------------------------------- */\n\n/* Create a new RedisModuleCallReply object. The processing of the reply\n * is lazy, the object is just populated with the raw protocol and later\n * is processed as needed. Initially we just make sure to set the right\n * reply type, which is extremely cheap to do. */\nRedisModuleCallReply *moduleCreateCallReplyFromProto(RedisModuleCtx *ctx, sds proto) {\n    RedisModuleCallReply *reply = zmalloc(sizeof(*reply));\n    reply->ctx = ctx;\n    reply->proto = proto;\n    reply->protolen = sdslen(proto);\n    reply->flags = REDISMODULE_REPLYFLAG_TOPARSE; /* Lazy parsing. */\n    switch(proto[0]) {\n    case '$':\n    case '+': reply->type = REDISMODULE_REPLY_STRING; break;\n    case '-': reply->type = REDISMODULE_REPLY_ERROR; break;\n    case ':': reply->type = REDISMODULE_REPLY_INTEGER; break;\n    case '*': reply->type = REDISMODULE_REPLY_ARRAY; break;\n    default: reply->type = REDISMODULE_REPLY_UNKNOWN; break;\n    }\n    if ((proto[0] == '*' || proto[0] == '$') && proto[1] == '-')\n        reply->type = REDISMODULE_REPLY_NULL;\n    return reply;\n}\n\nvoid moduleParseCallReply_Int(RedisModuleCallReply *reply);\nvoid moduleParseCallReply_BulkString(RedisModuleCallReply *reply);\nvoid moduleParseCallReply_SimpleString(RedisModuleCallReply *reply);\nvoid moduleParseCallReply_Array(RedisModuleCallReply *reply);\n\n/* Do nothing if REDISMODULE_REPLYFLAG_TOPARSE is false, otherwise\n * use the protcol of the reply in reply->proto in order to fill the\n * reply with parsed data according to the reply type. */\nvoid moduleParseCallReply(RedisModuleCallReply *reply) {\n    if (!(reply->flags & REDISMODULE_REPLYFLAG_TOPARSE)) return;\n    reply->flags &= ~REDISMODULE_REPLYFLAG_TOPARSE;\n\n    switch(reply->proto[0]) {\n    case ':': moduleParseCallReply_Int(reply); break;\n    case '$': moduleParseCallReply_BulkString(reply); break;\n    case '-': /* handled by next item. */\n    case '+': moduleParseCallReply_SimpleString(reply); break;\n    case '*': moduleParseCallReply_Array(reply); break;\n    }\n}\n\nvoid moduleParseCallReply_Int(RedisModuleCallReply *reply) {\n    char *proto = reply->proto;\n    char *p = strchr(proto+1,'\\r');\n\n    string2ll(proto+1,p-proto-1,&reply->val.ll);\n    reply->protolen = p-proto+2;\n    reply->type = REDISMODULE_REPLY_INTEGER;\n}\n\nvoid moduleParseCallReply_BulkString(RedisModuleCallReply *reply) {\n    char *proto = reply->proto;\n    char *p = strchr(proto+1,'\\r');\n    long long bulklen;\n\n    string2ll(proto+1,p-proto-1,&bulklen);\n    if (bulklen == -1) {\n        reply->protolen = p-proto+2;\n        reply->type = REDISMODULE_REPLY_NULL;\n    } else {\n        reply->val.str = p+2;\n        reply->len = bulklen;\n        reply->protolen = p-proto+2+bulklen+2;\n        reply->type = REDISMODULE_REPLY_STRING;\n    }\n}\n\nvoid moduleParseCallReply_SimpleString(RedisModuleCallReply *reply) {\n    char *proto = reply->proto;\n    char *p = strchr(proto+1,'\\r');\n\n    reply->val.str = proto+1;\n    reply->len = p-proto-1;\n    reply->protolen = p-proto+2;\n    reply->type = proto[0] == '+' ? REDISMODULE_REPLY_STRING :\n                                    REDISMODULE_REPLY_ERROR;\n}\n\nvoid moduleParseCallReply_Array(RedisModuleCallReply *reply) {\n    char *proto = reply->proto;\n    char *p = strchr(proto+1,'\\r');\n    long long arraylen, j;\n\n    string2ll(proto+1,p-proto-1,&arraylen);\n    p += 2;\n\n    if (arraylen == -1) {\n        reply->protolen = p-proto;\n        reply->type = REDISMODULE_REPLY_NULL;\n        return;\n    }\n\n    reply->val.array = zmalloc(sizeof(RedisModuleCallReply)*arraylen);\n    reply->len = arraylen;\n    for (j = 0; j < arraylen; j++) {\n        RedisModuleCallReply *ele = reply->val.array+j;\n        ele->flags = REDISMODULE_REPLYFLAG_NESTED |\n                     REDISMODULE_REPLYFLAG_TOPARSE;\n        ele->proto = p;\n        ele->ctx = reply->ctx;\n        moduleParseCallReply(ele);\n        p += ele->protolen;\n    }\n    reply->protolen = p-proto;\n    reply->type = REDISMODULE_REPLY_ARRAY;\n}\n\n/* Free a Call reply and all the nested replies it contains if it's an\n * array. */\nvoid RM_FreeCallReply_Rec(RedisModuleCallReply *reply, int freenested){\n    /* Don't free nested replies by default: the user must always free the\n     * toplevel reply. However be gentle and don't crash if the module\n     * misuses the API. */\n    if (!freenested && reply->flags & REDISMODULE_REPLYFLAG_NESTED) return;\n\n    if (!(reply->flags & REDISMODULE_REPLYFLAG_TOPARSE)) {\n        if (reply->type == REDISMODULE_REPLY_ARRAY) {\n            size_t j;\n            for (j = 0; j < reply->len; j++)\n                RM_FreeCallReply_Rec(reply->val.array+j,1);\n            zfree(reply->val.array);\n        }\n    }\n\n    /* For nested replies, we don't free reply->proto (which if not NULL\n     * references the parent reply->proto buffer), nor the structure\n     * itself which is allocated as an array of structures, and is freed\n     * when the array value is released. */\n    if (!(reply->flags & REDISMODULE_REPLYFLAG_NESTED)) {\n        if (reply->proto) sdsfree(reply->proto);\n        zfree(reply);\n    }\n}\n\n/* Wrapper for the recursive free reply function. This is needed in order\n * to have the first level function to return on nested replies, but only\n * if called by the module API. */\nvoid RM_FreeCallReply(RedisModuleCallReply *reply) {\n\n    RedisModuleCtx *ctx = reply->ctx;\n    RM_FreeCallReply_Rec(reply,0);\n    autoMemoryFreed(ctx,REDISMODULE_AM_REPLY,reply);\n}\n\n/* Return the reply type. */\nint RM_CallReplyType(RedisModuleCallReply *reply) {\n    if (!reply) return REDISMODULE_REPLY_UNKNOWN;\n    return reply->type;\n}\n\n/* Return the reply type length, where applicable. */\nsize_t RM_CallReplyLength(RedisModuleCallReply *reply) {\n    moduleParseCallReply(reply);\n    switch(reply->type) {\n    case REDISMODULE_REPLY_STRING:\n    case REDISMODULE_REPLY_ERROR:\n    case REDISMODULE_REPLY_ARRAY:\n        return reply->len;\n    default:\n        return 0;\n    }\n}\n\n/* Return the 'idx'-th nested call reply element of an array reply, or NULL\n * if the reply type is wrong or the index is out of range. */\nRedisModuleCallReply *RM_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx) {\n    moduleParseCallReply(reply);\n    if (reply->type != REDISMODULE_REPLY_ARRAY) return NULL;\n    if (idx >= reply->len) return NULL;\n    return reply->val.array+idx;\n}\n\n/* Return the long long of an integer reply. */\nlong long RM_CallReplyInteger(RedisModuleCallReply *reply) {\n    moduleParseCallReply(reply);\n    if (reply->type != REDISMODULE_REPLY_INTEGER) return LLONG_MIN;\n    return reply->val.ll;\n}\n\n/* Return the pointer and length of a string or error reply. */\nconst char *RM_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len) {\n    moduleParseCallReply(reply);\n    if (reply->type != REDISMODULE_REPLY_STRING &&\n        reply->type != REDISMODULE_REPLY_ERROR) return NULL;\n    if (len) *len = reply->len;\n    return reply->val.str;\n}\n\n/* Return a new string object from a call reply of type string, error or\n * integer. Otherwise (wrong reply type) return NULL. */\nRedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply) {\n    moduleParseCallReply(reply);\n    switch(reply->type) {\n    case REDISMODULE_REPLY_STRING:\n    case REDISMODULE_REPLY_ERROR:\n        return RM_CreateString(reply->ctx,reply->val.str,reply->len);\n    case REDISMODULE_REPLY_INTEGER: {\n        char buf[64];\n        int len = ll2string(buf,sizeof(buf),reply->val.ll);\n        return RM_CreateString(reply->ctx,buf,len);\n        }\n    default: return NULL;\n    }\n}\n\n/* Returns an array of robj pointers, and populates *argc with the number\n * of items, by parsing the format specifier \"fmt\" as described for\n * the RM_Call(), RM_Replicate() and other module APIs.\n *\n * The integer pointed by 'flags' is populated with flags according\n * to special modifiers in \"fmt\". For now only one exists:\n *\n *     \"!\" -> REDISMODULE_ARGV_REPLICATE\n *\n * On error (format specifier error) NULL is returned and nothing is\n * allocated. On success the argument vector is returned. */\n\n#define REDISMODULE_ARGV_REPLICATE (1<<0)\n\nrobj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap) {\n    int argc = 0, argv_size, j;\n    robj **argv = NULL;\n\n    /* As a first guess to avoid useless reallocations, size argv to\n     * hold one argument for each char specifier in 'fmt'. */\n    argv_size = strlen(fmt)+1; /* +1 because of the command name. */\n    argv = zrealloc(argv,sizeof(robj*)*argv_size);\n\n    /* Build the arguments vector based on the format specifier. */\n    argv[0] = createStringObject(cmdname,strlen(cmdname));\n    argc++;\n\n    /* Create the client and dispatch the command. */\n    const char *p = fmt;\n    while(*p) {\n        if (*p == 'c') {\n            char *cstr = va_arg(ap,char*);\n            argv[argc++] = createStringObject(cstr,strlen(cstr));\n        } else if (*p == 's') {\n            robj *obj = va_arg(ap,void*);\n            argv[argc++] = obj;\n            incrRefCount(obj);\n        } else if (*p == 'b') {\n            char *buf = va_arg(ap,char*);\n            size_t len = va_arg(ap,size_t);\n            argv[argc++] = createStringObject(buf,len);\n        } else if (*p == 'l') {\n            long ll = va_arg(ap,long long);\n            argv[argc++] = createObject(OBJ_STRING,sdsfromlonglong(ll));\n        } else if (*p == 'v') {\n             /* A vector of strings */\n             robj **v = va_arg(ap, void*);\n             size_t vlen = va_arg(ap, size_t);\n\n             /* We need to grow argv to hold the vector's elements.\n              * We resize by vector_len-1 elements, because we held\n              * one element in argv for the vector already */\n             argv_size += vlen-1;\n             argv = zrealloc(argv,sizeof(robj*)*argv_size);\n\n             size_t i = 0;\n             for (i = 0; i < vlen; i++) {\n                 incrRefCount(v[i]);\n                 argv[argc++] = v[i];\n             }\n        } else if (*p == '!') {\n            if (flags) (*flags) |= REDISMODULE_ARGV_REPLICATE;\n        } else {\n            goto fmterr;\n        }\n        p++;\n    }\n    *argcp = argc;\n    return argv;\n\nfmterr:\n    for (j = 0; j < argc; j++)\n        decrRefCount(argv[j]);\n    zfree(argv);\n    return NULL;\n}\n\n/* Exported API to call any Redis command from modules.\n * On success a RedisModuleCallReply object is returned, otherwise\n * NULL is returned and errno is set to the following values:\n *\n * EINVAL: command non existing, wrong arity, wrong format specifier.\n * EPERM:  operation in Cluster instance with key in non local slot. */\nRedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {\n    struct redisCommand *cmd;\n    client *c = NULL;\n    robj **argv = NULL;\n    int argc = 0, flags = 0;\n    va_list ap;\n    RedisModuleCallReply *reply = NULL;\n    int replicate = 0; /* Replicate this command? */\n\n    cmd = lookupCommandByCString((char*)cmdname);\n    if (!cmd) {\n        errno = EINVAL;\n        return NULL;\n    }\n\n    /* Create the client and dispatch the command. */\n    va_start(ap, fmt);\n    c = createClient(-1);\n    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);\n    replicate = flags & REDISMODULE_ARGV_REPLICATE;\n    va_end(ap);\n\n    /* Setup our fake client for command execution. */\n    c->flags |= CLIENT_MODULE;\n    c->db = ctx->client->db;\n    c->argv = argv;\n    c->argc = argc;\n    c->cmd = c->lastcmd = cmd;\n    /* We handle the above format error only when the client is setup so that\n     * we can free it normally. */\n    if (argv == NULL) goto cleanup;\n\n    /* Basic arity checks. */\n    if ((cmd->arity > 0 && cmd->arity != argc) || (argc < -cmd->arity)) {\n        errno = EINVAL;\n        goto cleanup;\n    }\n\n    /* If this is a Redis Cluster node, we need to make sure the module is not\n     * trying to access non-local keys, with the exception of commands\n     * received from our master. */\n    if (server.cluster_enabled && !(ctx->client->flags & CLIENT_MASTER)) {\n        /* Duplicate relevant flags in the module client. */\n        c->flags &= ~(CLIENT_READONLY|CLIENT_ASKING);\n        c->flags |= ctx->client->flags & (CLIENT_READONLY|CLIENT_ASKING);\n        if (getNodeByQuery(c,c->cmd,c->argv,c->argc,NULL,NULL) !=\n                           server.cluster->myself)\n        {\n            errno = EPERM;\n            goto cleanup;\n        }\n    }\n\n    /* If we are using single commands replication, we need to wrap what\n     * we propagate into a MULTI/EXEC block, so that it will be atomic like\n     * a Lua script in the context of AOF and slaves. */\n    if (replicate) moduleReplicateMultiIfNeeded(ctx);\n\n    /* Run the command */\n    int call_flags = CMD_CALL_SLOWLOG | CMD_CALL_STATS;\n    if (replicate) {\n        call_flags |= CMD_CALL_PROPAGATE_AOF;\n        call_flags |= CMD_CALL_PROPAGATE_REPL;\n    }\n    call(c,call_flags);\n\n    /* Convert the result of the Redis command into a suitable Lua type.\n     * The first thing we need is to create a single string from the client\n     * output buffers. */\n    sds proto = sdsnewlen(c->buf,c->bufpos);\n    c->bufpos = 0;\n    while(listLength(c->reply)) {\n        clientReplyBlock *o = listNodeValue(listFirst(c->reply));\n\n        proto = sdscatlen(proto,o->buf,o->used);\n        listDelNode(c->reply,listFirst(c->reply));\n    }\n    reply = moduleCreateCallReplyFromProto(ctx,proto);\n    autoMemoryAdd(ctx,REDISMODULE_AM_REPLY,reply);\n\ncleanup:\n    freeClient(c);\n    return reply;\n}\n\n/* Return a pointer, and a length, to the protocol returned by the command\n * that returned the reply object. */\nconst char *RM_CallReplyProto(RedisModuleCallReply *reply, size_t *len) {\n    if (reply->proto) *len = sdslen(reply->proto);\n    return reply->proto;\n}\n\n/* --------------------------------------------------------------------------\n * Modules data types\n *\n * When String DMA or using existing data structures is not enough, it is\n * possible to create new data types from scratch and export them to\n * Redis. The module must provide a set of callbacks for handling the\n * new values exported (for example in order to provide RDB saving/loading,\n * AOF rewrite, and so forth). In this section we define this API.\n * -------------------------------------------------------------------------- */\n\n/* Turn a 9 chars name in the specified charset and a 10 bit encver into\n * a single 64 bit unsigned integer that represents this exact module name\n * and version. This final number is called a \"type ID\" and is used when\n * writing module exported values to RDB files, in order to re-associate the\n * value to the right module to load them during RDB loading.\n *\n * If the string is not of the right length or the charset is wrong, or\n * if encver is outside the unsigned 10 bit integer range, 0 is returned,\n * otherwise the function returns the right type ID.\n *\n * The resulting 64 bit integer is composed as follows:\n *\n *     (high order bits) 6|6|6|6|6|6|6|6|6|10 (low order bits)\n *\n * The first 6 bits value is the first character, name[0], while the last\n * 6 bits value, immediately before the 10 bits integer, is name[8].\n * The last 10 bits are the encoding version.\n *\n * Note that a name and encver combo of \"AAAAAAAAA\" and 0, will produce\n * zero as return value, that is the same we use to signal errors, thus\n * this combination is invalid, and also useless since type names should\n * try to be vary to avoid collisions. */\n\nconst char *ModuleTypeNameCharSet =\n             \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n             \"abcdefghijklmnopqrstuvwxyz\"\n             \"0123456789-_\";\n\nuint64_t moduleTypeEncodeId(const char *name, int encver) {\n    /* We use 64 symbols so that we can map each character into 6 bits\n     * of the final output. */\n    const char *cset = ModuleTypeNameCharSet;\n    if (strlen(name) != 9) return 0;\n    if (encver < 0 || encver > 1023) return 0;\n\n    uint64_t id = 0;\n    for (int j = 0; j < 9; j++) {\n        char *p = strchr(cset,name[j]);\n        if (!p) return 0;\n        unsigned long pos = p-cset;\n        id = (id << 6) | pos;\n    }\n    id = (id << 10) | encver;\n    return id;\n}\n\n/* Search, in the list of exported data types of all the modules registered,\n * a type with the same name as the one given. Returns the moduleType\n * structure pointer if such a module is found, or NULL otherwise. */\nmoduleType *moduleTypeLookupModuleByName(const char *name) {\n    dictIterator *di = dictGetIterator(modules);\n    dictEntry *de;\n\n    while ((de = dictNext(di)) != NULL) {\n        struct RedisModule *module = dictGetVal(de);\n        listIter li;\n        listNode *ln;\n\n        listRewind(module->types,&li);\n        while((ln = listNext(&li))) {\n            moduleType *mt = ln->value;\n            if (memcmp(name,mt->name,sizeof(mt->name)) == 0) {\n                dictReleaseIterator(di);\n                return mt;\n            }\n        }\n    }\n    dictReleaseIterator(di);\n    return NULL;\n}\n\n/* Lookup a module by ID, with caching. This function is used during RDB\n * loading. Modules exporting data types should never be able to unload, so\n * our cache does not need to expire. */\n#define MODULE_LOOKUP_CACHE_SIZE 3\n\nmoduleType *moduleTypeLookupModuleByID(uint64_t id) {\n    static struct {\n        uint64_t id;\n        moduleType *mt;\n    } cache[MODULE_LOOKUP_CACHE_SIZE];\n\n    /* Search in cache to start. */\n    int j;\n    for (j = 0; j < MODULE_LOOKUP_CACHE_SIZE && cache[j].mt != NULL; j++)\n        if (cache[j].id == id) return cache[j].mt;\n\n    /* Slow module by module lookup. */\n    moduleType *mt = NULL;\n    dictIterator *di = dictGetIterator(modules);\n    dictEntry *de;\n\n    while ((de = dictNext(di)) != NULL && mt == NULL) {\n        struct RedisModule *module = dictGetVal(de);\n        listIter li;\n        listNode *ln;\n\n        listRewind(module->types,&li);\n        while((ln = listNext(&li))) {\n            moduleType *this_mt = ln->value;\n            /* Compare only the 54 bit module identifier and not the\n             * encoding version. */\n            if (this_mt->id >> 10 == id >> 10) {\n                mt = this_mt;\n                break;\n            }\n        }\n    }\n    dictReleaseIterator(di);\n\n    /* Add to cache if possible. */\n    if (mt && j < MODULE_LOOKUP_CACHE_SIZE) {\n        cache[j].id = id;\n        cache[j].mt = mt;\n    }\n    return mt;\n}\n\n/* Turn an (unresolved) module ID into a type name, to show the user an\n * error when RDB files contain module data we can't load.\n * The buffer pointed by 'name' must be 10 bytes at least. The function will\n * fill it with a null terminated module name. */\nvoid moduleTypeNameByID(char *name, uint64_t moduleid) {\n    const char *cset = ModuleTypeNameCharSet;\n\n    name[9] = '\\0';\n    char *p = name+8;\n    moduleid >>= 10;\n    for (int j = 0; j < 9; j++) {\n        *p-- = cset[moduleid & 63];\n        moduleid >>= 6;\n    }\n}\n\n/* Register a new data type exported by the module. The parameters are the\n * following. Please for in depth documentation check the modules API\n * documentation, especially the TYPES.md file.\n *\n * * **name**: A 9 characters data type name that MUST be unique in the Redis\n *   Modules ecosystem. Be creative... and there will be no collisions. Use\n *   the charset A-Z a-z 9-0, plus the two \"-_\" characters. A good\n *   idea is to use, for example `<typename>-<vendor>`. For example\n *   \"tree-AntZ\" may mean \"Tree data structure by @antirez\". To use both\n *   lower case and upper case letters helps in order to prevent collisions.\n * * **encver**: Encoding version, which is, the version of the serialization\n *   that a module used in order to persist data. As long as the \"name\"\n *   matches, the RDB loading will be dispatched to the type callbacks\n *   whatever 'encver' is used, however the module can understand if\n *   the encoding it must load are of an older version of the module.\n *   For example the module \"tree-AntZ\" initially used encver=0. Later\n *   after an upgrade, it started to serialize data in a different format\n *   and to register the type with encver=1. However this module may\n *   still load old data produced by an older version if the rdb_load\n *   callback is able to check the encver value and act accordingly.\n *   The encver must be a positive value between 0 and 1023.\n * * **typemethods_ptr** is a pointer to a RedisModuleTypeMethods structure\n *   that should be populated with the methods callbacks and structure\n *   version, like in the following example:\n *\n *      RedisModuleTypeMethods tm = {\n *          .version = REDISMODULE_TYPE_METHOD_VERSION,\n *          .rdb_load = myType_RDBLoadCallBack,\n *          .rdb_save = myType_RDBSaveCallBack,\n *          .aof_rewrite = myType_AOFRewriteCallBack,\n *          .free = myType_FreeCallBack,\n *\n *          // Optional fields\n *          .digest = myType_DigestCallBack,\n *          .mem_usage = myType_MemUsageCallBack,\n *      }\n *\n * * **rdb_load**: A callback function pointer that loads data from RDB files.\n * * **rdb_save**: A callback function pointer that saves data to RDB files.\n * * **aof_rewrite**: A callback function pointer that rewrites data as commands.\n * * **digest**: A callback function pointer that is used for `DEBUG DIGEST`.\n * * **free**: A callback function pointer that can free a type value.\n *\n * The **digest* and **mem_usage** methods should currently be omitted since\n * they are not yet implemented inside the Redis modules core.\n *\n * Note: the module name \"AAAAAAAAA\" is reserved and produces an error, it\n * happens to be pretty lame as well.\n *\n * If there is already a module registering a type with the same name,\n * and if the module name or encver is invalid, NULL is returned.\n * Otherwise the new type is registered into Redis, and a reference of\n * type RedisModuleType is returned: the caller of the function should store\n * this reference into a gobal variable to make future use of it in the\n * modules type API, since a single module may register multiple types.\n * Example code fragment:\n *\n *      static RedisModuleType *BalancedTreeType;\n *\n *      int RedisModule_OnLoad(RedisModuleCtx *ctx) {\n *          // some code here ...\n *          BalancedTreeType = RM_CreateDataType(...);\n *      }\n */\nmoduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, void *typemethods_ptr) {\n    uint64_t id = moduleTypeEncodeId(name,encver);\n    if (id == 0) return NULL;\n    if (moduleTypeLookupModuleByName(name) != NULL) return NULL;\n\n    long typemethods_version = ((long*)typemethods_ptr)[0];\n    if (typemethods_version == 0) return NULL;\n\n    struct typemethods {\n        uint64_t version;\n        moduleTypeLoadFunc rdb_load;\n        moduleTypeSaveFunc rdb_save;\n        moduleTypeRewriteFunc aof_rewrite;\n        moduleTypeMemUsageFunc mem_usage;\n        moduleTypeDigestFunc digest;\n        moduleTypeFreeFunc free;\n    } *tms = (struct typemethods*) typemethods_ptr;\n\n    moduleType *mt = zcalloc(sizeof(*mt));\n    mt->id = id;\n    mt->module = ctx->module;\n    mt->rdb_load = tms->rdb_load;\n    mt->rdb_save = tms->rdb_save;\n    mt->aof_rewrite = tms->aof_rewrite;\n    mt->mem_usage = tms->mem_usage;\n    mt->digest = tms->digest;\n    mt->free = tms->free;\n    memcpy(mt->name,name,sizeof(mt->name));\n    listAddNodeTail(ctx->module->types,mt);\n    return mt;\n}\n\n/* If the key is open for writing, set the specified module type object\n * as the value of the key, deleting the old value if any.\n * On success REDISMODULE_OK is returned. If the key is not open for\n * writing or there is an active iterator, REDISMODULE_ERR is returned. */\nint RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value) {\n    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;\n    RM_DeleteKey(key);\n    robj *o = createModuleObject(mt,value);\n    setKey(key->db,key->key,o);\n    decrRefCount(o);\n    key->value = o;\n    return REDISMODULE_OK;\n}\n\n/* Assuming RedisModule_KeyType() returned REDISMODULE_KEYTYPE_MODULE on\n * the key, returns the module type pointer of the value stored at key.\n *\n * If the key is NULL, is not associated with a module type, or is empty,\n * then NULL is returned instead. */\nmoduleType *RM_ModuleTypeGetType(RedisModuleKey *key) {\n    if (key == NULL ||\n        key->value == NULL ||\n        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;\n    moduleValue *mv = key->value->ptr;\n    return mv->type;\n}\n\n/* Assuming RedisModule_KeyType() returned REDISMODULE_KEYTYPE_MODULE on\n * the key, returns the module type low-level value stored at key, as\n * it was set by the user via RedisModule_ModuleTypeSet().\n *\n * If the key is NULL, is not associated with a module type, or is empty,\n * then NULL is returned instead. */\nvoid *RM_ModuleTypeGetValue(RedisModuleKey *key) {\n    if (key == NULL ||\n        key->value == NULL ||\n        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;\n    moduleValue *mv = key->value->ptr;\n    return mv->value;\n}\n\n/* --------------------------------------------------------------------------\n * RDB loading and saving functions\n * -------------------------------------------------------------------------- */\n\n/* Called when there is a load error in the context of a module. This cannot\n * be recovered like for the built-in types. */\nvoid moduleRDBLoadError(RedisModuleIO *io) {\n    serverLog(LL_WARNING,\n        \"Error loading data from RDB (short read or EOF). \"\n        \"Read performed by module '%s' about type '%s' \"\n        \"after reading '%llu' bytes of a value.\",\n        io->type->module->name,\n        io->type->name,\n        (unsigned long long)io->bytes);\n    exit(1);\n}\n\n/* Save an unsigned 64 bit value into the RDB file. This function should only\n * be called in the context of the rdb_save method of modules implementing new\n * data types. */\nvoid RM_SaveUnsigned(RedisModuleIO *io, uint64_t value) {\n    if (io->error) return;\n    /* Save opcode. */\n    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_UINT);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    /* Save value. */\n    retval = rdbSaveLen(io->rio, value);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    return;\n\nsaveerr:\n    io->error = 1;\n}\n\n/* Load an unsigned 64 bit value from the RDB file. This function should only\n * be called in the context of the rdb_load method of modules implementing\n * new data types. */\nuint64_t RM_LoadUnsigned(RedisModuleIO *io) {\n    if (io->ver == 2) {\n        uint64_t opcode = rdbLoadLen(io->rio,NULL);\n        if (opcode != RDB_MODULE_OPCODE_UINT) goto loaderr;\n    }\n    uint64_t value;\n    int retval = rdbLoadLenByRef(io->rio, NULL, &value);\n    if (retval == -1) goto loaderr;\n    return value;\n\nloaderr:\n    moduleRDBLoadError(io);\n    return 0; /* Never reached. */\n}\n\n/* Like RedisModule_SaveUnsigned() but for signed 64 bit values. */\nvoid RM_SaveSigned(RedisModuleIO *io, int64_t value) {\n    union {uint64_t u; int64_t i;} conv;\n    conv.i = value;\n    RM_SaveUnsigned(io,conv.u);\n}\n\n/* Like RedisModule_LoadUnsigned() but for signed 64 bit values. */\nint64_t RM_LoadSigned(RedisModuleIO *io) {\n    union {uint64_t u; int64_t i;} conv;\n    conv.u = RM_LoadUnsigned(io);\n    return conv.i;\n}\n\n/* In the context of the rdb_save method of a module type, saves a\n * string into the RDB file taking as input a RedisModuleString.\n *\n * The string can be later loaded with RedisModule_LoadString() or\n * other Load family functions expecting a serialized string inside\n * the RDB file. */\nvoid RM_SaveString(RedisModuleIO *io, RedisModuleString *s) {\n    if (io->error) return;\n    /* Save opcode. */\n    ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    /* Save value. */\n    retval = rdbSaveStringObject(io->rio, s);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    return;\n\nsaveerr:\n    io->error = 1;\n}\n\n/* Like RedisModule_SaveString() but takes a raw C pointer and length\n * as input. */\nvoid RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len) {\n    if (io->error) return;\n    /* Save opcode. */\n    ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    /* Save value. */\n    retval = rdbSaveRawString(io->rio, (unsigned char*)str,len);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    return;\n\nsaveerr:\n    io->error = 1;\n}\n\n/* Implements RM_LoadString() and RM_LoadStringBuffer() */\nvoid *moduleLoadString(RedisModuleIO *io, int plain, size_t *lenptr) {\n    if (io->ver == 2) {\n        uint64_t opcode = rdbLoadLen(io->rio,NULL);\n        if (opcode != RDB_MODULE_OPCODE_STRING) goto loaderr;\n    }\n    void *s = rdbGenericLoadStringObject(io->rio,\n              plain ? RDB_LOAD_PLAIN : RDB_LOAD_NONE, lenptr);\n    if (s == NULL) goto loaderr;\n    return s;\n\nloaderr:\n    moduleRDBLoadError(io);\n    return NULL; /* Never reached. */\n}\n\n/* In the context of the rdb_load method of a module data type, loads a string\n * from the RDB file, that was previously saved with RedisModule_SaveString()\n * functions family.\n *\n * The returned string is a newly allocated RedisModuleString object, and\n * the user should at some point free it with a call to RedisModule_FreeString().\n *\n * If the data structure does not store strings as RedisModuleString objects,\n * the similar function RedisModule_LoadStringBuffer() could be used instead. */\nRedisModuleString *RM_LoadString(RedisModuleIO *io) {\n    return moduleLoadString(io,0,NULL);\n}\n\n/* Like RedisModule_LoadString() but returns an heap allocated string that\n * was allocated with RedisModule_Alloc(), and can be resized or freed with\n * RedisModule_Realloc() or RedisModule_Free().\n *\n * The size of the string is stored at '*lenptr' if not NULL.\n * The returned string is not automatically NULL termianted, it is loaded\n * exactly as it was stored inisde the RDB file. */\nchar *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr) {\n    return moduleLoadString(io,1,lenptr);\n}\n\n/* In the context of the rdb_save method of a module data type, saves a double\n * value to the RDB file. The double can be a valid number, a NaN or infinity.\n * It is possible to load back the value with RedisModule_LoadDouble(). */\nvoid RM_SaveDouble(RedisModuleIO *io, double value) {\n    if (io->error) return;\n    /* Save opcode. */\n    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_DOUBLE);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    /* Save value. */\n    retval = rdbSaveBinaryDoubleValue(io->rio, value);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    return;\n\nsaveerr:\n    io->error = 1;\n}\n\n/* In the context of the rdb_save method of a module data type, loads back the\n * double value saved by RedisModule_SaveDouble(). */\ndouble RM_LoadDouble(RedisModuleIO *io) {\n    if (io->ver == 2) {\n        uint64_t opcode = rdbLoadLen(io->rio,NULL);\n        if (opcode != RDB_MODULE_OPCODE_DOUBLE) goto loaderr;\n    }\n    double value;\n    int retval = rdbLoadBinaryDoubleValue(io->rio, &value);\n    if (retval == -1) goto loaderr;\n    return value;\n\nloaderr:\n    moduleRDBLoadError(io);\n    return 0; /* Never reached. */\n}\n\n/* In the context of the rdb_save method of a module data type, saves a float\n * value to the RDB file. The float can be a valid number, a NaN or infinity.\n * It is possible to load back the value with RedisModule_LoadFloat(). */\nvoid RM_SaveFloat(RedisModuleIO *io, float value) {\n    if (io->error) return;\n    /* Save opcode. */\n    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_FLOAT);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    /* Save value. */\n    retval = rdbSaveBinaryFloatValue(io->rio, value);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    return;\n\nsaveerr:\n    io->error = 1;\n}\n\n/* In the context of the rdb_save method of a module data type, loads back the\n * float value saved by RedisModule_SaveFloat(). */\nfloat RM_LoadFloat(RedisModuleIO *io) {\n    if (io->ver == 2) {\n        uint64_t opcode = rdbLoadLen(io->rio,NULL);\n        if (opcode != RDB_MODULE_OPCODE_FLOAT) goto loaderr;\n    }\n    float value;\n    int retval = rdbLoadBinaryFloatValue(io->rio, &value);\n    if (retval == -1) goto loaderr;\n    return value;\n\nloaderr:\n    moduleRDBLoadError(io);\n    return 0; /* Never reached. */\n}\n\n/* --------------------------------------------------------------------------\n * Key digest API (DEBUG DIGEST interface for modules types)\n * -------------------------------------------------------------------------- */\n\n/* Add a new element to the digest. This function can be called multiple times\n * one element after the other, for all the elements that constitute a given\n * data structure. The function call must be followed by the call to\n * `RedisModule_DigestEndSequence` eventually, when all the elements that are\n * always in a given order are added. See the Redis Modules data types\n * documentation for more info. However this is a quick example that uses Redis\n * data types as an example.\n *\n * To add a sequence of unordered elements (for example in the case of a Redis\n * Set), the pattern to use is:\n *\n *     foreach element {\n *         AddElement(element);\n *         EndSequence();\n *     }\n *\n * Because Sets are not ordered, so every element added has a position that\n * does not depend from the other. However if instead our elements are\n * ordered in pairs, like field-value pairs of an Hash, then one should\n * use:\n *\n *     foreach key,value {\n *         AddElement(key);\n *         AddElement(value);\n *         EndSquence();\n *     }\n *\n * Because the key and value will be always in the above order, while instead\n * the single key-value pairs, can appear in any position into a Redis hash.\n *\n * A list of ordered elements would be implemented with:\n *\n *     foreach element {\n *         AddElement(element);\n *     }\n *     EndSequence();\n *\n */\nvoid RM_DigestAddStringBuffer(RedisModuleDigest *md, unsigned char *ele, size_t len) {\n    mixDigest(md->o,ele,len);\n}\n\n/* Like `RedisModule_DigestAddStringBuffer()` but takes a long long as input\n * that gets converted into a string before adding it to the digest. */\nvoid RM_DigestAddLongLong(RedisModuleDigest *md, long long ll) {\n    char buf[LONG_STR_SIZE];\n    size_t len = ll2string(buf,sizeof(buf),ll);\n    mixDigest(md->o,buf,len);\n}\n\n/* See the documentation for `RedisModule_DigestAddElement()`. */\nvoid RM_DigestEndSequence(RedisModuleDigest *md) {\n    xorDigest(md->x,md->o,sizeof(md->o));\n    memset(md->o,0,sizeof(md->o));\n}\n\n/* --------------------------------------------------------------------------\n * AOF API for modules data types\n * -------------------------------------------------------------------------- */\n\n/* Emits a command into the AOF during the AOF rewriting process. This function\n * is only called in the context of the aof_rewrite method of data types exported\n * by a module. The command works exactly like RedisModule_Call() in the way\n * the parameters are passed, but it does not return anything as the error\n * handling is performed by Redis itself. */\nvoid RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {\n    if (io->error) return;\n    struct redisCommand *cmd;\n    robj **argv = NULL;\n    int argc = 0, flags = 0, j;\n    va_list ap;\n\n    cmd = lookupCommandByCString((char*)cmdname);\n    if (!cmd) {\n        serverLog(LL_WARNING,\n            \"Fatal: AOF method for module data type '%s' tried to \"\n            \"emit unknown command '%s'\",\n            io->type->name, cmdname);\n        io->error = 1;\n        errno = EINVAL;\n        return;\n    }\n\n    /* Emit the arguments into the AOF in Redis protocol format. */\n    va_start(ap, fmt);\n    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);\n    va_end(ap);\n    if (argv == NULL) {\n        serverLog(LL_WARNING,\n            \"Fatal: AOF method for module data type '%s' tried to \"\n            \"call RedisModule_EmitAOF() with wrong format specifiers '%s'\",\n            io->type->name, fmt);\n        io->error = 1;\n        errno = EINVAL;\n        return;\n    }\n\n    /* Bulk count. */\n    if (!io->error && rioWriteBulkCount(io->rio,'*',argc) == 0)\n        io->error = 1;\n\n    /* Arguments. */\n    for (j = 0; j < argc; j++) {\n        if (!io->error && rioWriteBulkObject(io->rio,argv[j]) == 0)\n            io->error = 1;\n        decrRefCount(argv[j]);\n    }\n    zfree(argv);\n    return;\n}\n\n/* --------------------------------------------------------------------------\n * IO context handling\n * -------------------------------------------------------------------------- */\n\nRedisModuleCtx *RM_GetContextFromIO(RedisModuleIO *io) {\n    if (io->ctx) return io->ctx; /* Can't have more than one... */\n    RedisModuleCtx ctxtemplate = REDISMODULE_CTX_INIT;\n    io->ctx = zmalloc(sizeof(RedisModuleCtx));\n    *(io->ctx) = ctxtemplate;\n    io->ctx->module = io->type->module;\n    io->ctx->client = NULL;\n    return io->ctx;\n}\n\n/* --------------------------------------------------------------------------\n * Logging\n * -------------------------------------------------------------------------- */\n\n/* This is the low level function implementing both:\n *\n *      RM_Log()\n *      RM_LogIOError()\n *\n */\nvoid RM_LogRaw(RedisModule *module, const char *levelstr, const char *fmt, va_list ap) {\n    char msg[LOG_MAX_LEN];\n    size_t name_len;\n    int level;\n\n    if (!strcasecmp(levelstr,\"debug\")) level = LL_DEBUG;\n    else if (!strcasecmp(levelstr,\"verbose\")) level = LL_VERBOSE;\n    else if (!strcasecmp(levelstr,\"notice\")) level = LL_NOTICE;\n    else if (!strcasecmp(levelstr,\"warning\")) level = LL_WARNING;\n    else level = LL_VERBOSE; /* Default. */\n\n    name_len = snprintf(msg, sizeof(msg),\"<%s> \", module->name);\n    vsnprintf(msg + name_len, sizeof(msg) - name_len, fmt, ap);\n    serverLogRaw(level,msg);\n}\n\n/* Produces a log message to the standard Redis log, the format accepts\n * printf-alike specifiers, while level is a string describing the log\n * level to use when emitting the log, and must be one of the following:\n *\n * * \"debug\"\n * * \"verbose\"\n * * \"notice\"\n * * \"warning\"\n *\n * If the specified log level is invalid, verbose is used by default.\n * There is a fixed limit to the length of the log line this function is able\n * to emit, this limit is not specified but is guaranteed to be more than\n * a few lines of text.\n */\nvoid RM_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...) {\n    if (!ctx->module) return;   /* Can only log if module is initialized */\n\n    va_list ap;\n    va_start(ap, fmt);\n    RM_LogRaw(ctx->module,levelstr,fmt,ap);\n    va_end(ap);\n}\n\n/* Log errors from RDB / AOF serialization callbacks.\n *\n * This function should be used when a callback is returning a critical\n * error to the caller since cannot load or save the data for some\n * critical reason. */\nvoid RM_LogIOError(RedisModuleIO *io, const char *levelstr, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    RM_LogRaw(io->type->module,levelstr,fmt,ap);\n    va_end(ap);\n}\n\n/* --------------------------------------------------------------------------\n * Blocking clients from modules\n * -------------------------------------------------------------------------- */\n\n/* Readable handler for the awake pipe. We do nothing here, the awake bytes\n * will be actually read in a more appropriate place in the\n * moduleHandleBlockedClients() function that is where clients are actually\n * served. */\nvoid moduleBlockedClientPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {\n    UNUSED(el);\n    UNUSED(fd);\n    UNUSED(mask);\n    UNUSED(privdata);\n}\n\n/* This is called from blocked.c in order to unblock a client: may be called\n * for multiple reasons while the client is in the middle of being blocked\n * because the client is terminated, but is also called for cleanup when a\n * client is unblocked in a clean way after replaying.\n *\n * What we do here is just to set the client to NULL in the redis module\n * blocked client handle. This way if the client is terminated while there\n * is a pending threaded operation involving the blocked client, we'll know\n * that the client no longer exists and no reply callback should be called.\n *\n * The structure RedisModuleBlockedClient will be always deallocated when\n * running the list of clients blocked by a module that need to be unblocked. */\nvoid unblockClientFromModule(client *c) {\n    RedisModuleBlockedClient *bc = c->bpop.module_blocked_handle;\n\n    /* Call the disconnection callback if any. */\n    if (bc->disconnect_callback) {\n        RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n        ctx.blocked_privdata = bc->privdata;\n        ctx.module = bc->module;\n        ctx.client = bc->client;\n        bc->disconnect_callback(&ctx,bc);\n        moduleFreeContext(&ctx);\n    }\n\n    bc->client = NULL;\n    /* Reset the client for a new query since, for blocking commands implemented\n     * into modules, we do not it immediately after the command returns (and\n     * the client blocks) in order to be still able to access the argument\n     * vector from callbacks. */\n    resetClient(c);\n}\n\n/* Block a client in the context of a blocking command, returning an handle\n * which will be used, later, in order to unblock the client with a call to\n * RedisModule_UnblockClient(). The arguments specify callback functions\n * and a timeout after which the client is unblocked.\n *\n * The callbacks are called in the following contexts:\n *\n *     reply_callback:  called after a successful RedisModule_UnblockClient()\n *                      call in order to reply to the client and unblock it.\n *\n *     reply_timeout:   called when the timeout is reached in order to send an\n *                      error to the client.\n *\n *     free_privdata:   called in order to free the private data that is passed\n *                      by RedisModule_UnblockClient() call.\n */\nRedisModuleBlockedClient *RM_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), long long timeout_ms) {\n    client *c = ctx->client;\n    int islua = c->flags & CLIENT_LUA;\n    int ismulti = c->flags & CLIENT_MULTI;\n\n    c->bpop.module_blocked_handle = zmalloc(sizeof(RedisModuleBlockedClient));\n    RedisModuleBlockedClient *bc = c->bpop.module_blocked_handle;\n\n    /* We need to handle the invalid operation of calling modules blocking\n     * commands from Lua or MULTI. We actually create an already aborted\n     * (client set to NULL) blocked client handle, and actually reply with\n     * an error. */\n    bc->client = (islua || ismulti) ? NULL : c;\n    bc->module = ctx->module;\n    bc->reply_callback = reply_callback;\n    bc->timeout_callback = timeout_callback;\n    bc->disconnect_callback = NULL; /* Set by RM_SetDisconnectCallback() */\n    bc->free_privdata = free_privdata;\n    bc->privdata = NULL;\n    bc->reply_client = createClient(-1);\n    bc->reply_client->flags |= CLIENT_MODULE;\n    bc->dbid = c->db->id;\n    c->bpop.timeout = timeout_ms ? (mstime()+timeout_ms) : 0;\n\n    if (islua || ismulti) {\n        c->bpop.module_blocked_handle = NULL;\n        addReplyError(c, islua ?\n            \"Blocking module command called from Lua script\" :\n            \"Blocking module command called from transaction\");\n    } else {\n        blockClient(c,BLOCKED_MODULE);\n    }\n    return bc;\n}\n\n/* Unblock a client blocked by `RedisModule_BlockedClient`. This will trigger\n * the reply callbacks to be called in order to reply to the client.\n * The 'privdata' argument will be accessible by the reply callback, so\n * the caller of this function can pass any value that is needed in order to\n * actually reply to the client.\n *\n * A common usage for 'privdata' is a thread that computes something that\n * needs to be passed to the client, included but not limited some slow\n * to compute reply or some reply obtained via networking.\n *\n * Note: this function can be called from threads spawned by the module. */\nint RM_UnblockClient(RedisModuleBlockedClient *bc, void *privdata) {\n    pthread_mutex_lock(&moduleUnblockedClientsMutex);\n    bc->privdata = privdata;\n    listAddNodeTail(moduleUnblockedClients,bc);\n    if (write(server.module_blocked_pipe[1],\"A\",1) != 1) {\n        /* Ignore the error, this is best-effort. */\n    }\n    pthread_mutex_unlock(&moduleUnblockedClientsMutex);\n    return REDISMODULE_OK;\n}\n\n/* Abort a blocked client blocking operation: the client will be unblocked\n * without firing any callback. */\nint RM_AbortBlock(RedisModuleBlockedClient *bc) {\n    bc->reply_callback = NULL;\n    bc->disconnect_callback = NULL;\n    return RM_UnblockClient(bc,NULL);\n}\n\n/* Set a callback that will be called if a blocked client disconnects\n * before the module has a chance to call RedisModule_UnblockClient()\n *\n * Usually what you want to do there, is to cleanup your module state\n * so that you can call RedisModule_UnblockClient() safely, otherwise\n * the client will remain blocked forever if the timeout is large.\n *\n * Notes:\n *\n * 1. It is not safe to call Reply* family functions here, it is also\n *    useless since the client is gone.\n *\n * 2. This callback is not called if the client disconnects because of\n *    a timeout. In such a case, the client is unblocked automatically\n *    and the timeout callback is called.\n */\nvoid RM_SetDisconnectCallback(RedisModuleBlockedClient *bc, RedisModuleDisconnectFunc callback) {\n    bc->disconnect_callback = callback;\n}\n\n/* This function will check the moduleUnblockedClients queue in order to\n * call the reply callback and really unblock the client.\n *\n * Clients end into this list because of calls to RM_UnblockClient(),\n * however it is possible that while the module was doing work for the\n * blocked client, it was terminated by Redis (for timeout or other reasons).\n * When this happens the RedisModuleBlockedClient structure in the queue\n * will have the 'client' field set to NULL. */\nvoid moduleHandleBlockedClients(void) {\n    listNode *ln;\n    RedisModuleBlockedClient *bc;\n\n    pthread_mutex_lock(&moduleUnblockedClientsMutex);\n    /* Here we unblock all the pending clients blocked in modules operations\n     * so we can read every pending \"awake byte\" in the pipe. */\n    char buf[1];\n    while (read(server.module_blocked_pipe[0],buf,1) == 1);\n    while (listLength(moduleUnblockedClients)) {\n        ln = listFirst(moduleUnblockedClients);\n        bc = ln->value;\n        client *c = bc->client;\n        listDelNode(moduleUnblockedClients,ln);\n        pthread_mutex_unlock(&moduleUnblockedClientsMutex);\n\n        /* Release the lock during the loop, as long as we don't\n         * touch the shared list. */\n\n        /* Call the reply callback if the client is valid and we have\n         * any callback. */\n        if (c && bc->reply_callback) {\n            RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n            ctx.flags |= REDISMODULE_CTX_BLOCKED_REPLY;\n            ctx.blocked_privdata = bc->privdata;\n            ctx.module = bc->module;\n            ctx.client = bc->client;\n            ctx.blocked_client = bc;\n            bc->reply_callback(&ctx,(void**)c->argv,c->argc);\n            moduleHandlePropagationAfterCommandCallback(&ctx);\n            moduleFreeContext(&ctx);\n        }\n\n        /* Free privdata if any. */\n        if (bc->privdata && bc->free_privdata) {\n            RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n            if (c == NULL)\n                ctx.flags |= REDISMODULE_CTX_BLOCKED_DISCONNECTED;\n            ctx.blocked_privdata = bc->privdata;\n            ctx.module = bc->module;\n            ctx.client = bc->client;\n            bc->free_privdata(&ctx,bc->privdata);\n            moduleFreeContext(&ctx);\n        }\n\n        /* It is possible that this blocked client object accumulated\n         * replies to send to the client in a thread safe context.\n         * We need to glue such replies to the client output buffer and\n         * free the temporary client we just used for the replies. */\n        if (c) {\n            if (bc->reply_client->bufpos)\n                addReplyString(c,bc->reply_client->buf,\n                                 bc->reply_client->bufpos);\n            if (listLength(bc->reply_client->reply))\n                listJoin(c->reply,bc->reply_client->reply);\n            c->reply_bytes += bc->reply_client->reply_bytes;\n        }\n        freeClient(bc->reply_client);\n\n        if (c != NULL) {\n            /* Before unblocking the client, set the disconnect callback\n             * to NULL, because if we reached this point, the client was\n             * properly unblocked by the module. */\n            bc->disconnect_callback = NULL;\n            unblockClient(c);\n            /* Put the client in the list of clients that need to write\n             * if there are pending replies here. This is needed since\n             * during a non blocking command the client may receive output. */\n            if (clientHasPendingReplies(c) &&\n                !(c->flags & CLIENT_PENDING_WRITE))\n            {\n                c->flags |= CLIENT_PENDING_WRITE;\n                listAddNodeHead(server.clients_pending_write,c);\n            }\n        }\n\n        /* Free 'bc' only after unblocking the client, since it is\n         * referenced in the client blocking context, and must be valid\n         * when calling unblockClient(). */\n        zfree(bc);\n\n        /* Lock again before to iterate the loop. */\n        pthread_mutex_lock(&moduleUnblockedClientsMutex);\n    }\n    pthread_mutex_unlock(&moduleUnblockedClientsMutex);\n}\n\n/* Called when our client timed out. After this function unblockClient()\n * is called, and it will invalidate the blocked client. So this function\n * does not need to do any cleanup. Eventually the module will call the\n * API to unblock the client and the memory will be released. */\nvoid moduleBlockedClientTimedOut(client *c) {\n    RedisModuleBlockedClient *bc = c->bpop.module_blocked_handle;\n    RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n    ctx.flags |= REDISMODULE_CTX_BLOCKED_TIMEOUT;\n    ctx.module = bc->module;\n    ctx.client = bc->client;\n    ctx.blocked_client = bc;\n    bc->timeout_callback(&ctx,(void**)c->argv,c->argc);\n    moduleFreeContext(&ctx);\n    /* For timeout events, we do not want to call the disconnect callback,\n     * because the blocked client will be automatically disconnected in\n     * this case, and the user can still hook using the timeout callback. */\n    bc->disconnect_callback = NULL;\n}\n\n/* Return non-zero if a module command was called in order to fill the\n * reply for a blocked client. */\nint RM_IsBlockedReplyRequest(RedisModuleCtx *ctx) {\n    return (ctx->flags & REDISMODULE_CTX_BLOCKED_REPLY) != 0;\n}\n\n/* Return non-zero if a module command was called in order to fill the\n * reply for a blocked client that timed out. */\nint RM_IsBlockedTimeoutRequest(RedisModuleCtx *ctx) {\n    return (ctx->flags & REDISMODULE_CTX_BLOCKED_TIMEOUT) != 0;\n}\n\n/* Get the private data set by RedisModule_UnblockClient() */\nvoid *RM_GetBlockedClientPrivateData(RedisModuleCtx *ctx) {\n    return ctx->blocked_privdata;\n}\n\n/* Get the blocked client associated with a given context.\n * This is useful in the reply and timeout callbacks of blocked clients,\n * before sometimes the module has the blocked client handle references\n * around, and wants to cleanup it. */\nRedisModuleBlockedClient *RM_GetBlockedClientHandle(RedisModuleCtx *ctx) {\n    return ctx->blocked_client;\n}\n\n/* Return true if when the free callback of a blocked client is called,\n * the reason for the client to be unblocked is that it disconnected\n * while it was blocked. */\nint RM_BlockedClientDisconnected(RedisModuleCtx *ctx) {\n    return (ctx->flags & REDISMODULE_CTX_BLOCKED_DISCONNECTED) != 0;\n}\n\n/* --------------------------------------------------------------------------\n * Thread Safe Contexts\n * -------------------------------------------------------------------------- */\n\n/* Return a context which can be used inside threads to make Redis context\n * calls with certain modules APIs. If 'bc' is not NULL then the module will\n * be bound to a blocked client, and it will be possible to use the\n * `RedisModule_Reply*` family of functions to accumulate a reply for when the\n * client will be unblocked. Otherwise the thread safe context will be\n * detached by a specific client.\n *\n * To call non-reply APIs, the thread safe context must be prepared with:\n *\n *     RedisModule_ThreadSafeCallStart(ctx);\n *     ... make your call here ...\n *     RedisModule_ThreadSafeCallStop(ctx);\n *\n * This is not needed when using `RedisModule_Reply*` functions, assuming\n * that a blocked client was used when the context was created, otherwise\n * no RedisModule_Reply* call should be made at all.\n *\n * TODO: thread safe contexts do not inherit the blocked client\n * selected database. */\nRedisModuleCtx *RM_GetThreadSafeContext(RedisModuleBlockedClient *bc) {\n    RedisModuleCtx *ctx = zmalloc(sizeof(*ctx));\n    RedisModuleCtx empty = REDISMODULE_CTX_INIT;\n    memcpy(ctx,&empty,sizeof(empty));\n    if (bc) {\n        ctx->blocked_client = bc;\n        ctx->module = bc->module;\n    }\n    ctx->flags |= REDISMODULE_CTX_THREAD_SAFE;\n    /* Even when the context is associated with a blocked client, we can't\n     * access it safely from another thread, so we create a fake client here\n     * in order to keep things like the currently selected database and similar\n     * things. */\n    ctx->client = createClient(-1);\n    if (bc) selectDb(ctx->client,bc->dbid);\n    return ctx;\n}\n\n/* Release a thread safe context. */\nvoid RM_FreeThreadSafeContext(RedisModuleCtx *ctx) {\n    moduleFreeContext(ctx);\n    zfree(ctx);\n}\n\n/* Acquire the server lock before executing a thread safe API call.\n * This is not needed for `RedisModule_Reply*` calls when there is\n * a blocked client connected to the thread safe context. */\nvoid RM_ThreadSafeContextLock(RedisModuleCtx *ctx) {\n    UNUSED(ctx);\n    moduleAcquireGIL();\n}\n\n/* Release the server lock after a thread safe API call was executed. */\nvoid RM_ThreadSafeContextUnlock(RedisModuleCtx *ctx) {\n    UNUSED(ctx);\n    moduleReleaseGIL();\n}\n\nvoid moduleAcquireGIL(void) {\n    pthread_mutex_lock(&moduleGIL);\n}\n\nvoid moduleReleaseGIL(void) {\n    pthread_mutex_unlock(&moduleGIL);\n}\n\n\n/* --------------------------------------------------------------------------\n * Module Keyspace Notifications API\n * -------------------------------------------------------------------------- */\n\n/* Subscribe to keyspace notifications. This is a low-level version of the\n * keyspace-notifications API. A module can register callbacks to be notified\n * when keyspce events occur.\n *\n * Notification events are filtered by their type (string events, set events,\n * etc), and the subscriber callback receives only events that match a specific\n * mask of event types.\n *\n * When subscribing to notifications with RedisModule_SubscribeToKeyspaceEvents \n * the module must provide an event type-mask, denoting the events the subscriber\n * is interested in. This can be an ORed mask of any of the following flags:\n *\n *  - REDISMODULE_NOTIFY_GENERIC: Generic commands like DEL, EXPIRE, RENAME\n *  - REDISMODULE_NOTIFY_STRING: String events\n *  - REDISMODULE_NOTIFY_LIST: List events\n *  - REDISMODULE_NOTIFY_SET: Set events\n *  - REDISMODULE_NOTIFY_HASH: Hash events\n *  - REDISMODULE_NOTIFY_ZSET: Sorted Set events\n *  - REDISMODULE_NOTIFY_EXPIRED: Expiration events\n *  - REDISMODULE_NOTIFY_EVICTED: Eviction events\n *  - REDISMODULE_NOTIFY_STREAM: Stream events\n *  - REDISMODULE_NOTIFY_ALL: All events\n *\n * We do not distinguish between key events and keyspace events, and it is up\n * to the module to filter the actions taken based on the key.\n *\n * The subscriber signature is:\n *\n *   int (*RedisModuleNotificationFunc) (RedisModuleCtx *ctx, int type,\n *                                       const char *event,\n *                                       RedisModuleString *key);\n *\n * `type` is the event type bit, that must match the mask given at registration\n * time. The event string is the actual command being executed, and key is the\n * relevant Redis key.\n *\n * Notification callback gets executed with a redis context that can not be\n * used to send anything to the client, and has the db number where the event\n * occurred as its selected db number.\n *\n * Notice that it is not necessary to enable notifications in redis.conf for\n * module notifications to work.\n *\n * Warning: the notification callbacks are performed in a synchronous manner,\n * so notification callbacks must to be fast, or they would slow Redis down.\n * If you need to take long actions, use threads to offload them.\n *\n * See https://redis.io/topics/notifications for more information.\n */\nint RM_SubscribeToKeyspaceEvents(RedisModuleCtx *ctx, int types, RedisModuleNotificationFunc callback) {\n    RedisModuleKeyspaceSubscriber *sub = zmalloc(sizeof(*sub));\n    sub->module = ctx->module;\n    sub->event_mask = types;\n    sub->notify_callback = callback;\n    sub->active = 0;\n\n    listAddNodeTail(moduleKeyspaceSubscribers, sub);\n    return REDISMODULE_OK;\n}\n\n/* Dispatcher for keyspace notifications to module subscriber functions.\n * This gets called  only if at least one module requested to be notified on\n * keyspace notifications */\nvoid moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid) {\n    /* Don't do anything if there aren't any subscribers */\n    if (listLength(moduleKeyspaceSubscribers) == 0) return;\n\n    listIter li;\n    listNode *ln;\n    listRewind(moduleKeyspaceSubscribers,&li);\n\n    /* Remove irrelevant flags from the type mask */\n    type &= ~(NOTIFY_KEYEVENT | NOTIFY_KEYSPACE);\n\n    while((ln = listNext(&li))) {\n        RedisModuleKeyspaceSubscriber *sub = ln->value;\n        /* Only notify subscribers on events matching they registration,\n         * and avoid subscribers triggering themselves */\n        if ((sub->event_mask & type) && sub->active == 0) {\n            RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n            ctx.module = sub->module;\n            ctx.client = moduleFreeContextReusedClient;\n            selectDb(ctx.client, dbid);\n\n            /* mark the handler as active to avoid reentrant loops.\n             * If the subscriber performs an action triggering itself,\n             * it will not be notified about it. */\n            sub->active = 1;\n            sub->notify_callback(&ctx, type, event, key);\n            sub->active = 0;\n            moduleFreeContext(&ctx);\n        }\n    }\n}\n\n/* Unsubscribe any notification subscribers this module has upon unloading */\nvoid moduleUnsubscribeNotifications(RedisModule *module) {\n    listIter li;\n    listNode *ln;\n    listRewind(moduleKeyspaceSubscribers,&li);\n    while((ln = listNext(&li))) {\n        RedisModuleKeyspaceSubscriber *sub = ln->value;\n        if (sub->module == module) {\n            listDelNode(moduleKeyspaceSubscribers, ln);\n            zfree(sub);\n        }\n    }\n}\n\n/* --------------------------------------------------------------------------\n * Modules Cluster API\n * -------------------------------------------------------------------------- */\n\n/* The Cluster message callback function pointer type. */\ntypedef void (*RedisModuleClusterMessageReceiver)(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len);\n\n/* This structure identifies a registered caller: it must match a given module\n * ID, for a given message type. The callback function is just the function\n * that was registered as receiver. */\ntypedef struct moduleClusterReceiver {\n    uint64_t module_id;\n    RedisModuleClusterMessageReceiver callback;\n    struct RedisModule *module;\n    struct moduleClusterReceiver *next;\n} moduleClusterReceiver;\n\ntypedef struct moduleClusterNodeInfo {\n    int flags;\n    char ip[NET_IP_STR_LEN];\n    int port;\n    char master_id[40]; /* Only if flags & REDISMODULE_NODE_MASTER is true. */\n} mdouleClusterNodeInfo;\n\n/* We have an array of message types: each bucket is a linked list of\n * configured receivers. */\nstatic moduleClusterReceiver *clusterReceivers[UINT8_MAX];\n\n/* Dispatch the message to the right module receiver. */\nvoid moduleCallClusterReceivers(const char *sender_id, uint64_t module_id, uint8_t type, const unsigned char *payload, uint32_t len) {\n    moduleClusterReceiver *r = clusterReceivers[type];\n    while(r) {\n        if (r->module_id == module_id) {\n            RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n            ctx.module = r->module;\n            ctx.client = moduleFreeContextReusedClient;\n            selectDb(ctx.client, 0);\n            r->callback(&ctx,sender_id,type,payload,len);\n            moduleFreeContext(&ctx);\n            return;\n        }\n        r = r->next;\n    }\n}\n\n/* Register a callback receiver for cluster messages of type 'type'. If there\n * was already a registered callback, this will replace the callback function\n * with the one provided, otherwise if the callback is set to NULL and there\n * is already a callback for this function, the callback is unregistered\n * (so this API call is also used in order to delete the receiver). */\nvoid RM_RegisterClusterMessageReceiver(RedisModuleCtx *ctx, uint8_t type, RedisModuleClusterMessageReceiver callback) {\n    if (!server.cluster_enabled) return;\n\n    uint64_t module_id = moduleTypeEncodeId(ctx->module->name,0);\n    moduleClusterReceiver *r = clusterReceivers[type], *prev = NULL;\n    while(r) {\n        if (r->module_id == module_id) {\n            /* Found! Set or delete. */\n            if (callback) {\n                r->callback = callback;\n            } else {\n                /* Delete the receiver entry if the user is setting\n                 * it to NULL. Just unlink the receiver node from the\n                 * linked list. */\n                if (prev)\n                    prev->next = r->next;\n                else\n                    clusterReceivers[type]->next = r->next;\n                zfree(r);\n            }\n            return;\n        }\n        prev = r;\n        r = r->next;\n    }\n\n    /* Not found, let's add it. */\n    if (callback) {\n        r = zmalloc(sizeof(*r));\n        r->module_id = module_id;\n        r->module = ctx->module;\n        r->callback = callback;\n        r->next = clusterReceivers[type];\n        clusterReceivers[type] = r;\n    }\n}\n\n/* Send a message to all the nodes in the cluster if `target` is NULL, otherwise\n * at the specified target, which is a REDISMODULE_NODE_ID_LEN bytes node ID, as\n * returned by the receiver callback or by the nodes iteration functions.\n *\n * The function returns REDISMODULE_OK if the message was successfully sent,\n * otherwise if the node is not connected or such node ID does not map to any\n * known cluster node, REDISMODULE_ERR is returned. */\nint RM_SendClusterMessage(RedisModuleCtx *ctx, char *target_id, uint8_t type, unsigned char *msg, uint32_t len) {\n    if (!server.cluster_enabled) return REDISMODULE_ERR;\n    uint64_t module_id = moduleTypeEncodeId(ctx->module->name,0);\n    if (clusterSendModuleMessageToTarget(target_id,module_id,type,msg,len) == C_OK)\n        return REDISMODULE_OK;\n    else\n        return REDISMODULE_ERR;\n}\n\n/* Return an array of string pointers, each string pointer points to a cluster\n * node ID of exactly REDISMODULE_NODE_ID_SIZE bytes (without any null term).\n * The number of returned node IDs is stored into `*numnodes`.\n * However if this function is called by a module not running an a Redis\n * instance with Redis Cluster enabled, NULL is returned instead.\n *\n * The IDs returned can be used with RedisModule_GetClusterNodeInfo() in order\n * to get more information about single nodes.\n *\n * The array returned by this function must be freed using the function\n * RedisModule_FreeClusterNodesList().\n *\n * Example:\n *\n *     size_t count, j;\n *     char **ids = RedisModule_GetClusterNodesList(ctx,&count);\n *     for (j = 0; j < count; j++) {\n *         RedisModule_Log(\"notice\",\"Node %.*s\",\n *             REDISMODULE_NODE_ID_LEN,ids[j]);\n *     }\n *     RedisModule_FreeClusterNodesList(ids);\n */\nchar **RM_GetClusterNodesList(RedisModuleCtx *ctx, size_t *numnodes) {\n    UNUSED(ctx);\n\n    if (!server.cluster_enabled) return NULL;\n    size_t count = dictSize(server.cluster->nodes);\n    char **ids = zmalloc((count+1)*REDISMODULE_NODE_ID_LEN);\n    dictIterator *di = dictGetIterator(server.cluster->nodes);\n    dictEntry *de;\n    int j = 0;\n    while((de = dictNext(di)) != NULL) {\n        clusterNode *node = dictGetVal(de);\n        if (node->flags & (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE)) continue;\n        ids[j] = zmalloc(REDISMODULE_NODE_ID_LEN);\n        memcpy(ids[j],node->name,REDISMODULE_NODE_ID_LEN);\n        j++;\n    }\n    *numnodes = j;\n    ids[j] = NULL; /* Null term so that FreeClusterNodesList does not need\n                    * to also get the count argument. */\n    dictReleaseIterator(di);\n    return ids;\n}\n\n/* Free the node list obtained with RedisModule_GetClusterNodesList. */\nvoid RM_FreeClusterNodesList(char **ids) {\n    if (ids == NULL) return;\n    for (int j = 0; ids[j]; j++) zfree(ids[j]);\n    zfree(ids);\n}\n\n/* Return this node ID (REDISMODULE_CLUSTER_ID_LEN bytes) or NULL if the cluster\n * is disabled. */\nconst char *RM_GetMyClusterID(void) {\n    if (!server.cluster_enabled) return NULL;\n    return server.cluster->myself->name;\n}\n\n/* Return the number of nodes in the cluster, regardless of their state\n * (handshake, noaddress, ...) so that the number of active nodes may actually\n * be smaller, but not greater than this number. If the instance is not in\n * cluster mode, zero is returned. */\nsize_t RM_GetClusterSize(void) {\n    if (!server.cluster_enabled) return 0;\n    return dictSize(server.cluster->nodes);\n}\n\n/* Populate the specified info for the node having as ID the specified 'id',\n * then returns REDISMODULE_OK. Otherwise if the node ID does not exist from\n * the POV of this local node, REDISMODULE_ERR is returned.\n *\n * The arguments ip, master_id, port and flags can be NULL in case we don't\n * need to populate back certain info. If an ip and master_id (only populated\n * if the instance is a slave) are specified, they point to buffers holding\n * at least REDISMODULE_NODE_ID_LEN bytes. The strings written back as ip\n * and master_id are not null terminated.\n *\n * The list of flags reported is the following:\n *\n * * REDISMODULE_NODE_MYSELF        This node\n * * REDISMODULE_NODE_MASTER        The node is a master\n * * REDISMODULE_NODE_SLAVE         The node is a replica\n * * REDISMODULE_NODE_PFAIL         We see the node as failing\n * * REDISMODULE_NODE_FAIL          The cluster agrees the node is failing\n * * REDISMODULE_NODE_NOFAILOVER    The slave is configured to never failover\n */\n\nclusterNode *clusterLookupNode(const char *name); /* We need access to internals */\n\nint RM_GetClusterNodeInfo(RedisModuleCtx *ctx, const char *id, char *ip, char *master_id, int *port, int *flags) {\n    UNUSED(ctx);\n\n    clusterNode *node = clusterLookupNode(id);\n    if (node->flags & (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE))\n        return REDISMODULE_ERR;\n\n    if (ip) memcpy(ip,node->name,REDISMODULE_NODE_ID_LEN);\n\n    if (master_id) {\n        /* If the information is not available, the function will set the\n         * field to zero bytes, so that when the field can't be populated the\n         * function kinda remains predictable. */\n        if (node->flags & CLUSTER_NODE_MASTER && node->slaveof)\n            memcpy(master_id,node->slaveof->name,REDISMODULE_NODE_ID_LEN);\n        else\n            memset(master_id,0,REDISMODULE_NODE_ID_LEN);\n    }\n    if (port) *port = node->port;\n\n    /* As usually we have to remap flags for modules, in order to ensure\n     * we can provide binary compatibility. */\n    if (flags) {\n        *flags = 0;\n        if (node->flags & CLUSTER_NODE_MYSELF) *flags |= REDISMODULE_NODE_MYSELF;\n        if (node->flags & CLUSTER_NODE_MASTER) *flags |= REDISMODULE_NODE_MASTER;\n        if (node->flags & CLUSTER_NODE_SLAVE) *flags |= REDISMODULE_NODE_SLAVE;\n        if (node->flags & CLUSTER_NODE_PFAIL) *flags |= REDISMODULE_NODE_PFAIL;\n        if (node->flags & CLUSTER_NODE_FAIL) *flags |= REDISMODULE_NODE_FAIL;\n        if (node->flags & CLUSTER_NODE_NOFAILOVER) *flags |= REDISMODULE_NODE_NOFAILOVER;\n    }\n    return REDISMODULE_OK;\n}\n\n/* Set Redis Cluster flags in order to change the normal behavior of\n * Redis Cluster, especially with the goal of disabling certain functions.\n * This is useful for modules that use the Cluster API in order to create\n * a different distributed system, but still want to use the Redis Cluster\n * message bus. Flags that can be set:\n *\n *  CLUSTER_MODULE_FLAG_NO_FAILOVER\n *  CLUSTER_MODULE_FLAG_NO_REDIRECTION\n *\n * With the following effects:\n *\n *  NO_FAILOVER: prevent Redis Cluster slaves to failover a failing master.\n *               Also disables the replica migration feature.\n *\n *  NO_REDIRECTION: Every node will accept any key, without trying to perform\n *                  partitioning according to the user Redis Cluster algorithm.\n *                  Slots informations will still be propagated across the\n *                  cluster, but without effects. */\nvoid RM_SetClusterFlags(RedisModuleCtx *ctx, uint64_t flags) {\n    UNUSED(ctx);\n    if (flags & REDISMODULE_CLUSTER_FLAG_NO_FAILOVER)\n        server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_FAILOVER;\n    if (flags & REDISMODULE_CLUSTER_FLAG_NO_REDIRECTION)\n        server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_REDIRECTION;\n}\n\n/* --------------------------------------------------------------------------\n * Modules Timers API\n *\n * Module timers are an high precision \"green timers\" abstraction where\n * every module can register even millions of timers without problems, even if\n * the actual event loop will just have a single timer that is used to awake the\n * module timers subsystem in order to process the next event.\n *\n * All the timers are stored into a radix tree, ordered by expire time, when\n * the main Redis event loop timer callback is called, we try to process all\n * the timers already expired one after the other. Then we re-enter the event\n * loop registering a timer that will expire when the next to process module\n * timer will expire.\n *\n * Every time the list of active timers drops to zero, we unregister the\n * main event loop timer, so that there is no overhead when such feature is\n * not used.\n * -------------------------------------------------------------------------- */\n\nstatic rax *Timers;     /* The radix tree of all the timers sorted by expire. */\nlong long aeTimer = -1; /* Main event loop (ae.c) timer identifier. */\n\ntypedef void (*RedisModuleTimerProc)(RedisModuleCtx *ctx, void *data);\n\n/* The timer descriptor, stored as value in the radix tree. */\ntypedef struct RedisModuleTimer {\n    RedisModule *module;                /* Module reference. */\n    RedisModuleTimerProc callback;      /* The callback to invoke on expire. */\n    void *data;                         /* Private data for the callback. */\n    int dbid;                           /* Database number selected by the original client. */\n} RedisModuleTimer;\n\n/* This is the timer handler that is called by the main event loop. We schedule\n * this timer to be called when the nearest of our module timers will expire. */\nint moduleTimerHandler(struct aeEventLoop *eventLoop, long long id, void *clientData) {\n    UNUSED(eventLoop);\n    UNUSED(id);\n    UNUSED(clientData);\n\n    /* To start let's try to fire all the timers already expired. */\n    raxIterator ri;\n    raxStart(&ri,Timers);\n    uint64_t now = ustime();\n    long long next_period = 0;\n    while(1) {\n        raxSeek(&ri,\"^\",NULL,0);\n        if (!raxNext(&ri)) break;\n        uint64_t expiretime;\n        memcpy(&expiretime,ri.key,sizeof(expiretime));\n        expiretime = ntohu64(expiretime);\n        if (now >= expiretime) {\n            RedisModuleTimer *timer = ri.data;\n            RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n\n            ctx.module = timer->module;\n            ctx.client = moduleFreeContextReusedClient;\n            selectDb(ctx.client, timer->dbid);\n            timer->callback(&ctx,timer->data);\n            moduleFreeContext(&ctx);\n            raxRemove(Timers,(unsigned char*)ri.key,ri.key_len,NULL);\n            zfree(timer);\n        } else {\n            next_period = (expiretime-now)/1000; /* Scale to milliseconds. */\n            break;\n        }\n    }\n    raxStop(&ri);\n\n    /* Reschedule the next timer or cancel it. */\n    if (next_period <= 0) next_period = 1;\n    return (raxSize(Timers) > 0) ? next_period : AE_NOMORE;\n}\n\n/* Create a new timer that will fire after `period` milliseconds, and will call\n * the specified function using `data` as argument. The returned timer ID can be\n * used to get information from the timer or to stop it before it fires. */\nRedisModuleTimerID RM_CreateTimer(RedisModuleCtx *ctx, mstime_t period, RedisModuleTimerProc callback, void *data) {\n    RedisModuleTimer *timer = zmalloc(sizeof(*timer));\n    timer->module = ctx->module;\n    timer->callback = callback;\n    timer->data = data;\n    timer->dbid = ctx->client->db->id;\n    uint64_t expiretime = ustime()+period*1000;\n    uint64_t key;\n\n    while(1) {\n        key = htonu64(expiretime);\n        if (raxFind(Timers, (unsigned char*)&key,sizeof(key)) == raxNotFound) {\n            raxInsert(Timers,(unsigned char*)&key,sizeof(key),timer,NULL);\n            break;\n        } else {\n            expiretime++;\n        }\n    }\n\n    /* We need to install the main event loop timer if it's not already\n     * installed, or we may need to refresh its period if we just installed\n     * a timer that will expire sooner than any other else. */\n    if (aeTimer != -1) {\n        raxIterator ri;\n        raxStart(&ri,Timers);\n        raxSeek(&ri,\"^\",NULL,0);\n        raxNext(&ri);\n        if (memcmp(ri.key,&key,sizeof(key)) == 0) {\n            /* This is the first key, we need to re-install the timer according\n             * to the just added event. */\n            aeDeleteTimeEvent(server.el,aeTimer);\n            aeTimer = -1;\n        }\n        raxStop(&ri);\n    }\n\n    /* If we have no main timer (the old one was invalidated, or this is the\n     * first module timer we have), install one. */\n    if (aeTimer == -1)\n        aeTimer = aeCreateTimeEvent(server.el,period,moduleTimerHandler,NULL,NULL);\n\n    return key;\n}\n\n/* Stop a timer, returns REDISMODULE_OK if the timer was found, belonged to the\n * calling module, and was stopped, otherwise REDISMODULE_ERR is returned.\n * If not NULL, the data pointer is set to the value of the data argument when\n * the timer was created. */\nint RM_StopTimer(RedisModuleCtx *ctx, RedisModuleTimerID id, void **data) {\n    RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&id,sizeof(id));\n    if (timer == raxNotFound || timer->module != ctx->module)\n        return REDISMODULE_ERR;\n    if (data) *data = timer->data;\n    raxRemove(Timers,(unsigned char*)&id,sizeof(id),NULL);\n    zfree(timer);\n    return REDISMODULE_OK;\n}\n\n/* Obtain information about a timer: its remaining time before firing\n * (in milliseconds), and the private data pointer associated with the timer.\n * If the timer specified does not exist or belongs to a different module\n * no information is returned and the function returns REDISMODULE_ERR, otherwise\n * REDISMODULE_OK is returned. The arguments remaining or data can be NULL if\n * the caller does not need certain information. */\nint RM_GetTimerInfo(RedisModuleCtx *ctx, RedisModuleTimerID id, uint64_t *remaining, void **data) {\n    RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&id,sizeof(id));\n    if (timer == raxNotFound || timer->module != ctx->module)\n        return REDISMODULE_ERR;\n    if (remaining) {\n        int64_t rem = ntohu64(id)-ustime();\n        if (rem < 0) rem = 0;\n        *remaining = rem/1000; /* Scale to milliseconds. */\n    }\n    if (data) *data = timer->data;\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Modules Dictionary API\n *\n * Implements a sorted dictionary (actually backed by a radix tree) with\n * the usual get / set / del / num-items API, together with an iterator\n * capable of going back and forth.\n * -------------------------------------------------------------------------- */\n\n/* Create a new dictionary. The 'ctx' pointer can be the current module context\n * or NULL, depending on what you want. Please follow the following rules:\n *\n * 1. Use a NULL context if you plan to retain a reference to this dictionary\n *    that will survive the time of the module callback where you created it.\n * 2. Use a NULL context if no context is available at the time you are creating\n *    the dictionary (of course...).\n * 3. However use the current callback context as 'ctx' argument if the\n *    dictionary time to live is just limited to the callback scope. In this\n *    case, if enabled, you can enjoy the automatic memory management that will\n *    reclaim the dictionary memory, as well as the strings returned by the\n *    Next / Prev dictionary iterator calls.\n */\nRedisModuleDict *RM_CreateDict(RedisModuleCtx *ctx) {\n    struct RedisModuleDict *d = zmalloc(sizeof(*d));\n    d->rax = raxNew();\n    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_DICT,d);\n    return d;\n}\n\n/* Free a dictionary created with RM_CreateDict(). You need to pass the\n * context pointer 'ctx' only if the dictionary was created using the\n * context instead of passing NULL. */\nvoid RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d) {\n    if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_DICT,d);\n    raxFree(d->rax);\n    zfree(d);\n}\n\n/* Return the size of the dictionary (number of keys). */\nuint64_t RM_DictSize(RedisModuleDict *d) {\n    return raxSize(d->rax);\n}\n\n/* Store the specified key into the dictionary, setting its value to the\n * pointer 'ptr'. If the key was added with success, since it did not\n * already exist, REDISMODULE_OK is returned. Otherwise if the key already\n * exists the function returns REDISMODULE_ERR. */\nint RM_DictSetC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {\n    int retval = raxTryInsert(d->rax,key,keylen,ptr,NULL);\n    return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* Like RedisModule_DictSetC() but will replace the key with the new\n * value if the key already exists. */\nint RM_DictReplaceC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {\n    int retval = raxInsert(d->rax,key,keylen,ptr,NULL);\n    return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* Like RedisModule_DictSetC() but takes the key as a RedisModuleString. */\nint RM_DictSet(RedisModuleDict *d, RedisModuleString *key, void *ptr) {\n    return RM_DictSetC(d,key->ptr,sdslen(key->ptr),ptr);\n}\n\n/* Like RedisModule_DictReplaceC() but takes the key as a RedisModuleString. */\nint RM_DictReplace(RedisModuleDict *d, RedisModuleString *key, void *ptr) {\n    return RM_DictReplaceC(d,key->ptr,sdslen(key->ptr),ptr);\n}\n\n/* Return the value stored at the specified key. The function returns NULL\n * both in the case the key does not exist, or if you actually stored\n * NULL at key. So, optionally, if the 'nokey' pointer is not NULL, it will\n * be set by reference to 1 if the key does not exist, or to 0 if the key\n * exists. */\nvoid *RM_DictGetC(RedisModuleDict *d, void *key, size_t keylen, int *nokey) {\n    void *res = raxFind(d->rax,key,keylen);\n    if (nokey) *nokey = (res == raxNotFound);\n    return (res == raxNotFound) ? NULL : res;\n}\n\n/* Like RedisModule_DictGetC() but takes the key as a RedisModuleString. */\nvoid *RM_DictGet(RedisModuleDict *d, RedisModuleString *key, int *nokey) {\n    return RM_DictGetC(d,key->ptr,sdslen(key->ptr),nokey);\n}\n\n/* Remove the specified key from the dictionary, returning REDISMODULE_OK if\n * the key was found and delted, or REDISMODULE_ERR if instead there was\n * no such key in the dictionary. When the operation is successful, if\n * 'oldval' is not NULL, then '*oldval' is set to the value stored at the\n * key before it was deleted. Using this feature it is possible to get\n * a pointer to the value (for instance in order to release it), without\n * having to call RedisModule_DictGet() before deleting the key. */\nint RM_DictDelC(RedisModuleDict *d, void *key, size_t keylen, void *oldval) {\n    int retval = raxRemove(d->rax,key,keylen,oldval);\n    return retval ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* Like RedisModule_DictDelC() but gets the key as a RedisModuleString. */\nint RM_DictDel(RedisModuleDict *d, RedisModuleString *key, void *oldval) {\n    return RM_DictDelC(d,key->ptr,sdslen(key->ptr),oldval);\n}\n\n/* Return an interator, setup in order to start iterating from the specified\n * key by applying the operator 'op', which is just a string specifying the\n * comparison operator to use in order to seek the first element. The\n * operators avalable are:\n *\n * \"^\"   -- Seek the first (lexicographically smaller) key.\n * \"$\"   -- Seek the last  (lexicographically biffer) key.\n * \">\"   -- Seek the first element greter than the specified key.\n * \">=\"  -- Seek the first element greater or equal than the specified key.\n * \"<\"   -- Seek the first element smaller than the specified key.\n * \"<=\"  -- Seek the first element smaller or equal than the specified key.\n * \"==\"  -- Seek the first element matching exactly the specified key.\n *\n * Note that for \"^\" and \"$\" the passed key is not used, and the user may\n * just pass NULL with a length of 0.\n *\n * If the element to start the iteration cannot be seeked based on the\n * key and operator passed, RedisModule_DictNext() / Prev() will just return\n * REDISMODULE_ERR at the first call, otherwise they'll produce elements.\n */\nRedisModuleDictIter *RM_DictIteratorStartC(RedisModuleDict *d, const char *op, void *key, size_t keylen) {\n    RedisModuleDictIter *di = zmalloc(sizeof(*di));\n    di->dict = d;\n    raxStart(&di->ri,d->rax);\n    raxSeek(&di->ri,op,key,keylen);\n    return di;\n}\n\n/* Exactly like RedisModule_DictIteratorStartC, but the key is passed as a\n * RedisModuleString. */\nRedisModuleDictIter *RM_DictIteratorStart(RedisModuleDict *d, const char *op, RedisModuleString *key) {\n    return RM_DictIteratorStartC(d,op,key->ptr,sdslen(key->ptr));\n}\n\n/* Release the iterator created with RedisModule_DictIteratorStart(). This call\n * is mandatory otherwise a memory leak is introduced in the module. */\nvoid RM_DictIteratorStop(RedisModuleDictIter *di) {\n    raxStop(&di->ri);\n    zfree(di);\n}\n\n/* After its creation with RedisModule_DictIteratorStart(), it is possible to\n * change the currently selected element of the iterator by using this\n * API call. The result based on the operator and key is exactly like\n * the function RedisModule_DictIteratorStart(), however in this case the\n * return value is just REDISMODULE_OK in case the seeked element was found,\n * or REDISMODULE_ERR in case it was not possible to seek the specified\n * element. It is possible to reseek an iterator as many times as you want. */\nint RM_DictIteratorReseekC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {\n    return raxSeek(&di->ri,op,key,keylen);\n}\n\n/* Like RedisModule_DictIteratorReseekC() but takes the key as as a\n * RedisModuleString. */\nint RM_DictIteratorReseek(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {\n    return RM_DictIteratorReseekC(di,op,key->ptr,sdslen(key->ptr));\n}\n\n/* Return the current item of the dictionary iterator 'di' and steps to the\n * next element. If the iterator already yield the last element and there\n * are no other elements to return, NULL is returned, otherwise a pointer\n * to a string representing the key is provided, and the '*keylen' length\n * is set by reference (if keylen is not NULL). The '*dataptr', if not NULL\n * is set to the value of the pointer stored at the returned key as auxiliary\n * data (as set by the RedisModule_DictSet API).\n *\n * Usage example:\n *\n *      ... create the iterator here ...\n *      char *key;\n *      void *data;\n *      while((key = RedisModule_DictNextC(iter,&keylen,&data)) != NULL) {\n *          printf(\"%.*s %p\\n\", (int)keylen, key, data);\n *      }\n *\n * The returned pointer is of type void because sometimes it makes sense\n * to cast it to a char* sometimes to an unsigned char* depending on the\n * fact it contains or not binary data, so this API ends being more\n * comfortable to use.\n *\n * The validity of the returned pointer is until the next call to the\n * next/prev iterator step. Also the pointer is no longer valid once the\n * iterator is released. */\nvoid *RM_DictNextC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {\n    if (!raxNext(&di->ri)) return NULL;\n    if (keylen) *keylen = di->ri.key_len;\n    if (dataptr) *dataptr = di->ri.data;\n    return di->ri.key;\n}\n\n/* This function is exactly like RedisModule_DictNext() but after returning\n * the currently selected element in the iterator, it selects the previous\n * element (laxicographically smaller) instead of the next one. */\nvoid *RM_DictPrevC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {\n    if (!raxPrev(&di->ri)) return NULL;\n    if (keylen) *keylen = di->ri.key_len;\n    if (dataptr) *dataptr = di->ri.data;\n    return di->ri.key;\n}\n\n/* Like RedisModuleNextC(), but instead of returning an internally allocated\n * buffer and key length, it returns directly a module string object allocated\n * in the specified context 'ctx' (that may be NULL exactly like for the main\n * API RedisModule_CreateString).\n *\n * The returned string object should be deallocated after use, either manually\n * or by using a context that has automatic memory management active. */\nRedisModuleString *RM_DictNext(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {\n    size_t keylen;\n    void *key = RM_DictNextC(di,&keylen,dataptr);\n    if (key == NULL) return NULL;\n    return RM_CreateString(ctx,key,keylen);\n}\n\n/* Like RedisModule_DictNext() but after returning the currently selected\n * element in the iterator, it selects the previous element (laxicographically\n * smaller) instead of the next one. */\nRedisModuleString *RM_DictPrev(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {\n    size_t keylen;\n    void *key = RM_DictPrevC(di,&keylen,dataptr);\n    if (key == NULL) return NULL;\n    return RM_CreateString(ctx,key,keylen);\n}\n\n/* Compare the element currently pointed by the iterator to the specified\n * element given by key/keylen, according to the operator 'op' (the set of\n * valid operators are the same valid for RedisModule_DictIteratorStart).\n * If the comparision is successful the command returns REDISMODULE_OK\n * otherwise REDISMODULE_ERR is returned.\n *\n * This is useful when we want to just emit a lexicographical range, so\n * in the loop, as we iterate elements, we can also check if we are still\n * on range.\n *\n * The function returne REDISMODULE_ERR if the iterator reached the\n * end of elements condition as well. */\nint RM_DictCompareC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {\n    if (raxEOF(&di->ri)) return REDISMODULE_ERR;\n    int res = raxCompare(&di->ri,op,key,keylen);\n    return res ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* Like RedisModule_DictCompareC but gets the key to compare with the current\n * iterator key as a RedisModuleString. */\nint RM_DictCompare(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {\n    if (raxEOF(&di->ri)) return REDISMODULE_ERR;\n    int res = raxCompare(&di->ri,op,key->ptr,sdslen(key->ptr));\n    return res ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* --------------------------------------------------------------------------\n * Modules utility APIs\n * -------------------------------------------------------------------------- */\n\n/* Return random bytes using SHA1 in counter mode with a /dev/urandom\n * initialized seed. This function is fast so can be used to generate\n * many bytes without any effect on the operating system entropy pool.\n * Currently this function is not thread safe. */\nvoid RM_GetRandomBytes(unsigned char *dst, size_t len) {\n    getRandomBytes(dst,len);\n}\n\n/* Like RedisModule_GetRandomBytes() but instead of setting the string to\n * random bytes the string is set to random characters in the in the\n * hex charset [0-9a-f]. */\nvoid RM_GetRandomHexChars(char *dst, size_t len) {\n    getRandomHexChars(dst,len);\n}\n\n/* --------------------------------------------------------------------------\n * Modules API internals\n * -------------------------------------------------------------------------- */\n\n/* server.moduleapi dictionary type. Only uses plain C strings since\n * this gets queries from modules. */\n\nuint64_t dictCStringKeyHash(const void *key) {\n    return dictGenHashFunction((unsigned char*)key, strlen((char*)key));\n}\n\nint dictCStringKeyCompare(void *privdata, const void *key1, const void *key2) {\n    UNUSED(privdata);\n    return strcmp(key1,key2) == 0;\n}\n\ndictType moduleAPIDictType = {\n    dictCStringKeyHash,        /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictCStringKeyCompare,     /* key compare */\n    NULL,                      /* key destructor */\n    NULL                       /* val destructor */\n};\n\nint moduleRegisterApi(const char *funcname, void *funcptr) {\n    return dictAdd(server.moduleapi, (char*)funcname, funcptr);\n}\n\n#define REGISTER_API(name) \\\n    moduleRegisterApi(\"RedisModule_\" #name, (void *)(unsigned long)RM_ ## name)\n\n/* Global initialization at Redis startup. */\nvoid moduleRegisterCoreAPI(void);\n\nvoid moduleInitModulesSystem(void) {\n    moduleUnblockedClients = listCreate();\n    server.loadmodule_queue = listCreate();\n    modules = dictCreate(&modulesDictType,NULL);\n\n    /* Set up the keyspace notification susbscriber list and static client */\n    moduleKeyspaceSubscribers = listCreate();\n    moduleFreeContextReusedClient = createClient(-1);\n    moduleFreeContextReusedClient->flags |= CLIENT_MODULE;\n\n    moduleRegisterCoreAPI();\n    if (pipe(server.module_blocked_pipe) == -1) {\n        serverLog(LL_WARNING,\n            \"Can't create the pipe for module blocking commands: %s\",\n            strerror(errno));\n        exit(1);\n    }\n    /* Make the pipe non blocking. This is just a best effort aware mechanism\n     * and we do not want to block not in the read nor in the write half. */\n    anetNonBlock(NULL,server.module_blocked_pipe[0]);\n    anetNonBlock(NULL,server.module_blocked_pipe[1]);\n\n    /* Create the timers radix tree. */\n    Timers = raxNew();\n\n    /* Our thread-safe contexts GIL must start with already locked:\n     * it is just unlocked when it's safe. */\n    pthread_mutex_lock(&moduleGIL);\n}\n\n/* Load all the modules in the server.loadmodule_queue list, which is\n * populated by `loadmodule` directives in the configuration file.\n * We can't load modules directly when processing the configuration file\n * because the server must be fully initialized before loading modules.\n *\n * The function aborts the server on errors, since to start with missing\n * modules is not considered sane: clients may rely on the existence of\n * given commands, loading AOF also may need some modules to exist, and\n * if this instance is a slave, it must understand commands from master. */\nvoid moduleLoadFromQueue(void) {\n    listIter li;\n    listNode *ln;\n\n    listRewind(server.loadmodule_queue,&li);\n    while((ln = listNext(&li))) {\n        struct moduleLoadQueueEntry *loadmod = ln->value;\n        if (moduleLoad(loadmod->path,(void **)loadmod->argv,loadmod->argc)\n            == C_ERR)\n        {\n            serverLog(LL_WARNING,\n                \"Can't load module from %s: server aborting\",\n                loadmod->path);\n            exit(1);\n        }\n    }\n}\n\nvoid moduleFreeModuleStructure(struct RedisModule *module) {\n    listRelease(module->types);\n    sdsfree(module->name);\n    zfree(module);\n}\n\nvoid moduleUnregisterCommands(struct RedisModule *module) {\n    /* Unregister all the commands registered by this module. */\n    dictIterator *di = dictGetSafeIterator(server.commands);\n    dictEntry *de;\n    while ((de = dictNext(di)) != NULL) {\n        struct redisCommand *cmd = dictGetVal(de);\n        if (cmd->proc == RedisModuleCommandDispatcher) {\n            RedisModuleCommandProxy *cp =\n                (void*)(unsigned long)cmd->getkeys_proc;\n            sds cmdname = cp->rediscmd->name;\n            if (cp->module == module) {\n                dictDelete(server.commands,cmdname);\n                dictDelete(server.orig_commands,cmdname);\n                sdsfree(cmdname);\n                zfree(cp->rediscmd);\n                zfree(cp);\n            }\n        }\n    }\n    dictReleaseIterator(di);\n}\n\n/* Load a module and initialize it. On success C_OK is returned, otherwise\n * C_ERR is returned. */\nint moduleLoad(const char *path, void **module_argv, int module_argc) {\n    int (*onload)(void *, void **, int);\n    void *handle;\n    RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n\n    handle = dlopen(path,RTLD_NOW|RTLD_LOCAL);\n    if (handle == NULL) {\n        serverLog(LL_WARNING, \"Module %s failed to load: %s\", path, dlerror());\n        return C_ERR;\n    }\n    onload = (int (*)(void *, void **, int))(unsigned long) dlsym(handle,\"RedisModule_OnLoad\");\n    if (onload == NULL) {\n        dlclose(handle);\n        serverLog(LL_WARNING,\n            \"Module %s does not export RedisModule_OnLoad() \"\n            \"symbol. Module not loaded.\",path);\n        return C_ERR;\n    }\n    if (onload((void*)&ctx,module_argv,module_argc) == REDISMODULE_ERR) {\n        if (ctx.module) {\n            moduleUnregisterCommands(ctx.module);\n            moduleFreeModuleStructure(ctx.module);\n        }\n        dlclose(handle);\n        serverLog(LL_WARNING,\n            \"Module %s initialization failed. Module not loaded\",path);\n        return C_ERR;\n    }\n\n    /* Redis module loaded! Register it. */\n    dictAdd(modules,ctx.module->name,ctx.module);\n    ctx.module->handle = handle;\n    serverLog(LL_NOTICE,\"Module '%s' loaded from %s\",ctx.module->name,path);\n    moduleFreeContext(&ctx);\n    return C_OK;\n}\n\n\n/* Unload the module registered with the specified name. On success\n * C_OK is returned, otherwise C_ERR is returned and errno is set\n * to the following values depending on the type of error:\n *\n * * ENONET: No such module having the specified name.\n * * EBUSY: The module exports a new data type and can only be reloaded. */\nint moduleUnload(sds name) {\n    struct RedisModule *module = dictFetchValue(modules,name);\n\n    if (module == NULL) {\n        errno = ENOENT;\n        return REDISMODULE_ERR;\n    }\n\n    if (listLength(module->types)) {\n        errno = EBUSY;\n        return REDISMODULE_ERR;\n    }\n\n    moduleUnregisterCommands(module);\n\n    /* Remove any notification subscribers this module might have */\n    moduleUnsubscribeNotifications(module);\n\n    /* Unregister all the hooks. TODO: Yet no hooks support here. */\n\n    /* Unload the dynamic library. */\n    if (dlclose(module->handle) == -1) {\n        char *error = dlerror();\n        if (error == NULL) error = \"Unknown error\";\n        serverLog(LL_WARNING,\"Error when trying to close the %s module: %s\",\n            module->name, error);\n    }\n\n    /* Remove from list of modules. */\n    serverLog(LL_NOTICE,\"Module %s unloaded\",module->name);\n    dictDelete(modules,module->name);\n    module->name = NULL; /* The name was already freed by dictDelete(). */\n    moduleFreeModuleStructure(module);\n\n    return REDISMODULE_OK;\n}\n\n/* Redis MODULE command.\n *\n * MODULE LOAD <path> [args...] */\nvoid moduleCommand(client *c) {\n    char *subcmd = c->argv[1]->ptr;\n    if (c->argc == 2 && !strcasecmp(subcmd,\"help\")) {\n        const char *help[] = {\n\"LIST -- Return a list of loaded modules.\",\n\"LOAD <path> [arg ...] -- Load a module library from <path>.\",\n\"UNLOAD <name> -- Unload a module.\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else\n    if (!strcasecmp(subcmd,\"load\") && c->argc >= 3) {\n        robj **argv = NULL;\n        int argc = 0;\n\n        if (c->argc > 3) {\n            argc = c->argc - 3;\n            argv = &c->argv[3];\n        }\n\n        if (moduleLoad(c->argv[2]->ptr,(void **)argv,argc) == C_OK)\n            addReply(c,shared.ok);\n        else\n            addReplyError(c,\n                \"Error loading the extension. Please check the server logs.\");\n    } else if (!strcasecmp(subcmd,\"unload\") && c->argc == 3) {\n        if (moduleUnload(c->argv[2]->ptr) == C_OK)\n            addReply(c,shared.ok);\n        else {\n            char *errmsg;\n            switch(errno) {\n            case ENOENT:\n                errmsg = \"no such module with that name\";\n                break;\n            case EBUSY:\n                errmsg = \"the module exports one or more module-side data types, can't unload\";\n                break;\n            default:\n                errmsg = \"operation not possible.\";\n                break;\n            }\n            addReplyErrorFormat(c,\"Error unloading module: %s\",errmsg);\n        }\n    } else if (!strcasecmp(subcmd,\"list\") && c->argc == 2) {\n        dictIterator *di = dictGetIterator(modules);\n        dictEntry *de;\n\n        addReplyMultiBulkLen(c,dictSize(modules));\n        while ((de = dictNext(di)) != NULL) {\n            sds name = dictGetKey(de);\n            struct RedisModule *module = dictGetVal(de);\n            addReplyMultiBulkLen(c,4);\n            addReplyBulkCString(c,\"name\");\n            addReplyBulkCBuffer(c,name,sdslen(name));\n            addReplyBulkCString(c,\"ver\");\n            addReplyLongLong(c,module->ver);\n        }\n        dictReleaseIterator(di);\n    } else {\n        addReplySubcommandSyntaxError(c);\n        return;\n    }\n}\n\n/* Return the number of registered modules. */\nsize_t moduleCount(void) {\n    return dictSize(modules);\n}\n\n/* Register all the APIs we export. Keep this function at the end of the\n * file so that's easy to seek it to add new entries. */\nvoid moduleRegisterCoreAPI(void) {\n    server.moduleapi = dictCreate(&moduleAPIDictType,NULL);\n    REGISTER_API(Alloc);\n    REGISTER_API(Calloc);\n    REGISTER_API(Realloc);\n    REGISTER_API(Free);\n    REGISTER_API(Strdup);\n    REGISTER_API(CreateCommand);\n    REGISTER_API(SetModuleAttribs);\n    REGISTER_API(IsModuleNameBusy);\n    REGISTER_API(WrongArity);\n    REGISTER_API(ReplyWithLongLong);\n    REGISTER_API(ReplyWithError);\n    REGISTER_API(ReplyWithSimpleString);\n    REGISTER_API(ReplyWithArray);\n    REGISTER_API(ReplySetArrayLength);\n    REGISTER_API(ReplyWithString);\n    REGISTER_API(ReplyWithStringBuffer);\n    REGISTER_API(ReplyWithNull);\n    REGISTER_API(ReplyWithCallReply);\n    REGISTER_API(ReplyWithDouble);\n    REGISTER_API(GetSelectedDb);\n    REGISTER_API(SelectDb);\n    REGISTER_API(OpenKey);\n    REGISTER_API(CloseKey);\n    REGISTER_API(KeyType);\n    REGISTER_API(ValueLength);\n    REGISTER_API(ListPush);\n    REGISTER_API(ListPop);\n    REGISTER_API(StringToLongLong);\n    REGISTER_API(StringToDouble);\n    REGISTER_API(Call);\n    REGISTER_API(CallReplyProto);\n    REGISTER_API(FreeCallReply);\n    REGISTER_API(CallReplyInteger);\n    REGISTER_API(CallReplyType);\n    REGISTER_API(CallReplyLength);\n    REGISTER_API(CallReplyArrayElement);\n    REGISTER_API(CallReplyStringPtr);\n    REGISTER_API(CreateStringFromCallReply);\n    REGISTER_API(CreateString);\n    REGISTER_API(CreateStringFromLongLong);\n    REGISTER_API(CreateStringFromString);\n    REGISTER_API(CreateStringPrintf);\n    REGISTER_API(FreeString);\n    REGISTER_API(StringPtrLen);\n    REGISTER_API(AutoMemory);\n    REGISTER_API(Replicate);\n    REGISTER_API(ReplicateVerbatim);\n    REGISTER_API(DeleteKey);\n    REGISTER_API(UnlinkKey);\n    REGISTER_API(StringSet);\n    REGISTER_API(StringDMA);\n    REGISTER_API(StringTruncate);\n    REGISTER_API(SetExpire);\n    REGISTER_API(GetExpire);\n    REGISTER_API(ZsetAdd);\n    REGISTER_API(ZsetIncrby);\n    REGISTER_API(ZsetScore);\n    REGISTER_API(ZsetRem);\n    REGISTER_API(ZsetRangeStop);\n    REGISTER_API(ZsetFirstInScoreRange);\n    REGISTER_API(ZsetLastInScoreRange);\n    REGISTER_API(ZsetFirstInLexRange);\n    REGISTER_API(ZsetLastInLexRange);\n    REGISTER_API(ZsetRangeCurrentElement);\n    REGISTER_API(ZsetRangeNext);\n    REGISTER_API(ZsetRangePrev);\n    REGISTER_API(ZsetRangeEndReached);\n    REGISTER_API(HashSet);\n    REGISTER_API(HashGet);\n    REGISTER_API(IsKeysPositionRequest);\n    REGISTER_API(KeyAtPos);\n    REGISTER_API(GetClientId);\n    REGISTER_API(GetContextFlags);\n    REGISTER_API(PoolAlloc);\n    REGISTER_API(CreateDataType);\n    REGISTER_API(ModuleTypeSetValue);\n    REGISTER_API(ModuleTypeGetType);\n    REGISTER_API(ModuleTypeGetValue);\n    REGISTER_API(SaveUnsigned);\n    REGISTER_API(LoadUnsigned);\n    REGISTER_API(SaveSigned);\n    REGISTER_API(LoadSigned);\n    REGISTER_API(SaveString);\n    REGISTER_API(SaveStringBuffer);\n    REGISTER_API(LoadString);\n    REGISTER_API(LoadStringBuffer);\n    REGISTER_API(SaveDouble);\n    REGISTER_API(LoadDouble);\n    REGISTER_API(SaveFloat);\n    REGISTER_API(LoadFloat);\n    REGISTER_API(EmitAOF);\n    REGISTER_API(Log);\n    REGISTER_API(LogIOError);\n    REGISTER_API(StringAppendBuffer);\n    REGISTER_API(RetainString);\n    REGISTER_API(StringCompare);\n    REGISTER_API(GetContextFromIO);\n    REGISTER_API(BlockClient);\n    REGISTER_API(UnblockClient);\n    REGISTER_API(IsBlockedReplyRequest);\n    REGISTER_API(IsBlockedTimeoutRequest);\n    REGISTER_API(GetBlockedClientPrivateData);\n    REGISTER_API(AbortBlock);\n    REGISTER_API(Milliseconds);\n    REGISTER_API(GetThreadSafeContext);\n    REGISTER_API(FreeThreadSafeContext);\n    REGISTER_API(ThreadSafeContextLock);\n    REGISTER_API(ThreadSafeContextUnlock);\n    REGISTER_API(DigestAddStringBuffer);\n    REGISTER_API(DigestAddLongLong);\n    REGISTER_API(DigestEndSequence);\n    REGISTER_API(SubscribeToKeyspaceEvents);\n    REGISTER_API(RegisterClusterMessageReceiver);\n    REGISTER_API(SendClusterMessage);\n    REGISTER_API(GetClusterNodeInfo);\n    REGISTER_API(GetClusterNodesList);\n    REGISTER_API(FreeClusterNodesList);\n    REGISTER_API(CreateTimer);\n    REGISTER_API(StopTimer);\n    REGISTER_API(GetTimerInfo);\n    REGISTER_API(GetMyClusterID);\n    REGISTER_API(GetClusterSize);\n    REGISTER_API(GetRandomBytes);\n    REGISTER_API(GetRandomHexChars);\n    REGISTER_API(BlockedClientDisconnected);\n    REGISTER_API(SetDisconnectCallback);\n    REGISTER_API(GetBlockedClientHandle);\n    REGISTER_API(SetClusterFlags);\n    REGISTER_API(CreateDict);\n    REGISTER_API(FreeDict);\n    REGISTER_API(DictSize);\n    REGISTER_API(DictSetC);\n    REGISTER_API(DictReplaceC);\n    REGISTER_API(DictSet);\n    REGISTER_API(DictReplace);\n    REGISTER_API(DictGetC);\n    REGISTER_API(DictGet);\n    REGISTER_API(DictDelC);\n    REGISTER_API(DictDel);\n    REGISTER_API(DictIteratorStartC);\n    REGISTER_API(DictIteratorStart);\n    REGISTER_API(DictIteratorStop);\n    REGISTER_API(DictIteratorReseekC);\n    REGISTER_API(DictIteratorReseek);\n    REGISTER_API(DictNextC);\n    REGISTER_API(DictPrevC);\n    REGISTER_API(DictNext);\n    REGISTER_API(DictPrev);\n    REGISTER_API(DictCompareC);\n    REGISTER_API(DictCompare);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.2-kgnq7exerr43idfj34trfbqmeiidhb7d/spack-src/deps/lua/src/luaconf.h": "/*\n** $Id: luaconf.h,v 1.82.1.7 2008/02/11 16:25:08 roberto Exp $\n** Configuration file for Lua\n** See Copyright Notice in lua.h\n*/\n\n\n#ifndef lconfig_h\n#define lconfig_h\n\n#include <limits.h>\n#include <stddef.h>\n\n\n/*\n** ==================================================================\n** Search for \"@@\" to find all configurable definitions.\n** ===================================================================\n*/\n\n\n/*\n@@ LUA_ANSI controls the use of non-ansi features.\n** CHANGE it (define it) if you want Lua to avoid the use of any\n** non-ansi feature or library.\n*/\n#if defined(__STRICT_ANSI__)\n#define LUA_ANSI\n#endif\n\n\n#if !defined(LUA_ANSI) && defined(_WIN32)\n#define LUA_WIN\n#endif\n\n#if defined(LUA_USE_LINUX)\n#define LUA_USE_POSIX\n#define LUA_USE_DLOPEN\t\t/* needs an extra library: -ldl */\n#define LUA_USE_READLINE\t/* needs some extra libraries */\n#endif\n\n#if defined(LUA_USE_MACOSX)\n#define LUA_USE_POSIX\n#define LUA_DL_DYLD\t\t/* does not need extra library */\n#endif\n\n\n\n/*\n@@ LUA_USE_POSIX includes all functionallity listed as X/Open System\n@* Interfaces Extension (XSI).\n** CHANGE it (define it) if your system is XSI compatible.\n*/\n#if defined(LUA_USE_POSIX)\n#define LUA_USE_MKSTEMP\n#define LUA_USE_ISATTY\n#define LUA_USE_POPEN\n#define LUA_USE_ULONGJMP\n#endif\n\n\n/*\n@@ LUA_PATH and LUA_CPATH are the names of the environment variables that\n@* Lua check to set its paths.\n@@ LUA_INIT is the name of the environment variable that Lua\n@* checks for initialization code.\n** CHANGE them if you want different names.\n*/\n#define LUA_PATH        \"LUA_PATH\"\n#define LUA_CPATH       \"LUA_CPATH\"\n#define LUA_INIT\t\"LUA_INIT\"\n\n\n/*\n@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for\n@* Lua libraries.\n@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for\n@* C libraries.\n** CHANGE them if your machine has a non-conventional directory\n** hierarchy or if you want to install your libraries in\n** non-conventional directories.\n*/\n#if defined(_WIN32)\n/*\n** In Windows, any exclamation mark ('!') in the path is replaced by the\n** path of the directory of the executable file of the current process.\n*/\n#define LUA_LDIR\t\"!\\\\lua\\\\\"\n#define LUA_CDIR\t\"!\\\\\"\n#define LUA_PATH_DEFAULT  \\\n\t\t\".\\\\?.lua;\"  LUA_LDIR\"?.lua;\"  LUA_LDIR\"?\\\\init.lua;\" \\\n\t\t             LUA_CDIR\"?.lua;\"  LUA_CDIR\"?\\\\init.lua\"\n#define LUA_CPATH_DEFAULT \\\n\t\".\\\\?.dll;\"  LUA_CDIR\"?.dll;\" LUA_CDIR\"loadall.dll\"\n\n#else\n#define LUA_ROOT\t\"/usr/local/\"\n#define LUA_LDIR\tLUA_ROOT \"share/lua/5.1/\"\n#define LUA_CDIR\tLUA_ROOT \"lib/lua/5.1/\"\n#define LUA_PATH_DEFAULT  \\\n\t\t\"./?.lua;\"  LUA_LDIR\"?.lua;\"  LUA_LDIR\"?/init.lua;\" \\\n\t\t            LUA_CDIR\"?.lua;\"  LUA_CDIR\"?/init.lua\"\n#define LUA_CPATH_DEFAULT \\\n\t\"./?.so;\"  LUA_CDIR\"?.so;\" LUA_CDIR\"loadall.so\"\n#endif\n\n\n/*\n@@ LUA_DIRSEP is the directory separator (for submodules).\n** CHANGE it if your machine does not use \"/\" as the directory separator\n** and is not Windows. (On Windows Lua automatically uses \"\\\".)\n*/\n#if defined(_WIN32)\n#define LUA_DIRSEP\t\"\\\\\"\n#else\n#define LUA_DIRSEP\t\"/\"\n#endif\n\n\n/*\n@@ LUA_PATHSEP is the character that separates templates in a path.\n@@ LUA_PATH_MARK is the string that marks the substitution points in a\n@* template.\n@@ LUA_EXECDIR in a Windows path is replaced by the executable's\n@* directory.\n@@ LUA_IGMARK is a mark to ignore all before it when bulding the\n@* luaopen_ function name.\n** CHANGE them if for some reason your system cannot use those\n** characters. (E.g., if one of those characters is a common character\n** in file/directory names.) Probably you do not need to change them.\n*/\n#define LUA_PATHSEP\t\";\"\n#define LUA_PATH_MARK\t\"?\"\n#define LUA_EXECDIR\t\"!\"\n#define LUA_IGMARK\t\"-\"\n\n\n/*\n@@ LUA_INTEGER is the integral type used by lua_pushinteger/lua_tointeger.\n** CHANGE that if ptrdiff_t is not adequate on your machine. (On most\n** machines, ptrdiff_t gives a good choice between int or long.)\n*/\n#define LUA_INTEGER\tptrdiff_t\n\n\n/*\n@@ LUA_API is a mark for all core API functions.\n@@ LUALIB_API is a mark for all standard library functions.\n** CHANGE them if you need to define those functions in some special way.\n** For instance, if you want to create one Windows DLL with the core and\n** the libraries, you may want to use the following definition (define\n** LUA_BUILD_AS_DLL to get it).\n*/\n#if defined(LUA_BUILD_AS_DLL)\n\n#if defined(LUA_CORE) || defined(LUA_LIB)\n#define LUA_API __declspec(dllexport)\n#else\n#define LUA_API __declspec(dllimport)\n#endif\n\n#else\n\n#define LUA_API\t\textern\n\n#endif\n\n/* more often than not the libs go together with the core */\n#define LUALIB_API\tLUA_API\n\n\n/*\n@@ LUAI_FUNC is a mark for all extern functions that are not to be\n@* exported to outside modules.\n@@ LUAI_DATA is a mark for all extern (const) variables that are not to\n@* be exported to outside modules.\n** CHANGE them if you need to mark them in some special way. Elf/gcc\n** (versions 3.2 and later) mark them as \"hidden\" to optimize access\n** when Lua is compiled as a shared library.\n*/\n#if defined(luaall_c)\n#define LUAI_FUNC\tstatic\n#define LUAI_DATA\t/* empty */\n\n#elif defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \\\n      defined(__ELF__)\n#define LUAI_FUNC\t__attribute__((visibility(\"hidden\"))) extern\n#define LUAI_DATA\tLUAI_FUNC\n\n#else\n#define LUAI_FUNC\textern\n#define LUAI_DATA\textern\n#endif\n\n\n\n/*\n@@ LUA_QL describes how error messages quote program elements.\n** CHANGE it if you want a different appearance.\n*/\n#define LUA_QL(x)\t\"'\" x \"'\"\n#define LUA_QS\t\tLUA_QL(\"%s\")\n\n\n/*\n@@ LUA_IDSIZE gives the maximum size for the description of the source\n@* of a function in debug information.\n** CHANGE it if you want a different size.\n*/\n#define LUA_IDSIZE\t60\n\n\n/*\n** {==================================================================\n** Stand-alone configuration\n** ===================================================================\n*/\n\n#if defined(lua_c) || defined(luaall_c)\n\n/*\n@@ lua_stdin_is_tty detects whether the standard input is a 'tty' (that\n@* is, whether we're running lua interactively).\n** CHANGE it if you have a better definition for non-POSIX/non-Windows\n** systems.\n*/\n#if defined(LUA_USE_ISATTY)\n#include <unistd.h>\n#define lua_stdin_is_tty()\tisatty(0)\n#elif defined(LUA_WIN)\n#include <io.h>\n#include <stdio.h>\n#define lua_stdin_is_tty()\t_isatty(_fileno(stdin))\n#else\n#define lua_stdin_is_tty()\t1  /* assume stdin is a tty */\n#endif\n\n\n/*\n@@ LUA_PROMPT is the default prompt used by stand-alone Lua.\n@@ LUA_PROMPT2 is the default continuation prompt used by stand-alone Lua.\n** CHANGE them if you want different prompts. (You can also change the\n** prompts dynamically, assigning to globals _PROMPT/_PROMPT2.)\n*/\n#define LUA_PROMPT\t\t\"> \"\n#define LUA_PROMPT2\t\t\">> \"\n\n\n/*\n@@ LUA_PROGNAME is the default name for the stand-alone Lua program.\n** CHANGE it if your stand-alone interpreter has a different name and\n** your system is not able to detect that name automatically.\n*/\n#define LUA_PROGNAME\t\t\"lua\"\n\n\n/*\n@@ LUA_MAXINPUT is the maximum length for an input line in the\n@* stand-alone interpreter.\n** CHANGE it if you need longer lines.\n*/\n#define LUA_MAXINPUT\t512\n\n\n/*\n@@ lua_readline defines how to show a prompt and then read a line from\n@* the standard input.\n@@ lua_saveline defines how to \"save\" a read line in a \"history\".\n@@ lua_freeline defines how to free a line read by lua_readline.\n** CHANGE them if you want to improve this functionality (e.g., by using\n** GNU readline and history facilities).\n*/\n#if defined(LUA_USE_READLINE)\n#include <stdio.h>\n#include <readline/readline.h>\n#include <readline/history.h>\n#define lua_readline(L,b,p)\t((void)L, ((b)=readline(p)) != NULL)\n#define lua_saveline(L,idx) \\\n\tif (lua_strlen(L,idx) > 0)  /* non-empty line? */ \\\n\t  add_history(lua_tostring(L, idx));  /* add it to history */\n#define lua_freeline(L,b)\t((void)L, free(b))\n#else\n#define lua_readline(L,b,p)\t\\\n\t((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \\\n\tfgets(b, LUA_MAXINPUT, stdin) != NULL)  /* get line */\n#define lua_saveline(L,idx)\t{ (void)L; (void)idx; }\n#define lua_freeline(L,b)\t{ (void)L; (void)b; }\n#endif\n\n#endif\n\n/* }================================================================== */\n\n\n/*\n@@ LUAI_GCPAUSE defines the default pause between garbage-collector cycles\n@* as a percentage.\n** CHANGE it if you want the GC to run faster or slower (higher values\n** mean larger pauses which mean slower collection.) You can also change\n** this value dynamically.\n*/\n#define LUAI_GCPAUSE\t200  /* 200% (wait memory to double before next GC) */\n\n\n/*\n@@ LUAI_GCMUL defines the default speed of garbage collection relative to\n@* memory allocation as a percentage.\n** CHANGE it if you want to change the granularity of the garbage\n** collection. (Higher values mean coarser collections. 0 represents\n** infinity, where each step performs a full collection.) You can also\n** change this value dynamically.\n*/\n#define LUAI_GCMUL\t200 /* GC runs 'twice the speed' of memory allocation */\n\n\n\n/*\n@@ LUA_COMPAT_GETN controls compatibility with old getn behavior.\n** CHANGE it (define it) if you want exact compatibility with the\n** behavior of setn/getn in Lua 5.0.\n*/\n#undef LUA_COMPAT_GETN\n\n/*\n@@ LUA_COMPAT_LOADLIB controls compatibility about global loadlib.\n** CHANGE it to undefined as soon as you do not need a global 'loadlib'\n** function (the function is still available as 'package.loadlib').\n*/\n#undef LUA_COMPAT_LOADLIB\n\n/*\n@@ LUA_COMPAT_VARARG controls compatibility with old vararg feature.\n** CHANGE it to undefined as soon as your programs use only '...' to\n** access vararg parameters (instead of the old 'arg' table).\n*/\n#define LUA_COMPAT_VARARG\n\n/*\n@@ LUA_COMPAT_MOD controls compatibility with old math.mod function.\n** CHANGE it to undefined as soon as your programs use 'math.fmod' or\n** the new '%' operator instead of 'math.mod'.\n*/\n#define LUA_COMPAT_MOD\n\n/*\n@@ LUA_COMPAT_LSTR controls compatibility with old long string nesting\n@* facility.\n** CHANGE it to 2 if you want the old behaviour, or undefine it to turn\n** off the advisory error when nesting [[...]].\n*/\n#define LUA_COMPAT_LSTR\t\t1\n\n/*\n@@ LUA_COMPAT_GFIND controls compatibility with old 'string.gfind' name.\n** CHANGE it to undefined as soon as you rename 'string.gfind' to\n** 'string.gmatch'.\n*/\n#define LUA_COMPAT_GFIND\n\n/*\n@@ LUA_COMPAT_OPENLIB controls compatibility with old 'luaL_openlib'\n@* behavior.\n** CHANGE it to undefined as soon as you replace to 'luaL_register'\n** your uses of 'luaL_openlib'\n*/\n#define LUA_COMPAT_OPENLIB\n\n\n\n/*\n@@ luai_apicheck is the assert macro used by the Lua-C API.\n** CHANGE luai_apicheck if you want Lua to perform some checks in the\n** parameters it gets from API calls. This may slow down the interpreter\n** a bit, but may be quite useful when debugging C code that interfaces\n** with Lua. A useful redefinition is to use assert.h.\n*/\n#if defined(LUA_USE_APICHECK)\n#include <assert.h>\n#define luai_apicheck(L,o)\t{ (void)L; assert(o); }\n#else\n#define luai_apicheck(L,o)\t{ (void)L; }\n#endif\n\n\n/*\n@@ LUAI_BITSINT defines the number of bits in an int.\n** CHANGE here if Lua cannot automatically detect the number of bits of\n** your machine. Probably you do not need to change this.\n*/\n/* avoid overflows in comparison */\n#if INT_MAX-20 < 32760\n#define LUAI_BITSINT\t16\n#elif INT_MAX > 2147483640L\n/* int has at least 32 bits */\n#define LUAI_BITSINT\t32\n#else\n#error \"you must define LUA_BITSINT with number of bits in an integer\"\n#endif\n\n\n/*\n@@ LUAI_UINT32 is an unsigned integer with at least 32 bits.\n@@ LUAI_INT32 is an signed integer with at least 32 bits.\n@@ LUAI_UMEM is an unsigned integer big enough to count the total\n@* memory used by Lua.\n@@ LUAI_MEM is a signed integer big enough to count the total memory\n@* used by Lua.\n** CHANGE here if for some weird reason the default definitions are not\n** good enough for your machine. (The definitions in the 'else'\n** part always works, but may waste space on machines with 64-bit\n** longs.) Probably you do not need to change this.\n*/\n#if LUAI_BITSINT >= 32\n#define LUAI_UINT32\tunsigned int\n#define LUAI_INT32\tint\n#define LUAI_MAXINT32\tINT_MAX\n#define LUAI_UMEM\tsize_t\n#define LUAI_MEM\tptrdiff_t\n#else\n/* 16-bit ints */\n#define LUAI_UINT32\tunsigned long\n#define LUAI_INT32\tlong\n#define LUAI_MAXINT32\tLONG_MAX\n#define LUAI_UMEM\tunsigned long\n#define LUAI_MEM\tlong\n#endif\n\n\n/*\n@@ LUAI_MAXCALLS limits the number of nested calls.\n** CHANGE it if you need really deep recursive calls. This limit is\n** arbitrary; its only purpose is to stop infinite recursion before\n** exhausting memory.\n*/\n#define LUAI_MAXCALLS\t20000\n\n\n/*\n@@ LUAI_MAXCSTACK limits the number of Lua stack slots that a C function\n@* can use.\n** CHANGE it if you need lots of (Lua) stack space for your C\n** functions. This limit is arbitrary; its only purpose is to stop C\n** functions to consume unlimited stack space. (must be smaller than\n** -LUA_REGISTRYINDEX)\n*/\n#define LUAI_MAXCSTACK\t8000\n\n\n\n/*\n** {==================================================================\n** CHANGE (to smaller values) the following definitions if your system\n** has a small C stack. (Or you may want to change them to larger\n** values if your system has a large C stack and these limits are\n** too rigid for you.) Some of these constants control the size of\n** stack-allocated arrays used by the compiler or the interpreter, while\n** others limit the maximum number of recursive calls that the compiler\n** or the interpreter can perform. Values too large may cause a C stack\n** overflow for some forms of deep constructs.\n** ===================================================================\n*/\n\n\n/*\n@@ LUAI_MAXCCALLS is the maximum depth for nested C calls (short) and\n@* syntactical nested non-terminals in a program.\n*/\n#define LUAI_MAXCCALLS\t\t200\n\n\n/*\n@@ LUAI_MAXVARS is the maximum number of local variables per function\n@* (must be smaller than 250).\n*/\n#define LUAI_MAXVARS\t\t200\n\n\n/*\n@@ LUAI_MAXUPVALUES is the maximum number of upvalues per function\n@* (must be smaller than 250).\n*/\n#define LUAI_MAXUPVALUES\t60\n\n\n/*\n@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.\n*/\n#define LUAL_BUFFERSIZE\t\tBUFSIZ\n\n/* }================================================================== */\n\n\n\n\n/*\n** {==================================================================\n@@ LUA_NUMBER is the type of numbers in Lua.\n** CHANGE the following definitions only if you want to build Lua\n** with a number type different from double. You may also need to\n** change lua_number2int & lua_number2integer.\n** ===================================================================\n*/\n\n#define LUA_NUMBER_DOUBLE\n#define LUA_NUMBER\tdouble\n\n/*\n@@ LUAI_UACNUMBER is the result of an 'usual argument conversion'\n@* over a number.\n*/\n#define LUAI_UACNUMBER\tdouble\n\n\n/*\n@@ LUA_NUMBER_SCAN is the format for reading numbers.\n@@ LUA_NUMBER_FMT is the format for writing numbers.\n@@ lua_number2str converts a number to a string.\n@@ LUAI_MAXNUMBER2STR is maximum size of previous conversion.\n@@ lua_str2number converts a string to a number.\n*/\n#define LUA_NUMBER_SCAN\t\t\"%lf\"\n#define LUA_NUMBER_FMT\t\t\"%.14g\"\n#define lua_number2str(s,n)\tsprintf((s), LUA_NUMBER_FMT, (n))\n#define LUAI_MAXNUMBER2STR\t32 /* 16 digits, sign, point, and \\0 */\n#define lua_str2number(s,p)\tstrtod((s), (p))\n\n\n/*\n@@ The luai_num* macros define the primitive operations over numbers.\n*/\n#if defined(LUA_CORE)\n#include <math.h>\n#define luai_numadd(a,b)\t((a)+(b))\n#define luai_numsub(a,b)\t((a)-(b))\n#define luai_nummul(a,b)\t((a)*(b))\n#define luai_numdiv(a,b)\t((a)/(b))\n#define luai_nummod(a,b)\t((a) - floor((a)/(b))*(b))\n#define luai_numpow(a,b)\t(pow(a,b))\n#define luai_numunm(a)\t\t(-(a))\n#define luai_numeq(a,b)\t\t((a)==(b))\n#define luai_numlt(a,b)\t\t((a)<(b))\n#define luai_numle(a,b)\t\t((a)<=(b))\n#define luai_numisnan(a)\t(!luai_numeq((a), (a)))\n#endif\n\n\n/*\n@@ lua_number2int is a macro to convert lua_Number to int.\n@@ lua_number2integer is a macro to convert lua_Number to lua_Integer.\n** CHANGE them if you know a faster way to convert a lua_Number to\n** int (with any rounding method and without throwing errors) in your\n** system. In Pentium machines, a naive typecast from double to int\n** in C is extremely slow, so any alternative is worth trying.\n*/\n\n/* On a Pentium, resort to a trick */\n#if defined(LUA_NUMBER_DOUBLE) && !defined(LUA_ANSI) && !defined(__SSE2__) && \\\n    (defined(__i386) || defined (_M_IX86) || defined(__i386__))\n\n/* On a Microsoft compiler, use assembler */\n#if defined(_MSC_VER)\n\n#define lua_number2int(i,d)   __asm fld d   __asm fistp i\n#define lua_number2integer(i,n)\t\tlua_number2int(i, n)\n\n/* the next trick should work on any Pentium, but sometimes clashes\n   with a DirectX idiosyncrasy */\n#else\n\nunion luai_Cast { double l_d; long l_l; };\n#define lua_number2int(i,d) \\\n  { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }\n#define lua_number2integer(i,n)\t\tlua_number2int(i, n)\n\n#endif\n\n\n/* this option always works, but may be slow */\n#else\n#define lua_number2int(i,d)\t((i)=(int)(d))\n#define lua_number2integer(i,d)\t((i)=(lua_Integer)(d))\n\n#endif\n\n/* }================================================================== */\n\n\n/*\n@@ LUAI_USER_ALIGNMENT_T is a type that requires maximum alignment.\n** CHANGE it if your system requires alignments larger than double. (For\n** instance, if your system supports long doubles and they must be\n** aligned in 16-byte boundaries, then you should add long double in the\n** union.) Probably you do not need to change this.\n*/\n#define LUAI_USER_ALIGNMENT_T\tunion { double u; void *s; long l; }\n\n\n/*\n@@ LUAI_THROW/LUAI_TRY define how Lua does exception handling.\n** CHANGE them if you prefer to use longjmp/setjmp even with C++\n** or if want/don't to use _longjmp/_setjmp instead of regular\n** longjmp/setjmp. By default, Lua handles errors with exceptions when\n** compiling as C++ code, with _longjmp/_setjmp when asked to use them,\n** and with longjmp/setjmp otherwise.\n*/\n#if defined(__cplusplus)\n/* C++ exceptions */\n#define LUAI_THROW(L,c)\tthrow(c)\n#define LUAI_TRY(L,c,a)\ttry { a } catch(...) \\\n\t{ if ((c)->status == 0) (c)->status = -1; }\n#define luai_jmpbuf\tint  /* dummy variable */\n\n#elif defined(LUA_USE_ULONGJMP)\n/* in Unix, try _longjmp/_setjmp (more efficient) */\n#define LUAI_THROW(L,c)\t_longjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\tif (_setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\tjmp_buf\n\n#else\n/* default handling with long jumps */\n#define LUAI_THROW(L,c)\tlongjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\tif (setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\tjmp_buf\n\n#endif\n\n\n/*\n@@ LUA_MAXCAPTURES is the maximum number of captures that a pattern\n@* can do during pattern-matching.\n** CHANGE it if you need more captures. This limit is arbitrary.\n*/\n#define LUA_MAXCAPTURES\t\t32\n\n\n/*\n@@ lua_tmpnam is the function that the OS library uses to create a\n@* temporary name.\n@@ LUA_TMPNAMBUFSIZE is the maximum size of a name created by lua_tmpnam.\n** CHANGE them if you have an alternative to tmpnam (which is considered\n** insecure) or if you want the original tmpnam anyway.  By default, Lua\n** uses tmpnam except when POSIX is available, where it uses mkstemp.\n*/\n#if defined(loslib_c) || defined(luaall_c)\n\n#if defined(LUA_USE_MKSTEMP)\n#include <unistd.h>\n#define LUA_TMPNAMBUFSIZE\t32\n#define lua_tmpnam(b,e)\t{ \\\n\tstrcpy(b, \"/tmp/lua_XXXXXX\"); \\\n\te = mkstemp(b); \\\n\tif (e != -1) close(e); \\\n\te = (e == -1); }\n\n#else\n#define LUA_TMPNAMBUFSIZE\tL_tmpnam\n#define lua_tmpnam(b,e)\t\t{ e = (tmpnam(b) == NULL); }\n#endif\n\n#endif\n\n\n/*\n@@ lua_popen spawns a new process connected to the current one through\n@* the file streams.\n** CHANGE it if you have a way to implement it in your system.\n*/\n#if defined(LUA_USE_POPEN)\n\n#define lua_popen(L,c,m)\t((void)L, fflush(NULL), popen(c,m))\n#define lua_pclose(L,file)\t((void)L, (pclose(file) != -1))\n\n#elif defined(LUA_WIN)\n\n#define lua_popen(L,c,m)\t((void)L, _popen(c,m))\n#define lua_pclose(L,file)\t((void)L, (_pclose(file) != -1))\n\n#else\n\n#define lua_popen(L,c,m)\t((void)((void)c, m),  \\\n\t\tluaL_error(L, LUA_QL(\"popen\") \" not supported\"), (FILE*)0)\n#define lua_pclose(L,file)\t\t((void)((void)L, file), 0)\n\n#endif\n\n/*\n@@ LUA_DL_* define which dynamic-library system Lua should use.\n** CHANGE here if Lua has problems choosing the appropriate\n** dynamic-library system for your platform (either Windows' DLL, Mac's\n** dyld, or Unix's dlopen). If your system is some kind of Unix, there\n** is a good chance that it has dlopen, so LUA_DL_DLOPEN will work for\n** it.  To use dlopen you also need to adapt the src/Makefile (probably\n** adding -ldl to the linker options), so Lua does not select it\n** automatically.  (When you change the makefile to add -ldl, you must\n** also add -DLUA_USE_DLOPEN.)\n** If you do not want any kind of dynamic library, undefine all these\n** options.\n** By default, _WIN32 gets LUA_DL_DLL and MAC OS X gets LUA_DL_DYLD.\n*/\n#if defined(LUA_USE_DLOPEN)\n#define LUA_DL_DLOPEN\n#endif\n\n#if defined(LUA_WIN)\n#define LUA_DL_DLL\n#endif\n\n\n/*\n@@ LUAI_EXTRASPACE allows you to add user-specific data in a lua_State\n@* (the data goes just *before* the lua_State pointer).\n** CHANGE (define) this if you really need that. This value must be\n** a multiple of the maximum alignment required for your machine.\n*/\n#define LUAI_EXTRASPACE\t\t0\n\n\n/*\n@@ luai_userstate* allow user-specific actions on threads.\n** CHANGE them if you defined LUAI_EXTRASPACE and need to do something\n** extra when a thread is created/deleted/resumed/yielded.\n*/\n#define luai_userstateopen(L)\t\t((void)L)\n#define luai_userstateclose(L)\t\t((void)L)\n#define luai_userstatethread(L,L1)\t((void)L)\n#define luai_userstatefree(L)\t\t((void)L)\n#define luai_userstateresume(L,n)\t((void)L)\n#define luai_userstateyield(L,n)\t((void)L)\n\n\n/*\n@@ LUA_INTFRMLEN is the length modifier for integer conversions\n@* in 'string.format'.\n@@ LUA_INTFRM_T is the integer type correspoding to the previous length\n@* modifier.\n** CHANGE them if your system supports long long or does not support long.\n*/\n\n#if defined(LUA_USELONGLONG)\n\n#define LUA_INTFRMLEN\t\t\"ll\"\n#define LUA_INTFRM_T\t\tlong long\n\n#else\n\n#define LUA_INTFRMLEN\t\t\"l\"\n#define LUA_INTFRM_T\t\tlong\n\n#endif\n\n\n\n/* =================================================================== */\n\n/*\n** Local configuration. You can use this space to add your redefinitions\n** without modifying the main part of the file.\n*/\n\n\n\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.2-kgnq7exerr43idfj34trfbqmeiidhb7d/spack-src/deps/lua/src/loadlib.c": "/*\n** $Id: loadlib.c,v 1.52.1.4 2009/09/09 13:17:16 roberto Exp $\n** Dynamic library loader for Lua\n** See Copyright Notice in lua.h\n**\n** This module contains an implementation of loadlib for Unix systems\n** that have dlfcn, an implementation for Darwin (Mac OS X), an\n** implementation for Windows, and a stub for other systems.\n*/\n\n\n#include <stdlib.h>\n#include <string.h>\n\n\n#define loadlib_c\n#define LUA_LIB\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/* prefix for open functions in C libraries */\n#define LUA_POF\t\t\"luaopen_\"\n\n/* separator for open functions in C libraries */\n#define LUA_OFSEP\t\"_\"\n\n\n#define LIBPREFIX\t\"LOADLIB: \"\n\n#define POF\t\tLUA_POF\n#define LIB_FAIL\t\"open\"\n\n\n/* error codes for ll_loadfunc */\n#define ERRLIB\t\t1\n#define ERRFUNC\t\t2\n\n#define setprogdir(L)\t\t((void)0)\n\n\nstatic void ll_unloadlib (void *lib);\nstatic void *ll_load (lua_State *L, const char *path);\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym);\n\n\n\n#if defined(LUA_DL_DLOPEN)\n/*\n** {========================================================================\n** This is an implementation of loadlib based on the dlfcn interface.\n** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,\n** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least\n** as an emulation layer on top of native functions.\n** =========================================================================\n*/\n\n#include <dlfcn.h>\n\nstatic void ll_unloadlib (void *lib) {\n  dlclose(lib);\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path) {\n  void *lib = dlopen(path, RTLD_NOW);\n  if (lib == NULL) lua_pushstring(L, dlerror());\n  return lib;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);\n  if (f == NULL) lua_pushstring(L, dlerror());\n  return f;\n}\n\n/* }====================================================== */\n\n\n\n#elif defined(LUA_DL_DLL)\n/*\n** {======================================================================\n** This is an implementation of loadlib for Windows using native functions.\n** =======================================================================\n*/\n\n#include <windows.h>\n\n\n#undef setprogdir\n\nstatic void setprogdir (lua_State *L) {\n  char buff[MAX_PATH + 1];\n  char *lb;\n  DWORD nsize = sizeof(buff)/sizeof(char);\n  DWORD n = GetModuleFileNameA(NULL, buff, nsize);\n  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\\\')) == NULL)\n    luaL_error(L, \"unable to get ModuleFileName\");\n  else {\n    *lb = '\\0';\n    luaL_gsub(L, lua_tostring(L, -1), LUA_EXECDIR, buff);\n    lua_remove(L, -2);  /* remove original string */\n  }\n}\n\n\nstatic void pusherror (lua_State *L) {\n  int error = GetLastError();\n  char buffer[128];\n  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, buffer, sizeof(buffer), NULL))\n    lua_pushstring(L, buffer);\n  else\n    lua_pushfstring(L, \"system error %d\\n\", error);\n}\n\nstatic void ll_unloadlib (void *lib) {\n  FreeLibrary((HINSTANCE)lib);\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path) {\n  HINSTANCE lib = LoadLibraryA(path);\n  if (lib == NULL) pusherror(L);\n  return lib;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)GetProcAddress((HINSTANCE)lib, sym);\n  if (f == NULL) pusherror(L);\n  return f;\n}\n\n/* }====================================================== */\n\n\n\n#elif defined(LUA_DL_DYLD)\n/*\n** {======================================================================\n** Native Mac OS X / Darwin Implementation\n** =======================================================================\n*/\n\n#include <mach-o/dyld.h>\n\n\n/* Mac appends a `_' before C function names */\n#undef POF\n#define POF\t\"_\" LUA_POF\n\n\nstatic void pusherror (lua_State *L) {\n  const char *err_str;\n  const char *err_file;\n  NSLinkEditErrors err;\n  int err_num;\n  NSLinkEditError(&err, &err_num, &err_file, &err_str);\n  lua_pushstring(L, err_str);\n}\n\n\nstatic const char *errorfromcode (NSObjectFileImageReturnCode ret) {\n  switch (ret) {\n    case NSObjectFileImageInappropriateFile:\n      return \"file is not a bundle\";\n    case NSObjectFileImageArch:\n      return \"library is for wrong CPU type\";\n    case NSObjectFileImageFormat:\n      return \"bad format\";\n    case NSObjectFileImageAccess:\n      return \"cannot access file\";\n    case NSObjectFileImageFailure:\n    default:\n      return \"unable to load library\";\n  }\n}\n\n\nstatic void ll_unloadlib (void *lib) {\n  NSUnLinkModule((NSModule)lib, NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES);\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path) {\n  NSObjectFileImage img;\n  NSObjectFileImageReturnCode ret;\n  /* this would be a rare case, but prevents crashing if it happens */\n  if(!_dyld_present()) {\n    lua_pushliteral(L, \"dyld not present\");\n    return NULL;\n  }\n  ret = NSCreateObjectFileImageFromFile(path, &img);\n  if (ret == NSObjectFileImageSuccess) {\n    NSModule mod = NSLinkModule(img, path, NSLINKMODULE_OPTION_PRIVATE |\n                       NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n    NSDestroyObjectFileImage(img);\n    if (mod == NULL) pusherror(L);\n    return mod;\n  }\n  lua_pushstring(L, errorfromcode(ret));\n  return NULL;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  NSSymbol nss = NSLookupSymbolInModule((NSModule)lib, sym);\n  if (nss == NULL) {\n    lua_pushfstring(L, \"symbol \" LUA_QS \" not found\", sym);\n    return NULL;\n  }\n  return (lua_CFunction)NSAddressOfSymbol(nss);\n}\n\n/* }====================================================== */\n\n\n\n#else\n/*\n** {======================================================\n** Fallback for other systems\n** =======================================================\n*/\n\n#undef LIB_FAIL\n#define LIB_FAIL\t\"absent\"\n\n\n#define DLMSG\t\"dynamic libraries not enabled; check your Lua installation\"\n\n\nstatic void ll_unloadlib (void *lib) {\n  (void)lib;  /* to avoid warnings */\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path) {\n  (void)path;  /* to avoid warnings */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  (void)lib; (void)sym;  /* to avoid warnings */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n/* }====================================================== */\n#endif\n\n\n\nstatic void **ll_register (lua_State *L, const char *path) {\n  void **plib;\n  lua_pushfstring(L, \"%s%s\", LIBPREFIX, path);\n  lua_gettable(L, LUA_REGISTRYINDEX);  /* check library in registry? */\n  if (!lua_isnil(L, -1))  /* is there an entry? */\n    plib = (void **)lua_touserdata(L, -1);\n  else {  /* no entry yet; create one */\n    lua_pop(L, 1);\n    plib = (void **)lua_newuserdata(L, sizeof(const void *));\n    *plib = NULL;\n    luaL_getmetatable(L, \"_LOADLIB\");\n    lua_setmetatable(L, -2);\n    lua_pushfstring(L, \"%s%s\", LIBPREFIX, path);\n    lua_pushvalue(L, -2);\n    lua_settable(L, LUA_REGISTRYINDEX);\n  }\n  return plib;\n}\n\n\n/*\n** __gc tag method: calls library's `ll_unloadlib' function with the lib\n** handle\n*/\nstatic int gctm (lua_State *L) {\n  void **lib = (void **)luaL_checkudata(L, 1, \"_LOADLIB\");\n  if (*lib) ll_unloadlib(*lib);\n  *lib = NULL;  /* mark library as closed */\n  return 0;\n}\n\n\nstatic int ll_loadfunc (lua_State *L, const char *path, const char *sym) {\n  void **reg = ll_register(L, path);\n  if (*reg == NULL) *reg = ll_load(L, path);\n  if (*reg == NULL)\n    return ERRLIB;  /* unable to load library */\n  else {\n    lua_CFunction f = ll_sym(L, *reg, sym);\n    if (f == NULL)\n      return ERRFUNC;  /* unable to find function */\n    lua_pushcfunction(L, f);\n    return 0;  /* return function */\n  }\n}\n\n\nstatic int ll_loadlib (lua_State *L) {\n  const char *path = luaL_checkstring(L, 1);\n  const char *init = luaL_checkstring(L, 2);\n  int stat = ll_loadfunc(L, path, init);\n  if (stat == 0)  /* no errors? */\n    return 1;  /* return the loaded function */\n  else {  /* error; error message is on stack top */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : \"init\");\n    return 3;  /* return nil, error message, and where */\n  }\n}\n\n\n\n/*\n** {======================================================\n** 'require' function\n** =======================================================\n*/\n\n\nstatic int readable (const char *filename) {\n  FILE *f = fopen(filename, \"r\");  /* try to open file */\n  if (f == NULL) return 0;  /* open failed */\n  fclose(f);\n  return 1;\n}\n\n\nstatic const char *pushnexttemplate (lua_State *L, const char *path) {\n  const char *l;\n  while (*path == *LUA_PATHSEP) path++;  /* skip separators */\n  if (*path == '\\0') return NULL;  /* no more templates */\n  l = strchr(path, *LUA_PATHSEP);  /* find next separator */\n  if (l == NULL) l = path + strlen(path);\n  lua_pushlstring(L, path, l - path);  /* template */\n  return l;\n}\n\n\nstatic const char *findfile (lua_State *L, const char *name,\n                                           const char *pname) {\n  const char *path;\n  name = luaL_gsub(L, name, \".\", LUA_DIRSEP);\n  lua_getfield(L, LUA_ENVIRONINDEX, pname);\n  path = lua_tostring(L, -1);\n  if (path == NULL)\n    luaL_error(L, LUA_QL(\"package.%s\") \" must be a string\", pname);\n  lua_pushliteral(L, \"\");  /* error accumulator */\n  while ((path = pushnexttemplate(L, path)) != NULL) {\n    const char *filename;\n    filename = luaL_gsub(L, lua_tostring(L, -1), LUA_PATH_MARK, name);\n    lua_remove(L, -2);  /* remove path template */\n    if (readable(filename))  /* does file exist and is readable? */\n      return filename;  /* return that file name */\n    lua_pushfstring(L, \"\\n\\tno file \" LUA_QS, filename);\n    lua_remove(L, -2);  /* remove file name */\n    lua_concat(L, 2);  /* add entry to possible error message */\n  }\n  return NULL;  /* not found */\n}\n\n\nstatic void loaderror (lua_State *L, const char *filename) {\n  luaL_error(L, \"error loading module \" LUA_QS \" from file \" LUA_QS \":\\n\\t%s\",\n                lua_tostring(L, 1), filename, lua_tostring(L, -1));\n}\n\n\nstatic int loader_Lua (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  filename = findfile(L, name, \"path\");\n  if (filename == NULL) return 1;  /* library not found in this path */\n  if (luaL_loadfile(L, filename) != 0)\n    loaderror(L, filename);\n  return 1;  /* library loaded successfully */\n}\n\n\nstatic const char *mkfuncname (lua_State *L, const char *modname) {\n  const char *funcname;\n  const char *mark = strchr(modname, *LUA_IGMARK);\n  if (mark) modname = mark + 1;\n  funcname = luaL_gsub(L, modname, \".\", LUA_OFSEP);\n  funcname = lua_pushfstring(L, POF\"%s\", funcname);\n  lua_remove(L, -2);  /* remove 'gsub' result */\n  return funcname;\n}\n\n\nstatic int loader_C (lua_State *L) {\n  const char *funcname;\n  const char *name = luaL_checkstring(L, 1);\n  const char *filename = findfile(L, name, \"cpath\");\n  if (filename == NULL) return 1;  /* library not found in this path */\n  funcname = mkfuncname(L, name);\n  if (ll_loadfunc(L, filename, funcname) != 0)\n    loaderror(L, filename);\n  return 1;  /* library loaded successfully */\n}\n\n\nstatic int loader_Croot (lua_State *L) {\n  const char *funcname;\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  const char *p = strchr(name, '.');\n  int stat;\n  if (p == NULL) return 0;  /* is root */\n  lua_pushlstring(L, name, p - name);\n  filename = findfile(L, lua_tostring(L, -1), \"cpath\");\n  if (filename == NULL) return 1;  /* root not found */\n  funcname = mkfuncname(L, name);\n  if ((stat = ll_loadfunc(L, filename, funcname)) != 0) {\n    if (stat != ERRFUNC) loaderror(L, filename);  /* real error */\n    lua_pushfstring(L, \"\\n\\tno module \" LUA_QS \" in file \" LUA_QS,\n                       name, filename);\n    return 1;  /* function not found */\n  }\n  return 1;\n}\n\n\nstatic int loader_preload (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_getfield(L, LUA_ENVIRONINDEX, \"preload\");\n  if (!lua_istable(L, -1))\n    luaL_error(L, LUA_QL(\"package.preload\") \" must be a table\");\n  lua_getfield(L, -1, name);\n  if (lua_isnil(L, -1))  /* not found? */\n    lua_pushfstring(L, \"\\n\\tno field package.preload['%s']\", name);\n  return 1;\n}\n\n\nstatic const int sentinel_ = 0;\n#define sentinel\t((void *)&sentinel_)\n\n\nstatic int ll_require (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  int i;\n  lua_settop(L, 1);  /* _LOADED table will be at index 2 */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, 2, name);\n  if (lua_toboolean(L, -1)) {  /* is it there? */\n    if (lua_touserdata(L, -1) == sentinel)  /* check loops */\n      luaL_error(L, \"loop or previous error loading module \" LUA_QS, name);\n    return 1;  /* package is already loaded */\n  }\n  /* else must load it; iterate over available loaders */\n  lua_getfield(L, LUA_ENVIRONINDEX, \"loaders\");\n  if (!lua_istable(L, -1))\n    luaL_error(L, LUA_QL(\"package.loaders\") \" must be a table\");\n  lua_pushliteral(L, \"\");  /* error message accumulator */\n  for (i=1; ; i++) {\n    lua_rawgeti(L, -2, i);  /* get a loader */\n    if (lua_isnil(L, -1))\n      luaL_error(L, \"module \" LUA_QS \" not found:%s\",\n                    name, lua_tostring(L, -2));\n    lua_pushstring(L, name);\n    lua_call(L, 1, 1);  /* call it */\n    if (lua_isfunction(L, -1))  /* did it find module? */\n      break;  /* module loaded successfully */\n    else if (lua_isstring(L, -1))  /* loader returned error message? */\n      lua_concat(L, 2);  /* accumulate it */\n    else\n      lua_pop(L, 1);\n  }\n  lua_pushlightuserdata(L, sentinel);\n  lua_setfield(L, 2, name);  /* _LOADED[name] = sentinel */\n  lua_pushstring(L, name);  /* pass name as argument to module */\n  lua_call(L, 1, 1);  /* run loaded module */\n  if (!lua_isnil(L, -1))  /* non-nil return? */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */\n  lua_getfield(L, 2, name);\n  if (lua_touserdata(L, -1) == sentinel) {   /* module did not set a value? */\n    lua_pushboolean(L, 1);  /* use true as result */\n    lua_pushvalue(L, -1);  /* extra copy to be returned */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = true */\n  }\n  return 1;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** 'module' function\n** =======================================================\n*/\n  \n\nstatic void setfenv (lua_State *L) {\n  lua_Debug ar;\n  if (lua_getstack(L, 1, &ar) == 0 ||\n      lua_getinfo(L, \"f\", &ar) == 0 ||  /* get calling function */\n      lua_iscfunction(L, -1))\n    luaL_error(L, LUA_QL(\"module\") \" not called from a Lua function\");\n  lua_pushvalue(L, -2);\n  lua_setfenv(L, -2);\n  lua_pop(L, 1);\n}\n\n\nstatic void dooptions (lua_State *L, int n) {\n  int i;\n  for (i = 2; i <= n; i++) {\n    lua_pushvalue(L, i);  /* get option (a function) */\n    lua_pushvalue(L, -2);  /* module */\n    lua_call(L, 1, 0);\n  }\n}\n\n\nstatic void modinit (lua_State *L, const char *modname) {\n  const char *dot;\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -2, \"_M\");  /* module._M = module */\n  lua_pushstring(L, modname);\n  lua_setfield(L, -2, \"_NAME\");\n  dot = strrchr(modname, '.');  /* look for last dot in module name */\n  if (dot == NULL) dot = modname;\n  else dot++;\n  /* set _PACKAGE as package name (full module name minus last part) */\n  lua_pushlstring(L, modname, dot - modname);\n  lua_setfield(L, -2, \"_PACKAGE\");\n}\n\n\nstatic int ll_module (lua_State *L) {\n  const char *modname = luaL_checkstring(L, 1);\n  int loaded = lua_gettop(L) + 1;  /* index of _LOADED table */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, loaded, modname);  /* get _LOADED[modname] */\n  if (!lua_istable(L, -1)) {  /* not found? */\n    lua_pop(L, 1);  /* remove previous result */\n    /* try global variable (and create one if it does not exist) */\n    if (luaL_findtable(L, LUA_GLOBALSINDEX, modname, 1) != NULL)\n      return luaL_error(L, \"name conflict for module \" LUA_QS, modname);\n    lua_pushvalue(L, -1);\n    lua_setfield(L, loaded, modname);  /* _LOADED[modname] = new table */\n  }\n  /* check whether table already has a _NAME field */\n  lua_getfield(L, -1, \"_NAME\");\n  if (!lua_isnil(L, -1))  /* is table an initialized module? */\n    lua_pop(L, 1);\n  else {  /* no; initialize it */\n    lua_pop(L, 1);\n    modinit(L, modname);\n  }\n  lua_pushvalue(L, -1);\n  setfenv(L);\n  dooptions(L, loaded - 1);\n  return 0;\n}\n\n\nstatic int ll_seeall (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  if (!lua_getmetatable(L, 1)) {\n    lua_createtable(L, 0, 1); /* create new metatable */\n    lua_pushvalue(L, -1);\n    lua_setmetatable(L, 1);\n  }\n  lua_pushvalue(L, LUA_GLOBALSINDEX);\n  lua_setfield(L, -2, \"__index\");  /* mt.__index = _G */\n  return 0;\n}\n\n\n/* }====================================================== */\n\n\n\n/* auxiliary mark (for internal use) */\n#define AUXMARK\t\t\"\\1\"\n\nstatic void setpath (lua_State *L, const char *fieldname, const char *envname,\n                                   const char *def) {\n  const char *path = getenv(envname);\n  if (path == NULL)  /* no environment variable? */\n    lua_pushstring(L, def);  /* use default */\n  else {\n    /* replace \";;\" by \";AUXMARK;\" and then AUXMARK by default path */\n    path = luaL_gsub(L, path, LUA_PATHSEP LUA_PATHSEP,\n                              LUA_PATHSEP AUXMARK LUA_PATHSEP);\n    luaL_gsub(L, path, AUXMARK, def);\n    lua_remove(L, -2);\n  }\n  setprogdir(L);\n  lua_setfield(L, -2, fieldname);\n}\n\n\nstatic const luaL_Reg pk_funcs[] = {\n  {\"loadlib\", ll_loadlib},\n  {\"seeall\", ll_seeall},\n  {NULL, NULL}\n};\n\n\nstatic const luaL_Reg ll_funcs[] = {\n  {\"module\", ll_module},\n  {\"require\", ll_require},\n  {NULL, NULL}\n};\n\n\nstatic const lua_CFunction loaders[] =\n  {loader_preload, loader_Lua, loader_C, loader_Croot, NULL};\n\n\nLUALIB_API int luaopen_package (lua_State *L) {\n  int i;\n  /* create new type _LOADLIB */\n  luaL_newmetatable(L, \"_LOADLIB\");\n  lua_pushcfunction(L, gctm);\n  lua_setfield(L, -2, \"__gc\");\n  /* create `package' table */\n  luaL_register(L, LUA_LOADLIBNAME, pk_funcs);\n#if defined(LUA_COMPAT_LOADLIB) \n  lua_getfield(L, -1, \"loadlib\");\n  lua_setfield(L, LUA_GLOBALSINDEX, \"loadlib\");\n#endif\n  lua_pushvalue(L, -1);\n  lua_replace(L, LUA_ENVIRONINDEX);\n  /* create `loaders' table */\n  lua_createtable(L, sizeof(loaders)/sizeof(loaders[0]) - 1, 0);\n  /* fill it with pre-defined loaders */\n  for (i=0; loaders[i] != NULL; i++) {\n    lua_pushcfunction(L, loaders[i]);\n    lua_rawseti(L, -2, i+1);\n  }\n  lua_setfield(L, -2, \"loaders\");  /* put it in field `loaders' */\n  setpath(L, \"path\", LUA_PATH, LUA_PATH_DEFAULT);  /* set field `path' */\n  setpath(L, \"cpath\", LUA_CPATH, LUA_CPATH_DEFAULT); /* set field `cpath' */\n  /* store config information */\n  lua_pushliteral(L, LUA_DIRSEP \"\\n\" LUA_PATHSEP \"\\n\" LUA_PATH_MARK \"\\n\"\n                     LUA_EXECDIR \"\\n\" LUA_IGMARK);\n  lua_setfield(L, -2, \"config\");\n  /* set field `loaded' */\n  luaL_findtable(L, LUA_REGISTRYINDEX, \"_LOADED\", 2);\n  lua_setfield(L, -2, \"loaded\");\n  /* set field `preload' */\n  lua_newtable(L);\n  lua_setfield(L, -2, \"preload\");\n  lua_pushvalue(L, LUA_GLOBALSINDEX);\n  luaL_register(L, NULL, ll_funcs);  /* open lib into global table */\n  lua_pop(L, 1);\n  return 1;  /* return 'package' table */\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.2-kgnq7exerr43idfj34trfbqmeiidhb7d/spack-src/deps/jemalloc/INSTALL.md": "Building and installing a packaged release of jemalloc can be as simple as\ntyping the following while in the root directory of the source tree:\n\n    ./configure\n    make\n    make install\n\nIf building from unpackaged developer sources, the simplest command sequence\nthat might work is:\n\n    ./autogen.sh\n    make dist\n    make\n    make install\n\nNote that documentation is not built by the default target because doing so\nwould create a dependency on xsltproc in packaged releases, hence the\nrequirement to either run 'make dist' or avoid installing docs via the various\ninstall_* targets documented below.\n\n\n## Advanced configuration\n\nThe 'configure' script supports numerous options that allow control of which\nfunctionality is enabled, where jemalloc is installed, etc.  Optionally, pass\nany of the following arguments (not a definitive list) to 'configure':\n\n* `--help`\n\n    Print a definitive list of options.\n\n* `--prefix=<install-root-dir>`\n\n    Set the base directory in which to install.  For example:\n\n        ./configure --prefix=/usr/local\n\n    will cause files to be installed into /usr/local/include, /usr/local/lib,\n    and /usr/local/man.\n\n* `--with-version=(<major>.<minor>.<bugfix>-<nrev>-g<gid>|VERSION)`\n\n    The VERSION file is mandatory for successful configuration, and the\n    following steps are taken to assure its presence:\n    1) If --with-version=<major>.<minor>.<bugfix>-<nrev>-g<gid> is specified,\n       generate VERSION using the specified value.\n    2) If --with-version is not specified in either form and the source\n       directory is inside a git repository, try to generate VERSION via 'git\n       describe' invocations that pattern-match release tags.\n    3) If VERSION is missing, generate it with a bogus version:\n       0.0.0-0-g0000000000000000000000000000000000000000\n\n    Note that --with-version=VERSION bypasses (1) and (2), which simplifies\n    VERSION configuration when embedding a jemalloc release into another\n    project's git repository.\n\n* `--with-rpath=<colon-separated-rpath>`\n\n    Embed one or more library paths, so that libjemalloc can find the libraries\n    it is linked to.  This works only on ELF-based systems.\n\n* `--with-mangling=<map>`\n\n    Mangle public symbols specified in <map> which is a comma-separated list of\n    name:mangled pairs.\n\n    For example, to use ld's --wrap option as an alternative method for\n    overriding libc's malloc implementation, specify something like:\n\n      --with-mangling=malloc:__wrap_malloc,free:__wrap_free[...]\n\n    Note that mangling happens prior to application of the prefix specified by\n    --with-jemalloc-prefix, and mangled symbols are then ignored when applying\n    the prefix.\n\n* `--with-jemalloc-prefix=<prefix>`\n\n    Prefix all public APIs with <prefix>.  For example, if <prefix> is\n    \"prefix_\", API changes like the following occur:\n\n      malloc()         --> prefix_malloc()\n      malloc_conf      --> prefix_malloc_conf\n      /etc/malloc.conf --> /etc/prefix_malloc.conf\n      MALLOC_CONF      --> PREFIX_MALLOC_CONF\n\n    This makes it possible to use jemalloc at the same time as the system\n    allocator, or even to use multiple copies of jemalloc simultaneously.\n\n    By default, the prefix is \"\", except on OS X, where it is \"je_\".  On OS X,\n    jemalloc overlays the default malloc zone, but makes no attempt to actually\n    replace the \"malloc\", \"calloc\", etc. symbols.\n\n* `--without-export`\n\n    Don't export public APIs.  This can be useful when building jemalloc as a\n    static library, or to avoid exporting public APIs when using the zone\n    allocator on OSX.\n\n* `--with-private-namespace=<prefix>`\n\n    Prefix all library-private APIs with <prefix>je_.  For shared libraries,\n    symbol visibility mechanisms prevent these symbols from being exported, but\n    for static libraries, naming collisions are a real possibility.  By\n    default, <prefix> is empty, which results in a symbol prefix of je_ .\n\n* `--with-install-suffix=<suffix>`\n\n    Append <suffix> to the base name of all installed files, such that multiple\n    versions of jemalloc can coexist in the same installation directory.  For\n    example, libjemalloc.so.0 becomes libjemalloc<suffix>.so.0.\n\n* `--with-malloc-conf=<malloc_conf>`\n\n    Embed `<malloc_conf>` as a run-time options string that is processed prior to\n    the malloc_conf global variable, the /etc/malloc.conf symlink, and the\n    MALLOC_CONF environment variable.  For example, to change the default decay\n    time to 30 seconds:\n\n      --with-malloc-conf=decay_ms:30000\n\n* `--enable-debug`\n\n    Enable assertions and validation code.  This incurs a substantial\n    performance hit, but is very useful during application development.\n\n* `--disable-stats`\n\n    Disable statistics gathering functionality.  See the \"opt.stats_print\"\n    option documentation for usage details.\n\n* `--enable-prof`\n\n    Enable heap profiling and leak detection functionality.  See the \"opt.prof\"\n    option documentation for usage details.  When enabled, there are several\n    approaches to backtracing, and the configure script chooses the first one\n    in the following list that appears to function correctly:\n\n    + libunwind      (requires --enable-prof-libunwind)\n    + libgcc         (unless --disable-prof-libgcc)\n    + gcc intrinsics (unless --disable-prof-gcc)\n\n* `--enable-prof-libunwind`\n\n    Use the libunwind library (http://www.nongnu.org/libunwind/) for stack\n    backtracing.\n\n* `--disable-prof-libgcc`\n\n    Disable the use of libgcc's backtracing functionality.\n\n* `--disable-prof-gcc`\n\n    Disable the use of gcc intrinsics for backtracing.\n\n* `--with-static-libunwind=<libunwind.a>`\n\n    Statically link against the specified libunwind.a rather than dynamically\n    linking with -lunwind.\n\n* `--disable-fill`\n\n    Disable support for junk/zero filling of memory.  See the \"opt.junk\" and\n    \"opt.zero\" option documentation for usage details.\n\n* `--disable-zone-allocator`\n\n    Disable zone allocator for Darwin.  This means jemalloc won't be hooked as\n    the default allocator on OSX/iOS.\n\n* `--enable-utrace`\n\n    Enable utrace(2)-based allocation tracing.  This feature is not broadly\n    portable (FreeBSD has it, but Linux and OS X do not).\n\n* `--enable-xmalloc`\n\n    Enable support for optional immediate termination due to out-of-memory\n    errors, as is commonly implemented by \"xmalloc\" wrapper function for malloc.\n    See the \"opt.xmalloc\" option documentation for usage details.\n\n* `--enable-lazy-lock`\n\n    Enable code that wraps pthread_create() to detect when an application\n    switches from single-threaded to multi-threaded mode, so that it can avoid\n    mutex locking/unlocking operations while in single-threaded mode.  In\n    practice, this feature usually has little impact on performance unless\n    thread-specific caching is disabled.\n\n* `--disable-cache-oblivious`\n\n    Disable cache-oblivious large allocation alignment for large allocation\n    requests with no alignment constraints.  If this feature is disabled, all\n    large allocations are page-aligned as an implementation artifact, which can\n    severely harm CPU cache utilization.  However, the cache-oblivious layout\n    comes at the cost of one extra page per large allocation, which in the\n    most extreme case increases physical memory usage for the 16 KiB size class\n    to 20 KiB.\n\n* `--disable-syscall`\n\n    Disable use of syscall(2) rather than {open,read,write,close}(2).  This is\n    intended as a workaround for systems that place security limitations on\n    syscall(2).\n\n* `--disable-cxx`\n\n    Disable C++ integration.  This will cause new and delete operator\n    implementations to be omitted.\n\n* `--with-xslroot=<path>`\n\n    Specify where to find DocBook XSL stylesheets when building the\n    documentation.\n\n* `--with-lg-page=<lg-page>`\n\n    Specify the base 2 log of the allocator page size, which must in turn be at\n    least as large as the system page size.  By default the configure script\n    determines the host's page size and sets the allocator page size equal to\n    the system page size, so this option need not be specified unless the\n    system page size may change between configuration and execution, e.g. when\n    cross compiling.\n\n* `--with-lg-page-sizes=<lg-page-sizes>`\n\n    Specify the comma-separated base 2 logs of the page sizes to support.  This\n    option may be useful when cross compiling in combination with\n    `--with-lg-page`, but its primary use case is for integration with FreeBSD's\n    libc, wherein jemalloc is embedded.\n\n* `--with-lg-hugepage=<lg-hugepage>`\n\n    Specify the base 2 log of the system huge page size.  This option is useful\n    when cross compiling, or when overriding the default for systems that do\n    not explicitly support huge pages.\n\n* `--with-lg-quantum=<lg-quantum>`\n\n    Specify the base 2 log of the minimum allocation alignment.  jemalloc needs\n    to know the minimum alignment that meets the following C standard\n    requirement (quoted from the April 12, 2011 draft of the C11 standard):\n\n    >  The pointer returned if the allocation succeeds is suitably aligned so\n      that it may be assigned to a pointer to any type of object with a\n      fundamental alignment requirement and then used to access such an object\n      or an array of such objects in the space allocated [...]\n\n    This setting is architecture-specific, and although jemalloc includes known\n    safe values for the most commonly used modern architectures, there is a\n    wrinkle related to GNU libc (glibc) that may impact your choice of\n    <lg-quantum>.  On most modern architectures, this mandates 16-byte\n    alignment (<lg-quantum>=4), but the glibc developers chose not to meet this\n    requirement for performance reasons.  An old discussion can be found at\n    <https://sourceware.org/bugzilla/show_bug.cgi?id=206> .  Unlike glibc,\n    jemalloc does follow the C standard by default (caveat: jemalloc\n    technically cheats for size classes smaller than the quantum), but the fact\n    that Linux systems already work around this allocator noncompliance means\n    that it is generally safe in practice to let jemalloc's minimum alignment\n    follow glibc's lead.  If you specify `--with-lg-quantum=3` during\n    configuration, jemalloc will provide additional size classes that are not\n    16-byte-aligned (24, 40, and 56).\n\n* `--with-lg-vaddr=<lg-vaddr>`\n\n    Specify the number of significant virtual address bits.  By default, the\n    configure script attempts to detect virtual address size on those platforms\n    where it knows how, and picks a default otherwise.  This option may be\n    useful when cross-compiling.\n\n* `--disable-initial-exec-tls`\n\n    Disable the initial-exec TLS model for jemalloc's internal thread-local\n    storage (on those platforms that support explicit settings).  This can allow\n    jemalloc to be dynamically loaded after program startup (e.g. using dlopen).\n    Note that in this case, there will be two malloc implementations operating\n    in the same process, which will almost certainly result in confusing runtime\n    crashes if pointers leak from one implementation to the other.\n\nThe following environment variables (not a definitive list) impact configure's\nbehavior:\n\n* `CFLAGS=\"?\"`\n* `CXXFLAGS=\"?\"`\n\n    Pass these flags to the C/C++ compiler.  Any flags set by the configure\n    script are prepended, which means explicitly set flags generally take\n    precedence.  Take care when specifying flags such as -Werror, because\n    configure tests may be affected in undesirable ways.\n\n* `EXTRA_CFLAGS=\"?\"`\n* `EXTRA_CXXFLAGS=\"?\"`\n\n    Append these flags to CFLAGS/CXXFLAGS, without passing them to the\n    compiler(s) during configuration.  This makes it possible to add flags such\n    as -Werror, while allowing the configure script to determine what other\n    flags are appropriate for the specified configuration.\n\n* `CPPFLAGS=\"?\"`\n\n    Pass these flags to the C preprocessor.  Note that CFLAGS is not passed to\n    'cpp' when 'configure' is looking for include files, so you must use\n    CPPFLAGS instead if you need to help 'configure' find header files.\n\n* `LD_LIBRARY_PATH=\"?\"`\n\n    'ld' uses this colon-separated list to find libraries.\n\n* `LDFLAGS=\"?\"`\n\n    Pass these flags when linking.\n\n* `PATH=\"?\"`\n\n    'configure' uses this to find programs.\n\nIn some cases it may be necessary to work around configuration results that do\nnot match reality.  For example, Linux 4.5 added support for the MADV_FREE flag\nto madvise(2), which can cause problems if building on a host with MADV_FREE\nsupport and deploying to a target without.  To work around this, use a cache\nfile to override the relevant configuration variable defined in configure.ac,\ne.g.:\n\n    echo \"je_cv_madv_free=no\" > config.cache && ./configure -C\n\n\n## Advanced compilation\n\nTo build only parts of jemalloc, use the following targets:\n\n    build_lib_shared\n    build_lib_static\n    build_lib\n    build_doc_html\n    build_doc_man\n    build_doc\n\nTo install only parts of jemalloc, use the following targets:\n\n    install_bin\n    install_include\n    install_lib_shared\n    install_lib_static\n    install_lib_pc\n    install_lib\n    install_doc_html\n    install_doc_man\n    install_doc\n\nTo clean up build results to varying degrees, use the following make targets:\n\n    clean\n    distclean\n    relclean\n\n\n## Advanced installation\n\nOptionally, define make variables when invoking make, including (not\nexclusively):\n\n* `INCLUDEDIR=\"?\"`\n\n    Use this as the installation prefix for header files.\n\n* `LIBDIR=\"?\"`\n\n    Use this as the installation prefix for libraries.\n\n* `MANDIR=\"?\"`\n\n    Use this as the installation prefix for man pages.\n\n* `DESTDIR=\"?\"`\n\n    Prepend DESTDIR to INCLUDEDIR, LIBDIR, DATADIR, and MANDIR.  This is useful\n    when installing to a different path than was specified via --prefix.\n\n* `CC=\"?\"`\n\n    Use this to invoke the C compiler.\n\n* `CFLAGS=\"?\"`\n\n    Pass these flags to the compiler.\n\n* `CPPFLAGS=\"?\"`\n\n    Pass these flags to the C preprocessor.\n\n* `LDFLAGS=\"?\"`\n\n    Pass these flags when linking.\n\n* `PATH=\"?\"`\n\n    Use this to search for programs used during configuration and building.\n\n\n## Development\n\nIf you intend to make non-trivial changes to jemalloc, use the 'autogen.sh'\nscript rather than 'configure'.  This re-generates 'configure', enables\nconfiguration dependency rules, and enables re-generation of automatically\ngenerated source files.\n\nThe build system supports using an object directory separate from the source\ntree.  For example, you can create an 'obj' directory, and from within that\ndirectory, issue configuration and build commands:\n\n    autoconf\n    mkdir obj\n    cd obj\n    ../configure --enable-autogen\n    make\n\n\n## Documentation\n\nThe manual page is generated in both html and roff formats.  Any web browser\ncan be used to view the html manual.  The roff manual page can be formatted\nprior to installation via the following command:\n\n    nroff -man -t doc/jemalloc.3\n",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.2-kgnq7exerr43idfj34trfbqmeiidhb7d/spack-src/deps/jemalloc/src/jemalloc.c": "#define JEMALLOC_C_\n#include \"jemalloc/internal/jemalloc_preamble.h\"\n#include \"jemalloc/internal/jemalloc_internal_includes.h\"\n\n#include \"jemalloc/internal/assert.h\"\n#include \"jemalloc/internal/atomic.h\"\n#include \"jemalloc/internal/ctl.h\"\n#include \"jemalloc/internal/extent_dss.h\"\n#include \"jemalloc/internal/extent_mmap.h\"\n#include \"jemalloc/internal/jemalloc_internal_types.h\"\n#include \"jemalloc/internal/log.h\"\n#include \"jemalloc/internal/malloc_io.h\"\n#include \"jemalloc/internal/mutex.h\"\n#include \"jemalloc/internal/rtree.h\"\n#include \"jemalloc/internal/size_classes.h\"\n#include \"jemalloc/internal/spin.h\"\n#include \"jemalloc/internal/sz.h\"\n#include \"jemalloc/internal/ticker.h\"\n#include \"jemalloc/internal/util.h\"\n\n/******************************************************************************/\n/* Data. */\n\n/* Runtime configuration options. */\nconst char\t*je_malloc_conf\n#ifndef _WIN32\n    JEMALLOC_ATTR(weak)\n#endif\n    ;\nbool\topt_abort =\n#ifdef JEMALLOC_DEBUG\n    true\n#else\n    false\n#endif\n    ;\nbool\topt_abort_conf =\n#ifdef JEMALLOC_DEBUG\n    true\n#else\n    false\n#endif\n    ;\nconst char\t*opt_junk =\n#if (defined(JEMALLOC_DEBUG) && defined(JEMALLOC_FILL))\n    \"true\"\n#else\n    \"false\"\n#endif\n    ;\nbool\topt_junk_alloc =\n#if (defined(JEMALLOC_DEBUG) && defined(JEMALLOC_FILL))\n    true\n#else\n    false\n#endif\n    ;\nbool\topt_junk_free =\n#if (defined(JEMALLOC_DEBUG) && defined(JEMALLOC_FILL))\n    true\n#else\n    false\n#endif\n    ;\n\nbool\topt_utrace = false;\nbool\topt_xmalloc = false;\nbool\topt_zero = false;\nunsigned\topt_narenas = 0;\n\nunsigned\tncpus;\n\n/* Protects arenas initialization. */\nmalloc_mutex_t arenas_lock;\n/*\n * Arenas that are used to service external requests.  Not all elements of the\n * arenas array are necessarily used; arenas are created lazily as needed.\n *\n * arenas[0..narenas_auto) are used for automatic multiplexing of threads and\n * arenas.  arenas[narenas_auto..narenas_total) are only used if the application\n * takes some action to create them and allocate from them.\n *\n * Points to an arena_t.\n */\nJEMALLOC_ALIGNED(CACHELINE)\natomic_p_t\t\tarenas[MALLOCX_ARENA_LIMIT];\nstatic atomic_u_t\tnarenas_total; /* Use narenas_total_*(). */\nstatic arena_t\t\t*a0; /* arenas[0]; read-only after initialization. */\nunsigned\t\tnarenas_auto; /* Read-only after initialization. */\n\ntypedef enum {\n\tmalloc_init_uninitialized\t= 3,\n\tmalloc_init_a0_initialized\t= 2,\n\tmalloc_init_recursible\t\t= 1,\n\tmalloc_init_initialized\t\t= 0 /* Common case --> jnz. */\n} malloc_init_t;\nstatic malloc_init_t\tmalloc_init_state = malloc_init_uninitialized;\n\n/* False should be the common case.  Set to true to trigger initialization. */\nbool\t\t\tmalloc_slow = true;\n\n/* When malloc_slow is true, set the corresponding bits for sanity check. */\nenum {\n\tflag_opt_junk_alloc\t= (1U),\n\tflag_opt_junk_free\t= (1U << 1),\n\tflag_opt_zero\t\t= (1U << 2),\n\tflag_opt_utrace\t\t= (1U << 3),\n\tflag_opt_xmalloc\t= (1U << 4)\n};\nstatic uint8_t\tmalloc_slow_flags;\n\n#ifdef JEMALLOC_THREADED_INIT\n/* Used to let the initializing thread recursively allocate. */\n#  define NO_INITIALIZER\t((unsigned long)0)\n#  define INITIALIZER\t\tpthread_self()\n#  define IS_INITIALIZER\t(malloc_initializer == pthread_self())\nstatic pthread_t\t\tmalloc_initializer = NO_INITIALIZER;\n#else\n#  define NO_INITIALIZER\tfalse\n#  define INITIALIZER\t\ttrue\n#  define IS_INITIALIZER\tmalloc_initializer\nstatic bool\t\t\tmalloc_initializer = NO_INITIALIZER;\n#endif\n\n/* Used to avoid initialization races. */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\nstatic malloc_mutex_t\tinit_lock = SRWLOCK_INIT;\n#else\nstatic malloc_mutex_t\tinit_lock;\nstatic bool init_lock_initialized = false;\n\nJEMALLOC_ATTR(constructor)\nstatic void WINAPI\n_init_init_lock(void) {\n\t/*\n\t * If another constructor in the same binary is using mallctl to e.g.\n\t * set up extent hooks, it may end up running before this one, and\n\t * malloc_init_hard will crash trying to lock the uninitialized lock. So\n\t * we force an initialization of the lock in malloc_init_hard as well.\n\t * We don't try to care about atomicity of the accessed to the\n\t * init_lock_initialized boolean, since it really only matters early in\n\t * the process creation, before any separate thread normally starts\n\t * doing anything.\n\t */\n\tif (!init_lock_initialized) {\n\t\tmalloc_mutex_init(&init_lock, \"init\", WITNESS_RANK_INIT,\n\t\t    malloc_mutex_rank_exclusive);\n\t}\n\tinit_lock_initialized = true;\n}\n\n#ifdef _MSC_VER\n#  pragma section(\".CRT$XCU\", read)\nJEMALLOC_SECTION(\".CRT$XCU\") JEMALLOC_ATTR(used)\nstatic const void (WINAPI *init_init_lock)(void) = _init_init_lock;\n#endif\n#endif\n#else\nstatic malloc_mutex_t\tinit_lock = MALLOC_MUTEX_INITIALIZER;\n#endif\n\ntypedef struct {\n\tvoid\t*p;\t/* Input pointer (as in realloc(p, s)). */\n\tsize_t\ts;\t/* Request size. */\n\tvoid\t*r;\t/* Result pointer. */\n} malloc_utrace_t;\n\n#ifdef JEMALLOC_UTRACE\n#  define UTRACE(a, b, c) do {\t\t\t\t\t\t\\\n\tif (unlikely(opt_utrace)) {\t\t\t\t\t\\\n\t\tint utrace_serrno = errno;\t\t\t\t\\\n\t\tmalloc_utrace_t ut;\t\t\t\t\t\\\n\t\tut.p = (a);\t\t\t\t\t\t\\\n\t\tut.s = (b);\t\t\t\t\t\t\\\n\t\tut.r = (c);\t\t\t\t\t\t\\\n\t\tutrace(&ut, sizeof(ut));\t\t\t\t\\\n\t\terrno = utrace_serrno;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n#else\n#  define UTRACE(a, b, c)\n#endif\n\n/* Whether encountered any invalid config options. */\nstatic bool had_conf_error = false;\n\n/******************************************************************************/\n/*\n * Function prototypes for static functions that are referenced prior to\n * definition.\n */\n\nstatic bool\tmalloc_init_hard_a0(void);\nstatic bool\tmalloc_init_hard(void);\n\n/******************************************************************************/\n/*\n * Begin miscellaneous support functions.\n */\n\nbool\nmalloc_initialized(void) {\n\treturn (malloc_init_state == malloc_init_initialized);\n}\n\nJEMALLOC_ALWAYS_INLINE bool\nmalloc_init_a0(void) {\n\tif (unlikely(malloc_init_state == malloc_init_uninitialized)) {\n\t\treturn malloc_init_hard_a0();\n\t}\n\treturn false;\n}\n\nJEMALLOC_ALWAYS_INLINE bool\nmalloc_init(void) {\n\tif (unlikely(!malloc_initialized()) && malloc_init_hard()) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * The a0*() functions are used instead of i{d,}alloc() in situations that\n * cannot tolerate TLS variable access.\n */\n\nstatic void *\na0ialloc(size_t size, bool zero, bool is_internal) {\n\tif (unlikely(malloc_init_a0())) {\n\t\treturn NULL;\n\t}\n\n\treturn iallocztm(TSDN_NULL, size, sz_size2index(size), zero, NULL,\n\t    is_internal, arena_get(TSDN_NULL, 0, true), true);\n}\n\nstatic void\na0idalloc(void *ptr, bool is_internal) {\n\tidalloctm(TSDN_NULL, ptr, NULL, NULL, is_internal, true);\n}\n\nvoid *\na0malloc(size_t size) {\n\treturn a0ialloc(size, false, true);\n}\n\nvoid\na0dalloc(void *ptr) {\n\ta0idalloc(ptr, true);\n}\n\n/*\n * FreeBSD's libc uses the bootstrap_*() functions in bootstrap-senstive\n * situations that cannot tolerate TLS variable access (TLS allocation and very\n * early internal data structure initialization).\n */\n\nvoid *\nbootstrap_malloc(size_t size) {\n\tif (unlikely(size == 0)) {\n\t\tsize = 1;\n\t}\n\n\treturn a0ialloc(size, false, false);\n}\n\nvoid *\nbootstrap_calloc(size_t num, size_t size) {\n\tsize_t num_size;\n\n\tnum_size = num * size;\n\tif (unlikely(num_size == 0)) {\n\t\tassert(num == 0 || size == 0);\n\t\tnum_size = 1;\n\t}\n\n\treturn a0ialloc(num_size, true, false);\n}\n\nvoid\nbootstrap_free(void *ptr) {\n\tif (unlikely(ptr == NULL)) {\n\t\treturn;\n\t}\n\n\ta0idalloc(ptr, false);\n}\n\nvoid\narena_set(unsigned ind, arena_t *arena) {\n\tatomic_store_p(&arenas[ind], arena, ATOMIC_RELEASE);\n}\n\nstatic void\nnarenas_total_set(unsigned narenas) {\n\tatomic_store_u(&narenas_total, narenas, ATOMIC_RELEASE);\n}\n\nstatic void\nnarenas_total_inc(void) {\n\tatomic_fetch_add_u(&narenas_total, 1, ATOMIC_RELEASE);\n}\n\nunsigned\nnarenas_total_get(void) {\n\treturn atomic_load_u(&narenas_total, ATOMIC_ACQUIRE);\n}\n\n/* Create a new arena and insert it into the arenas array at index ind. */\nstatic arena_t *\narena_init_locked(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {\n\tarena_t *arena;\n\n\tassert(ind <= narenas_total_get());\n\tif (ind >= MALLOCX_ARENA_LIMIT) {\n\t\treturn NULL;\n\t}\n\tif (ind == narenas_total_get()) {\n\t\tnarenas_total_inc();\n\t}\n\n\t/*\n\t * Another thread may have already initialized arenas[ind] if it's an\n\t * auto arena.\n\t */\n\tarena = arena_get(tsdn, ind, false);\n\tif (arena != NULL) {\n\t\tassert(ind < narenas_auto);\n\t\treturn arena;\n\t}\n\n\t/* Actually initialize the arena. */\n\tarena = arena_new(tsdn, ind, extent_hooks);\n\n\treturn arena;\n}\n\nstatic void\narena_new_create_background_thread(tsdn_t *tsdn, unsigned ind) {\n\tif (ind == 0) {\n\t\treturn;\n\t}\n\tif (have_background_thread) {\n\t\tbool err;\n\t\tmalloc_mutex_lock(tsdn, &background_thread_lock);\n\t\terr = background_thread_create(tsdn_tsd(tsdn), ind);\n\t\tmalloc_mutex_unlock(tsdn, &background_thread_lock);\n\t\tif (err) {\n\t\t\tmalloc_printf(\"<jemalloc>: error in background thread \"\n\t\t\t\t      \"creation for arena %u. Abort.\\n\", ind);\n\t\t\tabort();\n\t\t}\n\t}\n}\n\narena_t *\narena_init(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {\n\tarena_t *arena;\n\n\tmalloc_mutex_lock(tsdn, &arenas_lock);\n\tarena = arena_init_locked(tsdn, ind, extent_hooks);\n\tmalloc_mutex_unlock(tsdn, &arenas_lock);\n\n\tarena_new_create_background_thread(tsdn, ind);\n\n\treturn arena;\n}\n\nstatic void\narena_bind(tsd_t *tsd, unsigned ind, bool internal) {\n\tarena_t *arena = arena_get(tsd_tsdn(tsd), ind, false);\n\tarena_nthreads_inc(arena, internal);\n\n\tif (internal) {\n\t\ttsd_iarena_set(tsd, arena);\n\t} else {\n\t\ttsd_arena_set(tsd, arena);\n\t}\n}\n\nvoid\narena_migrate(tsd_t *tsd, unsigned oldind, unsigned newind) {\n\tarena_t *oldarena, *newarena;\n\n\toldarena = arena_get(tsd_tsdn(tsd), oldind, false);\n\tnewarena = arena_get(tsd_tsdn(tsd), newind, false);\n\tarena_nthreads_dec(oldarena, false);\n\tarena_nthreads_inc(newarena, false);\n\ttsd_arena_set(tsd, newarena);\n}\n\nstatic void\narena_unbind(tsd_t *tsd, unsigned ind, bool internal) {\n\tarena_t *arena;\n\n\tarena = arena_get(tsd_tsdn(tsd), ind, false);\n\tarena_nthreads_dec(arena, internal);\n\n\tif (internal) {\n\t\ttsd_iarena_set(tsd, NULL);\n\t} else {\n\t\ttsd_arena_set(tsd, NULL);\n\t}\n}\n\narena_tdata_t *\narena_tdata_get_hard(tsd_t *tsd, unsigned ind) {\n\tarena_tdata_t *tdata, *arenas_tdata_old;\n\tarena_tdata_t *arenas_tdata = tsd_arenas_tdata_get(tsd);\n\tunsigned narenas_tdata_old, i;\n\tunsigned narenas_tdata = tsd_narenas_tdata_get(tsd);\n\tunsigned narenas_actual = narenas_total_get();\n\n\t/*\n\t * Dissociate old tdata array (and set up for deallocation upon return)\n\t * if it's too small.\n\t */\n\tif (arenas_tdata != NULL && narenas_tdata < narenas_actual) {\n\t\tarenas_tdata_old = arenas_tdata;\n\t\tnarenas_tdata_old = narenas_tdata;\n\t\tarenas_tdata = NULL;\n\t\tnarenas_tdata = 0;\n\t\ttsd_arenas_tdata_set(tsd, arenas_tdata);\n\t\ttsd_narenas_tdata_set(tsd, narenas_tdata);\n\t} else {\n\t\tarenas_tdata_old = NULL;\n\t\tnarenas_tdata_old = 0;\n\t}\n\n\t/* Allocate tdata array if it's missing. */\n\tif (arenas_tdata == NULL) {\n\t\tbool *arenas_tdata_bypassp = tsd_arenas_tdata_bypassp_get(tsd);\n\t\tnarenas_tdata = (ind < narenas_actual) ? narenas_actual : ind+1;\n\n\t\tif (tsd_nominal(tsd) && !*arenas_tdata_bypassp) {\n\t\t\t*arenas_tdata_bypassp = true;\n\t\t\tarenas_tdata = (arena_tdata_t *)a0malloc(\n\t\t\t    sizeof(arena_tdata_t) * narenas_tdata);\n\t\t\t*arenas_tdata_bypassp = false;\n\t\t}\n\t\tif (arenas_tdata == NULL) {\n\t\t\ttdata = NULL;\n\t\t\tgoto label_return;\n\t\t}\n\t\tassert(tsd_nominal(tsd) && !*arenas_tdata_bypassp);\n\t\ttsd_arenas_tdata_set(tsd, arenas_tdata);\n\t\ttsd_narenas_tdata_set(tsd, narenas_tdata);\n\t}\n\n\t/*\n\t * Copy to tdata array.  It's possible that the actual number of arenas\n\t * has increased since narenas_total_get() was called above, but that\n\t * causes no correctness issues unless two threads concurrently execute\n\t * the arenas.create mallctl, which we trust mallctl synchronization to\n\t * prevent.\n\t */\n\n\t/* Copy/initialize tickers. */\n\tfor (i = 0; i < narenas_actual; i++) {\n\t\tif (i < narenas_tdata_old) {\n\t\t\tticker_copy(&arenas_tdata[i].decay_ticker,\n\t\t\t    &arenas_tdata_old[i].decay_ticker);\n\t\t} else {\n\t\t\tticker_init(&arenas_tdata[i].decay_ticker,\n\t\t\t    DECAY_NTICKS_PER_UPDATE);\n\t\t}\n\t}\n\tif (narenas_tdata > narenas_actual) {\n\t\tmemset(&arenas_tdata[narenas_actual], 0, sizeof(arena_tdata_t)\n\t\t    * (narenas_tdata - narenas_actual));\n\t}\n\n\t/* Read the refreshed tdata array. */\n\ttdata = &arenas_tdata[ind];\nlabel_return:\n\tif (arenas_tdata_old != NULL) {\n\t\ta0dalloc(arenas_tdata_old);\n\t}\n\treturn tdata;\n}\n\n/* Slow path, called only by arena_choose(). */\narena_t *\narena_choose_hard(tsd_t *tsd, bool internal) {\n\tarena_t *ret JEMALLOC_CC_SILENCE_INIT(NULL);\n\n\tif (have_percpu_arena && PERCPU_ARENA_ENABLED(opt_percpu_arena)) {\n\t\tunsigned choose = percpu_arena_choose();\n\t\tret = arena_get(tsd_tsdn(tsd), choose, true);\n\t\tassert(ret != NULL);\n\t\tarena_bind(tsd, arena_ind_get(ret), false);\n\t\tarena_bind(tsd, arena_ind_get(ret), true);\n\n\t\treturn ret;\n\t}\n\n\tif (narenas_auto > 1) {\n\t\tunsigned i, j, choose[2], first_null;\n\t\tbool is_new_arena[2];\n\n\t\t/*\n\t\t * Determine binding for both non-internal and internal\n\t\t * allocation.\n\t\t *\n\t\t *   choose[0]: For application allocation.\n\t\t *   choose[1]: For internal metadata allocation.\n\t\t */\n\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tchoose[j] = 0;\n\t\t\tis_new_arena[j] = false;\n\t\t}\n\n\t\tfirst_null = narenas_auto;\n\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &arenas_lock);\n\t\tassert(arena_get(tsd_tsdn(tsd), 0, false) != NULL);\n\t\tfor (i = 1; i < narenas_auto; i++) {\n\t\t\tif (arena_get(tsd_tsdn(tsd), i, false) != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Choose the first arena that has the lowest\n\t\t\t\t * number of threads assigned to it.\n\t\t\t\t */\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tif (arena_nthreads_get(arena_get(\n\t\t\t\t\t    tsd_tsdn(tsd), i, false), !!j) <\n\t\t\t\t\t    arena_nthreads_get(arena_get(\n\t\t\t\t\t    tsd_tsdn(tsd), choose[j], false),\n\t\t\t\t\t    !!j)) {\n\t\t\t\t\t\tchoose[j] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (first_null == narenas_auto) {\n\t\t\t\t/*\n\t\t\t\t * Record the index of the first uninitialized\n\t\t\t\t * arena, in case all extant arenas are in use.\n\t\t\t\t *\n\t\t\t\t * NB: It is possible for there to be\n\t\t\t\t * discontinuities in terms of initialized\n\t\t\t\t * versus uninitialized arenas, due to the\n\t\t\t\t * \"thread.arena\" mallctl.\n\t\t\t\t */\n\t\t\t\tfirst_null = i;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tif (arena_nthreads_get(arena_get(tsd_tsdn(tsd),\n\t\t\t    choose[j], false), !!j) == 0 || first_null ==\n\t\t\t    narenas_auto) {\n\t\t\t\t/*\n\t\t\t\t * Use an unloaded arena, or the least loaded\n\t\t\t\t * arena if all arenas are already initialized.\n\t\t\t\t */\n\t\t\t\tif (!!j == internal) {\n\t\t\t\t\tret = arena_get(tsd_tsdn(tsd),\n\t\t\t\t\t    choose[j], false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarena_t *arena;\n\n\t\t\t\t/* Initialize a new arena. */\n\t\t\t\tchoose[j] = first_null;\n\t\t\t\tarena = arena_init_locked(tsd_tsdn(tsd),\n\t\t\t\t    choose[j],\n\t\t\t\t    (extent_hooks_t *)&extent_hooks_default);\n\t\t\t\tif (arena == NULL) {\n\t\t\t\t\tmalloc_mutex_unlock(tsd_tsdn(tsd),\n\t\t\t\t\t    &arenas_lock);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tis_new_arena[j] = true;\n\t\t\t\tif (!!j == internal) {\n\t\t\t\t\tret = arena;\n\t\t\t\t}\n\t\t\t}\n\t\t\tarena_bind(tsd, choose[j], !!j);\n\t\t}\n\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &arenas_lock);\n\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tif (is_new_arena[j]) {\n\t\t\t\tassert(choose[j] > 0);\n\t\t\t\tarena_new_create_background_thread(\n\t\t\t\t    tsd_tsdn(tsd), choose[j]);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tret = arena_get(tsd_tsdn(tsd), 0, false);\n\t\tarena_bind(tsd, 0, false);\n\t\tarena_bind(tsd, 0, true);\n\t}\n\n\treturn ret;\n}\n\nvoid\niarena_cleanup(tsd_t *tsd) {\n\tarena_t *iarena;\n\n\tiarena = tsd_iarena_get(tsd);\n\tif (iarena != NULL) {\n\t\tarena_unbind(tsd, arena_ind_get(iarena), true);\n\t}\n}\n\nvoid\narena_cleanup(tsd_t *tsd) {\n\tarena_t *arena;\n\n\tarena = tsd_arena_get(tsd);\n\tif (arena != NULL) {\n\t\tarena_unbind(tsd, arena_ind_get(arena), false);\n\t}\n}\n\nvoid\narenas_tdata_cleanup(tsd_t *tsd) {\n\tarena_tdata_t *arenas_tdata;\n\n\t/* Prevent tsd->arenas_tdata from being (re)created. */\n\t*tsd_arenas_tdata_bypassp_get(tsd) = true;\n\n\tarenas_tdata = tsd_arenas_tdata_get(tsd);\n\tif (arenas_tdata != NULL) {\n\t\ttsd_arenas_tdata_set(tsd, NULL);\n\t\ta0dalloc(arenas_tdata);\n\t}\n}\n\nstatic void\nstats_print_atexit(void) {\n\tif (config_stats) {\n\t\ttsdn_t *tsdn;\n\t\tunsigned narenas, i;\n\n\t\ttsdn = tsdn_fetch();\n\n\t\t/*\n\t\t * Merge stats from extant threads.  This is racy, since\n\t\t * individual threads do not lock when recording tcache stats\n\t\t * events.  As a consequence, the final stats may be slightly\n\t\t * out of date by the time they are reported, if other threads\n\t\t * continue to allocate.\n\t\t */\n\t\tfor (i = 0, narenas = narenas_total_get(); i < narenas; i++) {\n\t\t\tarena_t *arena = arena_get(tsdn, i, false);\n\t\t\tif (arena != NULL) {\n\t\t\t\ttcache_t *tcache;\n\n\t\t\t\tmalloc_mutex_lock(tsdn, &arena->tcache_ql_mtx);\n\t\t\t\tql_foreach(tcache, &arena->tcache_ql, link) {\n\t\t\t\t\ttcache_stats_merge(tsdn, tcache, arena);\n\t\t\t\t}\n\t\t\t\tmalloc_mutex_unlock(tsdn,\n\t\t\t\t    &arena->tcache_ql_mtx);\n\t\t\t}\n\t\t}\n\t}\n\tje_malloc_stats_print(NULL, NULL, opt_stats_print_opts);\n}\n\n/*\n * Ensure that we don't hold any locks upon entry to or exit from allocator\n * code (in a \"broad\" sense that doesn't count a reentrant allocation as an\n * entrance or exit).\n */\nJEMALLOC_ALWAYS_INLINE void\ncheck_entry_exit_locking(tsdn_t *tsdn) {\n\tif (!config_debug) {\n\t\treturn;\n\t}\n\tif (tsdn_null(tsdn)) {\n\t\treturn;\n\t}\n\ttsd_t *tsd = tsdn_tsd(tsdn);\n\t/*\n\t * It's possible we hold locks at entry/exit if we're in a nested\n\t * allocation.\n\t */\n\tint8_t reentrancy_level = tsd_reentrancy_level_get(tsd);\n\tif (reentrancy_level != 0) {\n\t\treturn;\n\t}\n\twitness_assert_lockless(tsdn_witness_tsdp_get(tsdn));\n}\n\n/*\n * End miscellaneous support functions.\n */\n/******************************************************************************/\n/*\n * Begin initialization functions.\n */\n\nstatic char *\njemalloc_secure_getenv(const char *name) {\n#ifdef JEMALLOC_HAVE_SECURE_GETENV\n\treturn secure_getenv(name);\n#else\n#  ifdef JEMALLOC_HAVE_ISSETUGID\n\tif (issetugid() != 0) {\n\t\treturn NULL;\n\t}\n#  endif\n\treturn getenv(name);\n#endif\n}\n\nstatic unsigned\nmalloc_ncpus(void) {\n\tlong result;\n\n#ifdef _WIN32\n\tSYSTEM_INFO si;\n\tGetSystemInfo(&si);\n\tresult = si.dwNumberOfProcessors;\n#elif defined(JEMALLOC_GLIBC_MALLOC_HOOK) && defined(CPU_COUNT)\n\t/*\n\t * glibc >= 2.6 has the CPU_COUNT macro.\n\t *\n\t * glibc's sysconf() uses isspace().  glibc allocates for the first time\n\t * *before* setting up the isspace tables.  Therefore we need a\n\t * different method to get the number of CPUs.\n\t */\n\t{\n\t\tcpu_set_t set;\n\n\t\tpthread_getaffinity_np(pthread_self(), sizeof(set), &set);\n\t\tresult = CPU_COUNT(&set);\n\t}\n#else\n\tresult = sysconf(_SC_NPROCESSORS_ONLN);\n#endif\n\treturn ((result == -1) ? 1 : (unsigned)result);\n}\n\nstatic void\ninit_opt_stats_print_opts(const char *v, size_t vlen) {\n\tsize_t opts_len = strlen(opt_stats_print_opts);\n\tassert(opts_len <= stats_print_tot_num_options);\n\n\tfor (size_t i = 0; i < vlen; i++) {\n\t\tswitch (v[i]) {\n#define OPTION(o, v, d, s) case o: break;\n\t\t\tSTATS_PRINT_OPTIONS\n#undef OPTION\n\t\tdefault: continue;\n\t\t}\n\n\t\tif (strchr(opt_stats_print_opts, v[i]) != NULL) {\n\t\t\t/* Ignore repeated. */\n\t\t\tcontinue;\n\t\t}\n\n\t\topt_stats_print_opts[opts_len++] = v[i];\n\t\topt_stats_print_opts[opts_len] = '\\0';\n\t\tassert(opts_len <= stats_print_tot_num_options);\n\t}\n\tassert(opts_len == strlen(opt_stats_print_opts));\n}\n\nstatic bool\nmalloc_conf_next(char const **opts_p, char const **k_p, size_t *klen_p,\n    char const **v_p, size_t *vlen_p) {\n\tbool accept;\n\tconst char *opts = *opts_p;\n\n\t*k_p = opts;\n\n\tfor (accept = false; !accept;) {\n\t\tswitch (*opts) {\n\t\tcase 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n\t\tcase 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n\t\tcase 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n\t\tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n\t\tcase 'Y': case 'Z':\n\t\tcase 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n\t\tcase 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n\t\tcase 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n\t\tcase 's': case 't': case 'u': case 'v': case 'w': case 'x':\n\t\tcase 'y': case 'z':\n\t\tcase '0': case '1': case '2': case '3': case '4': case '5':\n\t\tcase '6': case '7': case '8': case '9':\n\t\tcase '_':\n\t\t\topts++;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\topts++;\n\t\t\t*klen_p = (uintptr_t)opts - 1 - (uintptr_t)*k_p;\n\t\t\t*v_p = opts;\n\t\t\taccept = true;\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\tif (opts != *opts_p) {\n\t\t\t\tmalloc_write(\"<jemalloc>: Conf string ends \"\n\t\t\t\t    \"with key\\n\");\n\t\t\t}\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tmalloc_write(\"<jemalloc>: Malformed conf string\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor (accept = false; !accept;) {\n\t\tswitch (*opts) {\n\t\tcase ',':\n\t\t\topts++;\n\t\t\t/*\n\t\t\t * Look ahead one character here, because the next time\n\t\t\t * this function is called, it will assume that end of\n\t\t\t * input has been cleanly reached if no input remains,\n\t\t\t * but we have optimistically already consumed the\n\t\t\t * comma if one exists.\n\t\t\t */\n\t\t\tif (*opts == '\\0') {\n\t\t\t\tmalloc_write(\"<jemalloc>: Conf string ends \"\n\t\t\t\t    \"with comma\\n\");\n\t\t\t}\n\t\t\t*vlen_p = (uintptr_t)opts - 1 - (uintptr_t)*v_p;\n\t\t\taccept = true;\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\t*vlen_p = (uintptr_t)opts - (uintptr_t)*v_p;\n\t\t\taccept = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\topts++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*opts_p = opts;\n\treturn false;\n}\n\nstatic void\nmalloc_abort_invalid_conf(void) {\n\tassert(opt_abort_conf);\n\tmalloc_printf(\"<jemalloc>: Abort (abort_conf:true) on invalid conf \"\n\t    \"value (see above).\\n\");\n\tabort();\n}\n\nstatic void\nmalloc_conf_error(const char *msg, const char *k, size_t klen, const char *v,\n    size_t vlen) {\n\tmalloc_printf(\"<jemalloc>: %s: %.*s:%.*s\\n\", msg, (int)klen, k,\n\t    (int)vlen, v);\n\t/* If abort_conf is set, error out after processing all options. */\n\thad_conf_error = true;\n}\n\nstatic void\nmalloc_slow_flag_init(void) {\n\t/*\n\t * Combine the runtime options into malloc_slow for fast path.  Called\n\t * after processing all the options.\n\t */\n\tmalloc_slow_flags |= (opt_junk_alloc ? flag_opt_junk_alloc : 0)\n\t    | (opt_junk_free ? flag_opt_junk_free : 0)\n\t    | (opt_zero ? flag_opt_zero : 0)\n\t    | (opt_utrace ? flag_opt_utrace : 0)\n\t    | (opt_xmalloc ? flag_opt_xmalloc : 0);\n\n\tmalloc_slow = (malloc_slow_flags != 0);\n}\n\nstatic void\nmalloc_conf_init(void) {\n\tunsigned i;\n\tchar buf[PATH_MAX + 1];\n\tconst char *opts, *k, *v;\n\tsize_t klen, vlen;\n\n\tfor (i = 0; i < 4; i++) {\n\t\t/* Get runtime configuration. */\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\topts = config_malloc_conf;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (je_malloc_conf != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Use options that were compiled into the\n\t\t\t\t * program.\n\t\t\t\t */\n\t\t\t\topts = je_malloc_conf;\n\t\t\t} else {\n\t\t\t\t/* No configuration specified. */\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t\topts = buf;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: {\n\t\t\tssize_t linklen = 0;\n#ifndef _WIN32\n\t\t\tint saved_errno = errno;\n\t\t\tconst char *linkname =\n#  ifdef JEMALLOC_PREFIX\n\t\t\t    \"/etc/\"JEMALLOC_PREFIX\"malloc.conf\"\n#  else\n\t\t\t    \"/etc/malloc.conf\"\n#  endif\n\t\t\t    ;\n\n\t\t\t/*\n\t\t\t * Try to use the contents of the \"/etc/malloc.conf\"\n\t\t\t * symbolic link's name.\n\t\t\t */\n\t\t\tlinklen = readlink(linkname, buf, sizeof(buf) - 1);\n\t\t\tif (linklen == -1) {\n\t\t\t\t/* No configuration specified. */\n\t\t\t\tlinklen = 0;\n\t\t\t\t/* Restore errno. */\n\t\t\t\tset_errno(saved_errno);\n\t\t\t}\n#endif\n\t\t\tbuf[linklen] = '\\0';\n\t\t\topts = buf;\n\t\t\tbreak;\n\t\t} case 3: {\n\t\t\tconst char *envname =\n#ifdef JEMALLOC_PREFIX\n\t\t\t    JEMALLOC_CPREFIX\"MALLOC_CONF\"\n#else\n\t\t\t    \"MALLOC_CONF\"\n#endif\n\t\t\t    ;\n\n\t\t\tif ((opts = jemalloc_secure_getenv(envname)) != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Do nothing; opts is already initialized to\n\t\t\t\t * the value of the MALLOC_CONF environment\n\t\t\t\t * variable.\n\t\t\t\t */\n\t\t\t} else {\n\t\t\t\t/* No configuration specified. */\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t\topts = buf;\n\t\t\t}\n\t\t\tbreak;\n\t\t} default:\n\t\t\tnot_reached();\n\t\t\tbuf[0] = '\\0';\n\t\t\topts = buf;\n\t\t}\n\n\t\twhile (*opts != '\\0' && !malloc_conf_next(&opts, &k, &klen, &v,\n\t\t    &vlen)) {\n#define CONF_MATCH(n)\t\t\t\t\t\t\t\\\n\t(sizeof(n)-1 == klen && strncmp(n, k, klen) == 0)\n#define CONF_MATCH_VALUE(n)\t\t\t\t\t\t\\\n\t(sizeof(n)-1 == vlen && strncmp(n, v, vlen) == 0)\n#define CONF_HANDLE_BOOL(o, n)\t\t\t\t\t\t\\\n\t\t\tif (CONF_MATCH(n)) {\t\t\t\t\\\n\t\t\t\tif (CONF_MATCH_VALUE(\"true\")) {\t\t\\\n\t\t\t\t\to = true;\t\t\t\\\n\t\t\t\t} else if (CONF_MATCH_VALUE(\"false\")) {\t\\\n\t\t\t\t\to = false;\t\t\t\\\n\t\t\t\t} else {\t\t\t\t\\\n\t\t\t\t\tmalloc_conf_error(\t\t\\\n\t\t\t\t\t    \"Invalid conf value\",\t\\\n\t\t\t\t\t    k, klen, v, vlen);\t\t\\\n\t\t\t\t}\t\t\t\t\t\\\n\t\t\t\tcontinue;\t\t\t\t\\\n\t\t\t}\n#define CONF_MIN_no(um, min)\tfalse\n#define CONF_MIN_yes(um, min)\t((um) < (min))\n#define CONF_MAX_no(um, max)\tfalse\n#define CONF_MAX_yes(um, max)\t((um) > (max))\n#define CONF_HANDLE_T_U(t, o, n, min, max, check_min, check_max, clip)\t\\\n\t\t\tif (CONF_MATCH(n)) {\t\t\t\t\\\n\t\t\t\tuintmax_t um;\t\t\t\t\\\n\t\t\t\tchar *end;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tset_errno(0);\t\t\t\t\\\n\t\t\t\tum = malloc_strtoumax(v, &end, 0);\t\\\n\t\t\t\tif (get_errno() != 0 || (uintptr_t)end -\\\n\t\t\t\t    (uintptr_t)v != vlen) {\t\t\\\n\t\t\t\t\tmalloc_conf_error(\t\t\\\n\t\t\t\t\t    \"Invalid conf value\",\t\\\n\t\t\t\t\t    k, klen, v, vlen);\t\t\\\n\t\t\t\t} else if (clip) {\t\t\t\\\n\t\t\t\t\tif (CONF_MIN_##check_min(um,\t\\\n\t\t\t\t\t    (t)(min))) {\t\t\\\n\t\t\t\t\t\to = (t)(min);\t\t\\\n\t\t\t\t\t} else if (\t\t\t\\\n\t\t\t\t\t    CONF_MAX_##check_max(um,\t\\\n\t\t\t\t\t    (t)(max))) {\t\t\\\n\t\t\t\t\t\to = (t)(max);\t\t\\\n\t\t\t\t\t} else {\t\t\t\\\n\t\t\t\t\t\to = (t)um;\t\t\\\n\t\t\t\t\t}\t\t\t\t\\\n\t\t\t\t} else {\t\t\t\t\\\n\t\t\t\t\tif (CONF_MIN_##check_min(um,\t\\\n\t\t\t\t\t    (t)(min)) ||\t\t\\\n\t\t\t\t\t    CONF_MAX_##check_max(um,\t\\\n\t\t\t\t\t    (t)(max))) {\t\t\\\n\t\t\t\t\t\tmalloc_conf_error(\t\\\n\t\t\t\t\t\t    \"Out-of-range \"\t\\\n\t\t\t\t\t\t    \"conf value\",\t\\\n\t\t\t\t\t\t    k, klen, v, vlen);\t\\\n\t\t\t\t\t} else {\t\t\t\\\n\t\t\t\t\t\to = (t)um;\t\t\\\n\t\t\t\t\t}\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\\\n\t\t\t\tcontinue;\t\t\t\t\\\n\t\t\t}\n#define CONF_HANDLE_UNSIGNED(o, n, min, max, check_min, check_max,\t\\\n    clip)\t\t\t\t\t\t\t\t\\\n\t\t\tCONF_HANDLE_T_U(unsigned, o, n, min, max,\t\\\n\t\t\t    check_min, check_max, clip)\n#define CONF_HANDLE_SIZE_T(o, n, min, max, check_min, check_max, clip)\t\\\n\t\t\tCONF_HANDLE_T_U(size_t, o, n, min, max,\t\t\\\n\t\t\t    check_min, check_max, clip)\n#define CONF_HANDLE_SSIZE_T(o, n, min, max)\t\t\t\t\\\n\t\t\tif (CONF_MATCH(n)) {\t\t\t\t\\\n\t\t\t\tlong l;\t\t\t\t\t\\\n\t\t\t\tchar *end;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tset_errno(0);\t\t\t\t\\\n\t\t\t\tl = strtol(v, &end, 0);\t\t\t\\\n\t\t\t\tif (get_errno() != 0 || (uintptr_t)end -\\\n\t\t\t\t    (uintptr_t)v != vlen) {\t\t\\\n\t\t\t\t\tmalloc_conf_error(\t\t\\\n\t\t\t\t\t    \"Invalid conf value\",\t\\\n\t\t\t\t\t    k, klen, v, vlen);\t\t\\\n\t\t\t\t} else if (l < (ssize_t)(min) || l >\t\\\n\t\t\t\t    (ssize_t)(max)) {\t\t\t\\\n\t\t\t\t\tmalloc_conf_error(\t\t\\\n\t\t\t\t\t    \"Out-of-range conf value\",\t\\\n\t\t\t\t\t    k, klen, v, vlen);\t\t\\\n\t\t\t\t} else {\t\t\t\t\\\n\t\t\t\t\to = l;\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\\\n\t\t\t\tcontinue;\t\t\t\t\\\n\t\t\t}\n#define CONF_HANDLE_CHAR_P(o, n, d)\t\t\t\t\t\\\n\t\t\tif (CONF_MATCH(n)) {\t\t\t\t\\\n\t\t\t\tsize_t cpylen = (vlen <=\t\t\\\n\t\t\t\t    sizeof(o)-1) ? vlen :\t\t\\\n\t\t\t\t    sizeof(o)-1;\t\t\t\\\n\t\t\t\tstrncpy(o, v, cpylen);\t\t\t\\\n\t\t\t\to[cpylen] = '\\0';\t\t\t\\\n\t\t\t\tcontinue;\t\t\t\t\\\n\t\t\t}\n\n\t\t\tCONF_HANDLE_BOOL(opt_abort, \"abort\")\n\t\t\tCONF_HANDLE_BOOL(opt_abort_conf, \"abort_conf\")\n\t\t\tif (strncmp(\"metadata_thp\", k, klen) == 0) {\n\t\t\t\tint i;\n\t\t\t\tbool match = false;\n\t\t\t\tfor (i = 0; i < metadata_thp_mode_limit; i++) {\n\t\t\t\t\tif (strncmp(metadata_thp_mode_names[i],\n\t\t\t\t\t    v, vlen) == 0) {\n\t\t\t\t\t\topt_metadata_thp = i;\n\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!match) {\n\t\t\t\t\tmalloc_conf_error(\"Invalid conf value\",\n\t\t\t\t\t    k, klen, v, vlen);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCONF_HANDLE_BOOL(opt_retain, \"retain\")\n\t\t\tif (strncmp(\"dss\", k, klen) == 0) {\n\t\t\t\tint i;\n\t\t\t\tbool match = false;\n\t\t\t\tfor (i = 0; i < dss_prec_limit; i++) {\n\t\t\t\t\tif (strncmp(dss_prec_names[i], v, vlen)\n\t\t\t\t\t    == 0) {\n\t\t\t\t\t\tif (extent_dss_prec_set(i)) {\n\t\t\t\t\t\t\tmalloc_conf_error(\n\t\t\t\t\t\t\t    \"Error setting dss\",\n\t\t\t\t\t\t\t    k, klen, v, vlen);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\topt_dss =\n\t\t\t\t\t\t\t    dss_prec_names[i];\n\t\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!match) {\n\t\t\t\t\tmalloc_conf_error(\"Invalid conf value\",\n\t\t\t\t\t    k, klen, v, vlen);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCONF_HANDLE_UNSIGNED(opt_narenas, \"narenas\", 1,\n\t\t\t    UINT_MAX, yes, no, false)\n\t\t\tCONF_HANDLE_SSIZE_T(opt_dirty_decay_ms,\n\t\t\t    \"dirty_decay_ms\", -1, NSTIME_SEC_MAX * KQU(1000) <\n\t\t\t    QU(SSIZE_MAX) ? NSTIME_SEC_MAX * KQU(1000) :\n\t\t\t    SSIZE_MAX);\n\t\t\tCONF_HANDLE_SSIZE_T(opt_muzzy_decay_ms,\n\t\t\t    \"muzzy_decay_ms\", -1, NSTIME_SEC_MAX * KQU(1000) <\n\t\t\t    QU(SSIZE_MAX) ? NSTIME_SEC_MAX * KQU(1000) :\n\t\t\t    SSIZE_MAX);\n\t\t\tCONF_HANDLE_BOOL(opt_stats_print, \"stats_print\")\n\t\t\tif (CONF_MATCH(\"stats_print_opts\")) {\n\t\t\t\tinit_opt_stats_print_opts(v, vlen);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (config_fill) {\n\t\t\t\tif (CONF_MATCH(\"junk\")) {\n\t\t\t\t\tif (CONF_MATCH_VALUE(\"true\")) {\n\t\t\t\t\t\topt_junk = \"true\";\n\t\t\t\t\t\topt_junk_alloc = opt_junk_free =\n\t\t\t\t\t\t    true;\n\t\t\t\t\t} else if (CONF_MATCH_VALUE(\"false\")) {\n\t\t\t\t\t\topt_junk = \"false\";\n\t\t\t\t\t\topt_junk_alloc = opt_junk_free =\n\t\t\t\t\t\t    false;\n\t\t\t\t\t} else if (CONF_MATCH_VALUE(\"alloc\")) {\n\t\t\t\t\t\topt_junk = \"alloc\";\n\t\t\t\t\t\topt_junk_alloc = true;\n\t\t\t\t\t\topt_junk_free = false;\n\t\t\t\t\t} else if (CONF_MATCH_VALUE(\"free\")) {\n\t\t\t\t\t\topt_junk = \"free\";\n\t\t\t\t\t\topt_junk_alloc = false;\n\t\t\t\t\t\topt_junk_free = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmalloc_conf_error(\n\t\t\t\t\t\t    \"Invalid conf value\", k,\n\t\t\t\t\t\t    klen, v, vlen);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tCONF_HANDLE_BOOL(opt_zero, \"zero\")\n\t\t\t}\n\t\t\tif (config_utrace) {\n\t\t\t\tCONF_HANDLE_BOOL(opt_utrace, \"utrace\")\n\t\t\t}\n\t\t\tif (config_xmalloc) {\n\t\t\t\tCONF_HANDLE_BOOL(opt_xmalloc, \"xmalloc\")\n\t\t\t}\n\t\t\tCONF_HANDLE_BOOL(opt_tcache, \"tcache\")\n\t\t\tCONF_HANDLE_SIZE_T(opt_lg_extent_max_active_fit,\n\t\t\t    \"lg_extent_max_active_fit\", 0,\n\t\t\t    (sizeof(size_t) << 3), yes, yes, false)\n\t\t\tCONF_HANDLE_SSIZE_T(opt_lg_tcache_max, \"lg_tcache_max\",\n\t\t\t    -1, (sizeof(size_t) << 3) - 1)\n\t\t\tif (strncmp(\"percpu_arena\", k, klen) == 0) {\n\t\t\t\tbool match = false;\n\t\t\t\tfor (int i = percpu_arena_mode_names_base; i <\n\t\t\t\t    percpu_arena_mode_names_limit; i++) {\n\t\t\t\t\tif (strncmp(percpu_arena_mode_names[i],\n\t\t\t\t\t    v, vlen) == 0) {\n\t\t\t\t\t\tif (!have_percpu_arena) {\n\t\t\t\t\t\t\tmalloc_conf_error(\n\t\t\t\t\t\t\t    \"No getcpu support\",\n\t\t\t\t\t\t\t    k, klen, v, vlen);\n\t\t\t\t\t\t}\n\t\t\t\t\t\topt_percpu_arena = i;\n\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!match) {\n\t\t\t\t\tmalloc_conf_error(\"Invalid conf value\",\n\t\t\t\t\t    k, klen, v, vlen);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCONF_HANDLE_BOOL(opt_background_thread,\n\t\t\t    \"background_thread\");\n\t\t\tCONF_HANDLE_SIZE_T(opt_max_background_threads,\n\t\t\t\t\t   \"max_background_threads\", 1,\n\t\t\t\t\t   opt_max_background_threads, yes, yes,\n\t\t\t\t\t   true);\n\t\t\tif (config_prof) {\n\t\t\t\tCONF_HANDLE_BOOL(opt_prof, \"prof\")\n\t\t\t\tCONF_HANDLE_CHAR_P(opt_prof_prefix,\n\t\t\t\t    \"prof_prefix\", \"jeprof\")\n\t\t\t\tCONF_HANDLE_BOOL(opt_prof_active, \"prof_active\")\n\t\t\t\tCONF_HANDLE_BOOL(opt_prof_thread_active_init,\n\t\t\t\t    \"prof_thread_active_init\")\n\t\t\t\tCONF_HANDLE_SIZE_T(opt_lg_prof_sample,\n\t\t\t\t    \"lg_prof_sample\", 0, (sizeof(uint64_t) << 3)\n\t\t\t\t    - 1, no, yes, true)\n\t\t\t\tCONF_HANDLE_BOOL(opt_prof_accum, \"prof_accum\")\n\t\t\t\tCONF_HANDLE_SSIZE_T(opt_lg_prof_interval,\n\t\t\t\t    \"lg_prof_interval\", -1,\n\t\t\t\t    (sizeof(uint64_t) << 3) - 1)\n\t\t\t\tCONF_HANDLE_BOOL(opt_prof_gdump, \"prof_gdump\")\n\t\t\t\tCONF_HANDLE_BOOL(opt_prof_final, \"prof_final\")\n\t\t\t\tCONF_HANDLE_BOOL(opt_prof_leak, \"prof_leak\")\n\t\t\t}\n\t\t\tif (config_log) {\n\t\t\t\tif (CONF_MATCH(\"log\")) {\n\t\t\t\t\tsize_t cpylen = (\n\t\t\t\t\t    vlen <= sizeof(log_var_names) ?\n\t\t\t\t\t    vlen : sizeof(log_var_names) - 1);\n\t\t\t\t\tstrncpy(log_var_names, v, cpylen);\n\t\t\t\t\tlog_var_names[cpylen] = '\\0';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (CONF_MATCH(\"thp\")) {\n\t\t\t\tbool match = false;\n\t\t\t\tfor (int i = 0; i < thp_mode_names_limit; i++) {\n\t\t\t\t\tif (strncmp(thp_mode_names[i],v, vlen)\n\t\t\t\t\t    == 0) {\n\t\t\t\t\t\tif (!have_madvise_huge) {\n\t\t\t\t\t\t\tmalloc_conf_error(\n\t\t\t\t\t\t\t    \"No THP support\",\n\t\t\t\t\t\t\t    k, klen, v, vlen);\n\t\t\t\t\t\t}\n\t\t\t\t\t\topt_thp = i;\n\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!match) {\n\t\t\t\t\tmalloc_conf_error(\"Invalid conf value\",\n\t\t\t\t\t    k, klen, v, vlen);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmalloc_conf_error(\"Invalid conf pair\", k, klen, v,\n\t\t\t    vlen);\n#undef CONF_MATCH\n#undef CONF_MATCH_VALUE\n#undef CONF_HANDLE_BOOL\n#undef CONF_MIN_no\n#undef CONF_MIN_yes\n#undef CONF_MAX_no\n#undef CONF_MAX_yes\n#undef CONF_HANDLE_T_U\n#undef CONF_HANDLE_UNSIGNED\n#undef CONF_HANDLE_SIZE_T\n#undef CONF_HANDLE_SSIZE_T\n#undef CONF_HANDLE_CHAR_P\n\t\t}\n\t\tif (opt_abort_conf && had_conf_error) {\n\t\t\tmalloc_abort_invalid_conf();\n\t\t}\n\t}\n\tatomic_store_b(&log_init_done, true, ATOMIC_RELEASE);\n}\n\nstatic bool\nmalloc_init_hard_needed(void) {\n\tif (malloc_initialized() || (IS_INITIALIZER && malloc_init_state ==\n\t    malloc_init_recursible)) {\n\t\t/*\n\t\t * Another thread initialized the allocator before this one\n\t\t * acquired init_lock, or this thread is the initializing\n\t\t * thread, and it is recursively allocating.\n\t\t */\n\t\treturn false;\n\t}\n#ifdef JEMALLOC_THREADED_INIT\n\tif (malloc_initializer != NO_INITIALIZER && !IS_INITIALIZER) {\n\t\t/* Busy-wait until the initializing thread completes. */\n\t\tspin_t spinner = SPIN_INITIALIZER;\n\t\tdo {\n\t\t\tmalloc_mutex_unlock(TSDN_NULL, &init_lock);\n\t\t\tspin_adaptive(&spinner);\n\t\t\tmalloc_mutex_lock(TSDN_NULL, &init_lock);\n\t\t} while (!malloc_initialized());\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}\n\nstatic bool\nmalloc_init_hard_a0_locked() {\n\tmalloc_initializer = INITIALIZER;\n\n\tif (config_prof) {\n\t\tprof_boot0();\n\t}\n\tmalloc_conf_init();\n\tif (opt_stats_print) {\n\t\t/* Print statistics at exit. */\n\t\tif (atexit(stats_print_atexit) != 0) {\n\t\t\tmalloc_write(\"<jemalloc>: Error in atexit()\\n\");\n\t\t\tif (opt_abort) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t}\n\t}\n\tif (pages_boot()) {\n\t\treturn true;\n\t}\n\tif (base_boot(TSDN_NULL)) {\n\t\treturn true;\n\t}\n\tif (extent_boot()) {\n\t\treturn true;\n\t}\n\tif (ctl_boot()) {\n\t\treturn true;\n\t}\n\tif (config_prof) {\n\t\tprof_boot1();\n\t}\n\tarena_boot();\n\tif (tcache_boot(TSDN_NULL)) {\n\t\treturn true;\n\t}\n\tif (malloc_mutex_init(&arenas_lock, \"arenas\", WITNESS_RANK_ARENAS,\n\t    malloc_mutex_rank_exclusive)) {\n\t\treturn true;\n\t}\n\t/*\n\t * Create enough scaffolding to allow recursive allocation in\n\t * malloc_ncpus().\n\t */\n\tnarenas_auto = 1;\n\tmemset(arenas, 0, sizeof(arena_t *) * narenas_auto);\n\t/*\n\t * Initialize one arena here.  The rest are lazily created in\n\t * arena_choose_hard().\n\t */\n\tif (arena_init(TSDN_NULL, 0, (extent_hooks_t *)&extent_hooks_default)\n\t    == NULL) {\n\t\treturn true;\n\t}\n\ta0 = arena_get(TSDN_NULL, 0, false);\n\tmalloc_init_state = malloc_init_a0_initialized;\n\n\treturn false;\n}\n\nstatic bool\nmalloc_init_hard_a0(void) {\n\tbool ret;\n\n\tmalloc_mutex_lock(TSDN_NULL, &init_lock);\n\tret = malloc_init_hard_a0_locked();\n\tmalloc_mutex_unlock(TSDN_NULL, &init_lock);\n\treturn ret;\n}\n\n/* Initialize data structures which may trigger recursive allocation. */\nstatic bool\nmalloc_init_hard_recursible(void) {\n\tmalloc_init_state = malloc_init_recursible;\n\n\tncpus = malloc_ncpus();\n\n#if (defined(JEMALLOC_HAVE_PTHREAD_ATFORK) && !defined(JEMALLOC_MUTEX_INIT_CB) \\\n    && !defined(JEMALLOC_ZONE) && !defined(_WIN32) && \\\n    !defined(__native_client__))\n\t/* LinuxThreads' pthread_atfork() allocates. */\n\tif (pthread_atfork(jemalloc_prefork, jemalloc_postfork_parent,\n\t    jemalloc_postfork_child) != 0) {\n\t\tmalloc_write(\"<jemalloc>: Error in pthread_atfork()\\n\");\n\t\tif (opt_abort) {\n\t\t\tabort();\n\t\t}\n\t\treturn true;\n\t}\n#endif\n\n\tif (background_thread_boot0()) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic unsigned\nmalloc_narenas_default(void) {\n\tassert(ncpus > 0);\n\t/*\n\t * For SMP systems, create more than one arena per CPU by\n\t * default.\n\t */\n\tif (ncpus > 1) {\n\t\treturn ncpus << 2;\n\t} else {\n\t\treturn 1;\n\t}\n}\n\nstatic percpu_arena_mode_t\npercpu_arena_as_initialized(percpu_arena_mode_t mode) {\n\tassert(!malloc_initialized());\n\tassert(mode <= percpu_arena_disabled);\n\n\tif (mode != percpu_arena_disabled) {\n\t\tmode += percpu_arena_mode_enabled_base;\n\t}\n\n\treturn mode;\n}\n\nstatic bool\nmalloc_init_narenas(void) {\n\tassert(ncpus > 0);\n\n\tif (opt_percpu_arena != percpu_arena_disabled) {\n\t\tif (!have_percpu_arena || malloc_getcpu() < 0) {\n\t\t\topt_percpu_arena = percpu_arena_disabled;\n\t\t\tmalloc_printf(\"<jemalloc>: perCPU arena getcpu() not \"\n\t\t\t    \"available. Setting narenas to %u.\\n\", opt_narenas ?\n\t\t\t    opt_narenas : malloc_narenas_default());\n\t\t\tif (opt_abort) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t} else {\n\t\t\tif (ncpus >= MALLOCX_ARENA_LIMIT) {\n\t\t\t\tmalloc_printf(\"<jemalloc>: narenas w/ percpu\"\n\t\t\t\t    \"arena beyond limit (%d)\\n\", ncpus);\n\t\t\t\tif (opt_abort) {\n\t\t\t\t\tabort();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t/* NB: opt_percpu_arena isn't fully initialized yet. */\n\t\t\tif (percpu_arena_as_initialized(opt_percpu_arena) ==\n\t\t\t    per_phycpu_arena && ncpus % 2 != 0) {\n\t\t\t\tmalloc_printf(\"<jemalloc>: invalid \"\n\t\t\t\t    \"configuration -- per physical CPU arena \"\n\t\t\t\t    \"with odd number (%u) of CPUs (no hyper \"\n\t\t\t\t    \"threading?).\\n\", ncpus);\n\t\t\t\tif (opt_abort)\n\t\t\t\t\tabort();\n\t\t\t}\n\t\t\tunsigned n = percpu_arena_ind_limit(\n\t\t\t    percpu_arena_as_initialized(opt_percpu_arena));\n\t\t\tif (opt_narenas < n) {\n\t\t\t\t/*\n\t\t\t\t * If narenas is specified with percpu_arena\n\t\t\t\t * enabled, actual narenas is set as the greater\n\t\t\t\t * of the two. percpu_arena_choose will be free\n\t\t\t\t * to use any of the arenas based on CPU\n\t\t\t\t * id. This is conservative (at a small cost)\n\t\t\t\t * but ensures correctness.\n\t\t\t\t *\n\t\t\t\t * If for some reason the ncpus determined at\n\t\t\t\t * boot is not the actual number (e.g. because\n\t\t\t\t * of affinity setting from numactl), reserving\n\t\t\t\t * narenas this way provides a workaround for\n\t\t\t\t * percpu_arena.\n\t\t\t\t */\n\t\t\t\topt_narenas = n;\n\t\t\t}\n\t\t}\n\t}\n\tif (opt_narenas == 0) {\n\t\topt_narenas = malloc_narenas_default();\n\t}\n\tassert(opt_narenas > 0);\n\n\tnarenas_auto = opt_narenas;\n\t/*\n\t * Limit the number of arenas to the indexing range of MALLOCX_ARENA().\n\t */\n\tif (narenas_auto >= MALLOCX_ARENA_LIMIT) {\n\t\tnarenas_auto = MALLOCX_ARENA_LIMIT - 1;\n\t\tmalloc_printf(\"<jemalloc>: Reducing narenas to limit (%d)\\n\",\n\t\t    narenas_auto);\n\t}\n\tnarenas_total_set(narenas_auto);\n\n\treturn false;\n}\n\nstatic void\nmalloc_init_percpu(void) {\n\topt_percpu_arena = percpu_arena_as_initialized(opt_percpu_arena);\n}\n\nstatic bool\nmalloc_init_hard_finish(void) {\n\tif (malloc_mutex_boot()) {\n\t\treturn true;\n\t}\n\n\tmalloc_init_state = malloc_init_initialized;\n\tmalloc_slow_flag_init();\n\n\treturn false;\n}\n\nstatic void\nmalloc_init_hard_cleanup(tsdn_t *tsdn, bool reentrancy_set) {\n\tmalloc_mutex_assert_owner(tsdn, &init_lock);\n\tmalloc_mutex_unlock(tsdn, &init_lock);\n\tif (reentrancy_set) {\n\t\tassert(!tsdn_null(tsdn));\n\t\ttsd_t *tsd = tsdn_tsd(tsdn);\n\t\tassert(tsd_reentrancy_level_get(tsd) > 0);\n\t\tpost_reentrancy(tsd);\n\t}\n}\n\nstatic bool\nmalloc_init_hard(void) {\n\ttsd_t *tsd;\n\n#if defined(_WIN32) && _WIN32_WINNT < 0x0600\n\t_init_init_lock();\n#endif\n\tmalloc_mutex_lock(TSDN_NULL, &init_lock);\n\n#define UNLOCK_RETURN(tsdn, ret, reentrancy)\t\t\\\n\tmalloc_init_hard_cleanup(tsdn, reentrancy);\t\\\n\treturn ret;\n\n\tif (!malloc_init_hard_needed()) {\n\t\tUNLOCK_RETURN(TSDN_NULL, false, false)\n\t}\n\n\tif (malloc_init_state != malloc_init_a0_initialized &&\n\t    malloc_init_hard_a0_locked()) {\n\t\tUNLOCK_RETURN(TSDN_NULL, true, false)\n\t}\n\n\tmalloc_mutex_unlock(TSDN_NULL, &init_lock);\n\t/* Recursive allocation relies on functional tsd. */\n\ttsd = malloc_tsd_boot0();\n\tif (tsd == NULL) {\n\t\treturn true;\n\t}\n\tif (malloc_init_hard_recursible()) {\n\t\treturn true;\n\t}\n\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &init_lock);\n\t/* Set reentrancy level to 1 during init. */\n\tpre_reentrancy(tsd, NULL);\n\t/* Initialize narenas before prof_boot2 (for allocation). */\n\tif (malloc_init_narenas() || background_thread_boot1(tsd_tsdn(tsd))) {\n\t\tUNLOCK_RETURN(tsd_tsdn(tsd), true, true)\n\t}\n\tif (config_prof && prof_boot2(tsd)) {\n\t\tUNLOCK_RETURN(tsd_tsdn(tsd), true, true)\n\t}\n\n\tmalloc_init_percpu();\n\n\tif (malloc_init_hard_finish()) {\n\t\tUNLOCK_RETURN(tsd_tsdn(tsd), true, true)\n\t}\n\tpost_reentrancy(tsd);\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &init_lock);\n\n\twitness_assert_lockless(witness_tsd_tsdn(\n\t    tsd_witness_tsdp_get_unsafe(tsd)));\n\tmalloc_tsd_boot1();\n\t/* Update TSD after tsd_boot1. */\n\ttsd = tsd_fetch();\n\tif (opt_background_thread) {\n\t\tassert(have_background_thread);\n\t\t/*\n\t\t * Need to finish init & unlock first before creating background\n\t\t * threads (pthread_create depends on malloc).  ctl_init (which\n\t\t * sets isthreaded) needs to be called without holding any lock.\n\t\t */\n\t\tbackground_thread_ctl_init(tsd_tsdn(tsd));\n\n\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &background_thread_lock);\n\t\tbool err = background_thread_create(tsd, 0);\n\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &background_thread_lock);\n\t\tif (err) {\n\t\t\treturn true;\n\t\t}\n\t}\n#undef UNLOCK_RETURN\n\treturn false;\n}\n\n/*\n * End initialization functions.\n */\n/******************************************************************************/\n/*\n * Begin allocation-path internal functions and data structures.\n */\n\n/*\n * Settings determined by the documented behavior of the allocation functions.\n */\ntypedef struct static_opts_s static_opts_t;\nstruct static_opts_s {\n\t/* Whether or not allocation size may overflow. */\n\tbool may_overflow;\n\t/* Whether or not allocations of size 0 should be treated as size 1. */\n\tbool bump_empty_alloc;\n\t/*\n\t * Whether to assert that allocations are not of size 0 (after any\n\t * bumping).\n\t */\n\tbool assert_nonempty_alloc;\n\n\t/*\n\t * Whether or not to modify the 'result' argument to malloc in case of\n\t * error.\n\t */\n\tbool null_out_result_on_error;\n\t/* Whether to set errno when we encounter an error condition. */\n\tbool set_errno_on_error;\n\n\t/*\n\t * The minimum valid alignment for functions requesting aligned storage.\n\t */\n\tsize_t min_alignment;\n\n\t/* The error string to use if we oom. */\n\tconst char *oom_string;\n\t/* The error string to use if the passed-in alignment is invalid. */\n\tconst char *invalid_alignment_string;\n\n\t/*\n\t * False if we're configured to skip some time-consuming operations.\n\t *\n\t * This isn't really a malloc \"behavior\", but it acts as a useful\n\t * summary of several other static (or at least, static after program\n\t * initialization) options.\n\t */\n\tbool slow;\n};\n\nJEMALLOC_ALWAYS_INLINE void\nstatic_opts_init(static_opts_t *static_opts) {\n\tstatic_opts->may_overflow = false;\n\tstatic_opts->bump_empty_alloc = false;\n\tstatic_opts->assert_nonempty_alloc = false;\n\tstatic_opts->null_out_result_on_error = false;\n\tstatic_opts->set_errno_on_error = false;\n\tstatic_opts->min_alignment = 0;\n\tstatic_opts->oom_string = \"\";\n\tstatic_opts->invalid_alignment_string = \"\";\n\tstatic_opts->slow = false;\n}\n\n/*\n * These correspond to the macros in jemalloc/jemalloc_macros.h.  Broadly, we\n * should have one constant here per magic value there.  Note however that the\n * representations need not be related.\n */\n#define TCACHE_IND_NONE ((unsigned)-1)\n#define TCACHE_IND_AUTOMATIC ((unsigned)-2)\n#define ARENA_IND_AUTOMATIC ((unsigned)-1)\n\ntypedef struct dynamic_opts_s dynamic_opts_t;\nstruct dynamic_opts_s {\n\tvoid **result;\n\tsize_t num_items;\n\tsize_t item_size;\n\tsize_t alignment;\n\tbool zero;\n\tunsigned tcache_ind;\n\tunsigned arena_ind;\n};\n\nJEMALLOC_ALWAYS_INLINE void\ndynamic_opts_init(dynamic_opts_t *dynamic_opts) {\n\tdynamic_opts->result = NULL;\n\tdynamic_opts->num_items = 0;\n\tdynamic_opts->item_size = 0;\n\tdynamic_opts->alignment = 0;\n\tdynamic_opts->zero = false;\n\tdynamic_opts->tcache_ind = TCACHE_IND_AUTOMATIC;\n\tdynamic_opts->arena_ind = ARENA_IND_AUTOMATIC;\n}\n\n/* ind is ignored if dopts->alignment > 0. */\nJEMALLOC_ALWAYS_INLINE void *\nimalloc_no_sample(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd,\n    size_t size, size_t usize, szind_t ind) {\n\ttcache_t *tcache;\n\tarena_t *arena;\n\n\t/* Fill in the tcache. */\n\tif (dopts->tcache_ind == TCACHE_IND_AUTOMATIC) {\n\t\tif (likely(!sopts->slow)) {\n\t\t\t/* Getting tcache ptr unconditionally. */\n\t\t\ttcache = tsd_tcachep_get(tsd);\n\t\t\tassert(tcache == tcache_get(tsd));\n\t\t} else {\n\t\t\ttcache = tcache_get(tsd);\n\t\t}\n\t} else if (dopts->tcache_ind == TCACHE_IND_NONE) {\n\t\ttcache = NULL;\n\t} else {\n\t\ttcache = tcaches_get(tsd, dopts->tcache_ind);\n\t}\n\n\t/* Fill in the arena. */\n\tif (dopts->arena_ind == ARENA_IND_AUTOMATIC) {\n\t\t/*\n\t\t * In case of automatic arena management, we defer arena\n\t\t * computation until as late as we can, hoping to fill the\n\t\t * allocation out of the tcache.\n\t\t */\n\t\tarena = NULL;\n\t} else {\n\t\tarena = arena_get(tsd_tsdn(tsd), dopts->arena_ind, true);\n\t}\n\n\tif (unlikely(dopts->alignment != 0)) {\n\t\treturn ipalloct(tsd_tsdn(tsd), usize, dopts->alignment,\n\t\t    dopts->zero, tcache, arena);\n\t}\n\n\treturn iallocztm(tsd_tsdn(tsd), size, ind, dopts->zero, tcache, false,\n\t    arena, sopts->slow);\n}\n\nJEMALLOC_ALWAYS_INLINE void *\nimalloc_sample(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd,\n    size_t usize, szind_t ind) {\n\tvoid *ret;\n\n\t/*\n\t * For small allocations, sampling bumps the usize.  If so, we allocate\n\t * from the ind_large bucket.\n\t */\n\tszind_t ind_large;\n\tsize_t bumped_usize = usize;\n\n\tif (usize <= SMALL_MAXCLASS) {\n\t\tassert(((dopts->alignment == 0) ? sz_s2u(LARGE_MINCLASS) :\n\t\t    sz_sa2u(LARGE_MINCLASS, dopts->alignment))\n\t\t    == LARGE_MINCLASS);\n\t\tind_large = sz_size2index(LARGE_MINCLASS);\n\t\tbumped_usize = sz_s2u(LARGE_MINCLASS);\n\t\tret = imalloc_no_sample(sopts, dopts, tsd, bumped_usize,\n\t\t    bumped_usize, ind_large);\n\t\tif (unlikely(ret == NULL)) {\n\t\t\treturn NULL;\n\t\t}\n\t\tarena_prof_promote(tsd_tsdn(tsd), ret, usize);\n\t} else {\n\t\tret = imalloc_no_sample(sopts, dopts, tsd, usize, usize, ind);\n\t}\n\n\treturn ret;\n}\n\n/*\n * Returns true if the allocation will overflow, and false otherwise.  Sets\n * *size to the product either way.\n */\nJEMALLOC_ALWAYS_INLINE bool\ncompute_size_with_overflow(bool may_overflow, dynamic_opts_t *dopts,\n    size_t *size) {\n\t/*\n\t * This function is just num_items * item_size, except that we may have\n\t * to check for overflow.\n\t */\n\n\tif (!may_overflow) {\n\t\tassert(dopts->num_items == 1);\n\t\t*size = dopts->item_size;\n\t\treturn false;\n\t}\n\n\t/* A size_t with its high-half bits all set to 1. */\n\tstatic const size_t high_bits = SIZE_T_MAX << (sizeof(size_t) * 8 / 2);\n\n\t*size = dopts->item_size * dopts->num_items;\n\n\tif (unlikely(*size == 0)) {\n\t\treturn (dopts->num_items != 0 && dopts->item_size != 0);\n\t}\n\n\t/*\n\t * We got a non-zero size, but we don't know if we overflowed to get\n\t * there.  To avoid having to do a divide, we'll be clever and note that\n\t * if both A and B can be represented in N/2 bits, then their product\n\t * can be represented in N bits (without the possibility of overflow).\n\t */\n\tif (likely((high_bits & (dopts->num_items | dopts->item_size)) == 0)) {\n\t\treturn false;\n\t}\n\tif (likely(*size / dopts->item_size == dopts->num_items)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nJEMALLOC_ALWAYS_INLINE int\nimalloc_body(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd) {\n\t/* Where the actual allocated memory will live. */\n\tvoid *allocation = NULL;\n\t/* Filled in by compute_size_with_overflow below. */\n\tsize_t size = 0;\n\t/*\n\t * For unaligned allocations, we need only ind.  For aligned\n\t * allocations, or in case of stats or profiling we need usize.\n\t *\n\t * These are actually dead stores, in that their values are reset before\n\t * any branch on their value is taken.  Sometimes though, it's\n\t * convenient to pass them as arguments before this point.  To avoid\n\t * undefined behavior then, we initialize them with dummy stores.\n\t */\n\tszind_t ind = 0;\n\tsize_t usize = 0;\n\n\t/* Reentrancy is only checked on slow path. */\n\tint8_t reentrancy_level;\n\n\t/* Compute the amount of memory the user wants. */\n\tif (unlikely(compute_size_with_overflow(sopts->may_overflow, dopts,\n\t    &size))) {\n\t\tgoto label_oom;\n\t}\n\n\t/* Validate the user input. */\n\tif (sopts->bump_empty_alloc) {\n\t\tif (unlikely(size == 0)) {\n\t\t\tsize = 1;\n\t\t}\n\t}\n\n\tif (sopts->assert_nonempty_alloc) {\n\t\tassert (size != 0);\n\t}\n\n\tif (unlikely(dopts->alignment < sopts->min_alignment\n\t    || (dopts->alignment & (dopts->alignment - 1)) != 0)) {\n\t\tgoto label_invalid_alignment;\n\t}\n\n\t/* This is the beginning of the \"core\" algorithm. */\n\n\tif (dopts->alignment == 0) {\n\t\tind = sz_size2index(size);\n\t\tif (unlikely(ind >= NSIZES)) {\n\t\t\tgoto label_oom;\n\t\t}\n\t\tif (config_stats || (config_prof && opt_prof)) {\n\t\t\tusize = sz_index2size(ind);\n\t\t\tassert(usize > 0 && usize <= LARGE_MAXCLASS);\n\t\t}\n\t} else {\n\t\tusize = sz_sa2u(size, dopts->alignment);\n\t\tif (unlikely(usize == 0 || usize > LARGE_MAXCLASS)) {\n\t\t\tgoto label_oom;\n\t\t}\n\t}\n\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\t/*\n\t * If we need to handle reentrancy, we can do it out of a\n\t * known-initialized arena (i.e. arena 0).\n\t */\n\treentrancy_level = tsd_reentrancy_level_get(tsd);\n\tif (sopts->slow && unlikely(reentrancy_level > 0)) {\n\t\t/*\n\t\t * We should never specify particular arenas or tcaches from\n\t\t * within our internal allocations.\n\t\t */\n\t\tassert(dopts->tcache_ind == TCACHE_IND_AUTOMATIC ||\n\t\t    dopts->tcache_ind == TCACHE_IND_NONE);\n\t\tassert(dopts->arena_ind == ARENA_IND_AUTOMATIC);\n\t\tdopts->tcache_ind = TCACHE_IND_NONE;\n\t\t/* We know that arena 0 has already been initialized. */\n\t\tdopts->arena_ind = 0;\n\t}\n\n\t/* If profiling is on, get our profiling context. */\n\tif (config_prof && opt_prof) {\n\t\t/*\n\t\t * Note that if we're going down this path, usize must have been\n\t\t * initialized in the previous if statement.\n\t\t */\n\t\tprof_tctx_t *tctx = prof_alloc_prep(\n\t\t    tsd, usize, prof_active_get_unlocked(), true);\n\n\t\talloc_ctx_t alloc_ctx;\n\t\tif (likely((uintptr_t)tctx == (uintptr_t)1U)) {\n\t\t\talloc_ctx.slab = (usize <= SMALL_MAXCLASS);\n\t\t\tallocation = imalloc_no_sample(\n\t\t\t    sopts, dopts, tsd, usize, usize, ind);\n\t\t} else if ((uintptr_t)tctx > (uintptr_t)1U) {\n\t\t\t/*\n\t\t\t * Note that ind might still be 0 here.  This is fine;\n\t\t\t * imalloc_sample ignores ind if dopts->alignment > 0.\n\t\t\t */\n\t\t\tallocation = imalloc_sample(\n\t\t\t    sopts, dopts, tsd, usize, ind);\n\t\t\talloc_ctx.slab = false;\n\t\t} else {\n\t\t\tallocation = NULL;\n\t\t}\n\n\t\tif (unlikely(allocation == NULL)) {\n\t\t\tprof_alloc_rollback(tsd, tctx, true);\n\t\t\tgoto label_oom;\n\t\t}\n\t\tprof_malloc(tsd_tsdn(tsd), allocation, usize, &alloc_ctx, tctx);\n\t} else {\n\t\t/*\n\t\t * If dopts->alignment > 0, then ind is still 0, but usize was\n\t\t * computed in the previous if statement.  Down the positive\n\t\t * alignment path, imalloc_no_sample ignores ind and size\n\t\t * (relying only on usize).\n\t\t */\n\t\tallocation = imalloc_no_sample(sopts, dopts, tsd, size, usize,\n\t\t    ind);\n\t\tif (unlikely(allocation == NULL)) {\n\t\t\tgoto label_oom;\n\t\t}\n\t}\n\n\t/*\n\t * Allocation has been done at this point.  We still have some\n\t * post-allocation work to do though.\n\t */\n\tassert(dopts->alignment == 0\n\t    || ((uintptr_t)allocation & (dopts->alignment - 1)) == ZU(0));\n\n\tif (config_stats) {\n\t\tassert(usize == isalloc(tsd_tsdn(tsd), allocation));\n\t\t*tsd_thread_allocatedp_get(tsd) += usize;\n\t}\n\n\tif (sopts->slow) {\n\t\tUTRACE(0, size, allocation);\n\t}\n\n\t/* Success! */\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\t*dopts->result = allocation;\n\treturn 0;\n\nlabel_oom:\n\tif (unlikely(sopts->slow) && config_xmalloc && unlikely(opt_xmalloc)) {\n\t\tmalloc_write(sopts->oom_string);\n\t\tabort();\n\t}\n\n\tif (sopts->slow) {\n\t\tUTRACE(NULL, size, NULL);\n\t}\n\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\tif (sopts->set_errno_on_error) {\n\t\tset_errno(ENOMEM);\n\t}\n\n\tif (sopts->null_out_result_on_error) {\n\t\t*dopts->result = NULL;\n\t}\n\n\treturn ENOMEM;\n\n\t/*\n\t * This label is only jumped to by one goto; we move it out of line\n\t * anyways to avoid obscuring the non-error paths, and for symmetry with\n\t * the oom case.\n\t */\nlabel_invalid_alignment:\n\tif (config_xmalloc && unlikely(opt_xmalloc)) {\n\t\tmalloc_write(sopts->invalid_alignment_string);\n\t\tabort();\n\t}\n\n\tif (sopts->set_errno_on_error) {\n\t\tset_errno(EINVAL);\n\t}\n\n\tif (sopts->slow) {\n\t\tUTRACE(NULL, size, NULL);\n\t}\n\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\tif (sopts->null_out_result_on_error) {\n\t\t*dopts->result = NULL;\n\t}\n\n\treturn EINVAL;\n}\n\n/* Returns the errno-style error code of the allocation. */\nJEMALLOC_ALWAYS_INLINE int\nimalloc(static_opts_t *sopts, dynamic_opts_t *dopts) {\n\tif (unlikely(!malloc_initialized()) && unlikely(malloc_init())) {\n\t\tif (config_xmalloc && unlikely(opt_xmalloc)) {\n\t\t\tmalloc_write(sopts->oom_string);\n\t\t\tabort();\n\t\t}\n\t\tUTRACE(NULL, dopts->num_items * dopts->item_size, NULL);\n\t\tset_errno(ENOMEM);\n\t\t*dopts->result = NULL;\n\n\t\treturn ENOMEM;\n\t}\n\n\t/* We always need the tsd.  Let's grab it right away. */\n\ttsd_t *tsd = tsd_fetch();\n\tassert(tsd);\n\tif (likely(tsd_fast(tsd))) {\n\t\t/* Fast and common path. */\n\t\ttsd_assert_fast(tsd);\n\t\tsopts->slow = false;\n\t\treturn imalloc_body(sopts, dopts, tsd);\n\t} else {\n\t\tsopts->slow = true;\n\t\treturn imalloc_body(sopts, dopts, tsd);\n\t}\n}\n/******************************************************************************/\n/*\n * Begin malloc(3)-compatible functions.\n */\n\nJEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN\nvoid JEMALLOC_NOTHROW *\nJEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1)\nje_malloc(size_t size) {\n\tvoid *ret;\n\tstatic_opts_t sopts;\n\tdynamic_opts_t dopts;\n\n\tLOG(\"core.malloc.entry\", \"size: %zu\", size);\n\n\tstatic_opts_init(&sopts);\n\tdynamic_opts_init(&dopts);\n\n\tsopts.bump_empty_alloc = true;\n\tsopts.null_out_result_on_error = true;\n\tsopts.set_errno_on_error = true;\n\tsopts.oom_string = \"<jemalloc>: Error in malloc(): out of memory\\n\";\n\n\tdopts.result = &ret;\n\tdopts.num_items = 1;\n\tdopts.item_size = size;\n\n\timalloc(&sopts, &dopts);\n\n\tLOG(\"core.malloc.exit\", \"result: %p\", ret);\n\n\treturn ret;\n}\n\nJEMALLOC_EXPORT int JEMALLOC_NOTHROW\nJEMALLOC_ATTR(nonnull(1))\nje_posix_memalign(void **memptr, size_t alignment, size_t size) {\n\tint ret;\n\tstatic_opts_t sopts;\n\tdynamic_opts_t dopts;\n\n\tLOG(\"core.posix_memalign.entry\", \"mem ptr: %p, alignment: %zu, \"\n\t    \"size: %zu\", memptr, alignment, size);\n\n\tstatic_opts_init(&sopts);\n\tdynamic_opts_init(&dopts);\n\n\tsopts.bump_empty_alloc = true;\n\tsopts.min_alignment = sizeof(void *);\n\tsopts.oom_string =\n\t    \"<jemalloc>: Error allocating aligned memory: out of memory\\n\";\n\tsopts.invalid_alignment_string =\n\t    \"<jemalloc>: Error allocating aligned memory: invalid alignment\\n\";\n\n\tdopts.result = memptr;\n\tdopts.num_items = 1;\n\tdopts.item_size = size;\n\tdopts.alignment = alignment;\n\n\tret = imalloc(&sopts, &dopts);\n\n\tLOG(\"core.posix_memalign.exit\", \"result: %d, alloc ptr: %p\", ret,\n\t    *memptr);\n\n\treturn ret;\n}\n\nJEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN\nvoid JEMALLOC_NOTHROW *\nJEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(2)\nje_aligned_alloc(size_t alignment, size_t size) {\n\tvoid *ret;\n\n\tstatic_opts_t sopts;\n\tdynamic_opts_t dopts;\n\n\tLOG(\"core.aligned_alloc.entry\", \"alignment: %zu, size: %zu\\n\",\n\t    alignment, size);\n\n\tstatic_opts_init(&sopts);\n\tdynamic_opts_init(&dopts);\n\n\tsopts.bump_empty_alloc = true;\n\tsopts.null_out_result_on_error = true;\n\tsopts.set_errno_on_error = true;\n\tsopts.min_alignment = 1;\n\tsopts.oom_string =\n\t    \"<jemalloc>: Error allocating aligned memory: out of memory\\n\";\n\tsopts.invalid_alignment_string =\n\t    \"<jemalloc>: Error allocating aligned memory: invalid alignment\\n\";\n\n\tdopts.result = &ret;\n\tdopts.num_items = 1;\n\tdopts.item_size = size;\n\tdopts.alignment = alignment;\n\n\timalloc(&sopts, &dopts);\n\n\tLOG(\"core.aligned_alloc.exit\", \"result: %p\", ret);\n\n\treturn ret;\n}\n\nJEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN\nvoid JEMALLOC_NOTHROW *\nJEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE2(1, 2)\nje_calloc(size_t num, size_t size) {\n\tvoid *ret;\n\tstatic_opts_t sopts;\n\tdynamic_opts_t dopts;\n\n\tLOG(\"core.calloc.entry\", \"num: %zu, size: %zu\\n\", num, size);\n\n\tstatic_opts_init(&sopts);\n\tdynamic_opts_init(&dopts);\n\n\tsopts.may_overflow = true;\n\tsopts.bump_empty_alloc = true;\n\tsopts.null_out_result_on_error = true;\n\tsopts.set_errno_on_error = true;\n\tsopts.oom_string = \"<jemalloc>: Error in calloc(): out of memory\\n\";\n\n\tdopts.result = &ret;\n\tdopts.num_items = num;\n\tdopts.item_size = size;\n\tdopts.zero = true;\n\n\timalloc(&sopts, &dopts);\n\n\tLOG(\"core.calloc.exit\", \"result: %p\", ret);\n\n\treturn ret;\n}\n\nstatic void *\nirealloc_prof_sample(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t usize,\n    prof_tctx_t *tctx) {\n\tvoid *p;\n\n\tif (tctx == NULL) {\n\t\treturn NULL;\n\t}\n\tif (usize <= SMALL_MAXCLASS) {\n\t\tp = iralloc(tsd, old_ptr, old_usize, LARGE_MINCLASS, 0, false);\n\t\tif (p == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tarena_prof_promote(tsd_tsdn(tsd), p, usize);\n\t} else {\n\t\tp = iralloc(tsd, old_ptr, old_usize, usize, 0, false);\n\t}\n\n\treturn p;\n}\n\nJEMALLOC_ALWAYS_INLINE void *\nirealloc_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t usize,\n   alloc_ctx_t *alloc_ctx) {\n\tvoid *p;\n\tbool prof_active;\n\tprof_tctx_t *old_tctx, *tctx;\n\n\tprof_active = prof_active_get_unlocked();\n\told_tctx = prof_tctx_get(tsd_tsdn(tsd), old_ptr, alloc_ctx);\n\ttctx = prof_alloc_prep(tsd, usize, prof_active, true);\n\tif (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {\n\t\tp = irealloc_prof_sample(tsd, old_ptr, old_usize, usize, tctx);\n\t} else {\n\t\tp = iralloc(tsd, old_ptr, old_usize, usize, 0, false);\n\t}\n\tif (unlikely(p == NULL)) {\n\t\tprof_alloc_rollback(tsd, tctx, true);\n\t\treturn NULL;\n\t}\n\tprof_realloc(tsd, p, usize, tctx, prof_active, true, old_ptr, old_usize,\n\t    old_tctx);\n\n\treturn p;\n}\n\nJEMALLOC_ALWAYS_INLINE void\nifree(tsd_t *tsd, void *ptr, tcache_t *tcache, bool slow_path) {\n\tif (!slow_path) {\n\t\ttsd_assert_fast(tsd);\n\t}\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\tif (tsd_reentrancy_level_get(tsd) != 0) {\n\t\tassert(slow_path);\n\t}\n\n\tassert(ptr != NULL);\n\tassert(malloc_initialized() || IS_INITIALIZER);\n\n\talloc_ctx_t alloc_ctx;\n\trtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);\n\trtree_szind_slab_read(tsd_tsdn(tsd), &extents_rtree, rtree_ctx,\n\t    (uintptr_t)ptr, true, &alloc_ctx.szind, &alloc_ctx.slab);\n\tassert(alloc_ctx.szind != NSIZES);\n\n\tsize_t usize;\n\tif (config_prof && opt_prof) {\n\t\tusize = sz_index2size(alloc_ctx.szind);\n\t\tprof_free(tsd, ptr, usize, &alloc_ctx);\n\t} else if (config_stats) {\n\t\tusize = sz_index2size(alloc_ctx.szind);\n\t}\n\tif (config_stats) {\n\t\t*tsd_thread_deallocatedp_get(tsd) += usize;\n\t}\n\n\tif (likely(!slow_path)) {\n\t\tidalloctm(tsd_tsdn(tsd), ptr, tcache, &alloc_ctx, false,\n\t\t    false);\n\t} else {\n\t\tidalloctm(tsd_tsdn(tsd), ptr, tcache, &alloc_ctx, false,\n\t\t    true);\n\t}\n}\n\nJEMALLOC_ALWAYS_INLINE void\nisfree(tsd_t *tsd, void *ptr, size_t usize, tcache_t *tcache, bool slow_path) {\n\tif (!slow_path) {\n\t\ttsd_assert_fast(tsd);\n\t}\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\tif (tsd_reentrancy_level_get(tsd) != 0) {\n\t\tassert(slow_path);\n\t}\n\n\tassert(ptr != NULL);\n\tassert(malloc_initialized() || IS_INITIALIZER);\n\n\talloc_ctx_t alloc_ctx, *ctx;\n\tif (!config_cache_oblivious && ((uintptr_t)ptr & PAGE_MASK) != 0) {\n\t\t/*\n\t\t * When cache_oblivious is disabled and ptr is not page aligned,\n\t\t * the allocation was not sampled -- usize can be used to\n\t\t * determine szind directly.\n\t\t */\n\t\talloc_ctx.szind = sz_size2index(usize);\n\t\talloc_ctx.slab = true;\n\t\tctx = &alloc_ctx;\n\t\tif (config_debug) {\n\t\t\talloc_ctx_t dbg_ctx;\n\t\t\trtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);\n\t\t\trtree_szind_slab_read(tsd_tsdn(tsd), &extents_rtree,\n\t\t\t    rtree_ctx, (uintptr_t)ptr, true, &dbg_ctx.szind,\n\t\t\t    &dbg_ctx.slab);\n\t\t\tassert(dbg_ctx.szind == alloc_ctx.szind);\n\t\t\tassert(dbg_ctx.slab == alloc_ctx.slab);\n\t\t}\n\t} else if (config_prof && opt_prof) {\n\t\trtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);\n\t\trtree_szind_slab_read(tsd_tsdn(tsd), &extents_rtree, rtree_ctx,\n\t\t    (uintptr_t)ptr, true, &alloc_ctx.szind, &alloc_ctx.slab);\n\t\tassert(alloc_ctx.szind == sz_size2index(usize));\n\t\tctx = &alloc_ctx;\n\t} else {\n\t\tctx = NULL;\n\t}\n\n\tif (config_prof && opt_prof) {\n\t\tprof_free(tsd, ptr, usize, ctx);\n\t}\n\tif (config_stats) {\n\t\t*tsd_thread_deallocatedp_get(tsd) += usize;\n\t}\n\n\tif (likely(!slow_path)) {\n\t\tisdalloct(tsd_tsdn(tsd), ptr, usize, tcache, ctx, false);\n\t} else {\n\t\tisdalloct(tsd_tsdn(tsd), ptr, usize, tcache, ctx, true);\n\t}\n}\n\nJEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN\nvoid JEMALLOC_NOTHROW *\nJEMALLOC_ALLOC_SIZE(2)\nje_realloc(void *ptr, size_t size) {\n\tvoid *ret;\n\ttsdn_t *tsdn JEMALLOC_CC_SILENCE_INIT(NULL);\n\tsize_t usize JEMALLOC_CC_SILENCE_INIT(0);\n\tsize_t old_usize = 0;\n\n\tLOG(\"core.realloc.entry\", \"ptr: %p, size: %zu\\n\", ptr, size);\n\n\tif (unlikely(size == 0)) {\n\t\tif (ptr != NULL) {\n\t\t\t/* realloc(ptr, 0) is equivalent to free(ptr). */\n\t\t\tUTRACE(ptr, 0, 0);\n\t\t\ttcache_t *tcache;\n\t\t\ttsd_t *tsd = tsd_fetch();\n\t\t\tif (tsd_reentrancy_level_get(tsd) == 0) {\n\t\t\t\ttcache = tcache_get(tsd);\n\t\t\t} else {\n\t\t\t\ttcache = NULL;\n\t\t\t}\n\t\t\tifree(tsd, ptr, tcache, true);\n\n\t\t\tLOG(\"core.realloc.exit\", \"result: %p\", NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\tsize = 1;\n\t}\n\n\tif (likely(ptr != NULL)) {\n\t\tassert(malloc_initialized() || IS_INITIALIZER);\n\t\ttsd_t *tsd = tsd_fetch();\n\n\t\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\t\talloc_ctx_t alloc_ctx;\n\t\trtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);\n\t\trtree_szind_slab_read(tsd_tsdn(tsd), &extents_rtree, rtree_ctx,\n\t\t    (uintptr_t)ptr, true, &alloc_ctx.szind, &alloc_ctx.slab);\n\t\tassert(alloc_ctx.szind != NSIZES);\n\t\told_usize = sz_index2size(alloc_ctx.szind);\n\t\tassert(old_usize == isalloc(tsd_tsdn(tsd), ptr));\n\t\tif (config_prof && opt_prof) {\n\t\t\tusize = sz_s2u(size);\n\t\t\tret = unlikely(usize == 0 || usize > LARGE_MAXCLASS) ?\n\t\t\t    NULL : irealloc_prof(tsd, ptr, old_usize, usize,\n\t\t\t    &alloc_ctx);\n\t\t} else {\n\t\t\tif (config_stats) {\n\t\t\t\tusize = sz_s2u(size);\n\t\t\t}\n\t\t\tret = iralloc(tsd, ptr, old_usize, size, 0, false);\n\t\t}\n\t\ttsdn = tsd_tsdn(tsd);\n\t} else {\n\t\t/* realloc(NULL, size) is equivalent to malloc(size). */\n\t\tvoid *ret = je_malloc(size);\n\t\tLOG(\"core.realloc.exit\", \"result: %p\", ret);\n\t\treturn ret;\n\t}\n\n\tif (unlikely(ret == NULL)) {\n\t\tif (config_xmalloc && unlikely(opt_xmalloc)) {\n\t\t\tmalloc_write(\"<jemalloc>: Error in realloc(): \"\n\t\t\t    \"out of memory\\n\");\n\t\t\tabort();\n\t\t}\n\t\tset_errno(ENOMEM);\n\t}\n\tif (config_stats && likely(ret != NULL)) {\n\t\ttsd_t *tsd;\n\n\t\tassert(usize == isalloc(tsdn, ret));\n\t\ttsd = tsdn_tsd(tsdn);\n\t\t*tsd_thread_allocatedp_get(tsd) += usize;\n\t\t*tsd_thread_deallocatedp_get(tsd) += old_usize;\n\t}\n\tUTRACE(ptr, size, ret);\n\tcheck_entry_exit_locking(tsdn);\n\n\tLOG(\"core.realloc.exit\", \"result: %p\", ret);\n\treturn ret;\n}\n\nJEMALLOC_EXPORT void JEMALLOC_NOTHROW\nje_free(void *ptr) {\n\tLOG(\"core.free.entry\", \"ptr: %p\", ptr);\n\n\tUTRACE(ptr, 0, 0);\n\tif (likely(ptr != NULL)) {\n\t\t/*\n\t\t * We avoid setting up tsd fully (e.g. tcache, arena binding)\n\t\t * based on only free() calls -- other activities trigger the\n\t\t * minimal to full transition.  This is because free() may\n\t\t * happen during thread shutdown after tls deallocation: if a\n\t\t * thread never had any malloc activities until then, a\n\t\t * fully-setup tsd won't be destructed properly.\n\t\t */\n\t\ttsd_t *tsd = tsd_fetch_min();\n\t\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\t\ttcache_t *tcache;\n\t\tif (likely(tsd_fast(tsd))) {\n\t\t\ttsd_assert_fast(tsd);\n\t\t\t/* Unconditionally get tcache ptr on fast path. */\n\t\t\ttcache = tsd_tcachep_get(tsd);\n\t\t\tifree(tsd, ptr, tcache, false);\n\t\t} else {\n\t\t\tif (likely(tsd_reentrancy_level_get(tsd) == 0)) {\n\t\t\t\ttcache = tcache_get(tsd);\n\t\t\t} else {\n\t\t\t\ttcache = NULL;\n\t\t\t}\n\t\t\tifree(tsd, ptr, tcache, true);\n\t\t}\n\t\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\t}\n\tLOG(\"core.free.exit\", \"\");\n}\n\n/*\n * End malloc(3)-compatible functions.\n */\n/******************************************************************************/\n/*\n * Begin non-standard override functions.\n */\n\n#ifdef JEMALLOC_OVERRIDE_MEMALIGN\nJEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN\nvoid JEMALLOC_NOTHROW *\nJEMALLOC_ATTR(malloc)\nje_memalign(size_t alignment, size_t size) {\n\tvoid *ret;\n\tstatic_opts_t sopts;\n\tdynamic_opts_t dopts;\n\n\tLOG(\"core.memalign.entry\", \"alignment: %zu, size: %zu\\n\", alignment,\n\t    size);\n\n\tstatic_opts_init(&sopts);\n\tdynamic_opts_init(&dopts);\n\n\tsopts.bump_empty_alloc = true;\n\tsopts.min_alignment = 1;\n\tsopts.oom_string =\n\t    \"<jemalloc>: Error allocating aligned memory: out of memory\\n\";\n\tsopts.invalid_alignment_string =\n\t    \"<jemalloc>: Error allocating aligned memory: invalid alignment\\n\";\n\tsopts.null_out_result_on_error = true;\n\n\tdopts.result = &ret;\n\tdopts.num_items = 1;\n\tdopts.item_size = size;\n\tdopts.alignment = alignment;\n\n\timalloc(&sopts, &dopts);\n\n\tLOG(\"core.memalign.exit\", \"result: %p\", ret);\n\treturn ret;\n}\n#endif\n\n#ifdef JEMALLOC_OVERRIDE_VALLOC\nJEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN\nvoid JEMALLOC_NOTHROW *\nJEMALLOC_ATTR(malloc)\nje_valloc(size_t size) {\n\tvoid *ret;\n\n\tstatic_opts_t sopts;\n\tdynamic_opts_t dopts;\n\n\tLOG(\"core.valloc.entry\", \"size: %zu\\n\", size);\n\n\tstatic_opts_init(&sopts);\n\tdynamic_opts_init(&dopts);\n\n\tsopts.bump_empty_alloc = true;\n\tsopts.null_out_result_on_error = true;\n\tsopts.min_alignment = PAGE;\n\tsopts.oom_string =\n\t    \"<jemalloc>: Error allocating aligned memory: out of memory\\n\";\n\tsopts.invalid_alignment_string =\n\t    \"<jemalloc>: Error allocating aligned memory: invalid alignment\\n\";\n\n\tdopts.result = &ret;\n\tdopts.num_items = 1;\n\tdopts.item_size = size;\n\tdopts.alignment = PAGE;\n\n\timalloc(&sopts, &dopts);\n\n\tLOG(\"core.valloc.exit\", \"result: %p\\n\", ret);\n\treturn ret;\n}\n#endif\n\n#if defined(JEMALLOC_IS_MALLOC) && defined(JEMALLOC_GLIBC_MALLOC_HOOK)\n/*\n * glibc provides the RTLD_DEEPBIND flag for dlopen which can make it possible\n * to inconsistently reference libc's malloc(3)-compatible functions\n * (https://bugzilla.mozilla.org/show_bug.cgi?id=493541).\n *\n * These definitions interpose hooks in glibc.  The functions are actually\n * passed an extra argument for the caller return address, which will be\n * ignored.\n */\nJEMALLOC_EXPORT void (*__free_hook)(void *ptr) = je_free;\nJEMALLOC_EXPORT void *(*__malloc_hook)(size_t size) = je_malloc;\nJEMALLOC_EXPORT void *(*__realloc_hook)(void *ptr, size_t size) = je_realloc;\n#  ifdef JEMALLOC_GLIBC_MEMALIGN_HOOK\nJEMALLOC_EXPORT void *(*__memalign_hook)(size_t alignment, size_t size) =\n    je_memalign;\n#  endif\n\n#  ifdef CPU_COUNT\n/*\n * To enable static linking with glibc, the libc specific malloc interface must\n * be implemented also, so none of glibc's malloc.o functions are added to the\n * link.\n */\n#    define ALIAS(je_fn)\t__attribute__((alias (#je_fn), used))\n/* To force macro expansion of je_ prefix before stringification. */\n#    define PREALIAS(je_fn)\tALIAS(je_fn)\n#    ifdef JEMALLOC_OVERRIDE___LIBC_CALLOC\nvoid *__libc_calloc(size_t n, size_t size) PREALIAS(je_calloc);\n#    endif\n#    ifdef JEMALLOC_OVERRIDE___LIBC_FREE\nvoid __libc_free(void* ptr) PREALIAS(je_free);\n#    endif\n#    ifdef JEMALLOC_OVERRIDE___LIBC_MALLOC\nvoid *__libc_malloc(size_t size) PREALIAS(je_malloc);\n#    endif\n#    ifdef JEMALLOC_OVERRIDE___LIBC_MEMALIGN\nvoid *__libc_memalign(size_t align, size_t s) PREALIAS(je_memalign);\n#    endif\n#    ifdef JEMALLOC_OVERRIDE___LIBC_REALLOC\nvoid *__libc_realloc(void* ptr, size_t size) PREALIAS(je_realloc);\n#    endif\n#    ifdef JEMALLOC_OVERRIDE___LIBC_VALLOC\nvoid *__libc_valloc(size_t size) PREALIAS(je_valloc);\n#    endif\n#    ifdef JEMALLOC_OVERRIDE___POSIX_MEMALIGN\nint __posix_memalign(void** r, size_t a, size_t s) PREALIAS(je_posix_memalign);\n#    endif\n#    undef PREALIAS\n#    undef ALIAS\n#  endif\n#endif\n\n/*\n * End non-standard override functions.\n */\n/******************************************************************************/\n/*\n * Begin non-standard functions.\n */\n\nJEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN\nvoid JEMALLOC_NOTHROW *\nJEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1)\nje_mallocx(size_t size, int flags) {\n\tvoid *ret;\n\tstatic_opts_t sopts;\n\tdynamic_opts_t dopts;\n\n\tLOG(\"core.mallocx.entry\", \"size: %zu, flags: %d\", size, flags);\n\n\tstatic_opts_init(&sopts);\n\tdynamic_opts_init(&dopts);\n\n\tsopts.assert_nonempty_alloc = true;\n\tsopts.null_out_result_on_error = true;\n\tsopts.oom_string = \"<jemalloc>: Error in mallocx(): out of memory\\n\";\n\n\tdopts.result = &ret;\n\tdopts.num_items = 1;\n\tdopts.item_size = size;\n\tif (unlikely(flags != 0)) {\n\t\tif ((flags & MALLOCX_LG_ALIGN_MASK) != 0) {\n\t\t\tdopts.alignment = MALLOCX_ALIGN_GET_SPECIFIED(flags);\n\t\t}\n\n\t\tdopts.zero = MALLOCX_ZERO_GET(flags);\n\n\t\tif ((flags & MALLOCX_TCACHE_MASK) != 0) {\n\t\t\tif ((flags & MALLOCX_TCACHE_MASK)\n\t\t\t    == MALLOCX_TCACHE_NONE) {\n\t\t\t\tdopts.tcache_ind = TCACHE_IND_NONE;\n\t\t\t} else {\n\t\t\t\tdopts.tcache_ind = MALLOCX_TCACHE_GET(flags);\n\t\t\t}\n\t\t} else {\n\t\t\tdopts.tcache_ind = TCACHE_IND_AUTOMATIC;\n\t\t}\n\n\t\tif ((flags & MALLOCX_ARENA_MASK) != 0)\n\t\t\tdopts.arena_ind = MALLOCX_ARENA_GET(flags);\n\t}\n\n\timalloc(&sopts, &dopts);\n\n\tLOG(\"core.mallocx.exit\", \"result: %p\", ret);\n\treturn ret;\n}\n\nstatic void *\nirallocx_prof_sample(tsdn_t *tsdn, void *old_ptr, size_t old_usize,\n    size_t usize, size_t alignment, bool zero, tcache_t *tcache, arena_t *arena,\n    prof_tctx_t *tctx) {\n\tvoid *p;\n\n\tif (tctx == NULL) {\n\t\treturn NULL;\n\t}\n\tif (usize <= SMALL_MAXCLASS) {\n\t\tp = iralloct(tsdn, old_ptr, old_usize, LARGE_MINCLASS,\n\t\t    alignment, zero, tcache, arena);\n\t\tif (p == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tarena_prof_promote(tsdn, p, usize);\n\t} else {\n\t\tp = iralloct(tsdn, old_ptr, old_usize, usize, alignment, zero,\n\t\t    tcache, arena);\n\t}\n\n\treturn p;\n}\n\nJEMALLOC_ALWAYS_INLINE void *\nirallocx_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t size,\n    size_t alignment, size_t *usize, bool zero, tcache_t *tcache,\n    arena_t *arena, alloc_ctx_t *alloc_ctx) {\n\tvoid *p;\n\tbool prof_active;\n\tprof_tctx_t *old_tctx, *tctx;\n\n\tprof_active = prof_active_get_unlocked();\n\told_tctx = prof_tctx_get(tsd_tsdn(tsd), old_ptr, alloc_ctx);\n\ttctx = prof_alloc_prep(tsd, *usize, prof_active, false);\n\tif (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {\n\t\tp = irallocx_prof_sample(tsd_tsdn(tsd), old_ptr, old_usize,\n\t\t    *usize, alignment, zero, tcache, arena, tctx);\n\t} else {\n\t\tp = iralloct(tsd_tsdn(tsd), old_ptr, old_usize, size, alignment,\n\t\t    zero, tcache, arena);\n\t}\n\tif (unlikely(p == NULL)) {\n\t\tprof_alloc_rollback(tsd, tctx, false);\n\t\treturn NULL;\n\t}\n\n\tif (p == old_ptr && alignment != 0) {\n\t\t/*\n\t\t * The allocation did not move, so it is possible that the size\n\t\t * class is smaller than would guarantee the requested\n\t\t * alignment, and that the alignment constraint was\n\t\t * serendipitously satisfied.  Additionally, old_usize may not\n\t\t * be the same as the current usize because of in-place large\n\t\t * reallocation.  Therefore, query the actual value of usize.\n\t\t */\n\t\t*usize = isalloc(tsd_tsdn(tsd), p);\n\t}\n\tprof_realloc(tsd, p, *usize, tctx, prof_active, false, old_ptr,\n\t    old_usize, old_tctx);\n\n\treturn p;\n}\n\nJEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN\nvoid JEMALLOC_NOTHROW *\nJEMALLOC_ALLOC_SIZE(2)\nje_rallocx(void *ptr, size_t size, int flags) {\n\tvoid *p;\n\ttsd_t *tsd;\n\tsize_t usize;\n\tsize_t old_usize;\n\tsize_t alignment = MALLOCX_ALIGN_GET(flags);\n\tbool zero = flags & MALLOCX_ZERO;\n\tarena_t *arena;\n\ttcache_t *tcache;\n\n\tLOG(\"core.rallocx.entry\", \"ptr: %p, size: %zu, flags: %d\", ptr,\n\t    size, flags);\n\n\n\tassert(ptr != NULL);\n\tassert(size != 0);\n\tassert(malloc_initialized() || IS_INITIALIZER);\n\ttsd = tsd_fetch();\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\tif (unlikely((flags & MALLOCX_ARENA_MASK) != 0)) {\n\t\tunsigned arena_ind = MALLOCX_ARENA_GET(flags);\n\t\tarena = arena_get(tsd_tsdn(tsd), arena_ind, true);\n\t\tif (unlikely(arena == NULL)) {\n\t\t\tgoto label_oom;\n\t\t}\n\t} else {\n\t\tarena = NULL;\n\t}\n\n\tif (unlikely((flags & MALLOCX_TCACHE_MASK) != 0)) {\n\t\tif ((flags & MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE) {\n\t\t\ttcache = NULL;\n\t\t} else {\n\t\t\ttcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));\n\t\t}\n\t} else {\n\t\ttcache = tcache_get(tsd);\n\t}\n\n\talloc_ctx_t alloc_ctx;\n\trtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);\n\trtree_szind_slab_read(tsd_tsdn(tsd), &extents_rtree, rtree_ctx,\n\t    (uintptr_t)ptr, true, &alloc_ctx.szind, &alloc_ctx.slab);\n\tassert(alloc_ctx.szind != NSIZES);\n\told_usize = sz_index2size(alloc_ctx.szind);\n\tassert(old_usize == isalloc(tsd_tsdn(tsd), ptr));\n\tif (config_prof && opt_prof) {\n\t\tusize = (alignment == 0) ?\n\t\t    sz_s2u(size) : sz_sa2u(size, alignment);\n\t\tif (unlikely(usize == 0 || usize > LARGE_MAXCLASS)) {\n\t\t\tgoto label_oom;\n\t\t}\n\t\tp = irallocx_prof(tsd, ptr, old_usize, size, alignment, &usize,\n\t\t    zero, tcache, arena, &alloc_ctx);\n\t\tif (unlikely(p == NULL)) {\n\t\t\tgoto label_oom;\n\t\t}\n\t} else {\n\t\tp = iralloct(tsd_tsdn(tsd), ptr, old_usize, size, alignment,\n\t\t    zero, tcache, arena);\n\t\tif (unlikely(p == NULL)) {\n\t\t\tgoto label_oom;\n\t\t}\n\t\tif (config_stats) {\n\t\t\tusize = isalloc(tsd_tsdn(tsd), p);\n\t\t}\n\t}\n\tassert(alignment == 0 || ((uintptr_t)p & (alignment - 1)) == ZU(0));\n\n\tif (config_stats) {\n\t\t*tsd_thread_allocatedp_get(tsd) += usize;\n\t\t*tsd_thread_deallocatedp_get(tsd) += old_usize;\n\t}\n\tUTRACE(ptr, size, p);\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\tLOG(\"core.rallocx.exit\", \"result: %p\", p);\n\treturn p;\nlabel_oom:\n\tif (config_xmalloc && unlikely(opt_xmalloc)) {\n\t\tmalloc_write(\"<jemalloc>: Error in rallocx(): out of memory\\n\");\n\t\tabort();\n\t}\n\tUTRACE(ptr, size, 0);\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\tLOG(\"core.rallocx.exit\", \"result: %p\", NULL);\n\treturn NULL;\n}\n\nJEMALLOC_ALWAYS_INLINE size_t\nixallocx_helper(tsdn_t *tsdn, void *ptr, size_t old_usize, size_t size,\n    size_t extra, size_t alignment, bool zero) {\n\tsize_t usize;\n\n\tif (ixalloc(tsdn, ptr, old_usize, size, extra, alignment, zero)) {\n\t\treturn old_usize;\n\t}\n\tusize = isalloc(tsdn, ptr);\n\n\treturn usize;\n}\n\nstatic size_t\nixallocx_prof_sample(tsdn_t *tsdn, void *ptr, size_t old_usize, size_t size,\n    size_t extra, size_t alignment, bool zero, prof_tctx_t *tctx) {\n\tsize_t usize;\n\n\tif (tctx == NULL) {\n\t\treturn old_usize;\n\t}\n\tusize = ixallocx_helper(tsdn, ptr, old_usize, size, extra, alignment,\n\t    zero);\n\n\treturn usize;\n}\n\nJEMALLOC_ALWAYS_INLINE size_t\nixallocx_prof(tsd_t *tsd, void *ptr, size_t old_usize, size_t size,\n    size_t extra, size_t alignment, bool zero, alloc_ctx_t *alloc_ctx) {\n\tsize_t usize_max, usize;\n\tbool prof_active;\n\tprof_tctx_t *old_tctx, *tctx;\n\n\tprof_active = prof_active_get_unlocked();\n\told_tctx = prof_tctx_get(tsd_tsdn(tsd), ptr, alloc_ctx);\n\t/*\n\t * usize isn't knowable before ixalloc() returns when extra is non-zero.\n\t * Therefore, compute its maximum possible value and use that in\n\t * prof_alloc_prep() to decide whether to capture a backtrace.\n\t * prof_realloc() will use the actual usize to decide whether to sample.\n\t */\n\tif (alignment == 0) {\n\t\tusize_max = sz_s2u(size+extra);\n\t\tassert(usize_max > 0 && usize_max <= LARGE_MAXCLASS);\n\t} else {\n\t\tusize_max = sz_sa2u(size+extra, alignment);\n\t\tif (unlikely(usize_max == 0 || usize_max > LARGE_MAXCLASS)) {\n\t\t\t/*\n\t\t\t * usize_max is out of range, and chances are that\n\t\t\t * allocation will fail, but use the maximum possible\n\t\t\t * value and carry on with prof_alloc_prep(), just in\n\t\t\t * case allocation succeeds.\n\t\t\t */\n\t\t\tusize_max = LARGE_MAXCLASS;\n\t\t}\n\t}\n\ttctx = prof_alloc_prep(tsd, usize_max, prof_active, false);\n\n\tif (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {\n\t\tusize = ixallocx_prof_sample(tsd_tsdn(tsd), ptr, old_usize,\n\t\t    size, extra, alignment, zero, tctx);\n\t} else {\n\t\tusize = ixallocx_helper(tsd_tsdn(tsd), ptr, old_usize, size,\n\t\t    extra, alignment, zero);\n\t}\n\tif (usize == old_usize) {\n\t\tprof_alloc_rollback(tsd, tctx, false);\n\t\treturn usize;\n\t}\n\tprof_realloc(tsd, ptr, usize, tctx, prof_active, false, ptr, old_usize,\n\t    old_tctx);\n\n\treturn usize;\n}\n\nJEMALLOC_EXPORT size_t JEMALLOC_NOTHROW\nje_xallocx(void *ptr, size_t size, size_t extra, int flags) {\n\ttsd_t *tsd;\n\tsize_t usize, old_usize;\n\tsize_t alignment = MALLOCX_ALIGN_GET(flags);\n\tbool zero = flags & MALLOCX_ZERO;\n\n\tLOG(\"core.xallocx.entry\", \"ptr: %p, size: %zu, extra: %zu, \"\n\t    \"flags: %d\", ptr, size, extra, flags);\n\n\tassert(ptr != NULL);\n\tassert(size != 0);\n\tassert(SIZE_T_MAX - size >= extra);\n\tassert(malloc_initialized() || IS_INITIALIZER);\n\ttsd = tsd_fetch();\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\talloc_ctx_t alloc_ctx;\n\trtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);\n\trtree_szind_slab_read(tsd_tsdn(tsd), &extents_rtree, rtree_ctx,\n\t    (uintptr_t)ptr, true, &alloc_ctx.szind, &alloc_ctx.slab);\n\tassert(alloc_ctx.szind != NSIZES);\n\told_usize = sz_index2size(alloc_ctx.szind);\n\tassert(old_usize == isalloc(tsd_tsdn(tsd), ptr));\n\t/*\n\t * The API explicitly absolves itself of protecting against (size +\n\t * extra) numerical overflow, but we may need to clamp extra to avoid\n\t * exceeding LARGE_MAXCLASS.\n\t *\n\t * Ordinarily, size limit checking is handled deeper down, but here we\n\t * have to check as part of (size + extra) clamping, since we need the\n\t * clamped value in the above helper functions.\n\t */\n\tif (unlikely(size > LARGE_MAXCLASS)) {\n\t\tusize = old_usize;\n\t\tgoto label_not_resized;\n\t}\n\tif (unlikely(LARGE_MAXCLASS - size < extra)) {\n\t\textra = LARGE_MAXCLASS - size;\n\t}\n\n\tif (config_prof && opt_prof) {\n\t\tusize = ixallocx_prof(tsd, ptr, old_usize, size, extra,\n\t\t    alignment, zero, &alloc_ctx);\n\t} else {\n\t\tusize = ixallocx_helper(tsd_tsdn(tsd), ptr, old_usize, size,\n\t\t    extra, alignment, zero);\n\t}\n\tif (unlikely(usize == old_usize)) {\n\t\tgoto label_not_resized;\n\t}\n\n\tif (config_stats) {\n\t\t*tsd_thread_allocatedp_get(tsd) += usize;\n\t\t*tsd_thread_deallocatedp_get(tsd) += old_usize;\n\t}\nlabel_not_resized:\n\tUTRACE(ptr, size, ptr);\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\tLOG(\"core.xallocx.exit\", \"result: %zu\", usize);\n\treturn usize;\n}\n\nJEMALLOC_EXPORT size_t JEMALLOC_NOTHROW\nJEMALLOC_ATTR(pure)\nje_sallocx(const void *ptr, UNUSED int flags) {\n\tsize_t usize;\n\ttsdn_t *tsdn;\n\n\tLOG(\"core.sallocx.entry\", \"ptr: %p, flags: %d\", ptr, flags);\n\n\tassert(malloc_initialized() || IS_INITIALIZER);\n\tassert(ptr != NULL);\n\n\ttsdn = tsdn_fetch();\n\tcheck_entry_exit_locking(tsdn);\n\n\tif (config_debug || force_ivsalloc) {\n\t\tusize = ivsalloc(tsdn, ptr);\n\t\tassert(force_ivsalloc || usize != 0);\n\t} else {\n\t\tusize = isalloc(tsdn, ptr);\n\t}\n\n\tcheck_entry_exit_locking(tsdn);\n\n\tLOG(\"core.sallocx.exit\", \"result: %zu\", usize);\n\treturn usize;\n}\n\nJEMALLOC_EXPORT void JEMALLOC_NOTHROW\nje_dallocx(void *ptr, int flags) {\n\tLOG(\"core.dallocx.entry\", \"ptr: %p, flags: %d\", ptr, flags);\n\n\tassert(ptr != NULL);\n\tassert(malloc_initialized() || IS_INITIALIZER);\n\n\ttsd_t *tsd = tsd_fetch();\n\tbool fast = tsd_fast(tsd);\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\ttcache_t *tcache;\n\tif (unlikely((flags & MALLOCX_TCACHE_MASK) != 0)) {\n\t\t/* Not allowed to be reentrant and specify a custom tcache. */\n\t\tassert(tsd_reentrancy_level_get(tsd) == 0);\n\t\tif ((flags & MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE) {\n\t\t\ttcache = NULL;\n\t\t} else {\n\t\t\ttcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));\n\t\t}\n\t} else {\n\t\tif (likely(fast)) {\n\t\t\ttcache = tsd_tcachep_get(tsd);\n\t\t\tassert(tcache == tcache_get(tsd));\n\t\t} else {\n\t\t\tif (likely(tsd_reentrancy_level_get(tsd) == 0)) {\n\t\t\t\ttcache = tcache_get(tsd);\n\t\t\t}  else {\n\t\t\t\ttcache = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tUTRACE(ptr, 0, 0);\n\tif (likely(fast)) {\n\t\ttsd_assert_fast(tsd);\n\t\tifree(tsd, ptr, tcache, false);\n\t} else {\n\t\tifree(tsd, ptr, tcache, true);\n\t}\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\tLOG(\"core.dallocx.exit\", \"\");\n}\n\nJEMALLOC_ALWAYS_INLINE size_t\ninallocx(tsdn_t *tsdn, size_t size, int flags) {\n\tcheck_entry_exit_locking(tsdn);\n\n\tsize_t usize;\n\tif (likely((flags & MALLOCX_LG_ALIGN_MASK) == 0)) {\n\t\tusize = sz_s2u(size);\n\t} else {\n\t\tusize = sz_sa2u(size, MALLOCX_ALIGN_GET_SPECIFIED(flags));\n\t}\n\tcheck_entry_exit_locking(tsdn);\n\treturn usize;\n}\n\nJEMALLOC_EXPORT void JEMALLOC_NOTHROW\nje_sdallocx(void *ptr, size_t size, int flags) {\n\tassert(ptr != NULL);\n\tassert(malloc_initialized() || IS_INITIALIZER);\n\n\tLOG(\"core.sdallocx.entry\", \"ptr: %p, size: %zu, flags: %d\", ptr,\n\t    size, flags);\n\n\ttsd_t *tsd = tsd_fetch();\n\tbool fast = tsd_fast(tsd);\n\tsize_t usize = inallocx(tsd_tsdn(tsd), size, flags);\n\tassert(usize == isalloc(tsd_tsdn(tsd), ptr));\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\ttcache_t *tcache;\n\tif (unlikely((flags & MALLOCX_TCACHE_MASK) != 0)) {\n\t\t/* Not allowed to be reentrant and specify a custom tcache. */\n\t\tassert(tsd_reentrancy_level_get(tsd) == 0);\n\t\tif ((flags & MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE) {\n\t\t\ttcache = NULL;\n\t\t} else {\n\t\t\ttcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));\n\t\t}\n\t} else {\n\t\tif (likely(fast)) {\n\t\t\ttcache = tsd_tcachep_get(tsd);\n\t\t\tassert(tcache == tcache_get(tsd));\n\t\t} else {\n\t\t\tif (likely(tsd_reentrancy_level_get(tsd) == 0)) {\n\t\t\t\ttcache = tcache_get(tsd);\n\t\t\t} else {\n\t\t\t\ttcache = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tUTRACE(ptr, 0, 0);\n\tif (likely(fast)) {\n\t\ttsd_assert_fast(tsd);\n\t\tisfree(tsd, ptr, usize, tcache, false);\n\t} else {\n\t\tisfree(tsd, ptr, usize, tcache, true);\n\t}\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\tLOG(\"core.sdallocx.exit\", \"\");\n}\n\nJEMALLOC_EXPORT size_t JEMALLOC_NOTHROW\nJEMALLOC_ATTR(pure)\nje_nallocx(size_t size, int flags) {\n\tsize_t usize;\n\ttsdn_t *tsdn;\n\n\tassert(size != 0);\n\n\tif (unlikely(malloc_init())) {\n\t\tLOG(\"core.nallocx.exit\", \"result: %zu\", ZU(0));\n\t\treturn 0;\n\t}\n\n\ttsdn = tsdn_fetch();\n\tcheck_entry_exit_locking(tsdn);\n\n\tusize = inallocx(tsdn, size, flags);\n\tif (unlikely(usize > LARGE_MAXCLASS)) {\n\t\tLOG(\"core.nallocx.exit\", \"result: %zu\", ZU(0));\n\t\treturn 0;\n\t}\n\n\tcheck_entry_exit_locking(tsdn);\n\tLOG(\"core.nallocx.exit\", \"result: %zu\", usize);\n\treturn usize;\n}\n\nJEMALLOC_EXPORT int JEMALLOC_NOTHROW\nje_mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp,\n    size_t newlen) {\n\tint ret;\n\ttsd_t *tsd;\n\n\tLOG(\"core.mallctl.entry\", \"name: %s\", name);\n\n\tif (unlikely(malloc_init())) {\n\t\tLOG(\"core.mallctl.exit\", \"result: %d\", EAGAIN);\n\t\treturn EAGAIN;\n\t}\n\n\ttsd = tsd_fetch();\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\tret = ctl_byname(tsd, name, oldp, oldlenp, newp, newlen);\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\tLOG(\"core.mallctl.exit\", \"result: %d\", ret);\n\treturn ret;\n}\n\nJEMALLOC_EXPORT int JEMALLOC_NOTHROW\nje_mallctlnametomib(const char *name, size_t *mibp, size_t *miblenp) {\n\tint ret;\n\n\tLOG(\"core.mallctlnametomib.entry\", \"name: %s\", name);\n\n\tif (unlikely(malloc_init())) {\n\t\tLOG(\"core.mallctlnametomib.exit\", \"result: %d\", EAGAIN);\n\t\treturn EAGAIN;\n\t}\n\n\ttsd_t *tsd = tsd_fetch();\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\tret = ctl_nametomib(tsd, name, mibp, miblenp);\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\n\tLOG(\"core.mallctlnametomib.exit\", \"result: %d\", ret);\n\treturn ret;\n}\n\nJEMALLOC_EXPORT int JEMALLOC_NOTHROW\nje_mallctlbymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,\n  void *newp, size_t newlen) {\n\tint ret;\n\ttsd_t *tsd;\n\n\tLOG(\"core.mallctlbymib.entry\", \"\");\n\n\tif (unlikely(malloc_init())) {\n\t\tLOG(\"core.mallctlbymib.exit\", \"result: %d\", EAGAIN);\n\t\treturn EAGAIN;\n\t}\n\n\ttsd = tsd_fetch();\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\tret = ctl_bymib(tsd, mib, miblen, oldp, oldlenp, newp, newlen);\n\tcheck_entry_exit_locking(tsd_tsdn(tsd));\n\tLOG(\"core.mallctlbymib.exit\", \"result: %d\", ret);\n\treturn ret;\n}\n\nJEMALLOC_EXPORT void JEMALLOC_NOTHROW\nje_malloc_stats_print(void (*write_cb)(void *, const char *), void *cbopaque,\n    const char *opts) {\n\ttsdn_t *tsdn;\n\n\tLOG(\"core.malloc_stats_print.entry\", \"\");\n\n\ttsdn = tsdn_fetch();\n\tcheck_entry_exit_locking(tsdn);\n\tstats_print(write_cb, cbopaque, opts);\n\tcheck_entry_exit_locking(tsdn);\n\tLOG(\"core.malloc_stats_print.exit\", \"\");\n}\n\nJEMALLOC_EXPORT size_t JEMALLOC_NOTHROW\nje_malloc_usable_size(JEMALLOC_USABLE_SIZE_CONST void *ptr) {\n\tsize_t ret;\n\ttsdn_t *tsdn;\n\n\tLOG(\"core.malloc_usable_size.entry\", \"ptr: %p\", ptr);\n\n\tassert(malloc_initialized() || IS_INITIALIZER);\n\n\ttsdn = tsdn_fetch();\n\tcheck_entry_exit_locking(tsdn);\n\n\tif (unlikely(ptr == NULL)) {\n\t\tret = 0;\n\t} else {\n\t\tif (config_debug || force_ivsalloc) {\n\t\t\tret = ivsalloc(tsdn, ptr);\n\t\t\tassert(force_ivsalloc || ret != 0);\n\t\t} else {\n\t\t\tret = isalloc(tsdn, ptr);\n\t\t}\n\t}\n\n\tcheck_entry_exit_locking(tsdn);\n\tLOG(\"core.malloc_usable_size.exit\", \"result: %zu\", ret);\n\treturn ret;\n}\n\n/*\n * End non-standard functions.\n */\n/******************************************************************************/\n/*\n * The following functions are used by threading libraries for protection of\n * malloc during fork().\n */\n\n/*\n * If an application creates a thread before doing any allocation in the main\n * thread, then calls fork(2) in the main thread followed by memory allocation\n * in the child process, a race can occur that results in deadlock within the\n * child: the main thread may have forked while the created thread had\n * partially initialized the allocator.  Ordinarily jemalloc prevents\n * fork/malloc races via the following functions it registers during\n * initialization using pthread_atfork(), but of course that does no good if\n * the allocator isn't fully initialized at fork time.  The following library\n * constructor is a partial solution to this problem.  It may still be possible\n * to trigger the deadlock described above, but doing so would involve forking\n * via a library constructor that runs before jemalloc's runs.\n */\n#ifndef JEMALLOC_JET\nJEMALLOC_ATTR(constructor)\nstatic void\njemalloc_constructor(void) {\n\tmalloc_init();\n}\n#endif\n\n#ifndef JEMALLOC_MUTEX_INIT_CB\nvoid\njemalloc_prefork(void)\n#else\nJEMALLOC_EXPORT void\n_malloc_prefork(void)\n#endif\n{\n\ttsd_t *tsd;\n\tunsigned i, j, narenas;\n\tarena_t *arena;\n\n#ifdef JEMALLOC_MUTEX_INIT_CB\n\tif (!malloc_initialized()) {\n\t\treturn;\n\t}\n#endif\n\tassert(malloc_initialized());\n\n\ttsd = tsd_fetch();\n\n\tnarenas = narenas_total_get();\n\n\twitness_prefork(tsd_witness_tsdp_get(tsd));\n\t/* Acquire all mutexes in a safe order. */\n\tctl_prefork(tsd_tsdn(tsd));\n\ttcache_prefork(tsd_tsdn(tsd));\n\tmalloc_mutex_prefork(tsd_tsdn(tsd), &arenas_lock);\n\tif (have_background_thread) {\n\t\tbackground_thread_prefork0(tsd_tsdn(tsd));\n\t}\n\tprof_prefork0(tsd_tsdn(tsd));\n\tif (have_background_thread) {\n\t\tbackground_thread_prefork1(tsd_tsdn(tsd));\n\t}\n\t/* Break arena prefork into stages to preserve lock order. */\n\tfor (i = 0; i < 8; i++) {\n\t\tfor (j = 0; j < narenas; j++) {\n\t\t\tif ((arena = arena_get(tsd_tsdn(tsd), j, false)) !=\n\t\t\t    NULL) {\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tarena_prefork0(tsd_tsdn(tsd), arena);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tarena_prefork1(tsd_tsdn(tsd), arena);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tarena_prefork2(tsd_tsdn(tsd), arena);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tarena_prefork3(tsd_tsdn(tsd), arena);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tarena_prefork4(tsd_tsdn(tsd), arena);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tarena_prefork5(tsd_tsdn(tsd), arena);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tarena_prefork6(tsd_tsdn(tsd), arena);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tarena_prefork7(tsd_tsdn(tsd), arena);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: not_reached();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprof_prefork1(tsd_tsdn(tsd));\n}\n\n#ifndef JEMALLOC_MUTEX_INIT_CB\nvoid\njemalloc_postfork_parent(void)\n#else\nJEMALLOC_EXPORT void\n_malloc_postfork(void)\n#endif\n{\n\ttsd_t *tsd;\n\tunsigned i, narenas;\n\n#ifdef JEMALLOC_MUTEX_INIT_CB\n\tif (!malloc_initialized()) {\n\t\treturn;\n\t}\n#endif\n\tassert(malloc_initialized());\n\n\ttsd = tsd_fetch();\n\n\twitness_postfork_parent(tsd_witness_tsdp_get(tsd));\n\t/* Release all mutexes, now that fork() has completed. */\n\tfor (i = 0, narenas = narenas_total_get(); i < narenas; i++) {\n\t\tarena_t *arena;\n\n\t\tif ((arena = arena_get(tsd_tsdn(tsd), i, false)) != NULL) {\n\t\t\tarena_postfork_parent(tsd_tsdn(tsd), arena);\n\t\t}\n\t}\n\tprof_postfork_parent(tsd_tsdn(tsd));\n\tif (have_background_thread) {\n\t\tbackground_thread_postfork_parent(tsd_tsdn(tsd));\n\t}\n\tmalloc_mutex_postfork_parent(tsd_tsdn(tsd), &arenas_lock);\n\ttcache_postfork_parent(tsd_tsdn(tsd));\n\tctl_postfork_parent(tsd_tsdn(tsd));\n}\n\nvoid\njemalloc_postfork_child(void) {\n\ttsd_t *tsd;\n\tunsigned i, narenas;\n\n\tassert(malloc_initialized());\n\n\ttsd = tsd_fetch();\n\n\twitness_postfork_child(tsd_witness_tsdp_get(tsd));\n\t/* Release all mutexes, now that fork() has completed. */\n\tfor (i = 0, narenas = narenas_total_get(); i < narenas; i++) {\n\t\tarena_t *arena;\n\n\t\tif ((arena = arena_get(tsd_tsdn(tsd), i, false)) != NULL) {\n\t\t\tarena_postfork_child(tsd_tsdn(tsd), arena);\n\t\t}\n\t}\n\tprof_postfork_child(tsd_tsdn(tsd));\n\tif (have_background_thread) {\n\t\tbackground_thread_postfork_child(tsd_tsdn(tsd));\n\t}\n\tmalloc_mutex_postfork_child(tsd_tsdn(tsd), &arenas_lock);\n\ttcache_postfork_child(tsd_tsdn(tsd));\n\tctl_postfork_child(tsd_tsdn(tsd));\n}\n\n/******************************************************************************/\n\n/* Helps the application decide if a pointer is worth re-allocating in order to reduce fragmentation.\n * returns 0 if the allocation is in the currently active run,\n * or when it is not causing any frag issue (large or huge bin)\n * returns the bin utilization and run utilization both in fixed point 16:16.\n * If the application decides to re-allocate it should use MALLOCX_TCACHE_NONE when doing so. */\nJEMALLOC_EXPORT int JEMALLOC_NOTHROW\nget_defrag_hint(void* ptr, int *bin_util, int *run_util) {\n\tassert(ptr != NULL);\n\treturn iget_defrag_hint(TSDN_NULL, ptr, bin_util, run_util);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.2-kgnq7exerr43idfj34trfbqmeiidhb7d/spack-src/tests/assets/hash-zipmap.rdb",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.2-kgnq7exerr43idfj34trfbqmeiidhb7d/spack-src/tests/assets/encodings.rdb",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.2-kgnq7exerr43idfj34trfbqmeiidhb7d/spack-src/deps/lua/test/life.lua",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.2-kgnq7exerr43idfj34trfbqmeiidhb7d/spack-src/deps/lua/etc/lua.ico",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.2-kgnq7exerr43idfj34trfbqmeiidhb7d/spack-src/deps/lua/doc/logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.2-kgnq7exerr43idfj34trfbqmeiidhb7d/spack-src/deps/lua/doc/cover.png"
    ],
    "total_files": 701
}