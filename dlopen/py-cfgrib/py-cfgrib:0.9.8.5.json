{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/cfgrib/bindings.py": "#\n# Copyright 2017-2020 European Centre for Medium-Range Weather Forecasts (ECMWF).\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# Authors:\n#   Alessandro Amici - B-Open - https://bopen.eu\n#\n\nimport os\nimport functools\nimport logging\nimport pkgutil\nimport typing as T  # noqa\n\nimport cffi\n\nLOG = logging.getLogger(__name__)\n\n\nffi = cffi.FFI()\nffi.cdef(\n    pkgutil.get_data(__name__, 'grib_api.h').decode('utf-8')\n    + pkgutil.get_data(__name__, 'eccodes.h').decode('utf-8')\n)\n\n\nLIBNAMES = [\"eccodes\", \"libeccodes.so\", \"libeccodes\"]\n\ntry:\n    import ecmwflibs\n    LIBNAMES.insert(0, ecmwflibs.find(\"eccodes\"))\nexcept Exception:\n    pass\n\nif os.environ.get(\"ECCODES_DIR\"):\n    eccdir = os.environ[\"ECCODES_DIR\"]\n    LIBNAMES.insert(0, os.path.join(eccdir, \"lib/libeccodes.so\"))\n    LIBNAMES.insert(0, os.path.join(eccdir, \"lib64/libeccodes.so\"))\n\nfor libname in LIBNAMES:\n    try:\n        lib = ffi.dlopen(libname)\n        LOG.debug(\"ecCodes library found using name '%s'.\", libname)\n        break\n    except OSError:\n        raise RuntimeError(f\"ecCodes library not found using {LIBNAMES}\")\n\n\n# default encoding for ecCodes strings\nENC = 'ascii'\n\n#\n# from gribapi.py\n#\nCODES_PRODUCT_ANY = 0\n\"\"\" Generic product kind \"\"\"\nCODES_PRODUCT_GRIB = 1\n\"\"\" GRIB product kind \"\"\"\nCODES_PRODUCT_BUFR = 2\n\"\"\" BUFR product kind \"\"\"\nCODES_PRODUCT_METAR = 3\n\"\"\" METAR product kind \"\"\"\nCODES_PRODUCT_GTS = 4\n\"\"\" GTS product kind \"\"\"\nCODES_PRODUCT_TAF = 5\n\"\"\" TAF product kind \"\"\"\n\n# Constants for 'missing'\nGRIB_MISSING_DOUBLE = -1e100\nGRIB_MISSING_LONG = 2147483647\n\nCODES_MISSING_DOUBLE = GRIB_MISSING_DOUBLE\nCODES_MISSING_LONG = GRIB_MISSING_LONG\n\n#\n# Helper values to discriminate key types\n#\nCODES_TYPE_UNDEFINED = lib.GRIB_TYPE_UNDEFINED\nCODES_TYPE_LONG = lib.GRIB_TYPE_LONG\nCODES_TYPE_DOUBLE = lib.GRIB_TYPE_DOUBLE\nCODES_TYPE_STRING = lib.GRIB_TYPE_STRING\nCODES_TYPE_BYTES = lib.GRIB_TYPE_BYTES\nCODES_TYPE_SECTION = lib.GRIB_TYPE_SECTION\nCODES_TYPE_LABEL = lib.GRIB_TYPE_LABEL\nCODES_TYPE_MISSING = lib.GRIB_TYPE_MISSING\n\nKEYTYPES = {1: int, 2: float, 3: str}\n\nCODES_KEYS_ITERATOR_ALL_KEYS = 0\nCODES_KEYS_ITERATOR_SKIP_READ_ONLY = 1 << 0\nCODES_KEYS_ITERATOR_SKIP_OPTIONAL = 1 << 1\nCODES_KEYS_ITERATOR_SKIP_EDITION_SPECIFIC = 1 << 2\nCODES_KEYS_ITERATOR_SKIP_CODED = 1 << 3\nCODES_KEYS_ITERATOR_SKIP_COMPUTED = 1 << 4\nCODES_KEYS_ITERATOR_SKIP_DUPLICATES = 1 << 5\nCODES_KEYS_ITERATOR_SKIP_FUNCTION = 1 << 6\nCODES_KEYS_ITERATOR_DUMP_ONLY = 1 << 7\n\n\n#\n# Helper functions for error reporting\n#\ndef grib_get_error_message(code):\n    # type: (int) -> str\n    message = lib.grib_get_error_message(code)\n    return ffi.string(message).decode(ENC)\n\n\nclass GribInternalError(Exception):\n    def __init__(self, code, message=None, *args):\n        self.code = code\n        self.eccode_message = grib_get_error_message(code)\n        if message is None:\n            message = '%s (%s).' % (self.eccode_message, code)\n        super(GribInternalError, self).__init__(message, code, *args)\n\n\nclass KeyValueNotFoundError(GribInternalError):\n    \"\"\"Key/value not found.\"\"\"\n\n\nclass ReadOnlyError(GribInternalError):\n    \"\"\"Value is read only.\"\"\"\n\n\nclass FileNotFoundError(GribInternalError):\n    \"\"\"File not found.\"\"\"\n\n\nERROR_MAP = {-18: ReadOnlyError, -10: KeyValueNotFoundError, -7: FileNotFoundError}\n\n\ndef check_last(func):\n    @functools.wraps(func)\n    def wrapper(*args):\n        code = ffi.new('int *')\n        args += (code,)\n        retval = func(*args)\n        if code[0] != lib.GRIB_SUCCESS:\n            if code[0] in ERROR_MAP:\n                raise ERROR_MAP[code[0]](code[0])\n            else:\n                raise GribInternalError(code[0])\n        return retval\n\n    return wrapper\n\n\ndef check_return(func):\n    @functools.wraps(func)\n    def wrapper(*args):\n        code = func(*args)\n        if code != lib.GRIB_SUCCESS:\n            if code in ERROR_MAP:\n                raise ERROR_MAP[code](code)\n            else:\n                raise GribInternalError(code)\n\n    return wrapper\n\n\n#\n# CFFI reimplementation of gribapi.py functions with codes names\n#\ndef codes_grib_new_from_file(fileobj, product_kind=CODES_PRODUCT_GRIB, context=None):\n    if context is None:\n        context = ffi.NULL\n    try:\n        retval = check_last(lib.codes_handle_new_from_file)(context, fileobj, product_kind)\n        if retval == ffi.NULL:\n            raise EOFError(\"End of file: %r\" % fileobj)\n        else:\n            return retval\n    except GribInternalError as ex:\n        if ex.code == lib.GRIB_END_OF_FILE:\n            raise EOFError(\"End of file: %r\" % fileobj)\n        raise\n\n\ncodes_new_from_file = codes_grib_new_from_file\n\n\ndef codes_clone(handle):\n    # type: (cffi.FFI.CData) -> cffi.FFI.CData\n    cloned_handle = lib.codes_handle_clone(handle)\n    if cloned_handle is ffi.NULL:\n        raise GribInternalError(lib.GRIB_NULL_POINTER)\n    return cloned_handle\n\n\ncodes_release = lib.codes_handle_delete\n\n\n_codes_get_size = check_return(lib.codes_get_size)\n\n\ndef codes_get_size(handle, key):\n    # type: (cffi.FFI.CData, str) -> int\n    \"\"\"\n    Get the number of coded value from a key.\n    If several keys of the same name are present, the total sum is returned.\n\n    :param bytes key: the keyword to get the size of\n\n    :rtype: int\n    \"\"\"\n    size = ffi.new('size_t *')\n    _codes_get_size(handle, key.encode(ENC), size)\n    return size[0]\n\n\n_codes_get_length = check_return(lib.codes_get_length)\n\n\ndef codes_get_string_length(handle, key):\n    # type: (cffi.FFI.CData, str) -> int\n    \"\"\"\n    Get the length of the string representation of the key.\n    If several keys of the same name are present, the maximum length is returned.\n\n    :param bytes key: the keyword to get the string representation size of.\n\n    :rtype: int\n    \"\"\"\n    size = ffi.new('size_t *')\n    _codes_get_length(handle, key.encode(ENC), size)\n    return size[0]\n\n\n_codes_get_bytes = check_return(lib.codes_get_bytes)\n\n\ndef codes_get_bytes_array(handle, key, size):\n    # type: (cffi.FFI.CData, str, int) -> T.List[int]\n    \"\"\"\n    Get unsigned chars array values from a key.\n\n    :param bytes key: the keyword whose value(s) are to be extracted\n\n    :rtype: List(int)\n    \"\"\"\n    values = ffi.new('unsigned char[]', size)\n    size_p = ffi.new('size_t *', size)\n    _codes_get_bytes(handle, key.encode(ENC), values, size_p)\n    return list(values)\n\n\n_codes_get_long_array = check_return(lib.codes_get_long_array)\n\n\ndef codes_get_long_array(handle, key, size):\n    # type: (cffi.FFI.CData, str, int) -> T.List[int]\n    \"\"\"\n    Get long array values from a key.\n\n    :param bytes key: the keyword whose value(s) are to be extracted\n\n    :rtype: List(int)\n    \"\"\"\n    values = ffi.new('long[]', size)\n    size_p = ffi.new('size_t *', size)\n    _codes_get_long_array(handle, key.encode(ENC), values, size_p)\n    return list(values)\n\n\n_codes_get_double_array = check_return(lib.codes_get_double_array)\n\n\ndef codes_get_double_array(handle, key, size):\n    # type: (cffi.FFI.CData, str, int) -> T.List[float]\n    \"\"\"\n    Get double array values from a key.\n\n    :param bytes key: the keyword whose value(s) are to be extracted\n\n    :rtype: T.List(float)\n    \"\"\"\n    values = ffi.new('double[]', size)\n    size_p = ffi.new('size_t *', size)\n    _codes_get_double_array(handle, key.encode(ENC), values, size_p)\n    return list(values)\n\n\n_codes_get_string_array = check_return(lib.codes_get_string_array)\n\n\ndef codes_get_string_array(handle, key, size, length=None):\n    # type: (cffi.FFI.CData, str, int, int) -> T.List[bytes]\n    \"\"\"\n    Get string array values from a key.\n\n    :param bytes key: the keyword whose value(s) are to be extracted\n\n    :rtype: T.List[bytes]\n    \"\"\"\n    if length is None:\n        length = codes_get_string_length(handle, key)\n    values_keepalive = [ffi.new('char[]', length) for _ in range(size)]\n    values = ffi.new('char*[]', values_keepalive)\n    size_p = ffi.new('size_t *', size)\n    _codes_get_string_array(handle, key.encode(ENC), values, size_p)\n    return [ffi.string(values[i]).decode(ENC) for i in range(size_p[0])]\n\n\ndef codes_get_long(handle, key):\n    # type: (cffi.FFI.CData, str) -> int\n    value = ffi.new('long *')\n    _codes_get_long = check_return(lib.codes_get_long)\n    _codes_get_long(handle, key.encode(ENC), value)\n    return value[0]\n\n\ndef codes_get_double(handle, key):\n    # type: (cffi.FFI.CData, str) -> int\n    value = ffi.new('double *')\n    _codes_get_long = check_return(lib.codes_get_double)\n    _codes_get_long(handle, key.encode(ENC), value)\n    return value[0]\n\n\ndef codes_get_string(handle, key, length=None):\n    # type: (cffi.FFI.CData, str, int) -> str\n    \"\"\"\n    Get string element from a key.\n    It may or may not fail in case there are more than one key in a message.\n    Outputs the last element.\n\n    :param bytes key: the keyword to select the value of\n    :param int length: (optional) length of the string\n\n    :rtype: bytes\n    \"\"\"\n    if length is None:\n        length = codes_get_string_length(handle, key)\n    values = ffi.new('char[]', length)\n    length_p = ffi.new('size_t *', length)\n    _codes_get_string = check_return(lib.codes_get_string)\n    _codes_get_string(handle, key.encode(ENC), values, length_p)\n    return ffi.string(values, length_p[0]).decode(ENC)\n\n\n_codes_get_native_type = check_return(lib.codes_get_native_type)\n\n\ndef codes_get_native_type(handle, key):\n    # type: (cffi.FFI.CData, str) -> int\n    grib_type = ffi.new('int *')\n    _codes_get_native_type(handle, key.encode(ENC), grib_type)\n    return KEYTYPES.get(grib_type[0], grib_type[0])\n\n\ndef codes_get_array(handle, key, key_type=None, size=None, length=None, log=LOG):\n    # type: (cffi.FFI.CData, str, int, int, int, logging.Logger) -> T.Any\n    if key_type is None:\n        key_type = codes_get_native_type(handle, key)\n    if size is None:\n        size = codes_get_size(handle, key)\n\n    if key_type == int:\n        return codes_get_long_array(handle, key, size)\n    elif key_type == float:\n        return codes_get_double_array(handle, key, size)\n    elif key_type == str:\n        return codes_get_string_array(handle, key, size, length=length)\n    elif key_type == CODES_TYPE_BYTES:\n        return codes_get_bytes_array(handle, key, size)\n    else:\n        log.warning(\"Unknown GRIB key type: %r\", key_type)\n\n\ndef codes_get(handle, key, key_type=None, length=None, log=LOG):\n    # type: (cffi.FFI.CData, str, int, int, logging.Logger) -> T.Any\n    if key_type is None:\n        key_type = codes_get_native_type(handle, key)\n\n    if key_type == int:\n        return codes_get_long(handle, key)\n    elif key_type == float:\n        return codes_get_double(handle, key)\n    elif key_type == str:\n        return codes_get_string(handle, key, length=length)\n    else:\n        log.warning(\"Unknown GRIB key type: %r\", key_type)\n\n\ndef codes_keys_iterator_new(handle, flags=CODES_KEYS_ITERATOR_ALL_KEYS, namespace=None):\n    # type: (cffi.FFI.CData, int, str) -> cffi.FFI.CData\n    if namespace is None:\n        bnamespace = ffi.NULL\n    else:\n        bnamespace = namespace.encode(ENC)\n\n    codes_keys_iterator_new = lib.codes_keys_iterator_new\n    return codes_keys_iterator_new(handle, flags, bnamespace)\n\n\ndef codes_keys_iterator_next(iterator_id):\n    return lib.codes_keys_iterator_next(iterator_id)\n\n\ndef codes_keys_iterator_get_name(iterator):\n    ret = lib.codes_keys_iterator_get_name(iterator)\n    return ffi.string(ret).decode(ENC)\n\n\ndef codes_keys_iterator_delete(iterator_id):\n    codes_keys_iterator_delete = check_return(lib.codes_keys_iterator_delete)\n    codes_keys_iterator_delete(iterator_id)\n\n\ndef codes_get_api_version():\n    \"\"\"\n    Get the API version.\n\n    Returns the version of the API as a string in the format \"major.minor.revision\".\n    \"\"\"\n    ver = lib.codes_get_api_version()\n    patch = ver % 100\n    ver = ver // 100\n    minor = ver % 100\n    major = ver // 100\n\n    return \"%d.%d.%d\" % (major, minor, patch)\n\n\ndef portable_handle_new_from_samples(samplename, product_kind):\n    #\n    # re-implement codes_grib_handle_new_from_samples in a portable way.\n    # imports are here not to pollute the head of the file with (hopefully!) temporary stuff\n    #\n    import os.path\n    import platform\n\n    handle = ffi.NULL\n    if platform.platform().startswith('Windows'):\n        samples_folder = ffi.string(lib.codes_samples_path(ffi.NULL)).decode('utf-8')\n        sample_path = os.path.join(samples_folder, samplename + '.tmpl')\n        try:\n            with open(sample_path, 'rb') as file:\n                handle = codes_grib_new_from_file(file, product_kind)\n        except Exception:\n            logging.exception(\"creating empty message from sample failed\")\n    return handle\n\n\ndef codes_new_from_samples(samplename, product_kind=CODES_PRODUCT_GRIB):\n    # type: (str, int) -> cffi.FFI.CData\n\n    # work around an ecCodes bug on Windows, hopefully this will go away soon\n    handle = portable_handle_new_from_samples(samplename, product_kind)\n    if handle != ffi.NULL:\n        return handle\n    # end of work-around\n\n    if product_kind == CODES_PRODUCT_GRIB:\n        handle = lib.codes_grib_handle_new_from_samples(ffi.NULL, samplename.encode(ENC))\n    elif product_kind == CODES_PRODUCT_BUFR:\n        handle = lib.codes_bufr_handle_new_from_samples(ffi.NULL, samplename.encode(ENC))\n    else:\n        raise NotImplementedError(\"product kind not supported: %r\" % product_kind)\n    if handle == ffi.NULL:\n        raise ValueError(\"sample not found: %r\" % samplename)\n    return handle\n\n\ndef codes_set_long(handle, key, value):\n    # type: (cffi.FFI.CData, str, int) -> None\n    codes_set_long = check_return(lib.codes_set_long)\n    codes_set_long(handle, key.encode(ENC), value)\n\n\ndef codes_set_double(handle, key, value):\n    # type: (cffi.FFI.CData, str, float) -> None\n    codes_set_double = check_return(lib.codes_set_double)\n    codes_set_double(handle, key.encode(ENC), value)\n\n\ndef codes_set_string(handle, key, value):\n    # type: (cffi.FFI.CData, str, str) -> None\n    size = ffi.new('size_t *', len(value))\n    codes_set_string = check_return(lib.codes_set_string)\n    codes_set_string(handle, key.encode(ENC), value.encode(ENC), size)\n\n\ndef codes_set(handle, key, value):\n    \"\"\"\"\"\"\n    if isinstance(value, int):\n        codes_set_long(handle, key, value)\n    elif isinstance(value, float):\n        codes_set_double(handle, key, value)\n    elif isinstance(value, str):\n        codes_set_string(handle, key, value)\n    else:\n        raise TypeError(\"Unsupported type %r\" % type(value))\n\n\ndef codes_set_double_array(handle, key, values):\n    # type: (cffi.FFI.CData, str, T.List[float]) -> None\n    size = len(values)\n    c_values = ffi.new(\"double []\", values)\n    codes_set_double_array = check_return(lib.codes_set_double_array)\n    codes_set_double_array(handle, key.encode(ENC), c_values, size)\n\n\ndef codes_set_long_array(handle, key, values):\n    # type: (cffi.FFI.CData, str, T.List[int]) -> None\n    size = len(values)\n    c_values = ffi.new(\"long []\", values)\n    codes_set_long_array = check_return(lib.codes_set_long_array)\n    codes_set_long_array(handle, key.encode(ENC), c_values, size)\n\n\ndef codes_set_array(handle, key, values):\n    # type: (cffi.FFI.CData, str, T.List[T.Any]) -> None\n    if len(values) > 0:\n        if isinstance(values[0], float):\n            codes_set_double_array(handle, key, values)\n        elif isinstance(values[0], int):\n            codes_set_long_array(handle, key, values)\n        else:\n            raise TypeError(\"Unsupported value type: %r\" % type(values[0]))\n    else:\n        raise ValueError(\"Cannot set an empty list.\")\n\n\ndef codes_grib_multi_support_on(context=None):\n    if context is None:\n        context = ffi.NULL\n    lib.codes_grib_multi_support_on(context)\n\n\ndef codes_grib_multi_support_off(context=None):\n    if context is None:\n        context = ffi.NULL\n    lib.codes_grib_multi_support_off(context)\n\n\ndef codes_grib_multi_support_reset_file(file):\n    context = lib.codes_context_get_default()\n    return lib.codes_grib_multi_support_reset_file(context, file)\n\n\ndef codes_write(handle, outfile):\n    # type: (cffi.FFI.CData, T.BinaryIO) -> None\n    \"\"\"\n    Write a coded message to a file. If the file does not exist, it is created.\n\n    :param str path: (optional) the path to the GRIB file;\n        defaults to the one of the open index.\n    \"\"\"\n    mess = ffi.new('const void **')\n    mess_len = ffi.new('size_t*')\n    codes_get_message = check_return(lib.codes_get_message)\n    codes_get_message(handle, mess, mess_len)\n    message = ffi.buffer(mess[0], size=mess_len[0])\n    outfile.write(message)\n"
    },
    "skipped": [
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/nam.t00z.awp21100.tm00.grib2",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/era5-levels-members.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/uv_on_different_levels.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/tp_on_different_grid_resolutions.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/t_on_different_level_types.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/t_analysis_and_fc_0.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/spherical_harmonics.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/scanning_mode_64.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/regular_ll_wrong_increment.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/regular_ll_sfc.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/regular_ll_msl.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/regular_gg_wrong_increment.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/regular_gg_sfc.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/regular_gg_pl.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/regular_gg_ml_g2.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/regular_gg_ml.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/reduced_gg.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/multi_param_on_multi_dims.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/lambert_grid.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/hpa_and_pa.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/forecast_monthly_ukmo.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/fields_with_missing_values.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/era5-levels-members.grib",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cfgrib-0.9.8.5-3wvmpoe3ea3kilvcsupbhyermo7rj2gx/spack-src/tests/sample-data/era5-levels-corrupted.grib"
    ],
    "total_files": 94
}