{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-5pf2pj3n7miz4zdj2eytkioexqm5klxe/spack-src/talloc.h": "#ifndef _TALLOC_H_\n#define _TALLOC_H_\n/*\n   Unix SMB/CIFS implementation.\n   Samba temporary memory allocation functions\n\n   Copyright (C) Andrew Tridgell 2004-2005\n   Copyright (C) Stefan Metzmacher 2006\n\n     ** NOTE! The following LGPL license applies to the talloc\n     ** library. This does NOT imply that all of Samba is released\n     ** under the LGPL\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 3 of the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * @defgroup talloc The talloc API\n *\n * talloc is a hierarchical, reference counted memory pool system with\n * destructors. It is the core memory allocator used in Samba.\n *\n * @{\n */\n\n#define TALLOC_VERSION_MAJOR 2\n#define TALLOC_VERSION_MINOR 1\n\nint talloc_version_major(void);\nint talloc_version_minor(void);\n/* This is mostly useful only for testing */\nint talloc_test_get_magic(void);\n\n/**\n * @brief Define a talloc parent type\n *\n * As talloc is a hierarchial memory allocator, every talloc chunk is a\n * potential parent to other talloc chunks. So defining a separate type for a\n * talloc chunk is not strictly necessary. TALLOC_CTX is defined nevertheless,\n * as it provides an indicator for function arguments. You will frequently\n * write code like\n *\n * @code\n *      struct foo *foo_create(TALLOC_CTX *mem_ctx)\n *      {\n *              struct foo *result;\n *              result = talloc(mem_ctx, struct foo);\n *              if (result == NULL) return NULL;\n *                      ... initialize foo ...\n *              return result;\n *      }\n * @endcode\n *\n * In this type of allocating functions it is handy to have a general\n * TALLOC_CTX type to indicate which parent to put allocated structures on.\n */\ntypedef void TALLOC_CTX;\n\n/*\n  this uses a little trick to allow __LINE__ to be stringified\n*/\n#ifndef __location__\n#define __TALLOC_STRING_LINE1__(s)    #s\n#define __TALLOC_STRING_LINE2__(s)   __TALLOC_STRING_LINE1__(s)\n#define __TALLOC_STRING_LINE3__  __TALLOC_STRING_LINE2__(__LINE__)\n#define __location__ __FILE__ \":\" __TALLOC_STRING_LINE3__\n#endif\n\n#ifndef TALLOC_DEPRECATED\n#define TALLOC_DEPRECATED 0\n#endif\n\n#ifndef PRINTF_ATTRIBUTE\n#if (__GNUC__ >= 3)\n/** Use gcc attribute to check printf fns.  a1 is the 1-based index of\n * the parameter containing the format, and a2 the index of the first\n * argument. Note that some gcc 2.x versions don't handle this\n * properly **/\n#define PRINTF_ATTRIBUTE(a1, a2) __attribute__ ((format (__printf__, a1, a2)))\n#else\n#define PRINTF_ATTRIBUTE(a1, a2)\n#endif\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Create a new talloc context.\n *\n * The talloc() macro is the core of the talloc library. It takes a memory\n * context and a type, and returns a pointer to a new area of memory of the\n * given type.\n *\n * The returned pointer is itself a talloc context, so you can use it as the\n * context argument to more calls to talloc if you wish.\n *\n * The returned pointer is a \"child\" of the supplied context. This means that if\n * you talloc_free() the context then the new child disappears as well.\n * Alternatively you can free just the child.\n *\n * @param[in]  ctx      A talloc context to create a new reference on or NULL to\n *                      create a new top level context.\n *\n * @param[in]  type     The type of memory to allocate.\n *\n * @return              A type casted talloc context or NULL on error.\n *\n * @code\n *      unsigned int *a, *b;\n *\n *      a = talloc(NULL, unsigned int);\n *      b = talloc(a, unsigned int);\n * @endcode\n *\n * @see talloc_zero\n * @see talloc_array\n * @see talloc_steal\n * @see talloc_free\n */\nvoid *talloc(const void *ctx, #type);\n#else\n#define talloc(ctx, type) (type *)talloc_named_const(ctx, sizeof(type), #type)\nvoid *_talloc(const void *context, size_t size);\n#endif\n\n/**\n * @brief Create a new top level talloc context.\n *\n * This function creates a zero length named talloc context as a top level\n * context. It is equivalent to:\n *\n * @code\n *      talloc_named(NULL, 0, fmt, ...);\n * @endcode\n * @param[in]  fmt      Format string for the name.\n *\n * @param[in]  ...      Additional printf-style arguments.\n *\n * @return              The allocated memory chunk, NULL on error.\n *\n * @see talloc_named()\n */\nvoid *talloc_init(const char *fmt, ...) PRINTF_ATTRIBUTE(1,2);\n\n#ifdef DOXYGEN\n/**\n * @brief Free a chunk of talloc memory.\n *\n * The talloc_free() function frees a piece of talloc memory, and all its\n * children. You can call talloc_free() on any pointer returned by\n * talloc().\n *\n * The return value of talloc_free() indicates success or failure, with 0\n * returned for success and -1 for failure. A possible failure condition\n * is if the pointer had a destructor attached to it and the destructor\n * returned -1. See talloc_set_destructor() for details on\n * destructors. Likewise, if \"ptr\" is NULL, then the function will make\n * no modifications and return -1.\n *\n * From version 2.0 and onwards, as a special case, talloc_free() is\n * refused on pointers that have more than one parent associated, as talloc\n * would have no way of knowing which parent should be removed. This is\n * different from older versions in the sense that always the reference to\n * the most recently established parent has been destroyed. Hence to free a\n * pointer that has more than one parent please use talloc_unlink().\n *\n * To help you find problems in your code caused by this behaviour, if\n * you do try and free a pointer with more than one parent then the\n * talloc logging function will be called to give output like this:\n *\n * @code\n *   ERROR: talloc_free with references at some_dir/source/foo.c:123\n *     reference at some_dir/source/other.c:325\n *     reference at some_dir/source/third.c:121\n * @endcode\n *\n * Please see the documentation for talloc_set_log_fn() and\n * talloc_set_log_stderr() for more information on talloc logging\n * functions.\n *\n * If <code>TALLOC_FREE_FILL</code> environment variable is set,\n * the memory occupied by the context is filled with the value of this variable.\n * The value should be a numeric representation of the character you want to\n * use.\n *\n * talloc_free() operates recursively on its children.\n *\n * @param[in]  ptr      The chunk to be freed.\n *\n * @return              Returns 0 on success and -1 on error. A possible\n *                      failure condition is if the pointer had a destructor\n *                      attached to it and the destructor returned -1. Likewise,\n *                      if \"ptr\" is NULL, then the function will make no\n *                      modifications and returns -1.\n *\n * Example:\n * @code\n *      unsigned int *a, *b;\n *      a = talloc(NULL, unsigned int);\n *      b = talloc(a, unsigned int);\n *\n *      talloc_free(a); // Frees a and b\n * @endcode\n *\n * @see talloc_set_destructor()\n * @see talloc_unlink()\n */\nint talloc_free(void *ptr);\n#else\n#define talloc_free(ctx) _talloc_free(ctx, __location__)\nint _talloc_free(void *ptr, const char *location);\n#endif\n\n/**\n * @brief Free a talloc chunk's children.\n *\n * The function walks along the list of all children of a talloc context and\n * talloc_free()s only the children, not the context itself.\n *\n * A NULL argument is handled as no-op.\n *\n * @param[in]  ptr      The chunk that you want to free the children of\n *                      (NULL is allowed too)\n */\nvoid talloc_free_children(void *ptr);\n\n#ifdef DOXYGEN\n/**\n * @brief Assign a destructor function to be called when a chunk is freed.\n *\n * The function talloc_set_destructor() sets the \"destructor\" for the pointer\n * \"ptr\". A destructor is a function that is called when the memory used by a\n * pointer is about to be released. The destructor receives the pointer as an\n * argument, and should return 0 for success and -1 for failure.\n *\n * The destructor can do anything it wants to, including freeing other pieces\n * of memory. A common use for destructors is to clean up operating system\n * resources (such as open file descriptors) contained in the structure the\n * destructor is placed on.\n *\n * You can only place one destructor on a pointer. If you need more than one\n * destructor then you can create a zero-length child of the pointer and place\n * an additional destructor on that.\n *\n * To remove a destructor call talloc_set_destructor() with NULL for the\n * destructor.\n *\n * If your destructor attempts to talloc_free() the pointer that it is the\n * destructor for then talloc_free() will return -1 and the free will be\n * ignored. This would be a pointless operation anyway, as the destructor is\n * only called when the memory is just about to go away.\n *\n * @param[in]  ptr      The talloc chunk to add a destructor to.\n *\n * @param[in]  destructor  The destructor function to be called. NULL to remove\n *                         it.\n *\n * Example:\n * @code\n *      static int destroy_fd(int *fd) {\n *              close(*fd);\n *              return 0;\n *      }\n *\n *      int *open_file(const char *filename) {\n *              int *fd = talloc(NULL, int);\n *              *fd = open(filename, O_RDONLY);\n *              if (*fd < 0) {\n *                      talloc_free(fd);\n *                      return NULL;\n *              }\n *              // Whenever they free this, we close the file.\n *              talloc_set_destructor(fd, destroy_fd);\n *              return fd;\n *      }\n * @endcode\n *\n * @see talloc()\n * @see talloc_free()\n */\nvoid talloc_set_destructor(const void *ptr, int (*destructor)(void *));\n\n/**\n * @brief Change a talloc chunk's parent.\n *\n * The talloc_steal() function changes the parent context of a talloc\n * pointer. It is typically used when the context that the pointer is\n * currently a child of is going to be freed and you wish to keep the\n * memory for a longer time.\n *\n * To make the changed hierarchy less error-prone, you might consider to use\n * talloc_move().\n *\n * If you try and call talloc_steal() on a pointer that has more than one\n * parent then the result is ambiguous. Talloc will choose to remove the\n * parent that is currently indicated by talloc_parent() and replace it with\n * the chosen parent. You will also get a message like this via the talloc\n * logging functions:\n *\n * @code\n *   WARNING: talloc_steal with references at some_dir/source/foo.c:123\n *     reference at some_dir/source/other.c:325\n *     reference at some_dir/source/third.c:121\n * @endcode\n *\n * To unambiguously change the parent of a pointer please see the function\n * talloc_reparent(). See the talloc_set_log_fn() documentation for more\n * information on talloc logging.\n *\n * @param[in]  new_ctx  The new parent context.\n *\n * @param[in]  ptr      The talloc chunk to move.\n *\n * @return              Returns the pointer that you pass it. It does not have\n *                      any failure modes.\n *\n * @note It is possible to produce loops in the parent/child relationship\n * if you are not careful with talloc_steal(). No guarantees are provided\n * as to your sanity or the safety of your data if you do this.\n */\nvoid *talloc_steal(const void *new_ctx, const void *ptr);\n#else /* DOXYGEN */\n/* try to make talloc_set_destructor() and talloc_steal() type safe,\n   if we have a recent gcc */\n#if (__GNUC__ >= 3)\n#define _TALLOC_TYPEOF(ptr) __typeof__(ptr)\n#define talloc_set_destructor(ptr, function)\t\t\t\t      \\\n\tdo {\t\t\t\t\t\t\t\t      \\\n\t\tint (*_talloc_destructor_fn)(_TALLOC_TYPEOF(ptr)) = (function);\t      \\\n\t\t_talloc_set_destructor((ptr), (int (*)(void *))_talloc_destructor_fn); \\\n\t} while(0)\n/* this extremely strange macro is to avoid some braindamaged warning\n   stupidity in gcc 4.1.x */\n#define talloc_steal(ctx, ptr) ({ _TALLOC_TYPEOF(ptr) __talloc_steal_ret = (_TALLOC_TYPEOF(ptr))_talloc_steal_loc((ctx),(ptr), __location__); __talloc_steal_ret; })\n#else /* __GNUC__ >= 3 */\n#define talloc_set_destructor(ptr, function) \\\n\t_talloc_set_destructor((ptr), (int (*)(void *))(function))\n#define _TALLOC_TYPEOF(ptr) void *\n#define talloc_steal(ctx, ptr) (_TALLOC_TYPEOF(ptr))_talloc_steal_loc((ctx),(ptr), __location__)\n#endif /* __GNUC__ >= 3 */\nvoid _talloc_set_destructor(const void *ptr, int (*_destructor)(void *));\nvoid *_talloc_steal_loc(const void *new_ctx, const void *ptr, const char *location);\n#endif /* DOXYGEN */\n\n/**\n * @brief Assign a name to a talloc chunk.\n *\n * Each talloc pointer has a \"name\". The name is used principally for\n * debugging purposes, although it is also possible to set and get the name on\n * a pointer in as a way of \"marking\" pointers in your code.\n *\n * The main use for names on pointer is for \"talloc reports\". See\n * talloc_report() and talloc_report_full() for details. Also see\n * talloc_enable_leak_report() and talloc_enable_leak_report_full().\n *\n * The talloc_set_name() function allocates memory as a child of the\n * pointer. It is logically equivalent to:\n *\n * @code\n *      talloc_set_name_const(ptr, talloc_asprintf(ptr, fmt, ...));\n * @endcode\n *\n * @param[in]  ptr      The talloc chunk to assign a name to.\n *\n * @param[in]  fmt      Format string for the name.\n *\n * @param[in]  ...      Add printf-style additional arguments.\n *\n * @return              The assigned name, NULL on error.\n *\n * @note Multiple calls to talloc_set_name() will allocate more memory without\n * releasing the name. All of the memory is released when the ptr is freed\n * using talloc_free().\n */\nconst char *talloc_set_name(const void *ptr, const char *fmt, ...) PRINTF_ATTRIBUTE(2,3);\n\n#ifdef DOXYGEN\n/**\n * @brief Change a talloc chunk's parent.\n *\n * This function has the same effect as talloc_steal(), and additionally sets\n * the source pointer to NULL. You would use it like this:\n *\n * @code\n *      struct foo *X = talloc(tmp_ctx, struct foo);\n *      struct foo *Y;\n *      Y = talloc_move(new_ctx, &X);\n * @endcode\n *\n * @param[in]  new_ctx  The new parent context.\n *\n * @param[in]  pptr     Pointer to the talloc chunk to move.\n *\n * @return              The pointer of the talloc chunk it has been moved to,\n *                      NULL on error.\n */\nvoid *talloc_move(const void *new_ctx, void **pptr);\n#else\n#define talloc_move(ctx, pptr) (_TALLOC_TYPEOF(*(pptr)))_talloc_move((ctx),(void *)(pptr))\nvoid *_talloc_move(const void *new_ctx, const void *pptr);\n#endif\n\n/**\n * @brief Assign a name to a talloc chunk.\n *\n * The function is just like talloc_set_name(), but it takes a string constant,\n * and is much faster. It is extensively used by the \"auto naming\" macros, such\n * as talloc_p().\n *\n * This function does not allocate any memory. It just copies the supplied\n * pointer into the internal representation of the talloc ptr. This means you\n * must not pass a name pointer to memory that will disappear before the ptr\n * is freed with talloc_free().\n *\n * @param[in]  ptr      The talloc chunk to assign a name to.\n *\n * @param[in]  name     Format string for the name.\n */\nvoid talloc_set_name_const(const void *ptr, const char *name);\n\n/**\n * @brief Create a named talloc chunk.\n *\n * The talloc_named() function creates a named talloc pointer. It is\n * equivalent to:\n *\n * @code\n *      ptr = talloc_size(context, size);\n *      talloc_set_name(ptr, fmt, ....);\n * @endcode\n *\n * @param[in]  context  The talloc context to hang the result off.\n *\n * @param[in]  size     Number of char's that you want to allocate.\n *\n * @param[in]  fmt      Format string for the name.\n *\n * @param[in]  ...      Additional printf-style arguments.\n *\n * @return              The allocated memory chunk, NULL on error.\n *\n * @see talloc_set_name()\n */\nvoid *talloc_named(const void *context, size_t size,\n\t\t   const char *fmt, ...) PRINTF_ATTRIBUTE(3,4);\n\n/**\n * @brief Basic routine to allocate a chunk of memory.\n *\n * This is equivalent to:\n *\n * @code\n *      ptr = talloc_size(context, size);\n *      talloc_set_name_const(ptr, name);\n * @endcode\n *\n * @param[in]  context  The parent context.\n *\n * @param[in]  size     The number of char's that we want to allocate.\n *\n * @param[in]  name     The name the talloc block has.\n *\n * @return             The allocated memory chunk, NULL on error.\n */\nvoid *talloc_named_const(const void *context, size_t size, const char *name);\n\n#ifdef DOXYGEN\n/**\n * @brief Untyped allocation.\n *\n * The function should be used when you don't have a convenient type to pass to\n * talloc(). Unlike talloc(), it is not type safe (as it returns a void *), so\n * you are on your own for type checking.\n *\n * Best to use talloc() or talloc_array() instead.\n *\n * @param[in]  ctx     The talloc context to hang the result off.\n *\n * @param[in]  size    Number of char's that you want to allocate.\n *\n * @return             The allocated memory chunk, NULL on error.\n *\n * Example:\n * @code\n *      void *mem = talloc_size(NULL, 100);\n * @endcode\n */\nvoid *talloc_size(const void *ctx, size_t size);\n#else\n#define talloc_size(ctx, size) talloc_named_const(ctx, size, __location__)\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Allocate into a typed pointer.\n *\n * The talloc_ptrtype() macro should be used when you have a pointer and want\n * to allocate memory to point at with this pointer. When compiling with\n * gcc >= 3 it is typesafe. Note this is a wrapper of talloc_size() and\n * talloc_get_name() will return the current location in the source file and\n * not the type.\n *\n * @param[in]  ctx      The talloc context to hang the result off.\n *\n * @param[in]  type     The pointer you want to assign the result to.\n *\n * @return              The properly casted allocated memory chunk, NULL on\n *                      error.\n *\n * Example:\n * @code\n *       unsigned int *a = talloc_ptrtype(NULL, a);\n * @endcode\n */\nvoid *talloc_ptrtype(const void *ctx, #type);\n#else\n#define talloc_ptrtype(ctx, ptr) (_TALLOC_TYPEOF(ptr))talloc_size(ctx, sizeof(*(ptr)))\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Allocate a new 0-sized talloc chunk.\n *\n * This is a utility macro that creates a new memory context hanging off an\n * existing context, automatically naming it \"talloc_new: __location__\" where\n * __location__ is the source line it is called from. It is particularly\n * useful for creating a new temporary working context.\n *\n * @param[in]  ctx      The talloc parent context.\n *\n * @return              A new talloc chunk, NULL on error.\n */\nvoid *talloc_new(const void *ctx);\n#else\n#define talloc_new(ctx) talloc_named_const(ctx, 0, \"talloc_new: \" __location__)\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Allocate a 0-initizialized structure.\n *\n * The macro is equivalent to:\n *\n * @code\n *      ptr = talloc(ctx, type);\n *      if (ptr) memset(ptr, 0, sizeof(type));\n * @endcode\n *\n * @param[in]  ctx      The talloc context to hang the result off.\n *\n * @param[in]  type     The type that we want to allocate.\n *\n * @return              Pointer to a piece of memory, properly cast to 'type *',\n *                      NULL on error.\n *\n * Example:\n * @code\n *      unsigned int *a, *b;\n *      a = talloc_zero(NULL, unsigned int);\n *      b = talloc_zero(a, unsigned int);\n * @endcode\n *\n * @see talloc()\n * @see talloc_zero_size()\n * @see talloc_zero_array()\n */\nvoid *talloc_zero(const void *ctx, #type);\n\n/**\n * @brief Allocate untyped, 0-initialized memory.\n *\n * @param[in]  ctx      The talloc context to hang the result off.\n *\n * @param[in]  size     Number of char's that you want to allocate.\n *\n * @return              The allocated memory chunk.\n */\nvoid *talloc_zero_size(const void *ctx, size_t size);\n#else\n#define talloc_zero(ctx, type) (type *)_talloc_zero(ctx, sizeof(type), #type)\n#define talloc_zero_size(ctx, size) _talloc_zero(ctx, size, __location__)\nvoid *_talloc_zero(const void *ctx, size_t size, const char *name);\n#endif\n\n/**\n * @brief Return the name of a talloc chunk.\n *\n * @param[in]  ptr      The talloc chunk.\n *\n * @return              The current name for the given talloc pointer.\n *\n * @see talloc_set_name()\n */\nconst char *talloc_get_name(const void *ptr);\n\n/**\n * @brief Verify that a talloc chunk carries a specified name.\n *\n * This function checks if a pointer has the specified name. If it does\n * then the pointer is returned.\n *\n * @param[in]  ptr       The talloc chunk to check.\n *\n * @param[in]  name      The name to check against.\n *\n * @return               The pointer if the name matches, NULL if it doesn't.\n */\nvoid *talloc_check_name(const void *ptr, const char *name);\n\n/**\n * @brief Get the parent chunk of a pointer.\n *\n * @param[in]  ptr      The talloc pointer to inspect.\n *\n * @return              The talloc parent of ptr, NULL on error.\n */\nvoid *talloc_parent(const void *ptr);\n\n/**\n * @brief Get a talloc chunk's parent name.\n *\n * @param[in]  ptr      The talloc pointer to inspect.\n *\n * @return              The name of ptr's parent chunk.\n */\nconst char *talloc_parent_name(const void *ptr);\n\n/**\n * @brief Get the total size of a talloc chunk including its children.\n *\n * The function returns the total size in bytes used by this pointer and all\n * child pointers. Mostly useful for debugging.\n *\n * Passing NULL is allowed, but it will only give a meaningful result if\n * talloc_enable_leak_report() or talloc_enable_leak_report_full() has\n * been called.\n *\n * @param[in]  ptr      The talloc chunk.\n *\n * @return              The total size.\n */\nsize_t talloc_total_size(const void *ptr);\n\n/**\n * @brief Get the number of talloc chunks hanging off a chunk.\n *\n * The talloc_total_blocks() function returns the total memory block\n * count used by this pointer and all child pointers. Mostly useful for\n * debugging.\n *\n * Passing NULL is allowed, but it will only give a meaningful result if\n * talloc_enable_leak_report() or talloc_enable_leak_report_full() has\n * been called.\n *\n * @param[in]  ptr      The talloc chunk.\n *\n * @return              The total size.\n */\nsize_t talloc_total_blocks(const void *ptr);\n\n#ifdef DOXYGEN\n/**\n * @brief Duplicate a memory area into a talloc chunk.\n *\n * The function is equivalent to:\n *\n * @code\n *      ptr = talloc_size(ctx, size);\n *      if (ptr) memcpy(ptr, p, size);\n * @endcode\n *\n * @param[in]  t        The talloc context to hang the result off.\n *\n * @param[in]  p        The memory chunk you want to duplicate.\n *\n * @param[in]  size     Number of char's that you want copy.\n *\n * @return              The allocated memory chunk.\n *\n * @see talloc_size()\n */\nvoid *talloc_memdup(const void *t, const void *p, size_t size);\n#else\n#define talloc_memdup(t, p, size) _talloc_memdup(t, p, size, __location__)\nvoid *_talloc_memdup(const void *t, const void *p, size_t size, const char *name);\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Assign a type to a talloc chunk.\n *\n * This macro allows you to force the name of a pointer to be of a particular\n * type. This can be used in conjunction with talloc_get_type() to do type\n * checking on void* pointers.\n *\n * It is equivalent to this:\n *\n * @code\n *      talloc_set_name_const(ptr, #type)\n * @endcode\n *\n * @param[in]  ptr      The talloc chunk to assign the type to.\n *\n * @param[in]  type     The type to assign.\n */\nvoid talloc_set_type(const char *ptr, #type);\n\n/**\n * @brief Get a typed pointer out of a talloc pointer.\n *\n * This macro allows you to do type checking on talloc pointers. It is\n * particularly useful for void* private pointers. It is equivalent to\n * this:\n *\n * @code\n *      (type *)talloc_check_name(ptr, #type)\n * @endcode\n *\n * @param[in]  ptr      The talloc pointer to check.\n *\n * @param[in]  type     The type to check against.\n *\n * @return              The properly casted pointer given by ptr, NULL on error.\n */\ntype *talloc_get_type(const void *ptr, #type);\n#else\n#define talloc_set_type(ptr, type) talloc_set_name_const(ptr, #type)\n#define talloc_get_type(ptr, type) (type *)talloc_check_name(ptr, #type)\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Safely turn a void pointer into a typed pointer.\n *\n * This macro is used together with talloc(mem_ctx, struct foo). If you had to\n * assign the talloc chunk pointer to some void pointer variable,\n * talloc_get_type_abort() is the recommended way to get the convert the void\n * pointer back to a typed pointer.\n *\n * @param[in]  ptr      The void pointer to convert.\n *\n * @param[in]  type     The type that this chunk contains\n *\n * @return              The same value as ptr, type-checked and properly cast.\n */\nvoid *talloc_get_type_abort(const void *ptr, #type);\n#else\n#ifdef TALLOC_GET_TYPE_ABORT_NOOP\n#define talloc_get_type_abort(ptr, type) (type *)(ptr)\n#else\n#define talloc_get_type_abort(ptr, type) (type *)_talloc_get_type_abort(ptr, #type, __location__)\n#endif\nvoid *_talloc_get_type_abort(const void *ptr, const char *name, const char *location);\n#endif\n\n/**\n * @brief Find a parent context by name.\n *\n * Find a parent memory context of the current context that has the given\n * name. This can be very useful in complex programs where it may be\n * difficult to pass all information down to the level you need, but you\n * know the structure you want is a parent of another context.\n *\n * @param[in]  ctx      The talloc chunk to start from.\n *\n * @param[in]  name     The name of the parent we look for.\n *\n * @return              The memory context we are looking for, NULL if not\n *                      found.\n */\nvoid *talloc_find_parent_byname(const void *ctx, const char *name);\n\n#ifdef DOXYGEN\n/**\n * @brief Find a parent context by type.\n *\n * Find a parent memory context of the current context that has the given\n * name. This can be very useful in complex programs where it may be\n * difficult to pass all information down to the level you need, but you\n * know the structure you want is a parent of another context.\n *\n * Like talloc_find_parent_byname() but takes a type, making it typesafe.\n *\n * @param[in]  ptr      The talloc chunk to start from.\n *\n * @param[in]  type     The type of the parent to look for.\n *\n * @return              The memory context we are looking for, NULL if not\n *                      found.\n */\nvoid *talloc_find_parent_bytype(const void *ptr, #type);\n#else\n#define talloc_find_parent_bytype(ptr, type) (type *)talloc_find_parent_byname(ptr, #type)\n#endif\n\n/**\n * @brief Allocate a talloc pool.\n *\n * A talloc pool is a pure optimization for specific situations. In the\n * release process for Samba 3.2 we found out that we had become considerably\n * slower than Samba 3.0 was. Profiling showed that malloc(3) was a large CPU\n * consumer in benchmarks. For Samba 3.2 we have internally converted many\n * static buffers to dynamically allocated ones, so malloc(3) being beaten\n * more was no surprise. But it made us slower.\n *\n * talloc_pool() is an optimization to call malloc(3) a lot less for the use\n * pattern Samba has: The SMB protocol is mainly a request/response protocol\n * where we have to allocate a certain amount of memory per request and free\n * that after the SMB reply is sent to the client.\n *\n * talloc_pool() creates a talloc chunk that you can use as a talloc parent\n * exactly as you would use any other ::TALLOC_CTX. The difference is that\n * when you talloc a child of this pool, no malloc(3) is done. Instead, talloc\n * just increments a pointer inside the talloc_pool. This also works\n * recursively. If you use the child of the talloc pool as a parent for\n * grand-children, their memory is also taken from the talloc pool.\n *\n * If there is not enough memory in the pool to allocate the new child,\n * it will create a new talloc chunk as if the parent was a normal talloc\n * context.\n *\n * If you talloc_free() children of a talloc pool, the memory is not given\n * back to the system. Instead, free(3) is only called if the talloc_pool()\n * itself is released with talloc_free().\n *\n * The downside of a talloc pool is that if you talloc_move() a child of a\n * talloc pool to a talloc parent outside the pool, the whole pool memory is\n * not free(3)'ed until that moved chunk is also talloc_free()ed.\n *\n * @param[in]  context  The talloc context to hang the result off.\n *\n * @param[in]  size     Size of the talloc pool.\n *\n * @return              The allocated talloc pool, NULL on error.\n */\nvoid *talloc_pool(const void *context, size_t size);\n\n#ifdef DOXYGEN\n/**\n * @brief Allocate a talloc object as/with an additional pool.\n *\n * This is like talloc_pool(), but's it's more flexible\n * and allows an object to be a pool for its children.\n *\n * @param[in] ctx                   The talloc context to hang the result off.\n *\n * @param[in] type                  The type that we want to allocate.\n *\n * @param[in] num_subobjects        The expected number of subobjects, which will\n *                                  be allocated within the pool. This allocates\n *                                  space for talloc_chunk headers.\n *\n * @param[in] total_subobjects_size The size that all subobjects can use in total.\n *\n *\n * @return              The allocated talloc object, NULL on error.\n */\nvoid *talloc_pooled_object(const void *ctx, #type,\n\t\t\t   unsigned num_subobjects,\n\t\t\t   size_t total_subobjects_size);\n#else\n#define talloc_pooled_object(_ctx, _type, \\\n\t\t\t     _num_subobjects, \\\n\t\t\t     _total_subobjects_size) \\\n\t(_type *)_talloc_pooled_object((_ctx), sizeof(_type), #_type, \\\n\t\t\t\t\t(_num_subobjects), \\\n\t\t\t\t\t(_total_subobjects_size))\nvoid *_talloc_pooled_object(const void *ctx,\n\t\t\t    size_t type_size,\n\t\t\t    const char *type_name,\n\t\t\t    unsigned num_subobjects,\n\t\t\t    size_t total_subobjects_size);\n#endif\n\n/**\n * @brief Free a talloc chunk and NULL out the pointer.\n *\n * TALLOC_FREE() frees a pointer and sets it to NULL. Use this if you want\n * immediate feedback (i.e. crash) if you use a pointer after having free'ed\n * it.\n *\n * @param[in]  ctx      The chunk to be freed.\n */\n#define TALLOC_FREE(ctx) do { if (ctx != NULL) { talloc_free(ctx); ctx=NULL; } } while(0)\n\n/* @} ******************************************************************/\n\n/**\n * \\defgroup talloc_ref The talloc reference function.\n * @ingroup talloc\n *\n * This module contains the definitions around talloc references\n *\n * @{\n */\n\n/**\n * @brief Increase the reference count of a talloc chunk.\n *\n * The talloc_increase_ref_count(ptr) function is exactly equivalent to:\n *\n * @code\n *      talloc_reference(NULL, ptr);\n * @endcode\n *\n * You can use either syntax, depending on which you think is clearer in\n * your code.\n *\n * @param[in]  ptr      The pointer to increase the reference count.\n *\n * @return              0 on success, -1 on error.\n */\nint talloc_increase_ref_count(const void *ptr);\n\n/**\n * @brief Get the number of references to a talloc chunk.\n *\n * @param[in]  ptr      The pointer to retrieve the reference count from.\n *\n * @return              The number of references.\n */\nsize_t talloc_reference_count(const void *ptr);\n\n#ifdef DOXYGEN\n/**\n * @brief Create an additional talloc parent to a pointer.\n *\n * The talloc_reference() function makes \"context\" an additional parent of\n * ptr. Each additional reference consumes around 48 bytes of memory on intel\n * x86 platforms.\n *\n * If ptr is NULL, then the function is a no-op, and simply returns NULL.\n *\n * After creating a reference you can free it in one of the following ways:\n *\n * - you can talloc_free() any parent of the original pointer. That\n *   will reduce the number of parents of this pointer by 1, and will\n *   cause this pointer to be freed if it runs out of parents.\n *\n * - you can talloc_free() the pointer itself if it has at maximum one\n *   parent. This behaviour has been changed since the release of version\n *   2.0. Further informations in the description of \"talloc_free\".\n *\n * For more control on which parent to remove, see talloc_unlink()\n * @param[in]  ctx      The additional parent.\n *\n * @param[in]  ptr      The pointer you want to create an additional parent for.\n *\n * @return              The original pointer 'ptr', NULL if talloc ran out of\n *                      memory in creating the reference.\n *\n * @warning You should try to avoid using this interface. It turns a beautiful\n *          talloc-tree into a graph. It is often really hard to debug if you\n *          screw something up by accident.\n *\n * Example:\n * @code\n *      unsigned int *a, *b, *c;\n *      a = talloc(NULL, unsigned int);\n *      b = talloc(NULL, unsigned int);\n *      c = talloc(a, unsigned int);\n *      // b also serves as a parent of c.\n *      talloc_reference(b, c);\n * @endcode\n *\n * @see talloc_unlink()\n */\nvoid *talloc_reference(const void *ctx, const void *ptr);\n#else\n#define talloc_reference(ctx, ptr) (_TALLOC_TYPEOF(ptr))_talloc_reference_loc((ctx),(ptr), __location__)\nvoid *_talloc_reference_loc(const void *context, const void *ptr, const char *location);\n#endif\n\n/**\n * @brief Remove a specific parent from a talloc chunk.\n *\n * The function removes a specific parent from ptr. The context passed must\n * either be a context used in talloc_reference() with this pointer, or must be\n * a direct parent of ptr.\n *\n * You can just use talloc_free() instead of talloc_unlink() if there\n * is at maximum one parent. This behaviour has been changed since the\n * release of version 2.0. Further informations in the description of\n * \"talloc_free\".\n *\n * @param[in]  context  The talloc parent to remove.\n *\n * @param[in]  ptr      The talloc ptr you want to remove the parent from.\n *\n * @return              0 on success, -1 on error.\n *\n * @note If the parent has already been removed using talloc_free() then\n * this function will fail and will return -1.  Likewise, if ptr is NULL,\n * then the function will make no modifications and return -1.\n *\n * @warning You should try to avoid using this interface. It turns a beautiful\n *          talloc-tree into a graph. It is often really hard to debug if you\n *          screw something up by accident.\n *\n * Example:\n * @code\n *      unsigned int *a, *b, *c;\n *      a = talloc(NULL, unsigned int);\n *      b = talloc(NULL, unsigned int);\n *      c = talloc(a, unsigned int);\n *      // b also serves as a parent of c.\n *      talloc_reference(b, c);\n *      talloc_unlink(b, c);\n * @endcode\n */\nint talloc_unlink(const void *context, void *ptr);\n\n/**\n * @brief Provide a talloc context that is freed at program exit.\n *\n * This is a handy utility function that returns a talloc context\n * which will be automatically freed on program exit. This can be used\n * to reduce the noise in memory leak reports.\n *\n * Never use this in code that might be used in objects loaded with\n * dlopen and unloaded with dlclose. talloc_autofree_context()\n * internally uses atexit(3). Some platforms like modern Linux handles\n * this fine, but for example FreeBSD does not deal well with dlopen()\n * and atexit() used simultaneously: dlclose() does not clean up the\n * list of atexit-handlers, so when the program exits the code that\n * was registered from within talloc_autofree_context() is gone, the\n * program crashes at exit.\n *\n * @return              A talloc context, NULL on error.\n */\nvoid *talloc_autofree_context(void);\n\n/**\n * @brief Get the size of a talloc chunk.\n *\n * This function lets you know the amount of memory allocated so far by\n * this context. It does NOT account for subcontext memory.\n * This can be used to calculate the size of an array.\n *\n * @param[in]  ctx      The talloc chunk.\n *\n * @return              The size of the talloc chunk.\n */\nsize_t talloc_get_size(const void *ctx);\n\n/**\n * @brief Show the parentage of a context.\n *\n * @param[in]  context            The talloc context to look at.\n *\n * @param[in]  file               The output to use, a file, stdout or stderr.\n */\nvoid talloc_show_parents(const void *context, FILE *file);\n\n/**\n * @brief Check if a context is parent of a talloc chunk.\n *\n * This checks if context is referenced in the talloc hierarchy above ptr.\n *\n * @param[in]  context  The assumed talloc context.\n *\n * @param[in]  ptr      The talloc chunk to check.\n *\n * @return              Return 1 if this is the case, 0 if not.\n */\nint talloc_is_parent(const void *context, const void *ptr);\n\n/**\n * @brief Change the parent context of a talloc pointer.\n *\n * The function changes the parent context of a talloc pointer. It is typically\n * used when the context that the pointer is currently a child of is going to be\n * freed and you wish to keep the memory for a longer time.\n *\n * The difference between talloc_reparent() and talloc_steal() is that\n * talloc_reparent() can specify which parent you wish to change. This is\n * useful when a pointer has multiple parents via references.\n *\n * @param[in]  old_parent\n * @param[in]  new_parent\n * @param[in]  ptr\n *\n * @return              Return the pointer you passed. It does not have any\n *                      failure modes.\n */\nvoid *talloc_reparent(const void *old_parent, const void *new_parent, const void *ptr);\n\n/* @} ******************************************************************/\n\n/**\n * @defgroup talloc_array The talloc array functions\n * @ingroup talloc\n *\n * Talloc contains some handy helpers for handling Arrays conveniently\n *\n * @{\n */\n\n#ifdef DOXYGEN\n/**\n * @brief Allocate an array.\n *\n * The macro is equivalent to:\n *\n * @code\n *      (type *)talloc_size(ctx, sizeof(type) * count);\n * @endcode\n *\n * except that it provides integer overflow protection for the multiply,\n * returning NULL if the multiply overflows.\n *\n * @param[in]  ctx      The talloc context to hang the result off.\n *\n * @param[in]  type     The type that we want to allocate.\n *\n * @param[in]  count    The number of 'type' elements you want to allocate.\n *\n * @return              The allocated result, properly cast to 'type *', NULL on\n *                      error.\n *\n * Example:\n * @code\n *      unsigned int *a, *b;\n *      a = talloc_zero(NULL, unsigned int);\n *      b = talloc_array(a, unsigned int, 100);\n * @endcode\n *\n * @see talloc()\n * @see talloc_zero_array()\n */\nvoid *talloc_array(const void *ctx, #type, unsigned count);\n#else\n#define talloc_array(ctx, type, count) (type *)_talloc_array(ctx, sizeof(type), count, #type)\nvoid *_talloc_array(const void *ctx, size_t el_size, unsigned count, const char *name);\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Allocate an array.\n *\n * @param[in]  ctx      The talloc context to hang the result off.\n *\n * @param[in]  size     The size of an array element.\n *\n * @param[in]  count    The number of elements you want to allocate.\n *\n * @return              The allocated result, NULL on error.\n */\nvoid *talloc_array_size(const void *ctx, size_t size, unsigned count);\n#else\n#define talloc_array_size(ctx, size, count) _talloc_array(ctx, size, count, __location__)\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Allocate an array into a typed pointer.\n *\n * The macro should be used when you have a pointer to an array and want to\n * allocate memory of an array to point at with this pointer. When compiling\n * with gcc >= 3 it is typesafe. Note this is a wrapper of talloc_array_size()\n * and talloc_get_name() will return the current location in the source file\n * and not the type.\n *\n * @param[in]  ctx      The talloc context to hang the result off.\n *\n * @param[in]  ptr      The pointer you want to assign the result to.\n *\n * @param[in]  count    The number of elements you want to allocate.\n *\n * @return              The allocated memory chunk, properly casted. NULL on\n *                      error.\n */\nvoid *talloc_array_ptrtype(const void *ctx, const void *ptr, unsigned count);\n#else\n#define talloc_array_ptrtype(ctx, ptr, count) (_TALLOC_TYPEOF(ptr))talloc_array_size(ctx, sizeof(*(ptr)), count)\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Get the number of elements in a talloc'ed array.\n *\n * A talloc chunk carries its own size, so for talloc'ed arrays it is not\n * necessary to store the number of elements explicitly.\n *\n * @param[in]  ctx      The allocated array.\n *\n * @return              The number of elements in ctx.\n */\nsize_t talloc_array_length(const void *ctx);\n#else\n#define talloc_array_length(ctx) (talloc_get_size(ctx)/sizeof(*ctx))\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Allocate a zero-initialized array\n *\n * @param[in]  ctx      The talloc context to hang the result off.\n *\n * @param[in]  type     The type that we want to allocate.\n *\n * @param[in]  count    The number of \"type\" elements you want to allocate.\n *\n * @return              The allocated result casted to \"type *\", NULL on error.\n *\n * The talloc_zero_array() macro is equivalent to:\n *\n * @code\n *     ptr = talloc_array(ctx, type, count);\n *     if (ptr) memset(ptr, sizeof(type) * count);\n * @endcode\n */\nvoid *talloc_zero_array(const void *ctx, #type, unsigned count);\n#else\n#define talloc_zero_array(ctx, type, count) (type *)_talloc_zero_array(ctx, sizeof(type), count, #type)\nvoid *_talloc_zero_array(const void *ctx,\n\t\t\t size_t el_size,\n\t\t\t unsigned count,\n\t\t\t const char *name);\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Change the size of a talloc array.\n *\n * The macro changes the size of a talloc pointer. The 'count' argument is the\n * number of elements of type 'type' that you want the resulting pointer to\n * hold.\n *\n * talloc_realloc() has the following equivalences:\n *\n * @code\n *      talloc_realloc(ctx, NULL, type, 1) ==> talloc(ctx, type);\n *      talloc_realloc(ctx, NULL, type, N) ==> talloc_array(ctx, type, N);\n *      talloc_realloc(ctx, ptr, type, 0)  ==> talloc_free(ptr);\n * @endcode\n *\n * The \"context\" argument is only used if \"ptr\" is NULL, otherwise it is\n * ignored.\n *\n * @param[in]  ctx      The parent context used if ptr is NULL.\n *\n * @param[in]  ptr      The chunk to be resized.\n *\n * @param[in]  type     The type of the array element inside ptr.\n *\n * @param[in]  count    The intended number of array elements.\n *\n * @return              The new array, NULL on error. The call will fail either\n *                      due to a lack of memory, or because the pointer has more\n *                      than one parent (see talloc_reference()).\n */\nvoid *talloc_realloc(const void *ctx, void *ptr, #type, size_t count);\n#else\n#define talloc_realloc(ctx, p, type, count) (type *)_talloc_realloc_array(ctx, p, sizeof(type), count, #type)\nvoid *_talloc_realloc_array(const void *ctx, void *ptr, size_t el_size, unsigned count, const char *name);\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Untyped realloc to change the size of a talloc array.\n *\n * The macro is useful when the type is not known so the typesafe\n * talloc_realloc() cannot be used.\n *\n * @param[in]  ctx      The parent context used if 'ptr' is NULL.\n *\n * @param[in]  ptr      The chunk to be resized.\n *\n * @param[in]  size     The new chunk size.\n *\n * @return              The new array, NULL on error.\n */\nvoid *talloc_realloc_size(const void *ctx, void *ptr, size_t size);\n#else\n#define talloc_realloc_size(ctx, ptr, size) _talloc_realloc(ctx, ptr, size, __location__)\nvoid *_talloc_realloc(const void *context, void *ptr, size_t size, const char *name);\n#endif\n\n/**\n * @brief Provide a function version of talloc_realloc_size.\n *\n * This is a non-macro version of talloc_realloc(), which is useful as\n * libraries sometimes want a ralloc function pointer. A realloc()\n * implementation encapsulates the functionality of malloc(), free() and\n * realloc() in one call, which is why it is useful to be able to pass around\n * a single function pointer.\n *\n * @param[in]  context  The parent context used if ptr is NULL.\n *\n * @param[in]  ptr      The chunk to be resized.\n *\n * @param[in]  size     The new chunk size.\n *\n * @return              The new chunk, NULL on error.\n */\nvoid *talloc_realloc_fn(const void *context, void *ptr, size_t size);\n\n/* @} ******************************************************************/\n\n/**\n * @defgroup talloc_string The talloc string functions.\n * @ingroup talloc\n *\n * talloc string allocation and manipulation functions.\n * @{\n */\n\n/**\n * @brief Duplicate a string into a talloc chunk.\n *\n * This function is equivalent to:\n *\n * @code\n *      ptr = talloc_size(ctx, strlen(p)+1);\n *      if (ptr) memcpy(ptr, p, strlen(p)+1);\n * @endcode\n *\n * This functions sets the name of the new pointer to the passed\n * string. This is equivalent to:\n *\n * @code\n *      talloc_set_name_const(ptr, ptr)\n * @endcode\n *\n * @param[in]  t        The talloc context to hang the result off.\n *\n * @param[in]  p        The string you want to duplicate.\n *\n * @return              The duplicated string, NULL on error.\n */\nchar *talloc_strdup(const void *t, const char *p);\n\n/**\n * @brief Append a string to given string.\n *\n * The destination string is reallocated to take\n * <code>strlen(s) + strlen(a) + 1</code> characters.\n *\n * This functions sets the name of the new pointer to the new\n * string. This is equivalent to:\n *\n * @code\n *      talloc_set_name_const(ptr, ptr)\n * @endcode\n *\n * If <code>s == NULL</code> then new context is created.\n *\n * @param[in]  s        The destination to append to.\n *\n * @param[in]  a        The string you want to append.\n *\n * @return              The concatenated strings, NULL on error.\n *\n * @see talloc_strdup()\n * @see talloc_strdup_append_buffer()\n */\nchar *talloc_strdup_append(char *s, const char *a);\n\n/**\n * @brief Append a string to a given buffer.\n *\n * This is a more efficient version of talloc_strdup_append(). It determines the\n * length of the destination string by the size of the talloc context.\n *\n * Use this very carefully as it produces a different result than\n * talloc_strdup_append() when a zero character is in the middle of the\n * destination string.\n *\n * @code\n *      char *str_a = talloc_strdup(NULL, \"hello world\");\n *      char *str_b = talloc_strdup(NULL, \"hello world\");\n *      str_a[5] = str_b[5] = '\\0'\n *\n *      char *app = talloc_strdup_append(str_a, \", hello\");\n *      char *buf = talloc_strdup_append_buffer(str_b, \", hello\");\n *\n *      printf(\"%s\\n\", app); // hello, hello (app = \"hello, hello\")\n *      printf(\"%s\\n\", buf); // hello (buf = \"hello\\0world, hello\")\n * @endcode\n *\n * If <code>s == NULL</code> then new context is created.\n *\n * @param[in]  s        The destination buffer to append to.\n *\n * @param[in]  a        The string you want to append.\n *\n * @return              The concatenated strings, NULL on error.\n *\n * @see talloc_strdup()\n * @see talloc_strdup_append()\n * @see talloc_array_length()\n */\nchar *talloc_strdup_append_buffer(char *s, const char *a);\n\n/**\n * @brief Duplicate a length-limited string into a talloc chunk.\n *\n * This function is the talloc equivalent of the C library function strndup(3).\n *\n * This functions sets the name of the new pointer to the passed string. This is\n * equivalent to:\n *\n * @code\n *      talloc_set_name_const(ptr, ptr)\n * @endcode\n *\n * @param[in]  t        The talloc context to hang the result off.\n *\n * @param[in]  p        The string you want to duplicate.\n *\n * @param[in]  n        The maximum string length to duplicate.\n *\n * @return              The duplicated string, NULL on error.\n */\nchar *talloc_strndup(const void *t, const char *p, size_t n);\n\n/**\n * @brief Append at most n characters of a string to given string.\n *\n * The destination string is reallocated to take\n * <code>strlen(s) + strnlen(a, n) + 1</code> characters.\n *\n * This functions sets the name of the new pointer to the new\n * string. This is equivalent to:\n *\n * @code\n *      talloc_set_name_const(ptr, ptr)\n * @endcode\n *\n * If <code>s == NULL</code> then new context is created.\n *\n * @param[in]  s        The destination string to append to.\n *\n * @param[in]  a        The source string you want to append.\n *\n * @param[in]  n        The number of characters you want to append from the\n *                      string.\n *\n * @return              The concatenated strings, NULL on error.\n *\n * @see talloc_strndup()\n * @see talloc_strndup_append_buffer()\n */\nchar *talloc_strndup_append(char *s, const char *a, size_t n);\n\n/**\n * @brief Append at most n characters of a string to given buffer\n *\n * This is a more efficient version of talloc_strndup_append(). It determines\n * the length of the destination string by the size of the talloc context.\n *\n * Use this very carefully as it produces a different result than\n * talloc_strndup_append() when a zero character is in the middle of the\n * destination string.\n *\n * @code\n *      char *str_a = talloc_strdup(NULL, \"hello world\");\n *      char *str_b = talloc_strdup(NULL, \"hello world\");\n *      str_a[5] = str_b[5] = '\\0'\n *\n *      char *app = talloc_strndup_append(str_a, \", hello\", 7);\n *      char *buf = talloc_strndup_append_buffer(str_b, \", hello\", 7);\n *\n *      printf(\"%s\\n\", app); // hello, hello (app = \"hello, hello\")\n *      printf(\"%s\\n\", buf); // hello (buf = \"hello\\0world, hello\")\n * @endcode\n *\n * If <code>s == NULL</code> then new context is created.\n *\n * @param[in]  s        The destination buffer to append to.\n *\n * @param[in]  a        The source string you want to append.\n *\n * @param[in]  n        The number of characters you want to append from the\n *                      string.\n *\n * @return              The concatenated strings, NULL on error.\n *\n * @see talloc_strndup()\n * @see talloc_strndup_append()\n * @see talloc_array_length()\n */\nchar *talloc_strndup_append_buffer(char *s, const char *a, size_t n);\n\n/**\n * @brief Format a string given a va_list.\n *\n * This function is the talloc equivalent of the C library function\n * vasprintf(3).\n *\n * This functions sets the name of the new pointer to the new string. This is\n * equivalent to:\n *\n * @code\n *      talloc_set_name_const(ptr, ptr)\n * @endcode\n *\n * @param[in]  t        The talloc context to hang the result off.\n *\n * @param[in]  fmt      The format string.\n *\n * @param[in]  ap       The parameters used to fill fmt.\n *\n * @return              The formatted string, NULL on error.\n */\nchar *talloc_vasprintf(const void *t, const char *fmt, va_list ap) PRINTF_ATTRIBUTE(2,0);\n\n/**\n * @brief Format a string given a va_list and append it to the given destination\n *        string.\n *\n * @param[in]  s        The destination string to append to.\n *\n * @param[in]  fmt      The format string.\n *\n * @param[in]  ap       The parameters used to fill fmt.\n *\n * @return              The formatted string, NULL on error.\n *\n * @see talloc_vasprintf()\n */\nchar *talloc_vasprintf_append(char *s, const char *fmt, va_list ap) PRINTF_ATTRIBUTE(2,0);\n\n/**\n * @brief Format a string given a va_list and append it to the given destination\n *        buffer.\n *\n * @param[in]  s        The destination buffer to append to.\n *\n * @param[in]  fmt      The format string.\n *\n * @param[in]  ap       The parameters used to fill fmt.\n *\n * @return              The formatted string, NULL on error.\n *\n * @see talloc_vasprintf()\n */\nchar *talloc_vasprintf_append_buffer(char *s, const char *fmt, va_list ap) PRINTF_ATTRIBUTE(2,0);\n\n/**\n * @brief Format a string.\n *\n * This function is the talloc equivalent of the C library function asprintf(3).\n *\n * This functions sets the name of the new pointer to the new string. This is\n * equivalent to:\n *\n * @code\n *      talloc_set_name_const(ptr, ptr)\n * @endcode\n *\n * @param[in]  t        The talloc context to hang the result off.\n *\n * @param[in]  fmt      The format string.\n *\n * @param[in]  ...      The parameters used to fill fmt.\n *\n * @return              The formatted string, NULL on error.\n */\nchar *talloc_asprintf(const void *t, const char *fmt, ...) PRINTF_ATTRIBUTE(2,3);\n\n/**\n * @brief Append a formatted string to another string.\n *\n * This function appends the given formatted string to the given string. Use\n * this variant when the string in the current talloc buffer may have been\n * truncated in length.\n *\n * This functions sets the name of the new pointer to the new\n * string. This is equivalent to:\n *\n * @code\n *      talloc_set_name_const(ptr, ptr)\n * @endcode\n *\n * If <code>s == NULL</code> then new context is created.\n *\n * @param[in]  s        The string to append to.\n *\n * @param[in]  fmt      The format string.\n *\n * @param[in]  ...      The parameters used to fill fmt.\n *\n * @return              The formatted string, NULL on error.\n */\nchar *talloc_asprintf_append(char *s, const char *fmt, ...) PRINTF_ATTRIBUTE(2,3);\n\n/**\n * @brief Append a formatted string to another string.\n *\n * This is a more efficient version of talloc_asprintf_append(). It determines\n * the length of the destination string by the size of the talloc context.\n *\n * Use this very carefully as it produces a different result than\n * talloc_asprintf_append() when a zero character is in the middle of the\n * destination string.\n *\n * @code\n *      char *str_a = talloc_strdup(NULL, \"hello world\");\n *      char *str_b = talloc_strdup(NULL, \"hello world\");\n *      str_a[5] = str_b[5] = '\\0'\n *\n *      char *app = talloc_asprintf_append(str_a, \"%s\", \", hello\");\n *      char *buf = talloc_strdup_append_buffer(str_b, \"%s\", \", hello\");\n *\n *      printf(\"%s\\n\", app); // hello, hello (app = \"hello, hello\")\n *      printf(\"%s\\n\", buf); // hello (buf = \"hello\\0world, hello\")\n * @endcode\n *\n * If <code>s == NULL</code> then new context is created.\n *\n * @param[in]  s        The string to append to\n *\n * @param[in]  fmt      The format string.\n *\n * @param[in]  ...      The parameters used to fill fmt.\n *\n * @return              The formatted string, NULL on error.\n *\n * @see talloc_asprintf()\n * @see talloc_asprintf_append()\n */\nchar *talloc_asprintf_append_buffer(char *s, const char *fmt, ...) PRINTF_ATTRIBUTE(2,3);\n\n/* @} ******************************************************************/\n\n/**\n * @defgroup talloc_debug The talloc debugging support functions\n * @ingroup talloc\n *\n * To aid memory debugging, talloc contains routines to inspect the currently\n * allocated memory hierarchy.\n *\n * @{\n */\n\n/**\n * @brief Walk a complete talloc hierarchy.\n *\n * This provides a more flexible reports than talloc_report(). It\n * will recursively call the callback for the entire tree of memory\n * referenced by the pointer. References in the tree are passed with\n * is_ref = 1 and the pointer that is referenced.\n *\n * You can pass NULL for the pointer, in which case a report is\n * printed for the top level memory context, but only if\n * talloc_enable_leak_report() or talloc_enable_leak_report_full()\n * has been called.\n *\n * The recursion is stopped when depth >= max_depth.\n * max_depth = -1 means only stop at leaf nodes.\n *\n * @param[in]  ptr      The talloc chunk.\n *\n * @param[in]  depth    Internal parameter to control recursion. Call with 0.\n *\n * @param[in]  max_depth  Maximum recursion level.\n *\n * @param[in]  callback  Function to be called on every chunk.\n *\n * @param[in]  private_data  Private pointer passed to callback.\n */\nvoid talloc_report_depth_cb(const void *ptr, int depth, int max_depth,\n\t\t\t    void (*callback)(const void *ptr,\n\t\t\t\t\t     int depth, int max_depth,\n\t\t\t\t\t     int is_ref,\n\t\t\t\t\t     void *private_data),\n\t\t\t    void *private_data);\n\n/**\n * @brief Print a talloc hierarchy.\n *\n * This provides a more flexible reports than talloc_report(). It\n * will let you specify the depth and max_depth.\n *\n * @param[in]  ptr      The talloc chunk.\n *\n * @param[in]  depth    Internal parameter to control recursion. Call with 0.\n *\n * @param[in]  max_depth  Maximum recursion level.\n *\n * @param[in]  f        The file handle to print to.\n */\nvoid talloc_report_depth_file(const void *ptr, int depth, int max_depth, FILE *f);\n\n/**\n * @brief Print a summary report of all memory used by ptr.\n *\n * This provides a more detailed report than talloc_report(). It will\n * recursively print the entire tree of memory referenced by the\n * pointer. References in the tree are shown by giving the name of the\n * pointer that is referenced.\n *\n * You can pass NULL for the pointer, in which case a report is printed\n * for the top level memory context, but only if\n * talloc_enable_leak_report() or talloc_enable_leak_report_full() has\n * been called.\n *\n * @param[in]  ptr      The talloc chunk.\n *\n * @param[in]  f        The file handle to print to.\n *\n * Example:\n * @code\n *      unsigned int *a, *b;\n *      a = talloc(NULL, unsigned int);\n *      b = talloc(a, unsigned int);\n *      fprintf(stderr, \"Dumping memory tree for a:\\n\");\n *      talloc_report_full(a, stderr);\n * @endcode\n *\n * @see talloc_report()\n */\nvoid talloc_report_full(const void *ptr, FILE *f);\n\n/**\n * @brief Print a summary report of all memory used by ptr.\n *\n * This function prints a summary report of all memory used by ptr. One line of\n * report is printed for each immediate child of ptr, showing the total memory\n * and number of blocks used by that child.\n *\n * You can pass NULL for the pointer, in which case a report is printed\n * for the top level memory context, but only if talloc_enable_leak_report()\n * or talloc_enable_leak_report_full() has been called.\n *\n * @param[in]  ptr      The talloc chunk.\n *\n * @param[in]  f        The file handle to print to.\n *\n * Example:\n * @code\n *      unsigned int *a, *b;\n *      a = talloc(NULL, unsigned int);\n *      b = talloc(a, unsigned int);\n *      fprintf(stderr, \"Summary of memory tree for a:\\n\");\n *      talloc_report(a, stderr);\n * @endcode\n *\n * @see talloc_report_full()\n */\nvoid talloc_report(const void *ptr, FILE *f);\n\n/**\n * @brief Enable tracking the use of NULL memory contexts.\n *\n * This enables tracking of the NULL memory context without enabling leak\n * reporting on exit. Useful for when you want to do your own leak\n * reporting call via talloc_report_null_full();\n */\nvoid talloc_enable_null_tracking(void);\n\n/**\n * @brief Enable tracking the use of NULL memory contexts.\n *\n * This enables tracking of the NULL memory context without enabling leak\n * reporting on exit. Useful for when you want to do your own leak\n * reporting call via talloc_report_null_full();\n */\nvoid talloc_enable_null_tracking_no_autofree(void);\n\n/**\n * @brief Disable tracking of the NULL memory context.\n *\n * This disables tracking of the NULL memory context.\n */\nvoid talloc_disable_null_tracking(void);\n\n/**\n * @brief Enable leak report when a program exits.\n *\n * This enables calling of talloc_report(NULL, stderr) when the program\n * exits. In Samba4 this is enabled by using the --leak-report command\n * line option.\n *\n * For it to be useful, this function must be called before any other\n * talloc function as it establishes a \"null context\" that acts as the\n * top of the tree. If you don't call this function first then passing\n * NULL to talloc_report() or talloc_report_full() won't give you the\n * full tree printout.\n *\n * Here is a typical talloc report:\n *\n * @code\n * talloc report on 'null_context' (total 267 bytes in 15 blocks)\n *      libcli/auth/spnego_parse.c:55  contains     31 bytes in   2 blocks\n *      libcli/auth/spnego_parse.c:55  contains     31 bytes in   2 blocks\n *      iconv(UTF8,CP850)              contains     42 bytes in   2 blocks\n *      libcli/auth/spnego_parse.c:55  contains     31 bytes in   2 blocks\n *      iconv(CP850,UTF8)              contains     42 bytes in   2 blocks\n *      iconv(UTF8,UTF-16LE)           contains     45 bytes in   2 blocks\n *      iconv(UTF-16LE,UTF8)           contains     45 bytes in   2 blocks\n * @endcode\n */\nvoid talloc_enable_leak_report(void);\n\n/**\n * @brief Enable full leak report when a program exits.\n *\n * This enables calling of talloc_report_full(NULL, stderr) when the\n * program exits. In Samba4 this is enabled by using the\n * --leak-report-full command line option.\n *\n * For it to be useful, this function must be called before any other\n * talloc function as it establishes a \"null context\" that acts as the\n * top of the tree. If you don't call this function first then passing\n * NULL to talloc_report() or talloc_report_full() won't give you the\n * full tree printout.\n *\n * Here is a typical full report:\n *\n * @code\n * full talloc report on 'root' (total 18 bytes in 8 blocks)\n *      p1                             contains     18 bytes in   7 blocks (ref 0)\n *      r1                             contains     13 bytes in   2 blocks (ref 0)\n *      reference to: p2\n *      p2                             contains      1 bytes in   1 blocks (ref 1)\n *      x3                             contains      1 bytes in   1 blocks (ref 0)\n *      x2                             contains      1 bytes in   1 blocks (ref 0)\n *      x1                             contains      1 bytes in   1 blocks (ref 0)\n * @endcode\n */\nvoid talloc_enable_leak_report_full(void);\n\n/**\n * @brief Set a custom \"abort\" function that is called on serious error.\n *\n * The default \"abort\" function is <code>abort()</code>.\n *\n * The \"abort\" function is called when:\n *\n * <ul>\n *  <li>talloc_get_type_abort() fails</li>\n *  <li>the provided pointer is not a valid talloc context</li>\n *  <li>when the context meta data are invalid</li>\n *  <li>when access after free is detected</li>\n * </ul>\n *\n * Example:\n *\n * @code\n * void my_abort(const char *reason)\n * {\n *      fprintf(stderr, \"talloc abort: %s\\n\", reason);\n *      abort();\n * }\n *\n *      talloc_set_abort_fn(my_abort);\n * @endcode\n *\n * @param[in]  abort_fn      The new \"abort\" function.\n *\n * @see talloc_set_log_fn()\n * @see talloc_get_type()\n */\nvoid talloc_set_abort_fn(void (*abort_fn)(const char *reason));\n\n/**\n * @brief Set a logging function.\n *\n * @param[in]  log_fn      The logging function.\n *\n * @see talloc_set_log_stderr()\n * @see talloc_set_abort_fn()\n */\nvoid talloc_set_log_fn(void (*log_fn)(const char *message));\n\n/**\n * @brief Set stderr as the output for logs.\n *\n * @see talloc_set_log_fn()\n * @see talloc_set_abort_fn()\n */\nvoid talloc_set_log_stderr(void);\n\n/**\n * @brief Set a max memory limit for the current context hierarchy\n *\t  This affects all children of this context and constrain any\n *\t  allocation in the hierarchy to never exceed the limit set.\n *\t  The limit can be removed by setting 0 (unlimited) as the\n *\t  max_size by calling the funciton again on the sam context.\n *\t  Memory limits can also be nested, meaning a hild can have\n *\t  a stricter memory limit than a parent.\n *\t  Memory limits are enforced only at memory allocation time.\n *\t  Stealing a context into a 'limited' hierarchy properly\n *\t  updates memory usage but does *not* cause failure if the\n *\t  move causes the new parent to exceed its limits. However\n *\t  any further allocation on that hierarchy will then fail.\n *\n * @param[in]\tctx\t\tThe talloc context to set the limit on\n * @param[in]\tmax_size\tThe (new) max_size\n */\nint talloc_set_memlimit(const void *ctx, size_t max_size);\n\n/* @} ******************************************************************/\n\n#if TALLOC_DEPRECATED\n#define talloc_zero_p(ctx, type) talloc_zero(ctx, type)\n#define talloc_p(ctx, type) talloc(ctx, type)\n#define talloc_array_p(ctx, type, count) talloc_array(ctx, type, count)\n#define talloc_realloc_p(ctx, p, type, count) talloc_realloc(ctx, p, type, count)\n#define talloc_destroy(ctx) talloc_free(ctx)\n#define talloc_append_string(c, s, a) (s?talloc_strdup_append(s,a):talloc_strdup(c, a))\n#endif\n\n#ifndef TALLOC_MAX_DEPTH\n#define TALLOC_MAX_DEPTH 10000\n#endif\n\n#ifdef __cplusplus\n} /* end of extern \"C\" */\n#endif\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-5pf2pj3n7miz4zdj2eytkioexqm5klxe/spack-src/talloc_guide.txt": "Using talloc in Samba4\n======================\n\n.. contents::\n\nAndrew Tridgell\nAugust 2009\n\nThe most current version of this document is available at\n   http://samba.org/ftp/unpacked/talloc/talloc_guide.txt\n\nIf you are used to the \"old\" talloc from Samba3 before 3.0.20 then please read\nthis carefully, as talloc has changed a lot. With 3.0.20 (or 3.0.14?) the\nSamba4 talloc has been ported back to Samba3, so this guide applies to both.\n\nThe new talloc is a hierarchical, reference counted memory pool system\nwith destructors. Quite a mouthful really, but not too bad once you\nget used to it.\n\nPerhaps the biggest change from Samba3 is that there is no distinction\nbetween a \"talloc context\" and a \"talloc pointer\". Any pointer\nreturned from talloc() is itself a valid talloc context. This means\nyou can do this::\n\n  struct foo *X = talloc(mem_ctx, struct foo);\n  X->name = talloc_strdup(X, \"foo\");\n\nand the pointer X->name would be a \"child\" of the talloc context \"X\"\nwhich is itself a child of \"mem_ctx\". So if you do talloc_free(mem_ctx)\nthen it is all destroyed, whereas if you do talloc_free(X) then just X\nand X->name are destroyed, and if you do talloc_free(X->name) then\njust the name element of X is destroyed.\n\nIf you think about this, then what this effectively gives you is an\nn-ary tree, where you can free any part of the tree with\ntalloc_free().\n\nIf you find this confusing, then I suggest you run the testsuite to\nwatch talloc in action. You may also like to add your own tests to\ntestsuite.c to clarify how some particular situation is handled.\n\n\nPerformance\n-----------\n\nAll the additional features of talloc() over malloc() do come at a\nprice. We have a simple performance test in Samba4 that measures\ntalloc() versus malloc() performance, and it seems that talloc() is\nabout 4% slower than malloc() on my x86 Debian Linux box. For Samba,\nthe great reduction in code complexity that we get by using talloc\nmakes this worthwhile, especially as the total overhead of\ntalloc/malloc in Samba is already quite small.\n\n\ntalloc API\n----------\n\nThe following is a complete guide to the talloc API. Read it all at\nleast twice.\n\nMulti-threading\n---------------\n\ntalloc itself does not deal with threads. It is thread-safe (assuming  \nthe underlying \"malloc\" is), as long as each thread uses different  \nmemory contexts.\nIf two threads use the same context then they need to synchronize in\norder to be safe. In particular:\n- when using talloc_enable_leak_report(), giving directly NULL as a  \nparent context implicitly refers to a hidden \"null context\" global  \nvariable, so this should not be used in a multi-threaded environment  \nwithout proper synchronization. In threaded code turn off null tracking using\ntalloc_disable_null_tracking(). ;\n- the context returned by talloc_autofree_context() is also global so  \nshouldn't be used by several threads simultaneously without  \nsynchronization.\n\ntalloc and shared objects\n-------------------------\n\ntalloc can be used in shared objects. Special care needs to be taken\nto never use talloc_autofree_context() in code that might be loaded\nwith dlopen() and unloaded with dlclose(), as talloc_autofree_context()\ninternally uses atexit(3). Some platforms like modern Linux handles\nthis fine, but for example FreeBSD does not deal well with dlopen()\nand atexit() used simultaneously: dlclose() does not clean up the list\nof atexit-handlers, so when the program exits the code that was\nregistered from within talloc_autofree_context() is gone, the program\ncrashes at exit.\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n(type *)talloc(const void *context, type);\n\nThe talloc() macro is the core of the talloc library. It takes a\nmemory context and a type, and returns a pointer to a new area of\nmemory of the given type.\n\nThe returned pointer is itself a talloc context, so you can use it as\nthe context argument to more calls to talloc if you wish.\n\nThe returned pointer is a \"child\" of the supplied context. This means\nthat if you talloc_free() the context then the new child disappears as\nwell. Alternatively you can free just the child.\n\nThe context argument to talloc() can be NULL, in which case a new top\nlevel context is created. \n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_size(const void *context, size_t size);\n\nThe function talloc_size() should be used when you don't have a\nconvenient type to pass to talloc(). Unlike talloc(), it is not type\nsafe (as it returns a void *), so you are on your own for type checking.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n(typeof(ptr)) talloc_ptrtype(const void *ctx, ptr);\n\nThe talloc_ptrtype() macro should be used when you have a pointer and\nwant to allocate memory to point at with this pointer. When compiling\nwith gcc >= 3 it is typesafe. Note this is a wrapper of talloc_size()\nand talloc_get_name() will return the current location in the source file.\nand not the type.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nint talloc_free(void *ptr);\n\nThe talloc_free() function frees a piece of talloc memory, and all its\nchildren. You can call talloc_free() on any pointer returned by\ntalloc().\n\nThe return value of talloc_free() indicates success or failure, with 0\nreturned for success and -1 for failure. A possible failure condition\nis if the pointer had a destructor attached to it and the destructor\nreturned -1. See talloc_set_destructor() for details on\ndestructors. Likewise, if \"ptr\" is NULL, then the function will make\nno modifications and returns -1.\n\nFrom version 2.0 and onwards, as a special case, talloc_free() is\nrefused on pointers that have more than one parent associated, as talloc\nwould have no way of knowing which parent should be removed. This is\ndifferent from older versions in the sense that always the reference to\nthe most recently established parent has been destroyed. Hence to free a\npointer that has more than one parent please use talloc_unlink().\n\nTo help you find problems in your code caused by this behaviour, if\nyou do try and free a pointer with more than one parent then the\ntalloc logging function will be called to give output like this:\n\n  ERROR: talloc_free with references at some_dir/source/foo.c:123\n  \treference at some_dir/source/other.c:325\n  \treference at some_dir/source/third.c:121\n\nPlease see the documentation for talloc_set_log_fn() and\ntalloc_set_log_stderr() for more information on talloc logging\nfunctions.\n\ntalloc_free() operates recursively on its children.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid talloc_free_children(void *ptr);\n\nThe talloc_free_children() walks along the list of all children of a\ntalloc context and talloc_free()s only the children, not the context\nitself.\n\nA NULL argument is handled as no-op.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_reference(const void *context, const void *ptr);\n\nThe talloc_reference() function makes \"context\" an additional parent\nof \"ptr\".\n\nThe return value of talloc_reference() is always the original pointer\n\"ptr\", unless talloc ran out of memory in creating the reference in\nwhich case it will return NULL (each additional reference consumes\naround 48 bytes of memory on intel x86 platforms).\n\nIf \"ptr\" is NULL, then the function is a no-op, and simply returns NULL.\n\nAfter creating a reference you can free it in one of the following\nways:\n\n  - you can talloc_free() any parent of the original pointer. That\n    will reduce the number of parents of this pointer by 1, and will\n    cause this pointer to be freed if it runs out of parents.\n\n  - you can talloc_free() the pointer itself if it has at maximum one\n    parent. This behaviour has been changed since the release of version\n    2.0. Further informations in the description of \"talloc_free\".\n\nFor more control on which parent to remove, see talloc_unlink()\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nint talloc_unlink(const void *context, void *ptr);\n\nThe talloc_unlink() function removes a specific parent from ptr. The\ncontext passed must either be a context used in talloc_reference()\nwith this pointer, or must be a direct parent of ptr. \n\nNote that if the parent has already been removed using talloc_free()\nthen this function will fail and will return -1.  Likewise, if \"ptr\"\nis NULL, then the function will make no modifications and return -1.\n\nYou can just use talloc_free() instead of talloc_unlink() if there\nis at maximum one parent. This behaviour has been changed since the\nrelease of version 2.0. Further informations in the description of\n\"talloc_free\".\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid talloc_set_destructor(const void *ptr, int (*destructor)(void *));\n\nThe function talloc_set_destructor() sets the \"destructor\" for the\npointer \"ptr\". A destructor is a function that is called when the\nmemory used by a pointer is about to be released. The destructor\nreceives the pointer as an argument, and should return 0 for success\nand -1 for failure.\n\nThe destructor can do anything it wants to, including freeing other\npieces of memory. A common use for destructors is to clean up\noperating system resources (such as open file descriptors) contained\nin the structure the destructor is placed on.\n\nYou can only place one destructor on a pointer. If you need more than\none destructor then you can create a zero-length child of the pointer\nand place an additional destructor on that.\n\nTo remove a destructor call talloc_set_destructor() with NULL for the\ndestructor.\n\nIf your destructor attempts to talloc_free() the pointer that it is\nthe destructor for then talloc_free() will return -1 and the free will\nbe ignored. This would be a pointless operation anyway, as the\ndestructor is only called when the memory is just about to go away.\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nint talloc_increase_ref_count(const void *ptr);\n\nThe talloc_increase_ref_count(ptr) function is exactly equivalent to:\n\n  talloc_reference(NULL, ptr);\n\nYou can use either syntax, depending on which you think is clearer in\nyour code.\n\nIt returns 0 on success and -1 on failure.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nsize_t talloc_reference_count(const void *ptr);\n\nReturn the number of references to the pointer.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid talloc_set_name(const void *ptr, const char *fmt, ...);\n\nEach talloc pointer has a \"name\". The name is used principally for\ndebugging purposes, although it is also possible to set and get the\nname on a pointer in as a way of \"marking\" pointers in your code.\n\nThe main use for names on pointer is for \"talloc reports\". See\ntalloc_report() and talloc_report_full() for details. Also see\ntalloc_enable_leak_report() and talloc_enable_leak_report_full().\n\nThe talloc_set_name() function allocates memory as a child of the\npointer. It is logically equivalent to:\n  talloc_set_name_const(ptr, talloc_asprintf(ptr, fmt, ...));\n\nNote that multiple calls to talloc_set_name() will allocate more\nmemory without releasing the name. All of the memory is released when\nthe ptr is freed using talloc_free().\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid talloc_set_name_const(const void *ptr, const char *name);\n\nThe function talloc_set_name_const() is just like talloc_set_name(),\nbut it takes a string constant, and is much faster. It is extensively\nused by the \"auto naming\" macros, such as talloc_p().\n\nThis function does not allocate any memory. It just copies the\nsupplied pointer into the internal representation of the talloc\nptr. This means you must not pass a name pointer to memory that will\ndisappear before the ptr is freed with talloc_free().\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_named(const void *context, size_t size, const char *fmt, ...);\n\nThe talloc_named() function creates a named talloc pointer. It is\nequivalent to:\n\n   ptr = talloc_size(context, size);\n   talloc_set_name(ptr, fmt, ....);\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_named_const(const void *context, size_t size, const char *name);\n\nThis is equivalent to::\n\n   ptr = talloc_size(context, size);\n   talloc_set_name_const(ptr, name);\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nconst char *talloc_get_name(const void *ptr);\n\nThis returns the current name for the given talloc pointer. See\ntalloc_set_name() for details.\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_init(const char *fmt, ...);\n\nThis function creates a zero length named talloc context as a top\nlevel context. It is equivalent to::\n\n  talloc_named(NULL, 0, fmt, ...);\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_new(void *ctx);\n\nThis is a utility macro that creates a new memory context hanging\noff an exiting context, automatically naming it \"talloc_new: __location__\"\nwhere __location__ is the source line it is called from. It is\nparticularly useful for creating a new temporary working context.\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n(type *)talloc_realloc(const void *context, void *ptr, type, count);\n\nThe talloc_realloc() macro changes the size of a talloc\npointer. The \"count\" argument is the number of elements of type \"type\"\nthat you want the resulting pointer to hold. \n\ntalloc_realloc() has the following equivalences::\n\n  talloc_realloc(context, NULL, type, 1) ==> talloc(context, type);\n  talloc_realloc(context, NULL, type, N) ==> talloc_array(context, type, N);\n  talloc_realloc(context, ptr, type, 0)  ==> talloc_free(ptr);\n\nThe \"context\" argument is only used if \"ptr\" is NULL, otherwise it is\nignored.\n\ntalloc_realloc() returns the new pointer, or NULL on failure. The call\nwill fail either due to a lack of memory, or because the pointer has\nmore than one parent (see talloc_reference()).\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_realloc_size(const void *context, void *ptr, size_t size);\n\nthe talloc_realloc_size() function is useful when the type is not \nknown so the typesafe talloc_realloc() cannot be used.\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_steal(const void *new_ctx, const void *ptr);\n\nThe talloc_steal() function changes the parent context of a talloc\npointer. It is typically used when the context that the pointer is\ncurrently a child of is going to be freed and you wish to keep the\nmemory for a longer time. \n\nThe talloc_steal() function returns the pointer that you pass it. It\ndoes not have any failure modes.\n\nNOTE: It is possible to produce loops in the parent/child relationship\nif you are not careful with talloc_steal(). No guarantees are provided\nas to your sanity or the safety of your data if you do this.\n\ntalloc_steal (new_ctx, NULL) will return NULL with no sideeffects.\n\nNote that if you try and call talloc_steal() on a pointer that has\nmore than one parent then the result is ambiguous. Talloc will choose\nto remove the parent that is currently indicated by talloc_parent()\nand replace it with the chosen parent. You will also get a message\nlike this via the talloc logging functions:\n\n  WARNING: talloc_steal with references at some_dir/source/foo.c:123\n  \treference at some_dir/source/other.c:325\n  \treference at some_dir/source/third.c:121\n\nTo unambiguously change the parent of a pointer please see the\nfunction talloc_reparent(). See the talloc_set_log_fn() documentation\nfor more information on talloc logging.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_reparent(const void *old_parent, const void *new_parent, const void *ptr);\n\nThe talloc_reparent() function changes the parent context of a talloc\npointer. It is typically used when the context that the pointer is\ncurrently a child of is going to be freed and you wish to keep the\nmemory for a longer time.\n\nThe talloc_reparent() function returns the pointer that you pass it. It\ndoes not have any failure modes.\n\nThe difference between talloc_reparent() and talloc_steal() is that\ntalloc_reparent() can specify which parent you wish to change. This is\nuseful when a pointer has multiple parents via references.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_parent(const void *ptr);\n\nThe talloc_parent() function returns the current talloc parent. This\nis usually the pointer under which this memory was originally created,\nbut it may have changed due to a talloc_steal() or talloc_reparent()\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nsize_t talloc_total_size(const void *ptr);\n\nThe talloc_total_size() function returns the total size in bytes used\nby this pointer and all child pointers. Mostly useful for debugging.\n\nPassing NULL is allowed, but it will only give a meaningful result if\ntalloc_enable_leak_report() or talloc_enable_leak_report_full() has\nbeen called.\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nsize_t talloc_total_blocks(const void *ptr);\n\nThe talloc_total_blocks() function returns the total memory block\ncount used by this pointer and all child pointers. Mostly useful for\ndebugging.\n\nPassing NULL is allowed, but it will only give a meaningful result if\ntalloc_enable_leak_report() or talloc_enable_leak_report_full() has\nbeen called.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid talloc_report_depth_cb(const void *ptr, int depth, int max_depth,\n\t\t\t    void (*callback)(const void *ptr,\n\t\t\t    \t\t     int depth, int max_depth,\n\t\t\t\t\t     int is_ref,\n\t\t\t\t\t     void *priv),\n\t\t\t    void *priv);\n\nThis provides a more flexible reports than talloc_report(). It\nwill recursively call the callback for the entire tree of memory\nreferenced by the pointer. References in the tree are passed with\nis_ref = 1 and the pointer that is referenced.\n\nYou can pass NULL for the pointer, in which case a report is\nprinted for the top level memory context, but only if\ntalloc_enable_leak_report() or talloc_enable_leak_report_full()\nhas been called.\n\nThe recursion is stopped when depth >= max_depth.\nmax_depth = -1 means only stop at leaf nodes.\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid talloc_report_depth_file(const void *ptr, int depth, int max_depth, FILE *f);\n\nThis provides a more flexible reports than talloc_report(). It\nwill let you specify the depth and max_depth.\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid talloc_report(const void *ptr, FILE *f);\n\nThe talloc_report() function prints a summary report of all memory\nused by ptr. One line of report is printed for each immediate child of\nptr, showing the total memory and number of blocks used by that child.\n\nYou can pass NULL for the pointer, in which case a report is printed\nfor the top level memory context, but only if\ntalloc_enable_leak_report() or talloc_enable_leak_report_full() has\nbeen called.\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid talloc_report_full(const void *ptr, FILE *f);\n\nThis provides a more detailed report than talloc_report(). It will\nrecursively print the entire tree of memory referenced by the\npointer. References in the tree are shown by giving the name of the\npointer that is referenced.\n\nYou can pass NULL for the pointer, in which case a report is printed\nfor the top level memory context, but only if\ntalloc_enable_leak_report() or talloc_enable_leak_report_full() has\nbeen called.\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid talloc_enable_leak_report(void);\n\nThis enables calling of talloc_report(NULL, stderr) when the program\nexits. In Samba4 this is enabled by using the --leak-report command\nline option.\n\nFor it to be useful, this function must be called before any other\ntalloc function as it establishes a \"null context\" that acts as the\ntop of the tree. If you don't call this function first then passing\nNULL to talloc_report() or talloc_report_full() won't give you the\nfull tree printout.\n\nHere is a typical talloc report:\n\ntalloc report on 'null_context' (total 267 bytes in 15 blocks)\n        libcli/auth/spnego_parse.c:55  contains     31 bytes in   2 blocks\n        libcli/auth/spnego_parse.c:55  contains     31 bytes in   2 blocks\n        iconv(UTF8,CP850)              contains     42 bytes in   2 blocks\n        libcli/auth/spnego_parse.c:55  contains     31 bytes in   2 blocks\n        iconv(CP850,UTF8)              contains     42 bytes in   2 blocks\n        iconv(UTF8,UTF-16LE)           contains     45 bytes in   2 blocks\n        iconv(UTF-16LE,UTF8)           contains     45 bytes in   2 blocks\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid talloc_enable_leak_report_full(void);\n\nThis enables calling of talloc_report_full(NULL, stderr) when the\nprogram exits. In Samba4 this is enabled by using the\n--leak-report-full command line option.\n\nFor it to be useful, this function must be called before any other\ntalloc function as it establishes a \"null context\" that acts as the\ntop of the tree. If you don't call this function first then passing\nNULL to talloc_report() or talloc_report_full() won't give you the\nfull tree printout.\n\nHere is a typical full report:\n\nfull talloc report on 'root' (total 18 bytes in 8 blocks)\n    p1                             contains     18 bytes in   7 blocks (ref 0)\n        r1                             contains     13 bytes in   2 blocks (ref 0)\n            reference to: p2\n        p2                             contains      1 bytes in   1 blocks (ref 1)\n        x3                             contains      1 bytes in   1 blocks (ref 0)\n        x2                             contains      1 bytes in   1 blocks (ref 0)\n        x1                             contains      1 bytes in   1 blocks (ref 0)\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid talloc_enable_null_tracking(void);\n\nThis enables tracking of the NULL memory context without enabling leak\nreporting on exit. Useful for when you want to do your own leak\nreporting call via talloc_report_null_full();\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid talloc_disable_null_tracking(void);\n\nThis disables tracking of the NULL memory context.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n(type *)talloc_zero(const void *ctx, type);\n\nThe talloc_zero() macro is equivalent to::\n\n  ptr = talloc(ctx, type);\n  if (ptr) memset(ptr, 0, sizeof(type));\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_zero_size(const void *ctx, size_t size)\n\nThe talloc_zero_size() function is useful when you don't have a known type\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_memdup(const void *ctx, const void *p, size_t size);\n\nThe talloc_memdup() function is equivalent to::\n\n  ptr = talloc_size(ctx, size);\n  if (ptr) memcpy(ptr, p, size);\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nchar *talloc_strdup(const void *ctx, const char *p);\n\nThe talloc_strdup() function is equivalent to::\n\n  ptr = talloc_size(ctx, strlen(p)+1);\n  if (ptr) memcpy(ptr, p, strlen(p)+1);\n\nThis functions sets the name of the new pointer to the passed\nstring. This is equivalent to::\n\n   talloc_set_name_const(ptr, ptr)\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nchar *talloc_strndup(const void *t, const char *p, size_t n);\n\nThe talloc_strndup() function is the talloc equivalent of the C\nlibrary function strndup()\n\nThis functions sets the name of the new pointer to the passed\nstring. This is equivalent to:\n   talloc_set_name_const(ptr, ptr)\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nchar *talloc_append_string(const void *t, char *orig, const char *append);\n\nThe talloc_append_string() function appends the given formatted\nstring to the given string.\n\nThis function sets the name of the new pointer to the new\nstring. This is equivalent to::\n\n   talloc_set_name_const(ptr, ptr)\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nchar *talloc_vasprintf(const void *t, const char *fmt, va_list ap);\n\nThe talloc_vasprintf() function is the talloc equivalent of the C\nlibrary function vasprintf()\n\nThis functions sets the name of the new pointer to the new\nstring. This is equivalent to::\n\n   talloc_set_name_const(ptr, ptr)\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nchar *talloc_asprintf(const void *t, const char *fmt, ...);\n\nThe talloc_asprintf() function is the talloc equivalent of the C\nlibrary function asprintf()\n\nThis functions sets the name of the new pointer to the new\nstring. This is equivalent to::\n\n   talloc_set_name_const(ptr, ptr)\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nchar *talloc_asprintf_append(char *s, const char *fmt, ...);\n\nThe talloc_asprintf_append() function appends the given formatted\nstring to the given string.\nUse this variant when the string in the current talloc buffer may\nhave been truncated in length.\n\nThis functions sets the name of the new pointer to the new\nstring. This is equivalent to::\n\n   talloc_set_name_const(ptr, ptr)\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nchar *talloc_asprintf_append_buffer(char *s, const char *fmt, ...);\n\nThe talloc_asprintf_append() function appends the given formatted \nstring to the end of the currently allocated talloc buffer.\nUse this variant when the string in the current talloc buffer has\nnot been changed.\n\nThis functions sets the name of the new pointer to the new\nstring. This is equivalent to::\n\n   talloc_set_name_const(ptr, ptr)\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n((type *)talloc_array(const void *ctx, type, unsigned int count);\n\nThe talloc_array() macro is equivalent to::\n\n  (type *)talloc_size(ctx, sizeof(type) * count);\n\nexcept that it provides integer overflow protection for the multiply,\nreturning NULL if the multiply overflows.\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_array_size(const void *ctx, size_t size, unsigned int count);\n\nThe talloc_array_size() function is useful when the type is not\nknown. It operates in the same way as talloc_array(), but takes a size\ninstead of a type.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n(typeof(ptr)) talloc_array_ptrtype(const void *ctx, ptr, unsigned int count);\n\nThe talloc_ptrtype() macro should be used when you have a pointer to an array\nand want to allocate memory of an array to point at with this pointer. When compiling\nwith gcc >= 3 it is typesafe. Note this is a wrapper of talloc_array_size()\nand talloc_get_name() will return the current location in the source file.\nand not the type.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_realloc_fn(const void *ctx, void *ptr, size_t size);\n\nThis is a non-macro version of talloc_realloc(), which is useful \nas libraries sometimes want a ralloc function pointer. A realloc()\nimplementation encapsulates the functionality of malloc(), free() and\nrealloc() in one call, which is why it is useful to be able to pass\naround a single function pointer.\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_autofree_context(void);\n\nThis is a handy utility function that returns a talloc context\nwhich will be automatically freed on program exit. This can be used\nto reduce the noise in memory leak reports.\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_check_name(const void *ptr, const char *name);\n\nThis function checks if a pointer has the specified name. If it does\nthen the pointer is returned. It it doesn't then NULL is returned.\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n(type *)talloc_get_type(const void *ptr, type);\n\nThis macro allows you to do type checking on talloc pointers. It is\nparticularly useful for void* private pointers. It is equivalent to\nthis::\n\n   (type *)talloc_check_name(ptr, #type)\n\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\ntalloc_set_type(const void *ptr, type);\n\nThis macro allows you to force the name of a pointer to be of a\nparticular type. This can be used in conjunction with\ntalloc_get_type() to do type checking on void* pointers.\n\nIt is equivalent to this::\n\n   talloc_set_name_const(ptr, #type)\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\ntalloc_get_size(const void *ctx);\n\nThis function lets you know the amount of memory allocated so far by\nthis context. It does NOT account for subcontext memory.\nThis can be used to calculate the size of an array.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid *talloc_find_parent_byname(const void *ctx, const char *name);\n\nFind a parent memory context of the current context that has the given\nname. This can be very useful in complex programs where it may be\ndifficult to pass all information down to the level you need, but you\nknow the structure you want is a parent of another context.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n(type *)talloc_find_parent_bytype(ctx, type);\n\nLike talloc_find_parent_byname() but takes a type, making it typesafe.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid talloc_set_log_fn(void (*log_fn)(const char *message));\n\nThis function sets a logging function that talloc will use for\nwarnings and errors. By default talloc will not print any warnings or\nerrors.\n\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nvoid talloc_set_log_stderr(void)\n\nThis sets the talloc log function to write log messages to stderr.\n",
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-5pf2pj3n7miz4zdj2eytkioexqm5klxe/spack-src/third_party/waf/wafadmin/Tools/libtool.py": "#!/usr/bin/env python\n# encoding: utf-8\n# Matthias Jahn, 2008, jahn matthias ath freenet punto de\n# Thomas Nagy, 2008 (ita)\n\nimport sys, re, os, optparse\n\nimport TaskGen, Task, Utils, preproc\nfrom Logs import error, debug, warn\nfrom TaskGen import taskgen, after, before, feature\n\nREVISION=\"0.1.3\"\n\n\"\"\"\nif you want to use the code here, you must use something like this:\nobj = obj.create(...)\nobj.features.append(\"libtool\")\nobj.vnum = \"1.2.3\" # optional, but versioned libraries are common\n\"\"\"\n\n# fake libtool files\nfakelibtool_vardeps = ['CXX', 'PREFIX']\ndef fakelibtool_build(task):\n\t# Writes a .la file, used by libtool\n\tenv = task.env\n\tdest  = open(task.outputs[0].abspath(env), 'w')\n\tsname = task.inputs[0].name\n\tfu = dest.write\n\tfu(\"# Generated by ltmain.sh - GNU libtool 1.5.18 - (pwn3d by BKsys II code name WAF)\\n\")\n\tif env['vnum']:\n\t\tnums = env['vnum'].split('.')\n\t\tlibname = task.inputs[0].name\n\t\tname3 = libname+'.'+env['vnum']\n\t\tname2 = libname+'.'+nums[0]\n\t\tname1 = libname\n\t\tfu(\"dlname='%s'\\n\" % name2)\n\t\tstrn = \" \".join([name3, name2, name1])\n\t\tfu(\"library_names='%s'\\n\" % (strn) )\n\telse:\n\t\tfu(\"dlname='%s'\\n\" % sname)\n\t\tfu(\"library_names='%s %s %s'\\n\" % (sname, sname, sname) )\n\tfu(\"old_library=''\\n\")\n\tvars = ' '.join(env['libtoolvars']+env['LINKFLAGS'])\n\tfu(\"dependency_libs='%s'\\n\" % vars)\n\tfu(\"current=0\\n\")\n\tfu(\"age=0\\nrevision=0\\ninstalled=yes\\nshouldnotlink=no\\n\")\n\tfu(\"dlopen=''\\ndlpreopen=''\\n\")\n\tfu(\"libdir='%s/lib'\\n\" % env['PREFIX'])\n\tdest.close()\n\treturn 0\n\ndef read_la_file(path):\n\tsp = re.compile(r'^([^=]+)=\\'(.*)\\'$')\n\tdc={}\n\tfile = open(path, \"r\")\n\tfor line in file.readlines():\n\t\ttry:\n\t\t\t#print sp.split(line.strip())\n\t\t\t_, left, right, _ = sp.split(line.strip())\n\t\t\tdc[left]=right\n\t\texcept ValueError:\n\t\t\tpass\n\tfile.close()\n\treturn dc\n\n@feature(\"libtool\")\n@after('apply_link')\ndef apply_link_libtool(self):\n\tif self.type != 'program':\n\t\tlinktask = self.link_task\n\t\tself.latask = self.create_task('fakelibtool', linktask.outputs, linktask.outputs[0].change_ext('.la'))\n\n\tif self.bld.is_install:\n\t\tself.bld.install_files('${PREFIX}/lib', linktask.outputs[0], self.env)\n\n@feature(\"libtool\")\n@before('apply_core')\ndef apply_libtool(self):\n\tself.env['vnum']=self.vnum\n\n\tpaths=[]\n\tlibs=[]\n\tlibtool_files=[]\n\tlibtool_vars=[]\n\n\tfor l in self.env['LINKFLAGS']:\n\t\tif l[:2]=='-L':\n\t\t\tpaths.append(l[2:])\n\t\telif l[:2]=='-l':\n\t\t\tlibs.append(l[2:])\n\n\tfor l in libs:\n\t\tfor p in paths:\n\t\t\tdict = read_la_file(p+'/lib'+l+'.la')\n\t\t\tlinkflags2 = dict.get('dependency_libs', '')\n\t\t\tfor v in linkflags2.split():\n\t\t\t\tif v.endswith('.la'):\n\t\t\t\t\tlibtool_files.append(v)\n\t\t\t\t\tlibtool_vars.append(v)\n\t\t\t\t\tcontinue\n\t\t\t\tself.env.append_unique('LINKFLAGS', v)\n\t\t\t\tbreak\n\n\tself.env['libtoolvars']=libtool_vars\n\n\twhile libtool_files:\n\t\tfile = libtool_files.pop()\n\t\tdict = read_la_file(file)\n\t\tfor v in dict['dependency_libs'].split():\n\t\t\tif v[-3:] == '.la':\n\t\t\t\tlibtool_files.append(v)\n\t\t\t\tcontinue\n\t\t\tself.env.append_unique('LINKFLAGS', v)\n\nTask.task_type_from_func('fakelibtool', vars=fakelibtool_vardeps, func=fakelibtool_build, color='BLUE', after=\"cc_link cxx_link static_link\")\n\nclass libtool_la_file:\n\tdef __init__ (self, la_filename):\n\t\tself.__la_filename = la_filename\n\t\t#remove path and .la suffix\n\t\tself.linkname = str(os.path.split(la_filename)[-1])[:-3]\n\t\tif self.linkname.startswith(\"lib\"):\n\t\t\tself.linkname = self.linkname[3:]\n\t\t# The name that we can dlopen(3).\n\t\tself.dlname = None\n\t\t# Names of this library\n\t\tself.library_names = None\n\t\t# The name of the static archive.\n\t\tself.old_library = None\n\t\t# Libraries that this one depends upon.\n\t\tself.dependency_libs = None\n\t\t# Version information for libIlmImf.\n\t\tself.current = None\n\t\tself.age = None\n\t\tself.revision = None\n\t\t# Is this an already installed library?\n\t\tself.installed = None\n\t\t# Should we warn about portability when linking against -modules?\n\t\tself.shouldnotlink = None\n\t\t# Files to dlopen/dlpreopen\n\t\tself.dlopen = None\n\t\tself.dlpreopen = None\n\t\t# Directory that this library needs to be installed in:\n\t\tself.libdir = '/usr/lib'\n\t\tif not self.__parse():\n\t\t\traise ValueError(\"file %s not found!!\" %(la_filename))\n\n\tdef __parse(self):\n\t\t\"Retrieve the variables from a file\"\n\t\tif not os.path.isfile(self.__la_filename): return 0\n\t\tla_file=open(self.__la_filename, 'r')\n\t\tfor line in la_file:\n\t\t\tln = line.strip()\n\t\t\tif not ln: continue\n\t\t\tif ln[0]=='#': continue\n\t\t\t(key, value) = str(ln).split('=', 1)\n\t\t\tkey = key.strip()\n\t\t\tvalue = value.strip()\n\t\t\tif value == \"no\": value = False\n\t\t\telif value == \"yes\": value = True\n\t\t\telse:\n\t\t\t\ttry: value = int(value)\n\t\t\t\texcept ValueError: value = value.strip(\"'\")\n\t\t\tsetattr(self, key, value)\n\t\tla_file.close()\n\t\treturn 1\n\n\tdef get_libs(self):\n\t\t\"\"\"return linkflags for this lib\"\"\"\n\t\tlibs = []\n\t\tif self.dependency_libs:\n\t\t\tlibs = str(self.dependency_libs).strip().split()\n\t\tif libs == None:\n\t\t\tlibs = []\n\t\t# add la lib and libdir\n\t\tlibs.insert(0, \"-l%s\" % self.linkname.strip())\n\t\tlibs.insert(0, \"-L%s\" % self.libdir.strip())\n\t\treturn libs\n\n\tdef __str__(self):\n\t\treturn '''\\\ndlname = \"%(dlname)s\"\nlibrary_names = \"%(library_names)s\"\nold_library = \"%(old_library)s\"\ndependency_libs = \"%(dependency_libs)s\"\nversion = %(current)s.%(age)s.%(revision)s\ninstalled = \"%(installed)s\"\nshouldnotlink = \"%(shouldnotlink)s\"\ndlopen = \"%(dlopen)s\"\ndlpreopen = \"%(dlpreopen)s\"\nlibdir = \"%(libdir)s\"''' % self.__dict__\n\nclass libtool_config:\n\tdef __init__ (self, la_filename):\n\t\tself.__libtool_la_file = libtool_la_file(la_filename)\n\t\ttmp = self.__libtool_la_file\n\t\tself.__version = [int(tmp.current), int(tmp.age), int(tmp.revision)]\n\t\tself.__sub_la_files = []\n\t\tself.__sub_la_files.append(la_filename)\n\t\tself.__libs = None\n\n\tdef __cmp__(self, other):\n\t\t\"\"\"make it compareable with X.Y.Z versions (Y and Z are optional)\"\"\"\n\t\tif not other:\n\t\t\treturn 1\n\t\tothervers = [int(s) for s in str(other).split(\".\")]\n\t\tselfvers = self.__version\n\t\treturn cmp(selfvers, othervers)\n\n\tdef __str__(self):\n\t\treturn \"\\n\".join([\n\t\t\tstr(self.__libtool_la_file),\n\t\t\t' '.join(self.__libtool_la_file.get_libs()),\n\t\t\t'* New getlibs:',\n\t\t\t' '.join(self.get_libs())\n\t\t])\n\n\tdef __get_la_libs(self, la_filename):\n\t\treturn libtool_la_file(la_filename).get_libs()\n\n\tdef get_libs(self):\n\t\t\"\"\"return the complete uniqe linkflags that do not\n\t\tcontain .la files anymore\"\"\"\n\t\tlibs_list = list(self.__libtool_la_file.get_libs())\n\t\tlibs_map = {}\n\t\twhile len(libs_list) > 0:\n\t\t\tentry = libs_list.pop(0)\n\t\t\tif entry:\n\t\t\t\tif str(entry).endswith(\".la\"):\n\t\t\t\t\t## prevents duplicate .la checks\n\t\t\t\t\tif entry not in self.__sub_la_files:\n\t\t\t\t\t\tself.__sub_la_files.append(entry)\n\t\t\t\t\t\tlibs_list.extend(self.__get_la_libs(entry))\n\t\t\t\telse:\n\t\t\t\t\tlibs_map[entry]=1\n\t\tself.__libs = libs_map.keys()\n\t\treturn self.__libs\n\n\tdef get_libs_only_L(self):\n\t\tif not self.__libs: self.get_libs()\n\t\tlibs = self.__libs\n\t\tlibs = [s for s in libs if str(s).startswith('-L')]\n\t\treturn libs\n\n\tdef get_libs_only_l(self):\n\t\tif not self.__libs: self.get_libs()\n\t\tlibs = self.__libs\n\t\tlibs = [s for s in libs if str(s).startswith('-l')]\n\t\treturn libs\n\n\tdef get_libs_only_other(self):\n\t\tif not self.__libs: self.get_libs()\n\t\tlibs = self.__libs\n\t\tlibs = [s for s in libs if not(str(s).startswith('-L')or str(s).startswith('-l'))]\n\t\treturn libs\n\ndef useCmdLine():\n\t\"\"\"parse cmdline args and control build\"\"\"\n\tusage = '''Usage: %prog [options] PathToFile.la\nexample: %prog --atleast-version=2.0.0 /usr/lib/libIlmImf.la\nnor: %prog --libs /usr/lib/libamarok.la'''\n\tparser = optparse.OptionParser(usage)\n\ta = parser.add_option\n\ta(\"--version\", dest = \"versionNumber\",\n\t\taction = \"store_true\", default = False,\n\t\thelp = \"output version of libtool-config\"\n\t\t)\n\ta(\"--debug\", dest = \"debug\",\n\t\taction = \"store_true\", default = False,\n\t\thelp = \"enable debug\"\n\t\t)\n\ta(\"--libs\", dest = \"libs\",\n\t\taction = \"store_true\", default = False,\n\t\thelp = \"output all linker flags\"\n\t\t)\n\ta(\"--libs-only-l\", dest = \"libs_only_l\",\n\t\taction = \"store_true\", default = False,\n\t\thelp = \"output -l flags\"\n\t\t)\n\ta(\"--libs-only-L\", dest = \"libs_only_L\",\n\t\taction = \"store_true\", default = False,\n\t\thelp = \"output -L flags\"\n\t\t)\n\ta(\"--libs-only-other\", dest = \"libs_only_other\",\n\t\taction = \"store_true\", default = False,\n\t\thelp = \"output other libs (e.g. -pthread)\"\n\t\t)\n\ta(\"--atleast-version\", dest = \"atleast_version\",\n\t\tdefault=None,\n\t\thelp = \"return 0 if the module is at least version ATLEAST_VERSION\"\n\t\t)\n\ta(\"--exact-version\", dest = \"exact_version\",\n\t\tdefault=None,\n\t\thelp = \"return 0 if the module is exactly version EXACT_VERSION\"\n\t\t)\n\ta(\"--max-version\", dest = \"max_version\",\n\t\tdefault=None,\n\t\thelp = \"return 0 if the module is at no newer than version MAX_VERSION\"\n\t\t)\n\n\t(options, args) = parser.parse_args()\n\tif len(args) != 1 and not options.versionNumber:\n\t\tparser.error(\"incorrect number of arguments\")\n\tif options.versionNumber:\n\t\tprint(\"libtool-config version %s\" % REVISION)\n\t\treturn 0\n\tltf = libtool_config(args[0])\n\tif options.debug:\n\t\tprint(ltf)\n\tif options.atleast_version:\n\t\tif ltf >= options.atleast_version: return 0\n\t\tsys.exit(1)\n\tif options.exact_version:\n\t\tif ltf == options.exact_version: return 0\n\t\tsys.exit(1)\n\tif options.max_version:\n\t\tif ltf <= options.max_version: return 0\n\t\tsys.exit(1)\n\n\tdef p(x):\n\t\tprint(\" \".join(x))\n\tif options.libs: p(ltf.get_libs())\n\telif options.libs_only_l: p(ltf.get_libs_only_l())\n\telif options.libs_only_L: p(ltf.get_libs_only_L())\n\telif options.libs_only_other: p(ltf.get_libs_only_other())\n\treturn 0\n\nif __name__ == '__main__':\n\tuseCmdLine()\n",
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-5pf2pj3n7miz4zdj2eytkioexqm5klxe/spack-src/lib/replace/replace.h": "/*\n   Unix SMB/CIFS implementation.\n\n   macros to go along with the lib/replace/ portability layer code\n\n   Copyright (C) Andrew Tridgell 2005\n   Copyright (C) Jelmer Vernooij 2006-2008\n   Copyright (C) Jeremy Allison 2007.\n\n     ** NOTE! The following LGPL license applies to the replace\n     ** library. This does NOT imply that all of Samba is released\n     ** under the LGPL\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 3 of the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef _LIBREPLACE_REPLACE_H\n#define _LIBREPLACE_REPLACE_H\n\n#ifndef NO_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef HAVE_STANDARDS_H\n#include <standards.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <errno.h>\n\n#ifndef HAVE_DECL_EWOULDBLOCK\n#define EWOULDBLOCK EAGAIN\n#endif\n\n#if defined(_MSC_VER) || defined(__MINGW32__)\n#include \"win32_replace.h\"\n#endif\n\n\n#ifdef HAVE_INTTYPES_H\n#define __STDC_FORMAT_MACROS\n#include <inttypes.h>\n#elif HAVE_STDINT_H\n#include <stdint.h>\n/* force off HAVE_INTTYPES_H so that roken doesn't try to include both,\n   which causes a warning storm on irix */\n#undef HAVE_INTTYPES_H\n#endif\n\n#ifdef HAVE_MALLOC_H\n#include <malloc.h>\n#endif\n\n#ifndef __PRI64_PREFIX\n# if __WORDSIZE == 64 && ! defined __APPLE__\n#  define __PRI64_PREFIX\t\"l\"\n# else\n#  define __PRI64_PREFIX\t\"ll\"\n# endif\n#endif\n\n/* Decimal notation.  */\n#ifndef PRId8\n# define PRId8\t\t\"d\"\n#endif\n#ifndef PRId16\n# define PRId16\t\t\"d\"\n#endif\n#ifndef PRId32\n# define PRId32\t\t\"d\"\n#endif\n#ifndef PRId64\n# define PRId64\t\t__PRI64_PREFIX \"d\"\n#endif\n\n#ifndef PRIi8\n# define PRIi8\t\t\"i\"\n#endif\n#ifndef PRIi16\n# define PRIi16\t\t\"i\"\n#endif\n#ifndef PRIi32\n# define PRIi32\t\t\"i\"\n#endif\n#ifndef PRIi64\n# define PRIi64\t\t__PRI64_PREFIX \"i\"\n#endif\n\n#ifndef PRIu8\n# define PRIu8\t\t\"u\"\n#endif\n#ifndef PRIu16\n# define PRIu16\t\t\"u\"\n#endif\n#ifndef PRIu32\n# define PRIu32\t\t\"u\"\n#endif\n#ifndef PRIu64\n# define PRIu64\t\t__PRI64_PREFIX \"u\"\n#endif\n\n#ifndef SCNd8\n# define SCNd8\t\t\"hhd\"\n#endif\n#ifndef SCNd16\n# define SCNd16\t\t\"hd\"\n#endif\n#ifndef SCNd32\n# define SCNd32\t\t\"d\"\n#endif\n#ifndef SCNd64\n# define SCNd64\t\t__PRI64_PREFIX \"d\"\n#endif\n\n#ifndef SCNi8\n# define SCNi8\t\t\"hhi\"\n#endif\n#ifndef SCNi16\n# define SCNi16\t\t\"hi\"\n#endif\n#ifndef SCNi32\n# define SCNi32\t\t\"i\"\n#endif\n#ifndef SCNi64\n# define SCNi64\t\t__PRI64_PREFIX \"i\"\n#endif\n\n#ifndef SCNu8\n# define SCNu8\t\t\"hhu\"\n#endif\n#ifndef SCNu16\n# define SCNu16\t\t\"hu\"\n#endif\n#ifndef SCNu32\n# define SCNu32\t\t\"u\"\n#endif\n#ifndef SCNu64\n# define SCNu64\t\t__PRI64_PREFIX \"u\"\n#endif\n\n#ifdef HAVE_BSD_STRING_H\n#include <bsd/string.h>\n#endif\n\n#ifdef HAVE_BSD_UNISTD_H\n#include <bsd/unistd.h>\n#endif\n\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n\n#ifdef HAVE_STRINGS_H\n#include <strings.h>\n#endif\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\n#ifdef HAVE_SYS_SYSMACROS_H\n#include <sys/sysmacros.h>\n#endif\n\n#ifdef HAVE_SETPROCTITLE_H\n#include <setproctitle.h>\n#endif\n\n#if STDC_HEADERS\n#include <stdlib.h>\n#include <stddef.h>\n#endif\n\n#ifdef HAVE_LINUX_TYPES_H\n/*\n * This is needed as some broken header files require this to be included early\n */\n#include <linux/types.h>\n#endif\n\n#ifndef HAVE_STRERROR\nextern char *sys_errlist[];\n#define strerror(i) sys_errlist[i]\n#endif\n\n#ifndef HAVE_ERRNO_DECL\nextern int errno;\n#endif\n\n#ifndef HAVE_STRDUP\n#define strdup rep_strdup\nchar *rep_strdup(const char *s);\n#endif\n\n#ifndef HAVE_MEMMOVE\n#define memmove rep_memmove\nvoid *rep_memmove(void *dest,const void *src,int size);\n#endif\n\n#ifndef HAVE_MEMMEM\n#define memmem rep_memmem\nvoid *rep_memmem(const void *haystack, size_t haystacklen,\n\t\t const void *needle, size_t needlelen);\n#endif\n\n#ifndef HAVE_MEMALIGN\n#define memalign rep_memalign\nvoid *rep_memalign(size_t boundary, size_t size);\n#endif\n\n#ifndef HAVE_MKTIME\n#define mktime rep_mktime\n/* prototype is in \"system/time.h\" */\n#endif\n\n#ifndef HAVE_TIMEGM\n#define timegm rep_timegm\n/* prototype is in \"system/time.h\" */\n#endif\n\n#ifndef HAVE_UTIME\n#define utime rep_utime\n/* prototype is in \"system/time.h\" */\n#endif\n\n#ifndef HAVE_UTIMES\n#define utimes rep_utimes\n/* prototype is in \"system/time.h\" */\n#endif\n\n#ifndef HAVE_STRLCPY\n#define strlcpy rep_strlcpy\nsize_t rep_strlcpy(char *d, const char *s, size_t bufsize);\n#endif\n\n#ifndef HAVE_STRLCAT\n#define strlcat rep_strlcat\nsize_t rep_strlcat(char *d, const char *s, size_t bufsize);\n#endif\n\n#ifndef HAVE_CLOSEFROM\n#define closefrom rep_closefrom\nint rep_closefrom(int lower);\n#endif\n\n\n#if (defined(BROKEN_STRNDUP) || !defined(HAVE_STRNDUP))\n#undef HAVE_STRNDUP\n#define strndup rep_strndup\nchar *rep_strndup(const char *s, size_t n);\n#endif\n\n#if (defined(BROKEN_STRNLEN) || !defined(HAVE_STRNLEN))\n#undef HAVE_STRNLEN\n#define strnlen rep_strnlen\nsize_t rep_strnlen(const char *s, size_t n);\n#endif\n\n#if !HAVE_DECL_ENVIRON\n#ifdef __APPLE__\n#include <crt_externs.h>\n#define environ (*_NSGetEnviron())\n#else\nextern char **environ;\n#endif\n#endif\n\n#ifndef HAVE_SETENV\n#define setenv rep_setenv\nint rep_setenv(const char *name, const char *value, int overwrite);\n#else\n#ifndef HAVE_SETENV_DECL\nint setenv(const char *name, const char *value, int overwrite);\n#endif\n#endif\n\n#ifndef HAVE_UNSETENV\n#define unsetenv rep_unsetenv\nint rep_unsetenv(const char *name);\n#endif\n\n#ifndef HAVE_SETEUID\n#define seteuid rep_seteuid\nint rep_seteuid(uid_t);\n#endif\n\n#ifndef HAVE_SETEGID\n#define setegid rep_setegid\nint rep_setegid(gid_t);\n#endif\n\n#if (defined(USE_SETRESUID) && !defined(HAVE_SETRESUID_DECL))\n/* stupid glibc */\nint setresuid(uid_t ruid, uid_t euid, uid_t suid);\n#endif\n#if (defined(USE_SETRESUID) && !defined(HAVE_SETRESGID_DECL))\nint setresgid(gid_t rgid, gid_t egid, gid_t sgid);\n#endif\n\n#ifndef HAVE_CHOWN\n#define chown rep_chown\nint rep_chown(const char *path, uid_t uid, gid_t gid);\n#endif\n\n#ifndef HAVE_CHROOT\n#define chroot rep_chroot\nint rep_chroot(const char *dirname);\n#endif\n\n#ifndef HAVE_LINK\n#define link rep_link\nint rep_link(const char *oldpath, const char *newpath);\n#endif\n\n#ifndef HAVE_READLINK\n#define readlink rep_readlink\nssize_t rep_readlink(const char *path, char *buf, size_t bufsize);\n#endif\n\n#ifndef HAVE_SYMLINK\n#define symlink rep_symlink\nint rep_symlink(const char *oldpath, const char *newpath);\n#endif\n\n#ifndef HAVE_REALPATH\n#define realpath rep_realpath\nchar *rep_realpath(const char *path, char *resolved_path);\n#endif\n\n#ifndef HAVE_LCHOWN\n#define lchown rep_lchown\nint rep_lchown(const char *fname,uid_t uid,gid_t gid);\n#endif\n\n#ifdef HAVE_UNIX_H\n#include <unix.h>\n#endif\n\n#ifndef HAVE_SETLINEBUF\n#define setlinebuf rep_setlinebuf\nvoid rep_setlinebuf(FILE *);\n#endif\n\n#ifndef HAVE_STRCASESTR\n#define strcasestr rep_strcasestr\nchar *rep_strcasestr(const char *haystack, const char *needle);\n#endif\n\n#ifndef HAVE_STRSEP\n#define strsep rep_strsep\nchar *rep_strsep(char **pps, const char *delim);\n#endif\n\n#ifndef HAVE_STRTOK_R\n#define strtok_r rep_strtok_r\nchar *rep_strtok_r(char *s, const char *delim, char **save_ptr);\n#endif\n\n\n\n#ifndef HAVE_STRTOLL\n#define strtoll rep_strtoll\nlong long int rep_strtoll(const char *str, char **endptr, int base);\n#else\n#ifdef HAVE_BSD_STRTOLL\n#define strtoll rep_strtoll\nlong long int rep_strtoll(const char *str, char **endptr, int base);\n#endif\n#endif\n\n#ifndef HAVE_STRTOULL\n#define strtoull rep_strtoull\nunsigned long long int rep_strtoull(const char *str, char **endptr, int base);\n#else\n#ifdef HAVE_BSD_STRTOLL /* yes, it's not HAVE_BSD_STRTOULL */\n#define strtoull rep_strtoull\nunsigned long long int rep_strtoull(const char *str, char **endptr, int base);\n#endif\n#endif\n\n#ifndef HAVE_FTRUNCATE\n#define ftruncate rep_ftruncate\nint rep_ftruncate(int,off_t);\n#endif\n\n#ifndef HAVE_INITGROUPS\n#define initgroups rep_initgroups\nint rep_initgroups(char *name, gid_t id);\n#endif\n\n#if !defined(HAVE_BZERO) && defined(HAVE_MEMSET)\n#define bzero(a,b) memset((a),'\\0',(b))\n#endif\n\n#ifndef HAVE_DLERROR\n#define dlerror rep_dlerror\nchar *rep_dlerror(void);\n#endif\n\n#ifndef HAVE_DLOPEN\n#define dlopen rep_dlopen\n#ifdef DLOPEN_TAKES_UNSIGNED_FLAGS\nvoid *rep_dlopen(const char *name, unsigned int flags);\n#else\nvoid *rep_dlopen(const char *name, int flags);\n#endif\n#endif\n\n#ifndef HAVE_DLSYM\n#define dlsym rep_dlsym\nvoid *rep_dlsym(void *handle, const char *symbol);\n#endif\n\n#ifndef HAVE_DLCLOSE\n#define dlclose rep_dlclose\nint rep_dlclose(void *handle);\n#endif\n\n#ifndef HAVE_SOCKETPAIR\n#define socketpair rep_socketpair\n/* prototype is in system/network.h */\n#endif\n\n#ifndef PRINTF_ATTRIBUTE\n#ifdef HAVE___ATTRIBUTE__\n/** Use gcc attribute to check printf fns.  a1 is the 1-based index of\n * the parameter containing the format, and a2 the index of the first\n * argument. Note that some gcc 2.x versions don't handle this\n * properly **/\n#define PRINTF_ATTRIBUTE(a1, a2) __attribute__ ((format (__printf__, a1, a2)))\n#else\n#define PRINTF_ATTRIBUTE(a1, a2)\n#endif\n#endif\n\n#ifndef _DEPRECATED_\n#ifdef HAVE___ATTRIBUTE__\n#define _DEPRECATED_ __attribute__ ((deprecated))\n#else\n#define _DEPRECATED_\n#endif\n#endif\n\n#if !defined(HAVE_VDPRINTF) || !defined(HAVE_C99_VSNPRINTF)\n#define vdprintf rep_vdprintf\nint rep_vdprintf(int fd, const char *format, va_list ap) PRINTF_ATTRIBUTE(2,0);\n#endif\n\n#if !defined(HAVE_DPRINTF) || !defined(HAVE_C99_VSNPRINTF)\n#define dprintf rep_dprintf\nint rep_dprintf(int fd, const char *format, ...) PRINTF_ATTRIBUTE(2,3);\n#endif\n\n#if !defined(HAVE_VASPRINTF) || !defined(HAVE_C99_VSNPRINTF)\n#define vasprintf rep_vasprintf\nint rep_vasprintf(char **ptr, const char *format, va_list ap) PRINTF_ATTRIBUTE(2,0);\n#endif\n\n#if !defined(HAVE_SNPRINTF) || !defined(HAVE_C99_VSNPRINTF)\n#define snprintf rep_snprintf\nint rep_snprintf(char *,size_t ,const char *, ...) PRINTF_ATTRIBUTE(3,4);\n#endif\n\n#if !defined(HAVE_VSNPRINTF) || !defined(HAVE_C99_VSNPRINTF)\n#define vsnprintf rep_vsnprintf\nint rep_vsnprintf(char *,size_t ,const char *, va_list ap) PRINTF_ATTRIBUTE(3,0);\n#endif\n\n#if !defined(HAVE_ASPRINTF) || !defined(HAVE_C99_VSNPRINTF)\n#define asprintf rep_asprintf\nint rep_asprintf(char **,const char *, ...) PRINTF_ATTRIBUTE(2,3);\n#endif\n\n#if !defined(HAVE_C99_VSNPRINTF)\n#ifdef REPLACE_BROKEN_PRINTF\n/*\n * We do not redefine printf by default\n * as it breaks the build if system headers\n * use __attribute__((format(printf, 3, 0)))\n * instead of __attribute__((format(__printf__, 3, 0)))\n */\n#define printf rep_printf\n#endif\nint rep_printf(const char *, ...) PRINTF_ATTRIBUTE(1,2);\n#endif\n\n#if !defined(HAVE_C99_VSNPRINTF)\n#define fprintf rep_fprintf\nint rep_fprintf(FILE *stream, const char *, ...) PRINTF_ATTRIBUTE(2,3);\n#endif\n\n#ifndef HAVE_VSYSLOG\n#ifdef HAVE_SYSLOG\n#define vsyslog rep_vsyslog\nvoid rep_vsyslog (int facility_priority, const char *format, va_list arglist) PRINTF_ATTRIBUTE(2,0);\n#endif\n#endif\n\n/* we used to use these fns, but now we have good replacements\n   for snprintf and vsnprintf */\n#define slprintf snprintf\n\n\n#ifndef HAVE_VA_COPY\n#undef va_copy\n#ifdef HAVE___VA_COPY\n#define va_copy(dest, src) __va_copy(dest, src)\n#else\n#define va_copy(dest, src) (dest) = (src)\n#endif\n#endif\n\n#ifndef HAVE_VOLATILE\n#define volatile\n#endif\n\n#ifndef HAVE_COMPARISON_FN_T\ntypedef int (*comparison_fn_t)(const void *, const void *);\n#endif\n\n#ifndef HAVE_WORKING_STRPTIME\n#define strptime rep_strptime\nstruct tm;\nchar *rep_strptime(const char *buf, const char *format, struct tm *tm);\n#endif\n\n#ifndef HAVE_DUP2\n#define dup2 rep_dup2\nint rep_dup2(int oldfd, int newfd);\n#endif\n\n/* Load header file for dynamic linking stuff */\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#ifndef RTLD_LAZY\n#define RTLD_LAZY 0\n#endif\n#ifndef RTLD_NOW\n#define RTLD_NOW 0\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#ifndef HAVE_SECURE_MKSTEMP\n#define mkstemp(path) rep_mkstemp(path)\nint rep_mkstemp(char *temp);\n#endif\n\n#ifndef HAVE_MKDTEMP\n#define mkdtemp rep_mkdtemp\nchar *rep_mkdtemp(char *template);\n#endif\n\n#ifndef HAVE_PREAD\n#define pread rep_pread\nssize_t rep_pread(int __fd, void *__buf, size_t __nbytes, off_t __offset);\n#define LIBREPLACE_PREAD_REPLACED 1\n#else\n#define LIBREPLACE_PREAD_NOT_REPLACED 1\n#endif\n\n#ifndef HAVE_PWRITE\n#define pwrite rep_pwrite\nssize_t rep_pwrite(int __fd, const void *__buf, size_t __nbytes, off_t __offset);\n#define LIBREPLACE_PWRITE_REPLACED 1\n#else\n#define LIBREPLACE_PWRITE_NOT_REPLACED 1\n#endif\n\n#if !defined(HAVE_INET_NTOA) || defined(REPLACE_INET_NTOA)\n#define inet_ntoa rep_inet_ntoa\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_INET_PTON\n#define inet_pton rep_inet_pton\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_INET_NTOP\n#define inet_ntop rep_inet_ntop\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_INET_ATON\n#define inet_aton rep_inet_aton\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_CONNECT\n#define connect rep_connect\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_GETHOSTBYNAME\n#define gethostbyname rep_gethostbyname\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_GETIFADDRS\n#define getifaddrs rep_getifaddrs\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_FREEIFADDRS\n#define freeifaddrs rep_freeifaddrs\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_GET_CURRENT_DIR_NAME\n#define get_current_dir_name rep_get_current_dir_name\nchar *rep_get_current_dir_name(void);\n#endif\n\n#ifndef HAVE_STRERROR_R\n#define strerror_r rep_strerror_r\nint rep_strerror_r(int errnum, char *buf, size_t buflen);\n#endif\n\n#if !defined(HAVE_CLOCK_GETTIME)\n#define clock_gettime rep_clock_gettime\n#endif\n\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n\n/* The extra casts work around common compiler bugs.  */\n#define _TYPE_SIGNED(t) (! ((t) 0 < (t) -1))\n/* The outer cast is needed to work around a bug in Cray C 5.0.3.0.\n   It is necessary at least when t == time_t.  */\n#define _TYPE_MINIMUM(t) ((t) (_TYPE_SIGNED (t) \\\n  \t\t\t      ? ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1) : (t) 0))\n#define _TYPE_MAXIMUM(t) ((t) (~ (t) 0 - _TYPE_MINIMUM (t)))\n\n#ifndef UINT16_MAX\n#define UINT16_MAX 65535\n#endif\n\n#ifndef UINT32_MAX\n#define UINT32_MAX (4294967295U)\n#endif\n\n#ifndef UINT64_MAX\n#define UINT64_MAX ((uint64_t)-1)\n#endif\n\n#ifndef INT64_MAX\n#define INT64_MAX 9223372036854775807LL\n#endif\n\n#ifndef CHAR_BIT\n#define CHAR_BIT 8\n#endif\n\n#ifndef INT32_MAX\n#define INT32_MAX _TYPE_MAXIMUM(int32_t)\n#endif\n\n#ifdef HAVE_STDBOOL_H\n#include <stdbool.h>\n#endif\n\n#if !defined(HAVE_BOOL)\n#ifdef HAVE__Bool\n#define bool _Bool\n#else\ntypedef int bool;\n#endif\n#endif\n\n#if !defined(HAVE_INTPTR_T)\ntypedef long long intptr_t ;\n#endif\n\n#if !defined(HAVE_UINTPTR_T)\ntypedef unsigned long long uintptr_t ;\n#endif\n\n#if !defined(HAVE_PTRDIFF_T)\ntypedef unsigned long long ptrdiff_t ;\n#endif\n\n/*\n * to prevent <rpcsvc/yp_prot.h> from doing a redefine of 'bool'\n *\n * IRIX, HPUX, MacOS 10 and Solaris need BOOL_DEFINED\n * Tru64 needs _BOOL_EXISTS\n * AIX needs _BOOL,_TRUE,_FALSE\n */\n#ifndef BOOL_DEFINED\n#define BOOL_DEFINED\n#endif\n#ifndef _BOOL_EXISTS\n#define _BOOL_EXISTS\n#endif\n#ifndef _BOOL\n#define _BOOL\n#endif\n\n#ifndef __bool_true_false_are_defined\n#define __bool_true_false_are_defined\n#endif\n\n#ifndef true\n#define true (1)\n#endif\n#ifndef false\n#define false (0)\n#endif\n\n#ifndef _TRUE\n#define _TRUE true\n#endif\n#ifndef _FALSE\n#define _FALSE false\n#endif\n\n#ifndef HAVE_FUNCTION_MACRO\n#ifdef HAVE_func_MACRO\n#define __FUNCTION__ __func__\n#else\n#define __FUNCTION__ (\"\")\n#endif\n#endif\n\n\n#ifndef MIN\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#endif\n\n#ifndef MAX\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#endif\n\n#if !defined(HAVE_VOLATILE)\n#define volatile\n#endif\n\n/**\n  this is a warning hack. The idea is to use this everywhere that we\n  get the \"discarding const\" warning from gcc. That doesn't actually\n  fix the problem of course, but it means that when we do get to\n  cleaning them up we can do it by searching the code for\n  discard_const.\n\n  It also means that other error types aren't as swamped by the noise\n  of hundreds of const warnings, so we are more likely to notice when\n  we get new errors.\n\n  Please only add more uses of this macro when you find it\n  _really_ hard to fix const warnings. Our aim is to eventually use\n  this function in only a very few places.\n\n  Also, please call this via the discard_const_p() macro interface, as that\n  makes the return type safe.\n*/\n#define discard_const(ptr) ((void *)((uintptr_t)(ptr)))\n\n/** Type-safe version of discard_const */\n#define discard_const_p(type, ptr) ((type *)discard_const(ptr))\n\n#ifndef __STRING\n#define __STRING(x)    #x\n#endif\n\n#ifndef __STRINGSTRING\n#define __STRINGSTRING(x) __STRING(x)\n#endif\n\n#ifndef __LINESTR__\n#define __LINESTR__ __STRINGSTRING(__LINE__)\n#endif\n\n#ifndef __location__\n#define __location__ __FILE__ \":\" __LINESTR__\n#endif\n\n/** \n * zero a structure \n */\n#define ZERO_STRUCT(x) memset((char *)&(x), 0, sizeof(x))\n\n/** \n * zero a structure given a pointer to the structure \n */\n#define ZERO_STRUCTP(x) do { if ((x) != NULL) memset((char *)(x), 0, sizeof(*(x))); } while(0)\n\n/** \n * zero a structure given a pointer to the structure - no zero check \n */\n#define ZERO_STRUCTPN(x) memset((char *)(x), 0, sizeof(*(x)))\n\n/* zero an array - note that sizeof(array) must work - ie. it must not be a\n   pointer */\n#define ZERO_ARRAY(x) memset((char *)(x), 0, sizeof(x))\n\n/**\n * work out how many elements there are in a static array \n */\n#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))\n\n/** \n * pointer difference macro \n */\n#define PTR_DIFF(p1,p2) ((ptrdiff_t)(((const char *)(p1)) - (const char *)(p2)))\n\n#if MMAP_BLACKLIST\n#undef HAVE_MMAP\n#endif\n\n#ifdef __COMPAR_FN_T\n#define QSORT_CAST (__compar_fn_t)\n#endif\n\n#ifndef QSORT_CAST\n#define QSORT_CAST (int (*)(const void *, const void *))\n#endif\n\n#ifndef PATH_MAX\n#define PATH_MAX 1024\n#endif\n\n#ifndef MAX_DNS_NAME_LENGTH\n#define MAX_DNS_NAME_LENGTH 256 /* Actually 255 but +1 for terminating null. */\n#endif\n\n#ifndef HAVE_CRYPT\nchar *ufc_crypt(const char *key, const char *salt);\n#define crypt ufc_crypt\n#else\n#ifdef HAVE_CRYPT_H\n#include <crypt.h>\n#endif\n#endif\n\n/* these macros gain us a few percent of speed on gcc */\n#if (__GNUC__ >= 3)\n/* the strange !! is to ensure that __builtin_expect() takes either 0 or 1\n   as its first argument */\n#ifndef likely\n#define likely(x)   __builtin_expect(!!(x), 1)\n#endif\n#ifndef unlikely\n#define unlikely(x) __builtin_expect(!!(x), 0)\n#endif\n#else\n#ifndef likely\n#define likely(x) (x)\n#endif\n#ifndef unlikely\n#define unlikely(x) (x)\n#endif\n#endif\n\n#ifndef HAVE_FDATASYNC\n#define fdatasync(fd) fsync(fd)\n#elif !defined(HAVE_DECL_FDATASYNC)\nint fdatasync(int );\n#endif\n\n/* these are used to mark symbols as local to a shared lib, or\n * publicly available via the shared lib API */\n#ifndef _PUBLIC_\n#ifdef HAVE_VISIBILITY_ATTR\n#define _PUBLIC_ __attribute__((visibility(\"default\")))\n#else\n#define _PUBLIC_\n#endif\n#endif\n\n#ifndef _PRIVATE_\n#ifdef HAVE_VISIBILITY_ATTR\n#  define _PRIVATE_ __attribute__((visibility(\"hidden\")))\n#else\n#  define _PRIVATE_\n#endif\n#endif\n\n#ifndef HAVE_POLL\n#define poll rep_poll\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_GETPEEREID\n#define getpeereid rep_getpeereid\nint rep_getpeereid(int s, uid_t *uid, gid_t *gid);\n#endif\n\n#ifndef HAVE_USLEEP\n#define usleep rep_usleep\ntypedef long useconds_t;\nint usleep(useconds_t);\n#endif\n\n#ifndef HAVE_SETPROCTITLE\n#define setproctitle rep_setproctitle\nvoid rep_setproctitle(const char *fmt, ...) PRINTF_ATTRIBUTE(1, 2);\n#endif\n\nbool nss_wrapper_enabled(void);\nbool nss_wrapper_hosts_enabled(void);\nbool socket_wrapper_enabled(void);\nbool uid_wrapper_enabled(void);\n\n/* Needed for Solaris atomic_add_XX functions. */\n#if defined(HAVE_SYS_ATOMIC_H)\n#include <sys/atomic.h>\n#endif\n\n#endif /* _LIBREPLACE_REPLACE_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-5pf2pj3n7miz4zdj2eytkioexqm5klxe/spack-src/lib/replace/dlfcn.c": "/* \n   Unix SMB/CIFS implementation.\n   Samba system utilities\n   Copyright (C) Andrew Tridgell 1992-1998\n   Copyright (C) Jeremy Allison 1998-2002\n   Copyright (C) Jelmer Vernooij 2006\n\n     ** NOTE! The following LGPL license applies to the replace\n     ** library. This does NOT imply that all of Samba is released\n     ** under the LGPL\n   \n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 3 of the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"replace.h\"\n#ifdef HAVE_DL_H\n#include <dl.h>\n#endif\n\n#ifndef HAVE_DLOPEN\n#ifdef DLOPEN_TAKES_UNSIGNED_FLAGS\nvoid *rep_dlopen(const char *name, unsigned int flags)\n#else\nvoid *rep_dlopen(const char *name, int flags)\n#endif\n{\n#ifdef HAVE_SHL_LOAD\n\tif (name == NULL)\n\t\treturn PROG_HANDLE;\n\treturn (void *)shl_load(name, flags, 0);\n#else\n\treturn NULL;\n#endif\n}\n#endif\n\n#ifndef HAVE_DLSYM\nvoid *rep_dlsym(void *handle, const char *symbol)\n{\n#ifdef HAVE_SHL_FINDSYM\n\tvoid *sym_addr;\n\tif (!shl_findsym((shl_t *)&handle, symbol, TYPE_UNDEFINED, &sym_addr))\n\t\treturn sym_addr;\n#endif\n    return NULL;\n}\n#endif\n\n#ifndef HAVE_DLERROR\nchar *rep_dlerror(void)\n{\n\treturn \"dynamic loading of objects not supported on this platform\";\n}\n#endif\n\n#ifndef HAVE_DLCLOSE\nint rep_dlclose(void *handle)\n{\n#ifdef HAVE_SHL_CLOSE\n\treturn shl_unload((shl_t)handle);\n#else\n\treturn 0;\n#endif\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-5pf2pj3n7miz4zdj2eytkioexqm5klxe/spack-src/lib/replace/test/testsuite.c": "/* \n   Unix SMB/CIFS implementation.\n\n   libreplace tests\n\n   Copyright (C) Jelmer Vernooij 2006\n\n     ** NOTE! The following LGPL license applies to the talloc\n     ** library. This does NOT imply that all of Samba is released\n     ** under the LGPL\n   \n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 3 of the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"replace.h\"\n#include \"replace-test.h\"\n#include \"replace-testsuite.h\"\n\n/*\n  we include all the system/ include files here so that libreplace tests\n  them in the build farm\n*/\n#include \"system/capability.h\"\n#include \"system/dir.h\"\n#include \"system/filesys.h\"\n#include \"system/glob.h\"\n#include \"system/iconv.h\"\n#include \"system/locale.h\"\n#include \"system/network.h\"\n#include \"system/passwd.h\"\n#include \"system/readline.h\"\n#include \"system/select.h\"\n#include \"system/shmem.h\"\n#include \"system/syslog.h\"\n#include \"system/terminal.h\"\n#include \"system/time.h\"\n#include \"system/wait.h\"\n#include \"system/aio.h\"\n\n#define TESTFILE \"testfile.dat\"\n\n\n/*\n  test ftruncate() function\n */\nstatic int test_ftruncate(void)\n{\n\tstruct stat st;\n\tint fd;\n\tconst int size = 1234;\n\tprintf(\"test: ftruncate\\n\");\n\tunlink(TESTFILE);\n\tfd = open(TESTFILE, O_RDWR|O_CREAT, 0600);\n\tif (fd == -1) {\n\t\tprintf(\"failure: ftruncate [\\n\"\n\t\t\t   \"creating '%s' failed - %s\\n]\\n\", TESTFILE, strerror(errno));\n\t\treturn false;\n\t}\n\tif (ftruncate(fd, size) != 0) {\n\t\tprintf(\"failure: ftruncate [\\n%s\\n]\\n\", strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tif (fstat(fd, &st) != 0) {\n\t\tprintf(\"failure: ftruncate [\\nfstat failed - %s\\n]\\n\", strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tif (st.st_size != size) {\n\t\tprintf(\"failure: ftruncate [\\ngave wrong size %d - expected %d\\n]\\n\",\n\t\t       (int)st.st_size, size);\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tunlink(TESTFILE);\n\tprintf(\"success: ftruncate\\n\");\n\tclose(fd);\n\treturn true;\n}\n\n/*\n  test strlcpy() function.\n  see http://www.gratisoft.us/todd/papers/strlcpy.html\n */\nstatic int test_strlcpy(void)\n{\n\tchar buf[4];\n\tconst struct {\n\t\tconst char *src;\n\t\tsize_t result;\n\t} tests[] = {\n\t\t{ \"abc\", 3 },\n\t\t{ \"abcdef\", 6 },\n\t\t{ \"abcd\", 4 },\n\t\t{ \"\", 0 },\n\t\t{ NULL, 0 }\n\t};\n\tint i;\n\tprintf(\"test: strlcpy\\n\");\n\tfor (i=0;tests[i].src;i++) {\n\t\tif (strlcpy(buf, tests[i].src, sizeof(buf)) != tests[i].result) {\n\t\t\tprintf(\"failure: strlcpy [\\ntest %d failed\\n]\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\tprintf(\"success: strlcpy\\n\");\n\treturn true;\n}\n\nstatic int test_strlcat(void)\n{\n\tchar tmp[10];\n\tprintf(\"test: strlcat\\n\");\n\tstrlcpy(tmp, \"\", sizeof(tmp));\n\tif (strlcat(tmp, \"bla\", 3) != 3) {\n\t\tprintf(\"failure: strlcat [\\ninvalid return code\\n]\\n\");\n\t\treturn false;\n\t}\n\tif (strcmp(tmp, \"bl\") != 0) {\n\t\tprintf(\"failure: strlcat [\\nexpected \\\"bl\\\", got \\\"%s\\\"\\n]\\n\", \n\t\t\t   tmp);\n\t\treturn false;\n\t}\n\n\tstrlcpy(tmp, \"da\", sizeof(tmp));\n\tif (strlcat(tmp, \"me\", 4) != 4) {\n\t\tprintf(\"failure: strlcat [\\nexpected \\\"dam\\\", got \\\"%s\\\"\\n]\\n\",\n\t\t\t   tmp);\n\t\treturn false;\n\t}\n\n\tprintf(\"success: strlcat\\n\");\n\treturn true;\n}\n\nstatic int test_mktime(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_initgroups(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_memmove(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_strdup(void)\n{\n\tchar *x;\n\tprintf(\"test: strdup\\n\");\n\tx = strdup(\"bla\");\n\tif (strcmp(\"bla\", x) != 0) {\n\t\tprintf(\"failure: strdup [\\nfailed: expected \\\"bla\\\", got \\\"%s\\\"\\n]\\n\",\n\t\t\t   x);\n\t\treturn false;\n\t}\n\tfree(x);\n\tprintf(\"success: strdup\\n\");\n\treturn true;\n}\t\n\nstatic int test_setlinebuf(void)\n{\n\tprintf(\"test: setlinebuf\\n\");\n\tsetlinebuf(stdout);\n\tprintf(\"success: setlinebuf\\n\");\n\treturn true;\n}\n\nstatic int test_vsyslog(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_timegm(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_setenv(void)\n{\n#define TEST_SETENV(key, value, overwrite, result) do { \\\n\tint _ret; \\\n\tchar *_v; \\\n\t_ret = setenv(key, value, overwrite); \\\n\tif (_ret != 0) { \\\n\t\tprintf(\"failure: setenv [\\n\" \\\n\t\t\t\"setenv(%s, %s, %d) failed\\n\" \\\n\t\t\t\"]\\n\", \\\n\t\t\tkey, value, overwrite); \\\n\t\treturn false; \\\n\t} \\\n\t_v=getenv(key); \\\n\tif (!_v) { \\\n\t\tprintf(\"failure: setenv [\\n\" \\\n\t\t\t\"getenv(%s) returned NULL\\n\" \\\n\t\t\t\"]\\n\", \\\n\t\t\tkey); \\\n\t\treturn false; \\\n\t} \\\n\tif (strcmp(result, _v) != 0) { \\\n\t\tprintf(\"failure: setenv [\\n\" \\\n\t\t\t\"getenv(%s): '%s' != '%s'\\n\" \\\n\t\t\t\"]\\n\", \\\n\t\t\tkey, result, _v); \\\n\t\treturn false; \\\n\t} \\\n} while(0)\n\n#define TEST_UNSETENV(key) do { \\\n\tchar *_v; \\\n\tunsetenv(key); \\\n\t_v=getenv(key); \\\n\tif (_v) { \\\n\t\tprintf(\"failure: setenv [\\n\" \\\n\t\t\t\"getenv(%s): NULL != '%s'\\n\" \\\n\t\t\t\"]\\n\", \\\n\t\t\tSETENVTEST_KEY, _v); \\\n\t\treturn false; \\\n\t} \\\n} while (0)\n\n#define SETENVTEST_KEY \"SETENVTESTKEY\"\n#define SETENVTEST_VAL \"SETENVTESTVAL\"\n\n\tprintf(\"test: setenv\\n\");\n\tTEST_SETENV(SETENVTEST_KEY, SETENVTEST_VAL\"1\", 0, SETENVTEST_VAL\"1\");\n\tTEST_SETENV(SETENVTEST_KEY, SETENVTEST_VAL\"2\", 0, SETENVTEST_VAL\"1\");\n\tTEST_SETENV(SETENVTEST_KEY, SETENVTEST_VAL\"3\", 1, SETENVTEST_VAL\"3\");\n\tTEST_SETENV(SETENVTEST_KEY, SETENVTEST_VAL\"4\", 1, SETENVTEST_VAL\"4\");\n\tTEST_UNSETENV(SETENVTEST_KEY);\n\tTEST_UNSETENV(SETENVTEST_KEY);\n\tTEST_SETENV(SETENVTEST_KEY, SETENVTEST_VAL\"5\", 0, SETENVTEST_VAL\"5\");\n\tTEST_UNSETENV(SETENVTEST_KEY);\n\tTEST_UNSETENV(SETENVTEST_KEY);\n\tprintf(\"success: setenv\\n\");\n\treturn true;\n}\n\nstatic int test_strndup(void)\n{\n\tchar *x;\n\tprintf(\"test: strndup\\n\");\n\tx = strndup(\"bla\", 0);\n\tif (strcmp(x, \"\") != 0) {\n\t\tprintf(\"failure: strndup [\\ninvalid\\n]\\n\");\n\t\treturn false;\n\t}\n\tfree(x);\n\tx = strndup(\"bla\", 2);\n\tif (strcmp(x, \"bl\") != 0) {\n\t\tprintf(\"failure: strndup [\\ninvalid\\n]\\n\");\n\t\treturn false;\n\t}\n\tfree(x);\n\tx = strndup(\"bla\", 10);\n\tif (strcmp(x, \"bla\") != 0) {\n\t\tprintf(\"failure: strndup [\\ninvalid\\n]\\n\");\n\t\tfree(x);\n\t\treturn false;\n\t}\n\tfree(x);\n\tprintf(\"success: strndup\\n\");\n\treturn true;\n}\n\nstatic int test_strnlen(void)\n{\n\tprintf(\"test: strnlen\\n\");\n\tif (strnlen(\"bla\", 2) != 2) {\n\t\tprintf(\"failure: strnlen [\\nunexpected length\\n]\\n\");\n\t\treturn false;\n\t}\n\n\tif (strnlen(\"some text\\n\", 0) != 0) {\n\t\tprintf(\"failure: strnlen [\\nunexpected length\\n]\\n\");\n\t\treturn false;\n\t}\n\n\tif (strnlen(\"some text\", 20) != 9) {\n\t\tprintf(\"failure: strnlen [\\nunexpected length\\n]\\n\");\n\t\treturn false;\n\t}\n\n\tprintf(\"success: strnlen\\n\");\n\treturn true;\n}\n\nstatic int test_waitpid(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_seteuid(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_setegid(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_asprintf(void)\n{\n\tchar *x;\n\tprintf(\"test: asprintf\\n\");\n\tif (asprintf(&x, \"%d\", 9) != 1) {\n\t\tprintf(\"failure: asprintf [\\ngenerate asprintf\\n]\\n\");\n\t\treturn false;\n\t}\n\tif (strcmp(x, \"9\") != 0) {\n\t\tprintf(\"failure: asprintf [\\ngenerate asprintf\\n]\\n\");\n\t\treturn false;\n\t}\n\tif (asprintf(&x, \"dat%s\", \"a\") != 4) {\n\t\tprintf(\"failure: asprintf [\\ngenerate asprintf\\n]\\n\");\n\t\treturn false;\n\t}\n\tif (strcmp(x, \"data\") != 0) {\n\t\tprintf(\"failure: asprintf [\\ngenerate asprintf\\n]\\n\");\n\t\treturn false;\n\t}\n\tprintf(\"success: asprintf\\n\");\n\treturn true;\n}\n\nstatic int test_snprintf(void)\n{\n\tchar tmp[10];\n\tprintf(\"test: snprintf\\n\");\n\tif (snprintf(tmp, 3, \"foo%d\", 9) != 4) {\n\t\tprintf(\"failure: snprintf [\\nsnprintf return code failed\\n]\\n\");\n\t\treturn false;\n\t}\n\n\tif (strcmp(tmp, \"fo\") != 0) {\n\t\tprintf(\"failure: snprintf [\\nsnprintf failed\\n]\\n\");\n\t\treturn false;\n\t}\n\n\tprintf(\"success: snprintf\\n\");\n\treturn true;\n}\n\nstatic int test_vasprintf(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_vsnprintf(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_opendir(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_readdir(void)\n{\n\tprintf(\"test: readdir\\n\");\n\tif (test_readdir_os2_delete() != 0) {\n\t\treturn false;\n\t}\n\tprintf(\"success: readdir\\n\");\n\treturn true;\n}\n\nstatic int test_telldir(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_seekdir(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_dlopen(void)\n{\n\t/* FIXME: test dlopen, dlsym, dlclose, dlerror */\n\treturn true;\n}\n\n\nstatic int test_chroot(void)\n{\n\t/* FIXME: chroot() */\n\treturn true;\n}\n\nstatic int test_bzero(void)\n{\n\t/* FIXME: bzero */\n\treturn true;\n}\n\nstatic int test_strerror(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_errno(void)\n{\n\tprintf(\"test: errno\\n\");\n\terrno = 3;\n\tif (errno != 3) {\n\t\tprintf(\"failure: errno [\\nerrno failed\\n]\\n\");\n\t\treturn false;\n\t}\n\n\tprintf(\"success: errno\\n\");\n\treturn true;\n}\n\nstatic int test_mkdtemp(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_mkstemp(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_pread(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_pwrite(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_inet_ntoa(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\n#define TEST_STRTO_X(type,fmt,func,str,base,res,diff,rrnoo) do {\\\n\ttype _v; \\\n\tchar _s[64]; \\\n\tchar *_p = NULL;\\\n\tchar *_ep = NULL; \\\n\tstrlcpy(_s, str, sizeof(_s));\\\n\tif (diff >= 0) { \\\n\t\t_ep = &_s[diff]; \\\n\t} \\\n\terrno = 0; \\\n\t_v = func(_s, &_p, base); \\\n\tif (errno != rrnoo) { \\\n\t\tprintf(\"failure: %s [\\n\" \\\n\t\t       \"\\t%s\\n\" \\\n\t\t       \"\\t%s(\\\"%s\\\",%d,%d): \" fmt \" (=/!)= \" fmt \"\\n\" \\\n\t\t       \"\\terrno: %d != %d\\n\" \\\n\t\t       \"]\\n\", \\\n\t\t        __STRING(func), __location__, __STRING(func), \\\n\t\t       str, diff, base, res, _v, rrnoo, errno); \\\n\t\treturn false; \\\n\t} else if (_v != res) { \\\n\t\tprintf(\"failure: %s [\\n\" \\\n\t\t       \"\\t%s\\n\" \\\n\t\t       \"\\t%s(\\\"%s\\\",%d,%d): \" fmt \" != \" fmt \"\\n\" \\\n\t\t       \"]\\n\", \\\n\t\t       __STRING(func), __location__, __STRING(func), \\\n\t\t       str, diff, base, res, _v); \\\n\t\treturn false; \\\n\t} else if (_p != _ep) { \\\n\t\tprintf(\"failure: %s [\\n\" \\\n\t\t       \"\\t%s\\n\" \\\n\t\t       \"\\t%s(\\\"%s\\\",%d,%d): \" fmt \" (=/!)= \" fmt \"\\n\" \\\n\t\t       \"\\tptr: %p - %p = %d != %d\\n\" \\\n\t\t       \"]\\n\", \\\n\t\t       __STRING(func), __location__, __STRING(func), \\\n\t\t       str, diff, base, res, _v, _ep, _p, (int)(diff - (_ep - _p)), diff); \\\n\t\treturn false; \\\n\t} \\\n} while (0)\n\nstatic int test_strtoll(void)\n{\n\tprintf(\"test: strtoll\\n\");\n\n#define TEST_STRTOLL(str,base,res,diff,errnoo) TEST_STRTO_X(long long int, \"%lld\", strtoll,str,base,res,diff,errnoo)\n\n\tTEST_STRTOLL(\"15\",\t10,\t15LL,\t2, 0);\n\tTEST_STRTOLL(\"  15\",\t10,\t15LL,\t4, 0);\n\tTEST_STRTOLL(\"15\",\t0,\t15LL,\t2, 0);\n\tTEST_STRTOLL(\" 15 \",\t0,\t15LL,\t3, 0);\n\tTEST_STRTOLL(\"+15\",\t10,\t15LL,\t3, 0);\n\tTEST_STRTOLL(\"  +15\",\t10,\t15LL,\t5, 0);\n\tTEST_STRTOLL(\"+15\",\t0,\t15LL,\t3, 0);\n\tTEST_STRTOLL(\" +15 \",\t0,\t15LL,\t4, 0);\n\tTEST_STRTOLL(\"-15\",\t10,\t-15LL,\t3, 0);\n\tTEST_STRTOLL(\"  -15\",\t10,\t-15LL,\t5, 0);\n\tTEST_STRTOLL(\"-15\",\t0,\t-15LL,\t3, 0);\n\tTEST_STRTOLL(\" -15 \",\t0,\t-15LL,\t4, 0);\n\tTEST_STRTOLL(\"015\",\t10,\t15LL,\t3, 0);\n\tTEST_STRTOLL(\"  015\",\t10,\t15LL,\t5, 0);\n\tTEST_STRTOLL(\"015\",\t0,\t13LL,\t3, 0);\n\tTEST_STRTOLL(\"  015\",\t0,\t13LL,\t5, 0);\n\tTEST_STRTOLL(\"0x15\",\t10,\t0LL,\t1, 0);\n\tTEST_STRTOLL(\"  0x15\",\t10,\t0LL,\t3, 0);\n\tTEST_STRTOLL(\"0x15\",\t0,\t21LL,\t4, 0);\n\tTEST_STRTOLL(\"  0x15\",\t0,\t21LL,\t6, 0);\n\n\tTEST_STRTOLL(\"10\",\t16,\t16LL,\t2, 0);\n\tTEST_STRTOLL(\"  10 \",\t16,\t16LL,\t4, 0);\n\tTEST_STRTOLL(\"0x10\",\t16,\t16LL,\t4, 0);\n\tTEST_STRTOLL(\"0x10\",\t0,\t16LL,\t4, 0);\n\tTEST_STRTOLL(\" 0x10 \",\t0,\t16LL,\t5, 0);\n\tTEST_STRTOLL(\"+10\",\t16,\t16LL,\t3, 0);\n\tTEST_STRTOLL(\"  +10 \",\t16,\t16LL,\t5, 0);\n\tTEST_STRTOLL(\"+0x10\",\t16,\t16LL,\t5, 0);\n\tTEST_STRTOLL(\"+0x10\",\t0,\t16LL,\t5, 0);\n\tTEST_STRTOLL(\" +0x10 \",\t0,\t16LL,\t6, 0);\n\tTEST_STRTOLL(\"-10\",\t16,\t-16LL,\t3, 0);\n\tTEST_STRTOLL(\"  -10 \",\t16,\t-16LL,\t5, 0);\n\tTEST_STRTOLL(\"-0x10\",\t16,\t-16LL,\t5, 0);\n\tTEST_STRTOLL(\"-0x10\",\t0,\t-16LL,\t5, 0);\n\tTEST_STRTOLL(\" -0x10 \",\t0,\t-16LL,\t6, 0);\n\tTEST_STRTOLL(\"010\",\t16,\t16LL,\t3, 0);\n\tTEST_STRTOLL(\"  010 \",\t16,\t16LL,\t5, 0);\n\tTEST_STRTOLL(\"-010\",\t16,\t-16LL,\t4, 0);\n\n\tTEST_STRTOLL(\"11\",\t8,\t9LL,\t2, 0);\n\tTEST_STRTOLL(\"011\",\t8,\t9LL,\t3, 0);\n\tTEST_STRTOLL(\"011\",\t0,\t9LL,\t3, 0);\n\tTEST_STRTOLL(\"-11\",\t8,\t-9LL,\t3, 0);\n\tTEST_STRTOLL(\"-011\",\t8,\t-9LL,\t4, 0);\n\tTEST_STRTOLL(\"-011\",\t0,\t-9LL,\t4, 0);\n\n\tTEST_STRTOLL(\"011\",\t8,\t9LL,\t3, 0);\n\tTEST_STRTOLL(\"011\",\t0,\t9LL,\t3, 0);\n\tTEST_STRTOLL(\"-11\",\t8,\t-9LL,\t3, 0);\n\tTEST_STRTOLL(\"-011\",\t8,\t-9LL,\t4, 0);\n\tTEST_STRTOLL(\"-011\",\t0,\t-9LL,\t4, 0);\n\n\tTEST_STRTOLL(\"Text\",\t0,\t0LL,\t0, 0);\n\n\tTEST_STRTOLL(\"9223372036854775807\",\t10,\t9223372036854775807LL,\t19, 0);\n\tTEST_STRTOLL(\"9223372036854775807\",\t0,\t9223372036854775807LL,\t19, 0);\n\tTEST_STRTOLL(\"9223372036854775808\",\t0,\t9223372036854775807LL,\t19, ERANGE);\n\tTEST_STRTOLL(\"9223372036854775808\",\t10,\t9223372036854775807LL,\t19, ERANGE);\n\tTEST_STRTOLL(\"0x7FFFFFFFFFFFFFFF\",\t0,\t9223372036854775807LL,\t18, 0);\n\tTEST_STRTOLL(\"0x7FFFFFFFFFFFFFFF\",\t16,\t9223372036854775807LL,\t18, 0);\n\tTEST_STRTOLL(\"7FFFFFFFFFFFFFFF\",\t16,\t9223372036854775807LL,\t16, 0);\n\tTEST_STRTOLL(\"0x8000000000000000\",\t0,\t9223372036854775807LL,\t18, ERANGE);\n\tTEST_STRTOLL(\"0x8000000000000000\",\t16,\t9223372036854775807LL,\t18, ERANGE);\n\tTEST_STRTOLL(\"80000000000000000\",\t16,\t9223372036854775807LL,\t17, ERANGE);\n\tTEST_STRTOLL(\"0777777777777777777777\",\t0,\t9223372036854775807LL,\t22, 0);\n\tTEST_STRTOLL(\"0777777777777777777777\",\t8,\t9223372036854775807LL,\t22, 0);\n\tTEST_STRTOLL(\"777777777777777777777\",\t8,\t9223372036854775807LL,\t21, 0);\n\tTEST_STRTOLL(\"01000000000000000000000\",\t0,\t9223372036854775807LL,\t23, ERANGE);\n\tTEST_STRTOLL(\"01000000000000000000000\",\t8,\t9223372036854775807LL,\t23, ERANGE);\n\tTEST_STRTOLL(\"1000000000000000000000\",\t8,\t9223372036854775807LL,\t22, ERANGE);\n\n\tTEST_STRTOLL(\"-9223372036854775808\",\t10,\t-9223372036854775807LL -1,\t20, 0);\n\tTEST_STRTOLL(\"-9223372036854775808\",\t0,\t-9223372036854775807LL -1,\t20, 0);\n\tTEST_STRTOLL(\"-9223372036854775809\",\t0,\t-9223372036854775807LL -1,\t20, ERANGE);\n\tTEST_STRTOLL(\"-9223372036854775809\",\t10,\t-9223372036854775807LL -1,\t20, ERANGE);\n\tTEST_STRTOLL(\"-0x8000000000000000\",\t0,\t-9223372036854775807LL -1,\t19, 0);\n\tTEST_STRTOLL(\"-0x8000000000000000\",\t16,\t-9223372036854775807LL -1,\t19, 0);\n\tTEST_STRTOLL(\"-8000000000000000\",\t16,\t-9223372036854775807LL -1,\t17, 0);\n\tTEST_STRTOLL(\"-0x8000000000000001\",\t0,\t-9223372036854775807LL -1,\t19, ERANGE);\n\tTEST_STRTOLL(\"-0x8000000000000001\",\t16,\t-9223372036854775807LL -1,\t19, ERANGE);\n\tTEST_STRTOLL(\"-80000000000000001\",\t16,\t-9223372036854775807LL -1,\t18, ERANGE);\n\tTEST_STRTOLL(\"-01000000000000000000000\",0,\t-9223372036854775807LL -1,\t24, 0);\n\tTEST_STRTOLL(\"-01000000000000000000000\",8,\t-9223372036854775807LL -1,\t24, 0);\n\tTEST_STRTOLL(\"-1000000000000000000000\",\t8,\t-9223372036854775807LL -1,\t23, 0);\n\tTEST_STRTOLL(\"-01000000000000000000001\",0,\t-9223372036854775807LL -1,\t24, ERANGE);\n\tTEST_STRTOLL(\"-01000000000000000000001\",8,\t-9223372036854775807LL -1,\t24, ERANGE);\n\tTEST_STRTOLL(\"-1000000000000000000001\",\t8,\t-9223372036854775807LL -1,\t23, ERANGE);\n\n\tprintf(\"success: strtoll\\n\");\n\treturn true;\n}\n\nstatic int test_strtoull(void)\n{\n\tprintf(\"test: strtoull\\n\");\n\n#define TEST_STRTOULL(str,base,res,diff,errnoo) TEST_STRTO_X(long long unsigned int,\"%llu\",strtoull,str,base,res,diff,errnoo)\n\n\tTEST_STRTOULL(\"15\",\t10,\t15LLU,\t2, 0);\n\tTEST_STRTOULL(\"  15\",\t10,\t15LLU,\t4, 0);\n\tTEST_STRTOULL(\"15\",\t0,\t15LLU,\t2, 0);\n\tTEST_STRTOULL(\" 15 \",\t0,\t15LLU,\t3, 0);\n\tTEST_STRTOULL(\"+15\",\t10,\t15LLU,\t3, 0);\n\tTEST_STRTOULL(\"  +15\",\t10,\t15LLU,\t5, 0);\n\tTEST_STRTOULL(\"+15\",\t0,\t15LLU,\t3, 0);\n\tTEST_STRTOULL(\" +15 \",\t0,\t15LLU,\t4, 0);\n\tTEST_STRTOULL(\"-15\",\t10,\t18446744073709551601LLU,\t3, 0);\n\tTEST_STRTOULL(\"  -15\",\t10,\t18446744073709551601LLU,\t5, 0);\n\tTEST_STRTOULL(\"-15\",\t0,\t18446744073709551601LLU,\t3, 0);\n\tTEST_STRTOULL(\" -15 \",\t0,\t18446744073709551601LLU,\t4, 0);\n\tTEST_STRTOULL(\"015\",\t10,\t15LLU,\t3, 0);\n\tTEST_STRTOULL(\"  015\",\t10,\t15LLU,\t5, 0);\n\tTEST_STRTOULL(\"015\",\t0,\t13LLU,\t3, 0);\n\tTEST_STRTOULL(\"  015\",\t0,\t13LLU,\t5, 0);\n\tTEST_STRTOULL(\"0x15\",\t10,\t0LLU,\t1, 0);\n\tTEST_STRTOULL(\"  0x15\",\t10,\t0LLU,\t3, 0);\n\tTEST_STRTOULL(\"0x15\",\t0,\t21LLU,\t4, 0);\n\tTEST_STRTOULL(\"  0x15\",\t0,\t21LLU,\t6, 0);\n\n\tTEST_STRTOULL(\"10\",\t16,\t16LLU,\t2, 0);\n\tTEST_STRTOULL(\"  10 \",\t16,\t16LLU,\t4, 0);\n\tTEST_STRTOULL(\"0x10\",\t16,\t16LLU,\t4, 0);\n\tTEST_STRTOULL(\"0x10\",\t0,\t16LLU,\t4, 0);\n\tTEST_STRTOULL(\" 0x10 \",\t0,\t16LLU,\t5, 0);\n\tTEST_STRTOULL(\"+10\",\t16,\t16LLU,\t3, 0);\n\tTEST_STRTOULL(\"  +10 \",\t16,\t16LLU,\t5, 0);\n\tTEST_STRTOULL(\"+0x10\",\t16,\t16LLU,\t5, 0);\n\tTEST_STRTOULL(\"+0x10\",\t0,\t16LLU,\t5, 0);\n\tTEST_STRTOULL(\" +0x10 \",\t0,\t16LLU,\t6, 0);\n\tTEST_STRTOULL(\"-10\",\t16,\t-16LLU,\t3, 0);\n\tTEST_STRTOULL(\"  -10 \",\t16,\t-16LLU,\t5, 0);\n\tTEST_STRTOULL(\"-0x10\",\t16,\t-16LLU,\t5, 0);\n\tTEST_STRTOULL(\"-0x10\",\t0,\t-16LLU,\t5, 0);\n\tTEST_STRTOULL(\" -0x10 \",\t0,\t-16LLU,\t6, 0);\n\tTEST_STRTOULL(\"010\",\t16,\t16LLU,\t3, 0);\n\tTEST_STRTOULL(\"  010 \",\t16,\t16LLU,\t5, 0);\n\tTEST_STRTOULL(\"-010\",\t16,\t-16LLU,\t4, 0);\n\n\tTEST_STRTOULL(\"11\",\t8,\t9LLU,\t2, 0);\n\tTEST_STRTOULL(\"011\",\t8,\t9LLU,\t3, 0);\n\tTEST_STRTOULL(\"011\",\t0,\t9LLU,\t3, 0);\n\tTEST_STRTOULL(\"-11\",\t8,\t-9LLU,\t3, 0);\n\tTEST_STRTOULL(\"-011\",\t8,\t-9LLU,\t4, 0);\n\tTEST_STRTOULL(\"-011\",\t0,\t-9LLU,\t4, 0);\n\n\tTEST_STRTOULL(\"011\",\t8,\t9LLU,\t3, 0);\n\tTEST_STRTOULL(\"011\",\t0,\t9LLU,\t3, 0);\n\tTEST_STRTOULL(\"-11\",\t8,\t-9LLU,\t3, 0);\n\tTEST_STRTOULL(\"-011\",\t8,\t-9LLU,\t4, 0);\n\tTEST_STRTOULL(\"-011\",\t0,\t-9LLU,\t4, 0);\n\n\tTEST_STRTOULL(\"Text\",\t0,\t0LLU,\t0, 0);\n\n\tTEST_STRTOULL(\"9223372036854775807\",\t10,\t9223372036854775807LLU,\t19, 0);\n\tTEST_STRTOULL(\"9223372036854775807\",\t0,\t9223372036854775807LLU,\t19, 0);\n\tTEST_STRTOULL(\"9223372036854775808\",\t0,\t9223372036854775808LLU,\t19, 0);\n\tTEST_STRTOULL(\"9223372036854775808\",\t10,\t9223372036854775808LLU,\t19, 0);\n\tTEST_STRTOULL(\"0x7FFFFFFFFFFFFFFF\",\t0,\t9223372036854775807LLU,\t18, 0);\n\tTEST_STRTOULL(\"0x7FFFFFFFFFFFFFFF\",\t16,\t9223372036854775807LLU,\t18, 0);\n\tTEST_STRTOULL(\"7FFFFFFFFFFFFFFF\",\t16,\t9223372036854775807LLU,\t16, 0);\n\tTEST_STRTOULL(\"0x8000000000000000\",\t0,\t9223372036854775808LLU,\t18, 0);\n\tTEST_STRTOULL(\"0x8000000000000000\",\t16,\t9223372036854775808LLU,\t18, 0);\n\tTEST_STRTOULL(\"8000000000000000\",\t16,\t9223372036854775808LLU,\t16, 0);\n\tTEST_STRTOULL(\"0777777777777777777777\",\t0,\t9223372036854775807LLU,\t22, 0);\n\tTEST_STRTOULL(\"0777777777777777777777\",\t8,\t9223372036854775807LLU,\t22, 0);\n\tTEST_STRTOULL(\"777777777777777777777\",\t8,\t9223372036854775807LLU,\t21, 0);\n\tTEST_STRTOULL(\"01000000000000000000000\",0,\t9223372036854775808LLU,\t23, 0);\n\tTEST_STRTOULL(\"01000000000000000000000\",8,\t9223372036854775808LLU,\t23, 0);\n\tTEST_STRTOULL(\"1000000000000000000000\",\t8,\t9223372036854775808LLU,\t22, 0);\n\n\tTEST_STRTOULL(\"-9223372036854775808\",\t10,\t9223372036854775808LLU,\t20, 0);\n\tTEST_STRTOULL(\"-9223372036854775808\",\t0,\t9223372036854775808LLU,\t20, 0);\n\tTEST_STRTOULL(\"-9223372036854775809\",\t0,\t9223372036854775807LLU,\t20, 0);\n\tTEST_STRTOULL(\"-9223372036854775809\",\t10,\t9223372036854775807LLU,\t20, 0);\n\tTEST_STRTOULL(\"-0x8000000000000000\",\t0,\t9223372036854775808LLU,\t19, 0);\n\tTEST_STRTOULL(\"-0x8000000000000000\",\t16,\t9223372036854775808LLU,\t19, 0);\n\tTEST_STRTOULL(\"-8000000000000000\",\t16,\t9223372036854775808LLU,\t17, 0);\n\tTEST_STRTOULL(\"-0x8000000000000001\",\t0,\t9223372036854775807LLU,\t19, 0);\n\tTEST_STRTOULL(\"-0x8000000000000001\",\t16,\t9223372036854775807LLU,\t19, 0);\n\tTEST_STRTOULL(\"-8000000000000001\",\t16,\t9223372036854775807LLU,\t17, 0);\n\tTEST_STRTOULL(\"-01000000000000000000000\",0,\t9223372036854775808LLU,\t24, 0);\n\tTEST_STRTOULL(\"-01000000000000000000000\",8,\t9223372036854775808LLU,\t24, 0);\n\tTEST_STRTOULL(\"-1000000000000000000000\",8,\t9223372036854775808LLU,\t23, 0);\n\tTEST_STRTOULL(\"-01000000000000000000001\",0,\t9223372036854775807LLU,\t24, 0);\n\tTEST_STRTOULL(\"-01000000000000000000001\",8,\t9223372036854775807LLU,\t24, 0);\n\tTEST_STRTOULL(\"-1000000000000000000001\",8,\t9223372036854775807LLU,\t23, 0);\n\n\tTEST_STRTOULL(\"18446744073709551615\",\t0,\t18446744073709551615LLU,\t20, 0);\n\tTEST_STRTOULL(\"18446744073709551615\",\t10,\t18446744073709551615LLU,\t20, 0);\n\tTEST_STRTOULL(\"18446744073709551616\",\t0,\t18446744073709551615LLU,\t20, ERANGE);\n\tTEST_STRTOULL(\"18446744073709551616\",\t10,\t18446744073709551615LLU,\t20, ERANGE);\n\tTEST_STRTOULL(\"0xFFFFFFFFFFFFFFFF\",\t0,\t18446744073709551615LLU,\t18, 0);\n\tTEST_STRTOULL(\"0xFFFFFFFFFFFFFFFF\",\t16,\t18446744073709551615LLU,\t18, 0);\n\tTEST_STRTOULL(\"FFFFFFFFFFFFFFFF\",\t16,\t18446744073709551615LLU,\t16, 0);\n\tTEST_STRTOULL(\"0x10000000000000000\",\t0,\t18446744073709551615LLU,\t19, ERANGE);\n\tTEST_STRTOULL(\"0x10000000000000000\",\t16,\t18446744073709551615LLU,\t19, ERANGE);\n\tTEST_STRTOULL(\"10000000000000000\",\t16,\t18446744073709551615LLU,\t17, ERANGE);\n\tTEST_STRTOULL(\"01777777777777777777777\",0,\t18446744073709551615LLU,\t23, 0);\n\tTEST_STRTOULL(\"01777777777777777777777\",8,\t18446744073709551615LLU,\t23, 0);\n\tTEST_STRTOULL(\"1777777777777777777777\",\t8,\t18446744073709551615LLU,\t22, 0);\n\tTEST_STRTOULL(\"02000000000000000000000\",0,\t18446744073709551615LLU,\t23, ERANGE);\n\tTEST_STRTOULL(\"02000000000000000000000\",8,\t18446744073709551615LLU,\t23, ERANGE);\n\tTEST_STRTOULL(\"2000000000000000000000\",\t8,\t18446744073709551615LLU,\t22, ERANGE);\n\n\tTEST_STRTOULL(\"-18446744073709551615\",\t0,\t1LLU,\t\t\t\t21, 0);\n\tTEST_STRTOULL(\"-18446744073709551615\",\t10,\t1LLU,\t\t\t\t21, 0);\n\tTEST_STRTOULL(\"-18446744073709551616\",\t0,\t18446744073709551615LLU,\t21, ERANGE);\n\tTEST_STRTOULL(\"-18446744073709551616\",\t10,\t18446744073709551615LLU,\t21, ERANGE);\n\tTEST_STRTOULL(\"-0xFFFFFFFFFFFFFFFF\",\t0,\t1LLU,\t\t\t\t19, 0);\n\tTEST_STRTOULL(\"-0xFFFFFFFFFFFFFFFF\",\t16,\t1LLU,\t\t\t\t19, 0);\n\tTEST_STRTOULL(\"-FFFFFFFFFFFFFFFF\",\t16,\t1LLU,\t\t\t\t17, 0);\n\tTEST_STRTOULL(\"-0x10000000000000000\",\t0,\t18446744073709551615LLU,\t20, ERANGE);\n\tTEST_STRTOULL(\"-0x10000000000000000\",\t16,\t18446744073709551615LLU,\t20, ERANGE);\n\tTEST_STRTOULL(\"-10000000000000000\",\t16,\t18446744073709551615LLU,\t18, ERANGE);\n\tTEST_STRTOULL(\"-01777777777777777777777\",0,\t1LLU,\t\t\t\t24, 0);\n\tTEST_STRTOULL(\"-01777777777777777777777\",8,\t1LLU,\t\t\t\t24, 0);\n\tTEST_STRTOULL(\"-1777777777777777777777\",8,\t1LLU,\t\t\t\t23, 0);\n\tTEST_STRTOULL(\"-02000000000000000000000\",0,\t18446744073709551615LLU,\t24, ERANGE);\n\tTEST_STRTOULL(\"-02000000000000000000000\",8,\t18446744073709551615LLU,\t24, ERANGE);\n\tTEST_STRTOULL(\"-2000000000000000000000\",8,\t18446744073709551615LLU,\t23, ERANGE);\n\n\tprintf(\"success: strtoull\\n\");\n\treturn true;\n}\n\n/* \nFIXME:\nTypes:\nbool\nsocklen_t\nuint{8,16,32,64}_t\nint{8,16,32,64}_t\nintptr_t\n\nConstants:\nPATH_NAME_MAX\nUINT{16,32,64}_MAX\nINT32_MAX\n*/\n\nstatic int test_va_copy(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_FUNCTION(void)\n{\n\tprintf(\"test: FUNCTION\\n\");\n\tif (strcmp(__FUNCTION__, \"test_FUNCTION\") != 0) {\n\t\tprintf(\"failure: FUNCTION [\\nFUNCTION invalid\\n]\\n\");\n\t\treturn false;\n\t}\n\tprintf(\"success: FUNCTION\\n\");\n\treturn true;\n}\n\nstatic int test_MIN(void)\n{\n\tprintf(\"test: MIN\\n\");\n\tif (MIN(20, 1) != 1) {\n\t\tprintf(\"failure: MIN [\\nMIN invalid\\n]\\n\");\n\t\treturn false;\n\t}\n\tif (MIN(1, 20) != 1) {\n\t\tprintf(\"failure: MIN [\\nMIN invalid\\n]\\n\");\n\t\treturn false;\n\t}\n\tprintf(\"success: MIN\\n\");\n\treturn true;\n}\n\nstatic int test_MAX(void)\n{\n\tprintf(\"test: MAX\\n\");\n\tif (MAX(20, 1) != 20) {\n\t\tprintf(\"failure: MAX [\\nMAX invalid\\n]\\n\");\n\t\treturn false;\n\t}\n\tif (MAX(1, 20) != 20) {\n\t\tprintf(\"failure: MAX [\\nMAX invalid\\n]\\n\");\n\t\treturn false;\n\t}\n\tprintf(\"success: MAX\\n\");\n\treturn true;\n}\n\nstatic int test_socketpair(void)\n{\n\tint sock[2];\n\tchar buf[20];\n\n\tprintf(\"test: socketpair\\n\");\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, sock) == -1) {\n\t\tprintf(\"failure: socketpair [\\n\"\n\t\t\t   \"socketpair() failed\\n\"\n\t\t\t   \"]\\n\");\n\t\treturn false;\n\t}\n\n\tif (write(sock[1], \"automatisch\", 12) == -1) {\n\t\tprintf(\"failure: socketpair [\\n\"\n\t\t\t   \"write() failed: %s\\n\"\n\t\t\t   \"]\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\n\tif (read(sock[0], buf, 12) == -1) {\n\t\tprintf(\"failure: socketpair [\\n\"\n\t\t\t   \"read() failed: %s\\n\"\n\t\t\t   \"]\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\n\tif (strcmp(buf, \"automatisch\") != 0) {\n\t\tprintf(\"failure: socketpair [\\n\"\n\t\t\t   \"expected: automatisch, got: %s\\n\"\n\t\t\t   \"]\\n\", buf);\n\t\treturn false;\n\t}\n\n\tprintf(\"success: socketpair\\n\");\n\n\treturn true;\n}\n\nextern int libreplace_test_strptime(void);\n\nstatic int test_strptime(void)\n{\n\treturn libreplace_test_strptime();\n}\n\nextern int getifaddrs_test(void);\n\nstatic int test_getifaddrs(void)\n{\n\n\tprintf(\"test: getifaddrs\\n\");\n\n\tif (getifaddrs_test() != 0) {\n\t\tprintf(\"failure: getifaddrs\\n\");\n\t\treturn false;\n\t}\n\n\tprintf(\"success: getifaddrs\\n\");\n\treturn true;\n}\n\nstatic int test_utime(void)\n{\n\tstruct utimbuf u;\n\tstruct stat st1, st2, st3;\n\tint fd;\n\n\tprintf(\"test: utime\\n\");\n\tunlink(TESTFILE);\n\n\tfd = open(TESTFILE, O_RDWR|O_CREAT, 0600);\n\tif (fd == -1) {\n\t\tprintf(\"failure: utime [\\n\"\n\t\t       \"creating '%s' failed - %s\\n]\\n\",\n\t\t       TESTFILE, strerror(errno));\n\t\treturn false;\n\t}\n\n\tif (fstat(fd, &st1) != 0) {\n\t\tprintf(\"failure: utime [\\n\"\n\t\t       \"fstat (1) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tu.actime = st1.st_atime + 300;\n\tu.modtime = st1.st_mtime - 300;\n\tif (utime(TESTFILE, &u) != 0) {\n\t\tprintf(\"failure: utime [\\n\"\n\t\t       \"utime(&u) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tif (fstat(fd, &st2) != 0) {\n\t\tprintf(\"failure: utime [\\n\"\n\t\t       \"fstat (2) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tif (utime(TESTFILE, NULL) != 0) {\n\t\tprintf(\"failure: utime [\\n\"\n\t\t       \"utime(NULL) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tif (fstat(fd, &st3) != 0) {\n\t\tprintf(\"failure: utime [\\n\"\n\t\t       \"fstat (3) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n#define CMP_VAL(a,c,b) do { \\\n\tif (a c b) { \\\n\t\tprintf(\"failure: utime [\\n\" \\\n\t\t       \"%s: %s(%d) %s %s(%d)\\n]\\n\", \\\n\t\t       __location__, \\\n\t\t       #a, (int)a, #c, #b, (int)b); \\\n\t\tclose(fd); \\\n\t\treturn false; \\\n\t} \\\n} while(0)\n#define EQUAL_VAL(a,b) CMP_VAL(a,!=,b)\n#define GREATER_VAL(a,b) CMP_VAL(a,<=,b)\n#define LESSER_VAL(a,b) CMP_VAL(a,>=,b)\n\n\tEQUAL_VAL(st2.st_atime, st1.st_atime + 300);\n\tEQUAL_VAL(st2.st_mtime, st1.st_mtime - 300);\n\tLESSER_VAL(st3.st_atime, st2.st_atime);\n\tGREATER_VAL(st3.st_mtime, st2.st_mtime);\n\n#undef CMP_VAL\n#undef EQUAL_VAL\n#undef GREATER_VAL\n#undef LESSER_VAL\n\n\tunlink(TESTFILE);\n\tprintf(\"success: utime\\n\");\n\tclose(fd);\n\treturn true;\n}\n\nstatic int test_utimes(void)\n{\n\tstruct timeval tv[2];\n\tstruct stat st1, st2;\n\tint fd;\n\n\tprintf(\"test: utimes\\n\");\n\tunlink(TESTFILE);\n\n\tfd = open(TESTFILE, O_RDWR|O_CREAT, 0600);\n\tif (fd == -1) {\n\t\tprintf(\"failure: utimes [\\n\"\n\t\t       \"creating '%s' failed - %s\\n]\\n\",\n\t\t       TESTFILE, strerror(errno));\n\t\treturn false;\n\t}\n\n\tif (fstat(fd, &st1) != 0) {\n\t\tprintf(\"failure: utimes [\\n\"\n\t\t       \"fstat (1) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tZERO_STRUCT(tv);\n\ttv[0].tv_sec = st1.st_atime + 300;\n\ttv[1].tv_sec = st1.st_mtime - 300;\n\tif (utimes(TESTFILE, tv) != 0) {\n\t\tprintf(\"failure: utimes [\\n\"\n\t\t       \"utimes(tv) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tif (fstat(fd, &st2) != 0) {\n\t\tprintf(\"failure: utimes [\\n\"\n\t\t       \"fstat (2) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n#define EQUAL_VAL(a,b) do { \\\n\tif (a != b) { \\\n\t\tprintf(\"failure: utimes [\\n\" \\\n\t\t       \"%s: %s(%d) != %s(%d)\\n]\\n\", \\\n\t\t       __location__, \\\n\t\t       #a, (int)a, #b, (int)b); \\\n\t\tclose(fd); \\\n\t\treturn false; \\\n\t} \\\n} while(0)\n\n\tEQUAL_VAL(st2.st_atime, st1.st_atime + 300);\n\tEQUAL_VAL(st2.st_mtime, st1.st_mtime - 300);\n\n#undef EQUAL_VAL\n\n\tunlink(TESTFILE);\n\tprintf(\"success: utimes\\n\");\n\tclose(fd);\n\treturn true;\n}\n\nstatic int test_memmem(void)\n{\n\tchar *s;\n\n\tprintf(\"test: memmem\\n\");\n\n\ts = (char *)memmem(\"foo\", 3, \"fo\", 2);\n\tif (strcmp(s, \"foo\") != 0) {\n\t\tprintf(__location__ \": Failed memmem\\n\");\n\t\treturn false;\n\t}\n\n\ts = (char *)memmem(\"foo\", 3, \"\", 0);\n\t/* it is allowable for this to return NULL (as happens on\n\t   FreeBSD) */\n\tif (s && strcmp(s, \"foo\") != 0) {\n\t\tprintf(__location__ \": Failed memmem\\n\");\n\t\treturn false;\n\t}\n\n\ts = (char *)memmem(\"foo\", 4, \"o\", 1);\n\tif (strcmp(s, \"oo\") != 0) {\n\t\tprintf(__location__ \": Failed memmem\\n\");\n\t\treturn false;\n\t}\n\n\ts = (char *)memmem(\"foobarfodx\", 11, \"fod\", 3);\n\tif (strcmp(s, \"fodx\") != 0) {\n\t\tprintf(__location__ \": Failed memmem\\n\");\n\t\treturn false;\n\t}\n\n\tprintf(\"success: memmem\\n\");\n\n\treturn true;\n}\n\nstatic bool test_closefrom(void)\n{\n\tint i, fd;\n\n\tfor (i=0; i<100; i++) {\n\t\tfd = dup(0);\n\t\tif (fd == -1) {\n\t\t\tperror(\"dup failed\");\n\t\t\treturn false;\n\t\t}\n\n\t\t/* 1000 is just an arbitrarily chosen upper bound */\n\n\t\tif (fd >= 1000) {\n\t\t\tprintf(\"fd=%d\\n\", fd);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tclosefrom(3);\n\n\tfor (i=3; i<=fd; i++) {\n\t\toff_t off;\n\t\toff = lseek(i, 0, SEEK_CUR);\n\t\tif ((off != (off_t)-1) || (errno != EBADF)) {\n\t\t\tprintf(\"fd %d not closed\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool torture_local_replace(struct torture_context *ctx)\n{\n\tbool ret = true;\n\tret &= test_ftruncate();\n\tret &= test_strlcpy();\n\tret &= test_strlcat();\n\tret &= test_mktime();\n\tret &= test_initgroups();\n\tret &= test_memmove();\n\tret &= test_strdup();\n\tret &= test_setlinebuf();\n\tret &= test_vsyslog();\n\tret &= test_timegm();\n\tret &= test_setenv();\n\tret &= test_strndup();\n\tret &= test_strnlen();\n\tret &= test_waitpid();\n\tret &= test_seteuid();\n\tret &= test_setegid();\n\tret &= test_asprintf();\n\tret &= test_snprintf();\n\tret &= test_vasprintf();\n\tret &= test_vsnprintf();\n\tret &= test_opendir();\n\tret &= test_readdir();\n\tret &= test_telldir();\n\tret &= test_seekdir();\n\tret &= test_dlopen();\n\tret &= test_chroot();\n\tret &= test_bzero();\n\tret &= test_strerror();\n\tret &= test_errno();\n\tret &= test_mkdtemp();\n\tret &= test_mkstemp();\n\tret &= test_pread();\n\tret &= test_pwrite();\n\tret &= test_inet_ntoa();\n\tret &= test_strtoll();\n\tret &= test_strtoull();\n\tret &= test_va_copy();\n\tret &= test_FUNCTION();\n\tret &= test_MIN();\n\tret &= test_MAX();\n\tret &= test_socketpair();\n\tret &= test_strptime();\n\tret &= test_getifaddrs();\n\tret &= test_utime();\n\tret &= test_utimes();\n\tret &= test_memmem();\n\tret &= test_closefrom();\n\n\treturn ret;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-5pf2pj3n7miz4zdj2eytkioexqm5klxe/spack-src/lib/replace/timegm.c",
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-5pf2pj3n7miz4zdj2eytkioexqm5klxe/spack-src/doc/context.png",
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-5pf2pj3n7miz4zdj2eytkioexqm5klxe/spack-src/doc/stealing.png",
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-5pf2pj3n7miz4zdj2eytkioexqm5klxe/spack-src/doc/context_tree.png"
    ],
    "total_files": 246
}