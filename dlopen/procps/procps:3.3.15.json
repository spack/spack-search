{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-procps-3.3.15-7t5vyquf2qqr6grf67vw57m6nxql3tx6/spack-src/configure.ac": "#                                               -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\n\nAC_PREREQ([2.69])\nAC_CONFIG_MACRO_DIR([m4])\nAC_INIT([procps-ng],\n\tm4_esyscmd([misc/git-version-gen .tarball-version]),\n\t[procps@freelists.org],,[https://gitlab.com/procps-ng/procps])\nAM_INIT_AUTOMAKE([foreign 1.11 subdir-objects -Wall -Wno-portability tar-pax no-dist-gzip dist-xz])\nAM_SILENT_RULES([yes])\nAC_CONFIG_SRCDIR([free.c])\nAC_CONFIG_HEADERS([config.h])\n\n# Checks for programs.\nAC_USE_SYSTEM_EXTENSIONS\nAC_SYS_LARGEFILE\nAC_PROG_AWK\nAC_PROG_CC\nAC_PROG_CC_STDC\nif test \"$cross_compiling\" = no; then\n  if test \"x$ac_cv_prog_cc_c99\" = \"xno\" || test \"x$ac_cv_prog_cc_c99\" = \"x\"; then\n  # We might be on RHEL5 with a git checkout and so broken\n  # autoconf. Check if CC is gcc and if it bails when given -std=gnu99.\n  # If not, use that.  Yuck.\n    if test \"x$ac_cv_c_compiler_gnu\" = \"xyes\"; then\n       CC=\"$CC -std=gnu99\"\n       AC_RUN_IFELSE(\n          [AC_LANG_PROGRAM([],[[\n  return 0;\n      ]])],\n      [],\n      [AC_MSG_ERROR([Could not find a C99 compatible compiler])])\n    else\n      AC_MSG_ERROR([Could not find a C99 compatible compiler])\n    fi\n  fi\nfi\nAM_PROG_CC_C_O\nAC_PROG_CPP\nAC_PROG_INSTALL\nAC_PROG_LN_S\nPKG_PROG_PKG_CONFIG\nAC_PROG_MAKE_SET\n\n# Checks for header files.\nAC_HEADER_MAJOR\nAC_CHECK_HEADERS([arpa/inet.h fcntl.h float.h langinfo.h libintl.h limits.h locale.h netinet/in.h stdint.h stdio_ext.h stdlib.h string.h sys/file.h sys/ioctl.h sys/param.h sys/time.h termios.h unistd.h utmp.h values.h wchar.h wctype.h])\n\n# Checks for typedefs, structures, and compiler characteristics.\nAC_CHECK_HEADER_STDBOOL\nAC_TYPE_UID_T\nAC_C_INLINE\nAC_TYPE_INT32_T\nAC_TYPE_PID_T\nAC_C_RESTRICT\nAC_TYPE_SIZE_T\nAC_TYPE_SSIZE_T\nAC_CHECK_MEMBERS([struct stat.st_rdev])\n\ndnl libtool\nLT_INIT\n\n# Checks for library functions.\nAC_FUNC_ERROR_AT_LINE\nAC_FUNC_FORK\nAC_FUNC_MALLOC\nAC_FUNC_MBRTOWC\nAC_FUNC_MMAP\nAC_FUNC_REALLOC\nAC_FUNC_STRTOD\n\nusrbin_execdir='${exec_prefix}/bin'\nAC_SUBST([usrbin_execdir])\n\nif test \"x$host_os\" = xcygwin\nthen\n  prefix=/usr\n  sysconfdir=/etc\n  libexecdir=/usr/lib\n  localstatedir=/var\n  datadir=/usr/share\n  mandir=/usr/share/man\n  infodir=/usr/share/info\n  AC_SUBST([prefix])\n  AC_SUBST([sysconfdir])\n  AC_SUBST([libexecdir])\n  AC_SUBST([localstatedir])\n  AC_SUBST([datadir])\n  AC_SUBST([mandir])\n  AC_SUBST([infodir])\nfi\n\nAM_GNU_GETTEXT_VERSION([0.14.1])\nAM_GNU_GETTEXT([external])\nif test -d \"$srcdir/po\"\nthen\n\tALL_LINGUAS=`cd $srcdir/po > /dev/null && echo *.po | sed 's/\\.po//g'`\nelse\n\tALL_LINGUAS=\"af am ar as be bg bn_IN bn ca cs cy da de el en_GB es et eu_ES fa fi fr gl gu he hi hr hu hy id is it ja ka kn ko ku lo lt lv mk ml mr ms my nb nl nn no nso or pa pl pt_BR pt ro ru si sk sl sq sr@Latn sr sv ta te th tr uk ur vi zh_CN zh_TW zu\"\nfi\n\nAC_CHECK_HEADERS(error.h, [], [], AC_INCLUDES_DEFAULT)\n\nAC_CHECK_HEADERS(stdio_ext.h, [], [], AC_INCLUDES_DEFAULT)\n\nAC_MSG_CHECKING(whether program_invocation_name is defined)\nAC_TRY_COMPILE([#include <errno.h>],\n\t\t[program_invocation_name = \"test\";],\n\t\tAC_DEFINE(HAVE_PROGRAM_INVOCATION_NAME, 1,\n\t\t\t[Define if program_invocation_name is defined])\n\t\tAC_MSG_RESULT(yes),\n\t\tAC_MSG_RESULT(no))\n\nAC_MSG_CHECKING(whether program_invocation_short_name is defined)\nAC_TRY_COMPILE([#include <errno.h>],\n\t\t[program_invocation_short_name = \"test\";],\n\t\tAC_DEFINE(HAVE_PROGRAM_INVOCATION_SHORT_NAME, 1,\n\t\t\t[Define if program_invocation_short_name is defined])\n\t\tAC_MSG_RESULT(yes),\n\t\tAC_MSG_RESULT(no))\n\ndnl watch8bit must be before the AC_ARG_WITH set as it sets up ncurses\nAC_SUBST([WITH_WATCH8BIT])\nAC_ARG_ENABLE([watch8bit],\n  AS_HELP_STRING([--enable-watch8bit], [enable watch to be 8bit clean (requires ncursesw)]),\n  [], [enable_watch8bit=no]\n)\nif test \"$enable_watch8bit\" = \"yes\"; then\n  AC_DEFINE([WITH_WATCH8BIT], [1], [Enable 8 bit clean watch])\nfi\n\nAC_ARG_ENABLE([libselinux],\n  AS_HELP_STRING([--enable-libselinux], [enable libselinux]),\n  [], [enable_libselinux=no]\n)\nif test \"$enable_libselinux\" = \"yes\"; then\n  AC_DEFINE([ENABLE_LIBSELINUX], [1], [Enable libselinux])\nfi\n\n# Optional packages - AC_ARG_WITH\nAC_ARG_WITH([ncurses],\n  AS_HELP_STRING([--without-ncurses], [build only applications not needing ncurses]),\n  [], [with_ncurses=yes]\n)\nif test \"x$with_ncurses\" = xno; then\n  AM_CONDITIONAL(WITH_NCURSES, false)\nelse\n  PKG_CHECK_MODULES([NCURSES], [ncurses], [], [\n    AC_CHECK_LIB(ncurses, initscr, [have_ncurses=yes], [have_ncurses=no])\n    AC_CHECK_HEADERS(curses.h ncurses.h term.h, [], [have_ncurses=no], AC_INCLUDES_DEFAULT)\n    if test \"x$have_ncurses\" = xno; then\n      AC_MSG_ERROR([ncurses support missing/incomplete (for partial build use --without-ncurses)])\n    fi\n    NCURSES_LIBS=\"-lncurses\"\n  ])\n  AM_CONDITIONAL(WITH_NCURSES, true)\n  if test \"$enable_watch8bit\" = yes; then\n    PKG_CHECK_MODULES([NCURSESW], [ncursesw], [WATCH_NCURSES_LIBS=\"$NCURSESW_LIBS\"]\n    [WATCH_NCURSES_CFLAGS=\"$NCURSESW_CFLAGS\"], [\n      AC_CHECK_LIB([ncursesw], [addwstr], [WATCH_NCURSES_LIBS=-lncursesw],\n                   [AC_MSG_ERROR([Cannot find ncurses wide library ncursesw with --enable-watch8bit])])\n    ])\n  else\n    WATCH_NCURSES_LIBS=\"$NCURSES_LIBS\"\n  fi\nfi\nAC_SUBST([NCURSES_LIBS])\nAC_SUBST([WATCH_NCURSES_LIBS])\nAC_SUBST([WATCH_NCURSES_CFLAGS])\n\nAC_ARG_WITH([systemd],\n  [AS_HELP_STRING([--with-systemd], [enable systemd support])],\n  [], [with_systemd=no]\n)\nAS_IF([test \"x$with_systemd\" != \"xno\"], [\n  PKG_CHECK_MODULES([SYSTEMD], [libsystemd])\n  AC_DEFINE(WITH_SYSTEMD, 1, [enable systemd support])\n])\nAM_CONDITIONAL([WITH_SYSTEMD], [test x$with_systemd != xno])\n\nAC_ARG_WITH([elogind],\n  [AS_HELP_STRING([--with-elogind], [enable elogind support])],\n  [], [with_elogind=no]\n)\n# Do not allow elogind if systemd is wanted and found\nAS_IF([test \"x$with_systemd\" != \"xno\"], [with_elogind=no])\n\nAS_IF([test \"x$with_elogind\" != \"xno\"], [\n  PKG_CHECK_MODULES([ELOGIND], [libelogind])\n  AC_DEFINE(WITH_ELOGIND, 1, [enable elogind support])\n])\nAM_CONDITIONAL([WITH_ELOGIND], [test x$with_elogind != xno])\n\n# AC_ARG_ENABLEs\nAC_ARG_ENABLE([pidof],\n  AS_HELP_STRING([--disable-pidof], [do not build pidof]),\n  [], [enable_pidof=yes]\n)\nAM_CONDITIONAL(BUILD_PIDOF, test \"x$enable_pidof\" = xyes)\n\nAC_ARG_ENABLE([kill],\n  AS_HELP_STRING([--disable-kill], [do not build kill]),\n  [], [enable_kill=yes]\n)\nAM_CONDITIONAL(BUILD_KILL, test \"x$enable_kill\" = xyes)\nAM_CONDITIONAL(LINUX, test \"x$host_os\" = xlinux-gnu)\nAM_CONDITIONAL(CYGWIN, test \"x$host_os\" = xcygwin)\n\nAC_ARG_ENABLE([skill],\n  AS_HELP_STRING([--enable-skill], [build skill and snice]),\n  [], [enable_skill=no]\n)\nAM_CONDITIONAL(BUILD_SKILL, test \"x$enable_skill\" = xyes)\n\nAC_ARG_ENABLE([examples],\n  AS_HELP_STRING([--enable-examples], [add example files to installation]),\n  [], [enable_examples=no]\n)\nAM_CONDITIONAL(EXAMPLE_FILES, test \"x$enable_examples\" = xyes)\n\nAC_ARG_ENABLE([sigwinch],\n  AS_HELP_STRING([--enable-sigwinch], [reduce impact of x-windows resize operations on top]),\n  [], [enable_sigwinch=no]\n)\nif test \"x$enable_sigwinch\" = xyes; then\n  AC_DEFINE(SIGNALS_LESS, 1, [reduce impact of x-windows resize operations on top])\nfi\n\nAC_ARG_ENABLE([wide-percent],\n  AS_HELP_STRING([--enable-wide-percent], [provide extra precision under %CPU and %MEM for top]),\n  [], [enable_wide_percent=no]\n)\nif test \"x$enable_wide_percent\" = xyes; then\n  AC_DEFINE(BOOST_PERCNT, 1, [provide extra precision under %CPU and %MEM for top])\nfi\n\nAC_ARG_ENABLE([wide-memory],\n  AS_HELP_STRING([--enable-wide-memory], [provide extra precision under memory fields for top]),\n  [], [enable_wide_memory=no]\n)\nif test \"x$enable_wide_memory\" = xyes; then\n  AC_DEFINE(BOOST_MEMORY, 1, [provide extra precision under memory fields for top])\nfi\n\nAC_ARG_ENABLE([modern-top],\n  AS_HELP_STRING([--disable-modern-top], [disable new startup defaults, return to original top]),\n  [], [enable_modern_top=yes]\n)\nif test \"x$enable_modern_top\" = xno; then\n  AC_DEFINE(ORIG_TOPDEFS, 1, [disable new startup defaults, return to original top])\nfi\n\nDL_LIB=\nAC_ARG_ENABLE([numa],\n  AS_HELP_STRING([--disable-numa], [disable NUMA/Node support in top]),\n  [], [enable_numa=yes]\n)\nif test \"x$enable_numa\" = xno; then\n  AC_DEFINE([NUMA_DISABLE], [1], [disable NUMA/Node support in top])\nelse\n  AC_SEARCH_LIBS([dlopen], [dl], [],\n    [AC_MSG_ERROR([dynamic linking unavailable, circumvent with --disable-numa])])\n  if test \"x$ac_cv_search_dlopen\" != \"xnone required\"; then\n    DL_LIB=\"$ac_cv_search_dlopen\"\n  fi\nfi\nAC_SUBST([DL_LIB])\n\nAC_ARG_ENABLE([w-from],\n  AS_HELP_STRING([--enable-w-from], [enable w from field by default]),\n  [], [enable_w_from=no]\n)\nif test \"x$enable_w_from\" = xyes; then\n  AC_DEFINE(W_SHOWFROM, 1, [enable w from field by default])\nfi\n\nAC_ARG_ENABLE([whining],\n  AS_HELP_STRING([--disable-whining], [do not print unnecessary warnings (slackware-ism)]),\n  [], [enable_whining=yes]\n)\nif test \"x$enable_whining\" = xyes; then\n  AC_DEFINE(BUILD_WITH_WHINE, 1, [should extra warnings be printed (slackware-ism)])\nfi\n\nif test x\"$DEJAGNU\" = x\nthen\n  DEJAGNU=\"/dev/null\"\nfi\nAC_SUBST(DEJAGNU)\n\nAC_CHECK_FUNCS([__fpending alarm atexit dup2 gethostname getpagesize gettimeofday iswprint memchr memmove memset nl_langinfo putenv regcomp rpmatch select setlocale strcasecmp strchr strcspn strdup strerror strncasecmp strndup strpbrk strrchr strspn strstr strtol strtoul strtoull strverscmp utmpname wcwidth])\n\nAC_CONFIG_FILES([Makefile\n                 include/Makefile\n                 man-po/Makefile\n                 po/Makefile.in\n                 proc/libprocps.pc\n                 testsuite/Makefile])\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-procps-3.3.15-7t5vyquf2qqr6grf67vw57m6nxql3tx6/spack-src/ps/output.c": "/*\n * output.c - ps output definitions\n * Copyright 1999-2004 by Albert Cahalan\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n/*\n * This file is really gross, and I know it. I looked into several\n * alternate ways to deal with the mess, and they were all ugly.\n *\n * FreeBSD has a fancy hack using offsets into a struct -- that\n * saves code but it is _really_ gross. See the PO macro below.\n *\n * We could have a second column width for wide output format.\n * For example, Digital prints the real-time signals.\n */\n\n/*\n * Data table idea:\n *\n * table 1 maps aix to specifier\n * table 2 maps shortsort to specifier\n * table 3 maps macro to specifiers\n * table 4 maps specifier to title,datatype,offset,vendor,helptext\n * table 5 maps datatype to justification,width,widewidth,sorting,printing\n *\n * Here, \"datatype\" could be user,uid,u16,pages,deltaT,signals,tty,longtty...\n * It must be enough to determine printing and sorting.\n *\n * After the tables, increase width as needed to fit the header.\n *\n * Table 5 could go in a file with the output functions.\n */\n\n#include <ctype.h>\n#if ENABLE_LIBSELINUX\n#include <dlfcn.h>\n#endif\n#include <fcntl.h>\n#include <grp.h>\n#include <limits.h>\n#include <pwd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n\n#include \"../proc/readproc.h\"\n#include \"../proc/sysinfo.h\"\n#include \"../proc/wchan.h\"\n#include \"../proc/procps.h\"\n#include \"../proc/devname.h\"\n#include \"../proc/escape.h\"\n#include \"../proc/numa.h\"\n\n#include \"common.h\"\n\n/* TODO:\n * Stop assuming system time is local time.\n */\n\n#define COLWID 240 /* satisfy snprintf, which is faster than sprintf */\n\nstatic unsigned max_rightward = OUTBUF_SIZE-1; /* space for RIGHT stuff */\nstatic unsigned max_leftward = OUTBUF_SIZE-1; /* space for LEFT stuff */\n\n\n\nstatic int wide_signals;  /* true if we have room */\n\nstatic time_t seconds_since_1970;\n\n\n/*************************************************************************/\n/************ Lots of sort functions, starting with the NOP **************/\n\nstatic int sr_nop(const proc_t* a, const proc_t* b){\n  (void)a;(void)b; /* shut up gcc */\n  return 0;\n}\n\nstatic int sr_cgroup(const proc_t* a, const proc_t* b)\n{\n    /* This is a \"vector\" of one */\n    if (*a->cgroup == NULL || *b->cgroup == NULL)\n        return 0;\n    return strcmp(*a->cgroup, *b->cgroup);\n}\n\n#define CMP_STR(NAME) \\\nstatic int sr_ ## NAME(const proc_t* P, const proc_t* Q) { \\\n    return strcmp(P->NAME, Q->NAME); \\\n}\n\n#define CMP_INT(NAME) \\\nstatic int sr_ ## NAME (const proc_t* P, const proc_t* Q) { \\\n    if (P->NAME < Q->NAME) return -1; \\\n    if (P->NAME > Q->NAME) return  1; \\\n    return 0; \\\n}\n\n/* fast versions, for values which either:\n * a. differ by no more than 0x7fffffff\n * b. only need to be grouped same w/ same\n */\n#define CMP_SMALL(NAME) \\\nstatic int sr_ ## NAME (const proc_t* P, const proc_t* Q) { \\\n    return (int)(P->NAME) - (int)(Q->NAME); \\\n}\n#define CMP_SMALL2(NAME,WHAT) \\\nstatic int sr_ ## NAME (const proc_t* P, const proc_t* Q) { \\\n    return (int)(P->WHAT) - (int)(Q->WHAT); \\\n}\n\n#define cook_time(P) (P->utime + P->stime) / Hertz\n\n#define cook_etime(P) (((unsigned long long)seconds_since_boot >= (P->start_time / Hertz)) ? ((unsigned long long)seconds_since_boot - (P->start_time / Hertz)) : 0)\n\n#define CMP_COOKED_TIME(NAME) \\\nstatic int sr_ ## NAME (const proc_t* P, const proc_t* Q) { \\\n    unsigned long p_time,q_time; \\\n    p_time=cook_ ##NAME (P); \\\n    q_time=cook_ ##NAME (Q); \\\n    if (p_time < q_time) return -1; \\\n    if (p_time > q_time) return 1; \\\n    return 0; \\\n}\n\n#define CMP_NS(NAME, ID) \\\nstatic int sr_ ## NAME (const proc_t* P, const proc_t* Q) { \\\n    if ((unsigned long)P->ns[ID] < (unsigned long)Q->ns[ID]) return -1; \\\n    if ((unsigned long)P->ns[ID] > (unsigned long)Q->ns[ID]) return  1; \\\n    return 0; \\\n}\n\nCMP_INT(rtprio)\nCMP_SMALL(sched)\nCMP_INT(cutime)\nCMP_SMALL(priority)                                             /* nice */\nCMP_SMALL(nlwp)\nCMP_SMALL(nice)                                                 /* priority */\nCMP_INT(rss)      /* resident set size from stat file */ /* vm_rss, resident */\nCMP_INT(alarm)\nCMP_INT(size)      /* total pages */                     /* vm_size, vsize */\nCMP_INT(resident)  /* resident pages */                     /* vm_rss, rss */\nCMP_INT(share)     /* shared pages */\nCMP_INT(trs)       /* executable pages */\nCMP_INT(lrs)       /* obsolete \"library\" pages above 0x60000000 */\nCMP_INT(drs)       /* other pages (assumed data?) */\nCMP_INT(dt)        /* dirty pages */\n\nCMP_INT(vm_size)    /* kB VM */                             /* size, vsize */\nCMP_INT(vm_lock)    /* kB locked */\nCMP_INT(vm_rss)     /* kB rss */                          /* rss, resident */\nCMP_INT(vm_data)    /* kB \"data\" == data-stack */\nCMP_INT(vm_stack)   /* kB stack */\nCMP_INT(vm_exe)     /* kB \"exec\" == exec-lib */\nCMP_INT(vm_lib)     /* kB \"libraries\" */\nCMP_INT(vsize)      /* pages VM */                        /* size, vm_size */\nCMP_INT(rss_rlim)\nCMP_SMALL(flags)\nCMP_INT(min_flt)\nCMP_INT(maj_flt)\nCMP_INT(cmin_flt)\nCMP_INT(cmaj_flt)\nCMP_INT(utime)\nCMP_INT(stime)    /* Old: sort by systime. New: show start time. Uh oh. */\nCMP_INT(start_code)\nCMP_INT(end_code)\nCMP_INT(start_stack)\nCMP_INT(kstk_esp)\nCMP_INT(kstk_eip)\nCMP_INT(start_time)\nCMP_INT(wchan)\n\n/* CMP_STR(*environ) */\n/* CMP_STR(*cmdline) */\n\nCMP_STR(ruser)\nCMP_STR(euser)\nCMP_STR(suser)\nCMP_STR(fuser)\nCMP_STR(rgroup)\nCMP_STR(egroup)\nCMP_STR(sgroup)\nCMP_STR(fgroup)\nCMP_STR(cmd)\n/* CMP_STR(ttyc) */    /* FIXME -- use strncmp with 8 max */\n\nCMP_INT(ruid)\nCMP_INT(rgid)\nCMP_INT(euid)\nCMP_INT(egid)\nCMP_INT(suid)\nCMP_INT(sgid)\nCMP_INT(fuid)\nCMP_INT(fgid)\nCMP_SMALL2(procs,tgid)\nCMP_SMALL2(tasks,tid)\nCMP_SMALL(ppid)\nCMP_SMALL(pgrp)\nCMP_SMALL(session)\nCMP_INT(tty)\nCMP_SMALL(tpgid)\n\nCMP_SMALL(pcpu)\n\nCMP_SMALL(state)\n\nCMP_COOKED_TIME(time)\nCMP_COOKED_TIME(etime)\n\nCMP_NS(ipcns, IPCNS);\nCMP_NS(mntns, MNTNS);\nCMP_NS(netns, NETNS);\nCMP_NS(pidns, PIDNS);\nCMP_NS(userns, USERNS);\nCMP_NS(utsns, UTSNS);\n\nCMP_STR(lxcname)\nCMP_STR(cgname)\n\n/* approximation to: kB of address space that could end up in swap */\nstatic int sr_swapable(const proc_t* P, const proc_t* Q) {\n  unsigned long p_swapable = P->vm_data + P->vm_stack;\n  unsigned long q_swapable = Q->vm_data + Q->vm_stack;\n  if (p_swapable < q_swapable) return -1;\n  if (p_swapable > q_swapable) return  1;\n  return 0;\n}\n\n\n/***************************************************************************/\n/************ Lots of format functions, starting with the NOP **************/\n\n// so popular it can't be \"static\"\nint pr_nop(char *restrict const outbuf, const proc_t *restrict const pp){\n  (void)pp;\n  return snprintf(outbuf, COLWID, \"%c\", '-');\n}\n\n\n/********* Unix 98 ************/\n\n/***\n\nOnly comm and args are allowed to contain blank characters; all others are\nnot. Any implementation-dependent variables will be specified in the system\ndocumentation along with the default header and indicating if the field\nmay contain blank characters.\n\nSome headers do not have a standardized specifier!\n\n%CPU\tpcpu\tThe % of cpu time used recently, with unspecified \"recently\".\nADDR\t\tThe address of the process.\nC\t\tProcessor utilisation for scheduling.\nCMD\t\tThe command name, or everything with -f.\nCOMMAND\targs\tCommand + args. May chop as desired. May use either version.\nCOMMAND\tcomm\targv[0]\nELAPSED\tetime\tElapsed time since the process was started. [[dd-]hh:]mm:ss\nF\t\tFlags (octal and additive)\nGROUP\tgroup\tEffective group ID, prefer text over decimal.\nNI\tnice\tDecimal system scheduling priority, see nice(1).\nPGID\tpgid\tThe decimal value of the process group ID.\nPID\tpid\tDecimal PID.\nPPID\tppid\tDecimal PID.\nPRI\t\tPriority. Higher numbers mean lower priority.\nRGROUP\trgroup\tReal group ID, prefer text over decimal.\nRUSER\truser\tReal user ID, prefer text over decimal.\nS\t\tThe state of the process.\nSTIME\t\tStarting time of the process.\nSZ\t\tThe size in blocks of the core image of the process.\nTIME\ttime\tCumulative CPU time. [dd-]hh:mm:ss\nTT\ttty\tName of tty in format used by who(1).\nTTY\t\tThe controlling terminal for the process.\nUID\t\tUID, or name when -f\nUSER\tuser\tEffective user ID, prefer text over decimal.\nVSZ\tvsz\tVirtual memory size in decimal kB.\nWCHAN\t\tWhere waiting/sleeping or blank if running.\n\nThe nice value is used to compute the priority.\n\nFor some undefined ones, Digital does:\n\nF       flag    Process flags -- but in hex!\nPRI     pri     Process priority\nS       state   Symbolic process status\nTTY     tt,tty,tname,longtname  -- all do \"ttyp1\", \"console\", \"??\"\nUID     uid     Process user ID (effective UID)\nWCHAN   wchan   Address of event on which a\n\nFor some undefined ones, Sun does:\n\nADDR\taddr\tmemory address of the process\nC\tc\tProcessor utilization  for  scheduling  (obsolete).\nCMD\nF\tf\nS\ts\tstate: OSRZT\nSTIME\t\tstart time, printed w/o blanks. If 24h old, months & days\nSZ\t\tsize (in pages) of the swappable process's image in main memory\nTTY\nUID\tuid\nWCHAN\twchan\n\nFor some undefined ones, SCO does:\nADDR\taddr\tVirtual address of the process' entry in the process table.\nSZ\t\tswappable size in kB of the virtual data and stack\nSTIME\tstime\thms or md time format\n***/\n\n/* Source & destination are known. Return bytes or screen characters? */\n//\n//       OldLinux   FreeBSD    HPUX\n// ' '    '    '     '  '      '  '\n// 'L'    ' \\_ '     '`-'      '  '\n// '+'    ' \\_ '     '|-'      '  '\n// '|'    ' |  '     '| '      '  '\n//\nstatic int forest_helper(char *restrict const outbuf){\n  char *p = forest_prefix;\n  char *q = outbuf;\n  int rightward = max_rightward < OUTBUF_SIZE ? max_rightward : OUTBUF_SIZE-1;\n  *q = '\\0';\n  if(!*p) return 0;\n  /* Arrrgh! somebody defined unix as 1 */\n  if(forest_type == 'u') goto unixy;\n  while(*p){\n    if (rightward < 4) break;\n    switch(*p){\n    case ' ': strcpy(q, \"    \");  break;\n    case 'L': strcpy(q, \" \\\\_ \"); break;\n    case '+': strcpy(q, \" \\\\_ \"); break;\n    case '|': strcpy(q, \" |  \");  break;\n    case '\\0': return q-outbuf;    /* redundant & not used */\n    }\n    q += 4;\n    rightward -= 4;\n    p++;\n  }\n  return q-outbuf;   /* gcc likes this here */\nunixy:\n  while(*p){\n    if (rightward < 2) break;\n    switch(*p){\n    case ' ': strcpy(q, \"  \"); break;\n    case 'L': strcpy(q, \"  \"); break;\n    case '+': strcpy(q, \"  \"); break;\n    case '|': strcpy(q, \"  \"); break;\n    case '\\0': return q-outbuf;    /* redundant & not used */\n    }\n    q += 2;\n    rightward -= 2;\n    p++;\n  }\n  return q-outbuf;   /* gcc likes this here */\n}\n\n\n/* XPG4-UNIX, according to Digital:\nThe \"args\" and \"command\" specifiers show what was passed to the command.\nModifications to the arguments are not shown.\n*/\n\n/*\n * pp->cmd       short accounting name (comm & ucomm)\n * pp->cmdline   long name with args (args & command)\n * pp->environ   environment\n */\n\n// FIXME: some of these may hit the guard page in forest mode\n\n#define OUTBUF_SIZE_AT(endp) \\\n  (((endp) >= outbuf && (endp) < outbuf + OUTBUF_SIZE) ? (outbuf + OUTBUF_SIZE) - (endp) : 0)\n\n/*\n * \"args\", \"cmd\", \"command\" are all the same:  long  unless  c\n * \"comm\", \"ucmd\", \"ucomm\"  are all the same:  short unless -f\n * ( determinations are made in display.c, we mostly deal with results ) */\nstatic int pr_args(char *restrict const outbuf, const proc_t *restrict const pp){\n  char *endp = outbuf;\n  int rightward = max_rightward;\n  int fh = forest_helper(outbuf);\n\n  endp += fh;\n  rightward -= fh;\n\n  if(pp->cmdline && !bsd_c_option)\n    endp += escaped_copy(endp, *pp->cmdline, OUTBUF_SIZE_AT(endp), &rightward);\n  else\n    endp += escape_command(endp, pp, OUTBUF_SIZE_AT(endp), &rightward, ESC_DEFUNCT);\n\n  if(bsd_e_option && rightward>1 && OUTBUF_SIZE_AT(endp)>1) {\n    if(pp->environ && *pp->environ) {\n      *endp++ = ' ';\n      rightward--;\n      endp += escape_strlist(endp, pp->environ, OUTBUF_SIZE_AT(endp), &rightward);\n    }\n  }\n  return max_rightward-rightward;\n}\n\n/*\n * \"args\", \"cmd\", \"command\" are all the same:  long  unless  c\n * \"comm\", \"ucmd\", \"ucomm\"  are all the same:  short unless -f\n * ( determinations are made in display.c, we mostly deal with results ) */\nstatic int pr_comm(char *restrict const outbuf, const proc_t *restrict const pp){\n  char *endp = outbuf;\n  int rightward = max_rightward;\n  int fh = forest_helper(outbuf);\n\n  endp += fh;\n  rightward -= fh;\n\n  if(pp->cmdline && unix_f_option)\n    endp += escaped_copy(endp, *pp->cmdline, OUTBUF_SIZE_AT(endp), &rightward);\n  else\n    endp += escape_command(endp, pp, OUTBUF_SIZE_AT(endp), &rightward, ESC_DEFUNCT);\n\n  if(bsd_e_option && rightward>1 && OUTBUF_SIZE_AT(endp)>1) {\n    if(pp->environ && *pp->environ) {\n      *endp++ = ' ';\n      rightward--;\n      endp += escape_strlist(endp, pp->environ, OUTBUF_SIZE_AT(endp), &rightward);\n    }\n  }\n  return max_rightward-rightward;\n}\n\nstatic int pr_cgname(char *restrict const outbuf, const proc_t *restrict const pp){\n  int rightward = max_rightward;\n\n  escaped_copy(outbuf, pp->cgname, OUTBUF_SIZE, &rightward);\n  return max_rightward-rightward;\n}\n\nstatic int pr_cgroup(char *restrict const outbuf,const proc_t *restrict const pp) {\n  int rightward = max_rightward;\n\n  escaped_copy(outbuf, *pp->cgroup, OUTBUF_SIZE, &rightward);\n  return max_rightward-rightward;\n}\n\n/* Non-standard, from SunOS 5 */\nstatic int pr_fname(char *restrict const outbuf, const proc_t *restrict const pp){\n  char *endp = outbuf;\n  int rightward = max_rightward;\n  int fh = forest_helper(outbuf);\n\n  endp += fh;\n  rightward -= fh;\n\n  if (rightward>8)  /* 8=default, but forest maybe feeds more */\n    rightward = 8;\n\n  endp += escape_str(endp, pp->cmd, OUTBUF_SIZE_AT(endp), &rightward);\n  //return endp - outbuf;\n  return max_rightward-rightward;\n}\n\n#undef OUTBUF_SIZE_AT\n\n/* elapsed wall clock time, [[dd-]hh:]mm:ss format (not same as \"time\") */\nstatic int pr_etime(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned long t;\n  unsigned dd,hh,mm,ss;\n  char *cp = outbuf;\n  t = cook_etime(pp);\n  ss = t%60;\n  t /= 60;\n  mm = t%60;\n  t /= 60;\n  hh = t%24;\n  t /= 24;\n  dd = t;\n  cp +=(     dd      ?  snprintf(cp, COLWID, \"%u-\", dd)           :  0 );\n  cp +=( (dd || hh)  ?  snprintf(cp, COLWID, \"%02u:\", hh)         :  0 );\n  cp +=                 snprintf(cp, COLWID, \"%02u:%02u\", mm, ss)       ;\n  return (int)(cp-outbuf);\n}\n\n/* elapsed wall clock time in seconds */\nstatic int pr_etimes(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned t = cook_etime(pp);\n  return snprintf(outbuf, COLWID, \"%u\", t);\n}\n\n/* \"Processor utilisation for scheduling.\"  --- we use %cpu w/o fraction */\nstatic int pr_c(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned long long total_time;   /* jiffies used by this process */\n  unsigned pcpu = 0;               /* scaled %cpu, 99 means 99% */\n  unsigned long long seconds;      /* seconds of process life */\n  total_time = pp->utime + pp->stime;\n  if(include_dead_children) total_time += (pp->cutime + pp->cstime);\n  seconds = cook_etime(pp);\n  if(seconds) pcpu = (total_time * 100ULL / Hertz) / seconds;\n  if (pcpu > 99U) pcpu = 99U;\n  return snprintf(outbuf, COLWID, \"%2u\", pcpu);\n}\n/* normal %CPU in ##.# format. */\nstatic int pr_pcpu(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned long long total_time;   /* jiffies used by this process */\n  unsigned pcpu = 0;               /* scaled %cpu, 999 means 99.9% */\n  unsigned long long seconds;      /* seconds of process life */\n  total_time = pp->utime + pp->stime;\n  if(include_dead_children) total_time += (pp->cutime + pp->cstime);\n  seconds = cook_etime(pp);\n  if(seconds) pcpu = (total_time * 1000ULL / Hertz) / seconds;\n  if (pcpu > 999U)\n    return snprintf(outbuf, COLWID, \"%u\", pcpu/10U);\n  return snprintf(outbuf, COLWID, \"%u.%u\", pcpu/10U, pcpu%10U);\n}\n/* this is a \"per-mill\" format, like %cpu with no decimal point */\nstatic int pr_cp(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned long long total_time;   /* jiffies used by this process */\n  unsigned pcpu = 0;               /* scaled %cpu, 999 means 99.9% */\n  unsigned long long seconds;      /* seconds of process life */\n  total_time = pp->utime + pp->stime;\n  if(include_dead_children) total_time += (pp->cutime + pp->cstime);\n  seconds = cook_etime(pp);\n  if(seconds) pcpu = (total_time * 1000ULL / Hertz) / seconds;\n  if (pcpu > 999U) pcpu = 999U;\n  return snprintf(outbuf, COLWID, \"%3u\", pcpu);\n}\n\nstatic int pr_pgid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%u\", pp->pgrp);\n}\nstatic int pr_ppid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%u\", pp->ppid);\n}\n\n\n/* cumulative CPU time, [dd-]hh:mm:ss format (not same as \"etime\") */\nstatic int pr_time(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned long t;\n  unsigned dd,hh,mm,ss;\n  int c;\n  t = cook_time(pp);\n  ss = t%60;\n  t /= 60;\n  mm = t%60;\n  t /= 60;\n  hh = t%24;\n  t /= 24;\n  dd = t;\n  c  =( dd ? snprintf(outbuf, COLWID, \"%u-\", dd) : 0              );\n  c +=( snprintf(outbuf+c, COLWID, \"%02u:%02u:%02u\", hh, mm, ss)    );\n  return c;\n}\n\n/* cumulative CPU time in seconds (not same as \"etimes\") */\nstatic int pr_times(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned t = cook_time(pp);\n  return snprintf(outbuf, COLWID, \"%u\", t);\n}\n\n/* HP-UX puts this (I forget, vsz or vsize?) in kB and uses \"sz\" for pages.\n * Unix98 requires \"vsz\" to be kB.\n * Tru64 does both vsize and vsz like \"1.23M\"\n *\n * Our pp->vm_size is kB and our pp->vsize is pages.\n *\n * TODO: add flag for \"1.23M\" behavior, on this and other columns.\n */\nstatic int pr_vsz(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%lu\", pp->vm_size);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n// \"PRI\" is created by \"opri\", or by \"pri\" when -c is used.\n//\n// Unix98 only specifies that a high \"PRI\" is low priority.\n// Sun and SCO add the -c behavior. Sun defines \"pri\" and \"opri\".\n// Linux may use \"priority\" for historical purposes.\n//\n// According to the kernel's fs/proc/array.c and kernel/sched.c source,\n// the kernel reports it in /proc via this:\n//        p->prio - MAX_RT_PRIO\n// such that \"RT tasks are offset by -200. Normal tasks are centered\n// around 0, value goes from -16 to +15\" but who knows if that is\n// before or after the conversion...\n//\n// <linux/sched.h> says:\n// MAX_RT_PRIO is currently 100.       (so we see 0 in /proc)\n// RT tasks have a p->prio of 0 to 99. (so we see -100 to -1)\n// non-RT tasks are from 100 to 139.   (so we see 0 to 39)\n// Lower values have higher priority, as in the UNIX standard.\n//\n// In any case, pp->priority+100 should get us back to what the kernel\n// has for p->prio.\n//\n// Test results with the \"yes\" program on a 2.6.x kernel:\n//\n// # ps -C19,_20 -o pri,opri,intpri,priority,ni,pcpu,pid,comm\n// PRI PRI PRI PRI  NI %CPU  PID COMMAND\n//   0  99  99  39  19 10.6 8686 19\n//  34  65  65   5 -20 94.7 8687 _20\n//\n// Grrr. So the UNIX standard \"PRI\" must NOT be from \"pri\".\n// Either of the others will do. We use \"opri\" for this.\n// (and use \"pri\" when the \"-c\" option is used)\n// Probably we should have Linux-specific \"pri_for_l\" and \"pri_for_lc\"\n//\n// sched_get_priority_min.2 says the Linux static priority is\n// 1..99 for RT and 0 for other... maybe 100 is kernel-only?\n//\n// A nice range would be -99..0 for RT and 1..40 for normal,\n// which is pp->priority+1. (3-digit max, positive is normal,\n// negative or 0 is RT, and meets the standard for PRI)\n//\n\n// legal as UNIX \"PRI\"\n// \"priority\"         (was -20..20, now -100..39)\nstatic int pr_priority(char *restrict const outbuf, const proc_t *restrict const pp){    /* -20..20 */\n    return snprintf(outbuf, COLWID, \"%ld\", pp->priority);\n}\n\n// legal as UNIX \"PRI\"\n// \"intpri\" and \"opri\" (was 39..79, now  -40..99)\nstatic int pr_opri(char *restrict const outbuf, const proc_t *restrict const pp){        /* 39..79 */\n    return snprintf(outbuf, COLWID, \"%ld\", 60 + pp->priority);\n}\n\n// legal as UNIX \"PRI\"\n// \"pri_foo\"   --  match up w/ nice values of sleeping processes (-120..19)\nstatic int pr_pri_foo(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%ld\", pp->priority - 20);\n}\n\n// legal as UNIX \"PRI\"\n// \"pri_bar\"   --  makes RT pri show as negative       (-99..40)\nstatic int pr_pri_bar(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%ld\", pp->priority + 1);\n}\n\n// legal as UNIX \"PRI\"\n// \"pri_baz\"   --  the kernel's ->prio value, as of Linux 2.6.8     (1..140)\nstatic int pr_pri_baz(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%ld\", pp->priority + 100);\n}\n\n\n// not legal as UNIX \"PRI\"\n// \"pri\"               (was 20..60, now    0..139)\nstatic int pr_pri(char *restrict const outbuf, const proc_t *restrict const pp){         /* 20..60 */\n    return snprintf(outbuf, COLWID, \"%ld\", 39 - pp->priority);\n}\n\n// not legal as UNIX \"PRI\"\n// \"pri_api\"   --  match up w/ RT API    (-40..99)\nstatic int pr_pri_api(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%ld\", -1 - pp->priority);\n}\n\n// Linux applies nice value in the scheduling policies (classes)\n// SCHED_OTHER(0) and SCHED_BATCH(3).  Ref: sched_setscheduler(2).\n// Also print nice value for old kernels which didn't use scheduling\n// policies (-1).\nstatic int pr_nice(char *restrict const outbuf, const proc_t *restrict const pp){\n  if(pp->sched!=0 && pp->sched!=3 && pp->sched!=-1) return snprintf(outbuf, COLWID, \"-\");\n  return snprintf(outbuf, COLWID, \"%ld\", pp->nice);\n}\n\n// HP-UX   \"cls\": RT RR RR2 ???? HPUX FIFO KERN\n// Solaris \"class\": SYS TS FX IA RT FSS (FIFO is RR w/ Inf quant)\n//                  FIFO+RR share RT; FIFO has Inf quant\n//                  IA=interactive; FX=fixed; TS=timeshare; SYS=system\n//                  FSS=fairshare; INTS=interrupts\n// Tru64   \"policy\": FF RR TS\n// IRIX    \"class\": RT TS B BC WL GN\n//                  RT=real-time; TS=time-share; B=batch; BC=batch-critical\n//                  WL=weightless; GN=gang-scheduled\n//                  see miser(1) for this; PRI has some letter codes too\nstatic int pr_class(char *restrict const outbuf, const proc_t *restrict const pp){\n  switch(pp->sched){\n  case -1: return snprintf(outbuf, COLWID, \"-\");   // not reported\n  case  0: return snprintf(outbuf, COLWID, \"TS\");  // SCHED_OTHER SCHED_NORMAL\n  case  1: return snprintf(outbuf, COLWID, \"FF\");  // SCHED_FIFO\n  case  2: return snprintf(outbuf, COLWID, \"RR\");  // SCHED_RR\n  case  3: return snprintf(outbuf, COLWID, \"B\");   // SCHED_BATCH\n  case  4: return snprintf(outbuf, COLWID, \"ISO\"); // reserved for SCHED_ISO (Con Kolivas)\n  case  5: return snprintf(outbuf, COLWID, \"IDL\"); // SCHED_IDLE\n  case  6: return snprintf(outbuf, COLWID, \"DLN\"); // SCHED_DEADLINE\n  case  7: return snprintf(outbuf, COLWID, \"#7\");  //\n  case  8: return snprintf(outbuf, COLWID, \"#8\");  //\n  case  9: return snprintf(outbuf, COLWID, \"#9\");  //\n  default: return snprintf(outbuf, COLWID, \"?\");   // unknown value\n  }\n}\n// Based on \"type\", FreeBSD would do:\n//    REALTIME  \"real:%u\", prio\n//    NORMAL    \"normal\"\n//    IDLE      \"idle:%u\", prio\n//    default   \"%u:%u\", type, prio\n// We just print the priority, and have other keywords for type.\nstatic int pr_rtprio(char *restrict const outbuf, const proc_t *restrict const pp){\n  if(pp->sched==0 || pp->sched==(unsigned long)-1) return snprintf(outbuf, COLWID, \"-\");\n  return snprintf(outbuf, COLWID, \"%ld\", pp->rtprio);\n}\nstatic int pr_sched(char *restrict const outbuf, const proc_t *restrict const pp){\n  if(pp->sched==(unsigned long)-1) return snprintf(outbuf, COLWID, \"-\");\n  return snprintf(outbuf, COLWID, \"%ld\", pp->sched);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstatic int pr_wchan(char *restrict const outbuf, const proc_t *restrict const pp){\n/*\n * Unix98 says \"blank if running\" and also \"no blanks\"! :-(\n * Unix98 also says to use '-' if something is meaningless.\n * Digital uses both '*' and '-', with undocumented differences.\n * (the '*' for -1 (rare) and the '-' for 0)\n * Sun claims to use a blank AND use '-', in the same man page.\n * Perhaps \"blank\" should mean '-'.\n *\n * AIX uses '-' for running processes, the location when there is\n * only one thread waiting in the kernel, and '*' when there is\n * more than one thread waiting in the kernel.\n *\n * The output should be truncated to maximal columns width -- overflow\n * is not supported for the \"wchan\".\n */\n  const char *w;\n  size_t len;\n  if(!(pp->wchan & 0xffffff)) return memcpy(outbuf,\"-\",2),1;\n  if(wchan_is_number) return snprintf(outbuf, COLWID, \"%x\", (unsigned)(pp->wchan) & 0xffffffu);\n  w = lookup_wchan(pp->XXXID);\n  len = strlen(w);\n  if(len>max_rightward) len=max_rightward;\n  memcpy(outbuf, w, len);\n  outbuf[len] = '\\0';\n  return len;\n}\n\nstatic int pr_wname(char *restrict const outbuf, const proc_t *restrict const pp){\n/* SGI's IRIX always uses a number for \"wchan\", so \"wname\" is provided too.\n *\n * We use '-' for running processes, the location when there is\n * only one thread waiting in the kernel, and '*' when there is\n * more than one thread waiting in the kernel.\n *\n * The output should be truncated to maximal columns width -- overflow\n * is not supported for the \"wchan\".\n */\n  const char *w;\n  size_t len;\n  if(!(pp->wchan & 0xffffff)) return memcpy(outbuf,\"-\",2),1;\n  w = lookup_wchan(pp->XXXID);\n  len = strlen(w);\n  if(len>max_rightward) len=max_rightward;\n  memcpy(outbuf, w, len);\n  outbuf[len] = '\\0';\n  return len;\n}\n\nstatic int pr_nwchan(char *restrict const outbuf, const proc_t *restrict const pp){\n  if(!(pp->wchan & 0xffffff)) return memcpy(outbuf,\"-\",2),1;\n  return snprintf(outbuf, COLWID, \"%x\", (unsigned)(pp->wchan) & 0xffffffu);\n}\n\n/* Terrible trunctuation, like BSD crap uses: I999 J999 K999 */\n/* FIXME: disambiguate /dev/tty69 and /dev/pts/69. */\nstatic int pr_tty4(char *restrict const outbuf, const proc_t *restrict const pp){\n/* snprintf(outbuf, COLWID, \"%02x:%02x\", pp->tty>>8, pp->tty&0xff); */\n  return dev_to_tty(outbuf, 4, pp->tty, pp->XXXID, ABBREV_DEV|ABBREV_TTY|ABBREV_PTS);\n}\n\n/* Unix98: format is unspecified, but must match that used by who(1). */\nstatic int pr_tty8(char *restrict const outbuf, const proc_t *restrict const pp){\n/* snprintf(outbuf, COLWID, \"%02x:%02x\", pp->tty>>8, pp->tty&0xff); */\n  return dev_to_tty(outbuf, COLWID, pp->tty, pp->XXXID, ABBREV_DEV);\n}\n\n#if 0\n/* This BSD state display may contain spaces, which is illegal. */\nstatic int pr_oldstate(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%s\", status(pp));\n}\n#endif\n\n// This state display is Unix98 compliant and has lots of info like BSD.\nstatic int pr_stat(char *restrict const outbuf, const proc_t *restrict const pp){\n    int end = 0;\n    outbuf[end++] = pp->state;\n//  if(pp->rss==0 && pp->state!='Z')  outbuf[end++] = 'W'; // useless \"swapped out\"\n    if(pp->nice < 0)                  outbuf[end++] = '<';\n    if(pp->nice > 0)                  outbuf[end++] = 'N';\n// In this order, NetBSD would add:\n//     traced   'X'\n//     systrace 'x'\n//     exiting  'E' (not printed for zombies)\n//     vforked  'V'\n//     system   'K' (and do not print 'L' too)\n    if(pp->vm_lock)                   outbuf[end++] = 'L';\n    if(pp->session == pp->tgid)       outbuf[end++] = 's'; // session leader\n    if(pp->nlwp > 1)                  outbuf[end++] = 'l'; // multi-threaded\n    if(pp->pgrp == pp->tpgid)         outbuf[end++] = '+'; // in foreground process group\n    outbuf[end] = '\\0';\n    return end;\n}\n\n/* This minimal state display is Unix98 compliant, like SCO and SunOS 5 */\nstatic int pr_s(char *restrict const outbuf, const proc_t *restrict const pp){\n    outbuf[0] = pp->state;\n    outbuf[1] = '\\0';\n    return 1;\n}\n\nstatic int pr_flag(char *restrict const outbuf, const proc_t *restrict const pp){\n    /* Unix98 requires octal flags */\n    /* this user-hostile and volatile junk gets 1 character */\n    return snprintf(outbuf, COLWID, \"%o\", (unsigned)(pp->flags>>6U)&0x7U);\n}\n\n// plus these: euid,ruid,egroup,rgroup (elsewhere in this file)\n\n/*********** non-standard ***********/\n\n/*** BSD\nsess\tsession pointer\n(SCO has:Process session leader ID as a decimal value. (SESSION))\njobc\tjob control count\ncpu\tshort-term cpu usage factor (for scheduling)\nsl\tsleep time (in seconds; 127 = infinity)\nre\tcore residency time (in seconds; 127 = infinity)\npagein\tpageins (same as majflt)\nlim\tsoft memory limit\ntsiz\ttext size (in Kbytes)\n***/\n\nstatic int pr_stackp(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%0*lx\", (int)(2*sizeof(long)), pp->start_stack);\n}\n\nstatic int pr_esp(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%0*lx\", (int)(2*sizeof(long)), pp->kstk_esp);\n}\n\nstatic int pr_eip(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%0*lx\", (int)(2*sizeof(long)), pp->kstk_eip);\n}\n\n/* This function helps print old-style time formats */\nstatic int old_time_helper(char *dst, unsigned long long t, unsigned long long rel) {\n  if(!t)            return snprintf(dst, COLWID, \"    -\");\n  if(t == ~0ULL)    return snprintf(dst, COLWID, \"   xx\");\n  if((long long)(t-=rel) < 0)  t=0ULL;\n  if(t>9999ULL)     return snprintf(dst, COLWID, \"%5llu\", t/100ULL);\n  else              return snprintf(dst, COLWID, \"%2u.%02u\", (unsigned)t/100U, (unsigned)t%100U);\n}\n\nstatic int pr_bsdtime(char *restrict const outbuf, const proc_t *restrict const pp){\n    unsigned long long t;\n    unsigned u;\n    t = pp->utime + pp->stime;\n    if(include_dead_children) t += (pp->cutime + pp->cstime);\n    u = t / Hertz;\n    return snprintf(outbuf, COLWID, \"%3u:%02u\", u/60U, u%60U);\n}\n\nstatic int pr_bsdstart(char *restrict const outbuf, const proc_t *restrict const pp){\n  time_t start;\n  time_t seconds_ago;\n  start = getbtime() + pp->start_time / Hertz;\n  seconds_ago = seconds_since_1970 - start;\n  if(seconds_ago < 0) seconds_ago=0;\n  if(seconds_ago > 3600*24)  snprintf(outbuf, COLWID, \"%s\", ctime(&start)+4);\n  else                       snprintf(outbuf, COLWID, \"%s\", ctime(&start)+10);\n  outbuf[6] = '\\0';\n  return 6;\n}\n\nstatic int pr_alarm(char *restrict const outbuf, const proc_t *restrict const pp){\n    return old_time_helper(outbuf, pp->alarm, 0ULL);\n}\n\n/* HP-UX puts this in pages and uses \"vsz\" for kB */\nstatic int pr_sz(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%lu\", (pp->vm_size)/(page_size/1024));\n}\n\n\n/*\n * FIXME: trs,drs,tsiz,dsiz,m_trs,m_drs,vm_exe,vm_data,trss\n * I suspect some/all of those are broken. They seem to have been\n * inherited by Linux and AIX from early BSD systems. FreeBSD only\n * retains tsiz. The prefixed versions come from Debian.\n * Sun and Digital have none of this crap. The code here comes\n * from an old Linux ps, and might not be correct for ELF executables.\n *\n * AIX            TRS    size of resident-set (real memory) of text\n * AIX            TSIZ   size of text (shared-program) image\n * FreeBSD        tsiz   text size (in Kbytes)\n * 4.3BSD NET/2   trss   text resident set size (in Kbytes)\n * 4.3BSD NET/2   tsiz   text size (in Kbytes)\n */\n\n/* kB data size. See drs, tsiz & trs. */\nstatic int pr_dsiz(char *restrict const outbuf, const proc_t *restrict const pp){\n    long dsiz = 0;\n    if(pp->vsize) dsiz += (pp->vsize - pp->end_code + pp->start_code) >> 10;\n    return snprintf(outbuf, COLWID, \"%ld\", dsiz);\n}\n\n/* kB text (code) size. See trs, dsiz & drs. */\nstatic int pr_tsiz(char *restrict const outbuf, const proc_t *restrict const pp){\n    long tsiz = 0;\n    if(pp->vsize) tsiz += (pp->end_code - pp->start_code) >> 10;\n    return snprintf(outbuf, COLWID, \"%ld\", tsiz);\n}\n\n/* kB _resident_ data size. See dsiz, tsiz & trs. */\nstatic int pr_drs(char *restrict const outbuf, const proc_t *restrict const pp){\n    long drs = 0;\n    if(pp->vsize) drs += (pp->vsize - pp->end_code + pp->start_code) >> 10;\n    return snprintf(outbuf, COLWID, \"%ld\", drs);\n}\n\n/* kB text _resident_ (code) size. See tsiz, dsiz & drs. */\nstatic int pr_trs(char *restrict const outbuf, const proc_t *restrict const pp){\n    long trs = 0;\n    if(pp->vsize) trs += (pp->end_code - pp->start_code) >> 10;\n    return snprintf(outbuf, COLWID, \"%ld\", trs);\n}\n\n/* approximation to: kB of address space that could end up in swap */\nstatic int pr_swapable(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%ld\", pp->vm_data + pp->vm_stack);\n}\n\n/* nasty old Debian thing */\nstatic int pr_size(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%ld\", pp->size);\n}\n\n\nstatic int pr_minflt(char *restrict const outbuf, const proc_t *restrict const pp){\n    long flt = pp->min_flt;\n    if(include_dead_children) flt += pp->cmin_flt;\n    return snprintf(outbuf, COLWID, \"%ld\", flt);\n}\n\nstatic int pr_majflt(char *restrict const outbuf, const proc_t *restrict const pp){\n    long flt = pp->maj_flt;\n    if(include_dead_children) flt += pp->cmaj_flt;\n    return snprintf(outbuf, COLWID, \"%ld\", flt);\n}\n\nstatic int pr_lim(char *restrict const outbuf, const proc_t *restrict const pp){\n    if(pp->rss_rlim == RLIM_INFINITY){\n      outbuf[0] = 'x';\n      outbuf[1] = 'x';\n      outbuf[2] = '\\0';\n      return 2;\n    }\n    return snprintf(outbuf, COLWID, \"%5ld\", pp->rss_rlim >> 10);\n}\n\n/* should print leading tilde ('~') if process is bound to the CPU */\nstatic int pr_psr(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->processor);\n}\n\nstatic int pr_numa(char *restrict const outbuf, const proc_t *restrict const pp){\n  static int first = 1;\n  if (first) { numa_init(); first = 0; }   // we'll keep this dependency local\n  return snprintf(outbuf, COLWID, \"%d\", numa_node_of_cpu(pp->processor));\n}\n\nstatic int pr_rss(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%lu\", pp->vm_rss);\n}\n\n/* pp->vm_rss * 1000 would overflow on 32-bit systems with 64 GB memory */\nstatic int pr_pmem(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned long pmem = 0;\n  pmem = pp->vm_rss * 1000ULL / kb_main_total;\n  if (pmem > 999) pmem = 999;\n  return snprintf(outbuf, COLWID, \"%2u.%u\", (unsigned)(pmem/10), (unsigned)(pmem%10));\n}\n\nstatic int pr_lstart(char *restrict const outbuf, const proc_t *restrict const pp){\n  time_t t;\n  t = getbtime() + pp->start_time / Hertz;\n  return snprintf(outbuf, COLWID, \"%24.24s\", ctime(&t));\n}\n\n/* Unix98 specifies a STIME header for a column that shows the start\n * time of the process, but does not specify a format or format specifier.\n * From the general Unix98 rules, we know there must not be any spaces.\n * Most systems violate that rule, though the Solaris documentation\n * claims to print the column without spaces. (NOT!)\n *\n * So this isn't broken, but could be renamed to u98_std_stime,\n * as long as it still shows as STIME when using the -f option.\n */\nstatic int pr_stime(char *restrict const outbuf, const proc_t *restrict const pp){\n  struct tm *proc_time;\n  struct tm *our_time;\n  time_t t;\n  const char *fmt;\n  int tm_year;\n  int tm_yday;\n  size_t len;\n  our_time = localtime(&seconds_since_1970);   /* not reentrant */\n  tm_year = our_time->tm_year;\n  tm_yday = our_time->tm_yday;\n  t = getbtime() + pp->start_time / Hertz;\n  proc_time = localtime(&t); /* not reentrant, this corrupts our_time */\n  fmt = \"%H:%M\";                                   /* 03:02 23:59 */\n  if(tm_yday != proc_time->tm_yday) fmt = \"%b%d\";  /* Jun06 Aug27 */\n  if(tm_year != proc_time->tm_year) fmt = \"%Y\";    /* 1991 2001 */\n  len = strftime(outbuf, COLWID, fmt, proc_time);\n  if(len <= 0 || len >= COLWID) outbuf[len = 0] = '\\0';\n  return len;\n}\n\nstatic int pr_start(char *restrict const outbuf, const proc_t *restrict const pp){\n  time_t t;\n  char *str;\n  t = getbtime() + pp->start_time / Hertz;\n  str = ctime(&t);\n  if(str[8]==' ')  str[8]='0';\n  if(str[11]==' ') str[11]='0';\n  if((unsigned long)t+60*60*24 > (unsigned long)seconds_since_1970)\n    return snprintf(outbuf, COLWID, \"%8.8s\", str+11);\n  return snprintf(outbuf, COLWID, \"  %6.6s\", str+4);\n}\n\n\n#ifdef SIGNAL_STRING\nstatic int help_pr_sig(char *restrict const outbuf, const char *restrict const sig){\n  const size_t len = strlen(sig);\n  if(wide_signals){\n    if(len>8) return snprintf(outbuf, COLWID, \"%s\", sig);\n    return snprintf(outbuf, COLWID, \"00000000%s\", sig);\n  }\n  if(len-strspn(sig,\"0\") > 8)\n    return snprintf(outbuf, COLWID, \"<%s\", sig+len-8);\n  if(len < 8)\n    return snprintf(outbuf, COLWID, \"%s%s\", \"00000000\"+len, sig);\n  return snprintf(outbuf, COLWID,  \"%s\", sig+len-8);\n}\n#else\nstatic int help_pr_sig(unsigned long long sig){\n  if(wide_signals) return snprintf(outbuf, COLWID, \"%016Lx\", sig);\n  if(sig>>32)      return snprintf(outbuf, COLWID, \"<%08Lx\", sig&0xffffffffLL);\n  return                  snprintf(outbuf, COLWID,  \"%08Lx\", sig&0xffffffffLL);\n}\n#endif\n\n// This one is always thread-specific pending. (from Dragonfly BSD)\nstatic int pr_tsig(char *restrict const outbuf, const proc_t *restrict const pp){\n  return help_pr_sig(outbuf, pp->_sigpnd);\n}\n// This one is (wrongly?) thread-specific when printing thread lines,\n// but process-pending otherwise.\nstatic int pr_sig(char *restrict const outbuf, const proc_t *restrict const pp){\n  return help_pr_sig(outbuf, pp->signal);\n}\nstatic int pr_sigmask(char *restrict const outbuf, const proc_t *restrict const pp){\n  return help_pr_sig(outbuf, pp->blocked);\n}\nstatic int pr_sigignore(char *restrict const outbuf, const proc_t *restrict const pp){\n  return help_pr_sig(outbuf, pp->sigignore);\n}\nstatic int pr_sigcatch(char *restrict const outbuf, const proc_t *restrict const pp){\n  return help_pr_sig(outbuf, pp->sigcatch);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n/*\n * internal terms:  ruid  euid  suid  fuid\n * kernel vars:      uid  euid  suid fsuid\n * command args:    ruid   uid svuid   n/a\n */\n\nstatic int pr_egid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->egid);\n}\nstatic int pr_rgid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->rgid);\n}\nstatic int pr_sgid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->sgid);\n}\nstatic int pr_fgid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->fgid);\n}\n\nstatic int pr_euid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->euid);\n}\nstatic int pr_ruid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->ruid);\n}\nstatic int pr_suid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->suid);\n}\nstatic int pr_fuid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->fuid);\n}\n\n// The Open Group Base Specifications Issue 6 (IEEE Std 1003.1, 2004 Edition)\n// requires that user and group names print as decimal numbers if there is\n// not enough room in the column.  However, we will now truncate such names\n// and provide a visual hint of such truncation.  Hopefully, this will reduce\n// the volume of bug reports regarding that former 'feature'.\n//\n// The UNIX and POSIX way to change column width is to rename it:\n//      ps -o pid,user=CumbersomeUserNames -o comm\n// The easy way is to directly specify the desired width:\n//      ps -o pid,user:19,comm\n//\nstatic int do_pr_name(char *restrict const outbuf, const char *restrict const name, unsigned u){\n  if(!user_is_number){\n    int rightward = OUTBUF_SIZE;\t/* max cells */\n    int len;\t\t\t\t/* real cells */\n\n    escape_str(outbuf, name, OUTBUF_SIZE, &rightward);\n    len = OUTBUF_SIZE-rightward;\n\n    if(len <= (int)max_rightward)\n      return len;  /* returns number of cells */\n\n    // only use '+' when not on a multi-byte char, else show uid\n    if (max_rightward >= 1 && (unsigned)outbuf[max_rightward-1] < 127) {\n      len = max_rightward-1;\n      outbuf[len++] = '+';\n      outbuf[len] = 0;\n      return len;\n    }\n  }\n  return snprintf(outbuf, COLWID, \"%u\", u);\n}\n\nstatic int pr_ruser(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->ruser, pp->ruid);\n}\nstatic int pr_euser(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->euser, pp->euid);\n}\nstatic int pr_fuser(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->fuser, pp->fuid);\n}\nstatic int pr_suser(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->suser, pp->suid);\n}\nstatic int pr_egroup(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->egroup, pp->egid);\n}\nstatic int pr_rgroup(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->rgroup, pp->rgid);\n}\nstatic int pr_fgroup(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->fgroup, pp->fgid);\n}\nstatic int pr_sgroup(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->sgroup, pp->sgid);\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\n// PID pid, TGID tgid\nstatic int pr_procs(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%u\", pp->tgid);\n}\n// LWP lwp, SPID spid, TID tid\nstatic int pr_tasks(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%u\", pp->tid);\n}\n// thcount THCNT\nstatic int pr_nlwp(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%d\", pp->nlwp);\n}\n\nstatic int pr_sess(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%u\", pp->session);\n}\n\nstatic int pr_supgid(char *restrict const outbuf, const proc_t *restrict const pp){\n  int rightward = max_rightward;\n  escaped_copy(outbuf, pp->supgid, OUTBUF_SIZE, &rightward);\n  return max_rightward-rightward;\n}\n\nstatic int pr_supgrp(char *restrict const outbuf, const proc_t *restrict const pp){\n  int rightward = max_rightward;\n  escaped_copy(outbuf, pp->supgrp, OUTBUF_SIZE, &rightward);\n  return max_rightward-rightward;\n}\n\nstatic int pr_tpgid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->tpgid);\n}\n\n/* SGI uses \"cpu\" to print the processor ID with header \"P\" */\nstatic int pr_sgi_p(char *restrict const outbuf, const proc_t *restrict const pp){          /* FIXME */\n  if(pp->state == 'R') return snprintf(outbuf, COLWID, \"%d\", pp->processor);\n  return snprintf(outbuf, COLWID, \"*\");\n}\n\n/* LoginID implementation */\nstatic int pr_luid(char *restrict const outbuf, const proc_t *restrict const pp){\n    char filename[48];\n    ssize_t num_read;\n    int fd;\n    u_int32_t luid;\n\n    snprintf(filename, sizeof filename, \"/proc/%d/loginuid\", pp->tgid);\n\n    if ((fd = open(filename, O_RDONLY, 0)) != -1) {\n        num_read = read(fd, outbuf, OUTBUF_SIZE - 1);\n        close(fd);\n        if (num_read > 0) {\n            outbuf[num_read] = '\\0';\n\n            // processes born before audit have no LoginID set\n            luid = (u_int32_t) atoi(outbuf);\n            if (luid != -1)\n                return num_read;\n        }\n    }\n    outbuf[0] = '-';\n    outbuf[1] = '\\0';\n    num_read = 1;\n    return num_read;\n}\n\n\n/************************* Systemd stuff ********************************/\nstatic int pr_sd_unit(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->sd_unit);\n}\n\nstatic int pr_sd_session(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->sd_sess);\n}\n\nstatic int pr_sd_ouid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->sd_ouid);\n}\n\nstatic int pr_sd_machine(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->sd_mach);\n}\n\nstatic int pr_sd_uunit(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->sd_uunit);\n}\n\nstatic int pr_sd_seat(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->sd_seat);\n}\n\nstatic int pr_sd_slice(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->sd_slice);\n}\n/************************ Linux namespaces ******************************/\n\n#define _pr_ns(NAME, ID)\\\nstatic int pr_##NAME(char *restrict const outbuf, const proc_t *restrict const pp) {\\\n  if (pp->ns[ID])\\\n    return snprintf(outbuf, COLWID, \"%lu\", (unsigned long)pp->ns[ID]);\\\n  else\\\n    return snprintf(outbuf, COLWID, \"-\");\\\n}\n_pr_ns(ipcns, IPCNS);\n_pr_ns(mntns, MNTNS);\n_pr_ns(netns, NETNS);\n_pr_ns(pidns, PIDNS);\n_pr_ns(userns, USERNS);\n_pr_ns(utsns, UTSNS);\n\n/************************ Linux containers ******************************/\nstatic int pr_lxcname(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->lxcname);\n}\n\n/****************** FLASK & seLinux security stuff **********************/\n// move the bulk of this to libproc sometime\n\n// This needs more study, considering:\n// 1. the static linking option (maybe disable this in that case)\n// 2. the -z and -Z option issue\n// 3. width of output\nstatic int pr_context(char *restrict const outbuf, const proc_t *restrict const pp){\n  static void (*ps_freecon)(char*) = 0;\n  static int (*ps_getpidcon)(pid_t pid, char **context) = 0;\n  static int selinux_enabled = 0;;\n  size_t len;\n  char *context;\n\n#if ENABLE_LIBSELINUX\n  static int (*ps_is_selinux_enabled)(void) = 0;\n  static int tried_load = 0;\n\n  if(!ps_getpidcon && !tried_load){\n    void *handle = dlopen(\"libselinux.so.1\", RTLD_NOW);\n    if(handle){\n      ps_freecon = dlsym(handle, \"freecon\");\n      if(dlerror())\n        ps_freecon = 0;\n      dlerror();\n      ps_getpidcon = dlsym(handle, \"getpidcon\");\n      if(dlerror())\n        ps_getpidcon = 0;\n      ps_is_selinux_enabled = dlsym(handle, \"is_selinux_enabled\");\n      if(dlerror())\n        ps_is_selinux_enabled = 0;\n      else\n        selinux_enabled = ps_is_selinux_enabled();\n    }\n    tried_load++;\n  }\n#endif\n  if(ps_getpidcon && selinux_enabled && !ps_getpidcon(pp->tgid, &context)){\n    size_t max_len = OUTBUF_SIZE-1;\n    len = strlen(context);\n    if(len > max_len) len = max_len;\n    memcpy(outbuf, context, len);\n    if (len >= 1 && outbuf[len-1] == '\\n') --len;\n    outbuf[len] = '\\0';\n    ps_freecon(context);\n  }else{\n    char filename[48];\n    ssize_t num_read;\n    int fd;\n\n// wchan file is suitable for testing\n//snprintf(filename, sizeof filename, \"/proc/%d/wchan\", pp->tgid);\n    snprintf(filename, sizeof filename, \"/proc/%d/attr/current\", pp->tgid);\n\n    if ((fd = open(filename, O_RDONLY, 0)) != -1) {\n      num_read = read(fd, outbuf, OUTBUF_SIZE-1);\n      close(fd);\n      if (num_read > 0) {\n        outbuf[num_read] = '\\0';\n        len = 0;\n        while(isprint(outbuf[len]))\n          len++;\n        outbuf[len] = '\\0';\n        if(len)\n          return len;\n      }\n    }\n    outbuf[0] = '-';\n    outbuf[1] = '\\0';\n    len = 1;\n  }\n  return len;\n}\n\n////////////////////////////// Test code /////////////////////////////////\n\n// like \"args\"\nstatic int pr_t_unlimited(char *restrict const outbuf, const proc_t *restrict const pp){\n  static const char *const vals[] = {\"[123456789-12345] <defunct>\",\"ps\",\"123456789-123456\"};\n  (void)pp;\n  snprintf(outbuf, max_rightward+1, \"%s\", vals[lines_to_next_header%3u]);\n  return strlen(outbuf);\n}\nstatic int pr_t_unlimited2(char *restrict const outbuf, const proc_t *restrict const pp){\n  static const char *const vals[] = {\"unlimited\", \"[123456789-12345] <defunct>\",\"ps\",\"123456789-123456\"};\n  (void)pp;\n  snprintf(outbuf, max_rightward+1, \"%s\", vals[lines_to_next_header%4u]);\n  return strlen(outbuf);\n}\n\n// like \"etime\"\nstatic int pr_t_right(char *restrict const outbuf, const proc_t *restrict const pp){\n  static const char *const vals[] = {\"999-23:59:59\",\"99-23:59:59\",\"9-23:59:59\",\"59:59\"};\n  (void)pp;\n  return snprintf(outbuf, COLWID, \"%s\", vals[lines_to_next_header%4u]);\n}\nstatic int pr_t_right2(char *restrict const outbuf, const proc_t *restrict const pp){\n  static const char *const vals[] = {\"999-23:59:59\",\"99-23:59:59\",\"9-23:59:59\"};\n  (void)pp;\n  return snprintf(outbuf, COLWID, \"%s\", vals[lines_to_next_header%3u]);\n}\n\n// like \"tty\"\nstatic int pr_t_left(char *restrict const outbuf, const proc_t *restrict const pp){\n  static const char *const vals[] = {\"tty7\",\"pts/9999\",\"iseries/vtty42\",\"ttySMX0\",\"3270/tty4\"};\n  (void)pp;\n  return snprintf(outbuf, COLWID, \"%s\", vals[lines_to_next_header%5u]);\n}\nstatic int pr_t_left2(char *restrict const outbuf, const proc_t *restrict const pp){\n  static const char *const vals[] = {\"tty7\",\"pts/9999\",\"ttySMX0\",\"3270/tty4\"};\n  (void)pp;\n  return snprintf(outbuf, COLWID, \"%s\", vals[lines_to_next_header%4u]);\n}\n\n/***************************************************************************/\n/*************************** other stuff ***********************************/\n\n/*\n * Old header specifications.\n *\n * short   Up  \"  PID TTY STAT  TIME COMMAND\"\n * long  l Pp  \" FLAGS   UID   PID  PPID PRI  NI   SIZE   RSS WCHAN       STA TTY TIME COMMAND\n * user  u up  \"USER       PID %CPU %MEM  SIZE   RSS TTY STAT START   TIME COMMAND\n * jobs  j gPp \" PPID   PID  PGID   SID TTY TPGID  STAT   UID   TIME COMMAND\n * sig   s p   \"  UID   PID SIGNAL   BLOCKED  IGNORED  CATCHED  STAT TTY   TIME COMMAND\n * vm    v r   \"  PID TTY STAT  TIME  PAGEIN TSIZ DSIZ  RSS   LIM %MEM COMMAND\n * m     m r   \"  PID TTY MAJFLT MINFLT   TRS   DRS  SIZE  SWAP   RSS  SHRD   LIB  DT COMMAND\n * regs  X p   \"NR   PID    STACK      ESP      EIP TMOUT ALARM STAT TTY   TIME COMMAND\n */\n\n/*\n * Unix98 requires that the heading for tty is TT, though XPG4, Digital,\n * and BSD use TTY. The Unix98 headers are:\n *              args,comm,etime,group,nice,pcpu,pgid\n *              pid,ppid,rgroup,ruser,time,tty,user,vsz\n *\n * BSD c:   \"command\" becomes accounting name (\"comm\" or \"ucomm\")\n * BSD n:   \"user\" becomes \"uid\" and \"wchan\" becomes \"nwchan\" (number)\n */\n\n/* Justification control for flags field. */\n#define USER      CF_USER   // left if text, right if numeric\n#define LEFT      CF_LEFT\n#define RIGHT     CF_RIGHT\n#define UNLIMITED CF_UNLIMITED\n#define WCHAN     CF_WCHAN  // left if text, right if numeric\n#define SIGNAL    CF_SIGNAL // right in 9, or 16 if room\n#define PIDMAX    CF_PIDMAX\n#define TO        CF_PRINT_THREAD_ONLY\n#define PO        CF_PRINT_PROCESS_ONLY\n#define ET        CF_PRINT_EVERY_TIME\n#define AN        CF_PRINT_AS_NEEDED // no idea\n\n/* short names to save space */\n#define MEM PROC_FILLMEM     /* read statm  */\n#define ARG PROC_FILLARG     /* read cmdline (cleared if c option) */\n#define COM PROC_FILLCOM     /* read cmdline (cleared if not -f option) */\n#define ENV PROC_FILLENV     /* read environ */\n#define USR PROC_FILLUSR     /* uid_t -> user names */\n#define GRP PROC_FILLGRP     /* gid_t -> group names */\n#define NS  PROC_FILLNS      /* read namespace information */\n#define LXC PROC_FILL_LXC    /* value the lxc name field */\n#define SD  PROC_FILLSYSTEMD /* retrieve systemd stuff */\n#define SGRP PROC_FILLSTATUS | PROC_FILLSUPGRP  /* supgid -> supgrp (names) */\n#define CGRP PROC_FILLCGROUP | PROC_EDITCGRPCVT /* read cgroup */\n\n/* TODO\n *      pull out annoying BSD aliases into another table (to macro table?)\n *      add sorting functions here (to unify names)\n */\n\n/* temporary hack -- mark new stuff grabbed from Debian ps */\n#define LNx LNX\n\n/* there are about 211 listed */\n\n/* Many of these are placeholders for unsupported options. */\nstatic const format_struct format_array[] = {\n/* code       header     print()      sort()    width need vendor flags  */\n{\"%cpu\",      \"%CPU\",    pr_pcpu,     sr_pcpu,    4,   0,    BSD, ET|RIGHT}, /*pcpu*/\n{\"%mem\",      \"%MEM\",    pr_pmem,     sr_rss,     4,   0,    BSD, PO|RIGHT}, /*pmem*/\n{\"_left\",     \"LLLLLLLL\", pr_t_left,  sr_nop,     8,   0,    TST, ET|LEFT},\n{\"_left2\",    \"L2L2L2L2\", pr_t_left2, sr_nop,     8,   0,    TST, ET|LEFT},\n{\"_right\",    \"RRRRRRRRRRR\", pr_t_right, sr_nop, 11,   0,    TST, ET|RIGHT},\n{\"_right2\",   \"R2R2R2R2R2R\", pr_t_right2, sr_nop, 11,  0,    TST, ET|RIGHT},\n{\"_unlimited\",\"U\",   pr_t_unlimited,  sr_nop,    16,   0,    TST, ET|UNLIMITED},\n{\"_unlimited2\",\"U2\", pr_t_unlimited2, sr_nop,    16,   0,    TST, ET|UNLIMITED},\n{\"acflag\",    \"ACFLG\",   pr_nop,      sr_nop,     5,   0,    XXX, AN|RIGHT}, /*acflg*/\n{\"acflg\",     \"ACFLG\",   pr_nop,      sr_nop,     5,   0,    BSD, AN|RIGHT}, /*acflag*/\n{\"addr\",      \"ADDR\",    pr_nop,      sr_nop,     4,   0,    XXX, AN|RIGHT},\n{\"addr_1\",    \"ADDR\",    pr_nop,      sr_nop,     1,   0,    LNX, AN|LEFT},\n{\"alarm\",     \"ALARM\",   pr_alarm,    sr_alarm,   5,   0,    LNX, AN|RIGHT},\n{\"argc\",      \"ARGC\",    pr_nop,      sr_nop,     4,   0,    LNX, PO|RIGHT},\n{\"args\",      \"COMMAND\", pr_args,     sr_cmd,    27, ARG,    U98, PO|UNLIMITED}, /*command*/\n{\"atime\",     \"TIME\",    pr_time,     sr_time,    8,   0,    SOE, ET|RIGHT}, /*cputime*/ /* was 6 wide */\n{\"blocked\",   \"BLOCKED\", pr_sigmask,  sr_nop,     9,   0,    BSD, TO|SIGNAL}, /*sigmask*/\n{\"bnd\",       \"BND\",     pr_nop,      sr_nop,     1,   0,    AIX, TO|RIGHT},\n{\"bsdstart\",  \"START\",   pr_bsdstart, sr_nop,     6,   0,    LNX, ET|RIGHT},\n{\"bsdtime\",   \"TIME\",    pr_bsdtime,  sr_nop,     6,   0,    LNX, ET|RIGHT},\n{\"c\",         \"C\",       pr_c,        sr_pcpu,    2,   0,    SUN, ET|RIGHT},\n{\"caught\",    \"CAUGHT\",  pr_sigcatch, sr_nop,     9,   0,    BSD, TO|SIGNAL}, /*sigcatch*/\n{\"cgname\",    \"CGNAME\",  pr_cgname,   sr_cgname, 27,CGRP,    LNX, PO|UNLIMITED},\n{\"cgroup\",    \"CGROUP\",  pr_cgroup,   sr_cgroup, 27,CGRP,    LNX, PO|UNLIMITED},\n{\"class\",     \"CLS\",     pr_class,    sr_sched,   3,   0,    XXX, TO|LEFT},\n{\"cls\",       \"CLS\",     pr_class,    sr_sched,   3,   0,    HPU, TO|RIGHT}, /*says HPUX or RT*/\n{\"cmaj_flt\",  \"-\",       pr_nop,      sr_cmaj_flt, 1,  0,    LNX, AN|RIGHT},\n{\"cmd\",       \"CMD\",     pr_args,     sr_cmd,    27, ARG,    DEC, PO|UNLIMITED}, /*ucomm*/\n{\"cmin_flt\",  \"-\",       pr_nop,      sr_cmin_flt, 1,  0,    LNX, AN|RIGHT},\n{\"cnswap\",    \"-\",       pr_nop,      sr_nop,     1,   0,    LNX, AN|RIGHT},\n{\"comm\",      \"COMMAND\", pr_comm,     sr_cmd,    15, COM,    U98, PO|UNLIMITED}, /*ucomm*/\n{\"command\",   \"COMMAND\", pr_args,     sr_cmd,    27, ARG,    XXX, PO|UNLIMITED}, /*args*/\n{\"context\",   \"CONTEXT\", pr_context,  sr_nop,    31,   0,    LNX, ET|LEFT},\n{\"cp\",        \"CP\",      pr_cp,       sr_pcpu,    3,   0,    DEC, ET|RIGHT}, /*cpu*/\n{\"cpu\",       \"CPU\",     pr_nop,      sr_nop,     3,   0,    BSD, AN|RIGHT}, /* FIXME ... HP-UX wants this as the CPU number for SMP? */\n{\"cpuid\",     \"CPUID\",   pr_psr,      sr_nop,     5,   0,    BSD, TO|RIGHT}, // OpenBSD: 8 wide!\n{\"cputime\",   \"TIME\",    pr_time,     sr_time,    8,   0,    DEC, ET|RIGHT}, /*time*/\n{\"cputimes\",  \"TIME\",    pr_times,    sr_time,    8,   0,    LNX, ET|RIGHT}, /*time*/\n{\"ctid\",      \"CTID\",    pr_nop,      sr_nop,     5,   0,    SUN, ET|RIGHT}, // resource contracts?\n{\"cursig\",    \"CURSIG\",  pr_nop,      sr_nop,     6,   0,    DEC, AN|RIGHT},\n{\"cutime\",    \"-\",       pr_nop,      sr_cutime,  1,   0,    LNX, AN|RIGHT},\n{\"cwd\",       \"CWD\",     pr_nop,      sr_nop,     3,   0,    LNX, AN|LEFT},\n{\"drs\",       \"DRS\",     pr_drs,      sr_drs,     5, MEM,    LNX, PO|RIGHT},\n{\"dsiz\",      \"DSIZ\",    pr_dsiz,     sr_nop,     4,   0,    LNX, PO|RIGHT},\n{\"egid\",      \"EGID\",    pr_egid,     sr_egid,    5,   0,    LNX, ET|RIGHT},\n{\"egroup\",    \"EGROUP\",  pr_egroup,   sr_egroup,  8, GRP,    LNX, ET|USER},\n{\"eip\",       \"EIP\",     pr_eip,      sr_kstk_eip, (int)(2*sizeof(long)), 0, LNX, TO|RIGHT},\n{\"emul\",      \"EMUL\",    pr_nop,      sr_nop,    13,   0,    BSD, PO|LEFT}, /* \"FreeBSD ELF32\" and such */\n{\"end_code\",  \"E_CODE\",  pr_nop,      sr_end_code, (int)(2*sizeof(long)), 0, LNx, PO|RIGHT},\n{\"environ\",\"ENVIRONMENT\",pr_nop,      sr_nop,    11, ENV,    LNx, PO|UNLIMITED},\n{\"esp\",       \"ESP\",     pr_esp,      sr_kstk_esp, (int)(2*sizeof(long)), 0, LNX, TO|RIGHT},\n{\"etime\",     \"ELAPSED\", pr_etime,    sr_etime,  11,   0,    U98, ET|RIGHT}, /* was 7 wide */\n{\"etimes\",    \"ELAPSED\", pr_etimes,   sr_etime,   7,   0,    BSD, ET|RIGHT}, /* FreeBSD */\n{\"euid\",      \"EUID\",    pr_euid,     sr_euid,    5,   0,    LNX, ET|RIGHT},\n{\"euser\",     \"EUSER\",   pr_euser,    sr_euser,   8, USR,    LNX, ET|USER},\n{\"f\",         \"F\",       pr_flag,     sr_flags,   1,   0,    XXX, ET|RIGHT}, /*flags*/\n{\"fgid\",      \"FGID\",    pr_fgid,     sr_fgid,    5,   0,    LNX, ET|RIGHT},\n{\"fgroup\",    \"FGROUP\",  pr_fgroup,   sr_fgroup,  8, GRP,    LNX, ET|USER},\n{\"flag\",      \"F\",       pr_flag,     sr_flags,   1,   0,    DEC, ET|RIGHT},\n{\"flags\",     \"F\",       pr_flag,     sr_flags,   1,   0,    BSD, ET|RIGHT}, /*f*/ /* was FLAGS, 8 wide */\n{\"fname\",     \"COMMAND\", pr_fname,    sr_nop,     8,   0,    SUN, PO|LEFT},\n{\"fsgid\",     \"FSGID\",   pr_fgid,     sr_fgid,    5,   0,    LNX, ET|RIGHT},\n{\"fsgroup\",   \"FSGROUP\", pr_fgroup,   sr_fgroup,  8, GRP,    LNX, ET|USER},\n{\"fsuid\",     \"FSUID\",   pr_fuid,     sr_fuid,    5,   0,    LNX, ET|RIGHT},\n{\"fsuser\",    \"FSUSER\",  pr_fuser,    sr_fuser,   8, USR,    LNX, ET|USER},\n{\"fuid\",      \"FUID\",    pr_fuid,     sr_fuid,    5,   0,    LNX, ET|RIGHT},\n{\"fuser\",     \"FUSER\",   pr_fuser,    sr_fuser,   8, USR,    LNX, ET|USER},\n{\"gid\",       \"GID\",     pr_egid,     sr_egid,    5,   0,    SUN, ET|RIGHT},\n{\"group\",     \"GROUP\",   pr_egroup,   sr_egroup,  8, GRP,    U98, ET|USER},\n{\"ignored\",   \"IGNORED\", pr_sigignore,sr_nop,     9,   0,    BSD, TO|SIGNAL}, /*sigignore*/\n{\"inblk\",     \"INBLK\",   pr_nop,      sr_nop,     5,   0,    BSD, AN|RIGHT}, /*inblock*/\n{\"inblock\",   \"INBLK\",   pr_nop,      sr_nop,     5,   0,    DEC, AN|RIGHT}, /*inblk*/\n{\"intpri\",    \"PRI\",     pr_opri,     sr_priority, 3,  0,    HPU, TO|RIGHT},\n{\"ipcns\",     \"IPCNS\",   pr_ipcns,    sr_ipcns,  10,  NS,    LNX, ET|RIGHT},\n{\"jid\",       \"JID\",     pr_nop,      sr_nop,     1,   0,    SGI, PO|RIGHT},\n{\"jobc\",      \"JOBC\",    pr_nop,      sr_nop,     4,   0,    XXX, AN|RIGHT},\n{\"ktrace\",    \"KTRACE\",  pr_nop,      sr_nop,     8,   0,    BSD, AN|RIGHT},\n{\"ktracep\",   \"KTRACEP\", pr_nop,      sr_nop,     8,   0,    BSD, AN|RIGHT},\n{\"label\",     \"LABEL\",   pr_context,  sr_nop,    31,  0,     SGI, ET|LEFT},\n{\"lastcpu\",   \"C\",       pr_psr,      sr_nop,     3,   0,    BSD, TO|RIGHT}, // DragonFly\n{\"lim\",       \"LIM\",     pr_lim,      sr_rss_rlim, 5,  0,    BSD, AN|RIGHT},\n{\"login\",     \"LOGNAME\", pr_nop,      sr_nop,     8,   0,    BSD, AN|LEFT}, /*logname*/   /* double check */\n{\"logname\",   \"LOGNAME\", pr_nop,      sr_nop,     8,   0,    XXX, AN|LEFT}, /*login*/\n{\"longtname\", \"TTY\",     pr_tty8,     sr_tty,     8,   0,    DEC, PO|LEFT},\n{\"lsession\",  \"SESSION\", pr_sd_session, sr_nop,  11,  SD,    LNX, ET|LEFT},\n{\"lstart\",    \"STARTED\", pr_lstart,   sr_nop,    24,   0,    XXX, ET|RIGHT},\n{\"luid\",      \"LUID\",    pr_luid,     sr_nop,     5,   0,    LNX, ET|RIGHT}, /* login ID */\n{\"luser\",     \"LUSER\",   pr_nop,      sr_nop,     8, USR,    LNX, ET|USER}, /* login USER */\n{\"lwp\",       \"LWP\",     pr_tasks,    sr_tasks,   5,   0,    SUN, TO|PIDMAX|RIGHT},\n{\"lxc\",       \"LXC\",     pr_lxcname,  sr_lxcname, 8, LXC,    LNX, ET|LEFT},\n{\"m_drs\",     \"DRS\",     pr_drs,      sr_drs,     5, MEM,    LNx, PO|RIGHT},\n{\"m_dt\",      \"DT\",      pr_nop,      sr_dt,      4, MEM,    LNx, PO|RIGHT},\n{\"m_lrs\",     \"LRS\",     pr_nop,      sr_lrs,     5, MEM,    LNx, PO|RIGHT},\n{\"m_resident\", \"RES\",    pr_nop,      sr_resident, 5,MEM,    LNx, PO|RIGHT},\n{\"m_share\",   \"SHRD\",    pr_nop,      sr_share,   5, MEM,    LNx, PO|RIGHT},\n{\"m_size\",    \"SIZE\",    pr_size,     sr_size,    5, MEM,    LNX, PO|RIGHT},\n{\"m_swap\",    \"SWAP\",    pr_nop,      sr_nop,     5,   0,    LNx, PO|RIGHT},\n{\"m_trs\",     \"TRS\",     pr_trs,      sr_trs,     5, MEM,    LNx, PO|RIGHT},\n{\"machine\",   \"MACHINE\", pr_sd_machine, sr_nop,  31,  SD,    LNX, ET|LEFT},\n{\"maj_flt\",   \"MAJFL\",   pr_majflt,   sr_maj_flt, 6,   0,    LNX, AN|RIGHT},\n{\"majflt\",    \"MAJFLT\",  pr_majflt,   sr_maj_flt, 6,   0,    XXX, AN|RIGHT},\n{\"min_flt\",   \"MINFL\",   pr_minflt,   sr_min_flt, 6,   0,    LNX, AN|RIGHT},\n{\"minflt\",    \"MINFLT\",  pr_minflt,   sr_min_flt, 6,   0,    XXX, AN|RIGHT},\n{\"mntns\",     \"MNTNS\",   pr_mntns,    sr_mntns,  10,  NS,    LNX, ET|RIGHT},\n{\"msgrcv\",    \"MSGRCV\",  pr_nop,      sr_nop,     6,   0,    XXX, AN|RIGHT},\n{\"msgsnd\",    \"MSGSND\",  pr_nop,      sr_nop,     6,   0,    XXX, AN|RIGHT},\n{\"mwchan\",    \"MWCHAN\",  pr_nop,      sr_nop,     6,   0,    BSD, TO|WCHAN}, /* mutex (FreeBSD) */\n{\"netns\",     \"NETNS\",   pr_netns,    sr_netns,  10,  NS,    LNX, ET|RIGHT},\n{\"ni\",        \"NI\",      pr_nice,     sr_nice,    3,   0,    BSD, TO|RIGHT}, /*nice*/\n{\"nice\",      \"NI\",      pr_nice,     sr_nice,    3,   0,    U98, TO|RIGHT}, /*ni*/\n{\"nivcsw\",    \"IVCSW\",   pr_nop,      sr_nop,     5,   0,    XXX, AN|RIGHT},\n{\"nlwp\",      \"NLWP\",    pr_nlwp,     sr_nlwp,    4,   0,    SUN, PO|RIGHT},\n{\"nsignals\",  \"NSIGS\",   pr_nop,      sr_nop,     5,   0,    DEC, AN|RIGHT}, /*nsigs*/\n{\"nsigs\",     \"NSIGS\",   pr_nop,      sr_nop,     5,   0,    BSD, AN|RIGHT}, /*nsignals*/\n{\"nswap\",     \"NSWAP\",   pr_nop,      sr_nop,     5,   0,    XXX, AN|RIGHT},\n{\"numa\",      \"NUMA\",    pr_numa,     sr_nop,     4,   0,    XXX, AN|RIGHT},\n{\"nvcsw\",     \"VCSW\",    pr_nop,      sr_nop,     5,   0,    XXX, AN|RIGHT},\n{\"nwchan\",    \"WCHAN\",   pr_nwchan,   sr_nop,     6,   0,    XXX, TO|RIGHT},\n{\"opri\",      \"PRI\",     pr_opri,     sr_priority, 3,  0,    SUN, TO|RIGHT},\n{\"osz\",       \"SZ\",      pr_nop,      sr_nop,     2,   0,    SUN, PO|RIGHT},\n{\"oublk\",     \"OUBLK\",   pr_nop,      sr_nop,     5,   0,    BSD, AN|RIGHT}, /*oublock*/\n{\"oublock\",   \"OUBLK\",   pr_nop,      sr_nop,     5,   0,    DEC, AN|RIGHT}, /*oublk*/\n{\"ouid\",      \"OWNER\",   pr_sd_ouid,  sr_nop,     5,  SD,    LNX, ET|LEFT},\n{\"p_ru\",      \"P_RU\",    pr_nop,      sr_nop,     6,   0,    BSD, AN|RIGHT},\n{\"paddr\",     \"PADDR\",   pr_nop,      sr_nop,     6,   0,    BSD, AN|RIGHT},\n{\"pagein\",    \"PAGEIN\",  pr_majflt,   sr_maj_flt, 6,   0,    XXX, AN|RIGHT},\n{\"pcpu\",      \"%CPU\",    pr_pcpu,     sr_pcpu,    4,   0,    U98, ET|RIGHT}, /*%cpu*/\n{\"pending\",   \"PENDING\", pr_sig,      sr_nop,     9,   0,    BSD, ET|SIGNAL}, /*sig*/\n{\"pgid\",      \"PGID\",    pr_pgid,     sr_pgrp,    5,   0,    U98, PO|PIDMAX|RIGHT},\n{\"pgrp\",      \"PGRP\",    pr_pgid,     sr_pgrp,    5,   0,    LNX, PO|PIDMAX|RIGHT},\n{\"pid\",       \"PID\",     pr_procs,    sr_procs,   5,   0,    U98, PO|PIDMAX|RIGHT},\n{\"pidns\",     \"PIDNS\",   pr_pidns,    sr_pidns,  10,  NS,    LNX, ET|RIGHT},\n{\"pmem\",      \"%MEM\",    pr_pmem,     sr_rss,     4,   0,    XXX, PO|RIGHT}, /*%mem*/\n{\"poip\",      \"-\",       pr_nop,      sr_nop,     1,   0,    BSD, AN|RIGHT},\n{\"policy\",    \"POL\",     pr_class,    sr_sched,   3,   0,    DEC, TO|LEFT},\n{\"ppid\",      \"PPID\",    pr_ppid,     sr_ppid,    5,   0,    U98, PO|PIDMAX|RIGHT},\n{\"pri\",       \"PRI\",     pr_pri,      sr_nop,     3,   0,    XXX, TO|RIGHT},\n{\"pri_api\",   \"API\",     pr_pri_api,  sr_nop,     3,   0,    LNX, TO|RIGHT},\n{\"pri_bar\",   \"BAR\",     pr_pri_bar,  sr_nop,     3,   0,    LNX, TO|RIGHT},\n{\"pri_baz\",   \"BAZ\",     pr_pri_baz,  sr_nop,     3,   0,    LNX, TO|RIGHT},\n{\"pri_foo\",   \"FOO\",     pr_pri_foo,  sr_nop,     3,   0,    LNX, TO|RIGHT},\n{\"priority\",  \"PRI\",     pr_priority, sr_priority, 3,  0,    LNX, TO|RIGHT},\n{\"prmgrp\",    \"PRMGRP\",  pr_nop,      sr_nop,    12,   0,    HPU, PO|RIGHT},\n{\"prmid\",     \"PRMID\",   pr_nop,      sr_nop,    12,   0,    HPU, PO|RIGHT},\n{\"project\",   \"PROJECT\", pr_nop,      sr_nop,    12,   0,    SUN, PO|LEFT}, // see prm* andctid\n{\"projid\",    \"PROJID\",  pr_nop,      sr_nop,     5,   0,    SUN, PO|RIGHT},\n{\"pset\",      \"PSET\",    pr_nop,      sr_nop,     4,   0,    DEC, TO|RIGHT},\n{\"psr\",       \"PSR\",     pr_psr,      sr_nop,     3,   0,    DEC, TO|RIGHT},\n{\"psxpri\",    \"PPR\",     pr_nop,      sr_nop,     3,   0,    DEC, TO|RIGHT},\n{\"re\",        \"RE\",      pr_nop,      sr_nop,     3,   0,    BSD, AN|RIGHT},\n{\"resident\",  \"RES\",     pr_nop,      sr_resident, 5,MEM,    LNX, PO|RIGHT},\n{\"rgid\",      \"RGID\",    pr_rgid,     sr_rgid,    5,   0,    XXX, ET|RIGHT},\n{\"rgroup\",    \"RGROUP\",  pr_rgroup,   sr_rgroup,  8, GRP,    U98, ET|USER}, /* was 8 wide */\n{\"rlink\",     \"RLINK\",   pr_nop,      sr_nop,     8,   0,    BSD, AN|RIGHT},\n{\"rss\",       \"RSS\",     pr_rss,      sr_rss,     5,   0,    XXX, PO|RIGHT}, /* was 5 wide */\n{\"rssize\",    \"RSS\",     pr_rss,      sr_vm_rss,  5,   0,    DEC, PO|RIGHT}, /*rsz*/\n{\"rsz\",       \"RSZ\",     pr_rss,      sr_vm_rss,  5,   0,    BSD, PO|RIGHT}, /*rssize*/\n{\"rtprio\",    \"RTPRIO\",  pr_rtprio,   sr_rtprio,  6,   0,    BSD, TO|RIGHT},\n{\"ruid\",      \"RUID\",    pr_ruid,     sr_ruid,    5,   0,    XXX, ET|RIGHT},\n{\"ruser\",     \"RUSER\",   pr_ruser,    sr_ruser,   8, USR,    U98, ET|USER},\n{\"s\",         \"S\",       pr_s,        sr_state,   1,   0,    SUN, TO|LEFT}, /*stat,state*/\n{\"sched\",     \"SCH\",     pr_sched,    sr_sched,   3,   0,    AIX, TO|RIGHT},\n{\"scnt\",      \"SCNT\",    pr_nop,      sr_nop,     4,   0,    DEC, AN|RIGHT},  /* man page misspelling of scount? */\n{\"scount\",    \"SC\",      pr_nop,      sr_nop,     4,   0,    AIX, AN|RIGHT},  /* scnt==scount, DEC claims both */\n{\"seat\",      \"SEAT\",    pr_sd_seat,  sr_nop,    11,  SD,    LNX, ET|LEFT},\n{\"sess\",      \"SESS\",    pr_sess,     sr_session, 5,   0,    XXX, PO|PIDMAX|RIGHT},\n{\"session\",   \"SESS\",    pr_sess,     sr_session, 5,   0,    LNX, PO|PIDMAX|RIGHT},\n{\"sgi_p\",     \"P\",       pr_sgi_p,    sr_nop,     1,   0,    LNX, TO|RIGHT}, /* \"cpu\" number */\n{\"sgi_rss\",   \"RSS\",     pr_rss,      sr_nop,     4,   0,    LNX, PO|LEFT}, /* SZ:RSS */\n{\"sgid\",      \"SGID\",    pr_sgid,     sr_sgid,    5,   0,    LNX, ET|RIGHT},\n{\"sgroup\",    \"SGROUP\",  pr_sgroup,   sr_sgroup,  8, GRP,    LNX, ET|USER},\n{\"share\",     \"-\",       pr_nop,      sr_share,   1, MEM,    LNX, PO|RIGHT},\n{\"sid\",       \"SID\",     pr_sess,     sr_session, 5,   0,    XXX, PO|PIDMAX|RIGHT}, /* Sun & HP */\n{\"sig\",       \"PENDING\", pr_sig,      sr_nop,     9,   0,    XXX, ET|SIGNAL}, /*pending -- Dragonfly uses this for whole-proc and \"tsig\" for thread */\n{\"sig_block\", \"BLOCKED\",  pr_sigmask, sr_nop,     9,   0,    LNX, TO|SIGNAL},\n{\"sig_catch\", \"CATCHED\", pr_sigcatch, sr_nop,     9,   0,    LNX, TO|SIGNAL},\n{\"sig_ignore\", \"IGNORED\",pr_sigignore, sr_nop,    9,   0,    LNX, TO|SIGNAL},\n{\"sig_pend\",  \"SIGNAL\",   pr_sig,     sr_nop,     9,   0,    LNX, ET|SIGNAL},\n{\"sigcatch\",  \"CAUGHT\",  pr_sigcatch, sr_nop,     9,   0,    XXX, TO|SIGNAL}, /*caught*/\n{\"sigignore\", \"IGNORED\", pr_sigignore,sr_nop,     9,   0,    XXX, TO|SIGNAL}, /*ignored*/\n{\"sigmask\",   \"BLOCKED\", pr_sigmask,  sr_nop,     9,   0,    XXX, TO|SIGNAL}, /*blocked*/\n{\"size\",      \"SIZE\",    pr_swapable, sr_swapable, 5,  0,    SCO, PO|RIGHT},\n{\"sl\",        \"SL\",      pr_nop,      sr_nop,     3,   0,    XXX, AN|RIGHT},\n{\"slice\",      \"SLICE\",  pr_sd_slice, sr_nop,    31,  SD,    LNX, ET|LEFT},\n{\"spid\",      \"SPID\",    pr_tasks,    sr_tasks,   5,   0,    SGI, TO|PIDMAX|RIGHT},\n{\"stackp\",    \"STACKP\",  pr_stackp,   sr_start_stack, (int)(2*sizeof(long)), 0, LNX, PO|RIGHT}, /*start_stack*/\n{\"start\",     \"STARTED\", pr_start,    sr_nop,     8,   0,    XXX, ET|RIGHT},\n{\"start_code\", \"S_CODE\",  pr_nop,     sr_start_code,  (int)(2*sizeof(long)), 0, LNx, PO|RIGHT},\n{\"start_stack\", \"STACKP\", pr_stackp,  sr_start_stack, (int)(2*sizeof(long)), 0, LNX, PO|RIGHT}, /*stackp*/\n{\"start_time\", \"START\",  pr_stime,    sr_start_time, 5, 0,   LNx, ET|RIGHT},\n{\"stat\",      \"STAT\",    pr_stat,     sr_state,   4,   0,    BSD, TO|LEFT}, /*state,s*/\n{\"state\",     \"S\",       pr_s,        sr_state,   1,   0,    XXX, TO|LEFT}, /*stat,s*/ /* was STAT */\n{\"status\",    \"STATUS\",  pr_nop,      sr_nop,     6,   0,    DEC, AN|RIGHT},\n{\"stime\",     \"STIME\",   pr_stime,    sr_stime,   5,   0,    XXX, ET|RIGHT}, /* was 6 wide */\n{\"suid\",      \"SUID\",    pr_suid,     sr_suid,    5,   0,    LNx, ET|RIGHT},\n{\"supgid\",    \"SUPGID\",  pr_supgid,   sr_nop,    20,   0,    LNX, PO|UNLIMITED},\n{\"supgrp\",    \"SUPGRP\",  pr_supgrp,   sr_nop,    40,SGRP,    LNX, PO|UNLIMITED},\n{\"suser\",     \"SUSER\",   pr_suser,    sr_suser,   8, USR,    LNx, ET|USER},\n{\"svgid\",     \"SVGID\",   pr_sgid,     sr_sgid,    5,   0,    XXX, ET|RIGHT},\n{\"svgroup\",   \"SVGROUP\", pr_sgroup,   sr_sgroup,  8, GRP,    LNX, ET|USER},\n{\"svuid\",     \"SVUID\",   pr_suid,     sr_suid,    5,   0,    XXX, ET|RIGHT},\n{\"svuser\",    \"SVUSER\",  pr_suser,    sr_suser,   8, USR,    LNX, ET|USER},\n{\"systime\",   \"SYSTEM\",  pr_nop,      sr_nop,     6,   0,    DEC, ET|RIGHT},\n{\"sz\",        \"SZ\",      pr_sz,       sr_nop,     5,   0,    HPU, PO|RIGHT},\n{\"taskid\",    \"TASKID\",  pr_nop,      sr_nop,     5,   0,    SUN, TO|PIDMAX|RIGHT}, // is this a thread ID?\n{\"tdev\",      \"TDEV\",    pr_nop,      sr_nop,     4,   0,    XXX, AN|RIGHT},\n{\"tgid\",      \"TGID\",    pr_procs,    sr_procs,   5,   0,    LNX, PO|PIDMAX|RIGHT},\n{\"thcount\",   \"THCNT\",   pr_nlwp,     sr_nlwp,    5,   0,    AIX, PO|RIGHT},\n{\"tid\",       \"TID\",     pr_tasks,    sr_tasks,   5,   0,    AIX, TO|PIDMAX|RIGHT},\n{\"time\",      \"TIME\",    pr_time,     sr_time,    8,   0,    U98, ET|RIGHT}, /*cputime*/ /* was 6 wide */\n{\"timeout\",   \"TMOUT\",   pr_nop,      sr_nop,     5,   0,    LNX, AN|RIGHT}, // 2.0.xx era\n{\"times\",     \"TIME\",    pr_times,    sr_time,    8,   0,    LNX, ET|RIGHT},\n{\"tmout\",     \"TMOUT\",   pr_nop,      sr_nop,     5,   0,    LNX, AN|RIGHT}, // 2.0.xx era\n{\"tname\",     \"TTY\",     pr_tty8,     sr_tty,     8,   0,    DEC, PO|LEFT},\n{\"tpgid\",     \"TPGID\",   pr_tpgid,    sr_tpgid,   5,   0,    XXX, PO|PIDMAX|RIGHT},\n{\"trs\",       \"TRS\",     pr_trs,      sr_trs,     4, MEM,    AIX, PO|RIGHT},\n{\"trss\",      \"TRSS\",    pr_trs,      sr_trs,     4, MEM,    BSD, PO|RIGHT}, /* 4.3BSD NET/2 */\n{\"tsess\",     \"TSESS\",   pr_nop,      sr_nop,     5,   0,    BSD, PO|PIDMAX|RIGHT},\n{\"tsession\",  \"TSESS\",   pr_nop,      sr_nop,     5,   0,    DEC, PO|PIDMAX|RIGHT},\n{\"tsid\",      \"TSID\",    pr_nop,      sr_nop,     5,   0,    BSD, PO|PIDMAX|RIGHT},\n{\"tsig\",      \"PENDING\", pr_tsig,     sr_nop,     9,   0,    BSD, ET|SIGNAL}, /* Dragonfly used this for thread-specific, and \"sig\" for whole-proc */\n{\"tsiz\",      \"TSIZ\",    pr_tsiz,     sr_nop,     4,   0,    BSD, PO|RIGHT},\n{\"tt\",        \"TT\",      pr_tty8,     sr_tty,     8,   0,    BSD, PO|LEFT},\n{\"tty\",       \"TT\",      pr_tty8,     sr_tty,     8,   0,    U98, PO|LEFT}, /* Unix98 requires \"TT\" but has \"TTY\" too. :-( */  /* was 3 wide */\n{\"tty4\",      \"TTY\",     pr_tty4,     sr_tty,     4,   0,    LNX, PO|LEFT},\n{\"tty8\",      \"TTY\",     pr_tty8,     sr_tty,     8,   0,    LNX, PO|LEFT},\n{\"u_procp\",   \"UPROCP\",  pr_nop,      sr_nop,     6,   0,    DEC, AN|RIGHT},\n{\"ucmd\",      \"CMD\",     pr_comm,     sr_cmd,    15, COM,    DEC, PO|UNLIMITED}, /*ucomm*/\n{\"ucomm\",     \"COMMAND\", pr_comm,     sr_cmd,    15, COM,    XXX, PO|UNLIMITED}, /*comm*/\n{\"uid\",       \"UID\",     pr_euid,     sr_euid,    5,   0,    XXX, ET|RIGHT},\n{\"uid_hack\",  \"UID\",     pr_euser,    sr_euser,   8, USR,    XXX, ET|USER},\n{\"umask\",     \"UMASK\",   pr_nop,      sr_nop,     5,   0,    DEC, AN|RIGHT},\n{\"uname\",     \"USER\",    pr_euser,    sr_euser,   8, USR,    DEC, ET|USER}, /* man page misspelling of user? */\n{\"unit\",      \"UNIT\",    pr_sd_unit,  sr_nop,    31,  SD,    LNX, ET|LEFT},\n{\"upr\",       \"UPR\",     pr_nop,      sr_nop,     3,   0,    BSD, TO|RIGHT}, /*usrpri*/\n{\"uprocp\",    \"UPROCP\",  pr_nop,      sr_nop,     8,   0,    BSD, AN|RIGHT},\n{\"user\",      \"USER\",    pr_euser,    sr_euser,   8, USR,    U98, ET|USER}, /* BSD n forces this to UID */\n{\"userns\",    \"USERNS\",  pr_userns,   sr_userns, 10,  NS,    LNX, ET|RIGHT},\n{\"usertime\",  \"USER\",    pr_nop,      sr_nop,     4,   0,    DEC, ET|RIGHT},\n{\"usrpri\",    \"UPR\",     pr_nop,      sr_nop,     3,   0,    DEC, TO|RIGHT}, /*upr*/\n{\"util\",      \"C\",       pr_c,        sr_pcpu,    2,   0,    SGI, ET|RIGHT}, // not sure about \"C\"\n{\"utime\",     \"UTIME\",   pr_nop,      sr_utime,   6,   0,    LNx, ET|RIGHT},\n{\"utsns\",     \"UTSNS\",   pr_utsns,    sr_utsns,  10,  NS,    LNX, ET|RIGHT},\n{\"uunit\",     \"UUNIT\",   pr_sd_uunit, sr_nop,    31,  SD,    LNX, ET|LEFT},\n{\"vm_data\",   \"DATA\",    pr_nop,      sr_vm_data, 5,   0,    LNx, PO|RIGHT},\n{\"vm_exe\",    \"EXE\",     pr_nop,      sr_vm_exe,  5,   0,    LNx, PO|RIGHT},\n{\"vm_lib\",    \"LIB\",     pr_nop,      sr_vm_lib,  5,   0,    LNx, PO|RIGHT},\n{\"vm_lock\",   \"LCK\",     pr_nop,      sr_vm_lock, 3,   0,    LNx, PO|RIGHT},\n{\"vm_stack\",  \"STACK\",   pr_nop,      sr_vm_stack, 5,  0,    LNx, PO|RIGHT},\n{\"vsize\",     \"VSZ\",     pr_vsz,      sr_vsize,   6,   0,    DEC, PO|RIGHT}, /*vsz*/\n{\"vsz\",       \"VSZ\",     pr_vsz,      sr_vm_size, 6,   0,    U98, PO|RIGHT}, /*vsize*/\n{\"wchan\",     \"WCHAN\",   pr_wchan,    sr_wchan,   6,   0,    XXX, TO|WCHAN}, /* BSD n forces this to nwchan */ /* was 10 wide */\n{\"wname\",     \"WCHAN\",   pr_wname,    sr_nop,     6,   0,    SGI, TO|WCHAN}, /* opposite of nwchan */\n{\"xstat\",     \"XSTAT\",   pr_nop,      sr_nop,     5,   0,    BSD, AN|RIGHT},\n{\"zone\",      \"ZONE\",    pr_context,  sr_nop,    31,   0,    SUN, ET|LEFT}, // Solaris zone == Linux context?\n{\"zoneid\",    \"ZONEID\",  pr_nop,      sr_nop,    31,   0,    SUN, ET|RIGHT},// Linux only offers context names\n{\"~\",         \"-\",       pr_nop,      sr_nop,     1,   0,    LNX, AN|RIGHT}  /* NULL would ruin alphabetical order */\n};\n\n#undef USER\n#undef LEFT\n#undef RIGHT\n#undef UNLIMITED\n#undef WCHAN\n#undef SIGNAL\n#undef PIDMAX\n#undef PO\n#undef TO\n#undef AN\n#undef ET\n\nstatic const int format_array_count = sizeof(format_array)/sizeof(format_struct);\n\n\n/****************************** Macro formats *******************************/\n/* First X field may be NR, which is p->start_code>>26 printed with %2ld */\n/* That seems useless though, and Debian already killed it. */\n/* The ones marked \"Digital\" have the name defined, not just the data. */\nstatic const macro_struct macro_array[] = {\n{\"DFMT\",     \"pid,tname,state,cputime,cmd\"},         /* Digital's default */\n{\"DefBSD\",   \"pid,tname,stat,bsdtime,args\"},               /* Our BSD default */\n{\"DefSysV\",  \"pid,tname,time,cmd\"},                     /* Our SysV default */\n{\"END_BSD\",  \"state,tname,cputime,comm\"},                 /* trailer for O */\n{\"END_SYS5\", \"state,tname,time,command\"},                 /* trailer for -O */\n{\"F5FMT\",    \"uname,pid,ppid,c,start,tname,time,cmd\"},       /* Digital -f */\n\n{\"FB_\",      \"pid,tt,stat,time,command\"},                          /* FreeBSD default */\n{\"FB_j\",     \"user,pid,ppid,pgid,sess,jobc,stat,tt,time,command\"},     /* FreeBSD j */\n{\"FB_l\",     \"uid,pid,ppid,cpu,pri,nice,vsz,rss,wchan,stat,tt,time,command\"},   /* FreeBSD l */\n{\"FB_u\",     \"user,pid,pcpu,pmem,vsz,rss,tt,stat,start,time,command\"},     /* FreeBSD u */\n{\"FB_v\",     \"pid,stat,time,sl,re,pagein,vsz,rss,lim,tsiz,pcpu,pmem,command\"},   /* FreeBSD v */\n\n{\"FD_\",      \"pid,tty,time,comm\"},                                 /* Fictional Debian SysV default */\n{\"FD_f\",     \"user,pid,ppid,start_time,tty,time,comm\"},                /* Fictional Debian -f */\n{\"FD_fj\",    \"user,pid,ppid,start_time,tty,time,pgid,sid,comm\"},        /* Fictional Debian -jf */\n{\"FD_j\",     \"pid,tty,time,pgid,sid,comm\"},                                  /* Fictional Debian -j */\n{\"FD_l\",     \"flags,state,uid,pid,ppid,priority,nice,vsz,wchan,tty,time,comm\"},    /* Fictional Debian -l */\n{\"FD_lj\",    \"flags,state,uid,pid,ppid,priority,nice,vsz,wchan,tty,time,pgid,sid,comm\"}, /* Fictional Debian -jl */\n\n{\"FL5FMT\",   \"f,state,uid,pid,ppid,pcpu,pri,nice,rss,wchan,start,time,command\"},  /* Digital -fl */\n\n{\"FLASK_context\",   \"pid,context,command\"},  /* Flask Linux context, --context */\n\n{\"HP_\",      \"pid,tty,time,comm\"},  /* HP default */\n{\"HP_f\",     \"user,pid,ppid,cpu,stime,tty,time,args\"},  /* HP -f */\n{\"HP_fl\",    \"flags,state,user,pid,ppid,cpu,intpri,nice,addr,sz,wchan,stime,tty,time,args\"},  /* HP -fl */\n{\"HP_l\",     \"flags,state,uid,pid,ppid,cpu,intpri,nice,addr,sz,wchan,tty,time,comm\"},  /* HP -l */\n\n{\"J390\",     \"pid,sid,pgrp,tname,atime,args\"},   /* OS/390 -j */\n{\"JFMT\",     \"user,pid,ppid,pgid,sess,jobc,state,tname,cputime,command\"},   /* Digital j and -j */\n{\"L5FMT\",    \"f,state,uid,pid,ppid,c,pri,nice,addr,sz,wchan,tt,time,ucmd\"},   /* Digital -l */\n{\"LFMT\",     \"uid,pid,ppid,cp,pri,nice,vsz,rss,wchan,state,tname,cputime,command\"},   /* Digital l */\n\n{\"OL_X\",     \"pid,start_stack,esp,eip,timeout,alarm,stat,tname,bsdtime,args\"},      /* Old i386 Linux X */\n{\"OL_j\",     \"ppid,pid,pgid,sid,tname,tpgid,stat,uid,bsdtime,args\"},                   /* Old Linux j */\n{\"OL_l\",     \"flags,uid,pid,ppid,priority,nice,vsz,rss,wchan,stat,tname,bsdtime,args\"},     /* Old Linux l */\n{\"OL_m\",     \"pid,tname,majflt,minflt,m_trs,m_drs,m_size,m_swap,rss,m_share,vm_lib,m_dt,args\"}, /* Old Linux m */\n{\"OL_s\",     \"uid,pid,pending,sig_block,sig_ignore,caught,stat,tname,bsdtime,args\"},  /* Old Linux s */\n{\"OL_u\",     \"user,pid,pcpu,pmem,vsz,rss,tname,stat,start_time,bsdtime,args\"},       /* Old Linux u */\n{\"OL_v\",     \"pid,tname,stat,bsdtime,maj_flt,m_trs,m_drs,rss,pmem,args\"},            /* Old Linux v */\n\n{\"RD_\",      \"pid,tname,state,bsdtime,comm\"},                                       /* Real Debian default */\n{\"RD_f\",     \"uid,pid,ppid,start_time,tname,bsdtime,args\"},                         /* Real Debian -f */\n{\"RD_fj\",    \"uid,pid,ppid,start_time,tname,bsdtime,pgid,sid,args\"},                /* Real Debian -jf */\n{\"RD_j\",     \"pid,tname,state,bsdtime,pgid,sid,comm\"},                               /* Real Debian -j */\n{\"RD_l\",     \"flags,state,uid,pid,ppid,priority,nice,wchan,tname,bsdtime,comm\"},           /* Real Debian -l */\n{\"RD_lj\",    \"flags,state,uid,pid,ppid,priority,nice,wchan,tname,bsdtime,pgid,sid,comm\"},  /* Real Debian -jl */\n\n{\"RUSAGE\",   \"minflt,majflt,nswap,inblock,oublock,msgsnd,msgrcv,nsigs,nvcsw,nivcsw\"}, /* Digital -o \"RUSAGE\" */\n{\"SCHED\",    \"user,pcpu,pri,usrpri,nice,psxpri,psr,policy,pset\"},                /* Digital -o \"SCHED\" */\n{\"SFMT\",     \"uid,pid,cursig,sig,sigmask,sigignore,sigcatch,stat,tname,command\"},  /* Digital s */\n\n{\"Std_f\",    \"uid_hack,pid,ppid,c,stime,tname,time,cmd\"},                     /* new -f */\n{\"Std_fl\",   \"f,s,uid_hack,pid,ppid,c,opri,ni,addr,sz,wchan,stime,tname,time,cmd\"}, /* -fl */\n{\"Std_l\",    \"f,s,uid,pid,ppid,c,opri,ni,addr,sz,wchan,tname,time,ucmd\"},  /* new -l */\n\n{\"THREAD\",   \"user,pcpu,pri,scnt,wchan,usertime,systime\"},                /* Digital -o \"THREAD\" */\n{\"UFMT\",     \"uname,pid,pcpu,pmem,vsz,rss,tt,state,start,time,command\"},   /* Digital u */\n{\"VFMT\",     \"pid,tt,state,time,sl,pagein,vsz,rss,pcpu,pmem,command\"},   /* Digital v */\n{\"~\", \"~\"} /* NULL would ruin alphabetical order */\n};\n\nstatic const int macro_array_count = sizeof(macro_array)/sizeof(macro_struct);\n\n\n/*************************** AIX formats ********************/\n/* Convert AIX format codes to normal format specifiers. */\nstatic const aix_struct aix_array[] = {\n{'C', \"pcpu\",   \"%CPU\"},\n{'G', \"group\",  \"GROUP\"},\n{'P', \"ppid\",   \"PPID\"},\n{'U', \"user\",   \"USER\"},\n{'a', \"args\",   \"COMMAND\"},\n{'c', \"comm\",   \"COMMAND\"},\n{'g', \"rgroup\", \"RGROUP\"},\n{'n', \"nice\",   \"NI\"},\n{'p', \"pid\",    \"PID\"},\n{'r', \"pgid\",   \"PGID\"},\n{'t', \"etime\",  \"ELAPSED\"},\n{'u', \"ruser\",  \"RUSER\"},\n{'x', \"time\",   \"TIME\"},\n{'y', \"tty\",    \"TTY\"},\n{'z', \"vsz\",    \"VSZ\"},\n{'~', \"~\",      \"~\"} /* NULL would ruin alphabetical order */\n};\n//static const int aix_array_count = sizeof(aix_array)/sizeof(aix_struct);\n\n\n/********************* sorting ***************************/\n/* Convert short sorting codes to normal format specifiers. */\nstatic const shortsort_struct shortsort_array[] = {\n{'C', \"pcpu\"       },\n{'G', \"tpgid\"      },\n{'J', \"cstime\"     },\n/* {'K', \"stime\"      }, */  /* conflict, system vs. start time */\n{'M', \"maj_flt\"    },\n{'N', \"cmaj_flt\"   },\n{'P', \"ppid\"       },\n{'R', \"resident\"   },\n{'S', \"share\"      },\n{'T', \"start_time\" },\n{'U', \"uid\"        }, /* euid */\n{'c', \"cmd\"        },\n{'f', \"flags\"      },\n{'g', \"pgrp\"       },\n{'j', \"cutime\"     },\n{'k', \"utime\"      },\n{'m', \"min_flt\"    },\n{'n', \"cmin_flt\"   },\n{'o', \"session\"    },\n{'p', \"pid\"        },\n{'r', \"rss\"        },\n{'s', \"size\"       },\n{'t', \"tty\"        },\n{'u', \"user\"       },\n{'v', \"vsize\"      },\n{'y', \"priority\"   }, /* nice */\n{'~', \"~\"          } /* NULL would ruin alphabetical order */\n};\n//static const int shortsort_array_count = sizeof(shortsort_array)/sizeof(shortsort_struct);\n\n\n/*********** print format_array **********/\n/* called by the parser in another file */\nvoid print_format_specifiers(void){\n  const format_struct *walk = format_array;\n  while(*(walk->spec) != '~'){\n    if(walk->pr != pr_nop) printf(\"%-12.12s %-8.8s\\n\", walk->spec, walk->head);\n    walk++;\n  }\n}\n\n/************ comparison functions for bsearch *************/\n\nstatic int compare_format_structs(const void *a, const void *b){\n  return strcmp(((const format_struct*)a)->spec,((const format_struct*)b)->spec);\n}\n\nstatic int compare_macro_structs(const void *a, const void *b){\n  return strcmp(((const macro_struct*)a)->spec,((const macro_struct*)b)->spec);\n}\n\n/******** look up structs as needed by the sort & format parsers ******/\n\nconst shortsort_struct *search_shortsort_array(const int findme){\n  const shortsort_struct *walk = shortsort_array;\n  while(walk->desc != '~'){\n    if(walk->desc == findme) return walk;\n    walk++;\n  }\n  return NULL;\n}\n\nconst aix_struct *search_aix_array(const int findme){\n  const aix_struct *walk = aix_array;\n  while(walk->desc != '~'){\n    if(walk->desc == findme) return walk;\n    walk++;\n  }\n  return NULL;\n}\n\nconst format_struct *search_format_array(const char *findme){\n  format_struct key;\n  key.spec = findme;\n  return bsearch(&key, format_array, format_array_count,\n    sizeof(format_struct), compare_format_structs\n  );\n}\n\nconst macro_struct *search_macro_array(const char *findme){\n  macro_struct key;\n  key.spec = findme;\n  return bsearch(&key, macro_array, macro_array_count,\n    sizeof(macro_struct), compare_macro_structs\n  );\n}\n\nstatic unsigned int active_cols;  /* some multiple of screen_cols */\n\n/***** Last chance, avoid needless trunctuation. */\nstatic void check_header_width(void){\n  format_node *walk = format_list;\n  unsigned int total = 0;\n  int was_normal = 0;\n  unsigned int i = 0;\n  unsigned int sigs = 0;\n  while(walk){\n    switch((walk->flags) & CF_JUST_MASK){\n    default:\n      total += walk->width;\n      total += was_normal;\n      was_normal = 1;\n      break;\n    case CF_SIGNAL:\n      sigs++;\n      total += walk->width;\n      total += was_normal;\n      was_normal = 1;\n      break;\n    case CF_UNLIMITED:  /* could chop this a bit */\n      if(walk->next) total += walk->width;\n      else total += 3; /* not strlen(walk->name) */\n      total += was_normal;\n      was_normal = 1;\n      break;\n    case 0:  /* AIX */\n      total += walk->width;\n      was_normal = 0;\n      break;\n    }\n    walk = walk->next;\n  }\n  for(;;){\n    i++;\n    active_cols = screen_cols * i;\n    if(active_cols>=total) break;\n    if(screen_cols*i >= OUTBUF_SIZE/2) break; /* can't go over */\n  }\n  wide_signals = (total+sigs*7 <= active_cols);\n}\n\n\n/********** show one process (NULL proc prints header) **********/\n\n//#define SPACE_AMOUNT page_size\n#define SPACE_AMOUNT 144\n\nstatic char *saved_outbuf;\n\nvoid show_one_proc(const proc_t *restrict const p, const format_node *restrict fmt){\n  /* unknown: maybe set correct & actual to 1, remove +/- 1 below */\n  int correct  = 0;  /* screen position we should be at */\n  int actual   = 0;  /* screen position we are at */\n  int amount   = 0;  /* amount of text that this data is */\n  int leftpad  = 0;  /* amount of space this column _could_ need */\n  int space    = 0;  /* amount of space we actually need to print */\n  int dospace  = 0;  /* previous column determined that we need a space */\n  int legit    = 0;  /* legitimately stolen extra space */\n  int sz       = 0;  /* real size of data in outbuffer */\n  int tmpspace = 0;\n  char *restrict const outbuf = saved_outbuf;\n  static int did_stuff = 0;  /* have we ever printed anything? */\n\n  if(unlikely(-1==(long)p)){    /* true only once, at the end */\n    if(did_stuff) return;\n    /* have _never_ printed anything, but might need a header */\n    if(!--lines_to_next_header){\n      lines_to_next_header = header_gap;\n      show_one_proc(NULL,fmt);\n    }\n    /* fprintf(stderr, \"No processes available.\\n\"); */  /* legal? */\n    exit(1);\n  }\n  if(likely(p)){  /* not header, maybe we should call ourselves for it */\n    if(unlikely(!--lines_to_next_header)){\n      lines_to_next_header = header_gap;\n      show_one_proc(NULL,fmt);\n    }\n  }\n  did_stuff = 1;\n  if(unlikely(active_cols>(int)OUTBUF_SIZE)) fprintf(stderr,_(\"fix bigness error\\n\"));\n\n  /* print row start sequence */\n  for(;;){\n    legit = 0;\n    /* set width suggestion which might be ignored */\n//    if(likely(fmt->next)) max_rightward = fmt->width;\n//    else max_rightward = active_cols-((correct>actual) ? correct : actual);\n\n    if(likely(fmt->next)){\n      max_rightward = fmt->width;\n      tmpspace = 0;\n    }else{\n      tmpspace = correct-actual;\n      if (tmpspace<1){\n        tmpspace = dospace;\n        max_rightward = active_cols-actual-tmpspace;\n      }else{\n\tmax_rightward = active_cols - ( (correct>actual) ? correct : actual );\n      }\n    }\n    if(max_rightward <= 0) max_rightward = 0;\n    else if(max_rightward >= OUTBUF_SIZE) max_rightward = OUTBUF_SIZE-1;\n\n    max_leftward  = fmt->width + actual - correct; /* TODO check this */\n    if(max_leftward <= 0) max_leftward = 0;\n    else if(max_leftward >= OUTBUF_SIZE) max_leftward = OUTBUF_SIZE-1;\n\n//    fprintf(stderr, \"cols: %d, max_rightward: %d, max_leftward: %d, actual: %d, correct: %d\\n\",\n//\t\t    active_cols, max_rightward, max_leftward, actual, correct);\n\n    /* prepare data and calculate leftpad */\n    if(likely(p) && likely(fmt->pr)) amount = (*fmt->pr)(outbuf,p);\n    else amount = snprintf(outbuf, OUTBUF_SIZE, \"%s\", fmt->name); /* AIX or headers */\n\n    if(amount < 0) outbuf[amount = 0] = '\\0';\n    else if(amount >= OUTBUF_SIZE) outbuf[amount = OUTBUF_SIZE-1] = '\\0';\n\n    switch((fmt->flags) & CF_JUST_MASK){\n    case 0:  /* for AIX, assigned outside this file */\n      leftpad = 0;\n      break;\n    case CF_LEFT:          /* bad */\n      leftpad = 0;\n      break;\n    case CF_RIGHT:     /* OK */\n      leftpad = fmt->width - amount;\n      if(leftpad < 0) leftpad = 0;\n      break;\n    case CF_SIGNAL:\n      /* if the screen is wide enough, use full 16-character output */\n      if(wide_signals){\n        leftpad = 16 - amount;\n        legit = 7;\n      }else{\n        leftpad =  9 - amount;\n      }\n      if(leftpad < 0) leftpad = 0;\n      break;\n    case CF_USER:       /* bad */\n      leftpad = fmt->width - amount;\n      if(leftpad < 0) leftpad = 0;\n      if(!user_is_number) leftpad = 0;\n      break;\n    case CF_WCHAN:       /* bad */\n      if(wchan_is_number){\n        leftpad = fmt->width - amount;\n        if(leftpad < 0) leftpad = 0;\n        break;\n      }else{\n        if ((active_cols-actual-tmpspace)<1)\n          outbuf[1] = '\\0';  /* oops, we (mostly) lose this column... */\n        leftpad = 0;\n        break;\n      }\n    case CF_UNLIMITED:\n    {\n      if(active_cols-actual-tmpspace < 1)\n        outbuf[1] = '\\0';    /* oops, we (mostly) lose this column... */\n      leftpad = 0;\n      break;\n    }\n    default:\n      fprintf(stderr, _(\"bad alignment code\\n\"));\n      break;\n    }\n    /* At this point:\n     *\n     * correct   from previous column\n     * actual    from previous column\n     * amount    not needed (garbage due to chopping)\n     * leftpad   left padding for this column alone (not make-up or gap)\n     * space     not needed (will recalculate now)\n     * dospace   if we require space between this and the prior column\n     * legit     space we were allowed to steal, and thus did steal\n     */\n    space = correct - actual + leftpad;\n    if(space<1) space=dospace;\n    if(unlikely(space>SPACE_AMOUNT)) space=SPACE_AMOUNT;  // only so much available\n\n    /* real size -- don't forget in 'amount' is number of cells */\n    outbuf[OUTBUF_SIZE-1] = '\\0';\n    sz = strlen(outbuf);\n\n    /* print data, set x position stuff */\n    if(unlikely(!fmt->next)){\n      /* Last column. Write padding + data + newline all together. */\n      outbuf[sz] = '\\n';\n      fwrite(outbuf-space, space+sz+1, 1, stdout);\n      break;\n    }\n    /* Not the last column. Write padding + data together. */\n    fwrite(outbuf-space, space+sz, 1, stdout);\n    actual  += space+amount;\n    correct += fmt->width;\n    correct += legit;        /* adjust for SIGNAL expansion */\n    if(fmt->pr && fmt->next->pr){ /* neither is AIX filler */\n      correct++;\n      dospace = 1;\n    }else{\n      dospace = 0;\n    }\n    fmt = fmt->next;\n    /* At this point:\n     *\n     * correct   screen position we should be at\n     * actual    screen position we are at\n     * amount    not needed\n     * leftpad   not needed\n     * space     not needed\n     * dospace   if have determined that we need a space next time\n     * legit     not needed\n     */\n  }\n}\n\n\nvoid init_output(void){\n  int outbuf_pages;\n  char *outbuf;\n\n  // add page_size-1 to round up\n  outbuf_pages = (OUTBUF_SIZE+SPACE_AMOUNT+page_size-1)/page_size;\n  outbuf = mmap(\n    0,\n    page_size * (outbuf_pages+1), // 1 more, for guard page at high addresses\n    PROT_READ | PROT_WRITE,\n    MAP_PRIVATE | MAP_ANONYMOUS,\n    -1,\n    0\n  );\n  if(outbuf == MAP_FAILED)\n    catastrophic_failure(__FILE__, __LINE__, _(\"please report this bug\"));\n\n  memset(outbuf, ' ', SPACE_AMOUNT);\n  if(SPACE_AMOUNT==page_size) mprotect(outbuf, page_size, PROT_READ);\n  mprotect(outbuf + page_size*outbuf_pages, page_size, PROT_NONE); // guard page\n  saved_outbuf = outbuf + SPACE_AMOUNT;\n  // available space:  page_size*outbuf_pages-SPACE_AMOUNT\n\n  seconds_since_1970 = time(NULL);\n\n  meminfo();\n\n  check_header_width();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-procps-3.3.15-7t5vyquf2qqr6grf67vw57m6nxql3tx6/spack-src/proc/numa.c": "/*\n * NUMA node support for <PIDS> & <STAT> interfaces\n * Copyright 2017 by James C. Warmer\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#ifndef NUMA_DISABLE\n#include <dlfcn.h>\n#endif\n#include <stdlib.h>\n\n#include \"numa.h\"\n\n/*\n * We're structured so that if numa_init() is NOT called or that ./configure |\n * --disable-numa WAS specified, then calls to both of our primary functions |\n * of numa_max_node() plus numa_node_of_cpu() would always return a negative |\n * 1 which signifies that NUMA information isn't available. That ./configure |\n * option might be required when libdl.so (necessary for dlopen) is missing. |\n */\n\n\n/* ------------------------------------------------------------------------- +\n   a strictly development #define, existing specifically for the top program |\n   ( and it has no affect if ./configure --disable-numa has been specified ) | */\n//#define PRETEND_NUMA     // pretend there are 3 'discontiguous' numa nodes |\n// ------------------------------------------------------------------------- +\n\n\nstatic int null_max_node (void) { return -1; }\nstatic int null_node_of_cpu (int n) { (void)n; return -1; }\n\n\n#ifndef NUMA_DISABLE\n #ifdef PRETEND_NUMA\nstatic int fake_max_node (void) { return 3; }\nstatic int fake_node_of_cpu (int n) { return (1 == (n % 4)) ? 0 : (n % 4); }\n #endif\n#endif\n\n\n#ifndef NUMA_DISABLE\nstatic void *libnuma_handle;\n#endif\nint (*numa_max_node) (void)   = null_max_node;\nint (*numa_node_of_cpu) (int) = null_node_of_cpu;\n\n\nvoid numa_init (void) {\n    static int initialized;\n\n    if (initialized)\n        return;\n\n#ifndef NUMA_DISABLE\n #ifndef PRETEND_NUMA\n    // we'll try for the most recent version, then a version we know works...\n    if ((libnuma_handle = dlopen(\"libnuma.so\", RTLD_LAZY))\n    || (libnuma_handle = dlopen(\"libnuma.so.1\", RTLD_LAZY))) {\n        numa_max_node = dlsym(libnuma_handle, \"numa_max_node\");\n        numa_node_of_cpu = dlsym(libnuma_handle, \"numa_node_of_cpu\");\n        if (numa_max_node == NULL\n        || (numa_node_of_cpu == NULL)) {\n            // this dlclose is safe - we've yet to call numa_node_of_cpu\n            // ( there's one other dlclose which has now been disabled )\n            dlclose(libnuma_handle);\n            libnuma_handle = NULL;\n            numa_max_node = null_max_node;\n            numa_node_of_cpu = null_node_of_cpu;\n        }\n    }\n #else\n    libnuma_handle = (void *)-1;\n    numa_max_node = fake_max_node;\n    numa_node_of_cpu = fake_node_of_cpu;\n #endif\n#endif\n    initialized = 1;\n} // end: numa_init\n\n\nvoid numa_uninit (void) {\n#ifndef PRETEND_NUMA\n    /* note: we'll skip a dlcose() to avoid the following libnuma memory\n     *       leak which is triggered after a call to numa_node_of_cpu():\n     *         ==1234== LEAK SUMMARY:\n     *         ==1234==    definitely lost: 512 bytes in 1 blocks\n     *         ==1234==    indirectly lost: 48 bytes in 2 blocks\n     *         ==1234==    ...\n     * [ thanks very much libnuma for all the pains you have caused us ]\n     */\n//  if (libnuma_handle)\n//      dlclose(libnuma_handle);\n#endif\n} // end: numa_uninit\n\n\n#if defined(PRETEND_NUMA) && defined(NUMA_DISABLE)\n# warning 'PRETEND_NUMA' ignored, 'NUMA_DISABLE' is active\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-procps-3.3.15-7t5vyquf2qqr6grf67vw57m6nxql3tx6/spack-src/proc/sysinfo.c": "/*\n * File for parsing top-level /proc entities.\n * Copyright (C) 1992-1998 by Michael K. Johnson, johnsonm@redhat.com\n * Copyright 1998-2003 Albert Cahalan\n * June 2003, Fabian Frederick, disk and slab info\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <locale.h>\n#include <limits.h>\n#include <errno.h>\n\n#include <unistd.h>\n#include <fcntl.h>\n#ifdef __CYGWIN__\n#include <sys/param.h>\n#endif\n#include \"alloc.h\"\n#include \"version.h\"\n#include \"sysinfo.h\" /* include self to verify prototypes */\n\n#ifndef HZ\n#include <netinet/in.h>  /* htons */\n#endif\n\n#ifndef __CYGWIN__\n#include <link.h>\n#endif\n#include <elf.h>\n\nlong smp_num_cpus;     /* number of CPUs */\nlong page_bytes;       /* this architecture's page size */\n\n#define BAD_OPEN_MESSAGE\t\t\t\t\t\\\n\"Error: /proc must be mounted\\n\"\t\t\t\t\\\n\"  To mount /proc at boot you need an /etc/fstab line like:\\n\"\t\\\n\"      proc   /proc   proc    defaults\\n\"\t\t\t\\\n\"  In the meantime, run \\\"mount proc /proc -t proc\\\"\\n\"\n\n#define STAT_FILE    \"/proc/stat\"\nstatic int stat_fd = -1;\n#define UPTIME_FILE  \"/proc/uptime\"\nstatic int uptime_fd = -1;\n#define LOADAVG_FILE \"/proc/loadavg\"\nstatic int loadavg_fd = -1;\n#define MEMINFO_FILE \"/proc/meminfo\"\nstatic int meminfo_fd = -1;\n#define VMINFO_FILE \"/proc/vmstat\"\nstatic int vminfo_fd = -1;\n#define VM_MIN_FREE_FILE \"/proc/sys/vm/min_free_kbytes\"\nstatic int vm_min_free_fd = -1;\n\n// As of 2.6.24 /proc/meminfo seems to need 888 on 64-bit,\n// and would need 1258 if the obsolete fields were there.\n// As of 3.13 /proc/vmstat needs 2623,\n// and /proc/stat needs 3076.\nstatic char buf[8192];\n\n/* This macro opens filename only if necessary and seeks to 0 so\n * that successive calls to the functions are more efficient.\n * It also reads the current contents of the file into the global buf.\n */\n#define FILE_TO_BUF(filename, fd) do{\t\t\t\t\\\n    static int local_n;\t\t\t\t\t\t\\\n    if (fd == -1 && (fd = open(filename, O_RDONLY)) == -1) {\t\\\n\tfputs(BAD_OPEN_MESSAGE, stderr);\t\t\t\\\n\tfflush(NULL);\t\t\t\t\t\t\\\n\t_exit(102);\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\\\n    lseek(fd, 0L, SEEK_SET);\t\t\t\t\t\\\n    if ((local_n = read(fd, buf, sizeof buf - 1)) < 0) {\t\\\n\tperror(filename);\t\t\t\t\t\\\n\tfflush(NULL);\t\t\t\t\t\t\\\n\t_exit(103);\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\\\n    buf[local_n] = '\\0';\t\t\t\t\t\\\n}while(0)\n\n/* evals 'x' twice */\n#define SET_IF_DESIRED(x,y) do{  if(x) *(x) = (y); }while(0)\n\n/* return minimum of two values */\n#ifndef __CYGWIN__\n#define MIN(x,y) ((x) < (y) ? (x) : (y))\n#endif\n\n/***********************************************************************/\nint uptime(double *restrict uptime_secs, double *restrict idle_secs) {\n    double up=0, idle=0;\n    char *savelocale;\n\n    FILE_TO_BUF(UPTIME_FILE,uptime_fd);\n    savelocale = strdup(setlocale(LC_NUMERIC, NULL));\n    setlocale(LC_NUMERIC,\"C\");\n    if (sscanf(buf, \"%lf %lf\", &up, &idle) < 2) {\n        setlocale(LC_NUMERIC,savelocale);\n        free(savelocale);\n        fputs(\"bad data in \" UPTIME_FILE \"\\n\", stderr);\n\t    return 0;\n    }\n    setlocale(LC_NUMERIC,savelocale);\n    free(savelocale);\n    SET_IF_DESIRED(uptime_secs, up);\n    SET_IF_DESIRED(idle_secs, idle);\n    return up;\t/* assume never be zero seconds in practice */\n}\n\nunsigned long getbtime(void) {\n    static unsigned long btime = 0;\n    bool found_btime = false;\n    FILE *f;\n\n    if (btime)\n\treturn btime;\n\n    /* /proc/stat can get very large on multi-CPU systems so we\n       can't use FILE_TO_BUF */\n    if (!(f = fopen(STAT_FILE, \"r\"))) {\n\tfputs(BAD_OPEN_MESSAGE, stderr);\n\tfflush(NULL);\n\t_exit(102);\n    }\n\n    while ((fgets(buf, sizeof buf, f))) {\n        if (sscanf(buf, \"btime %lu\", &btime) == 1) {\n            found_btime = true;\n            break;\n        }\n    }\n    fclose(f);\n\n    if (!found_btime) {\n\tfputs(\"missing btime in \" STAT_FILE \"\\n\", stderr);\n\texit(1);\n    }\n\n    return btime;\n}\n\n/***********************************************************************\n * Some values in /proc are expressed in units of 1/HZ seconds, where HZ\n * is the kernel clock tick rate. One of these units is called a jiffy.\n * The HZ value used in the kernel may vary according to hacker desire.\n * According to Linus Torvalds, this is not true. He considers the values\n * in /proc as being in architecture-dependent units that have no relation\n * to the kernel clock tick rate. Examination of the kernel source code\n * reveals that opinion as wishful thinking.\n *\n * In any case, we need the HZ constant as used in /proc. (the real HZ value\n * may differ, but we don't care) There are several ways we could get HZ:\n *\n * 1. Include the kernel header file. If it changes, recompile this library.\n * 2. Use the sysconf() function. When HZ changes, recompile the C library!\n * 3. Ask the kernel. This is obviously correct...\n *\n * Linus Torvalds won't let us ask the kernel, because he thinks we should\n * not know the HZ value. Oh well, we don't have to listen to him.\n * Someone smuggled out the HZ value. :-)\n *\n * This code should work fine, even if Linus fixes the kernel to match his\n * stated behavior. The code only fails in case of a partial conversion.\n *\n * Recent update: on some architectures, the 2.4 kernel provides an\n * ELF note to indicate HZ. This may be for ARM or user-mode Linux\n * support. This ought to be investigated. Note that sysconf() is still\n * unreliable, because it doesn't return an error code when it is\n * used with a kernel that doesn't support the ELF note. On some other\n * architectures there may be a system call or sysctl() that will work.\n */\n\nunsigned long long Hertz;\n\nstatic void old_Hertz_hack(void){\n  unsigned long long user_j, nice_j, sys_j, other_j, wait_j, hirq_j, sirq_j, stol_j;  /* jiffies (clock ticks) */\n  double up_1, up_2, seconds;\n  unsigned long long jiffies;\n  unsigned h;\n  char *savelocale;\n  long hz;\n\n#ifdef _SC_CLK_TCK\n  if((hz = sysconf(_SC_CLK_TCK)) > 0){\n    Hertz = hz;\n    return;\n  }\n#endif\n\n  wait_j = hirq_j = sirq_j = stol_j = 0;\n  savelocale = strdup(setlocale(LC_NUMERIC, NULL));\n  setlocale(LC_NUMERIC, \"C\");\n  do{\n    FILE_TO_BUF(UPTIME_FILE,uptime_fd);  sscanf(buf, \"%lf\", &up_1);\n    /* uptime(&up_1, NULL); */\n    FILE_TO_BUF(STAT_FILE,stat_fd);\n    sscanf(buf, \"cpu %llu %llu %llu %llu %llu %llu %llu %llu\", &user_j, &nice_j, &sys_j, &other_j, &wait_j, &hirq_j, &sirq_j, &stol_j);\n    FILE_TO_BUF(UPTIME_FILE,uptime_fd);  sscanf(buf, \"%lf\", &up_2);\n    /* uptime(&up_2, NULL); */\n  } while((long long)( (up_2-up_1)*1000.0/up_1 )); /* want under 0.1% error */\n  setlocale(LC_NUMERIC, savelocale);\n  free(savelocale);\n  jiffies = user_j + nice_j + sys_j + other_j + wait_j + hirq_j + sirq_j + stol_j ;\n  seconds = (up_1 + up_2) / 2;\n  h = (unsigned)( (double)jiffies/seconds/smp_num_cpus );\n  /* actual values used by 2.4 kernels: 32 64 100 128 1000 1024 1200 */\n  switch(h){\n  case    9 ...   11 :  Hertz =   10; break; /* S/390 (sometimes) */\n  case   18 ...   22 :  Hertz =   20; break; /* user-mode Linux */\n  case   30 ...   34 :  Hertz =   32; break; /* ia64 emulator */\n  case   48 ...   52 :  Hertz =   50; break;\n  case   58 ...   61 :  Hertz =   60; break;\n  case   62 ...   65 :  Hertz =   64; break; /* StrongARM /Shark */\n  case   95 ...  105 :  Hertz =  100; break; /* normal Linux */\n  case  124 ...  132 :  Hertz =  128; break; /* MIPS, ARM */\n  case  195 ...  204 :  Hertz =  200; break; /* normal << 1 */\n  case  247 ...  252 :  Hertz =  250; break;\n  case  253 ...  260 :  Hertz =  256; break;\n  case  393 ...  408 :  Hertz =  400; break; /* normal << 2 */\n  case  410 ...  600 :  Hertz =  500; break; /* SMP WinNT */\n  case  790 ...  808 :  Hertz =  800; break; /* normal << 3 */\n  case  990 ... 1010 :  Hertz = 1000; break; /* ARM */\n  case 1015 ... 1035 :  Hertz = 1024; break; /* Alpha, ia64 */\n  case 1180 ... 1220 :  Hertz = 1200; break; /* Alpha */\n  default:\n#ifdef HZ\n    Hertz = (unsigned long long)HZ;    /* <asm/param.h> */\n#else\n    /* If 32-bit or big-endian (not Alpha or ia64), assume HZ is 100. */\n    Hertz = (sizeof(long)==sizeof(int) || htons(999)==999) ? 100UL : 1024UL;\n#endif\n    fprintf(stderr, \"Unknown HZ value! (%d) Assume %Ld.\\n\", h, Hertz);\n  }\n}\n\n// same as:   euid != uid || egid != gid\n#ifndef AT_SECURE\n#define AT_SECURE      23     // secure mode boolean (true if setuid, etc.)\n#endif\n\n#ifndef AT_CLKTCK\n#define AT_CLKTCK       17    // frequency of times()\n#endif\n\n#define NOTE_NOT_FOUND 42\n\nextern char** environ;\n\nstatic unsigned long find_elf_note(unsigned long type)\n{\n#ifdef __CYGWIN__\n  return NOTE_NOT_FOUND;\n#else\n  ElfW(auxv_t) auxv_struct;\n  ElfW(auxv_t) *auxv_temp;\n  FILE *fd;\n  int i;\n  static ElfW(auxv_t) *auxv = NULL;\n  unsigned long *ep = (unsigned long *)environ;\n  unsigned long ret_val = NOTE_NOT_FOUND;\n\n\n  if(!auxv) {\n\n    fd = fopen(\"/proc/self/auxv\", \"rb\");\n\n    if(!fd) {  // can't open auxv? that could be caused by euid change\n               // ... and we need to fall back to the old and unsafe\n               // ... method that doesn't work when calling library\n               // ... functions with dlopen -> FIXME :(\n\n      while(*ep++);  // for ELF executables, notes are pushed\n      while(*ep){    // ... before environment and args\n        if(ep[0]==type) return ep[1];\n        ep+=2;\n      }\n      return NOTE_NOT_FOUND;\n    }\n\n    auxv = (ElfW(auxv_t) *) malloc(getpagesize());\n    if (!auxv) {\n      perror(\"malloc\");\n      exit(EXIT_FAILURE);\n    }\n\n    i = 0;\n    do {\n      fread(&auxv_struct, sizeof(ElfW(auxv_t)), 1, fd);\n      auxv[i] = auxv_struct;\n      i++;\n    } while (auxv_struct.a_type != AT_NULL);\n\n    fclose(fd);\n\n  }\n\n  auxv_temp = auxv;\n  i = 0;\n  do {\n    if(auxv_temp[i].a_type == type) {\n      ret_val = (unsigned long)auxv_temp[i].a_un.a_val;\n      break;\n    }\n    i++;\n  } while (auxv_temp[i].a_type != AT_NULL);\n\n  if (auxv){\n\t  auxv_temp = NULL;\n\t  free(auxv);\n\t  auxv = NULL;\n  }\n  return ret_val;\n#endif\n}\n\nint have_privs;\n\nstatic int check_for_privs(void){\n  unsigned long rc = find_elf_note(AT_SECURE);\n  if(rc==NOTE_NOT_FOUND){\n    // not valid to run this code after UID or GID change!\n    // (if needed, may use AT_UID and friends instead)\n    rc = geteuid() != getuid() || getegid() != getgid();\n  }\n  return !!rc;\n}\n\nstatic void init_libproc(void) __attribute__((constructor));\nstatic void init_libproc(void){\n  have_privs = check_for_privs();\n  int linux_version_code = procps_linux_version();\n\n  cpuinfo();\n  page_bytes = sysconf(_SC_PAGESIZE);\n\n#ifdef __linux__\n  if(linux_version_code > LINUX_VERSION(2, 4, 0)){\n    Hertz = find_elf_note(AT_CLKTCK);\n    if(Hertz!=NOTE_NOT_FOUND) return;\n//  fputs(\"2.4+ kernel w/o ELF notes? -- report this\\n\", stderr);\n  }\n#endif /* __linux __ */\n#if defined(__FreeBSD_kernel__) || defined(__FreeBSD__)\n  /* On FreeBSD the Hertz hack is unrelaible, there is no ELF note and\n   * Hertz isn't defined in asm/params.h\n   * See Debian Bug #460331\n   */\n  Hertz = 100;\n  return;\n#endif /* __FreeBSD__ */\n#ifdef __CYGWIN__\n  // On Cygwin we can rely on the HZ value given in sys/param.h\n  Hertz = (unsigned long long)HZ;    /* <sys/param.h> */\n  return;\n#endif\n  old_Hertz_hack();\n}\n\n#if 0\n/***********************************************************************\n * The /proc filesystem calculates idle=jiffies-(user+nice+sys) and we\n * recover jiffies by adding up the 4 or 5 numbers we are given. SMP kernels\n * (as of pre-2.4 era) can report idle time going backwards, perhaps due\n * to non-atomic reads and updates. There is no locking for these values.\n */\n#ifndef NAN\n#define NAN (-0.0)\n#endif\n#define JT unsigned long long\nvoid eight_cpu_numbers(double *restrict uret, double *restrict nret, double *restrict sret, double *restrict iret, double *restrict wret, double *restrict xret, double *restrict yret, double *restrict zret){\n    double tmp_u, tmp_n, tmp_s, tmp_i, tmp_w, tmp_x, tmp_y, tmp_z;\n    double scale;  /* scale values to % */\n    static JT old_u, old_n, old_s, old_i, old_w, old_x, old_y, old_z;\n    JT new_u, new_n, new_s, new_i, new_w, new_x, new_y, new_z;\n    JT ticks_past; /* avoid div-by-0 by not calling too often :-( */\n\n    tmp_w = 0.0;\n    new_w = 0;\n    tmp_x = 0.0;\n    new_x = 0;\n    tmp_y = 0.0;\n    new_y = 0;\n    tmp_z = 0.0;\n    new_z = 0;\n\n    FILE_TO_BUF(STAT_FILE,stat_fd);\n    sscanf(buf, \"cpu %llu %llu %llu %llu %llu %llu %llu %llu\", &new_u, &new_n, &new_s, &new_i, &new_w, &new_x, &new_y, &new_z);\n    ticks_past = (new_u+new_n+new_s+new_i+new_w+new_x+new_y+new_z)-(old_u+old_n+old_s+old_i+old_w+old_x+old_y+old_z);\n    if(ticks_past){\n      scale = 100.0 / (double)ticks_past;\n      tmp_u = ( (double)new_u - (double)old_u ) * scale;\n      tmp_n = ( (double)new_n - (double)old_n ) * scale;\n      tmp_s = ( (double)new_s - (double)old_s ) * scale;\n      tmp_i = ( (double)new_i - (double)old_i ) * scale;\n      tmp_w = ( (double)new_w - (double)old_w ) * scale;\n      tmp_x = ( (double)new_x - (double)old_x ) * scale;\n      tmp_y = ( (double)new_y - (double)old_y ) * scale;\n      tmp_z = ( (double)new_z - (double)old_z ) * scale;\n    }else{\n      tmp_u = NAN;\n      tmp_n = NAN;\n      tmp_s = NAN;\n      tmp_i = NAN;\n      tmp_w = NAN;\n      tmp_x = NAN;\n      tmp_y = NAN;\n      tmp_z = NAN;\n    }\n    SET_IF_DESIRED(uret, tmp_u);\n    SET_IF_DESIRED(nret, tmp_n);\n    SET_IF_DESIRED(sret, tmp_s);\n    SET_IF_DESIRED(iret, tmp_i);\n    SET_IF_DESIRED(wret, tmp_w);\n    SET_IF_DESIRED(xret, tmp_x);\n    SET_IF_DESIRED(yret, tmp_y);\n    SET_IF_DESIRED(zret, tmp_z);\n    old_u=new_u;\n    old_n=new_n;\n    old_s=new_s;\n    old_i=new_i;\n    old_w=new_w;\n    old_x=new_x;\n    old_y=new_y;\n    old_z=new_z;\n}\n#undef JT\n#endif\n\n/***********************************************************************/\nvoid loadavg(double *restrict av1, double *restrict av5, double *restrict av15) {\n    double avg_1=0, avg_5=0, avg_15=0;\n    char *savelocale;\n\n    FILE_TO_BUF(LOADAVG_FILE,loadavg_fd);\n    savelocale = strdup(setlocale(LC_NUMERIC, NULL));\n    setlocale(LC_NUMERIC, \"C\");\n    if (sscanf(buf, \"%lf %lf %lf\", &avg_1, &avg_5, &avg_15) < 3) {\n\tfputs(\"bad data in \" LOADAVG_FILE \"\\n\", stderr);\n\tfree(savelocale);\n\texit(1);\n    }\n    setlocale(LC_NUMERIC, savelocale);\n    free(savelocale);\n    SET_IF_DESIRED(av1,  avg_1);\n    SET_IF_DESIRED(av5,  avg_5);\n    SET_IF_DESIRED(av15, avg_15);\n}\n\n  static char buff[BUFFSIZE]; /* used in the procedures */\n/***********************************************************************/\n\nstatic void crash(const char *filename) {\n    perror(filename);\n    exit(EXIT_FAILURE);\n}\n\n/***********************************************************************/\n\nstatic void getrunners(unsigned int *restrict running, unsigned int *restrict blocked) {\n  struct dirent *ent;\n  DIR *proc;\n\n  *running=0;\n  *blocked=0;\n\n  if((proc=opendir(\"/proc\"))==NULL) crash(\"/proc\");\n\n  while(( ent=readdir(proc) )) {\n    char tbuf[32];\n    char *cp;\n    int fd;\n    char c;\n\n    if (!isdigit(ent->d_name[0])) continue;\n    sprintf(tbuf, \"/proc/%s/stat\", ent->d_name);\n\n    fd = open(tbuf, O_RDONLY, 0);\n    if (fd == -1) continue;\n    memset(tbuf, '\\0', sizeof tbuf); // didn't feel like checking read()\n    read(fd, tbuf, sizeof tbuf - 1); // need 32 byte buffer at most\n    close(fd);\n\n    cp = strrchr(tbuf, ')');\n    if(!cp) continue;\n    c = cp[2];\n\n    if (c=='R') {\n      (*running)++;\n      continue;\n    }\n    if (c=='D') {\n      (*blocked)++;\n      continue;\n    }\n  }\n  closedir(proc);\n}\n\n/***********************************************************************/\n\nvoid getstat(jiff *restrict cuse, jiff *restrict cice, jiff *restrict csys, jiff *restrict cide, jiff *restrict ciow, jiff *restrict cxxx, jiff *restrict cyyy, jiff *restrict czzz,\n\t     unsigned long *restrict pin, unsigned long *restrict pout, unsigned long *restrict s_in, unsigned long *restrict sout,\n\t     unsigned *restrict intr, unsigned *restrict ctxt,\n\t     unsigned int *restrict running, unsigned int *restrict blocked,\n\t     unsigned int *restrict btime, unsigned int *restrict processes) {\n  static int fd;\n  unsigned long long llbuf = 0;\n  int need_vmstat_file = 0;\n  int need_proc_scan = 0;\n  const char* b;\n  memset(buff, '\\0', BUFFSIZE);  /* ensure null termination in buffer */\n\n  if(fd){\n    lseek(fd, 0L, SEEK_SET);\n  }else{\n    fd = open(\"/proc/stat\", O_RDONLY, 0);\n    if(fd == -1) crash(\"/proc/stat\");\n  }\n  read(fd,buff,BUFFSIZE-1);\n  *intr = 0;\n  *ciow = 0;  /* not separated out until the 2.5.41 kernel */\n  *cxxx = 0;  /* not separated out until the 2.6.0-test4 kernel */\n  *cyyy = 0;  /* not separated out until the 2.6.0-test4 kernel */\n  *czzz = 0;  /* not separated out until the 2.6.11 kernel */\n\n  b = strstr(buff, \"cpu \");\n  if(b) sscanf(b,  \"cpu  %llu %llu %llu %llu %llu %llu %llu %llu\", cuse, cice, csys, cide, ciow, cxxx, cyyy, czzz);\n\n  b = strstr(buff, \"page \");\n  if(b) sscanf(b,  \"page %lu %lu\", pin, pout);\n  else need_vmstat_file = 1;\n\n  b = strstr(buff, \"swap \");\n  if(b) sscanf(b,  \"swap %lu %lu\", s_in, sout);\n  else need_vmstat_file = 1;\n\n  b = strstr(buff, \"intr \");\n  if(b) sscanf(b,  \"intr %llu\", &llbuf);\n  *intr = llbuf;\n\n  b = strstr(buff, \"ctxt \");\n  if(b) sscanf(b,  \"ctxt %llu\", &llbuf);\n  *ctxt = llbuf;\n\n  b = strstr(buff, \"btime \");\n  if(b) sscanf(b,  \"btime %u\", btime);\n\n  b = strstr(buff, \"processes \");\n  if(b) sscanf(b,  \"processes %u\", processes);\n\n  b = strstr(buff, \"procs_running \");\n  if(b) sscanf(b,  \"procs_running %u\", running);\n  else need_proc_scan = 1;\n\n  b = strstr(buff, \"procs_blocked \");\n  if(b) sscanf(b,  \"procs_blocked %u\", blocked);\n  else need_proc_scan = 1;\n\n  if(need_proc_scan){   /* Linux 2.5.46 (approximately) and below */\n    getrunners(running, blocked);\n  }\n\n  if(*running)\n    (*running)--;   // exclude vmstat itself\n\n  if(need_vmstat_file){  /* Linux 2.5.40-bk4 and above */\n    vminfo();\n    *pin  = vm_pgpgin;\n    *pout = vm_pgpgout;\n    *s_in = vm_pswpin;\n    *sout = vm_pswpout;\n  }\n}\n\n/***********************************************************************/\n/*\n * Copyright 1999 by Albert Cahalan; all rights reserved.\n * This file may be used subject to the terms and conditions of the\n * GNU Library General Public License Version 2, or any later version\n * at your option, as published by the Free Software Foundation.\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Library General Public License for more details.\n */\n\ntypedef struct mem_table_struct {\n  const char *name;     /* memory type name */\n  unsigned long *slot; /* slot in return struct */\n} mem_table_struct;\n\nstatic int compare_mem_table_structs(const void *a, const void *b){\n  return strcmp(((const mem_table_struct*)a)->name,((const mem_table_struct*)b)->name);\n}\n\n/* example data, following junk, with comments added:\n *\n * MemTotal:        61768 kB    old\n * MemFree:          1436 kB    old\n * Buffers:          1312 kB    old\n * Cached:          20932 kB    old\n * Active:          12464 kB    new\n * Inact_dirty:      7772 kB    new\n * Inact_clean:      2008 kB    new\n * Inact_target:        0 kB    new\n * Inact_laundry:       0 kB    new, and might be missing too\n * HighTotal:           0 kB\n * HighFree:            0 kB\n * LowTotal:        61768 kB\n * LowFree:          1436 kB\n * SwapTotal:      122580 kB    old\n * SwapFree:        60352 kB    old\n * Inactive:        20420 kB    2.5.41+\n * Dirty:               0 kB    2.5.41+\n * Writeback:           0 kB    2.5.41+\n * Mapped:           9792 kB    2.5.41+\n * Shmem:              28 kB    2.6.32+\n * Slab:             4564 kB    2.5.41+\n * Committed_AS:     8440 kB    2.5.41+\n * PageTables:        304 kB    2.5.41+\n * ReverseMaps:      5738       2.5.41+\n * SwapCached:          0 kB    2.5.??+\n * HugePages_Total:   220       2.5.??+\n * HugePages_Free:    138       2.5.??+\n * Hugepagesize:     4096 kB    2.5.??+\n */\n\n/* Shmem in 2.6.32+ */\nunsigned long kb_main_shared;\n/* old but still kicking -- the important stuff */\nstatic unsigned long kb_page_cache;\nunsigned long kb_main_buffers;\nunsigned long kb_main_free;\nunsigned long kb_main_total;\nunsigned long kb_swap_free;\nunsigned long kb_swap_total;\n/* recently introduced */\nunsigned long kb_high_free;\nunsigned long kb_high_total;\nunsigned long kb_low_free;\nunsigned long kb_low_total;\nunsigned long kb_main_available;\n/* 2.4.xx era */\nunsigned long kb_active;\nunsigned long kb_inact_laundry;\nunsigned long kb_inact_dirty;\nunsigned long kb_inact_clean;\nunsigned long kb_inact_target;\nunsigned long kb_swap_cached;  /* late 2.4 and 2.6+ only */\n/* derived values */\nunsigned long kb_main_cached;\nunsigned long kb_swap_used;\nunsigned long kb_main_used;\n/* 2.5.41+ */\nunsigned long kb_writeback;\nunsigned long kb_slab;\nunsigned long nr_reversemaps;\nunsigned long kb_committed_as;\nunsigned long kb_dirty;\nunsigned long kb_inactive;\nunsigned long kb_mapped;\nunsigned long kb_pagetables;\n// seen on a 2.6.x kernel:\nstatic unsigned long kb_vmalloc_chunk;\nstatic unsigned long kb_vmalloc_total;\nstatic unsigned long kb_vmalloc_used;\n// seen on 2.6.24-rc6-git12\nstatic unsigned long kb_anon_pages;\nstatic unsigned long kb_bounce;\nstatic unsigned long kb_commit_limit;\nstatic unsigned long kb_nfs_unstable;\n// seen on 2.6.18\nstatic unsigned long kb_min_free;\n// 2.6.19+\nstatic unsigned long kb_slab_reclaimable;\nstatic unsigned long kb_slab_unreclaimable;\n// 2.6.27+\nstatic unsigned long kb_active_file;\nstatic unsigned long kb_inactive_file;\n\n\nvoid meminfo(void){\n  char namebuf[32]; /* big enough to hold any row name */\n  int linux_version_code = procps_linux_version();\n  mem_table_struct findme = { namebuf, NULL};\n  mem_table_struct *found;\n  char *head;\n  char *tail;\n  static const mem_table_struct mem_table[] = {\n  {\"Active\",       &kb_active},       // important\n  {\"Active(file)\", &kb_active_file},\n  {\"AnonPages\",    &kb_anon_pages},\n  {\"Bounce\",       &kb_bounce},\n  {\"Buffers\",      &kb_main_buffers}, // important\n  {\"Cached\",       &kb_page_cache},  // important\n  {\"CommitLimit\",  &kb_commit_limit},\n  {\"Committed_AS\", &kb_committed_as},\n  {\"Dirty\",        &kb_dirty},        // kB version of vmstat nr_dirty\n  {\"HighFree\",     &kb_high_free},\n  {\"HighTotal\",    &kb_high_total},\n  {\"Inact_clean\",  &kb_inact_clean},\n  {\"Inact_dirty\",  &kb_inact_dirty},\n  {\"Inact_laundry\",&kb_inact_laundry},\n  {\"Inact_target\", &kb_inact_target},\n  {\"Inactive\",     &kb_inactive},     // important\n  {\"Inactive(file)\",&kb_inactive_file},\n  {\"LowFree\",      &kb_low_free},\n  {\"LowTotal\",     &kb_low_total},\n  {\"Mapped\",       &kb_mapped},       // kB version of vmstat nr_mapped\n  {\"MemAvailable\", &kb_main_available}, // important\n  {\"MemFree\",      &kb_main_free},    // important\n  {\"MemTotal\",     &kb_main_total},   // important\n  {\"NFS_Unstable\", &kb_nfs_unstable},\n  {\"PageTables\",   &kb_pagetables},   // kB version of vmstat nr_page_table_pages\n  {\"ReverseMaps\",  &nr_reversemaps},  // same as vmstat nr_page_table_pages\n  {\"SReclaimable\", &kb_slab_reclaimable}, // \"slab reclaimable\" (dentry and inode structures)\n  {\"SUnreclaim\",   &kb_slab_unreclaimable},\n  {\"Shmem\",        &kb_main_shared},  // kernel 2.6.32 and later\n  {\"Slab\",         &kb_slab},         // kB version of vmstat nr_slab\n  {\"SwapCached\",   &kb_swap_cached},\n  {\"SwapFree\",     &kb_swap_free},    // important\n  {\"SwapTotal\",    &kb_swap_total},   // important\n  {\"VmallocChunk\", &kb_vmalloc_chunk},\n  {\"VmallocTotal\", &kb_vmalloc_total},\n  {\"VmallocUsed\",  &kb_vmalloc_used},\n  {\"Writeback\",    &kb_writeback},    // kB version of vmstat nr_writeback\n  };\n  const int mem_table_count = sizeof(mem_table)/sizeof(mem_table_struct);\n  unsigned long watermark_low;\n  signed long mem_available, mem_used;\n\n  FILE_TO_BUF(MEMINFO_FILE,meminfo_fd);\n\n  kb_inactive = ~0UL;\n  kb_low_total = kb_main_available = 0;\n\n  head = buf;\n  for(;;){\n    tail = strchr(head, ':');\n    if(!tail) break;\n    *tail = '\\0';\n    if(strlen(head) >= sizeof(namebuf)){\n      head = tail+1;\n      goto nextline;\n    }\n    strcpy(namebuf,head);\n    found = bsearch(&findme, mem_table, mem_table_count,\n        sizeof(mem_table_struct), compare_mem_table_structs\n    );\n    head = tail+1;\n    if(!found) goto nextline;\n    *(found->slot) = (unsigned long)strtoull(head,&tail,10);\nnextline:\n    tail = strchr(head, '\\n');\n    if(!tail) break;\n    head = tail+1;\n  }\n  if(!kb_low_total){  /* low==main except with large-memory support */\n    kb_low_total = kb_main_total;\n    kb_low_free  = kb_main_free;\n  }\n  if(kb_inactive==~0UL){\n    kb_inactive = kb_inact_dirty + kb_inact_clean + kb_inact_laundry;\n  }\n  kb_main_cached = kb_page_cache + kb_slab_reclaimable;\n  kb_swap_used = kb_swap_total - kb_swap_free;\n\n  /* if kb_main_available is greater than kb_main_total or our calculation of\n     mem_used overflows, that's symptomatic of running within a lxc container\n     where such values will be dramatically distorted over those of the host. */\n  if (kb_main_available > kb_main_total)\n    kb_main_available = kb_main_free;\n  mem_used = kb_main_total - kb_main_free - kb_main_cached - kb_main_buffers;\n  if (mem_used < 0)\n    mem_used = kb_main_total - kb_main_free;\n  kb_main_used = (unsigned long)mem_used;\n\n  /* zero? might need fallback for 2.6.27 <= kernel <? 3.14 */\n  if (!kb_main_available) {\n#ifdef __linux__\n    if (linux_version_code < LINUX_VERSION(2, 6, 27))\n      kb_main_available = kb_main_free;\n    else {\n      FILE_TO_BUF(VM_MIN_FREE_FILE, vm_min_free_fd);\n      kb_min_free = (unsigned long) strtoull(buf,&tail,10);\n\n      watermark_low = kb_min_free * 5 / 4; /* should be equal to sum of all 'low' fields in /proc/zoneinfo */\n\n      mem_available = (signed long)kb_main_free - watermark_low\n      + kb_inactive_file + kb_active_file - MIN((kb_inactive_file + kb_active_file) / 2, watermark_low)\n      + kb_slab_reclaimable - MIN(kb_slab_reclaimable / 2, watermark_low);\n\n      if (mem_available < 0) mem_available = 0;\n      kb_main_available = (unsigned long)mem_available;\n    }\n#else\n      kb_main_available = kb_main_free;\n#endif /* linux */\n  }\n}\n\n/*****************************************************************/\n\n/* read /proc/vminfo only for 2.5.41 and above */\n\ntypedef struct vm_table_struct {\n  const char *name;     /* VM statistic name */\n  unsigned long *slot;       /* slot in return struct */\n} vm_table_struct;\n\nstatic int compare_vm_table_structs(const void *a, const void *b){\n  return strcmp(((const vm_table_struct*)a)->name,((const vm_table_struct*)b)->name);\n}\n\n// see include/linux/page-flags.h and mm/page_alloc.c\nunsigned long vm_nr_dirty;           // dirty writable pages\nunsigned long vm_nr_writeback;       // pages under writeback\nunsigned long vm_nr_pagecache;       // pages in pagecache -- gone in 2.5.66+ kernels\nunsigned long vm_nr_page_table_pages;// pages used for pagetables\nunsigned long vm_nr_reverse_maps;    // includes PageDirect\nunsigned long vm_nr_mapped;          // mapped into pagetables\nunsigned long vm_nr_slab;            // in slab\nunsigned long vm_nr_slab_reclaimable;  // 2.6.19+ kernels\nunsigned long vm_nr_slab_unreclaimable;// 2.6.19+ kernels\nunsigned long vm_nr_active_file;       // 2.6.27+ kernels\nunsigned long vm_nr_inactive_file;     // 2.6.27+ kernels\nunsigned long vm_nr_free_pages;        // 2.6.21+ kernels\nunsigned long vm_pgpgin;             // kB disk reads  (same as 1st num on /proc/stat page line)\nunsigned long vm_pgpgout;            // kB disk writes (same as 2nd num on /proc/stat page line)\nunsigned long vm_pswpin;             // swap reads     (same as 1st num on /proc/stat swap line)\nunsigned long vm_pswpout;            // swap writes    (same as 2nd num on /proc/stat swap line)\nunsigned long vm_pgalloc;            // page allocations\nunsigned long vm_pgfree;             // page freeings\nunsigned long vm_pgactivate;         // pages moved inactive -> active\nunsigned long vm_pgdeactivate;       // pages moved active -> inactive\nunsigned long vm_pgfault;           // total faults (major+minor)\nunsigned long vm_pgmajfault;       // major faults\nunsigned long vm_pgscan;          // pages scanned by page reclaim\nunsigned long vm_pgrefill;       // inspected by refill_inactive_zone\nunsigned long vm_pgsteal;       // total pages reclaimed\nunsigned long vm_kswapd_steal; // pages reclaimed by kswapd\n// next 3 as defined by the 2.5.52 kernel\nunsigned long vm_pageoutrun;  // times kswapd ran page reclaim\nunsigned long vm_allocstall; // times a page allocator ran direct reclaim\nunsigned long vm_pgrotated; // pages rotated to the tail of the LRU for immediate reclaim\n// seen on a 2.6.8-rc1 kernel, apparently replacing old fields\nstatic unsigned long vm_pgalloc_dma;          //\nstatic unsigned long vm_pgalloc_high;         //\nstatic unsigned long vm_pgalloc_normal;       //\nstatic unsigned long vm_pgrefill_dma;         //\nstatic unsigned long vm_pgrefill_high;        //\nstatic unsigned long vm_pgrefill_normal;      //\nstatic unsigned long vm_pgscan_direct_dma;    //\nstatic unsigned long vm_pgscan_direct_high;   //\nstatic unsigned long vm_pgscan_direct_normal; //\nstatic unsigned long vm_pgscan_kswapd_dma;    //\nstatic unsigned long vm_pgscan_kswapd_high;   //\nstatic unsigned long vm_pgscan_kswapd_normal; //\nstatic unsigned long vm_pgsteal_dma;          //\nstatic unsigned long vm_pgsteal_high;         //\nstatic unsigned long vm_pgsteal_normal;       //\n// seen on a 2.6.8-rc1 kernel\nstatic unsigned long vm_kswapd_inodesteal;    //\nstatic unsigned long vm_nr_unstable;          //\nstatic unsigned long vm_pginodesteal;         //\nstatic unsigned long vm_slabs_scanned;        //\n\nvoid vminfo(void){\n  char namebuf[32]; /* big enough to hold any row name */\n  vm_table_struct findme = { namebuf, NULL};\n  vm_table_struct *found;\n  char *head;\n  char *tail;\n  static const vm_table_struct vm_table[] = {\n  {\"allocstall\",          &vm_allocstall},\n  {\"kswapd_inodesteal\",   &vm_kswapd_inodesteal},\n  {\"kswapd_steal\",        &vm_kswapd_steal},\n  {\"nr_active_file\",      &vm_nr_active_file},     // 2.6.27+ kernels\n  {\"nr_dirty\",            &vm_nr_dirty},           // page version of meminfo Dirty\n  {\"nr_free_pages\",       &vm_nr_free_pages},      // 2.6.21+ kernels\n  {\"nr_inactive_file\",    &vm_nr_inactive_file},   // 2.6.27+ kernels\n  {\"nr_mapped\",           &vm_nr_mapped},          // page version of meminfo Mapped\n  {\"nr_page_table_pages\", &vm_nr_page_table_pages},// same as meminfo PageTables\n  {\"nr_pagecache\",        &vm_nr_pagecache},       // gone in 2.5.66+ kernels\n  {\"nr_reverse_maps\",     &vm_nr_reverse_maps},    // page version of meminfo ReverseMaps GONE\n  {\"nr_slab\",             &vm_nr_slab},            // page version of meminfo Slab (gone in 2.6.19+)\n  {\"nr_slab_reclaimable\", &vm_nr_slab_reclaimable},// 2.6.19+ kernels\n {\"nr_slab_unreclaimable\",&vm_nr_slab_unreclaimable},// 2.6.19+ kernels\n  {\"nr_unstable\",         &vm_nr_unstable},\n  {\"nr_writeback\",        &vm_nr_writeback},       // page version of meminfo Writeback\n  {\"pageoutrun\",          &vm_pageoutrun},\n  {\"pgactivate\",          &vm_pgactivate},\n  {\"pgalloc\",             &vm_pgalloc},  // GONE (now separate dma,high,normal)\n  {\"pgalloc_dma\",         &vm_pgalloc_dma},\n  {\"pgalloc_high\",        &vm_pgalloc_high},\n  {\"pgalloc_normal\",      &vm_pgalloc_normal},\n  {\"pgdeactivate\",        &vm_pgdeactivate},\n  {\"pgfault\",             &vm_pgfault},\n  {\"pgfree\",              &vm_pgfree},\n  {\"pginodesteal\",        &vm_pginodesteal},\n  {\"pgmajfault\",          &vm_pgmajfault},\n  {\"pgpgin\",              &vm_pgpgin},     // important\n  {\"pgpgout\",             &vm_pgpgout},     // important\n  {\"pgrefill\",            &vm_pgrefill},  // GONE (now separate dma,high,normal)\n  {\"pgrefill_dma\",        &vm_pgrefill_dma},\n  {\"pgrefill_high\",       &vm_pgrefill_high},\n  {\"pgrefill_normal\",     &vm_pgrefill_normal},\n  {\"pgrotated\",           &vm_pgrotated},\n  {\"pgscan\",              &vm_pgscan},  // GONE (now separate direct,kswapd and dma,high,normal)\n  {\"pgscan_direct_dma\",   &vm_pgscan_direct_dma},\n  {\"pgscan_direct_high\",  &vm_pgscan_direct_high},\n  {\"pgscan_direct_normal\",&vm_pgscan_direct_normal},\n  {\"pgscan_kswapd_dma\",   &vm_pgscan_kswapd_dma},\n  {\"pgscan_kswapd_high\",  &vm_pgscan_kswapd_high},\n  {\"pgscan_kswapd_normal\",&vm_pgscan_kswapd_normal},\n  {\"pgsteal\",             &vm_pgsteal},  // GONE (now separate dma,high,normal)\n  {\"pgsteal_dma\",         &vm_pgsteal_dma},\n  {\"pgsteal_high\",        &vm_pgsteal_high},\n  {\"pgsteal_normal\",      &vm_pgsteal_normal},\n  {\"pswpin\",              &vm_pswpin},     // important\n  {\"pswpout\",             &vm_pswpout},     // important\n  {\"slabs_scanned\",       &vm_slabs_scanned},\n  };\n  const int vm_table_count = sizeof(vm_table)/sizeof(vm_table_struct);\n\n#if __SIZEOF_LONG__ == 4\n  unsigned long long slotll;\n#endif\n\n  vm_pgalloc = 0;\n  vm_pgrefill = 0;\n  vm_pgscan = 0;\n  vm_pgsteal = 0;\n\n  FILE_TO_BUF(VMINFO_FILE,vminfo_fd);\n\n  head = buf;\n  for(;;){\n    tail = strchr(head, ' ');\n    if(!tail) break;\n    *tail = '\\0';\n    if(strlen(head) >= sizeof(namebuf)){\n      head = tail+1;\n      goto nextline;\n    }\n    strcpy(namebuf,head);\n    found = bsearch(&findme, vm_table, vm_table_count,\n        sizeof(vm_table_struct), compare_vm_table_structs\n    );\n    head = tail+1;\n    if(!found) goto nextline;\n#if __SIZEOF_LONG__ == 4\n    // A 32 bit kernel would have already truncated the value, a 64 bit kernel\n    // doesn't need to.  Truncate here to let 32 bit programs to continue to get\n    // truncated values.  It's that or change the API for a larger data type.\n    slotll = strtoull(head,&tail,10);\n    *(found->slot) = (unsigned long)slotll;\n#else\n    *(found->slot) = strtoul(head,&tail,10);\n#endif\nnextline:\n\n//if(found) fprintf(stderr,\"%s=%d\\n\",found->name,*(found->slot));\n//else      fprintf(stderr,\"%s not found\\n\",findme.name);\n\n    tail = strchr(head, '\\n');\n    if(!tail) break;\n    head = tail+1;\n  }\n  if(!vm_pgalloc)\n    vm_pgalloc  = vm_pgalloc_dma + vm_pgalloc_high + vm_pgalloc_normal;\n  if(!vm_pgrefill)\n    vm_pgrefill = vm_pgrefill_dma + vm_pgrefill_high + vm_pgrefill_normal;\n  if(!vm_pgscan)\n    vm_pgscan   = vm_pgscan_direct_dma + vm_pgscan_direct_high + vm_pgscan_direct_normal\n                + vm_pgscan_kswapd_dma + vm_pgscan_kswapd_high + vm_pgscan_kswapd_normal;\n  if(!vm_pgsteal)\n    vm_pgsteal  = vm_pgsteal_dma + vm_pgsteal_high + vm_pgsteal_normal;\n}\n\n///////////////////////////////////////////////////////////////////////\n// based on Fabian Frederick's /proc/diskstats parser\n\n\nunsigned int getpartitions_num(struct disk_stat *disks, int ndisks){\n  int i=0;\n  int partitions=0;\n\n  for (i=0;i<ndisks;i++){\n\tpartitions+=disks[i].partitions;\n  }\n  return partitions;\n\n}\n\n/////////////////////////////////////////////////////////////////////////////\nstatic int is_disk(char *dev)\n{\n  char syspath[64];\n  char *slash;\n\n  while ((slash = strchr(dev, '/')))\n    *slash = '!';\n  snprintf(syspath, sizeof(syspath), \"/sys/block/%s\", dev);\n  return !(access(syspath, F_OK));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\nunsigned int getdiskstat(struct disk_stat **disks, struct partition_stat **partitions){\n  FILE* fd;\n  int cDisk = 0;\n  int cPartition = 0;\n  int fields;\n  unsigned dummy;\n  char devname[35];\n\n  *disks = NULL;\n  *partitions = NULL;\n  buff[BUFFSIZE-1] = 0;\n  fd = fopen(\"/proc/diskstats\", \"rb\");\n  if(!fd) crash(\"/proc/diskstats\");\n\n  for (;;) {\n    if (!fgets(buff,BUFFSIZE-1,fd)){\n      fclose(fd);\n      break;\n    }\n    fields = sscanf(buff, \" %*d %*d %34s %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %u\", devname, &dummy);\n    if (fields == 2 && is_disk(devname)){\n      if (cDisk < 0 || (size_t)cDisk >= INT_MAX / sizeof(struct disk_stat)) {\n        errno = EFBIG;\n        crash(\"/proc/diskstats\");\n      }\n      (*disks) = xrealloc(*disks, (cDisk+1)*sizeof(struct disk_stat));\n      sscanf(buff,  \"   %*d    %*d %31s %u %u %llu %u %u %u %llu %u %u %u %u\",\n        //&disk_major,\n        //&disk_minor,\n        (*disks)[cDisk].disk_name,\n        &(*disks)[cDisk].reads,\n        &(*disks)[cDisk].merged_reads,\n        &(*disks)[cDisk].reads_sectors,\n        &(*disks)[cDisk].milli_reading,\n        &(*disks)[cDisk].writes,\n        &(*disks)[cDisk].merged_writes,\n        &(*disks)[cDisk].written_sectors,\n        &(*disks)[cDisk].milli_writing,\n        &(*disks)[cDisk].inprogress_IO,\n        &(*disks)[cDisk].milli_spent_IO,\n        &(*disks)[cDisk].weighted_milli_spent_IO\n      );\n        (*disks)[cDisk].partitions=0;\n      cDisk++;\n    }else{\n      if (cPartition < 0 || (size_t)cPartition >= INT_MAX / sizeof(struct partition_stat)) {\n        errno = EFBIG;\n        crash(\"/proc/diskstats\");\n      }\n      (*partitions) = xrealloc(*partitions, (cPartition+1)*sizeof(struct partition_stat));\n      fflush(stdout);\n      sscanf(buff,  (fields == 2)\n          ? \"   %*d    %*d %34s %u %*u %llu %*u %u %*u %llu %*u %*u %*u %*u\"\n          : \"   %*d    %*d %34s %u %llu %u %llu\",\n        //&part_major,\n        //&part_minor,\n        (*partitions)[cPartition].partition_name,\n        &(*partitions)[cPartition].reads,\n        &(*partitions)[cPartition].reads_sectors,\n        &(*partitions)[cPartition].writes,\n        &(*partitions)[cPartition].requested_writes\n      );\n\n      if (cDisk > 0) {\n        (*partitions)[cPartition++].parent_disk = cDisk-1;\n        (*disks)[cDisk-1].partitions++;\n      }\n    }\n  }\n\n  return cDisk;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// based on Fabian Frederick's /proc/slabinfo parser\n\nunsigned int getslabinfo (struct slab_cache **slab){\n  FILE* fd;\n  int cSlab = 0;\n  buff[BUFFSIZE-1] = 0;\n  *slab = NULL;\n  fd = fopen(\"/proc/slabinfo\", \"rb\");\n  if(!fd) crash(\"/proc/slabinfo\");\n  while (fgets(buff,BUFFSIZE-1,fd)){\n    if(!memcmp(\"slabinfo - version:\",buff,19)) continue; // skip header\n    if(*buff == '#')                           continue; // skip comments\n    if(cSlab < 0 || (size_t)cSlab >= INT_MAX / sizeof(struct slab_cache)){\n      errno = EFBIG;\n      crash(\"/proc/slabinfo\");\n    }\n    (*slab) = xrealloc(*slab, (cSlab+1)*sizeof(struct slab_cache));\n    sscanf(buff,  \"%47s %u %u %u %u\",  // allow 47; max seen is 24\n      (*slab)[cSlab].name,\n      &(*slab)[cSlab].active_objs,\n      &(*slab)[cSlab].num_objs,\n      &(*slab)[cSlab].objsize,\n      &(*slab)[cSlab].objperslab\n    ) ;\n    cSlab++;\n  }\n  fclose(fd);\n  return cSlab;\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nunsigned get_pid_digits(void){\n  char pidbuf[24];\n  char *endp;\n  long rc;\n  int fd;\n  static unsigned ret;\n\n  if(ret) goto out;\n  ret = 5;\n  fd = open(\"/proc/sys/kernel/pid_max\", O_RDONLY);\n  if(fd==-1) goto out;\n  rc = read(fd, pidbuf, sizeof pidbuf - 1);\n  close(fd);\n  if(rc<3) goto out;\n  pidbuf[rc] = '\\0';\n  rc = strtol(pidbuf,&endp,10);\n  if(rc<42) goto out;\n  if(*endp && *endp!='\\n') goto out;\n  rc--;  // the pid_max value is really the max PID plus 1\n  ret = 0;\n  while(rc){\n    rc /= 10;\n    ret++;\n  }\nout:\n  return ret;\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nvoid cpuinfo (void) {\n  // ought to count CPUs in /proc/stat instead of relying\n  // on glibc, which foolishly tries to parse /proc/cpuinfo\n  // note: that may have been the case but now /proc/stat\n  //       is the default source.  parsing of /proc/cpuinfo\n  //       only occurs if the open on /proc/stat fails\n  //\n  // SourceForge has an old Alpha running Linux 2.2.20 that\n  // appears to have a non-SMP kernel on a 2-way SMP box.\n  // _SC_NPROCESSORS_CONF returns 2, resulting in HZ=512\n  // _SC_NPROCESSORS_ONLN returns 1, which should work OK\n\n  smp_num_cpus = sysconf(_SC_NPROCESSORS_ONLN);\n  if (smp_num_cpus<1)        /* SPARC glibc is buggy */\n    smp_num_cpus=1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-procps-3.3.15-7t5vyquf2qqr6grf67vw57m6nxql3tx6/spack-src/top/top.c": "/* top.c - Source file:         show Linux processes */\n/*\n * Copyright (c) 2002-2018, by: James C. Warner\n *\n * This file may be used subject to the terms and conditions of the\n * GNU Library General Public License Version 2, or any later version\n * at your option, as published by the Free Software Foundation.\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Library General Public License for more details.\n */\n/* For contributions to this program, the author wishes to thank:\n *    Craig Small, <csmall@small.dropbear.id.au>\n *    Albert D. Cahalan, <albert@users.sf.net>\n *    Sami Kerola, <kerolasa@iki.fi>\n */\n\n#include <ctype.h>\n#include <curses.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <float.h>\n#include <limits.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <term.h>            // foul sob, defines all sorts of stuff...\n#undef    raw\n#undef    tab\n#undef    TTY\n#include <termios.h>\n#include <time.h>\n#include <unistd.h>\n#include <wchar.h>\n\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n#include <sys/select.h>      // also available via <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>       // also available via <stdlib.h>\n\n#include \"../include/fileutils.h\"\n#include \"../include/nls.h\"\n\n#include \"../proc/alloc.h\"\n#include \"../proc/devname.h\"\n#include \"../proc/numa.h\"\n#include \"../proc/procps.h\"\n#include \"../proc/readproc.h\"\n#include \"../proc/sig.h\"\n#include \"../proc/sysinfo.h\"\n#include \"../proc/version.h\"\n#include \"../proc/wchan.h\"\n#include \"../proc/whattime.h\"\n\n#include \"top.h\"\n#include \"top_nls.h\"\n\n\n/*######  Miscellaneous global stuff  ####################################*/\n\n        /* The original and new terminal definitions\n           (only set when not in 'Batch' mode) */\nstatic struct termios Tty_original,    // our inherited terminal definition\n#ifdef TERMIOS_ONLY\n                      Tty_tweaked,     // for interactive 'line' input\n#endif\n                      Tty_raw;         // for unsolicited input\nstatic int Ttychanged = 0;\n\n        /* Last established cursor state/shape */\nstatic const char *Cursor_state = \"\";\n\n        /* Program name used in error messages and local 'rc' file name */\nstatic char *Myname;\n\n        /* Our constant sigset, so we need initialize it but once */\nstatic sigset_t Sigwinch_set;\n\n        /* The 'local' config file support */\nstatic char  Rc_name [OURPATHSZ];\nstatic RCF_t Rc = DEF_RCFILE;\nstatic int   Rc_questions;\n\n        /* The run-time acquired page stuff */\nstatic unsigned Pg2K_shft = 0;\n\n        /* SMP, Irix/Solaris mode, Linux 2.5.xx support */\nstatic CPU_t      *Cpu_tics;\nstatic int         Cpu_faux_tot;\nstatic float       Cpu_pmax;\nstatic const char *Cpu_States_fmts;\n\n        /* Specific process id monitoring support */\nstatic pid_t Monpids [MONPIDMAX] = { 0 };\nstatic int   Monpidsidx = 0;\n\n        /* Current screen dimensions.\n           note: the number of processes displayed is tracked on a per window\n                 basis (see the WIN_t).  Max_lines is the total number of\n                 screen rows after deducting summary information overhead. */\n        /* Current terminal screen size. */\nstatic int Screen_cols, Screen_rows, Max_lines;\n\n        /* This is really the number of lines needed to display the summary\n           information (0 - nn), but is used as the relative row where we\n           stick the cursor between frames. */\nstatic int Msg_row;\n\n        /* The nearly complete scroll coordinates message for the current\n           window, built at the time column headers are constructed */\nstatic char Scroll_fmts [SMLBUFSIZ];\n\n        /* Global/Non-windows mode stuff that is NOT persistent */\nstatic int Batch = 0,           // batch mode, collect no input, dumb output\n           Loops = -1,          // number of iterations, -1 loops forever\n           Secure_mode = 0,     // set if some functionality restricted\n           Thread_mode = 0,     // set w/ 'H' - show threads via readeither()\n           Width_mode = 0;      // set w/ 'w' - potential output override\n\n        /* Unchangeable cap's stuff built just once (if at all) and\n           thus NOT saved in a WIN_t's RCW_t.  To accommodate 'Batch'\n           mode, they begin life as empty strings so the overlying\n           logic need not change ! */\nstatic char  Cap_clr_eol    [CAPBUFSIZ] = \"\",    // global and/or static vars\n             Cap_nl_clreos  [CAPBUFSIZ] = \"\",    // are initialized to zeros!\n             Cap_clr_scr    [CAPBUFSIZ] = \"\",    // the assignments used here\n             Cap_curs_norm  [CAPBUFSIZ] = \"\",    // cost nothing but DO serve\n             Cap_curs_huge  [CAPBUFSIZ] = \"\",    // to remind people of those\n             Cap_curs_hide  [CAPBUFSIZ] = \"\",    // batch requirements!\n             Cap_clr_eos    [CAPBUFSIZ] = \"\",\n             Cap_home       [CAPBUFSIZ] = \"\",\n             Cap_norm       [CAPBUFSIZ] = \"\",\n             Cap_reverse    [CAPBUFSIZ] = \"\",\n             Caps_off       [CAPBUFSIZ] = \"\",\n             Caps_endline   [CAPBUFSIZ] = \"\";\n#ifndef RMAN_IGNORED\nstatic char  Cap_rmam       [CAPBUFSIZ] = \"\",\n             Cap_smam       [CAPBUFSIZ] = \"\";\n        /* set to 1 if writing to the last column would be troublesome\n           (we don't distinguish the lowermost row from the other rows) */\nstatic int   Cap_avoid_eol = 0;\n#endif\nstatic int   Cap_can_goto = 0;\n\n        /* Some optimization stuff, to reduce output demands...\n           The Pseudo_ guys are managed by adj_geometry and frame_make.  They\n           are exploited in a macro and represent 90% of our optimization.\n           The Stdout_buf is transparent to our code and regardless of whose\n           buffer is used, stdout is flushed at frame end or if interactive. */\nstatic char  *Pseudo_screen;\nstatic int    Pseudo_row = PROC_XTRA;\nstatic size_t Pseudo_size;\n#ifndef OFF_STDIOLBF\n        // less than stdout's normal buffer but with luck mostly '\\n' anyway\nstatic char  Stdout_buf[2048];\n#endif\n\n        /* Our four WIN_t's, and which of those is considered the 'current'\n           window (ie. which window is associated with any summ info displayed\n           and to which window commands are directed) */\nstatic WIN_t  Winstk [GROUPSMAX];\nstatic WIN_t *Curwin;\n\n        /* Frame oriented stuff that can't remain local to any 1 function\n           and/or that would be too cumbersome managed as parms,\n           and/or that are simply more efficiently handled as globals\n           [ 'Frames_...' (plural) stuff persists beyond 1 frame ]\n           [ or are used in response to async signals received ! ] */\nstatic volatile int Frames_signal;     // time to rebuild all column headers\nstatic          int Frames_libflags;   // PROC_FILLxxx flags\nstatic int          Frame_maxtask;     // last known number of active tasks\n                                       // ie. current 'size' of proc table\nstatic float        Frame_etscale;     // so we can '*' vs. '/' WHEN 'pcpu'\nstatic unsigned     Frame_running,     // state categories for this frame\n                    Frame_sleepin,\n                    Frame_stopped,\n                    Frame_zombied;\nstatic int          Frame_srtflg,      // the subject window's sort direction\n                    Frame_ctimes,      // the subject window's ctimes flag\n                    Frame_cmdlin;      // the subject window's cmdlin flag\n\n        /* Support for 'history' processing so we can calculate %cpu */\nstatic int    HHist_siz;               // max number of HST_t structs\nstatic HST_t *PHist_sav,               // alternating 'old/new' HST_t anchors\n             *PHist_new;\n#ifndef OFF_HST_HASH\n#define       HHASH_SIZ  1024\nstatic int    HHash_one [HHASH_SIZ],   // actual hash tables ( hereafter known\n              HHash_two [HHASH_SIZ],   // as PHash_sav/PHash_new )\n              HHash_nul [HHASH_SIZ];   // 'empty' hash table image\nstatic int   *PHash_sav = HHash_one,   // alternating 'old/new' hash tables\n             *PHash_new = HHash_two;\n#endif\n\n        /* Support for automatically sized fixed-width column expansions.\n         * (hopefully, the macros help clarify/document our new 'feature') */\nstatic int Autox_array [EU_MAXPFLGS],\n           Autox_found;\n#define AUTOX_NO      EU_MAXPFLGS\n#define AUTOX_COL(f)  if (EU_MAXPFLGS > f && f >= 0) Autox_array[f] = Autox_found = 1\n#define AUTOX_MODE   (0 > Rc.fixed_widest)\n\n        /* Support for scale_mem and scale_num (to avoid duplication. */\n#ifdef CASEUP_SUFIX                                                // nls_maybe\n   static char Scaled_sfxtab[] =  { 'K', 'M', 'G', 'T', 'P', 'E', 0 };\n#else                                                              // nls_maybe\n   static char Scaled_sfxtab[] =  { 'k', 'm', 'g', 't', 'p', 'e', 0 };\n#endif\n\n        /* Support for NUMA Node display and node expansion/targeting */\n#ifndef OFF_STDERROR\nstatic int Stderr_save = -1;\n#endif\nstatic int Numa_node_tot;\nstatic int Numa_node_sel = -1;\n\n        /* Support for Graphing of the View_STATES ('t') and View_MEMORY ('m')\n           commands -- which are now both 4-way toggles */\n#define GRAPH_prefix  25     // beginning text + opening '['\n#define GRAPH_actual  100    // the actual bars or blocks\n#define GRAPH_suffix  2      // ending ']' + trailing space\nstatic float Graph_adj;      // bars/blocks scaling factor\nstatic int   Graph_len;      // scaled length (<= GRAPH_actual)\nstatic const char Graph_blks[] = \"                                                                                                    \";\nstatic const char Graph_bars[] = \"||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\";\n\f\n/*######  Sort callbacks  ################################################*/\n\n        /*\n         * These happen to be coded in the enum identifier alphabetic order,\n         * not the order of the enum 'pflgs' value.  Also note that a callback\n         * routine may serve more than one column.\n         */\n\nSCB_STRS(CGN, cgname)\nSCB_STRS(CGR, cgroup[0])\nSCB_STRV(CMD, Frame_cmdlin, cmdline, cmd)\nSCB_NUM1(COD, trs)\nSCB_NUMx(CPN, processor)\nSCB_NUM1(CPU, pcpu)\nSCB_NUM1(DAT, drs)\nSCB_NUM1(DRT, dt)\nSCB_STRS(ENV, environ[0])\nSCB_NUM1(FL1, maj_flt)\nSCB_NUM1(FL2, min_flt)\nSCB_NUM1(FLG, flags)\nSCB_NUM1(FV1, maj_delta)\nSCB_NUM1(FV2, min_delta)\nSCB_NUMx(GID, egid)\nSCB_STRS(GRP, egroup)\nSCB_STRS(LXC, lxcname)\nSCB_NUMx(NCE, nice)\nstatic int SCB_NAME(NMA) (const proc_t **P, const proc_t **Q) {\n   /* this is a terrible cost to pay for sorting on numa nodes, but it's\n      necessary if we're to avoid ABI breakage via changes to the proc_t */\n   int p = numa_node_of_cpu((*P)->processor);\n   int q = numa_node_of_cpu((*Q)->processor);\n   return Frame_srtflg * ( q - p );\n}\nSCB_NUM1(NS1, ns[IPCNS])\nSCB_NUM1(NS2, ns[MNTNS])\nSCB_NUM1(NS3, ns[NETNS])\nSCB_NUM1(NS4, ns[PIDNS])\nSCB_NUM1(NS5, ns[USERNS])\nSCB_NUM1(NS6, ns[UTSNS])\nSCB_NUM1(OOA, oom_adj)\nSCB_NUM1(OOM, oom_score)\nSCB_NUMx(PGD, pgrp)\nSCB_NUMx(PID, tid)\nSCB_NUMx(PPD, ppid)\nSCB_NUMx(PRI, priority)\nSCB_NUM1(RES, resident)                // also serves MEM !\nSCB_NUM1(RZA, vm_rss_anon)\nSCB_NUM1(RZF, vm_rss_file)\nSCB_NUM1(RZL, vm_lock)\nSCB_NUM1(RZS, vm_rss_shared)\nSCB_STRX(SGD, supgid)\nSCB_STRS(SGN, supgrp)\nSCB_NUM1(SHR, share)\nSCB_NUM1(SID, session)\nSCB_NUMx(STA, state)\nSCB_NUM1(SWP, vm_swap)\nSCB_NUMx(TGD, tgid)\nSCB_NUMx(THD, nlwp)\n                                       // also serves TM2 !\nstatic int SCB_NAME(TME) (const proc_t **P, const proc_t **Q) {\n   if (Frame_ctimes) {\n      if (((*P)->cutime + (*P)->cstime + (*P)->utime + (*P)->stime)\n        < ((*Q)->cutime + (*Q)->cstime + (*Q)->utime + (*Q)->stime))\n           return SORT_lt;\n      if (((*P)->cutime + (*P)->cstime + (*P)->utime + (*P)->stime)\n        > ((*Q)->cutime + (*Q)->cstime + (*Q)->utime + (*Q)->stime))\n           return SORT_gt;\n   } else {\n      if (((*P)->utime + (*P)->stime) < ((*Q)->utime + (*Q)->stime))\n         return SORT_lt;\n      if (((*P)->utime + (*P)->stime) > ((*Q)->utime + (*Q)->stime))\n         return SORT_gt;\n   }\n   return SORT_eq;\n}\nSCB_NUM1(TPG, tpgid)\nSCB_NUMx(TTY, tty)\nSCB_NUMx(UED, euid)\nSCB_STRS(UEN, euser)\nSCB_NUMx(URD, ruid)\nSCB_STRS(URN, ruser)\nSCB_NUMx(USD, suid)\nSCB_NUM2(USE, vm_rss, vm_swap)\nSCB_STRS(USN, suser)\nSCB_NUM1(VRT, size)\nSCB_NUM1(WCH, wchan)\n\n#ifdef OFF_HST_HASH\n        /* special sort for procs_hlp() ! ------------------------ */\nstatic int sort_HST_t (const HST_t *P, const HST_t *Q) {\n   return P->pid - Q->pid;\n}\n#endif\n\f\n/*######  Tiny useful routine(s)  ########################################*/\n\n        /*\n         * This routine simply formats whatever the caller wants and\n         * returns a pointer to the resulting 'const char' string... */\nstatic const char *fmtmk (const char *fmts, ...) __attribute__((format(printf,1,2)));\nstatic const char *fmtmk (const char *fmts, ...) {\n   static char buf[BIGBUFSIZ];          // with help stuff, our buffer\n   va_list va;                          // requirements now exceed 1k\n\n   va_start(va, fmts);\n   vsnprintf(buf, sizeof(buf), fmts, va);\n   va_end(va);\n   return (const char *)buf;\n} // end: fmtmk\n\n\n        /*\n         * This guy is just our way of avoiding the overhead of the standard\n         * strcat function (should the caller choose to participate) */\nstatic inline char *scat (char *dst, const char *src) {\n   while (*dst) dst++;\n   while ((*(dst++) = *(src++)));\n   return --dst;\n} // end: scat\n\n\n        /*\n         * This guy just facilitates Batch and protects against dumb ttys\n         * -- we'd 'inline' him but he's only called twice per frame,\n         * yet used in many other locations. */\nstatic const char *tg2 (int x, int y) {\n   // it's entirely possible we're trying for an invalid row...\n   return Cap_can_goto ? tgoto(cursor_address, x, y) : \"\";\n} // end: tg2\n\f\n/*######  Exit/Interrput routines  #######################################*/\n\n        /*\n         * Reset the tty, if necessary */\nstatic void at_eoj (void) {\n   if (Ttychanged) {\n      tcsetattr(STDIN_FILENO, TCSAFLUSH, &Tty_original);\n      if (keypad_local) putp(keypad_local);\n      putp(tg2(0, Screen_rows));\n      putp(\"\\n\");\n#ifdef OFF_SCROLLBK\n      if (exit_ca_mode) {\n         // this next will also replace top's most recent screen with the\n         // original display contents that were visible at our invocation\n         putp(exit_ca_mode);\n      }\n#endif\n      putp(Cap_curs_norm);\n      putp(Cap_clr_eol);\n#ifndef RMAN_IGNORED\n      putp(Cap_smam);\n#endif\n   }\n   fflush(stdout);\n#ifndef OFF_STDERROR\n   /* we gotta reverse the stderr redirect which was employed during start up\n      and needed because the two libnuma 'weak' functions were useless to us! */\n   if (-1 < Stderr_save) {\n      dup2(Stderr_save, fileno(stderr));\n      close(Stderr_save);\n      Stderr_save = -1;      // we'll be ending soon anyway but what the heck\n   }\n#endif\n} // end: at_eoj\n\n\n        /*\n         * The real program end */\nstatic void bye_bye (const char *str) NORETURN;\nstatic void bye_bye (const char *str) {\n   at_eoj();                 // restore tty in preparation for exit\n#ifdef ATEOJ_RPTSTD\n{  proc_t *p;\n   if (!str && !Frames_signal && Ttychanged) { fprintf(stderr,\n      \"\\n%s's Summary report:\"\n      \"\\n\\tProgram\"\n      \"\\n\\t   %s\"\n      \"\\n\\t   Hertz = %u (%u bytes, %u-bit time)\"\n      \"\\n\\t   page_bytes = %d, Cpu_faux_tot = %d, smp_num_cpus = %d\"\n      \"\\n\\t   sizeof(CPU_t) = %u, sizeof(HST_t) = %u (%d HST_t's/Page), HHist_siz = %u\"\n      \"\\n\\t   sizeof(proc_t) = %u, sizeof(proc_t.cmd) = %u, sizeof(proc_t*) = %u\"\n      \"\\n\\t   Frames_libflags = %08lX\"\n      \"\\n\\t   SCREENMAX = %u, ROWMINSIZ = %u, ROWMAXSIZ = %u\"\n      \"\\n\\t   PACKAGE = '%s', LOCALEDIR = '%s'\"\n      \"\\n\\tTerminal: %s\"\n      \"\\n\\t   device = %s, ncurses = v%s\"\n      \"\\n\\t   max_colors = %d, max_pairs = %d\"\n      \"\\n\\t   Cap_can_goto = %s\"\n      \"\\n\\t   Screen_cols = %d, Screen_rows = %d\"\n      \"\\n\\t   Max_lines = %d, most recent Pseudo_size = %u\"\n#ifndef OFF_STDIOLBF\n      \"\\n\\t   Stdout_buf = %u, BUFSIZ = %u\"\n#endif\n      \"\\n\\tWindows and Curwin->\"\n      \"\\n\\t   sizeof(WIN_t) = %u, GROUPSMAX = %d\"\n      \"\\n\\t   winname = %s, grpname = %s\"\n#ifdef CASEUP_HEXES\n      \"\\n\\t   winflags = %08X, maxpflgs = %d\"\n#else\n      \"\\n\\t   winflags = %08x, maxpflgs = %d\"\n#endif\n      \"\\n\\t   sortindx = %d, fieldscur = %s\"\n      \"\\n\\t   maxtasks = %d, varcolsz = %d, winlines = %d\"\n      \"\\n\\t   strlen(columnhdr) = %d\"\n      \"\\n\"\n      , __func__\n      , PACKAGE_STRING\n      , (unsigned)Hertz, (unsigned)sizeof(Hertz), (unsigned)sizeof(Hertz) * 8\n      , (int)page_bytes, Cpu_faux_tot, (int)smp_num_cpus, (unsigned)sizeof(CPU_t)\n      , (unsigned)sizeof(HST_t), ((int)page_bytes / (int)sizeof(HST_t)), HHist_siz\n      , (unsigned)sizeof(proc_t), (unsigned)sizeof(p->cmd), (unsigned)sizeof(proc_t*)\n      , (long)Frames_libflags\n      , (unsigned)SCREENMAX, (unsigned)ROWMINSIZ, (unsigned)ROWMAXSIZ\n      , PACKAGE, LOCALEDIR\n#ifdef PRETENDNOCAP\n      , \"dumb\"\n#else\n      , termname()\n#endif\n      , ttyname(STDOUT_FILENO), NCURSES_VERSION\n      , max_colors, max_pairs\n      , Cap_can_goto ? \"yes\" : \"No!\"\n      , Screen_cols, Screen_rows\n      , Max_lines, (unsigned)Pseudo_size\n#ifndef OFF_STDIOLBF\n      , (unsigned)sizeof(Stdout_buf), (unsigned)BUFSIZ\n#endif\n      , (unsigned)sizeof(WIN_t), GROUPSMAX\n      , Curwin->rc.winname, Curwin->grpname\n      , Curwin->rc.winflags, Curwin->maxpflgs\n      , Curwin->rc.sortindx, Curwin->rc.fieldscur\n      , Curwin->rc.maxtasks, Curwin->varcolsz, Curwin->winlines\n      , (int)strlen(Curwin->columnhdr)\n      );\n   }\n}\n#endif // end: ATEOJ_RPTSTD\n\n#ifndef OFF_HST_HASH\n#ifdef ATEOJ_RPTHSH\n   if (!str && !Frames_signal && Ttychanged) {\n      int i, j, pop, total_occupied, maxdepth, maxdepth_sav, numdepth\n         , cross_foot, sz = HHASH_SIZ * (unsigned)sizeof(int);\n      int depths[HHASH_SIZ];\n\n      for (i = 0, total_occupied = 0, maxdepth = 0; i < HHASH_SIZ; i++) {\n         int V = PHash_new[i];\n         j = 0;\n         if (-1 < V) {\n            ++total_occupied;\n            while (-1 < V) {\n               V = PHist_new[V].lnk;\n               if (-1 < V) j++;\n            }\n         }\n         depths[i] = j;\n         if (maxdepth < j) maxdepth = j;\n      }\n      maxdepth_sav = maxdepth;\n\n      fprintf(stderr,\n         \"\\n%s's Supplementary HASH report:\"\n         \"\\n\\tTwo Tables providing for %d entries each + 1 extra for 'empty' image\"\n         \"\\n\\t%dk (%d bytes) per table, %d total bytes (including 'empty' image)\"\n         \"\\n\\tResults from latest hash (PHash_new + PHist_new)...\"\n         \"\\n\"\n         \"\\n\\tTotal hashed = %d\"\n         \"\\n\\tLevel-0 hash entries = %d (%d%% occupied)\"\n         \"\\n\\tMax Depth = %d\"\n         \"\\n\\n\"\n         , __func__\n         , HHASH_SIZ, sz / 1024, sz, sz * 3\n         , Frame_maxtask\n         , total_occupied, (total_occupied * 100) / HHASH_SIZ\n         , maxdepth + 1);\n\n      if (total_occupied) {\n         for (pop = total_occupied, cross_foot = 0; maxdepth; maxdepth--) {\n            for (i = 0, numdepth = 0; i < HHASH_SIZ; i++)\n               if (depths[i] == maxdepth) ++numdepth;\n            fprintf(stderr,\n               \"\\t %5d (%3d%%) hash table entries at depth %d\\n\"\n               , numdepth, (numdepth * 100) / total_occupied, maxdepth + 1);\n            pop -= numdepth;\n            cross_foot += numdepth;\n            if (0 == pop && cross_foot == total_occupied) break;\n         }\n         if (pop) {\n            fprintf(stderr, \"\\t %5d (%3d%%) unchained hash table entries\\n\"\n               , pop, (pop * 100) / total_occupied);\n            cross_foot += pop;\n         }\n         fprintf(stderr,\n            \"\\t -----\\n\"\n            \"\\t %5d total entries occupied\\n\", cross_foot);\n\n         if (maxdepth_sav > 1) {\n            fprintf(stderr, \"\\nPIDs at max depth: \");\n            for (i = 0; i < HHASH_SIZ; i++)\n               if (depths[i] == maxdepth_sav) {\n                  j = PHash_new[i];\n                  fprintf(stderr, \"\\n\\tpos %4d:  %05d\", i, PHist_new[j].pid);\n                  while (-1 < j) {\n                     j = PHist_new[j].lnk;\n                     if (-1 < j) fprintf(stderr, \", %05d\", PHist_new[j].pid);\n                  }\n               }\n            fprintf(stderr, \"\\n\");\n         }\n      }\n   }\n#endif // end: ATEOJ_RPTHSH\n#endif // end: OFF_HST_HASH\n\n   numa_uninit();\n   if (str) {\n      fputs(str, stderr);\n      exit(EXIT_FAILURE);\n   }\n   if (Batch) fputs(\"\\n\", stdout);\n   exit(EXIT_SUCCESS);\n} // end: bye_bye\n\n\n        /*\n         * Standard error handler to normalize the look of all err output */\nstatic void error_exit (const char *str) NORETURN;\nstatic void error_exit (const char *str) {\n   static char buf[MEDBUFSIZ];\n\n   /* we'll use our own buffer so callers can still use fmtmk() and, after\n      twelve long years, 2013 was the year we finally eliminated the leading\n      tab character -- now our message can get lost in screen clutter too! */\n   snprintf(buf, sizeof(buf), \"%s: %s\\n\", Myname, str);\n   bye_bye(buf);\n} // end: error_exit\n\n\n        /*\n         * Catches all remaining signals not otherwise handled */\nstatic void sig_abexit (int sig) {\n   sigset_t ss;\n\n// POSIX.1-2004 async-signal-safe: sigfillset, sigprocmask, signal, raise\n   sigfillset(&ss);\n   sigprocmask(SIG_BLOCK, &ss, NULL);\n   at_eoj();                 // restore tty in preparation for exit\n   fprintf(stderr, N_fmt(EXIT_signals_fmt)\n      , sig, signal_number_to_name(sig), Myname);\n   signal(sig, SIG_DFL);     // allow core dumps, if applicable\n   raise(sig);               // ( plus set proper return code )\n   _exit(sig | 0x80);        // if default sig action is ignore\n} // end: sig_abexit\n\n\n        /*\n         * Catches:\n         *    SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,\n         *    SIGUSR1 and SIGUSR2 */\nstatic void sig_endpgm (int dont_care_sig) NORETURN;\nstatic void sig_endpgm (int dont_care_sig) {\n   sigset_t ss;\n\n// POSIX.1-2004 async-signal-safe: sigfillset, sigprocmask\n   sigfillset(&ss);\n   sigprocmask(SIG_BLOCK, &ss, NULL);\n   Frames_signal = BREAK_sig;\n   bye_bye(NULL);\n   (void)dont_care_sig;\n} // end: sig_endpgm\n\n\n        /*\n         * Catches:\n         *    SIGTSTP, SIGTTIN and SIGTTOU */\nstatic void sig_paused (int dont_care_sig) {\n// POSIX.1-2004 async-signal-safe: tcsetattr, tcdrain, raise\n   if (-1 == tcsetattr(STDIN_FILENO, TCSAFLUSH, &Tty_original))\n      error_exit(fmtmk(N_fmt(FAIL_tty_set_fmt), strerror(errno)));\n   if (keypad_local) putp(keypad_local);\n   putp(tg2(0, Screen_rows));\n   putp(Cap_curs_norm);\n#ifndef RMAN_IGNORED\n   putp(Cap_smam);\n#endif\n   // tcdrain(STDOUT_FILENO) was not reliable prior to ncurses-5.9.20121017,\n   // so we'll risk POSIX's wrath with good ol' fflush, lest 'Stopped' gets\n   // co-mingled with our most recent output...\n   fflush(stdout);\n   raise(SIGSTOP);\n   // later, after SIGCONT...\n   if (-1 == tcsetattr(STDIN_FILENO, TCSAFLUSH, &Tty_raw))\n      error_exit(fmtmk(N_fmt(FAIL_tty_set_fmt), strerror(errno)));\n#ifndef RMAN_IGNORED\n   putp(Cap_rmam);\n#endif\n   if (keypad_xmit) putp(keypad_xmit);\n   putp(Cursor_state);\n   Frames_signal = BREAK_sig;\n   (void)dont_care_sig;\n} // end: sig_paused\n\n\n        /*\n         * Catches:\n         *    SIGCONT and SIGWINCH */\nstatic void sig_resize (int dont_care_sig) {\n// POSIX.1-2004 async-signal-safe: tcdrain\n   tcdrain(STDOUT_FILENO);\n   Frames_signal = BREAK_sig;\n   (void)dont_care_sig;\n} // end: sig_resize\n\n\n        /*\n         * Handles libproc memory errors, so our tty can be reset */\nstatic void xalloc_our_handler (const char *fmts, ...) {\n   static char buf[MEDBUFSIZ];\n   va_list va;\n\n   va_start(va, fmts);\n   vsnprintf(buf, sizeof(buf), fmts, va);\n   va_end(va);\n   scat(buf, \"\\n\");\n   bye_bye(buf);\n} // end: xalloc_our_handler\n\f\n/*######  Special UTF-8 Multi-Byte support  ##############################*/\n\n        /* Support for NLS translated multi-byte strings */\nstatic char UTF8_tab[] = {\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x00 - 0x0F\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x10 - 0x1F\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x20 - 0x2F\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x30 - 0x3F\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x40 - 0x4F\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x50 - 0x5F\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x60 - 0x6F\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x70 - 0x7F\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, // 0x80 - 0x8F\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, // 0x90 - 0x9F\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, // 0xA0 - 0xAF\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, // 0xB0 - 0xBF\n  -1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // 0xC0 - 0xCF, 0xC2 = begins 2\n   2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // 0xD0 - 0xDF\n   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, // 0xE0 - 0xEF, 0xE0 = begins 3\n   4, 4, 4, 4, 4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, // 0xF0 - 0xFF, 0xF0 = begins 4\n};                                                 //            ( 0xF5 & beyond invalid )\n\n\n        /*\n         * Accommodate any potential differences between some multibyte\n         * character sequence and the screen columns needed to print it */\nstatic inline int utf8_cols (const unsigned char *p, int n) {\n#ifndef OFF_XTRAWIDE\n   wchar_t wc;\n\n   if (n > 1) {\n      (void)mbtowc(&wc, (const char *)p, n);\n      if ((n = wcwidth(wc)) < 1) n = 1;\n   }\n   return n;\n#else\n   (void)p; (void)n;\n   return 1;\n#endif\n} // end: utf8_cols\n\n\n        /*\n         * Determine difference between total bytes versus printable\n         * characters in that passed, potentially multi-byte, string */\nstatic int utf8_delta (const char *str) {\n   const unsigned char *p = (const unsigned char *)str;\n   int clen, cnum = 0;\n\n   while (*p) {\n      // -1 represents a decoding error, pretend it's untranslated ...\n      if (0 > (clen = UTF8_tab[*p])) return 0;\n      cnum += utf8_cols(p, clen);\n      p += clen;\n   }\n   return (int)((const char *)p - str) - cnum;\n} // end: utf8_delta\n\n\n        /*\n         * Determine a physical end within a potential multi-byte string\n         * where maximum printable chars could be accommodated in width */\nstatic int utf8_embody (const char *str, int width) {\n   const unsigned char *p = (const unsigned char *)str;\n   int clen, cnum = 0;\n\n   if (width > 0) {\n      while (*p) {\n         // -1 represents a decoding error, pretend it's untranslated ...\n         if (0 > (clen = UTF8_tab[*p])) return width;\n         if (width < (cnum += utf8_cols(p, clen))) break;\n         p += clen;\n      }\n   }\n   return (int)((const char *)p - str);\n} // end: utf8_embody\n\n\n        /*\n         * Like the regular justify_pad routine but this guy\n         * can accommodate the multi-byte translated strings */\nstatic const char *utf8_justify (const char *str, int width, int justr) {\n   static char l_fmt[]  = \"%-*.*s%s\", r_fmt[] = \"%*.*s%s\";\n   static char buf[SCREENMAX];\n   char tmp[SCREENMAX];\n\n   snprintf(tmp, sizeof(tmp), \"%.*s\", utf8_embody(str, width), str);\n   width += utf8_delta(tmp);\n   snprintf(buf, sizeof(buf), justr ? r_fmt : l_fmt, width, width, tmp, COLPADSTR);\n   return buf;\n} // end: utf8_justify\n\n\n        /*\n         * Returns a physical or logical column number given a\n         * multi-byte string and a target column value */\nstatic int utf8_proper_col (const char *str, int col, int tophysical) {\n   const unsigned char *p = (const unsigned char *)str;\n   int clen, tlen = 0, cnum = 0;\n\n   while (*p) {\n      // -1 represents a decoding error, don't encourage repositioning ...\n      if (0 > (clen = UTF8_tab[*p])) return col;\n      if (cnum + 1 > col && tophysical) break;\n      p += clen;\n      tlen += clen;\n      if (tlen > col && !tophysical) break;\n      ++cnum;\n   }\n   return tophysical ? tlen : cnum;\n} // end: utf8_proper_col\n\f\n/*######  Misc Color/Display support  ####################################*/\n\n        /*\n         * Make the appropriate caps/color strings for a window/field group.\n         * note: we avoid the use of background color so as to maximize\n         *       compatibility with the user's xterm settings */\nstatic void capsmk (WIN_t *q) {\n   /* macro to test if a basic (non-color) capability is valid\n         thanks: Floyd Davidson <floyd@ptialaska.net> */\n #define tIF(s)  s ? s : \"\"\n   /* macro to make compatible with netbsd-curses too\n         thanks: rofl0r <retnyg@gmx.net> */\n #define tPM(a,b) tparm(a, b, 0, 0, 0, 0, 0, 0, 0, 0)\n   static int capsdone = 0;\n\n   // we must NOT disturb our 'empty' terminfo strings!\n   if (Batch) return;\n\n   // these are the unchangeable puppies, so we only do 'em once\n   if (!capsdone) {\n      STRLCPY(Cap_clr_eol, tIF(clr_eol))\n      STRLCPY(Cap_clr_eos, tIF(clr_eos))\n      STRLCPY(Cap_clr_scr, tIF(clear_screen))\n      // due to the leading newline, the following must be used with care\n      snprintf(Cap_nl_clreos, sizeof(Cap_nl_clreos), \"\\n%s\", tIF(clr_eos));\n      STRLCPY(Cap_curs_huge, tIF(cursor_visible))\n      STRLCPY(Cap_curs_norm, tIF(cursor_normal))\n      STRLCPY(Cap_curs_hide, tIF(cursor_invisible))\n      STRLCPY(Cap_home, tIF(cursor_home))\n      STRLCPY(Cap_norm, tIF(exit_attribute_mode))\n      STRLCPY(Cap_reverse, tIF(enter_reverse_mode))\n#ifndef RMAN_IGNORED\n      if (!eat_newline_glitch) {\n         STRLCPY(Cap_rmam, tIF(exit_am_mode))\n         STRLCPY(Cap_smam, tIF(enter_am_mode))\n         if (!*Cap_rmam || !*Cap_smam) {\n            *Cap_rmam = '\\0';\n            *Cap_smam = '\\0';\n            if (auto_right_margin)\n               Cap_avoid_eol = 1;\n         }\n         putp(Cap_rmam);\n      }\n#endif\n      snprintf(Caps_off, sizeof(Caps_off), \"%s%s\", Cap_norm, tIF(orig_pair));\n      snprintf(Caps_endline, sizeof(Caps_endline), \"%s%s\", Caps_off, Cap_clr_eol);\n      if (tgoto(cursor_address, 1, 1)) Cap_can_goto = 1;\n      capsdone = 1;\n   }\n\n   /* the key to NO run-time costs for configurable colors -- we spend a\n      little time with the user now setting up our terminfo strings, and\n      the job's done until he/she/it has a change-of-heart */\n   STRLCPY(q->cap_bold, CHKw(q, View_NOBOLD) ? Cap_norm : tIF(enter_bold_mode))\n   if (CHKw(q, Show_COLORS) && max_colors > 0) {\n      STRLCPY(q->capclr_sum, tPM(set_a_foreground, q->rc.summclr))\n      snprintf(q->capclr_msg, sizeof(q->capclr_msg), \"%s%s\"\n         , tPM(set_a_foreground, q->rc.msgsclr), Cap_reverse);\n      snprintf(q->capclr_pmt, sizeof(q->capclr_pmt), \"%s%s\"\n         , tPM(set_a_foreground, q->rc.msgsclr), q->cap_bold);\n      snprintf(q->capclr_hdr, sizeof(q->capclr_hdr), \"%s%s\"\n         , tPM(set_a_foreground, q->rc.headclr), Cap_reverse);\n      snprintf(q->capclr_rownorm, sizeof(q->capclr_rownorm), \"%s%s\"\n         , Caps_off, tPM(set_a_foreground, q->rc.taskclr));\n   } else {\n      q->capclr_sum[0] = '\\0';\n#ifdef USE_X_COLHDR\n      snprintf(q->capclr_msg, sizeof(q->capclr_msg), \"%s%s\"\n         , Cap_reverse, q->cap_bold);\n#else\n      STRLCPY(q->capclr_msg, Cap_reverse)\n#endif\n      STRLCPY(q->capclr_pmt, q->cap_bold)\n      STRLCPY(q->capclr_hdr, Cap_reverse)\n      STRLCPY(q->capclr_rownorm, Cap_norm)\n   }\n\n   // composite(s), so we do 'em outside and after the if\n   snprintf(q->capclr_rowhigh, sizeof(q->capclr_rowhigh), \"%s%s\"\n      , q->capclr_rownorm, CHKw(q, Show_HIBOLD) ? q->cap_bold : Cap_reverse);\n #undef tIF\n #undef tPM\n} // end: capsmk\n\n\n        /*\n         * Show an error message (caller may include '\\a' for sound) */\nstatic void show_msg (const char *str) {\n   PUTT(\"%s%s %.*s %s%s%s\"\n      , tg2(0, Msg_row)\n      , Curwin->capclr_msg\n      , utf8_embody(str, Screen_cols - 2)\n      , str\n      , Cap_curs_hide\n      , Caps_off\n      , Cap_clr_eol);\n   fflush(stdout);\n   usleep(MSG_USLEEP);\n} // end: show_msg\n\n\n        /*\n         * Show an input prompt + larger cursor (if possible) */\nstatic int show_pmt (const char *str) {\n   char buf[MEDBUFSIZ];\n   int len;\n\n   snprintf(buf, sizeof(buf), \"%.*s\", utf8_embody(str, Screen_cols - 2), str);\n   len = utf8_delta(buf);\n#ifdef PRETENDNOCAP\n   PUTT(\"\\n%s%s%.*s %s%s%s\"\n#else\n   PUTT(\"%s%s%.*s %s%s%s\"\n#endif\n      , tg2(0, Msg_row)\n      , Curwin->capclr_pmt\n      , (Screen_cols - 2) + len\n      , buf\n      , Cap_curs_huge\n      , Caps_off\n      , Cap_clr_eol);\n   fflush(stdout);\n   len = strlen(buf) - len;\n   // +1 for the space we added or -1 for the cursor...\n   return (len + 1 < Screen_cols) ? len + 1 : Screen_cols - 1;\n} // end: show_pmt\n\n\n        /*\n         * Show lines with specially formatted elements, but only output\n         * what will fit within the current screen width.\n         *    Our special formatting consists of:\n         *       \"some text <_delimiter_> some more text <_delimiter_>...\\n\"\n         *    Where <_delimiter_> is a two byte combination consisting of a\n         *    tilde followed by an ascii digit in the range of 1 - 8.\n         *       examples: ~1, ~5, ~8, etc.\n         *    The tilde is effectively stripped and the next digit\n         *    converted to an index which is then used to select an\n         *    'attribute' from a capabilities table.  That attribute\n         *    is then applied to the *preceding* substring.\n         * Once recognized, the delimiter is replaced with a null character\n         * and viola, we've got a substring ready to output!  Strings or\n         * substrings without delimiters will receive the Cap_norm attribute.\n         *\n         * Caution:\n         *    This routine treats all non-delimiter bytes as displayable\n         *    data subject to our screen width marching orders.  If callers\n         *    embed non-display data like tabs or terminfo strings in our\n         *    glob, a line will truncate incorrectly at best.  Worse case\n         *    would be truncation of an embedded tty escape sequence.\n         *\n         *    Tabs must always be avoided or our efforts are wasted and\n         *    lines will wrap.  To lessen but not eliminate the risk of\n         *    terminfo string truncation, such non-display stuff should\n         *    be placed at the beginning of a \"short\" line. */\nstatic void show_special (int interact, const char *glob) {\n  /* note: the following is for documentation only,\n           the real captab is now found in a group's WIN_t !\n     +------------------------------------------------------+\n     | char *captab[] = {                 :   Cap's = Index |\n     |   Cap_norm, Cap_norm,              =   \\000, \\001,   |\n     |   cap_bold, capclr_sum,            =   \\002, \\003,   |\n     |   capclr_msg, capclr_pmt,          =   \\004, \\005,   |\n     |   capclr_hdr,                      =   \\006,         |\n     |   capclr_rowhigh,                  =   \\007,         |\n     |   capclr_rownorm  };               =   \\010 [octal!] |\n     +------------------------------------------------------+ */\n  /* ( Pssst, after adding the termcap transitions, row may )\n     ( exceed 300+ bytes, even in an 80x24 terminal window! )\n     ( Shown here are the former buffer size specifications )\n     ( char tmp[SMLBUFSIZ], lin[MEDBUFSIZ], row[LRGBUFSIZ]. )\n     ( So now we use larger buffers and a little protection )\n     ( against overrunning them with this 'lin_end - glob'. )\n\n     ( That was uncovered during 'Inspect' development when )\n     ( this guy was being considered for a supporting role. )\n     ( However, such an approach was abandoned. As a result )\n     ( this function is called only with a glob under top's )\n     ( control and never containing any 'raw/binary' chars! ) */\n   char tmp[LRGBUFSIZ], lin[LRGBUFSIZ], row[ROWMAXSIZ];\n   char *rp, *lin_end, *sub_beg, *sub_end;\n   int room;\n\n   // handle multiple lines passed in a bunch\n   while ((lin_end = strchr(glob, '\\n'))) {\n     #define myMIN(a,b) (((a) < (b)) ? (a) : (b))\n      size_t lessor = myMIN((size_t)(lin_end - glob), sizeof(lin) -3);\n\n      // create a local copy we can extend and otherwise abuse\n      memcpy(lin, glob, lessor);\n      // zero terminate this part and prepare to parse substrings\n      lin[lessor] = '\\0';\n      room = Screen_cols;\n      sub_beg = sub_end = lin;\n      *(rp = row) = '\\0';\n\n      while (*sub_beg) {\n         int ch = *sub_end;\n         if ('~' == ch) ch = *(sub_end + 1) - '0';\n         switch (ch) {\n            case 0:                    // no end delim, captab makes normal\n               // only possible when '\\n' was NOT preceeded with a '~#' sequence\n               // ( '~1' thru '~8' is valid range, '~0' is never actually used )\n               *(sub_end + 1) = '\\0';  // extend str end, then fall through\n               *(sub_end + 2) = '\\0';  // ( +1 optimization for usual path )\n            case 1: case 2: case 3: case 4:\n            case 5: case 6: case 7: case 8:\n               *sub_end = '\\0';\n               snprintf(tmp, sizeof(tmp), \"%s%.*s%s\"\n                  , Curwin->captab[ch], utf8_embody(sub_beg, room), sub_beg, Caps_off);\n               rp = scat(rp, tmp);\n               room -= (sub_end - sub_beg);\n               room += utf8_delta(sub_beg);\n               sub_beg = (sub_end += 2);\n               break;\n            default:                   // nothin' special, just text\n               ++sub_end;\n         }\n         if (0 >= room) break;         // skip substrings that won't fit\n      }\n\n      if (interact) PUTT(\"%s%s\\n\", row, Cap_clr_eol);\n      else PUFF(\"%s%s\\n\", row, Caps_endline);\n      glob = ++lin_end;                // point to next line (maybe)\n\n     #undef myMIN\n   } // end: while 'lines'\n\n   /* If there's anything left in the glob (by virtue of no trailing '\\n'),\n      it probably means caller wants to retain cursor position on this final\n      line.  That, in turn, means we're interactive and so we'll just do our\n      'fit-to-screen' thingy while also leaving room for the cursor... */\n   if (*glob) PUTT(\"%.*s\", utf8_embody(glob, Screen_cols - 1), glob);\n} // end: show_special\n\n\n        /*\n         * Create a nearly complete scroll coordinates message, but still\n         * a format string since we'll be missing the current total tasks. */\nstatic void updt_scroll_msg (void) {\n   char tmp1[SMLBUFSIZ], tmp2[SMLBUFSIZ];\n   int totpflgs = Curwin->totpflgs;\n   int begpflgs = Curwin->begpflg + 1;\n\n#ifndef USE_X_COLHDR\n   if (CHKw(Curwin, Show_HICOLS)) {\n      totpflgs -= 2;\n      if (ENUpos(Curwin, Curwin->rc.sortindx) < Curwin->begpflg) begpflgs -= 2;\n   }\n#endif\n   if (1 > totpflgs) totpflgs = 1;\n   if (1 > begpflgs) begpflgs = 1;\n   snprintf(tmp1, sizeof(tmp1)\n      , N_fmt(SCROLL_coord_fmt), Curwin->begtask + 1, begpflgs, totpflgs);\n   strcpy(tmp2, tmp1);\n#ifndef SCROLLVAR_NO\n   if (Curwin->varcolbeg)\n      snprintf(tmp2, sizeof(tmp2), \"%s + %d\", tmp1, Curwin->varcolbeg);\n#endif\n   // this Scroll_fmts string no longer provides for termcap tgoto so that\n   // the usage timing is critical -- see frame_make() for additional info\n   snprintf(Scroll_fmts, sizeof(Scroll_fmts)\n      , \"%s  %.*s%s\", Caps_off, Screen_cols - 3, tmp2, Cap_clr_eol);\n} // end: updt_scroll_msg\n\f\n/*######  Low Level Memory/Keyboard/File I/O support  ####################*/\n\n        /*\n         * Handle our own memory stuff without the risk of leaving the\n         * user's terminal in an ugly state should things go sour. */\n\nstatic void *alloc_c (size_t num) MALLOC;\nstatic void *alloc_c (size_t num) {\n   void *pv;\n\n   if (!num) ++num;\n   if (!(pv = calloc(1, num)))\n      error_exit(N_txt(FAIL_alloc_c_txt));\n   return pv;\n} // end: alloc_c\n\n\nstatic void *alloc_r (void *ptr, size_t num) MALLOC;\nstatic void *alloc_r (void *ptr, size_t num) {\n   void *pv;\n\n   if (!num) ++num;\n   if (!(pv = realloc(ptr, num)))\n      error_exit(N_txt(FAIL_alloc_r_txt));\n   return pv;\n} // end: alloc_r\n\n\nstatic char *alloc_s (const char *str) MALLOC;\nstatic char *alloc_s (const char *str) {\n   return strcpy(alloc_c(strlen(str) +1), str);\n} // end: alloc_s\n\n\n        /*\n         * This function is used in connection with raw single byte\n         * unsolicited keyboard input that's susceptible to SIGWINCH\n         * interrupts (or any other signal).  He also supports timout\n         * in the absence of user keystrokes or some signal interrupt. */\nstatic inline int ioa (struct timespec *ts) {\n   fd_set fs;\n   int rc;\n\n   FD_ZERO(&fs);\n   FD_SET(STDIN_FILENO, &fs);\n\n#ifdef SIGNALS_LESS // conditional comments are silly, but help in documenting\n   // hold here until we've got keyboard input, any signal except SIGWINCH\n   // or (optionally) we timeout with nanosecond granularity\n#else\n   // hold here until we've got keyboard input, any signal (including SIGWINCH)\n   // or (optionally) we timeout with nanosecond granularity\n#endif\n   rc = pselect(STDIN_FILENO + 1, &fs, NULL, NULL, ts, &Sigwinch_set);\n\n   if (rc < 0) rc = 0;\n   return rc;\n} // end: ioa\n\n\n        /*\n         * This routine isolates ALL user INPUT and ensures that we\n         * wont be mixing I/O from stdio and low-level read() requests */\nstatic int ioch (int ech, char *buf, unsigned cnt) {\n   int rc = -1;\n\n#ifdef TERMIOS_ONLY\n   if (ech) {\n      tcsetattr(STDIN_FILENO, TCSAFLUSH, &Tty_tweaked);\n      rc = read(STDIN_FILENO, buf, cnt);\n      tcsetattr(STDIN_FILENO, TCSAFLUSH, &Tty_raw);\n   } else {\n      if (ioa(NULL))\n         rc = read(STDIN_FILENO, buf, cnt);\n   }\n#else\n   (void)ech;\n   if (ioa(NULL))\n      rc = read(STDIN_FILENO, buf, cnt);\n#endif\n\n   // zero means EOF, might happen if we erroneously get detached from terminal\n   if (0 == rc) bye_bye(NULL);\n\n   // it may have been the beginning of a lengthy escape sequence\n   tcflush(STDIN_FILENO, TCIFLUSH);\n\n   // note: we do NOT produce a valid 'string'\n   return rc;\n} // end: ioch\n\n\n        /*\n         * Support for single or multiple keystroke input AND\n         * escaped cursor motion keys.\n         * note: we support more keys than we currently need, in case\n         *       we attract new consumers in the future */\nstatic int iokey (int action) {\n   static char buf12[CAPBUFSIZ], buf13[CAPBUFSIZ]\n      , buf14[CAPBUFSIZ], buf15[CAPBUFSIZ];\n   static struct {\n      const char *str;\n      int key;\n   } tinfo_tab[] = {\n      { \"\\033\\n\",kbd_ENTER }, { NULL, kbd_UP       }, { NULL, kbd_DOWN     },\n      { NULL, kbd_LEFT     }, { NULL, kbd_RIGHT    }, { NULL, kbd_PGUP     },\n      { NULL, kbd_PGDN     }, { NULL, kbd_HOME     }, { NULL, kbd_END      },\n      { NULL, kbd_BKSP     }, { NULL, kbd_INS      }, { NULL, kbd_DEL      },\n         // next 4 destined to be meta + arrow keys...\n      { buf12, kbd_PGUP    }, { buf13, kbd_PGDN    },\n      { buf14, kbd_HOME    }, { buf15, kbd_END     },\n         // remainder are alternatives for above, just in case...\n         // ( the k,j,l,h entries are the vim cursor motion keys )\n      { \"\\033\\\\\",   kbd_UP    }, { \"\\033/\",    kbd_DOWN  }, /* meta+      \\,/ */\n      { \"\\033<\",    kbd_LEFT  }, { \"\\033>\",    kbd_RIGHT }, /* meta+      <,> */\n      { \"\\033k\",    kbd_UP    }, { \"\\033j\",    kbd_DOWN  }, /* meta+      k,j */\n      { \"\\033h\",    kbd_LEFT  }, { \"\\033l\",    kbd_RIGHT }, /* meta+      h,l */\n      { \"\\033\\013\", kbd_PGUP  }, { \"\\033\\012\", kbd_PGDN  }, /* ctrl+meta+ k,j */\n      { \"\\033\\010\", kbd_HOME  }, { \"\\033\\014\", kbd_END   }  /* ctrl+meta+ h,l */\n   };\n#ifdef TERMIOS_ONLY\n   char buf[SMLBUFSIZ], *pb;\n#else\n   static char buf[SMLBUFSIZ];\n   static int pos, len;\n   char *pb;\n#endif\n   int i;\n\n   if (action == 0) {\n    #define tOk(s)  s ? s : \"\"\n      tinfo_tab[1].str  = tOk(key_up);\n      tinfo_tab[2].str  = tOk(key_down);\n      tinfo_tab[3].str  = tOk(key_left);\n      tinfo_tab[4].str  = tOk(key_right);\n      tinfo_tab[5].str  = tOk(key_ppage);\n      tinfo_tab[6].str  = tOk(key_npage);\n      tinfo_tab[7].str  = tOk(key_home);\n      tinfo_tab[8].str  = tOk(key_end);\n      tinfo_tab[9].str  = tOk(key_backspace);\n      tinfo_tab[10].str = tOk(key_ic);\n      tinfo_tab[11].str = tOk(key_dc);\n      STRLCPY(buf12, fmtmk(\"\\033%s\", tOk(key_up)));\n      STRLCPY(buf13, fmtmk(\"\\033%s\", tOk(key_down)));\n      STRLCPY(buf14, fmtmk(\"\\033%s\", tOk(key_left)));\n      STRLCPY(buf15, fmtmk(\"\\033%s\", tOk(key_right)));\n      // next is critical so returned results match bound terminfo keys\n      putp(tOk(keypad_xmit));\n      // ( converse keypad_local issued at pause/pgm end, just in case )\n      return 0;\n    #undef tOk\n   }\n\n   if (action == 1) {\n      memset(buf, '\\0', sizeof(buf));\n      if (1 > ioch(0, buf, sizeof(buf)-1)) return 0;\n   }\n\n#ifndef TERMIOS_ONLY\n   if (action == 2) {\n      if (pos < len)\n         return buf[pos++];            // exhaust prior keystrokes\n      pos = len = 0;\n      memset(buf, '\\0', sizeof(buf));\n      if (1 > ioch(0, buf, sizeof(buf)-1)) return 0;\n      if (isprint(buf[0])) {           // no need for translation\n         len = strlen(buf);\n         pos = 1;\n         return buf[0];\n      }\n   }\n#endif\n\n   /* some emulators implement 'key repeat' too well and we get duplicate\n      key sequences -- so we'll focus on the last escaped sequence, while\n      also allowing use of the meta key... */\n   if (!(pb = strrchr(buf, '\\033'))) pb = buf;\n   else if (pb > buf && '\\033' == *(pb - 1)) --pb;\n\n   for (i = 0; i < MAXTBL(tinfo_tab); i++)\n      if (!strcmp(tinfo_tab[i].str, pb))\n         return tinfo_tab[i].key;\n\n   // no match, so we'll return single non-escaped keystrokes only\n   if (buf[0] == '\\033' && buf[1]) return 0;\n   return buf[0];\n} // end: iokey\n\n\n#ifdef TERMIOS_ONLY\n        /*\n         * Get line oriented interactive input from the user,\n         * using native tty support */\nstatic char *ioline (const char *prompt) {\n   static const char ws[] = \"\\b\\f\\n\\r\\t\\v\\x1b\\x9b\";  // 0x1b + 0x9b are escape\n   static char buf[MEDBUFSIZ];\n   char *p;\n\n   show_pmt(prompt);\n   memset(buf, '\\0', sizeof(buf));\n   ioch(1, buf, sizeof(buf)-1);\n\n   if ((p = strpbrk(buf, ws))) *p = '\\0';\n   // note: we DO produce a vaid 'string'\n   return buf;\n} // end: ioline\n\n#else\n        /*\n         * Get line oriented interactive input from the user,\n         * going way beyond native tty support by providing:\n         * . true line editing, not just destructive backspace\n         * . an input limit sensitive to current screen dimensions\n         * . ability to recall prior strings for re-input/re-editing */\nstatic char *ioline (const char *prompt) {\n #define savMAX  50\n    // thank goodness memmove allows the two strings to overlap\n #define sqzSTR  { memmove(&buf[pos], &buf[pos+1], bufMAX-pos); \\\n       buf[sizeof(buf)-1] = '\\0'; }\n #define expSTR  if (len+1 < bufMAX && len+beg+1 < Screen_cols) { \\\n       memmove(&buf[pos+1], &buf[pos], bufMAX-pos); buf[pos] = ' '; }\n #define logCOL  (pos+1)\n #define phyCOL  (beg+pos+1)\n #define bufMAX  ((int)sizeof(buf)-2)  // -1 for '\\0' string delimeter\n   static char buf[MEDBUFSIZ+1];       // +1 for '\\0' string delimeter\n   static int ovt;\n   int beg, pos, len, key, i;\n   struct lin_s {\n      struct lin_s *bkw;               // ptr to older saved strs\n      struct lin_s *fwd;               // ptr to newer saved strs\n      char *str;                       // the saved string\n   };\n   static struct lin_s *anchor, *plin;\n\n   if (!anchor) {\n      anchor = alloc_c(sizeof(struct lin_s));\n      anchor->str = alloc_s(\"\");       // top-of-stack == empty str\n   }\n   plin = anchor;\n   pos = 0;\n   beg = show_pmt(prompt);\n   memset(buf, '\\0', sizeof(buf));\n   putp(ovt ? Cap_curs_huge : Cap_curs_norm);\n\n   do {\n      fflush(stdout);\n      len = strlen(buf);\n      key = iokey(2);\n      switch (key) {\n         case 0:\n            buf[0] = '\\0';\n            return buf;\n         case kbd_ESC:\n            buf[0] = kbd_ESC;\n            return buf;\n         case kbd_ENTER:\n            continue;\n         case kbd_INS:\n            ovt = !ovt;\n            putp(ovt ? Cap_curs_huge : Cap_curs_norm);\n            break;\n         case kbd_DEL:\n            sqzSTR\n            break;\n         case kbd_BKSP :\n            if (0 < pos) { --pos; sqzSTR }\n            break;\n         case kbd_LEFT:\n            if (0 < pos) --pos;\n            break;\n         case kbd_RIGHT:\n            if (pos < len) ++pos;\n            break;\n         case kbd_HOME:\n            pos = 0;\n            break;\n         case kbd_END:\n            pos = len;\n            break;\n         case kbd_UP:\n            if (plin->bkw) {\n               plin = plin->bkw;\n               memset(buf, '\\0', sizeof(buf));\n               pos = snprintf(buf, sizeof(buf), \"%.*s\", Screen_cols - beg - 1, plin->str);\n            }\n            break;\n         case kbd_DOWN:\n            memset(buf, '\\0', sizeof(buf));\n            if (plin->fwd) plin = plin->fwd;\n            pos = snprintf(buf, sizeof(buf), \"%.*s\", Screen_cols - beg - 1, plin->str);\n            break;\n         default:                      // what we REALLY wanted (maybe)\n            if (isprint(key) && logCOL < bufMAX && phyCOL < Screen_cols) {\n               if (!ovt) expSTR\n               buf[pos++] = key;\n            }\n            break;\n      }\n      putp(fmtmk(\"%s%s%s\", tg2(beg, Msg_row), Cap_clr_eol, buf));\n      putp(tg2(beg+pos, Msg_row));\n   } while (key != kbd_ENTER);\n\n   // weed out duplicates, including empty strings (top-of-stack)...\n   for (i = 0, plin = anchor; ; i++) {\n#ifdef RECALL_FIXED\n      if (!STRCMP(plin->str, buf))     // if matched, retain original order\n         return buf;\n#else\n      if (!STRCMP(plin->str, buf)) {   // if matched, rearrange stack order\n         if (i > 1) {                  // but not null str or if already #2\n            if (plin->bkw)             // splice around this matched string\n               plin->bkw->fwd = plin->fwd; // if older exists link to newer\n            plin->fwd->bkw = plin->bkw;    // newer linked to older or NULL\n            anchor->bkw->fwd = plin;   // stick matched on top of former #2\n            plin->bkw = anchor->bkw;   // keep empty string at top-of-stack\n            plin->fwd = anchor;        // then prepare to be the 2nd banana\n            anchor->bkw = plin;        // by sliding us in below the anchor\n         }\n         return buf;\n      }\n#endif\n      if (!plin->bkw) break;           // let i equal total stacked strings\n      plin = plin->bkw;                // ( with plin representing bottom )\n   }\n   if (i < savMAX)\n      plin = alloc_c(sizeof(struct lin_s));\n   else {                              // when a new string causes overflow\n      plin->fwd->bkw = NULL;           // make next-to-last string new last\n      free(plin->str);                 // and toss copy but keep the struct\n   }\n   plin->str = alloc_s(buf);           // copy user's new unique input line\n   plin->bkw = anchor->bkw;            // keep empty string as top-of-stack\n   if (plin->bkw)                      // did we have some already stacked?\n      plin->bkw->fwd = plin;           // yep, so point prior to new string\n   plin->fwd = anchor;                 // and prepare to be a second banana\n   anchor->bkw = plin;                 // by sliding it in as new number 2!\n\n   return buf;                         // protect our copy, return original\n #undef savMAX\n #undef sqzSTR\n #undef expSTR\n #undef logCOL\n #undef phyCOL\n #undef bufMAX\n} // end: ioline\n#endif\n\n\n        /*\n         * Make locale unaware float (but maybe restrict to whole numbers). */\nstatic int mkfloat (const char *str, float *num, int whole) {\n   char tmp[SMLBUFSIZ], *ep;\n\n   if (whole) {\n      *num = (float)strtol(str, &ep, 0);\n      if (ep != str && *ep == '\\0' && *num < INT_MAX)\n         return 1;\n      return 0;\n   }\n   snprintf(tmp, sizeof(tmp), \"%s\", str);\n   *num = strtof(tmp, &ep);\n   if (*ep != '\\0') {\n      // fallback - try to swap the floating point separator\n      if (*ep == '.') *ep = ',';\n      else if (*ep == ',') *ep = '.';\n      *num = strtof(tmp, &ep);\n   }\n   if (ep != tmp && *ep == '\\0' && *num < INT_MAX)\n      return 1;\n   return 0;\n} // end: mkfloat\n\n\n        /*\n         * This routine provides the i/o in support of files whose size\n         * cannot be determined in advance.  Given a stream pointer, he'll\n         * try to slurp in the whole thing and return a dynamically acquired\n         * buffer supporting that single string glob.\n         *\n         * He always creates a buffer at least READMINSZ big, possibly\n         * all zeros (an empty string), even if the file wasn't read. */\nstatic int readfile (FILE *fp, char **baddr, size_t *bsize, size_t *bread) {\n   char chunk[4096*16];\n   size_t num;\n\n   *bread = 0;\n   *bsize = READMINSZ;\n   *baddr = alloc_c(READMINSZ);\n   if (fp) {\n      while (0 < (num = fread(chunk, 1, sizeof(chunk), fp))) {\n         *baddr = alloc_r(*baddr, num + *bsize);\n         memcpy(*baddr + *bread, chunk, num);\n         *bread += num;\n         *bsize += num;\n      };\n      *(*baddr + *bread) = '\\0';\n      return ferror(fp);\n   }\n   return ENOENT;\n} // end: readfile\n\f\n/*######  Small Utility routines  ########################################*/\n\n#define GET_NUM_BAD  INT_MIN\n#define GET_NUM_ESC (INT_MIN + 1)\n#define GET_NUM_NOT (INT_MIN + 2)\n\n        /*\n         * Get a float from the user */\nstatic float get_float (const char *prompt) {\n   char *line;\n   float f;\n\n   line = ioline(prompt);\n   if (line[0] == kbd_ESC || Frames_signal) return GET_NUM_ESC;\n   if (!line[0]) return GET_NUM_NOT;\n   // note: we're not allowing negative floats\n   if (!mkfloat(line, &f, 0) || f < 0) {\n      show_msg(N_txt(BAD_numfloat_txt));\n      return GET_NUM_BAD;\n   }\n   return f;\n} // end: get_float\n\n\n        /*\n         * Get an integer from the user, returning INT_MIN for error */\nstatic int get_int (const char *prompt) {\n   char *line;\n   float f;\n\n   line = ioline(prompt);\n   if (line[0] == kbd_ESC || Frames_signal) return GET_NUM_ESC;\n   if (!line[0]) return GET_NUM_NOT;\n   // note: we've got to allow negative ints (renice)\n   if (!mkfloat(line, &f, 1)) {\n      show_msg(N_txt(BAD_integers_txt));\n      return GET_NUM_BAD;\n   }\n   return (int)f;\n} // end: get_int\n\n\n        /*\n         * Make a hex value, and maybe suppress zeroes. */\nstatic inline const char *hex_make (KLONG num, int noz) {\n   static char buf[SMLBUFSIZ];\n   int i;\n\n#ifdef CASEUP_HEXES\n   snprintf(buf, sizeof(buf), \"%08\" KLF \"X\", num);\n#else\n   snprintf(buf, sizeof(buf), \"%08\" KLF \"x\", num);\n#endif\n   if (noz)\n      for (i = 0; buf[i]; i++)\n         if ('0' == buf[i])\n            buf[i] = '.';\n   return buf;\n} // end: hex_make\n\n\n        /*\n         * This sructure is hung from a WIN_t when other filtering is active */\nstruct osel_s {\n   struct osel_s *nxt;                         // the next criteria or NULL.\n   int (*rel)(const char *, const char *);     // relational strings compare\n   char *(*sel)(const char *, const char *);   // for selection str compares\n   char *raw;                                  // raw user input (dup check)\n   char *val;                                  // value included or excluded\n   int   ops;                                  // filter delimiter/operation\n   int   inc;                                  // include == 1, exclude == 0\n   int   enu;                                  // field (procflag) to filter\n};\n\n\n        /*\n         * A function to turn off entire other filtering in the given window */\nstatic void osel_clear (WIN_t *q) {\n   struct osel_s *osel = q->osel_1st;\n\n   while (osel) {\n      struct osel_s *nxt = osel->nxt;\n      free(osel->val);\n      free(osel->raw);\n      free(osel);\n      osel = nxt;\n   }\n   q->osel_tot = 0;\n   q->osel_1st = NULL;\n   free (q->osel_prt);\n   q->osel_prt = NULL;\n#ifndef USE_X_COLHDR\n   OFFw(Curwin, NOHISEL_xxx);\n#endif\n} // end: osel_clear\n\n\n        /*\n         * Determine if there are matching values or relationships among the\n         * other criteria in this passed window -- it's called from only one\n         * place, and likely inlined even without the directive */\nstatic inline int osel_matched (const WIN_t *q, FLG_t enu, const char *str) {\n   struct osel_s *osel = q->osel_1st;\n\n   while (osel) {\n      if (osel->enu == enu) {\n         int r;\n         switch (osel->ops) {\n            case '<':                          // '<' needs the r < 0 unless\n               r = osel->rel(str, osel->val);  // '!' which needs an inverse\n               if ((r >= 0 && osel->inc) || (r < 0 && !osel->inc)) return 0;\n               break;\n            case '>':                          // '>' needs the r > 0 unless\n               r = osel->rel(str, osel->val);  // '!' which needs an inverse\n               if ((r <= 0 && osel->inc) || (r > 0 && !osel->inc)) return 0;\n               break;\n            default:\n            {  char *p = osel->sel(str, osel->val);\n               if ((!p && osel->inc) || (p && !osel->inc)) return 0;\n            }\n               break;\n         }\n      }\n      osel = osel->nxt;\n   }\n   return 1;\n} // end: osel_matched\n\n\n        /*\n         * Validate the passed string as a user name or number,\n         * and/or update the window's 'u/U' selection stuff. */\nstatic const char *user_certify (WIN_t *q, const char *str, char typ) {\n   struct passwd *pwd;\n   char *endp;\n   uid_t num;\n\n   q->usrseltyp = 0;\n   q->usrselflg = 1;\n   Monpidsidx = 0;\n   if (*str) {\n      if ('!' == *str) { ++str; q->usrselflg = 0; }\n      num = (uid_t)strtoul(str, &endp, 0);\n      if ('\\0' == *endp) {\n         pwd = getpwuid(num);\n         if (!pwd) {\n         /* allow foreign users, from e.g within chroot\n          ( thanks Dr. Werner Fink <werner@suse.de> ) */\n            q->usrseluid = num;\n            q->usrseltyp = typ;\n            return NULL;\n         }\n      } else\n         pwd = getpwnam(str);\n      if (!pwd) return N_txt(BAD_username_txt);\n      q->usrseluid = pwd->pw_uid;\n      q->usrseltyp = typ;\n   }\n   return NULL;\n} // end: user_certify\n\n\n        /*\n         * Determine if this proc_t matches the 'u/U' selection criteria\n         * for a given window -- it's called from only one place, and\n         * likely inlined even without the directive */\nstatic inline int user_matched (const WIN_t *q, const proc_t *p) {\n   switch(q->usrseltyp) {\n      case 0:                                    // uid selection inactive\n         return 1;\n      case 'U':                                  // match any uid\n         if (p->ruid == q->usrseluid) return q->usrselflg;\n         if (p->suid == q->usrseluid) return q->usrselflg;\n         if (p->fuid == q->usrseluid) return q->usrselflg;\n      // fall through...\n      case 'u':                                  // match effective uid\n         if (p->euid == q->usrseluid) return q->usrselflg;\n      // fall through...\n      default:                                   // no match...\n         ;\n   }\n   return !q->usrselflg;\n} // end: user_matched\n\f\n/*######  Basic Formatting support  ######################################*/\n\n        /*\n         * Just do some justify stuff, then add post column padding. */\nstatic inline const char *justify_pad (const char *str, int width, int justr) {\n   static char l_fmt[]  = \"%-*.*s%s\", r_fmt[] = \"%*.*s%s\";\n   static char buf[SCREENMAX];\n\n   snprintf(buf, sizeof(buf), justr ? r_fmt : l_fmt, width, width, str, COLPADSTR);\n   return buf;\n} // end: justify_pad\n\n\n        /*\n         * Make and then justify a single character. */\nstatic inline const char *make_chr (const char ch, int width, int justr) {\n   static char buf[SMLBUFSIZ];\n\n   snprintf(buf, sizeof(buf), \"%c\", ch);\n   return justify_pad(buf, width, justr);\n} // end: make_chr\n\n\n        /*\n         * Make and then justify an integer NOT subject to scaling,\n         * and include a visual clue should tuncation be necessary. */\nstatic inline const char *make_num (long num, int width, int justr, int col, int noz) {\n   static char buf[SMLBUFSIZ];\n\n   buf[0] = '\\0';\n   if (noz && Rc.zero_suppress && 0 == num)\n      goto end_justifies;\n\n   if (width < snprintf(buf, sizeof(buf), \"%ld\", num)) {\n      if (width <= 0 || (size_t)width >= sizeof(buf))\n         width = sizeof(buf)-1;\n      buf[width-1] = COLPLUSCH;\n      buf[width] = '\\0';\n      AUTOX_COL(col);\n   }\nend_justifies:\n   return justify_pad(buf, width, justr);\n} // end: make_num\n\n\n        /*\n         * Make and then justify a character string,\n         * and include a visual clue should tuncation be necessary. */\nstatic inline const char *make_str (const char *str, int width, int justr, int col) {\n   static char buf[SCREENMAX];\n\n   if (width < snprintf(buf, sizeof(buf), \"%s\", str)) {\n      if (width <= 0 || (size_t)width >= sizeof(buf))\n         width = sizeof(buf)-1;\n      buf[width-1] = COLPLUSCH;\n      buf[width] = '\\0';\n      AUTOX_COL(col);\n   }\n   return justify_pad(buf, width, justr);\n} // end: make_str\n\n\n        /*\n         * Make and then justify a potentially multi-byte character string,\n         * and include a visual clue should tuncation be necessary. */\nstatic inline const char *make_str_utf8 (const char *str, int width, int justr, int col) {\n   static char buf[SCREENMAX];\n   int delta = utf8_delta(str);\n\n   if (width + delta < snprintf(buf, sizeof(buf), \"%s\", str)) {\n      snprintf(buf, sizeof(buf), \"%.*s%c\", utf8_embody(str, width-1), str, COLPLUSCH);\n      delta = utf8_delta(buf);\n      AUTOX_COL(col);\n   }\n   return justify_pad(buf, width + delta, justr);\n} // end: make_str_utf8\n\n\n        /*\n         * Do some scaling then justify stuff.\n         * We'll interpret 'num' as a kibibytes quantity and try to\n         * format it to reach 'target' while also fitting 'width'. */\nstatic const char *scale_mem (int target, unsigned long num, int width, int justr) {\n   //                               SK_Kb   SK_Mb      SK_Gb      SK_Tb      SK_Pb      SK_Eb\n#ifdef BOOST_MEMORY\n   static const char *fmttab[] =  { \"%.0f\", \"%#.1f%c\", \"%#.3f%c\", \"%#.3f%c\", \"%#.3f%c\", NULL };\n#else\n   static const char *fmttab[] =  { \"%.0f\", \"%.1f%c\",  \"%.1f%c\",  \"%.1f%c\",  \"%.1f%c\",  NULL };\n#endif\n   static char buf[SMLBUFSIZ];\n   float scaled_num;\n   char *psfx;\n   int i;\n\n   buf[0] = '\\0';\n   if (Rc.zero_suppress && 0 >= num)\n      goto end_justifies;\n\n   scaled_num = num;\n   for (i = SK_Kb, psfx = Scaled_sfxtab; i < SK_Eb; psfx++, i++) {\n      if (i >= target\n      && (width >= snprintf(buf, sizeof(buf), fmttab[i], scaled_num, *psfx)))\n         goto end_justifies;\n      scaled_num /= 1024.0;\n   }\n\n   // well shoot, this outta' fit...\n   snprintf(buf, sizeof(buf), \"?\");\nend_justifies:\n   return justify_pad(buf, width, justr);\n} // end: scale_mem\n\n\n        /*\n         * Do some scaling then justify stuff. */\nstatic const char *scale_num (unsigned long num, int width, int justr) {\n   static char buf[SMLBUFSIZ];\n   float scaled_num;\n   char *psfx;\n\n   buf[0] = '\\0';\n   if (Rc.zero_suppress && 0 >= num)\n      goto end_justifies;\n   if (width >= snprintf(buf, sizeof(buf), \"%lu\", num))\n      goto end_justifies;\n\n   scaled_num = num;\n   for (psfx = Scaled_sfxtab; 0 < *psfx; psfx++) {\n      scaled_num /= 1024.0;\n      if (width >= snprintf(buf, sizeof(buf), \"%.1f%c\", scaled_num, *psfx))\n         goto end_justifies;\n      if (width >= snprintf(buf, sizeof(buf), \"%.0f%c\", scaled_num, *psfx))\n         goto end_justifies;\n   }\n\n   // well shoot, this outta' fit...\n   snprintf(buf, sizeof(buf), \"?\");\nend_justifies:\n   return justify_pad(buf, width, justr);\n} // end: scale_num\n\n\n        /*\n         * Make and then justify a percentage, with decreasing precision. */\nstatic const char *scale_pcnt (float num, int width, int justr) {\n   static char buf[SMLBUFSIZ];\n\n   buf[0] = '\\0';\n   if (Rc.zero_suppress && 0 >= num)\n      goto end_justifies;\n#ifdef BOOST_PERCNT\n   if (width >= snprintf(buf, sizeof(buf), \"%#.3f\", num))\n      goto end_justifies;\n   if (width >= snprintf(buf, sizeof(buf), \"%#.2f\", num))\n      goto end_justifies;\n#endif\n   if (width >= snprintf(buf, sizeof(buf), \"%#.1f\", num))\n      goto end_justifies;\n   if (width >= snprintf(buf, sizeof(buf), \"%*.0f\", width, num))\n      goto end_justifies;\n\n   // well shoot, this outta' fit...\n   snprintf(buf, sizeof(buf), \"?\");\nend_justifies:\n   return justify_pad(buf, width, justr);\n} // end: scale_pcnt\n\n\n        /*\n         * Do some scaling stuff.\n         * Format 'tics' to fit 'width', then justify it. */\nstatic const char *scale_tics (TIC_t tics, int width, int justr) {\n#ifdef CASEUP_SUFIX\n #define HH \"%uH\"                                                  // nls_maybe\n #define DD \"%uD\"\n #define WW \"%uW\"\n#else\n #define HH \"%uh\"                                                  // nls_maybe\n #define DD \"%ud\"\n #define WW \"%uw\"\n#endif\n   static char buf[SMLBUFSIZ];\n   unsigned long nt;    // narrow time, for speed on 32-bit\n   unsigned cc;         // centiseconds\n   unsigned nn;         // multi-purpose whatever\n\n   buf[0] = '\\0';\n   nt  = (tics * 100ull) / Hertz;               // up to 68 weeks of cpu time\n   if (Rc.zero_suppress && 0 >= nt)\n      goto end_justifies;\n   cc  = nt % 100;                              // centiseconds past second\n   nt /= 100;                                   // total seconds\n   nn  = nt % 60;                               // seconds past the minute\n   nt /= 60;                                    // total minutes\n   if (width >= snprintf(buf, sizeof(buf), \"%lu:%02u.%02u\", nt, nn, cc))\n      goto end_justifies;\n   if (width >= snprintf(buf, sizeof(buf), \"%lu:%02u\", nt, nn))\n      goto end_justifies;\n   nn  = nt % 60;                               // minutes past the hour\n   nt /= 60;                                    // total hours\n   if (width >= snprintf(buf, sizeof(buf), \"%lu,%02u\", nt, nn))\n      goto end_justifies;\n   nn = nt;                                     // now also hours\n   if (width >= snprintf(buf, sizeof(buf), HH, nn))\n      goto end_justifies;\n   nn /= 24;                                    // now days\n   if (width >= snprintf(buf, sizeof(buf), DD, nn))\n      goto end_justifies;\n   nn /= 7;                                     // now weeks\n   if (width >= snprintf(buf, sizeof(buf), WW, nn))\n      goto end_justifies;\n\n   // well shoot, this outta' fit...\n   snprintf(buf, sizeof(buf), \"?\");\nend_justifies:\n   return justify_pad(buf, width, justr);\n #undef HH\n #undef DD\n #undef WW\n} // end: scale_tics\n\f\n/*######  Fields Management support  #####################################*/\n\n   /* These are the Fieldstab.lflg values used here and in calibrate_fields.\n      (own identifiers as documentation and protection against changes) */\n#define L_stat     PROC_FILLSTAT\n#define L_statm    PROC_FILLMEM\n#define L_status   PROC_FILLSTATUS\n#define L_CGROUP   PROC_EDITCGRPCVT | PROC_FILLCGROUP\n#define L_CMDLINE  PROC_EDITCMDLCVT | PROC_FILLARG\n#define L_ENVIRON  PROC_EDITENVRCVT | PROC_FILLENV\n#define L_EUSER    PROC_FILLUSR\n#define L_OUSER    PROC_FILLSTATUS | PROC_FILLUSR\n#define L_EGROUP   PROC_FILLSTATUS | PROC_FILLGRP\n#define L_SUPGRP   PROC_FILLSTATUS | PROC_FILLSUPGRP\n#define L_NS       PROC_FILLNS\n#define L_LXC      PROC_FILL_LXC\n#define L_OOM      PROC_FILLOOM\n   // make 'none' non-zero (used to be important to Frames_libflags)\n#define L_NONE     PROC_SPARE_1\n   // from 'status' or 'stat' (favor stat), via bits not otherwise used\n#define L_EITHER   PROC_SPARE_2\n   // for calibrate_fields and summary_show 1st pass\n#define L_DEFAULT  PROC_FILLSTAT\n\n        /* These are our gosh darn 'Fields' !\n           They MUST be kept in sync with pflags !! */\nstatic FLD_t Fieldstab[] = {\n   // a temporary macro, soon to be undef'd...\n #define SF(f) (QFP_t)SCB_NAME(f)\n   // these identifiers reflect the default column alignment but they really\n   // contain the WIN_t flag used to check/change justification at run-time!\n #define A_right Show_JRNUMS       /* toggled with upper case 'J' */\n #define A_left  Show_JRSTRS       /* toggled with lower case 'j' */\n\n/* .width anomalies:\n        a -1 width represents variable width columns\n        a  0 width represents columns set once at startup (see zap_fieldstab)\n   .lflg anomalies:\n        EU_UED, L_NONE - natural outgrowth of 'stat()' in readproc        (euid)\n        EU_CPU, L_stat - never filled by libproc, but requires times      (pcpu)\n        EU_CMD, L_stat - may yet require L_CMDLINE in calibrate_fields    (cmd/cmdline)\n        L_EITHER       - favor L_stat (L_status == ++cost of gpref & hash scheme)\n\n     .width  .scale  .align    .sort     .lflg\n     ------  ------  --------  --------  --------  */\n   {     0,     -1,  A_right,  SF(PID),  L_NONE    },\n   {     0,     -1,  A_right,  SF(PPD),  L_EITHER  },\n   {     5,     -1,  A_right,  SF(UED),  L_NONE    },\n   {     8,     -1,  A_left,   SF(UEN),  L_EUSER   },\n   {     5,     -1,  A_right,  SF(URD),  L_status  },\n   {     8,     -1,  A_left,   SF(URN),  L_OUSER   },\n   {     5,     -1,  A_right,  SF(USD),  L_status  },\n   {     8,     -1,  A_left,   SF(USN),  L_OUSER   },\n   {     5,     -1,  A_right,  SF(GID),  L_NONE    },\n   {     8,     -1,  A_left,   SF(GRP),  L_EGROUP  },\n   {     0,     -1,  A_right,  SF(PGD),  L_stat    },\n   {     8,     -1,  A_left,   SF(TTY),  L_stat    },\n   {     0,     -1,  A_right,  SF(TPG),  L_stat    },\n   {     0,     -1,  A_right,  SF(SID),  L_stat    },\n   {     3,     -1,  A_right,  SF(PRI),  L_stat    },\n   {     3,     -1,  A_right,  SF(NCE),  L_stat    },\n   {     3,     -1,  A_right,  SF(THD),  L_EITHER  },\n   {     0,     -1,  A_right,  SF(CPN),  L_stat    },\n   {     5,     -1,  A_right,  SF(CPU),  L_stat    },\n   {     6,     -1,  A_right,  SF(TME),  L_stat    },\n   {     9,     -1,  A_right,  SF(TME),  L_stat    }, // EU_TM2 slot\n   {     5,     -1,  A_right,  SF(RES),  L_statm   }, // EU_MEM slot\n   {     7,  SK_Kb,  A_right,  SF(VRT),  L_statm   },\n   {     6,  SK_Kb,  A_right,  SF(SWP),  L_status  },\n   {     6,  SK_Kb,  A_right,  SF(RES),  L_statm   },\n   {     6,  SK_Kb,  A_right,  SF(COD),  L_statm   },\n   {     7,  SK_Kb,  A_right,  SF(DAT),  L_statm   },\n   {     6,  SK_Kb,  A_right,  SF(SHR),  L_statm   },\n   {     4,     -1,  A_right,  SF(FL1),  L_stat    },\n   {     4,     -1,  A_right,  SF(FL2),  L_stat    },\n   {     4,     -1,  A_right,  SF(DRT),  L_statm   },\n   {     1,     -1,  A_right,  SF(STA),  L_EITHER  },\n   {    -1,     -1,  A_left,   SF(CMD),  L_EITHER  },\n   {    10,     -1,  A_left,   SF(WCH),  L_stat    },\n   {     8,     -1,  A_left,   SF(FLG),  L_stat    },\n   {    -1,     -1,  A_left,   SF(CGR),  L_CGROUP  },\n   {    -1,     -1,  A_left,   SF(SGD),  L_status  },\n   {    -1,     -1,  A_left,   SF(SGN),  L_SUPGRP  },\n   {     0,     -1,  A_right,  SF(TGD),  L_NONE    },\n   {     5,     -1,  A_right,  SF(OOA),  L_OOM     },\n   {     4,     -1,  A_right,  SF(OOM),  L_OOM     },\n   {    -1,     -1,  A_left,   SF(ENV),  L_ENVIRON },\n   {     3,     -1,  A_right,  SF(FV1),  L_stat    },\n   {     3,     -1,  A_right,  SF(FV2),  L_stat    },\n   {     6,  SK_Kb,  A_right,  SF(USE),  L_status  },\n   {    10,     -1,  A_right,  SF(NS1),  L_NS      }, // IPCNS\n   {    10,     -1,  A_right,  SF(NS2),  L_NS      }, // MNTNS\n   {    10,     -1,  A_right,  SF(NS3),  L_NS      }, // NETNS\n   {    10,     -1,  A_right,  SF(NS4),  L_NS      }, // PIDNS\n   {    10,     -1,  A_right,  SF(NS5),  L_NS      }, // USERNS\n   {    10,     -1,  A_right,  SF(NS6),  L_NS      }, // UTSNS\n   {     8,     -1,  A_left,   SF(LXC),  L_LXC     },\n   {     6,  SK_Kb,  A_right,  SF(RZA),  L_status  },\n   {     6,  SK_Kb,  A_right,  SF(RZF),  L_status  },\n   {     6,  SK_Kb,  A_right,  SF(RZL),  L_status  },\n   {     6,  SK_Kb,  A_right,  SF(RZS),  L_status  },\n   {    -1,     -1,  A_left,   SF(CGN),  L_CGROUP  },\n   {     0,     -1,  A_right,  SF(NMA),  L_stat    },\n #undef SF\n #undef A_left\n #undef A_right\n};\n\n\n        /*\n         * A calibrate_fields() *Helper* function to refresh the\n         * cached screen geometry and related variables */\nstatic void adj_geometry (void) {\n   static size_t pseudo_max = 0;\n   static int w_set = 0, w_cols = 0, w_rows = 0;\n   struct winsize wz;\n\n   Screen_cols = columns;    // <term.h>\n   Screen_rows = lines;      // <term.h>\n\n   if (-1 != ioctl(STDOUT_FILENO, TIOCGWINSZ, &wz)\n   && 0 < wz.ws_col && 0 < wz.ws_row) {\n      Screen_cols = wz.ws_col;\n      Screen_rows = wz.ws_row;\n   }\n\n#ifndef RMAN_IGNORED\n   // be crudely tolerant of crude tty emulators\n   if (Cap_avoid_eol) Screen_cols--;\n#endif\n\n   // we might disappoint some folks (but they'll deserve it)\n   if (Screen_cols > SCREENMAX) Screen_cols = SCREENMAX;\n   if (Screen_cols < W_MIN_COL) Screen_cols = W_MIN_COL;\n\n   if (!w_set) {\n      if (Width_mode > 0)              // -w with arg, we'll try to honor\n         w_cols = Width_mode;\n      else\n      if (Width_mode < 0) {            // -w without arg, try environment\n         char *env_columns = getenv(\"COLUMNS\"),\n              *env_lines = getenv(\"LINES\"),\n              *ep;\n         if (env_columns && *env_columns) {\n            long t, tc = 0;\n            t = strtol(env_columns, &ep, 0);\n            if (!*ep && (t > 0) && (t <= 0x7fffffffL)) tc = t;\n            if (0 < tc) w_cols = (int)tc;\n         }\n         if (env_lines && *env_lines) {\n            long t, tr = 0;\n            t = strtol(env_lines, &ep, 0);\n            if (!*ep && (t > 0) && (t <= 0x7fffffffL)) tr = t;\n            if (0 < tr) w_rows = (int)tr;\n         }\n         if (!w_cols) w_cols = SCREENMAX;\n         if (w_cols && w_cols < W_MIN_COL) w_cols = W_MIN_COL;\n         if (w_rows && w_rows < W_MIN_ROW) w_rows = W_MIN_ROW;\n      }\n      if (w_cols > SCREENMAX) w_cols = SCREENMAX;\n      w_set = 1;\n   }\n\n   /* keep our support for output optimization in sync with current reality\n      note: when we're in Batch mode, we don't really need a Pseudo_screen\n            and when not Batch, our buffer will contain 1 extra 'line' since\n            Msg_row is never represented -- but it's nice to have some space\n            between us and the great-beyond... */\n   if (Batch) {\n      if (w_cols) Screen_cols = w_cols;\n      Screen_rows = w_rows ? w_rows : INT_MAX;\n      Pseudo_size = (sizeof(*Pseudo_screen) * ROWMAXSIZ);\n   } else {\n      const int max_rows = INT_MAX / (sizeof(*Pseudo_screen) * ROWMAXSIZ);\n      if (w_cols && w_cols < Screen_cols) Screen_cols = w_cols;\n      if (w_rows && w_rows < Screen_rows) Screen_rows = w_rows;\n      if (Screen_rows < 0 || Screen_rows > max_rows) Screen_rows = max_rows;\n      Pseudo_size = (sizeof(*Pseudo_screen) * ROWMAXSIZ) * Screen_rows;\n   }\n   // we'll only grow our Pseudo_screen, never shrink it\n   if (pseudo_max < Pseudo_size) {\n      pseudo_max = Pseudo_size;\n      Pseudo_screen = alloc_r(Pseudo_screen, pseudo_max);\n   }\n   // ensure each row is repainted (just in case)\n   PSU_CLREOS(0);\n\n   // prepare to customize potential cpu/memory graphs\n   Graph_len = Screen_cols - GRAPH_prefix - GRAPH_actual - GRAPH_suffix;\n   if (Graph_len >= 0) Graph_len = GRAPH_actual;\n   else if (Screen_cols > 80) Graph_len = Screen_cols - GRAPH_prefix - GRAPH_suffix;\n   else Graph_len = 80 - GRAPH_prefix - GRAPH_suffix;\n   Graph_adj = (float)Graph_len / 100.0;\n\n   fflush(stdout);\n   Frames_signal = BREAK_off;\n} // end: adj_geometry\n\n\n        /*\n         * A calibrate_fields() *Helper* function to build the\n         * actual column headers and required library flags */\nstatic void build_headers (void) {\n   FLG_t f;\n   char *s;\n   WIN_t *w = Curwin;\n#ifdef EQUCOLHDRYES\n   int x, hdrmax = 0;\n#endif\n   int i;\n\n   Frames_libflags = 0;\n\n   do {\n      if (VIZISw(w)) {\n         memset((s = w->columnhdr), 0, sizeof(w->columnhdr));\n         if (Rc.mode_altscr) s = scat(s, fmtmk(\"%d\", w->winnum));\n         for (i = 0; i < w->maxpflgs; i++) {\n            f = w->procflgs[i];\n#ifdef USE_X_COLHDR\n            if (CHKw(w, Show_HICOLS) && f == w->rc.sortindx) {\n               s = scat(s, fmtmk(\"%s%s\", Caps_off, w->capclr_msg));\n               w->hdrcaplen += strlen(Caps_off) + strlen(w->capclr_msg);\n            }\n#else\n            if (EU_MAXPFLGS <= f) continue;\n#endif\n            if (EU_CMD == f && CHKw(w, Show_CMDLIN)) Frames_libflags |= L_CMDLINE;\n            Frames_libflags |= Fieldstab[f].lflg;\n            s = scat(s, utf8_justify(N_col(f)\n               , VARcol(f) ? w->varcolsz : Fieldstab[f].width\n               , CHKw(w, Fieldstab[f].align)));\n#ifdef USE_X_COLHDR\n            if (CHKw(w, Show_HICOLS) && f == w->rc.sortindx) {\n               s = scat(s, fmtmk(\"%s%s\", Caps_off, w->capclr_hdr));\n               w->hdrcaplen += strlen(Caps_off) + strlen(w->capclr_hdr);\n            }\n#endif\n         }\n#ifdef EQUCOLHDRYES\n         // prepare to even out column header lengths...\n         if (hdrmax + w->hdrcaplen < (x = strlen(w->columnhdr))) hdrmax = x - w->hdrcaplen;\n#endif\n         // with forest view mode, we'll need tgid, ppid & start_time...\n         if (CHKw(w, Show_FOREST)) Frames_libflags |= L_stat;\n         // for 'busy' only processes, we'll need pcpu (utime & stime)...\n         if (!CHKw(w, Show_IDLEPS)) Frames_libflags |= L_stat;\n         // we must also accommodate an out of view sort field...\n         f = w->rc.sortindx;\n         Frames_libflags |= Fieldstab[f].lflg;\n         if (EU_CMD == f && CHKw(w, Show_CMDLIN)) Frames_libflags |= L_CMDLINE;\n         // for 'U' filtering we need the other user ids too\n         if (w->usrseltyp == 'U') Frames_libflags |= L_status;\n      } // end: VIZISw(w)\n\n      if (Rc.mode_altscr) w = w->next;\n   } while (w != Curwin);\n\n#ifdef EQUCOLHDRYES\n   /* now we can finally even out column header lengths\n      (we're assuming entire columnhdr was memset to '\\0') */\n   if (Rc.mode_altscr && SCREENMAX > Screen_cols)\n      for (i = 0; i < GROUPSMAX; i++) {\n         w = &Winstk[i];\n         if (CHKw(w, Show_TASKON))\n            if (hdrmax + w->hdrcaplen > (x = strlen(w->columnhdr)))\n               memset(&w->columnhdr[x], ' ', hdrmax + w->hdrcaplen - x);\n      }\n#endif\n\n   // finalize/touchup the libproc PROC_FILLxxx flags for current config...\n   if (Frames_libflags & L_EITHER) {\n      if (!(Frames_libflags & (L_stat | L_status)))\n         Frames_libflags |= L_stat;\n   }\n   if (!Frames_libflags) Frames_libflags = L_DEFAULT;\n   if (Monpidsidx) Frames_libflags |= PROC_PID;\n} // end: build_headers\n\n\n        /*\n         * This guy coordinates the activities surrounding the maintenance\n         * of each visible window's columns headers and the library flags\n         * required for the openproc interface. */\nstatic void calibrate_fields (void) {\n   FLG_t f;\n   char *s;\n   const char *h;\n   WIN_t *w = Curwin;\n   int i, varcolcnt, len;\n\n   adj_geometry();\n\n   do {\n      if (VIZISw(w)) {\n         w->hdrcaplen = 0;   // really only used with USE_X_COLHDR\n         // build window's pflgsall array, establish upper bounds for maxpflgs\n         for (i = 0, w->totpflgs = 0; i < EU_MAXPFLGS; i++) {\n            if (FLDviz(w, i)) {\n               f = FLDget(w, i);\n#ifdef USE_X_COLHDR\n               w->pflgsall[w->totpflgs++] = f;\n#else\n               if (CHKw(w, Show_HICOLS) && f == w->rc.sortindx) {\n                  w->pflgsall[w->totpflgs++] = EU_XON;\n                  w->pflgsall[w->totpflgs++] = f;\n                  w->pflgsall[w->totpflgs++] = EU_XOF;\n               } else\n                  w->pflgsall[w->totpflgs++] = f;\n#endif\n            }\n         }\n         if (!w->totpflgs) w->pflgsall[w->totpflgs++] = EU_PID;\n\n         /* build a preliminary columns header not to exceed screen width\n            while accounting for a possible leading window number */\n         w->varcolsz = varcolcnt = 0;\n         *(s = w->columnhdr) = '\\0';\n         if (Rc.mode_altscr) s = scat(s, \" \");\n         for (i = 0; i + w->begpflg < w->totpflgs; i++) {\n            f = w->pflgsall[i + w->begpflg];\n            w->procflgs[i] = f;\n#ifndef USE_X_COLHDR\n            if (EU_MAXPFLGS <= f) continue;\n#endif\n            h = N_col(f);\n            len = (VARcol(f) ? (int)strlen(h) : Fieldstab[f].width) + COLPADSIZ;\n            // oops, won't fit -- we're outta here...\n            if (Screen_cols < ((int)(s - w->columnhdr) + len)) break;\n            if (VARcol(f)) { ++varcolcnt; w->varcolsz += strlen(h); }\n            s = scat(s, fmtmk(\"%*.*s\", len, len, h));\n         }\n#ifndef USE_X_COLHDR\n         if (i >= 1 && EU_XON == w->procflgs[i - 1]) --i;\n#endif\n\n         /* establish the final maxpflgs and prepare to grow the variable column\n            heading(s) via varcolsz - it may be a fib if their pflags weren't\n            encountered, but that's ok because they won't be displayed anyway */\n         w->maxpflgs = i;\n         w->varcolsz += Screen_cols - strlen(w->columnhdr);\n         if (varcolcnt) w->varcolsz /= varcolcnt;\n\n         /* establish the field where all remaining fields would still\n            fit within screen width, including a leading window number */\n         *(s = w->columnhdr) = '\\0';\n         if (Rc.mode_altscr) s = scat(s, \" \");\n         w->endpflg = 0;\n         for (i = w->totpflgs - 1; -1 < i; i--) {\n            f = w->pflgsall[i];\n#ifndef USE_X_COLHDR\n            if (EU_MAXPFLGS <= f) { w->endpflg = i; continue; }\n#endif\n            h = N_col(f);\n            len = (VARcol(f) ? (int)strlen(h) : Fieldstab[f].width) + COLPADSIZ;\n            if (Screen_cols < ((int)(s - w->columnhdr) + len)) break;\n            s = scat(s, fmtmk(\"%*.*s\", len, len, h));\n            w->endpflg = i;\n         }\n#ifndef USE_X_COLHDR\n         if (EU_XOF == w->pflgsall[w->endpflg]) ++w->endpflg;\n#endif\n      } // end: if (VIZISw(w))\n\n      if (Rc.mode_altscr) w = w->next;\n   } while (w != Curwin);\n\n   build_headers();\n   if (CHKw(Curwin, View_SCROLL))\n      updt_scroll_msg();\n} // end: calibrate_fields\n\n\n        /*\n         * Display each field represented in the current window's fieldscur\n         * array along with its description.  Mark with bold and a leading\n         * asterisk those fields associated with the \"on\" or \"active\" state.\n         *\n         * Special highlighting will be accorded the \"focus\" field with such\n         * highlighting potentially extended to include the description.\n         *\n         * Below is the current Fieldstab space requirement and how\n         * we apportion it.  The xSUFX is considered sacrificial,\n         * something we can reduce or do without.\n         *            0        1         2         3\n         *            12345678901234567890123456789012\n         *            * HEADING = Longest Description!\n         *      xPRFX ----------______________________ xSUFX\n         *    ( xPRFX has pos 2 & 10 for 'extending' when at minimums )\n         *\n         * The first 4 screen rows are reserved for explanatory text, and\n         * the maximum number of columns is Screen_cols / xPRFX + 1 space\n         * between columns.  Thus, for example, with 42 fields a tty will\n         * still remain useable under these extremes:\n         *       rows       columns     what's\n         *       tty  top   tty  top    displayed\n         *       ---  ---   ---  ---    ------------------\n         *        46   42    10    1    xPRFX only\n         *        46   42    32    1    full xPRFX + xSUFX\n         *         6    2   231   21    xPRFX only\n         *        10    6   231    7    full xPRFX + xSUFX\n         */\nstatic void display_fields (int focus, int extend) {\n #define mkERR { putp(\"\\n\"); putp(N_txt(XTRA_winsize_txt)); return; }\n #define mxCOL ( (Screen_cols / 11) > 0 ? (Screen_cols / 11) : 1 )\n #define yRSVD  4\n #define xEQUS  2                      // length of suffix beginning '= '\n #define xSUFX  22                     // total suffix length, incl xEQUS\n #define xPRFX (10 + xadd)\n #define xTOTL (xPRFX + xSUFX)\n   static int col_sav, row_sav;\n   WIN_t *w = Curwin;                  // avoid gcc bloat with a local copy\n   int i;                              // utility int (a row, tot cols, ix)\n   int smax;                           // printable width of xSUFX\n   int xadd = 0;                       // spacing between data columns\n   int cmax = Screen_cols;             // total data column width\n   int rmax = Screen_rows - yRSVD;     // total useable rows\n\n   i = (EU_MAXPFLGS % mxCOL) ? 1 : 0;\n   if (rmax < i + (EU_MAXPFLGS / mxCOL)) mkERR;\n   i = EU_MAXPFLGS / rmax;\n   if (EU_MAXPFLGS % rmax) ++i;\n   if (i > 1) { cmax /= i; xadd = 1; }\n   if (cmax > xTOTL) cmax = xTOTL;\n   smax = cmax - xPRFX;\n   if (smax < 0) mkERR;\n\n   /* we'll go the extra distance to avoid any potential screen flicker\n      which occurs under some terminal emulators (but it was our fault) */\n   if (col_sav != Screen_cols || row_sav != Screen_rows) {\n      col_sav = Screen_cols;\n      row_sav = Screen_rows;\n      putp(Cap_clr_eos);\n   }\n   fflush(stdout);\n\n   for (i = 0; i < EU_MAXPFLGS; ++i) {\n      int b = FLDviz(w, i), x = (i / rmax) * cmax, y = (i % rmax) + yRSVD;\n      const char *e = (i == focus && extend) ? w->capclr_hdr : \"\";\n      FLG_t f = FLDget(w, i);\n      char sbuf[xSUFX*4];                        // 4 = max multi-byte\n      int xcol, xfld;\n\n      /* prep sacrificial suffix (allowing for beginning '= ')\n         note: width passed to 'utf8_embody' may go negative, but he'll be just fine */\n      snprintf(sbuf, sizeof(sbuf), \"= %.*s\", utf8_embody(N_fld(f), smax - xEQUS), N_fld(f));\n\n      // obtain translated deltas (if any) ...\n      xcol = utf8_delta(fmtmk(\"%.*s\", utf8_embody(N_col(f), 7), N_col(f)));\n      xfld = utf8_delta(sbuf + xEQUS);           // ignore beginning '= '\n\n      PUTT(\"%s%c%s%s %s%-*.*s%s%s%s %-*.*s%s\"\n         , tg2(x, y)\n         , b ? '*' : ' '\n         , b ? w->cap_bold : Cap_norm\n         , e\n         , i == focus ? w->capclr_hdr : \"\"\n         , 7 + xcol, 7 + xcol\n         , N_col(f)\n         , Cap_norm\n         , b ? w->cap_bold : \"\"\n         , e\n         , smax + xfld, smax + xfld\n         , sbuf\n         , Cap_norm);\n   }\n\n   putp(Caps_off);\n #undef mkERR\n #undef mxCOL\n #undef yRSVD\n #undef xEQUS\n #undef xSUFX\n #undef xPRFX\n #undef xTOTL\n} // end: display_fields\n\n\n        /*\n         * Manage all fields aspects (order/toggle/sort), for all windows. */\nstatic void fields_utility (void) {\n#ifndef SCROLLVAR_NO\n #define unSCRL  { w->begpflg = w->varcolbeg = 0; OFFw(w, Show_HICOLS); }\n#else\n #define unSCRL  { w->begpflg = 0; OFFw(w, Show_HICOLS); }\n#endif\n #define swapEM  { char c; unSCRL; c = w->rc.fieldscur[i]; \\\n       w->rc.fieldscur[i] = *p; *p = c; p = &w->rc.fieldscur[i]; }\n #define spewFI  { char *t; f = w->rc.sortindx; t = strchr(w->rc.fieldscur, f + FLD_OFFSET); \\\n       if (!t) t = strchr(w->rc.fieldscur, (f + FLD_OFFSET) | 0x80); \\\n       i = (t) ? (int)(t - w->rc.fieldscur) : 0; }\n   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy\n   const char *h = NULL;\n   char *p = NULL;\n   int i, key;\n   FLG_t f;\n\n   spewFI\nsignify_that:\n   putp(Cap_clr_scr);\n   adj_geometry();\n\n   do {\n      if (!h) h = N_col(f);\n      putp(Cap_home);\n      show_special(1, fmtmk(N_unq(FIELD_header_fmt)\n         , w->grpname, CHKw(w, Show_FOREST) ? N_txt(FOREST_views_txt) : h));\n      display_fields(i, (p != NULL));\n      fflush(stdout);\n\n      if (Frames_signal) goto signify_that;\n      key = iokey(1);\n      if (key < 1) goto signify_that;\n\n      switch (key) {\n         case kbd_UP:\n            if (i > 0) { --i; if (p) swapEM }\n            break;\n         case kbd_DOWN:\n            if (i + 1 < EU_MAXPFLGS) { ++i; if (p) swapEM }\n            break;\n         case kbd_LEFT:\n         case kbd_ENTER:\n            p = NULL;\n            break;\n         case kbd_RIGHT:\n            p = &w->rc.fieldscur[i];\n            break;\n         case kbd_HOME:\n         case kbd_PGUP:\n            if (!p) i = 0;\n            break;\n         case kbd_END:\n         case kbd_PGDN:\n            if (!p) i = EU_MAXPFLGS - 1;\n            break;\n         case kbd_SPACE:\n         case 'd':\n            if (!p) { FLDtog(w, i); unSCRL }\n            break;\n         case 's':\n#ifdef TREE_NORESET\n            if (!p && !CHKw(w, Show_FOREST)) { w->rc.sortindx = f = FLDget(w, i); h = NULL; unSCRL }\n#else\n            if (!p) { w->rc.sortindx = f = FLDget(w, i); h = NULL; unSCRL; OFFw(w, Show_FOREST); }\n#endif\n            break;\n         case 'a':\n         case 'w':\n            Curwin = w = ('a' == key) ? w->next : w->prev;\n            spewFI\n            h = p = NULL;\n            break;\n         default:                 // keep gcc happy\n            break;\n      }\n   } while (key != 'q' && key != kbd_ESC);\n #undef unSCRL\n #undef swapEM\n #undef spewFI\n} // end: fields_utility\n\n\n        /*\n         * This routine takes care of auto sizing field widths\n         * if/when the user sets Rc.fixed_widest to -1.  Along the\n         * way he reinitializes some things for the next frame. */\nstatic inline void widths_resize (void) {\n   int i;\n\n   // next var may also be set by the guys that actually truncate stuff\n   Autox_found = 0;\n   for (i = 0; i < EU_MAXPFLGS; i++) {\n      if (Autox_array[i]) {\n         Fieldstab[i].width++;\n         Autox_array[i] = 0;\n         Autox_found = 1;\n      }\n   }\n   if (Autox_found) calibrate_fields();\n} // end: widths_resize\n\n\n        /*\n         * This routine exists just to consolidate most of the messin'\n         * around with the Fieldstab array and some related stuff. */\nstatic void zap_fieldstab (void) {\n#ifdef WIDEN_COLUMN\n #define maX(E) ( (wtab[E].wnls > wtab[E].wmin) \\\n  ? wtab[E].wnls : wtab[E].wmin )\n   static struct {\n      int wmin;         // minimum field width (-1 == variable width)\n      int wnls;         // translated header column requirements\n      int watx;         // +1 == non-scalable auto sized columns\n   } wtab[EU_MAXPFLGS];\n#endif\n   static int once;\n   unsigned digits;\n   char buf[8];\n   int i;\n\n   if (!once) {\n      Fieldstab[EU_CPN].width = 1;\n      Fieldstab[EU_NMA].width = 2;\n      Fieldstab[EU_PID].width = Fieldstab[EU_PPD].width\n         = Fieldstab[EU_PGD].width = Fieldstab[EU_SID].width\n         = Fieldstab[EU_TGD].width = Fieldstab[EU_TPG].width = 5;\n      if (5 < (digits = get_pid_digits())) {\n         if (10 < digits) error_exit(N_txt(FAIL_widepid_txt));\n         Fieldstab[EU_PID].width = Fieldstab[EU_PPD].width\n            = Fieldstab[EU_PGD].width = Fieldstab[EU_SID].width\n            = Fieldstab[EU_TGD].width = Fieldstab[EU_TPG].width = digits;\n      }\n#ifdef WIDEN_COLUMN\n      // identify our non-scalable auto sized columns\n      wtab[EU_UED].watx = wtab[EU_UEN].watx = wtab[EU_URD].watx\n         = wtab[EU_URN].watx = wtab[EU_USD].watx = wtab[EU_USN].watx\n         = wtab[EU_GID].watx = wtab[EU_GRP].watx = wtab[EU_TTY].watx\n         = wtab[EU_WCH].watx = wtab[EU_NS1].watx = wtab[EU_NS2].watx\n         = wtab[EU_NS3].watx = wtab[EU_NS4].watx = wtab[EU_NS5].watx\n         = wtab[EU_NS6].watx = wtab[EU_LXC].watx = +1;\n      /* establish translatable header 'column' requirements\n         and ensure .width reflects the widest value */\n      for (i = 0; i < EU_MAXPFLGS; i++) {\n         wtab[i].wmin = Fieldstab[i].width;\n         wtab[i].wnls = (int)strlen(N_col(i)) - utf8_delta(N_col(i));\n         if (wtab[i].wmin != -1)\n            Fieldstab[i].width = maX(i);\n      }\n#endif\n      once = 1;\n   }\n\n   /*** hotplug_acclimated ***/\n\n   Cpu_pmax = 99.9;\n   if (Rc.mode_irixps && smp_num_cpus > 1 && !Thread_mode) {\n      Cpu_pmax = 100.0 * smp_num_cpus;\n      if (smp_num_cpus > 10) {\n         if (Cpu_pmax > 99999.0) Cpu_pmax = 99999.0;\n      } else {\n         if (Cpu_pmax > 999.9) Cpu_pmax = 999.9;\n      }\n   }\n\n#ifdef WIDEN_COLUMN\n   digits = (unsigned)snprintf(buf, sizeof(buf), \"%u\", (unsigned)smp_num_cpus);\n   if (wtab[EU_CPN].wmin < digits) {\n      if (5 < digits) error_exit(N_txt(FAIL_widecpu_txt));\n      wtab[EU_CPN].wmin = digits;\n      Fieldstab[EU_CPN].width = maX(EU_CPN);\n   }\n   digits = (unsigned)snprintf(buf, sizeof(buf), \"%u\", (unsigned)Numa_node_tot);\n   if (wtab[EU_NMA].wmin < digits) {\n      wtab[EU_NMA].wmin = digits;\n      Fieldstab[EU_NMA].width = maX(EU_NMA);\n   }\n\n   // and accommodate optional wider non-scalable columns (maybe)\n   if (!AUTOX_MODE) {\n      for (i = 0; i < EU_MAXPFLGS; i++) {\n         if (wtab[i].watx)\n            Fieldstab[i].width = Rc.fixed_widest ? Rc.fixed_widest + maX(i) : maX(i);\n      }\n   }\n#else\n   digits = (unsigned)snprintf(buf, sizeof(buf), \"%u\", (unsigned)smp_num_cpus);\n   if (1 < digits) {\n      if (5 < digits) error_exit(N_txt(FAIL_widecpu_txt));\n      Fieldstab[EU_CPN].width = digits;\n   }\n   digits = (unsigned)snprintf(buf, sizeof(buf), \"%u\", (unsigned)Numa_node_tot);\n   if (2 < digits) {\n      Fieldstab[EU_NMA].width = digits;\n   }\n   // and accommodate optional wider non-scalable columns (maybe)\n   if (!AUTOX_MODE) {\n      Fieldstab[EU_UED].width = Fieldstab[EU_URD].width\n         = Fieldstab[EU_USD].width = Fieldstab[EU_GID].width\n         = Rc.fixed_widest ? 5 + Rc.fixed_widest : 5;\n      Fieldstab[EU_UEN].width = Fieldstab[EU_URN].width\n         = Fieldstab[EU_USN].width = Fieldstab[EU_GRP].width\n         = Rc.fixed_widest ? 8 + Rc.fixed_widest : 8;\n      Fieldstab[EU_TTY].width = Fieldstab[EU_LXC].width\n         = Rc.fixed_widest ? 8 + Rc.fixed_widest : 8;\n      Fieldstab[EU_WCH].width\n         = Rc.fixed_widest ? 10 + Rc.fixed_widest : 10;\n      for (i = EU_NS1; i < EU_NS1 + NUM_NS; i++)\n         Fieldstab[i].width\n            = Rc.fixed_widest ? 10 + Rc.fixed_widest : 10;\n   }\n#endif\n\n   /* plus user selectable scaling */\n   Fieldstab[EU_VRT].scale = Fieldstab[EU_SWP].scale\n      = Fieldstab[EU_RES].scale = Fieldstab[EU_COD].scale\n      = Fieldstab[EU_DAT].scale = Fieldstab[EU_SHR].scale\n      = Fieldstab[EU_USE].scale = Fieldstab[EU_RZA].scale\n      = Fieldstab[EU_RZF].scale = Fieldstab[EU_RZL].scale\n      = Fieldstab[EU_RZS].scale = Rc.task_mscale;\n\n   // lastly, ensure we've got proper column headers...\n   calibrate_fields();\n #undef maX\n} // end: zap_fieldstab\n\f\n/*######  Library Interface  #############################################*/\n\n        /*\n         * This guy's modeled on libproc's 'eight_cpu_numbers' function except\n         * we preserve all cpu data in our CPU_t array which is organized\n         * as follows:\n         *    Cpu_tics[0] thru Cpu_tics[n] == tics for each separate cpu\n         *    Cpu_tics[sumSLOT]            == tics from /proc/stat line #1\n         *  [ and beyond sumSLOT           == tics for each cpu NUMA node ] */\nstatic void cpus_refresh (void) {\n #define sumSLOT ( smp_num_cpus )\n #define totSLOT ( 1 + smp_num_cpus + Numa_node_tot)\n   static FILE *fp = NULL;\n   static int siz, sav_slot = -1;\n   static char *buf;\n   CPU_t *sum_ptr;                               // avoid gcc subscript bloat\n   int i, num, tot_read;\n   int node;\n   char *bp;\n\n   /*** hotplug_acclimated ***/\n   if (sav_slot != sumSLOT) {\n      sav_slot = sumSLOT;\n      zap_fieldstab();\n      if (fp) { fclose(fp); fp = NULL; }\n      if (Cpu_tics) free(Cpu_tics);\n   }\n\n   /* by opening this file once, we'll avoid the hit on minor page faults\n      (sorry Linux, but you'll have to close it for us) */\n   if (!fp) {\n      if (!(fp = fopen(\"/proc/stat\", \"r\")))\n         error_exit(fmtmk(N_fmt(FAIL_statopn_fmt), strerror(errno)));\n      /* note: we allocate one more CPU_t via totSLOT than 'cpus' so that a\n               slot can hold tics representing the /proc/stat cpu summary */\n      Cpu_tics = alloc_c(totSLOT * sizeof(CPU_t));\n   }\n   rewind(fp);\n   fflush(fp);\n\n #define buffGRW 1024\n   /* we slurp in the entire directory thus avoiding repeated calls to fgets,\n      especially in a massively parallel environment.  additionally, each cpu\n      line is then frozen in time rather than changing until we get around to\n      accessing it.  this helps to minimize (not eliminate) most distortions. */\n   tot_read = 0;\n   if (buf) buf[0] = '\\0';\n   else buf = alloc_c((siz = buffGRW));\n   while (0 < (num = fread(buf + tot_read, 1, (siz - tot_read), fp))) {\n      tot_read += num;\n      if (tot_read < siz) break;\n      buf = alloc_r(buf, (siz += buffGRW));\n   };\n   buf[tot_read] = '\\0';\n   bp = buf;\n #undef buffGRW\n\n   // remember from last time around\n   sum_ptr = &Cpu_tics[sumSLOT];\n   memcpy(&sum_ptr->sav, &sum_ptr->cur, sizeof(CT_t));\n   // then value the last slot with the cpu summary line\n   if (4 > sscanf(bp, \"cpu %llu %llu %llu %llu %llu %llu %llu %llu\"\n      , &sum_ptr->cur.u, &sum_ptr->cur.n, &sum_ptr->cur.s\n      , &sum_ptr->cur.i, &sum_ptr->cur.w, &sum_ptr->cur.x\n      , &sum_ptr->cur.y, &sum_ptr->cur.z))\n         error_exit(N_txt(FAIL_statget_txt));\n#ifndef CPU_ZEROTICS\n   sum_ptr->cur.tot = sum_ptr->cur.u + sum_ptr->cur.s\n      + sum_ptr->cur.n + sum_ptr->cur.i + sum_ptr->cur.w\n      + sum_ptr->cur.x + sum_ptr->cur.y + sum_ptr->cur.z;\n   /* if a cpu has registered substantially fewer tics than those expected,\n      we'll force it to be treated as 'idle' so as not to present misleading\n      percentages. */\n   sum_ptr->edge =\n      ((sum_ptr->cur.tot - sum_ptr->sav.tot) / smp_num_cpus) / (100 / TICS_EDGE);\n#endif\n\n   // forget all of the prior node statistics (maybe)\n   if (CHKw(Curwin, View_CPUNOD) && Numa_node_tot)\n      memset(sum_ptr + 1, 0, Numa_node_tot * sizeof(CPU_t));\n\n   // now value each separate cpu's tics...\n   for (i = 0; i < sumSLOT; i++) {\n      CPU_t *cpu_ptr = &Cpu_tics[i];           // avoid gcc subscript bloat\n#ifdef PRETEND8CPUS\n      bp = buf;\n#endif\n      bp = 1 + strchr(bp, '\\n');\n      // remember from last time around\n      memcpy(&cpu_ptr->sav, &cpu_ptr->cur, sizeof(CT_t));\n      if (4 > sscanf(bp, \"cpu%d %llu %llu %llu %llu %llu %llu %llu %llu\", &cpu_ptr->id\n         , &cpu_ptr->cur.u, &cpu_ptr->cur.n, &cpu_ptr->cur.s\n         , &cpu_ptr->cur.i, &cpu_ptr->cur.w, &cpu_ptr->cur.x\n         , &cpu_ptr->cur.y, &cpu_ptr->cur.z)) {\n            break;        // tolerate cpus taken offline\n      }\n\n#ifndef CPU_ZEROTICS\n      cpu_ptr->edge = sum_ptr->edge;\n#endif\n#ifdef PRETEND8CPUS\n      cpu_ptr->id = i;\n#endif\n      /* henceforth, with just a little more arithmetic we can avoid\n         maintaining *any* node stats unless they're actually needed */\n      if (CHKw(Curwin, View_CPUNOD)\n      && Numa_node_tot\n      && -1 < (node = numa_node_of_cpu(cpu_ptr->id))) {\n         // use our own pointer to avoid gcc subscript bloat\n         CPU_t *nod_ptr = sum_ptr + 1 + node;\n         nod_ptr->cur.u += cpu_ptr->cur.u; nod_ptr->sav.u += cpu_ptr->sav.u;\n         nod_ptr->cur.n += cpu_ptr->cur.n; nod_ptr->sav.n += cpu_ptr->sav.n;\n         nod_ptr->cur.s += cpu_ptr->cur.s; nod_ptr->sav.s += cpu_ptr->sav.s;\n         nod_ptr->cur.i += cpu_ptr->cur.i; nod_ptr->sav.i += cpu_ptr->sav.i;\n         nod_ptr->cur.w += cpu_ptr->cur.w; nod_ptr->sav.w += cpu_ptr->sav.w;\n         nod_ptr->cur.x += cpu_ptr->cur.x; nod_ptr->sav.x += cpu_ptr->sav.x;\n         nod_ptr->cur.y += cpu_ptr->cur.y; nod_ptr->sav.y += cpu_ptr->sav.y;\n         nod_ptr->cur.z += cpu_ptr->cur.z; nod_ptr->sav.z += cpu_ptr->sav.z;\n#ifndef CPU_ZEROTICS\n         /* yep, we re-value this repeatedly for each cpu encountered, but we\n            can then avoid a prior loop to selectively initialize each node */\n         nod_ptr->edge = sum_ptr->edge;\n#endif\n         cpu_ptr->node = node;\n#ifndef OFF_NUMASKIP\n         nod_ptr->id = -1;\n#endif\n      }\n   } // end: for each cpu\n\n   Cpu_faux_tot = i;      // tolerate cpus taken offline\n #undef sumSLOT\n #undef totSLOT\n} // end: cpus_refresh\n\n\n#ifdef OFF_HST_HASH\n        /*\n         * Binary Search for HST_t's put/get support */\n\nstatic inline HST_t *hstbsrch (HST_t *hst, int max, int pid) {\n   int mid, min = 0;\n\n   while (min <= max) {\n      mid = (min + max) / 2;\n      if (pid < hst[mid].pid) max = mid - 1;\n      else if (pid > hst[mid].pid) min = mid + 1;\n      else return &hst[mid];\n   }\n   return NULL;\n} // end: hstbsrch\n\n#else\n        /*\n         * Hashing functions for HST_t's put/get support\n         * (not your normal 'chaining', those damn HST_t's might move!) */\n\n#define _HASH_(K) (K & (HHASH_SIZ - 1))\n\nstatic inline HST_t *hstget (int pid) {\n   int V = PHash_sav[_HASH_(pid)];\n\n   while (-1 < V) {\n      if (PHist_sav[V].pid == pid) return &PHist_sav[V];\n      V = PHist_sav[V].lnk; }\n   return NULL;\n} // end: hstget\n\n\nstatic inline void hstput (unsigned idx) {\n   int V = _HASH_(PHist_new[idx].pid);\n\n   PHist_new[idx].lnk = PHash_new[V];\n   PHash_new[V] = idx;\n} // end: hstput\n\n#undef _HASH_\n#endif\n\n        /*\n         * Refresh procs *Helper* function to eliminate yet one more need\n         * to loop through our darn proc_t table.  He's responsible for:\n         *    1) calculating the elapsed time since the previous frame\n         *    2) counting the number of tasks in each state (run, sleep, etc)\n         *    3) maintaining the HST_t's and priming the proc_t pcpu field\n         *    4) establishing the total number tasks for this frame */\nstatic void procs_hlp (proc_t *this) {\n#ifdef OFF_HST_HASH\n   static unsigned maxt_sav = 0;        // prior frame's max tasks\n#endif\n   TIC_t tics;\n   HST_t *h;\n\n   if (!this) {\n      static double uptime_sav;\n      double uptime_cur;\n      float et;\n      void *v;\n\n      uptime(&uptime_cur, NULL);\n      et = uptime_cur - uptime_sav;\n      if (et < 0.01) et = 0.005;\n      uptime_sav = uptime_cur;\n\n      // if in Solaris mode, adjust our scaling for all cpus\n      Frame_etscale = 100.0f / ((float)Hertz * (float)et * (Rc.mode_irixps ? 1 : smp_num_cpus));\n#ifdef OFF_HST_HASH\n      maxt_sav = Frame_maxtask;\n#endif\n      Frame_maxtask = Frame_running = Frame_sleepin = Frame_stopped = Frame_zombied = 0;\n\n      // prep for saving this frame's HST_t's (and reuse mem each time around)\n      v = PHist_sav;\n      PHist_sav = PHist_new;\n      PHist_new = v;\n#ifdef OFF_HST_HASH\n      // prep for binary search by sorting the last frame's HST_t's\n      qsort(PHist_sav, maxt_sav, sizeof(HST_t), (QFP_t)sort_HST_t);\n#else\n      v = PHash_sav;\n      PHash_sav = PHash_new;\n      PHash_new = v;\n      memcpy(PHash_new, HHash_nul, sizeof(HHash_nul));\n#endif\n      return;\n   }\n\n   switch (this->state) {\n      case 'R':\n         Frame_running++;\n         break;\n      case 't':     // 't' (tracing stop)\n      case 'T':\n         Frame_stopped++;\n         break;\n      case 'Z':\n         Frame_zombied++;\n         break;\n      default:\n         /* currently: 'D' (disk sleep),\n                       'I' (idle),\n                       'P' (parked),\n                       'S' (sleeping),\n                       'X' (dead - actually 'dying' & probably never seen)\n         */\n         Frame_sleepin++;\n         break;\n   }\n\n   if (Frame_maxtask+1 >= HHist_siz) {\n      /* we're subject to integer overflow if total linux tasks ever approach |\n         400+ million (but, do you think memory might be the bigger problem?) | */\n      HHist_siz = HHist_siz * 5 / 4 + 100;\n      PHist_sav = alloc_r(PHist_sav, sizeof(HST_t) * HHist_siz);\n      PHist_new = alloc_r(PHist_new, sizeof(HST_t) * HHist_siz);\n   }\n\n   /* calculate time in this process; the sum of user time (utime) and\n      system time (stime) -- but PLEASE dont waste time and effort on\n      calcs and saves that go unused, like the old top! */\n   PHist_new[Frame_maxtask].pid  = this->tid;\n   PHist_new[Frame_maxtask].tics = tics = (this->utime + this->stime);\n   // finally, save major/minor fault counts in case the deltas are displayable\n   PHist_new[Frame_maxtask].maj = this->maj_flt;\n   PHist_new[Frame_maxtask].min = this->min_flt;\n\n#ifdef OFF_HST_HASH\n   // find matching entry from previous frame and make stuff elapsed\n   if ((h = hstbsrch(PHist_sav, maxt_sav - 1, this->tid))) {\n      tics -= h->tics;\n      this->maj_delta = this->maj_flt - h->maj;\n      this->min_delta = this->min_flt - h->min;\n   }\n#else\n   // hash & save for the next frame\n   hstput(Frame_maxtask);\n   // find matching entry from previous frame and make stuff elapsed\n   if ((h = hstget(this->tid))) {\n      tics -= h->tics;\n      this->maj_delta = this->maj_flt - h->maj;\n      this->min_delta = this->min_flt - h->min;\n   }\n#endif\n\n   /* we're just saving elapsed tics, to be converted into %cpu if\n      this task wins it's displayable screen row lottery... */\n   this->pcpu = tics;\n\n   // shout this to the world with the final call (or us the next time in)\n   Frame_maxtask++;\n} // end: procs_hlp\n\n\n        /*\n         * This guy's modeled on libproc's 'readproctab' function except\n         * we reuse and extend any prior proc_t's.  He's been customized\n         * for our specific needs and to avoid the use of <stdarg.h> */\nstatic void procs_refresh (void) {\n #define n_used  Frame_maxtask                   // maintained by procs_hlp()\n   static proc_t **private_ppt;                  // our base proc_t ptr table\n   static int n_alloc = 0;                       // size of our private_ppt\n   static int n_saved = 0;                       // last window ppt size\n   proc_t *ptask;\n   PROCTAB* PT;\n   int i;\n   proc_t*(*read_something)(PROCTAB*, proc_t*);\n\n   procs_hlp(NULL);                              // prep for a new frame\n   if (NULL == (PT = openproc(Frames_libflags, Monpids)))\n      error_exit(fmtmk(N_fmt(FAIL_openlib_fmt), strerror(errno)));\n   read_something = Thread_mode ? readeither : readproc;\n\n   for (;;) {\n      if (n_used == n_alloc) {\n         /* we're subject to integer overflow if total linux tasks ever approach |\n            400+ million (but, do you think memory might be the bigger problem?) | */\n         n_alloc = 10 + ((n_alloc * 5) / 4);     // grow by over 25%\n         private_ppt = alloc_r(private_ppt, sizeof(proc_t*) * n_alloc);\n         // ensure NULL pointers for the additional memory just acquired\n         memset(private_ppt + n_used, 0, sizeof(proc_t*) * (n_alloc - n_used));\n      }\n      // on the way to n_alloc, the library will allocate the underlying\n      // proc_t storage whenever our private_ppt[] pointer is NULL...\n      if (!(ptask = read_something(PT, private_ppt[n_used]))) break;\n      procs_hlp((private_ppt[n_used] = ptask));  // tally this proc_t\n   }\n\n   closeproc(PT);\n\n   // lastly, refresh each window's proc pointers table...\n   if (n_saved == n_alloc)\n      for (i = 0; i < GROUPSMAX; i++)\n         memcpy(Winstk[i].ppt, private_ppt, sizeof(proc_t*) * n_used);\n   else {\n      n_saved = n_alloc;\n      for (i = 0; i < GROUPSMAX; i++) {\n         Winstk[i].ppt = alloc_r(Winstk[i].ppt, sizeof(proc_t*) * n_alloc);\n         memcpy(Winstk[i].ppt, private_ppt, sizeof(proc_t*) * n_used);\n      }\n   }\n #undef n_used\n} // end: procs_refresh\n\n\n        /*\n         * This serves as our interface to the memory & cpu count (sysinfo)\n         * portion of libproc.  In support of those hotpluggable resources,\n         * the sampling frequencies are reduced so as to minimize overhead. */\nstatic void sysinfo_refresh (int forced) {\n   static time_t sav_secs;\n   time_t cur_secs;\n\n   if (forced)\n      sav_secs = 0;\n   cur_secs = time(NULL);\n\n   /*** hotplug_acclimated ***/\n   if (3 <= cur_secs - sav_secs) {\n      meminfo();\n#ifndef PRETEND8CPUS\n      cpuinfo();\n      Cpu_faux_tot = smp_num_cpus;\n#endif\n      Numa_node_tot = numa_max_node() + 1;\n      sav_secs = cur_secs;\n   }\n} // end: sysinfo_refresh\n\f\n/*######  Inspect Other Output  ##########################################*/\n\n        /*\n         * HOWTO Extend the top 'inspect' functionality:\n         *\n         * To exploit the 'Y' interactive command, one must add entries to\n         * the top personal configuration file.  Such entries simply reflect\n         * a file to be read or command/pipeline to be executed whose results\n         * will then be displayed in a separate scrollable window.\n         *\n         * Entries beginning with a '#' character are ignored, regardless of\n         * content.  Otherwise they consist of the following 3 elements, each\n         * of which must be separated by a tab character (thus 2 '\\t' total):\n         *     type:  literal 'file' or 'pipe'\n         *     name:  selection shown on the Inspect screen\n         *     fmts:  string representing a path or command\n         *\n         * The two types of Inspect entries are not interchangeable.\n         * Those designated 'file' will be accessed using fopen/fread and must\n         * reference a single file in the 'fmts' element.  Entries specifying\n         * 'pipe' will employ popen/fread, their 'fmts' element could contain\n         * many pipelined commands and, none can be interactive.\n         *\n         * Here are some examples of both types of inspection entries.\n         * The first entry will be ignored due to the initial '#' character.\n         * For clarity, the pseudo tab depictions (^I) are surrounded by an\n         * extra space but the actual tabs would not be.\n         *\n         *     # pipe ^I Sockets ^I lsof -n -P -i 2>&1\n         *     pipe ^I Open Files ^I lsof -P -p %d 2>&1\n         *     file ^I NUMA Info ^I /proc/%d/numa_maps\n         *     pipe ^I Log ^I tail -n100 /var/log/syslog | sort -Mr\n         *\n         * Caution:  If the output contains unprintable characters they will\n         * be displayed in either the ^I notation or hexidecimal <FF> form.\n         * This applies to tab characters as well.  So if one wants a more\n         * accurate display, any tabs should be expanded within the 'fmts'.\n         *\n         * The following example takes what could have been a 'file' entry\n         * but employs a 'pipe' instead so as to expand the tabs.\n         *\n         *     # next would have contained '\\t' ...\n         *     # file ^I <your_name> ^I /proc/%d/status\n         *     # but this will eliminate embedded '\\t' ...\n         *     pipe ^I <your_name> ^I cat /proc/%d/status | expand -\n         */\n\n        /*\n         * Our driving table support, the basis for generalized inspection,\n         * built at startup (if at all) from rcfile or demo entries. */\nstruct I_ent {\n   void (*func)(char *, int);     // a pointer to file/pipe/demo function\n   char *type;                    // the type of entry ('file' or 'pipe')\n   char *name;                    // the selection label for display\n   char *fmts;                    // format string to build path or command\n   int   farg;                    // 1 = '%d' in fmts, 0 = not (future use)\n   const char *caps;              // not really caps, show_special() delim's\n   char *fstr;                    // entry's current/active search string\n   int   flen;                    // above's strlen, without call overhead\n};\nstruct I_struc {\n   int demo;                      // do NOT save table entries in rcfile\n   int total;                     // total I_ent table entries\n   char *raw;                     // all entries for 'W', incl '#' & blank\n   struct I_ent *tab;\n};\nstatic struct I_struc Inspect;\n\nstatic char   **Insp_p;           // pointers to each line start\nstatic int      Insp_nl;          // total lines, total Insp_p entries\nstatic int      Insp_utf8;        // treat Insp_buf as translatable, else raw\nstatic char    *Insp_buf;         // the results from insp_do_file/pipe\nstatic size_t   Insp_bufsz;       // allocated size of Insp_buf\nstatic size_t   Insp_bufrd;       // bytes actually in Insp_buf\nstatic struct I_ent *Insp_sel;    // currently selected Inspect entry\n\n        // Our 'make status line' macro\n#define INSP_MKSL(big,txt) { int _sz = big ? Screen_cols : 80; \\\n   const char *_p; \\\n   _sz += utf8_delta(txt); \\\n   _p = fmtmk(\"%-*.*s\", _sz, _sz, txt); \\\n   PUTT(\"%s%s%.*s%s\", tg2(0, (Msg_row = 3)), Curwin->capclr_hdr \\\n      , utf8_embody(_p, Screen_cols), _p, Cap_clr_eol); \\\n   putp(Caps_off); fflush(stdout); }\n\n        // Our 'row length' macro, equivalent to a strlen() call\n#define INSP_RLEN(idx) (int)(Insp_p[idx +1] - Insp_p[idx] -1)\n\n        // Our 'busy' (wait please) macro\n#define INSP_BUSY  { INSP_MKSL(0, N_txt(YINSP_workin_txt)); }\n\n\n        /*\n         * Establish the number of lines present in the Insp_buf glob plus\n         * build the all important row start array.  It is that array that\n         * others will rely on since we dare not try to use strlen() on what\n         * is potentially raw binary data.  Who knows what some user might\n         * name as a file or include in a pipeline (scary, ain't it?). */\nstatic void insp_cnt_nl (void) {\n   char *beg = Insp_buf;\n   char *cur = Insp_buf;\n   char *end = Insp_buf + Insp_bufrd + 1;\n\n#ifdef INSP_SAVEBUF\n{\n   static int n = 1;\n   char fn[SMLBUFSIZ];\n   FILE *fd;\n   snprintf(fn, sizeof(fn), \"%s.Insp_buf.%02d.txt\", Myname, n++);\n   fd = fopen(fn, \"w\");\n   if (fd) {\n      fwrite(Insp_buf, 1, Insp_bufrd, fd);\n      fclose(fd);\n   }\n}\n#endif\n   Insp_p = alloc_c(sizeof(char*) * 2);\n\n   for (Insp_nl = 0; beg < end; beg++) {\n      if (*beg == '\\n') {\n         Insp_p[Insp_nl++] = cur;\n         // keep our array ahead of next potential need (plus the 2 above)\n         Insp_p = alloc_r(Insp_p, (sizeof(char*) * (Insp_nl +3)));\n         cur = beg +1;\n      }\n   }\n   Insp_p[0] = Insp_buf;\n   Insp_p[Insp_nl++] = cur;\n   Insp_p[Insp_nl] = end;\n   if ((end - cur) == 1)          // if there's an eof null delimiter,\n      --Insp_nl;                  // don't count it as a new line\n} // end: insp_cnt_nl\n\n\n#ifndef INSP_OFFDEMO\n        /*\n         * The pseudo output DEMO utility. */\nstatic void insp_do_demo (char *fmts, int pid) {\n   (void)fmts; (void)pid;\n   /* next will put us on a par with the real file/pipe read buffers\n    ( and also avoid a harmless, but evil sounding, valgrind warning ) */\n   Insp_bufsz = READMINSZ + strlen(N_txt(YINSP_dstory_txt));\n   Insp_buf   = alloc_c(Insp_bufsz);\n   Insp_bufrd = snprintf(Insp_buf, Insp_bufsz, \"%s\", N_txt(YINSP_dstory_txt));\n   insp_cnt_nl();\n} // end: insp_do_demo\n#endif\n\n\n        /*\n         * The generalized FILE utility. */\nstatic void insp_do_file (char *fmts, int pid) {\n   char buf[LRGBUFSIZ];\n   FILE *fp;\n   int rc;\n\n   snprintf(buf, sizeof(buf), fmts, pid);\n   fp = fopen(buf, \"r\");\n   rc = readfile(fp, &Insp_buf, &Insp_bufsz, &Insp_bufrd);\n   if (fp) fclose(fp);\n   if (rc) Insp_bufrd = snprintf(Insp_buf, Insp_bufsz, \"%s\"\n      , fmtmk(N_fmt(YINSP_failed_fmt), strerror(errno)));\n   insp_cnt_nl();\n} // end: insp_do_file\n\n\n        /*\n         * The generalized PIPE utility. */\nstatic void insp_do_pipe (char *fmts, int pid) {\n   char buf[LRGBUFSIZ];\n   FILE *fp;\n   int rc;\n\n   snprintf(buf, sizeof(buf), fmts, pid);\n   fp = popen(buf, \"r\");\n   rc = readfile(fp, &Insp_buf, &Insp_bufsz, &Insp_bufrd);\n   if (fp) pclose(fp);\n   if (rc) Insp_bufrd = snprintf(Insp_buf, Insp_bufsz, \"%s\"\n      , fmtmk(N_fmt(YINSP_failed_fmt), strerror(errno)));\n   insp_cnt_nl();\n} // end: insp_do_pipe\n\n\n        /*\n         * This guy is a *Helper* function serving the following two masters:\n         *   insp_find_str() - find the next Insp_sel->fstr match\n         *   insp_mkrow_...  - highlight any Insp_sel->fstr matches in-view\n         * If Insp_sel->fstr is found in the designated row, he returns the\n         * offset from the start of the row, otherwise he returns a huge\n         * integer so traditional fencepost usage can be employed. */\nstatic inline int insp_find_ofs (int col, int row) {\n #define begFS (int)(fnd - Insp_p[row])\n   char *p, *fnd = NULL;\n\n   if (Insp_sel->fstr[0]) {\n      // skip this row, if there's no chance of a match\n      if (memchr(Insp_p[row], Insp_sel->fstr[0], INSP_RLEN(row))) {\n         for ( ; col < INSP_RLEN(row); col++) {\n            if (!*(p = Insp_p[row] + col))       // skip any empty strings\n               continue;\n            fnd = STRSTR(p, Insp_sel->fstr);     // with binary data, each\n            if (fnd)                             // row may have '\\0'.  so\n               break;                            // our scans must be done\n            col += strlen(p);                    // as individual strings.\n         }\n         if (fnd && fnd < Insp_p[row + 1])       // and, we must watch out\n            return begFS;                        // for potential overrun!\n      }\n   }\n   return INT_MAX;\n #undef begFS\n} // end: insp_find_ofs\n\n\n        /*\n         * This guy supports the inspect 'L' and '&' search provisions\n         * and returns the row and *optimal* column for viewing any match\n         * ( we'll always opt for left column justification since any )\n         * ( preceding ctrl chars appropriate an unpredictable amount ) */\nstatic void insp_find_str (int ch, int *col, int *row) {\n #define reDUX (found) ? N_txt(WORD_another_txt) : \"\"\n   static int found;\n\n   if ((ch == '&' || ch == 'n') && !Insp_sel->fstr[0]) {\n      show_msg(N_txt(FIND_no_next_txt));\n      return;\n   }\n   if (ch == 'L' || ch == '/') {\n      char *str = ioline(N_txt(GET_find_str_txt));\n      if (*str == kbd_ESC) return;\n      snprintf(Insp_sel->fstr, FNDBUFSIZ, \"%s\", str);\n      Insp_sel->flen = strlen(Insp_sel->fstr);\n      found = 0;\n   }\n   if (Insp_sel->fstr[0]) {\n      int xx, yy;\n\n      INSP_BUSY;\n      for (xx = *col, yy = *row; yy < Insp_nl; ) {\n         xx = insp_find_ofs(xx, yy);\n         if (xx < INSP_RLEN(yy)) {\n            found = 1;\n            if (xx == *col &&  yy == *row) {     // matched where we were!\n               ++xx;                             // ( was the user maybe )\n               continue;                         // ( trying to fool us? )\n            }\n            *col = xx;\n            *row = yy;\n            return;\n         }\n         xx = 0;\n         ++yy;\n      }\n      show_msg(fmtmk(N_fmt(FIND_no_find_fmt), reDUX, Insp_sel->fstr));\n   }\n #undef reDUX\n} // end: insp_find_str\n\n\n        /*\n         * This guy is a *Helper* function responsible for positioning a\n         * single row in the current 'X axis', then displaying the results.\n         * Along the way, he makes sure control characters and/or unprintable\n         * characters display in a less-like fashion:\n         *    '^A'    for control chars\n         *    '<BC>'  for other unprintable stuff\n         * Those will be highlighted with the current windows's capclr_msg,\n         * while visible search matches display with capclr_hdr for emphasis.\n         * ( we hide ugly plumbing in macros to concentrate on the algorithm ) */\nstatic void insp_mkrow_raw (int col, int row) {\n #define maxSZ ( Screen_cols - to )\n #define capNO { if (hicap) { putp(Caps_off); hicap = 0; } }\n #define mkFND { PUTT(\"%s%.*s%s\", Curwin->capclr_hdr, maxSZ, Insp_sel->fstr, Caps_off); \\\n    fr += Insp_sel->flen -1; to += Insp_sel->flen; hicap = 0; }\n#ifndef INSP_JUSTNOT\n #define mkCTL { const char *p = fmtmk(\"^%c\", uch + '@'); \\\n    PUTT(\"%s%.*s\", (!hicap) ? Curwin->capclr_msg : \"\", maxSZ, p); to += 2; hicap = 1; }\n #define mkUNP { const char *p = fmtmk(\"<%02X>\", uch); \\\n    PUTT(\"%s%.*s\", (!hicap) ? Curwin->capclr_msg : \"\", maxSZ, p); to += 4; hicap = 1; }\n#else\n #define mkCTL { if ((to += 2) <= Screen_cols) \\\n    PUTT(\"%s^%c\", (!hicap) ? Curwin->capclr_msg : \"\", uch + '@'); hicap = 1; }\n #define mkUNP { if ((to += 4) <= Screen_cols) \\\n    PUTT(\"%s<%02X>\", (!hicap) ? Curwin->capclr_msg : \"\", uch); hicap = 1; }\n#endif\n #define mkSTD { capNO; if (++to <= Screen_cols) { static char _str[2]; \\\n    _str[0] = uch; putp(_str); } }\n   unsigned char tline[SCREENMAX];\n   int fr, to, ofs;\n   int hicap = 0;\n\n   if (col < INSP_RLEN(row))\n      memcpy(tline, Insp_p[row] + col, sizeof(tline));\n   else tline[0] = '\\n';\n\n   for (fr = 0, to = 0, ofs = 0; to < Screen_cols; fr++) {\n      if (!ofs)\n         ofs = insp_find_ofs(col + fr, row);\n      if (col + fr < ofs) {\n         unsigned char uch = tline[fr];\n         if (uch == '\\n')   break;     // a no show  (he,he)\n         if (uch > 126)     mkUNP      // show as: '<AB>'\n         else if (uch < 32) mkCTL      // show as:  '^C'\n         else               mkSTD      // a show off (he,he)\n      } else {              mkFND      // a big show (he,he)\n         ofs = 0;\n      }\n      if (col + fr >= INSP_RLEN(row)) break;\n   }\n   capNO;\n   putp(Cap_clr_eol);\n\n #undef maxSZ\n #undef capNO\n #undef mkFND\n #undef mkCTL\n #undef mkUNP\n #undef mkSTD\n} // end: insp_mkrow_raw\n\n\n        /*\n         * This guy is a *Helper* function responsible for positioning a\n         * single row in the current 'X axis' within a multi-byte string\n         * then displaying the results. Along the way he ensures control\n         * characters will then be displayed in two positions like '^A'.\n         * ( assuming they can even get past those 'gettext' utilities ) */\nstatic void insp_mkrow_utf8 (int col, int row) {\n #define maxSZ ( Screen_cols - to )\n #define mkFND { PUTT(\"%s%.*s%s\", Curwin->capclr_hdr, maxSZ, Insp_sel->fstr, Caps_off); \\\n    fr += Insp_sel->flen; to += Insp_sel->flen; }\n#ifndef INSP_JUSTNOT\n #define mkCTL { const char *p = fmtmk(\"^%c\", uch + '@'); \\\n    PUTT(\"%s%.*s%s\", Curwin->capclr_msg, maxSZ, p, Caps_off); to += 2; }\n#else\n #define mkCTL { if ((to += 2) <= Screen_cols) \\\n    PUTT(\"%s^%c%s\", Curwin->capclr_msg, uch + '@', Caps_off); }\n#endif\n #define mkNUL { buf1[0] = ' '; doPUT(buf1) }\n #define doPUT(buf) if ((to += cno) <= Screen_cols) putp(buf);\n   static char buf1[2], buf2[3], buf3[4], buf4[5];\n   unsigned char tline[BIGBUFSIZ];\n   int fr, to, ofs;\n\n   col = utf8_proper_col(Insp_p[row], col, 1);\n   if (col < INSP_RLEN(row))\n      memcpy(tline, Insp_p[row] + col, sizeof(tline));\n   else tline[0] = '\\n';\n\n   for (fr = 0, to = 0, ofs = 0; to < Screen_cols; ) {\n      if (!ofs)\n         ofs = insp_find_ofs(col + fr, row);\n      if (col + fr < ofs) {\n         unsigned char uch = tline[fr];\n         int bno = UTF8_tab[uch];\n         int cno = utf8_cols(&tline[fr++], bno);\n         switch (bno) {\n            case 1:\n               if (uch == '\\n') break;\n               if (uch < 32) mkCTL\n               else if (uch == 127) mkNUL\n               else { buf1[0] = uch; doPUT(buf1) }\n               break;\n            case 2:\n               buf2[0] = uch; buf2[1] = tline[fr++];\n               doPUT(buf2)\n               break;\n            case 3:\n               buf3[0] = uch; buf3[1] = tline[fr++]; buf3[2] = tline[fr++];\n               doPUT(buf3)\n               break;\n            case 4:\n               buf4[0] = uch; buf4[1] = tline[fr++]; buf4[2] = tline[fr++]; buf4[3] = tline[fr++];\n               doPUT(buf4)\n               break;\n            default:\n               mkNUL\n               break;\n         }\n      } else {\n         mkFND\n         ofs = 0;\n      }\n      if (col + fr >= INSP_RLEN(row)) break;\n   }\n   putp(Cap_clr_eol);\n\n #undef maxSZ\n #undef mkFND\n #undef mkCTL\n #undef mkNUL\n #undef doPUT\n} // end: insp_mkrow_utf8\n\n\n        /*\n         * This guy is an insp_view_choice() *Helper* function who displays\n         * a page worth of of the user's damages.  He also creates a status\n         * line based on maximum digits for the current selection's lines and\n         * hozizontal position (so it serves to inform, not distract, by\n         * otherwise being jumpy). */\nstatic inline void insp_show_pgs (int col, int row, int max) {\n   char buf[SMLBUFSIZ];\n   void (*mkrow_func)(int, int);\n   int r = snprintf(buf, sizeof(buf), \"%d\", Insp_nl);\n   int c = snprintf(buf, sizeof(buf), \"%d\", col +Screen_cols);\n   int l = row +1, ls = Insp_nl;;\n\n   if (!Insp_bufrd)\n      l = ls = 0;\n   snprintf(buf, sizeof(buf), N_fmt(YINSP_status_fmt)\n      , Insp_sel->name\n      , r, l, r, ls\n      , c, col + 1, c, col + Screen_cols\n      , (unsigned long)Insp_bufrd);\n   INSP_MKSL(0, buf);\n\n   mkrow_func = Insp_utf8 ? insp_mkrow_utf8 : insp_mkrow_raw;\n\n   for ( ; max && row < Insp_nl; row++) {\n      putp(\"\\n\");\n      mkrow_func(col, row);\n      --max;\n   }\n\n   if (max)\n      putp(Cap_nl_clreos);\n} // end: insp_show_pgs\n\n\n        /*\n         * This guy is responsible for displaying the Insp_buf contents and\n         * managing all scrolling/locate requests until the user gives up. */\nstatic int insp_view_choice (proc_t *obj) {\n#ifdef INSP_SLIDE_1\n #define hzAMT  1\n#else\n #define hzAMT  8\n#endif\n #define maxLN (Screen_rows - (Msg_row +1))\n #define makHD(b1,b2) { \\\n    snprintf(b1, sizeof(b1), \"%d\", obj->tid); \\\n    snprintf(b2, sizeof(b2), \"%s\", obj->cmd); }\n #define makFS(dst) { if (Insp_sel->flen < 22) \\\n       snprintf(dst, sizeof(dst), \"%s\", Insp_sel->fstr); \\\n    else snprintf(dst, sizeof(dst), \"%.19s...\", Insp_sel->fstr); }\n   char buf[LRGBUFSIZ];\n   int key, curlin = 0, curcol = 0;\n\nsignify_that:\n   putp(Cap_clr_scr);\n   adj_geometry();\n\n   for (;;) {\n      char pid[6], cmd[64];\n\n      if (curcol < 0) curcol = 0;\n      if (curlin >= Insp_nl) curlin = Insp_nl -1;\n      if (curlin < 0) curlin = 0;\n\n      makFS(buf)\n      makHD(pid,cmd)\n      putp(Cap_home);\n      show_special(1, fmtmk(N_unq(YINSP_hdview_fmt)\n         , pid, cmd, (Insp_sel->fstr[0]) ? buf : \" N/A \"));   // nls_maybe\n      insp_show_pgs(curcol, curlin, maxLN);\n      fflush(stdout);\n      /* fflush(stdin) didn't do the trick, so we'll just dip a little deeper\n         lest repeated <Enter> keys produce immediate re-selection in caller */\n      tcflush(STDIN_FILENO, TCIFLUSH);\n\n      if (Frames_signal) goto signify_that;\n      key = iokey(1);\n      if (key < 1) goto signify_that;\n\n      switch (key) {\n         case kbd_ENTER:          // must force new iokey()\n            key = INT_MAX;        // fall through !\n         case kbd_ESC:\n         case 'q':\n            putp(Cap_clr_scr);\n            return key;\n         case kbd_LEFT:\n            curcol -= hzAMT;\n            break;\n         case kbd_RIGHT:\n            curcol += hzAMT;\n            break;\n         case kbd_UP:\n            --curlin;\n            break;\n         case kbd_DOWN:\n            ++curlin;\n            break;\n         case kbd_PGUP:\n         case 'b':\n            curlin -= maxLN -1;   // keep 1 line for reference\n            break;\n         case kbd_PGDN:\n         case kbd_SPACE:\n            curlin += maxLN -1;   // ditto\n            break;\n         case kbd_HOME:\n         case 'g':\n            curcol = curlin = 0;\n            break;\n         case kbd_END:\n         case 'G':\n            curcol = 0;\n            curlin = Insp_nl - maxLN;\n            break;\n         case 'L':\n         case '&':\n         case '/':\n         case 'n':\n            if (!Insp_utf8)\n               insp_find_str(key, &curcol, &curlin);\n            else {\n               int tmpcol = utf8_proper_col(Insp_p[curlin], curcol, 1);\n               insp_find_str(key, &tmpcol, &curlin);\n               curcol = utf8_proper_col(Insp_p[curlin], tmpcol, 0);\n            }\n            // must re-hide cursor in case a prompt for a string makes it huge\n            putp((Cursor_state = Cap_curs_hide));\n            break;\n         case '=':\n            snprintf(buf, sizeof(buf), \"%s: %s\", Insp_sel->type, Insp_sel->fmts);\n            INSP_MKSL(1, buf);    // show an extended SL\n            if (iokey(1) < 1)\n               goto signify_that;\n            break;\n         default:                 // keep gcc happy\n            break;\n      }\n   }\n #undef hzAMT\n #undef maxLN\n #undef makHD\n #undef makFS\n} // end: insp_view_choice\n\n\n        /*\n         * This is the main Inspect routine, responsible for:\n         *   1) validating the passed pid (required, but not always used)\n         *   2) presenting/establishing the target selection\n         *   3) arranging to fill Insp_buf (via the Inspect.tab[?].func)\n         *   4) invoking insp_view_choice for viewing/scrolling/searching\n         *   5) cleaning up the dynamically acquired memory afterwards */\nstatic void inspection_utility (int pid) {\n #define mkSEL(dst) { for (i = 0; i < Inspect.total; i++) Inspect.tab[i].caps = \"~1\"; \\\n      Inspect.tab[sel].caps = \"~4\"; dst[0] = '\\0'; \\\n      for (i = 0; i < Inspect.total; i++) { char _s[SMLBUFSIZ]; \\\n         snprintf(_s, sizeof(_s), \" %s %s\", Inspect.tab[i].name, Inspect.tab[i].caps); \\\n         strcat(dst, _s); } }\n   char sels[MEDBUFSIZ];\n   static int sel;\n   int i, key;\n   proc_t *p;\n\n   for (i = 0, p = NULL; i < Frame_maxtask; i++)\n      if (pid == Curwin->ppt[i]->tid) {\n         p = Curwin->ppt[i];\n         break;\n      }\n   if (!p) {\n      show_msg(fmtmk(N_fmt(YINSP_pidbad_fmt), pid));\n      return;\n   }\n   // must re-hide cursor since the prompt for a pid made it huge\n   putp((Cursor_state = Cap_curs_hide));\nsignify_that:\n   putp(Cap_clr_scr);\n   adj_geometry();\n\n   key = INT_MAX;\n   do {\n      mkSEL(sels);\n      putp(Cap_home);\n      show_special(1, fmtmk(N_unq(YINSP_hdsels_fmt)\n         , pid, p->cmd, sels));\n      INSP_MKSL(0, \" \");\n\n      if (Frames_signal) goto signify_that;\n      if (key == INT_MAX) key = iokey(1);\n      if (key < 1) goto signify_that;\n\n      switch (key) {\n         case 'q':\n         case kbd_ESC:\n            break;\n         case kbd_END:\n            sel = 0;              // fall through !\n         case kbd_LEFT:\n            if (--sel < 0) sel = Inspect.total -1;\n            key = INT_MAX;\n            break;\n         case kbd_HOME:\n            sel = Inspect.total;  // fall through !\n         case kbd_RIGHT:\n            if (++sel >= Inspect.total) sel = 0;\n            key = INT_MAX;\n            break;\n         case kbd_ENTER:\n            INSP_BUSY;\n            Insp_sel = &Inspect.tab[sel];\n            Inspect.tab[sel].func(Inspect.tab[sel].fmts, pid);\n            Insp_utf8 = utf8_delta(Insp_buf);\n            key = insp_view_choice(p);\n            free(Insp_buf);\n            free(Insp_p);\n            break;\n         default:\n            goto signify_that;\n      }\n   } while (key != 'q' && key != kbd_ESC);\n\n #undef mkSEL\n} // end: inspection_utility\n#undef INSP_MKSL\n#undef INSP_RLEN\n#undef INSP_BUSY\n\f\n/*######  Startup routines  ##############################################*/\n\n        /*\n         * No matter what *they* say, we handle the really really BIG and\n         * IMPORTANT stuff upon which all those lessor functions depend! */\nstatic void before (char *me) {\n   struct sigaction sa;\n   proc_t p;\n   int i;\n   int linux_version_code = procps_linux_version();\n\n   atexit(close_stdout);\n\n   // is /proc mounted?\n   look_up_our_self(&p);\n\n   // setup our program name\n   Myname = strrchr(me, '/');\n   if (Myname) ++Myname; else Myname = me;\n\n   // accommodate nls/gettext potential translations\n   initialize_nls();\n\n   // override default library memory alloc error handler\n   xalloc_err_handler = xalloc_our_handler;\n\n   // establish cpu particulars\n#ifdef PRETEND8CPUS\n   smp_num_cpus = 8;\n#endif\n   Cpu_faux_tot = smp_num_cpus;\n   Cpu_States_fmts = N_unq(STATE_lin2x4_fmt);\n   if (linux_version_code > LINUX_VERSION(2, 5, 41))\n      Cpu_States_fmts = N_unq(STATE_lin2x5_fmt);\n   if (linux_version_code >= LINUX_VERSION(2, 6, 0))\n      Cpu_States_fmts = N_unq(STATE_lin2x6_fmt);\n   if (linux_version_code >= LINUX_VERSION(2, 6, 11))\n      Cpu_States_fmts = N_unq(STATE_lin2x7_fmt);\n\n   // get virtual page stuff\n   i = page_bytes; // from sysinfo.c, at lib init\n   while(i > 1024) { i >>= 1; Pg2K_shft++; }\n\n#ifndef OFF_HST_HASH\n   // prep for HST_t's put/get hashing optimizations\n   for (i = 0; i < HHASH_SIZ; i++) HHash_nul[i] = -1;\n   memcpy(HHash_one, HHash_nul, sizeof(HHash_nul));\n   memcpy(HHash_two, HHash_nul, sizeof(HHash_nul));\n#endif\n\n   numa_init();\n   Numa_node_tot = numa_max_node() + 1;\n\n#ifndef SIGRTMAX       // not available on hurd, maybe others too\n#define SIGRTMAX 32\n#endif\n   // lastly, establish a robust signals environment\n   memset(&sa, 0, sizeof(sa));\n   sigemptyset(&sa.sa_mask);\n   // with user position preserved through SIGWINCH, we must avoid SA_RESTART\n   sa.sa_flags = 0;\n   for (i = SIGRTMAX; i; i--) {\n      switch (i) {\n         case SIGALRM: case SIGHUP:  case SIGINT:\n         case SIGPIPE: case SIGQUIT: case SIGTERM:\n         case SIGUSR1: case SIGUSR2:\n            sa.sa_handler = sig_endpgm;\n            break;\n         case SIGTSTP: case SIGTTIN: case SIGTTOU:\n            sa.sa_handler = sig_paused;\n            break;\n         case SIGCONT: case SIGWINCH:\n            sa.sa_handler = sig_resize;\n            break;\n         default:\n            sa.sa_handler = sig_abexit;\n            break;\n         case SIGKILL: case SIGSTOP:\n         // because uncatchable, fall through\n         case SIGCHLD: // we can't catch this\n            continue;  // when opening a pipe\n      }\n      sigaction(i, &sa, NULL);\n   }\n} // end: before\n\n\n        /*\n         * A config_file *Helper* function responsible for converting\n         * a single window's old rc stuff into a new style rcfile entry */\nstatic int config_cvt (WIN_t *q) {\n   static struct {\n      int old, new;\n   } flags_tab[] = {\n    #define old_View_NOBOLD  0x000001\n    #define old_VISIBLE_tsk  0x000008\n    #define old_Qsrt_NORMAL  0x000010\n    #define old_Show_HICOLS  0x000200\n    #define old_Show_THREAD  0x010000\n      { old_View_NOBOLD, View_NOBOLD },\n      { old_VISIBLE_tsk, Show_TASKON },\n      { old_Qsrt_NORMAL, Qsrt_NORMAL },\n      { old_Show_HICOLS, Show_HICOLS },\n      { old_Show_THREAD, 0           }\n    #undef old_View_NOBOLD\n    #undef old_VISIBLE_tsk\n    #undef old_Qsrt_NORMAL\n    #undef old_Show_HICOLS\n    #undef old_Show_THREAD\n   };\n   static const char fields_src[] = CVT_FIELDS;\n   char fields_dst[PFLAGSSIZ], *p1, *p2;\n   int i, j, x;\n\n   // first we'll touch up this window's winflags...\n   x = q->rc.winflags;\n   q->rc.winflags = 0;\n   for (i = 0; i < MAXTBL(flags_tab); i++) {\n      if (x & flags_tab[i].old) {\n         x &= ~flags_tab[i].old;\n         q->rc.winflags |= flags_tab[i].new;\n      }\n   }\n   q->rc.winflags |= x;\n\n   // now let's convert old top's more limited fields...\n   j = strlen(q->rc.fieldscur);\n   if (j > CVT_FLDMAX)\n      return 1;\n   strcpy(fields_dst, fields_src);\n   /* all other fields represent the 'on' state with a capitalized version\n      of a particular qwerty key.  for the 2 additional suse out-of-memory\n      fields it makes perfect sense to do the exact opposite, doesn't it?\n      in any case, we must turn them 'off' temporarily... */\n   if ((p1 = strchr(q->rc.fieldscur, '[')))  *p1 = '{';\n   if ((p2 = strchr(q->rc.fieldscur, '\\\\'))) *p2 = '|';\n   for (i = 0; i < j; i++) {\n      int c = q->rc.fieldscur[i];\n      x = tolower(c) - 'a';\n      if (x < 0 || x >= CVT_FLDMAX)\n         return 1;\n      fields_dst[i] = fields_src[x];\n      if (isupper(c))\n         FLDon(fields_dst[i]);\n   }\n   // if we turned any suse only fields off, turn 'em back on OUR way...\n   if (p1) FLDon(fields_dst[p1 - q->rc.fieldscur]);\n   if (p2) FLDon(fields_dst[p2 - q->rc.fieldscur]);\n   strcpy(q->rc.fieldscur, fields_dst);\n\n   // lastly, we must adjust the old sort field enum...\n   x = q->rc.sortindx;\n   q->rc.sortindx = fields_src[x] - FLD_OFFSET;\n   if (q->rc.sortindx < 0 || q->rc.sortindx >= EU_MAXPFLGS)\n      return 1;\n\n   return 0;\n} // end: config_cvt\n\n\n        /*\n         * A configs_reads *Helper* function responsible for processing\n         * a configuration file (personal or system-wide default) */\nstatic const char *config_file (FILE *fp, const char *name, float *delay) {\n   char fbuf[LRGBUFSIZ];\n   int i, tmp_whole, tmp_fract;\n   const char *p = NULL;\n\n   p = fmtmk(N_fmt(RC_bad_files_fmt), name);\n   (void)fgets(fbuf, sizeof(fbuf), fp);     // ignore eyecatcher\n   if (6 != fscanf(fp\n      , \"Id:%c, Mode_altscr=%d, Mode_irixps=%d, Delay_time=%d.%d, Curwin=%d\\n\"\n      , &Rc.id, &Rc.mode_altscr, &Rc.mode_irixps, &tmp_whole, &tmp_fract, &i)) {\n         return p;\n   }\n   if (Rc.id < 'a' || Rc.id > RCF_VERSION_ID)\n      return p;\n   if (Rc.mode_altscr < 0 || Rc.mode_altscr > 1)\n      return p;\n   if (Rc.mode_irixps < 0 || Rc.mode_irixps > 1)\n      return p;\n   if (tmp_whole < 0)\n      return p;\n   // you saw that, right?  (fscanf stickin' it to 'i')\n   if (i < 0 || i >= GROUPSMAX)\n      return p;\n   Curwin = &Winstk[i];\n   // this may be ugly, but it keeps us locale independent...\n   *delay = (float)tmp_whole + (float)tmp_fract / 1000;\n\n   for (i = 0 ; i < GROUPSMAX; i++) {\n      int n, x;\n      WIN_t *w = &Winstk[i];\n      p = fmtmk(N_fmt(RC_bad_entry_fmt), i+1, name);\n\n      // note: \"fieldscur=%__s\" on next line should equal (PFLAGSSIZ -1) !\n      if (2 != fscanf(fp, \"%3s\\tfieldscur=%99s\\n\"\n         , w->rc.winname, w->rc.fieldscur))\n            return p;\n#if PFLAGSSIZ != 100\n // too bad fscanf is not as flexible with his format string as snprintf\n #error Hey, fix the above fscanf 'PFLAGSSIZ' dependency !\n#endif\n      // ensure there's been no manual alteration of fieldscur\n      for (n = 0 ; n < EU_MAXPFLGS; n++) {\n         if (strchr(w->rc.fieldscur, w->rc.fieldscur[n]) != strrchr(w->rc.fieldscur, w->rc.fieldscur[n]))\n            return p;\n      }\n      // be tolerant of missing release 3.3.10 graph modes additions\n      if (3 > fscanf(fp, \"\\twinflags=%d, sortindx=%d, maxtasks=%d, graph_cpus=%d, graph_mems=%d\\n\"\n         , &w->rc.winflags, &w->rc.sortindx, &w->rc.maxtasks, &w->rc.graph_cpus, &w->rc.graph_mems))\n            return p;\n      if (w->rc.sortindx < 0 || w->rc.sortindx >= EU_MAXPFLGS)\n         return p;\n      if (w->rc.maxtasks < 0)\n         return p;\n      if (w->rc.graph_cpus < 0 || w->rc.graph_cpus > 2)\n         return p;\n      if (w->rc.graph_mems < 0 || w->rc.graph_mems > 2)\n         return p;\n\n      if (4 != fscanf(fp, \"\\tsummclr=%d, msgsclr=%d, headclr=%d, taskclr=%d\\n\"\n         , &w->rc.summclr, &w->rc.msgsclr\n         , &w->rc.headclr, &w->rc.taskclr))\n            return p;\n      if (w->rc.summclr < 0 || w->rc.summclr > 7) return p;\n      if (w->rc.msgsclr < 0 || w->rc.msgsclr > 7) return p;\n      if (w->rc.headclr < 0 || w->rc.headclr > 7) return p;\n      if (w->rc.taskclr < 0 || w->rc.taskclr > 7) return p;\n\n      switch (Rc.id) {\n         case 'a':                          // 3.2.8 (former procps)\n            if (config_cvt(w))\n               return p;\n         case 'f':                          // 3.3.0 thru 3.3.3 (ng)\n            SETw(w, Show_JRNUMS);\n         case 'g':                          // from 3.3.4 thru 3.3.8\n            scat(w->rc.fieldscur, RCF_PLUS_H);\n         case 'h':                          // this is release 3.3.9\n            w->rc.graph_cpus = w->rc.graph_mems = 0;\n            // these next 2 are really global, but best documented here\n            Rc.summ_mscale = Rc.task_mscale = SK_Kb;\n         case 'i':                          // actual RCF_VERSION_ID\n            scat(w->rc.fieldscur, RCF_PLUS_J);\n         case 'j':                          // and the next version\n         default:\n            if (strlen(w->rc.fieldscur) != sizeof(DEF_FIELDS) - 1)\n               return p;\n            for (x = 0; x < EU_MAXPFLGS; ++x)\n               if (EU_MAXPFLGS <= FLDget(w, x))\n                  return p;\n            break;\n      }\n#ifndef USE_X_COLHDR\n      OFFw(w, NOHIFND_xxx | NOHISEL_xxx);\n#endif\n   } // end: for (GROUPSMAX)\n\n   // any new addition(s) last, for older rcfiles compatibility...\n   (void)fscanf(fp, \"Fixed_widest=%d, Summ_mscale=%d, Task_mscale=%d, Zero_suppress=%d\\n\"\n      , &Rc.fixed_widest, &Rc.summ_mscale, &Rc.task_mscale, &Rc.zero_suppress);\n   if (Rc.fixed_widest < -1 || Rc.fixed_widest > SCREENMAX)\n      Rc.fixed_widest = 0;\n   if (Rc.summ_mscale < 0   || Rc.summ_mscale > SK_Eb)\n      Rc.summ_mscale = 0;\n   if (Rc.task_mscale < 0   || Rc.task_mscale > SK_Pb)\n      Rc.task_mscale = 0;\n\n   // we'll start off Inspect stuff with 1 'potential' blank line\n   // ( only realized if we end up with Inspect.total > 0 )\n   for (i = 0, Inspect.raw = alloc_s(\"\\n\");;) {\n    #define iT(element) Inspect.tab[i].element\n      size_t lraw = strlen(Inspect.raw) +1;\n      char *s;\n\n      if (i < 0 || (size_t)i >= INT_MAX / sizeof(struct I_ent)) break;\n      if (lraw >= INT_MAX - sizeof(fbuf)) break;\n\n      if (!fgets(fbuf, sizeof(fbuf), fp)) break;\n      lraw += strlen(fbuf) +1;\n      Inspect.raw = alloc_r(Inspect.raw, lraw);\n      strcat(Inspect.raw, fbuf);\n\n      if (fbuf[0] == '#' || fbuf[0] == '\\n') continue;\n      Inspect.tab = alloc_r(Inspect.tab, sizeof(struct I_ent) * (i + 1));\n\n      if (!(s = strtok(fbuf, \"\\t\\n\"))) { Rc_questions = 1; continue; }\n      iT(type) = alloc_s(s);\n      if (!(s = strtok(NULL, \"\\t\\n\"))) { Rc_questions = 1; continue; }\n      iT(name) = alloc_s(s);\n      if (!(s = strtok(NULL, \"\\t\\n\"))) { Rc_questions = 1; continue; }\n      iT(fmts) = alloc_s(s);\n\n      switch (toupper(fbuf[0])) {\n         case 'F':\n            iT(func) = insp_do_file;\n            break;\n         case 'P':\n            iT(func) = insp_do_pipe;\n            break;\n         default:\n            Rc_questions = 1;\n            continue;\n      }\n      iT(farg) = (strstr(iT(fmts), \"%d\")) ? 1 : 0;\n      iT(fstr) = alloc_c(FNDBUFSIZ);\n      iT(flen) = 0;\n\n      ++i;\n    #undef iT\n   } // end: for ('inspect' entries)\n\n   Inspect.total = i;\n#ifndef INSP_OFFDEMO\n   if (!Inspect.total) {\n    #define mkS(n) N_txt(YINSP_demo ## n ## _txt)\n      const char *sels[] = { mkS(01), mkS(02), mkS(03) };\n      Inspect.total = Inspect.demo = MAXTBL(sels);\n      Inspect.tab = alloc_c(sizeof(struct I_ent) * Inspect.total);\n      for (i = 0; i < Inspect.total; i++) {\n         Inspect.tab[i].type = alloc_s(N_txt(YINSP_deqtyp_txt));\n         Inspect.tab[i].name = alloc_s(sels[i]);\n         Inspect.tab[i].func = insp_do_demo;\n         Inspect.tab[i].fmts = alloc_s(N_txt(YINSP_deqfmt_txt));\n         Inspect.tab[i].fstr = alloc_c(FNDBUFSIZ);\n      }\n    #undef mkS\n   }\n#endif\n   return NULL;\n} // end: config_file\n\n\n        /*\n         * A configs_reads *Helper* function responsible for ensuring the\n         * complete path was established, otherwise force the 'W' to fail */\nstatic int configs_path (const char *const fmts, ...) __attribute__((format(printf,1,2)));\nstatic int configs_path (const char *const fmts, ...) {\n   int len;\n   va_list ap;\n\n   va_start(ap, fmts);\n   len = vsnprintf(Rc_name, sizeof(Rc_name), fmts, ap);\n   va_end(ap);\n   if (len <= 0 || (size_t)len >= sizeof(Rc_name)) {\n      Rc_name[0] = '\\0';\n      len = 0;\n   }\n   return len;\n} // end: configs_path\n\n\n        /*\n         * Try reading up to 3 rcfiles\n         * 1. 'SYS_RCRESTRICT' contains two lines consisting of the secure\n         *     mode switch and an update interval.  Its presence limits what\n         *     ordinary users are allowed to do.\n         * 2. 'Rc_name' contains multiple lines - 3 global + 3 per window.\n         *     line 1  : an eyecatcher and creating program/alias name\n         *     line 2  : an id, Mode_altcsr, Mode_irixps, Delay_time, Curwin.\n         *     For each of the 4 windows:\n         *       line a: contains w->winname, fieldscur\n         *       line b: contains w->winflags, sortindx, maxtasks, graph modes\n         *       line c: contains w->summclr, msgsclr, headclr, taskclr\n         *     line 15 : miscellaneous additional global settings\n         *     Any remaining lines are devoted to the 'Inspect Other' feature\n         * 3. 'SYS_RCDEFAULTS' system-wide defaults if 'Rc_name' absent\n         *     format is identical to #2 above */\nstatic void configs_reads (void) {\n   float tmp_delay = DEF_DELAY;\n   const char *p, *p_home;\n   FILE *fp;\n\n   fp = fopen(SYS_RCRESTRICT, \"r\");\n   if (fp) {\n      char fbuf[SMLBUFSIZ];\n      if (fgets(fbuf, sizeof(fbuf), fp)) {     // sys rc file, line 1\n         Secure_mode = 1;\n         if (fgets(fbuf, sizeof(fbuf), fp))    // sys rc file, line 2\n            sscanf(fbuf, \"%f\", &Rc.delay_time);\n      }\n      fclose(fp);\n   }\n\n   Rc_name[0] = '\\0'; // \"fopen() shall fail if pathname is an empty string.\"\n   // attempt to use the legacy file first, if we cannot access that file, use\n   // the new XDG basedir locations (XDG_CONFIG_HOME or HOME/.config) instead.\n   p_home = getenv(\"HOME\");\n   if (!p_home || p_home[0] != '/') {\n      const struct passwd *const pwd = getpwuid(getuid());\n      if (!pwd || !(p_home = pwd->pw_dir) || p_home[0] != '/') {\n         p_home = NULL;\n      }\n   }\n   if (p_home) {\n      configs_path(\"%s/.%src\", p_home, Myname);\n   }\n\n   if (!(fp = fopen(Rc_name, \"r\"))) {\n      p = getenv(\"XDG_CONFIG_HOME\");\n      // ensure the path we get is absolute, fallback otherwise.\n      if (!p || p[0] != '/') {\n         if (!p_home) goto system_default;\n         p = fmtmk(\"%s/.config\", p_home);\n         (void)mkdir(p, 0700);\n      }\n      if (!configs_path(\"%s/procps\", p)) goto system_default;\n      (void)mkdir(Rc_name, 0700);\n      if (!configs_path(\"%s/procps/%src\", p, Myname)) goto system_default;\n      fp = fopen(Rc_name, \"r\");\n   }\n\n   if (fp) {\n      p = config_file(fp, Rc_name, &tmp_delay);\n      fclose(fp);\n      if (p) goto default_or_error;\n   } else {\nsystem_default:\n      fp = fopen(SYS_RCDEFAULTS, \"r\");\n      if (fp) {\n         p = config_file(fp, SYS_RCDEFAULTS, &tmp_delay);\n         fclose(fp);\n         if (p) goto default_or_error;\n      }\n   }\n\n   // lastly, establish the true runtime secure mode and delay time\n   if (!getuid()) Secure_mode = 0;\n   if (!Secure_mode) Rc.delay_time = tmp_delay;\n   return;\n\ndefault_or_error:\n#ifdef RCFILE_NOERR\n{  RCF_t rcdef = DEF_RCFILE;\n   int i;\n   Rc = rcdef;\n   for (i = 0 ; i < GROUPSMAX; i++)\n      Winstk[i].rc  = Rc.win[i];\n}\n#else\n   error_exit(p);\n#endif\n} // end: configs_reads\n\n\n        /*\n         * Parse command line arguments.\n         * Note: it's assumed that the rc file(s) have already been read\n         *       and our job is to see if any of those options are to be\n         *       overridden -- we'll force some on and negate others in our\n         *       best effort to honor the loser's (oops, user's) wishes... */\nstatic void parse_args (char **args) {\n   /* differences between us and the former top:\n      -C (separate CPU states for SMP) is left to an rcfile\n      -u (user monitoring) added to compliment interactive 'u'\n      -p (pid monitoring) allows a comma delimited list\n      -q (zero delay) eliminated as redundant, incomplete and inappropriate\n            use: \"nice -n-10 top -d0\" to achieve what was only claimed\n      .  most switches act as toggles (not 'on' sw) for more user flexibility\n      .  no deprecated/illegal use of 'breakargv:' with goto\n      .  bunched args are actually handled properly and none are ignored\n      .  we tolerate NO whitespace and NO switches -- maybe too tolerant? */\n   static const char numbs_str[] = \"+,-.0123456789\";\n   float tmp_delay = FLT_MAX;\n   int i;\n\n   while (*args) {\n      const char *cp = *(args++);\n\n      while (*cp) {\n         char ch;\n         float tmp;\n\n         switch ((ch = *cp)) {\n            case '\\0':\n               break;\n            case '-':\n               if (cp[1]) ++cp;\n               else if (*args) cp = *args++;\n               if (strspn(cp, \"+,-.\"))\n                  error_exit(fmtmk(N_fmt(WRONG_switch_fmt)\n                     , cp, Myname, N_txt(USAGE_abbrev_txt)));\n               continue;\n            case '1':   // ensure behavior identical to run-time toggle\n               if (CHKw(Curwin, View_CPUNOD)) OFFw(Curwin, View_CPUSUM);\n               else TOGw(Curwin, View_CPUSUM);\n               OFFw(Curwin, View_CPUNOD);\n               SETw(Curwin, View_STATES);\n               goto bump_cp;\n            case 'b':\n               Batch = 1;\n               goto bump_cp;\n            case 'c':\n               TOGw(Curwin, Show_CMDLIN);\n               goto bump_cp;\n            case 'd':\n               if (cp[1]) ++cp;\n               else if (*args) cp = *args++;\n               else error_exit(fmtmk(N_fmt(MISSING_args_fmt), ch));\n               if (!mkfloat(cp, &tmp_delay, 0))\n                  error_exit(fmtmk(N_fmt(BAD_delayint_fmt), cp));\n               if (0 > tmp_delay)\n                  error_exit(N_txt(DELAY_badarg_txt));\n               break;\n            case 'E':\n            {  const char *get = \"kmgtpe\", *got;\n               if (cp[1]) cp++;\n               else if (*args) cp = *args++;\n               else error_exit(fmtmk(N_fmt(MISSING_args_fmt), ch));\n               if (!(got = strchr(get, tolower(*cp))))\n                  error_exit(fmtmk(N_fmt(BAD_memscale_fmt), *cp));\n               Rc.summ_mscale = (int)(got - get);\n            }  goto bump_cp;\n            case 'H':\n               Thread_mode = 1;\n               goto bump_cp;\n            case 'h':\n            case 'v':\n               puts(fmtmk(N_fmt(HELP_cmdline_fmt)\n                  , PACKAGE_STRING, Myname, N_txt(USAGE_abbrev_txt)));\n               bye_bye(NULL);\n            case 'i':\n               TOGw(Curwin, Show_IDLEPS);\n               Curwin->rc.maxtasks = 0;\n               goto bump_cp;\n            case 'n':\n               if (cp[1]) cp++;\n               else if (*args) cp = *args++;\n               else error_exit(fmtmk(N_fmt(MISSING_args_fmt), ch));\n               if (!mkfloat(cp, &tmp, 1) || 1.0 > tmp)\n                  error_exit(fmtmk(N_fmt(BAD_niterate_fmt), cp));\n               Loops = (int)tmp;\n               break;\n            case 'o':\n               if (cp[1]) cp++;\n               else if (*args) cp = *args++;\n               else error_exit(fmtmk(N_fmt(MISSING_args_fmt), ch));\n               if (*cp == '+') { SETw(Curwin, Qsrt_NORMAL); ++cp; }\n               else if (*cp == '-') { OFFw(Curwin, Qsrt_NORMAL); ++cp; }\n               for (i = 0; i < EU_MAXPFLGS; i++)\n                  if (!STRCMP(cp, N_col(i))) break;\n               if (i == EU_MAXPFLGS)\n                  error_exit(fmtmk(N_fmt(XTRA_badflds_fmt), cp));\n               OFFw(Curwin, Show_FOREST);\n               Curwin->rc.sortindx = i;\n               cp += strlen(cp);\n               break;\n            case 'O':\n               for (i = 0; i < EU_MAXPFLGS; i++)\n                  puts(N_col(i));\n               bye_bye(NULL);\n            case 'p':\n            {  int pid; char *p;\n               if (Curwin->usrseltyp) error_exit(N_txt(SELECT_clash_txt));\n               do {\n                  if (cp[1]) cp++;\n                  else if (*args) cp = *args++;\n                  else error_exit(fmtmk(N_fmt(MISSING_args_fmt), ch));\n                  if (Monpidsidx >= MONPIDMAX)\n                     error_exit(fmtmk(N_fmt(LIMIT_exceed_fmt), MONPIDMAX));\n                  if (1 != sscanf(cp, \"%d\", &pid)\n                  || strpbrk(cp, \"+-.\"))\n                     error_exit(fmtmk(N_fmt(BAD_mon_pids_fmt), cp));\n                  if (!pid) pid = getpid();\n                  for (i = 0; i < Monpidsidx; i++)\n                     if (Monpids[i] == pid) goto next_pid;\n                  Monpids[Monpidsidx++] = pid;\n               next_pid:\n                  if (!(p = strchr(cp, ','))) break;\n                  cp = p;\n               } while (*cp);\n            }  break;\n            case 's':\n               Secure_mode = 1;\n               goto bump_cp;\n            case 'S':\n               TOGw(Curwin, Show_CTIMES);\n               goto bump_cp;\n            case 'u':\n            case 'U':\n            {  const char *errmsg;\n               if (Monpidsidx || Curwin->usrseltyp) error_exit(N_txt(SELECT_clash_txt));\n               if (cp[1]) cp++;\n               else if (*args) cp = *args++;\n               else error_exit(fmtmk(N_fmt(MISSING_args_fmt), ch));\n               if ((errmsg = user_certify(Curwin, cp, ch))) error_exit(errmsg);\n               cp += strlen(cp);\n            }  break;\n            case 'w':\n            {  const char *pn = NULL;\n               int ai = 0, ci = 0;\n               tmp = -1;\n               if (cp[1]) pn = &cp[1];\n               else if (*args) { pn = *args; ai = 1; }\n               if (pn && !(ci = strspn(pn, numbs_str))) { ai = 0; pn = NULL; }\n               if (pn && (!mkfloat(pn, &tmp, 1) || tmp < W_MIN_COL || tmp > SCREENMAX))\n                  error_exit(fmtmk(N_fmt(BAD_widtharg_fmt), pn));\n               Width_mode = (int)tmp;\n               cp++;\n               args += ai;\n               if (pn) cp = pn + ci;\n            }  continue;\n            default :\n               error_exit(fmtmk(N_fmt(UNKNOWN_opts_fmt)\n                  , *cp, Myname, N_txt(USAGE_abbrev_txt)));\n         } // end: switch (*cp)\n\n         // advance cp and jump over any numerical args used above\n         if (*cp) cp += strspn(&cp[1], numbs_str);\nbump_cp:\n         if (*cp) ++cp;\n      } // end: while (*cp)\n   } // end: while (*args)\n\n   // fixup delay time, maybe...\n   if (FLT_MAX > tmp_delay) {\n      if (Secure_mode)\n         error_exit(N_txt(DELAY_secure_txt));\n      Rc.delay_time = tmp_delay;\n   }\n} // end: parse_args\n\n\n        /*\n         * Set up the terminal attributes */\nstatic void whack_terminal (void) {\n   static char dummy[] = \"dumb\";\n   struct termios tmptty;\n\n   // the curses part...\n   if (Batch) {\n      setupterm(dummy, STDOUT_FILENO, NULL);\n      return;\n   }\n#ifdef PRETENDNOCAP\n   setupterm(dummy, STDOUT_FILENO, NULL);\n#else\n   setupterm(NULL, STDOUT_FILENO, NULL);\n#endif\n   // our part...\n   if (-1 == tcgetattr(STDIN_FILENO, &Tty_original))\n      error_exit(N_txt(FAIL_tty_get_txt));\n   // ok, haven't really changed anything but we do have our snapshot\n   Ttychanged = 1;\n\n   // first, a consistent canonical mode for interactive line input\n   tmptty = Tty_original;\n   tmptty.c_lflag |= (ECHO | ECHOCTL | ECHOE | ICANON | ISIG);\n   tmptty.c_lflag &= ~NOFLSH;\n   tmptty.c_oflag &= ~TAB3;\n   tmptty.c_iflag |= BRKINT;\n   tmptty.c_iflag &= ~IGNBRK;\n   if (key_backspace && 1 == strlen(key_backspace))\n      tmptty.c_cc[VERASE] = *key_backspace;\n#ifdef TERMIOS_ONLY\n   if (-1 == tcsetattr(STDIN_FILENO, TCSAFLUSH, &tmptty))\n      error_exit(fmtmk(N_fmt(FAIL_tty_set_fmt), strerror(errno)));\n   tcgetattr(STDIN_FILENO, &Tty_tweaked);\n#endif\n   // lastly, a nearly raw mode for unsolicited single keystrokes\n   tmptty.c_lflag &= ~(ECHO | ECHOCTL | ECHOE | ICANON);\n   tmptty.c_cc[VMIN] = 1;\n   tmptty.c_cc[VTIME] = 0;\n   if (-1 == tcsetattr(STDIN_FILENO, TCSAFLUSH, &tmptty))\n      error_exit(fmtmk(N_fmt(FAIL_tty_set_fmt), strerror(errno)));\n   tcgetattr(STDIN_FILENO, &Tty_raw);\n\n#ifndef OFF_STDIOLBF\n   // thanks anyway stdio, but we'll manage buffering at the frame level...\n   setbuffer(stdout, Stdout_buf, sizeof(Stdout_buf));\n#endif\n#ifdef OFF_SCROLLBK\n   // this has the effect of disabling any troublesome scrollback buffer...\n   if (enter_ca_mode) putp(enter_ca_mode);\n#endif\n   // and don't forget to ask iokey to initialize his tinfo_tab\n   iokey(0);\n} // end: whack_terminal\n\f\n/*######  Windows/Field Groups support  #################################*/\n\n        /*\n         * Value a window's name and make the associated group name. */\nstatic void win_names (WIN_t *q, const char *name) {\n   /* note: sprintf/snprintf results are \"undefined\" when src==dst,\n            according to C99 & POSIX.1-2001 (thanks adc) */\n   if (q->rc.winname != name)\n      snprintf(q->rc.winname, sizeof(q->rc.winname), \"%s\", name);\n   snprintf(q->grpname, sizeof(q->grpname), \"%d:%s\", q->winnum, name);\n} // end: win_names\n\n\n        /*\n         * This guy just resets (normalizes) a single window\n         * and he ensures pid monitoring is no longer active. */\nstatic void win_reset (WIN_t *q) {\n         SETw(q, Show_IDLEPS | Show_TASKON);\n#ifndef SCROLLVAR_NO\n         q->rc.maxtasks = q->usrseltyp = q->begpflg = q->begtask = q->varcolbeg = 0;\n#else\n         q->rc.maxtasks = q->usrseltyp = q->begpflg = q->begtask = 0;\n#endif\n         Monpidsidx = 0;\n         osel_clear(q);\n         q->findstr[0] = '\\0';\n#ifndef USE_X_COLHDR\n         // NOHISEL_xxx is redundant (already turned off by osel_clear)\n         OFFw(q, NOHIFND_xxx | NOHISEL_xxx);\n#endif\n} // end: win_reset\n\n\n        /*\n         * Display a window/field group (ie. make it \"current\"). */\nstatic WIN_t *win_select (int ch) {\n   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy\n\n   /* if there's no ch, it means we're supporting the external interface,\n      so we must try to get our own darn ch by begging the user... */\n   if (!ch) {\n      show_pmt(N_txt(CHOOSE_group_txt));\n      if (1 > (ch = iokey(1))) return w;\n   }\n   switch (ch) {\n      case 'a':                   // we don't carry 'a' / 'w' in our\n         w = w->next;             // pmt - they're here for a good\n         break;                   // friend of ours -- wins_colors.\n      case 'w':                   // (however those letters work via\n         w = w->prev;             // the pmt too but gee, end-loser\n         break;                   // should just press the darn key)\n      case '1': case '2' : case '3': case '4':\n         w = &Winstk[ch - '1'];\n         break;\n      default:                    // keep gcc happy\n         break;\n   }\n   return Curwin = w;\n} // end: win_select\n\n\n        /*\n         * Just warn the user when a command can't be honored. */\nstatic int win_warn (int what) {\n   switch (what) {\n      case Warn_ALT:\n         show_msg(N_txt(DISABLED_cmd_txt));\n         break;\n      case Warn_VIZ:\n         show_msg(fmtmk(N_fmt(DISABLED_win_fmt), Curwin->grpname));\n         break;\n      default:                    // keep gcc happy\n         break;\n   }\n   /* we gotta' return false 'cause we're somewhat well known within\n      macro society, by way of that sassy little tertiary operator... */\n   return 0;\n} // end: win_warn\n\n\n        /*\n         * Change colors *Helper* function to save/restore settings;\n         * ensure colors will show; and rebuild the terminfo strings. */\nstatic void wins_clrhlp (WIN_t *q, int save) {\n   static int flgssav, summsav, msgssav, headsav, tasksav;\n\n   if (save) {\n      flgssav = q->rc.winflags; summsav = q->rc.summclr;\n      msgssav = q->rc.msgsclr;  headsav = q->rc.headclr; tasksav = q->rc.taskclr;\n      SETw(q, Show_COLORS);\n   } else {\n      q->rc.winflags = flgssav; q->rc.summclr = summsav;\n      q->rc.msgsclr = msgssav;  q->rc.headclr = headsav; q->rc.taskclr = tasksav;\n   }\n   capsmk(q);\n} // end: wins_clrhlp\n\n\n        /*\n         * Change colors used in display */\nstatic void wins_colors (void) {\n #define kbdABORT  'q'\n #define kbdAPPLY  kbd_ENTER\n   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy\n   int clr = w->rc.taskclr, *pclr = &w->rc.taskclr;\n   char tgt = 'T';\n   int key;\n\n   if (0 >= max_colors) {\n      show_msg(N_txt(COLORS_nomap_txt));\n      return;\n   }\n   wins_clrhlp(w, 1);\n   putp((Cursor_state = Cap_curs_huge));\nsignify_that:\n   putp(Cap_clr_scr);\n   adj_geometry();\n\n   do {\n      putp(Cap_home);\n      // this string is well above ISO C89's minimum requirements!\n      show_special(1, fmtmk(N_unq(COLOR_custom_fmt)\n         , PACKAGE_STRING, w->grpname\n         , CHKw(w, View_NOBOLD) ? N_txt(ON_word_only_txt) : N_txt(OFF_one_word_txt)\n         , CHKw(w, Show_COLORS) ? N_txt(ON_word_only_txt) : N_txt(OFF_one_word_txt)\n         , CHKw(w, Show_HIBOLD) ? N_txt(ON_word_only_txt) : N_txt(OFF_one_word_txt)\n         , tgt, clr, w->grpname));\n      putp(Cap_clr_eos);\n      fflush(stdout);\n\n      if (Frames_signal) goto signify_that;\n      key = iokey(1);\n      if (key < 1) goto signify_that;\n\n      switch (key) {\n         case 'S':\n            pclr = &w->rc.summclr;\n            clr = *pclr;\n            tgt = key;\n            break;\n         case 'M':\n            pclr = &w->rc.msgsclr;\n            clr = *pclr;\n            tgt = key;\n            break;\n         case 'H':\n            pclr = &w->rc.headclr;\n            clr = *pclr;\n            tgt = key;\n            break;\n         case 'T':\n            pclr = &w->rc.taskclr;\n            clr = *pclr;\n            tgt = key;\n            break;\n         case '0': case '1': case '2': case '3':\n         case '4': case '5': case '6': case '7':\n            clr = key - '0';\n            *pclr = clr;\n            break;\n         case 'B':\n            TOGw(w, View_NOBOLD);\n            break;\n         case 'b':\n            TOGw(w, Show_HIBOLD);\n            break;\n         case 'z':\n            TOGw(w, Show_COLORS);\n            break;\n         case 'a':\n         case 'w':\n            wins_clrhlp((w = win_select(key)), 1);\n            clr = w->rc.taskclr, pclr = &w->rc.taskclr;\n            tgt = 'T';\n            break;\n         default:\n            break;                // keep gcc happy\n      }\n      capsmk(w);\n   } while (key != kbdAPPLY && key != kbdABORT);\n\n   if (key == kbdABORT) wins_clrhlp(w, 0);\n\n #undef kbdABORT\n #undef kbdAPPLY\n} // end: wins_colors\n\n\n        /*\n         * Manipulate flag(s) for all our windows. */\nstatic void wins_reflag (int what, int flg) {\n   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy\n\n   do {\n      switch (what) {\n         case Flags_TOG:\n            TOGw(w, flg);\n            break;\n         case Flags_SET:          // Ummmm, i can't find anybody\n            SETw(w, flg);         // who uses Flags_set ...\n            break;\n         case Flags_OFF:\n            OFFw(w, flg);\n            break;\n         default:                 // keep gcc happy\n            break;\n      }\n         /* a flag with special significance -- user wants to rebalance\n            display so we gotta' off some stuff then force on two flags... */\n      if (EQUWINS_xxx == flg)\n         win_reset(w);\n\n      w = w->next;\n   } while (w != Curwin);\n} // end: wins_reflag\n\n\n        /*\n         * Set up the raw/incomplete field group windows --\n         * they'll be finished off after startup completes.\n         * [ and very likely that will override most/all of our efforts ]\n         * [               --- life-is-NOT-fair ---                     ] */\nstatic void wins_stage_1 (void) {\n   WIN_t *w;\n   int i;\n\n   for (i = 0; i < GROUPSMAX; i++) {\n      w = &Winstk[i];\n      w->winnum = i + 1;\n      w->rc = Rc.win[i];\n      w->captab[0] = Cap_norm;\n      w->captab[1] = Cap_norm;\n      w->captab[2] = w->cap_bold;\n      w->captab[3] = w->capclr_sum;\n      w->captab[4] = w->capclr_msg;\n      w->captab[5] = w->capclr_pmt;\n      w->captab[6] = w->capclr_hdr;\n      w->captab[7] = w->capclr_rowhigh;\n      w->captab[8] = w->capclr_rownorm;\n      w->next = w + 1;\n      w->prev = w - 1;\n   }\n\n   // fixup the circular chains...\n   Winstk[GROUPSMAX - 1].next = &Winstk[0];\n   Winstk[0].prev = &Winstk[GROUPSMAX - 1];\n   Curwin = Winstk;\n} // end: wins_stage_1\n\n\n        /*\n         * This guy just completes the field group windows after the\n         * rcfiles have been read and command line arguments parsed.\n         * And since he's the cabose of startup, he'll also tidy up\n         * a few final things... */\nstatic void wins_stage_2 (void) {\n   int i;\n\n   for (i = 0; i < GROUPSMAX; i++) {\n      win_names(&Winstk[i], Winstk[i].rc.winname);\n      capsmk(&Winstk[i]);\n      Winstk[i].findstr = alloc_c(FNDBUFSIZ);\n      Winstk[i].findlen = 0;\n   }\n   if (!Batch)\n      putp((Cursor_state = Cap_curs_hide));\n   else {\n      OFFw(Curwin, View_SCROLL);\n      signal(SIGHUP, SIG_IGN);    // allow running under nohup\n   }\n   // fill in missing Fieldstab members and build each window's columnhdr\n   zap_fieldstab();\n\n#ifndef OFF_STDERROR\n   /* there's a chance that damn libnuma may spew to stderr so we gotta\n      make sure he does not corrupt poor ol' top's first output screen!\n      Yes, he provides some overridable 'weak' functions to change such\n      behavior but we can't exploit that since we don't follow a normal\n      ld route to symbol resolution (we use that dlopen() guy instead)! */\n   Stderr_save = dup(fileno(stderr));\n   if (-1 < Stderr_save && freopen(\"/dev/null\", \"w\", stderr))\n      ;                           // avoid -Wunused-result\n#endif\n\n   // lastly, initialize a signal set used to throttle one troublesome signal\n   sigemptyset(&Sigwinch_set);\n#ifdef SIGNALS_LESS\n   sigaddset(&Sigwinch_set, SIGWINCH);\n#endif\n} // end: wins_stage_2\n\f\n/*######  Interactive Input Tertiary support  ############################*/\n\n  /*\n   * This section exists so as to offer some function naming freedom\n   * while also maintaining the strict alphabetical order protocol\n   * within each section. */\n\n        /*\n         * This guy is a *Helper* function serving the following two masters:\n         *   find_string() - find the next match in a given window\n         *   task_show()   - highlight all matches currently in-view\n         * If q->findstr is found in the designated buffer, he returns the\n         * offset from the start of the buffer, otherwise he returns -1. */\nstatic inline int find_ofs (const WIN_t *q, const char *buf) {\n   char *fnd;\n\n   if (q->findstr[0] && (fnd = STRSTR(buf, q->findstr)))\n      return (int)(fnd - buf);\n   return -1;\n} // end: find_ofs\n\n\n\n   /* This is currently the one true prototype require by top.\n      It is placed here, instead of top.h, so as to avoid a compiler\n      warning when top_nls.c is compiled. */\nstatic const char *task_show (const WIN_t *q, const proc_t *p);\n\nstatic void find_string (int ch) {\n #define reDUX (found) ? N_txt(WORD_another_txt) : \"\"\n   static int found;\n   int i;\n\n   if ('&' == ch && !Curwin->findstr[0]) {\n      show_msg(N_txt(FIND_no_next_txt));\n      return;\n   }\n   if ('L' == ch) {\n      char *str = ioline(N_txt(GET_find_str_txt));\n      if (*str == kbd_ESC) return;\n      snprintf(Curwin->findstr, FNDBUFSIZ, \"%s\", str);\n      Curwin->findlen = strlen(Curwin->findstr);\n      found = 0;\n#ifndef USE_X_COLHDR\n      if (Curwin->findstr[0]) SETw(Curwin, NOHIFND_xxx);\n      else OFFw(Curwin, NOHIFND_xxx);\n#endif\n   }\n   if (Curwin->findstr[0]) {\n      SETw(Curwin, INFINDS_xxx);\n      for (i = Curwin->begtask; i < Frame_maxtask; i++) {\n         const char *row = task_show(Curwin, Curwin->ppt[i]);\n         if (*row && -1 < find_ofs(Curwin, row)) {\n            found = 1;\n            if (i == Curwin->begtask) continue;\n            Curwin->begtask = i;\n            return;\n         }\n      }\n      show_msg(fmtmk(N_fmt(FIND_no_find_fmt), reDUX, Curwin->findstr));\n   }\n #undef reDUX\n} // end: find_string\n\n\nstatic void help_view (void) {\n   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy\n   char key = 1;\n\n   putp((Cursor_state = Cap_curs_huge));\nsignify_that:\n   putp(Cap_clr_scr);\n   adj_geometry();\n\n   show_special(1, fmtmk(N_unq(KEYS_helpbas_fmt)\n      , PACKAGE_STRING\n      , w->grpname\n      , CHKw(w, Show_CTIMES) ? N_txt(ON_word_only_txt) : N_txt(OFF_one_word_txt)\n      , Rc.delay_time\n      , Secure_mode ? N_txt(ON_word_only_txt) : N_txt(OFF_one_word_txt)\n      , Secure_mode ? \"\" : N_unq(KEYS_helpext_fmt)));\n   putp(Cap_clr_eos);\n   fflush(stdout);\n\n   if (Frames_signal) goto signify_that;\n   key = iokey(1);\n   if (key < 1) goto signify_that;\n\n   switch (key) {\n      case kbd_ESC: case 'q':\n         break;\n      case '?': case 'h': case 'H':\n         do {\n            putp(Cap_home);\n            show_special(1, fmtmk(N_unq(WINDOWS_help_fmt)\n               , w->grpname\n               , Winstk[0].rc.winname, Winstk[1].rc.winname\n               , Winstk[2].rc.winname, Winstk[3].rc.winname));\n            putp(Cap_clr_eos);\n            fflush(stdout);\n            if (Frames_signal || (key = iokey(1)) < 1) {\n               adj_geometry();\n               putp(Cap_clr_scr);\n            } else w = win_select(key);\n         } while (key != kbd_ENTER && key != kbd_ESC);\n         break;\n      default:\n         goto signify_that;\n   }\n} // end: help_view\n\n\nstatic void other_selection (int ch) {\n   int (*rel)(const char *, const char *);\n   char *(*sel)(const char *, const char *);\n   char raw[MEDBUFSIZ], ops, *glob, *pval;\n   struct osel_s *osel;\n   const char *typ;\n   int inc, enu;\n\n   if (ch == 'o') {\n      typ   = N_txt(OSEL_casenot_txt);\n      rel   = strcasecmp;\n      sel   = strcasestr;\n   } else {\n      typ   = N_txt(OSEL_caseyes_txt);\n      rel   = strcmp;\n      sel   = strstr;\n   }\n   glob = ioline(fmtmk(N_fmt(OSEL_prompts_fmt), Curwin->osel_tot + 1, typ));\n   if (*glob == kbd_ESC\n   || !snprintf(raw, sizeof(raw), \"%s\", glob))\n      return;\n   for (osel = Curwin->osel_1st; osel; ) {\n      if (!strcmp(osel->raw, glob)) {          // #1: is criteria duplicate?\n         show_msg(N_txt(OSEL_errdups_txt));\n         return;\n      }\n      osel = osel->nxt;\n   }\n   if (*glob != '!') inc = 1;                  // #2: is it include/exclude?\n   else { ++glob; inc = 0; }\n   if (!(pval = strpbrk(glob, \"<=>\"))) {       // #3: do we see a delimiter?\n      show_msg(fmtmk(N_fmt(OSEL_errdelm_fmt)\n         , inc ? N_txt(WORD_include_txt) : N_txt(WORD_exclude_txt)));\n      return;\n   }\n   ops = *(pval);\n   *(pval++) = '\\0';\n   for (enu = 0; enu < EU_MAXPFLGS; enu++)     // #4: is this a valid field?\n      if (!STRCMP(N_col(enu), glob)) break;\n   if (enu == EU_MAXPFLGS) {\n      show_msg(fmtmk(N_fmt(XTRA_badflds_fmt), glob));\n      return;\n   }\n   if (!(*pval)) {                             // #5: did we get some value?\n      show_msg(fmtmk(N_fmt(OSEL_errvalu_fmt)\n         , inc ? N_txt(WORD_include_txt) : N_txt(WORD_exclude_txt)));\n      return;\n   }\n   if (Curwin->osel_prt && strlen(Curwin->osel_prt) >= INT_MAX - (sizeof(raw) + 6)) {\n      return;\n   }\n   osel = alloc_c(sizeof(struct osel_s));\n   osel->inc = inc;\n   osel->enu = enu;\n   osel->ops = ops;\n   if (ops == '=') osel->val = alloc_s(pval);\n   else osel->val = alloc_s(justify_pad(pval, Fieldstab[enu].width, Fieldstab[enu].align));\n   osel->rel = rel;\n   osel->sel = sel;\n   osel->raw = alloc_s(raw);\n   osel->nxt = Curwin->osel_1st;\n   Curwin->osel_1st = osel;\n   Curwin->osel_tot += 1;\n   if (!Curwin->osel_prt) Curwin->osel_prt = alloc_c(strlen(raw) + 3);\n   else Curwin->osel_prt = alloc_r(Curwin->osel_prt, strlen(Curwin->osel_prt) + strlen(raw) + 6);\n   strcat(Curwin->osel_prt, fmtmk(\"%s'%s'\", (Curwin->osel_tot > 1) ? \" + \" : \"\", raw));\n#ifndef USE_X_COLHDR\n   SETw(Curwin, NOHISEL_xxx);\n#endif\n} // end: other_selection\n\n\nstatic void write_rcfile (void) {\n   FILE *fp;\n   int i;\n\n   if (Rc_questions) {\n      show_pmt(N_txt(XTRA_warncfg_txt));\n      if ('y' != tolower(iokey(1)))\n         return;\n      Rc_questions = 0;\n   }\n   if (!(fp = fopen(Rc_name, \"w\"))) {\n      show_msg(fmtmk(N_fmt(FAIL_rc_open_fmt), Rc_name, strerror(errno)));\n      return;\n   }\n   fprintf(fp, \"%s's \" RCF_EYECATCHER, Myname);\n   fprintf(fp, \"Id:%c, Mode_altscr=%d, Mode_irixps=%d, Delay_time=%d.%d, Curwin=%d\\n\"\n      , RCF_VERSION_ID\n      , Rc.mode_altscr, Rc.mode_irixps\n        // this may be ugly, but it keeps us locale independent...\n      , (int)Rc.delay_time, (int)((Rc.delay_time - (int)Rc.delay_time) * 1000)\n      , (int)(Curwin - Winstk));\n\n   for (i = 0 ; i < GROUPSMAX; i++) {\n      fprintf(fp, \"%s\\tfieldscur=%s\\n\"\n         , Winstk[i].rc.winname, Winstk[i].rc.fieldscur);\n      fprintf(fp, \"\\twinflags=%d, sortindx=%d, maxtasks=%d, graph_cpus=%d, graph_mems=%d\\n\"\n         , Winstk[i].rc.winflags, Winstk[i].rc.sortindx, Winstk[i].rc.maxtasks\n         , Winstk[i].rc.graph_cpus,  Winstk[i].rc.graph_mems);\n      fprintf(fp, \"\\tsummclr=%d, msgsclr=%d, headclr=%d, taskclr=%d\\n\"\n         , Winstk[i].rc.summclr, Winstk[i].rc.msgsclr\n         , Winstk[i].rc.headclr, Winstk[i].rc.taskclr);\n   }\n\n   // any new addition(s) last, for older rcfiles compatibility...\n   fprintf(fp, \"Fixed_widest=%d, Summ_mscale=%d, Task_mscale=%d, Zero_suppress=%d\\n\"\n      , Rc.fixed_widest, Rc.summ_mscale, Rc.task_mscale, Rc.zero_suppress);\n\n   if (Inspect.raw)\n      fputs(Inspect.raw, fp);\n\n   fclose(fp);\n   show_msg(fmtmk(N_fmt(WRITE_rcfile_fmt), Rc_name));\n} // end: write_rcfile\n\f\n/*######  Interactive Input Secondary support (do_key helpers)  ##########*/\n\n  /*\n   *  These routines exist just to keep the do_key() function\n   *  a reasonably modest size. */\n\nstatic void keys_global (int ch) {\n   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy\n\n   switch (ch) {\n      case '?':\n      case 'h':\n         help_view();\n         break;\n      case 'B':\n         TOGw(w, View_NOBOLD);\n         capsmk(w);\n         break;\n      case 'd':\n      case 's':\n         if (Secure_mode)\n            show_msg(N_txt(NOT_onsecure_txt));\n         else {\n            float tmp =\n               get_float(fmtmk(N_fmt(DELAY_change_fmt), Rc.delay_time));\n            if (tmp > -1) Rc.delay_time = tmp;\n         }\n         break;\n      case 'E':\n         if (++Rc.summ_mscale > SK_Eb) Rc.summ_mscale = SK_Kb;\n         break;\n      case 'e':\n         if (++Rc.task_mscale > SK_Pb) Rc.task_mscale = SK_Kb;\n         break;\n      case 'F':\n      case 'f':\n         fields_utility();\n         break;\n      case 'g':\n         win_select(0);\n         break;\n      case 'H':\n         Thread_mode = !Thread_mode;\n         if (!CHKw(w, View_STATES))\n            show_msg(fmtmk(N_fmt(THREADS_show_fmt)\n               , Thread_mode ? N_txt(ON_word_only_txt) : N_txt(OFF_one_word_txt)));\n         // force an extra procs refresh to avoid %cpu distortions...\n         Pseudo_row = PROC_XTRA;\n         break;\n      case 'I':\n         if (Cpu_faux_tot > 1) {\n            Rc.mode_irixps = !Rc.mode_irixps;\n            show_msg(fmtmk(N_fmt(IRIX_curmode_fmt)\n               , Rc.mode_irixps ? N_txt(ON_word_only_txt) : N_txt(OFF_one_word_txt)));\n         } else\n            show_msg(N_txt(NOT_smp_cpus_txt));\n         break;\n      case 'k':\n         if (Secure_mode) {\n            show_msg(N_txt(NOT_onsecure_txt));\n         } else {\n            int sig = SIGTERM,\n                def = w->ppt[w->begtask]->tid,\n                pid = get_int(fmtmk(N_txt(GET_pid2kill_fmt), def));\n            if (pid > GET_NUM_ESC) {\n               char *str;\n               if (pid == GET_NUM_NOT) pid = def;\n               str = ioline(fmtmk(N_fmt(GET_sigs_num_fmt), pid, SIGTERM));\n               if (*str != kbd_ESC) {\n                  if (*str) sig = signal_name_to_number(str);\n                  if (Frames_signal) break;\n                  if (0 < sig && kill(pid, sig))\n                     show_msg(fmtmk(N_fmt(FAIL_signals_fmt)\n                        , pid, sig, strerror(errno)));\n                  else if (0 > sig) show_msg(N_txt(BAD_signalid_txt));\n               }\n            }\n         }\n         break;\n      case 'r':\n         if (Secure_mode)\n            show_msg(N_txt(NOT_onsecure_txt));\n         else {\n            int val,\n                def = w->ppt[w->begtask]->tid,\n                pid = get_int(fmtmk(N_fmt(GET_pid2nice_fmt), def));\n            if (pid > GET_NUM_ESC) {\n               if (pid == GET_NUM_NOT) pid = def;\n               val = get_int(fmtmk(N_fmt(GET_nice_num_fmt), pid));\n               if (val > GET_NUM_NOT\n               && setpriority(PRIO_PROCESS, (unsigned)pid, val))\n                  show_msg(fmtmk(N_fmt(FAIL_re_nice_fmt)\n                     , pid, val, strerror(errno)));\n            }\n         }\n         break;\n      case 'X':\n      {  int wide = get_int(fmtmk(N_fmt(XTRA_fixwide_fmt), Rc.fixed_widest));\n         if (wide > GET_NUM_NOT) {\n            if (wide >= 0 && wide <= SCREENMAX) Rc.fixed_widest = wide;\n            else Rc.fixed_widest = -1;\n         }\n      }\n         break;\n      case 'Y':\n         if (!Inspect.total)\n            ioline(N_txt(YINSP_noents_txt));\n         else {\n            int def = w->ppt[w->begtask]->tid,\n                pid = get_int(fmtmk(N_fmt(YINSP_pidsee_fmt), def));\n            if (pid > GET_NUM_ESC) {\n               if (pid == GET_NUM_NOT) pid = def;\n               if (pid) inspection_utility(pid);\n            }\n         }\n         break;\n      case 'Z':\n         wins_colors();\n         break;\n      case '0':\n         Rc.zero_suppress = !Rc.zero_suppress;\n         break;\n      case kbd_ENTER:             // these two have the effect of waking us\n      case kbd_SPACE:             // from 'pselect', refreshing the display\n         break;                   // and updating any hot-plugged resources\n      default:                    // keep gcc happy\n         break;\n   }\n} // end: keys_global\n\n\nstatic void keys_summary (int ch) {\n   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy\n\n   switch (ch) {\n      case '1':\n         if (CHKw(w, View_CPUNOD)) OFFw(w, View_CPUSUM);\n         else TOGw(w, View_CPUSUM);\n         OFFw(w, View_CPUNOD);\n         SETw(w, View_STATES);\n         break;\n      case '2':\n         if (!Numa_node_tot)\n            show_msg(N_txt(NUMA_nodenot_txt));\n         else {\n            if (Numa_node_sel < 0) TOGw(w, View_CPUNOD);\n            if (!CHKw(w, View_CPUNOD)) SETw(w, View_CPUSUM);\n            SETw(w, View_STATES);\n            Numa_node_sel = -1;\n         }\n         break;\n      case '3':\n         if (!Numa_node_tot)\n            show_msg(N_txt(NUMA_nodenot_txt));\n         else {\n            int num = get_int(fmtmk(N_fmt(NUMA_nodeget_fmt), Numa_node_tot -1));\n            if (num > GET_NUM_NOT) {\n               if (num >= 0 && num < Numa_node_tot) {\n                  Numa_node_sel = num;\n                  SETw(w, View_CPUNOD | View_STATES);\n                  OFFw(w, View_CPUSUM);\n               } else\n                  show_msg(N_txt(NUMA_nodebad_txt));\n            }\n         }\n         break;\n      case 'C':\n         VIZTOGw(w, View_SCROLL);\n         break;\n      case 'l':\n         TOGw(w, View_LOADAV);\n         break;\n      case 'm':\n         if (!CHKw(w, View_MEMORY))\n            SETw(w, View_MEMORY);\n         else if (++w->rc.graph_mems > 2) {\n            w->rc.graph_mems = 0;;\n            OFFw(w, View_MEMORY);\n         }\n         break;\n      case 't':\n         if (!CHKw(w, View_STATES))\n            SETw(w, View_STATES);\n         else if (++w->rc.graph_cpus > 2) {\n            w->rc.graph_cpus = 0;;\n            OFFw(w, View_STATES);\n         }\n         break;\n      default:                    // keep gcc happy\n         break;\n   }\n} // end: keys_summary\n\n\nstatic void keys_task (int ch) {\n   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy\n\n   switch (ch) {\n      case '#':\n      case 'n':\n         if (VIZCHKw(w)) {\n            int num = get_int(fmtmk(N_fmt(GET_max_task_fmt), w->rc.maxtasks));\n            if (num > GET_NUM_NOT) {\n               if (-1 < num ) w->rc.maxtasks = num;\n               else show_msg(N_txt(BAD_max_task_txt));\n            }\n         }\n         break;\n      case '<':\n#ifdef TREE_NORESET\n         if (CHKw(w, Show_FOREST)) break;\n#endif\n         if (VIZCHKw(w)) {\n            FLG_t *p = w->procflgs + w->maxpflgs - 1;\n            while (p > w->procflgs && *p != w->rc.sortindx) --p;\n            if (*p == w->rc.sortindx) {\n               --p;\n#ifndef USE_X_COLHDR\n               if (EU_MAXPFLGS < *p) --p;\n#endif\n               if (p >= w->procflgs) {\n                  w->rc.sortindx = *p;\n#ifndef TREE_NORESET\n                  OFFw(w, Show_FOREST);\n#endif\n               }\n            }\n         }\n         break;\n      case '>':\n#ifdef TREE_NORESET\n         if (CHKw(w, Show_FOREST)) break;\n#endif\n         if (VIZCHKw(w)) {\n            FLG_t *p = w->procflgs + w->maxpflgs - 1;\n            while (p > w->procflgs && *p != w->rc.sortindx) --p;\n            if (*p == w->rc.sortindx) {\n               ++p;\n#ifndef USE_X_COLHDR\n               if (EU_MAXPFLGS < *p) ++p;\n#endif\n               if (p < w->procflgs + w->maxpflgs) {\n                  w->rc.sortindx = *p;\n#ifndef TREE_NORESET\n                  OFFw(w, Show_FOREST);\n#endif\n               }\n            }\n         }\n         break;\n      case 'b':\n         TOGw(w, Show_HIBOLD);\n         capsmk(w);\n         break;\n      case 'c':\n         VIZTOGw(w, Show_CMDLIN);\n         break;\n      case 'i':\n      {  static WIN_t *w_sav;\n         static int beg_sav;\n         if (w_sav != w) { beg_sav = 0; w_sav = w; }\n         if (CHKw(w, Show_IDLEPS)) { beg_sav = w->begtask; w->begtask = 0; }\n         else { w->begtask = beg_sav; beg_sav = 0; }\n      }\n         VIZTOGw(w, Show_IDLEPS);\n         break;\n      case 'J':\n         VIZTOGw(w, Show_JRNUMS);\n         break;\n      case 'j':\n         VIZTOGw(w, Show_JRSTRS);\n         break;\n      case 'R':\n#ifdef TREE_NORESET\n         if (!CHKw(w, Show_FOREST)) VIZTOGw(w, Qsrt_NORMAL);\n#else\n         if (VIZCHKw(w)) {\n            TOGw(w, Qsrt_NORMAL);\n            OFFw(w, Show_FOREST);\n         }\n#endif\n         break;\n      case 'S':\n         if (VIZCHKw(w)) {\n            TOGw(w, Show_CTIMES);\n            show_msg(fmtmk(N_fmt(TIME_accumed_fmt) , CHKw(w, Show_CTIMES)\n               ? N_txt(ON_word_only_txt) : N_txt(OFF_one_word_txt)));\n         }\n         break;\n      case 'O':\n      case 'o':\n         if (VIZCHKw(w)) other_selection(ch);\n         break;\n      case 'U':\n      case 'u':\n         if (VIZCHKw(w)) {\n            const char *errmsg, *str = ioline(N_txt(GET_user_ids_txt));\n            if (*str != kbd_ESC\n            && (errmsg = user_certify(w, str, ch)))\n                show_msg(errmsg);\n         }\n         break;\n      case 'V':\n         if (VIZCHKw(w)) {\n            TOGw(w, Show_FOREST);\n            if (!ENUviz(w, EU_CMD))\n               show_msg(fmtmk(N_fmt(FOREST_modes_fmt) , CHKw(w, Show_FOREST)\n                  ? N_txt(ON_word_only_txt) : N_txt(OFF_one_word_txt)));\n         }\n         break;\n      case 'x':\n         if (VIZCHKw(w)) {\n#ifdef USE_X_COLHDR\n            TOGw(w, Show_HICOLS);\n            capsmk(w);\n#else\n            if (ENUviz(w, w->rc.sortindx)\n            && !CHKw(w, NOHIFND_xxx | NOHISEL_xxx)) {\n               TOGw(w, Show_HICOLS);\n               if (ENUpos(w, w->rc.sortindx) < w->begpflg) {\n                  if (CHKw(w, Show_HICOLS)) w->begpflg += 2;\n                  else w->begpflg -= 2;\n                  if (0 > w->begpflg) w->begpflg = 0;\n               }\n               capsmk(w);\n            }\n#endif\n         }\n         break;\n      case 'y':\n         if (VIZCHKw(w)) {\n            TOGw(w, Show_HIROWS);\n            capsmk(w);\n         }\n         break;\n      case 'z':\n         if (VIZCHKw(w)) {\n            TOGw(w, Show_COLORS);\n            capsmk(w);\n         }\n         break;\n      case kbd_CtrlO:\n         if (VIZCHKw(w))\n            ioline(fmtmk(N_fmt(OSEL_statlin_fmt)\n               , w->osel_prt ? w->osel_prt : N_txt(WORD_noneone_txt)));\n         break;\n      default:                    // keep gcc happy\n         break;\n   }\n} // end: keys_task\n\n\nstatic void keys_window (int ch) {\n   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy\n\n   switch (ch) {\n      case '+':\n         if (ALTCHKw) wins_reflag(Flags_OFF, EQUWINS_xxx);\n         break;\n      case '-':\n         if (ALTCHKw) TOGw(w, Show_TASKON);\n         break;\n      case '=':\n         win_reset(w);\n         break;\n      case '_':\n         if (ALTCHKw) wins_reflag(Flags_TOG, Show_TASKON);\n         break;\n      case '&':\n      case 'L':\n         if (VIZCHKw(w)) find_string(ch);\n         break;\n      case 'A':\n         Rc.mode_altscr = !Rc.mode_altscr;\n         break;\n      case 'a':\n      case 'w':\n         if (ALTCHKw) win_select(ch);\n         break;\n      case 'G':\n         if (ALTCHKw) {\n            char tmp[SMLBUFSIZ];\n            STRLCPY(tmp, ioline(fmtmk(N_fmt(NAME_windows_fmt), w->rc.winname)));\n            if (tmp[0] && tmp[0] != kbd_ESC) win_names(w, tmp);\n         }\n         break;\n      case kbd_UP:\n         if (VIZCHKw(w)) if (CHKw(w, Show_IDLEPS) && 0 < w->begtask) w->begtask -= 1;\n         break;\n      case kbd_DOWN:\n         if (VIZCHKw(w)) if (CHKw(w, Show_IDLEPS) && (w->begtask < Frame_maxtask - 1)) w->begtask += 1;\n         break;\n#ifdef USE_X_COLHDR // ------------------------------------\n      case kbd_LEFT:\n#ifndef SCROLLVAR_NO\n         if (VIZCHKw(w)) {\n            if (VARleft(w))\n               w->varcolbeg -= SCROLLAMT;\n            else if (0 < w->begpflg)\n               w->begpflg -= 1;\n         }\n#else\n         if (VIZCHKw(w)) if (0 < w->begpflg) w->begpflg -= 1;\n#endif\n         break;\n      case kbd_RIGHT:\n#ifndef SCROLLVAR_NO\n         if (VIZCHKw(w)) {\n            if (VARright(w)) {\n               w->varcolbeg += SCROLLAMT;\n               if (0 > w->varcolbeg) w->varcolbeg = 0;\n            } else if (w->begpflg + 1 < w->totpflgs)\n               w->begpflg += 1;\n         }\n#else\n         if (VIZCHKw(w)) if (w->begpflg + 1 < w->totpflgs) w->begpflg += 1;\n#endif\n         break;\n#else  // USE_X_COLHDR ------------------------------------\n      case kbd_LEFT:\n#ifndef SCROLLVAR_NO\n         if (VIZCHKw(w)) {\n            if (VARleft(w))\n               w->varcolbeg -= SCROLLAMT;\n            else if (0 < w->begpflg) {\n               w->begpflg -= 1;\n               if (EU_MAXPFLGS < w->pflgsall[w->begpflg]) w->begpflg -= 2;\n            }\n         }\n#else\n         if (VIZCHKw(w)) if (0 < w->begpflg) {\n            w->begpflg -= 1;\n            if (EU_MAXPFLGS < w->pflgsall[w->begpflg]) w->begpflg -= 2;\n         }\n#endif\n         break;\n      case kbd_RIGHT:\n#ifndef SCROLLVAR_NO\n         if (VIZCHKw(w)) {\n            if (VARright(w)) {\n               w->varcolbeg += SCROLLAMT;\n               if (0 > w->varcolbeg) w->varcolbeg = 0;\n            } else if (w->begpflg + 1 < w->totpflgs) {\n               if (EU_MAXPFLGS < w->pflgsall[w->begpflg])\n                  w->begpflg += (w->begpflg + 3 < w->totpflgs) ? 3 : 0;\n               else w->begpflg += 1;\n            }\n         }\n#else\n         if (VIZCHKw(w)) if (w->begpflg + 1 < w->totpflgs) {\n            if (EU_MAXPFLGS < w->pflgsall[w->begpflg])\n               w->begpflg += (w->begpflg + 3 < w->totpflgs) ? 3 : 0;\n            else w->begpflg += 1;\n         }\n#endif\n         break;\n#endif // USE_X_COLHDR ------------------------------------\n      case kbd_PGUP:\n         if (VIZCHKw(w)) if (0 < w->begtask) {\n               w->begtask -= (w->winlines - 1);\n               if (0 > w->begtask) w->begtask = 0;\n            }\n         break;\n      case kbd_PGDN:\n         if (VIZCHKw(w)) if (w->begtask < Frame_maxtask - 1) {\n               w->begtask += (w->winlines - 1);\n               if (w->begtask > Frame_maxtask - 1) w->begtask = Frame_maxtask - 1;\n               if (0 > w->begtask) w->begtask = 0;\n             }\n         break;\n      case kbd_HOME:\n#ifndef SCROLLVAR_NO\n         if (VIZCHKw(w)) w->begtask = w->begpflg = w->varcolbeg = 0;\n#else\n         if (VIZCHKw(w)) w->begtask = w->begpflg = 0;\n#endif\n         break;\n      case kbd_END:\n         if (VIZCHKw(w)) {\n            w->begtask = (Frame_maxtask - w->winlines) + 1;\n            if (0 > w->begtask) w->begtask = 0;\n            w->begpflg = w->endpflg;\n#ifndef SCROLLVAR_NO\n            w->varcolbeg = 0;\n#endif\n         }\n         break;\n      default:                    // keep gcc happy\n         break;\n   }\n} // end: keys_window\n\n\nstatic void keys_xtra (int ch) {\n// const char *xmsg;\n   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy\n\n#ifdef TREE_NORESET\n   if (CHKw(w, Show_FOREST)) return;\n#else\n   OFFw(w, Show_FOREST);\n#endif\n   /* these keys represent old-top compatibility --\n      they're grouped here so that if users could ever be weaned,\n      we would just whack do_key's key_tab entry and this function... */\n   switch (ch) {\n      case 'M':\n         w->rc.sortindx = EU_MEM;\n//       xmsg = \"Memory\";\n         break;\n      case 'N':\n         w->rc.sortindx = EU_PID;\n//       xmsg = \"Numerical\";\n         break;\n      case 'P':\n         w->rc.sortindx = EU_CPU;\n//       xmsg = \"CPU\";\n         break;\n      case 'T':\n         w->rc.sortindx = EU_TM2;\n//       xmsg = \"Time\";\n         break;\n      default:                    // keep gcc happy\n         break;\n   }\n// some have objected to this message, so we'll just keep silent...\n// show_msg(fmtmk(\"%s sort compatibility key honored\", xmsg));\n} // end: keys_xtra\n\f\n/*######  Forest View support  ###########################################*/\n\n        /*\n         * We try to keep most existing code unaware of our activities\n         * ( plus, maintain alphabetical order with carefully chosen )\n         * ( function names: forest_a, forest_b, forest_c & forest_d )\n         * ( each with exactly one letter more than its predecessor! ) */\nstatic proc_t **Seed_ppt;                   // temporary win ppt pointer\nstatic proc_t **Tree_ppt;                   // forest_create will resize\nstatic int      Tree_idx;                   // frame_make resets to zero\n\n        /*\n         * This little recursive guy is the real forest view workhorse.\n         * He fills in the Tree_ppt array and also sets the child indent\n         * level which is stored in an unused proc_t padding byte. */\nstatic void forest_adds (const int self, int level) {\n   int i;\n\n   if (Tree_idx < Frame_maxtask) {          // immunize against insanity\n      if (level > 100) level = 101;         // our arbitrary nests limit\n      Tree_ppt[Tree_idx] = Seed_ppt[self];  // add this as root or child\n      Tree_ppt[Tree_idx++]->pad_3 = level;  // borrow 1 byte, 127 levels\n#ifdef TREE_SCANALL\n      for (i = 0; i < Frame_maxtask; i++) {\n         if (i == self) continue;\n#else\n      for (i = self + 1; i < Frame_maxtask; i++) {\n#endif\n         if (Seed_ppt[self]->tid == Seed_ppt[i]->tgid\n         || (Seed_ppt[self]->tid == Seed_ppt[i]->ppid && Seed_ppt[i]->tid == Seed_ppt[i]->tgid))\n            forest_adds(i, level + 1);      // got one child any others?\n      }\n   }\n} // end: forest_adds\n\n\n#ifndef TREE_SCANALL\n        /*\n         * Our qsort callback to order a ppt by the non-display start_time\n         * which will make us immune from any pid, ppid or tgid anomalies\n         * if/when pid values are wrapped by the kernel! */\nstatic int forest_based (const proc_t **x, const proc_t **y) {\n   if ( (*x)->start_time > (*y)->start_time ) return  1;\n   if ( (*x)->start_time < (*y)->start_time ) return -1;\n   return 0;\n} // end: forest_based\n#endif\n\n\n        /*\n         * This routine is responsible for preparing the proc_t's for\n         * a forest display in the designated window.  Upon completion,\n         * he'll replace the original window ppt with our specially\n         * ordered forest version. */\nstatic void forest_create (WIN_t *q) {\n   static int hwmsav;\n   int i;\n\n   Seed_ppt = q->ppt;                       // avoid passing WIN_t ptrs\n   if (!Tree_idx) {                         // do just once per frame\n      if (hwmsav < Frame_maxtask) {         // grow, but never shrink\n         hwmsav = Frame_maxtask;\n         Tree_ppt = alloc_r(Tree_ppt, sizeof(proc_t*) * hwmsav);\n      }\n#ifndef TREE_SCANALL\n      qsort(Seed_ppt, Frame_maxtask, sizeof(proc_t*), (QFP_t)forest_based);\n#endif\n      for (i = 0; i < Frame_maxtask; i++)   // avoid any hidepid distortions\n         if (!Seed_ppt[i]->pad_3)           // identify real or pretend trees\n            forest_adds(i, 0);              // add as parent plus its children\n   }\n   memcpy(Seed_ppt, Tree_ppt, sizeof(proc_t*) * Frame_maxtask);\n} // end: forest_create\n\n\n        /*\n         * This guy adds the artwork to either p->cmd or p->cmdline\n         * when in forest view mode, otherwise he just returns 'em. */\nstatic inline const char *forest_display (const WIN_t *q, const proc_t *p) {\n#ifndef SCROLLVAR_NO\n   static char buf[1024*64*2]; // the same as readproc's MAX_BUFSZ\n#else\n   static char buf[ROWMINSIZ];\n#endif\n   const char *which = (CHKw(q, Show_CMDLIN)) ? *p->cmdline : p->cmd;\n\n   if (!CHKw(q, Show_FOREST) || !p->pad_3) return which;\n   if (p->pad_3 > 100) snprintf(buf, sizeof(buf), \"%400s%s\", \" +  \", which);\n   else snprintf(buf, sizeof(buf), \"%*s%s\", (4 * p->pad_3), \" `- \", which);\n   return buf;\n} // end: forest_display\n\f\n/*######  Main Screen routines  ##########################################*/\n\n        /*\n         * Process keyboard input during the main loop */\nstatic void do_key (int ch) {\n   static struct {\n      void (*func)(int ch);\n      char keys[SMLBUFSIZ];\n   } key_tab[] = {\n      { keys_global,\n         { '?', 'B', 'd', 'E', 'e', 'F', 'f', 'g', 'H', 'h'\n         , 'I', 'k', 'r', 's', 'X', 'Y', 'Z', '0'\n         , kbd_ENTER, kbd_SPACE, '\\0' } },\n      { keys_summary,\n         { '1', '2', '3', 'C', 'l', 'm', 't', '\\0' } },\n      { keys_task,\n         { '#', '<', '>', 'b', 'c', 'i', 'J', 'j', 'n', 'O', 'o'\n         , 'R', 'S', 'U', 'u', 'V', 'x', 'y', 'z'\n         , kbd_CtrlO, '\\0' } },\n      { keys_window,\n         { '+', '-', '=', '_', '&', 'A', 'a', 'G', 'L', 'w'\n         , kbd_UP, kbd_DOWN, kbd_LEFT, kbd_RIGHT, kbd_PGUP, kbd_PGDN\n         , kbd_HOME, kbd_END, '\\0' } },\n      { keys_xtra,\n         { 'M', 'N', 'P', 'T', '\\0'} }\n   };\n   int i;\n\n   switch (ch) {\n      case 0:                // ignored (always)\n      case kbd_ESC:          // ignored (sometimes)\n         goto all_done;\n      case 'q':              // no return from this guy\n         bye_bye(NULL);\n      case 'W':              // no need for rebuilds\n         write_rcfile();\n         goto all_done;\n      default:               // and now, the real work...\n         for (i = 0; i < MAXTBL(key_tab); ++i)\n            if (strchr(key_tab[i].keys, ch)) {\n               key_tab[i].func(ch);\n               Frames_signal = BREAK_kbd;\n               goto all_done;\n            }\n   };\n   /* Frames_signal above will force a rebuild of all column headers and\n      the PROC_FILLxxx flags.  It's NOT simply lazy programming.  Here are\n      some keys that COULD require new column headers and/or libproc flags:\n         'A' - likely\n         'c' - likely when !Mode_altscr, maybe when Mode_altscr\n         'F' - likely\n         'f' - likely\n         'g' - likely\n         'H' - likely\n         'I' - likely\n         'J' - always\n         'j' - always\n         'Z' - likely, if 'Curwin' changed when !Mode_altscr\n         '-' - likely (restricted to Mode_altscr)\n         '_' - likely (restricted to Mode_altscr)\n         '=' - maybe, but only when Mode_altscr\n         '+' - likely (restricted to Mode_altscr)\n         PLUS, likely for FOUR of the EIGHT cursor motion keys (scrolled)\n      ( At this point we have a human being involved and so have all the time )\n      ( in the world.  We can afford a few extra cpu cycles every now & then! )\n    */\n\n   show_msg(N_txt(UNKNOWN_cmds_txt));\nall_done:\n   sysinfo_refresh(1);       // let's be more responsive to hot-pluggin'\n   putp((Cursor_state = Cap_curs_hide));\n} // end: do_key\n\n\n        /*\n         * State display *Helper* function to calc and display the state\n         * percentages for a single cpu.  In this way, we can support\n         * the following environments without the usual code bloat.\n         *    1) single cpu machines\n         *    2) modest smp boxes with room for each cpu's percentages\n         *    3) massive smp guys leaving little or no room for process\n         *       display and thus requiring the cpu summary toggle */\nstatic void summary_hlp (CPU_t *cpu, const char *pfx) {\n   /* we'll trim to zero if we get negative time ticks,\n      which has happened with some SMP kernels (pre-2.4?)\n      and when cpus are dynamically added or removed */\n #define TRIMz(x)  ((tz = (SIC_t)(x)) < 0 ? 0 : tz)\n   //    user    syst    nice    idle    wait    hirg    sirq    steal\n   SIC_t u_frme, s_frme, n_frme, i_frme, w_frme, x_frme, y_frme, z_frme, tot_frme, tz;\n   float scale;\n\n   u_frme = TRIMz(cpu->cur.u - cpu->sav.u);\n   s_frme = TRIMz(cpu->cur.s - cpu->sav.s);\n   n_frme = TRIMz(cpu->cur.n - cpu->sav.n);\n   i_frme = TRIMz(cpu->cur.i - cpu->sav.i);\n   w_frme = TRIMz(cpu->cur.w - cpu->sav.w);\n   x_frme = TRIMz(cpu->cur.x - cpu->sav.x);\n   y_frme = TRIMz(cpu->cur.y - cpu->sav.y);\n   z_frme = TRIMz(cpu->cur.z - cpu->sav.z);\n   tot_frme = u_frme + s_frme + n_frme + i_frme + w_frme + x_frme + y_frme + z_frme;\n#ifndef CPU_ZEROTICS\n   if (tot_frme < cpu->edge)\n      tot_frme = u_frme = s_frme = n_frme = i_frme = w_frme = x_frme = y_frme = z_frme = 0;\n#endif\n   if (1 > tot_frme) i_frme = tot_frme = 1;\n   scale = 100.0 / (float)tot_frme;\n\n   /* display some kinda' cpu state percentages\n      (who or what is explained by the passed prefix) */\n   if (Curwin->rc.graph_cpus) {\n      static struct {\n         const char *user, *syst, *type;\n      } gtab[] = {\n         { \"%-.*s~7\", \"%-.*s~8\", Graph_bars },\n         { \"%-.*s~4\", \"%-.*s~6\", Graph_blks }\n      };\n      char user[SMLBUFSIZ], syst[SMLBUFSIZ], dual[MEDBUFSIZ];\n      int ix = Curwin->rc.graph_cpus - 1;\n      float pct_user = (float)(u_frme + n_frme) * scale,\n            pct_syst = (float)(s_frme + x_frme + y_frme) * scale;\n#ifndef QUICK_GRAPHS\n      int num_user = (int)((pct_user * Graph_adj) + .5),\n          num_syst = (int)((pct_syst * Graph_adj) + .5);\n      if (num_user + num_syst > Graph_len) num_syst = Graph_len - num_user;\n      snprintf(user, sizeof(user), gtab[ix].user, num_user, gtab[ix].type);\n      snprintf(syst, sizeof(syst), gtab[ix].syst, num_syst, gtab[ix].type);\n#else\n      snprintf(user, sizeof(user), gtab[ix].user, (int)((pct_user * Graph_adj) + .5), gtab[ix].type);\n      snprintf(syst, sizeof(syst), gtab[ix].syst, (int)((pct_syst * Graph_adj) + .4), gtab[ix].type);\n#endif\n      snprintf(dual, sizeof(dual), \"%s%s\", user, syst);\n      show_special(0, fmtmk(\"%%%s ~3%#5.1f~2/%-#5.1f~3 %3.0f[~1%-*s]~1\\n\"\n         , pfx, pct_user, pct_syst, pct_user + pct_syst, Graph_len +4, dual));\n   } else {\n      show_special(0, fmtmk(Cpu_States_fmts, pfx\n         , (float)u_frme * scale, (float)s_frme * scale\n         , (float)n_frme * scale, (float)i_frme * scale\n         , (float)w_frme * scale, (float)x_frme * scale\n         , (float)y_frme * scale, (float)z_frme * scale));\n   }\n #undef TRIMz\n} // end: summary_hlp\n\n\n        /*\n         * In support of a new frame:\n         *    1) Display uptime and load average (maybe)\n         *    2) Display task/cpu states (maybe)\n         *    3) Display memory & swap usage (maybe) */\nstatic void summary_show (void) {\n #define isROOM(f,n) (CHKw(w, f) && Msg_row + (n) < Screen_rows - 1)\n #define anyFLG 0xffffff\n   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy\n   char tmp[MEDBUFSIZ];\n   int i;\n\n   // Display Uptime and Loadavg\n   if (isROOM(View_LOADAV, 1)) {\n      if (!Rc.mode_altscr)\n         show_special(0, fmtmk(LOADAV_line, Myname, sprint_uptime(0)));\n      else\n         show_special(0, fmtmk(CHKw(w, Show_TASKON)? LOADAV_line_alt : LOADAV_line\n            , w->grpname, sprint_uptime(0)));\n      Msg_row += 1;\n   } // end: View_LOADAV\n\n   // Display Task and Cpu(s) States\n   if (isROOM(View_STATES, 2)) {\n      show_special(0, fmtmk(N_unq(STATE_line_1_fmt)\n         , Thread_mode ? N_txt(WORD_threads_txt) : N_txt(WORD_process_txt)\n         , Frame_maxtask, Frame_running, Frame_sleepin\n         , Frame_stopped, Frame_zombied));\n      Msg_row += 1;\n\n      cpus_refresh();\n\n      if (!Numa_node_tot) goto numa_nope;\n\n      if (CHKw(w, View_CPUNOD)) {\n         if (Numa_node_sel < 0) {\n            // display the 1st /proc/stat line, then the nodes (if room)\n            summary_hlp(&Cpu_tics[smp_num_cpus], N_txt(WORD_allcpus_txt));\n            Msg_row += 1;\n            // display each cpu node's states\n            for (i = 0; i < Numa_node_tot; i++) {\n               CPU_t *nod_ptr = &Cpu_tics[1 + smp_num_cpus + i];\n               if (!isROOM(anyFLG, 1)) break;\n#ifndef OFF_NUMASKIP\n               if (nod_ptr->id) {\n#endif\n               snprintf(tmp, sizeof(tmp), N_fmt(NUMA_nodenam_fmt), i);\n               summary_hlp(nod_ptr, tmp);\n               Msg_row += 1;\n#ifndef OFF_NUMASKIP\n               }\n#endif\n            }\n         } else {\n            // display the node summary, then the associated cpus (if room)\n            snprintf(tmp, sizeof(tmp), N_fmt(NUMA_nodenam_fmt), Numa_node_sel);\n            summary_hlp(&Cpu_tics[1 + smp_num_cpus + Numa_node_sel], tmp);\n            Msg_row += 1;\n            for (i = 0; i < Cpu_faux_tot; i++) {\n               if (Numa_node_sel == Cpu_tics[i].node) {\n                  if (!isROOM(anyFLG, 1)) break;\n                  snprintf(tmp, sizeof(tmp), N_fmt(WORD_eachcpu_fmt), Cpu_tics[i].id);\n                  summary_hlp(&Cpu_tics[i], tmp);\n                  Msg_row += 1;\n               }\n            }\n         }\n      } else\nnuma_nope:\n      if (CHKw(w, View_CPUSUM)) {\n         // display just the 1st /proc/stat line\n         summary_hlp(&Cpu_tics[Cpu_faux_tot], N_txt(WORD_allcpus_txt));\n         Msg_row += 1;\n\n      } else {\n         // display each cpu's states separately, screen height permitting...\n         for (i = 0; i < Cpu_faux_tot; i++) {\n            snprintf(tmp, sizeof(tmp), N_fmt(WORD_eachcpu_fmt), Cpu_tics[i].id);\n            summary_hlp(&Cpu_tics[i], tmp);\n            Msg_row += 1;\n            if (!isROOM(anyFLG, 1)) break;\n         }\n      }\n   } // end: View_STATES\n\n   // Display Memory and Swap stats\n   if (isROOM(View_MEMORY, 2)) {\n    #define bfT(n)  buftab[n].buf\n    #define scT(e)  scaletab[Rc.summ_mscale]. e\n    #define mkM(x) (float)kb_main_ ## x / scT(div)\n    #define mkS(x) (float)kb_swap_ ## x / scT(div)\n    #define prT(b,z) { if (9 < snprintf(b, 10, scT(fmts), z)) b[8] = '+'; }\n      static struct {\n         float div;\n         const char *fmts;\n         const char *label;\n      } scaletab[] = {\n         { 1, \"%.0f \", NULL },                             // kibibytes\n#ifdef BOOST_MEMORY\n         { 1024.0, \"%#.3f \", NULL },                       // mebibytes\n         { 1024.0*1024, \"%#.3f \", NULL },                  // gibibytes\n         { 1024.0*1024*1024, \"%#.3f \", NULL },             // tebibytes\n         { 1024.0*1024*1024*1024, \"%#.3f \", NULL },        // pebibytes\n         { 1024.0*1024*1024*1024*1024, \"%#.3f \", NULL }    // exbibytes\n#else\n         { 1024.0, \"%#.1f \", NULL },                       // mebibytes\n         { 1024.0*1024, \"%#.1f \", NULL },                  // gibibytes\n         { 1024.0*1024*1024, \"%#.1f \", NULL },             // tebibytes\n         { 1024.0*1024*1024*1024, \"%#.1f \", NULL },        // pebibytes\n         { 1024.0*1024*1024*1024*1024, \"%#.1f \", NULL }    // exbibytes\n#endif\n      };\n      struct { //                                            0123456789\n      // snprintf contents of each buf (after SK_Kb):       'nnnn.nnn 0'\n      // and prT macro might replace space at buf[8] with:   ------> +\n         char buf[10]; // MEMORY_lines_fmt provides for 8+1 bytes\n      } buftab[8];\n\n      if (!scaletab[0].label) {\n         scaletab[0].label = N_txt(AMT_kilobyte_txt);\n         scaletab[1].label = N_txt(AMT_megabyte_txt);\n         scaletab[2].label = N_txt(AMT_gigabyte_txt);\n         scaletab[3].label = N_txt(AMT_terabyte_txt);\n         scaletab[4].label = N_txt(AMT_petabyte_txt);\n         scaletab[5].label = N_txt(AMT_exxabyte_txt);\n      }\n\n      if (w->rc.graph_mems) {\n         static const struct {\n            const char *used, *misc, *swap, *type;\n         } gtab[] = {\n            { \"%-.*s~7\", \"%-.*s~8\", \"%-.*s~8\", Graph_bars },\n            { \"%-.*s~4\", \"%-.*s~6\", \"%-.*s~6\", Graph_blks }\n         };\n         char used[SMLBUFSIZ], util[SMLBUFSIZ], dual[MEDBUFSIZ];\n         float pct_used, pct_misc, pct_swap;\n         int ix, num_used, num_misc;\n\n         pct_used = (float)kb_main_used * (100.0 / (float)kb_main_total);\n#ifdef MEMGRAPH_OLD\n         pct_misc = (float)(kb_main_buffers + kb_main_cached) * (100.0 / (float)kb_main_total);\n#else\n         pct_misc = (float)(kb_main_total - kb_main_available - kb_main_used) * (100.0 / (float)kb_main_total);\n#endif\n         if (pct_used + pct_misc > 100.0 || pct_misc < 0) pct_misc = 0;\n         pct_swap = kb_swap_total ? (float)kb_swap_used * (100.0 / (float)kb_swap_total) : 0;\n         ix = w->rc.graph_mems - 1;\n#ifndef QUICK_GRAPHS\n         num_used = (int)((pct_used * Graph_adj) + .5),\n         num_misc = (int)((pct_misc * Graph_adj) + .5);\n         if (num_used + num_misc > Graph_len) num_misc = Graph_len - num_used;\n         snprintf(used, sizeof(used), gtab[ix].used, num_used, gtab[ix].type);\n         snprintf(util, sizeof(util), gtab[ix].misc, num_misc, gtab[ix].type);\n#else\n         (void)num_used; (void)num_misc;\n         snprintf(used, sizeof(used), gtab[ix].used, (int)((pct_used * Graph_adj) + .5), gtab[ix].type);\n         snprintf(util, sizeof(util), gtab[ix].misc, (int)((pct_misc * Graph_adj) + .4), gtab[ix].type);\n#endif\n         snprintf(dual, sizeof(dual), \"%s%s\", used, util);\n         snprintf(util, sizeof(util), gtab[ix].swap, (int)((pct_swap * Graph_adj) + .5), gtab[ix].type);\n         prT(bfT(0), mkM(total)); prT(bfT(1), mkS(total));\n         show_special(0, fmtmk( \"%s %s:~3%#5.1f~2/%-9.9s~3[~1%-*s]~1\\n%s %s:~3%#5.1f~2/%-9.9s~3[~1%-*s]~1\\n\"\n            , scT(label), N_txt(WORD_abv_mem_txt), pct_used + pct_misc, bfT(0), Graph_len +4, dual\n            , scT(label), N_txt(WORD_abv_swp_txt), pct_swap, bfT(1), Graph_len +2, util));\n      } else {\n         unsigned long kb_main_my_misc = kb_main_buffers + kb_main_cached;\n         prT(bfT(0), mkM(total)); prT(bfT(1), mkM(free));\n         prT(bfT(2), mkM(used));  prT(bfT(3), mkM(my_misc));\n         prT(bfT(4), mkS(total)); prT(bfT(5), mkS(free));\n         prT(bfT(6), mkS(used));  prT(bfT(7), mkM(available));\n         show_special(0, fmtmk(N_unq(MEMORY_lines_fmt)\n            , scT(label), N_txt(WORD_abv_mem_txt), bfT(0), bfT(1), bfT(2), bfT(3)\n            , scT(label), N_txt(WORD_abv_swp_txt), bfT(4), bfT(5), bfT(6), bfT(7)\n            , N_txt(WORD_abv_mem_txt)));\n      }\n      Msg_row += 2;\n    #undef bfT\n    #undef scT\n    #undef mkM\n    #undef mkS\n    #undef prT\n   } // end: View_MEMORY\n\n #undef isROOM\n #undef anyFLG\n} // end: summary_show\n\n\n        /*\n         * Build the information for a single task row and\n         * display the results or return them to the caller. */\nstatic const char *task_show (const WIN_t *q, const proc_t *p) {\n#ifndef SCROLLVAR_NO\n #define makeVAR(v)  { const char *pv = v; \\\n    if (!q->varcolbeg) cp = make_str(pv, q->varcolsz, Js, AUTOX_NO); \\\n    else cp = make_str(q->varcolbeg < (int)strlen(pv) ? pv + q->varcolbeg : \"\", q->varcolsz, Js, AUTOX_NO); }\n #define varUTF8(v)  { const char *pv = v; \\\n    if (!q->varcolbeg) cp = make_str_utf8(pv, q->varcolsz, Js, AUTOX_NO); \\\n    else cp = make_str_utf8((q->varcolbeg < ((int)strlen(pv) - utf8_delta(pv))) \\\n    ? pv + utf8_embody(pv, q->varcolbeg) : \"\", q->varcolsz, Js, AUTOX_NO); }\n#else\n #define makeVAR(v) cp = make_str(v, q->varcolsz, Js, AUTOX_NO)\n #define varUTF8(v) cp = make_str_utf8(v, q->varcolsz, Js, AUTOX_NO)\n#endif\n #define pages2K(n)  (unsigned long)( (n) << Pg2K_shft )\n   static char rbuf[ROWMINSIZ];\n   char *rp;\n   int x;\n\n   // we must begin a row with a possible window number in mind...\n   *(rp = rbuf) = '\\0';\n   if (Rc.mode_altscr) rp = scat(rp, \" \");\n\n   for (x = 0; x < q->maxpflgs; x++) {\n      const char *cp = NULL;\n      FLG_t       i = q->procflgs[x];\n      #define S   Fieldstab[i].scale        // these used to be variables\n      #define W   Fieldstab[i].width        // but it's much better if we\n      #define Js  CHKw(q, Show_JRSTRS)      // represent them as #defines\n      #define Jn  CHKw(q, Show_JRNUMS)      // and only exec code if used\n\n      switch (i) {\n#ifndef USE_X_COLHDR\n         // these 2 aren't real procflgs, they're used in column highlighting!\n         case EU_XON:\n         case EU_XOF:\n            cp = NULL;\n            if (!CHKw(q, INFINDS_xxx | NOHIFND_xxx | NOHISEL_xxx)) {\n               /* treat running tasks specially - entire row may get highlighted\n                  so we needn't turn it on and we MUST NOT turn it off */\n               if (!('R' == p->state && CHKw(q, Show_HIROWS)))\n                  cp = (EU_XON == i ? q->capclr_rowhigh : q->capclr_rownorm);\n            }\n            break;\n#endif\n         case EU_CGN:\n            makeVAR(p->cgname);\n            break;\n         case EU_CGR:\n            makeVAR(p->cgroup[0]);\n            break;\n         case EU_CMD:\n            makeVAR(forest_display(q, p));\n            break;\n         case EU_COD:\n            cp = scale_mem(S, pages2K(p->trs), W, Jn);\n            break;\n         case EU_CPN:\n            cp = make_num(p->processor, W, Jn, AUTOX_NO, 0);\n            break;\n         case EU_CPU:\n         {  float u = (float)p->pcpu * Frame_etscale;\n            /* process can't use more %cpu than number of threads it has\n             ( thanks Jaromir Capik <jcapik@redhat.com> ) */\n            if (u > 100.0 * p->nlwp) u = 100.0 * p->nlwp;\n            if (u > Cpu_pmax) u = Cpu_pmax;\n            cp = scale_pcnt(u, W, Jn);\n         }\n            break;\n         case EU_DAT:\n            cp = scale_mem(S, pages2K(p->drs), W, Jn);\n            break;\n         case EU_DRT:\n            cp = scale_num(p->dt, W, Jn);\n            break;\n         case EU_ENV:\n            makeVAR(p->environ[0]);\n            break;\n         case EU_FL1:\n            cp = scale_num(p->maj_flt, W, Jn);\n            break;\n         case EU_FL2:\n            cp = scale_num(p->min_flt, W, Jn);\n            break;\n         case EU_FLG:\n            cp = make_str(hex_make(p->flags, 1), W, Js, AUTOX_NO);\n            break;\n         case EU_FV1:\n            cp = scale_num(p->maj_delta, W, Jn);\n            break;\n         case EU_FV2:\n            cp = scale_num(p->min_delta, W, Jn);\n            break;\n         case EU_GID:\n            cp = make_num(p->egid, W, Jn, EU_GID, 0);\n            break;\n         case EU_GRP:\n            cp = make_str_utf8(p->egroup, W, Js, EU_GRP);\n            break;\n         case EU_LXC:\n            cp = make_str(p->lxcname, W, Js, EU_LXC);\n            break;\n         case EU_MEM:\n            cp = scale_pcnt((float)pages2K(p->resident) * 100 / kb_main_total, W, Jn);\n            break;\n         case EU_NCE:\n            cp = make_num(p->nice, W, Jn, AUTOX_NO, 1);\n            break;\n         case EU_NMA:\n            cp = make_num(numa_node_of_cpu(p->processor), W, Jn, AUTOX_NO, 0);\n            break;\n         case EU_NS1:  // IPCNS\n         case EU_NS2:  // MNTNS\n         case EU_NS3:  // NETNS\n         case EU_NS4:  // PIDNS\n         case EU_NS5:  // USERNS\n         case EU_NS6:  // UTSNS\n         {  long ino = p->ns[i - EU_NS1];\n            cp = make_num(ino, W, Jn, i, 1);\n         }\n            break;\n         case EU_OOA:\n            cp = make_num(p->oom_adj, W, Jn, AUTOX_NO, 1);\n            break;\n         case EU_OOM:\n            cp = make_num(p->oom_score, W, Jn, AUTOX_NO, 1);\n            break;\n         case EU_PGD:\n            cp = make_num(p->pgrp, W, Jn, AUTOX_NO, 0);\n            break;\n         case EU_PID:\n            cp = make_num(p->tid, W, Jn, AUTOX_NO, 0);\n            break;\n         case EU_PPD:\n            cp = make_num(p->ppid, W, Jn, AUTOX_NO, 0);\n            break;\n         case EU_PRI:\n            if (-99 > p->priority || 999 < p->priority) {\n               cp = make_str(\"rt\", W, Jn, AUTOX_NO);\n            } else\n               cp = make_num(p->priority, W, Jn, AUTOX_NO, 0);\n            break;\n         case EU_RES:\n            cp = scale_mem(S, pages2K(p->resident), W, Jn);\n            break;\n         case EU_RZA:\n            cp = scale_mem(S, p->vm_rss_anon, W, Jn);\n            break;\n         case EU_RZF:\n            cp = scale_mem(S, p->vm_rss_file, W, Jn);\n            break;\n         case EU_RZL:\n            cp = scale_mem(S, p->vm_lock, W, Jn);\n            break;\n         case EU_RZS:\n            cp = scale_mem(S, p->vm_rss_shared, W, Jn);\n            break;\n         case EU_SGD:\n            makeVAR(p->supgid);\n            break;\n         case EU_SGN:\n            varUTF8(p->supgrp);\n            break;\n         case EU_SHR:\n            cp = scale_mem(S, pages2K(p->share), W, Jn);\n            break;\n         case EU_SID:\n            cp = make_num(p->session, W, Jn, AUTOX_NO, 0);\n            break;\n         case EU_STA:\n            cp = make_chr(p->state, W, Js);\n            break;\n         case EU_SWP:\n            cp = scale_mem(S, p->vm_swap, W, Jn);\n            break;\n         case EU_TGD:\n            cp = make_num(p->tgid, W, Jn, AUTOX_NO, 0);\n            break;\n         case EU_THD:\n            cp = make_num(p->nlwp, W, Jn, AUTOX_NO, 0);\n            break;\n         case EU_TM2:\n         case EU_TME:\n         {  TIC_t t = p->utime + p->stime;\n            if (CHKw(q, Show_CTIMES)) t += (p->cutime + p->cstime);\n            cp = scale_tics(t, W, Jn);\n         }\n            break;\n         case EU_TPG:\n            cp = make_num(p->tpgid, W, Jn, AUTOX_NO, 0);\n            break;\n         case EU_TTY:\n         {  char tmp[SMLBUFSIZ];\n            dev_to_tty(tmp, W, p->tty, p->tid, ABBREV_DEV);\n            cp = make_str(tmp, W, Js, EU_TTY);\n         }\n            break;\n         case EU_UED:\n            cp = make_num(p->euid, W, Jn, EU_UED, 0);\n            break;\n         case EU_UEN:\n            cp = make_str_utf8(p->euser, W, Js, EU_UEN);\n            break;\n         case EU_URD:\n            cp = make_num(p->ruid, W, Jn, EU_URD, 0);\n            break;\n         case EU_URN:\n            cp = make_str_utf8(p->ruser, W, Js, EU_URN);\n            break;\n         case EU_USD:\n            cp = make_num(p->suid, W, Jn, EU_USD, 0);\n            break;\n         case EU_USE:\n            cp = scale_mem(S, (p->vm_swap + p->vm_rss), W, Jn);\n            break;\n         case EU_USN:\n            cp = make_str_utf8(p->suser, W, Js, EU_USN);\n            break;\n         case EU_VRT:\n            cp = scale_mem(S, pages2K(p->size), W, Jn);\n            break;\n         case EU_WCH:\n            cp = make_str(lookup_wchan(p->tid), W, Js, EU_WCH);\n            break;\n         default:                 // keep gcc happy\n            continue;\n\n      } // end: switch 'procflag'\n\n      if (cp) {\n         if (q->osel_tot && !osel_matched(q, i, cp)) return \"\";\n         rp = scat(rp, cp);\n      }\n      #undef S\n      #undef W\n      #undef Js\n      #undef Jn\n   } // end: for 'maxpflgs'\n\n   if (!CHKw(q, INFINDS_xxx)) {\n      const char *cap = ((CHKw(q, Show_HIROWS) && 'R' == p->state))\n         ? q->capclr_rowhigh : q->capclr_rownorm;\n      char *row = rbuf;\n      int ofs;\n      /* since we can't predict what the search string will be and,\n         considering what a single space search request would do to\n         potential buffer needs, when any matches are found we skip\n         normal output routing and send all of the results directly\n         to the terminal (and we sound asthmatic: poof, putt, puff) */\n      if (-1 < (ofs = find_ofs(q, row))) {\n         POOF(\"\\n\", cap);\n         do {\n            row[ofs] = '\\0';\n            PUTT(\"%s%s%s%s\", row, q->capclr_hdr, q->findstr, cap);\n            row += (ofs + q->findlen);\n            ofs = find_ofs(q, row);\n         } while (-1 < ofs);\n         PUTT(\"%s%s\", row, Caps_endline);\n         // with a corrupted rbuf, ensure row is 'counted' by window_show\n         rbuf[0] = '!';\n      } else\n         PUFF(\"\\n%s%s%s\", cap, row, Caps_endline);\n   }\n   return rbuf;\n #undef makeVAR\n #undef varUTF8\n #undef pages2K\n} // end: task_show\n\n\n        /*\n         * Squeeze as many tasks as we can into a single window,\n         * after sorting the passed proc table. */\nstatic int window_show (WIN_t *q, int wmax) {\n /* the isBUSY macro determines if a task is 'active' --\n    it returns true if some cpu was used since the last sample.\n    ( actual 'running' tasks will be a subset of those selected ) */\n #define isBUSY(x)   (0 < (x)->pcpu)\n #define winMIN(a,b) (((a) < (b)) ? (a) : (b))\n   int i, lwin;\n\n   // Display Column Headings -- and distract 'em while we sort (maybe)\n   PUFF(\"\\n%s%s%s\", q->capclr_hdr, q->columnhdr, Caps_endline);\n\n   if (CHKw(q, Show_FOREST))\n      forest_create(q);\n   else {\n      if (CHKw(q, Qsrt_NORMAL)) Frame_srtflg = 1;   // this is always needed!\n      else Frame_srtflg = -1;\n      Frame_ctimes = CHKw(q, Show_CTIMES);          // this & next, only maybe\n      Frame_cmdlin = CHKw(q, Show_CMDLIN);\n      qsort(q->ppt, Frame_maxtask, sizeof(proc_t*), Fieldstab[q->rc.sortindx].sort);\n   }\n\n   i = q->begtask;\n   lwin = 1;                                        // 1 for the column header\n   wmax = winMIN(wmax, q->winlines + 1);            // ditto for winlines, too\n\n   /* the least likely scenario is also the most costly, so we'll try to avoid\n      checking some stuff with each iteration and check it just once... */\n   if (CHKw(q, Show_IDLEPS) && !q->usrseltyp)\n      while (i < Frame_maxtask && lwin < wmax) {\n         if (*task_show(q, q->ppt[i++]))\n            ++lwin;\n      }\n   else\n      while (i < Frame_maxtask && lwin < wmax) {\n         if ((CHKw(q, Show_IDLEPS) || isBUSY(q->ppt[i]))\n         && user_matched(q, q->ppt[i])\n         && *task_show(q, q->ppt[i]))\n            ++lwin;\n         ++i;\n      }\n\n   return lwin;\n #undef winMIN\n #undef isBUSY\n} // end: window_show\n\f\n/*######  Entry point plus two  ##########################################*/\n\n        /*\n         * This guy's just a *Helper* function who apportions the\n         * remaining amount of screen real estate under multiple windows */\nstatic void frame_hlp (int wix, int max) {\n   int i, size, wins;\n\n   // calc remaining number of visible windows\n   for (i = wix, wins = 0; i < GROUPSMAX; i++)\n      if (CHKw(&Winstk[i], Show_TASKON))\n         ++wins;\n\n   if (!wins) wins = 1;\n   // deduct 1 line/window for the columns heading\n   size = (max - wins) / wins;\n\n   /* for subject window, set WIN_t winlines to either the user's\n      maxtask (1st choice) or our 'foxized' size calculation\n      (foxized  adj. -  'fair and balanced') */\n   Winstk[wix].winlines =\n      Winstk[wix].rc.maxtasks ? Winstk[wix].rc.maxtasks : size;\n} // end: frame_hlp\n\n\n        /*\n         * Initiate the Frame Display Update cycle at someone's whim!\n         * This routine doesn't do much, mostly he just calls others.\n         *\n         * (Whoa, wait a minute, we DO caretake those row guys, plus)\n         * (we CALCULATE that IMPORTANT Max_lines thingy so that the)\n         * (*subordinate* functions invoked know WHEN the user's had)\n         * (ENOUGH already.  And at Frame End, it SHOULD be apparent)\n         * (WE am d'MAN -- clearing UNUSED screen LINES and ensuring)\n         * (that those auto-sized columns are addressed, know what I)\n         * (mean?  Huh, \"doesn't DO MUCH\"!  Never, EVER think or say)\n         * (THAT about THIS function again, Ok?  Good that's better.)\n         *\n         * (ps. we ARE the UNEQUALED justification KING of COMMENTS!)\n         * (No, I don't mean significance/relevance, only alignment.)\n         */\nstatic void frame_make (void) {\n   WIN_t *w = Curwin;             // avoid gcc bloat with a local copy\n   int i, scrlins;\n\n   // deal with potential signal(s) since the last time around...\n   if (Frames_signal)\n      zap_fieldstab();\n\n   // whoa either first time or thread/task mode change, (re)prime the pump...\n   if (Pseudo_row == PROC_XTRA) {\n      cpus_refresh();\n      procs_refresh();\n      usleep(LIB_USLEEP);\n      putp(Cap_clr_scr);\n   } else\n      putp(Batch ? \"\\n\\n\" : Cap_home);\n\n   sysinfo_refresh(0);\n   procs_refresh();\n\n   Tree_idx = Pseudo_row = Msg_row = scrlins = 0;\n   summary_show();\n   Max_lines = (Screen_rows - Msg_row) - 1;\n   OFFw(w, INFINDS_xxx);\n\n   /* one way or another, rid us of any prior frame's msg\n      [ now that this is positioned after the call to summary_show(), ]\n      [ we no longer need or employ tg2(0, Msg_row) since all summary ]\n      [ lines end with a newline, and header lines begin with newline ] */\n   if (VIZISw(w) && CHKw(w, View_SCROLL)) PUTT(Scroll_fmts, Frame_maxtask);\n   else putp(Cap_clr_eol);\n\n   if (!Rc.mode_altscr) {\n      // only 1 window to show so, piece o' cake\n      w->winlines = w->rc.maxtasks ? w->rc.maxtasks : Max_lines;\n      scrlins = window_show(w, Max_lines);\n   } else {\n      // maybe NO window is visible but assume, pieces o' cakes\n      for (i = 0 ; i < GROUPSMAX; i++) {\n         if (CHKw(&Winstk[i], Show_TASKON)) {\n            frame_hlp(i, Max_lines - scrlins);\n            scrlins += window_show(&Winstk[i], Max_lines - scrlins);\n         }\n         if (Max_lines <= scrlins) break;\n      }\n   }\n\n   /* clear to end-of-screen - critical if last window is 'idleps off'\n      (main loop must iterate such that we're always called before sleep) */\n   if (scrlins < Max_lines) {\n      putp(Cap_nl_clreos);\n      PSU_CLREOS(Pseudo_row);\n   }\n   fflush(stdout);\n\n   /* we'll deem any terminal not supporting tgoto as dumb and disable\n      the normal non-interactive output optimization... */\n   if (!Cap_can_goto) PSU_CLREOS(0);\n\n   /* lastly, check auto-sized width needs for the next iteration */\n   if (AUTOX_MODE && Autox_found)\n      widths_resize();\n} // end: frame_make\n\n\n        /*\n         * duh... */\nint main (int dont_care_argc, char **argv) {\n   (void)dont_care_argc;\n   before(*argv);\n                                        //                 +-------------+\n   wins_stage_1();                      //                 top (sic) slice\n   configs_reads();                     //                 > spread etc, <\n   parse_args(&argv[1]);                //                 > lean stuff, <\n   whack_terminal();                    //                 > onions etc. <\n   wins_stage_2();                      //                 as bottom slice\n                                        //                 +-------------+\n\n   for (;;) {\n      struct timespec ts;\n\n      frame_make();\n\n      if (0 < Loops) --Loops;\n      if (!Loops) bye_bye(NULL);\n\n      ts.tv_sec = Rc.delay_time;\n      ts.tv_nsec = (Rc.delay_time - (int)Rc.delay_time) * 1000000000;\n\n      if (Batch)\n         pselect(0, NULL, NULL, NULL, &ts, NULL);\n      else {\n         if (ioa(&ts))\n            do_key(iokey(1));\n      }\n           /* note: that above ioa routine exists to consolidate all logic\n                    which is susceptible to signal interrupt and must then\n                    produce a screen refresh. in this main loop frame_make\n                    assumes responsibility for such refreshes. other logic\n                    in contact with users must deal more obliquely with an\n                    interrupt/refresh (hint: Frames_signal + return code)!\n\n                    (everything is perfectly justified plus right margins)\n                    (are completely filled, but of course it must be luck)\n            */\n   }\n   return 0;\n} // end: main\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-procps-3.3.15-7t5vyquf2qqr6grf67vw57m6nxql3tx6/spack-src/lib/strverscmp.c",
        "/tmp/vanessa/spack-stage/spack-stage-procps-3.3.15-7t5vyquf2qqr6grf67vw57m6nxql3tx6/spack-src/.git/objects/pack/pack-3bdbf92a2e78d59cb1fb17ec91ed250f2a754557.idx",
        "/tmp/vanessa/spack-stage/spack-stage-procps-3.3.15-7t5vyquf2qqr6grf67vw57m6nxql3tx6/spack-src/.git/objects/pack/pack-3bdbf92a2e78d59cb1fb17ec91ed250f2a754557.pack",
        "/tmp/vanessa/spack-stage/spack-stage-procps-3.3.15-7t5vyquf2qqr6grf67vw57m6nxql3tx6/spack-src/top/top.h"
    ],
    "total_files": 173
}