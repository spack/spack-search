{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/aclocal.m4": "AC_PREREQ(2.63)\nAC_COPYRIGHT([Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009\nMassachusetts Institute of Technology.\n])\ndnl\ndefine([K5_TOPDIR],[.])dnl\ndnl\nAC_DEFUN(V5_SET_TOPDIR,[dnl\nac_reltopdir=\"K5_TOPDIR\"\nif test ! -r \"$srcdir/K5_TOPDIR/aclocal.m4\"; then\n  AC_MSG_ERROR([Configure could not determine the relative topdir])\nfi\nac_topdir=$srcdir/$ac_reltopdir\nac_config_fragdir=$ac_reltopdir/config\n# echo \"Looking for $srcdir/$ac_config_fragdir\"\nif test -d \"$srcdir/$ac_config_fragdir\"; then\n  AC_CONFIG_AUX_DIR(K5_TOPDIR/config)\nelse\n  AC_MSG_ERROR([can not find config/ directory in $ac_reltopdir])\nfi\n])dnl\ndnl\ndnl Version info.\ndnl\npushdef([x],esyscmd([sed -n 's/#define \\([A-Z0-9_]*\\)[ \\t]*\\(.*\\)/\\1=\\2/p' < ]K5_TOPDIR/patchlevel.h))\ndefine([PL_KRB5_MAJOR_RELEASE],regexp(x,[KRB5_MAJOR_RELEASE=\\(.*\\)],[\\1]))\nifelse(PL_KRB5_MAJOR_RELEASE,,[errprint([Can't determine KRB5_MAJOR_RELEASE value from patchlevel.h.\n]) m4exit(1) dnl sometimes that does not work?\nbuiltin(m4exit,1)])\ndefine([PL_KRB5_MINOR_RELEASE],regexp(x,[KRB5_MINOR_RELEASE=\\(.*\\)],[\\1]))\nifelse(PL_KRB5_MINOR_RELEASE,,[errprint([Can't determine KRB5_MINOR_RELEASE value from patchlevel.h.\n]) m4exit(1) dnl sometimes that does not work?\nbuiltin(m4exit,1)])\ndefine([PL_KRB5_PATCHLEVEL],regexp(x,[KRB5_PATCHLEVEL=\\(.*\\)],[\\1]))\nifelse(PL_KRB5_PATCHLEVEL,,[errprint([Can't determine KRB5_PATCHLEVEL value from patchlevel.h.\n]) m4exit(1) dnl sometimes that does not work?\nbuiltin(m4exit,1)])\ndefine([PL_KRB5_RELTAIL],regexp(x,[KRB5_RELTAIL=\"\\(.*\\)\"],[\\1]))\ndnl RELTAIL is allowed to not be defined.\npopdef([x])\ndefine([K5_VERSION],PL_KRB5_MAJOR_RELEASE.PL_KRB5_MINOR_RELEASE[]ifelse(PL_KRB5_PATCHLEVEL,0,,.PL_KRB5_PATCHLEVEL)ifelse(PL_KRB5_RELTAIL,,,-PL_KRB5_RELTAIL))\ndefine([K5_BUGADDR],krb5-bugs@mit.edu)\ndefine([K5_AC_INIT],[AC_INIT(Kerberos 5, K5_VERSION, K5_BUGADDR, krb5)\nAC_CONFIG_SRCDIR($1)\nbuild_dynobj=no])\ndnl\ndnl drop in standard rules for all configure files -- CONFIG_RULES\ndnl\nAC_DEFUN(CONFIG_RULES,[dnl\nAC_REQUIRE([V5_SET_TOPDIR]) dnl\nEXTRA_FILES=\"\"\nAC_SUBST(EXTRA_FILES)\ndnl Consider using AC_USE_SYSTEM_EXTENSIONS when we require autoconf\ndnl 2.59c or later, but be sure to test on Solaris first.\nAC_DEFINE([_GNU_SOURCE], 1, [Define to enable extensions in glibc])\nAC_DEFINE([__STDC_WANT_LIB_EXT1__], 1, [Define to enable C11 extensions])\n\nWITH_CC dnl\nAC_REQUIRE_CPP\nif test -z \"$LD\" ; then LD=$CC; fi\nAC_ARG_VAR(LD,[linker command [CC]])\nAC_SUBST(LDFLAGS) dnl\nKRB5_AC_CHOOSE_ET dnl\nKRB5_AC_CHOOSE_SS dnl\nKRB5_AC_CHOOSE_DB dnl\ndnl allow stuff in tree to access deprecated stuff for now\ndnl AC_DEFINE([KRB5_DEPRECATED], 1, [Define only if building in-tree])\nAC_C_CONST dnl\nWITH_NETLIB dnl\nWITH_HESIOD dnl\nKRB5_AC_MAINTAINER_MODE dnl\nAC_ARG_PROGRAM dnl\ndnl\ndnl This identifies the top of the source tree relative to the directory \ndnl in which the configure file lives.\ndnl\nCONFIG_RELTOPDIR=$ac_reltopdir\nAC_SUBST(CONFIG_RELTOPDIR)\nlib_frag=$srcdir/$ac_config_fragdir/lib.in\nAC_SUBST_FILE(lib_frag)\nlibobj_frag=$srcdir/$ac_config_fragdir/libobj.in\nAC_SUBST_FILE(libobj_frag)\nlibnover_frag=$srcdir/$ac_config_fragdir/libnover.in\nAC_SUBST_FILE(libnover_frag)\nlibpriv_frag=$srcdir/$ac_config_fragdir/libpriv.in\nAC_SUBST_FILE(libpriv_frag)\nlibnodeps_frag=$srcdir/$ac_config_fragdir/libnodeps.in\nAC_SUBST_FILE(libnodeps_frag)\ndnl\nKRB5_AC_PRAGMA_WEAK_REF\nWITH_LDAP\nKRB5_LIB_PARAMS\nKRB5_AC_INITFINI\nKRB5_AC_ENABLE_THREADS\nKRB5_AC_FIND_DLOPEN\nKRB5_AC_KEYRING_CCACHE\nKRB5_AC_PERSISTENT_KEYRING\n])dnl\n\ndnl Maintainer mode, akin to what automake provides, 'cept we don't\ndnl want to use automake right now.\nAC_DEFUN([KRB5_AC_MAINTAINER_MODE],\n[AC_ARG_ENABLE([maintainer-mode],\nAC_HELP_STRING([--enable-maintainer-mode],[enable rebuilding of source files, Makefiles, etc]),\nUSE_MAINTAINER_MODE=$enableval,\nUSE_MAINTAINER_MODE=no)\nif test \"$USE_MAINTAINER_MODE\" = yes; then\n  MAINTAINER_MODE_TRUE=\n  MAINTAINER_MODE_FALSE='#'\n  AC_MSG_NOTICE(enabling maintainer mode)\nelse\n  MAINTAINER_MODE_TRUE='#'\n  MAINTAINER_MODE_FALSE=\nfi\nMAINT=$MAINTAINER_MODE_TRUE\nAC_SUBST(MAINTAINER_MODE_TRUE)\nAC_SUBST(MAINTAINER_MODE_FALSE)\nAC_SUBST(MAINT)\n])\n\ndnl\nAC_DEFUN([KRB5_AC_INITFINI],[\ndnl Do we want initialization at load time?\nAC_ARG_ENABLE([delayed-initialization],\nAC_HELP_STRING([--disable-delayed-initialization],initialize library code when loaded @<:@delay until first use@:>@), , enable_delayed_initialization=yes)\ncase \"$enable_delayed_initialization\" in\n  yes)\n    AC_DEFINE(DELAY_INITIALIZER,1,[Define if library initialization should be delayed until first use]) ;;\n  no) ;;\n  *)  AC_MSG_ERROR(invalid option $enable_delayed_initialization for delayed-initialization) ;;\nesac\ndnl We always want finalization at unload time.\ndnl\ndnl Can we do things through gcc?\nKRB5_AC_GCC_ATTRS\ndnl How about with the linker?\nif test -z \"$use_linker_init_option\" ; then\n  AC_MSG_ERROR(ran INITFINI before checking shlib.conf?)\nfi\nif test \"$use_linker_init_option\" = yes; then\n  AC_DEFINE(USE_LINKER_INIT_OPTION,1,[Define if link-time options for library initialization will be used])\nfi\nif test \"$use_linker_fini_option\" = yes; then\n  AC_DEFINE(USE_LINKER_FINI_OPTION,1,[Define if link-time options for library finalization will be used])\nfi\n])\n\ndnl find dlopen\nAC_DEFUN([KRB5_AC_FIND_DLOPEN],[\nold_LIBS=\"$LIBS\"\nDL_LIB=\nAC_SEARCH_LIBS(dlopen, dl, [\nif test \"$ac_cv_search_dlopen\" != \"none required\"; then\n  DL_LIB=$ac_cv_search_dlopen\nfi\nLIBS=\"$old_LIBS\"\nAC_DEFINE(USE_DLOPEN,1,[Define if dlopen should be used])])\nAC_SUBST(DL_LIB)\n])\n\n\ndnl Hack for now.\nAC_DEFUN([KRB5_AC_ENABLE_THREADS],[\nAC_ARG_ENABLE([thread-support],\nAC_HELP_STRING([--disable-thread-support],don't enable thread support @<:@enabled@:>@), , enable_thread_support=yes)\nif test \"$enable_thread_support\" = yes ; then\n  AC_MSG_NOTICE(enabling thread support)\n  AC_DEFINE(ENABLE_THREADS,1,[Define if thread support enabled])\nfi\ndnl Maybe this should be inside the conditional above?  Doesn't cache....\nif test \"$enable_thread_support\" = yes; then\n  AX_PTHREAD(,[AC_MSG_ERROR([cannot determine options for enabling thread support; try --disable-thread-support])])\n  AC_MSG_NOTICE(PTHREAD_CC = $PTHREAD_CC)\n  AC_MSG_NOTICE(PTHREAD_CFLAGS = $PTHREAD_CFLAGS)\n  AC_MSG_NOTICE(PTHREAD_LIBS = $PTHREAD_LIBS)\n  dnl Not really needed -- if pthread.h isn't found, ACX_PTHREAD will fail.\n  dnl AC_CHECK_HEADERS(pthread.h)\n  # AIX and Tru64 don't support weak references, and don't have\n  # stub versions of the pthread code in libc.\n  case \"${host_os}\" in\n    aix* | osf*)\n      # On these platforms, we'll always pull in the thread support.\n      LIBS=\"$LIBS $PTHREAD_LIBS\"\n      CFLAGS=\"$CFLAGS $PTHREAD_CFLAGS\"\n      # We don't need to sometimes add the flags we've just folded in...\n      PTHREAD_LIBS=\n      PTHREAD_CFLAGS=\n      ;;\n    hpux*)\n      # These are the flags that \"gcc -pthread\" adds.  But we don't\n      # want \"-pthread\" because that has link-time effects, and we\n      # don't exclude CFLAGS when linking.  *sigh*\n      PTHREAD_CFLAGS=\"-D_REENTRANT -D_THREAD_SAFE -D_POSIX_C_SOURCE=199506L\"\n      ;;\n    solaris2.[[1-9]])\n      # On Solaris 10 with gcc 3.4.3, the autoconf archive macro doesn't\n      # get the right result.   XXX What about Solaris 9 and earlier?\n      if test \"$GCC\" = yes ; then\n        PTHREAD_CFLAGS=\"-D_REENTRANT -pthreads\"\n      fi\n      ;;\n    solaris*)\n      # On Solaris 10 with gcc 3.4.3, the autoconf archive macro doesn't\n      # get the right result.\n      if test \"$GCC\" = yes ; then\n        PTHREAD_CFLAGS=\"-D_REENTRANT -pthreads\"\n      fi\n      # On Solaris 10, the thread support is always available in libc.\n      AC_DEFINE(NO_WEAK_PTHREADS,1,[Define if references to pthread routines should be non-weak.])\n      ;;\n  esac\n  THREAD_SUPPORT=1\nelse\n  PTHREAD_CC=\"$CC\"\n  PTHREAD_CFLAGS=\"\"\n  PTHREAD_LIBS=\"\"\n  THREAD_SUPPORT=0\nfi\nAC_SUBST(THREAD_SUPPORT)\ndnl We want to know where these routines live, so on systems with weak\ndnl reference support we can figure out whether or not the pthread library\ndnl has been linked in.\ndnl If we don't add any libraries for thread support, don't bother.\nAC_CHECK_FUNCS(pthread_once pthread_rwlock_init)\nold_CC=\"$CC\"\ntest \"$PTHREAD_CC\" != \"\" && test \"$ac_cv_c_compiler_gnu\" = no && CC=$PTHREAD_CC\nold_CFLAGS=\"$CFLAGS\"\n# On Solaris, -pthreads is added to CFLAGS, no extra explicit libraries.\nCFLAGS=\"$CFLAGS $PTHREAD_CFLAGS\"\nAC_SUBST(PTHREAD_CFLAGS)\nold_LIBS=\"$LIBS\"\nLIBS=\"$PTHREAD_LIBS $LIBS\"\nAC_MSG_NOTICE(rechecking with PTHREAD_... options)\nAC_CHECK_LIB(c, pthread_rwlock_init,\n  [AC_DEFINE(HAVE_PTHREAD_RWLOCK_INIT_IN_THREAD_LIB,1,[Define if pthread_rwlock_init is provided in the thread library.])])\nLIBS=\"$old_LIBS\"\nCC=\"$old_CC\"\nCFLAGS=\"$old_CFLAGS\"\n])\n\ndnl This is somewhat gross and should go away when the build system\ndnl is revamped. -- tlyu\ndnl DECLARE_SYS_ERRLIST - check for sys_errlist in libc\ndnl\nAC_DEFUN([DECLARE_SYS_ERRLIST],\n[AC_CACHE_CHECK([for sys_errlist declaration], krb5_cv_decl_sys_errlist,\n[AC_TRY_COMPILE([#include <stdio.h>\n#include <errno.h>], [1+sys_nerr;],\nkrb5_cv_decl_sys_errlist=yes, krb5_cv_decl_sys_errlist=no)])\n# assume sys_nerr won't be declared w/o being in libc\nif test $krb5_cv_decl_sys_errlist = yes; then\n  AC_DEFINE(SYS_ERRLIST_DECLARED,1,[Define if sys_errlist is defined in errno.h])\n  AC_DEFINE(HAVE_SYS_ERRLIST,1,[Define if sys_errlist in libc])\nelse\n  # This means that sys_errlist is not declared in errno.h, but may still\n  # be in libc.\n  AC_CACHE_CHECK([for sys_errlist in libc], krb5_cv_var_sys_errlist,\n  [AC_TRY_LINK([extern int sys_nerr;], [if (1+sys_nerr < 0) return 1;],\n  krb5_cv_var_sys_errlist=yes, krb5_cv_var_sys_errlist=no;)])\n  if test $krb5_cv_var_sys_errlist = yes; then\n    AC_DEFINE(HAVE_SYS_ERRLIST,1,[Define if sys_errlist in libc])\n    # Do this cruft for backwards compatibility for now.\n    AC_DEFINE(NEED_SYS_ERRLIST,1,[Define if need to declare sys_errlist])\n  else\n    AC_MSG_WARN([sys_errlist is neither in errno.h nor in libc])\n  fi\nfi])\n\ndnl\ndnl check for sigmask/sigprocmask -- CHECK_SIGPROCMASK\ndnl\nAC_DEFUN(CHECK_SIGPROCMASK,[\nAC_MSG_CHECKING([for use of sigprocmask])\nAC_CACHE_VAL(krb5_cv_func_sigprocmask_use,\n[AC_TRY_LINK([#include <signal.h>], [sigprocmask(SIG_SETMASK,0,0);],\n krb5_cv_func_sigprocmask_use=yes,\nAC_TRY_LINK([#include <signal.h>], [sigmask(1);], \n krb5_cv_func_sigprocmask_use=no, krb5_cv_func_sigprocmask_use=yes))])\nAC_MSG_RESULT($krb5_cv_func_sigprocmask_use)\nif test $krb5_cv_func_sigprocmask_use = yes; then\n AC_DEFINE(USE_SIGPROCMASK,1,[Define if sigprocmask should be used])\nfi\n])dnl\ndnl\nAC_DEFUN(AC_PROG_ARCHIVE, [AC_CHECK_PROG(ARCHIVE, ar, ar cqv, false)])dnl\nAC_DEFUN(AC_PROG_ARCHIVE_ADD, [AC_CHECK_PROG(ARADD, ar, ar cruv, false)])dnl\ndnl\ndnl check for <dirent.h> -- CHECK_DIRENT\ndnl (may need to be more complex later)\ndnl\nAC_DEFUN(CHECK_DIRENT,[\nAC_CHECK_HEADER(dirent.h,AC_DEFINE(USE_DIRENT_H,1,[Define if you have dirent.h functionality]))])dnl\ndnl\ndnl check if union wait is defined, or if WAIT_USES_INT -- CHECK_WAIT_TYPE\ndnl\nAC_DEFUN(CHECK_WAIT_TYPE,[\nAC_MSG_CHECKING([if argument to wait is int *])\nAC_CACHE_VAL(krb5_cv_struct_wait,\ndnl Test for prototype clash - if there is none - then assume int * works\n[AC_TRY_COMPILE([#include <sys/types.h>\n#include <sys/wait.h>\nextern pid_t wait(int *);],[], krb5_cv_struct_wait=no,dnl\ndnl Else fallback on old stuff\n[AC_TRY_COMPILE(\n[#include <sys/wait.h>], [union wait i;\n#ifdef WEXITSTATUS\n  WEXITSTATUS (i);\n#endif\n], \n\tkrb5_cv_struct_wait=yes, krb5_cv_struct_wait=no)])])\nAC_MSG_RESULT($krb5_cv_struct_wait)\nif test $krb5_cv_struct_wait = no; then\n\tAC_DEFINE(WAIT_USES_INT,1,[Define if wait takes int as a argument])\nfi\n])dnl\ndnl\ndnl check for POSIX signal handling -- CHECK_SIGNALS\ndnl\nAC_DEFUN(CHECK_SIGNALS,[\nAC_CHECK_FUNC(sigprocmask,\nAC_MSG_CHECKING(for sigset_t and POSIX_SIGNALS)\nAC_CACHE_VAL(krb5_cv_type_sigset_t,\n[AC_TRY_COMPILE(\n[#include <signal.h>],\n[sigset_t x],\nkrb5_cv_type_sigset_t=yes, krb5_cv_type_sigset_t=no)])\nAC_MSG_RESULT($krb5_cv_type_sigset_t)\nif test $krb5_cv_type_sigset_t = yes; then\n  AC_DEFINE(POSIX_SIGNALS,1,[Define if POSIX signal handling is used])\nfi\n)])dnl\ndnl\ndnl check for signal type\ndnl\ndnl AC_RETSIGTYPE isn't quite right, but almost.\nAC_DEFUN(KRB5_SIGTYPE,[\nAC_MSG_CHECKING([POSIX signal handlers])\nAC_CACHE_VAL(krb5_cv_has_posix_signals,\n[AC_TRY_COMPILE(\n[#include <sys/types.h>\n#include <signal.h>\n#ifdef signal\n#undef signal\n#endif\nextern void (*signal ()) ();], [],\nkrb5_cv_has_posix_signals=yes, krb5_cv_has_posix_signals=no)])\nAC_MSG_RESULT($krb5_cv_has_posix_signals)\nif test $krb5_cv_has_posix_signals = yes; then\n   stype=void\n   AC_DEFINE(POSIX_SIGTYPE, 1, [Define if POSIX signal handlers are used])\nelse\n  if test $ac_cv_type_signal = void; then\n     stype=void\n  else\n     stype=int\n  fi\nfi\nAC_DEFINE_UNQUOTED(krb5_sigtype, $stype, [Define krb5_sigtype to type of signal handler])dnl\n])dnl\ndnl\ndnl check for POSIX setjmp/longjmp -- CHECK_SETJMP\ndnl\nAC_DEFUN(CHECK_SETJMP,[\nAC_CHECK_FUNC(sigsetjmp,\nAC_MSG_CHECKING(for sigjmp_buf)\nAC_CACHE_VAL(krb5_cv_struct_sigjmp_buf,\n[AC_TRY_COMPILE(\n[#include <setjmp.h>],[sigjmp_buf x],\nkrb5_cv_struct_sigjmp_buf=yes,krb5_cv_struct_sigjmp_buf=no)])\nAC_MSG_RESULT($krb5_cv_struct_sigjmp_buf)\nif test $krb5_cv_struct_sigjmp_buf = yes; then\n  AC_DEFINE(POSIX_SETJMP,1,[Define if setjmp indicates POSIX interface])\nfi\n)])dnl\ndnl\ndnl Check for IPv6 compile-time support.\ndnl\nAC_DEFUN(KRB5_AC_INET6,[\nAC_CHECK_HEADERS(sys/types.h sys/socket.h netinet/in.h netdb.h)\nAC_CHECK_FUNCS(inet_ntop inet_pton getnameinfo)\ndnl getaddrinfo test needs netdb.h, for proper compilation on alpha\ndnl under OSF/1^H^H^H^H^HDigital^H^H^H^H^H^H^HTru64 UNIX, where it's\ndnl a macro\nAC_MSG_CHECKING(for getaddrinfo)\nAC_CACHE_VAL(ac_cv_func_getaddrinfo,\n[AC_TRY_LINK([#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif],[\nstruct addrinfo *ai;\ngetaddrinfo(\"kerberos.mit.edu\", \"echo\", 0, &ai);\n], ac_cv_func_getaddrinfo=yes, ac_cv_func_getaddrinfo=no)])\nAC_MSG_RESULT($ac_cv_func_getaddrinfo)\nif test $ac_cv_func_getaddrinfo = yes; then\n  AC_DEFINE(HAVE_GETADDRINFO,1,[Define if you have the getaddrinfo function])\nfi\ndnl\nAC_REQUIRE([KRB5_SOCKADDR_SA_LEN])dnl\nAC_MSG_CHECKING(for IPv6 compile-time support without -DINET6)\nAC_CACHE_VAL(krb5_cv_inet6,[\nif test \"$ac_cv_func_inet_ntop\" != \"yes\" ; then\n  krb5_cv_inet6=no\nelse\nAC_TRY_COMPILE([\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n],[\n  struct sockaddr_in6 in;\n  AF_INET6;\n  IN6_IS_ADDR_LINKLOCAL (&in.sin6_addr);\n],krb5_cv_inet6=yes,krb5_cv_inet6=no)])\nfi\nAC_MSG_RESULT($krb5_cv_inet6)\nif test \"$krb5_cv_inet6\" = no && test \"$ac_cv_func_inet_ntop\" = yes; then\nAC_MSG_CHECKING(for IPv6 compile-time support with -DINET6)\nAC_CACHE_VAL(krb5_cv_inet6_with_dinet6,[\nold_CC=\"$CC\"\nCC=\"$CC -DINET6\"\nAC_TRY_COMPILE([\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n],[\n  struct sockaddr_in6 in;\n  AF_INET6;\n  IN6_IS_ADDR_LINKLOCAL (&in.sin6_addr);\n],krb5_cv_inet6_with_dinet6=yes,krb5_cv_inet6_with_dinet6=no)\nCC=\"$old_CC\"])\nAC_MSG_RESULT($krb5_cv_inet6_with_dinet6)\nfi\nif test $krb5_cv_inet6 = yes || test \"$krb5_cv_inet6_with_dinet6\" = yes; then\n  if test \"$krb5_cv_inet6_with_dinet6\" = yes; then\n    AC_DEFINE(INET6,1,[May need to be defined to enable IPv6 support, for example on IRIX])\n  fi\nfi\n])dnl\ndnl\nAC_DEFUN(KRB5_AC_CHECK_FOR_CFLAGS,[\nAC_BEFORE([$0],[AC_PROG_CC])\nAC_BEFORE([$0],[AC_PROG_CXX])\nkrb5_ac_cflags_set=${CFLAGS+set}\nkrb5_ac_cxxflags_set=${CXXFLAGS+set}\nkrb5_ac_warn_cflags_set=${WARN_CFLAGS+set}\nkrb5_ac_warn_cxxflags_set=${WARN_CXXFLAGS+set}\n])\ndnl\nAC_DEFUN(TRY_WARN_CC_FLAG_1,[dnl\n  cachevar=`echo \"krb5_cv_cc_flag_$1\" | sed -e s/=/_eq_/g -e s/-/_dash_/g -e s/[[^a-zA-Z0-9_]]/_/g`\n  AC_CACHE_CHECK([if C compiler supports $1], [$cachevar],\n  [# first try without, then with\n  AC_TRY_COMPILE([], 1;,\n    [old_cflags=\"$CFLAGS\"\n     CFLAGS=\"$CFLAGS $cflags_warning_test_flags $1\"\n     AC_TRY_COMPILE([], 1;, eval $cachevar=yes, eval $cachevar=no)\n     CFLAGS=\"$old_cflags\"],\n    [AC_MSG_ERROR(compiling simple test program with $CFLAGS failed)])])\n  if eval test '\"${'$cachevar'}\"' = yes; then\n    WARN_CFLAGS=\"$WARN_CFLAGS $1\"\n  fi\n  eval flag_supported='${'$cachevar'}'\n])dnl\ndnl\ndnl Are additional flags needed to make unsupported warning options\ndnl get reported as errors?\nAC_DEFUN(CHECK_CC_WARNING_TEST_FLAGS,[dnl\n  cflags_warning_test_flags=\n  TRY_WARN_CC_FLAG_1(-Werror=unknown-warning-option)\n  if test $flag_supported = yes; then\n    cflags_warning_test_flags=-Werror=unknown-warning-option\n  fi\n])dnl\ndnl\nAC_DEFUN(TRY_WARN_CC_FLAG,[dnl\nAC_REQUIRE([CHECK_CC_WARNING_TEST_FLAGS])dnl\nTRY_WARN_CC_FLAG_1($1)dnl\n])dnl\ndnl\nAC_DEFUN(WITH_CC,[dnl\nAC_REQUIRE([KRB5_AC_CHECK_FOR_CFLAGS])dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_PROG_CXX])dnl\nif test $ac_cv_c_compiler_gnu = yes ; then\n     HAVE_GCC=yes\n     else HAVE_GCC=\nfi\nAC_SUBST(HAVE_GCC)\nAC_CACHE_CHECK([for GNU linker], krb5_cv_prog_gnu_ld,\n[krb5_cv_prog_gnu_ld=no\nif test \"$GCC\" = yes; then\n  if AC_TRY_COMMAND([$CC -Wl,-v 2>&1 dnl\n\t\t\t| grep \"GNU ld\" > /dev/null]); then\n    krb5_cv_prog_gnu_ld=yes\n  fi\nfi])\nAC_ARG_WITH([size-optimizations],\n[  --with-size-optimizations enable a few optimizations to reduce code size\n                          possibly at some run-time cost],\n,\nwithval=no)\nif test \"$withval\" = yes; then\n  AC_DEFINE(CONFIG_SMALL,1,[Define to reduce code size even if it means more cpu usage])\nfi\n# -Wno-long-long, if needed, for k5-platform.h without inttypes.h etc.\nextra_gcc_warn_opts=\"-Wall -Wcast-align -Wshadow\"\n# -Wmissing-prototypes\nif test \"$GCC\" = yes ; then\n  # Putting this here means we get -Os after -O2, which works.\n  if test \"$with_size_optimizations\" = yes && test \"x$krb5_ac_cflags_set\" != xset; then\n    AC_MSG_NOTICE(adding -Os optimization option)\n    case \"$CFLAGS\" in\n      \"-g -O2\") CFLAGS=\"-g -Os\" ;;\n      \"-O2\")    CFLAGS=\"-Os\" ;;\n      *)        CFLAGS=\"$CFLAGS -Os\" ;;\n    esac\n  fi\n  if test \"x$krb5_ac_warn_cflags_set\" = xset ; then\n    AC_MSG_NOTICE(not adding extra gcc warning flags because WARN_CFLAGS was set)\n  else\n    AC_MSG_NOTICE(adding extra warning flags for gcc)\n    WARN_CFLAGS=\"$WARN_CFLAGS $extra_gcc_warn_opts -Wmissing-prototypes\"\n    if test \"`uname -s`\" = Darwin ; then\n      AC_MSG_NOTICE(skipping pedantic warnings on Darwin)\n    elif test \"`uname -s`\" = Linux ; then\n      AC_MSG_NOTICE(skipping pedantic warnings on Linux)\n    else\n      WARN_CFLAGS=\"$WARN_CFLAGS -pedantic\"\n    fi\n    if test \"$ac_cv_cxx_compiler_gnu\" = yes; then\n      if test \"x$krb5_ac_warn_cxxflags_set\" = xset ; then\n        AC_MSG_NOTICE(not adding extra g++ warnings because WARN_CXXFLAGS was set)\n      else\n        AC_MSG_NOTICE(adding extra warning flags for g++)\n        WARN_CXXFLAGS=\"$WARN_CXXFLAGS $extra_gcc_warn_opts\"\n      fi\n    fi\n    # Currently, G++ does not support -Wno-format-zero-length.\n    TRY_WARN_CC_FLAG(-Wno-format-zero-length)\n    # Other flags here may not be supported on some versions of\n    # gcc that people want to use.\n    for flag in overflow strict-overflow missing-format-attribute missing-prototypes return-type missing-braces parentheses switch unused-function unused-label unused-variable unused-value unknown-pragmas sign-compare newline-eof error=uninitialized no-maybe-uninitialized error=pointer-arith error=int-conversion error=incompatible-pointer-types error=discarded-qualifiers error=implicit-int ; do\n      TRY_WARN_CC_FLAG(-W$flag)\n    done\n    #  old-style-definition? generates many, many warnings\n    #\n    # Warnings that we'd like to turn into errors on versions of gcc\n    # that support promoting only specific warnings to errors, but\n    # we'll take as warnings on older compilers.  (If such a warning\n    # is added after the -Werror=foo feature, you can just put\n    # error=foo in the above list, and skip the test for the\n    # warning-only form.)  At least in some versions, -Werror= doesn't\n    # seem to make the conditions actual errors, but still issues\n    # warnings; I guess we'll take what we can get.\n    #\n    # We're currently targeting C89+, not C99, so disallow some\n    # constructs.\n    for flag in declaration-after-statement ; do\n      TRY_WARN_CC_FLAG(-Werror=$flag)\n      if test \"$flag_supported\" = no; then\n        TRY_WARN_CC_FLAG(-W$flag)\n      fi\n    done\n    # We require function declarations now.\n    #\n    # In some compiler versions -- e.g., \"gcc version 4.2.1 (Apple\n    # Inc. build 5664)\" -- the -Werror- option works, but the -Werror=\n    # version doesn't cause implicitly declared functions to be\n    # flagged as errors.  If neither works, -Wall implies\n    # -Wimplicit-function-declaration so don't bother.\n    TRY_WARN_CC_FLAG(-Werror-implicit-function-declaration)\n    if test \"implicit-function-declaration_supported\" = no; then\n      TRY_WARN_CC_FLAG(-Werror=implicit-function-declaration)\n    fi\n    #\n  fi\n  if test \"`uname -s`\" = Darwin ; then\n    # Someday this should be a feature test.\n    # One current (Jaguar = OS 10.2) problem:\n    # Archive library with foo.o undef sym X and bar.o common sym X,\n    # if foo.o is pulled in at link time, bar.o may not be, causing\n    # the linker to complain.\n    # Dynamic library problems too?\n    case \"$CC $CFLAGS\" in\n    *-fcommon*) ;; # why someone would do this, I don't know\n    *-fno-common*) ;; # okay, they're already doing the right thing\n    *)\n      AC_MSG_NOTICE(disabling the use of common storage on Darwin)\n      CFLAGS=\"$CFLAGS -fno-common\"\n      ;;\n    esac\n    case \"$LD $LDFLAGS\" in\n    *-Wl,-search_paths_first*) ;;\n    *) LDFLAGS=\"${LDFLAGS} -Wl,-search_paths_first\" ;;\n    esac\n  fi\nelse\n  if test \"`uname -s`\" = AIX ; then\n    # Using AIX but not GCC, assume native compiler.\n    # The native compiler appears not to give a nonzero exit\n    # status for certain classes of errors, like missing arguments\n    # in function calls.  Let's try to fix that with -qhalt=e.\n    case \"$CC $CFLAGS\" in\n      *-qhalt=*) ;;\n      *)\n\tCFLAGS=\"$CFLAGS -qhalt=e\"\n\tAC_MSG_NOTICE(adding -qhalt=e for better error reporting)\n\t;;\n    esac\n    # Also, the optimizer isn't turned on by default, which means\n    # the static inline functions get left in random object files,\n    # leading to references to pthread_mutex_lock from anything that\n    # includes k5-int.h whether it uses threads or not.\n    case \"$CC $CFLAGS\" in\n      *-O*) ;;\n      *)\n\tCFLAGS=\"$CFLAGS -O\"\n\tAC_MSG_NOTICE(adding -O for inline thread-support function elimination)\n\t;;\n    esac\n  fi\n  if test \"`uname -s`\" = SunOS ; then\n    # Using Solaris but not GCC, assume Sunsoft compiler.\n    # We have some error-out-on-warning options available.\n    # Sunsoft 12 compiler defaults to -xc99=all, it appears, so \"inline\"\n    # works, but it also means that declaration-in-code warnings won't\n    # be issued.\n    # -v -fd -errwarn=E_DECLARATION_IN_CODE ...\n    if test \"x$krb5_ac_warn_cflags_set\" = xset ; then\n      AC_MSG_NOTICE(not adding extra warning flags because WARN_CFLAGS was set)\n    else\n      WARN_CFLAGS=\"-errtags=yes -errwarn=E_BAD_PTR_INT_COMBINATION,E_BAD_PTR_INT_COMB_ARG,E_PTR_TO_VOID_IN_ARITHMETIC,E_NO_IMPLICIT_DECL_ALLOWED,E_ATTRIBUTE_PARAM_UNDEFINED\"\n    fi\n    if test \"x$krb5_ac_warn_cxxflags_set\" = xset ; then\n      AC_MSG_NOTICE(not adding extra warning flags because WARN_CXXFLAGS was set)\n    else\n      WARN_CXXFLAGS=\"-errtags=yes +w +w2 -xport64\"\n    fi\n  fi\nfi\nAC_SUBST(WARN_CFLAGS)\nAC_SUBST(WARN_CXXFLAGS)\n])dnl\ndnl\ndnl\ndnl check for yylineno -- HAVE_YYLINENO\ndnl\nAC_DEFUN(HAVE_YYLINENO,[dnl\nAC_REQUIRE_CPP()AC_REQUIRE([AC_PROG_LEX])dnl\nAC_MSG_CHECKING([for yylineno declaration])\nAC_CACHE_VAL(krb5_cv_type_yylineno,\n# some systems have yylineno, others don't...\n  echo '%%\n%%' | ${LEX} -t > conftest.out\n  if egrep yylineno conftest.out >/dev/null 2>&1; then\n\tkrb5_cv_type_yylineno=yes\n  else\n\tkrb5_cv_type_yylineno=no\n  fi\n  rm -f conftest.out)\n  AC_MSG_RESULT($krb5_cv_type_yylineno)\n  if test $krb5_cv_type_yylineno = no; then\n\tAC_DEFINE(NO_YYLINENO, 1, [Define if lex produes code with yylineno])\n  fi\n])dnl\ndnl\ndnl K5_GEN_MAKEFILE([dir, [frags]])\ndnl\nAC_DEFUN(K5_GEN_MAKEFILE,[dnl\nifelse($1, ,[_K5_GEN_MAKEFILE(.,$2)],[_K5_GEN_MAKEFILE($1,$2)])\n])\ndnl\ndnl _K5_GEN_MAKEFILE(dir, [frags])\ndnl  dir must be present in this case\ndnl  Note: Be careful in quoting. \ndnl        The ac_foreach generates the list of fragments to include\ndnl        or \"\" if $2 is empty\nAC_DEFUN(_K5_GEN_MAKEFILE,[dnl\nAC_CONFIG_FILES([$1/Makefile:$srcdir/]K5_TOPDIR[/config/pre.in:$1/Makefile.in:$1/deps:$srcdir/]K5_TOPDIR[/config/post.in])\n])\ndnl\ndnl K5_GEN_FILE( <ac_output arguments> )\ndnl\nAC_DEFUN(K5_GEN_FILE,[AC_CONFIG_FILES($1)])dnl\ndnl\ndnl K5_AC_OUTPUT\ndnl    Note: Adds the variables to config.status for individual \ndnl          Makefile generation from config.status\nAC_DEFUN(K5_AC_OUTPUT,[AC_OUTPUT])dnl\ndnl\ndnl V5_AC_OUTPUT_MAKEFILE\ndnl\nAC_DEFUN(V5_AC_OUTPUT_MAKEFILE,\n[ifelse($1, , [_V5_AC_OUTPUT_MAKEFILE(.,$2)],[_V5_AC_OUTPUT_MAKEFILE($1,$2)])])\ndnl\ndefine(_V5_AC_OUTPUT_MAKEFILE,\n[ifelse($2, , ,AC_CONFIG_FILES($2))\nAC_FOREACH([DIR], [$1],dnl\n [AC_CONFIG_FILES(DIR[/Makefile:$srcdir/]K5_TOPDIR[/config/pre.in:]DIR[/Makefile.in:]DIR[/deps:$srcdir/]K5_TOPDIR[/config/post.in])])\nK5_AC_OUTPUT])dnl\ndnl\ndnl\ndnl KRB5_SOCKADDR_SA_LEN: define HAVE_SA_LEN if sockaddr contains the sa_len\ndnl component\ndnl\nAC_DEFUN([KRB5_SOCKADDR_SA_LEN],[ dnl\nAC_CHECK_MEMBER(struct sockaddr.sa_len,\n  AC_DEFINE(HAVE_SA_LEN,1,[Define if struct sockaddr contains sa_len])\n,,[#include <sys/types.h>\n#include <sys/socket.h>])])\ndnl\ndnl WITH_NETLIB\ndnl \ndnl\nAC_DEFUN(WITH_NETLIB,[\nAC_ARG_WITH([netlib],\nAC_HELP_STRING([--with-netlib=LIBS], use user defined resolver library),\n[  if test \"$withval\" = yes -o \"$withval\" = no ; then\n\tAC_MSG_RESULT(\"netlib will link with C library resolver only\")\n  else\n\tLIBS=\"$LIBS $withval\"\n\tAC_MSG_RESULT(\"netlib will use \\'$withval\\'\")\n  fi\n],dnl\n[AC_LIBRARY_NET]\n)])dnl\ndnl\ndnl\nAC_DEFUN(KRB5_AC_NEED_DAEMON, [\nKRB5_NEED_PROTO([#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif],daemon,1)])dnl\n\ndnl\ndnl KRB5_AC_NEED_LIBGEN --- check if libgen needs to be linked in for\ndnl \t\t\t\tcompile/step\t\ndnl\ndnl\nAC_DEFUN(KRB5_AC_NEED_LIBGEN,[\nAC_REQUIRE([AC_PROG_CC])dnl\ndnl\ndnl regcomp is present but non-functional on Solaris 2.4\ndnl\nAC_MSG_CHECKING(for working regcomp)\nAC_CACHE_VAL(ac_cv_func_regcomp,[\nAC_TRY_RUN([\n#include <sys/types.h>\n#include <regex.h>\nregex_t x; regmatch_t m;\nint main() { return regcomp(&x,\"pat.*\",0) || regexec(&x,\"pattern\",1,&m,0); }\n], ac_cv_func_regcomp=yes, ac_cv_func_regcomp=no, AC_MSG_ERROR([Cannot test regcomp when cross compiling]))])\nAC_MSG_RESULT($ac_cv_func_regcomp)\ntest $ac_cv_func_regcomp = yes && AC_DEFINE(HAVE_REGCOMP,1,[Define if regcomp exists and functions])\ndnl\ndnl Check for the compile and step functions - only if regcomp is not available\ndnl\nif test $ac_cv_func_regcomp = no; then\n save_LIBS=\"$LIBS\"\n LIBS=-lgen\ndnl this will fail if there's no compile/step in -lgen, or if there's\ndnl no -lgen.  This is fine.\n AC_CHECK_FUNCS(compile step)\n LIBS=\"$save_LIBS\"\ndnl\ndnl Set GEN_LIB if necessary \ndnl\n AC_CHECK_LIB(gen, compile, GEN_LIB=-lgen, GEN_LIB=)\n AC_SUBST(GEN_LIB)\nfi\n])\ndnl\ndnl KRB5_AC_REGEX_FUNCS --- check for different regular expression \ndnl\t\t\t\tsupport functions\ndnl\nAC_DEFUN(KRB5_AC_REGEX_FUNCS,[\nAC_CHECK_FUNCS(re_comp re_exec regexec)\nAC_REQUIRE([KRB5_AC_NEED_LIBGEN])dnl\n])dnl\ndnl\ndnl AC_KRB5_TCL_FIND_CONFIG (uses tcl_dir)\ndnl\nAC_DEFUN(AC_KRB5_TCL_FIND_CONFIG,[\nAC_REQUIRE([KRB5_LIB_AUX])dnl\nAC_MSG_CHECKING(for tclConfig.sh)\ndnl On Debian, we might be given --with-tcl=/usr, or tclsh might\ndnl point us to /usr/lib/tcl8.4; either way, we need to find\ndnl /usr/lib/tcl8.4/tclConfig.sh.\ndnl On NetBSD, we might be given --with-tcl=/usr/pkg, or tclsh\ndnl might point us to /usr/pkg/lib/tcl8.4; we need to find\ndnl /usr/pkg/lib/tclConfig.sh.\nif test -r \"$tcl_dir/lib/tclConfig.sh\" ; then\n  tcl_conf=\"$tcl_dir/lib/tclConfig.sh\"\nelif test -r \"$tcl_dir/tclConfig.sh\" ; then\n  tcl_conf=\"$tcl_dir/tclConfig.sh\"\nelif test -r \"$tcl_dir/../tclConfig.sh\" ; then\n  tcl_conf=\"$tcl_dir/../tclConfig.sh\"\nelse\n  tcl_conf=\n  lib=\"$tcl_dir/lib\"\n  changequote(<<,>>)dnl\n  for d in \"$lib\" \"$lib\"/tcl7.[0-9] \"$lib\"/tcl8.[0-9] ; do\n    if test -r \"$d/tclConfig.sh\" ; then\n      tcl_conf=\"$tcl_conf $d/tclConfig.sh\"\n    fi\n  done\n  changequote([,])dnl\nfi\nif test -n \"$tcl_conf\" ; then\n  AC_MSG_RESULT($tcl_conf)\nelse\n  AC_MSG_RESULT(not found)\nfi\ntcl_ok_conf=\ntcl_vers_maj=\ntcl_vers_min=\nold_CPPFLAGS=$CPPFLAGS\nold_LIBS=$LIBS\nold_LDFLAGS=$LDFLAGS\nif test -n \"$tcl_conf\" ; then\n  for file in $tcl_conf ; do\n    TCL_MAJOR_VERSION=x ; TCL_MINOR_VERSION=x\n    AC_MSG_CHECKING(Tcl info in $file)\n    . $file\n    v=$TCL_MAJOR_VERSION.$TCL_MINOR_VERSION\n    if test -z \"$tcl_vers_maj\" \\\n\t|| test \"$tcl_vers_maj\" -lt \"$TCL_MAJOR_VERSION\" \\\n\t|| test \"$tcl_vers_maj\" = \"$TCL_MAJOR_VERSION\" -a \"$tcl_vers_min\" -lt \"$TCL_MINOR_VERSION\" ; then\n      for incdir in \"$TCL_PREFIX/include/tcl$v\" \"$TCL_PREFIX/include\" ; do\n\tif test -r \"$incdir/tcl.h\" -o -r \"$incdir/tcl/tcl.h\" ; then\n\t  CPPFLAGS=\"$old_CPPFLAGS -I$incdir\"\n\t  break\n\tfi\n      done\n      LIBS=\"$old_LIBS `eval echo x $TCL_LIB_SPEC $TCL_LIBS | sed 's/^x//'`\"\n      LDFLAGS=\"$old_LDFLAGS $TCL_LD_FLAGS\"\n      AC_TRY_LINK( , [Tcl_CreateInterp ();],\n\ttcl_ok_conf=$file\n\ttcl_vers_maj=$TCL_MAJOR_VERSION\n\ttcl_vers_min=$TCL_MINOR_VERSION\n\tAC_MSG_RESULT($v - working),\n\tAC_MSG_RESULT($v - compilation failed)\n      )\n    else\n      AC_MSG_RESULT(older version $v)\n    fi\n  done\nfi\nCPPFLAGS=$old_CPPFLAGS\nLIBS=$old_LIBS\nLDFLAGS=$old_LDFLAGS\ntcl_header=no\ntcl_lib=no\nif test -n \"$tcl_ok_conf\" ; then\n  . $tcl_ok_conf\n  TCL_INCLUDES=\n  for incdir in \"$TCL_PREFIX/include/tcl$v\" \"$TCL_PREFIX/include\" ; do\n    if test -r \"$incdir/tcl.h\" -o -r \"$incdir/tcl/tcl.h\" ; then\n      if test \"$incdir\" != \"/usr/include\" ; then\n        TCL_INCLUDES=-I$incdir\n      fi\n      break\n    fi\n  done\n  # Need eval because the first-level expansion could reference\n  # variables like ${TCL_DBGX}.\n  eval TCL_LIBS='\"'$TCL_LIB_SPEC $TCL_LIBS $TCL_DL_LIBS'\"'\n  TCL_LIBPATH=\"-L$TCL_EXEC_PREFIX/lib\"\n  TCL_RPATH=\":$TCL_EXEC_PREFIX/lib\"\n  if test \"$DEPLIBEXT\" != \"$SHLIBEXT\" && test -n \"$RPATH_FLAG\"; then\n    TCL_MAYBE_RPATH='$(RPATH_FLAG)'\"$TCL_EXEC_PREFIX/lib$RPATH_TAIL\"\n  else\n    TCL_MAYBE_RPATH=\n  fi\n  CPPFLAGS=\"$old_CPPFLAGS $TCL_INCLUDES\"\n  AC_CHECK_HEADER(tcl.h,AC_DEFINE(HAVE_TCL_H,1,[Define if tcl.h is available]) tcl_header=yes)\n  if test $tcl_header=no; then\n     AC_CHECK_HEADER(tcl/tcl.h,AC_DEFINE(HAVE_TCL_TCL_H,1,[Define if tcl/tcl.h is available]) tcl_header=yes)\n  fi\n  CPPFLAGS=\"$old_CPPFLAGS\"\n  tcl_lib=yes\nelse\n  # If we read a tclConfig.sh file, it probably set this.\n  TCL_LIBS=\nfi  \nAC_SUBST(TCL_INCLUDES)\nAC_SUBST(TCL_LIBS)\nAC_SUBST(TCL_LIBPATH)\nAC_SUBST(TCL_RPATH)\nAC_SUBST(TCL_MAYBE_RPATH)\n])dnl\ndnl\ndnl AC_KRB5_TCL_TRYOLD\ndnl attempt to use old search algorithm for locating tcl\ndnl\nAC_DEFUN(AC_KRB5_TCL_TRYOLD, [\nAC_REQUIRE([KRB5_AC_FIND_DLOPEN])\nAC_MSG_WARN([trying old tcl search code])\nif test \"$with_tcl\" != yes -a \"$with_tcl\" != no; then\n\tTCL_INCLUDES=-I$with_tcl/include\n\tTCL_LIBPATH=-L$with_tcl/lib\n\tTCL_RPATH=:$with_tcl/lib\nfi\nif test \"$with_tcl\" != no ; then\n\tkrb5_save_CPPFLAGS=\"$CPPFLAGS\"\n\tkrb5_save_LDFLAGS=\"$LDFLAGS\"\n\tCPPFLAGS=\"$CPPFLAGS $TCL_INCLUDES\"\n\tLDFLAGS=\"$LDFLAGS $TCL_LIBPATH\"\n\ttcl_header=no\n\tAC_CHECK_HEADER(tcl.h,AC_DEFINE(HAVE_TCL_H,1,[Define if tcl.h found]) tcl_header=yes)\n\tif test $tcl_header=no; then\n\t   AC_CHECK_HEADER(tcl/tcl.h,AC_DEFINE(HAVE_TCL_TCL_H,1,[Define if tcl/tcl.h found]) tcl_header=yes)\n\tfi\n\n\tif test $tcl_header = yes ; then\n\t\ttcl_lib=no\n\n\t\tif test $tcl_lib = no; then\n\t\t\tAC_CHECK_LIB(tcl8.0, Tcl_CreateCommand, \n\t\t\t\tTCL_LIBS=\"$TCL_LIBS -ltcl8.0 -lm $DL_LIB $LIBS\"\n\t\t\t\ttcl_lib=yes,,-lm $DL_LIB)\n\t\tfi\n\t\tif test $tcl_lib = no; then\n\t\t\tAC_CHECK_LIB(tcl7.6, Tcl_CreateCommand, \n\t\t\t\tTCL_LIBS=\"$TCL_LIBS -ltcl7.6 -lm $DL_LIB $LIBS\"\n\t\t\t\ttcl_lib=yes,,-lm $DL_LIB)\n\t\tfi\n\t\tif test $tcl_lib = no; then\n\t\t\tAC_CHECK_LIB(tcl7.5, Tcl_CreateCommand, \n\t\t\t\tTCL_LIBS=\"$TCL_LIBS -ltcl7.5 -lm $DL_LIB $LIBS\"\n\t\t\t\ttcl_lib=yes,,-lm $DL_LIB)\n\n\t\tfi\n\t\tif test $tcl_lib = no ; then\n\t\t\tAC_CHECK_LIB(tcl, Tcl_CreateCommand, \n\t\t\t\tTCL_LIBS=\"$TCL_LIBS -ltcl -lm $DL_LIB $LIBS\"\n\t\t\t\ttcl_lib=yes,,-lm $DL_LIB)\n\n\t\tfi\n\t\tif test $tcl_lib = no ; then\t\t\n\t\t\tAC_MSG_WARN(\"tcl.h found but not library\")\n\t\tfi\n\telse\n\t\tAC_MSG_WARN(Could not find Tcl which is needed for the kadm5 tests)\n\t\tTCL_LIBS=\n\tfi\n\tCPPFLAGS=\"$krb5_save_CPPFLAGS\"\n\tLDFLAGS=\"$krb5_save_LDFLAGS\"\n\tAC_SUBST(TCL_INCLUDES)\n\tAC_SUBST(TCL_LIBS)\n\tAC_SUBST(TCL_LIBPATH)\n\tAC_SUBST(TCL_RPATH)\nelse\n\tAC_MSG_RESULT(\"Not looking for Tcl library\")\nfi\n])dnl\ndnl\ndnl AC_KRB5_TCL - determine if the TCL library is present on system\ndnl\nAC_DEFUN(AC_KRB5_TCL,[\nTCL_INCLUDES=\nTCL_LIBPATH=\nTCL_RPATH=\nTCL_LIBS=\nTCL_WITH=\ntcl_dir=\nAC_ARG_WITH(tcl,\n[  --with-tcl=path         where Tcl resides], , with_tcl=try)\nif test \"$with_tcl\" = no ; then\n  true\nelif test \"$with_tcl\" = yes -o \"$with_tcl\" = try ; then\n  tcl_dir=/usr\n  if test ! -r /usr/lib/tclConfig.sh; then\n    cat >> conftest <<\\EOF\nputs \"tcl_dir=$tcl_library\"\nEOF\n    if tclsh conftest >conftest.out 2>/dev/null; then\n      if grep tcl_dir= conftest.out >/dev/null 2>&1; then\n        t=`sed s/tcl_dir=// conftest.out`\n        tcl_dir=$t\n      fi\n    fi # tclsh ran script okay\n  rm -f conftest conftest.out\n  fi # no /usr/lib/tclConfig.sh\nelse\n  tcl_dir=$with_tcl\nfi\nif test \"$with_tcl\" != no ; then\n  AC_KRB5_TCL_FIND_CONFIG\n  if test $tcl_lib = no ; then\n    if test \"$with_tcl\" != try ; then\n      AC_KRB5_TCL_TRYOLD\n    else\n      AC_MSG_WARN(Could not find Tcl which is needed for some tests)\n    fi\n  fi\nfi\n# If \"yes\" or pathname, error out if not found.\nif test \"$with_tcl\" != no -a \"$with_tcl\" != try ; then\n  if test \"$tcl_header $tcl_lib\" != \"yes yes\" ; then\n    AC_MSG_ERROR(Could not find Tcl)\n  fi\nfi\n])dnl\n\ndnl\ndnl WITH_HESIOD\ndnl\nAC_DEFUN(WITH_HESIOD,\n[AC_ARG_WITH(hesiod, AC_HELP_STRING(--with-hesiod[=path], compile with hesiod support @<:@omitted@:>@),\n\thesiod=$with_hesiod, with_hesiod=no)\nif test \"$with_hesiod\" != \"no\"; then\n\tHESIOD_DEFS=-DHESIOD\n\tAC_CHECK_LIB(resolv, res_send, res_lib=-lresolv)\n\tif test \"$hesiod\" != \"yes\"; then\n\t\tHESIOD_LIBS=\"-L${hesiod}/lib -lhesiod $res_lib\"\n\telse\n\t\tHESIOD_LIBS=\"-lhesiod $res_lib\"\n\tfi\nelse\n\tHESIOD_DEFS=\n\tHESIOD_LIBS=\nfi\nAC_SUBST(HESIOD_DEFS)\nAC_SUBST(HESIOD_LIBS)])\n\n\ndnl\ndnl KRB5_BUILD_LIBRARY\ndnl\ndnl Pull in the necessary stuff to create the libraries.\n\nAC_DEFUN(KRB5_BUILD_LIBRARY,\n[AC_REQUIRE([KRB5_LIB_AUX])dnl\nAC_REQUIRE([AC_PROG_LN_S])dnl\nAC_REQUIRE([AC_PROG_RANLIB])dnl\nAC_REQUIRE([AC_PROG_ARCHIVE])dnl\nAC_REQUIRE([AC_PROG_ARCHIVE_ADD])dnl\nAC_REQUIRE([AC_PROG_INSTALL])dnl\nAC_CHECK_PROG(AR, ar, ar, false)\nif test \"$AR\" = \"false\"; then\n  AC_MSG_ERROR([ar not found in PATH])\nfi\nAC_CHECK_PROG(PERL, perl, perl, false)\nif test \"$ac_cv_prog_PERL\" = \"false\"; then\n  AC_MSG_ERROR(Perl is now required for Kerberos builds.)\nfi\nAC_SUBST(LIBLIST)\nAC_SUBST(LIBLINKS)\nAC_SUBST(PLUGIN)\nAC_SUBST(PLUGINLINK)\nAC_SUBST(PLUGININST)\nAC_SUBST(KDB5_PLUGIN_DEPLIBS)\nAC_SUBST(KDB5_PLUGIN_LIBS)\nAC_SUBST(MAKE_SHLIB_COMMAND)\nAC_SUBST(SHLIB_RPATH_FLAGS)\nAC_SUBST(SHLIB_EXPFLAGS)\nAC_SUBST(SHLIB_EXPORT_FILE_DEP)\nAC_SUBST(DYNOBJ_EXPDEPS)\nAC_SUBST(DYNOBJ_EXPFLAGS)\nAC_SUBST(INSTALL_SHLIB)\nAC_SUBST(STLIBEXT)\nAC_SUBST(SHLIBEXT)\nAC_SUBST(SHLIBVEXT)\nAC_SUBST(SHLIBSEXT)\nAC_SUBST(DEPLIBEXT)\nAC_SUBST(PFLIBEXT)\nAC_SUBST(LIBINSTLIST)\nAC_SUBST(DYNOBJEXT)\nAC_SUBST(MAKE_DYNOBJ_COMMAND)\nAC_SUBST(UNDEF_CHECK)\n])\n\ndnl\ndnl KRB5_BUILD_LIBOBJS\ndnl\ndnl Pull in the necessary stuff to build library objects.\n\nAC_DEFUN(KRB5_BUILD_LIBOBJS,\n[AC_REQUIRE([KRB5_LIB_AUX])dnl\nAC_SUBST(OBJLISTS)\nAC_SUBST(STOBJEXT)\nAC_SUBST(SHOBJEXT)\nAC_SUBST(PFOBJEXT)\nAC_SUBST(PICFLAGS)\nAC_SUBST(PROFFLAGS)])\n\ndnl\ndnl KRB5_BUILD_PROGRAM\ndnl\ndnl Set variables to build a program.\n\nAC_DEFUN(KRB5_BUILD_PROGRAM,\n[AC_REQUIRE([KRB5_LIB_AUX])dnl\nAC_REQUIRE([KRB5_AC_NEED_LIBGEN])dnl\nAC_SUBST(CC_LINK)\nAC_SUBST(CXX_LINK)\nAC_SUBST(RPATH_FLAG)\nAC_SUBST(PROG_RPATH_FLAGS)\nAC_SUBST(DEPLIBEXT)])\n\ndnl\ndnl KRB5_RUN_FLAGS\ndnl\ndnl Set up environment for running dynamic executables out of build tree\n\nAC_DEFUN(KRB5_RUN_FLAGS,\n[AC_REQUIRE([KRB5_LIB_AUX])dnl\nKRB5_RUN_ENV=\"$RUN_ENV\"\nKRB5_RUN_VARS=\"$RUN_VARS\"\nAC_SUBST(KRB5_RUN_ENV)\nAC_SUBST(KRB5_RUN_VARS)])\n\ndnl\ndnl KRB5_LIB_AUX\ndnl\ndnl Parse configure options related to library building.\n\nAC_DEFUN(KRB5_LIB_AUX,\n[AC_REQUIRE([KRB5_LIB_PARAMS])dnl\n\nAC_ARG_ENABLE([static],,, [enable_static=no])\nAC_ARG_ENABLE([shared],,, [enable_shared=yes])\n\nif test \"x$enable_static\" = \"x$enable_shared\"; then\n  AC_MSG_ERROR([--enable-static must be specified with --disable-shared])\nfi\n\nAC_ARG_ENABLE([rpath],\nAC_HELP_STRING([--disable-rpath],[suppress run path flags in link lines]),,\n[enable_rpath=yes])\n\nif test \"x$enable_rpath\" != xyes ; then\n\t# Unset the rpath flag values set by shlib.conf\n\tSHLIB_RPATH_FLAGS=\n\tRPATH_FLAG=\n\tPROG_RPATH_FLAGS=\nfi\n\nif test \"$SHLIBEXT\" = \".so-nobuild\"; then\n   AC_MSG_ERROR([Shared libraries are not yet supported on this platform.])\nfi\n\nDEPLIBEXT=$SHLIBEXT\n\nif test \"x$enable_static\" = xyes; then\n\tAC_MSG_NOTICE([using static libraries])\n\tLIBLIST='lib$(LIBBASE)$(STLIBEXT)'\n\tLIBLINKS='$(TOPLIBD)/lib$(LIBBASE)$(STLIBEXT)'\n\tPLUGIN='libkrb5_$(LIBBASE)$(STLIBEXT)'\n\tPLUGINLINK='$(TOPLIBD)/libkrb5_$(LIBBASE)$(STLIBEXT)'\n\tPLUGININST=install-static\n\tOBJLISTS=OBJS.ST\n\tLIBINSTLIST=install-static\n\tDEPLIBEXT=$STLIBEXT\n\tAC_DEFINE([STATIC_PLUGINS], 1, [Define for static plugin linkage])\n\n\tKDB5_PLUGIN_DEPLIBS='$(TOPLIBD)/libkrb5_db2$(DEPLIBEXT)'\n\tKDB5_PLUGIN_LIBS='-lkrb5_db2'\n\tif test \"x$OPENLDAP_PLUGIN\" = xyes; then\n\t\tKDB5_PLUGIN_DEBLIBS=$KDB5_PLUGIN_DEPLIBS' $(TOPLIBD)/libkrb5_ldap$(DEPLIBEXT) $(TOPLIBD)/libkdb_ldap$(DEPLIBEXT)'\n\t\tKDB5_PLUGIN_LIBS=$KDB5_PLUGIN_LIBS' -lkrb5_kldap -lkdb_ldap $(LDAP_LIBS)'\n\tfi\n\t# kadm5srv_mit normally comes before kdb on the link line.  Add it\n\t# again after the KDB plugins, since they depend on it for XDR stuff.\n\tKDB5_PLUGIN_DEPLIBS=$KDB5_PLUGIN_DEPLIBS' $(TOPLIBD)/libkadm5srv_mit$(DEPLIBEXT)'\n\tKDB5_PLUGIN_LIBS=$KDB5_PLUGIN_LIBS' -lkadm5srv_mit'\n\n\t# avoid duplicate rules generation for AIX and such\n\tSHLIBEXT=.so-nobuild\n\tSHLIBVEXT=.so.v-nobuild\n\tSHLIBSEXT=.so.s-nobuild\nelse\n\tAC_MSG_NOTICE([using shared libraries])\n\n\t# Clear some stuff in case of AIX, etc.\n\tif test \"$STLIBEXT\" = \"$SHLIBEXT\" ; then\n\t\tSTLIBEXT=.a-nobuild\n\tfi\n\tcase \"$SHLIBSEXT\" in\n\t.so.s-nobuild)\n\t\tLIBLIST='lib$(LIBBASE)$(SHLIBEXT)'\n\t\tLIBLINKS='$(TOPLIBD)/lib$(LIBBASE)$(SHLIBEXT) $(TOPLIBD)/lib$(LIBBASE)$(SHLIBVEXT)'\n\t\tLIBINSTLIST=\"install-shared\"\n\t\t;;\n\t*)\n\t\tLIBLIST='lib$(LIBBASE)$(SHLIBEXT) lib$(LIBBASE)$(SHLIBSEXT)'\n\t\tLIBLINKS='$(TOPLIBD)/lib$(LIBBASE)$(SHLIBEXT) $(TOPLIBD)/lib$(LIBBASE)$(SHLIBVEXT) $(TOPLIBD)/lib$(LIBBASE)$(SHLIBSEXT)'\n\t\tLIBINSTLIST=\"install-shlib-soname\"\n\t\t;;\n\tesac\n\tOBJLISTS=\"OBJS.SH\"\n\tPLUGIN='$(LIBBASE)$(DYNOBJEXT)'\n\tPLUGINLINK='../$(PLUGIN)'\n\tPLUGININST=install-plugin\n\tKDB5_PLUGIN_DEPLIBS=\n\tKDB5_PLUGIN_LIBS=\nfi\nCC_LINK=\"$CC_LINK_SHARED\"\nCXX_LINK=\"$CXX_LINK_SHARED\"\n\nif test -z \"$LIBLIST\"; then\n\tAC_MSG_ERROR([must enable one of shared or static libraries])\nfi\n\n# Check whether to build profiled libraries.\nAC_ARG_ENABLE([profiled],\ndnl [  --enable-profiled       build profiled libraries @<:@disabled@:>@]\n,\n[if test \"$enableval\" = yes; then\n  AC_MSG_ERROR([Sorry, profiled libraries do not work in this release.])\nfi])])\n\ndnl\ndnl KRB5_LIB_PARAMS\ndnl\ndnl Determine parameters related to libraries, e.g. various extensions.\n\nAC_DEFUN(KRB5_LIB_PARAMS,\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nkrb5_cv_host=$host\nAC_SUBST(krb5_cv_host)\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([V5_SET_TOPDIR])dnl\n. $ac_topdir/config/shlib.conf])\ndnl\ndnl The following was written by jhawk@mit.edu\ndnl\ndnl AC_LIBRARY_NET: Id: net.m4,v 1.4 1997/10/25 20:49:53 jhawk Exp \ndnl\ndnl This test is for network applications that need socket() and\ndnl gethostbyname() -ish functions.  Under Solaris, those applications need to\ndnl link with \"-lsocket -lnsl\".  Under IRIX, they should *not* link with\ndnl \"-lsocket\" because libsocket.a breaks a number of things (for instance:\ndnl gethostbyname() under IRIX 5.2, and snoop sockets under most versions of\ndnl IRIX).\ndnl \ndnl Unfortunately, many application developers are not aware of this, and\ndnl mistakenly write tests that cause -lsocket to be used under IRIX.  It is\ndnl also easy to write tests that cause -lnsl to be used under operating\ndnl systems where neither are necessary (or useful), such as SunOS 4.1.4, which\ndnl uses -lnsl for TLI.\ndnl \ndnl This test exists so that every application developer does not test this in\ndnl a different, and subtly broken fashion.\ndnl \ndnl It has been argued that this test should be broken up into two seperate\ndnl tests, one for the resolver libraries, and one for the libraries necessary\ndnl for using Sockets API. Unfortunately, the two are carefully intertwined and\ndnl allowing the autoconf user to use them independantly potentially results in\ndnl unfortunate ordering dependancies -- as such, such component macros would\ndnl have to carefully use indirection and be aware if the other components were\ndnl executed. Since other autoconf macros do not go to this trouble, and almost\ndnl no applications use sockets without the resolver, this complexity has not\ndnl been implemented.\ndnl\ndnl The check for libresolv is in case you are attempting to link statically\ndnl and happen to have a libresolv.a lying around (and no libnsl.a).\ndnl\nAC_DEFUN(AC_LIBRARY_NET, [\n   # Most operating systems have gethostbyname() in the default searched\n   # libraries (i.e. libc):\n   AC_CHECK_FUNC(gethostbyname, , [\n     # Some OSes (eg. Solaris) place it in libnsl:\n     AC_CHECK_LIB(nsl, gethostbyname, , [\n       # Some strange OSes (SINIX) have it in libsocket:\n       AC_CHECK_LIB(socket, gethostbyname, , [\n          # Unfortunately libsocket sometimes depends on libnsl.\n          # AC_CHECK_LIB's API is essentially broken so the following\n          # ugliness is necessary:\n          AC_CHECK_LIB(socket, gethostbyname,\n             LIBS=\"-lsocket -lnsl $LIBS\",\n               [AC_CHECK_LIB(resolv, gethostbyname,\n\t\t\t     LIBS=\"-lresolv $LIBS\" )],\n             -lnsl)\n       ])\n     ])\n   ])\n  AC_CHECK_FUNC(socket, , AC_CHECK_LIB(socket, socket, ,\n    AC_CHECK_LIB(socket, socket, LIBS=\"-lsocket -lnsl $LIBS\", , -lnsl)))\n  KRB5_AC_ENABLE_DNS\n  if test \"$enable_dns\" = yes ; then\n    # We assume that if libresolv exists we can link against it.\n    # This may get us a gethostby* that doesn't respect nsswitch.\n    AC_CHECK_LIB(resolv, main)\n\n_KRB5_AC_CHECK_RES_FUNCS(res_ninit res_nclose res_ndestroy res_nsearch dnl\nns_initparse ns_name_uncompress dn_skipname res_search)\n    if test $krb5_cv_func_res_nsearch = no \\\n      && test $krb5_cv_func_res_search = no; then\n\t# Attempt to link with res_search(), in case it's not prototyped.\n\tAC_CHECK_FUNC(res_search,\n\t  [AC_DEFINE(HAVE_RES_SEARCH, 1,\n\t    [Define to 1 if you have the `res_search' function])],\n\t  [AC_ERROR([cannot find res_nsearch or res_search])])\n    fi\n  fi\n])\nAC_DEFUN([_KRB5_AC_CHECK_RES_FUNCS],\n[AC_FOREACH([AC_Func], [$1],\n  [AH_TEMPLATE(AS_TR_CPP(HAVE_[]AC_Func),\n               [Define to 1 if you have the `]AC_Func[' function.])])dnl\nfor krb5_func in $1; do\n_KRB5_AC_CHECK_RES_FUNC($krb5_func)\ndone\n])\nAC_DEFUN([_KRB5_AC_CHECK_RES_FUNC], [\n# Solaris 9 prototypes ns_name_uncompress() in arpa/nameser.h, but\n# doesn't export it from libresolv.so, so we use extreme paranoia here\n# and check both for the declaration and that we can link against the\n# function.\nAC_CACHE_CHECK([for $1], [krb5_cv_func_$1], [AC_TRY_LINK(\n[#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/nameser.h>\n@%:@include <resolv.h>],\n[/*\n * Use volatile, or else optimization can cause false positives.\n */\nvoid (* volatile p)() = (void (*)())$1;],\n\t\t\t     [AS_VAR_SET(krb5_cv_func_$1, yes)],\n\t\t\t     [AS_VAR_SET(krb5_cv_func_$1, no)])])\nAS_IF([test AS_VAR_GET(krb5_cv_func_$1) = yes],\n      [AC_DEFINE_UNQUOTED(AS_TR_CPP([HAVE_$1]), 1,\n\t\t\t  [Define to 1 if you have the `$1' function])])[]dnl\n])\ndnl\ndnl\ndnl KRB5_AC_ENABLE_DNS\ndnl\nAC_DEFUN(KRB5_AC_ENABLE_DNS, [\nenable_dns=yes\n  AC_ARG_ENABLE([dns-for-realm],\n[  --enable-dns-for-realm  enable DNS lookups of Kerberos realm names], ,\n[enable_dns_for_realm=no])\n  if test \"$enable_dns_for_realm\" = yes; then\n    AC_DEFINE(KRB5_DNS_LOOKUP_REALM,1,[Define to enable DNS lookups of Kerberos realm names])\n  fi\n\nAC_DEFINE(KRB5_DNS_LOOKUP, 1,[Define for DNS support of locating realms and KDCs])\n\n])\ndnl\ndnl\ndnl Check if we need the prototype for a function - we give it a bogus \ndnl prototype and if it complains - then a valid prototype exists on the \ndnl system.\ndnl\ndnl KRB5_NEED_PROTO(includes, function, [bypass])\ndnl if $3 set, don't see if library defined. \ndnl Useful for case where we will define in libkrb5 the function if need be\ndnl but want to know if a prototype exists in either case on system.\ndnl\nAC_DEFUN([KRB5_NEED_PROTO], [\nifelse([$3], ,[if test \"x$ac_cv_func_$2\" = xyes; then])\nAC_CACHE_CHECK([if $2 needs a prototype provided], krb5_cv_func_$2_noproto,\nAC_TRY_COMPILE([$1],\n[#undef $2\nstruct k5foo {int foo; } xx;\nextern int $2 (struct k5foo*);\n$2(&xx);\n],\nkrb5_cv_func_$2_noproto=yes,krb5_cv_func_$2_noproto=no))\nif test $krb5_cv_func_$2_noproto = yes; then\n\tAC_DEFINE([NEED_]translit($2, [a-z], [A-Z])[_PROTO], 1, dnl\n[define if the system header files are missing prototype for $2()])\nfi\nifelse([$3], ,[fi])\n])\ndnl\ndnl =============================================================\ndnl Internal function for testing for getpeername prototype\ndnl\nAC_DEFUN([KRB5_GETPEERNAME_ARGS],[\nAC_DEFINE([GETPEERNAME_ARG3_TYPE],GETSOCKNAME_ARG3_TYPE,[Type of getpeername second argument.])\n])\ndnl\ndnl =============================================================\ndnl Internal function for testing for getsockname arguments\ndnl\nAC_DEFUN([TRY_GETSOCK_INT],[\nkrb5_lib_var=`echo \"$1 $2\" | sed 'y% ./+-*%___p_p%'`\nAC_MSG_CHECKING([if getsockname() takes arguments $1 and $2])\nAC_CACHE_VAL(krb5_cv_getsockname_proto_$krb5_lib_var,\n[\nAC_TRY_COMPILE([#include <sys/types.h>\n#include <sys/socket.h>\nextern int getsockname(int, $1, $2);\n],,eval \"krb5_cv_getsockname_proto_$krb5_lib_var=yes\",\n    eval \"krb5_cv_getsockname_proto_$krb5_lib_var=no\")])\nif eval \"test \\\"`echo '$krb5_cv_getsockname_proto_'$krb5_lib_var`\\\" = yes\"; then\n\tAC_MSG_RESULT(yes)\n\tsock_set=yes; res1=\"$1\"; res2=\"$2\"\nelse\n\tAC_MSG_RESULT(no)\nfi\n])\ndnl\ndnl Determines the types of the second and third arguments to getsockname().\ndnl\nAC_DEFUN([KRB5_GETSOCKNAME_ARGS],[\nsock_set=no\nfor sock_arg1 in \"struct sockaddr *\" \"void *\"\ndo\n  for sock_arg2 in \"size_t *\" \"int *\" \"socklen_t *\"\n  do\n\tif test $sock_set = no; then\n\t  TRY_GETSOCK_INT($sock_arg1, $sock_arg2)\n\tfi\n  done \ndone\nif test \"$sock_set\" = no; then\n  AC_MSG_NOTICE(assuming struct sockaddr and socklen_t for getsockname args)\n  res1=\"struct sockaddr *\"\n  res2=\"socklen_t *\"\nfi\nres1=`echo \"$res1\" | tr -d '*' | sed -e 's/ *$//'`\nres2=`echo \"$res2\" | tr -d '*' | sed -e 's/ *$//'`\nAC_DEFINE_UNQUOTED([GETSOCKNAME_ARG3_TYPE],$res2,[Type of pointer target for argument 3 to getsockname])\n])\ndnl\ndnl\nAC_DEFUN([KRB5_AC_CHOOSE_ET],[\nAC_ARG_WITH([system-et],\nAC_HELP_STRING(--with-system-et,use system compile_et and -lcom_err @<:@default: build and install a local version@:>@))\nAC_MSG_CHECKING(which version of com_err to use)\nif test \"x$with_system_et\" = xyes ; then\n  # This will be changed to \"intlsys\" if textdomain support is present.\n  COM_ERR_VERSION=sys\n  AC_MSG_RESULT(system)\nelse\n  COM_ERR_VERSION=k5\n  AC_MSG_RESULT(krb5)\nfi\nif test $COM_ERR_VERSION = sys; then\n  # check for various functions we need\n  AC_CHECK_LIB(com_err, add_error_table, :, AC_MSG_ERROR(cannot find add_error_table in com_err library))\n  AC_CHECK_LIB(com_err, remove_error_table, :, AC_MSG_ERROR(cannot find remove_error_table in com_err library))\n  # make sure compile_et provides \"et_foo\" name\n  cat >> conf$$e.et <<EOF\nerror_table foo\nerror_code ERR_FOO, \"foo\"\nend\nEOF\n  AC_CHECK_PROGS(compile_et,compile_et,false)\n  if test \"$compile_et\" = false; then\n    AC_MSG_ERROR(cannot find compile_et)\n  fi\n  AC_CACHE_CHECK(whether compile_et is useful,krb5_cv_compile_et_useful,[\n  if compile_et conf$$e.et >/dev/null 2>&1 ; then true ; else\n    AC_MSG_ERROR(execution failed)\n  fi\n  AC_TRY_COMPILE([#include \"conf$$e.h\"\n      \t\t ],[ &et_foo_error_table; ],:,\n\t\t [AC_MSG_ERROR(cannot use et_foo_error_table)])\n  # Anything else we need to test for?\n  rm -f conf$$e.c conf$$e.h\n  krb5_cv_compile_et_useful=yes\n  ])\n  AC_CACHE_CHECK(whether compile_et supports --textdomain,\n                 krb5_cv_compile_et_textdomain,[\n  krb5_cv_compile_et_textdomain=no\n  if compile_et --textdomain=xyzw conf$$e.et >/dev/null 2>&1 ; then\n    if grep -q xyzw conf$$e.c; then\n      krb5_cv_compile_et_textdomain=yes\n    fi\n  fi\n  rm -f conf$$e.c conf$$e.h\n  ])\n  if test \"$krb5_cv_compile_et_textdomain\" = yes; then\n    COM_ERR_VERSION=intlsys\n  fi\n  rm -f conf$$e.et\nfi\nAC_SUBST(COM_ERR_VERSION)\nif test \"$COM_ERR_VERSION\" = k5 -o \"$COM_ERR_VERSION\" = intlsys; then\n  AC_DEFINE(HAVE_COM_ERR_INTL,1,\n            [Define if com_err has compatible gettext support])\nfi\n])\nAC_DEFUN([KRB5_AC_CHOOSE_SS],[\nAC_ARG_WITH(system-ss,\n\t    AC_HELP_STRING(--with-system-ss,use system -lss and mk_cmds @<:@private version@:>@))\nAC_ARG_VAR(SS_LIB,[system libraries for 'ss' package [-lss]])\nAC_MSG_CHECKING(which version of subsystem package to use)\nif test \"x$with_system_ss\" = xyes ; then\n  SS_VERSION=sys\n  AC_MSG_RESULT(system)\n  # todo: check for various libraries we might need\n  # in the meantime...\n  test \"x${SS_LIB+set}\" = xset || SS_LIB=-lss\n  old_LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $SS_LIB\"\n  AC_CACHE_CHECK(whether system ss package works, krb5_cv_system_ss_okay,[\n  AC_TRY_RUN([\n#include <ss/ss.h>\nint main(int argc, char *argv[]) {\n  if (argc == 42) {\n    int i, err;\n    i = ss_create_invocation(\"foo\",\"foo\",\"\",0,&err);\n    ss_listen(i);\n  }\n  return 0;\n}], krb5_cv_system_ss_okay=yes, AC_MSG_ERROR(cannot run test program),\n  krb5_cv_system_ss_okay=\"assumed\")])\n  LIBS=\"$old_LIBS\"\n  KRB5_NEED_PROTO([#include <ss/ss.h>],ss_execute_command,1)\nelse\n  SS_VERSION=k5\n  AC_MSG_RESULT(krb5)\nfi\nAC_SUBST(SS_LIB)\nAC_SUBST(SS_VERSION)\n])\ndnl\nAC_DEFUN([KRB5_AC_CHOOSE_DB],[\nAC_ARG_WITH(system-db,\n\t    AC_HELP_STRING(--with-system-db,use system Berkeley db @<:@private version@:>@))\nAC_ARG_VAR(DB_HEADER,[header file for system Berkeley db package [db.h]])\nAC_ARG_VAR(DB_LIB,[library for system Berkeley db package [-ldb]])\nif test \"x$with_system_db\" = xyes ; then\n  DB_VERSION=sys\n  # TODO: Do we have specific routines we should check for?\n  # How about known, easily recognizable bugs?\n  # We want to use bt_rseq in some cases, but no other version but\n  # ours has it right now.\n  #\n  # Okay, check the variables.\n  test \"x${DB_HEADER+set}\" = xset || DB_HEADER=db.h\n  test \"x${DB_LIB+set}\" = xset || DB_LIB=-ldb\n  #\n  if test \"x${DB_HEADER}\" = xdb.h ; then\n    DB_HEADER_VERSION=sys\n  else\n    DB_HEADER_VERSION=redirect\n  fi\n  KDB5_DB_LIB=\"$DB_LIB\"\nelse\n  DB_VERSION=k5\n  AC_DEFINE(HAVE_BT_RSEQ,1,[Define if bt_rseq is available, for recursive btree traversal.])\n  DB_HEADER=db.h\n  DB_HEADER_VERSION=k5\n  # libdb gets sucked into libkdb\n  KDB5_DB_LIB=\n  # needed for a couple of things that need libdb for its own sake\n  DB_LIB=-ldb\nfi\nAC_SUBST(DB_VERSION)\nAC_SUBST(DB_HEADER)\nAC_SUBST(DB_HEADER_VERSION)\nAC_SUBST(DB_LIB)\nAC_SUBST(KDB5_DB_LIB)\n])\ndnl\ndnl KRB5_AC_PRIOCNTL_HACK\ndnl\ndnl\nAC_DEFUN([KRB5_AC_PRIOCNTL_HACK],\n[AC_REQUIRE([AC_PROG_AWK])dnl\nAC_REQUIRE([AC_LANG_COMPILER_REQUIRE])dnl\nAC_CACHE_CHECK([whether to use priocntl hack], [krb5_cv_priocntl_hack],\n[case $krb5_cv_host in\n*-*-solaris2.9*)\n\tif test \"$cross_compiling\" = yes; then\n\t\tkrb5_cv_priocntl_hack=yes\n\telse\n\t\t# Solaris patch 117171-11 (sparc) or 117172-11 (x86)\n\t\t# fixes the Solaris 9 bug where final pty output\n\t\t# gets lost on close.\n\t\tif showrev -p | $AWK 'BEGIN { e = 1 }\n/Patch: 11717[[12]]/ { x = index[]([$]2, \"-\");\nif (substr[]([$]2, x + 1, length([$]2) - x) >= 11)\n{ e = 0 } else { e = 1 } }\nEND { exit e; }'; then\n\t\t\tkrb5_cv_priocntl_hack=no\n\t\telse\n\t\t\tkrb5_cv_priocntl_hack=yes\n\t\tfi\n\tfi\n\t;;\n*)\n\tkrb5_cv_priocntl_hack=no\n\t;;\nesac])\nif test \"$krb5_cv_priocntl_hack\" = yes; then\n\tPRIOCNTL_HACK=1\nelse\n\tPRIOCNTL_HACK=0\nfi\nAC_SUBST(PRIOCNTL_HACK)])\ndnl\ndnl\ndnl KRB5_AC_GCC_ATTRS\nAC_DEFUN([KRB5_AC_GCC_ATTRS],\n[AC_CACHE_CHECK([for constructor/destructor attribute support],krb5_cv_attr_constructor_destructor,\n[rm -f conftest.1 conftest.2\nif test -r conftest.1 || test -r conftest.2 ; then\n  AC_MSG_ERROR(write error in local file system?)\nfi\ntrue > conftest.1\ntrue > conftest.2\nif test -r conftest.1 && test -r conftest.2 ; then true ; else\n  AC_MSG_ERROR(write error in local file system?)\nfi\na=no\nb=no\n# blindly assume we have 'unlink'...\nAC_TRY_RUN([void foo1() __attribute__((constructor));\nvoid foo1() { unlink(\"conftest.1\"); }\nvoid foo2() __attribute__((destructor));\nvoid foo2() { unlink(\"conftest.2\"); }\nint main () { return 0; }],\n[test -r conftest.1 || a=yes\ntest -r conftest.2 || b=yes], , AC_MSG_ERROR(Cannot test for constructor/destructor support when cross compiling))\ncase $krb5_cv_host in\n*-*-aix4.*)\n\t# Under AIX 4.3.3, at least, shared library destructor functions\n\t# appear to get executed in reverse link order (right to left),\n\t# so that a library's destructor function may run after that of\n\t# libraries it depends on, and may still have to access in the\n\t# destructor.\n\t#\n\t# That counts as \"not working\", for me, but it's a much more\n\t# complicated test case to set up.\n\tb=no\n\t;;\nesac\nkrb5_cv_attr_constructor_destructor=\"$a,$b\"\n])\n# Okay, krb5_cv_... should be set now.\ncase $krb5_cv_attr_constructor_destructor in\n  yes,*)\n    AC_DEFINE(CONSTRUCTOR_ATTR_WORKS,1,[Define if __attribute__((constructor)) works]) ;;\nesac\ncase $krb5_cv_attr_constructor_destructor in\n  *,yes)\n    AC_DEFINE(DESTRUCTOR_ATTR_WORKS,1,[Define if __attribute__((destructor)) works]) ;;\nesac\ndnl End of attributes we care about right now.\n])\ndnl\ndnl\ndnl KRB5_AC_PRAGMA_WEAK_REF\nAC_DEFUN([KRB5_AC_PRAGMA_WEAK_REF],\n[AC_CACHE_CHECK([whether pragma weak references are supported],\nkrb5_cv_pragma_weak_ref,\n[AC_TRY_LINK([#pragma weak flurbl\nextern int flurbl(void);],[if (&flurbl != 0) return flurbl();],\nkrb5_cv_pragma_weak_ref=yes,krb5_cv_pragma_weak_ref=no)])\nif test $krb5_cv_pragma_weak_ref = yes ; then\n  AC_DEFINE(HAVE_PRAGMA_WEAK_REF,1,[Define if #pragma weak references work])\nfi])\ndnl\ndnl\nm4_include(config/ac-archive/ax_pthread.m4)\nm4_include(config/ac-archive/ax_recursive_eval.m4)\nm4_include(config/pkg.m4)\ndnl\ndnl\ndnl\ndnl --with-ldap=value\ndnl\nAC_DEFUN(WITH_LDAP,[\nAC_ARG_WITH([ldap],\n[  --with-ldap             compile OpenLDAP database backend module],\n[case \"$withval\" in\n    OPENLDAP) with_ldap=yes ;;\n    yes | no) ;;\n    *)  AC_MSG_ERROR(Invalid option value --with-ldap=\"$withval\") ;;\nesac], with_ldap=no)dnl\n\nif test \"$with_ldap\" = yes; then\n  AC_MSG_NOTICE(enabling OpenLDAP database backend module support)\n  OPENLDAP_PLUGIN=yes\nfi\n])dnl\ndnl\ndnl If libkeyutils exists (on Linux) include it and use keyring ccache\nAC_DEFUN(KRB5_AC_KEYRING_CCACHE,[\n  AC_CHECK_HEADERS([keyutils.h],\n    AC_CHECK_LIB(keyutils, add_key, \n      [dnl Pre-reqs were found\n       AC_DEFINE(USE_KEYRING_CCACHE, 1, [Define if the keyring ccache should be enabled])\n       LIBS=\"-lkeyutils $LIBS\"\n      ]))\n])dnl\ndnl\ndnl If libkeyutils supports persistent keyrings, use them\nAC_DEFUN(KRB5_AC_PERSISTENT_KEYRING,[\n  AC_CHECK_HEADERS([keyutils.h],\n    AC_CHECK_LIB(keyutils, keyctl_get_persistent,\n      [AC_DEFINE(HAVE_PERSISTENT_KEYRING, 1,\n                 [Define if persistent keyrings are supported])\n      ]))\n])dnl\ndnl\n",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/include/autoconf.h.in": "/* include/autoconf.h.in.  Generated from configure.in by autoheader.  */\n\n\n#ifndef KRB5_AUTOCONF_H\n#define KRB5_AUTOCONF_H\n\n\n/* Define if AES-NI support is enabled */\n#undef AESNI\n\n/* Define if socket can't be bound to 0.0.0.0 */\n#undef BROKEN_STREAMS_SOCKETS\n\n/* Define if va_list objects can be simply copied by assignment. */\n#undef CAN_COPY_VA_LIST\n\n/* Define to reduce code size even if it means more cpu usage */\n#undef CONFIG_SMALL\n\n/* Define if __attribute__((constructor)) works */\n#undef CONSTRUCTOR_ATTR_WORKS\n\n/* Define to default ccache name */\n#undef DEFCCNAME\n\n/* Define to default client keytab name */\n#undef DEFCKTNAME\n\n/* Define to default keytab name */\n#undef DEFKTNAME\n\n/* Define if library initialization should be delayed until first use */\n#undef DELAY_INITIALIZER\n\n/* Define if __attribute__((destructor)) works */\n#undef DESTRUCTOR_ATTR_WORKS\n\n/* Define to disable PKINIT plugin support */\n#undef DISABLE_PKINIT\n\n/* Define if LDAP KDB support within the Kerberos library (mainly ASN.1 code)\n   should be enabled. */\n#undef ENABLE_LDAP\n\n/* Define if translation functions should be used. */\n#undef ENABLE_NLS\n\n/* Define if thread support enabled */\n#undef ENABLE_THREADS\n\n/* Define as return type of endrpcent */\n#undef ENDRPCENT_TYPE\n\n/* Define if Fortuna PRNG is selected */\n#undef FORTUNA\n\n/* Define to the type of elements in the array set by `getgroups'. Usually\n   this is either `int' or `gid_t'. */\n#undef GETGROUPS_T\n\n/* Define if gethostbyname_r returns int rather than struct hostent * */\n#undef GETHOSTBYNAME_R_RETURNS_INT\n\n/* Type of getpeername second argument. */\n#undef GETPEERNAME_ARG3_TYPE\n\n/* Define if getpwnam_r exists but takes only 4 arguments (e.g., POSIX draft 6\n   implementations like some Solaris releases). */\n#undef GETPWNAM_R_4_ARGS\n\n/* Define if getpwnam_r returns an int */\n#undef GETPWNAM_R_RETURNS_INT\n\n/* Define if getpwuid_r exists but takes only 4 arguments (e.g., POSIX draft 6\n   implementations like some Solaris releases). */\n#undef GETPWUID_R_4_ARGS\n\n/* Define if getservbyname_r returns int rather than struct servent * */\n#undef GETSERVBYNAME_R_RETURNS_INT\n\n/* Type of pointer target for argument 3 to getsockname */\n#undef GETSOCKNAME_ARG3_TYPE\n\n/* Define if gmtime_r returns int instead of struct tm pointer, as on old\n   HP-UX systems. */\n#undef GMTIME_R_RETURNS_INT\n\n/* Define if va_copy macro or function is available. */\n#undef HAS_VA_COPY\n\n/* Define to 1 if you have the `access' function. */\n#undef HAVE_ACCESS\n\n/* Define to 1 if you have the <alloca.h> header file. */\n#undef HAVE_ALLOCA_H\n\n/* Define to 1 if you have the <arpa/inet.h> header file. */\n#undef HAVE_ARPA_INET_H\n\n/* Define to 1 if you have the `bswap16' function. */\n#undef HAVE_BSWAP16\n\n/* Define to 1 if you have the `bswap64' function. */\n#undef HAVE_BSWAP64\n\n/* Define to 1 if bswap_16 is available via byteswap.h */\n#undef HAVE_BSWAP_16\n\n/* Define to 1 if bswap_64 is available via byteswap.h */\n#undef HAVE_BSWAP_64\n\n/* Define if bt_rseq is available, for recursive btree traversal. */\n#undef HAVE_BT_RSEQ\n\n/* Define to 1 if you have the <byteswap.h> header file. */\n#undef HAVE_BYTESWAP_H\n\n/* Define to 1 if you have the `chmod' function. */\n#undef HAVE_CHMOD\n\n/* Define if cmocka library is available. */\n#undef HAVE_CMOCKA\n\n/* Define to 1 if you have the `compile' function. */\n#undef HAVE_COMPILE\n\n/* Define if com_err has compatible gettext support */\n#undef HAVE_COM_ERR_INTL\n\n/* Define to 1 if you have the <cpuid.h> header file. */\n#undef HAVE_CPUID_H\n\n/* Define to 1 if you have the `daemon' function. */\n#undef HAVE_DAEMON\n\n/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you\n   don't. */\n#undef HAVE_DECL_STRERROR_R\n\n/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.\n   */\n#undef HAVE_DIRENT_H\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#undef HAVE_DLFCN_H\n\n/* Define to 1 if you have the `dn_skipname' function. */\n#undef HAVE_DN_SKIPNAME\n\n/* Define to 1 if you have the <endian.h> header file. */\n#undef HAVE_ENDIAN_H\n\n/* Define to 1 if you have the <errno.h> header file. */\n#undef HAVE_ERRNO_H\n\n/* Define to 1 if you have the `fchmod' function. */\n#undef HAVE_FCHMOD\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n#undef HAVE_FCNTL_H\n\n/* Define to 1 if you have the `flock' function. */\n#undef HAVE_FLOCK\n\n/* Define to 1 if you have the `fnmatch' function. */\n#undef HAVE_FNMATCH\n\n/* Define to 1 if you have the <fnmatch.h> header file. */\n#undef HAVE_FNMATCH_H\n\n/* Define if you have the getaddrinfo function */\n#undef HAVE_GETADDRINFO\n\n/* Define to 1 if you have the `getcwd' function. */\n#undef HAVE_GETCWD\n\n/* Define to 1 if you have the `getenv' function. */\n#undef HAVE_GETENV\n\n/* Define to 1 if you have the `geteuid' function. */\n#undef HAVE_GETEUID\n\n/* Define if gethostbyname_r exists and its return type is known */\n#undef HAVE_GETHOSTBYNAME_R\n\n/* Define to 1 if you have the `getnameinfo' function. */\n#undef HAVE_GETNAMEINFO\n\n/* Define if system getopt should be used. */\n#undef HAVE_GETOPT\n\n/* Define if system getopt_long should be used. */\n#undef HAVE_GETOPT_LONG\n\n/* Define if getpwnam_r is available and useful. */\n#undef HAVE_GETPWNAM_R\n\n/* Define if getpwuid_r is available and useful. */\n#undef HAVE_GETPWUID_R\n\n/* Define if getservbyname_r exists and its return type is known */\n#undef HAVE_GETSERVBYNAME_R\n\n/* Have the gettimeofday function */\n#undef HAVE_GETTIMEOFDAY\n\n/* Define to 1 if you have the `getusershell' function. */\n#undef HAVE_GETUSERSHELL\n\n/* Define to 1 if you have the `gmtime_r' function. */\n#undef HAVE_GMTIME_R\n\n/* Define to 1 if you have the <ifaddrs.h> header file. */\n#undef HAVE_IFADDRS_H\n\n/* Define to 1 if you have the `inet_ntop' function. */\n#undef HAVE_INET_NTOP\n\n/* Define to 1 if you have the `inet_pton' function. */\n#undef HAVE_INET_PTON\n\n/* Define to 1 if the system has the type `int16_t'. */\n#undef HAVE_INT16_T\n\n/* Define to 1 if the system has the type `int32_t'. */\n#undef HAVE_INT32_T\n\n/* Define to 1 if the system has the type `int8_t'. */\n#undef HAVE_INT8_T\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#undef HAVE_INTTYPES_H\n\n/* Define to 1 if you have the <keyutils.h> header file. */\n#undef HAVE_KEYUTILS_H\n\n/* Define to 1 if you have the <lber.h> header file. */\n#undef HAVE_LBER_H\n\n/* Define to 1 if you have the <ldap.h> header file. */\n#undef HAVE_LDAP_H\n\n/* Define to 1 if you have the `crypto' library (-lcrypto). */\n#undef HAVE_LIBCRYPTO\n\n/* Define if building with libedit. */\n#undef HAVE_LIBEDIT\n\n/* Define to 1 if you have the `nsl' library (-lnsl). */\n#undef HAVE_LIBNSL\n\n/* Define to 1 if you have the `resolv' library (-lresolv). */\n#undef HAVE_LIBRESOLV\n\n/* Define to 1 if you have the `socket' library (-lsocket). */\n#undef HAVE_LIBSOCKET\n\n/* Define if the util library is available */\n#undef HAVE_LIBUTIL\n\n/* Define to 1 if you have the <limits.h> header file. */\n#undef HAVE_LIMITS_H\n\n/* Define to 1 if you have the `localtime_r' function. */\n#undef HAVE_LOCALTIME_R\n\n/* Define to 1 if you have the <machine/byte_order.h> header file. */\n#undef HAVE_MACHINE_BYTE_ORDER_H\n\n/* Define to 1 if you have the <machine/endian.h> header file. */\n#undef HAVE_MACHINE_ENDIAN_H\n\n/* Define to 1 if you have the <memory.h> header file. */\n#undef HAVE_MEMORY_H\n\n/* Define to 1 if you have the `mkstemp' function. */\n#undef HAVE_MKSTEMP\n\n/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */\n#undef HAVE_NDIR_H\n\n/* Define to 1 if you have the <netdb.h> header file. */\n#undef HAVE_NETDB_H\n\n/* Define if netdb.h declares h_errno */\n#undef HAVE_NETDB_H_H_ERRNO\n\n/* Define to 1 if you have the <netinet/in.h> header file. */\n#undef HAVE_NETINET_IN_H\n\n/* Define to 1 if you have the `ns_initparse' function. */\n#undef HAVE_NS_INITPARSE\n\n/* Define to 1 if you have the `ns_name_uncompress' function. */\n#undef HAVE_NS_NAME_UNCOMPRESS\n\n/* Define if OpenSSL supports cms. */\n#undef HAVE_OPENSSL_CMS\n\n/* Define to 1 if you have the <paths.h> header file. */\n#undef HAVE_PATHS_H\n\n/* Define if persistent keyrings are supported */\n#undef HAVE_PERSISTENT_KEYRING\n\n/* Define to 1 if you have the <poll.h> header file. */\n#undef HAVE_POLL_H\n\n/* Define if #pragma weak references work */\n#undef HAVE_PRAGMA_WEAK_REF\n\n/* Define if you have POSIX threads libraries and header files. */\n#undef HAVE_PTHREAD\n\n/* Define to 1 if you have the `pthread_once' function. */\n#undef HAVE_PTHREAD_ONCE\n\n/* Have PTHREAD_PRIO_INHERIT. */\n#undef HAVE_PTHREAD_PRIO_INHERIT\n\n/* Define to 1 if you have the `pthread_rwlock_init' function. */\n#undef HAVE_PTHREAD_RWLOCK_INIT\n\n/* Define if pthread_rwlock_init is provided in the thread library. */\n#undef HAVE_PTHREAD_RWLOCK_INIT_IN_THREAD_LIB\n\n/* Define to 1 if you have the <pwd.h> header file. */\n#undef HAVE_PWD_H\n\n/* Define if building with GNU Readline. */\n#undef HAVE_READLINE\n\n/* Define if regcomp exists and functions */\n#undef HAVE_REGCOMP\n\n/* Define to 1 if you have the `regexec' function. */\n#undef HAVE_REGEXEC\n\n/* Define to 1 if you have the <regexpr.h> header file. */\n#undef HAVE_REGEXPR_H\n\n/* Define to 1 if you have the <regex.h> header file. */\n#undef HAVE_REGEX_H\n\n/* Define to 1 if you have the `res_nclose' function. */\n#undef HAVE_RES_NCLOSE\n\n/* Define to 1 if you have the `res_ndestroy' function. */\n#undef HAVE_RES_NDESTROY\n\n/* Define to 1 if you have the `res_ninit' function. */\n#undef HAVE_RES_NINIT\n\n/* Define to 1 if you have the `res_nsearch' function. */\n#undef HAVE_RES_NSEARCH\n\n/* Define to 1 if you have the `res_search' function */\n#undef HAVE_RES_SEARCH\n\n/* Define to 1 if you have the `re_comp' function. */\n#undef HAVE_RE_COMP\n\n/* Define to 1 if you have the `re_exec' function. */\n#undef HAVE_RE_EXEC\n\n/* Define to 1 if you have the <sasl/sasl.h> header file. */\n#undef HAVE_SASL_SASL_H\n\n/* Define if struct sockaddr contains sa_len */\n#undef HAVE_SA_LEN\n\n/* Define to 1 if you have the `setegid' function. */\n#undef HAVE_SETEGID\n\n/* Define to 1 if you have the `setenv' function. */\n#undef HAVE_SETENV\n\n/* Define to 1 if you have the `seteuid' function. */\n#undef HAVE_SETEUID\n\n/* Define if setluid provided in OSF/1 security library */\n#undef HAVE_SETLUID\n\n/* Define to 1 if you have the `setregid' function. */\n#undef HAVE_SETREGID\n\n/* Define to 1 if you have the `setresgid' function. */\n#undef HAVE_SETRESGID\n\n/* Define to 1 if you have the `setresuid' function. */\n#undef HAVE_SETRESUID\n\n/* Define to 1 if you have the `setreuid' function. */\n#undef HAVE_SETREUID\n\n/* Define to 1 if you have the `setsid' function. */\n#undef HAVE_SETSID\n\n/* Define to 1 if you have the `setvbuf' function. */\n#undef HAVE_SETVBUF\n\n/* Define if there is a socklen_t type. If not, probably use size_t */\n#undef HAVE_SOCKLEN_T\n\n/* Define to 1 if you have the `srand' function. */\n#undef HAVE_SRAND\n\n/* Define to 1 if you have the `srand48' function. */\n#undef HAVE_SRAND48\n\n/* Define to 1 if you have the `srandom' function. */\n#undef HAVE_SRANDOM\n\n/* Define to 1 if the system has the type `ssize_t'. */\n#undef HAVE_SSIZE_T\n\n/* Define to 1 if you have the `stat' function. */\n#undef HAVE_STAT\n\n/* Define to 1 if you have the <stddef.h> header file. */\n#undef HAVE_STDDEF_H\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#undef HAVE_STDINT_H\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#undef HAVE_STDLIB_H\n\n/* Define to 1 if you have the `step' function. */\n#undef HAVE_STEP\n\n/* Define to 1 if you have the `strchr' function. */\n#undef HAVE_STRCHR\n\n/* Define to 1 if you have the `strdup' function. */\n#undef HAVE_STRDUP\n\n/* Define to 1 if you have the `strerror' function. */\n#undef HAVE_STRERROR\n\n/* Define to 1 if you have the `strerror_r' function. */\n#undef HAVE_STRERROR_R\n\n/* Define to 1 if you have the <strings.h> header file. */\n#undef HAVE_STRINGS_H\n\n/* Define to 1 if you have the <string.h> header file. */\n#undef HAVE_STRING_H\n\n/* Define to 1 if you have the `strlcpy' function. */\n#undef HAVE_STRLCPY\n\n/* Define to 1 if you have the `strptime' function. */\n#undef HAVE_STRPTIME\n\n/* Define to 1 if the system has the type `struct cmsghdr'. */\n#undef HAVE_STRUCT_CMSGHDR\n\n/* Define if there is a struct if_laddrconf. */\n#undef HAVE_STRUCT_IF_LADDRCONF\n\n/* Define to 1 if the system has the type `struct in6_pktinfo'. */\n#undef HAVE_STRUCT_IN6_PKTINFO\n\n/* Define to 1 if the system has the type `struct in_pktinfo'. */\n#undef HAVE_STRUCT_IN_PKTINFO\n\n/* Define if there is a struct lifconf. */\n#undef HAVE_STRUCT_LIFCONF\n\n/* Define to 1 if the system has the type `struct rt_msghdr'. */\n#undef HAVE_STRUCT_RT_MSGHDR\n\n/* Define to 1 if the system has the type `struct sockaddr_storage'. */\n#undef HAVE_STRUCT_SOCKADDR_STORAGE\n\n/* Define to 1 if `st_mtimensec' is a member of `struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_MTIMENSEC\n\n/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC\n\n/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC\n\n/* Define to 1 if you have the <sys/bswap.h> header file. */\n#undef HAVE_SYS_BSWAP_H\n\n/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.\n   */\n#undef HAVE_SYS_DIR_H\n\n/* Define if sys_errlist in libc */\n#undef HAVE_SYS_ERRLIST\n\n/* Define to 1 if you have the <sys/file.h> header file. */\n#undef HAVE_SYS_FILE_H\n\n/* Define to 1 if you have the <sys/filio.h> header file. */\n#undef HAVE_SYS_FILIO_H\n\n/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.\n   */\n#undef HAVE_SYS_NDIR_H\n\n/* Define to 1 if you have the <sys/param.h> header file. */\n#undef HAVE_SYS_PARAM_H\n\n/* Define to 1 if you have the <sys/select.h> header file. */\n#undef HAVE_SYS_SELECT_H\n\n/* Define to 1 if you have the <sys/socket.h> header file. */\n#undef HAVE_SYS_SOCKET_H\n\n/* Define to 1 if you have the <sys/sockio.h> header file. */\n#undef HAVE_SYS_SOCKIO_H\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#undef HAVE_SYS_STAT_H\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#undef HAVE_SYS_TIME_H\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#undef HAVE_SYS_TYPES_H\n\n/* Define to 1 if you have the <sys/uio.h> header file. */\n#undef HAVE_SYS_UIO_H\n\n/* Define if tcl.h found */\n#undef HAVE_TCL_H\n\n/* Define if tcl/tcl.h found */\n#undef HAVE_TCL_TCL_H\n\n/* Define to 1 if you have the `timegm' function. */\n#undef HAVE_TIMEGM\n\n/* Define to 1 if you have the <time.h> header file. */\n#undef HAVE_TIME_H\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#undef HAVE_UNISTD_H\n\n/* Define to 1 if you have the `unsetenv' function. */\n#undef HAVE_UNSETENV\n\n/* Define to 1 if the system has the type `u_char'. */\n#undef HAVE_U_CHAR\n\n/* Define to 1 if the system has the type `u_int'. */\n#undef HAVE_U_INT\n\n/* Define to 1 if the system has the type `u_int16_t'. */\n#undef HAVE_U_INT16_T\n\n/* Define to 1 if the system has the type `u_int32_t'. */\n#undef HAVE_U_INT32_T\n\n/* Define to 1 if the system has the type `u_int8_t'. */\n#undef HAVE_U_INT8_T\n\n/* Define to 1 if the system has the type `u_long'. */\n#undef HAVE_U_LONG\n\n/* Define to 1 if you have the `vasprintf' function. */\n#undef HAVE_VASPRINTF\n\n/* Define to 1 if you have the `vsnprintf' function. */\n#undef HAVE_VSNPRINTF\n\n/* Define to 1 if you have the `vsprintf' function. */\n#undef HAVE_VSPRINTF\n\n/* Define to 1 if the system has the type `__int128_t'. */\n#undef HAVE___INT128_T\n\n/* Define to 1 if the system has the type `__uint128_t'. */\n#undef HAVE___UINT128_T\n\n/* Define if errno.h declares perror */\n#undef HDR_HAS_PERROR\n\n/* May need to be defined to enable IPv6 support, for example on IRIX */\n#undef INET6\n\n/* Define if MIT Project Athena default configuration should be used */\n#undef KRB5_ATHENA_COMPAT\n\n/* Define for DNS support of locating realms and KDCs */\n#undef KRB5_DNS_LOOKUP\n\n/* Define to enable DNS lookups of Kerberos realm names */\n#undef KRB5_DNS_LOOKUP_REALM\n\n/* Define if the KDC should return only vague error codes to clients */\n#undef KRBCONF_VAGUE_ERRORS\n\n/* define if the system header files are missing prototype for daemon() */\n#undef NEED_DAEMON_PROTO\n\n/* Define if in6addr_any is not defined in libc */\n#undef NEED_INSIXADDR_ANY\n\n/* define if the system header files are missing prototype for\n   ss_execute_command() */\n#undef NEED_SS_EXECUTE_COMMAND_PROTO\n\n/* define if the system header files are missing prototype for strptime() */\n#undef NEED_STRPTIME_PROTO\n\n/* define if the system header files are missing prototype for swab() */\n#undef NEED_SWAB_PROTO\n\n/* Define if need to declare sys_errlist */\n#undef NEED_SYS_ERRLIST\n\n/* define if the system header files are missing prototype for vasprintf() */\n#undef NEED_VASPRINTF_PROTO\n\n/* Define if the KDC should use no lookaside cache */\n#undef NOCACHE\n\n/* Define if references to pthread routines should be non-weak. */\n#undef NO_WEAK_PTHREADS\n\n/* Define if lex produes code with yylineno */\n#undef NO_YYLINENO\n\n/* Define to the address where bug reports for this package should be sent. */\n#undef PACKAGE_BUGREPORT\n\n/* Define to the full name of this package. */\n#undef PACKAGE_NAME\n\n/* Define to the full name and version of this package. */\n#undef PACKAGE_STRING\n\n/* Define to the one symbol short name of this package. */\n#undef PACKAGE_TARNAME\n\n/* Define to the home page for this package. */\n#undef PACKAGE_URL\n\n/* Define to the version of this package. */\n#undef PACKAGE_VERSION\n\n/* Define if setjmp indicates POSIX interface */\n#undef POSIX_SETJMP\n\n/* Define if POSIX signal handling is used */\n#undef POSIX_SIGNALS\n\n/* Define if POSIX signal handlers are used */\n#undef POSIX_SIGTYPE\n\n/* Define if termios.h exists and tcsetattr exists */\n#undef POSIX_TERMIOS\n\n/* Define to necessary symbol if this constant uses a non-standard name on\n   your system. */\n#undef PTHREAD_CREATE_JOINABLE\n\n/* Define as the return type of signal handlers (`int' or `void'). */\n#undef RETSIGTYPE\n\n/* Define as return type of setrpcent */\n#undef SETRPCENT_TYPE\n\n/* The size of `size_t', as computed by sizeof. */\n#undef SIZEOF_SIZE_T\n\n/* The size of `time_t', as computed by sizeof. */\n#undef SIZEOF_TIME_T\n\n/* Define to use OpenSSL for SPAKE preauth */\n#undef SPAKE_OPENSSL\n\n/* Define for static plugin linkage */\n#undef STATIC_PLUGINS\n\n/* Define to 1 if you have the ANSI C header files. */\n#undef STDC_HEADERS\n\n/* Define to 1 if strerror_r returns char *. */\n#undef STRERROR_R_CHAR_P\n\n/* Define if sys_errlist is defined in errno.h */\n#undef SYS_ERRLIST_DECLARED\n\n/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n#undef TIME_WITH_SYS_TIME\n\n/* Define if no TLS implementation is selected */\n#undef TLS_IMPL_NONE\n\n/* Define if TLS implementation is OpenSSL */\n#undef TLS_IMPL_OPENSSL\n\n/* Define if you have dirent.h functionality */\n#undef USE_DIRENT_H\n\n/* Define if dlopen should be used */\n#undef USE_DLOPEN\n\n/* Define if the keyring ccache should be enabled */\n#undef USE_KEYRING_CCACHE\n\n/* Define if link-time options for library finalization will be used */\n#undef USE_LINKER_FINI_OPTION\n\n/* Define if link-time options for library initialization will be used */\n#undef USE_LINKER_INIT_OPTION\n\n/* Define if sigprocmask should be used */\n#undef USE_SIGPROCMASK\n\n/* Define if wait takes int as a argument */\n#undef WAIT_USES_INT\n\n/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a\n   `char[]'. */\n#undef YYTEXT_POINTER\n\n/* Define to enable extensions in glibc */\n#undef _GNU_SOURCE\n\n/* Define to enable C11 extensions */\n#undef __STDC_WANT_LIB_EXT1__\n\n/* Define to empty if `const' does not conform to ANSI C. */\n#undef const\n\n/* Define to `int' if <sys/types.h> doesn't define. */\n#undef gid_t\n\n/* Define to `__inline__' or `__inline' if that's what the C compiler\n   calls it, or to nothing if 'inline' is not supported under any name.  */\n#ifndef __cplusplus\n#undef inline\n#endif\n\n/* Define krb5_sigtype to type of signal handler */\n#undef krb5_sigtype\n\n/* Define to `int' if <sys/types.h> does not define. */\n#undef mode_t\n\n/* Define to `long int' if <sys/types.h> does not define. */\n#undef off_t\n\n/* Define to `long' if <sys/types.h> does not define. */\n#undef time_t\n\n/* Define to `int' if <sys/types.h> doesn't define. */\n#undef uid_t\n\n\n#if defined(__GNUC__) && !defined(inline)\n/* Silence gcc pedantic warnings about ANSI C.  */\n# define inline __inline__\n#endif\n#endif /* KRB5_AUTOCONF_H */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/tests/shlib/t_loader.c": "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* tests/shlib/t_loader.c */\n/*\n * Copyright (C) 2005 by the Massachusetts Institute of Technology.\n * All rights reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n#include \"k5-platform.h\"\n#include \"krb5.h\"\n#include \"gssapi/gssapi.h\"\n#define HAVE_DLOPEN 1\n\nstatic int verbose = 1;\n\n#ifdef HAVE_DLFCN_H\n# include <dlfcn.h>\n#endif\n/* Solaris man page recommends link.h too */\n\n/* lazy = 1 means resolve symbols later, 0 means now; any\n   other flags we should be testing?  On Windows, maybe?\n\n   Return value is the library handle.  On error, print a message and\n   exit.  */\n#define do_open(LIB,REV,FLAGS) do_open_1(LIB,REV,FLAGS,__LINE__)\nstatic void *do_open_1(const char *libname, const char *rev, int lazy, int line);\n\n/* Look up a function symbol in the library and return a pointer.\n\n   The return value may need casting to the correct type.  On error,\n   print a message and exit.  */\nstatic void *get_sym_1(void *libhandle, const char *sym, int line);\n#define get_sym(LIB, NAME) get_sym_1(LIB, NAME, __LINE__)\n#define GET_FSYM(TYPE, LIB, NAME) ((TYPE) get_sym(LIB, NAME))\n#define get_gfun(LIB, NAME) ((OM_uint32 KRB5_CALLCONV(*)()) get_sym(LIB, NAME))\n\n/* Close dynamically-opened library.\n\n   If the OS reports an error in doing so, print a message and\n   exit.  */\n#define do_close(X) do_close_1(X, __LINE__)\nstatic void do_close_1(void *libhandle, int line);\n\n#ifdef HAVE_DLOPEN\n\n#ifdef _AIX\n# define SHLIB_SUFFIX \".a\"\n#else\n# define SHLIB_SUFFIX \".so\"\n#endif\n\n#define HORIZ 25\n\nstatic void *do_open_1(const char *libname, const char *rev,\n                       int lazy, int line)\n{\n    void *p;\n    char *namebuf;\n    int r;\n\n    if (verbose)\n        printf(\"from line %d: do_open(%s)...%*s\", line, libname,\n               HORIZ-strlen(libname), \"\");\n#ifdef _AIX\n    r = asprintf(&namebuf, \"lib%s%s\", libname, SHLIB_SUFFIX);\n#else\n    r = asprintf(&namebuf, \"lib%s%s(shr.o.%s)\", libname, SHLIB_SUFFIX, rev);\n#endif\n    if (r < 0) {\n        perror(\"asprintf\");\n        exit(1);\n    }\n\n#ifndef RTLD_MEMBER\n#define RTLD_MEMBER 0\n#endif\n    p = dlopen(namebuf, (lazy ? RTLD_LAZY : RTLD_NOW) | RTLD_MEMBER);\n    if (p == 0) {\n        fprintf(stderr, \"dlopen of %s failed: %s\\n\", namebuf, dlerror());\n        exit(1);\n    }\n    free(namebuf);\n    if (verbose)\n        printf(\"done: %p\\n\", p);\n    return p;\n}\n\n#define SYM_PREFIX \"\"\nstatic void *get_sym_1(void *libhandle, const char *symname, int line)\n{\n    void *s;\n\n    /* Bah.  Fix this later, if we care.  */\n    assert(strlen(SYM_PREFIX) == 0);\n\n    if (verbose)\n        printf(\"from line %d: get_sym(%s)...%*s\", line, symname,\n               HORIZ-strlen(symname), \"\");\n\n    s = dlsym(libhandle, symname);\n    if (s == 0) {\n        fprintf(stderr, \"symbol %s not found\\n\", symname);\n        exit(1);\n    }\n    if (verbose)\n        printf(\"done: %p\\n\", s);\n    return s;\n}\n\nstatic void do_close_1(void *libhandle, int line)\n{\n    if (verbose) {\n        char pbuf[3*sizeof(libhandle)+4];\n        snprintf(pbuf, sizeof(pbuf), \"%p\", libhandle);\n        printf(\"from line %d: do_close(%s)...%*s\", line, pbuf,\n               HORIZ-1-strlen(pbuf), \"\");\n    }\n    if (dlclose(libhandle) != 0) {\n        fprintf(stderr, \"dlclose failed: %s\\n\", dlerror());\n        exit(1);\n    }\n    if (verbose)\n        printf(\"done\\n\");\n}\n\n#elif defined _WIN32\n\nstatic void *do_open(const char *libname, int lazy)\n{\n    /* To be written?  */\n    abort();\n}\n\nstatic void *get_sym(void *libhandle, const char *symname)\n{\n    abort();\n}\n\nstatic void do_close(void *libhandle)\n{\n    abort();\n}\n\n#else\n\nstatic void *do_open(const char *libname, int lazy)\n{\n    printf(\"don't know how to do dynamic loading here, punting\\n\");\n    exit(0);\n}\n\nstatic void *get_sym(void *libhandle, const char *symname)\n{\n    abort();\n}\n\nstatic void do_close(void *libhandle)\n{\n    abort();\n}\n\n#endif\n\nint main()\n{\n    void *celib, *k5lib, *gsslib, *celib2;\n\n    (void) setvbuf(stdout, 0, _IONBF, 0);\n\n    celib = do_open(\"com_err\", \"3.0\", 0);\n    k5lib = do_open(\"krb5\", \"3.2\", 0);\n    gsslib = do_open(\"gssapi_krb5\", \"2.2\", 0);\n    celib2 = do_open(\"com_err\", \"3.0\", 0);\n    do_close(celib2);\n    {\n        typedef krb5_error_code KRB5_CALLCONV (*ict)(krb5_context *);\n        typedef void KRB5_CALLCONV (*fct)(krb5_context);\n\n        ict init_context = (ict) get_sym(k5lib, \"krb5_init_context\");\n        fct free_context = (fct) get_sym(k5lib, \"krb5_free_context\");\n        krb5_context ctx;\n        krb5_error_code err;\n\n#define CALLING(S) (verbose ? printf(\"at   line %d: calling %s...%*s\", __LINE__, #S, (int)(HORIZ+1-strlen(#S)), \"\") : 0)\n#define DONE() (verbose ? printf(\"done\\n\") : 0)\n\n        CALLING(krb5_init_context);\n        err = init_context(&ctx);\n        DONE();\n        if (err) {\n            fprintf(stderr, \"error 0x%lx initializing context\\n\",\n                    (unsigned long) err);\n            exit(1);\n        }\n        CALLING(krb5_free_context);\n        free_context(ctx);\n        DONE();\n    }\n    celib2 = do_open(\"com_err\", \"3.0\", 0);\n    do_close(celib);\n    do_close(k5lib);\n    do_close(celib2);\n    do_close(gsslib);\n\n    /* Test gssapi_krb5 without having loaded anything else.  */\n    gsslib = do_open(\"gssapi_krb5\", \"2.2\", 1);\n    {\n        OM_uint32 KRB5_CALLCONV (*init_sec_context)(OM_uint32 *, gss_cred_id_t,\n                                                    gss_ctx_id_t *, gss_name_t,\n                                                    gss_OID,\n                                                    OM_uint32, OM_uint32,\n                                                    gss_channel_bindings_t,\n                                                    gss_buffer_t, gss_OID *,\n                                                    gss_buffer_t,\n                                                    OM_uint32 *, OM_uint32 *)\n            = get_gfun(gsslib, \"gss_init_sec_context\");\n        OM_uint32 KRB5_CALLCONV (*import_name)(OM_uint32 *, gss_buffer_t,\n                                               gss_OID, gss_name_t *)\n            = get_gfun(gsslib, \"gss_import_name\");\n        OM_uint32 KRB5_CALLCONV (*release_buffer)(OM_uint32 *, gss_buffer_t)\n            = get_gfun(gsslib, \"gss_release_buffer\");\n        OM_uint32 KRB5_CALLCONV (*release_name)(OM_uint32 *, gss_name_t *)\n            = get_gfun(gsslib, \"gss_release_name\");\n        OM_uint32 KRB5_CALLCONV (*delete_sec_context)(OM_uint32 *,\n                                                      gss_ctx_id_t *,\n                                                      gss_buffer_t)\n            = get_gfun(gsslib, \"gss_delete_sec_context\");\n\n        OM_uint32 gmaj, gmin;\n        OM_uint32 retflags;\n        gss_ctx_id_t gctx = GSS_C_NO_CONTEXT;\n        gss_buffer_desc token;\n        gss_name_t target;\n        static gss_buffer_desc target_name_buf = {\n            9, \"x@mit.edu\"\n        };\n        static gss_OID_desc service_name = {\n            10, \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x01\\x04\"\n        };\n\n        CALLING(gss_import_name);\n        gmaj = import_name(&gmin, &target_name_buf, &service_name, &target);\n        DONE();\n        if (gmaj != GSS_S_COMPLETE) {\n            fprintf(stderr,\n                    \"import_name reports error major 0x%lx minor 0x%lx(%ld)\\n\",\n                    (unsigned long) gmaj, (unsigned long) gmin,\n                    (signed long) gmin);\n            exit(1);\n        }\n        /* This will probably get different errors, depending on\n           whether we have tickets at the time.  Doesn't matter much,\n           we're ignoring the error and testing whether we're doing\n           cleanup properly.  (Though the internal cleanup needed in\n           the two cases might be different.)  */\n        CALLING(gss_init_sec_context);\n        gmaj = init_sec_context(&gmin, GSS_C_NO_CREDENTIAL, &gctx, target,\n                                GSS_C_NULL_OID, 0, 0, NULL, GSS_C_NO_BUFFER,\n                                NULL, &token, &retflags, NULL);\n        DONE();\n        /* Ignore success/failure indication.  */\n        if (token.length) {\n            CALLING(gss_release_buffer);\n            release_buffer(&gmin, &token);\n            DONE();\n        }\n        CALLING(gss_release_name);\n        release_name(&gmin, &target);\n        DONE();\n        if (gctx != GSS_C_NO_CONTEXT) {\n            CALLING(gss_delete_sec_context);\n            delete_sec_context(&gmin, gctx, GSS_C_NO_BUFFER);\n            DONE();\n        }\n    }\n    do_close(gsslib);\n\n    /* Test gssapi_krb5 with com_err already loaded, then unload\n       com_err first.  */\n    celib = do_open(\"com_err\", \"3.0\", 1);\n    gsslib = do_open(\"gssapi_krb5\", \"2.2\", 1);\n    {\n        OM_uint32 KRB5_CALLCONV (*init_sec_context)(OM_uint32 *, gss_cred_id_t,\n                                                    gss_ctx_id_t *, gss_name_t,\n                                                    gss_OID,\n                                                    OM_uint32, OM_uint32,\n                                                    gss_channel_bindings_t,\n                                                    gss_buffer_t, gss_OID *,\n                                                    gss_buffer_t,\n                                                    OM_uint32 *, OM_uint32 *)\n            = get_gfun(gsslib, \"gss_init_sec_context\");\n        OM_uint32 KRB5_CALLCONV (*import_name)(OM_uint32 *, gss_buffer_t,\n                                               gss_OID, gss_name_t *)\n            = get_gfun(gsslib, \"gss_import_name\");\n        OM_uint32 KRB5_CALLCONV (*release_buffer)(OM_uint32 *, gss_buffer_t)\n            = get_gfun(gsslib, \"gss_release_buffer\");\n        OM_uint32 KRB5_CALLCONV (*release_name)(OM_uint32 *, gss_name_t *)\n            = get_gfun(gsslib, \"gss_release_name\");\n        OM_uint32 KRB5_CALLCONV (*delete_sec_context)(OM_uint32 *,\n                                                      gss_ctx_id_t *,\n                                                      gss_buffer_t)\n            = get_gfun(gsslib, \"gss_delete_sec_context\");\n\n        OM_uint32 gmaj, gmin;\n        OM_uint32 retflags;\n        gss_ctx_id_t gctx = GSS_C_NO_CONTEXT;\n        gss_buffer_desc token;\n        gss_name_t target;\n        static gss_buffer_desc target_name_buf = {\n            9, \"x@mit.edu\"\n        };\n        static gss_OID_desc service_name = {\n            10, \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x01\\x04\"\n        };\n\n        CALLING(gss_import_name);\n        gmaj = import_name(&gmin, &target_name_buf, &service_name, &target);\n        DONE();\n        if (gmaj != GSS_S_COMPLETE) {\n            fprintf(stderr,\n                    \"import_name reports error major 0x%lx minor 0x%lx(%ld)\\n\",\n                    (unsigned long) gmaj, (unsigned long) gmin,\n                    (signed long) gmin);\n            exit(1);\n        }\n        /* This will probably get different errors, depending on\n           whether we have tickets at the time.  Doesn't matter much,\n           we're ignoring the error and testing whether we're doing\n           cleanup properly.  (Though the internal cleanup needed in\n           the two cases might be different.)  */\n        CALLING(gss_init_sec_context);\n        gmaj = init_sec_context(&gmin, GSS_C_NO_CREDENTIAL, &gctx, target,\n                                GSS_C_NULL_OID, 0, 0, NULL, GSS_C_NO_BUFFER,\n                                NULL, &token, &retflags, NULL);\n        DONE();\n        /* Ignore success/failure indication.  */\n        if (token.length) {\n            CALLING(gss_release_buffer);\n            release_buffer(&gmin, &token);\n            DONE();\n        }\n        CALLING(gss_release_name);\n        release_name(&gmin, &target);\n        DONE();\n        if (gctx != GSS_C_NO_CONTEXT) {\n            CALLING(gss_delete_sec_context);\n            delete_sec_context(&gmin, gctx, GSS_C_NO_BUFFER);\n            DONE();\n        }\n    }\n    do_close(celib);\n    do_close(gsslib);\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/plugins/preauth/pkinit/pkinit_crypto_openssl.c": "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * COPYRIGHT (C) 2006,2007\n * THE REGENTS OF THE UNIVERSITY OF MICHIGAN\n * ALL RIGHTS RESERVED\n *\n * Permission is granted to use, copy, create derivative works\n * and redistribute this software and such derivative works\n * for any purpose, so long as the name of The University of\n * Michigan is not used in any advertising or publicity\n * pertaining to the use of distribution of this software\n * without specific, written prior authorization.  If the\n * above copyright notice or any other identification of the\n * University of Michigan is included in any copy of any\n * portion of this software, then the disclaimer below must\n * also be included.\n *\n * THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION\n * FROM THE UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY\n * PURPOSE, AND WITHOUT WARRANTY BY THE UNIVERSITY OF\n * MICHIGAN OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING\n * WITHOUT LIMITATION THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE\n * REGENTS OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE\n * FOR ANY DAMAGES, INCLUDING SPECIAL, INDIRECT, INCIDENTAL, OR\n * CONSEQUENTIAL DAMAGES, WITH RESPECT TO ANY CLAIM ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN\n * IF IT HAS BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGES.\n */\n\n#include \"k5-int.h\"\n#include \"pkinit_crypto_openssl.h\"\n#include \"k5-buf.h\"\n#include \"k5-hex.h\"\n#include <dlfcn.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <arpa/inet.h>\n\nstatic krb5_error_code pkinit_init_pkinit_oids(pkinit_plg_crypto_context );\nstatic void pkinit_fini_pkinit_oids(pkinit_plg_crypto_context );\n\nstatic krb5_error_code pkinit_init_dh_params(pkinit_plg_crypto_context );\nstatic void pkinit_fini_dh_params(pkinit_plg_crypto_context );\n\nstatic krb5_error_code pkinit_init_certs(pkinit_identity_crypto_context ctx);\nstatic void pkinit_fini_certs(pkinit_identity_crypto_context ctx);\n\nstatic krb5_error_code pkinit_init_pkcs11(pkinit_identity_crypto_context ctx);\nstatic void pkinit_fini_pkcs11(pkinit_identity_crypto_context ctx);\n\nstatic krb5_error_code pkinit_encode_dh_params\n(const BIGNUM *, const BIGNUM *, const BIGNUM *, uint8_t **, unsigned int *);\nstatic DH *decode_dh_params(const uint8_t *, unsigned int );\nstatic int pkinit_check_dh_params(DH *dh1, DH *dh2);\n\nstatic krb5_error_code pkinit_sign_data\n(krb5_context context, pkinit_identity_crypto_context cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **sig, unsigned int *sig_len);\n\nstatic krb5_error_code create_signature\n(unsigned char **, unsigned int *, unsigned char *, unsigned int,\n EVP_PKEY *pkey);\n\nstatic krb5_error_code pkinit_decode_data\n(krb5_context context, pkinit_identity_crypto_context cryptoctx,\n const uint8_t *data, unsigned int data_len, uint8_t **decoded,\n unsigned int *decoded_len);\n\n#ifdef DEBUG_DH\nstatic void print_dh(DH *, char *);\nstatic void print_pubkey(BIGNUM *, char *);\n#endif\n\nstatic int prepare_enc_data\n(const uint8_t *indata, int indata_len, uint8_t **outdata, int *outdata_len);\n\nstatic int openssl_callback (int, X509_STORE_CTX *);\nstatic int openssl_callback_ignore_crls (int, X509_STORE_CTX *);\n\nstatic int pkcs7_decrypt\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n PKCS7 *p7, BIO *bio);\n\nstatic BIO * pkcs7_dataDecode\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n PKCS7 *p7);\n\nstatic ASN1_OBJECT * pkinit_pkcs7type2oid\n(pkinit_plg_crypto_context plg_cryptoctx, int pkcs7_type);\n\nstatic krb5_error_code pkinit_create_sequence_of_principal_identifiers\n(krb5_context context, pkinit_plg_crypto_context plg_cryptoctx,\n pkinit_req_crypto_context req_cryptoctx,\n pkinit_identity_crypto_context id_cryptoctx,\n int type, krb5_pa_data ***e_data_out);\n\n#ifndef WITHOUT_PKCS11\nstatic krb5_error_code pkinit_find_private_key\n(pkinit_identity_crypto_context, CK_ATTRIBUTE_TYPE usage,\n CK_OBJECT_HANDLE *objp);\nstatic krb5_error_code pkinit_login\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n CK_TOKEN_INFO *tip, const char *password);\nstatic krb5_error_code pkinit_open_session\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx);\nstatic void * pkinit_C_LoadModule(const char *modname, CK_FUNCTION_LIST_PTR_PTR p11p);\nstatic CK_RV pkinit_C_UnloadModule(void *handle);\n#ifdef SILLYDECRYPT\nCK_RV pkinit_C_Decrypt\n(pkinit_identity_crypto_context id_cryptoctx,\n CK_BYTE_PTR pEncryptedData, CK_ULONG  ulEncryptedDataLen,\n CK_BYTE_PTR pData, CK_ULONG_PTR pulDataLen);\n#endif\n\nstatic krb5_error_code pkinit_sign_data_pkcs11\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **sig, unsigned int *sig_len);\nstatic krb5_error_code pkinit_decode_data_pkcs11\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n const uint8_t *data, unsigned int data_len, uint8_t **decoded_data,\n unsigned int *decoded_data_len);\n#endif  /* WITHOUT_PKCS11 */\n\nstatic krb5_error_code pkinit_sign_data_fs\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **sig, unsigned int *sig_len);\nstatic krb5_error_code pkinit_decode_data_fs\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n const uint8_t *data, unsigned int data_len, uint8_t **decoded_data,\n unsigned int *decoded_data_len);\n\nstatic krb5_error_code\ncreate_krb5_invalidCertificates(krb5_context context,\n                                pkinit_plg_crypto_context plg_cryptoctx,\n                                pkinit_req_crypto_context req_cryptoctx,\n                                pkinit_identity_crypto_context id_cryptoctx,\n                                krb5_external_principal_identifier *** ids);\n\nstatic krb5_error_code\ncreate_identifiers_from_stack(STACK_OF(X509) *sk,\n                              krb5_external_principal_identifier *** ids);\nstatic int\nwrap_signeddata(unsigned char *data, unsigned int data_len,\n                unsigned char **out, unsigned int *out_len);\n\nstatic char *\npkinit_pkcs11_code_to_text(int err);\n\n\n#ifdef HAVE_OPENSSL_CMS\n/* Use CMS support present in OpenSSL. */\n#include <openssl/cms.h>\n#define pkinit_CMS_get0_content_signed(_cms) CMS_get0_content(_cms)\n#define pkinit_CMS_get0_content_data(_cms) CMS_get0_content(_cms)\n#define pkinit_CMS_free1_crls(_sk_x509crl)              \\\n    sk_X509_CRL_pop_free((_sk_x509crl), X509_CRL_free)\n#define pkinit_CMS_free1_certs(_sk_x509)        \\\n    sk_X509_pop_free((_sk_x509), X509_free)\n#define pkinit_CMS_SignerInfo_get_cert(_cms,_si,_x509_pp)       \\\n    CMS_SignerInfo_get0_algs(_si,NULL,_x509_pp,NULL,NULL)\n#else\n/* Fake up CMS support using PKCS7. */\n#define pkinit_CMS_free1_crls(_stack_of_x509crls)   /* Don't free these */\n#define pkinit_CMS_free1_certs(_stack_of_x509certs) /* Don't free these */\n#define CMS_NO_SIGNER_CERT_VERIFY PKCS7_NOVERIFY\n#define CMS_NOATTR PKCS7_NOATTR\n#define CMS_ContentInfo PKCS7\n#define CMS_SignerInfo PKCS7_SIGNER_INFO\n#define d2i_CMS_ContentInfo d2i_PKCS7\n#define CMS_get0_type(_p7) ((_p7)->type)\n#define pkinit_CMS_get0_content_signed(_p7) (&((_p7)->d.sign->contents->d.other->value.octet_string))\n#define pkinit_CMS_get0_content_data(_p7) (&((_p7)->d.other->value.octet_string))\n#define CMS_set1_signers_certs(_p7,_stack_of_x509,_uint)\n#define CMS_get0_SignerInfos PKCS7_get_signer_info\n#define stack_st_CMS_SignerInfo stack_st_PKCS7_SIGNER_INFO\n#undef  sk_CMS_SignerInfo_value\n#define sk_CMS_SignerInfo_value sk_PKCS7_SIGNER_INFO_value\n#define CMS_get0_eContentType(_p7) (_p7->d.sign->contents->type)\n#define CMS_verify PKCS7_verify\n#define CMS_get1_crls(_p7) (_p7->d.sign->crl)\n#define CMS_get1_certs(_p7) (_p7->d.sign->cert)\n#define CMS_ContentInfo_free(_p7) PKCS7_free(_p7)\n#define pkinit_CMS_SignerInfo_get_cert(_p7,_si,_x509_pp)        \\\n    (*_x509_pp) = PKCS7_cert_from_signer_info(_p7,_si)\n#endif\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\n/* 1.1 standardizes constructor and destructor names, renaming\n * EVP_MD_CTX_{create,destroy} and deprecating ASN1_STRING_data. */\n\n#define EVP_MD_CTX_new EVP_MD_CTX_create\n#define EVP_MD_CTX_free EVP_MD_CTX_destroy\n#define ASN1_STRING_get0_data ASN1_STRING_data\n\n/* 1.1 makes many handle types opaque and adds accessors.  Add compatibility\n * versions of the new accessors we use for pre-1.1. */\n\n#define OBJ_get0_data(o) ((o)->data)\n#define OBJ_length(o) ((o)->length)\n\n#define DH_set0_pqg compat_dh_set0_pqg\nstatic int compat_dh_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g)\n{\n    /* The real function frees the old values and does argument checking, but\n     * our code doesn't need that. */\n    dh->p = p;\n    dh->q = q;\n    dh->g = g;\n    return 1;\n}\n\n#define DH_get0_pqg compat_dh_get0_pqg\nstatic void compat_dh_get0_pqg(const DH *dh, const BIGNUM **p,\n                               const BIGNUM **q, const BIGNUM **g)\n{\n    if (p != NULL)\n        *p = dh->p;\n    if (q != NULL)\n        *q = dh->q;\n    if (g != NULL)\n        *g = dh->g;\n}\n\n#define DH_get0_key compat_dh_get0_key\nstatic void compat_dh_get0_key(const DH *dh, const BIGNUM **pub,\n                               const BIGNUM **priv)\n{\n    if (pub != NULL)\n        *pub = dh->pub_key;\n    if (priv != NULL)\n        *priv = dh->priv_key;\n}\n\n/* Return true if the cert c includes a key usage which doesn't include u.\n * Define using direct member access for pre-1.1. */\n#define ku_reject(c, u)                                                 \\\n    (((c)->ex_flags & EXFLAG_KUSAGE) && !((c)->ex_kusage & (u)))\n\n#else /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\n\n/* Return true if the cert x includes a key usage which doesn't include u. */\n#define ku_reject(c, u) (!(X509_get_key_usage(c) & (u)))\n\n#endif\n\nstatic struct pkcs11_errstrings {\n    short code;\n    char *text;\n} pkcs11_errstrings[] = {\n    { 0x0,      \"ok\" },\n    { 0x1,      \"cancel\" },\n    { 0x2,      \"host memory\" },\n    { 0x3,      \"slot id invalid\" },\n    { 0x5,      \"general error\" },\n    { 0x6,      \"function failed\" },\n    { 0x7,      \"arguments bad\" },\n    { 0x8,      \"no event\" },\n    { 0x9,      \"need to create threads\" },\n    { 0xa,      \"cant lock\" },\n    { 0x10,     \"attribute read only\" },\n    { 0x11,     \"attribute sensitive\" },\n    { 0x12,     \"attribute type invalid\" },\n    { 0x13,     \"attribute value invalid\" },\n    { 0x20,     \"data invalid\" },\n    { 0x21,     \"data len range\" },\n    { 0x30,     \"device error\" },\n    { 0x31,     \"device memory\" },\n    { 0x32,     \"device removed\" },\n    { 0x40,     \"encrypted data invalid\" },\n    { 0x41,     \"encrypted data len range\" },\n    { 0x50,     \"function canceled\" },\n    { 0x51,     \"function not parallel\" },\n    { 0x54,     \"function not supported\" },\n    { 0x60,     \"key handle invalid\" },\n    { 0x62,     \"key size range\" },\n    { 0x63,     \"key type inconsistent\" },\n    { 0x64,     \"key not needed\" },\n    { 0x65,     \"key changed\" },\n    { 0x66,     \"key needed\" },\n    { 0x67,     \"key indigestible\" },\n    { 0x68,     \"key function not permitted\" },\n    { 0x69,     \"key not wrappable\" },\n    { 0x6a,     \"key unextractable\" },\n    { 0x70,     \"mechanism invalid\" },\n    { 0x71,     \"mechanism param invalid\" },\n    { 0x82,     \"object handle invalid\" },\n    { 0x90,     \"operation active\" },\n    { 0x91,     \"operation not initialized\" },\n    { 0xa0,     \"pin incorrect\" },\n    { 0xa1,     \"pin invalid\" },\n    { 0xa2,     \"pin len range\" },\n    { 0xa3,     \"pin expired\" },\n    { 0xa4,     \"pin locked\" },\n    { 0xb0,     \"session closed\" },\n    { 0xb1,     \"session count\" },\n    { 0xb3,     \"session handle invalid\" },\n    { 0xb4,     \"session parallel not supported\" },\n    { 0xb5,     \"session read only\" },\n    { 0xb6,     \"session exists\" },\n    { 0xb7,     \"session read only exists\" },\n    { 0xb8,     \"session read write so exists\" },\n    { 0xc0,     \"signature invalid\" },\n    { 0xc1,     \"signature len range\" },\n    { 0xd0,     \"template incomplete\" },\n    { 0xd1,     \"template inconsistent\" },\n    { 0xe0,     \"token not present\" },\n    { 0xe1,     \"token not recognized\" },\n    { 0xe2,     \"token write protected\" },\n    { 0xf0,     \"unwrapping key handle invalid\" },\n    { 0xf1,     \"unwrapping key size range\" },\n    { 0xf2,     \"unwrapping key type inconsistent\" },\n    { 0x100,    \"user already logged in\" },\n    { 0x101,    \"user not logged in\" },\n    { 0x102,    \"user pin not initialized\" },\n    { 0x103,    \"user type invalid\" },\n    { 0x104,    \"user another already logged in\" },\n    { 0x105,    \"user too many types\" },\n    { 0x110,    \"wrapped key invalid\" },\n    { 0x112,    \"wrapped key len range\" },\n    { 0x113,    \"wrapping key handle invalid\" },\n    { 0x114,    \"wrapping key size range\" },\n    { 0x115,    \"wrapping key type inconsistent\" },\n    { 0x120,    \"random seed not supported\" },\n    { 0x121,    \"random no rng\" },\n    { 0x130,    \"domain params invalid\" },\n    { 0x150,    \"buffer too small\" },\n    { 0x160,    \"saved state invalid\" },\n    { 0x170,    \"information sensitive\" },\n    { 0x180,    \"state unsaveable\" },\n    { 0x190,    \"cryptoki not initialized\" },\n    { 0x191,    \"cryptoki already initialized\" },\n    { 0x1a0,    \"mutex bad\" },\n    { 0x1a1,    \"mutex not locked\" },\n    { 0x200,    \"function rejected\" },\n    { -1,       NULL }\n};\n\n/* DH parameters */\nstatic uint8_t oakley_1024[128] = {\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\n    0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\n    0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\n    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\n    0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\n    0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE6, 0x53, 0x81,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n};\n\nstatic uint8_t oakley_2048[2048/8] = {\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\n    0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\n    0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\n    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\n    0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\n    0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,\n    0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\n    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,\n    0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\n    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,\n    0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\n    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,\n    0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\n    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C,\n    0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\n    0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03,\n    0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\n    0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9,\n    0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\n    0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5,\n    0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\n    0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAC, 0xAA, 0x68,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n};\n\nstatic uint8_t oakley_4096[4096/8] = {\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\n    0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\n    0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\n    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\n    0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\n    0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,\n    0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\n    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,\n    0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\n    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,\n    0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\n    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,\n    0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\n    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C,\n    0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\n    0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03,\n    0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\n    0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9,\n    0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\n    0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5,\n    0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\n    0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAA, 0xC4, 0x2D,\n    0xAD, 0x33, 0x17, 0x0D, 0x04, 0x50, 0x7A, 0x33,\n    0xA8, 0x55, 0x21, 0xAB, 0xDF, 0x1C, 0xBA, 0x64,\n    0xEC, 0xFB, 0x85, 0x04, 0x58, 0xDB, 0xEF, 0x0A,\n    0x8A, 0xEA, 0x71, 0x57, 0x5D, 0x06, 0x0C, 0x7D,\n    0xB3, 0x97, 0x0F, 0x85, 0xA6, 0xE1, 0xE4, 0xC7,\n    0xAB, 0xF5, 0xAE, 0x8C, 0xDB, 0x09, 0x33, 0xD7,\n    0x1E, 0x8C, 0x94, 0xE0, 0x4A, 0x25, 0x61, 0x9D,\n    0xCE, 0xE3, 0xD2, 0x26, 0x1A, 0xD2, 0xEE, 0x6B,\n    0xF1, 0x2F, 0xFA, 0x06, 0xD9, 0x8A, 0x08, 0x64,\n    0xD8, 0x76, 0x02, 0x73, 0x3E, 0xC8, 0x6A, 0x64,\n    0x52, 0x1F, 0x2B, 0x18, 0x17, 0x7B, 0x20, 0x0C,\n    0xBB, 0xE1, 0x17, 0x57, 0x7A, 0x61, 0x5D, 0x6C,\n    0x77, 0x09, 0x88, 0xC0, 0xBA, 0xD9, 0x46, 0xE2,\n    0x08, 0xE2, 0x4F, 0xA0, 0x74, 0xE5, 0xAB, 0x31,\n    0x43, 0xDB, 0x5B, 0xFC, 0xE0, 0xFD, 0x10, 0x8E,\n    0x4B, 0x82, 0xD1, 0x20, 0xA9, 0x21, 0x08, 0x01,\n    0x1A, 0x72, 0x3C, 0x12, 0xA7, 0x87, 0xE6, 0xD7,\n    0x88, 0x71, 0x9A, 0x10, 0xBD, 0xBA, 0x5B, 0x26,\n    0x99, 0xC3, 0x27, 0x18, 0x6A, 0xF4, 0xE2, 0x3C,\n    0x1A, 0x94, 0x68, 0x34, 0xB6, 0x15, 0x0B, 0xDA,\n    0x25, 0x83, 0xE9, 0xCA, 0x2A, 0xD4, 0x4C, 0xE8,\n    0xDB, 0xBB, 0xC2, 0xDB, 0x04, 0xDE, 0x8E, 0xF9,\n    0x2E, 0x8E, 0xFC, 0x14, 0x1F, 0xBE, 0xCA, 0xA6,\n    0x28, 0x7C, 0x59, 0x47, 0x4E, 0x6B, 0xC0, 0x5D,\n    0x99, 0xB2, 0x96, 0x4F, 0xA0, 0x90, 0xC3, 0xA2,\n    0x23, 0x3B, 0xA1, 0x86, 0x51, 0x5B, 0xE7, 0xED,\n    0x1F, 0x61, 0x29, 0x70, 0xCE, 0xE2, 0xD7, 0xAF,\n    0xB8, 0x1B, 0xDD, 0x76, 0x21, 0x70, 0x48, 0x1C,\n    0xD0, 0x06, 0x91, 0x27, 0xD5, 0xB0, 0x5A, 0xA9,\n    0x93, 0xB4, 0xEA, 0x98, 0x8D, 0x8F, 0xDD, 0xC1,\n    0x86, 0xFF, 0xB7, 0xDC, 0x90, 0xA6, 0xC0, 0x8F,\n    0x4D, 0xF4, 0x35, 0xC9, 0x34, 0x06, 0x31, 0x99,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n};\n\nMAKE_INIT_FUNCTION(pkinit_openssl_init);\n\nstatic krb5_error_code oerr(krb5_context context, krb5_error_code code,\n                            const char *fmt, ...)\n#if !defined(__cplusplus) && (__GNUC__ > 2)\n    __attribute__((__format__(__printf__, 3, 4)))\n#endif\n    ;\n\n/*\n * Set an error string containing the formatted arguments and the first pending\n * OpenSSL error.  Write the formatted arguments and all pending OpenSSL error\n * messages to the trace log.  Return code, or KRB5KDC_ERR_PREAUTH_FAILED if\n * code is 0.\n */\nstatic krb5_error_code\noerr(krb5_context context, krb5_error_code code, const char *fmt, ...)\n{\n    unsigned long err;\n    va_list ap;\n    char *str, buf[128];\n    int r;\n\n    if (!code)\n        code = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    va_start(ap, fmt);\n    r = vasprintf(&str, fmt, ap);\n    va_end(ap);\n    if (r < 0)\n        return code;\n\n    err = ERR_peek_error();\n    if (err) {\n        krb5_set_error_message(context, code, _(\"%s: %s\"), str,\n                               ERR_reason_error_string(err));\n    } else {\n        krb5_set_error_message(context, code, \"%s\", str);\n    }\n\n    TRACE_PKINIT_OPENSSL_ERROR(context, str);\n    while ((err = ERR_get_error()) != 0) {\n        ERR_error_string_n(err, buf, sizeof(buf));\n        TRACE_PKINIT_OPENSSL_ERROR(context, buf);\n    }\n\n    free(str);\n    return code;\n}\n\n/*\n * Set an appropriate error string containing msg for a certificate\n * verification failure from certctx.  Write the message and all pending\n * OpenSSL error messages to the trace log.  Return code, or\n * KRB5KDC_ERR_PREAUTH_FAILED if code is 0.\n */\nstatic krb5_error_code\noerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,\n          const char *msg)\n{\n    int depth = X509_STORE_CTX_get_error_depth(certctx);\n    int err = X509_STORE_CTX_get_error(certctx);\n    const char *errstr = X509_verify_cert_error_string(err);\n\n    return oerr(context, code, _(\"%s (depth %d): %s\"), msg, depth, errstr);\n}\n\nkrb5_error_code\npkinit_init_plg_crypto(pkinit_plg_crypto_context *cryptoctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_plg_crypto_context ctx = NULL;\n\n    (void)CALL_INIT_FUNCTION(pkinit_openssl_init);\n\n    ctx = malloc(sizeof(*ctx));\n    if (ctx == NULL)\n        goto out;\n    memset(ctx, 0, sizeof(*ctx));\n\n    pkiDebug(\"%s: initializing openssl crypto context at %p\\n\",\n             __FUNCTION__, ctx);\n    retval = pkinit_init_pkinit_oids(ctx);\n    if (retval)\n        goto out;\n\n    retval = pkinit_init_dh_params(ctx);\n    if (retval)\n        goto out;\n\n    *cryptoctx = ctx;\n\nout:\n    if (retval && ctx != NULL)\n        pkinit_fini_plg_crypto(ctx);\n\n    return retval;\n}\n\nvoid\npkinit_fini_plg_crypto(pkinit_plg_crypto_context cryptoctx)\n{\n    pkiDebug(\"%s: freeing context at %p\\n\", __FUNCTION__, cryptoctx);\n\n    if (cryptoctx == NULL)\n        return;\n    pkinit_fini_pkinit_oids(cryptoctx);\n    pkinit_fini_dh_params(cryptoctx);\n    free(cryptoctx);\n}\n\nkrb5_error_code\npkinit_init_identity_crypto(pkinit_identity_crypto_context *idctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_identity_crypto_context ctx = NULL;\n\n    ctx = malloc(sizeof(*ctx));\n    if (ctx == NULL)\n        goto out;\n    memset(ctx, 0, sizeof(*ctx));\n\n    ctx->identity = NULL;\n\n    retval = pkinit_init_certs(ctx);\n    if (retval)\n        goto out;\n\n    retval = pkinit_init_pkcs11(ctx);\n    if (retval)\n        goto out;\n\n    pkiDebug(\"%s: returning ctx at %p\\n\", __FUNCTION__, ctx);\n    *idctx = ctx;\n\nout:\n    if (retval) {\n        if (ctx)\n            pkinit_fini_identity_crypto(ctx);\n    }\n\n    return retval;\n}\n\nvoid\npkinit_fini_identity_crypto(pkinit_identity_crypto_context idctx)\n{\n    if (idctx == NULL)\n        return;\n\n    pkiDebug(\"%s: freeing ctx at %p\\n\", __FUNCTION__, idctx);\n    if (idctx->deferred_ids != NULL)\n        pkinit_free_deferred_ids(idctx->deferred_ids);\n    free(idctx->identity);\n    pkinit_fini_certs(idctx);\n    pkinit_fini_pkcs11(idctx);\n    free(idctx);\n}\n\nkrb5_error_code\npkinit_init_req_crypto(pkinit_req_crypto_context *cryptoctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_req_crypto_context ctx = NULL;\n\n    ctx = malloc(sizeof(*ctx));\n    if (ctx == NULL)\n        goto out;\n    memset(ctx, 0, sizeof(*ctx));\n\n    ctx->dh = NULL;\n    ctx->received_cert = NULL;\n\n    *cryptoctx = ctx;\n\n    pkiDebug(\"%s: returning ctx at %p\\n\", __FUNCTION__, ctx);\n    retval = 0;\nout:\n    if (retval)\n        free(ctx);\n\n    return retval;\n}\n\nvoid\npkinit_fini_req_crypto(pkinit_req_crypto_context req_cryptoctx)\n{\n    if (req_cryptoctx == NULL)\n        return;\n\n    pkiDebug(\"%s: freeing ctx at %p\\n\", __FUNCTION__, req_cryptoctx);\n    if (req_cryptoctx->dh != NULL)\n        DH_free(req_cryptoctx->dh);\n    if (req_cryptoctx->received_cert != NULL)\n        X509_free(req_cryptoctx->received_cert);\n\n    free(req_cryptoctx);\n}\n\nstatic krb5_error_code\npkinit_init_pkinit_oids(pkinit_plg_crypto_context ctx)\n{\n    ctx->id_pkinit_san = OBJ_txt2obj(\"1.3.6.1.5.2.2\", 1);\n    if (ctx->id_pkinit_san == NULL)\n        return ENOMEM;\n\n    ctx->id_pkinit_authData = OBJ_txt2obj(\"1.3.6.1.5.2.3.1\", 1);\n    if (ctx->id_pkinit_authData == NULL)\n        return ENOMEM;\n\n    ctx->id_pkinit_DHKeyData = OBJ_txt2obj(\"1.3.6.1.5.2.3.2\", 1);\n    if (ctx->id_pkinit_DHKeyData == NULL)\n        return ENOMEM;\n\n    ctx->id_pkinit_rkeyData = OBJ_txt2obj(\"1.3.6.1.5.2.3.3\", 1);\n    if (ctx->id_pkinit_rkeyData == NULL)\n        return ENOMEM;\n\n    ctx->id_pkinit_KPClientAuth = OBJ_txt2obj(\"1.3.6.1.5.2.3.4\", 1);\n    if (ctx->id_pkinit_KPClientAuth == NULL)\n        return ENOMEM;\n\n    ctx->id_pkinit_KPKdc = OBJ_txt2obj(\"1.3.6.1.5.2.3.5\", 1);\n    if (ctx->id_pkinit_KPKdc == NULL)\n        return ENOMEM;\n\n    ctx->id_ms_kp_sc_logon = OBJ_txt2obj(\"1.3.6.1.4.1.311.20.2.2\", 1);\n    if (ctx->id_ms_kp_sc_logon == NULL)\n        return ENOMEM;\n\n    ctx->id_ms_san_upn = OBJ_txt2obj(\"1.3.6.1.4.1.311.20.2.3\", 1);\n    if (ctx->id_ms_san_upn == NULL)\n        return ENOMEM;\n\n    ctx->id_kp_serverAuth = OBJ_txt2obj(\"1.3.6.1.5.5.7.3.1\", 1);\n    if (ctx->id_kp_serverAuth == NULL)\n        return ENOMEM;\n\n    return 0;\n}\n\nstatic krb5_error_code\nget_cert(char *filename, X509 **retcert)\n{\n    X509 *cert = NULL;\n    BIO *tmp = NULL;\n    int code;\n    krb5_error_code retval;\n\n    if (filename == NULL || retcert == NULL)\n        return EINVAL;\n\n    *retcert = NULL;\n\n    tmp = BIO_new(BIO_s_file());\n    if (tmp == NULL)\n        return ENOMEM;\n\n    code = BIO_read_filename(tmp, filename);\n    if (code == 0) {\n        retval = errno;\n        goto cleanup;\n    }\n\n    cert = (X509 *) PEM_read_bio_X509(tmp, NULL, NULL, NULL);\n    if (cert == NULL) {\n        retval = EIO;\n        pkiDebug(\"failed to read certificate from %s\\n\", filename);\n        goto cleanup;\n    }\n    *retcert = cert;\n    retval = 0;\ncleanup:\n    if (tmp != NULL)\n        BIO_free(tmp);\n    return retval;\n}\n\nstruct get_key_cb_data {\n    krb5_context context;\n    pkinit_identity_crypto_context id_cryptoctx;\n    const char *fsname;\n    char *filename;\n    const char *password;\n};\n\nstatic int\nget_key_cb(char *buf, int size, int rwflag, void *userdata)\n{\n    struct get_key_cb_data *data = userdata;\n    pkinit_identity_crypto_context id_cryptoctx;\n    krb5_data rdat;\n    krb5_prompt kprompt;\n    krb5_prompt_type prompt_type;\n    krb5_error_code retval;\n    char *prompt;\n\n    if (data->id_cryptoctx->defer_id_prompt) {\n        /* Supply the identity name to be passed to a responder callback. */\n        pkinit_set_deferred_id(&data->id_cryptoctx->deferred_ids,\n                               data->fsname, 0, NULL);\n        return -1;\n    }\n    if (data->password == NULL) {\n        /* We don't already have a password to use, so prompt for one. */\n        if (data->id_cryptoctx->prompter == NULL)\n            return -1;\n        if (asprintf(&prompt, \"%s %s\", _(\"Pass phrase for\"),\n                     data->filename) < 0)\n            return -1;\n        rdat.data = buf;\n        rdat.length = size;\n        kprompt.prompt = prompt;\n        kprompt.hidden = 1;\n        kprompt.reply = &rdat;\n        prompt_type = KRB5_PROMPT_TYPE_PREAUTH;\n\n        /* PROMPTER_INVOCATION */\n        k5int_set_prompt_types(data->context, &prompt_type);\n        id_cryptoctx = data->id_cryptoctx;\n        retval = (data->id_cryptoctx->prompter)(data->context,\n                                                id_cryptoctx->prompter_data,\n                                                NULL, NULL, 1, &kprompt);\n        k5int_set_prompt_types(data->context, 0);\n        free(prompt);\n        if (retval != 0)\n            return -1;\n    } else {\n        /* Just use the already-supplied password. */\n        rdat.length = strlen(data->password);\n        if ((int)rdat.length >= size)\n            return -1;\n        snprintf(buf, size, \"%s\", data->password);\n    }\n    return (int)rdat.length;\n}\n\nstatic krb5_error_code\nget_key(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n        char *filename, const char *fsname, EVP_PKEY **retkey,\n        const char *password)\n{\n    EVP_PKEY *pkey = NULL;\n    BIO *tmp = NULL;\n    struct get_key_cb_data cb_data;\n    int code;\n    krb5_error_code retval;\n\n    if (filename == NULL || retkey == NULL)\n        return EINVAL;\n\n    tmp = BIO_new(BIO_s_file());\n    if (tmp == NULL)\n        return ENOMEM;\n\n    code = BIO_read_filename(tmp, filename);\n    if (code == 0) {\n        retval = errno;\n        goto cleanup;\n    }\n    cb_data.context = context;\n    cb_data.id_cryptoctx = id_cryptoctx;\n    cb_data.filename = filename;\n    cb_data.fsname = fsname;\n    cb_data.password = password;\n    pkey = PEM_read_bio_PrivateKey(tmp, NULL, get_key_cb, &cb_data);\n    if (pkey == NULL && !id_cryptoctx->defer_id_prompt) {\n        retval = EIO;\n        pkiDebug(\"failed to read private key from %s\\n\", filename);\n        goto cleanup;\n    }\n    *retkey = pkey;\n    retval = 0;\ncleanup:\n    if (tmp != NULL)\n        BIO_free(tmp);\n    return retval;\n}\n\nstatic void\npkinit_fini_pkinit_oids(pkinit_plg_crypto_context ctx)\n{\n    if (ctx == NULL)\n        return;\n    ASN1_OBJECT_free(ctx->id_pkinit_san);\n    ASN1_OBJECT_free(ctx->id_pkinit_authData);\n    ASN1_OBJECT_free(ctx->id_pkinit_DHKeyData);\n    ASN1_OBJECT_free(ctx->id_pkinit_rkeyData);\n    ASN1_OBJECT_free(ctx->id_pkinit_KPClientAuth);\n    ASN1_OBJECT_free(ctx->id_pkinit_KPKdc);\n    ASN1_OBJECT_free(ctx->id_ms_kp_sc_logon);\n    ASN1_OBJECT_free(ctx->id_ms_san_upn);\n    ASN1_OBJECT_free(ctx->id_kp_serverAuth);\n}\n\n/* Construct an OpenSSL DH object for an Oakley group. */\nstatic DH *\nmake_oakley_dh(uint8_t *prime, size_t len)\n{\n    DH *dh = NULL;\n    BIGNUM *p = NULL, *q = NULL, *g = NULL;\n\n    p = BN_bin2bn(prime, len, NULL);\n    if (p == NULL)\n        goto cleanup;\n    q = BN_new();\n    if (q == NULL)\n        goto cleanup;\n    if (!BN_rshift1(q, p))\n        goto cleanup;\n    g = BN_new();\n    if (g == NULL)\n        goto cleanup;\n    if (!BN_set_word(g, DH_GENERATOR_2))\n        goto cleanup;\n\n    dh = DH_new();\n    if (dh == NULL)\n        goto cleanup;\n    DH_set0_pqg(dh, p, q, g);\n    p = g = q = NULL;\n\ncleanup:\n    BN_free(p);\n    BN_free(q);\n    BN_free(g);\n    return dh;\n}\n\nstatic krb5_error_code\npkinit_init_dh_params(pkinit_plg_crypto_context plgctx)\n{\n    krb5_error_code retval = ENOMEM;\n\n    plgctx->dh_1024 = make_oakley_dh(oakley_1024, sizeof(oakley_1024));\n    if (plgctx->dh_1024 == NULL)\n        goto cleanup;\n\n    plgctx->dh_2048 = make_oakley_dh(oakley_2048, sizeof(oakley_2048));\n    if (plgctx->dh_2048 == NULL)\n        goto cleanup;\n\n    plgctx->dh_4096 = make_oakley_dh(oakley_4096, sizeof(oakley_4096));\n    if (plgctx->dh_4096 == NULL)\n        goto cleanup;\n\n    retval = 0;\n\ncleanup:\n    if (retval)\n        pkinit_fini_dh_params(plgctx);\n\n    return retval;\n}\n\nstatic void\npkinit_fini_dh_params(pkinit_plg_crypto_context plgctx)\n{\n    if (plgctx->dh_1024 != NULL)\n        DH_free(plgctx->dh_1024);\n    if (plgctx->dh_2048 != NULL)\n        DH_free(plgctx->dh_2048);\n    if (plgctx->dh_4096 != NULL)\n        DH_free(plgctx->dh_4096);\n\n    plgctx->dh_1024 = plgctx->dh_2048 = plgctx->dh_4096 = NULL;\n}\n\nstatic krb5_error_code\npkinit_init_certs(pkinit_identity_crypto_context ctx)\n{\n    krb5_error_code retval = ENOMEM;\n    int i;\n\n    for (i = 0; i < MAX_CREDS_ALLOWED; i++)\n        ctx->creds[i] = NULL;\n    ctx->my_certs = NULL;\n    ctx->cert_index = 0;\n    ctx->my_key = NULL;\n    ctx->trustedCAs = NULL;\n    ctx->intermediateCAs = NULL;\n    ctx->revoked = NULL;\n\n    retval = 0;\n    return retval;\n}\n\nstatic void\npkinit_fini_certs(pkinit_identity_crypto_context ctx)\n{\n    if (ctx == NULL)\n        return;\n\n    if (ctx->my_certs != NULL)\n        sk_X509_pop_free(ctx->my_certs, X509_free);\n\n    if (ctx->my_key != NULL)\n        EVP_PKEY_free(ctx->my_key);\n\n    if (ctx->trustedCAs != NULL)\n        sk_X509_pop_free(ctx->trustedCAs, X509_free);\n\n    if (ctx->intermediateCAs != NULL)\n        sk_X509_pop_free(ctx->intermediateCAs, X509_free);\n\n    if (ctx->revoked != NULL)\n        sk_X509_CRL_pop_free(ctx->revoked, X509_CRL_free);\n}\n\nstatic krb5_error_code\npkinit_init_pkcs11(pkinit_identity_crypto_context ctx)\n{\n    krb5_error_code retval = ENOMEM;\n\n#ifndef WITHOUT_PKCS11\n    ctx->p11_module_name = strdup(PKCS11_MODNAME);\n    if (ctx->p11_module_name == NULL)\n        return retval;\n    ctx->p11_module = NULL;\n    ctx->slotid = PK_NOSLOT;\n    ctx->token_label = NULL;\n    ctx->cert_label = NULL;\n    ctx->session = CK_INVALID_HANDLE;\n    ctx->p11 = NULL;\n#endif\n    ctx->pkcs11_method = 0;\n\n    retval = 0;\n    return retval;\n}\n\nstatic void\npkinit_fini_pkcs11(pkinit_identity_crypto_context ctx)\n{\n#ifndef WITHOUT_PKCS11\n    if (ctx == NULL)\n        return;\n\n    if (ctx->p11 != NULL) {\n        if (ctx->session != CK_INVALID_HANDLE) {\n            ctx->p11->C_CloseSession(ctx->session);\n            ctx->session = CK_INVALID_HANDLE;\n        }\n        ctx->p11->C_Finalize(NULL_PTR);\n        ctx->p11 = NULL;\n    }\n    if (ctx->p11_module != NULL) {\n        pkinit_C_UnloadModule(ctx->p11_module);\n        ctx->p11_module = NULL;\n    }\n    free(ctx->p11_module_name);\n    free(ctx->token_label);\n    free(ctx->cert_id);\n    free(ctx->cert_label);\n#endif\n}\n\nkrb5_error_code\npkinit_identity_set_prompter(pkinit_identity_crypto_context id_cryptoctx,\n                             krb5_prompter_fct prompter,\n                             void *prompter_data)\n{\n    id_cryptoctx->prompter = prompter;\n    id_cryptoctx->prompter_data = prompter_data;\n\n    return 0;\n}\n\n/* Create a CMS ContentInfo of type oid containing the octet string in data. */\nstatic krb5_error_code\ncreate_contentinfo(krb5_context context, ASN1_OBJECT *oid,\n                   unsigned char *data, size_t data_len, PKCS7 **p7_out)\n{\n    PKCS7 *p7 = NULL;\n    ASN1_OCTET_STRING *ostr = NULL;\n\n    *p7_out = NULL;\n\n    ostr = ASN1_OCTET_STRING_new();\n    if (ostr == NULL)\n        goto oom;\n    if (!ASN1_OCTET_STRING_set(ostr, (unsigned char *)data, data_len))\n        goto oom;\n\n    p7 = PKCS7_new();\n    if (p7 == NULL)\n        goto oom;\n    p7->type = OBJ_dup(oid);\n    if (p7->type == NULL)\n        goto oom;\n\n    if (OBJ_obj2nid(oid) == NID_pkcs7_data) {\n        /* Draft 9 uses id-pkcs7-data for signed data.  For this type OpenSSL\n         * expects an octet string in d.data. */\n        p7->d.data = ostr;\n    } else {\n        p7->d.other = ASN1_TYPE_new();\n        if (p7->d.other == NULL)\n            goto oom;\n        p7->d.other->type = V_ASN1_OCTET_STRING;\n        p7->d.other->value.octet_string = ostr;\n    }\n\n    *p7_out = p7;\n    return 0;\n\noom:\n    if (ostr != NULL)\n        ASN1_OCTET_STRING_free(ostr);\n    if (p7 != NULL)\n        PKCS7_free(p7);\n    return ENOMEM;\n}\n\nkrb5_error_code\ncms_contentinfo_create(krb5_context context,                          /* IN */\n                       pkinit_plg_crypto_context plg_cryptoctx,       /* IN */\n                       pkinit_req_crypto_context req_cryptoctx,       /* IN */\n                       pkinit_identity_crypto_context id_cryptoctx,   /* IN */\n                       int cms_msg_type,\n                       unsigned char *data, unsigned int data_len,\n                       unsigned char **out_data, unsigned int *out_data_len)\n{\n    krb5_error_code retval = ENOMEM;\n    ASN1_OBJECT *oid;\n    PKCS7 *p7 = NULL;\n    unsigned char *p;\n\n    /* Pick the correct oid for the eContentInfo. */\n    oid = pkinit_pkcs7type2oid(plg_cryptoctx, cms_msg_type);\n    if (oid == NULL)\n        goto cleanup;\n    retval = create_contentinfo(context, oid, data, data_len, &p7);\n    if (retval != 0)\n        goto cleanup;\n    *out_data_len = i2d_PKCS7(p7, NULL);\n    if (!(*out_data_len)) {\n        retval = oerr(context, 0, _(\"Failed to DER encode PKCS7\"));\n        goto cleanup;\n    }\n    retval = ENOMEM;\n    if ((p = *out_data = malloc(*out_data_len)) == NULL)\n        goto cleanup;\n\n    /* DER encode PKCS7 data */\n    retval = i2d_PKCS7(p7, &p);\n    if (!retval) {\n        retval = oerr(context, 0, _(\"Failed to DER encode PKCS7\"));\n        goto cleanup;\n    }\n    retval = 0;\ncleanup:\n    if (p7)\n        PKCS7_free(p7);\n    return retval;\n}\n\n\n\nkrb5_error_code\ncms_signeddata_create(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      int cms_msg_type,\n                      int include_certchain,\n                      unsigned char *data,\n                      unsigned int data_len,\n                      unsigned char **signed_data,\n                      unsigned int *signed_data_len)\n{\n    krb5_error_code retval = ENOMEM;\n    PKCS7  *p7 = NULL, *inner_p7 = NULL;\n    PKCS7_SIGNED *p7s = NULL;\n    PKCS7_SIGNER_INFO *p7si = NULL;\n    unsigned char *p;\n    STACK_OF(X509) * cert_stack = NULL;\n    ASN1_OCTET_STRING *digest_attr = NULL;\n    EVP_MD_CTX *ctx;\n    const EVP_MD *md_tmp = NULL;\n    unsigned char md_data[EVP_MAX_MD_SIZE], md_data2[EVP_MAX_MD_SIZE];\n    unsigned char *digestInfo_buf = NULL, *abuf = NULL;\n    unsigned int md_len, md_len2, alen, digestInfo_len;\n    STACK_OF(X509_ATTRIBUTE) * sk;\n    unsigned char *sig = NULL;\n    unsigned int sig_len = 0;\n    X509_ALGOR *alg = NULL;\n    ASN1_OCTET_STRING *digest = NULL;\n    unsigned int alg_len = 0, digest_len = 0;\n    unsigned char *y = NULL;\n    X509 *cert = NULL;\n    ASN1_OBJECT *oid = NULL, *oid_copy;\n\n    /* Start creating PKCS7 data. */\n    if ((p7 = PKCS7_new()) == NULL)\n        goto cleanup;\n    p7->type = OBJ_nid2obj(NID_pkcs7_signed);\n\n    if ((p7s = PKCS7_SIGNED_new()) == NULL)\n        goto cleanup;\n    p7->d.sign = p7s;\n    if (!ASN1_INTEGER_set(p7s->version, 3))\n        goto cleanup;\n\n    /* pick the correct oid for the eContentInfo */\n    oid = pkinit_pkcs7type2oid(plg_cryptoctx, cms_msg_type);\n    if (oid == NULL)\n        goto cleanup;\n\n    if (id_cryptoctx->my_certs != NULL) {\n        /* create a cert chain that has at least the signer's certificate */\n        if ((cert_stack = sk_X509_new_null()) == NULL)\n            goto cleanup;\n\n        cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n        if (!include_certchain) {\n            pkiDebug(\"only including signer's certificate\\n\");\n            sk_X509_push(cert_stack, X509_dup(cert));\n        } else {\n            /* create a cert chain */\n            X509_STORE *certstore = NULL;\n            X509_STORE_CTX *certctx;\n            STACK_OF(X509) *certstack = NULL;\n            char buf[DN_BUF_LEN];\n            unsigned int i = 0, size = 0;\n\n            if ((certstore = X509_STORE_new()) == NULL)\n                goto cleanup;\n            pkiDebug(\"building certificate chain\\n\");\n            X509_STORE_set_verify_cb(certstore, openssl_callback);\n            certctx = X509_STORE_CTX_new();\n            if (certctx == NULL)\n                goto cleanup;\n            X509_STORE_CTX_init(certctx, certstore, cert,\n                                id_cryptoctx->intermediateCAs);\n            X509_STORE_CTX_trusted_stack(certctx, id_cryptoctx->trustedCAs);\n            if (!X509_verify_cert(certctx)) {\n                retval = oerr_cert(context, 0, certctx,\n                                   _(\"Failed to verify own certificate\"));\n                goto cleanup;\n            }\n            certstack = X509_STORE_CTX_get1_chain(certctx);\n            size = sk_X509_num(certstack);\n            pkiDebug(\"size of certificate chain = %d\\n\", size);\n            for(i = 0; i < size - 1; i++) {\n                X509 *x = sk_X509_value(certstack, i);\n                X509_NAME_oneline(X509_get_subject_name(x), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", i, buf);\n                sk_X509_push(cert_stack, X509_dup(x));\n            }\n            X509_STORE_CTX_free(certctx);\n            X509_STORE_free(certstore);\n            sk_X509_pop_free(certstack, X509_free);\n        }\n        p7s->cert = cert_stack;\n\n        /* fill-in PKCS7_SIGNER_INFO */\n        if ((p7si = PKCS7_SIGNER_INFO_new()) == NULL)\n            goto cleanup;\n        if (!ASN1_INTEGER_set(p7si->version, 1))\n            goto cleanup;\n        if (!X509_NAME_set(&p7si->issuer_and_serial->issuer,\n                           X509_get_issuer_name(cert)))\n            goto cleanup;\n        /* because ASN1_INTEGER_set is used to set a 'long' we will do\n         * things the ugly way. */\n        ASN1_INTEGER_free(p7si->issuer_and_serial->serial);\n        if (!(p7si->issuer_and_serial->serial =\n              ASN1_INTEGER_dup(X509_get_serialNumber(cert))))\n            goto cleanup;\n\n        /* will not fill-out EVP_PKEY because it's on the smartcard */\n\n        /* Set digest algs */\n        p7si->digest_alg->algorithm = OBJ_nid2obj(NID_sha1);\n\n        if (p7si->digest_alg->parameter != NULL)\n            ASN1_TYPE_free(p7si->digest_alg->parameter);\n        if ((p7si->digest_alg->parameter = ASN1_TYPE_new()) == NULL)\n            goto cleanup;\n        p7si->digest_alg->parameter->type = V_ASN1_NULL;\n\n        /* Set sig algs */\n        if (p7si->digest_enc_alg->parameter != NULL)\n            ASN1_TYPE_free(p7si->digest_enc_alg->parameter);\n        p7si->digest_enc_alg->algorithm = OBJ_nid2obj(NID_sha1WithRSAEncryption);\n        if (!(p7si->digest_enc_alg->parameter = ASN1_TYPE_new()))\n            goto cleanup;\n        p7si->digest_enc_alg->parameter->type = V_ASN1_NULL;\n\n        if (cms_msg_type == CMS_SIGN_DRAFT9){\n            /* don't include signed attributes for pa-type 15 request */\n            abuf = data;\n            alen = data_len;\n        } else {\n            /* add signed attributes */\n            /* compute sha1 digest over the EncapsulatedContentInfo */\n            ctx = EVP_MD_CTX_new();\n            if (ctx == NULL)\n                goto cleanup;\n            EVP_DigestInit_ex(ctx, EVP_sha1(), NULL);\n            EVP_DigestUpdate(ctx, data, data_len);\n            md_tmp = EVP_MD_CTX_md(ctx);\n            EVP_DigestFinal_ex(ctx, md_data, &md_len);\n            EVP_MD_CTX_free(ctx);\n\n            /* create a message digest attr */\n            digest_attr = ASN1_OCTET_STRING_new();\n            ASN1_OCTET_STRING_set(digest_attr, md_data, (int)md_len);\n            PKCS7_add_signed_attribute(p7si, NID_pkcs9_messageDigest,\n                                       V_ASN1_OCTET_STRING, (char *) digest_attr);\n\n            /* create a content-type attr */\n            oid_copy = OBJ_dup(oid);\n            if (oid_copy == NULL)\n                goto cleanup2;\n            PKCS7_add_signed_attribute(p7si, NID_pkcs9_contentType,\n                                       V_ASN1_OBJECT, oid_copy);\n\n            /* create the signature over signed attributes. get DER encoded value */\n            /* This is the place where smartcard signature needs to be calculated */\n            sk = p7si->auth_attr;\n            alen = ASN1_item_i2d((ASN1_VALUE *) sk, &abuf,\n                                 ASN1_ITEM_rptr(PKCS7_ATTR_SIGN));\n            if (abuf == NULL)\n                goto cleanup2;\n        } /* signed attributes */\n\n#ifndef WITHOUT_PKCS11\n        /* Some tokens can only do RSAEncryption without sha1 hash */\n        /* to compute sha1WithRSAEncryption, encode the algorithm ID for the hash\n         * function and the hash value into an ASN.1 value of type DigestInfo\n         * DigestInfo::=SEQUENCE {\n         *  digestAlgorithm  AlgorithmIdentifier,\n         *  digest OCTET STRING }\n         */\n        if (id_cryptoctx->pkcs11_method == 1 &&\n            id_cryptoctx->mech == CKM_RSA_PKCS) {\n            pkiDebug(\"mech = CKM_RSA_PKCS\\n\");\n            ctx = EVP_MD_CTX_new();\n            if (ctx == NULL)\n                goto cleanup;\n            /* if this is not draft9 request, include digest signed attribute */\n            if (cms_msg_type != CMS_SIGN_DRAFT9)\n                EVP_DigestInit_ex(ctx, md_tmp, NULL);\n            else\n                EVP_DigestInit_ex(ctx, EVP_sha1(), NULL);\n            EVP_DigestUpdate(ctx, abuf, alen);\n            EVP_DigestFinal_ex(ctx, md_data2, &md_len2);\n            EVP_MD_CTX_free(ctx);\n\n            alg = X509_ALGOR_new();\n            if (alg == NULL)\n                goto cleanup2;\n            X509_ALGOR_set0(alg, OBJ_nid2obj(NID_sha1), V_ASN1_NULL, NULL);\n            alg_len = i2d_X509_ALGOR(alg, NULL);\n\n            digest = ASN1_OCTET_STRING_new();\n            if (digest == NULL)\n                goto cleanup2;\n            ASN1_OCTET_STRING_set(digest, md_data2, (int)md_len2);\n            digest_len = i2d_ASN1_OCTET_STRING(digest, NULL);\n\n            digestInfo_len = ASN1_object_size(1, (int)(alg_len + digest_len),\n                                              V_ASN1_SEQUENCE);\n            y = digestInfo_buf = malloc(digestInfo_len);\n            if (digestInfo_buf == NULL)\n                goto cleanup2;\n            ASN1_put_object(&y, 1, (int)(alg_len + digest_len), V_ASN1_SEQUENCE,\n                            V_ASN1_UNIVERSAL);\n            i2d_X509_ALGOR(alg, &y);\n            i2d_ASN1_OCTET_STRING(digest, &y);\n#ifdef DEBUG_SIG\n            pkiDebug(\"signing buffer\\n\");\n            print_buffer(digestInfo_buf, digestInfo_len);\n            print_buffer_bin(digestInfo_buf, digestInfo_len, \"/tmp/pkcs7_tosign\");\n#endif\n            retval = pkinit_sign_data(context, id_cryptoctx, digestInfo_buf,\n                                      digestInfo_len, &sig, &sig_len);\n        } else\n#endif\n        {\n            pkiDebug(\"mech = %s\\n\",\n                     id_cryptoctx->pkcs11_method == 1 ? \"CKM_SHA1_RSA_PKCS\" : \"FS\");\n            retval = pkinit_sign_data(context, id_cryptoctx, abuf, alen,\n                                      &sig, &sig_len);\n        }\n#ifdef DEBUG_SIG\n        print_buffer(sig, sig_len);\n#endif\n        if (cms_msg_type != CMS_SIGN_DRAFT9 )\n            free(abuf);\n        if (retval)\n            goto cleanup2;\n\n        /* Add signature */\n        if (!ASN1_STRING_set(p7si->enc_digest, (unsigned char *) sig,\n                             (int)sig_len)) {\n            retval = oerr(context, 0, _(\"Failed to add digest attribute\"));\n            goto cleanup2;\n        }\n        /* adder signer_info to pkcs7 signed */\n        if (!PKCS7_add_signer(p7, p7si))\n            goto cleanup2;\n    } /* we have a certificate */\n\n    /* start on adding data to the pkcs7 signed */\n    retval = create_contentinfo(context, oid, data, data_len, &inner_p7);\n    if (p7s->contents != NULL)\n        PKCS7_free(p7s->contents);\n    p7s->contents = inner_p7;\n\n    *signed_data_len = i2d_PKCS7(p7, NULL);\n    if (!(*signed_data_len)) {\n        retval = oerr(context, 0, _(\"Failed to DER encode PKCS7\"));\n        goto cleanup2;\n    }\n    retval = ENOMEM;\n    if ((p = *signed_data = malloc(*signed_data_len)) == NULL)\n        goto cleanup2;\n\n    /* DER encode PKCS7 data */\n    retval = i2d_PKCS7(p7, &p);\n    if (!retval) {\n        retval = oerr(context, 0, _(\"Failed to DER encode PKCS7\"));\n        goto cleanup2;\n    }\n    retval = 0;\n\n#ifdef DEBUG_ASN1\n    if (cms_msg_type == CMS_SIGN_CLIENT) {\n        print_buffer_bin(*signed_data, *signed_data_len,\n                         \"/tmp/client_pkcs7_signeddata\");\n    } else {\n        if (cms_msg_type == CMS_SIGN_SERVER) {\n            print_buffer_bin(*signed_data, *signed_data_len,\n                             \"/tmp/kdc_pkcs7_signeddata\");\n        } else {\n            print_buffer_bin(*signed_data, *signed_data_len,\n                             \"/tmp/draft9_pkcs7_signeddata\");\n        }\n    }\n#endif\n\ncleanup2:\n    if (p7si) {\n        if (cms_msg_type != CMS_SIGN_DRAFT9)\n#ifndef WITHOUT_PKCS11\n        if (id_cryptoctx->pkcs11_method == 1 &&\n            id_cryptoctx->mech == CKM_RSA_PKCS) {\n            free(digestInfo_buf);\n            if (digest != NULL)\n                ASN1_OCTET_STRING_free(digest);\n        }\n#endif\n        if (alg != NULL)\n            X509_ALGOR_free(alg);\n    }\ncleanup:\n    if (p7 != NULL)\n        PKCS7_free(p7);\n    free(sig);\n\n    return retval;\n}\n\nkrb5_error_code\ncms_signeddata_verify(krb5_context context,\n                      pkinit_plg_crypto_context plgctx,\n                      pkinit_req_crypto_context reqctx,\n                      pkinit_identity_crypto_context idctx,\n                      int cms_msg_type,\n                      int require_crl_checking,\n                      unsigned char *signed_data,\n                      unsigned int signed_data_len,\n                      unsigned char **data,\n                      unsigned int *data_len,\n                      unsigned char **authz_data,\n                      unsigned int *authz_data_len,\n                      int *is_signed)\n{\n    /*\n     * Warning: Since most openssl functions do not set retval, large chunks of\n     * this function assume that retval is always a failure and may go to\n     * cleanup without setting retval explicitly. Make sure retval is not set\n     * to 0 or errors such as signature verification failure may be converted\n     * to success with significant security consequences.\n     */\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    CMS_ContentInfo *cms = NULL;\n    BIO *out = NULL;\n    int flags = CMS_NO_SIGNER_CERT_VERIFY;\n    int valid_oid = 0;\n    unsigned int i = 0;\n    unsigned int vflags = 0, size = 0;\n    const unsigned char *p = signed_data;\n    STACK_OF(CMS_SignerInfo) *si_sk = NULL;\n    CMS_SignerInfo *si = NULL;\n    X509 *x = NULL;\n    X509_STORE *store = NULL;\n    X509_STORE_CTX *cert_ctx;\n    STACK_OF(X509) *signerCerts = NULL;\n    STACK_OF(X509) *intermediateCAs = NULL;\n    STACK_OF(X509_CRL) *signerRevoked = NULL;\n    STACK_OF(X509_CRL) *revoked = NULL;\n    STACK_OF(X509) *verified_chain = NULL;\n    ASN1_OBJECT *oid = NULL;\n    const ASN1_OBJECT *type = NULL, *etype = NULL;\n    ASN1_OCTET_STRING **octets;\n    krb5_external_principal_identifier **krb5_verified_chain = NULL;\n    krb5_data *authz = NULL;\n    char buf[DN_BUF_LEN];\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(signed_data, signed_data_len,\n                     \"/tmp/client_received_pkcs7_signeddata\");\n#endif\n    if (is_signed)\n        *is_signed = 1;\n\n    oid = pkinit_pkcs7type2oid(plgctx, cms_msg_type);\n    if (oid == NULL)\n        goto cleanup;\n\n    /* decode received CMS message */\n    if ((cms = d2i_CMS_ContentInfo(NULL, &p, (int)signed_data_len)) == NULL) {\n        retval = oerr(context, 0, _(\"Failed to decode CMS message\"));\n        goto cleanup;\n    }\n    etype = CMS_get0_eContentType(cms);\n\n    /*\n     * Prior to 1.10 the MIT client incorrectly emitted the pkinit structure\n     * directly in a CMS ContentInfo rather than using SignedData with no\n     * signers. Handle that case.\n     */\n    type = CMS_get0_type(cms);\n    if (is_signed && !OBJ_cmp(type, oid)) {\n        unsigned char *d;\n        *is_signed = 0;\n        octets = pkinit_CMS_get0_content_data(cms);\n        if (!octets || ((*octets)->type != V_ASN1_OCTET_STRING)) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Invalid pkinit packet: octet string \"\n                                     \"expected\"));\n            goto cleanup;\n        }\n        *data_len = ASN1_STRING_length(*octets);\n        d = malloc(*data_len);\n        if (d == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        memcpy(d, ASN1_STRING_get0_data(*octets), *data_len);\n        *data = d;\n        goto out;\n    } else {\n        /* Verify that the received message is CMS SignedData message. */\n        if (OBJ_obj2nid(type) != NID_pkcs7_signed) {\n            pkiDebug(\"Expected id-signedData CMS msg (received type = %d)\\n\",\n                     OBJ_obj2nid(type));\n            krb5_set_error_message(context, retval, _(\"wrong oid\\n\"));\n            goto cleanup;\n        }\n    }\n\n    /* setup to verify X509 certificate used to sign CMS message */\n    if (!(store = X509_STORE_new()))\n        goto cleanup;\n\n    /* check if we are inforcing CRL checking */\n    vflags = X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL;\n    if (require_crl_checking)\n        X509_STORE_set_verify_cb(store, openssl_callback);\n    else\n        X509_STORE_set_verify_cb(store, openssl_callback_ignore_crls);\n    X509_STORE_set_flags(store, vflags);\n\n    /*\n     * Get the signer's information from the CMS message.  Match signer ID\n     * against anchors and intermediate CAs in case no certs are present in the\n     * SignedData.  If we start sending kdcPkId values in requests, we'll need\n     * to match against the source of that information too.\n     */\n    CMS_set1_signers_certs(cms, NULL, 0);\n    CMS_set1_signers_certs(cms, idctx->trustedCAs, CMS_NOINTERN);\n    CMS_set1_signers_certs(cms, idctx->intermediateCAs, CMS_NOINTERN);\n    if (((si_sk = CMS_get0_SignerInfos(cms)) == NULL) ||\n        ((si = sk_CMS_SignerInfo_value(si_sk, 0)) == NULL)) {\n        /* Not actually signed; anonymous case */\n        if (!is_signed)\n            goto cleanup;\n        *is_signed = 0;\n        /* We cannot use CMS_dataInit because there may be no digest */\n        octets = pkinit_CMS_get0_content_signed(cms);\n        if (octets)\n            out = BIO_new_mem_buf((*octets)->data, (*octets)->length);\n        if (out == NULL)\n            goto cleanup;\n    } else {\n        pkinit_CMS_SignerInfo_get_cert(cms, si, &x);\n        if (x == NULL)\n            goto cleanup;\n\n        /* create available CRL information (get local CRLs and include CRLs\n         * received in the CMS message\n         */\n        signerRevoked = CMS_get1_crls(cms);\n        if (idctx->revoked == NULL)\n            revoked = signerRevoked;\n        else if (signerRevoked == NULL)\n            revoked = idctx->revoked;\n        else {\n            size = sk_X509_CRL_num(idctx->revoked);\n            revoked = sk_X509_CRL_new_null();\n            for (i = 0; i < size; i++)\n                sk_X509_CRL_push(revoked, sk_X509_CRL_value(idctx->revoked, i));\n            size = sk_X509_CRL_num(signerRevoked);\n            for (i = 0; i < size; i++)\n                sk_X509_CRL_push(revoked, sk_X509_CRL_value(signerRevoked, i));\n        }\n\n        /* create available intermediate CAs chains (get local intermediateCAs and\n         * include the CA chain received in the CMS message\n         */\n        signerCerts = CMS_get1_certs(cms);\n        if (idctx->intermediateCAs == NULL)\n            intermediateCAs = signerCerts;\n        else if (signerCerts == NULL)\n            intermediateCAs = idctx->intermediateCAs;\n        else {\n            size = sk_X509_num(idctx->intermediateCAs);\n            intermediateCAs = sk_X509_new_null();\n            for (i = 0; i < size; i++) {\n                sk_X509_push(intermediateCAs,\n                             sk_X509_value(idctx->intermediateCAs, i));\n            }\n            size = sk_X509_num(signerCerts);\n            for (i = 0; i < size; i++) {\n                sk_X509_push(intermediateCAs, sk_X509_value(signerCerts, i));\n            }\n        }\n\n        /* initialize x509 context with the received certificate and\n         * trusted and intermediate CA chains and CRLs\n         */\n        cert_ctx = X509_STORE_CTX_new();\n        if (cert_ctx == NULL)\n            goto cleanup;\n        if (!X509_STORE_CTX_init(cert_ctx, store, x, intermediateCAs))\n            goto cleanup;\n\n        X509_STORE_CTX_set0_crls(cert_ctx, revoked);\n\n        /* add trusted CAs certificates for cert verification */\n        if (idctx->trustedCAs != NULL)\n            X509_STORE_CTX_trusted_stack(cert_ctx, idctx->trustedCAs);\n        else {\n            pkiDebug(\"unable to find any trusted CAs\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_CERTCHAIN\n        if (intermediateCAs != NULL) {\n            size = sk_X509_num(intermediateCAs);\n            pkiDebug(\"untrusted cert chain of size %d\\n\", size);\n            for (i = 0; i < size; i++) {\n                X509_NAME_oneline(X509_get_subject_name(\n                                      sk_X509_value(intermediateCAs, i)), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", i, buf);\n            }\n        }\n        if (idctx->trustedCAs != NULL) {\n            size = sk_X509_num(idctx->trustedCAs);\n            pkiDebug(\"trusted cert chain of size %d\\n\", size);\n            for (i = 0; i < size; i++) {\n                X509_NAME_oneline(X509_get_subject_name(\n                                      sk_X509_value(idctx->trustedCAs, i)), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", i, buf);\n            }\n        }\n        if (revoked != NULL) {\n            size = sk_X509_CRL_num(revoked);\n            pkiDebug(\"CRL chain of size %d\\n\", size);\n            for (i = 0; i < size; i++) {\n                X509_CRL *crl = sk_X509_CRL_value(revoked, i);\n                X509_NAME_oneline(X509_CRL_get_issuer(crl), buf, sizeof(buf));\n                pkiDebug(\"crls by CA #%d: %s\\n\", i , buf);\n            }\n        }\n#endif\n\n        i = X509_verify_cert(cert_ctx);\n        if (i <= 0) {\n            int j = X509_STORE_CTX_get_error(cert_ctx);\n            X509 *cert;\n\n            cert = X509_STORE_CTX_get_current_cert(cert_ctx);\n            reqctx->received_cert = X509_dup(cert);\n            switch(j) {\n            case X509_V_ERR_CERT_REVOKED:\n                retval = KRB5KDC_ERR_REVOKED_CERTIFICATE;\n                break;\n            case X509_V_ERR_UNABLE_TO_GET_CRL:\n                retval = KRB5KDC_ERR_REVOCATION_STATUS_UNKNOWN;\n                break;\n            case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\n            case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\n                retval = KRB5KDC_ERR_CANT_VERIFY_CERTIFICATE;\n                break;\n            default:\n                retval = KRB5KDC_ERR_INVALID_CERTIFICATE;\n            }\n            (void)oerr_cert(context, retval, cert_ctx,\n                            _(\"Failed to verify received certificate\"));\n            if (reqctx->received_cert == NULL)\n                strlcpy(buf, \"(none)\", sizeof(buf));\n            else\n                X509_NAME_oneline(X509_get_subject_name(reqctx->received_cert),\n                                  buf, sizeof(buf));\n            pkiDebug(\"problem with cert DN = %s (error=%d) %s\\n\", buf, j,\n                     X509_verify_cert_error_string(j));\n#ifdef DEBUG_CERTCHAIN\n            size = sk_X509_num(signerCerts);\n            pkiDebug(\"received cert chain of size %d\\n\", size);\n            for (j = 0; j < size; j++) {\n                X509 *tmp_cert = sk_X509_value(signerCerts, j);\n                X509_NAME_oneline(X509_get_subject_name(tmp_cert), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", j, buf);\n            }\n#endif\n        } else {\n            /* retrieve verified certificate chain */\n            if (cms_msg_type == CMS_SIGN_CLIENT || cms_msg_type == CMS_SIGN_DRAFT9)\n                verified_chain = X509_STORE_CTX_get1_chain(cert_ctx);\n        }\n        X509_STORE_CTX_free(cert_ctx);\n        if (i <= 0)\n            goto cleanup;\n        out = BIO_new(BIO_s_mem());\n        if (cms_msg_type == CMS_SIGN_DRAFT9)\n            flags |= CMS_NOATTR;\n        if (CMS_verify(cms, NULL, store, NULL, out, flags) == 0) {\n            unsigned long err = ERR_peek_error();\n            switch(ERR_GET_REASON(err)) {\n            case PKCS7_R_DIGEST_FAILURE:\n                retval = KRB5KDC_ERR_DIGEST_IN_SIGNED_DATA_NOT_ACCEPTED;\n                break;\n            case PKCS7_R_SIGNATURE_FAILURE:\n            default:\n                retval = KRB5KDC_ERR_INVALID_SIG;\n            }\n            (void)oerr(context, retval, _(\"Failed to verify CMS message\"));\n            goto cleanup;\n        }\n    } /* message was signed */\n    if (!OBJ_cmp(etype, oid))\n        valid_oid = 1;\n    else if (cms_msg_type == CMS_SIGN_DRAFT9) {\n        /*\n         * Various implementations of the pa-type 15 request use\n         * different OIDS.  We check that the returned object\n         * has any of the acceptable OIDs\n         */\n        ASN1_OBJECT *client_oid = NULL, *server_oid = NULL, *rsa_oid = NULL;\n        client_oid = pkinit_pkcs7type2oid(plgctx, CMS_SIGN_CLIENT);\n        server_oid = pkinit_pkcs7type2oid(plgctx, CMS_SIGN_SERVER);\n        rsa_oid = pkinit_pkcs7type2oid(plgctx, CMS_ENVEL_SERVER);\n        if (!OBJ_cmp(etype, client_oid) ||\n            !OBJ_cmp(etype, server_oid) ||\n            !OBJ_cmp(etype, rsa_oid))\n            valid_oid = 1;\n    }\n\n    if (valid_oid)\n        pkiDebug(\"CMS Verification successful\\n\");\n    else {\n        pkiDebug(\"wrong oid in eContentType\\n\");\n        print_buffer(OBJ_get0_data(etype), OBJ_length(etype));\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        krb5_set_error_message(context, retval, \"wrong oid\\n\");\n        goto cleanup;\n    }\n\n    /* transfer the data from CMS message into return buffer */\n    for (size = 0;;) {\n        int remain;\n        retval = ENOMEM;\n        if ((*data = realloc(*data, size + 1024 * 10)) == NULL)\n            goto cleanup;\n        remain = BIO_read(out, &((*data)[size]), 1024 * 10);\n        if (remain <= 0)\n            break;\n        else\n            size += remain;\n    }\n    *data_len = size;\n\n    if (x) {\n        reqctx->received_cert = X509_dup(x);\n\n        /* generate authorization data */\n        if (cms_msg_type == CMS_SIGN_CLIENT || cms_msg_type == CMS_SIGN_DRAFT9) {\n\n            if (authz_data == NULL || authz_data_len == NULL)\n                goto out;\n\n            *authz_data = NULL;\n            retval = create_identifiers_from_stack(verified_chain,\n                                                   &krb5_verified_chain);\n            if (retval) {\n                pkiDebug(\"create_identifiers_from_stack failed\\n\");\n                goto cleanup;\n            }\n\n            retval = k5int_encode_krb5_td_trusted_certifiers((krb5_external_principal_identifier *const *)krb5_verified_chain, &authz);\n            if (retval) {\n                pkiDebug(\"encode_krb5_td_trusted_certifiers failed\\n\");\n                goto cleanup;\n            }\n#ifdef DEBUG_ASN1\n            print_buffer_bin((unsigned char *)authz->data, authz->length,\n                             \"/tmp/kdc_ad_initial_verified_cas\");\n#endif\n            *authz_data = malloc(authz->length);\n            if (*authz_data == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n            memcpy(*authz_data, authz->data, authz->length);\n            *authz_data_len = authz->length;\n        }\n    }\nout:\n    retval = 0;\n\ncleanup:\n    if (out != NULL)\n        BIO_free(out);\n    if (store != NULL)\n        X509_STORE_free(store);\n    if (cms != NULL) {\n        if (signerCerts != NULL)\n            pkinit_CMS_free1_certs(signerCerts);\n        if (idctx->intermediateCAs != NULL && signerCerts)\n            sk_X509_free(intermediateCAs);\n        if (signerRevoked != NULL)\n            pkinit_CMS_free1_crls(signerRevoked);\n        if (idctx->revoked != NULL && signerRevoked)\n            sk_X509_CRL_free(revoked);\n        CMS_ContentInfo_free(cms);\n    }\n    if (verified_chain != NULL)\n        sk_X509_pop_free(verified_chain, X509_free);\n    if (krb5_verified_chain != NULL)\n        free_krb5_external_principal_identifier(&krb5_verified_chain);\n    if (authz != NULL)\n        krb5_free_data(context, authz);\n\n    return retval;\n}\n\nkrb5_error_code\ncms_envelopeddata_create(krb5_context context,\n                         pkinit_plg_crypto_context plgctx,\n                         pkinit_req_crypto_context reqctx,\n                         pkinit_identity_crypto_context idctx,\n                         krb5_preauthtype pa_type,\n                         int include_certchain,\n                         unsigned char *key_pack,\n                         unsigned int key_pack_len,\n                         unsigned char **out,\n                         unsigned int *out_len)\n{\n\n    krb5_error_code retval = ENOMEM;\n    PKCS7 *p7 = NULL;\n    BIO *in = NULL;\n    unsigned char *p = NULL, *signed_data = NULL, *enc_data = NULL;\n    int signed_data_len = 0, enc_data_len = 0, flags = PKCS7_BINARY;\n    STACK_OF(X509) *encerts = NULL;\n    const EVP_CIPHER *cipher = NULL;\n    int cms_msg_type;\n\n    /* create the PKCS7 SignedData portion of the PKCS7 EnvelopedData */\n    switch ((int)pa_type) {\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n    case KRB5_PADATA_PK_AS_REP_OLD:\n        cms_msg_type = CMS_SIGN_DRAFT9;\n        break;\n    case KRB5_PADATA_PK_AS_REQ:\n        cms_msg_type = CMS_ENVEL_SERVER;\n        break;\n    default:\n        goto cleanup;\n    }\n\n    retval = cms_signeddata_create(context, plgctx, reqctx, idctx,\n                                   cms_msg_type, include_certchain, key_pack, key_pack_len,\n                                   &signed_data, (unsigned int *)&signed_data_len);\n    if (retval) {\n        pkiDebug(\"failed to create pkcs7 signed data\\n\");\n        goto cleanup;\n    }\n\n    /* check we have client's certificate */\n    if (reqctx->received_cert == NULL) {\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        goto cleanup;\n    }\n    encerts = sk_X509_new_null();\n    sk_X509_push(encerts, reqctx->received_cert);\n\n    cipher = EVP_des_ede3_cbc();\n    in = BIO_new(BIO_s_mem());\n    switch (pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        prepare_enc_data(signed_data, signed_data_len, &enc_data,\n                         &enc_data_len);\n        retval = BIO_write(in, enc_data, enc_data_len);\n        if (retval != enc_data_len) {\n            pkiDebug(\"BIO_write only wrote %d\\n\", retval);\n            goto cleanup;\n        }\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        retval = BIO_write(in, signed_data, signed_data_len);\n        if (retval != signed_data_len) {\n            pkiDebug(\"BIO_write only wrote %d\\n\", retval);\n            goto cleanup;\n        }\n        break;\n    default:\n        retval = -1;\n        goto cleanup;\n    }\n\n    p7 = PKCS7_encrypt(encerts, in, cipher, flags);\n    if (p7 == NULL) {\n        retval = oerr(context, 0, _(\"Failed to encrypt PKCS7 object\"));\n        goto cleanup;\n    }\n    switch (pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        p7->d.enveloped->enc_data->content_type =\n            OBJ_nid2obj(NID_pkcs7_signed);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        p7->d.enveloped->enc_data->content_type =\n            OBJ_nid2obj(NID_pkcs7_data);\n        break;\n        break;\n        break;\n        break;\n    }\n\n    *out_len = i2d_PKCS7(p7, NULL);\n    if (!*out_len || (p = *out = malloc(*out_len)) == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    retval = i2d_PKCS7(p7, &p);\n    if (!retval) {\n        retval = oerr(context, 0, _(\"Failed to DER encode PKCS7\"));\n        goto cleanup;\n    }\n    retval = 0;\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(*out, *out_len, \"/tmp/kdc_enveloped_data\");\n#endif\n\ncleanup:\n    if (p7 != NULL)\n        PKCS7_free(p7);\n    if (in != NULL)\n        BIO_free(in);\n    free(signed_data);\n    free(enc_data);\n    if (encerts != NULL)\n        sk_X509_free(encerts);\n\n    return retval;\n}\n\nkrb5_error_code\ncms_envelopeddata_verify(krb5_context context,\n                         pkinit_plg_crypto_context plg_cryptoctx,\n                         pkinit_req_crypto_context req_cryptoctx,\n                         pkinit_identity_crypto_context id_cryptoctx,\n                         krb5_preauthtype pa_type,\n                         int require_crl_checking,\n                         unsigned char *enveloped_data,\n                         unsigned int enveloped_data_len,\n                         unsigned char **data,\n                         unsigned int *data_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7 *p7 = NULL;\n    BIO *out = NULL;\n    int i = 0;\n    unsigned int size = 0;\n    const unsigned char *p = enveloped_data;\n    unsigned int tmp_buf_len = 0, tmp_buf2_len = 0, vfy_buf_len = 0;\n    unsigned char *tmp_buf = NULL, *tmp_buf2 = NULL, *vfy_buf = NULL;\n    int msg_type = 0;\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(enveloped_data, enveloped_data_len,\n                     \"/tmp/client_envelopeddata\");\n#endif\n    /* decode received PKCS7 message */\n    if ((p7 = d2i_PKCS7(NULL, &p, (int)enveloped_data_len)) == NULL) {\n        retval = oerr(context, 0, _(\"Failed to decode PKCS7\"));\n        goto cleanup;\n    }\n\n    /* verify that the received message is PKCS7 EnvelopedData message */\n    if (OBJ_obj2nid(p7->type) != NID_pkcs7_enveloped) {\n        pkiDebug(\"Expected id-enveloped PKCS7 msg (received type = %d)\\n\",\n                 OBJ_obj2nid(p7->type));\n        krb5_set_error_message(context, retval, \"wrong oid\\n\");\n        goto cleanup;\n    }\n\n    /* decrypt received PKCS7 message */\n    out = BIO_new(BIO_s_mem());\n    if (pkcs7_decrypt(context, id_cryptoctx, p7, out)) {\n        pkiDebug(\"PKCS7 decryption successful\\n\");\n    } else {\n        retval = oerr(context, 0, _(\"Failed to decrypt PKCS7 message\"));\n        goto cleanup;\n    }\n\n    /* transfer the decoded PKCS7 SignedData message into a separate buffer */\n    for (;;) {\n        if ((tmp_buf = realloc(tmp_buf, size + 1024 * 10)) == NULL)\n            goto cleanup;\n        i = BIO_read(out, &(tmp_buf[size]), 1024 * 10);\n        if (i <= 0)\n            break;\n        else\n            size += i;\n    }\n    tmp_buf_len = size;\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(tmp_buf, tmp_buf_len, \"/tmp/client_enc_keypack\");\n#endif\n    /* verify PKCS7 SignedData message */\n    switch (pa_type) {\n    case KRB5_PADATA_PK_AS_REP:\n        msg_type = CMS_ENVEL_SERVER;\n\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n        msg_type = CMS_SIGN_DRAFT9;\n        break;\n    default:\n        pkiDebug(\"%s: unrecognized pa_type = %d\\n\", __FUNCTION__, pa_type);\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        goto cleanup;\n    }\n    /*\n     * If this is the RFC style, wrap the signed data to make\n     * decoding easier in the verify routine.\n     * For draft9-compatible, we don't do anything because it\n     * is already wrapped.\n     */\n    if (msg_type == CMS_ENVEL_SERVER) {\n        retval = wrap_signeddata(tmp_buf, tmp_buf_len,\n                                 &tmp_buf2, &tmp_buf2_len);\n        if (retval) {\n            pkiDebug(\"failed to encode signeddata\\n\");\n            goto cleanup;\n        }\n        vfy_buf = tmp_buf2;\n        vfy_buf_len = tmp_buf2_len;\n\n    } else {\n        vfy_buf = tmp_buf;\n        vfy_buf_len = tmp_buf_len;\n    }\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(vfy_buf, vfy_buf_len, \"/tmp/client_enc_keypack2\");\n#endif\n\n    retval = cms_signeddata_verify(context, plg_cryptoctx, req_cryptoctx,\n                                   id_cryptoctx, msg_type,\n                                   require_crl_checking,\n                                   vfy_buf, vfy_buf_len,\n                                   data, data_len, NULL, NULL, NULL);\n\n    if (!retval)\n        pkiDebug(\"PKCS7 Verification Success\\n\");\n    else {\n        pkiDebug(\"PKCS7 Verification Failure\\n\");\n        goto cleanup;\n    }\n\n    retval = 0;\n\ncleanup:\n\n    if (p7 != NULL)\n        PKCS7_free(p7);\n    if (out != NULL)\n        BIO_free(out);\n    free(tmp_buf);\n    free(tmp_buf2);\n\n    return retval;\n}\n\nstatic krb5_error_code\ncrypto_retrieve_X509_sans(krb5_context context,\n                          pkinit_plg_crypto_context plgctx,\n                          pkinit_req_crypto_context reqctx,\n                          X509 *cert,\n                          krb5_principal **princs_ret, char ***upn_ret,\n                          unsigned char ***dns_ret)\n{\n    krb5_error_code retval = EINVAL;\n    char buf[DN_BUF_LEN];\n    int p = 0, u = 0, d = 0, ret = 0, l;\n    krb5_principal *princs = NULL;\n    char **upns = NULL;\n    unsigned char **dnss = NULL;\n    unsigned int i, num_found = 0, num_sans = 0;\n    X509_EXTENSION *ext = NULL;\n    GENERAL_NAMES *ialt = NULL;\n    GENERAL_NAME *gen = NULL;\n\n    if (princs_ret != NULL)\n        *princs_ret = NULL;\n    if (upn_ret != NULL)\n        *upn_ret = NULL;\n    if (dns_ret != NULL)\n        *dns_ret = NULL;\n\n    if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) {\n        pkiDebug(\"%s: nowhere to return any values!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    if (cert == NULL) {\n        pkiDebug(\"%s: no certificate!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    X509_NAME_oneline(X509_get_subject_name(cert),\n                      buf, sizeof(buf));\n    pkiDebug(\"%s: looking for SANs in cert = %s\\n\", __FUNCTION__, buf);\n\n    l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);\n    if (l < 0)\n        return 0;\n\n    if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {\n        pkiDebug(\"%s: found no subject alt name extensions\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n    num_sans = sk_GENERAL_NAME_num(ialt);\n\n    pkiDebug(\"%s: found %d subject alt name extension(s)\\n\", __FUNCTION__,\n             num_sans);\n\n    /* OK, we're likely returning something. Allocate return values */\n    if (princs_ret != NULL) {\n        princs = calloc(num_sans + 1, sizeof(krb5_principal));\n        if (princs == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n    if (upn_ret != NULL) {\n        upns = calloc(num_sans + 1, sizeof(*upns));\n        if (upns == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n    if (dns_ret != NULL) {\n        dnss = calloc(num_sans + 1, sizeof(*dnss));\n        if (dnss == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < num_sans; i++) {\n        krb5_data name = { 0, 0, NULL };\n\n        gen = sk_GENERAL_NAME_value(ialt, i);\n        switch (gen->type) {\n        case GEN_OTHERNAME:\n            name.length = gen->d.otherName->value->value.sequence->length;\n            name.data = (char *)gen->d.otherName->value->value.sequence->data;\n            if (princs != NULL &&\n                OBJ_cmp(plgctx->id_pkinit_san,\n                        gen->d.otherName->type_id) == 0) {\n#ifdef DEBUG_ASN1\n                print_buffer_bin((unsigned char *)name.data, name.length,\n                                 \"/tmp/pkinit_san\");\n#endif\n                ret = k5int_decode_krb5_principal_name(&name, &princs[p]);\n                if (ret) {\n                    pkiDebug(\"%s: failed decoding pkinit san value\\n\",\n                             __FUNCTION__);\n                } else {\n                    p++;\n                    num_found++;\n                }\n            } else if (upns != NULL &&\n                       OBJ_cmp(plgctx->id_ms_san_upn,\n                               gen->d.otherName->type_id) == 0) {\n                /* Prevent abuse of embedded null characters. */\n                if (memchr(name.data, '\\0', name.length))\n                    break;\n                upns[u] = k5memdup0(name.data, name.length, &ret);\n                if (upns[u] == NULL)\n                    goto cleanup;\n            } else {\n                pkiDebug(\"%s: unrecognized othername oid in SAN\\n\",\n                         __FUNCTION__);\n                continue;\n            }\n\n            break;\n        case GEN_DNS:\n            if (dnss != NULL) {\n                /* Prevent abuse of embedded null characters. */\n                if (memchr(gen->d.dNSName->data, '\\0', gen->d.dNSName->length))\n                    break;\n                pkiDebug(\"%s: found dns name = %s\\n\", __FUNCTION__,\n                         gen->d.dNSName->data);\n                dnss[d] = (unsigned char *)\n                    strdup((char *)gen->d.dNSName->data);\n                if (dnss[d] == NULL) {\n                    pkiDebug(\"%s: failed to duplicate dns name\\n\",\n                             __FUNCTION__);\n                } else {\n                    d++;\n                    num_found++;\n                }\n            }\n            break;\n        default:\n            pkiDebug(\"%s: SAN type = %d expecting %d\\n\", __FUNCTION__,\n                     gen->type, GEN_OTHERNAME);\n        }\n    }\n    sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);\n\n    retval = 0;\n    if (princs != NULL && *princs != NULL) {\n        *princs_ret = princs;\n        princs = NULL;\n    }\n    if (upns != NULL && *upns != NULL) {\n        *upn_ret = upns;\n        upns = NULL;\n    }\n    if (dnss != NULL && *dnss != NULL) {\n        *dns_ret = dnss;\n        dnss = NULL;\n    }\n\ncleanup:\n    for (i = 0; princs != NULL && princs[i] != NULL; i++)\n        krb5_free_principal(context, princs[i]);\n    free(princs);\n    for (i = 0; upns != NULL && upns[i] != NULL; i++)\n        free(upns[i]);\n    free(upns);\n    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)\n        free(dnss[i]);\n    free(dnss);\n    return retval;\n}\n\nkrb5_error_code\ncrypto_retrieve_signer_identity(krb5_context context,\n                                pkinit_identity_crypto_context id_cryptoctx,\n                                const char **identity)\n{\n    *identity = id_cryptoctx->identity;\n    if (*identity == NULL)\n        return ENOENT;\n    return 0;\n}\n\nkrb5_error_code\ncrypto_retrieve_cert_sans(krb5_context context,\n                          pkinit_plg_crypto_context plgctx,\n                          pkinit_req_crypto_context reqctx,\n                          pkinit_identity_crypto_context idctx,\n                          krb5_principal **princs_ret, char ***upn_ret,\n                          unsigned char ***dns_ret)\n{\n    krb5_error_code retval = EINVAL;\n\n    if (reqctx->received_cert == NULL) {\n        pkiDebug(\"%s: No certificate!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    return crypto_retrieve_X509_sans(context, plgctx, reqctx,\n                                     reqctx->received_cert, princs_ret,\n                                     upn_ret, dns_ret);\n}\n\nkrb5_error_code\ncrypto_check_cert_eku(krb5_context context,\n                      pkinit_plg_crypto_context plgctx,\n                      pkinit_req_crypto_context reqctx,\n                      pkinit_identity_crypto_context idctx,\n                      int checking_kdc_cert,\n                      int allow_secondary_usage,\n                      int *valid_eku)\n{\n    char buf[DN_BUF_LEN];\n    int found_eku = 0;\n    krb5_error_code retval = EINVAL;\n    int i;\n\n    *valid_eku = 0;\n    if (reqctx->received_cert == NULL)\n        goto cleanup;\n\n    X509_NAME_oneline(X509_get_subject_name(reqctx->received_cert),\n                      buf, sizeof(buf));\n\n    if ((i = X509_get_ext_by_NID(reqctx->received_cert,\n                                 NID_ext_key_usage, -1)) >= 0) {\n        EXTENDED_KEY_USAGE *extusage;\n\n        extusage = X509_get_ext_d2i(reqctx->received_cert, NID_ext_key_usage,\n                                    NULL, NULL);\n        if (extusage) {\n            pkiDebug(\"%s: found eku info in the cert\\n\", __FUNCTION__);\n            for (i = 0; found_eku == 0 && i < sk_ASN1_OBJECT_num(extusage); i++) {\n                ASN1_OBJECT *tmp_oid;\n\n                tmp_oid = sk_ASN1_OBJECT_value(extusage, i);\n                pkiDebug(\"%s: checking eku %d of %d, allow_secondary = %d\\n\",\n                         __FUNCTION__, i+1, sk_ASN1_OBJECT_num(extusage),\n                         allow_secondary_usage);\n                if (checking_kdc_cert) {\n                    if ((OBJ_cmp(tmp_oid, plgctx->id_pkinit_KPKdc) == 0)\n                        || (allow_secondary_usage\n                            && OBJ_cmp(tmp_oid, plgctx->id_kp_serverAuth) == 0))\n                        found_eku = 1;\n                } else {\n                    if ((OBJ_cmp(tmp_oid, plgctx->id_pkinit_KPClientAuth) == 0)\n                        || (allow_secondary_usage\n                            && OBJ_cmp(tmp_oid, plgctx->id_ms_kp_sc_logon) == 0))\n                        found_eku = 1;\n                }\n            }\n        }\n        EXTENDED_KEY_USAGE_free(extusage);\n\n        if (found_eku) {\n            ASN1_BIT_STRING *usage = NULL;\n\n            /* check that digitalSignature KeyUsage is present */\n            X509_check_ca(reqctx->received_cert);\n            if ((usage = X509_get_ext_d2i(reqctx->received_cert,\n                                          NID_key_usage, NULL, NULL))) {\n\n                if (!ku_reject(reqctx->received_cert,\n                               X509v3_KU_DIGITAL_SIGNATURE)) {\n                    TRACE_PKINIT_EKU(context);\n                    *valid_eku = 1;\n                } else\n                    TRACE_PKINIT_EKU_NO_KU(context);\n            }\n            ASN1_BIT_STRING_free(usage);\n        }\n    }\n    retval = 0;\ncleanup:\n    pkiDebug(\"%s: returning retval %d, valid_eku %d\\n\",\n             __FUNCTION__, retval, *valid_eku);\n    return retval;\n}\n\nkrb5_error_code\npkinit_octetstring2key(krb5_context context,\n                       krb5_enctype etype,\n                       unsigned char *key,\n                       unsigned int dh_key_len,\n                       krb5_keyblock *key_block)\n{\n    krb5_error_code retval;\n    unsigned char *buf = NULL;\n    unsigned char md[SHA_DIGEST_LENGTH];\n    unsigned char counter;\n    size_t keybytes, keylength, offset;\n    krb5_data random_data;\n\n    if ((buf = malloc(dh_key_len)) == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    memset(buf, 0, dh_key_len);\n\n    counter = 0;\n    offset = 0;\n    do {\n        SHA_CTX c;\n\n        SHA1_Init(&c);\n        SHA1_Update(&c, &counter, 1);\n        SHA1_Update(&c, key, dh_key_len);\n        SHA1_Final(md, &c);\n\n        if (dh_key_len - offset < sizeof(md))\n            memcpy(buf + offset, md, dh_key_len - offset);\n        else\n            memcpy(buf + offset, md, sizeof(md));\n\n        offset += sizeof(md);\n        counter++;\n    } while (offset < dh_key_len);\n\n    key_block->magic = 0;\n    key_block->enctype = etype;\n\n    retval = krb5_c_keylengths(context, etype, &keybytes, &keylength);\n    if (retval)\n        goto cleanup;\n\n    key_block->length = keylength;\n    key_block->contents = malloc(keylength);\n    if (key_block->contents == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    random_data.length = keybytes;\n    random_data.data = (char *)buf;\n\n    retval = krb5_c_random_to_key(context, etype, &random_data, key_block);\n\ncleanup:\n    free(buf);\n    /* If this is an error return, free the allocated keyblock, if any */\n    if (retval) {\n        krb5_free_keyblock_contents(context, key_block);\n    }\n\n    return retval;\n}\n\n\n/**\n * Given an algorithm_identifier, this function returns the hash length\n * and EVP function associated with that algorithm.\n */\nstatic krb5_error_code\npkinit_alg_values(krb5_context context,\n                  const krb5_data *alg_id,\n                  size_t *hash_bytes,\n                  const EVP_MD *(**func)(void))\n{\n    *hash_bytes = 0;\n    *func = NULL;\n    if ((alg_id->length == krb5_pkinit_sha1_oid_len) &&\n        (0 == memcmp(alg_id->data, &krb5_pkinit_sha1_oid,\n                     krb5_pkinit_sha1_oid_len))) {\n        *hash_bytes = 20;\n        *func = &EVP_sha1;\n        return 0;\n    } else if ((alg_id->length == krb5_pkinit_sha256_oid_len) &&\n               (0 == memcmp(alg_id->data, krb5_pkinit_sha256_oid,\n                            krb5_pkinit_sha256_oid_len))) {\n        *hash_bytes = 32;\n        *func = &EVP_sha256;\n        return 0;\n    } else if ((alg_id->length == krb5_pkinit_sha512_oid_len) &&\n               (0 == memcmp(alg_id->data, krb5_pkinit_sha512_oid,\n                            krb5_pkinit_sha512_oid_len))) {\n        *hash_bytes = 64;\n        *func = &EVP_sha512;\n        return 0;\n    } else {\n        krb5_set_error_message(context, KRB5_ERR_BAD_S2K_PARAMS,\n                               \"Bad algorithm ID passed to PK-INIT KDF.\");\n        return KRB5_ERR_BAD_S2K_PARAMS;\n    }\n} /* pkinit_alg_values() */\n\n\n/* pkinit_alg_agility_kdf() --\n * This function generates a key using the KDF described in\n * draft_ietf_krb_wg_pkinit_alg_agility-04.txt.  The algorithm is\n * described as follows:\n *\n *     1.  reps = keydatalen (K) / hash length (H)\n *\n *     2.  Initialize a 32-bit, big-endian bit string counter as 1.\n *\n *     3.  For i = 1 to reps by 1, do the following:\n *\n *         -  Compute Hashi = H(counter || Z || OtherInfo).\n *\n *         -  Increment counter (modulo 2^32)\n *\n *     4.  Set key = Hash1 || Hash2 || ... so that length of key is K bytes.\n */\nkrb5_error_code\npkinit_alg_agility_kdf(krb5_context context,\n                       krb5_data *secret,\n                       krb5_data *alg_oid,\n                       krb5_const_principal party_u_info,\n                       krb5_const_principal party_v_info,\n                       krb5_enctype enctype,\n                       krb5_data *as_req,\n                       krb5_data *pk_as_rep,\n                       krb5_keyblock *key_block)\n{\n    krb5_error_code retval = 0;\n\n    unsigned int reps = 0;\n    uint32_t counter = 1;       /* Does this type work on Windows? */\n    size_t offset = 0;\n    size_t hash_len = 0;\n    size_t rand_len = 0;\n    size_t key_len = 0;\n    krb5_data random_data;\n    krb5_sp80056a_other_info other_info_fields;\n    krb5_pkinit_supp_pub_info supp_pub_info_fields;\n    krb5_data *other_info = NULL;\n    krb5_data *supp_pub_info = NULL;\n    krb5_algorithm_identifier alg_id;\n    EVP_MD_CTX *ctx = NULL;\n    const EVP_MD *(*EVP_func)(void);\n\n    /* initialize random_data here to make clean-up safe */\n    random_data.length = 0;\n    random_data.data = NULL;\n\n    /* allocate and initialize the key block */\n    key_block->magic = 0;\n    key_block->enctype = enctype;\n    if (0 != (retval = krb5_c_keylengths(context, enctype, &rand_len,\n                                         &key_len)))\n        goto cleanup;\n\n    random_data.length = rand_len;\n    key_block->length = key_len;\n\n    if (NULL == (key_block->contents = malloc(key_block->length))) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    memset (key_block->contents, 0, key_block->length);\n\n    /* If this is anonymous pkinit, use the anonymous principle for party_u_info */\n    if (party_u_info && krb5_principal_compare_any_realm(context, party_u_info,\n                                                         krb5_anonymous_principal()))\n        party_u_info = (krb5_principal)krb5_anonymous_principal();\n\n    if (0 != (retval = pkinit_alg_values(context, alg_oid, &hash_len, &EVP_func)))\n        goto cleanup;\n\n    /* 1.  reps = keydatalen (K) / hash length (H) */\n    reps = key_block->length/hash_len;\n\n    /* ... and round up, if necessary */\n    if (key_block->length > (reps * hash_len))\n        reps++;\n\n    /* Allocate enough space in the random data buffer to hash directly into\n     * it, even if the last hash will make it bigger than the key length. */\n    if (NULL == (random_data.data = malloc(reps * hash_len))) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Encode the ASN.1 octet string for \"SuppPubInfo\" */\n    supp_pub_info_fields.enctype = enctype;\n    supp_pub_info_fields.as_req = *as_req;\n    supp_pub_info_fields.pk_as_rep = *pk_as_rep;\n    if (0 != ((retval = encode_krb5_pkinit_supp_pub_info(&supp_pub_info_fields,\n                                                         &supp_pub_info))))\n        goto cleanup;\n\n    /* Now encode the ASN.1 octet string for \"OtherInfo\" */\n    memset(&alg_id, 0, sizeof alg_id);\n    alg_id.algorithm = *alg_oid; /*alias*/\n\n    other_info_fields.algorithm_identifier = alg_id;\n    other_info_fields.party_u_info = (krb5_principal) party_u_info;\n    other_info_fields.party_v_info = (krb5_principal) party_v_info;\n    other_info_fields.supp_pub_info = *supp_pub_info;\n    if (0 != (retval = encode_krb5_sp80056a_other_info(&other_info_fields, &other_info)))\n        goto cleanup;\n\n    /* 2.  Initialize a 32-bit, big-endian bit string counter as 1.\n     * 3.  For i = 1 to reps by 1, do the following:\n     *     -   Compute Hashi = H(counter || Z || OtherInfo).\n     *     -   Increment counter (modulo 2^32)\n     */\n    for (counter = 1; counter <= reps; counter++) {\n        uint s = 0;\n        uint32_t be_counter = htonl(counter);\n\n        ctx = EVP_MD_CTX_new();\n        if (ctx == NULL) {\n            retval = KRB5_CRYPTO_INTERNAL;\n            goto cleanup;\n        }\n\n        /* -   Compute Hashi = H(counter || Z || OtherInfo). */\n        if (!EVP_DigestInit(ctx, EVP_func())) {\n            krb5_set_error_message(context, KRB5_CRYPTO_INTERNAL,\n                                   \"Call to OpenSSL EVP_DigestInit() returned an error.\");\n            retval = KRB5_CRYPTO_INTERNAL;\n            goto cleanup;\n        }\n\n        if (!EVP_DigestUpdate(ctx, &be_counter, 4) ||\n            !EVP_DigestUpdate(ctx, secret->data, secret->length) ||\n            !EVP_DigestUpdate(ctx, other_info->data, other_info->length)) {\n            krb5_set_error_message(context, KRB5_CRYPTO_INTERNAL,\n                                   \"Call to OpenSSL EVP_DigestUpdate() returned an error.\");\n            retval = KRB5_CRYPTO_INTERNAL;\n            goto cleanup;\n        }\n\n        /* 4.  Set key = Hash1 || Hash2 || ... so that length of key is K bytes. */\n        if (!EVP_DigestFinal(ctx, (uint8_t *)random_data.data + offset, &s)) {\n            krb5_set_error_message(context, KRB5_CRYPTO_INTERNAL,\n                                   \"Call to OpenSSL EVP_DigestUpdate() returned an error.\");\n            retval = KRB5_CRYPTO_INTERNAL;\n            goto cleanup;\n        }\n        offset += s;\n        assert(s == hash_len);\n\n        EVP_MD_CTX_free(ctx);\n        ctx = NULL;\n    }\n\n    retval = krb5_c_random_to_key(context, enctype, &random_data,\n                                  key_block);\n\ncleanup:\n    EVP_MD_CTX_free(ctx);\n\n    /* If this has been an error, free the allocated key_block, if any */\n    if (retval) {\n        krb5_free_keyblock_contents(context, key_block);\n    }\n\n    /* free other allocated resources, either way */\n    if (random_data.data)\n        free(random_data.data);\n    krb5_free_data(context, other_info);\n    krb5_free_data(context, supp_pub_info);\n\n    return retval;\n} /*pkinit_alg_agility_kdf() */\n\n/* Call DH_compute_key() and ensure that we left-pad short results instead of\n * leaving junk bytes at the end of the buffer. */\nstatic void\ncompute_dh(unsigned char *buf, int size, BIGNUM *server_pub_key, DH *dh)\n{\n    int len, pad;\n\n    len = DH_compute_key(buf, server_pub_key, dh);\n    assert(len >= 0 && len <= size);\n    if (len < size) {\n        pad = size - len;\n        memmove(buf + pad, buf, len);\n        memset(buf, 0, pad);\n    }\n}\n\nkrb5_error_code\nclient_create_dh(krb5_context context,\n                 pkinit_plg_crypto_context plg_cryptoctx,\n                 pkinit_req_crypto_context cryptoctx,\n                 pkinit_identity_crypto_context id_cryptoctx,\n                 int dh_size,\n                 unsigned char **dh_params_out,\n                 unsigned int *dh_params_len_out,\n                 unsigned char **dh_pubkey_out,\n                 unsigned int *dh_pubkey_len_out)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    unsigned char *buf = NULL;\n    int dh_err = 0;\n    ASN1_INTEGER *pub_key = NULL;\n    const BIGNUM *pubkey_bn, *p, *q, *g;\n    unsigned char *dh_params = NULL, *dh_pubkey = NULL;\n    unsigned int dh_params_len, dh_pubkey_len;\n\n    *dh_params_out = *dh_pubkey_out = NULL;\n    *dh_params_len_out = *dh_pubkey_len_out = 0;\n\n    if (cryptoctx->dh == NULL) {\n        if (dh_size == 1024)\n            cryptoctx->dh = make_oakley_dh(oakley_1024, sizeof(oakley_1024));\n        else if (dh_size == 2048)\n            cryptoctx->dh = make_oakley_dh(oakley_2048, sizeof(oakley_2048));\n        else if (dh_size == 4096)\n            cryptoctx->dh = make_oakley_dh(oakley_4096, sizeof(oakley_4096));\n        if (cryptoctx->dh == NULL)\n            goto cleanup;\n    }\n\n    DH_generate_key(cryptoctx->dh);\n    DH_get0_key(cryptoctx->dh, &pubkey_bn, NULL);\n\n    DH_check(cryptoctx->dh, &dh_err);\n    if (dh_err != 0) {\n        pkiDebug(\"Warning: dh_check failed with %d\\n\", dh_err);\n        if (dh_err & DH_CHECK_P_NOT_PRIME)\n            pkiDebug(\"p value is not prime\\n\");\n        if (dh_err & DH_CHECK_P_NOT_SAFE_PRIME)\n            pkiDebug(\"p value is not a safe prime\\n\");\n        if (dh_err & DH_UNABLE_TO_CHECK_GENERATOR)\n            pkiDebug(\"unable to check the generator value\\n\");\n        if (dh_err & DH_NOT_SUITABLE_GENERATOR)\n            pkiDebug(\"the g value is not a generator\\n\");\n    }\n#ifdef DEBUG_DH\n    print_dh(cryptoctx->dh, \"client's DH params\\n\");\n    print_pubkey(cryptoctx->dh->pub_key, \"client's pub_key=\");\n#endif\n\n    DH_check_pub_key(cryptoctx->dh, pubkey_bn, &dh_err);\n    if (dh_err != 0) {\n        pkiDebug(\"dh_check_pub_key failed with %d\\n\", dh_err);\n        goto cleanup;\n    }\n\n    /* pack DHparams */\n    /* aglo: usually we could just call i2d_DHparams to encode DH params\n     * however, PKINIT requires RFC3279 encoding and openssl does pkcs#3.\n     */\n    DH_get0_pqg(cryptoctx->dh, &p, &q, &g);\n    retval = pkinit_encode_dh_params(p, g, q, &dh_params, &dh_params_len);\n    if (retval)\n        goto cleanup;\n\n    /* pack DH public key */\n    /* Diffie-Hellman public key must be ASN1 encoded as an INTEGER; this\n     * encoding shall be used as the contents (the value) of the\n     * subjectPublicKey component (a BIT STRING) of the SubjectPublicKeyInfo\n     * data element\n     */\n    pub_key = BN_to_ASN1_INTEGER(pubkey_bn, NULL);\n    if (pub_key == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    dh_pubkey_len = i2d_ASN1_INTEGER(pub_key, NULL);\n    buf = dh_pubkey = malloc(dh_pubkey_len);\n    if (dh_pubkey == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    i2d_ASN1_INTEGER(pub_key, &buf);\n\n    *dh_params_out = dh_params;\n    *dh_params_len_out = dh_params_len;\n    *dh_pubkey_out = dh_pubkey;\n    *dh_pubkey_len_out = dh_pubkey_len;\n    dh_params = dh_pubkey = NULL;\n\n    retval = 0;\n\ncleanup:\n    if (retval) {\n        DH_free(cryptoctx->dh);\n        cryptoctx->dh = NULL;\n    }\n    free(dh_params);\n    free(dh_pubkey);\n    ASN1_INTEGER_free(pub_key);\n    return retval;\n}\n\nkrb5_error_code\nclient_process_dh(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context cryptoctx,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  unsigned char *subjectPublicKey_data,\n                  unsigned int subjectPublicKey_length,\n                  unsigned char **client_key_out,\n                  unsigned int *client_key_len_out)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    BIGNUM *server_pub_key = NULL;\n    ASN1_INTEGER *pub_key = NULL;\n    unsigned char *client_key = NULL;\n    unsigned int client_key_len;\n    const unsigned char *p = NULL;\n\n    *client_key_out = NULL;\n    *client_key_len_out = 0;\n\n    client_key_len = DH_size(cryptoctx->dh);\n    client_key = malloc(client_key_len);\n    if (client_key == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    p = subjectPublicKey_data;\n    pub_key = d2i_ASN1_INTEGER(NULL, &p, (long)subjectPublicKey_length);\n    if (pub_key == NULL)\n        goto cleanup;\n    if ((server_pub_key = ASN1_INTEGER_to_BN(pub_key, NULL)) == NULL)\n        goto cleanup;\n\n    compute_dh(client_key, client_key_len, server_pub_key, cryptoctx->dh);\n#ifdef DEBUG_DH\n    print_pubkey(server_pub_key, \"server's pub_key=\");\n    pkiDebug(\"client computed key (%d)= \", client_key_len);\n    print_buffer(client_key, client_key_len);\n#endif\n\n    *client_key_out = client_key;\n    *client_key_len_out = client_key_len;\n    client_key = NULL;\n\n    retval = 0;\n\ncleanup:\n    BN_free(server_pub_key);\n    ASN1_INTEGER_free(pub_key);\n    free(client_key);\n    return retval;\n}\n\n/* Return 1 if dh is a permitted well-known group, otherwise return 0. */\nstatic int\ncheck_dh_wellknown(pkinit_plg_crypto_context cryptoctx, DH *dh, int nbits)\n{\n\n    switch (nbits) {\n    case 1024:\n        /* Oakley MODP group 2 */\n        if (pkinit_check_dh_params(cryptoctx->dh_1024, dh) == 0)\n            return 1;\n        break;\n\n    case 2048:\n        /* Oakley MODP group 14 */\n        if (pkinit_check_dh_params(cryptoctx->dh_2048, dh) == 0)\n            return 1;\n        break;\n\n    case 4096:\n        /* Oakley MODP group 16 */\n        if (pkinit_check_dh_params(cryptoctx->dh_4096, dh) == 0)\n            return 1;\n        break;\n\n    default:\n        break;\n    }\n    return 0;\n}\n\nkrb5_error_code\nserver_check_dh(krb5_context context,\n                pkinit_plg_crypto_context cryptoctx,\n                pkinit_req_crypto_context req_cryptoctx,\n                pkinit_identity_crypto_context id_cryptoctx,\n                krb5_data *dh_params,\n                int minbits)\n{\n    DH *dh = NULL;\n    const BIGNUM *p;\n    int dh_prime_bits;\n    krb5_error_code retval = KRB5KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n\n    dh = decode_dh_params((uint8_t *)dh_params->data, dh_params->length);\n    if (dh == NULL) {\n        pkiDebug(\"failed to decode dhparams\\n\");\n        goto cleanup;\n    }\n\n    /* KDC SHOULD check to see if the key parameters satisfy its policy */\n    DH_get0_pqg(dh, &p, NULL, NULL);\n    dh_prime_bits = BN_num_bits(p);\n    if (minbits && dh_prime_bits < minbits) {\n        pkiDebug(\"client sent dh params with %d bits, we require %d\\n\",\n                 dh_prime_bits, minbits);\n        goto cleanup;\n    }\n\n    if (check_dh_wellknown(cryptoctx, dh, dh_prime_bits))\n        retval = 0;\n\ncleanup:\n    if (retval == 0)\n        req_cryptoctx->dh = dh;\n    else\n        DH_free(dh);\n\n    return retval;\n}\n\n/* Duplicate a DH handle (parameters only, not public or private key). */\nstatic DH *\ndup_dh_params(const DH *src)\n{\n    const BIGNUM *oldp, *oldq, *oldg;\n    BIGNUM *p = NULL, *q = NULL, *g = NULL;\n    DH *dh;\n\n    DH_get0_pqg(src, &oldp, &oldq, &oldg);\n    p = BN_dup(oldp);\n    q = BN_dup(oldq);\n    g = BN_dup(oldg);\n    dh = DH_new();\n    if (p == NULL || q == NULL || g == NULL || dh == NULL) {\n        BN_free(p);\n        BN_free(q);\n        BN_free(g);\n        DH_free(dh);\n        return NULL;\n    }\n    DH_set0_pqg(dh, p, q, g);\n    return dh;\n}\n\n/* kdc's dh function */\nkrb5_error_code\nserver_process_dh(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context cryptoctx,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  unsigned char *data,\n                  unsigned int data_len,\n                  unsigned char **dh_pubkey_out,\n                  unsigned int *dh_pubkey_len_out,\n                  unsigned char **server_key_out,\n                  unsigned int *server_key_len_out)\n{\n    krb5_error_code retval = ENOMEM;\n    DH *dh = NULL, *dh_server = NULL;\n    unsigned char *p = NULL;\n    ASN1_INTEGER *pub_key = NULL;\n    BIGNUM *client_pubkey = NULL;\n    const BIGNUM *server_pubkey;\n    unsigned char *dh_pubkey = NULL, *server_key = NULL;\n    unsigned int dh_pubkey_len = 0, server_key_len = 0;\n\n    *dh_pubkey_out = *server_key_out = NULL;\n    *dh_pubkey_len_out = *server_key_len_out = 0;\n\n    /* get client's received DH parameters that we saved in server_check_dh */\n    dh = cryptoctx->dh;\n    dh_server = dup_dh_params(dh);\n    if (dh_server == NULL)\n        goto cleanup;\n\n    /* decode client's public key */\n    p = data;\n    pub_key = d2i_ASN1_INTEGER(NULL, (const unsigned char **)&p, (int)data_len);\n    if (pub_key == NULL)\n        goto cleanup;\n    client_pubkey = ASN1_INTEGER_to_BN(pub_key, NULL);\n    if (client_pubkey == NULL)\n        goto cleanup;\n    ASN1_INTEGER_free(pub_key);\n\n    if (!DH_generate_key(dh_server))\n        goto cleanup;\n    DH_get0_key(dh_server, &server_pubkey, NULL);\n\n    /* generate DH session key */\n    server_key_len = DH_size(dh_server);\n    server_key = malloc(server_key_len);\n    if (server_key == NULL)\n        goto cleanup;\n    compute_dh(server_key, server_key_len, client_pubkey, dh_server);\n\n#ifdef DEBUG_DH\n    print_dh(dh_server, \"client&server's DH params\\n\");\n    print_pubkey(client_pubkey, \"client's pub_key=\");\n    print_pubkey(server_pubkey, \"server's pub_key=\");\n    pkiDebug(\"server computed key=\");\n    print_buffer(server_key, server_key_len);\n#endif\n\n    /* KDC reply */\n    /* pack DH public key */\n    /* Diffie-Hellman public key must be ASN1 encoded as an INTEGER; this\n     * encoding shall be used as the contents (the value) of the\n     * subjectPublicKey component (a BIT STRING) of the SubjectPublicKeyInfo\n     * data element\n     */\n    pub_key = BN_to_ASN1_INTEGER(server_pubkey, NULL);\n    if (pub_key == NULL)\n        goto cleanup;\n    dh_pubkey_len = i2d_ASN1_INTEGER(pub_key, NULL);\n    p = dh_pubkey = malloc(dh_pubkey_len);\n    if (dh_pubkey == NULL)\n        goto cleanup;\n    i2d_ASN1_INTEGER(pub_key, &p);\n    if (pub_key != NULL)\n        ASN1_INTEGER_free(pub_key);\n\n    *dh_pubkey_out = dh_pubkey;\n    *dh_pubkey_len_out = dh_pubkey_len;\n    *server_key_out = server_key;\n    *server_key_len_out = server_key_len;\n    dh_pubkey = server_key = NULL;\n\n    retval = 0;\n\ncleanup:\n    BN_free(client_pubkey);\n    DH_free(dh_server);\n    free(dh_pubkey);\n    free(server_key);\n\n    return retval;\n}\n\nint\npkinit_openssl_init()\n{\n    /* Initialize OpenSSL. */\n    ERR_load_crypto_strings();\n    OpenSSL_add_all_algorithms();\n    return 0;\n}\n\nstatic krb5_error_code\npkinit_encode_dh_params(const BIGNUM *p, const BIGNUM *g, const BIGNUM *q,\n                        uint8_t **buf, unsigned int *buf_len)\n{\n    krb5_error_code retval = ENOMEM;\n    int bufsize = 0, r = 0;\n    unsigned char *tmp = NULL;\n    ASN1_INTEGER *ap = NULL, *ag = NULL, *aq = NULL;\n\n    if ((ap = BN_to_ASN1_INTEGER(p, NULL)) == NULL)\n        goto cleanup;\n    if ((ag = BN_to_ASN1_INTEGER(g, NULL)) == NULL)\n        goto cleanup;\n    if ((aq = BN_to_ASN1_INTEGER(q, NULL)) == NULL)\n        goto cleanup;\n    bufsize = i2d_ASN1_INTEGER(ap, NULL);\n    bufsize += i2d_ASN1_INTEGER(ag, NULL);\n    bufsize += i2d_ASN1_INTEGER(aq, NULL);\n\n    r = ASN1_object_size(1, bufsize, V_ASN1_SEQUENCE);\n\n    tmp = *buf = malloc((size_t) r);\n    if (tmp == NULL)\n        goto cleanup;\n\n    ASN1_put_object(&tmp, 1, bufsize, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n\n    i2d_ASN1_INTEGER(ap, &tmp);\n    i2d_ASN1_INTEGER(ag, &tmp);\n    i2d_ASN1_INTEGER(aq, &tmp);\n\n    *buf_len = r;\n\n    retval = 0;\n\ncleanup:\n    if (ap != NULL)\n        ASN1_INTEGER_free(ap);\n    if (ag != NULL)\n        ASN1_INTEGER_free(ag);\n    if (aq != NULL)\n        ASN1_INTEGER_free(aq);\n\n    return retval;\n}\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\n/*\n * We need to decode DomainParameters from RFC 3279 section 2.3.3.  We would\n * like to just call d2i_DHxparams(), but Microsoft's implementation may omit\n * the q value in violation of the RFC.  Instead we must copy the internal\n * structures and sequence declarations from dh_asn1.c, modified to make the q\n * field optional.\n */\n\ntypedef struct {\n    ASN1_BIT_STRING *seed;\n    BIGNUM *counter;\n} int_dhvparams;\n\ntypedef struct {\n    BIGNUM *p;\n    BIGNUM *q;\n    BIGNUM *g;\n    BIGNUM *j;\n    int_dhvparams *vparams;\n} int_dhx942_dh;\n\nASN1_SEQUENCE(DHvparams) = {\n    ASN1_SIMPLE(int_dhvparams, seed, ASN1_BIT_STRING),\n    ASN1_SIMPLE(int_dhvparams, counter, BIGNUM)\n} static_ASN1_SEQUENCE_END_name(int_dhvparams, DHvparams)\n\nASN1_SEQUENCE(DHxparams) = {\n    ASN1_SIMPLE(int_dhx942_dh, p, BIGNUM),\n    ASN1_SIMPLE(int_dhx942_dh, g, BIGNUM),\n    ASN1_OPT(int_dhx942_dh, q, BIGNUM),\n    ASN1_OPT(int_dhx942_dh, j, BIGNUM),\n    ASN1_OPT(int_dhx942_dh, vparams, DHvparams),\n} static_ASN1_SEQUENCE_END_name(int_dhx942_dh, DHxparams)\n\nstatic DH *\ndecode_dh_params(const uint8_t *p, unsigned int len)\n{\n    int_dhx942_dh *params;\n    DH *dh;\n\n    dh = DH_new();\n    if (dh == NULL)\n        return NULL;\n\n    params = (int_dhx942_dh *)ASN1_item_d2i(NULL, &p, len,\n                                            ASN1_ITEM_rptr(DHxparams));\n    if (params == NULL) {\n        DH_free(dh);\n        return NULL;\n    }\n\n    /* Steal the p, q, and g values from dhparams for dh.  Ignore j and\n     * vparams. */\n    DH_set0_pqg(dh, params->p, params->q, params->g);\n    params->p = params->q = params->g = NULL;\n    ASN1_item_free((ASN1_VALUE *)params, ASN1_ITEM_rptr(DHxparams));\n    return dh;\n}\n\n#else /* OPENSSL_VERSION_NUMBER < 0x10100000L */\n\n/*\n * Do the same decoding (except without decoding j and vparams or checking the\n * sequence length) using the pre-OpenSSL-1.1 asn1_mac.h.  Define an internal\n * function in the form demanded by the macros, then wrap it for caller\n * convenience.\n */\n\nstatic DH *\ndecode_dh_params_int(DH ** a, uint8_t **pp, unsigned int len)\n{\n    ASN1_INTEGER ai, *aip = NULL;\n    long length = (long) len;\n\n    M_ASN1_D2I_vars(a, DH *, DH_new);\n\n    M_ASN1_D2I_Init();\n    M_ASN1_D2I_start_sequence();\n    aip = &ai;\n    ai.data = NULL;\n    ai.length = 0;\n    M_ASN1_D2I_get_x(ASN1_INTEGER, aip, d2i_ASN1_INTEGER);\n    if (aip == NULL)\n        return NULL;\n    else {\n        ret->p = ASN1_INTEGER_to_BN(aip, NULL);\n        if (ret->p == NULL)\n            return NULL;\n        if (ai.data != NULL) {\n            OPENSSL_free(ai.data);\n            ai.data = NULL;\n            ai.length = 0;\n        }\n    }\n    M_ASN1_D2I_get_x(ASN1_INTEGER, aip, d2i_ASN1_INTEGER);\n    if (aip == NULL)\n        return NULL;\n    else {\n        ret->g = ASN1_INTEGER_to_BN(aip, NULL);\n        if (ret->g == NULL)\n            return NULL;\n        if (ai.data != NULL) {\n            OPENSSL_free(ai.data);\n            ai.data = NULL;\n            ai.length = 0;\n        }\n\n    }\n    M_ASN1_D2I_get_opt(aip, d2i_ASN1_INTEGER, V_ASN1_INTEGER);\n    if (aip == NULL || ai.data == NULL)\n        ret->q = NULL;\n    else {\n        ret->q = ASN1_INTEGER_to_BN(aip, NULL);\n        if (ret->q == NULL)\n            return NULL;\n        if (ai.data != NULL) {\n            OPENSSL_free(ai.data);\n            ai.data = NULL;\n            ai.length = 0;\n        }\n\n    }\n    M_ASN1_D2I_end_sequence();\n    M_ASN1_D2I_Finish(a, DH_free, 0);\n\n}\n\nstatic DH *\ndecode_dh_params(const uint8_t *p, unsigned int len)\n{\n    uint8_t *ptr = (uint8_t *)p;\n\n    return decode_dh_params_int(NULL, &ptr, len);\n}\n\n#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */\n\nstatic krb5_error_code\npkinit_create_sequence_of_principal_identifiers(\n    krb5_context context,\n    pkinit_plg_crypto_context plg_cryptoctx,\n    pkinit_req_crypto_context req_cryptoctx,\n    pkinit_identity_crypto_context id_cryptoctx,\n    int type,\n    krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = KRB5KRB_ERR_GENERIC;\n    krb5_external_principal_identifier **krb5_trusted_certifiers = NULL;\n    krb5_data *td_certifiers = NULL;\n    krb5_pa_data **pa_data = NULL;\n\n    switch(type) {\n    case TD_TRUSTED_CERTIFIERS:\n        retval = create_krb5_trustedCertifiers(context, plg_cryptoctx,\n                                               req_cryptoctx, id_cryptoctx, &krb5_trusted_certifiers);\n        if (retval) {\n            pkiDebug(\"create_krb5_trustedCertifiers failed\\n\");\n            goto cleanup;\n        }\n        break;\n    case TD_INVALID_CERTIFICATES:\n        retval = create_krb5_invalidCertificates(context, plg_cryptoctx,\n                                                 req_cryptoctx, id_cryptoctx, &krb5_trusted_certifiers);\n        if (retval) {\n            pkiDebug(\"create_krb5_invalidCertificates failed\\n\");\n            goto cleanup;\n        }\n        break;\n    default:\n        retval = -1;\n        goto cleanup;\n    }\n\n    retval = k5int_encode_krb5_td_trusted_certifiers((krb5_external_principal_identifier *const *)krb5_trusted_certifiers, &td_certifiers);\n    if (retval) {\n        pkiDebug(\"encode_krb5_td_trusted_certifiers failed\\n\");\n        goto cleanup;\n    }\n#ifdef DEBUG_ASN1\n    print_buffer_bin((unsigned char *)td_certifiers->data,\n                     td_certifiers->length, \"/tmp/kdc_td_certifiers\");\n#endif\n    pa_data = malloc(2 * sizeof(krb5_pa_data *));\n    if (pa_data == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[1] = NULL;\n    pa_data[0] = malloc(sizeof(krb5_pa_data));\n    if (pa_data[0] == NULL) {\n        free(pa_data);\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[0]->pa_type = type;\n    pa_data[0]->length = td_certifiers->length;\n    pa_data[0]->contents = (krb5_octet *)td_certifiers->data;\n    *e_data_out = pa_data;\n    retval = 0;\n\ncleanup:\n    if (krb5_trusted_certifiers != NULL)\n        free_krb5_external_principal_identifier(&krb5_trusted_certifiers);\n    free(td_certifiers);\n    return retval;\n}\n\nkrb5_error_code\npkinit_create_td_trusted_certifiers(krb5_context context,\n                                    pkinit_plg_crypto_context plg_cryptoctx,\n                                    pkinit_req_crypto_context req_cryptoctx,\n                                    pkinit_identity_crypto_context id_cryptoctx,\n                                    krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = KRB5KRB_ERR_GENERIC;\n\n    retval = pkinit_create_sequence_of_principal_identifiers(context,\n                                                             plg_cryptoctx, req_cryptoctx, id_cryptoctx,\n                                                             TD_TRUSTED_CERTIFIERS, e_data_out);\n\n    return retval;\n}\n\nkrb5_error_code\npkinit_create_td_invalid_certificate(\n    krb5_context context,\n    pkinit_plg_crypto_context plg_cryptoctx,\n    pkinit_req_crypto_context req_cryptoctx,\n    pkinit_identity_crypto_context id_cryptoctx,\n    krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = KRB5KRB_ERR_GENERIC;\n\n    retval = pkinit_create_sequence_of_principal_identifiers(context,\n                                                             plg_cryptoctx, req_cryptoctx, id_cryptoctx,\n                                                             TD_INVALID_CERTIFICATES, e_data_out);\n\n    return retval;\n}\n\nkrb5_error_code\npkinit_create_td_dh_parameters(krb5_context context,\n                               pkinit_plg_crypto_context plg_cryptoctx,\n                               pkinit_req_crypto_context req_cryptoctx,\n                               pkinit_identity_crypto_context id_cryptoctx,\n                               pkinit_plg_opts *opts,\n                               krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = ENOMEM;\n    unsigned int buf1_len = 0, buf2_len = 0, buf3_len = 0, i = 0;\n    unsigned char *buf1 = NULL, *buf2 = NULL, *buf3 = NULL;\n    krb5_pa_data **pa_data = NULL;\n    krb5_data *encoded_algId = NULL;\n    krb5_algorithm_identifier **algId = NULL;\n    const BIGNUM *p, *q, *g;\n\n    if (opts->dh_min_bits > 4096)\n        goto cleanup;\n\n    if (opts->dh_min_bits <= 1024) {\n        DH_get0_pqg(plg_cryptoctx->dh_1024, &p, &q, &g);\n        retval = pkinit_encode_dh_params(p, g, q, &buf1, &buf1_len);\n        if (retval)\n            goto cleanup;\n    }\n    if (opts->dh_min_bits <= 2048) {\n        DH_get0_pqg(plg_cryptoctx->dh_2048, &p, &q, &g);\n        retval = pkinit_encode_dh_params(p, g, q, &buf2, &buf2_len);\n        if (retval)\n            goto cleanup;\n    }\n    DH_get0_pqg(plg_cryptoctx->dh_4096, &p, &q, &g);\n    retval = pkinit_encode_dh_params(p, g, q, &buf3, &buf3_len);\n    if (retval)\n        goto cleanup;\n\n    if (opts->dh_min_bits <= 1024) {\n        algId = malloc(4 * sizeof(krb5_algorithm_identifier *));\n        if (algId == NULL)\n            goto cleanup;\n        algId[3] = NULL;\n        algId[0] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[0] == NULL)\n            goto cleanup;\n        algId[0]->parameters.data = malloc(buf2_len);\n        if (algId[0]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[0]->parameters.data, buf2, buf2_len);\n        algId[0]->parameters.length = buf2_len;\n        algId[0]->algorithm = dh_oid;\n\n        algId[1] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[1] == NULL)\n            goto cleanup;\n        algId[1]->parameters.data = malloc(buf3_len);\n        if (algId[1]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[1]->parameters.data, buf3, buf3_len);\n        algId[1]->parameters.length = buf3_len;\n        algId[1]->algorithm = dh_oid;\n\n        algId[2] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[2] == NULL)\n            goto cleanup;\n        algId[2]->parameters.data = malloc(buf1_len);\n        if (algId[2]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[2]->parameters.data, buf1, buf1_len);\n        algId[2]->parameters.length = buf1_len;\n        algId[2]->algorithm = dh_oid;\n\n    } else if (opts->dh_min_bits <= 2048) {\n        algId = malloc(3 * sizeof(krb5_algorithm_identifier *));\n        if (algId == NULL)\n            goto cleanup;\n        algId[2] = NULL;\n        algId[0] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[0] == NULL)\n            goto cleanup;\n        algId[0]->parameters.data = malloc(buf2_len);\n        if (algId[0]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[0]->parameters.data, buf2, buf2_len);\n        algId[0]->parameters.length = buf2_len;\n        algId[0]->algorithm = dh_oid;\n\n        algId[1] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[1] == NULL)\n            goto cleanup;\n        algId[1]->parameters.data = malloc(buf3_len);\n        if (algId[1]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[1]->parameters.data, buf3, buf3_len);\n        algId[1]->parameters.length = buf3_len;\n        algId[1]->algorithm = dh_oid;\n\n    } else if (opts->dh_min_bits <= 4096) {\n        algId = malloc(2 * sizeof(krb5_algorithm_identifier *));\n        if (algId == NULL)\n            goto cleanup;\n        algId[1] = NULL;\n        algId[0] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[0] == NULL)\n            goto cleanup;\n        algId[0]->parameters.data = malloc(buf3_len);\n        if (algId[0]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[0]->parameters.data, buf3, buf3_len);\n        algId[0]->parameters.length = buf3_len;\n        algId[0]->algorithm = dh_oid;\n\n    }\n    retval = k5int_encode_krb5_td_dh_parameters((krb5_algorithm_identifier *const *)algId, &encoded_algId);\n    if (retval)\n        goto cleanup;\n#ifdef DEBUG_ASN1\n    print_buffer_bin((unsigned char *)encoded_algId->data,\n                     encoded_algId->length, \"/tmp/kdc_td_dh_params\");\n#endif\n    pa_data = malloc(2 * sizeof(krb5_pa_data *));\n    if (pa_data == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[1] = NULL;\n    pa_data[0] = malloc(sizeof(krb5_pa_data));\n    if (pa_data[0] == NULL) {\n        free(pa_data);\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[0]->pa_type = TD_DH_PARAMETERS;\n    pa_data[0]->length = encoded_algId->length;\n    pa_data[0]->contents = (krb5_octet *)encoded_algId->data;\n    *e_data_out = pa_data;\n    retval = 0;\ncleanup:\n\n    free(buf1);\n    free(buf2);\n    free(buf3);\n    free(encoded_algId);\n\n    if (algId != NULL) {\n        while(algId[i] != NULL) {\n            free(algId[i]->parameters.data);\n            free(algId[i]);\n            i++;\n        }\n        free(algId);\n    }\n\n    return retval;\n}\n\nkrb5_error_code\npkinit_check_kdc_pkid(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *pdid_buf,\n                      unsigned int pkid_len,\n                      int *valid_kdcPkId)\n{\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    const unsigned char *p = pdid_buf;\n    int status = 1;\n    X509 *kdc_cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n\n    *valid_kdcPkId = 0;\n    pkiDebug(\"found kdcPkId in AS REQ\\n\");\n    is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);\n    if (is == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);\n    if (!status) {\n        status = ASN1_INTEGER_cmp(X509_get_serialNumber(kdc_cert), is->serial);\n        if (!status)\n            *valid_kdcPkId = 1;\n    }\n\n    X509_NAME_free(is->issuer);\n    ASN1_INTEGER_free(is->serial);\n    free(is);\n\n    return 0;\n}\n\n/* Check parameters against a well-known DH group. */\nstatic int\npkinit_check_dh_params(DH *dh1, DH *dh2)\n{\n    const BIGNUM *p1, *p2, *g1, *g2;\n\n    DH_get0_pqg(dh1, &p1, NULL, &g1);\n    DH_get0_pqg(dh2, &p2, NULL, &g2);\n    if (BN_cmp(p1, p2) != 0) {\n        pkiDebug(\"p is not well-known group dhparameter\\n\");\n        return -1;\n    }\n    if (BN_cmp(g1, g2) != 0) {\n        pkiDebug(\"bad g dhparameter\\n\");\n        return -1;\n    }\n    pkiDebug(\"good %d dhparams\\n\", BN_num_bits(p1));\n    return 0;\n}\n\nkrb5_error_code\npkinit_process_td_dh_params(krb5_context context,\n                            pkinit_plg_crypto_context cryptoctx,\n                            pkinit_req_crypto_context req_cryptoctx,\n                            pkinit_identity_crypto_context id_cryptoctx,\n                            krb5_algorithm_identifier **algId,\n                            int *new_dh_size)\n{\n    krb5_error_code retval = KRB5KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n    int i = 0, use_sent_dh = 0, ok = 0;\n\n    pkiDebug(\"dh parameters\\n\");\n\n    while (algId[i] != NULL) {\n        DH *dh = NULL;\n        const BIGNUM *p;\n        int dh_prime_bits = 0;\n\n        if (algId[i]->algorithm.length != dh_oid.length ||\n            memcmp(algId[i]->algorithm.data, dh_oid.data, dh_oid.length))\n            goto cleanup;\n\n        dh = decode_dh_params((uint8_t *)algId[i]->parameters.data,\n                              algId[i]->parameters.length);\n        if (dh == NULL)\n            goto cleanup;\n        DH_get0_pqg(dh, &p, NULL, NULL);\n        dh_prime_bits = BN_num_bits(p);\n        pkiDebug(\"client sent %d DH bits server prefers %d DH bits\\n\",\n                 *new_dh_size, dh_prime_bits);\n        ok = check_dh_wellknown(cryptoctx, dh, dh_prime_bits);\n        if (ok) {\n            *new_dh_size = dh_prime_bits;\n        }\n        if (!ok) {\n            DH_check(dh, &retval);\n            if (retval != 0) {\n                pkiDebug(\"DH parameters provided by server are unacceptable\\n\");\n                retval = KRB5KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n            }\n            else {\n                use_sent_dh = 1;\n                ok = 1;\n            }\n        }\n        if (!use_sent_dh)\n            DH_free(dh);\n        if (ok) {\n            if (req_cryptoctx->dh != NULL) {\n                DH_free(req_cryptoctx->dh);\n                req_cryptoctx->dh = NULL;\n            }\n            if (use_sent_dh)\n                req_cryptoctx->dh = dh;\n            break;\n        }\n        i++;\n    }\n\n    if (ok)\n        retval = 0;\n\ncleanup:\n    return retval;\n}\n\nstatic int\nopenssl_callback(int ok, X509_STORE_CTX * ctx)\n{\n#ifdef DEBUG\n    if (!ok) {\n        X509 *cert = X509_STORE_CTX_get_current_cert(ctx);\n        int err = X509_STORE_CTX_get_error(ctx);\n        const char *errmsg = X509_verify_cert_error_string(err);\n        char buf[DN_BUF_LEN];\n\n        X509_NAME_oneline(X509_get_subject_name(cert), buf, sizeof(buf));\n        pkiDebug(\"cert = %s\\n\", buf);\n        pkiDebug(\"callback function: %d (%s)\\n\", err, errmsg);\n    }\n#endif\n    return ok;\n}\n\nstatic int\nopenssl_callback_ignore_crls(int ok, X509_STORE_CTX * ctx)\n{\n    if (ok)\n        return ok;\n    return X509_STORE_CTX_get_error(ctx) == X509_V_ERR_UNABLE_TO_GET_CRL;\n}\n\nstatic ASN1_OBJECT *\npkinit_pkcs7type2oid(pkinit_plg_crypto_context cryptoctx, int pkcs7_type)\n{\n    switch (pkcs7_type) {\n    case CMS_SIGN_CLIENT:\n        return cryptoctx->id_pkinit_authData;\n    case CMS_SIGN_DRAFT9:\n        return OBJ_nid2obj(NID_pkcs7_data);\n    case CMS_SIGN_SERVER:\n        return cryptoctx->id_pkinit_DHKeyData;\n    case CMS_ENVEL_SERVER:\n        return cryptoctx->id_pkinit_rkeyData;\n    default:\n        return NULL;\n    }\n\n}\n\nstatic int\nwrap_signeddata(unsigned char *data, unsigned int data_len,\n                unsigned char **out, unsigned int *out_len)\n{\n\n    unsigned int orig_len = 0, oid_len = 0, tot_len = 0;\n    ASN1_OBJECT *oid = NULL;\n    unsigned char *p = NULL;\n\n    /* Get length to wrap the original data with SEQUENCE tag */\n    tot_len = orig_len = ASN1_object_size(1, (int)data_len, V_ASN1_SEQUENCE);\n\n    /* Add the signedData OID and adjust lengths */\n    oid = OBJ_nid2obj(NID_pkcs7_signed);\n    oid_len = i2d_ASN1_OBJECT(oid, NULL);\n\n    tot_len = ASN1_object_size(1, (int)(orig_len+oid_len), V_ASN1_SEQUENCE);\n\n    p = *out = malloc(tot_len);\n    if (p == NULL) return -1;\n\n    ASN1_put_object(&p, 1, (int)(orig_len+oid_len),\n                    V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n\n    i2d_ASN1_OBJECT(oid, &p);\n\n    ASN1_put_object(&p, 1, (int)data_len, 0, V_ASN1_CONTEXT_SPECIFIC);\n    memcpy(p, data, data_len);\n\n    *out_len = tot_len;\n\n    return 0;\n}\n\nstatic int\nprepare_enc_data(const uint8_t *indata, int indata_len, uint8_t **outdata,\n                 int *outdata_len)\n{\n    int tag, class;\n    long tlen, slen;\n    const uint8_t *p = indata, *oldp;\n\n    if (ASN1_get_object(&p, &slen, &tag, &class, indata_len) & 0x80)\n        return EINVAL;\n    if (tag != V_ASN1_SEQUENCE)\n        return EINVAL;\n\n    oldp = p;\n    if (ASN1_get_object(&p, &tlen, &tag, &class, slen) & 0x80)\n        return EINVAL;\n    p += tlen;\n    slen -= (p - oldp);\n\n    if (ASN1_get_object(&p, &tlen, &tag, &class, slen) & 0x80)\n        return EINVAL;\n\n    *outdata = malloc(tlen);\n    if (*outdata == NULL)\n        return ENOMEM;\n    memcpy(*outdata, p, tlen);\n    *outdata_len = tlen;\n    return 0;\n}\n\n#ifndef WITHOUT_PKCS11\nstatic void *\npkinit_C_LoadModule(const char *modname, CK_FUNCTION_LIST_PTR_PTR p11p)\n{\n    void *handle;\n    CK_RV (*getflist)(CK_FUNCTION_LIST_PTR_PTR);\n\n    pkiDebug(\"loading module \\\"%s\\\"... \", modname);\n    handle = dlopen(modname, RTLD_NOW);\n    if (handle == NULL) {\n        pkiDebug(\"not found\\n\");\n        return NULL;\n    }\n    getflist = (CK_RV (*)(CK_FUNCTION_LIST_PTR_PTR)) dlsym(handle, \"C_GetFunctionList\");\n    if (getflist == NULL || (*getflist)(p11p) != CKR_OK) {\n        dlclose(handle);\n        pkiDebug(\"failed\\n\");\n        return NULL;\n    }\n    pkiDebug(\"ok\\n\");\n    return handle;\n}\n\nstatic CK_RV\npkinit_C_UnloadModule(void *handle)\n{\n    dlclose(handle);\n    return CKR_OK;\n}\n\nstatic krb5_error_code\npkinit_login(krb5_context context,\n             pkinit_identity_crypto_context id_cryptoctx,\n             CK_TOKEN_INFO *tip, const char *password)\n{\n    krb5_data rdat;\n    char *prompt;\n    const char *warning;\n    krb5_prompt kprompt;\n    krb5_prompt_type prompt_type;\n    int r = 0;\n\n    if (tip->flags & CKF_PROTECTED_AUTHENTICATION_PATH) {\n        rdat.data = NULL;\n        rdat.length = 0;\n    } else if (password != NULL) {\n        rdat.data = strdup(password);\n        rdat.length = strlen(password);\n    } else if (id_cryptoctx->prompter == NULL) {\n        r = KRB5_LIBOS_CANTREADPWD;\n        rdat.data = NULL;\n    } else {\n        if (tip->flags & CKF_USER_PIN_LOCKED)\n            warning = \" (Warning: PIN locked)\";\n        else if (tip->flags & CKF_USER_PIN_FINAL_TRY)\n            warning = \" (Warning: PIN final try)\";\n        else if (tip->flags & CKF_USER_PIN_COUNT_LOW)\n            warning = \" (Warning: PIN count low)\";\n        else\n            warning = \"\";\n        if (asprintf(&prompt, \"%.*s PIN%s\", (int) sizeof (tip->label),\n                     tip->label, warning) < 0)\n            return ENOMEM;\n        rdat.data = malloc(tip->ulMaxPinLen + 2);\n        rdat.length = tip->ulMaxPinLen + 1;\n\n        kprompt.prompt = prompt;\n        kprompt.hidden = 1;\n        kprompt.reply = &rdat;\n        prompt_type = KRB5_PROMPT_TYPE_PREAUTH;\n\n        /* PROMPTER_INVOCATION */\n        k5int_set_prompt_types(context, &prompt_type);\n        r = (*id_cryptoctx->prompter)(context, id_cryptoctx->prompter_data,\n                                      NULL, NULL, 1, &kprompt);\n        k5int_set_prompt_types(context, 0);\n        free(prompt);\n    }\n\n    if (r == 0) {\n        r = id_cryptoctx->p11->C_Login(id_cryptoctx->session, CKU_USER,\n                                       (u_char *) rdat.data, rdat.length);\n\n        if (r != CKR_OK) {\n            pkiDebug(\"C_Login: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            r = KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n    }\n    free(rdat.data);\n\n    return r;\n}\n\nstatic krb5_error_code\npkinit_open_session(krb5_context context,\n                    pkinit_identity_crypto_context cctx)\n{\n    CK_ULONG i, r;\n    unsigned char *cp;\n    size_t label_len;\n    CK_ULONG count = 0;\n    CK_SLOT_ID_PTR slotlist;\n    CK_TOKEN_INFO tinfo;\n    char *p11name;\n    const char *password;\n\n    if (cctx->p11_module != NULL)\n        return 0; /* session already open */\n\n    /* Load module */\n    cctx->p11_module =\n        pkinit_C_LoadModule(cctx->p11_module_name, &cctx->p11);\n    if (cctx->p11_module == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    /* Init */\n    if ((r = cctx->p11->C_Initialize(NULL)) != CKR_OK) {\n        pkiDebug(\"C_Initialize: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    /* Get the list of available slots */\n    if (cctx->p11->C_GetSlotList(TRUE, NULL, &count) != CKR_OK)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    if (count == 0)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    slotlist = calloc(count, sizeof(CK_SLOT_ID));\n    if (slotlist == NULL)\n        return ENOMEM;\n    if (cctx->p11->C_GetSlotList(TRUE, slotlist, &count) != CKR_OK)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    /* Look for the given token label, or if none given take the first one */\n    for (i = 0; i < count; i++) {\n        /* Skip slots that don't match the specified slotid, if given. */\n        if (cctx->slotid != PK_NOSLOT && cctx->slotid != slotlist[i])\n            continue;\n\n        /* Open session */\n        if ((r = cctx->p11->C_OpenSession(slotlist[i], CKF_SERIAL_SESSION,\n                                          NULL, NULL, &cctx->session)) != CKR_OK) {\n            pkiDebug(\"C_OpenSession: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n\n        /* Get token info */\n        if ((r = cctx->p11->C_GetTokenInfo(slotlist[i], &tinfo)) != CKR_OK) {\n            pkiDebug(\"C_GetTokenInfo: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n\n        /* tinfo.label is zero-filled but not necessarily zero-terminated.\n         * Find the length, ignoring any trailing spaces. */\n        for (cp = tinfo.label + sizeof(tinfo.label); cp > tinfo.label; cp--) {\n            if (cp[-1] != '\\0' && cp[-1] != ' ')\n                break;\n        }\n        label_len = cp - tinfo.label;\n\n        pkiDebug(\"open_session: slotid %d token \\\"%.*s\\\"\\n\",\n                 (int)slotlist[i], (int)label_len, tinfo.label);\n        if (cctx->token_label == NULL ||\n            (strlen(cctx->token_label) == label_len &&\n             memcmp(cctx->token_label, tinfo.label, label_len) == 0))\n            break;\n        cctx->p11->C_CloseSession(cctx->session);\n    }\n    if (i >= count) {\n        free(slotlist);\n        pkiDebug(\"open_session: no matching token found\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    cctx->slotid = slotlist[i];\n    free(slotlist);\n    pkiDebug(\"open_session: slotid %d (%lu of %d)\\n\", (int)cctx->slotid,\n             i + 1, (int) count);\n\n    /* Login if needed */\n    if (tinfo.flags & CKF_LOGIN_REQUIRED) {\n        if (cctx->p11_module_name != NULL) {\n            if (cctx->slotid != PK_NOSLOT) {\n                if (asprintf(&p11name,\n                             \"PKCS11:module_name=%s:slotid=%ld:token=%.*s\",\n                             cctx->p11_module_name, (long)cctx->slotid,\n                             (int)label_len, tinfo.label) < 0)\n                    p11name = NULL;\n            } else {\n                if (asprintf(&p11name,\n                             \"PKCS11:module_name=%s,token=%.*s\",\n                             cctx->p11_module_name,\n                             (int)label_len, tinfo.label) < 0)\n                    p11name = NULL;\n            }\n        } else {\n            p11name = NULL;\n        }\n        if (cctx->defer_id_prompt) {\n            /* Supply the identity name to be passed to the responder. */\n            pkinit_set_deferred_id(&cctx->deferred_ids,\n                                   p11name, tinfo.flags, NULL);\n            free(p11name);\n            return KRB5KRB_ERR_GENERIC;\n        }\n        /* Look up a responder-supplied password for the token. */\n        password = pkinit_find_deferred_id(cctx->deferred_ids, p11name);\n        free(p11name);\n        r = pkinit_login(context, cctx, &tinfo, password);\n    }\n\n    return r;\n}\n\n/*\n * Look for a key that's:\n * 1. private\n * 2. capable of the specified operation (usually signing or decrypting)\n * 3. RSA (this may be wrong but it's all we can do for now)\n * 4. matches the id of the cert we chose\n *\n * You must call pkinit_get_certs before calling pkinit_find_private_key\n * (that's because we need the ID of the private key)\n *\n * pkcs11 says the id of the key doesn't have to match that of the cert, but\n * I can't figure out any other way to decide which key to use.\n *\n * We should only find one key that fits all the requirements.\n * If there are more than one, we just take the first one.\n */\n\nkrb5_error_code\npkinit_find_private_key(pkinit_identity_crypto_context id_cryptoctx,\n                        CK_ATTRIBUTE_TYPE usage,\n                        CK_OBJECT_HANDLE *objp)\n{\n    CK_OBJECT_CLASS cls;\n    CK_ATTRIBUTE attrs[4];\n    CK_ULONG count;\n    CK_KEY_TYPE keytype;\n    unsigned int nattrs = 0;\n    int r;\n#ifdef PKINIT_USE_KEY_USAGE\n    CK_BBOOL true_false;\n#endif\n\n    cls = CKO_PRIVATE_KEY;\n    attrs[nattrs].type = CKA_CLASS;\n    attrs[nattrs].pValue = &cls;\n    attrs[nattrs].ulValueLen = sizeof cls;\n    nattrs++;\n\n#ifdef PKINIT_USE_KEY_USAGE\n    /*\n     * Some cards get confused if you try to specify a key usage,\n     * so don't, and hope for the best. This will fail if you have\n     * several keys with the same id and different usages but I have\n     * not seen this on real cards.\n     */\n    true_false = TRUE;\n    attrs[nattrs].type = usage;\n    attrs[nattrs].pValue = &true_false;\n    attrs[nattrs].ulValueLen = sizeof true_false;\n    nattrs++;\n#endif\n\n    keytype = CKK_RSA;\n    attrs[nattrs].type = CKA_KEY_TYPE;\n    attrs[nattrs].pValue = &keytype;\n    attrs[nattrs].ulValueLen = sizeof keytype;\n    nattrs++;\n\n    attrs[nattrs].type = CKA_ID;\n    attrs[nattrs].pValue = id_cryptoctx->cert_id;\n    attrs[nattrs].ulValueLen = id_cryptoctx->cert_id_len;\n    nattrs++;\n\n    r = id_cryptoctx->p11->C_FindObjectsInit(id_cryptoctx->session, attrs, nattrs);\n    if (r != CKR_OK) {\n        pkiDebug(\"krb5_pkinit_sign_data: C_FindObjectsInit: %s\\n\",\n                 pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    r = id_cryptoctx->p11->C_FindObjects(id_cryptoctx->session, objp, 1, &count);\n    id_cryptoctx->p11->C_FindObjectsFinal(id_cryptoctx->session);\n    pkiDebug(\"found %d private keys (%s)\\n\", (int) count, pkinit_pkcs11_code_to_text(r));\n    if (r != CKR_OK || count < 1)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    return 0;\n}\n#endif\n\nstatic krb5_error_code\npkinit_decode_data_fs(krb5_context context,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      const uint8_t *data, unsigned int data_len,\n                      uint8_t **decoded_data, unsigned int *decoded_data_len)\n{\n    X509 *cert = sk_X509_value(id_cryptoctx->my_certs,\n                               id_cryptoctx->cert_index);\n    EVP_PKEY *pkey = id_cryptoctx->my_key;\n    uint8_t *buf;\n    int buf_len, decrypt_len;\n\n    *decoded_data = NULL;\n    *decoded_data_len = 0;\n\n    if (cert != NULL && !X509_check_private_key(cert, pkey)) {\n        pkiDebug(\"private key does not match certificate\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    buf_len = EVP_PKEY_size(pkey);\n    buf = malloc(buf_len + 10);\n    if (buf == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    decrypt_len = EVP_PKEY_decrypt_old(buf, data, data_len, pkey);\n    if (decrypt_len <= 0) {\n        pkiDebug(\"unable to decrypt received data (len=%d)\\n\", data_len);\n        free(buf);\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    *decoded_data = buf;\n    *decoded_data_len = decrypt_len;\n    return 0;\n}\n\n#ifndef WITHOUT_PKCS11\n/*\n * When using the ActivCard Linux pkcs11 library (v2.0.1), the decrypt function\n * fails.  By inserting an extra function call, which serves nothing but to\n * change the stack, we were able to work around the issue.  If the ActivCard\n * library is fixed in the future, this function can be inlined back into the\n * caller.\n */\nstatic CK_RV\npkinit_C_Decrypt(pkinit_identity_crypto_context id_cryptoctx,\n                 CK_BYTE_PTR pEncryptedData,\n                 CK_ULONG  ulEncryptedDataLen,\n                 CK_BYTE_PTR pData,\n                 CK_ULONG_PTR pulDataLen)\n{\n    CK_RV rv = CKR_OK;\n\n    rv = id_cryptoctx->p11->C_Decrypt(id_cryptoctx->session, pEncryptedData,\n                                      ulEncryptedDataLen, pData, pulDataLen);\n    if (rv == CKR_OK) {\n        pkiDebug(\"pData %p *pulDataLen %d\\n\", (void *) pData,\n                 (int) *pulDataLen);\n    }\n    return rv;\n}\n\nstatic krb5_error_code\npkinit_decode_data_pkcs11(krb5_context context,\n                          pkinit_identity_crypto_context id_cryptoctx,\n                          const uint8_t *data, unsigned int data_len,\n                          uint8_t **decoded_data,\n                          unsigned int *decoded_data_len)\n{\n    CK_OBJECT_HANDLE obj;\n    CK_ULONG len;\n    CK_MECHANISM mech;\n    uint8_t *cp;\n    int r;\n\n    *decoded_data = NULL;\n    *decoded_data_len = 0;\n\n    if (pkinit_open_session(context, id_cryptoctx)) {\n        pkiDebug(\"can't open pkcs11 session\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    pkinit_find_private_key(id_cryptoctx, CKA_DECRYPT, &obj);\n\n    mech.mechanism = CKM_RSA_PKCS;\n    mech.pParameter = NULL;\n    mech.ulParameterLen = 0;\n\n    if ((r = id_cryptoctx->p11->C_DecryptInit(id_cryptoctx->session, &mech,\n                                              obj)) != CKR_OK) {\n        pkiDebug(\"C_DecryptInit: 0x%x\\n\", (int) r);\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    pkiDebug(\"data_len = %d\\n\", data_len);\n    cp = malloc((size_t) data_len);\n    if (cp == NULL)\n        return ENOMEM;\n    len = data_len;\n    pkiDebug(\"session %p edata %p edata_len %d data %p datalen @%p %d\\n\",\n             (void *) id_cryptoctx->session, (void *) data, (int) data_len,\n             (void *) cp, (void *) &len, (int) len);\n    r = pkinit_C_Decrypt(id_cryptoctx, (CK_BYTE_PTR) data, (CK_ULONG) data_len,\n                         cp, &len);\n    if (r != CKR_OK) {\n        pkiDebug(\"C_Decrypt: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        if (r == CKR_BUFFER_TOO_SMALL)\n            pkiDebug(\"decrypt %d needs %d\\n\", (int) data_len, (int) len);\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    pkiDebug(\"decrypt %d -> %d\\n\", (int) data_len, (int) len);\n    *decoded_data_len = len;\n    *decoded_data = cp;\n\n    return 0;\n}\n#endif\n\nkrb5_error_code\npkinit_decode_data(krb5_context context,\n                   pkinit_identity_crypto_context id_cryptoctx,\n                   const uint8_t *data, unsigned int data_len,\n                   uint8_t **decoded_data, unsigned int *decoded_data_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    *decoded_data = NULL;\n    *decoded_data_len = 0;\n\n    if (id_cryptoctx->pkcs11_method != 1)\n        retval = pkinit_decode_data_fs(context, id_cryptoctx, data, data_len,\n                                       decoded_data, decoded_data_len);\n#ifndef WITHOUT_PKCS11\n    else\n        retval = pkinit_decode_data_pkcs11(context, id_cryptoctx, data,\n                                           data_len, decoded_data, decoded_data_len);\n#endif\n\n    return retval;\n}\n\nstatic krb5_error_code\npkinit_sign_data_fs(krb5_context context,\n                    pkinit_identity_crypto_context id_cryptoctx,\n                    unsigned char *data,\n                    unsigned int data_len,\n                    unsigned char **sig,\n                    unsigned int *sig_len)\n{\n    if (create_signature(sig, sig_len, data, data_len,\n                         id_cryptoctx->my_key) != 0) {\n        pkiDebug(\"failed to create the signature\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    return 0;\n}\n\n#ifndef WITHOUT_PKCS11\nstatic krb5_error_code\npkinit_sign_data_pkcs11(krb5_context context,\n                        pkinit_identity_crypto_context id_cryptoctx,\n                        unsigned char *data,\n                        unsigned int data_len,\n                        unsigned char **sig,\n                        unsigned int *sig_len)\n{\n    CK_OBJECT_HANDLE obj;\n    CK_ULONG len;\n    CK_MECHANISM mech;\n    unsigned char *cp;\n    int r;\n\n    if (pkinit_open_session(context, id_cryptoctx)) {\n        pkiDebug(\"can't open pkcs11 session\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    pkinit_find_private_key(id_cryptoctx, CKA_SIGN, &obj);\n\n    mech.mechanism = id_cryptoctx->mech;\n    mech.pParameter = NULL;\n    mech.ulParameterLen = 0;\n\n    if ((r = id_cryptoctx->p11->C_SignInit(id_cryptoctx->session, &mech,\n                                           obj)) != CKR_OK) {\n        pkiDebug(\"C_SignInit: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    /*\n     * Key len would give an upper bound on sig size, but there's no way to\n     * get that. So guess, and if it's too small, re-malloc.\n     */\n    len = PK_SIGLEN_GUESS;\n    cp = malloc((size_t) len);\n    if (cp == NULL)\n        return ENOMEM;\n\n    r = id_cryptoctx->p11->C_Sign(id_cryptoctx->session, data,\n                                  (CK_ULONG) data_len, cp, &len);\n    if (r == CKR_BUFFER_TOO_SMALL || (r == CKR_OK && len >= PK_SIGLEN_GUESS)) {\n        free(cp);\n        pkiDebug(\"C_Sign realloc %d\\n\", (int) len);\n        cp = malloc((size_t) len);\n        r = id_cryptoctx->p11->C_Sign(id_cryptoctx->session, data,\n                                      (CK_ULONG) data_len, cp, &len);\n    }\n    if (r != CKR_OK) {\n        pkiDebug(\"C_Sign: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    pkiDebug(\"sign %d -> %d\\n\", (int) data_len, (int) len);\n    *sig_len = len;\n    *sig = cp;\n\n    return 0;\n}\n#endif\n\nkrb5_error_code\npkinit_sign_data(krb5_context context,\n                 pkinit_identity_crypto_context id_cryptoctx,\n                 unsigned char *data,\n                 unsigned int data_len,\n                 unsigned char **sig,\n                 unsigned int *sig_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    if (id_cryptoctx == NULL || id_cryptoctx->pkcs11_method != 1)\n        retval = pkinit_sign_data_fs(context, id_cryptoctx, data, data_len,\n                                     sig, sig_len);\n#ifndef WITHOUT_PKCS11\n    else\n        retval = pkinit_sign_data_pkcs11(context, id_cryptoctx, data, data_len,\n                                         sig, sig_len);\n#endif\n\n    return retval;\n}\n\n\nstatic krb5_error_code\ncreate_signature(unsigned char **sig, unsigned int *sig_len,\n                 unsigned char *data, unsigned int data_len, EVP_PKEY *pkey)\n{\n    krb5_error_code retval = ENOMEM;\n    EVP_MD_CTX *ctx;\n\n    if (pkey == NULL)\n        return retval;\n\n    ctx = EVP_MD_CTX_new();\n    if (ctx == NULL)\n        return ENOMEM;\n    EVP_SignInit(ctx, EVP_sha1());\n    EVP_SignUpdate(ctx, data, data_len);\n    *sig_len = EVP_PKEY_size(pkey);\n    if ((*sig = malloc(*sig_len)) == NULL)\n        goto cleanup;\n    EVP_SignFinal(ctx, *sig, sig_len, pkey);\n\n    retval = 0;\n\ncleanup:\n    EVP_MD_CTX_free(ctx);\n\n    return retval;\n}\n\n/*\n * Note:\n * This is not the routine the KDC uses to get its certificate.\n * This routine is intended to be called by the client\n * to obtain the KDC's certificate from some local storage\n * to be sent as a hint in its request to the KDC.\n */\nkrb5_error_code\npkinit_get_kdc_cert(krb5_context context,\n                    pkinit_plg_crypto_context plg_cryptoctx,\n                    pkinit_req_crypto_context req_cryptoctx,\n                    pkinit_identity_crypto_context id_cryptoctx,\n                    krb5_principal princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    req_cryptoctx->received_cert = NULL;\n    retval = 0;\n    return retval;\n}\n\nstatic char *\nreassemble_pkcs12_name(const char *filename)\n{\n    char *ret;\n\n    if (asprintf(&ret, \"PKCS12:%s\", filename) < 0)\n        return NULL;\n    return ret;\n}\n\nstatic krb5_error_code\npkinit_get_certs_pkcs12(krb5_context context,\n                        pkinit_plg_crypto_context plg_cryptoctx,\n                        pkinit_req_crypto_context req_cryptoctx,\n                        pkinit_identity_opts *idopts,\n                        pkinit_identity_crypto_context id_cryptoctx,\n                        krb5_principal princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    char *prompt_string = NULL;\n    X509 *x = NULL;\n    PKCS12 *p12 = NULL;\n    int ret;\n    FILE *fp;\n    EVP_PKEY *y = NULL;\n\n    if (idopts->cert_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's cert location\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n\n    if (idopts->key_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's private key location\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n\n    fp = fopen(idopts->cert_filename, \"rb\");\n    if (fp == NULL) {\n        TRACE_PKINIT_PKCS_OPEN_FAIL(context, idopts->cert_filename, errno);\n        goto cleanup;\n    }\n    set_cloexec_file(fp);\n\n    p12 = d2i_PKCS12_fp(fp, NULL);\n    fclose(fp);\n    if (p12 == NULL) {\n        TRACE_PKINIT_PKCS_DECODE_FAIL(context, idopts->cert_filename);\n        goto cleanup;\n    }\n    /*\n     * Try parsing with no pass phrase first.  If that fails,\n     * prompt for the pass phrase and try again.\n     */\n    ret = PKCS12_parse(p12, NULL, &y, &x, NULL);\n    if (ret == 0) {\n        krb5_data rdat;\n        krb5_prompt kprompt;\n        krb5_prompt_type prompt_type;\n        krb5_error_code r;\n        char prompt_reply[128];\n        char *prompt_prefix = _(\"Pass phrase for\");\n        char *p12name = reassemble_pkcs12_name(idopts->cert_filename);\n        const char *tmp;\n\n        TRACE_PKINIT_PKCS_PARSE_FAIL_FIRST(context);\n\n        if (id_cryptoctx->defer_id_prompt) {\n            /* Supply the identity name to be passed to the responder. */\n            pkinit_set_deferred_id(&id_cryptoctx->deferred_ids, p12name, 0,\n                                   NULL);\n            free(p12name);\n            retval = 0;\n            goto cleanup;\n        }\n        /* Try to read a responder-supplied password. */\n        tmp = pkinit_find_deferred_id(id_cryptoctx->deferred_ids, p12name);\n        free(p12name);\n        if (tmp != NULL) {\n            /* Try using the responder-supplied password. */\n            rdat.data = (char *)tmp;\n            rdat.length = strlen(tmp);\n        } else if (id_cryptoctx->prompter == NULL) {\n            /* We can't use a prompter. */\n            goto cleanup;\n        } else {\n            /* Ask using a prompter. */\n            memset(prompt_reply, '\\0', sizeof(prompt_reply));\n            rdat.data = prompt_reply;\n            rdat.length = sizeof(prompt_reply);\n\n            if (asprintf(&prompt_string, \"%s %s\", prompt_prefix,\n                         idopts->cert_filename) < 0) {\n                prompt_string = NULL;\n                goto cleanup;\n            }\n            kprompt.prompt = prompt_string;\n            kprompt.hidden = 1;\n            kprompt.reply = &rdat;\n            prompt_type = KRB5_PROMPT_TYPE_PREAUTH;\n            /* PROMPTER_INVOCATION */\n            k5int_set_prompt_types(context, &prompt_type);\n            r = (*id_cryptoctx->prompter)(context, id_cryptoctx->prompter_data,\n                                          NULL, NULL, 1, &kprompt);\n            k5int_set_prompt_types(context, 0);\n            if (r) {\n                TRACE_PKINIT_PKCS_PROMPT_FAIL(context);\n                goto cleanup;\n            }\n        }\n\n        ret = PKCS12_parse(p12, rdat.data, &y, &x, NULL);\n        if (ret == 0) {\n            TRACE_PKINIT_PKCS_PARSE_FAIL_SECOND(context);\n            goto cleanup;\n        }\n    }\n    id_cryptoctx->creds[0] = malloc(sizeof(struct _pkinit_cred_info));\n    if (id_cryptoctx->creds[0] == NULL)\n        goto cleanup;\n    id_cryptoctx->creds[0]->name =\n        reassemble_pkcs12_name(idopts->cert_filename);\n    id_cryptoctx->creds[0]->cert = x;\n#ifndef WITHOUT_PKCS11\n    id_cryptoctx->creds[0]->cert_id = NULL;\n    id_cryptoctx->creds[0]->cert_id_len = 0;\n#endif\n    id_cryptoctx->creds[0]->key = y;\n    id_cryptoctx->creds[1] = NULL;\n\n    retval = 0;\n\ncleanup:\n    free(prompt_string);\n    if (p12)\n        PKCS12_free(p12);\n    if (retval) {\n        if (x != NULL)\n            X509_free(x);\n        if (y != NULL)\n            EVP_PKEY_free(y);\n    }\n    return retval;\n}\n\nstatic char *\nreassemble_files_name(const char *certfile, const char *keyfile)\n{\n    char *ret;\n\n    if (keyfile != NULL) {\n        if (asprintf(&ret, \"FILE:%s,%s\", certfile, keyfile) < 0)\n            return NULL;\n    } else {\n        if (asprintf(&ret, \"FILE:%s\", certfile) < 0)\n            return NULL;\n    }\n    return ret;\n}\n\nstatic krb5_error_code\npkinit_load_fs_cert_and_key(krb5_context context,\n                            pkinit_identity_crypto_context id_cryptoctx,\n                            char *certname,\n                            char *keyname,\n                            int cindex)\n{\n    krb5_error_code retval;\n    X509 *x = NULL;\n    EVP_PKEY *y = NULL;\n    char *fsname = NULL;\n    const char *password;\n\n    fsname = reassemble_files_name(certname, keyname);\n\n    /* Try to read a responder-supplied password. */\n    password = pkinit_find_deferred_id(id_cryptoctx->deferred_ids, fsname);\n\n    /* Load the certificate. */\n    retval = get_cert(certname, &x);\n    if (retval != 0 || x == NULL) {\n        retval = oerr(context, 0, _(\"Cannot read certificate file '%s'\"),\n                      certname);\n        goto cleanup;\n    }\n    /* Load the key. */\n    retval = get_key(context, id_cryptoctx, keyname, fsname, &y, password);\n    if (retval != 0 || y == NULL) {\n        retval = oerr(context, 0, _(\"Cannot read key file '%s'\"), fsname);\n        goto cleanup;\n    }\n\n    id_cryptoctx->creds[cindex] = malloc(sizeof(struct _pkinit_cred_info));\n    if (id_cryptoctx->creds[cindex] == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    id_cryptoctx->creds[cindex]->name = reassemble_files_name(certname,\n                                                              keyname);\n    id_cryptoctx->creds[cindex]->cert = x;\n#ifndef WITHOUT_PKCS11\n    id_cryptoctx->creds[cindex]->cert_id = NULL;\n    id_cryptoctx->creds[cindex]->cert_id_len = 0;\n#endif\n    id_cryptoctx->creds[cindex]->key = y;\n    id_cryptoctx->creds[cindex+1] = NULL;\n\n    retval = 0;\n\ncleanup:\n    free(fsname);\n    if (retval != 0 || y == NULL) {\n        if (x != NULL)\n            X509_free(x);\n        if (y != NULL)\n            EVP_PKEY_free(y);\n    }\n    return retval;\n}\n\nstatic krb5_error_code\npkinit_get_certs_fs(krb5_context context,\n                    pkinit_plg_crypto_context plg_cryptoctx,\n                    pkinit_req_crypto_context req_cryptoctx,\n                    pkinit_identity_opts *idopts,\n                    pkinit_identity_crypto_context id_cryptoctx,\n                    krb5_principal princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    if (idopts->cert_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's cert location\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n\n    if (idopts->key_filename == NULL) {\n        TRACE_PKINIT_NO_PRIVKEY(context);\n        goto cleanup;\n    }\n\n    retval = pkinit_load_fs_cert_and_key(context, id_cryptoctx,\n                                         idopts->cert_filename,\n                                         idopts->key_filename, 0);\ncleanup:\n    return retval;\n}\n\nstatic krb5_error_code\npkinit_get_certs_dir(krb5_context context,\n                     pkinit_plg_crypto_context plg_cryptoctx,\n                     pkinit_req_crypto_context req_cryptoctx,\n                     pkinit_identity_opts *idopts,\n                     pkinit_identity_crypto_context id_cryptoctx,\n                     krb5_principal princ)\n{\n    krb5_error_code retval = ENOMEM;\n    DIR *d = NULL;\n    struct dirent *dentry = NULL;\n    char certname[1024];\n    char keyname[1024];\n    int i = 0, len;\n    char *dirname, *suf;\n\n    if (idopts->cert_filename == NULL) {\n        TRACE_PKINIT_NO_CERT(context);\n        return ENOENT;\n    }\n\n    dirname = idopts->cert_filename;\n    d = opendir(dirname);\n    if (d == NULL)\n        return errno;\n\n    /*\n     * We'll assume that certs are named XXX.crt and the corresponding\n     * key is named XXX.key\n     */\n    while ((i < MAX_CREDS_ALLOWED) &&  (dentry = readdir(d)) != NULL) {\n        /* Ignore subdirectories and anything starting with a dot */\n#ifdef DT_DIR\n        if (dentry->d_type == DT_DIR)\n            continue;\n#endif\n        if (dentry->d_name[0] == '.')\n            continue;\n        len = strlen(dentry->d_name);\n        if (len < 5)\n            continue;\n        suf = dentry->d_name + (len - 4);\n        if (strncmp(suf, \".crt\", 4) != 0)\n            continue;\n\n        /* Checked length */\n        if (strlen(dirname) + strlen(dentry->d_name) + 2 > sizeof(certname)) {\n            pkiDebug(\"%s: Path too long -- directory '%s' and file '%s'\\n\",\n                     __FUNCTION__, dirname, dentry->d_name);\n            continue;\n        }\n        snprintf(certname, sizeof(certname), \"%s/%s\", dirname, dentry->d_name);\n        snprintf(keyname, sizeof(keyname), \"%s/%s\", dirname, dentry->d_name);\n        len = strlen(keyname);\n        keyname[len - 3] = 'k';\n        keyname[len - 2] = 'e';\n        keyname[len - 1] = 'y';\n\n        retval = pkinit_load_fs_cert_and_key(context, id_cryptoctx,\n                                             certname, keyname, i);\n        if (retval == 0) {\n            TRACE_PKINIT_LOADED_CERT(context, dentry->d_name);\n            i++;\n        }\n        else\n            continue;\n    }\n\n    if (!id_cryptoctx->defer_id_prompt && i == 0) {\n        TRACE_PKINIT_NO_CERT_AND_KEY(context, idopts->cert_filename);\n        retval = ENOENT;\n        goto cleanup;\n    }\n\n    retval = 0;\n\ncleanup:\n    if (d)\n        closedir(d);\n\n    return retval;\n}\n\n#ifndef WITHOUT_PKCS11\nstatic char *\nreassemble_pkcs11_name(pkinit_identity_opts *idopts)\n{\n    struct k5buf buf;\n    int n = 0;\n    char *ret;\n\n    k5_buf_init_dynamic(&buf);\n    k5_buf_add(&buf, \"PKCS11:\");\n    n = 0;\n    if (idopts->p11_module_name != NULL) {\n        k5_buf_add_fmt(&buf, \"%smodule_name=%s\", n++ ? \":\" : \"\",\n                       idopts->p11_module_name);\n    }\n    if (idopts->token_label != NULL) {\n        k5_buf_add_fmt(&buf, \"%stoken=%s\", n++ ? \":\" : \"\",\n                       idopts->token_label);\n    }\n    if (idopts->cert_label != NULL) {\n        k5_buf_add_fmt(&buf, \"%scertlabel=%s\", n++ ? \":\" : \"\",\n                       idopts->cert_label);\n    }\n    if (idopts->cert_id_string != NULL) {\n        k5_buf_add_fmt(&buf, \"%scertid=%s\", n++ ? \":\" : \"\",\n                       idopts->cert_id_string);\n    }\n    if (idopts->slotid != PK_NOSLOT) {\n        k5_buf_add_fmt(&buf, \"%sslotid=%ld\", n++ ? \":\" : \"\",\n                       (long)idopts->slotid);\n    }\n    if (k5_buf_status(&buf) == 0)\n        ret = strdup(buf.data);\n    else\n        ret = NULL;\n    k5_buf_free(&buf);\n    return ret;\n}\n\nstatic krb5_error_code\npkinit_get_certs_pkcs11(krb5_context context,\n                        pkinit_plg_crypto_context plg_cryptoctx,\n                        pkinit_req_crypto_context req_cryptoctx,\n                        pkinit_identity_opts *idopts,\n                        pkinit_identity_crypto_context id_cryptoctx,\n                        krb5_principal princ)\n{\n#ifdef PKINIT_USE_MECH_LIST\n    CK_MECHANISM_TYPE_PTR mechp;\n    CK_MECHANISM_INFO info;\n#endif\n    CK_OBJECT_CLASS cls;\n    CK_OBJECT_HANDLE obj;\n    CK_ATTRIBUTE attrs[4];\n    CK_ULONG count;\n    CK_CERTIFICATE_TYPE certtype;\n    CK_BYTE_PTR cert = NULL, cert_id;\n    const unsigned char *cp;\n    int i, r;\n    unsigned int nattrs;\n    X509 *x = NULL;\n\n    /* Copy stuff from idopts -> id_cryptoctx */\n    if (idopts->p11_module_name != NULL) {\n        free(id_cryptoctx->p11_module_name);\n        id_cryptoctx->p11_module_name = strdup(idopts->p11_module_name);\n        if (id_cryptoctx->p11_module_name == NULL)\n            return ENOMEM;\n    }\n    if (idopts->token_label != NULL) {\n        id_cryptoctx->token_label = strdup(idopts->token_label);\n        if (id_cryptoctx->token_label == NULL)\n            return ENOMEM;\n    }\n    if (idopts->cert_label != NULL) {\n        id_cryptoctx->cert_label = strdup(idopts->cert_label);\n        if (id_cryptoctx->cert_label == NULL)\n            return ENOMEM;\n    }\n    /* Convert the ascii cert_id string into a binary blob */\n    if (idopts->cert_id_string != NULL) {\n        r = k5_hex_decode(idopts->cert_id_string,\n                          &id_cryptoctx->cert_id, &id_cryptoctx->cert_id_len);\n        if (r != 0) {\n            pkiDebug(\"Failed to convert certid string [%s]\\n\",\n                     idopts->cert_id_string);\n            return r;\n        }\n    }\n    id_cryptoctx->slotid = idopts->slotid;\n    id_cryptoctx->pkcs11_method = 1;\n\n    if (pkinit_open_session(context, id_cryptoctx)) {\n        pkiDebug(\"can't open pkcs11 session\\n\");\n        if (!id_cryptoctx->defer_id_prompt)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    if (id_cryptoctx->defer_id_prompt) {\n        /*\n         * We need to reset all of the PKCS#11 state, so that the next time we\n         * poke at it, it'll be in as close to the state it was in after we\n         * loaded it the first time as we can make it.\n         */\n        pkinit_fini_pkcs11(id_cryptoctx);\n        pkinit_init_pkcs11(id_cryptoctx);\n        return 0;\n    }\n\n#ifndef PKINIT_USE_MECH_LIST\n    /*\n     * We'd like to use CKM_SHA1_RSA_PKCS for signing if it's available, but\n     * many cards seems to be confused about whether they are capable of\n     * this or not. The safe thing seems to be to ignore the mechanism list,\n     * always use CKM_RSA_PKCS and calculate the sha1 digest ourselves.\n     */\n\n    id_cryptoctx->mech = CKM_RSA_PKCS;\n#else\n    if ((r = id_cryptoctx->p11->C_GetMechanismList(id_cryptoctx->slotid, NULL,\n                                                   &count)) != CKR_OK || count <= 0) {\n        pkiDebug(\"C_GetMechanismList: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    mechp = malloc(count * sizeof (CK_MECHANISM_TYPE));\n    if (mechp == NULL)\n        return ENOMEM;\n    if ((r = id_cryptoctx->p11->C_GetMechanismList(id_cryptoctx->slotid,\n                                                   mechp, &count)) != CKR_OK)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    for (i = 0; i < count; i++) {\n        if ((r = id_cryptoctx->p11->C_GetMechanismInfo(id_cryptoctx->slotid,\n                                                       mechp[i], &info)) != CKR_OK)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n#ifdef DEBUG_MECHINFO\n        pkiDebug(\"mech %x flags %x\\n\", (int) mechp[i], (int) info.flags);\n        if ((info.flags & (CKF_SIGN|CKF_DECRYPT)) == (CKF_SIGN|CKF_DECRYPT))\n            pkiDebug(\"  this mech is good for sign & decrypt\\n\");\n#endif\n        if (mechp[i] == CKM_RSA_PKCS) {\n            /* This seems backwards... */\n            id_cryptoctx->mech =\n                (info.flags & CKF_SIGN) ? CKM_SHA1_RSA_PKCS : CKM_RSA_PKCS;\n        }\n    }\n    free(mechp);\n\n    pkiDebug(\"got %d mechs from card\\n\", (int) count);\n#endif\n\n    cls = CKO_CERTIFICATE;\n    attrs[0].type = CKA_CLASS;\n    attrs[0].pValue = &cls;\n    attrs[0].ulValueLen = sizeof cls;\n\n    certtype = CKC_X_509;\n    attrs[1].type = CKA_CERTIFICATE_TYPE;\n    attrs[1].pValue = &certtype;\n    attrs[1].ulValueLen = sizeof certtype;\n\n    nattrs = 2;\n\n    /* If a cert id and/or label were given, use them too */\n    if (id_cryptoctx->cert_id_len > 0) {\n        attrs[nattrs].type = CKA_ID;\n        attrs[nattrs].pValue = id_cryptoctx->cert_id;\n        attrs[nattrs].ulValueLen = id_cryptoctx->cert_id_len;\n        nattrs++;\n    }\n    if (id_cryptoctx->cert_label != NULL) {\n        attrs[nattrs].type = CKA_LABEL;\n        attrs[nattrs].pValue = id_cryptoctx->cert_label;\n        attrs[nattrs].ulValueLen = strlen(id_cryptoctx->cert_label);\n        nattrs++;\n    }\n\n    r = id_cryptoctx->p11->C_FindObjectsInit(id_cryptoctx->session, attrs, nattrs);\n    if (r != CKR_OK) {\n        pkiDebug(\"C_FindObjectsInit: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    for (i = 0; ; i++) {\n        if (i >= MAX_CREDS_ALLOWED)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n\n        /* Look for x.509 cert */\n        if ((r = id_cryptoctx->p11->C_FindObjects(id_cryptoctx->session,\n                                                  &obj, 1, &count)) != CKR_OK || count <= 0) {\n            id_cryptoctx->creds[i] = NULL;\n            break;\n        }\n\n        /* Get cert and id len */\n        attrs[0].type = CKA_VALUE;\n        attrs[0].pValue = NULL;\n        attrs[0].ulValueLen = 0;\n\n        attrs[1].type = CKA_ID;\n        attrs[1].pValue = NULL;\n        attrs[1].ulValueLen = 0;\n\n        if ((r = id_cryptoctx->p11->C_GetAttributeValue(id_cryptoctx->session,\n                                                        obj, attrs, 2)) != CKR_OK && r != CKR_BUFFER_TOO_SMALL) {\n            pkiDebug(\"C_GetAttributeValue: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n        cert = (CK_BYTE_PTR) malloc((size_t) attrs[0].ulValueLen + 1);\n        cert_id = (CK_BYTE_PTR) malloc((size_t) attrs[1].ulValueLen + 1);\n        if (cert == NULL || cert_id == NULL)\n            return ENOMEM;\n\n        /* Read the cert and id off the card */\n\n        attrs[0].type = CKA_VALUE;\n        attrs[0].pValue = cert;\n\n        attrs[1].type = CKA_ID;\n        attrs[1].pValue = cert_id;\n\n        if ((r = id_cryptoctx->p11->C_GetAttributeValue(id_cryptoctx->session,\n                                                        obj, attrs, 2)) != CKR_OK) {\n            pkiDebug(\"C_GetAttributeValue: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n\n        pkiDebug(\"cert %d size %d id %d idlen %d\\n\", i,\n                 (int) attrs[0].ulValueLen, (int) cert_id[0],\n                 (int) attrs[1].ulValueLen);\n\n        cp = (unsigned char *) cert;\n        x = d2i_X509(NULL, &cp, (int) attrs[0].ulValueLen);\n        if (x == NULL)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        id_cryptoctx->creds[i] = malloc(sizeof(struct _pkinit_cred_info));\n        if (id_cryptoctx->creds[i] == NULL)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        id_cryptoctx->creds[i]->name = reassemble_pkcs11_name(idopts);\n        id_cryptoctx->creds[i]->cert = x;\n        id_cryptoctx->creds[i]->key = NULL;\n        id_cryptoctx->creds[i]->cert_id = cert_id;\n        id_cryptoctx->creds[i]->cert_id_len = attrs[1].ulValueLen;\n        free(cert);\n    }\n    id_cryptoctx->p11->C_FindObjectsFinal(id_cryptoctx->session);\n    if (cert == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    return 0;\n}\n#endif\n\n\nstatic void\nfree_cred_info(krb5_context context,\n               pkinit_identity_crypto_context id_cryptoctx,\n               struct _pkinit_cred_info *cred)\n{\n    if (cred != NULL) {\n        if (cred->cert != NULL)\n            X509_free(cred->cert);\n        if (cred->key != NULL)\n            EVP_PKEY_free(cred->key);\n#ifndef WITHOUT_PKCS11\n        free(cred->cert_id);\n#endif\n        free(cred->name);\n        free(cred);\n    }\n}\n\nkrb5_error_code\ncrypto_free_cert_info(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx)\n{\n    int i;\n\n    if (id_cryptoctx == NULL)\n        return EINVAL;\n\n    for (i = 0; i < MAX_CREDS_ALLOWED; i++) {\n        if (id_cryptoctx->creds[i] != NULL) {\n            free_cred_info(context, id_cryptoctx, id_cryptoctx->creds[i]);\n            id_cryptoctx->creds[i] = NULL;\n        }\n    }\n    return 0;\n}\n\nkrb5_error_code\ncrypto_load_certs(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx,\n                  pkinit_identity_opts *idopts,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  krb5_principal princ,\n                  krb5_boolean defer_id_prompts)\n{\n    krb5_error_code retval;\n\n    id_cryptoctx->defer_id_prompt = defer_id_prompts;\n\n    switch(idopts->idtype) {\n    case IDTYPE_FILE:\n        retval = pkinit_get_certs_fs(context, plg_cryptoctx,\n                                     req_cryptoctx, idopts,\n                                     id_cryptoctx, princ);\n        break;\n    case IDTYPE_DIR:\n        retval = pkinit_get_certs_dir(context, plg_cryptoctx,\n                                      req_cryptoctx, idopts,\n                                      id_cryptoctx, princ);\n        break;\n#ifndef WITHOUT_PKCS11\n    case IDTYPE_PKCS11:\n        retval = pkinit_get_certs_pkcs11(context, plg_cryptoctx,\n                                         req_cryptoctx, idopts,\n                                         id_cryptoctx, princ);\n        break;\n#endif\n    case IDTYPE_PKCS12:\n        retval = pkinit_get_certs_pkcs12(context, plg_cryptoctx,\n                                         req_cryptoctx, idopts,\n                                         id_cryptoctx, princ);\n        break;\n    default:\n        retval = EINVAL;\n    }\n    if (retval)\n        goto cleanup;\n\ncleanup:\n    return retval;\n}\n\n/*\n * Get certificate Key Usage and Extended Key Usage\n */\nstatic krb5_error_code\ncrypto_retrieve_X509_key_usage(krb5_context context,\n                               pkinit_plg_crypto_context plgcctx,\n                               pkinit_req_crypto_context reqcctx,\n                               X509 *x,\n                               unsigned int *ret_ku_bits,\n                               unsigned int *ret_eku_bits)\n{\n    krb5_error_code retval = 0;\n    int i;\n    unsigned int eku_bits = 0, ku_bits = 0;\n    ASN1_BIT_STRING *usage = NULL;\n\n    if (ret_ku_bits == NULL && ret_eku_bits == NULL)\n        return EINVAL;\n\n    if (ret_eku_bits)\n        *ret_eku_bits = 0;\n    else {\n        pkiDebug(\"%s: EKUs not requested, not checking\\n\", __FUNCTION__);\n        goto check_kus;\n    }\n\n    /* Start with Extended Key usage */\n    i = X509_get_ext_by_NID(x, NID_ext_key_usage, -1);\n    if (i >= 0) {\n        EXTENDED_KEY_USAGE *eku;\n\n        eku = X509_get_ext_d2i(x, NID_ext_key_usage, NULL, NULL);\n        if (eku) {\n            for (i = 0; i < sk_ASN1_OBJECT_num(eku); i++) {\n                ASN1_OBJECT *certoid;\n                certoid = sk_ASN1_OBJECT_value(eku, i);\n                if ((OBJ_cmp(certoid, plgcctx->id_pkinit_KPClientAuth)) == 0)\n                    eku_bits |= PKINIT_EKU_PKINIT;\n                else if ((OBJ_cmp(certoid, OBJ_nid2obj(NID_ms_smartcard_login))) == 0)\n                    eku_bits |= PKINIT_EKU_MSSCLOGIN;\n                else if ((OBJ_cmp(certoid, OBJ_nid2obj(NID_client_auth))) == 0)\n                    eku_bits |= PKINIT_EKU_CLIENTAUTH;\n                else if ((OBJ_cmp(certoid, OBJ_nid2obj(NID_email_protect))) == 0)\n                    eku_bits |= PKINIT_EKU_EMAILPROTECTION;\n            }\n            EXTENDED_KEY_USAGE_free(eku);\n        }\n    }\n    pkiDebug(\"%s: returning eku 0x%08x\\n\", __FUNCTION__, eku_bits);\n    *ret_eku_bits = eku_bits;\n\ncheck_kus:\n    /* Now the Key Usage bits */\n    if (ret_ku_bits)\n        *ret_ku_bits = 0;\n    else {\n        pkiDebug(\"%s: KUs not requested, not checking\\n\", __FUNCTION__);\n        goto out;\n    }\n\n    /* Make sure usage exists before checking bits */\n    X509_check_ca(x);\n    usage = X509_get_ext_d2i(x, NID_key_usage, NULL, NULL);\n    if (usage) {\n        if (!ku_reject(x, X509v3_KU_DIGITAL_SIGNATURE))\n            ku_bits |= PKINIT_KU_DIGITALSIGNATURE;\n        if (!ku_reject(x, X509v3_KU_KEY_ENCIPHERMENT))\n            ku_bits |= PKINIT_KU_KEYENCIPHERMENT;\n        ASN1_BIT_STRING_free(usage);\n    }\n\n    pkiDebug(\"%s: returning ku 0x%08x\\n\", __FUNCTION__, ku_bits);\n    *ret_ku_bits = ku_bits;\n    retval = 0;\nout:\n    return retval;\n}\n\nstatic krb5_error_code\nrfc2253_name(X509_NAME *name, char **str_out)\n{\n    BIO *b = NULL;\n    char *str;\n\n    *str_out = NULL;\n    b = BIO_new(BIO_s_mem());\n    if (b == NULL)\n        return ENOMEM;\n    if (X509_NAME_print_ex(b, name, 0, XN_FLAG_SEP_COMMA_PLUS) < 0)\n        goto error;\n    str = calloc(BIO_number_written(b) + 1, 1);\n    if (str == NULL)\n        goto error;\n    BIO_read(b, str, BIO_number_written(b));\n    BIO_free(b);\n    *str_out = str;\n    return 0;\n\nerror:\n    BIO_free(b);\n    return ENOMEM;\n}\n\n/*\n * Get number of certificates available after crypto_load_certs()\n */\nstatic krb5_error_code\ncrypto_cert_get_count(pkinit_identity_crypto_context id_cryptoctx,\n                      int *cert_count)\n{\n    int count;\n\n    *cert_count = 0;\n    if (id_cryptoctx == NULL || id_cryptoctx->creds[0] == NULL)\n        return EINVAL;\n\n    for (count = 0;\n         count <= MAX_CREDS_ALLOWED && id_cryptoctx->creds[count] != NULL;\n         count++);\n    *cert_count = count;\n    return 0;\n}\n\nvoid\ncrypto_cert_free_matching_data(krb5_context context,\n                               pkinit_cert_matching_data *md)\n{\n    int i;\n\n    if (md == NULL)\n        return;\n    free(md->subject_dn);\n    free(md->issuer_dn);\n    for (i = 0; md->sans != NULL && md->sans[i] != NULL; i++)\n        krb5_free_principal(context, md->sans[i]);\n    free(md->sans);\n    for (i = 0; md->upns != NULL && md->upns[i] != NULL; i++)\n        free(md->upns[i]);\n    free(md->upns);\n    free(md);\n}\n\n/*\n * Free certificate matching data.\n */\nvoid\ncrypto_cert_free_matching_data_list(krb5_context context,\n                                    pkinit_cert_matching_data **list)\n{\n    int i;\n\n    for (i = 0; list != NULL && list[i] != NULL; i++)\n        crypto_cert_free_matching_data(context, list[i]);\n    free(list);\n}\n\n/*\n * Get certificate matching data for cert.\n */\nstatic krb5_error_code\nget_matching_data(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx, X509 *cert,\n                  pkinit_cert_matching_data **md_out)\n{\n    krb5_error_code ret = ENOMEM;\n    pkinit_cert_matching_data *md = NULL;\n\n    *md_out = NULL;\n\n    md = calloc(1, sizeof(*md));\n    if (md == NULL)\n        goto cleanup;\n\n    ret = rfc2253_name(X509_get_subject_name(cert), &md->subject_dn);\n    if (ret)\n        goto cleanup;\n    ret = rfc2253_name(X509_get_issuer_name(cert), &md->issuer_dn);\n    if (ret)\n        goto cleanup;\n\n    /* Get the SAN data. */\n    ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,\n                                    cert, &md->sans, &md->upns, NULL);\n    if (ret)\n        goto cleanup;\n\n    /* Get the KU and EKU data. */\n    ret = crypto_retrieve_X509_key_usage(context, plg_cryptoctx,\n                                         req_cryptoctx, cert, &md->ku_bits,\n                                         &md->eku_bits);\n    if (ret)\n        goto cleanup;\n\n    *md_out = md;\n    md = NULL;\n\ncleanup:\n    crypto_cert_free_matching_data(context, md);\n    return ret;\n}\n\nkrb5_error_code\ncrypto_cert_get_matching_data(krb5_context context,\n                              pkinit_plg_crypto_context plg_cryptoctx,\n                              pkinit_req_crypto_context req_cryptoctx,\n                              pkinit_identity_crypto_context id_cryptoctx,\n                              pkinit_cert_matching_data ***md_out)\n{\n    krb5_error_code ret;\n    pkinit_cert_matching_data **md_list = NULL;\n    int count, i;\n\n    ret = crypto_cert_get_count(id_cryptoctx, &count);\n    if (ret)\n        goto cleanup;\n\n    md_list = calloc(count + 1, sizeof(*md_list));\n    if (md_list == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    for (i = 0; i < count; i++) {\n        ret = get_matching_data(context, plg_cryptoctx, req_cryptoctx,\n                                id_cryptoctx->creds[i]->cert, &md_list[i]);\n        if (ret) {\n            pkiDebug(\"%s: crypto_cert_get_matching_data error %d, %s\\n\",\n                     __FUNCTION__, ret, error_message(ret));\n            goto cleanup;\n        }\n    }\n\n    *md_out = md_list;\n    md_list = NULL;\n\ncleanup:\n    crypto_cert_free_matching_data_list(context, md_list);\n    return ret;\n}\n\n/*\n * Set the certificate in idctx->creds[cred_index] as the selected certificate.\n */\nkrb5_error_code\ncrypto_cert_select(krb5_context context, pkinit_identity_crypto_context idctx,\n                   size_t cred_index)\n{\n    pkinit_cred_info ci = NULL;\n\n    if (cred_index >= MAX_CREDS_ALLOWED || idctx->creds[cred_index] == NULL)\n        return ENOENT;\n\n    ci = idctx->creds[cred_index];\n    /* copy the selected cert into our id_cryptoctx */\n    if (idctx->my_certs != NULL)\n        sk_X509_pop_free(idctx->my_certs, X509_free);\n    idctx->my_certs = sk_X509_new_null();\n    sk_X509_push(idctx->my_certs, ci->cert);\n    free(idctx->identity);\n    /* hang on to the selected credential name */\n    if (ci->name != NULL)\n        idctx->identity = strdup(ci->name);\n    else\n        idctx->identity = NULL;\n\n    ci->cert = NULL;       /* Don't free it twice */\n    idctx->cert_index = 0;\n    if (idctx->pkcs11_method != 1) {\n        idctx->my_key = ci->key;\n        ci->key = NULL;    /* Don't free it twice */\n    }\n#ifndef WITHOUT_PKCS11\n    else {\n        idctx->cert_id = ci->cert_id;\n        ci->cert_id = NULL; /* Don't free it twice */\n        idctx->cert_id_len = ci->cert_id_len;\n    }\n#endif\n    return 0;\n}\n\n/*\n * Choose the default certificate as \"the chosen one\"\n */\nkrb5_error_code\ncrypto_cert_select_default(krb5_context context,\n                           pkinit_plg_crypto_context plg_cryptoctx,\n                           pkinit_req_crypto_context req_cryptoctx,\n                           pkinit_identity_crypto_context id_cryptoctx)\n{\n    krb5_error_code retval;\n    int cert_count;\n\n    retval = crypto_cert_get_count(id_cryptoctx, &cert_count);\n    if (retval)\n        goto errout;\n\n    if (cert_count != 1) {\n        TRACE_PKINIT_NO_DEFAULT_CERT(context, cert_count);\n        retval = EINVAL;\n        goto errout;\n    }\n    /* copy the selected cert into our id_cryptoctx */\n    if (id_cryptoctx->my_certs != NULL) {\n        sk_X509_pop_free(id_cryptoctx->my_certs, X509_free);\n    }\n    id_cryptoctx->my_certs = sk_X509_new_null();\n    sk_X509_push(id_cryptoctx->my_certs, id_cryptoctx->creds[0]->cert);\n    id_cryptoctx->creds[0]->cert = NULL;        /* Don't free it twice */\n    id_cryptoctx->cert_index = 0;\n    /* hang on to the selected credential name */\n    if (id_cryptoctx->creds[0]->name != NULL)\n        id_cryptoctx->identity = strdup(id_cryptoctx->creds[0]->name);\n    else\n        id_cryptoctx->identity = NULL;\n\n    if (id_cryptoctx->pkcs11_method != 1) {\n        id_cryptoctx->my_key = id_cryptoctx->creds[0]->key;\n        id_cryptoctx->creds[0]->key = NULL;     /* Don't free it twice */\n    }\n#ifndef WITHOUT_PKCS11\n    else {\n        id_cryptoctx->cert_id = id_cryptoctx->creds[0]->cert_id;\n        id_cryptoctx->creds[0]->cert_id = NULL; /* Don't free it twice */\n        id_cryptoctx->cert_id_len = id_cryptoctx->creds[0]->cert_id_len;\n    }\n#endif\n    retval = 0;\nerrout:\n    return retval;\n}\n\n\n\nstatic krb5_error_code\nload_cas_and_crls(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  int catype,\n                  char *filename)\n{\n    STACK_OF(X509_INFO) *sk = NULL;\n    STACK_OF(X509) *ca_certs = NULL;\n    STACK_OF(X509_CRL) *ca_crls = NULL;\n    BIO *in = NULL;\n    krb5_error_code retval = ENOMEM;\n    int i = 0;\n\n    /* If there isn't already a stack in the context,\n     * create a temporary one now */\n    switch(catype) {\n    case CATYPE_ANCHORS:\n        if (id_cryptoctx->trustedCAs != NULL)\n            ca_certs = id_cryptoctx->trustedCAs;\n        else {\n            ca_certs = sk_X509_new_null();\n            if (ca_certs == NULL)\n                return ENOMEM;\n        }\n        break;\n    case CATYPE_INTERMEDIATES:\n        if (id_cryptoctx->intermediateCAs != NULL)\n            ca_certs = id_cryptoctx->intermediateCAs;\n        else {\n            ca_certs = sk_X509_new_null();\n            if (ca_certs == NULL)\n                return ENOMEM;\n        }\n        break;\n    case CATYPE_CRLS:\n        if (id_cryptoctx->revoked != NULL)\n            ca_crls = id_cryptoctx->revoked;\n        else {\n            ca_crls = sk_X509_CRL_new_null();\n            if (ca_crls == NULL)\n                return ENOMEM;\n        }\n        break;\n    default:\n        return ENOTSUP;\n    }\n\n    if (!(in = BIO_new_file(filename, \"r\"))) {\n        retval = oerr(context, 0, _(\"Cannot open file '%s'\"), filename);\n        goto cleanup;\n    }\n\n    /* This loads from a file, a stack of x509/crl/pkey sets */\n    if ((sk = PEM_X509_INFO_read_bio(in, NULL, NULL, NULL)) == NULL) {\n        pkiDebug(\"%s: error reading file '%s'\\n\", __FUNCTION__, filename);\n        retval = oerr(context, 0, _(\"Cannot read file '%s'\"), filename);\n        goto cleanup;\n    }\n\n    /* scan over the stack created from loading the file contents,\n     * weed out duplicates, and push new ones onto the return stack\n     */\n    for (i = 0; i < sk_X509_INFO_num(sk); i++) {\n        X509_INFO *xi = sk_X509_INFO_value(sk, i);\n        if (xi != NULL && xi->x509 != NULL && catype != CATYPE_CRLS) {\n            int j = 0, size = sk_X509_num(ca_certs), flag = 0;\n\n            if (!size) {\n                sk_X509_push(ca_certs, xi->x509);\n                xi->x509 = NULL;\n                continue;\n            }\n            for (j = 0; j < size; j++) {\n                X509 *x = sk_X509_value(ca_certs, j);\n                flag = X509_cmp(x, xi->x509);\n                if (flag == 0)\n                    break;\n                else\n                    continue;\n            }\n            if (flag != 0) {\n                sk_X509_push(ca_certs, X509_dup(xi->x509));\n            }\n        } else if (xi != NULL && xi->crl != NULL && catype == CATYPE_CRLS) {\n            int j = 0, size = sk_X509_CRL_num(ca_crls), flag = 0;\n            if (!size) {\n                sk_X509_CRL_push(ca_crls, xi->crl);\n                xi->crl = NULL;\n                continue;\n            }\n            for (j = 0; j < size; j++) {\n                X509_CRL *x = sk_X509_CRL_value(ca_crls, j);\n                flag = X509_CRL_cmp(x, xi->crl);\n                if (flag == 0)\n                    break;\n                else\n                    continue;\n            }\n            if (flag != 0) {\n                sk_X509_CRL_push(ca_crls, X509_CRL_dup(xi->crl));\n            }\n        }\n    }\n\n    /* If we added something and there wasn't a stack in the\n     * context before, add the temporary stack to the context.\n     */\n    switch(catype) {\n    case CATYPE_ANCHORS:\n        if (sk_X509_num(ca_certs) == 0) {\n            TRACE_PKINIT_NO_CA_ANCHOR(context, filename);\n            if (id_cryptoctx->trustedCAs == NULL)\n                sk_X509_free(ca_certs);\n        } else {\n            if (id_cryptoctx->trustedCAs == NULL)\n                id_cryptoctx->trustedCAs = ca_certs;\n        }\n        break;\n    case CATYPE_INTERMEDIATES:\n        if (sk_X509_num(ca_certs) == 0) {\n            TRACE_PKINIT_NO_CA_INTERMEDIATE(context, filename);\n            if (id_cryptoctx->intermediateCAs == NULL)\n                sk_X509_free(ca_certs);\n        } else {\n            if (id_cryptoctx->intermediateCAs == NULL)\n                id_cryptoctx->intermediateCAs = ca_certs;\n        }\n        break;\n    case CATYPE_CRLS:\n        if (sk_X509_CRL_num(ca_crls) == 0) {\n            TRACE_PKINIT_NO_CRL(context, filename);\n            if (id_cryptoctx->revoked == NULL)\n                sk_X509_CRL_free(ca_crls);\n        } else {\n            if (id_cryptoctx->revoked == NULL)\n                id_cryptoctx->revoked = ca_crls;\n        }\n        break;\n    default:\n        /* Should have been caught above! */\n        retval = EINVAL;\n        goto cleanup;\n        break;\n    }\n\n    retval = 0;\n\ncleanup:\n    if (in != NULL)\n        BIO_free(in);\n    if (sk != NULL)\n        sk_X509_INFO_pop_free(sk, X509_INFO_free);\n\n    return retval;\n}\n\nstatic krb5_error_code\nload_cas_and_crls_dir(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      int catype,\n                      char *dirname)\n{\n    krb5_error_code retval = EINVAL;\n    DIR *d = NULL;\n    struct dirent *dentry = NULL;\n    char filename[1024];\n\n    if (dirname == NULL)\n        return EINVAL;\n\n    d = opendir(dirname);\n    if (d == NULL)\n        return ENOENT;\n\n    while ((dentry = readdir(d))) {\n        if (strlen(dirname) + strlen(dentry->d_name) + 2 > sizeof(filename)) {\n            pkiDebug(\"%s: Path too long -- directory '%s' and file '%s'\\n\",\n                     __FUNCTION__, dirname, dentry->d_name);\n            goto cleanup;\n        }\n        /* Ignore subdirectories and anything starting with a dot */\n#ifdef DT_DIR\n        if (dentry->d_type == DT_DIR)\n            continue;\n#endif\n        if (dentry->d_name[0] == '.')\n            continue;\n        snprintf(filename, sizeof(filename), \"%s/%s\", dirname, dentry->d_name);\n\n        retval = load_cas_and_crls(context, plg_cryptoctx, req_cryptoctx,\n                                   id_cryptoctx, catype, filename);\n        if (retval)\n            goto cleanup;\n    }\n\n    retval = 0;\n\ncleanup:\n    if (d != NULL)\n        closedir(d);\n\n    return retval;\n}\n\nkrb5_error_code\ncrypto_load_cas_and_crls(krb5_context context,\n                         pkinit_plg_crypto_context plg_cryptoctx,\n                         pkinit_req_crypto_context req_cryptoctx,\n                         pkinit_identity_opts *idopts,\n                         pkinit_identity_crypto_context id_cryptoctx,\n                         int idtype,\n                         int catype,\n                         char *id)\n{\n    switch (idtype) {\n    case IDTYPE_FILE:\n        TRACE_PKINIT_LOAD_FROM_FILE(context);\n        return load_cas_and_crls(context, plg_cryptoctx, req_cryptoctx,\n                                 id_cryptoctx, catype, id);\n        break;\n    case IDTYPE_DIR:\n        TRACE_PKINIT_LOAD_FROM_DIR(context);\n        return load_cas_and_crls_dir(context, plg_cryptoctx, req_cryptoctx,\n                                     id_cryptoctx, catype, id);\n        break;\n    default:\n        return ENOTSUP;\n        break;\n    }\n}\n\nstatic krb5_error_code\ncreate_identifiers_from_stack(STACK_OF(X509) *sk,\n                              krb5_external_principal_identifier *** ids)\n{\n    int i = 0, sk_size = sk_X509_num(sk);\n    krb5_external_principal_identifier **krb5_cas = NULL;\n    X509 *x = NULL;\n    X509_NAME *xn = NULL;\n    unsigned char *p = NULL;\n    int len = 0;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    char buf[DN_BUF_LEN];\n\n    *ids = NULL;\n\n    krb5_cas = calloc(sk_size + 1, sizeof(*krb5_cas));\n    if (krb5_cas == NULL)\n        return ENOMEM;\n\n    for (i = 0; i < sk_size; i++) {\n        krb5_cas[i] = malloc(sizeof(krb5_external_principal_identifier));\n\n        x = sk_X509_value(sk, i);\n\n        X509_NAME_oneline(X509_get_subject_name(x), buf, sizeof(buf));\n        pkiDebug(\"#%d cert= %s\\n\", i, buf);\n\n        /* fill-in subjectName */\n        krb5_cas[i]->subjectName.magic = 0;\n        krb5_cas[i]->subjectName.length = 0;\n        krb5_cas[i]->subjectName.data = NULL;\n\n        xn = X509_get_subject_name(x);\n        len = i2d_X509_NAME(xn, NULL);\n        if ((p = malloc((size_t) len)) == NULL)\n            goto oom;\n        krb5_cas[i]->subjectName.data = (char *)p;\n        i2d_X509_NAME(xn, &p);\n        krb5_cas[i]->subjectName.length = len;\n\n        /* fill-in issuerAndSerialNumber */\n        krb5_cas[i]->issuerAndSerialNumber.length = 0;\n        krb5_cas[i]->issuerAndSerialNumber.magic = 0;\n        krb5_cas[i]->issuerAndSerialNumber.data = NULL;\n\n        is = PKCS7_ISSUER_AND_SERIAL_new();\n        if (is == NULL)\n            goto oom;\n        X509_NAME_set(&is->issuer, X509_get_issuer_name(x));\n        ASN1_INTEGER_free(is->serial);\n        is->serial = ASN1_INTEGER_dup(X509_get_serialNumber(x));\n        if (is->serial == NULL)\n            goto oom;\n        len = i2d_PKCS7_ISSUER_AND_SERIAL(is, NULL);\n        p = malloc(len);\n        if (p == NULL)\n            goto oom;\n        krb5_cas[i]->issuerAndSerialNumber.data = (char *)p;\n        i2d_PKCS7_ISSUER_AND_SERIAL(is, &p);\n        krb5_cas[i]->issuerAndSerialNumber.length = len;\n\n        /* fill-in subjectKeyIdentifier */\n        krb5_cas[i]->subjectKeyIdentifier.length = 0;\n        krb5_cas[i]->subjectKeyIdentifier.magic = 0;\n        krb5_cas[i]->subjectKeyIdentifier.data = NULL;\n\n        if (X509_get_ext_by_NID(x, NID_subject_key_identifier, -1) >= 0) {\n            ASN1_OCTET_STRING *ikeyid;\n\n            ikeyid = X509_get_ext_d2i(x, NID_subject_key_identifier, NULL,\n                                      NULL);\n            if (ikeyid != NULL) {\n                len = i2d_ASN1_OCTET_STRING(ikeyid, NULL);\n                p = malloc(len);\n                if (p == NULL)\n                    goto oom;\n                krb5_cas[i]->subjectKeyIdentifier.data = (char *)p;\n                i2d_ASN1_OCTET_STRING(ikeyid, &p);\n                krb5_cas[i]->subjectKeyIdentifier.length = len;\n                ASN1_OCTET_STRING_free(ikeyid);\n            }\n        }\n        PKCS7_ISSUER_AND_SERIAL_free(is);\n        is = NULL;\n    }\n\n    *ids = krb5_cas;\n    return 0;\n\noom:\n    free_krb5_external_principal_identifier(&krb5_cas);\n    PKCS7_ISSUER_AND_SERIAL_free(is);\n    return ENOMEM;\n}\n\nstatic krb5_error_code\ncreate_krb5_invalidCertificates(krb5_context context,\n                                pkinit_plg_crypto_context plg_cryptoctx,\n                                pkinit_req_crypto_context req_cryptoctx,\n                                pkinit_identity_crypto_context id_cryptoctx,\n                                krb5_external_principal_identifier *** ids)\n{\n\n    krb5_error_code retval = ENOMEM;\n    STACK_OF(X509) *sk = NULL;\n\n    *ids = NULL;\n    if (req_cryptoctx->received_cert == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    sk = sk_X509_new_null();\n    if (sk == NULL)\n        goto cleanup;\n    sk_X509_push(sk, req_cryptoctx->received_cert);\n\n    retval = create_identifiers_from_stack(sk, ids);\n\n    sk_X509_free(sk);\ncleanup:\n\n    return retval;\n}\n\nkrb5_error_code\ncreate_krb5_supportedCMSTypes(krb5_context context,\n                              pkinit_plg_crypto_context plg_cryptoctx,\n                              pkinit_req_crypto_context req_cryptoctx,\n                              pkinit_identity_crypto_context id_cryptoctx,\n                              krb5_algorithm_identifier ***oids)\n{\n\n    krb5_error_code retval = ENOMEM;\n    krb5_algorithm_identifier **loids = NULL;\n    krb5_data des3oid = {0, 8, \"\\x2A\\x86\\x48\\x86\\xF7\\x0D\\x03\\x07\" };\n\n    *oids = NULL;\n    loids = malloc(2 * sizeof(krb5_algorithm_identifier *));\n    if (loids == NULL)\n        goto cleanup;\n    loids[1] = NULL;\n    loids[0] = malloc(sizeof(krb5_algorithm_identifier));\n    if (loids[0] == NULL) {\n        free(loids);\n        goto cleanup;\n    }\n    retval = pkinit_copy_krb5_data(&loids[0]->algorithm, &des3oid);\n    if (retval) {\n        free(loids[0]);\n        free(loids);\n        goto cleanup;\n    }\n    loids[0]->parameters.length = 0;\n    loids[0]->parameters.data = NULL;\n\n    *oids = loids;\n    retval = 0;\ncleanup:\n\n    return retval;\n}\n\nkrb5_error_code\ncreate_krb5_trustedCertifiers(krb5_context context,\n                              pkinit_plg_crypto_context plg_cryptoctx,\n                              pkinit_req_crypto_context req_cryptoctx,\n                              pkinit_identity_crypto_context id_cryptoctx,\n                              krb5_external_principal_identifier *** ids)\n{\n\n    krb5_error_code retval = ENOMEM;\n    STACK_OF(X509) *sk = id_cryptoctx->trustedCAs;\n\n    *ids = NULL;\n    if (id_cryptoctx->trustedCAs == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    retval = create_identifiers_from_stack(sk, ids);\n\n    return retval;\n}\n\nkrb5_error_code\ncreate_issuerAndSerial(krb5_context context,\n                       pkinit_plg_crypto_context plg_cryptoctx,\n                       pkinit_req_crypto_context req_cryptoctx,\n                       pkinit_identity_crypto_context id_cryptoctx,\n                       unsigned char **out,\n                       unsigned int *out_len)\n{\n    unsigned char *p = NULL;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    int len = 0;\n    krb5_error_code retval = ENOMEM;\n    X509 *cert = req_cryptoctx->received_cert;\n\n    *out = NULL;\n    *out_len = 0;\n    if (req_cryptoctx->received_cert == NULL)\n        return 0;\n\n    is = PKCS7_ISSUER_AND_SERIAL_new();\n    X509_NAME_set(&is->issuer, X509_get_issuer_name(cert));\n    ASN1_INTEGER_free(is->serial);\n    is->serial = ASN1_INTEGER_dup(X509_get_serialNumber(cert));\n    len = i2d_PKCS7_ISSUER_AND_SERIAL(is, NULL);\n    if ((p = *out = malloc((size_t) len)) == NULL)\n        goto cleanup;\n    i2d_PKCS7_ISSUER_AND_SERIAL(is, &p);\n    *out_len = len;\n    retval = 0;\n\ncleanup:\n    X509_NAME_free(is->issuer);\n    ASN1_INTEGER_free(is->serial);\n    free(is);\n\n    return retval;\n}\n\nstatic int\npkcs7_decrypt(krb5_context context,\n              pkinit_identity_crypto_context id_cryptoctx,\n              PKCS7 *p7,\n              BIO *data)\n{\n    BIO *tmpmem = NULL;\n    int retval = 0, i = 0;\n    char buf[4096];\n\n    if(p7 == NULL)\n        return 0;\n\n    if(!PKCS7_type_is_enveloped(p7)) {\n        pkiDebug(\"wrong pkcs7 content type\\n\");\n        return 0;\n    }\n\n    if(!(tmpmem = pkcs7_dataDecode(context, id_cryptoctx, p7))) {\n        pkiDebug(\"unable to decrypt pkcs7 object\\n\");\n        return 0;\n    }\n\n    for(;;) {\n        i = BIO_read(tmpmem, buf, sizeof(buf));\n        if (i <= 0) break;\n        BIO_write(data, buf, i);\n        BIO_free_all(tmpmem);\n        return 1;\n    }\n    return retval;\n}\n\nkrb5_error_code\npkinit_process_td_trusted_certifiers(\n    krb5_context context,\n    pkinit_plg_crypto_context plg_cryptoctx,\n    pkinit_req_crypto_context req_cryptoctx,\n    pkinit_identity_crypto_context id_cryptoctx,\n    krb5_external_principal_identifier **krb5_trusted_certifiers,\n    int td_type)\n{\n    krb5_error_code retval = ENOMEM;\n    STACK_OF(X509_NAME) *sk_xn = NULL;\n    X509_NAME *xn = NULL;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    ASN1_OCTET_STRING *id = NULL;\n    const unsigned char *p = NULL;\n    char buf[DN_BUF_LEN];\n    int i = 0;\n\n    if (td_type == TD_TRUSTED_CERTIFIERS)\n        pkiDebug(\"received trusted certifiers\\n\");\n    else\n        pkiDebug(\"received invalid certificate\\n\");\n\n    sk_xn = sk_X509_NAME_new_null();\n    while(krb5_trusted_certifiers[i] != NULL) {\n        if (krb5_trusted_certifiers[i]->subjectName.data != NULL) {\n            p = (unsigned char *)krb5_trusted_certifiers[i]->subjectName.data;\n            xn = d2i_X509_NAME(NULL, &p,\n                               (int)krb5_trusted_certifiers[i]->subjectName.length);\n            if (xn == NULL)\n                goto cleanup;\n            X509_NAME_oneline(xn, buf, sizeof(buf));\n            if (td_type == TD_TRUSTED_CERTIFIERS)\n                pkiDebug(\"#%d cert = %s is trusted by kdc\\n\", i, buf);\n            else\n                pkiDebug(\"#%d cert = %s is invalid\\n\", i, buf);\n            sk_X509_NAME_push(sk_xn, xn);\n        }\n\n        if (krb5_trusted_certifiers[i]->issuerAndSerialNumber.data != NULL) {\n            p = (unsigned char *)\n                krb5_trusted_certifiers[i]->issuerAndSerialNumber.data;\n            is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p,\n                                             (int)krb5_trusted_certifiers[i]->issuerAndSerialNumber.length);\n            if (is == NULL)\n                goto cleanup;\n            X509_NAME_oneline(is->issuer, buf, sizeof(buf));\n            if (td_type == TD_TRUSTED_CERTIFIERS)\n                pkiDebug(\"#%d issuer = %s serial = %ld is trusted bu kdc\\n\", i,\n                         buf, ASN1_INTEGER_get(is->serial));\n            else\n                pkiDebug(\"#%d issuer = %s serial = %ld is invalid\\n\", i, buf,\n                         ASN1_INTEGER_get(is->serial));\n            PKCS7_ISSUER_AND_SERIAL_free(is);\n        }\n\n        if (krb5_trusted_certifiers[i]->subjectKeyIdentifier.data != NULL) {\n            p = (unsigned char *)\n                krb5_trusted_certifiers[i]->subjectKeyIdentifier.data;\n            id = d2i_ASN1_OCTET_STRING(NULL, &p,\n                                       (int)krb5_trusted_certifiers[i]->subjectKeyIdentifier.length);\n            if (id == NULL)\n                goto cleanup;\n            /* XXX */\n            ASN1_OCTET_STRING_free(id);\n        }\n        i++;\n    }\n    /* XXX Since we not doing anything with received trusted certifiers\n     * return an error. this is the place where we can pick a different\n     * client certificate based on the information in td_trusted_certifiers\n     */\n    retval = KRB5KDC_ERR_PREAUTH_FAILED;\ncleanup:\n    if (sk_xn != NULL)\n        sk_X509_NAME_pop_free(sk_xn, X509_NAME_free);\n\n    return retval;\n}\n\nstatic BIO *\npkcs7_dataDecode(krb5_context context,\n                 pkinit_identity_crypto_context id_cryptoctx,\n                 PKCS7 *p7)\n{\n    unsigned int eklen=0, tkeylen=0;\n    BIO *out=NULL,*etmp=NULL,*bio=NULL;\n    unsigned char *ek=NULL, *tkey=NULL;\n    ASN1_OCTET_STRING *data_body=NULL;\n    const EVP_CIPHER *evp_cipher=NULL;\n    EVP_CIPHER_CTX *evp_ctx=NULL;\n    X509_ALGOR *enc_alg=NULL;\n    STACK_OF(PKCS7_RECIP_INFO) *rsk=NULL;\n    PKCS7_RECIP_INFO *ri=NULL;\n\n    p7->state=PKCS7_S_HEADER;\n\n    rsk=p7->d.enveloped->recipientinfo;\n    enc_alg=p7->d.enveloped->enc_data->algorithm;\n    data_body=p7->d.enveloped->enc_data->enc_data;\n    evp_cipher=EVP_get_cipherbyobj(enc_alg->algorithm);\n    if (evp_cipher == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n        goto cleanup;\n    }\n\n    if ((etmp=BIO_new(BIO_f_cipher())) == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_BIO_LIB);\n        goto cleanup;\n    }\n\n    /* It was encrypted, we need to decrypt the secret key\n     * with the private key */\n\n    /* RFC 4556 section 3.2.3.2 requires that there be exactly one\n     * recipientInfo. */\n    if (sk_PKCS7_RECIP_INFO_num(rsk) != 1) {\n        pkiDebug(\"invalid number of EnvelopedData RecipientInfos\\n\");\n        goto cleanup;\n    }\n\n    ri = sk_PKCS7_RECIP_INFO_value(rsk, 0);\n    (void)pkinit_decode_data(context, id_cryptoctx,\n                             ASN1_STRING_get0_data(ri->enc_key),\n                             ASN1_STRING_length(ri->enc_key), &ek, &eklen);\n\n    evp_ctx=NULL;\n    BIO_get_cipher_ctx(etmp,&evp_ctx);\n    if (EVP_CipherInit_ex(evp_ctx,evp_cipher,NULL,NULL,NULL,0) <= 0)\n        goto cleanup;\n    if (EVP_CIPHER_asn1_to_param(evp_ctx,enc_alg->parameter) < 0)\n        goto cleanup;\n\n    /* Generate a random symmetric key to avoid exposing timing data if RSA\n     * decryption fails the padding check. */\n    tkeylen = EVP_CIPHER_CTX_key_length(evp_ctx);\n    tkey = OPENSSL_malloc(tkeylen);\n    if (tkey == NULL)\n        goto cleanup;\n    if (EVP_CIPHER_CTX_rand_key(evp_ctx, tkey) <= 0)\n        goto cleanup;\n    if (ek == NULL) {\n        ek = tkey;\n        eklen = tkeylen;\n        tkey = NULL;\n    }\n\n    if (eklen != (unsigned)EVP_CIPHER_CTX_key_length(evp_ctx)) {\n        /* Some S/MIME clients don't use the same key\n         * and effective key length. The key length is\n         * determined by the size of the decrypted RSA key.\n         */\n        if (!EVP_CIPHER_CTX_set_key_length(evp_ctx, (int)eklen)) {\n            ek = tkey;\n            eklen = tkeylen;\n            tkey = NULL;\n        }\n    }\n    if (EVP_CipherInit_ex(evp_ctx,NULL,NULL,ek,NULL,0) <= 0)\n        goto cleanup;\n\n    if (out == NULL)\n        out=etmp;\n    else\n        BIO_push(out,etmp);\n    etmp=NULL;\n\n    if (data_body->length > 0)\n        bio = BIO_new_mem_buf(data_body->data, data_body->length);\n    else {\n        bio=BIO_new(BIO_s_mem());\n        BIO_set_mem_eof_return(bio,0);\n    }\n    BIO_push(out,bio);\n    bio=NULL;\n\n    if (0) {\n    cleanup:\n        if (out != NULL) BIO_free_all(out);\n        if (etmp != NULL) BIO_free_all(etmp);\n        if (bio != NULL) BIO_free_all(bio);\n        out=NULL;\n    }\n    if (ek != NULL) {\n        OPENSSL_cleanse(ek, eklen);\n        OPENSSL_free(ek);\n    }\n    if (tkey != NULL) {\n        OPENSSL_cleanse(tkey, tkeylen);\n        OPENSSL_free(tkey);\n    }\n    return(out);\n}\n\n#ifdef DEBUG_DH\nstatic void\nprint_dh(DH * dh, char *msg)\n{\n    BIO *bio_err = NULL;\n\n    bio_err = BIO_new(BIO_s_file());\n    BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\n\n    if (msg)\n        BIO_puts(bio_err, (const char *)msg);\n    if (dh)\n        DHparams_print(bio_err, dh);\n\n    BIO_puts(bio_err, \"private key: \");\n    BN_print(bio_err, dh->priv_key);\n    BIO_puts(bio_err, (const char *)\"\\n\");\n    BIO_free(bio_err);\n\n}\n\nstatic void\nprint_pubkey(BIGNUM * key, char *msg)\n{\n    BIO *bio_err = NULL;\n\n    bio_err = BIO_new(BIO_s_file());\n    BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\n\n    if (msg)\n        BIO_puts(bio_err, (const char *)msg);\n    if (key)\n        BN_print(bio_err, key);\n    BIO_puts(bio_err, \"\\n\");\n\n    BIO_free(bio_err);\n\n}\n#endif\n\nstatic char *\npkinit_pkcs11_code_to_text(int err)\n{\n    int i;\n    static char uc[32];\n\n    for (i = 0; pkcs11_errstrings[i].text != NULL; i++)\n        if (pkcs11_errstrings[i].code == err)\n            break;\n    if (pkcs11_errstrings[i].text != NULL)\n        return (pkcs11_errstrings[i].text);\n    snprintf(uc, sizeof(uc), _(\"unknown code 0x%x\"), err);\n    return (uc);\n}\n\n/*\n * Add an item to the pkinit_identity_crypto_context's list of deferred\n * identities.\n */\nkrb5_error_code\ncrypto_set_deferred_id(krb5_context context,\n                       pkinit_identity_crypto_context id_cryptoctx,\n                       const char *identity, const char *password)\n{\n    unsigned long ck_flags;\n\n    ck_flags = pkinit_get_deferred_id_flags(id_cryptoctx->deferred_ids,\n                                            identity);\n    return pkinit_set_deferred_id(&id_cryptoctx->deferred_ids,\n                                  identity, ck_flags, password);\n}\n\n/*\n * Retrieve a read-only copy of the pkinit_identity_crypto_context's list of\n * deferred identities, sure to be valid only until the next time someone calls\n * either pkinit_set_deferred_id() or crypto_set_deferred_id().\n */\nconst pkinit_deferred_id *\ncrypto_get_deferred_ids(krb5_context context,\n                        pkinit_identity_crypto_context id_cryptoctx)\n{\n    pkinit_deferred_id *deferred;\n    const pkinit_deferred_id *ret;\n\n    deferred = id_cryptoctx->deferred_ids;\n    ret = (const pkinit_deferred_id *)deferred;\n    return ret;\n}\n\n/* Return the received certificate as DER-encoded data. */\nkrb5_error_code\ncrypto_encode_der_cert(krb5_context context, pkinit_req_crypto_context reqctx,\n                       uint8_t **der_out, size_t *der_len)\n{\n    int len;\n    unsigned char *der, *p;\n\n    *der_out = NULL;\n    *der_len = 0;\n\n    if (reqctx->received_cert == NULL)\n        return EINVAL;\n    p = NULL;\n    len = i2d_X509(reqctx->received_cert, NULL);\n    if (len <= 0)\n        return EINVAL;\n    p = der = malloc(len);\n    if (der == NULL)\n        return ENOMEM;\n    if (i2d_X509(reqctx->received_cert, &p) <= 0) {\n        free(der);\n        return EINVAL;\n    }\n    *der_out = der;\n    *der_len = len;\n    return 0;\n}\n\n/*\n * Get the certificate matching data from the request certificate.\n */\nkrb5_error_code\ncrypto_req_cert_matching_data(krb5_context context,\n                              pkinit_plg_crypto_context plgctx,\n                              pkinit_req_crypto_context reqctx,\n                              pkinit_cert_matching_data **md_out)\n{\n    *md_out = NULL;\n\n    if (reqctx == NULL || reqctx->received_cert == NULL)\n        return ENOENT;\n\n    return get_matching_data(context, plgctx, reqctx, reqctx->received_cert,\n                             md_out);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/util/support/plugins.c": "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* util/support/plugins.c - Plugin module support functions */\n/*\n * Copyright 2006, 2008 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n#include \"k5-platform.h\"\n#include \"k5-plugin.h\"\n#if USE_DLOPEN\n#include <dlfcn.h>\n#endif\n#include <sys/types.h>\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#if USE_DLOPEN\n#ifdef RTLD_GROUP\n#define GROUP RTLD_GROUP\n#else\n#define GROUP 0\n#endif\n#ifdef RTLD_NODELETE\n#define NODELETE RTLD_NODELETE\n#else\n#define NODELETE 0\n#endif\n#define PLUGIN_DLOPEN_FLAGS (RTLD_NOW | RTLD_LOCAL | GROUP | NODELETE)\n#endif\n\n#if USE_DLOPEN && USE_CFBUNDLE\n#include <CoreFoundation/CoreFoundation.h>\n\n/* Currently CoreFoundation only exists on the Mac so we just use\n * pthreads directly to avoid creating empty function calls on other\n * platforms.  If a thread initializer ever gets created in the common\n * plugin code, move this there */\nstatic pthread_mutex_t krb5int_bundle_mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif\n\n#include <stdarg.h>\nstatic void Tprintf (const char *fmt, ...)\n{\n#ifdef DEBUG\n    va_list va;\n    va_start (va, fmt);\n    vfprintf (stderr, fmt, va);\n    va_end (va);\n#endif\n}\n\nstruct plugin_file_handle {\n#if USE_DLOPEN\n    void *dlhandle;\n#endif\n#ifdef _WIN32\n    HMODULE hinstPlugin;\n#endif\n#if !defined (USE_DLOPEN) && !defined (_WIN32)\n    char dummy;\n#endif\n};\n\n#ifdef _WIN32\nstruct dirent {\n    long d_ino;                 /* inode (always 1 in WIN32) */\n    off_t d_off;                /* offset to this dirent */\n    unsigned short d_reclen;    /* length of d_name */\n    char d_name[_MAX_FNAME+1];  /* filename (null terminated) */\n};\n\ntypedef struct {\n    intptr_t handle;            /* _findfirst/_findnext handle */\n    short offset;               /* offset into directory */\n    short finished;             /* 1 if there are not more files */\n    struct _finddata_t fileinfo;/* from _findfirst/_findnext */\n    char *dir;                  /* the dir we are reading */\n    struct dirent dent;         /* the dirent to return */\n} DIR;\n\nDIR * opendir(const char *dir)\n{\n    DIR *dp;\n    char *filespec;\n    intptr_t handle;\n    int index;\n\n    filespec = malloc(strlen(dir) + 2 + 1);\n    strcpy(filespec, dir);\n    index = strlen(filespec) - 1;\n    if (index >= 0 && (filespec[index] == '/' || filespec[index] == '\\\\'))\n        filespec[index] = '\\0';\n    strcat(filespec, \"/*\");\n\n    dp = (DIR *)malloc(sizeof(DIR));\n    dp->offset = 0;\n    dp->finished = 0;\n    dp->dir = strdup(dir);\n\n    if ((handle = _findfirst(filespec, &(dp->fileinfo))) < 0) {\n        if (errno == ENOENT)\n            dp->finished = 1;\n        else {\n            free(filespec);\n            free(dp->dir);\n            free(dp);\n            return NULL;\n        }\n    }\n\n    dp->handle = handle;\n    free(filespec);\n\n    return dp;\n}\n\nstruct dirent * readdir(DIR *dp)\n{\n    if (!dp || dp->finished) return NULL;\n\n    if (dp->offset != 0) {\n        if (_findnext(dp->handle, &(dp->fileinfo)) < 0) {\n            dp->finished = 1;\n            return NULL;\n        }\n    }\n    dp->offset++;\n\n    strncpy(dp->dent.d_name, dp->fileinfo.name, _MAX_FNAME);\n    dp->dent.d_ino = 1;\n    dp->dent.d_reclen = (unsigned short)strlen(dp->dent.d_name);\n    dp->dent.d_off = dp->offset;\n\n    return &(dp->dent);\n}\n\nint closedir(DIR *dp)\n{\n    if (!dp) return 0;\n    _findclose(dp->handle);\n    free(dp->dir);\n    free(dp);\n\n    return 0;\n}\n#endif\n\nlong KRB5_CALLCONV\nkrb5int_open_plugin (const char *filepath, struct plugin_file_handle **h, struct errinfo *ep)\n{\n    long err = 0;\n    struct stat statbuf;\n    struct plugin_file_handle *htmp = NULL;\n    int got_plugin = 0;\n\n    if (!err) {\n        if (stat (filepath, &statbuf) < 0) {\n            err = errno;\n            Tprintf (\"stat(%s): %s\\n\", filepath, strerror (err));\n            k5_set_error(ep, err, _(\"unable to find plugin [%s]: %s\"),\n                         filepath, strerror(err));\n        }\n    }\n\n    if (!err) {\n        htmp = calloc (1, sizeof (*htmp)); /* calloc initializes ptrs to NULL */\n        if (htmp == NULL) { err = ENOMEM; }\n    }\n\n#if USE_DLOPEN\n    if (!err && ((statbuf.st_mode & S_IFMT) == S_IFREG\n#if USE_CFBUNDLE\n                 || (statbuf.st_mode & S_IFMT) == S_IFDIR\n#endif /* USE_CFBUNDLE */\n        )) {\n        void *handle = NULL;\n\n#if USE_CFBUNDLE\n        char executablepath[MAXPATHLEN];\n\n        if ((statbuf.st_mode & S_IFMT) == S_IFDIR) {\n            int lock_err = 0;\n            CFStringRef pluginString = NULL;\n            CFURLRef pluginURL = NULL;\n            CFBundleRef pluginBundle = NULL;\n            CFURLRef executableURL = NULL;\n\n            /* Lock around CoreFoundation calls since objects are refcounted\n             * and the refcounts are not thread-safe.  Using pthreads directly\n             * because this code is Mac-specific */\n            lock_err = pthread_mutex_lock(&krb5int_bundle_mutex);\n            if (lock_err) { err = lock_err; }\n\n            if (!err) {\n                pluginString = CFStringCreateWithCString (kCFAllocatorDefault,\n                                                          filepath,\n                                                          kCFStringEncodingASCII);\n                if (pluginString == NULL) { err = ENOMEM; }\n            }\n\n            if (!err) {\n                pluginURL = CFURLCreateWithFileSystemPath (kCFAllocatorDefault,\n                                                           pluginString,\n                                                           kCFURLPOSIXPathStyle,\n                                                           true);\n                if (pluginURL == NULL) { err = ENOMEM; }\n            }\n\n            if (!err) {\n                pluginBundle = CFBundleCreate (kCFAllocatorDefault, pluginURL);\n                if (pluginBundle == NULL) { err = ENOENT; } /* XXX need better error */\n            }\n\n            if (!err) {\n                executableURL = CFBundleCopyExecutableURL (pluginBundle);\n                if (executableURL == NULL) { err = ENOMEM; }\n            }\n\n            if (!err) {\n                if (!CFURLGetFileSystemRepresentation (executableURL,\n                                                       true, /* absolute */\n                                                       (UInt8 *)executablepath,\n                                                       sizeof (executablepath))) {\n                    err = ENOMEM;\n                }\n            }\n\n            if (!err) {\n                /* override the path the caller passed in */\n                filepath = executablepath;\n            }\n\n            if (executableURL    != NULL) { CFRelease (executableURL); }\n            if (pluginBundle     != NULL) { CFRelease (pluginBundle); }\n            if (pluginURL        != NULL) { CFRelease (pluginURL); }\n            if (pluginString     != NULL) { CFRelease (pluginString); }\n\n            /* unlock after CFRelease calls since they modify refcounts */\n            if (!lock_err) { pthread_mutex_unlock (&krb5int_bundle_mutex); }\n        }\n#endif /* USE_CFBUNDLE */\n\n        if (!err) {\n            handle = dlopen(filepath, PLUGIN_DLOPEN_FLAGS);\n            if (handle == NULL) {\n                const char *e = dlerror();\n                if (e == NULL)\n                    e = _(\"unknown failure\");\n                Tprintf (\"dlopen(%s): %s\\n\", filepath, e);\n                err = ENOENT; /* XXX */\n                k5_set_error(ep, err, _(\"unable to load plugin [%s]: %s\"),\n                             filepath, e);\n            }\n        }\n\n        if (!err) {\n            got_plugin = 1;\n            htmp->dlhandle = handle;\n            handle = NULL;\n        }\n\n        if (handle != NULL) { dlclose (handle); }\n    }\n#endif /* USE_DLOPEN */\n\n#ifdef _WIN32\n    if (!err && (statbuf.st_mode & S_IFMT) == S_IFREG) {\n        HMODULE handle = NULL;\n\n        handle = LoadLibrary(filepath);\n        if (handle == NULL) {\n            Tprintf (\"Unable to load dll: %s\\n\", filepath);\n            err = ENOENT; /* XXX */\n            k5_set_error(ep, err, _(\"unable to load DLL [%s]\"), filepath);\n        }\n\n        if (!err) {\n            got_plugin = 1;\n            htmp->hinstPlugin = handle;\n            handle = NULL;\n        }\n\n        if (handle != NULL)\n            FreeLibrary(handle);\n    }\n#endif\n\n    if (!err && !got_plugin) {\n        err = ENOENT;  /* no plugin or no way to load plugins */\n        k5_set_error(ep, err, _(\"plugin unavailable: %s\"), strerror(err));\n    }\n\n    if (!err) {\n        *h = htmp;\n        htmp = NULL;  /* h takes ownership */\n    }\n\n    free(htmp);\n\n    return err;\n}\n\nstatic long\nkrb5int_get_plugin_sym (struct plugin_file_handle *h,\n                        const char *csymname, int isfunc, void **ptr,\n                        struct errinfo *ep)\n{\n    long err = 0;\n    void *sym = NULL;\n\n#if USE_DLOPEN\n    if (!err && !sym && (h->dlhandle != NULL)) {\n        /* XXX Do we need to add a leading \"_\" to the symbol name on any\n           modern platforms?  */\n        sym = dlsym (h->dlhandle, csymname);\n        if (sym == NULL) {\n            const char *e = dlerror (); /* XXX copy and save away */\n            if (e == NULL)\n                e = \"unknown failure\";\n            Tprintf (\"dlsym(%s): %s\\n\", csymname, e);\n            err = ENOENT; /* XXX */\n            k5_set_error(ep, err, \"%s\", e);\n        }\n    }\n#endif\n\n#ifdef _WIN32\n    LPVOID lpMsgBuf;\n    DWORD dw;\n\n    if (!err && !sym && (h->hinstPlugin != NULL)) {\n        sym = GetProcAddress(h->hinstPlugin, csymname);\n        if (sym == NULL) {\n            const char *e = \"unable to get dll symbol\"; /* XXX copy and save away */\n            Tprintf (\"GetProcAddress(%s): %i\\n\", csymname, GetLastError());\n            err = ENOENT; /* XXX */\n            k5_set_error(ep, err, \"%s\", e);\n\n            dw = GetLastError();\n            if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                              FORMAT_MESSAGE_FROM_SYSTEM,\n                              NULL,\n                              dw,\n                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                              (LPTSTR) &lpMsgBuf,\n                              0, NULL )) {\n\n                fprintf (stderr, \"unable to get dll symbol, %s\\n\", (LPCTSTR)lpMsgBuf);\n                LocalFree(lpMsgBuf);\n            }\n        }\n    }\n#endif\n\n    if (!err && (sym == NULL)) {\n        err = ENOENT;  /* unimplemented */\n    }\n\n    if (!err) {\n        *ptr = sym;\n    }\n\n    return err;\n}\n\nlong KRB5_CALLCONV\nkrb5int_get_plugin_data (struct plugin_file_handle *h, const char *csymname,\n                         void **ptr, struct errinfo *ep)\n{\n    return krb5int_get_plugin_sym (h, csymname, 0, ptr, ep);\n}\n\nlong KRB5_CALLCONV\nkrb5int_get_plugin_func (struct plugin_file_handle *h, const char *csymname,\n                         void (**ptr)(), struct errinfo *ep)\n{\n    void *dptr = NULL;\n    long err = krb5int_get_plugin_sym (h, csymname, 1, &dptr, ep);\n    if (!err) {\n        /* Cast function pointers to avoid code duplication */\n        *ptr = (void (*)()) dptr;\n    }\n    return err;\n}\n\nvoid KRB5_CALLCONV\nkrb5int_close_plugin (struct plugin_file_handle *h)\n{\n#if USE_DLOPEN\n    if (h->dlhandle != NULL) { dlclose(h->dlhandle); }\n#endif\n#ifdef _WIN32\n    if (h->hinstPlugin != NULL) { FreeLibrary(h->hinstPlugin); }\n#endif\n    free (h);\n}\n\n/* autoconf docs suggest using this preference order */\n#if HAVE_DIRENT_H || USE_DIRENT_H\n#include <dirent.h>\n#define NAMELEN(D) strlen((D)->d_name)\n#else\n#ifndef _WIN32\n#define dirent direct\n#define NAMELEN(D) ((D)->d->namlen)\n#else\n#define NAMELEN(D) strlen((D)->d_name)\n#endif\n#if HAVE_SYS_NDIR_H\n# include <sys/ndir.h>\n#elif HAVE_SYS_DIR_H\n# include <sys/dir.h>\n#elif HAVE_NDIR_H\n# include <ndir.h>\n#endif\n#endif\n\nstatic long\nkrb5int_plugin_file_handle_array_init (struct plugin_file_handle ***harray)\n{\n    long err = 0;\n\n    *harray = calloc (1, sizeof (**harray)); /* calloc initializes to NULL */\n    if (*harray == NULL) { err = ENOMEM; }\n\n    return err;\n}\n\nstatic long\nkrb5int_plugin_file_handle_array_add (struct plugin_file_handle ***harray, size_t *count,\n                                      struct plugin_file_handle *p)\n{\n    long err = 0;\n    struct plugin_file_handle **newharray = NULL;\n    size_t newcount = *count + 1;\n\n    newharray = realloc (*harray, ((newcount + 1) * sizeof (**harray))); /* +1 for NULL */\n    if (newharray == NULL) {\n        err = ENOMEM;\n    } else {\n        newharray[newcount - 1] = p;\n        newharray[newcount] = NULL;\n        *count = newcount;\n        *harray = newharray;\n    }\n\n    return err;\n}\n\nstatic void\nkrb5int_plugin_file_handle_array_free (struct plugin_file_handle **harray)\n{\n    if (harray != NULL) {\n        int i;\n        for (i = 0; harray[i] != NULL; i++) {\n            krb5int_close_plugin (harray[i]);\n        }\n        free (harray);\n    }\n}\n\n#if TARGET_OS_MAC\n#define FILEEXTS { \"\", \".bundle\", \".dylib\", \".so\", NULL }\n#elif defined(_WIN32)\n#define FILEEXTS  { \"\", \".dll\", NULL }\n#else\n#define FILEEXTS  { \"\", \".so\", NULL }\n#endif\n\n\nstatic void\nkrb5int_free_plugin_filenames (char **filenames)\n{\n    if (filenames != NULL) {\n        int i;\n        for (i = 0; filenames[i] != NULL; i++) {\n            free (filenames[i]);\n        }\n        free (filenames);\n    }\n}\n\n\nstatic long\nkrb5int_get_plugin_filenames (const char * const *filebases, char ***filenames)\n{\n    long err = 0;\n    static const char *const fileexts[] = FILEEXTS;\n    char **tempnames = NULL;\n    size_t bases_count = 0;\n    size_t exts_count = 0;\n    size_t i;\n\n    if (!filebases) { err = EINVAL; }\n    if (!filenames) { err = EINVAL; }\n\n    if (!err) {\n        for (i = 0; filebases[i]; i++) { bases_count++; }\n        for (i = 0; fileexts[i]; i++) { exts_count++; }\n        tempnames = calloc ((bases_count * exts_count)+1, sizeof (char *));\n        if (!tempnames) { err = ENOMEM; }\n    }\n\n    if (!err) {\n        size_t j;\n        for (i = 0; !err && filebases[i]; i++) {\n            for (j = 0; !err && fileexts[j]; j++) {\n                if (asprintf(&tempnames[(i*exts_count)+j], \"%s%s\",\n                             filebases[i], fileexts[j]) < 0) {\n                    tempnames[(i*exts_count)+j] = NULL;\n                    err = ENOMEM;\n                }\n            }\n        }\n        tempnames[bases_count * exts_count] = NULL; /* NUL-terminate */\n    }\n\n    if (!err) {\n        *filenames = tempnames;\n        tempnames = NULL;\n    }\n\n    krb5int_free_plugin_filenames(tempnames);\n\n    return err;\n}\n\n\n/* Takes a NULL-terminated list of directories.  If filebases is NULL, filebases is ignored\n * all plugins in the directories are loaded.  If filebases is a NULL-terminated array of names,\n * only plugins in the directories with those name (plus any platform extension) are loaded. */\n\nlong KRB5_CALLCONV\nkrb5int_open_plugin_dirs (const char * const *dirnames,\n                          const char * const *filebases,\n                          struct plugin_dir_handle *dirhandle,\n                          struct errinfo *ep)\n{\n    long err = 0;\n    struct plugin_file_handle **h = NULL;\n    size_t count = 0;\n    char **filenames = NULL;\n    int i;\n\n    if (!err) {\n        err = krb5int_plugin_file_handle_array_init (&h);\n    }\n\n    if (!err && (filebases != NULL)) {\n        err = krb5int_get_plugin_filenames (filebases, &filenames);\n    }\n\n    for (i = 0; !err && dirnames[i] != NULL; i++) {\n        if (filenames != NULL) {\n            /* load plugins with names from filenames from each directory */\n            int j;\n\n            for (j = 0; !err && filenames[j] != NULL; j++) {\n                struct plugin_file_handle *handle = NULL;\n                char *filepath = NULL;\n\n                if (!err) {\n                    if (asprintf(&filepath, \"%s/%s\", dirnames[i], filenames[j]) < 0) {\n                        filepath = NULL;\n                        err = ENOMEM;\n                    }\n                }\n\n                if (!err && krb5int_open_plugin(filepath, &handle, ep) == 0) {\n                    err = krb5int_plugin_file_handle_array_add (&h, &count, handle);\n                    if (!err)\n                        handle = NULL; /* h takes ownership */\n                }\n\n                free(filepath);\n                if (handle   != NULL) { krb5int_close_plugin (handle); }\n            }\n        } else {\n            /* load all plugins in each directory */\n            DIR *dir = opendir (dirnames[i]);\n\n            while (dir != NULL && !err) {\n                struct dirent *d = NULL;\n                char *filepath = NULL;\n                struct plugin_file_handle *handle = NULL;\n\n                d = readdir (dir);\n                if (d == NULL) { break; }\n\n                if ((strcmp (d->d_name, \".\") == 0) ||\n                    (strcmp (d->d_name, \"..\") == 0)) {\n                    continue;\n                }\n\n                if (!err) {\n                    int len = NAMELEN (d);\n                    if (asprintf(&filepath, \"%s/%*s\", dirnames[i], len, d->d_name) < 0) {\n                        filepath = NULL;\n                        err = ENOMEM;\n                    }\n                }\n\n                if (!err) {\n                    if (krb5int_open_plugin (filepath, &handle, ep) == 0) {\n                        err = krb5int_plugin_file_handle_array_add (&h, &count, handle);\n                        if (!err) { handle = NULL; }  /* h takes ownership */\n                    }\n                }\n\n                free(filepath);\n                if (handle    != NULL) { krb5int_close_plugin (handle); }\n            }\n\n            if (dir != NULL) { closedir (dir); }\n        }\n    }\n\n    if (err == ENOENT) {\n        err = 0;  /* ran out of plugins -- do nothing */\n    }\n\n    if (!err) {\n        dirhandle->files = h;\n        h = NULL;  /* dirhandle->files takes ownership */\n    }\n\n    if (filenames != NULL) { krb5int_free_plugin_filenames (filenames); }\n    if (h         != NULL) { krb5int_plugin_file_handle_array_free (h); }\n\n    return err;\n}\n\nvoid KRB5_CALLCONV\nkrb5int_close_plugin_dirs (struct plugin_dir_handle *dirhandle)\n{\n    if (dirhandle->files != NULL) {\n        int i;\n        for (i = 0; dirhandle->files[i] != NULL; i++) {\n            krb5int_close_plugin (dirhandle->files[i]);\n        }\n        free (dirhandle->files);\n        dirhandle->files = NULL;\n    }\n}\n\nvoid KRB5_CALLCONV\nkrb5int_free_plugin_dir_data (void **ptrs)\n{\n    /* Nothing special to be done per pointer.  */\n    free(ptrs);\n}\n\nlong KRB5_CALLCONV\nkrb5int_get_plugin_dir_data (struct plugin_dir_handle *dirhandle,\n                             const char *symname,\n                             void ***ptrs,\n                             struct errinfo *ep)\n{\n    long err = 0;\n    void **p = NULL;\n    size_t count = 0;\n\n    /* XXX Do we need to add a leading \"_\" to the symbol name on any\n       modern platforms?  */\n\n    Tprintf(\"get_plugin_data_sym(%s)\\n\", symname);\n\n    if (!err) {\n        p = calloc (1, sizeof (*p)); /* calloc initializes to NULL */\n        if (p == NULL) { err = ENOMEM; }\n    }\n\n    if (!err && (dirhandle != NULL) && (dirhandle->files != NULL)) {\n        int i = 0;\n\n        for (i = 0; !err && (dirhandle->files[i] != NULL); i++) {\n            void *sym = NULL;\n\n            if (krb5int_get_plugin_data (dirhandle->files[i], symname, &sym, ep) == 0) {\n                void **newp = NULL;\n\n                count++;\n                newp = realloc (p, ((count + 1) * sizeof (*p))); /* +1 for NULL */\n                if (newp == NULL) {\n                    err = ENOMEM;\n                } else {\n                    p = newp;\n                    p[count - 1] = sym;\n                    p[count] = NULL;\n                }\n            }\n        }\n    }\n\n    if (!err) {\n        *ptrs = p;\n        p = NULL; /* ptrs takes ownership */\n    }\n\n    free(p);\n\n    return err;\n}\n\nvoid KRB5_CALLCONV\nkrb5int_free_plugin_dir_func (void (**ptrs)(void))\n{\n    /* Nothing special to be done per pointer.  */\n    free(ptrs);\n}\n\nlong KRB5_CALLCONV\nkrb5int_get_plugin_dir_func (struct plugin_dir_handle *dirhandle,\n                             const char *symname,\n                             void (***ptrs)(void),\n                             struct errinfo *ep)\n{\n    long err = 0;\n    void (**p)() = NULL;\n    size_t count = 0;\n\n    /* XXX Do we need to add a leading \"_\" to the symbol name on any\n       modern platforms?  */\n\n    Tprintf(\"get_plugin_data_sym(%s)\\n\", symname);\n\n    if (!err) {\n        p = calloc (1, sizeof (*p)); /* calloc initializes to NULL */\n        if (p == NULL) { err = ENOMEM; }\n    }\n\n    if (!err && (dirhandle != NULL) && (dirhandle->files != NULL)) {\n        int i = 0;\n\n        for (i = 0; !err && (dirhandle->files[i] != NULL); i++) {\n            void (*sym)() = NULL;\n\n            if (krb5int_get_plugin_func (dirhandle->files[i], symname, &sym, ep) == 0) {\n                void (**newp)() = NULL;\n\n                count++;\n                newp = realloc (p, ((count + 1) * sizeof (*p))); /* +1 for NULL */\n                if (newp == NULL) {\n                    err = ENOMEM;\n                } else {\n                    p = newp;\n                    p[count - 1] = sym;\n                    p[count] = NULL;\n                }\n            }\n        }\n    }\n\n    if (!err) {\n        *ptrs = p;\n        p = NULL; /* ptrs takes ownership */\n    }\n\n    free(p);\n\n    return err;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/thread-safe.txt": "[May be out of date.  Last significant update: Jan 2005.]\n\nIn general, it's assumed that the library initialization function (if\ninitialization isn't delayed) and the library finalization function\nare run in some thread-safe fashion, with no other parts of the\nlibrary in question in use.  (If dlopen or dlsym in one thread starts\nrunning the initializer, and then dlopen/dlsym in another thread\nreturns and lets you start accessing functions or data in the library\nbefore the initializer is finished, that really seems like a\ndlopen/dlsym bug.)\n\nIt's also assumed that if library A depends on library B, then library\nB's initializer runs first, and its finalizer last, whether loading\ndynamically at run time or at process startup/exit.  (It appears that\nAIX 4.3.3 may violate this, at least when we use gcc's\nconstructor/destructor attributes in shared libraries.)\n\nSupport for freeing the heap storage allocated by a library has NOT,\nin general, been written.  There are hooks, but often they ignore some\nof the library's local storage, mutexes, etc.\n\nIf shared library finalization code doesn't get run at all at dlclose\ntime, or if we can't use it because the execution order is wrong, then\nyou'll get memory leaks.  Deal with it.\n\nSeveral debugging variables that are not part of our official API are\nnot protected by mutexes.  In general, the only way to set them is by\nchanging the sources and recompiling, which obviously has no run-time\nthread safety issues, or by stopping the process under a debugger,\nwhich we blithely assert is \"safe enough\".\n\nDebug code that we don't normally enable may be less thread safe than\nmight be desired.  For example, multiple printf calls may be made,\nwith the assumption that the output will not be intermixed with output\nfrom some other thread.  Offhand, I'm not aware of any cases where\ndebugging code is \"really\" unsafe, as in likely to crash the program\nor produce insecure results.\n\nVarious libraries may call assert() and abort().  This should only be\nfor \"can't happen\" cases, and indicate programming errors.  In some\ncases, the compiler may be able to infer that the \"can't happen\" cases\nreally can't happen, and drop the calls, but in many cases, this is\nnot possible.\n\nThere are cases (e.g., in the com_err library) where errors arising\nwhen dealing with other errors are handled by calling abort, for lack\nof anything better.  We should probably clean those up someday.\n\nVarious libraries call getenv().  This is perfectly safe, as long as\nnothing is calling setenv or putenv or what have you, while multiple\nthreads are executing.  Of course, that severely curtails the ability\nto control our libraries through that \"interface\".\n\nVarious libraries call the ctype functions/macros (isupper, etc).  It\nis assumed that the program does not call setlocale, or does so only\nwhile the program is still single-threaded or while calls into the\nKerberos libraries are not in progress.\n\nThe Windows thread safety support is unfinished.\n\nI'm assuming that structure fields that are never written to (e.g.,\nafter a structure has been initialized and *then* made possibly\nvisible to multiple threads) are safe to read from one thread while\nanother field is being updated by another thread.  If that's not the\ncase, some more work is needed (and I'd like details on why it's not\nsafe).\n\n----------------\n\nlibcom_err\n\nIssues:\n\nThe callback hook support (set_com_err_hook, reset_com_err_hook, and\ncalls to com_err and com_err_va) uses a mutex to protect the handle on\nthe hook function.  As a side effect of this, if a callback function\nis registered which pops up a window and waits for the users'\nacknowledgement, then other errors cannot be reported by other threads\nuntil after the acknowledgement.  This could be fixed with\nmultiple-reader-one-writer type locks, but that's a bit more\ncomplicated.\n\nThe string returned by error_message may be per-thread storage.  It\ncan be passed off between threads, but it shouldn't be in use by any\nthread by the time the originating thread calls error_message again.\n\nError tables must no longer be in use (including pointers returned by\nerror_message) when the library containing them is unloaded.\n\nTemporary: A flag variable has been created in error_message.c which\nis used to try to catch cases where remove_error_table is called after\nthe library finalization function.  This generally indicates\nout-of-order execution of the library finalization functions.  The\nhandling of this flag is not thread-safe, but if the finalization\nfunction is called, other threads should in theory be finished with\nthis library anyways.\n\nStatics: error_message.c, com_err.c, covered above.\n\n----------------\n\nlibprofile (and its use in libkrb5)\n\nDoes no checks to see if it's opened multiple instances of the same\nfile under different names.  Does not guard against trying to open a\nfile while another thread or process is in the process of replacing\nit, or two threads trying to update a file at the same time.  The\nformer should be pretty safe on UNIX with atomic rename, but on\nWindows there's a race condition; there's a window (so to speak) where\nthe filename does not correspond to an actual file.\n\nStatics: prof_file.c, a list of opened config files and their parse\ntrees, and a mutex to protect it.\n\n----------------\n\nlibk5crypto\n\nUses of the Yarrow code from the krb5 crypto interface are protected\nby a single mutex.  Initialization of the Yarrow state will be done\nonce, the first time these routines are called.  Calls directly to the\nYarrow functions are not protected.\n\nUses ctype macros; what happens if the locale is changed in a\nmulti-threaded program?\n\nDebug var in pbkdf2.c.\n\nStatics: pbkdf2.c: debug variable.\n\nStatics: prng.c: Global Yarrow data and mutex.\n\nStatics: crypto_libinit.c: library initializer aux data.\n\n----------------\n\nlibkrb5\n\n(TBD)\n\nUses: ctype macros\n\nUses: getaddrinfo, getnameinfo.  According to current specifications,\ngetaddrinfo should be thread-safe; some implementations are not, and\nwe're not attempting to figure out which ones.  NetBSD 1.6, for\nexample, had an unsafe implementation.\n\nUses: res_ninit, res_nsearch.  If these aren't available, the non-'n'\nversions will be used, and they are sometimes not thread-safe.\n\nUses: mkstemp, mktemp -- Are these, or our uses of them, likely to be\nthread-safe?\n\nUses: sigaction\n\nThe use of sigaction is in the code prompting for a password; we try\nto catch the keyboard interrupt character being used and turn it into\nan error return from that function.  THIS IS NOT THREAD-SAFE.\n\nUses: tcgetattr, tcsetattr.  This is also in the password-prompting\ncode.  These are fine as long as no other threads are accessing the\nsame terminal at the same time.\n\nUses: fopen.  This is thread-safe, actually, but a multi-threaded\nserver is likely to be using lots of file descriptors.  On 32-bit\nSolaris platforms, fopen will not work if the next available file\ndescriptor number is 256 or higher.  This can cause the keytab code to\nfail.\n\nStatics: prompter.c: interrupt flag\n\nStatics: ccdefops.c: default operations table pointer\n\nStatics: ktdefname.c: variable to override default keytab name, NO\nLOCKING.  DON'T TOUCH THESE VARIABLES, at least in threaded programs.\n\nStatics: conv_creds.c: debug variable\n\nStatics: sendto_kdc.c: debug variable, in export list for KDC\n\nStatics: parse.c: default realm cache, changed to not cache\n\nStatics: krb5_libinit.c: lib init aux data\n\nStatics: osconfig.c: various internal variables, probably should be const\n\nStatics: init_ctx.c: \"brand\" string; not written.\n\nStatics: cc_memory.c: list of caches, with mutex.\n\nStatics: c_ustime.c: last timestamp, to implement \"microseconds must\nalways increment\"\n\nStatics: ktbase.c, ccbase.c, rc_base.c: type registries and mutexes.\n\n----------------\n\nlibgssapi_krb5\n\n(TBD)\n\nUses: ctype macros\n\nStatics: acquire_cred.c: name of keytab to use, and mutex.\n\nStatics: gssapi_krb5.c:\n\nStatics: init_sec_context.c:\n\nStatics: set_ccache.c:\n\nStatics: gssapi_generic.c: OID definitions, non-const by\nspecification.  We probably could make them const anyways.\n\nThe keytab name saved away by krb5_gss_register_acceptor_identity is\nglobal and protected by a mutex; the ccache name stored by\ngss_krb5_ccache_name is per-thread.  This inconsistency is due to the\nanticipated usage patterns.\n\nThe old ccache name returned by gss_krb5_ccache_name if the last\nparameter is not a null pointer is also stored per-thread, and will be\ndiscarded at the next call to that routine from the same thread, or at\nthread termination.\n\nNeeds work: check various objects for thread safety\n\n----------------\n\nlibgssrpc\n\nNew version is in place.  Ignore it for now?\n\n----------------\n\nlibkadm5*\nlibkdb5\n\nSkip these for now.  We may want the KDC libraries to be thread-safe\neventually, so the KDC can take better advantage of hyperthreaded or\nmultiprocessor systems.\n\n----------------\n\nlibapputils\nlibss\n\nUsed by single-threaded programs only (but see above re KDC).  Don't\nbother for now.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/lib/crypto/crypto_tests/test/katmct.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/lib/krb5/ccache/kcmrpc.defs",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/tests/dejagnu/pkinit-certs/user.p12",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/tests/dejagnu/pkinit-certs/user-upn.p12",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/tests/dejagnu/pkinit-certs/generic.p12",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/tests/dejagnu/pkinit-certs/user-upn3.p12",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/tests/dejagnu/pkinit-certs/user-enc.p12",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/tests/dejagnu/pkinit-certs/user-upn2.p12",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leashdll/res/leash.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leashdll/res/islogo.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/Forget_Principals.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/FAQ.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/Home_Tab.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/Renew_Tickets.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/View_Tickets.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/Kerberos_Terminology.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/Keyboard_Shortcuts.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/Using_Leash_Menus.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/Tickets.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/KINIT.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/Troubleshooting.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/Getting_Started.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/Destroy_Tickets.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/Encryption_Types.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/Options_Tab.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/Kerberos.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/html/Ticket_Settings.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/Images/Get_Ticket.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/Images/Change_Password.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/Images/Home_Tab.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/Images/Options_Tab.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/Images/Destroy_Ticket.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/Images/checkbox.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/Images/Make_Default.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/htmlhelp/Images/Renew_Ticket.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/getticketlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/renew_disabled.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/makedefaultlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/openlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/renew.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/new.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/Leash2.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/Leash_tkt_green.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/newlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/key.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/destroy.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/import.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/Leash_tickets_orange.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/importlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/Leash_tickets_out.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/refresh.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/renewlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/Leash_tickets_red.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/Leash_user_red.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/address.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/status_greenK.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/Leash_Doc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/password.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/Leash_toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/Leash_user_green.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/status_yelloK.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/Leash_tickets_green.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/import_disabled.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/status_redK.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/import.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/exportlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/Leash_user_out.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/Leash_tkt_red.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/Leash.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/Leash_user_orange.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/refresh_disabled.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/destroy_disabled.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/password_disabled.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/sync.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/sync_disabled.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/cursor1.cur",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/encryption.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/Leash_tkt_orange.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/destroylarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/new_disabled.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/status_grayK.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/leash/res/cpwlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/installer/wix/Binary/exclamic.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/installer/wix/Binary/removico.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/installer/wix/Binary/new.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/installer/wix/Binary/completi.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/installer/wix/Binary/info.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/installer/wix/Binary/bannrbmp.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/installer/wix/Binary/up.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/installer/wix/Binary/custicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/installer/wix/Binary/repairic.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/installer/wix/Binary/insticon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/src/windows/installer/wix/Binary/dlgbmp.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/pdf/user.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/pdf/plugindev.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/pdf/basic.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/pdf/admin.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/pdf/build.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/pdf/appdev.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/html/objects.inv",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/html/_static/comment-close.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/html/_static/down.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/html/_static/down-pressed.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/html/_static/plus.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/html/_static/comment-bright.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/html/_static/comment.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/html/_static/up-pressed.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/html/_static/bgfooter.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/html/_static/bgtop.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/html/_static/file.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/html/_static/ajax-loader.gif",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/html/_static/up.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/html/_static/minus.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.17-nb4kphmoqtczzqxcofzlz3wxqiuxuqpf/spack-src/doc/ccapi/html/doxygen.png"
    ],
    "total_files": 4370
}