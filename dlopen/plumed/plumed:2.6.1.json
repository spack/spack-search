{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/configure.ac": "# DO NOT EDIT ./configure FILE\n# One should edit configure.ac and the run autoconf in this\n# directory. Also the resulting \"configure\" is stored on the git,\n# so as to allow people not to install a recent autoconf on their\n# system.\n# If you modify configure.ac, remember to run\n# autoconf and then commit both files to the git repository.\n\n# we require a recent version\n# notice that autoconf is not necessary on user's machine, but only\n# if one has to update configure.ac\nAC_PREREQ([2.68])\nAC_INIT([PLUMED], [2])\n\n##################################################################\n# In order to add m4 macros, put then in a m4 directory and include them here.\n# E.g.:\n# m4_include([./m4/m4_ax_openmp.m4])\n\n##################################################################\n# Here we define a few useful macros\n\n# PLUMED_CONFIG_ENABLE(variablename,optionname,doc,default)\n# notice that variablename and optionname are likely identical,\n# they just need to be different with optionname contains a \"-\"\n# (not allowed in shell variable names)\nAC_DEFUN([PLUMED_CONFIG_ENABLE], [\nm4_bpatsubst([$1],-,_)=\nAC_ARG_ENABLE([$1],\n  AS_HELP_STRING([--enable-$1], [enable $2, default: $3]),\n  [case \"${enableval}\" in\n             (yes) m4_bpatsubst([$1],-,_)=true ;;\n             (no)  m4_bpatsubst([$1],-,_)=false ;;\n             (*)   AC_MSG_ERROR([wrong argument to --enable-$1]) ;;\n  esac],\n  [case \"$3\" in\n             (yes) m4_bpatsubst([$1],-,_)=true ;;\n             (no)  m4_bpatsubst([$1],-,_)=false ;;\n  esac]\n)\n])\n\n# PLUMED_CHECK_CXXFLAG(flag)\n# use it to check if a flag is available on this compiler\nAC_DEFUN([PLUMED_CHECK_CXXFLAG], [\n  save_CXXFLAGS=\"$CXXFLAGS\"\n  CXXFLAGS=\"$CXXFLAGS $1\"\n  AC_MSG_CHECKING([whether $CXX accepts $1])\n  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([])],\n    [\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([])],\n        [AC_MSG_RESULT([yes])],\n        [AC_MSG_RESULT([not linking]); CXXFLAGS=\"$save_CXXFLAGS\"])\n    ],\n    [AC_MSG_RESULT([no]); CXXFLAGS=\"$save_CXXFLAGS\"]\n  )\n])\n\n# PLUMED_CHECK_CFLAG(flag)\n# use it to check if a flag is available on this compiler\nAC_DEFUN([PLUMED_CHECK_CFLAG], [\n  AC_LANG_PUSH(C)\n  save_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS $1\"\n  AC_MSG_CHECKING([whether $CC accepts $1])\n  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([])],\n    [\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([])],\n        [AC_MSG_RESULT([yes])],\n        [AC_MSG_RESULT([not linking]); CCFLAGS=\"$save_CCFLAGS\"])\n    ],\n    [AC_MSG_RESULT([no]); CCFLAGS=\"$save_CCFLAGS\"]\n  )\n  AC_LANG_POP\n])\n\n# PLUMED_CHECK_LDFLAGS(flag)\n# use it to check if a flag is available on this compiler\nAC_DEFUN([PLUMED_CHECK_LDFLAGS], [\n  save_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $1\"\n  AC_MSG_CHECKING([whether LDFLAGS can contain $1])\n  AC_LINK_IFELSE([AC_LANG_PROGRAM([])],\n    [AC_MSG_RESULT([yes])],\n    [AC_MSG_RESULT([no]); LDFLAGS=\"$save_LDFLAGS\"])\n])\n\n# PLUMED_SEARCH_LIBS(function,search-libs[,action-if-found][,action-if-not-found][,other-libraries])\n# same as AC_SEARCH_LIBS, but does not try any library unless $libsearch==true\n# Should be used instead of AC_SEARCH_LIBS in order to make --disable-libsearch work correctly\nAC_DEFUN([PLUMED_SEARCH_LIBS], [\n  if test \"${libsearch}\" == true ; then\n    AC_SEARCH_LIBS([$1],[$2],[$3],[$4],[$5])\n  else\n    AC_SEARCH_LIBS([$1],[],[$3],[$4],[])\n  fi\n])\n\n# PLUMED_CHECK_PACKAGE(header,function,define[,library])\n# first we check if the header is present. if so, we check if the given function can be found.\n# if it cannot be found and the fourth argument (library) has been supplied, we look for it\n# in the library. finally, we set the define flag\nAC_DEFUN([PLUMED_CHECK_PACKAGE], [\n    found=ko\n    $3=no\n    AC_CHECK_HEADER( [$1],[\n      PLUMED_SEARCH_LIBS([$2],[$4],[found=ok])\n    ])\n    if test $found == ok ; then\n       AC_DEFINE([$3])\n       $3=yes\n    else\n       AC_MSG_WARN([cannot enable $3]) \n    fi\n])\n\n# PLUMED_CHECK_CXX_PACKAGE(name,program,define[,library])\n# Similar to PLUMED_CHECK_PACKAGE but suitable for checking C++ libraries.\n# Name is just a string used in the configure log\n# program is a string containing a short C++ program that should compiled.\n# If present and necessary, library is also linked.\nAC_DEFUN([PLUMED_CHECK_CXX_PACKAGE], [\n    found=ko\n    $3=no\n    if test \"${libsearch}\" == true ; then\n      testlibs=\"$4\"\n    else\n      testlibs=\"\"\n    fi\n    for testlib in \"\" $testlibs\n    do\n      save_LIBS=\"$LIBS\"\n      if test -n \"$testlib\" ; then\n        AC_MSG_CHECKING([$1 with -l$testlib])\n        LIBS=\"-l$testlib $LIBS\"\n      else\n        AC_MSG_CHECKING([$1 without extra libs])\n      fi\n      AC_LINK_IFELSE([AC_LANG_SOURCE([$2])],\n          [found=ok]\n          [AC_MSG_RESULT([yes])],\n          [AC_MSG_RESULT([no])]\n      )\n      if test $found == ok ; then\n        break\n      fi\n      LIBS=\"$save_LIBS\"\n    done\n    if test $found == ok ; then\n      AC_DEFINE([$3])\n      $3=yes\n    else\n      AC_MSG_WARN([cannot enable $3]) \n      LIBS=\"$save_LIBS\"\n    fi\n])\n\n##################################################################\n\nAC_MSG_NOTICE([Optional modules are disabled by default])\nrm -f src/*.on src/*.off\n\nAC_ARG_ENABLE([modules],\n  AS_HELP_STRING([--enable-modules], [all/none/reset or : separated list such as +crystallization:-bias default: reset]),\n  [\n   rm -f src/*.on src/*.off\n   if test \"${enableval}\" == yes ; then\n     enableval=reset\n   fi\n   if test \"${enableval}\" == no ; then\n     enableval=none\n   fi\n   for modules_mod in `echo \"${enableval}\" | sed 's/:/ /g' | sed 's/+/ +/g' | sed 's/-/ -/g'`\n   do\n     case \"$modules_mod\" in\n     (none)\n       AC_MSG_NOTICE([Disabling all optional modules])\n       rm -f src/*.off src/*.on\n       touch $(grep default-on src/*/module.type | sed \"s|/module.type:.*|.off|\") ;;\n     (all)\n       AC_MSG_NOTICE([Enabling all optional modules])\n       rm -f src/*.off src/*.off\n       touch $(grep default-off src/*/module.type | sed \"s|/module.type:.*|.on|\") ;;\n     (reset)\n        AC_MSG_NOTICE([Resetting modules to default])\n        rm -f src/*.on src/*.off ;;\n     (-*)\n       modules_mod=`echo \"${modules_mod}\" | sed \"s|-||\"`\n       if test ! -f src/$modules_mod/module.type ; then\n         AC_MSG_ERROR([trying to remove module $modules_mod which does not exist])\n       fi\n       AC_MSG_NOTICE([Disabling module ${modules_mod}])\n       rm -f src/$modules_mod.on\n       touch src/$modules_mod.off ;;\n     (+*)\n       modules_mod=`echo \"${modules_mod}\" | sed \"s|+||\"`\n       if test ! -f src/$modules_mod/module.type ; then\n         AC_MSG_ERROR([trying to add module $modules_mod which does not exist])\n       fi\n       AC_MSG_NOTICE([Enabling module ${modules_mod}])\n       rm -f src/$modules_mod.off\n       touch src/$modules_mod.on ;;\n     (*)\n       if test ! -f src/$modules_mod/module.type ; then\n         AC_MSG_ERROR([trying to add module $modules_mod which does not exist])\n       fi\n       AC_MSG_NOTICE([Enabling module ${modules_mod}])\n       rm -f src/$modules_mod.off\n       touch src/$modules_mod.on ;;\n     esac\n   done\n  ]\n  ,\n  []\n)\n\n\n# set enable flags for ./configure\n\n# This can be disabled when configuring within a package manager\n# such as macports to make sure that only libraries explicitly\n# listed in LDFLAGS are linked\nPLUMED_CONFIG_ENABLE([libsearch],[search for libraries],[yes])\n\n# This can be disabled to avoid the extra tests for static patching.\n# In the future, when this is disabled, we could disable the \"--static\" flag\n# of \"plumed patch\"\nPLUMED_CONFIG_ENABLE([static-patch],[allow statically linking plumed],[yes])\n\nPLUMED_CONFIG_ENABLE([doc],[documentation],[yes])\nPLUMED_CONFIG_ENABLE([pdfdoc],[pdf version of the manual],[no])\nPLUMED_CONFIG_ENABLE([debug],[debugging],[no])\nPLUMED_CONFIG_ENABLE([gcov],[gcov to estimate code coverage],[no])\nPLUMED_CONFIG_ENABLE([basic-warnings],[basic warnings],[yes])\nPLUMED_CONFIG_ENABLE([fussy],[fussy warnings],[no])\nPLUMED_CONFIG_ENABLE([debug-glibcxx],[enable boundary check],[no])\nPLUMED_CONFIG_ENABLE([shared],[shared libs],[yes])\nPLUMED_CONFIG_ENABLE([dependency-tracking],[dependency tracking],[yes])\nPLUMED_CONFIG_ENABLE([rpath],[store rpath],[no])\nPLUMED_CONFIG_ENABLE([absolute-soname],[store absolute soname (Linux only - this is the default behavior on OSX). Only enable for testing!],[no])\nPLUMED_CONFIG_ENABLE([absolute-install-name],[store absolute relative (OSX only - disable to have a behavior similar to Linux). Only disable for testing!],[yes])\nPLUMED_CONFIG_ENABLE([loader-path],[use @loader_path to find libplumedKernel.dylib (OSX only)],[yes])\nPLUMED_CONFIG_ENABLE([bsymbolic],[use -Bsymbolic flag in making shared libraries (Linux only)],[yes])\nPLUMED_CONFIG_ENABLE([ld-r],[group object files],[yes])\nPLUMED_CONFIG_ENABLE([ar-cr],[use ar to build libplumedWrapper.a],[yes])\nPLUMED_CONFIG_ENABLE([static-archive],[try to build libplumed.a for static linking],[yes])\nPLUMED_CONFIG_ENABLE([asmjit],[enable embedded asmjit],[no])\nPLUMED_CONFIG_ENABLE([mpi],[search for mpi],[yes])\nPLUMED_CONFIG_ENABLE([external-lapack],[search for external lapack],[yes])\nPLUMED_CONFIG_ENABLE([external-blas],[search for external blas],[yes])\nPLUMED_CONFIG_ENABLE([molfile-plugins],[use molfile_plugins],[yes])\nPLUMED_CONFIG_ENABLE([external-molfile-plugins],[search for external molfile_plugins],[yes])\nPLUMED_CONFIG_ENABLE([zlib],[search for zlib],[yes])\nPLUMED_CONFIG_ENABLE([readdir-r],[search for readdir_r (threadsafe)],[no])\nPLUMED_CONFIG_ENABLE([cregex],[search for C regular expression],[yes])\nPLUMED_CONFIG_ENABLE([dlopen],[search for dlopen],[yes])\nPLUMED_CONFIG_ENABLE([rtld_default],[search for RTLD_DEFAULT macro],[yes])\nPLUMED_CONFIG_ENABLE([chdir],[search for chdir function],[yes])\nPLUMED_CONFIG_ENABLE([subprocess],[search for functions needed to manage a subprocess],[yes])\nPLUMED_CONFIG_ENABLE([getcwd],[search for getcwd function],[yes])\nPLUMED_CONFIG_ENABLE([execinfo],[search for execinfo],[yes])\nPLUMED_CONFIG_ENABLE([gsl],[search for gsl],[yes])\nPLUMED_CONFIG_ENABLE([xdrfile],[search for xdrfile],[yes])\nPLUMED_CONFIG_ENABLE([boost_graph],[search for boost graph],[no])\nPLUMED_CONFIG_ENABLE([boost_serialization],[search for boost serialization],[no])\nPLUMED_CONFIG_ENABLE([fftw],[search for fftw],[yes])\nPLUMED_CONFIG_ENABLE([python],[search for python],[yes])\nPLUMED_CONFIG_ENABLE([af_ocl],[search for arrayfire_ocl],[no])\nPLUMED_CONFIG_ENABLE([af_cuda],[search for arrayfire_cuda],[no])\nPLUMED_CONFIG_ENABLE([af_cpu],[search for arrayfire_cpu],[no])\n\nAC_ARG_VAR(SOEXT,[extension of dynamic libraries (so/dylib)])\nAC_ARG_VAR(STATIC_LIBS,[variables that should be linked statically directly to MD code - configure will add here -ldl if necessary ])\nAC_ARG_VAR(LDSHARED,[command for linking shared library - configure will use CXX plus the proper flags ])\nAC_ARG_VAR(PYTHON_BIN,[python executable (e.g. python2.7 or /opt/local/bin/python2.7) - default: search for a python executable])\nAC_ARG_VAR(BASH_COMPLETION_DIR,[path where bash completion will be installed - default: search with pkg-config])\nAC_ARG_VAR(MPIEXEC,[command to run mpi programs in tests - default not specified, which means use PLUMED_MPIRUN env var at runtime for backward compatibility])\n\n\n# by default use -O flag\n# we override the autoconf default (-g) because in release build we do not want to\n# include symbol information (obj files are huge)\nif test -z \"$CXXFLAGS\"\nthen\n  CXXFLAGS=-O3\nfi\n\n# this is a list of common compilers\ncompilers=\"g++ c++ cxx icpc\"\nc_compilers=\"gcc cc icc\"\n\n# on OSX, prefer clang++\ncase `(uname)` in\n  (Darwin)\n    compilers=\"clang++ $compilers\"\n    c_compilers=\"clang $c_compilers\"\n  ;;\nesac\n\n# if searching for MPI, try first mpi-like compilers\nif test $mpi == true ; then\ncompilers=\"mpic++ mpicxx mpiicpc openmpic++ openmpicxx $compilers\"\nfi\n\n# do the actual search\nAC_PROG_CXX([$compilers])\nAC_PROG_CC([$c_compilers])\n\n# also setup Fortran compiler\n# this is optional, and can be used in the late part of this \n# script to verify that fortran can indeed link properly the\n# a c++ library\nAC_PROG_FC\n\n# we use C++ for all the autoconf tests\nAC_LANG(C++)\n\nif test -z \"$LDSHARED\" ; then\n  LDSHARED=\"$CXX\"\nfi\n\nAC_MSG_NOTICE([Initial CXX:         $CXX])\nAC_MSG_NOTICE([Initial CXXFLAGS:    $CXXFLAGS])\nAC_MSG_NOTICE([Initial CPPFLAGS:    $CPPFLAGS])\nAC_MSG_NOTICE([Initial CFLAGS:      $CFLAGS])\nAC_MSG_NOTICE([Initial LDFLAGS:     $LDFLAGS])\nAC_MSG_NOTICE([Initial LIBS:        $LIBS])\nAC_MSG_NOTICE([Initial STATIC_LIBS: $STATIC_LIBS])\nAC_MSG_NOTICE([Initial LD:          $LD])\nAC_MSG_NOTICE([Initial LDSHARED:    $LDSHARED])\nAC_MSG_NOTICE([Initial SOEXT:       $SOEXT])\n\n# check C++ flags\nif test $shared == true\nthen\n  PLUMED_CHECK_CXXFLAG([-fPIC])\n  PLUMED_CHECK_CFLAG([-fPIC])\nfi\n\nif test $basic_warnings == true\nthen\n  PLUMED_CHECK_CXXFLAG([-Wall])\n  PLUMED_CHECK_CXXFLAG([-pedantic])\n  PLUMED_CHECK_CXXFLAG([-std=c++11])\nfi\n\nif test $debug == true\nthen\n  PLUMED_CHECK_CXXFLAG([-g])\nfi\n\nif test $gcov == true\nthen\n  CXX=\"$CXX --coverage\"\n  LDSHARED=\"$LDSHARED --coverage\"\n  CFLAGS=\"$CFLAGS --coverage\"\n  PLUMED_CHECK_LDFLAGS([--coverage])\n  STATIC_LIBS=\"$STATIC_LIBS --coverage\"\nfi\n\nif test $fussy == true\nthen\n  PLUMED_CHECK_CXXFLAG([-Wextra])\n  PLUMED_CHECK_CXXFLAG([-Wfloat-equal])\n  PLUMED_CHECK_CXXFLAG([-Wwrite-strings])\n  PLUMED_CHECK_CXXFLAG([-Wpointer-arith])\n  PLUMED_CHECK_CXXFLAG([-Wcast-qual])\n  PLUMED_CHECK_CXXFLAG([-Wcast-align])\n  PLUMED_CHECK_CXXFLAG([-Wconversion])\n  PLUMED_CHECK_CXXFLAG([-Wredundant-delcs])\n  PLUMED_CHECK_CXXFLAG([-Wvariadic-macros])\n  PLUMED_CHECK_CXXFLAG([-Wold-style-cast])\nfi\n\nAC_MSG_CHECKING([whether $CXX declares c++11 support])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([\n#if __cplusplus <= 199711L\nthis_compiler_does_not_support_cxx11\n#endif\n])],\n  [AC_MSG_RESULT([yes])];\n  support_cxx11=true,\n  [AC_MSG_RESULT([no]) ;\n  support_cxx11=false])\n\nif test \"$support_cxx11\" = false\nthen\n   AC_MSG_WARN([C++11 support is required as of PLUMED 2.4])\n   AC_MSG_WARN([Your compiler appears not to support C++11])\n   AC_MSG_WARN([Please change compiler or make sure that everything works correctly])\nfi\n\nAC_MSG_CHECKING([whether C++ library supports C++11 exceptions])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([\n#include <new>\n#include <functional>\n#include <memory>\n#include <system_error>\n#include <ios>\n#include <future>\n// capable to catch:\nvoid func(void) {\n  try{\n  } catch(std::bad_array_new_length &) {\n  } catch(std::bad_function_call &) {\n  } catch(std::bad_weak_ptr &) {\n  } catch(std::ios_base::failure &e) {\n    if(e.code().category()==std::generic_category()) {}\n    else if(e.code().category()==std::system_category()) {}\n    else if(e.code().category()==std::iostream_category()) {}\n    else if(e.code().category()==std::future_category()) {}\n  } catch(std::system_error &e) {\n    if(e.code().category()==std::generic_category()) {}\n    else if(e.code().category()==std::system_category()) {}\n    else if(e.code().category()==std::iostream_category()) {}\n    else if(e.code().category()==std::future_category()) {}\n  }\n// capable to throw:\n  auto a=std::bad_array_new_length();\n  auto b=std::bad_function_call();\n  auto c=std::bad_weak_ptr();\n  auto d=std::system_error(10,std::generic_category(),\"msg\");\n  auto e=std::system_error(10,std::system_category(),\"msg\");\n  auto f=std::system_error(10,std::iostream_category(),\"msg\");\n  auto g=std::system_error(10,std::future_category(),\"msg\");\n  auto h=std::ios_base::failure(\"msg\",std::error_code(10,std::generic_category()));\n  auto i=std::ios_base::failure(\"msg\",std::error_code(10,std::system_category()));\n  auto j=std::ios_base::failure(\"msg\",std::error_code(10,std::iostream_category()));\n  auto k=std::ios_base::failure(\"msg\",std::error_code(10,std::future_category()));\n}\n])],\n[\n  AC_MSG_RESULT([yes]);\n  AC_DEFINE([__PLUMED_LIBCXX11])\n],\n[AC_MSG_RESULT([no])\n])\n\nAC_SUBST(disable_dependency_tracking)\n\nif test \"$dependency_tracking\" = true\nthen\n  AC_MSG_CHECKING([whether $CXX can generate dependency file with -MM -MF])\n  dependency=ko\n  echo \"#include \\\"conftest1.h\\\"\" > conftest.cpp\n  echo \"#include \\\"conftest2.h\\\"\" > conftest1.h\n  echo \"/* */\" > conftest2.h\n  $CXX $CXXFLAGS -c -MM -MFconftest.d conftest.cpp 1> /dev/null 2> /dev/null\n  grep conftest2 conftest.d 1> /dev/null 2>/dev/null && dependency=ok\n  if test \"$dependency\" = ok ; then\n    AC_MSG_RESULT([yes])\n    disable_dependency_tracking=no\n  else\n    AC_MSG_RESULT([no])\n    disable_dependency_tracking=yes\n  fi\nelse\n  disable_dependency_tracking=yes\nfi\n\nif test \"$disable_dependency_tracking\" = yes ; then\n  AC_MSG_WARN([dependencies tracking disabled - always make clean before make])\nelse\n  AC_MSG_NOTICE([dependency tracking enabled])\nfi\n\n\n\n\n#### Compulsory libraries ####\n# some of them might be made optional if we find that are not available in some system\nAC_MSG_NOTICE([Now we will check compulsory headers and libraries])\nAC_CHECK_HEADER([dirent.h],     [ ], [AC_MSG_ERROR([compulsory header not found])] )\nAC_CHECK_FUNC(  [readdir],      [ ], [AC_MSG_ERROR([compulsory function not found])] )\n\n# Then check for blas. This is a bit complicated because we want to allow\n# either the version with underscore or the one without\nblas_found=\nlapack_found=\n\n# external lapack can only work with external blas\n# thus, if external blas are disabled also external lapack should be disabled\nif test \"$external_blas\" == false && test \"$external_lapack\" == true ; then\n  AC_MSG_NOTICE([Internal blas can only be used with internal lapack])\n  AC_MSG_NOTICE([Will not search for external lapack])\n  external_lapack=false\nfi\n\n# first look for blas\nif test \"$external_blas\" == true ; then\n  AC_MSG_CHECKING([whether dgemv can be linked with no library])\n  AC_LINK_IFELSE([AC_LANG_CALL([], [dgemv])],[\n    AC_MSG_RESULT([yes])\n    blas_found=nounderscore\n    ],[\n    AC_MSG_RESULT([no])\n    AC_MSG_CHECKING([whether dgemv_ can be linked with no library])\n    AC_LINK_IFELSE([AC_LANG_CALL([], [dgemv_])],[\n      AC_MSG_RESULT([yes])\n      blas_found=underscore\n    ],[\n      AC_MSG_RESULT([no])\n      PLUMED_SEARCH_LIBS([dgemv],[blas],[blas_found=nounderscore],[\n        PLUMED_SEARCH_LIBS([dgemv_],[blas],[blas_found=underscore])\n      ])\n    ])\n  ])\nfi\n\n# if not found, then use internal lapack and blas\nif test -z \"$blas_found\" ; then\nAC_MSG_WARN([using internal lapack and blas, could be inefficient])\nfi\n\n# if found, also look for external lapack\nif test -n \"$blas_found\" ; then\n\nAC_DEFINE([__PLUMED_HAS_EXTERNAL_BLAS])\n\nif test \"$external_lapack\" == true ; then\n# Then we look for lapack using same underscoring\ncase \"$blas_found\" in\n(underscore) search_for=dsyevr_ ;;\n(nounderscore) search_for=dsyevr ;;\nesac\nPLUMED_SEARCH_LIBS( [$search_for],[lapack],[lapack_found=yes])\nfi\n\n# if not found, then use internal lapack with external blas\nif test -z \"$lapack_found\" ; then\nAC_MSG_WARN([using internal lapack, could be inefficient])\nelse\nAC_DEFINE([__PLUMED_HAS_EXTERNAL_LAPACK])\nfi\n\nfi \n\n# in case external blas have been found, take note of their underscoring\n# notice that this applies also when external blas are used with internal lapack\n# in the latter case, also (internal) lapack names will be underscored consistently\nif test \"$blas_found\" == nounderscore\nthen\n  AC_DEFINE([F77_NO_UNDERSCORE])\nfi\n\nif test -n \"$blas_found\" ; then\n\nAC_DEFUN([PLUMED_TEST_SDOT],[\n#if ! defined(F77_NO_UNDERSCORE)\n#define sdot sdot_\n#endif\nextern \"C\"{\n$1 sdot(int *n, float *dx, int *incx, float *dy, int *incy);\n}\n\nint main(){\n  int size=5;\n// notice that [[]] is required to cheat autoconf\n  float af[[5]],bf[[5]];\n  for(unsigned i=0;i<size;i++){\n    af[[i]]=size;\n    bf[[i]]=size-i;\n  }\n  int inca=1;\n  int incb=1;\n  $1 f=sdot(&size,af,&inca,bf,&incb)-75;\n  if(f*f<1e-10) return 0;\n  else return 1;\n}\n])\n\n\nAC_MSG_CHECKING([whether sdot returns float])\nAC_RUN_IFELSE([AC_LANG_SOURCE([PLUMED_TEST_SDOT([float])])],\n  [ sdot_returns_float=yes ; AC_MSG_RESULT([yes]) ],\n  [ sdot_returns_float=no ;  AC_MSG_RESULT([no]) ],\n  [ AC_MSG_RESULT([not checked (cross compiling)]) ]\n)\n\nif test \"$sdot_returns_float\" == no ;\nthen\n\nAC_MSG_CHECKING([whether sdot returns double])\nAC_RUN_IFELSE([AC_LANG_SOURCE([PLUMED_TEST_SDOT([double])])],\n  [ sdot_returns_double=yes ; AC_MSG_RESULT([yes]) ],\n  [ sdot_returns_double=no ;  AC_MSG_RESULT([no]) ],\n  [ AC_MSG_RESULT([not checked (cross compiling)]) ]\n)\n\nfi\n\nif test \"$sdot_returns_double\" = yes ; then\n  AC_MSG_NOTICE([Setting workaround for blas float functions returning double])\n  AC_DEFINE(__PLUMED_BLAS_RETURNS_FLOAT,double)\n  if test -n \"$lapack_found\" ; then\n    AC_MSG_NOTICE([Setting workaround for lapack float functions returning double])\n    AC_DEFINE(__PLUMED_LAPACK_RETURNS_FLOAT,double)\n  fi\nelse if test \"$sdot_returns_float\" = no && test \"$sdot_returns_double\" = no ;\nthen\n  AC_MSG_WARN([There is a problem with your blas implementation])\nfi\n\nfi\n\nfi\n\n#### End of compulsory libraries ####\n\n#### Optional libraries ####\nAC_MSG_NOTICE([Now we will check for optional headers and libraries])\n\n#############################################################\n# I add the possibility to completely remove molfile_plugins\n# I would like to be 100% that the molfile module compiles\n# correctly on all machines\n# In case of problem, it is sufficient to configure with\n# ./configure --disable-molfile-plugins\n# GB\n#############################################################\n\nif test $molfile_plugins == true ; then\n\n# Check for molfile_plugins and use internal fallback if not found. TG\n\n# We always have molfile, now\nAC_DEFINE([__PLUMED_HAS_MOLFILE_PLUGINS])\n\n  if test \"$external_molfile_plugins\" == true ; then\n    PLUMED_CHECK_PACKAGE([libmolfile_plugin.h],[molfile_dcdplugin_init],[__PLUMED_HAS_EXTERNAL_MOLFILE_PLUGINS],molfile_plugin)\n    if test \"$__PLUMED_HAS_EXTERNAL_MOLFILE_PLUGINS\" != yes ; then\n      AC_MSG_WARN([using internal molfile_plugins, which only support dcd/xtc/trr/trj/crd files])\n    else\n      AC_DEFINE([__PLUMED_HAS_EXTERNAL_MOLFILE_PLUGINS])\n    fi\n  fi\nfi\n\n# this is special and is also attached to STATIC_LIBS\n# this flag should be used also when linking MD engines to allow plumed\n# to be loaded later\nAC_CHECK_LIB([dl],dlopen, [STATIC_LIBS=\"-ldl $STATIC_LIBS\"] [LIBS=\"-ldl $LIBS\"])\n\nmpi_found=ko\n# optional libraries follow\nif test $mpi == true ; then\n  PLUMED_CHECK_PACKAGE([mpi.h],[MPI_Init],[__PLUMED_HAS_MPI])\n  if test \"$__PLUMED_HAS_MPI\" = yes; then\n    mpi_found=ok\n  fi\nelse \n  mpi_found=ko\nfi\n\n# search for openmp is automatically disabled by autoconf\n# when configuring with --disable-openmp\nAC_OPENMP\n\nif test $asmjit == true ; then\n  found=ko\n# asmjit calls clock_gettime and thus should be linked to rt on Linux\n  if test `(uname)` = Linux ; then\n    PLUMED_SEARCH_LIBS([clock_gettime],[rt],[found=ok])\n  else\n    found=ok\n  fi\n  if test \"$found\" = ok ; then\n    AC_MSG_NOTICE([Enabling embedded asmjit])\n    AC_DEFINE([__PLUMED_HAS_ASMJIT])\n  else\n    AC_MSG_WARN([cannot link clock_gettime on this Linux, asmjit will not be enabled])\n  fi\nfi\n\n\nif test $readdir_r == true ; then\n  PLUMED_CHECK_PACKAGE([dirent.h],[readdir_r],[__PLUMED_HAS_READDIR_R])\nfi\nif test $cregex == true ; then\n  PLUMED_CHECK_PACKAGE([regex.h],[regcomp],[__PLUMED_HAS_CREGEX])\nfi\nif test $dlopen == true ; then\n  PLUMED_CHECK_PACKAGE([dlfcn.h],[dlopen],[__PLUMED_HAS_DLOPEN])\nfi\n\nif test $rtld_default == true ; then\n  PLUMED_CHECK_CXX_PACKAGE([RTLD_DEFAULT],[\n#include <dlfcn.h>\nint\nmain ()\n{\n  void* f=dlsym(RTLD_DEFAULT,\"path\");\n  return 0;\n}\n  ], [__PLUMED_HAS_RTLD_DEFAULT])\nfi\n\nif test $chdir == true ; then\n  PLUMED_CHECK_PACKAGE([unistd.h],[chdir],[__PLUMED_HAS_CHDIR])\nfi\n\nif test $subprocess == true ; then\n  PLUMED_CHECK_CXX_PACKAGE([subprocess],[\n/* random program calling all the functions needed to manage a subprocess */\n#include <cstdio>\n#include <unistd.h>\n#include <csignal>\n\nint\nmain ()\n{\n// notice that [[]] is required to cheat autoconf\n  int cp[[2]];\n  FILE* fp;\n  char* arr[[3]];\n  arr[[0]]=NULL;\n  arr[[1]]=NULL;\n  arr[[2]]=NULL;\n  arr[[3]]=NULL;\n  if(pipe(cp)>=0)\n  if(fork()>=0)\n  if(close(1)>=0)\n  if(dup(cp[[1]])>=0) {\n    fp=fdopen(cp[[0]],\"w\");\n    execv(arr[[0]],arr);\n  }\n  auto p=fork();\n  kill(p,SIGINT);\n  kill(p,SIGCONT);\n  kill(p,SIGSTOP);\n  return 0;\n}\n\n  ], [__PLUMED_HAS_SUBPROCESS])\nfi\n\nif test $getcwd == true ; then\n  PLUMED_CHECK_PACKAGE([unistd.h],[getcwd],[__PLUMED_HAS_GETCWD])\nfi\n\nif test $execinfo == true ; then\n  PLUMED_CHECK_PACKAGE([execinfo.h],[backtrace],[__PLUMED_HAS_EXECINFO])\nfi\nif test $zlib == true ; then\n  PLUMED_CHECK_PACKAGE([zlib.h],[gzopen],[__PLUMED_HAS_ZLIB],[z])\nfi\n\nif test $gsl == true ; then\n  found=ko\n  PLUMED_SEARCH_LIBS([cblas_dgemv],[gslcblas], [\n    AC_CHECK_HEADER(  [gsl/gsl_vector.h], [\n      PLUMED_SEARCH_LIBS([gsl_vector_alloc],[gsl],[found=ok])\n    ])\n  ])\n  if test $found == ok ; then\n    AC_DEFINE([__PLUMED_HAS_GSL])\n  else\n    AC_MSG_WARN([cannot enable __PLUMED_HAS_GSL])\n  fi\nfi\n\nif test $xdrfile == true ; then\n  PLUMED_CHECK_PACKAGE([xdrfile/xdrfile_xtc.h],[write_xtc],[__PLUMED_HAS_XDRFILE],[xdrfile])\nfi\n\nif test $boost_graph == true ; then\n  PLUMED_CHECK_CXX_PACKAGE([boost graph],[\n#include <boost/graph/graph_utility.hpp>\n#include <boost/graph/adjacency_matrix.hpp>\nint\nmain ()\n{\n  boost::adjacency_matrix<boost::directedS> a(1);\n  ;\n  return 0;\n}\n  ], [__PLUMED_HAS_BOOST_GRAPH])\nfi\n\nif test $boost_serialization == true ; then\n  PLUMED_CHECK_CXX_PACKAGE([boost serialization],[\n#include <fstream>\n#include <boost/archive/text_oarchive.hpp>\nint main() {\n    std::ofstream ofs(\"filename\");\n    boost::archive::text_oarchive oa(ofs);\n    return 0;\n}\n  ], [__PLUMED_HAS_BOOST_SERIALIZATION],[boost_serialization boost_serialization-mt])\n# notice: macports install libraries with -mt suffix\nfi\n\nif test $fftw == true ; then\n  PLUMED_CHECK_PACKAGE([fftw3.h],[fftw_execute],[__PLUMED_HAS_FFTW],[fftw3])\nfi\n\nif test $python == true  ; then\n# if PYTHON_BIN is defined, it is expected to be the full path to python\n# Otherwise, search from a list of names:\n  if test -z \"$PYTHON_BIN\" ; then\n    AC_CHECK_PROGS([PYTHON_BIN],[python])\n  fi\n  if test -n \"$PYTHON_BIN\"\n  then\n    AC_MSG_NOTICE([Python executable is $PYTHON_BIN])\n    AC_MSG_CHECKING([support for required python modules (python3, setuptools, cython, subprocess, os, shutil)])\ntestimport=\"\nfrom setuptools import setup\nfrom setuptools import Extension\nimport subprocess\nimport os\nimport os.path\nimport sys\nfrom shutil import copyfile\nfrom Cython.Build import cythonize\nif sys.version_info < (3,):\n    raise ImportError('PLUMED 2.6 only supports Python 3')\n\"\n    if echo \"$testimport\" | \"$PYTHON_BIN\" 1>/dev/null 2>/dev/null;  then\n       AC_MSG_RESULT([yes])\n       AC_DEFINE([__PLUMED_HAS_PYTHON])\n    else\n       AC_MSG_RESULT([no])\n       AC_MSG_WARN([cannot enable python interface])\n       PYTHON_BIN=\n    fi\n  else\n    AC_MSG_WARN([cannot enable python interface])\n  fi\nfi\n\nif test \"$af_ocl\" == true ; then\n  PLUMED_CHECK_PACKAGE([arrayfire.h],[af_is_double],[__PLUMED_HAS_ARRAYFIRE],[afopencl])\nfi\nif test \"$af_cuda\" == true ; then\n  PLUMED_CHECK_PACKAGE([arrayfire.h],[af_is_double],[__PLUMED_HAS_ARRAYFIRE],[afcuda])\nfi\nif test \"$af_cpu\" == true ; then\n  PLUMED_CHECK_PACKAGE([arrayfire.h],[af_is_double],[__PLUMED_HAS_ARRAYFIRE],[afcpu])\nfi\n\n# in non-debug mode, add -DNDEBUG\nif test \"$debug\" == false ; then\n  AC_MSG_NOTICE([Release mode, adding -DNDEBUG])\n  AC_DEFINE([NDEBUG])\nfi\n\n# in debug-glibcxx mode, add -D_GLIBCXX_DEBUG\nif test \"$debug_glibcxx\" == true ; then\n  AC_MSG_NOTICE([Check boundaries, adding -D_GLIBCXX_DEBUG])\n  AC_DEFINE([_GLIBCXX_DEBUG])\nfi\n\n# this is necessary in many MPI implementations\n# I leave it by default, since it seems harmless\nAC_DEFINE([_REENTRANT])\n\n#### Options for dynamic library to work properly ####\nAC_SUBST(SOEXT)\nAC_SUBST(LDSHARED)\n# these are libraries that should be linked also to MD engines\nAC_SUBST(STATIC_LIBS)\n# python executable\nAC_SUBST(PYTHON_BIN)\n\nAC_SUBST(MPIEXEC)\n\nif test \"$shared\" == true ; then\n  case `(uname)` in\n  (Darwin)\n    AC_MSG_NOTICE([*** Special settings for dynamic libraries on OSX ***])\n    AC_MSG_NOTICE([Dynamic library extension is 'dylib'])\n    AC_MSG_NOTICE([LDSHARED needs special flags])\n    SOEXT=dylib\n    LDSHARED=\"$LDSHARED -dynamiclib -Wl,-headerpad_max_install_names\"\n    if test \"$rpath\" = true ; then\n      AC_MSG_NOTICE([Switching off rpath on OSX])\n      rpath=false\n    fi\n  ;;\n  (Linux)\n    AC_MSG_NOTICE([*** Special settings for dynamic libraries on Linux ***])\n    AC_MSG_NOTICE([Dynamic library extension is 'so'])\n    AC_MSG_NOTICE([LDSHARED and LDFLAGS need special flags])\n    SOEXT=so\n    LDSHARED=\"$LDSHARED -shared\"\n    PLUMED_CHECK_LDFLAGS([-rdynamic])\n    if test \"$bsymbolic\" == true ; then\n      PLUMED_CHECK_LDFLAGS([-Wl,-Bsymbolic])\n    fi\n  ;;\n  (*)\n    AC_MSG_NOTICE([*** Dynamic library only enabled on OSX and Linux ***])\n  esac\nfi\n\n# check linking of runtime library\nif test -n \"$SOEXT\"\nthen\n  AC_MSG_NOTICE([Using LDSHARED='$LDSHARED'])\n  AC_MSG_NOTICE([Using LDFLAGS='$LDFLAGS'])\n  AC_MSG_CHECKING([whether LDSHARED can create dynamic libraries])\n  rm -f conftest.*\n  echo \"void f(void){ return;}\" > conftest.cpp\n  $CXX $CXXFLAGS $CPPFLAGS -c conftest.cpp 1>/dev/null 2>/dev/null\n  $LDSHARED $LDFLAGS conftest.o -o conftest.$SOEXT 1>/dev/null 2>/dev/null\n  if test -f conftest.$SOEXT\n  then\n    AC_MSG_RESULT([yes])\n  else\n    AC_MSG_RESULT([no])\n    AC_MSG_WARN([dynamic library will be disabled])\n    SOEXT=\n  fi\n  if test -n \"$SOEXT\" && test \"$rpath\" = true ; then\n    rm -f conftest.$SOEXT\n    readelf=\"\"\n    AC_CHECK_PROG([readelf],[readelf],[found])\n    if test \"$readelf\" == found ; then\n      test_LDSHARED=\"$LDSHARED -Wl,-R -Wl,/some/random/dir/\"\n      $test_LDSHARED $LDFLAGS conftest.o -o conftest.$SOEXT 1>/dev/null 2>/dev/null\n      if readelf -d conftest.$SOEXT | grep RPATH | grep -q /some/random/dir ; then\n        LDSHARED=\"$LDSHARED -Wl,-R -Wl,\\\"$LIBRARY_PATH\\\"\"\n      else\n        AC_MSG_WARN([-R option seems not working, disabling rpath])\n      fi\n    else\n      AC_MSG_WARN([readelf not available, no way to set rpath])\n    fi \n  fi\n  rm -f conftest.*\nfi\n#### Options for dynamic library to work properly ####\n\nAC_SUBST(make_doc)\nmake_doc=no\nif test \"$doc\" == true\nthen\n\nmake_doc=yes\n\n### Look for doxygen\nAC_CHECK_PROG([doxygen],[doxygen],[found])\nif test \"$doxygen\" == found\nthen\n  doxygen_version=`doxygen --version | awk 'BEGIN{FS=\".\"}{if($1>1 || ($1==1 && $2>=8)) print \"ok\"}'`\n  if test \"$doxygen_version\" == ok\n  then\n    AC_MSG_NOTICE([Doxygen version is fine])\n  else\n    AC_MSG_WARN([Doxygen version is <1.8])\n    make_doc=no\n  fi\n  AC_CHECK_PROG([dot],[dot],[found])\n  if test \"$dot\" != found\n  then\n    AC_MSG_WARN([You will not be able to see diagrams in the manual])\n  fi\nelse\n  make_doc=no\nfi\nfi\n\nif test \"$make_doc\" = yes\nthen\n  AC_MSG_NOTICE([Manuals will be generated])\nelse\n  AC_MSG_NOTICE([Manuals will not be generated])\nfi\n\nAC_SUBST(make_pdfdoc)\nmake_pdfdoc=\"\"\nif test \"$pdfdoc\" == true && test \"$make_doc\" == yes\nthen\n  AC_MSG_NOTICE([A PDF version of the manual will be generated])\n  make_pdfdoc=yes\nelse\n  AC_MSG_NOTICE([A PDF version of the manual will not be generated])\n  make_pdfdoc=no\nfi\n\n### Look for xxd\nAC_CHECK_PROG([xxd],[xxd],[found])\nif test \"$xxd\" != found\nthen\n  AC_MSG_ERROR([xxd should be installed for PLUMED to compile properly])\nfi\n\nAC_SUBST(program_can_run)\nprogram_can_run=\"\"\nAC_MSG_CHECKING([whether a program can be run on this machine])\nAC_RUN_IFELSE([AC_LANG_SOURCE([\n#ifdef __PLUMED_HAS_MPI\n#include <mpi.h>\n#endif\n// notice that [[]] is required to cheat autoconf\nint main(int argc,char*argv[[]]){\n#ifdef __PLUMED_HAS_MPI\n// this emulates what happens when plumed\n// is compiled with mpi and invoked with --no-mpi\n  if(argc==10){\n    MPI_Init(&argc,&argv);\n    return MPI_Finalize();\n  }\n#endif\n  return 0;\n}\n])],\n  [ program_can_run=yes ; AC_MSG_RESULT([yes]) ],\n  [ program_can_run=no ; AC_MSG_RESULT([no]) ],\n  [ program_can_run=no ; AC_MSG_RESULT([no (cross compiling)]) ]\n)\n\nif test $mpi_found == ok ; then\nAC_SUBST(program_can_run_mpi)\nprogram_can_run_mpi=\"\"\nAC_MSG_CHECKING([whether a program compiled with mpi can be run on this machine])\nAC_RUN_IFELSE([AC_LANG_SOURCE([\n#ifdef __PLUMED_HAS_MPI\n#include <mpi.h>\n#endif\n// notice that [[]] is required to cheat autoconf\nint main(int argc,char*argv[[]]){\n#ifdef __PLUMED_HAS_MPI\n  MPI_Init(&argc,&argv);\n  return MPI_Finalize();\n#endif\n  return 0;\n}\n])],\n  [ program_can_run_mpi=yes ; AC_MSG_RESULT([yes]) ],\n  [ program_can_run_mpi=no ; AC_MSG_RESULT([no]) ],\n  [ program_can_run_mpi=no ; AC_MSG_RESULT([no (cross compiling)]) ]\n)\nfi\n\nif test $mpi_found == ok ; then\n  if test -n \"$MPIEXEC\" ; then\n    AC_MSG_NOTICE([Regtest suite will use $MPIEXEC command to run MPI tests])\n  else\n    AC_MSG_NOTICE([Regtest suite will use env var PLUMED_MPIRUN to run MPI tests (default: mpirun)])\n  fi\nfi\n\nif test \"$SOEXT\" == \"dylib\" ; then\n  use_absolute_soname=yes\nelse\n  use_absolute_soname=no\nfi\n\nAC_SUBST(use_absolute_soname)\nif test \"$absolute_soname\" == true ; then\n  if test \"$SOEXT\" == \"dylib\" ; then\n    AC_MSG_WARN([--enable-absolute-soname has no effect on OSX])\n  else\n    AC_MSG_NOTICE([enabling absolute soname. Full path will be hardcoded in plumed library soname])\n    use_absolute_soname=yes\n  fi\nfi\n\nif test \"$absolute_install_name\" == false ; then\n  if test \"$SOEXT\" == \"so\" ; then\n    AC_MSG_WARN([--disable-absolute-install-name has no effect on Linux])\n  else\n    AC_MSG_NOTICE([enabling relative install_name. You will have to set DYLD_LIBRARY_PATH yor plumed libraries to be found at runtime])\n    use_absolute_soname=no\n  fi\nfi\n\nAC_SUBST(use_loader_path)\nif test \"$SOEXT\" == \"dylib\" ; then\n  if test \"$loader_path\" == true ; then\n    use_loader_path=yes\n  else\n    use_loader_path=no\n  fi\nelse\n  use_loader_path=no\nfi\n\n#### This further tests are required to allow linking with non c++ compiler\nAC_MSG_NOTICE([PLUMED seems to be configured properly!])\nAC_MSG_NOTICE([**************************])\nAC_SUBST(LD_RO)\nLD_RO=\nif test \"$ld_r\" == true ; then\nfor test_LD_RO in \"$($CXX --print-prog-name=ld) -r -o\" \"$CXX -Wl,-r -o\" \"ld -r -o\"\ndo\n  AC_MSG_CHECKING([whether C++ objects can be grouped with $test_LD_RO])\n  \n  rm -f conftest-*\n  \n  cat << EOF > conftest-main.cpp\n  void f(void);\n  int main(int argc,char**argv){ f(); return 0; }\nEOF\n  cat << EOF > conftest-f.cpp\n  void g(void);\n  void f(void){ g(); }\nEOF\n  cat << EOF > conftest-g.cpp\n  void g(void){ return; }\nEOF\n  \n  $CXX $CXXFLAGS -c conftest-main.cpp 1> /dev/null 2> /dev/null\n  $CXX $CXXFLAGS -c conftest-f.cpp 1> /dev/null 2> /dev/null\n  $CXX $CXXFLAGS -c conftest-g.cpp 1> /dev/null 2> /dev/null\n  \n  $test_LD_RO conftest-both.o conftest-f.o conftest-g.o 1> /dev/null 2> /dev/null\n  \n  $CXX $CXXFLAGS -o conftest.exe conftest-main.o conftest-both.o 1> /dev/null 2> /dev/null\n  \n  if test -f conftest.exe\n  then\n    AC_MSG_RESULT([yes])\n    LD_RO=\"$test_LD_RO\"\n    break\n  else\n    AC_MSG_RESULT([no])\n  fi\ndone\n\nfi\n\nAC_SUBST(AR_CR)\nAR_CR=\nif test \"$ar_cr\" == true ; then\nfor test_AR_CR in \"$($CXX --print-prog-name=ar) cr\" \"ar cr\"\ndo\n  AC_MSG_CHECKING([whether static libraries can be created with $test_AR_CR])\n  \n  rm -f conftest-*\n  \n  cat << EOF > conftest-main.cpp\n  void f(void);\n  int main(int argc,char**argv){ f(); return 0; }\nEOF\n  cat << EOF > conftest-f.cpp\n  void g(void);\n  void f(void){ g(); }\nEOF\n  cat << EOF > conftest-g.cpp\n  void g(void){ return; }\nEOF\n  \n  $CXX $CXXFLAGS -c conftest-main.cpp 1> /dev/null 2> /dev/null\n  $CXX $CXXFLAGS -c conftest-f.cpp 1> /dev/null 2> /dev/null\n  $CXX $CXXFLAGS -c conftest-g.cpp 1> /dev/null 2> /dev/null\n  \n  $test_AR_CR conftest-both.a conftest-f.o conftest-g.o 1> /dev/null 2> /dev/null\n  \n  $CXX $CXXFLAGS -o conftest.exe conftest-main.o conftest-both.a 1> /dev/null 2> /dev/null\n  \n  if test -f conftest.exe\n  then\n    AC_MSG_RESULT([yes])\n    AR_CR=\"$test_AR_CR\"\n    break\n  else\n    AC_MSG_RESULT([no])\n  fi\ndone\n \nfi\n\nmake_static_archive=no\nAC_SUBST(make_static_archive)\n\nif test \"${static_archive}\" == true ; then\n  if test -z \"$LD_RO\" || test -z \"$AR_CR\" ; then\n    AC_MSG_WARN([no way to create a static archive if ld -ro or ar cr do not work])\n    static_archive=false\n  fi\nfi\n\nif test \"${static_archive}\" == true ; then\n  AC_MSG_CHECKING([whether static-object constructors can be linked from a static archive])\n\n  magic_token=c1bc476d093a3a5c67b4530e6c54c633593fe9aa\n  rm -f conftest-*\n  \n  cat << EOF > conftest-main.cpp\n  void f(void);\n  int main(int argc,char**argv){ f(); return 0; }\nEOF\n  cat << EOF > conftest-f.cpp\n  void f(void){ return; }\nEOF\n  cat << EOF > conftest-g.cpp\n#include <iostream>\n  class g{\n    public:\n    g(){ std::cout<<\"$magic_token\\n\"; }\n  } init;\nEOF\n\n  $CXX $CXXFLAGS -c conftest-main.cpp 1> /dev/null 2> /dev/null\n  $CXX $CXXFLAGS -c conftest-f.cpp 1> /dev/null 2> /dev/null\n  $CXX $CXXFLAGS -c conftest-g.cpp 1> /dev/null 2> /dev/null\n  \n  $LD_RO conftest-both.o conftest-f.o conftest-g.o 1> /dev/null 2> /dev/null\n# linking the previously merged objects should work:\n  $AR_CR conftest-both.a conftest-both.o 1> /dev/null 2> /dev/null\n# something like the following, instead, should not work:\n#  $AR_CR conftest-both.a conftest-f.o conftest-g.o 1> /dev/null 2> /dev/null\n#\n  $CXX $CXXFLAGS -o conftest.exe conftest-main.o conftest-both.a 1> /dev/null 2> /dev/null\n  if grep -q $magic_token ./conftest.exe ; then\n    AC_MSG_RESULT([yes])\n    make_static_archive=yes\n  else\n    AC_MSG_RESULT([no])\n  fi\nfi\n\nif test \"${static_patch}\" == true ; then\n\nAC_MSG_NOTICE([I will now check if C++ objects can be linked by C/Fortran compilers])\nAC_MSG_NOTICE([This is relevant if you want to use plumed patch --static on a non-C++ code])\n\nfor compiler in CC FC\ndo\n  rm -f conftest.* conftest-main.*\n  eval compexe=\\$$compiler\n  if test -n \"$compexe\" ; then\n    case $compiler in\n    (CC)\n      name=C\n      cat << EOF > conftest-main.c\nint main(int argc,char**argv){\n  return 0;\n}\nEOF\n      $CC -c conftest-main.c\n    ;;\n    (FC)\n      name=FORTRAN\n      cat << EOF > conftest-main.f90\n       program main\n       integer i\n       end program main\nEOF\n      $FC -c conftest-main.f90\n    ;;\n    esac\n    cat << EOF > conftest.cpp\n#include <iostream>\nvoid f(void){\n  std::cout<<\"ciao\";return;\n}\nEOF\n    $CXX $CXXFLAGS -c conftest.cpp \n# start search:\n    found=\n    if test \"${libsearch}\" == true ; then\n      testlibs=\"-lstdc++ -lc++ -lmpi_cxx\"\n    else\n      testlibs=\"\"\n    fi\n    for testlib in \"\" $testlibs ; do\n      comment=\n      test -n \"$testlib\" && comment=\" with library $testlib\"\n      AC_MSG_CHECKING([whether $name can link a C++ object$comment])\n      $compexe conftest.o conftest-main.o $LDFLAGS $testlib $LIBS -o conftest.exe 1>/dev/null 2>/dev/null\n      if test -f conftest.exe\n      then\n        found=yes\n        AC_MSG_RESULT([yes])\n        LIBS=\"$testlib $LIBS\"\n        break\n      else\n        AC_MSG_RESULT([no])\n      fi\n    done\n    if test -z \"$found\" ; then\n      AC_MSG_WARN([You might have problems linking $name programs.])\n      AC_MSG_WARN([Please add c++ library to LIBS])\n    fi\n  else\n    AC_MSG_NOTICE([$compiler compiler not configured])\n  fi\n  rm -f conftest.* conftest-main.*\ndone\n\nelse\nAC_MSG_NOTICE([Static patching is disabled, thus tests required for static patching will be skipped])\nfi\n\nif test \"$prefix\" == NONE\nthen\n  prefix=/usr/local\nfi\n\npkgconfig_bin=\"\"\n\nAC_PATH_PROGS(pkgconfig_bin,pkg-config)\n\nif test -z \"$BASH_COMPLETION_DIR\" && test -n \"$pkgconfig_bin\"; then\n  if test \"$prefix\" == \"$(pkg-config --variable=prefix bash-completion 2>/dev/null)\"\n  then\n    AC_MSG_NOTICE([bash-completion is installed on the same prefix where plumed will be installed])\n    if pkg-config --variable=completionsdir bash-completion 2>/dev/null >/dev/null ; then\n      BASH_COMPLETION_DIR=\"$(pkg-config --variable=completionsdir  bash-completion 2>/dev/null)\"\n    fi\n  else\n    AC_MSG_NOTICE([bash-completion is not installed or it is installed on a different prefix])\n    pkgconfig_bin=\"\"\n  fi\nfi\n\nif test -n \"$BASH_COMPLETION_DIR\"\nthen\n  AC_MSG_NOTICE([bash completion for plumed will be installed in $BASH_COMPLETION_DIR])\nelse\n  AC_MSG_NOTICE([bash completion for plumed will not be installed])\nfi\n\nAC_SUBST(BASH_COMPLETION_DIR)\n\nAC_ARG_PROGRAM\n\n\n# version modified to work in shell script instead of makefile:\nprogram_transform_name_sh=$(echo \"${program_transform_name}\" | sed 's:\\$\\$:$:g')\nprogram_name=$(echo plumed | sed \"$program_transform_name_sh\")\nAC_SUBST(program_name)\n\nif test \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]')\" != \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]' | sed 's/wrapper$//')\" ; then\n  AC_MSG_ERROR([$program_name is not a valid program name (should not terminate with Wrapper)])\nfi\nif test \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]')\" != \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]' | sed 's/kernel$//')\" ; then\n  AC_MSG_ERROR([$program_name is not a valid program name (should not terminate with Kernel)])\nfi\nif test \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]')\" != \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]' | sed 's/-patch$//')\" ; then\n  AC_MSG_ERROR([$program_name is not a valid program name (should not terminate with -patch)])\nfi\nif test \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]')\" != \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]' | sed 's/-config$//')\" ; then\n  AC_MSG_ERROR([$program_name is not a valid program name (should not terminate with -config)])\nfi\n\nAC_MSG_NOTICE([**** PLUMED will be installed using the following paths:])\nAC_MSG_NOTICE([**** prefix: $prefix])\nif test \"$exec_prefix\" = NONE ; then\n  exec_prefix_='${prefix}'\nelse\n  exec_prefix_=\"${exec_prefix}\"\nfi\nAC_MSG_NOTICE([**** exec_prefix: $exec_prefix_])\nAC_MSG_NOTICE([**** bindir: $bindir])\nAC_MSG_NOTICE([**** libdir: $libdir])\nAC_MSG_NOTICE([**** includedir: $includedir])\nAC_MSG_NOTICE([**** datarootdir: $datarootdir])\nAC_MSG_NOTICE([**** datadir: $datadir])\nAC_MSG_NOTICE([**** docdir: ${datarootdir}/doc/$program_name])\nAC_MSG_NOTICE([**** htmldir: $htmldir])\nAC_MSG_NOTICE([**** Executable will be named $program_name])\nAC_MSG_NOTICE([**** As of PLUMED 2.5, you cannot change paths anymore during \"make install\"])\nAC_MSG_NOTICE([**** Please configure and make clean to change the prefix])\n\nif test -z \"$BASH_COMPLETION_DIR\" ; then\n  AC_MSG_WARN([**** Bash completion for plumed will not be installed, please add the following two lines to your bashrc])\n  AC_MSG_WARN([**** _$program_name() { eval \"\\$($program_name --no-mpi completion 2>/dev/null)\";}])\n  AC_MSG_WARN([**** complete -F _$program_name -o default $program_name])\nfi\n\nif test $mpi == true; then\n  if test $mpi_found == ok; then\n    AC_MSG_NOTICE([**** PLUMED will be compiled using MPI])\n  else \n    AC_MSG_WARN([**** PLUMED will NOT be compiled using MPI because MPI have not been found!])\n  fi\nelse\n    AC_MSG_NOTICE([**** PLUMED will be compiled without MPI])\nfi\n\nif test $program_can_run == no ; then\n  AC_MSG_WARN([plumed executable will not run on this machine])\n  AC_MSG_WARN([to patch an MD code use 'plumed-patch'])\nelif test $mpi_found == ok ; then\n  if test $program_can_run_mpi == no ; then\n    AC_MSG_WARN([plumed executable will not run on this machine])\n    AC_MSG_WARN([unless you invoke it as 'plumed --no-mpi'])\n    AC_MSG_WARN([all command line tools are thus available as 'plumed --no-mpi name-of-the-tool'])\n    AC_MSG_WARN([e.g. 'plumed --no-mpi driver'])\n    AC_MSG_WARN([to patch an MD code use 'plumed --no-mpi patch'])\n    AC_MSG_WARN([(notice that MPI will be available anyway in the patched code)])\n  fi\nfi\n\nAC_SUBST(build_dir)\nbuild_dir=`pwd`\n\n\n\n# This is to replace tags in Makefile.conf.in\n# saving the result to Makefile.conf\nAC_CONFIG_FILES([Makefile.conf sourceme.sh])\n# This is to have the stamp-h file up to date\n# The date of this file keeps track of when Makefile.conf and sourceme.sh have been updated\nAC_CONFIG_FILES([stamp-h], [echo timestamp > stamp-h])\nAC_OUTPUT\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/src/wrapper/Plumed.h": "/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n   Copyright (c) 2011-2020 The plumed team\n   (see the PEOPLE file at the root of the distribution for a list of names)\n\n   See http://www.plumed.org for more information.\n\n   This file is part of plumed, version 2.\n\n   plumed is free software: you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   plumed is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#ifndef __PLUMED_wrapper_Plumed_h\n#define __PLUMED_wrapper_Plumed_h\n\n/*\n  This header might be included more than once in order to provide\n  the declarations and the definitions. The guard is thus closed before the end of the file\n  (match this brace) {\n  and a new guard is added for the definitions.\n*/\n\n/**\n\\page ReferencePlumedH Reference for interfacing MD codes with PLUMED\n\n  Plumed.h and Plumed.c contain the external plumed interface, which is used to\n  integrate it with MD engines. This interface is very general, and is expected\n  not to change across plumed versions. Plumed.c also implements a dummy version\n  of the interface, so as to allow a code to be fully linked even if the plumed\n  library is not available yet. These files could be directly included in the official\n  host MD distribution. In this manner, it will be sufficient to link the plumed\n  library at link time (on all systems) or directly at runtime (on systems where\n  dynamic loading is enabled) to include plumed features.\n\n  Notice that in PLUMED 2.5 this interface has been rewritten in order to allow\n  more debugging features and a better behavior in multithread environments.\n  The interface is almost perfectly backward compatible, although it implements\n  a few additional functions. See more details below.\n\n  Why is Plumed.c written in C and not C++? The reason is that the resulting Plumed.o\n  needs to be linked with the host MD code immediately (whereas the rest of plumed\n  could be linked a posteriori). Imagine the MD code is written in FORTRAN: when we\n  link the Plumed.o file we would like not to need any C++ library linked. In this\n  manner, we do not need to know which C++ compiler will be used to compile plumed.\n  The C++ library is only linked to the \"rest\" of plumed, which actually uses it.\n  Anyway, Plumed.c is written in such a manner to allow its compilation also in C++\n  (C++ is a bit stricter than C). This will\n  allow e.g. MD codes written in C++ to just incorporate Plumed.c (maybe renamed into\n  Plumed.cpp), without the need of configuring a plain C compiler.\n\n  Plumed interface can be used from C, C++ and FORTRAN. Everything concerning plumed\n  is hidden inside a single object type, which is described in C by a structure\n  (struct \\ref plumed), in C++ by a class (PLMD::Plumed) and in FORTRAN by a\n  fixed-length string (CHARACTER(LEN=32)). Obviously C++ can use both struct\n  and class interfaces, but the second should be preferred since it will automatically take\n  care of objects constructions and destructions. The reference interface\n  is the C one, whereas FORTRAN and C++ interfaces are implemented as wrappers\n  around it.\n  In the C++ interface, all the routines are implemented as methods of PLMD::Plumed.\n  In the C and FORTRAN interfaces, all the routines are named plumed_*, to\n  avoid potential name clashes. Notice that the entire plumed library\n  is implemented in C++, and it is hidden inside the PLMD namespace.\n\n  Handlers to the plumed object can be converted among different representations,\n  to allow inter-operability among languages. In C, there are tools to convert\n  to/from FORTRAN, whereas in C++ there are tools to convert to/from FORTRAN and C.\n\n  These handlers only contain a pointer to the real structure, so that\n  when a plumed object is brought from one language to another,\n  it brings a reference to the same environment.\n\n  Moreover, to simplify life in all cases where a single Plumed object is\n  required for the entire simulation (which covers many of the practical\n  applications with conventional MD codes) it is possible to take advantage\n  of a global interface, which is implicitly referring to a unique global instance.\n  The global object should still be initialized and finalized properly.\n  This global object is obviously not usable in a multithread context.\n\n  As of PLUMED 2.5, the interface contains a reference counter that allows\n  for a better control of plumed initializations and deallocations.\n  This is particularly useful for the C++ interface that now\n  behaves similarly to a primitive shared pointer and can be thus copied.\n  In other languages, to use the reference counter correctly it is sufficient to\n  remember the following rule: for any `plumed_create*` call, there should be a corresponding\n  `plumed_finalize` call. More examples can be found below.\n\n  The basic method to send a message to plumed is\n\\verbatim\n  (C) plumed_cmd\n  (C++) PLMD::Plumed::cmd\n  (FORTRAN)  PLUMED_F_CMD\n\\endverbatim\n\n  To initialize a plumed object, use:\n\\verbatim\n  (C)        plumed_create\n  (C++)      (constructor of PLMD::Plumed)\n  (FORTRAN)  PLUMED_F_CREATE\n\\endverbatim\n\n  As of PLUMED 2.5, you can also initialize a plumed object using the following functions,\n  that load a specific kernel:\n\\verbatim\n  (C)        plumed_create_dlopen\n  (C++)      PLMD::Plumed::dlopen\n  (FORTRAN)  PLUMED_F_CREATE_DLOPEN\n\\endverbatim\n\n  To finalize a plumed object, use\n\\verbatim\n  (C)        plumed_finalize\n  (C++)      (destructor of PLMD::Plumed)\n  (FORTRAN)  PLUMED_F_FINALIZE\n\\endverbatim\n\n  To access to the global-object, use\n\\verbatim\n  (C)        plumed_gcreate, plumed_gfinalize, plumed_gcmd\n  (C++)      PLMD::Plumed::gcreate, PLMD::Plumed::gfinalize, PLMD::Plumed::gcmd\n  (FORTRAN)  PLUMED_F_GCREATE, PLUMED_F_GFINALIZE, PLUMED_F_GCMD\n\\endverbatim\n\n  To check if the global object has been initialized, use\n\\verbatim\n  (C)        plumed_ginitialized\n  (C++)      PLMD::Plumed::ginitialized\n  (FORTRAN)  PLUMED_F_GINITIALIZED\n\\endverbatim\n\n  Notice that when using runtime binding the plumed library might be not available.\n  In this case, plumed_create (and plumed_gcreate) will still succeed, but a subsequent\n  call to plumed_cmd (or plumed_gcmd) would exit. In order to avoid this\n  unpleasant situation you have two options.\n\n  First, you can check if plumed library is available before actually creating an object\n  using this function:\n\\verbatim\n  (C)        plumed_installed\n  (C++)      PLMD::Plumed::installed\n  (FORTRAN)  PLUMED_F_INSTALLED\n\\endverbatim\n\n  Alternatively, as of PLUMED 2.5, you can interrogate the just created plumed\n  object using the following function:\n\\verbatim\n  (C)        plumed_valid\n  (C++)      PLMD::Plumed::valid\n  (FORTRAN)  PLUMED_F_VALID\n\\endverbatim\n\n  If you want to create on purpose an invalid Plumed object (useful in C++ to postpone\n  the loading of the library) you can use `Plumed p(Plumed::makeInvalid());`.\n\n  To know if the global object is valid instead you should use the following function:\n\\verbatim\n  (C)        plumed_gvalid\n  (C++)      PLMD::Plumed::gvalid\n  (FORTRAN)  PLUMED_F_GVALID\n\\endverbatim\n\n  To convert handlers between different languages, use\n\\verbatim\n  (C)        plumed_c2f                 (C to FORTRAN)\n  (C)        plumed_f2c                 (FORTRAN to C)\n  (C++)      Plumed(plumed) constructor (C to C++)\n  (C++)      operator plumed() cast     (C++ to C)\n  (C++)      Plumed(char*)  constructor (FORTRAN to C++)\n  (C++)      toFortran(char*)           (C++ to FORTRAN)\n\\endverbatim\n\n  As of PLUMED 2.5, when using C or C++ we allow a user to explicitly store a plumed object as\n  a void pointer (indeed: that's the only thing contained in a plumed object).\n  This might be useful in case you do not want to include the Plumed.h header in some\n  of your headers. In order to convert to/from void pointers you can use the following functions\n\\verbatim\n  (C)        plumed_v2c                 (void* to C)\n  (C)        plumed_c2v                 (C to void*)\n  (C++)      Plumed(void*) constructor  (void* to C++)\n  (C++)      toVoid()                   (C++ to void*)\n\\endverbatim\n  Using the functions above is much safer than accessing directly the pointer contained in the \\ref plumed struct\n  since, when compiling with debug options, it will check if the void pointer actually points to a plumed object.\n\n  As of PLUMED 2.5, we added a reference count. It is in practice possible\n  to create multiple `plumed` object that refer to the same environment.\n  This is done using the following functions\n\\verbatim\n  (C)        plumed_create_reference     (from a C object)\n  (C)        plumed_create_reference_f   (from a FORTRAN object)\n  (C)        plumed_create_reference_v   (from a void pointer)\n  (FORTRAN)  plumed_f_create_reference   (from a FORTRAN object)\n\\endverbatim\n  In C++ references are managed automatically by constructors and destructor.\n  In addition, you can manually manage them (with care!) using incref() and decref().\n\n  The interface of the FORTRAN functions is very similar to that of the C functions\n  and is listed below:\n\n\\verbatim\n  FORTRAN interface\n    SUBROUTINE PLUMED_F_CREATE(p)\n      CHARACTER(LEN=32), INTENT(OUT)   :: p\n    SUBROUTINE PLUMED_F_CREATE_DLOPEN(p,path)\n      CHARACTER(LEN=32), INTENT(OUT)   :: p\n      CHARACTER(LEN=*),  INTENT(IN)    :: path\n    SUBROUTINE PLUMED_F_CREATE_REFERENCE(p,r)\n      CHARACTER(LEN=32), INTENT(OUT)   :: p\n      CHARACTER(LEN=32), INTENT(IN)    :: r\n    SUBROUTINE PLUMED_F_CREATE_INVALID(p)\n      CHARACTER(LEN=32), INTENT(OUT)   :: p\n    SUBROUTINE PLUMED_F_CMD(p,key,val)\n      CHARACTER(LEN=32), INTENT(IN)    :: p\n      CHARACTER(LEN=*),  INTENT(IN)    :: key\n      UNSPECIFIED_TYPE,  INTENT(INOUT) :: val(*)\n    SUBROUTINE PLUMED_F_FINALIZE(p)\n      CHARACTER(LEN=32), INTENT(IN)    :: p\n    SUBROUTINE PLUMED_F_INSTALLED(i)\n      INTEGER,           INTENT(OUT)   :: i\n    SUBROUTINE PLUMED_F_VALID(p,i)\n      CHARACTER(LEN=32), INTENT(IN)    :: p\n      INTEGER,           INTENT(OUT)   :: i\n    SUBROUTINE PLUMED_F_USE_COUNT(p,i)\n      CHARACTER(LEN=32), INTENT(IN)    :: p\n      INTEGER,           INTENT(OUT)   :: i\n    SUBROUTINE PLUMED_F_GLOBAL(p)\n      CHARACTER(LEN=32), INTENT(OUT)   :: p\n    SUBROUTINE PLUMED_F_GINITIALIZED(i)\n      INTEGER,           INTENT(OUT)   :: i\n    SUBROUTINE PLUMED_F_GCREATE()\n    SUBROUTINE PLUMED_F_GCMD(key,val)\n      CHARACTER(LEN=*), INTENT(IN)     :: key\n      UNSPECIFIED_TYPE, INTENT(INOUT)  :: val(*)\n    SUBROUTINE PLUMED_F_GFINALIZE()\n    SUBROUTINE PLUMED_F_GVALID(i)\n      INTEGER,           INTENT(OUT)   :: i\n\\endverbatim\n\n  Almost all C functions have a corresponding FORTRAN function.\n  As a simple mnemonic, if you know the name of the C function you can obtain the\n  corresponding FORTRAN subroutine by adding `F_` after the `PLUMED_` prefix.\n  In addition, all `plumed` objects are replaced by `CHARACTER(LEN=32)` objects\n  holding the same information. These pointers basically contain a text representation\n  of the stored pointer, that is suitable to be contained in a string.\n  Finally, whenever a C function returns a value,\n  the corresponding FORTRAN subroutine will have an additional `INTENT(OUT)` parameter\n  passed as the its last argument.\n\n  When you compile the FORTRAN interface, wrapper functions are added with several possible\n  name manglings, so you should not experience problems linking the plumed library with a FORTRAN file.\n\n\\section ReferencePlumedH-exceptions Error handling\n\n  In case an error is detected by PLUMED, either because of some user error, some internal bug,\n  or some mistake in using the library, an exception will be thrown. The behavior is different depending if you use\n  PLUMED from C/FORTRAN or from C++.\n\n  First of all, notice that access to PLUMED goes through three functions:\n  - plumed_create: this, as of PLUMED 2.5, is guaranteed not to throw any exception. If there is a problem, it will\n    just return a NULL pointer\n  - plumed_cmd: this function might throw exceptions.\n  - plumed_finalize: this is a destructor and is guaranteed not to throw any exception.\n\n  The following discussion concerns all the exceptions thrown by plumed_cmd.\n\n  If you use C/FORTRAN, you will basically have no way to intercept the exception and the program will just terminate.\n\n  If you use C++ but you are calling the C interface (e.g. \\ref plumed_cmd), then you might be\n  able to catch the exceptions thrown by PLUMED. Notice that all the exceptions thrown by PLUMED inherit from std::exception,\n  so you might want to catch it by reference. Notice however that there is a C layer between your C++ code and the PLUMED\n  library. In principle, the stack unwinding performed during exception handling is undefined in C and might lead to problems\n  that are system and compiler dependent. In addition to this, there might be troubles when combining different compilers\n  or different standard libraries. E.g., if you MD code is linked against a given C++ library and PLUMED is linked against\n  another one, the two std::exception types will differ and you won't be able to catch exceptions raised by PLUMED.\n\n  If you use C++ and you are calling the C++ interface (e.g. \\ref Plumed::cmd), as of PLUMED 2.5 we implemented a complete\n  remapping of the exceptions thrown by PLUMED.  This solves both the problems mentioned above. In particular:\n  - Instead of throwing an exception, PLUMED will return (using a \\ref plumed_nothrow_handler) the details about the occurred error.\n  - An equivalent exception will be thrown within the inline PLUMED interface compiled with your MD code.\n\n  As a consequence, you will be able to combine different compilers and avoid stack unwinding in the C layer.\n\n  Notice that, even if you use \\ref Plumed::cmd, if you are loading a kernel <=2.4 any exception generated by PLUMED will\n  leak through the C layer. This might lead to undefined behavior. If you are lucky (with some compiler it works!) and\n  the exception arrives to C, PLUMED will catch it and rethrow it as it would do if you were using a kernel >=2.5.\n\n  The remapping of exceptions takes care of all the standard C++ exceptions plus all the exceptions raised within\n  PLUMED. Unexpected exceptions that are derived from std::exception will be rethrown as std::exception.\n  Notice that this implies some loss of information, since the original exception might have been of a different type.\n  However, it also implies that the virtual table of the original exception won't be needed anymore. This allows to\n  completely decouple the MD code from the PLUMED library.\n\n\\section ReferencePlumedH-2-5 New in PLUMED 2.5\n\n  The wrappers in PLUMED 2.5 have been completely rewritten with several improvements.\n  The interface is almost perfectly backward compatible, although the behavior of C++ constructors\n  has been modified slightly.\n  In addition, a few new functions are introduced (explicitly marked in the documentation).\n  As a consequence, if your code uses some of the new functions, you will not be able\n  to link it directly with an older PLUMED library (though you will still be able to load\n  an older PLUMED library at runtime). In addition, the reference counter changes slightly\n  the behavior of the C++ methods used to interoperate with C and FORTRAN.\n\n  An important novelty is in the way the runtime loader is implemented.\n  In particular, the loader works also if the symbols of the main executable are not exported.\n  The proper functions from the kernel are indeed searched explicitly now using `dlsym`.\n\n  Some additional features can be enabled using suitable environment variables. In particular:\n  - `PLUMED_LOAD_DEBUG` can be set to report more information about the loading process.\n  - `PLUMED_LOAD_NAMESPACE` can be set to `LOCAL` to load the PLUMED kernel in a separate\n    namespace. The default is global namespace, which is the same behavior of PLUMED <=2.4,\n    and is consistent with what happens when linking PLUMED as a shared library.\n  - `PLUMED_LOAD_NODEEPBIND` can be set to load the PLUMED kernel in not-deepbind mode. Deepbind\n    mode implies that the symbols defined in the library are preferred to other symbols with the same name.\n    Only works on systems supporting `RTLD_DEEPBIND` and is mostly for debugging purposes.\n\n  Another difference is that the implementation of the wrappers is now completely contained in the `Plumed.h`\n  file. You can see that the `Plumed.c` is much simpler now and just includes `Plumed.h`. With a similar\n  procedure you could compile the wrappers directly into your code making it unnecessary to link\n  the libplumedWrapper.a library. The corresponding macros are still subject to change and are not documented here.\n\n  As written above, the plumed object now implements a reference counter.  Consider the following example\n\\verbatim\n  plumed p=plumed_create();\n  plumed_cmd(p,\"init\",NULL);\n  plumed q=plumed_create_reference(p);\n  plumed_finalize(p);\n// at this stage, object q still exists\n  plumed_cmd(q,\"whatever\",NULL);\n  plumed_finalize(q);\n// now plumed has been really finalized\n\\endverbatim\n\n  In other words, every \\ref plumed_create, \\ref plumed_create_dlopen, \\ref plumed_create_reference,\n  \\ref plumed_create_reference_f, and \\ref plumed_create_reference_v call must be matched by a \\ref plumed_finalize.\n  Notice that in C++ whenever an object goes out of scope the reference counter\n  will be decreased. In addition, consider that conversion from C/FORTRAN/void* to C++ implies calling a C++ constructor, that\n  is increases the number of references by one. Converting from C++ to C/FORTRAN/void* instead does not call any constructor,\n  that is the number of references is unchanged.\n\n  The change in the behavior of C++ constructors means that the following code will behave in a backward incompatible manner:\n\\verbatim\n  plumed p=plumed_create();\n  plumed_cmd(p,\"init\",NULL);\n  Plumed q(p);\n  plumed_finalize(p);\n// at this stage, object q still exists with PLUMED 2.5\n// on the other hand, with PLUMED 2.4 object q refers to an\n// already finalized object\n  q.cmd(\"whatever\",NULL);\n\\endverbatim\n\n  Another difference is that the value of the variable `PLUMED_KERNEL` is read every time a new\n  plumed object is instantiated. So, you might even use it to load different plumed versions\n  simultaneously, although the preferred way to do this is using the function \\ref plumed_create_dlopen.\n  Notice that if you want to load multiple versions simultaneously you should load them in a local namespace.\n  \\ref plumed_create_dlopen does it automatically, whereas loading through env var `PLUMED_KERNEL` only does it if\n  you also set env var `PLUMED_NAMESPACE=LOCAL`.\n\n  Finally, a few functions have been added, namely:\n  - Functions to find if a plumed object is valid\n    (\\ref plumed_valid(), \\ref plumed_gvalid(), \\ref PLMD::Plumed::valid(), and \\ref PLMD::Plumed::gvalid()).\n  - Functions to create a plumed object based on the path of a specific kernel\n    (\\ref plumed_create_dlopen() and \\ref PLMD::Plumed::dlopen()).\n  - Functions to create a plumed object referencing to another one, implementing a reference counter\n    (\\ref plumed_create_reference(), \\ref plumed_create_reference_v(), \\ref plumed_create_reference_f().\n\n*/\n\n/* BEGINNING OF DECLARATIONS */\n\n/* SETTING DEFAULT VALUES FOR CONTROL MACROS */\n\n/*\n  1: make the C wrapper functions extern (default)\n  0: make the C wrapper functions static (C) or inline (C++)\n\n  If set to zero, it disables all functions that only make sense as extern, such as\n  Fortran wrappers, global objects, and plumed_kernel_register.\n\n  It can be set to zero to include multiple copies of the wrapper implementation without worrying\n  about duplicated symbols.\n\n  Notice that C++ wrappers are always inline. What this function controls is if the C wrappers\n  (called by the C++ wrappers) is inline or not. Also consider that if this header is compiled\n  with C++ and inline C wrappers, the C wrappers will be actually compiled with C++ linkage\n  in the root namespace.\n\n  Used both in declarations (to know which functions to declare) and definitions (to know which functions to define).\n*/\n\n#ifndef __PLUMED_WRAPPER_EXTERN\n#define __PLUMED_WRAPPER_EXTERN 1\n#endif\n\n/*\n  1: emit global plumed object and related functions (default)\n  0: do not emit global plumed object and related functions\n\n  Used both in declarations (to know which functions to declare) and definitions (to know which functions to define).\n*/\n\n#ifndef __PLUMED_WRAPPER_GLOBAL\n#define __PLUMED_WRAPPER_GLOBAL 1\n#endif\n\n/*\n  1: enable C++ wrapper (default)\n  0: disable C++ wrapper\n\n  Only used in declarations, but affects the scope of the C interface also in definitions.\n*/\n\n#ifndef __PLUMED_WRAPPER_CXX\n#define __PLUMED_WRAPPER_CXX 1\n#endif\n\n/*\n  1: new headers such as cstdlib are included in C++ (default)\n  0: old headers such as stdlib.h are included in C++\n\n  Should only be set to zero when including the Plumed.h file in a file using the\n  old (stdlib.h) convention.\n\n  Used both in declarations and definitions.\n*/\n\n#ifndef __PLUMED_WRAPPER_CXX_STD\n#define __PLUMED_WRAPPER_CXX_STD 1\n#endif\n\n/*\n  1: place C++ wrappers in an anonymous namespace\n  0: place C++ wrappers in the PLMD namespace (default)\n\n  It will make PLMD::Plumed a different class (though with the same name)\n  in each of the translation units in which `Plumed.h` is included.\n\n  Can be used to completey separate C++ implementations. However, it will make\n  it impossible to transfer Plumed objects between different translation units\n  without converting to a void* or plumed object.\n\n  Only used in declarations, but affects the scope of the C interface also in definitions.\n*/\n\n#ifndef __PLUMED_WRAPPER_CXX_ANONYMOUS_NAMESPACE\n#define __PLUMED_WRAPPER_CXX_ANONYMOUS_NAMESPACE 0\n#endif\n\n/*\n  1: make PLMD::Plumed class polymorphic (default)\n  0: make PLMD::Plumed class non-polymorphic\n\n  Only used in declarations.\n*/\n\n#ifndef __PLUMED_WRAPPER_CXX_POLYMORPHIC\n#define __PLUMED_WRAPPER_CXX_POLYMORPHIC 1\n#endif\n\n/*\n  1: make the default constructor create an invalid object\n  0: make the default constructor create a valid object\n\n  Only for internal usage.\n*/\n#ifndef __PLUMED_WRAPPER_CXX_DEFAULT_INVALID\n#define __PLUMED_WRAPPER_CXX_DEFAULT_INVALID 0\n#endif\n\n/*\n  Size of a buffer used to store message for exceptions with noexcept constructor.\n  Should typically hold short messages. Anyway, as long as the stack size stays within the correct\n  limits it does not seem to affect efficiency. Notice that there cannot be recursive calls of\n  PLMD::Plumed::cmd, so that it should be in practice irrelevant.\n*/\n#ifndef __PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER\n#define __PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER 512\n#endif\n\n\n/*\n By default, assume C++11 compliant library is not available.\n*/\n\n#ifndef __PLUMED_WRAPPER_LIBCXX11\n#define __PLUMED_WRAPPER_LIBCXX11 0\n#endif\n\n/* The following macros are just to define shortcuts */\n\n/* Simplify addition of extern \"C\" blocks.  */\n#ifdef __cplusplus\n#define __PLUMED_WRAPPER_EXTERN_C_BEGIN extern \"C\" {\n#define __PLUMED_WRAPPER_EXTERN_C_END }\n#else\n#define __PLUMED_WRAPPER_EXTERN_C_BEGIN\n#define __PLUMED_WRAPPER_EXTERN_C_END\n#endif\n\n/* Without C++, stdlib functions should not be prepended with ::std:: */\n#ifndef __cplusplus\n#undef __PLUMED_WRAPPER_CXX_STD\n#define __PLUMED_WRAPPER_CXX_STD 0\n#endif\n\n/* Set prefix for stdlib functions */\n#if __PLUMED_WRAPPER_CXX_STD\n#define __PLUMED_WRAPPER_STD ::std::\n#else\n#define __PLUMED_WRAPPER_STD\n#endif\n\n/* Allow using noexcept, explicit, and override with C++11 compilers */\n#if __cplusplus > 199711L\n#define __PLUMED_WRAPPER_CXX_NOEXCEPT noexcept\n#define __PLUMED_WRAPPER_CXX_EXPLICIT explicit\n#define __PLUMED_WRAPPER_CXX_OVERRIDE override\n#else\n#define __PLUMED_WRAPPER_CXX_NOEXCEPT throw()\n#define __PLUMED_WRAPPER_CXX_EXPLICIT\n#define __PLUMED_WRAPPER_CXX_OVERRIDE\n#endif\n\n/* Macros for anonymous namespace */\n#if __PLUMED_WRAPPER_CXX_ANONYMOUS_NAMESPACE && defined(__cplusplus) /*{*/\n#define __PLUMED_WRAPPER_ANONYMOUS_BEGIN namespace {\n#define __PLUMED_WRAPPER_ANONYMOUS_END }\n#else\n#define __PLUMED_WRAPPER_ANONYMOUS_BEGIN\n#define __PLUMED_WRAPPER_ANONYMOUS_END\n#endif /*}*/\n\n#if __PLUMED_WRAPPER_EXTERN /*{*/\n\n#define __PLUMED_WRAPPER_C_BEGIN __PLUMED_WRAPPER_EXTERN_C_BEGIN extern\n#define __PLUMED_WRAPPER_C_END __PLUMED_WRAPPER_EXTERN_C_END\n#define __PLUMED_WRAPPER_INTERNALS_BEGIN __PLUMED_WRAPPER_EXTERN_C_BEGIN static\n#define __PLUMED_WRAPPER_INTERNALS_END __PLUMED_WRAPPER_EXTERN_C_END\n\n#else\n\n#ifdef __cplusplus\n#define __PLUMED_WRAPPER_C_BEGIN  __PLUMED_WRAPPER_ANONYMOUS_BEGIN inline\n#define __PLUMED_WRAPPER_C_END __PLUMED_WRAPPER_ANONYMOUS_END\n#else\n#define __PLUMED_WRAPPER_C_BEGIN static\n#define __PLUMED_WRAPPER_C_END\n#endif\n\n#define __PLUMED_WRAPPER_INTERNALS_BEGIN __PLUMED_WRAPPER_C_BEGIN\n#define __PLUMED_WRAPPER_INTERNALS_END __PLUMED_WRAPPER_C_END\n\n/* with an not-external interface, it does not make sense to define global functions */\n#undef __PLUMED_WRAPPER_GLOBAL\n#define __PLUMED_WRAPPER_GLOBAL 0\n\n#endif /*}*/\n\n/**\n  \\brief Main plumed object\n\n  This is an object containing a Plumed instance, which should be used in\n  the MD engine. It should first be initialized with plumed_create(),\n  then it communicates with the MD engine using plumed_cmd(). Finally,\n  before the termination, it should be deallocated with plumed_finalize().\n  Its interface is very simple and general, and is expected\n  not to change across plumed versions. See \\ref ReferencePlumedH.\n*/\ntypedef struct {\n  /**\n    \\private\n    \\brief Void pointer holding the real PlumedMain structure\n\n    To maintain binary compatibility, we should not add members to this structure.\n    As of PLUMED 2.5, in order to add new components we do not store the pointer\n    to \\ref PlumedMain here but rather a pointer to an intermediate private structure\n    that contains all the details.\n  */\n  void*p;\n} plumed;\n\ntypedef struct {\n  void* ptr;\n  void (*handler)(void*,int,const char*,const void*);\n} plumed_nothrow_handler;\n\n/** \\relates plumed\n    \\brief Constructor\n\n    Constructs a plumed object.\n\n    Notice that if you are linking against libplumedWrapper.a, if you are\n    using a code patched in runtime mode, or if you are including the `Plumed.c`\n    file directly in your code, this constructor might return an invalid plumed\n    object. In particular, this could happen if the `PLUMED_KERNEL` environment\n    variable is not set or set incorrectly. In order to detect an incorrect\n    plumed object you might use \\ref plumed_valid() on the resulting object.\n    Alternatively, if you use \\ref plumed_cmd() on an invalid plumed object the code will exit.\n    Also notice that to avoid memory leaks you should call \\ref plumed_finalize()\n    to finalize a plumed object even if it is invalid:\n\\verbatim\n  plumed p=plumed_create();\n  if(!plumed_valid(p)) {\n// this will happen if the PLUMED_KERNEL variable is not set correctly\n    plumed_finalize(p);\n    return whatever;\n  }\n\\endverbatim\n\n    \\return The constructed plumed object\n*/\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create(void);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Constructor from path. Available as of PLUMED 2.5\n\n    It tries to construct a plumed object loading the kernel located at path.\n    Notice that it could leave the resulting object in an invalid state.\n    In order to detect an invalid\n    plumed object you might use \\ref plumed_valid() on the resulting object.\n    Alternatively, if you use \\ref plumed_cmd() on an invalid plumed object the code will exit.\n\n    Also notice that to avoid memory leaks you should call \\ref plumed_finalize()\n    to finalize a plumed object even if it is invalid.\n\\verbatim\n  plumed p=plumed_create(path);\n  if(!plumed_valid(p)) {\n// this will happen if the path argument is not set correctly\n    plumed_finalize(p);\n    return whatever;\n  }\n\\endverbatim\n\n    \\return The constructed plumed object\n*/\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_dlopen(const char*path);\n__PLUMED_WRAPPER_C_END\n\n\n/**\n  \\brief Constructor from path. Available as of PLUMED 2.5\n\n  Same as \\ref plumed_create_dlopen, but also allows to specify the mode for dlopen.\n\n  \\warning\n  Use with care, since not all the possible modes work correctly with PLUMED.\n*/\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_dlopen2(const char*path,int mode);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    Create a new reference to an existing object, increasing its reference count. Available as of PLUMED 2.5\n\n    Use it to increase by one the reference count of a plumed object.\n    The resulting pointer might be identical to the one passed as an\n    argument, but the reference count will be incremented by one.\n    Notice that you should finalize the resulting object.\n\\verbatim\n  plumed p1;\n  plumed p2;\n  p1=plumed_create();\n  p2=plumed_create_reference(p1);\n  plumed_finalize(p1);\n// now you can still use p2\n  plumed_cmd(p2,\"init\",NULL);\n  plumed_finalize(p2);\n// now the underlying object is destroyed.\n\\endverbatim\n\n    If the `p` object is invalid, also the returned object will be invalid.\n\n    \\param p The plumed object that will be referenced to.\n    \\return The constructed plumed object\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_reference(plumed p);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Create a new reference to an existing object passed as a void pointer, increasing its reference count. Available as of PLUMED 2.5\n\n  \\return The constructed plumed object\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_reference_v(void*v);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Create a new reference to an existing object passed as a fortran string, increasing its reference count. Available as of PLUMED 2.5\n\n  \\return The constructed plumed object\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_reference_f(const char*f);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Constructor as invalid. Available as of PLUMED 2.5\n\n   Can be used to create an object in the same state as if it was returned by\n   plumed_create_dlopen with an incorrect path (or plumed_create using runtime binding\n   and an incorrect PLUMED_KERNEL).\n\n   Can be used to initialize a plumed object to a well-defined state without explicitly\n   creating it. The resulting object can be checked later with \\ref plumed_valid.\n   Consider the following example\n\\verbatim\n    plumed p;\n    p=plumed_create_invalid();\n// at this point p is initialized to a well-defined (invalid) state.\n    setenv(\"PLUMED_KERNEL\",\"/path/to/kernel/libplumedKernel.so\",1);\n    plumed_finalize(p);\n    p=plumed_create();\n\\endverbatim\n\n    \\return The constructed plumed object\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_invalid();\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Tells p to execute a command.\n\n    If the object is not valid (see \\ref plumed_valid), this command will exit.\n\n    \\param p The plumed object on which command is acting\n    \\param key The name of the command to be executed\n    \\param val The argument. It is declared as const to allow calls like plumed_cmd(p,\"A\",\"B\"),\n               but for some choice of key it can change the content.\n\n    Notice that within PLUMED we use a const_cast to remove any const qualifier from the second\n    argument of \\ref plumed_cmd.\n\n    In some cases val can be omitted: just pass a NULL pointer (in C++, val is optional and can be omitted,\n    or you can equivalently pass NULL or nullptr).\n    The set of possible keys is the real API of the plumed library, and will be expanded with time.\n    New commands will be added, but backward compatibility will be retained as long as possible.\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid plumed_cmd(plumed p,const char*key,const void*val);\n__PLUMED_WRAPPER_C_END\n\n/**\n  \\relates plumed\n  \\brief Same as \\ref plumed_cmd, but does not throw exceptions.\n\n  This function is meant to be used when errors should be handled explicitly.\n  if an exception is raised within PLUMED, the function nothrow.handler() will\n  be called with arguments (nothrow.ptr,code,message,opt). This allows the C++ interface\n  to correctly rethrow exceptions, but might be used from C as well. opt can be used\n  to pass further information (not used yet).\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid plumed_cmd_nothrow(plumed p,const char*key,const void*val,plumed_nothrow_handler nothrow);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Destructor.\n\n    It must be used for any object created using \\ref plumed_create(),\n    even if the created object is not valid.\n\n    \\param p The plumed object to be deallocated\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid plumed_finalize(plumed p);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Check if plumed is installed (for runtime binding).\n\n    Notice that this is equivalent to creating a dummy object and checking if it is valid.\n\n\\verbatim\n  // this:\n  //int a=plumed_installed();\n  // is equivalent to this:\n\n  plumed p=plumed_create();\n  int a=plumed_valid(p);\n  plumed_finalize(p);\n\n\\endverbatim\n\n    This function is mostly provided for compatibility with PLUMED 2.4, where \\ref plumed_valid()\n    was not available. Using \\ref plumed_valid() is now preferred since it creates a single object\n    instead of creating a dummy object that is then discarded.\n\n    \\return 1 if plumed is installed, 0 otherwise\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nint plumed_installed(void);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Check if plumed object is valid. Available as of PLUMED 2.5\n\n    It might return false if plumed is not available at runtime.\n\n    \\return 1 if plumed is valid, 0 otherwise\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nint plumed_valid(plumed p);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Returns the number of references to the underlying object. Available as of PLUMED 2.5.\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nint plumed_use_count(plumed p);\n__PLUMED_WRAPPER_C_END\n\n\n/* routines to convert char handler from/to plumed objects */\n\n/** \\related plumed\n    \\brief Converts a C handler to a FORTRAN handler\n\n    \\param p The C handler\n    \\param c The FORTRAN handler (a char[32])\n\n    This function can be used to convert a plumed object created in C to\n    a plumed handler that can be used in FORTRAN. Notice that the reference counter\n    is not incremented. In other words, the FORTRAN object will be a weak reference.\n    If you later finalize the C handler, the FORTRAN handler will be invalid.\n\\verbatim\n#include <plumed/wrapper/Plumed.h>\nint main(int argc,char*argv[]){\n  plumed p;\n  p=plumed_create();\n  char fortran_handler[32];\n  plumed_c2f(p,fortran_handler);\n  printf(\"DEBUG: this is a string representation for the plumed handler: %s\\n\",fortran_handler);\n  fortran_routine(fortran_handler);\n  plumed_finalize(p);\n  return 0;\n}\n\\endverbatim\n  Here `fortran_routine` is a routine implemented in FORTRAN that manipulates the\n  fortran_handler.\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid   plumed_c2f(plumed p,char* c);\n__PLUMED_WRAPPER_C_END\n\n/** \\related plumed\n    \\brief Converts a FORTRAN handler to a C handler\n    \\param c The FORTRAN handler (a char[32])\n    \\return The C handler\n\n    This function can be used to convert a plumed object created in FORTRAN\n    to a plumed handler that can be used in C.  Notice that the reference counter\n    is not incremented. In other words, the C object will be a weak reference.\n    If you later finalize the FORTRAN handler, the C handler will be invalid.\n\\verbatim\nvoid c_routine(char handler[32]){\n  plumed p;\n  p=plumed_f2c(handler);\n  plumed_cmd(p,\"init\",NULL);\n}\n\\endverbatim\n  Here `c_routine` is a C function that can be called from FORTRAN\n  and interact with the provided plumed handler.\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_f2c(const char* c);\n__PLUMED_WRAPPER_C_END\n\n/** \\related plumed\n    \\brief Converts a plumed object to a void pointer. Available as of PLUMED 2.5.\n\n    It returns a void pointer that can be converted back to a plumed object using \\ref plumed_v2c.\n    When compiling without NDEBUG, it checks if the plumed object was properly created.\n    Notice that an invalid object (see \\ref plumed_valid) can be converted to void* and back.\n\n    Can be used to store a reference to a plumed object without including the Plumed.h header.\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid* plumed_c2v(plumed p);\n__PLUMED_WRAPPER_C_END\n\n\n/** \\related plumed\n    \\brief Converts a void pointer to a plumed object. Available as of PLUMED 2.5.\n\n    It returns a plumed object from a void pointer obtained with \\ref plumed_c2v.\n    When compiling without NDEBUG, it checks if the plumed object was properly created.\n\n    Can be used to store a reference to a plumed object without including the Plumed.h header.\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_v2c(void*);\n__PLUMED_WRAPPER_C_END\n\n\n#if __PLUMED_WRAPPER_GLOBAL /*{*/\n\n/* Global C functions are always extern */\n__PLUMED_WRAPPER_EXTERN_C_BEGIN /*{*/\n\n/** \\relates plumed\n    \\brief Retrieves an handler to the global structure.\n\n  You can use this if you work on a code that uses the global structure and you want to\n  pass to a generic routine an handler to the same structure. E.g.\n\n\\verbatim\n  plumed p=plumed_global();\n  some_routine(p);\n\\endverbatim\n*/\nextern\nplumed plumed_global(void);\n\n/** \\relates plumed\n    \\brief Check if the global interface has been initialized.\n\n    \\return 1 if plumed has been initialized, 0 otherwise\n*/\nextern\nint plumed_ginitialized(void);\n\n/** \\relates plumed\n    \\brief Constructor for the global interface.\n\n    \\note Equivalent to plumed_create(), but initialize the static global plumed object\n*/\nextern\nvoid plumed_gcreate(void);\n\n/** \\relates plumed\n    \\brief Tells to the global interface to execute a command.\n\n    \\param key The name of the command to be executed\n    \\param val The argument. It is declared as const to allow calls like plumed_gcmd(\"A\",\"B\"),\n               but for some choice of key it can change the content\n\n    `plumed_gcmd(a,b);` is equivalent to `plumed_cmd(plumed_global(),a,b);`.\n*/\nextern\nvoid plumed_gcmd(const char* key,const void* val);\n\n/** \\relates plumed\n    \\brief Destructor for the global interface.\n\n    `plumed_gfinalize(a,b);` is similar to `plumed_finalize(plumed_global(),a,b);`, but not completely\n    equivalent. In particular, plumed_gfinalize() also makes sure that the global object\n    is reset to its initial status. After calling it, \\ref plumed_ginitialized() will thus return 0.\n*/\nextern\nvoid plumed_gfinalize(void);\n\n/** \\relates plumed\n    \\brief Check if global plumed object is valid. Available as of PLUMED 2.5\n\n    It might return zero if plumed is not available at runtime.\n\n    \\return 1 if plumed is valid, 0 otherwise.\n*/\nextern\nint plumed_gvalid();\n\n__PLUMED_WRAPPER_EXTERN_C_END /*}*/\n\n#endif /*}*/\n\n#if defined( __cplusplus) && __PLUMED_WRAPPER_CXX /*{*/\n\n#if __PLUMED_WRAPPER_CXX_STD\n#include <cstdlib> /* NULL getenv */\n#include <cstring> /* strncat strlen */\n#include <cstdio> /* fprintf */\n#else\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#endif\n\n#include <exception> /* exception bad_exception */\n#include <stdexcept> /* runtime_error logic_error invalid_argument domain_error length_error out_of_range range_error overflow_error underflow_error */\n#include <string> /* string */\n#include <ios> /* iostream_category (C++11) ios_base::failure (C++11 and C++<11) */\n#include <new> /* bad_alloc bad_array_new_length (C++11) */\n#include <typeinfo> /* bad_typeid bad_cast */\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n#include <system_error> /* system_error generic_category system_category */\n#include <future> /* future_category */\n#include <memory> /* bad_weak_ptr */\n#include <functional> /* bad_function_call */\n#endif\n\n/* C++ interface is hidden in PLMD namespace (same as plumed library) */\nnamespace PLMD {\n\n/* Optionally, it is further hidden in an anonymous namespace */\n\n__PLUMED_WRAPPER_ANONYMOUS_BEGIN /*{*/\n\n/**\n  C++ wrapper for \\ref plumed.\n\n  This class provides a C++ interface to PLUMED.\n  It only containts a \\ref plumed object, but wraps it with a number of useful methods.\n  All methods are inlined so as to avoid the compilation of an extra c++ file.\n\n*/\n\nclass Plumed {\n  /**\n    C structure.\n  */\n  plumed main;\n\n  /**\n    Error handler used to rethrow exceptions.\n  */\n\n  struct NothrowHandler {\n    /** code used for translating messages */\n    int code;\n    /** short message buffer for non-throwing exceptions */\n    char exception_buffer[__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER];\n    /** if exception_buffer='\\0', message stored as an allocatable string */\n    ::std::string what;\n    /** error code for system_error */\n    int error_code;\n  };\n\n  /**\n    Callback function that sets the error handler.\n\n    opt argument is interpreted as the pointer to a null terminated array of void*.\n    The number of non-null element is expected to be even, and there should be a null element\n    that follows. Every pair of pointers should point\n    to a char, identifying the type of argument passed, and an arbitrary object.\n    Currently used to (optionally) pass error_code.\n  */\n  static void nothrow_handler(void*ptr,int code,const char*what,const void* opt) {\n    NothrowHandler* h=(NothrowHandler*) ptr;\n    h->code=code;\n    h->exception_buffer[0]='\\0';\n    h->what.clear();\n    h->error_code=0;\n    /*\n       These codes correspond to exceptions that should not allocate a separate buffer but use the fixed one.\n       Notice that a mismatch between the exceptions using the stack buffer here and those implementing\n       the stack buffer would be in practice harmless. However, it makes sense to be consistent.\n    */\n    if(code==10000 || (code>=11000 && code<12000)) {\n      __PLUMED_WRAPPER_STD strncat(h->exception_buffer,what,__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1);\n    } else {\n      h->what=what;\n    }\n\n    /* interpret optional arguments */\n    const void** options=(const void**)opt;\n    if(options) while(*options) {\n        if(*((char*)*options)=='c') h->error_code=*((int*)*(options+1));\n        options+=2;\n      }\n\n    static const char* debug=__PLUMED_WRAPPER_STD getenv(\"PLUMED_EXCEPTIONS_DEBUG\");\n\n    if(debug) {\n      __PLUMED_WRAPPER_STD fprintf(stderr,\"+++ PLUMED_EXCEPTIONS_DEBUG\\n\");\n      __PLUMED_WRAPPER_STD fprintf(stderr,\"+++ code: %d error_code: %d message:\\n%s\\n\",h->code,h->error_code,what);\n      if(__PLUMED_WRAPPER_STD strlen(what) > __PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1) __PLUMED_WRAPPER_STD fprintf(stderr,\"+++ WARNING: message will be truncated\\n\");\n      __PLUMED_WRAPPER_STD fprintf(stderr,\"+++ END PLUMED_EXCEPTIONS_DEBUG\\n\");\n    }\n\n  }\n\n  /**\n    Rethrow the exception based on the information saved in the NothrowHandler.\n  */\n\n  static void rethrow(const NothrowHandler&h) {\n    /* The interpretation of the codes should be kept in sync with core/PlumedMainInitializer.cpp */\n    /* check if we are using a full string or a fixes size buffer */\n    const char* msg=(h.exception_buffer[0]?h.exception_buffer:h.what.c_str());\n    if(h.code==1) throw Plumed::Invalid(msg);\n    /* logic errors */\n    if(h.code>=10100 && h.code<10200) {\n      if(h.code>=10105 && h.code<10110) throw ::std::invalid_argument(msg);\n      if(h.code>=10110 && h.code<10115) throw ::std::domain_error(msg);\n      if(h.code>=10115 && h.code<10120) throw ::std::length_error(msg);\n      if(h.code>=10120 && h.code<10125) throw ::std::out_of_range(msg);\n      throw ::std::logic_error(msg);\n    }\n    /* runtime errors */\n    if(h.code>=10200 && h.code<10300) {\n      if(h.code>=10205 && h.code<10210) throw ::std::range_error(msg);\n      if(h.code>=10210 && h.code<10215) throw ::std::overflow_error(msg);\n      if(h.code>=10215 && h.code<10220) throw ::std::underflow_error(msg);\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n      if(h.code==10220) throw ::std::system_error(h.error_code,::std::generic_category(),msg);\n      if(h.code==10221) throw ::std::system_error(h.error_code,::std::system_category(),msg);\n      if(h.code==10222) throw ::std::system_error(h.error_code,::std::iostream_category(),msg);\n      if(h.code==10223) throw ::std::system_error(h.error_code,::std::future_category(),msg);\n#endif\n      if(h.code>=10230 && h.code<10240) {\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n// These cases are probably useless as it looks like this should always be std::iostream_category\n        if(h.code==10230) throw ::std::ios_base::failure(msg,std::error_code(h.error_code,::std::generic_category()));\n        if(h.code==10231) throw ::std::ios_base::failure(msg,std::error_code(h.error_code,::std::system_category()));\n        if(h.code==10232) throw ::std::ios_base::failure(msg,std::error_code(h.error_code,::std::iostream_category()));\n        if(h.code==10233) throw ::std::ios_base::failure(msg,std::error_code(h.error_code,::std::future_category()));\n#endif\n        throw ::std::ios_base::failure(msg);\n      }\n      throw ::std::runtime_error(msg);\n    }\n    /* \"bad\" errors */\n    if(h.code>=11000 && h.code<11100) throw Plumed::std_bad_typeid(msg);\n    if(h.code>=11100 && h.code<11200) throw Plumed::std_bad_cast(msg);\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n    if(h.code>=11200 && h.code<11300) throw Plumed::std_bad_weak_ptr(msg);\n    if(h.code>=11300 && h.code<11400) throw Plumed::std_bad_function_call(msg);\n#endif\n    if(h.code>=11400 && h.code<11500) {\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n      if(h.code>=11410 && h.code<11420) throw Plumed::std_bad_array_new_length(msg);\n#endif\n      throw Plumed::std_bad_alloc(msg);\n    }\n    if(h.code>=11500 && h.code<11600) throw Plumed::std_bad_exception(msg);\n    /* lepton error */\n    if(h.code>=19900 && h.code<20000) throw Plumed::LeptonException(msg);\n    /* plumed exceptions */\n    if(h.code>=20000 && h.code<30000) {\n      /* debug - only raised with debug options */\n      if(h.code>=20100 && h.code<20200) throw Plumed::ExceptionDebug(msg);\n      /* error - runtime check */\n      if(h.code>=20200 && h.code<20300) throw Plumed::ExceptionError(msg);\n      throw Plumed::Exception(msg);\n    }\n    /* fallback for any other exception */\n    throw Plumed::std_exception(msg);\n  }\n\n  /**\n    Rethrow the current exception.\n\n    This is useful in order to handle an exception thrown by a kernel <=2.4.\n    Only std exceptions are handled, though some of them are thrown as special\n    Plumed exceptions in order to be attached a message.\n  */\n  static void rethrow() {\n    try {\n      throw;\n    } catch(const ::std::bad_exception & e) {\n      throw Plumed::std_bad_exception(e.what());\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n    } catch(const ::std::bad_array_new_length & e) {\n      throw Plumed::std_bad_array_new_length(e.what());\n#endif\n    } catch(const ::std::bad_alloc & e) {\n      throw Plumed::std_bad_alloc(e.what());\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n    } catch(const ::std::bad_function_call & e) {\n      throw Plumed::std_bad_function_call(e.what());\n    } catch(const ::std::bad_weak_ptr & e) {\n      throw Plumed::std_bad_weak_ptr(e.what());\n#endif\n    } catch(const ::std::bad_cast & e) {\n      throw Plumed::std_bad_cast(e.what());\n    } catch(const ::std::bad_typeid & e) {\n      throw Plumed::std_bad_typeid(e.what());\n      // not implemented yet: std::regex_error\n      // we do not allow regex yet due to portability problems with gcc 4.8\n      // as soon as we transition to using <regex> it should be straightforward to add\n    } catch(const ::std::ios_base::failure & e) {\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n      throw ::std::ios_base::failure(e.what(),e.code());\n#else\n      throw ::std::ios_base::failure(e.what());\n#endif\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n    } catch(const ::std::system_error & e) {\n      throw ::std::system_error(e.code(),e.what());\n#endif\n    } catch(const ::std::underflow_error &e) {\n      throw ::std::underflow_error(e.what());\n    } catch(const ::std::overflow_error &e) {\n      throw ::std::overflow_error(e.what());\n    } catch(const ::std::range_error &e) {\n      throw ::std::range_error(e.what());\n    } catch(const ::std::runtime_error & e) {\n      throw ::std::runtime_error(e.what());\n      // not implemented yet: std::future_error\n      // not clear how useful it would be.\n    } catch(const ::std::out_of_range & e) {\n      throw ::std::out_of_range(e.what());\n    } catch(const ::std::length_error & e) {\n      throw ::std::length_error(e.what());\n    } catch(const ::std::domain_error & e) {\n      throw ::std::domain_error(e.what());\n    } catch(const ::std::invalid_argument & e) {\n      throw ::std::invalid_argument(e.what());\n    } catch(const ::std::logic_error & e) {\n      throw ::std::logic_error(e.what());\n    } catch(const ::std::exception & e) {\n      throw Plumed::std_exception(e.what());\n    } catch(...) {\n      throw Plumed::std_bad_exception(\"plumed could not translate exception\");\n    }\n  }\n\npublic:\n\n  /**\n    Base class used to rethrow PLUMED exceptions.\n  */\n\n  class Exception :\n    public ::std::exception\n  {\n    ::std::string msg;\n  public:\n    __PLUMED_WRAPPER_CXX_EXPLICIT Exception(const char* msg): msg(msg) {}\n    const char* what() const __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {return msg.c_str();}\n    /* Destructor should be declared in order to have the correct throw() */\n    ~Exception() __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {}\n  };\n\n  /**\n    Used to rethrow a PLMD::ExceptionError\n  */\n\n  class ExceptionError :\n    public Exception {\n  public:\n    __PLUMED_WRAPPER_CXX_EXPLICIT ExceptionError(const char* msg): Exception(msg) {}\n    /* Destructor should be declared in order to have the correct throw() */\n    ~ExceptionError() __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {}\n  };\n\n  /**\n    Used to rethrow a PLMD::ExceptionDebug\n  */\n\n  class ExceptionDebug :\n    public Exception {\n  public:\n    __PLUMED_WRAPPER_CXX_EXPLICIT ExceptionDebug(const char* msg): Exception(msg) {}\n    /* Destructor should be declared in order to have the correct throw() */\n    ~ExceptionDebug() __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {}\n  };\n\n  /**\n    Thrown when trying to access an invalid plumed object\n  */\n\n  class Invalid :\n    public Exception {\n  public:\n    __PLUMED_WRAPPER_CXX_EXPLICIT Invalid(const char* msg): Exception(msg) {}\n    /* Destructor should be declared in order to have the correct throw() */\n    ~Invalid() __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {}\n  };\n\n  /**\n    Class used to rethrow Lepton exceptions.\n  */\n\n  class LeptonException :\n    public ::std::exception\n  {\n    ::std::string msg;\n  public:\n    __PLUMED_WRAPPER_CXX_EXPLICIT LeptonException(const char* msg): msg(msg) {}\n    const char* what() const __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {return msg.c_str();}\n    /* Destructor should be declared in order to have the correct throw() */\n    ~LeptonException() __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {}\n  };\n\nprivate:\n  /*\n    These exceptions are declared as private as they are not supposed to be\n    catched by value. they only exist to allow a buffer to be attached to\n    the std::exceptions that do not contain it already.\n    Notice that these exceptions are those whose constructor should never throw, and as\n    such they use a fixed size buffer.\n  */\n\n#define __PLUMED_WRAPPER_NOSTRING_EXCEPTION(name) \\\n  class std_ ## name : \\\n    public ::std::name \\\n  { \\\n    char msg[__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER]; \\\n  public: \\\n    __PLUMED_WRAPPER_CXX_EXPLICIT std_ ## name(const char * msg) __PLUMED_WRAPPER_CXX_NOEXCEPT { \\\n      this->msg[0]='\\0'; \\\n      __PLUMED_WRAPPER_STD strncat(this->msg,msg,__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1); \\\n      static const char* debug=__PLUMED_WRAPPER_STD getenv(\"PLUMED_EXCEPTIONS_DEBUG\"); \\\n      if(debug && __PLUMED_WRAPPER_STD strlen(msg) > __PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1) __PLUMED_WRAPPER_STD fprintf(stderr,\"+++ WARNING: message will be truncated\\n\"); \\\n    } \\\n    std_ ## name(const std_ ## name & other) __PLUMED_WRAPPER_CXX_NOEXCEPT { \\\n      msg[0]='\\0'; \\\n      __PLUMED_WRAPPER_STD strncat(msg,other.msg,__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1); \\\n    } \\\n    std_ ## name & operator=(const std_ ## name & other) __PLUMED_WRAPPER_CXX_NOEXCEPT { \\\n      if(this==&other) return *this;\\\n      msg[0]='\\0'; \\\n      __PLUMED_WRAPPER_STD strncat(msg,other.msg,__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1); \\\n      return *this; \\\n    } \\\n    const char* what() const __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {return msg;} \\\n    ~std_ ## name() __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {} \\\n  };\n\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_typeid)\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_cast)\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_weak_ptr)\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_function_call)\n#endif\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_alloc)\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_array_new_length)\n#endif\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_exception)\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(exception)\n\npublic:\n\n  /**\n     Check if plumed is installed (for runtime binding)\n     \\return true if plumed is installed, false otherwise\n     \\note Equivalent to plumed_installed() but returns a bool\n  */\n  static bool installed() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return plumed_installed();\n  }\n  /**\n     Check if Plumed object is valid. Available as of PLUMED 2.5\n     \\return true if plumed is valid, false otherwise\n     \\note Equivalent to plumed_valid() but returns a bool\n  */\n  bool valid() const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return plumed_valid(main);\n  }\n#if __cplusplus > 199711L\n  /**\n     Same as \\ref valid(). Available as of PLUMED 2.5.\n\n  Allow code such as\n  \\verbatim\n  Plumed p;\n  if(!p) raise_error();\n  p.cmd(\"init\");\n  \\endverbatim\n\n  In order to avoid ambiguous conversions, this is only allowed when compiling with C++11\n  where it is marked as explicit.\n  */\n  explicit\n  operator bool() const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return plumed_valid(main);\n  }\n#endif\n\n  /**\n     Returns the number of references to this object. Available as of PLUMED 2.5.\n    \\note Equivalent to plumed_use_count()\n  */\n  int useCount() const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return plumed_use_count(main);\n  }\n\n#if __PLUMED_WRAPPER_GLOBAL /*{*/\n  /**\n     Check if global-plumed has been initialized\n     \\return true if global plumed object (see global()) is initialized (i.e. if gcreate() has been\n             called), false otherwise.\n     \\note Equivalent to plumed_ginitialized() but returns a bool\n  */\n  static bool ginitialized() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return plumed_ginitialized();\n  }\n  /**\n     Check if global-plumed is valid\n     \\return true if global plumed object (see global()) is valid.\n     \\note Equivalent to plumed_gvalid() but returns a bool\n  */\n  static bool gvalid() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return plumed_gvalid();\n  }\n  /**\n     Initialize global-plumed.\n     \\note Equivalent to plumed_gcreate()\n  */\n  static void gcreate() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    plumed_gcreate();\n  }\n  /**\n     Send a command to global-plumed\n      \\param key The name of the command to be executed\n      \\param val The argument. It is declared as const to allow calls like gcmd(\"A\",\"B\"),\n                 but for some choice of key it can change the content\n     \\note Equivalent to plumed_gcmd()\n  */\n  static void gcmd(const char* key,const void* val=NULL) {\n    global().cmd(key,val);\n  }\n  /**\n     Finalize global-plumed\n  */\n  static void gfinalize() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    plumed_gfinalize();\n  }\n  /**\n     Returns the Plumed global object\n\n     Notice that the object is copied, thus increasing the reference counter of the\n     global object. In this manner, the global object will survive after a call to\n     \\ref gfinalize() if the resulting object is still in scope.\n\n     \\return The Plumed global object\n  */\n  static Plumed global() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return Plumed(plumed_global());\n  }\n#endif /*}*/\n  /**\n     Constructor.\n\n    Notice that when using runtime binding the constructed object might be\n    invalid. One might check it using the \\ref valid() method.\n\n    \\note Performs the same task a plumed_create()\n  */\nPlumed()__PLUMED_WRAPPER_CXX_NOEXCEPT :\n#if __PLUMED_WRAPPER_CXX_DEFAULT_INVALID\n  main(plumed_create_invalid())\n#else\n  main(plumed_create())\n#endif\n  {\n  }\n\n  /**\n     Clone a Plumed object from a FORTRAN char* handler.\n\n     \\param c The FORTRAN handler (a char[32]).\n\n     The reference counter for the corresponding object will be increased\n     to make sure that the object will be available after plumed_f_finalize is called\n     if the created object is still in scope.\n  */\n__PLUMED_WRAPPER_CXX_EXPLICIT Plumed(const char*c)__PLUMED_WRAPPER_CXX_NOEXCEPT :\n  main(plumed_create_reference_f(c))\n  {\n  }\n\n  /**\n    Create a reference from a void* pointer. Available as of PLUMED 2.5.\n  */\n__PLUMED_WRAPPER_CXX_EXPLICIT Plumed(void*v)__PLUMED_WRAPPER_CXX_NOEXCEPT :\n  main(plumed_create_reference_v(v))\n  {\n  }\n\n  /**\n     Clone a Plumed object from a C plumed structure\n\n     \\param p The C plumed structure.\n\n     The reference counter for the corresponding object will be increased\n     to make sure that the object will be available after plumed_finalize is called\n     if the created object is still in scope.\n  */\n__PLUMED_WRAPPER_CXX_EXPLICIT Plumed(plumed p)__PLUMED_WRAPPER_CXX_NOEXCEPT :\n  main(plumed_create_reference(p))\n  {\n  }\n\n  /** Copy constructor.\n\n    Takes a reference, incrementing the reference counter of the corresponding object.\n  */\nPlumed(const Plumed& p)__PLUMED_WRAPPER_CXX_NOEXCEPT :\n  main(plumed_create_reference(p.main))\n  {\n  }\n\n  /** Assignment operator. Available as of PLUMED 2.5.\n\n    Takes a reference,incrementing the reference counter of the corresponding object.\n  */\n  Plumed&operator=(const Plumed&p) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    if(this != &p) {\n// the check is needed to avoid calling plumed_finalize on moved objects\n      if(main.p) decref();\n      main=plumed_create_reference(p.main);\n    }\n    return *this;\n  }\n\n  /*\n    PLUMED >= 2.4 requires a C++11 compiler.\n    Anyway, since Plumed.h file might be redistributed with other codes\n    and it should be possible to combine it with earlier PLUMED versions,\n    we here explicitly check if C+11 is available before enabling move semantics.\n  */\n#if __cplusplus > 199711L\n  /** Move constructor. Available as of PLUMED 2.5.\n    Only if move semantics is enabled.\n  */\nPlumed(Plumed&&p)__PLUMED_WRAPPER_CXX_NOEXCEPT :\n  main(p.main)\n  {\n    p.main.p=nullptr;\n  }\n  /** Move assignment. Available as of PLUMED 2.5.\n    Only if move semantics is enabled.\n  */\n  Plumed& operator=(Plumed&&p)__PLUMED_WRAPPER_CXX_NOEXCEPT  {\n    if(this != &p) {\n// the check is needed to avoid calling plumed_finalize on moved objects\n      if(main.p) decref();\n      main=p.main;\n      p.main.p=nullptr;\n    }\n    return *this;\n  }\n#endif\n  /**\n    Create a PLUMED object loading a specific kernel. Available as of PLUMED 2.5.\n\n    It returns an object created with \\ref plumed_create_dlopen. The object is owned and\n    is then finalized in the destructor. It can be used as follows:\n  \\verbatim\n    PLMD::Plumed p = PLMD::Plumed::dlopen(\"/path/to/libplumedKernel.so\");\n  // or, equivalenty:\n  //    PLMD::Plumed p(PLMD::Plumed::dlopen(\"/path/to/libplumedKernel.so\"));\n    p.cmd(\"init\");\n  \\endverbatim\n    or, equivalently, as\n  \\verbatim\n    auto p = PLMD::Plumed::dlopen(\"/path/to/libplumedKernel.so\");\n    p.cmd(\"init\");\n  \\endverbatim\n  */\n  static Plumed dlopen(const char* path)__PLUMED_WRAPPER_CXX_NOEXCEPT  {\n// use decref to remove the extra reference\n    return Plumed(plumed_create_dlopen(path)).decref();\n  }\n\n  /**\n    Create a PLUMED object loading a specific kernel. Available as of PLUMED 2.5.\n\n    Same as \\ref dlopen(const char* path), but allows a dlopen mode to be chosen explicitly.\n  */\n  static Plumed dlopen(const char* path,int mode)__PLUMED_WRAPPER_CXX_NOEXCEPT  {\n// use decref to remove the extra reference\n    return Plumed(plumed_create_dlopen2(path,mode)).decref();\n  }\n  /** Invalid constructor. Available as of PLUMED 2.5.\n\n    Can be used to initialize an invalid object. It might be useful to postpone\n    the initialization of a Plumed object. Consider the following case\n  \\verbatim\n    Plumed p;\n    setenv(\"PLUMED_KERNEL\",\"/path/to/kernel/libplumedKernel.so\",1);\n    p.cmd(\"init\")\n  \\endverbatim\n    Here the `p` object will be initialized *before* the `PLUMED_KERNEL` env var has been set.\n    This can be particularly problematic if `p` is stored in some high level class.\n    The following case would do the job\n  \\verbatim\n    Plumed p;\n    setenv(\"PLUMED_KERNEL\",\"/path/to/kernel/libplumedKernel.so\",1);\n    p=Plumed();\n    p.cmd(\"init\")\n  \\endverbatim\n    However, there will be some error reported related to the attempt to load the kernel\n    when `p` is initialized. The following solution is the optimal one:\n  \\verbatim\n    Plumed p(Plumed::makeInvalid());\n    setenv(\"PLUMED_KERNEL\",\"/path/to/kernel/libplumedKernel.so\",1);\n    p=Plumed();\n    p.cmd(\"init\")\n  \\endverbatim\n  */\n  static Plumed makeInvalid() __PLUMED_WRAPPER_CXX_NOEXCEPT  {\n// use decref to remove the extra reference\n    return Plumed(plumed_create_invalid()).decref();\n  }\n\n  /**\n    Create a valid PLMD::Plumed object.\n\n    Can be used to create a valid object e.g. when Plumed.h was compiled with\n    `-D__PLUMED_WRAPPER_CXX_DEFAULT_INVALID`. For internal usage.\n  */\n\n  static Plumed makeValid()__PLUMED_WRAPPER_CXX_NOEXCEPT  {\n// use decref to remove the extra reference\n    return Plumed(plumed_create()).decref();\n  }\n\n\n  /**\n     Retrieve the C plumed structure for this object.\n\n     Notice that the resulting plumed structure is a weak reference and\n     should NOT be finalized, unless a new reference is explicitly added\n  \\verbatim\n  Plumed p;\n  plumed c=p;\n  plumed_finalize(c); // <- this is wrong\n  \\endverbatim\n  \\verbatim\n  Plumed p;\n  plumed c=plumed_create_reference(p);\n  plumed_finalize(c); // <- this is right\n  \\endverbatim\n  */\n  operator plumed()const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return main;\n  }\n\n  /**\n     Retrieve a FORTRAN handler for this object\n      \\param c The FORTRAN handler (a char[32]).\n    Notice that the resulting plumed structure is a weak reference and\n    should NOT be finalized, unless a new reference is explicitly added.\n  */\n  void toFortran(char*c)const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    plumed_c2f(main,c);\n  }\n\n  /**\n     Retrieve a void* handler for this object. Available as of PLUMED 2.5.\n    Notice that the resulting plumed structure is a weak reference and\n    should NOT be finalized, unless a new reference is explicitly added.\n  */\n  void* toVoid()const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return plumed_c2v(main);\n  }\n\n  /**\n    Increase reference counter. Available as of PLUMED 2.5.\n\n    Using this method improperly might interfere with correct object construction\n    and destruction.\n    If you want to play with this, also try to compile using `-D__PLUMED_WRAPPER_DEBUG_REFCOUNT=1` and see what happens.\n\n    A possible usage is to transfer the ownership of a temporary\n    object when it is converted\n  \\verbatim\n  plumed p=Plumed::dlopen(path).incref()\n  // without incref(), the just constructed object will be destroyed\n  // when the temporary object is deleted.\n  ... do stuff ...\n  plumed_finalize(p);\n  \\endverbatim\n\n  */\n  Plumed& incref() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    plumed_create_reference(main);\n    return *this;\n  }\n\n  /**\n    Decrease reference counter. Available as of PLUMED 2.5.\n\n    Using this method improperly might interfere with correct object construction\n    and destruction.\n    If you want to play with this, also try to compile using `-D__PLUMED_WRAPPER_DEBUG_REFCOUNT=1` and see what happens.\n  */\n  Plumed& decref() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n// calling decref on a moved plumed object should give an error, so we do not check if main.p!=NULL here:\n    plumed_finalize(main);\n    return *this;\n  }\n\n  /**\n     Send a command to this plumed object\n      \\param key The name of the command to be executed\n      \\param val The argument. It is declared as const to allow calls like p.cmd(\"A\",\"B\"),\n                 but for some choice of key it can change the content\n      \\note Similar to \\ref plumed_cmd(). It actually called \\ref plumed_cmd_nothrow() and\n            rethrow any exception raised within PLUMED.\n  */\n  void cmd(const char*key,const void*val=NULL) {\n    NothrowHandler h;\n    h.code=0;\n    plumed_nothrow_handler nothrow= {&h,nothrow_handler};\n    try {\n      plumed_cmd_nothrow(main,key,val,nothrow);\n    } catch (...) {\n      /*\n        When loading a kernel <=2.4, plumed_cmd_nothrow could throw an exception.\n        If the exception is transmitted through the C interface and arrives here,\n        we translate it so as to free the virtual tables of the loaded kernel.\n      */\n      rethrow();\n    }\n    if(h.code!=0) rethrow(h);\n  }\n\n  /**\n     Destructor\n\n     It calls \\ref plumed_finalize(). Notice that this is done also if the\n     constructor failed (that is, if it returned an invalid object). This allows\n     declaring Plumed objects also if PLUMED is actually not available, provided\n     one does not use the \\ref cmd method.\n\n     Destructor is virtual so as to allow correct inheritance from Plumed object.\n  */\n#if __PLUMED_WRAPPER_CXX_POLYMORPHIC\n  virtual\n#endif\n  ~Plumed() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n// the check is needed to avoid calling plumed_finalize on moved objects\n    if(main.p) decref();\n  }\n};\n\n/**\n  \\related Plumed\n  Comparison operator. Available as of PLUMED 2.5.\n*/\ninline\nbool operator==(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n  return a.toVoid()==b.toVoid();\n}\n\n/**\n  \\related Plumed\n  Comparison operator. Available as of PLUMED 2.5.\n*/\ninline\nbool operator!=(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n  return a.toVoid()!=b.toVoid();\n}\n\n/**\n  \\related Plumed\n  Comparison operator. Available as of PLUMED 2.5.\n*/\ninline\nbool operator<=(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n  return a.toVoid()<=b.toVoid();\n}\n\n/**\n  \\related Plumed\n  Comparison operator. Available as of PLUMED 2.5.\n*/\ninline\nbool operator<(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n  return a.toVoid()<b.toVoid();\n}\n\n/**\n  \\related Plumed\n  Comparison operator. Available as of PLUMED 2.5.\n*/\ninline\nbool operator>=(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n  return a.toVoid()>=b.toVoid();\n}\n\n/**\n  \\related Plumed\n  Comparison operator. Available as of PLUMED 2.5.\n*/\ninline\nbool operator>(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n  return a.toVoid()>b.toVoid();\n}\n\n__PLUMED_WRAPPER_ANONYMOUS_END /*}*/\n\n}\n\n#endif /*}*/\n\n#endif /*}*/\n\n/* END OF DECLARATIONS */\n\n/*\n\n  1: emit implementation\n  0: do not emit implementation\n\n  Allows an implementation to be emitted together with the declarations.\n\n  Used to decide if definitions should be emitted. This macro could have a different\n  value when Plumed.h is reincluded. As a consequence, we map it to a local\n  macro (__PLUMED_WRAPPER_IMPLEMENTATION_) that is reset at the end of this file.\n*/\n\n#ifdef __PLUMED_WRAPPER_IMPLEMENTATION\n#define __PLUMED_WRAPPER_IMPLEMENTATION_ __PLUMED_WRAPPER_IMPLEMENTATION\n#else\n#define __PLUMED_WRAPPER_IMPLEMENTATION_ 0\n#endif\n\n/* BEGINNING OF DEFINITIONS */\n\n#if __PLUMED_WRAPPER_IMPLEMENTATION_  /*{*/\n#ifndef __PLUMED_wrapper_Plumed_implementation /*{*/\n#define __PLUMED_wrapper_Plumed_implementation\n\n/*\n  the following macros only control the implementation\n*/\n\n/*\n  1: enable the definition of plumed_symbol_table_reexport\n  0: does not enable the definition of plumed_symbol_table_reexport\n\n  This is only needed in the official plumed library to make\n  the symbol table available. This is a hack to reexport the function table\n  and is only needed when creating the library libplumed.so.\n*/\n\n#ifndef __PLUMED_WRAPPER_REEXPORT_SYMBOL_TABLE\n#define __PLUMED_WRAPPER_REEXPORT_SYMBOL_TABLE 0\n#endif\n\n/*\n  1: write on stderr changes in reference counters\n  0: do not write changes in reference counters\n\n  Used for debugging.\n\n  Only used in definitions.\n*/\n\n#ifndef __PLUMED_WRAPPER_DEBUG_REFCOUNT\n#define __PLUMED_WRAPPER_DEBUG_REFCOUNT 0\n#endif\n\n/*\n  1: emit plumed_kernel_register function (default)\n  0: do not emit plumed_kernel_register function\n\n  This function is only needed to avoid an extra warning when loading old (<=2.4) kernels.\n  We might change its default in the future.\n\n  Used only in definitions.\n*/\n\n#ifndef __PLUMED_WRAPPER_KERNEL_REGISTER\n#define __PLUMED_WRAPPER_KERNEL_REGISTER 1\n#endif\n\n/*\n  1: emit Fortran wrappers\n  0: do not emit Fortran wrappers (default)\n\n  Used only in definitions.\n*/\n\n#ifndef __PLUMED_WRAPPER_FORTRAN\n#define __PLUMED_WRAPPER_FORTRAN 0\n#endif\n\n/*\n  With internal interface, it does not make sence to emit kernel register or fortran interfaces\n*/\n\n#if ! __PLUMED_WRAPPER_EXTERN /*{*/\n#undef __PLUMED_WRAPPER_KERNEL_REGISTER\n#define __PLUMED_WRAPPER_KERNEL_REGISTER 0\n#undef __PLUMED_WRAPPER_FORTRAN\n#define __PLUMED_WRAPPER_FORTRAN 0\n#endif /*}*/\n\n#ifdef __PLUMED_HAS_DLOPEN\n#include <dlfcn.h> /* dlopen dlerror dlsym */\n#endif\n\n#if __PLUMED_WRAPPER_CXX_STD\n#include <cstdio>  /* fprintf */\n#include <cstring> /* memcpy strlen strncpy memcmp memmove strcmp memcpy */\n#include <cassert> /* assert */\n#include <cstdlib> /* getenv malloc free abort exit */\n#include <climits> /* CHAR_BIT */\n#else\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <limits.h>\n#endif\n\n/**\n  Function pointer to plumed_create\n*/\n\ntypedef void*(*plumed_create_pointer)(void);\n/**\n  Function pointer to plumed_cmd\n*/\ntypedef void(*plumed_cmd_pointer)(void*,const char*,const void*);\n\n/**\n  Function pointer to plumed_finalize\n*/\ntypedef void(*plumed_finalize_pointer)(void*);\n\n/**\n   Holder for plumedmain function pointers.\n*/\ntypedef struct {\n  plumed_create_pointer create;\n  plumed_cmd_pointer cmd;\n  plumed_finalize_pointer finalize;\n} plumed_plumedmain_function_holder;\n\n/**\n  Holder for plumed symbol table.\n\n  The table contains pointers to function exported from plumed. Functions can be added increasing the version number.\n  Notice that the default way to extend functionalities is by adding cmd strings. This is a last resort, and all new\n  functions should be explicitly motivated. Here's the addition:\n\n  version=2, cmd_nothrow.\n\n  This function accepts an extra argument `plumed_nothrow_handler*handler`.\n  In case an exception is thrown withint plumed, it just calls `handler->handler(handler->ptr,code,message,opt)` and return.\n  An alternative would have been to install an error handler (with a call to cmd(\"setErrorHandler\")). However, the cost\n  of doing it everytime Plumed::cmd is called is too high. On the other hand, installing it only at object construction\n  is very risky since and object created in that way would not report any error if manipulated from the C interface.\n  So, it looks like this is the only possibility.\n\n*/\ntypedef struct {\n  /**\n    Version number.\n\n    Minimum value is 1.\n  */\n  int version;\n  /**\n    Pointers to standard plumed functions (create/cmd/finalize).\n\n    Always available.\n  */\n  plumed_plumedmain_function_holder functions;\n  /**\n    Pointer to a cmd function guaranteed not to throw exceptions.\n\n    Available with version>=2.\n  */\n  void (*cmd_nothrow)(void*plumed,const char*key,const void*val,plumed_nothrow_handler);\n} plumed_symbol_table_type;\n\n/* Utility to convert function pointers to pointers, just for the sake of printing them */\n#define __PLUMED_CONVERT_FPTR(ptr,fptr) { ptr=NULL; __PLUMED_WRAPPER_STD memcpy(&ptr,&fptr,(sizeof(fptr)>sizeof(ptr)?sizeof(ptr):sizeof(fptr))); }\n\n#define __PLUMED_GETENV __PLUMED_WRAPPER_STD getenv\n#define __PLUMED_FPRINTF __PLUMED_WRAPPER_STD fprintf\n#define __PLUMED_MALLOC __PLUMED_WRAPPER_STD malloc\n#define __PLUMED_FREE __PLUMED_WRAPPER_STD free\n\n/**\n  Historically (PLUMED<=2.4) register for plumedmain function pointers.\n  As of PLUMED>=2.5, this function does not do anything except for reporting the attempt to register\n  something. It always returns NULL. The function should be here anyway to allow an incomplete\n  libplumedKernel (<=2.4), expecting this function to be present, to be loaded correctly.\n*/\n#if __PLUMED_WRAPPER_KERNEL_REGISTER\n/* Since it is only called from outside, it must be hardcoded to be extern */\n__PLUMED_WRAPPER_EXTERN_C_BEGIN /*{*/\nextern plumed_plumedmain_function_holder* plumed_kernel_register(const plumed_plumedmain_function_holder*);\nplumed_plumedmain_function_holder* plumed_kernel_register(const plumed_plumedmain_function_holder* f) {\n  void* tmpptr;\n  if(f) {\n    if(__PLUMED_GETENV(\"PLUMED_LOAD_DEBUG\")) {\n      __PLUMED_FPRINTF(stderr,\"+++ Ignoring registration at %p (\",(void*)f);\n      __PLUMED_CONVERT_FPTR(tmpptr,f->create);\n      __PLUMED_FPRINTF(stderr,\"%p,\",tmpptr);\n      __PLUMED_CONVERT_FPTR(tmpptr,f->cmd);\n      __PLUMED_FPRINTF(stderr,\"%p,\",tmpptr);\n      __PLUMED_CONVERT_FPTR(tmpptr,f->finalize);\n      __PLUMED_FPRINTF(stderr,\"%p) +++\\n\",tmpptr);\n    }\n  }\n  return NULL;\n}\n__PLUMED_WRAPPER_EXTERN_C_END /*}*/\n#endif\n\n#if defined( __PLUMED_HAS_DLOPEN) /*{*/\n/**\nTry to dlopen a path with a given mode.\nIf the dlopen command fails, it tries to strip the `Kernel` part of the name.\n\nThis function is declared static (internal linkage) so that it is not visible from outside.\nIt is first declared then defined to make sure it is a regular C static function.\n*/\n\n__PLUMED_WRAPPER_INTERNALS_BEGIN\nvoid* plumed_attempt_dlopen(const char*path,int mode) {\n  char* pathcopy;\n  void* p;\n  char* pc;\n  size_t strlenpath;\n  FILE* fp;\n  pathcopy=NULL;\n  p=NULL;\n  pc=NULL;\n  strlenpath=0;\n  fp=__PLUMED_WRAPPER_STD fopen(path,\"r\");\n  if(!fp) {\n    __PLUMED_FPRINTF(stderr,\"+++ File %s does not exist or cannot be read\\n\",path);\n    return NULL;\n  }\n  __PLUMED_WRAPPER_STD fclose(fp);\n  dlerror();\n  p=dlopen(path,mode);\n  if(!p) {\n    /*\n      Something went wrong. We try to remove \"Kernel\" string from the PLUMED_KERNEL variable\n      and load directly the shared library. Notice that this particular path is only expected\n      to be necessary when using PLUMED<=2.4 and the symbols in the main executable are\n      not visible. All the other cases (either PLUMED>=2.5 or symbols in the main executable visible)\n      should work correctly without entering here.\n    */\n    __PLUMED_FPRINTF(stderr,\"+++ An error occurred. Message from dlopen(): %s +++\\n\",dlerror());\n    strlenpath=__PLUMED_WRAPPER_STD strlen(path);\n    pathcopy=(char*) __PLUMED_MALLOC(strlenpath+1);\n    __PLUMED_WRAPPER_STD strncpy(pathcopy,path,strlenpath+1);\n    pc=pathcopy+strlenpath-6;\n    while(pc>=pathcopy && __PLUMED_WRAPPER_STD memcmp(pc,\"Kernel\",6)) pc--;\n    if(pc>=pathcopy) {\n      __PLUMED_WRAPPER_STD memmove(pc, pc+6, __PLUMED_WRAPPER_STD strlen(pc)-5);\n      __PLUMED_FPRINTF(stderr,\"+++ This error is expected if you are trying to load a kernel <=2.4\\n\");\n      __PLUMED_FPRINTF(stderr,\"+++ Trying %s +++\\n\",pathcopy);\n      fp=__PLUMED_WRAPPER_STD fopen(path,\"r\");\n      if(!fp) {\n        __PLUMED_FPRINTF(stderr,\"+++ File %s does not exist or cannot be read\\n\",pathcopy);\n        __PLUMED_FREE(pathcopy);\n        return NULL;\n      }\n      __PLUMED_WRAPPER_STD fclose(fp);\n      dlerror();\n      p=dlopen(pathcopy,mode);\n      if(!p) __PLUMED_FPRINTF(stderr,\"+++ An error occurred. Message from dlopen(): %s +++\\n\",dlerror());\n    }\n    __PLUMED_FREE(pathcopy);\n  }\n  return p;\n}\n__PLUMED_WRAPPER_INTERNALS_END\n\n/**\n  Utility to search for a function.\n*/\n#define __PLUMED_SEARCH_FUNCTION(tmpptr,handle,func,name,debug) \\\n  if(!func) { \\\n    tmpptr=dlsym(handle,name); \\\n    if(tmpptr) { \\\n      *(void **)(&func)=tmpptr; \\\n      if(debug) __PLUMED_FPRINTF(stderr,\"+++ %s found at %p +++\\n\",name,tmpptr); \\\n    } else { \\\n      if(debug) __PLUMED_FPRINTF(stderr,\"+++ Function %s not found\\n\",name); \\\n    } \\\n  }\n\n/**\nSearch symbols in a dlopened library.\n\nThis function is declared static (internal linkage) so that it is not visible from outside.\n*/\n__PLUMED_WRAPPER_INTERNALS_BEGIN\nvoid plumed_search_symbols(void* handle, plumed_plumedmain_function_holder* f,plumed_symbol_table_type** table) {\n  plumed_plumedmain_function_holder functions;\n  plumed_symbol_table_type* table_ptr;\n  void* tmpptr;\n  char* debug;\n  functions.create=NULL;\n  functions.cmd=NULL;\n  functions.finalize=NULL;\n  table_ptr=NULL;\n  tmpptr=NULL;\n  /*\n    Notice that as of PLUMED 2.5 we ignore self registrations.\n    Pointers are searched in the form of a single pointer to a structure, which\n    is the standard way in PLUMED 2.5, as well as using alternative names used in\n    PLUMED 2.0 to 2.4 (e.g. plumedmain_create) and in some intermediate versions between\n    PLUMED 2.4 and 2.5 (e.g. plumed_plumedmain_create). The last chance is probably\n    unnecessary and might be removed at some point.\n  */\n  debug=__PLUMED_GETENV(\"PLUMED_LOAD_DEBUG\");\n  table_ptr=(plumed_symbol_table_type*) dlsym(handle,\"plumed_symbol_table\");\n  if(table_ptr) functions=table_ptr->functions;\n  if(debug) {\n    if(table_ptr) {\n      __PLUMED_FPRINTF(stderr,\"+++ plumed_symbol_table version %i found at %p +++\\n\",table_ptr->version,(void*)table_ptr);\n      __PLUMED_FPRINTF(stderr,\"+++ plumed_function_pointers found at %p (\",(void*)&table_ptr->functions);\n      __PLUMED_CONVERT_FPTR(tmpptr,functions.create);\n      __PLUMED_FPRINTF(stderr,\"%p,\",tmpptr);\n      __PLUMED_CONVERT_FPTR(tmpptr,functions.cmd);\n      __PLUMED_FPRINTF(stderr,\"%p,\",tmpptr);\n      __PLUMED_CONVERT_FPTR(tmpptr,functions.finalize);\n      __PLUMED_FPRINTF(stderr,\"%p) +++\\n\",tmpptr);\n    } else {\n      __PLUMED_FPRINTF(stderr,\"+++ plumed_symbol_table (available in PLUMED>=2.5) not found, perhaps kernel is older +++\\n\");\n    }\n  }\n  /* only searches if they were not found already */\n  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.create,\"plumedmain_create\",debug);\n  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.create,\"plumed_plumedmain_create\",debug);\n  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.cmd,\"plumedmain_cmd\",debug);\n  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.cmd,\"plumed_plumedmain_cmd\",debug);\n  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.finalize,\"plumedmain_finalize\",debug);\n  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.finalize,\"plumed_plumedmain_finalize\",debug);\n  if(functions.create && functions.cmd && functions.finalize) {\n    if(debug) __PLUMED_FPRINTF(stderr,\"+++ PLUMED was loaded correctly +++\\n\");\n    *f=functions;\n    if(table) *table=table_ptr;\n  } else {\n    if(!functions.create) __PLUMED_FPRINTF(stderr,\"+++ Pointer to (plumed_)plumedmain_create not found +++\\n\");\n    if(!functions.cmd) __PLUMED_FPRINTF(stderr,\"+++ Pointer to (plumed_)plumedmain_cmd not found +++\\n\");\n    if(!functions.finalize) __PLUMED_FPRINTF(stderr,\"+++ Pointer to (plumed_)plumedmain_finalize not found +++\\n\");\n    f->create=NULL;\n    f->cmd=NULL;\n    f->finalize=NULL;\n    if(table) *table=NULL;\n  }\n}\n__PLUMED_WRAPPER_INTERNALS_END\n\n#endif /*}*/\n\n\n#if __PLUMED_WRAPPER_REEXPORT_SYMBOL_TABLE\n\n/*\n  Here is the case where plumed_symbol_table is\n  visible as extern. We first declare it (together with plumed_symbol_table_init) ...\n*/\n\n__PLUMED_WRAPPER_EXTERN_C_BEGIN\nextern\nplumed_symbol_table_type plumed_symbol_table;\n__PLUMED_WRAPPER_EXTERN_C_END\n__PLUMED_WRAPPER_EXTERN_C_BEGIN\nextern\nvoid plumed_symbol_table_init(void);\n__PLUMED_WRAPPER_EXTERN_C_END\n\n/*\n  ... and then make available a function that returns the address\n  of the symbol table.\n*/\n__PLUMED_WRAPPER_C_BEGIN\nplumed_symbol_table_type* plumed_symbol_table_reexport() {\n  /* make sure the table is initialized */\n  plumed_symbol_table_init();\n  return &plumed_symbol_table;\n}\n__PLUMED_WRAPPER_C_END\n\n#else\n\n/*\n  Here is the case where plumed_symbol_table is not\n  visible as extern. We thus assume that plumed_symbol_table_reexport is\n  available.\n*/\n\n__PLUMED_WRAPPER_EXTERN_C_BEGIN\nextern plumed_symbol_table_type* plumed_symbol_table_reexport();\n__PLUMED_WRAPPER_EXTERN_C_END\n#endif\n\n\n/*\n  Returns the global pointers, either those available at link time or those\n  found in the library loaded at PLUMED_KERNEL env var.\n  If plumed_symbol_table_ptr is not NULL, it is used to return a pointer to the symbol table\n  (if available).\n  Notice that problems can be detected checking if the functions have a NULL ptr.\n  On the other hand, the symbol table pointer might be NULL just because the plumed version is <=2.4.\n  If handle is not NULL, it is used to return a dlopen handle that could be subsequently dlclosed.\n*/\n__PLUMED_WRAPPER_INTERNALS_BEGIN\nvoid plumed_retrieve_functions(plumed_plumedmain_function_holder* functions, plumed_symbol_table_type** plumed_symbol_table_ptr,void** handle) {\n#if ! __PLUMED_WRAPPER_LINK_RUNTIME\n  /*\n    Real interface, constructed using the symbol table obtained with plumed_symbol_table_reexport.\n    This makes the symbols hardcoded and independent of a mis-set PLUMED_KERNEL variable.\n  */\n  plumed_symbol_table_type* ptr=plumed_symbol_table_reexport();\n  if(plumed_symbol_table_ptr) *plumed_symbol_table_ptr=ptr;\n  if(handle) *handle=NULL;\n  if(functions) *functions=ptr->functions;\n#elif ! defined(__PLUMED_HAS_DLOPEN)\n  /*\n    When dlopen is not available, we hard code them to NULL\n  */\n  fprintf(stderr,\"+++ PLUMED has been compiled without dlopen and without a static kernel +++\\n\");\n  plumed_plumedmain_function_holder g= {NULL,NULL,NULL};\n  if(plumed_symbol_table_ptr) *plumed_symbol_table_ptr=NULL;\n  if(handle) *handle=NULL;\n  if(functions) *functions=g;\n#else\n  /*\n    On the other hand, for runtime binding, we use dlsym to find the relevant functions.\n  */\n  plumed_plumedmain_function_holder g;\n  /* search is done once and only once */\n  const char* path;\n  void* p;\n  char* debug;\n  int dlopenmode;\n  g.create=NULL;\n  g.cmd=NULL;\n  g.finalize=NULL;\n  path=__PLUMED_GETENV(\"PLUMED_KERNEL\");\n  p=NULL;\n  debug=__PLUMED_GETENV(\"PLUMED_LOAD_DEBUG\");\n  dlopenmode=0;\n  if(plumed_symbol_table_ptr) *plumed_symbol_table_ptr=NULL;\n  if(handle) *handle=NULL;\n#ifdef __PLUMED_DEFAULT_KERNEL\n  /*\n    This variable allows a default path for the kernel to be hardcoded.\n    Can be useful for hardcoding the predefined plumed location\n    still allowing the user to override this choice setting PLUMED_KERNEL.\n    The path should be chosen at compile time adding e.g.\n    -D__PLUMED_DEFAULT_KERNEL=/opt/local/lib/libplumed.dylib\n  */\n  /* This is required to add quotes */\n#define PLUMED_QUOTE_DIRECT(name) #name\n#define PLUMED_QUOTE(macro) PLUMED_QUOTE_DIRECT(macro)\n  if(! (path && (*path) )) path=PLUMED_QUOTE(__PLUMED_DEFAULT_KERNEL);\n#endif\n  if(path && (*path)) {\n    fprintf(stderr,\"+++ Loading the PLUMED kernel runtime +++\\n\");\n    fprintf(stderr,\"+++ PLUMED_KERNEL=\\\"%s\\\" +++\\n\",path);\n    if(debug) __PLUMED_FPRINTF(stderr,\"+++ Loading with mode RTLD_NOW\");\n    dlopenmode=RTLD_NOW;\n    if(__PLUMED_GETENV(\"PLUMED_LOAD_NAMESPACE\") && !__PLUMED_WRAPPER_STD strcmp(__PLUMED_GETENV(\"PLUMED_LOAD_NAMESPACE\"),\"LOCAL\")) {\n      dlopenmode=dlopenmode|RTLD_LOCAL;\n      if(debug) __PLUMED_FPRINTF(stderr,\"|RTLD_LOCAL\");\n    } else {\n      dlopenmode=dlopenmode|RTLD_GLOBAL;\n      if(debug) __PLUMED_FPRINTF(stderr,\"|RTLD_GLOBAL\");\n    }\n#ifdef RTLD_DEEPBIND\n    if(!__PLUMED_GETENV(\"PLUMED_LOAD_NODEEPBIND\")) {\n      dlopenmode=dlopenmode|RTLD_DEEPBIND;\n      if(debug) __PLUMED_FPRINTF(stderr,\"|RTLD_DEEPBIND\");\n    }\n#endif\n    if(debug) __PLUMED_FPRINTF(stderr,\" +++\\n\");\n    p=plumed_attempt_dlopen(path,dlopenmode);\n    if(p) plumed_search_symbols(p,&g,plumed_symbol_table_ptr);\n  }\n  if(handle) *handle=p;\n  if(functions) *functions=g;\n#endif\n}\n__PLUMED_WRAPPER_INTERNALS_END\n\n/**\n  Implementation.\n  Small object used to store pointers directly into the plumed object defined in Plumed.h.\n  This allows avoiding the extra function call to plumed_retrieve_functions at every cmd,\n  at the cost of an extra indirection.\n*/\ntypedef struct {\n  /* allows errors with pointers to be found when debugging */\n  char magic[6];\n  /* reference count */\n  int refcount;\n  /* handler to dlopened library. NULL if there was no library opened */\n  void* dlhandle;\n  /* non zero if, upon destruction, the library should be dlclosed */\n  int dlclose;\n  /* 1 if path to kernel was taken from PLUMED_KERNEL var, 0 otherwise */\n  int used_plumed_kernel;\n  /* function pointers */\n  plumed_plumedmain_function_holder functions;\n  /* pointer to the symbol table. NULL if kernel <=2.4 */\n  plumed_symbol_table_type* table;\n  /* pointer to plumed object */\n  void* p;\n} plumed_implementation;\n\n__PLUMED_WRAPPER_INTERNALS_BEGIN\nplumed_implementation* plumed_malloc_pimpl() {\n  plumed_implementation* pimpl;\n  /* allocate space for implementation object. this is free-ed in plumed_finalize(). */\n  pimpl=(plumed_implementation*) __PLUMED_MALLOC(sizeof(plumed_implementation));\n  if(!pimpl) {\n    __PLUMED_FPRINTF(stderr,\"+++ Allocation error +++\\n\");\n    __PLUMED_WRAPPER_STD abort();\n  }\n  __PLUMED_WRAPPER_STD memcpy(pimpl->magic,\"pLuMEd\",6);\n  pimpl->refcount=1;\n#if __PLUMED_WRAPPER_DEBUG_REFCOUNT\n  fprintf(stderr,\"refcount: new at %p\\n\",(void*)pimpl);\n#endif\n  pimpl->dlhandle=NULL;\n  pimpl->dlclose=0;\n  pimpl->used_plumed_kernel=0;\n  pimpl->functions.create=NULL;\n  pimpl->functions.cmd=NULL;\n  pimpl->functions.finalize=NULL;\n  pimpl->table=NULL;\n  pimpl->p=NULL;\n  return pimpl;\n}\n__PLUMED_WRAPPER_INTERNALS_END\n\n#ifndef NDEBUG\n\n__PLUMED_WRAPPER_INTERNALS_BEGIN\nint plumed_check_pimpl(plumed_implementation*pimpl) {\n  if(!pimpl) return 0;\n  if(__PLUMED_WRAPPER_STD memcmp(pimpl->magic,\"pLuMEd\",6)) return 0;\n  return 1;\n}\n__PLUMED_WRAPPER_INTERNALS_END\n#endif\n\n/* C wrappers: */\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create(void) {\n  /* returned object */\n  plumed p;\n  /* pointer to implementation */\n  plumed_implementation* pimpl;\n  /* allocate space for implementation object. this is free-ed in plumed_finalize(). */\n  pimpl=plumed_malloc_pimpl();\n  /* store pointers in pimpl */\n  plumed_retrieve_functions(&pimpl->functions,&pimpl->table,&pimpl->dlhandle);\n#if __PLUMED_WRAPPER_LINK_RUNTIME\n  /* note if PLUMED_KERNEL variable was used */\n  pimpl->used_plumed_kernel=1;\n#endif\n  /* note if handle should not be dlclosed */\n  pimpl->dlclose=1;\n  if(__PLUMED_GETENV(\"PLUMED_LOAD_DLCLOSE\") && !__PLUMED_WRAPPER_STD strcmp(__PLUMED_GETENV(\"PLUMED_LOAD_DLCLOSE\"),\"no\")) pimpl->dlclose=0;\n  /* in case of failure, return */\n  /* the resulting object should be plumed_finalized, though you cannot use plumed_cmd */\n  if(!pimpl->functions.create) {\n    /* store pimpl in returned object */\n    p.p=pimpl;\n    return p;\n  }\n  assert(pimpl->functions.cmd);\n  assert(pimpl->functions.finalize);\n  /* obtain object */\n  pimpl->p=(*(pimpl->functions.create))();\n  /* notice: we do not assert pimpl->p since in principle it might be nullptr */\n  /* user might identify this using plumed_valid() */\n  /* store pimpl in returned object */\n  p.p=pimpl;\n  return p;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_dlopen(const char*path) {\n  int dlopenmode;\n  /* plumed_create_dlopen always uses RTLD_LOCAL and, when possible, RTLD_DEEPBIND to allow multiple versions */\n#ifdef __PLUMED_HAS_DLOPEN\n  dlopenmode=RTLD_NOW|RTLD_LOCAL;\n#ifdef RTLD_DEEPBIND\n  dlopenmode=dlopenmode|RTLD_DEEPBIND;\n#endif\n#else\n  dlopenmode=0;\n#endif\n  return plumed_create_dlopen2(path,dlopenmode);\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_dlopen2(const char*path,int mode) {\n  /* returned object */\n  plumed p;\n  /* pointer to implementation */\n  plumed_implementation* pimpl;\n  /* allocate space for implementation object. this is free-ed in plumed_finalize(). */\n  pimpl=plumed_malloc_pimpl();\n#ifdef __PLUMED_HAS_DLOPEN\n  if(path) pimpl->dlhandle=plumed_attempt_dlopen(path,mode);\n  /* mark this library to be dlclosed when the object is finalized */\n  pimpl->dlclose=1;\n  if(pimpl->dlhandle) plumed_search_symbols(pimpl->dlhandle,&pimpl->functions,&pimpl->table);\n#endif\n  if(!pimpl->functions.create) {\n    p.p=pimpl;\n    return p;\n  }\n  assert(pimpl->functions.cmd);\n  assert(pimpl->functions.finalize);\n  /* obtain object */\n  pimpl->p=(*(pimpl->functions.create))();\n  /* notice: we do not assert pimpl->p since in principle it might be nullptr */\n  /* user might identify this using plumed_valid() */\n  /* store pimpl in returned object */\n  p.p=pimpl;\n  return p;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_reference(plumed p) {\n  plumed_implementation* pimpl;\n  /* obtain pimpl */\n  pimpl=(plumed_implementation*) p.p;\n  assert(plumed_check_pimpl(pimpl));\n  /* increase reference count */\n  pimpl->refcount++;\n#if __PLUMED_WRAPPER_DEBUG_REFCOUNT\n  fprintf(stderr,\"refcount: increase at %p\\n\",(void*)pimpl);\n#endif\n  return p;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_reference_v(void*v) {\n  return plumed_create_reference(plumed_v2c(v));\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_reference_f(const char*f) {\n  return plumed_create_reference(plumed_f2c(f));\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_invalid() {\n  plumed p;\n  plumed_implementation* pimpl;\n  pimpl=plumed_malloc_pimpl();\n  p.p=pimpl;\n  return p;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid plumed_cmd(plumed p,const char*key,const void*val) {\n  plumed_implementation* pimpl;\n  /* obtain pimpl */\n  pimpl=(plumed_implementation*) p.p;\n  assert(plumed_check_pimpl(pimpl));\n  if(!pimpl->p) {\n    __PLUMED_FPRINTF(stderr,\"+++ ERROR: You are trying to use an invalid plumed object. +++\\n\");\n    if(pimpl->used_plumed_kernel) __PLUMED_FPRINTF(stderr,\"+++ Check your PLUMED_KERNEL environment variable. +++\\n\");\n    __PLUMED_WRAPPER_STD exit(1);\n  }\n  assert(pimpl->functions.create);\n  assert(pimpl->functions.cmd);\n  assert(pimpl->functions.finalize);\n  /* execute */\n  (*(pimpl->functions.cmd))(pimpl->p,key,val);\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid plumed_cmd_nothrow(plumed p,const char*key,const void*val,plumed_nothrow_handler nothrow) {\n  plumed_implementation* pimpl;\n  /* obtain pimpl */\n  pimpl=(plumed_implementation*) p.p;\n  assert(plumed_check_pimpl(pimpl));\n  if(!pimpl->p) {\n    if(pimpl->used_plumed_kernel) {\n      nothrow.handler(nothrow.ptr,1,\"You are trying to use plumed, but it is not available.\\nCheck your PLUMED_KERNEL environment variable.\",NULL);\n    } else {\n      nothrow.handler(nothrow.ptr,1,\"You are trying to use plumed, but it is not available.\",NULL);\n    }\n    return;\n  }\n  assert(pimpl->functions.create);\n  assert(pimpl->functions.cmd);\n  assert(pimpl->functions.finalize);\n  /* execute */\n  if(pimpl->table && pimpl->table->version>1) (*(pimpl->table->cmd_nothrow))(pimpl->p,key,val,nothrow);\n  else (*(pimpl->functions.cmd))(pimpl->p,key,val);\n}\n__PLUMED_WRAPPER_C_END\n\n\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid plumed_finalize(plumed p) {\n  plumed_implementation* pimpl;\n  /* obtain pimpl */\n  pimpl=(plumed_implementation*) p.p;\n  assert(plumed_check_pimpl(pimpl));\n  /* decrease reference count */\n  pimpl->refcount--;\n#if __PLUMED_WRAPPER_DEBUG_REFCOUNT\n  fprintf(stderr,\"refcount: decrease at %p\\n\",(void*)pimpl);\n#endif\n  if(pimpl->refcount>0) return;\n  /* to allow finalizing an invalid plumed object, we only call\n     finalize if the object is valid */\n  if(pimpl->p) {\n    assert(pimpl->functions.create);\n    assert(pimpl->functions.cmd);\n    assert(pimpl->functions.finalize);\n    /* finalize */\n    (*(pimpl->functions.finalize))(pimpl->p);\n  }\n#ifdef __PLUMED_HAS_DLOPEN\n  /* dlclose library */\n  if(pimpl->dlhandle && pimpl->dlclose) {\n    if(__PLUMED_GETENV(\"PLUMED_LOAD_DEBUG\")) fprintf(stderr,\"+++ Unloading library\\n\");\n    dlclose(pimpl->dlhandle);\n  }\n#endif\n#if __PLUMED_WRAPPER_DEBUG_REFCOUNT\n  fprintf(stderr,\"refcount: delete at %p\\n\",(void*)pimpl);\n#endif\n  /* free pimpl space */\n  __PLUMED_FREE(pimpl);\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nint plumed_valid(plumed p) {\n  plumed_implementation* pimpl;\n  /* obtain pimpl */\n  pimpl=(plumed_implementation*) p.p;\n  assert(plumed_check_pimpl(pimpl));\n  if(pimpl->p) return 1;\n  else return 0;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nint plumed_use_count(plumed p) {\n  plumed_implementation* pimpl;\n  /* obtain pimpl */\n  pimpl=(plumed_implementation*) p.p;\n  assert(plumed_check_pimpl(pimpl));\n  return pimpl->refcount;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nint plumed_installed(void) {\n  plumed p;\n  int result;\n  p=plumed_create();\n  result=plumed_valid(p);\n  plumed_finalize(p);\n  return result;\n}\n__PLUMED_WRAPPER_C_END\n\n#if __PLUMED_WRAPPER_GLOBAL /*{*/\n\n__PLUMED_WRAPPER_EXTERN_C_BEGIN\n\n/* we declare a Plumed_g_main object here, in such a way that it is always available */\n\nstatic plumed plumed_gmain= {NULL};\n\nplumed plumed_global(void) {\n  return plumed_gmain;\n}\n\nvoid plumed_gcreate(void) {\n  /* should be created once */\n  assert(plumed_gmain.p==NULL);\n  plumed_gmain=plumed_create();\n}\n\nvoid plumed_gcmd(const char*key,const void*val) {\n  plumed_cmd(plumed_gmain,key,val);\n}\n\nvoid plumed_gfinalize(void) {\n  plumed_finalize(plumed_gmain);\n  plumed_gmain.p=NULL;\n}\n\nint plumed_ginitialized(void) {\n  if(plumed_gmain.p) return 1;\n  else        return 0;\n}\n\nint plumed_gvalid() {\n  assert(plumed_gmain.p);\n  return plumed_valid(plumed_gmain);\n}\n\n__PLUMED_WRAPPER_EXTERN_C_END\n\n#endif /*}*/\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid plumed_c2f(plumed p,char*c) {\n  unsigned i;\n  unsigned char* cc;\n  /*\n    Convert the address stored in p.p into a proper FORTRAN string\n    made of only ASCII characters. For this to work, the two following\n    assertions should be satisfied:\n  */\n  assert(CHAR_BIT<=12);\n  assert(sizeof(p.p)<=16);\n\n  assert(c);\n  cc=(unsigned char*)&p.p;\n  for(i=0; i<sizeof(p.p); i++) {\n    /*\n      characters will range between '0' (ASCII 48) and 'o' (ASCII 111=48+63)\n    */\n    c[2*i]=cc[i]/64+48;\n    c[2*i+1]=cc[i]%64+48;\n  }\n  for(; i<16; i++) {\n    c[2*i]=' ';\n    c[2*i+1]=' ';\n  }\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_f2c(const char*c) {\n  plumed p;\n  unsigned i;\n  unsigned char* cc;\n\n  assert(CHAR_BIT<=12);\n  assert(sizeof(p.p)<=16);\n\n  assert(c);\n\n  /*\n     needed to avoid cppcheck warning on uninitialized p\n  */\n  p.p=NULL;\n  cc=(unsigned char*)&p.p;\n  for(i=0; i<sizeof(p.p); i++) {\n    assert(c[2*i]>=48 && c[2*i]<48+64);\n    assert(c[2*i+1]>=48 && c[2*i+1]<48+64);\n    /*\n      perform the reversed transform\n    */\n    cc[i]=(c[2*i]-48)*64 + (c[2*i+1]-48);\n  }\n  for(; i<16; i++) {\n    assert(c[2*i]==' ');\n    assert(c[2*i+1]==' ');\n  }\n  return p;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid* plumed_c2v(plumed p) {\n  assert(plumed_check_pimpl((plumed_implementation*)p.p));\n  return p.p;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_v2c(void* v) {\n  assert(plumed_check_pimpl((plumed_implementation*)v));\n  plumed p;\n  p.p=v;\n  return p;\n}\n__PLUMED_WRAPPER_C_END\n\n#if __PLUMED_WRAPPER_FORTRAN /*{*/\n\n/*\n  Fortran wrappers\n  These are just like the global C wrappers. They are\n  just defined here and not declared since they\n  should not be used from c/c++ anyway.\n\n  We use a macro that does the following:\n  - declare a static function named NAME_static\n  - declare a number of functions named NAME_ etc, with all possible\n    fortran mangling schemes (zero, one, or two underscores, lower and upper case)\n  - define the NAME_static function.\n\n  The static function is used basically as an inline function in a C-compatible manner.\n*/\n\n#define __PLUMED_IMPLEMENT_FORTRAN(lower,upper,arg1,arg2) \\\n  static void lower ## _static arg1; \\\n  extern void lower      arg1 {lower ## _static arg2;} \\\n  extern void lower ##_  arg1 {lower ## _static arg2;} \\\n  extern void lower ##__ arg1 {lower ## _static arg2;} \\\n  extern void upper      arg1 {lower ## _static arg2;} \\\n  extern void upper ##_  arg1 {lower ## _static arg2;} \\\n  extern void upper ##__ arg1 {lower ## _static arg2;} \\\n  static void lower ## _static arg1\n\n/* FORTRAN wrappers would only make sense as extern \"C\" */\n\n__PLUMED_WRAPPER_EXTERN_C_BEGIN\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_create,PLUMED_F_CREATE,(char*c),(c)) {\n  plumed_c2f(plumed_create(),c);\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_create_dlopen,PLUMED_F_CREATE_DLOPEN,(char*path,char*c),(path,c)) {\n  plumed_c2f(plumed_create_dlopen(path),c);\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_create_reference,PLUMED_F_CREATE_REFERENCE,(char* r,char*c),(r,c)) {\n  plumed_c2f(plumed_create_reference_f(r),c);\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_create_invalid,PLUMED_F_CREATE_INVALID,(char* c),(c)) {\n  plumed_c2f(plumed_create_invalid(),c);\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_cmd,PLUMED_F_CMD,(char*c,char*key,void*val),(c,key,val)) {\n  plumed_cmd(plumed_f2c(c),key,val);\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_finalize,PLUMED_F_FINALIZE,(char*c),(c)) {\n  plumed_finalize(plumed_f2c(c));\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_installed,PLUMED_F_INSTALLED,(int*i),(i)) {\n  assert(i);\n  *i=plumed_installed();\n}\n\n/* New in PLUMED 2.5 */\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_valid,PLUMED_F_VALID,(char*c,int*i),(c,i)) {\n  assert(i);\n  *i=plumed_valid(plumed_f2c(c));\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_use_count,PLUMED_F_USE_COUNT,(char*c,int*i),(c,i)) {\n  assert(i);\n  *i=plumed_use_count(plumed_f2c(c));\n}\n\n#if __PLUMED_WRAPPER_GLOBAL /*{*/\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_global,PLUMED_F_GLOBAL,(char*c),(c)) {\n  plumed_c2f(plumed_gmain,c);\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_ginitialized,PLUMED_F_GINITIALIZED,(int*i),(i)) {\n  assert(i);\n  *i=plumed_ginitialized();\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_gcreate,PLUMED_F_GCREATE,(void),()) {\n  plumed_gcreate();\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_gcmd,PLUMED_F_GCMD,(char*key,void*val),(key,val)) {\n  plumed_gcmd(key,val);\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_gfinalize,PLUMED_F_GFINALIZE,(void),()) {\n  plumed_gfinalize();\n}\n\n/* New in PLUMED 2.5 */\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_gvalid,PLUMED_F_GVALID,(int*i),(i)) {\n  assert(i);\n  *i=plumed_gvalid();\n}\n\n#endif /*}*/\n\n__PLUMED_WRAPPER_EXTERN_C_END\n\n#endif /*}*/\n\n#endif /*}*/\n\n#endif /*}*/\n\n/* END OF DEFINITIONS */\n\n/* reset variable to allow it to be redefined upon re-inclusion */\n\n#undef __PLUMED_WRAPPER_IMPLEMENTATION_\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/src/molfile/vmdplugin.h": "/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\nUniversity of Illinois Open Source License\nCopyright 2003 Theoretical and Computational Biophysics Group, \nAll rights reserved.\n\nDeveloped by:\t\tTheoretical and Computational Biophysics Group\n\t\t\tUniversity of Illinois at Urbana-Champaign\n\t\t\thttp://www.ks.uiuc.edu/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the Software), to deal with \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to \ndo so, subject to the following conditions:\n\nRedistributions of source code must retain the above copyright notice, \nthis list of conditions and the following disclaimers.\n\nRedistributions in binary form must reproduce the above copyright notice, \nthis list of conditions and the following disclaimers in the documentation \nand/or other materials provided with the distribution.\n\nNeither the names of Theoretical and Computational Biophysics Group, \nUniversity of Illinois at Urbana-Champaign, nor the names of its contributors \nmay be used to endorse or promote products derived from this Software without \nspecific prior written permission.\n\nTHE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL \nTHE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR \nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, \nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR \nOTHER DEALINGS WITH THE SOFTWARE.\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#ifndef __PLUMED_molfile_vmdplugin_h\n#define __PLUMED_molfile_vmdplugin_h\nnamespace PLMD{\nnamespace molfile{\n/***************************************************************************\n *cr\n *cr            (C) Copyright 1995-2006 The Board of Trustees of the\n *cr                        University of Illinois\n *cr                         All Rights Reserved\n *cr\n ***************************************************************************/\n\n/***************************************************************************\n * RCS INFORMATION:\n *\n *      $RCSfile: vmdplugin.h,v $\n *      $Author: johns $       $Locker:  $             $State: Exp $\n *      $Revision: 1.33 $       $Date: 2015/10/29 05:10:54 $\n *\n ***************************************************************************/\n\n/** @file\n * This header must be included by every VMD plugin library.  It defines the\n * API for every plugin so that VMD can organize the plugins it finds.  \n */\n\n#ifndef VMD_PLUGIN_H\n#define VMD_PLUGIN_H\n\n\n/* \n * Preprocessor tricks to make it easier for us to redefine the names of\n * functions when building static plugins.\n */\n#if !defined(VMDPLUGIN)\n/** \n  * macro defining VMDPLUGIN if it hasn't already been set to the name of \n  * a static plugin that is being compiled.  This is the catch-all case.\n  */\n#define VMDPLUGIN vmdplugin\n#endif\n/** concatenation macro, joins args x and y together as a single string */\n#define xcat(x, y) cat(x, y)\n/** concatenation macro, joins args x and y together as a single string */\n#define cat(x, y) x ## y \n\n/*\n *  macros to correctly define plugin function names depending on whether \n *  the plugin is being compiled for static linkage or dynamic loading. \n *  When compiled for static linkage, each plugin needs to have unique\n *  function names for all of its entry points.  When compiled for dynamic\n *  loading, the plugins must name their entry points consistently so that\n *  the plugin loading mechanism can find the register, register_tcl, init,\n *  and fini routines via dlopen() or similar operating system interfaces.\n */\n/*@{*/\n/** Macro names entry points correctly for static linkage or dynamic loading */\n#define VMDPLUGIN_register     xcat(VMDPLUGIN, _register)\n#define VMDPLUGIN_register_tcl xcat(VMDPLUGIN, _register_tcl)\n#define VMDPLUGIN_init         xcat(VMDPLUGIN, _init)\n#define VMDPLUGIN_fini         xcat(VMDPLUGIN, _fini)\n/*@}*/\n\n\n/** \"WIN32\" is defined on both WIN32 and WIN64 platforms... */\n#if (defined(WIN32)) \n#define WIN32_LEAN_AND_MEAN\n}\n}\n#include <windows.h>\nnamespace PLMD{\nnamespace molfile{\n\n\n#if !defined(STATIC_PLUGIN)\n#if defined(VMDPLUGIN_EXPORTS)\n/** \n *  Only define DllMain for plugins, not in VMD or in statically linked plugins\n *  VMDPLUGIN_EXPORTS is only defined when compiling dynamically loaded plugins\n */\nBOOL APIENTRY DllMain( HANDLE hModule,\n                       DWORD ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n{\n  return TRUE;\n}\n\n#define VMDPLUGIN_API __declspec(dllexport)\n#else\n#define VMDPLUGIN_API __declspec(dllimport)\n#endif /* VMDPLUGIN_EXPORTS */\n#else  /* ! STATIC_PLUGIN */\n#define VMDPLUGIN_API\n#endif /* ! STATIC_PLUGIN */\n#else\n/** If we're not compiling on Windows, then this macro is defined empty */\n#define VMDPLUGIN_API \n#endif\n\n//TONI  Plumed mod: never \"extern\", C++ namespace\n/** define plugin linkage correctly for both C and C++ based plugins */\n#define VMDPLUGIN_EXTERN VMDPLUGIN_API\n\n/* \n * Plugin API functions start here \n */\n\n\n/** \n * Init routine: called the first time the library is loaded by the \n * application and before any other API functions are referenced.\n * Return 0 on success.\n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_init(void);\n\n/**\n * Macro for creating a struct header used in all plugin structures.\n * \n * This header should be placed at the top of every plugin API definition \n * so that it can be treated as a subtype of the base plugin type.\n *\n * abiversion: Defines the ABI for the base plugin type (not for other plugins)\n * type: A string descriptor of the plugin type.\n * name: A name for the plugin.\n * author: A string identifier, possibly including newlines.\n * Major and minor version.  \n * is_reentrant: Whether this library can be run concurrently with itself.\n */\n#define vmdplugin_HEAD \\\n  int abiversion; \\\n  const char *type; \\\n  const char *name; \\\n  const char *prettyname; \\\n  const char *author; \\\n  int majorv; \\\n  int minorv; \\\n  int is_reentrant; \n\n/** \n  * Typedef for generic plugin header, individual plugins can\n  * make their own structures as long as the header info remains \n  * the same as the generic plugin header, most easily done by \n  * using the vmdplugin_HEAD macro.\n  */\ntypedef struct {\n  vmdplugin_HEAD\n} vmdplugin_t;\n\n/**\n * Use this macro to initialize the abiversion member of each plugin\n */\n#define vmdplugin_ABIVERSION  17\n\n/*@{*/\n/** Use this macro to indicate a plugin's thread-safety at registration time */\n#define VMDPLUGIN_THREADUNSAFE 0\n#define VMDPLUGIN_THREADSAFE   1\n/*@}*/\n\n/*@{*/\n/** Error return code for use in the plugin registration and init functions */\n#define VMDPLUGIN_SUCCESS      0\n#define VMDPLUGIN_ERROR       -1\n/*@}*/\n\n/** \n * Function pointer typedef for register callback functions\n */\ntypedef int (*vmdplugin_register_cb)(void *, vmdplugin_t *);\n\n/**\n * Allow the library to register plugins with the application.\n * The callback should be called using the passed-in void pointer, which\n * should not be interpreted in any way by the library.  Each vmdplugin_t\n * pointer passed to the application should point to statically-allocated\n * or heap-allocated memory and should never be later modified by the plugin.\n * Applications must be permitted to retain only a copy of the the plugin\n * pointer, without making any deep copy of the items in the struct.\n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_register(void *, vmdplugin_register_cb);\n\n/**\n * Allow the library to register Tcl extensions.  \n * This API is optional; if found by dlopen, it will be called after first\n * calling init and register.  \n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_register_tcl(void *, void *tcl_interp, \n    vmdplugin_register_cb);\n\n/**\n * The Fini method is called when the application will no longer use \n * any plugins in the library.  \n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_fini(void);\n\n#endif   /* VMD_PLUGIN_H */\n}\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/src/generic/Plumed.cpp": "/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n   Copyright (c) 2018-2020 The plumed team\n   (see the PEOPLE file at the root of the distribution for a list of names)\n\n   See http://www.plumed.org for more information.\n\n   This file is part of plumed, version 2.\n\n   plumed is free software: you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   plumed is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#include \"core/ActionAtomistic.h\"\n#include \"core/ActionWithValue.h\"\n#include \"core/ActionPilot.h\"\n#include \"core/ActionRegister.h\"\n#include \"tools/Tools.h\"\n#include \"tools/PlumedHandle.h\"\n#include \"core/PlumedMain.h\"\n#include <cstring>\n#ifdef __PLUMED_HAS_DLOPEN\n#include <dlfcn.h>\n#endif\n\n#include <iostream>\n\nusing namespace std;\n\nnamespace PLMD {\nnamespace generic {\n\n//+PLUMEDOC GENERIC PLUMED\n/*\nEmbed a separate PLUMED instance.\n\nThis command can be used to embed a separate PLUMED instance.\nOnly required atoms will be passed to that instance, using an interface\nthat is similar to the one used when calling PLUMED from the NAMD engine.\n\nNotice that the two instances are running in the same UNIX process, so that they cannot be perfectly isolated.\nHowever, most of the features are expected to work correctly.\n\nNotes:\n- The \\ref LOAD action will not work correctly since registers will be shared among the two instances.\n  In particular, the loaded actions will be visible to both guest and host irrespective of where they are loaded from.\n  This can be fixed and will probably be fixed in a later version.\n- `CHDIR` is not thread safe.\n   However, in most implementations there will be a single process running PLUMED, with perhaps multiple OpenMP threads\n   spawn in order to parallelize the calculation of individual variables. So, this is likely not a problem.\n- MPI is working correctly. However, notice that the guest PLUMED will always run with a single process.\n  Multiple replicas should be handled correctly.\n\nAs an advanced feature, one can use the option `KERNEL` to select the version of the guest PLUMED instance.\nIn particular, an empty `KERNEL` (default) implies that the guest PLUMED instance is the same as the host one\n(no library is loaded).\nOn the other hand, `KERNEL=/path/to/libplumedKernel.so` will allow specifying a library to be loaded for the\nguest instance.\nIn addition to those mentioned above, this feature has limitations mostly related to\nclashes in the symbols defined in the different instances of the PLUMED library:\n- On OSX, if you load a KERNEL with version >=2.5 there should be no problem thanks to the use\n  of two-level namespaces.\n- On OSX, if you load a KERNEL with version <=2.4 there should be clashes in symbol resolution.\n  The only possible workarounds are:\n  - If you are are using PLUMED with an MD code, it should be patched with `--runtime` and you should\n    `export PLUMED_LOAD_NAMESPACE=LOCAL` before starting the MD engine.\n  - If you are using PLUMED driver, you should launch the `plumed-runtime` executable (contained in the\n    `prefix/lib/plumed/` directory), export `PLUMED_KERNEL` equal to the path of the host kernel library\n   (as usual in runtime loading) and `export PLUMED_LOAD_NAMESPACE=LOCAL` before launching `plumed-runtime driver`.\n- On Linux, any `KERNEL` should in principle work correctly. To achieve namespace separation we are loading\n  the guest kernel with `RTLD_DEEPBIND`. However, this might create difficult to track problems in other linked libraries.\n- On Unix systems where `RTLD_DEEPBIND` is not available kernels will not load correctly.\n- In general, there might be unexpected crashes. Particularly difficult are situations where different\n  kernels were compiled with different libraries.\n\nA possible solution for the symbol clashes (not tested) could be to recompile the alternative PLUMED\nversions using separate C++ namespaces (e.g. `./configure CPPFLAGS=-DPLMD=PLMD_2_3`).\n\n\\todo\n- Add support for multiple time stepping (`STRIDE` different from 1).\n- Add the possibility to import CVs calculated in the host PLUMED instance into the guest PLUMED instance.\n  Will be possible after \\issue{83} will be closed.\n- Add the possibility to export CVs calculated in the guest PLUMED instance into the host PLUMED instance.\n  Could be implemented using the `DataFetchingObject` class.\n\n\\par Examples\n\nHere an example plumed file:\n\\plumedfile\n# plumed.dat\np: PLUMED FILE=plumed2.dat\nPRINT ARG=p.bias FILE=COLVAR\n\\endplumedfile\n`plumed2.dat` can be an arbitrary plumed input file, for instance\n\\plumedfile\n# plumed2.dat\nd: DISTANCE ATOMS=1,10\nRESTRAINT ARG=d KAPPA=10 AT=2\n\\endplumedfile\n\nNow a more useful example.\nImagine that you ran simulations using two different PLUMED input files.\nThe files are long and complex and there are some clashes in the name of the variables (that is: same names\nare used in both files, same files are written, etc). In addition, files might have been written using different units (see \\ref UNITS`).\nIf you want to run a single simulation with a bias potential\nthat is the sum of the two bias potentials, you can:\n- Place the two input files, as well as all the files required by plumed, in separate directories `directory1` and `directory2`.\n- Run with the following input file in the parent directory:\n\\plumedfile\n# plumed.dat\nPLUMED FILE=plumed.dat CHDIR=directory1\nPLUMED FILE=plumed.dat CHDIR=directory2\n\\endplumedfile\n\n*/\n//+ENDPLUMEDOC\n\nclass Plumed:\n  public ActionAtomistic,\n  public ActionWithValue,\n  public ActionPilot\n{\n/// True on root processor\n  const bool root;\n/// Separate directory.\n  const std::string directory;\n/// Interface to underlying plumed object.\n  PlumedHandle p;\n/// API number.\n  const int API;\n/// Self communicator\n  Communicator comm_self;\n/// Intercommunicator\n  Communicator intercomm;\n/// Detect first usage.\n  bool first=true;\n/// Stop flag, used to stop e.g. in committor analysis\n  int stop=0;\n/// Index of requested atoms.\n  std::vector<int> index;\n/// Masses of requested atoms.\n  std::vector<double> masses;\n/// Charges of requested atoms.\n  std::vector<double> charges;\n/// Forces on requested atoms.\n  std::vector<double> forces;\n/// Requested positions.\n  std::vector<double> positions;\n/// Applied virial.\n  Tensor virial;\npublic:\n/// Constructor.\n  explicit Plumed(const ActionOptions&);\n/// Documentation.\n  static void registerKeywords( Keywords& keys );\n  void prepare() override;\n  void calculate() override;\n  void apply() override;\n  void update() override;\n  unsigned getNumberOfDerivatives() override {\n    return 0;\n  }\n};\n\nPLUMED_REGISTER_ACTION(Plumed,\"PLUMED\")\n\nvoid Plumed::registerKeywords( Keywords& keys ) {\n  Action::registerKeywords( keys );\n  ActionPilot::registerKeywords( keys );\n  ActionAtomistic::registerKeywords( keys );\n  keys.add(\"compulsory\",\"STRIDE\",\"1\",\"stride different from 1 are not supported yet\");\n  keys.add(\"optional\",\"FILE\",\"input file for the guest PLUMED instance\");\n  keys.add(\"optional\",\"KERNEL\",\"kernel to be used for the guest PLUMED instance (USE WITH CAUTION!)\");\n  keys.add(\"optional\",\"LOG\",\"log file for the guest PLUMED instance. By default the host log is used\");\n  keys.add(\"optional\",\"CHDIR\",\"run guest in a separate directory\");\n  keys.addFlag(\"NOREPLICAS\",false,\"run multiple replicas as isolated ones, without letting them know that the host has multiple replicas\");\n  keys.addOutputComponent(\"bias\",\"default\",\"the instantaneous value of the bias potential\");\n}\n\nPlumed::Plumed(const ActionOptions&ao):\n  Action(ao),\n  ActionAtomistic(ao),\n  ActionWithValue(ao),\n  ActionPilot(ao),\n  root(comm.Get_rank()==0),\n  directory([&]() {\n  std::string directory;\n  parse(\"CHDIR\",directory);\n  if(directory.length()>0) {\n    log<<\"  running on separate directory \"<<directory<<\"\\n\";\n  }\n  return directory;\n}()),\np([&]() {\n  std::string kernel;\n  parse(\"KERNEL\",kernel);\n  if(kernel.length()==0) {\n    log<<\"  using the current kernel\\n\";\n    return PlumedHandle();\n  } else {\n    log<<\"  using the kernel \"<<kernel<<\"\\n\";\n    return PlumedHandle::dlopen(kernel.c_str());\n  }\n}()),\nAPI([&]() {\n  int api=0;\n  p.cmd(\"getApiVersion\",&api);\n  log<<\"  reported API version is \"<<api<<\"\\n\";\n  // note: this is required in order to have cmd performCalcNoUpdate and cmd update\n  // as a matter of fact, any version <2.5 will not even load due to namespace pollution\n  plumed_assert(api>3) << \"API>3 is required for the PLUMED action to work correctly\\n\";\n  return api;\n}())\n{\n  Tools::DirectoryChanger directoryChanger(directory.c_str());\n\n  bool noreplicas;\n  parseFlag(\"NOREPLICAS\",noreplicas);\n  int nreps;\n  if(root) nreps=multi_sim_comm.Get_size();\n  comm.Bcast(nreps,0);\n  if(nreps>1) {\n    if(noreplicas) {\n      log<<\"  running replicas as independent (no suffix used)\\n\";\n    } else {\n      log<<\"  running replicas as standard multi replic (with suffix)\\n\";\n      if(root) {\n        intercomm.Set_comm(&multi_sim_comm.Get_comm());\n        p.cmd(\"GREX setMPIIntercomm\",&intercomm.Get_comm());\n        p.cmd(\"GREX setMPIIntracomm\",&comm_self.Get_comm());\n        p.cmd(\"GREX init\");\n      }\n    }\n  } else {\n    if(noreplicas) {\n      log<<\"  WARNING: flag NOREPLICAS ignored since we are running without replicas\\n\";\n    }\n  }\n\n  int natoms=plumed.getAtoms().getNatoms();\n\n  plumed_assert(getStride()==1) << \"currently only supports STRIDE=1\";\n\n  double dt=getTimeStep();\n\n  std::string file;\n  parse(\"FILE\",file);\n  if(file.length()>0) {\n    log<<\"  with input file \"<<file<<\"\\n\";\n  } else plumed_error() << \"you must provide an input file\\n\";\n\n  bool inherited_logfile=false;\n  std::string logfile;\n  parse(\"LOG\",logfile);\n  if(logfile.length()>0) {\n    log<<\"  with log file \"<<logfile<<\"\\n\";\n    if(root) p.cmd(\"setLogFile\",logfile.c_str());\n  } else if(log.getFILE()) {\n    log<<\"  with inherited log file\\n\";\n    if(root) p.cmd(\"setLog\",log.getFILE());\n    inherited_logfile=true;\n  } else {\n    log<<\"  with log on stdout\\n\";\n    if(root) p.cmd(\"setLog\",stdout);\n  }\n\n  checkRead();\n\n  if(root) p.cmd(\"setMDEngine\",\"plumed\");\n\n  double engunits=plumed.getAtoms().getUnits().getEnergy();\n  if(root) p.cmd(\"setMDEnergyUnits\",&engunits);\n\n  double lenunits=plumed.getAtoms().getUnits().getLength();\n  if(root) p.cmd(\"setMDLengthUnits\",&lenunits);\n\n  double timunits=plumed.getAtoms().getUnits().getTime();\n  if(root) p.cmd(\"setMDTimeUnits\",&timunits);\n\n  double chaunits=plumed.getAtoms().getUnits().getCharge();\n  if(root) p.cmd(\"setMDChargeUnits\",&chaunits);\n  double masunits=plumed.getAtoms().getUnits().getMass();\n  if(root) p.cmd(\"setMDMassUnits\",&masunits);\n\n  double kbt=plumed.getAtoms().getKbT();\n  if(root) p.cmd(\"setKbT\",&kbt);\n\n  int res=0;\n  if(getRestart()) res=1;\n  if(root) p.cmd(\"setRestart\",&res);\n\n  if(root) p.cmd(\"setNatoms\",&natoms);\n  if(root) p.cmd(\"setTimestep\",&dt);\n  if(root) p.cmd(\"setPlumedDat\",file.c_str());\n\n  addComponentWithDerivatives(\"bias\");\n  componentIsNotPeriodic(\"bias\");\n\n  if(inherited_logfile) log<<\"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";\n  if(root) p.cmd(\"init\");\n  if(inherited_logfile) log<<\"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\";\n}\n\nvoid Plumed::prepare() {\n  Tools::DirectoryChanger directoryChanger(directory.c_str());\n  int step=getStep();\n  if(root) p.cmd(\"setStep\",&step);\n  if(root) p.cmd(\"prepareDependencies\");\n  int ene=0;\n  if(root) p.cmd(\"isEnergyNeeded\",&ene);\n  if(ene) plumed_error()<<\"It is not currently possible to use ENERGY in a guest PLUMED\";\n  int n=0;\n  if(root) p.cmd(\"createFullList\",&n);\n  int *pointer=nullptr;\n  if(root) p.cmd(\"getFullList\",&pointer);\n  bool redo=(index.size()!=n);\n  if(first) redo=true;\n  first=false;\n  if(root && !redo) for(int i=0; i<n; i++) if(index[i]!=pointer[i]) { redo=true; break;};\n  if(root && redo) {\n    index.resize(n);\n    masses.resize(n);\n    forces.resize(3*n);\n    positions.resize(3*n);\n    charges.resize(n);\n    for(int i=0; i<n; i++) {\n      index[i]=pointer[i];\n    };\n    p.cmd(\"setAtomsNlocal\",&n);\n    p.cmd(\"setAtomsGatindex\",index.data());\n  }\n  if(root) p.cmd(\"clearFullList\");\n  int tmp=0;\n  if(root && redo) {\n    tmp=1;\n  }\n  comm.Bcast(tmp,0);\n  if(tmp) {\n    int s=index.size();\n    comm.Bcast(s,0);\n    if(!root) index.resize(s);\n    comm.Bcast(index,0);\n    std::vector<AtomNumber> numbers;\n    numbers.reserve(index.size());\n    for(auto i : index) numbers.emplace_back(AtomNumber::index(i));\n    requestAtoms(numbers);\n  }\n}\n\nvoid Plumed::calculate() {\n  Tools::DirectoryChanger directoryChanger(directory.c_str());\n  if(root) p.cmd(\"setStopFlag\",&stop);\n  Tensor box=getPbc().getBox();\n  if(root) p.cmd(\"setBox\",&box[0][0]);\n\n  virial.zero();\n  for(int i=0; i<forces.size(); i++) forces[i]=0.0;\n  for(int i=0; i<masses.size(); i++) masses[i]=getMass(i);\n  for(int i=0; i<charges.size(); i++) charges[i]=getCharge(i);\n\n  if(root) p.cmd(\"setMasses\",masses.data());\n  if(root) p.cmd(\"setCharges\",charges.data());\n  if(root) p.cmd(\"setPositions\",positions.data());\n  if(root) p.cmd(\"setForces\",forces.data());\n  if(root) p.cmd(\"setVirial\",&virial[0][0]);\n\n\n  if(root) for(unsigned i=0; i<getNumberOfAtoms(); i++) {\n      positions[3*i+0]=getPosition(i)[0];\n      positions[3*i+1]=getPosition(i)[1];\n      positions[3*i+2]=getPosition(i)[2];\n    }\n\n  if(root) p.cmd(\"shareData\");\n  if(root) p.cmd(\"performCalcNoUpdate\");\n\n  int s=forces.size();\n  comm.Bcast(s,0);\n  if(!root) forces.resize(s);\n  comm.Bcast(forces,0);\n  comm.Bcast(virial,0);\n\n  double bias=0.0;\n  if(root) p.cmd(\"getBias\",&bias);\n  comm.Bcast(bias,0);\n  getPntrToComponent(\"bias\")->set(bias);\n}\n\nvoid Plumed::apply() {\n  Tools::DirectoryChanger directoryChanger(directory.c_str());\n  auto & f(modifyForces());\n  for(unsigned i=0; i<getNumberOfAtoms(); i++) {\n    f[i][0]+=forces[3*i+0];\n    f[i][1]+=forces[3*i+1];\n    f[i][2]+=forces[3*i+2];\n  }\n  auto & v(modifyVirial());\n  v+=virial;\n}\n\nvoid Plumed::update() {\n  Tools::DirectoryChanger directoryChanger(directory.c_str());\n  if(root) p.cmd(\"update\");\n  comm.Bcast(stop,0);\n  if(stop) {\n    log<<\"  Action \" << getLabel()<<\" asked to stop\\n\";\n    plumed.stop();\n  }\n}\n\n}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/src/core/PlumedMainInitializer.h": "/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n   Copyright (c) 2018-2020 The plumed team\n   (see the PEOPLE file at the root of the distribution for a list of names)\n\n   See http://www.plumed.org for more information.\n\n   This file is part of plumed, version 2.\n\n   plumed is free software: you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   plumed is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#ifndef __PLUMED_core_PlumedMainInitializer_h\n#define __PLUMED_core_PlumedMainInitializer_h\n// !!!!!!!!!!!!!!!!!!!!!!    DANGER   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11\n// THE FOLLOWING ARE DEFINITIONS WHICH ARE NECESSARY FOR DYNAMIC LOADING OF THE PLUMED KERNEL:\n// This section should be consistent with the Plumed.h file.\n// Since the Plumed.h file may be included in host MD codes, **NEVER** MODIFY THE CODE IN THIS FILE\n// unless you know exactly what you are doing\n\n/**\n  Container for plumedmain function pointers (create, cmd and finalize).\n*/\ntypedef struct {\n  void*(*create)();\n  void(*cmd)(void*,const char*,const void*);\n  void(*finalize)(void*);\n} plumed_plumedmain_function_holder;\n\ntypedef struct {\n  void* ptr;\n  void (*handler)(void*,int,const char*,const void*);\n} plumed_nothrow_handler;\n\n/**\n  Container for symbol table. Presently only contains a version number and a plumed_plumedmain_function_holder object.\n  The definition of this structure might change in the future. In particular, the structure might grow adding\n  new fields. However, in that case the version number should be updated as well.\n*/\ntypedef struct {\n  int version;\n  plumed_plumedmain_function_holder functions;\n  void (*cmd_nothrow)(void*plumed,const char*key,const void*val,plumed_nothrow_handler nothrow);\n} plumed_symbol_table_type;\n\n\n// additional definitions\ntypedef void*(*plumed_create_pointer)(void);\ntypedef void(*plumed_cmd_pointer)(void*,const char*,const void*);\ntypedef void(*plumed_finalize_pointer)(void*);\n\n/* These functions should be accessible from C, since they might be statically\n   used from Plumed.c (for static binding) */\n\n/**\n  Constructs a plumed object.\n  This function returns a void pointer that can be used in \\ref plumed_plumedmain_cmd and \\ref plumed_plumedmain_finalize.\n*/\nextern \"C\" void*plumed_plumedmain_create();\n\n/**\n  Send a command `key` and a pointer `val` to a void pointer returned by \\ref plumed_plumedmain_create.\n*/\nextern \"C\" void plumed_plumedmain_cmd(void*plumed,const char*key,const void*val);\n\n/**\n  Finalize a void pointer returned by \\ref plumed_plumedmain_create\n*/\nextern \"C\" void plumed_plumedmain_finalize(void*plumed);\n\n/**\n  Static symbol table that is accessed by the plumed loader.\n  Notice that this table is initialized with a static object construction.\n  In principle, it should be accessed by other programs dlopening the plumed kernel.\n  In that case, it is guaranteed to be already initialized.\n  However, when accessed directly it might be safer to first call \\ref plumed_symbol_table_init.\n*/\n\nextern \"C\" plumed_symbol_table_type plumed_symbol_table;\n\n/**\n  Function that makes sure that \\ref plumed_symbol_table is initialized.\n  Can be called multiple times.\n*/\nextern \"C\" void plumed_symbol_table_init();\n\nnamespace PLMD {\n// This is just to avoid plumedcheck warnings.\n// Notice that the only define C-style objects here, so namespace is not needed\n}\n\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/src/core/CLToolMain.cpp": "/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n   Copyright (c) 2012-2020 The plumed team\n   (see the PEOPLE file at the root of the distribution for a list of names)\n\n   See http://www.plumed.org for more information.\n\n   This file is part of plumed, version 2.\n\n   plumed is free software: you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   plumed is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#include \"CLToolMain.h\"\n#include \"config/Config.h\"\n#include \"tools/Exception.h\"\n#include \"tools/Communicator.h\"\n#include \"CLTool.h\"\n#include \"CLToolRegister.h\"\n#include \"tools/Tools.h\"\n#include \"tools/DLLoader.h\"\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <memory>\n#include <unordered_map>\n\nusing namespace std;\n\nnamespace PLMD {\n\nCLToolMain::CLToolMain():\n  argc(0),\n  in(stdin),\n  out(stdout)\n{\n}\n\nCLToolMain::~CLToolMain() {\n// empty destructor to delete unique_ptr\n}\n\n#define CHECK_NULL(val,word) plumed_massert(val,\"NULL pointer received in cmd(\\\"CLTool \" + word + \"\\\")\");\n\nvoid CLToolMain::cmd(const std::string& word,void*val) {\n\n// Enumerate all possible commands:\n  enum {\n#include \"CLToolMainEnum.inc\"\n  };\n\n// Static object (initialized once) containing the map of commands:\n  const static std::unordered_map<std::string, int> word_map = {\n#include \"CLToolMainMap.inc\"\n  };\n\n  std::vector<std::string> words=Tools::getWords(word);\n  unsigned nw=words.size();\n  if(nw==0) {\n    // do nothing\n  } else {\n    int iword=-1;\n    char**v;\n    char*vv;\n    const auto it=word_map.find(words[0]);\n    if(it!=word_map.end()) iword=it->second;\n    switch(iword) {\n    case cmd_setArgc:\n      CHECK_NULL(val,word);\n      argc=*static_cast<int*>(val);\n      break;\n    case cmd_setArgv:\n      CHECK_NULL(val,word);\n      v=static_cast<char**>(val);\n      for(int i=0; i<argc; ++i) argv.push_back(string(v[i]));\n      break;\n    case cmd_setArgvLine:\n      CHECK_NULL(val,word);\n      vv=static_cast<char*>(val);\n      argv=Tools::getWords(vv);\n      break;\n    case cmd_setIn:\n      CHECK_NULL(val,word);\n      in=static_cast<FILE*>(val);\n      break;\n    case cmd_setOut:\n      CHECK_NULL(val,word);\n      out=static_cast<FILE*>(val);\n      break;\n    case cmd_setMPIComm:\n      comm.Set_comm(val);\n      break;\n    case cmd_setMPIFComm:\n      comm.Set_fcomm(val);\n      break;\n    case cmd_run:\n      CHECK_NULL(val,word);\n      argc=argv.size();\n      {\n        int n=0; for(int i=0; i<argc; ++i) n+=argv[i].length()+1;\n        std::vector<char> args(n);\n        std::vector<char*> vvv(argc);\n        char* ptr=&args[0];\n        for(int i=0; i<argc; ++i) {\n          vvv[i]=ptr;\n          for(unsigned c=0; c<argv[i].length(); ++c) {\n            *ptr=argv[i][c]; ptr++;\n          }\n          *ptr=0; ptr++;\n        }\n        int ret=run(argc,&vvv[0],in,out,comm);\n        *static_cast<int*>(val)=ret;\n      }\n      break;\n    default:\n      plumed_merror(\"cannot interpret cmd(\\\"CLTool \" + word + \"\\\"). check plumed developers manual to see the available commands.\");\n      break;\n    }\n  }\n}\n\n/**\nThis is the entry point to the command line tools\nincluded in the plumed library.\n*/\n\nint CLToolMain::run(int argc, char **argv,FILE*in,FILE*out,Communicator& pc) {\n  int i;\n  bool printhelp=false;\n\n  DLLoader dlloader;\n\n  string root=config::getPlumedRoot();\n\n  bool standalone_executable=false;\n\n// Start parsing options\n  string prefix(\"\");\n  string a(\"\");\n  for(i=1; i<argc; i++) {\n    a=prefix+argv[i];\n    if(a.length()==0) continue;\n    if(a==\"help\" || a==\"-h\" || a==\"--help\") {\n      printhelp=true;\n      break;\n    } else if(a==\"--has-mpi\") {\n      if(Communicator::initialized()) return 0;\n      else return 1;\n    } else if(a==\"--has-cregex\") {\n      return (config::hasCregex()?0:1);\n    } else if(a==\"--has-dlopen\") {\n      return (config::hasDlopen()?0:1);\n    } else if(a==\"--has-molfile\") {\n      return (config::hasMolfile()?0:1);\n    } else if(a==\"--has-external-molfile\") {\n      return (config::hasExternalMolfile()?0:1);\n    } else if(a==\"--has-zlib\") {\n      return (config::hasZlib()?0:1);\n    } else if(a==\"--has-xdrfile\") {\n      return (config::hasXdrfile()?0:1);\n    } else if(a==\"--is-installed\") {\n      return (config::isInstalled()?0:1);\n    } else if(a==\"--no-mpi\") {\n// this is ignored, as it is parsed in main\n      continue;\n    } else if(a==\"--mpi\") {\n// this is ignored, as it is parsed in main\n      continue;\n    } else if(a==\"--standalone-executable\") {\n      standalone_executable=true;\n    } else if(Tools::startWith(a,\"--load=\")) {\n      a.erase(0,a.find(\"=\")+1);\n      prefix=\"\";\n      void *p=dlloader.load(a);\n      if(!p) {\n        fprintf(stderr,\"ERROR: cannot load library %s\\n\",a.c_str());\n        fprintf(stderr,\"ERROR: %s\\n\",dlloader.error().c_str());\n        return 1;\n      }\n    } else if(a==\"--load\") {\n      prefix=\"--load=\";\n    } else if(a[0]=='-') {\n      string msg=\"ERROR: Unknown option \" +a;\n      fprintf(stderr,\"%s\\n\",msg.c_str());\n      return 1;\n    } else break;\n  }\n\n// Check if plumedRoot/patches/ directory exists (as a further check)\n  if(!standalone_executable) {\n    vector<string> files=Tools::ls(root);\n    if(find(files.begin(),files.end(),\"patches\")==files.end()) {\n      string msg=\n        \"WARNING: I cannot find \"+root+\"/patches/ directory. Set PLUMED_ROOT or reinstall PLUMED\\n\\n\";\n      fprintf(stderr,\"%s\",msg.c_str());\n    }\n  }\n\n// Build list of available C++ tools:\n  vector<string> availableCxx=cltoolRegister().list();\n// Build list of available shell tools:\n  vector<string> availableShell;\n  if(!standalone_executable) {\n    vector<string> tmp;\n    tmp=Tools::ls(string(root+\"/scripts\"));\n    for(unsigned j=0; j<tmp.size(); ++j) {\n      size_t ff=tmp[j].find(\".sh\");\n      if(ff==string::npos) tmp[j].erase();\n      else                 tmp[j].erase(ff);\n    }\n    for(unsigned j=0; j<tmp.size(); ++j) if(tmp[j].length()>0) availableShell.push_back(tmp[j]);\n  }\n\n  if(printhelp) {\n    string msg=\n      \"Usage: plumed [options] [command] [command options]\\n\"\n      \"  plumed [command] -h|--help: to print help for a specific command\\n\"\n      \"Options:\\n\"\n      \"  [help|-h|--help]          : to print this help\\n\"\n      \"  [--is-installed]          : fails if plumed is not installed\\n\"\n      \"  [--has-mpi]               : fails if plumed is running without MPI\\n\"\n      \"  [--has-dlopen]            : fails if plumed is compiled without dlopen\\n\"\n      \"  [--load LIB]              : loads a shared object (typically a plugin library)\\n\"\n      \"  [--standalone-executable] : tells plumed not to look for commands implemented as scripts\\n\"\n      \"Commands:\\n\";\n    fprintf(out,\"%s\",msg.c_str());\n    for(unsigned j=0; j<availableCxx.size(); ++j) {\n      auto cl=cltoolRegister().create(CLToolOptions(availableCxx[j]));\n      plumed_assert(cl);\n      string manual=availableCxx[j]+\" : \"+cl->description();\n      fprintf(out,\"  plumed %s\\n\", manual.c_str());\n    }\n    for(unsigned j=0; j<availableShell.size(); ++j) {\n      string cmd=config::getEnvCommand()+\" \\\"\"+root+\"/scripts/\"+availableShell[j]+\".sh\\\" --description\";\n      FILE *fp=popen(cmd.c_str(),\"r\");\n      string line,manual;\n      while(Tools::getline(fp,line))manual+=line;\n      pclose(fp);\n      manual= availableShell[j]+\" : \"+manual;\n      fprintf(out,\"  plumed %s\\n\", manual.c_str());\n    }\n    return 0;\n  }\n  if(i==argc) {\n    fprintf(out,\"%s\",\"Nothing to do. Use 'plumed help' for help\\n\");\n    return 0;\n  }\n\n// this is the command to be executed:\n  string command(argv[i]);\n\n  if(find(availableCxx.begin(),availableCxx.end(),command)!=availableCxx.end()) {\n    auto cl=cltoolRegister().create(CLToolOptions(command));\n    plumed_assert(cl);\n    // Read the command line options (returns false if we are just printing help)\n    if( !cl->readInput( argc-i,&argv[i],in,out ) ) { return 0; }\n    int ret=cl->main(in,out,pc);\n    return ret;\n  }\n\n  if(find(availableShell.begin(),availableShell.end(),command)!=availableShell.end()) {\n    plumed_massert(in==stdin,\"shell tools can only work on stdin\");\n    plumed_massert(out==stdout,\"shell tools can only work on stdin\");\n    string cmd=config::getEnvCommand()+\" \\\"\"+root+\"/scripts/\"+command+\".sh\\\"\";\n    for(int j=i+1; j<argc; j++) cmd+=string(\" \")+argv[j];\n    int r=system(cmd.c_str());\n// this is necessary since system seems to return numbers which are multiple\n// of 256. this would make the interpretation by the shell wrong\n// I just return 1 in case of failure and 0 in case of success\n    if(r!=0) return 1;\n    else return 0;\n  }\n\n  string msg=\"ERROR: unknown command \" + command + \". Use 'plumed help' for help\";\n  fprintf(stderr,\"%s\\n\",msg.c_str());\n  return 1;\n\n}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/src/core/PlumedMainInitializer.cpp": "/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n   Copyright (c) 2011-2020 The plumed team\n   (see the PEOPLE file at the root of the distribution for a list of names)\n\n   See http://www.plumed.org for more information.\n\n   This file is part of plumed, version 2.\n\n   plumed is free software: you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   plumed is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#include \"PlumedMainInitializer.h\"\n#include \"PlumedMain.h\"\n#include \"tools/Exception.h\"\n#include \"lepton/Exception.h\"\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#if defined __PLUMED_HAS_DLOPEN\n#include <dlfcn.h>\n#endif\n#include <exception>\n#include <stdexcept>\n#include <ios>\n#include <new>\n#include <typeinfo>\n#ifdef __PLUMED_LIBCXX11\n#include <system_error>\n#include <future>\n#include <memory>\n#include <functional>\n#endif\n\n\nusing namespace std;\n\n// create should never throw\n// in case of a problem, it logs the error and return a null pointer\n// when loaded by an interface >=2.5, this will result in a non valid plumed object.\n// earlier interfaces will just give a segfault or a failed assertion.\nextern \"C\" void*plumed_plumedmain_create() {\n  try {\n    return new PLMD::PlumedMain;\n  } catch(const std::exception & e) {\n    std::cerr<<\"+++ an error happened while creating a plumed object\\n\";\n    std::cerr<<e.what()<<std::endl;\n    return nullptr;\n  } catch(...) {\n    std::cerr<<\"+++ an unknown error happened while creating a plumed object\"<<std::endl;\n    return nullptr;\n  }\n}\n\nextern \"C\" void plumed_plumedmain_cmd(void*plumed,const char*key,const void*val) {\n  plumed_massert(plumed,\"trying to use a plumed object which is not initialized\");\n  auto p=static_cast<PLMD::PlumedMain*>(plumed);\n  p->cmd(key,val);\n}\n\nextern \"C\" void plumed_plumedmain_cmd_nothrow(void*plumed,const char*key,const void*val,plumed_nothrow_handler nothrow) {\n// At library boundaries we translate exceptions to error codes.\n// This allows an exception to be catched also if the MD code\n// was linked against a different C++ library\n  try {\n    plumed_massert(plumed,\"trying to use a plumed object which is not initialized\");\n    static_cast<PLMD::PlumedMain*>(plumed)->cmd(key,val);;\n  } catch(const PLMD::ExceptionError & e) {\n    nothrow.handler(nothrow.ptr,20200,e.what(),nullptr);\n  } catch(const PLMD::ExceptionDebug & e) {\n    nothrow.handler(nothrow.ptr,20100,e.what(),nullptr);\n  } catch(const PLMD::Exception & e) {\n    nothrow.handler(nothrow.ptr,20000,e.what(),nullptr);\n  } catch(const PLMD::lepton::Exception & e) {\n    nothrow.handler(nothrow.ptr,19900,e.what(),nullptr);\n    // 11000 to 12000 are \"bad exceptions\". message will be copied without new allocations\n  } catch(const bad_exception & e) {\n    nothrow.handler(nothrow.ptr,11500,e.what(),nullptr);\n#ifdef __PLUMED_LIBCXX11\n  } catch(const bad_array_new_length & e) {\n    nothrow.handler(nothrow.ptr,11410,e.what(),nullptr);\n#endif\n  } catch(const bad_alloc & e) {\n    nothrow.handler(nothrow.ptr,11400,e.what(),nullptr);\n#ifdef __PLUMED_LIBCXX11\n  } catch(const bad_function_call & e) {\n    nothrow.handler(nothrow.ptr,11300,e.what(),nullptr);\n  } catch(const bad_weak_ptr & e) {\n    nothrow.handler(nothrow.ptr,11200,e.what(),nullptr);\n#endif\n  } catch(const bad_cast & e) {\n    nothrow.handler(nothrow.ptr,11100,e.what(),nullptr);\n  } catch(const bad_typeid & e) {\n    nothrow.handler(nothrow.ptr,11000,e.what(),nullptr);\n    // not implemented yet: std::regex_error\n    // we do not allow regex yet due to portability problems with gcc 4.8\n    // as soon as we transition to using <regex> it should be straightforward to add\n  } catch(const std::ios_base::failure & e) {\n#ifdef __PLUMED_LIBCXX11\n    int value=e.code().value();\n    const void* opt[3]= {\"c\",&value,nullptr}; // \"c\" passes the error code. nullptr terminates the optional part.\n    if(e.code().category()==generic_category()) nothrow.handler(nothrow.ptr,10230,e.what(),opt);\n    else if(e.code().category()==system_category()) nothrow.handler(nothrow.ptr,10231,e.what(),opt);\n    else if(e.code().category()==iostream_category()) nothrow.handler(nothrow.ptr,10232,e.what(),opt);\n    else if(e.code().category()==future_category()) nothrow.handler(nothrow.ptr,10233,e.what(),opt);\n    else\n#endif\n      // 10239 represents std::ios_base::failure with default constructur\n      nothrow.handler(nothrow.ptr,10239,e.what(),nullptr);\n#ifdef __PLUMED_LIBCXX11\n  } catch(const std::system_error & e) {\n    int value=e.code().value();\n    const void* opt[3]= {\"c\",&value,nullptr}; // \"c\" passes the error code. nullptr terminates the optional part.\n    if(e.code().category()==generic_category()) nothrow.handler(nothrow.ptr,10220,e.what(),opt);\n    else if(e.code().category()==system_category()) nothrow.handler(nothrow.ptr,10221,e.what(),opt);\n    else if(e.code().category()==iostream_category()) nothrow.handler(nothrow.ptr,10222,e.what(),opt);\n    else if(e.code().category()==future_category()) nothrow.handler(nothrow.ptr,10223,e.what(),opt);\n    // fallback to generic runtime_error\n    else nothrow.handler(nothrow.ptr,10200,e.what(),nullptr);\n#endif\n  } catch(const std::underflow_error &e) {\n    nothrow.handler(nothrow.ptr,10215,e.what(),nullptr);\n  } catch(const std::overflow_error &e) {\n    nothrow.handler(nothrow.ptr,10210,e.what(),nullptr);\n  } catch(const std::range_error &e) {\n    nothrow.handler(nothrow.ptr,10205,e.what(),nullptr);\n  } catch(const std::runtime_error & e) {\n    nothrow.handler(nothrow.ptr,10200,e.what(),nullptr);\n    // not implemented yet: std::future_error\n    // not clear how useful it would be.\n  } catch(const std::out_of_range & e) {\n    nothrow.handler(nothrow.ptr,10120,e.what(),nullptr);\n  } catch(const std::length_error & e) {\n    nothrow.handler(nothrow.ptr,10115,e.what(),nullptr);\n  } catch(const std::domain_error & e) {\n    nothrow.handler(nothrow.ptr,10110,e.what(),nullptr);\n  } catch(const std::invalid_argument & e) {\n    nothrow.handler(nothrow.ptr,10105,e.what(),nullptr);\n  } catch(const std::logic_error & e) {\n    nothrow.handler(nothrow.ptr,10100,e.what(),nullptr);\n    // generic exception. message will be copied without new allocations\n    // reports all non caught exceptions that are derived from std::exception\n    // for instance, boost exceptions would end up here\n  } catch(const std::exception & e) {\n    nothrow.handler(nothrow.ptr,10000,e.what(),nullptr);\n  } catch(...) {\n    // if exception cannot be translated, we throw a bad_exception\n    nothrow.handler(nothrow.ptr,11500,\"plumed could not translate exception\",nullptr);\n    throw;\n  }\n}\n\nextern \"C\" void plumed_plumedmain_finalize(void*plumed) {\n  plumed_massert(plumed,\"trying to deallocate a plumed object which is not initialized\");\n// I think it is not possible to replace this delete with a smart pointer\n// since the ownership of this pointer is in a C structure. GB\n  delete static_cast<PLMD::PlumedMain*>(plumed);\n}\n\n// values here should be consistent with those in plumed_symbol_table_init !!!!\nplumed_symbol_table_type plumed_symbol_table= {\n  2,\n  {plumed_plumedmain_create,plumed_plumedmain_cmd,plumed_plumedmain_finalize},\n  plumed_plumedmain_cmd_nothrow\n};\n\n// values here should be consistent with those above !!!!\nextern \"C\" void plumed_symbol_table_init() {\n  plumed_symbol_table.version=2;\n  plumed_symbol_table.functions.create=plumed_plumedmain_create;\n  plumed_symbol_table.functions.cmd=plumed_plumedmain_cmd;\n  plumed_symbol_table.functions.finalize=plumed_plumedmain_finalize;\n  plumed_symbol_table.cmd_nothrow=plumed_plumedmain_cmd_nothrow;\n}\n\nnamespace PLMD {\n\n#define plumed_convert_fptr(ptr,fptr) { ptr=NULL; std::memcpy(&ptr,&fptr,(sizeof(fptr)>sizeof(ptr)?sizeof(ptr):sizeof(fptr))); }\n\n/// Static object which registers Plumed.\n/// This is a static object which, during its construction at startup,\n/// registers the pointers to plumed_plumedmain_create, plumed_plumedmain_cmd and plumed_plumedmain_finalize\n/// to the plumed_kernel_register function.\n/// Registration is only required with plumed loader <=2.4, but we do it anyway in order to maintain\n/// backward compatibility. Notice that as of plumed 2.5 the plumed_kernel_register is found\n/// using dlsym, in order to allow the libplumedKernel library to be loadable also when\n/// the plumed_kernel_register symbol is not available.\nstatic class PlumedMainInitializer {\n  const bool debug;\npublic:\n  PlumedMainInitializer():\n    debug(std::getenv(\"PLUMED_LOAD_DEBUG\"))\n  {\n// make sure static plumed_function_pointers is initialized here\n    plumed_symbol_table_init();\n    if(debug) fprintf(stderr,\"+++ Initializing PLUMED with plumed_symbol_table version %i at %p\\n\",plumed_symbol_table.version,(void*)&plumed_symbol_table);\n#if defined(__PLUMED_HAS_DLOPEN)\n    if(std::getenv(\"PLUMED_LOAD_SKIP_REGISTRATION\")) {\n      if(debug) fprintf(stderr,\"+++ Skipping registration +++\\n\");\n      return;\n    }\n    typedef plumed_plumedmain_function_holder* (*plumed_kernel_register_type)(const plumed_plumedmain_function_holder*);\n    plumed_kernel_register_type plumed_kernel_register=nullptr;\n    void* handle=nullptr;\n#if defined(__PLUMED_HAS_RTLD_DEFAULT)\n    if(debug) fprintf(stderr,\"+++ Registering functions. Looking in RTLD_DEFAULT +++\\n\");\n    void* dls=dlsym(RTLD_DEFAULT,\"plumed_kernel_register\");\n#else\n    handle=dlopen(NULL,RTLD_LOCAL);\n    if(debug) fprintf(stderr,\"+++ Registering functions. dlopen handle at %p +++\\n\",handle);\n    void* dls=dlsym(handle,\"plumed_kernel_register\");\n#endif\n    *(void **)(&plumed_kernel_register)=dls;\n    if(debug) {\n      if(plumed_kernel_register) {\n        fprintf(stderr,\"+++ plumed_kernel_register found at %p +++\\n\",dls);\n      }\n      else fprintf(stderr,\"+++ plumed_kernel_register not found +++\\n\");\n    }\n    void*createp;\n    void*cmdp;\n    void*finalizep;\n    plumed_convert_fptr(createp,plumed_symbol_table.functions.create);\n    plumed_convert_fptr(cmdp,plumed_symbol_table.functions.cmd);\n    plumed_convert_fptr(finalizep,plumed_symbol_table.functions.finalize);\n    if(plumed_kernel_register && debug) fprintf(stderr,\"+++ Registering functions at %p (%p,%p,%p) +++\\n\",\n          (void*)&plumed_symbol_table.functions,createp,cmdp,finalizep);\n    if(plumed_kernel_register) (*plumed_kernel_register)(&plumed_symbol_table.functions);\n// Notice that handle could be null in the following cases:\n// - if we use RTLD_DEFAULT\n// - on Linux if we don't use RTLD_DEFAULT, since dlopen(NULL,RTLD_LOCAL) returns a null pointer.\n    if(handle) dlclose(handle);\n#endif\n// I think this is a bug in cppcheck 1.87\n// Notice that if handle is NULL there's no point in dlclosing it.\n// cppcheck-suppress resourceLeak\n  }\n  ~PlumedMainInitializer() {\n    if(debug) fprintf(stderr,\"+++ Finalizing PLUMED with plumed_symbol_table at %p\\n\",(void*)&plumed_symbol_table);\n  }\n} PlumedMainInitializerRegisterMe;\n\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/src/tools/DLLoader.cpp": "/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n   Copyright (c) 2011-2020 The plumed team\n   (see the PEOPLE file at the root of the distribution for a list of names)\n\n   See http://www.plumed.org for more information.\n\n   This file is part of plumed, version 2.\n\n   plumed is free software: you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   plumed is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#include \"DLLoader.h\"\n#include <cstdlib>\n\n#ifdef __PLUMED_HAS_DLOPEN\n#include <dlfcn.h>\n#endif\n\nnamespace PLMD {\n\nbool DLLoader::installed() {\n#ifdef __PLUMED_HAS_DLOPEN\n  return true;\n#else\n  return false;\n#endif\n}\n\n\nvoid* DLLoader::load(const std::string&s) {\n#ifdef __PLUMED_HAS_DLOPEN\n  void* p=dlopen(s.c_str(),RTLD_NOW|RTLD_LOCAL);\n  if(!p) {\n    lastError=dlerror();\n  } else {\n    lastError=\"\";\n    handles.push(p);\n  }\n  return p;\n#else\n  return NULL;\n#endif\n}\n\nconst std::string & DLLoader::error() {\n  return lastError;\n}\n\nDLLoader::~DLLoader() {\n  auto debug=std::getenv(\"PLUMED_LOAD_DEBUG\");\n  if(debug) std::fprintf(stderr,\"delete dlloader\\n\");\n#ifdef __PLUMED_HAS_DLOPEN\n  while(!handles.empty()) {\n    int ret=dlclose(handles.top());\n    if(ret) {\n      std::fprintf(stderr,\"+++ error reported by dlclose: %s\\n\",dlerror());\n    }\n    handles.pop();\n  }\n#endif\n  if(debug) std::fprintf(stderr,\"end delete dlloader\\n\");\n}\n\nDLLoader::DLLoader() {\n  // do nothing\n}\n\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/src/tools/PlumedHandle.h": "/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n   Copyright (c) 2018-2020 The plumed team\n   (see the PEOPLE file at the root of the distribution for a list of names)\n\n   See http://www.plumed.org for more information.\n\n   This file is part of plumed, version 2.\n\n   plumed is free software: you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   plumed is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#ifndef __PLUMED_tools_PlumedHandle_h\n#define __PLUMED_tools_PlumedHandle_h\n#include \"core/PlumedMainInitializer.h\"\n#include <memory>\n\nnamespace PLMD\n{\n\nclass PlumedMain;\n\n/**\nTiny local class to load a PLUMED kernel.\n\nMaps command to either a loaded PLUMED kernel or to the present one.\nIt is a simplified version of the interface located at wrapper/Plumed.h.\nDifferences are:\n- It does not use the `PLUMED_KERNEL` env var. Indeed, it would not make sense to use it,\n  since this class is meant to load different kernels.\n- It does not implement interoperability with C/FORTRAN interfaces.\n- It does not implement global versions (e.g. PLMD::Plumed::gcmd).\n- It does not implement PLMD::Plumed::ginitialized. If it cannot be loaded, it crashes in its constructor.\n  This will make sure that once constructed the object is usable.\n\nThe mechanism for loading the kernel is anyway very similar to the one in wrapper/Plumed.c.\nIn particular, it can load both kernels from PLUMED <=2.4 and >=2.5, and it\ntries to load the `libplumed.so` object if the `libplumedKernel.so` object does not load correctly.\nIt can also be created without passing any kernel path. In that case it refers to the current one\n(the one to which this class belongs).\n\nThe following syntax creates a handle referring to the current kernel\n\\verbatim\nPlumedHandle p;\n// Alternatively:\n// auto p=PlumedHandle();\np.cmd(\"init\");\n\\endverbatim\n\nThe following syntax instead creates a handle referring to a loaded kernel\n\\verbatim\nPlumedHandle p(PlumedHandle::dlopen(\"/path/to/libplumedkernel.so\");\n// Alternatively:\n// auto p=PlumedHandle::dlopen(\"/path/to/libplumedkernel.so\");\np.cmd(\"init\");\n\\endverbatim\n\nNotice that if there are problems loading the kernel an exception is thrown.\nThus, once constructed the object is guaranteed to be functional.\n\n*/\nclass PlumedHandle {\n/// Automatically dlclosing auxiliary class.\n/// Just used to make sure that handle is dlclosed correctly.\n  class DlHandle {\n    void *handle=nullptr;\n  public:\n/// Default construct as nullptr\n    DlHandle() {}\n/// Construct from a void*\n    explicit DlHandle(void*h): handle(h) {}\n/// Destructor will call dlclose if necessary\n    ~DlHandle();\n/// Covertible to void* so that it can be used directly\n    operator void*() const {\n      return handle;\n    }\n  };\n/// Pointer to PlumedMain.\n/// Used when using the current kernel in order to avoid unneeded indirections.\n  std::unique_ptr<PlumedMain> local;\n/// Pointer to dlsym handle used to open the kernel.\n/// Null when using current kernel.\n  DlHandle handle;\n/// Pointer to symbol table.\n/// Used for kernels>=2.5. We store it here since it is needed\n/// in constructor to initialize create_/cmd_/finalize_.\n/// Later on we might use the additional version information that it carries.\n  plumed_symbol_table_type* const symbol_=nullptr;\n/// Pointer to create function.\n/// Used when kernel is dlopened.\n  const plumed_create_pointer create_=nullptr;\n/// Pointer to cmd function.\n/// Used when kernel is dlopened.\n  const plumed_cmd_pointer cmd_=nullptr;\n/// Pointer to finalize function.\n/// Used when kernel is dlopened.\n  const plumed_finalize_pointer finalize_=nullptr;\n/// Pointer to the plumed object.\n/// Used when kernel is dlopened.\n  void* const p=nullptr;\n/// Constructor using the path to a kernel.\n/// I keep it private to avoid confusion wrt the\n/// similar constructor of PLMD::Plumed that accepts a string (conversion from FORTRAN).\n  explicit PlumedHandle(const char* path);\npublic:\n/// Default constructor.\n/// Maps following commands to the current kernel.\n  PlumedHandle();\n/// Construct a PlumedHandle given the path to a kernel.\n/// It just uses the private constructor PlumedHandle(const char* path).\n  static PlumedHandle dlopen(const char* path);\n/// Destructor.\n/// In case a kernel was dlopened, it dlcloses it.\n/// I make it virtual for future extensibility, though this is not necessary now.\n  virtual ~PlumedHandle();\n/// Move constructor.\n  PlumedHandle(PlumedHandle &&) = default;\n/// Execute cmd.\n  void cmd(const char*key,const void*ptr=nullptr);\n};\n\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/src/tools/PlumedHandle.cpp": "/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n   Copyright (c) 2018-2020 The plumed team\n   (see the PEOPLE file at the root of the distribution for a list of names)\n\n   See http://www.plumed.org for more information.\n\n   This file is part of plumed, version 2.\n\n   plumed is free software: you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   plumed is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#include \"PlumedHandle.h\"\n#include \"core/PlumedMain.h\"\n#include \"Tools.h\"\n#include <cstring>\n#ifdef __PLUMED_HAS_DLOPEN\n#include <dlfcn.h>\n#endif\n\nnamespace PLMD\n{\n\nPlumedHandle::DlHandle::~DlHandle() {\n#ifdef __PLUMED_HAS_DLOPEN\n  if(handle) dlclose(handle);\n#endif\n}\n\nPlumedHandle::PlumedHandle():\n  local(new PlumedMain)\n{\n}\n\nPlumedHandle::PlumedHandle(const char* kernel)\n#ifdef __PLUMED_HAS_DLOPEN\n  :\n  handle([&]() {\n  dlerror();\n  int mode = RTLD_LOCAL | RTLD_NOW;\n#ifdef RTLD_DEEPBIND\n// Needed on Linux to avoid namespace clashes\n  mode |= RTLD_DEEPBIND;\n#endif\n  void* h=::dlopen(kernel,mode);\n// try to remove the \"Kernel\" string.\n// needed to load old versions\n  if(!h) {\n    std::string k(kernel);\n    auto i=k.rfind(\"Kernel\");\n    if(i!=std::string::npos) {\n      k=k.substr(0,i) + k.substr(i+6);\n      h=::dlopen(k.c_str(),mode);\n    }\n  }\n  plumed_assert(h) << \"there was a problem loading kernel \"<<kernel <<\"\\n\"<<dlerror();\n  return DlHandle(h);\n// once the DlHandle has been constructed we know that later exceptions will also call dlclose().\n}()),\nsymbol_((plumed_symbol_table_type*) dlsym(handle,\"plumed_symbol_table\")),\ncreate_([&]() {\n  if(symbol_) {\n    plumed_assert(symbol_->functions.create);\n    return symbol_->functions.create;\n  }\n  void* c=nullptr;\n  if(!c) c=dlsym(handle,\"plumedmain_create\");\n  if(!c) c=dlsym(handle,\"plumed_plumedmain_create\");\n  plumed_assert(c) << \"in kernel \"<<kernel<<\" I could not find (plumed_)plumedmain_create\";\n  plumed_create_pointer cc;\n  *(void **)(&cc)=c;\n  return cc;\n}()),\ncmd_([&]() {\n  if(symbol_) {\n    plumed_assert(symbol_->functions.cmd);\n    return symbol_->functions.cmd;\n  }\n  void* c=nullptr;\n  if(!c) c=dlsym(handle,\"plumedmain_cmd\");\n  if(!c) c=dlsym(handle,\"plumed_plumedmain_cmd\");\n  plumed_assert(c) << \"in kernel \"<<kernel<<\" I could not find (plumed_)plumedmain_cmd\";\n  plumed_cmd_pointer cc;\n  *(void **)(&cc)=c;\n  return cc;\n}()),\nfinalize_([&]() {\n  if(symbol_) {\n    plumed_assert(symbol_->functions.finalize);\n    return symbol_->functions.finalize;\n  }\n  void* f=nullptr;\n  if(!f) f=dlsym(handle,\"plumedmain_finalize\");\n  if(!f) f=dlsym(handle,\"plumed_plumedmain_finalize\");\n  plumed_assert(f) << \"in kernel \"<<kernel<<\" I could not find (plumed_)plumedmain_finalize\";\n  plumed_finalize_pointer ff;\n  *(void **)(&ff)=f;\n  return ff;\n}()),\np(create_())\n// No exceptions thrown past this point.\n// Thus, destructor PlumedHandle::~PlumedHandle() will always be called and p will always be finalized.\n{}\n#else\n{\n  plumed_error() << \"You are trying to dynamically load a kernel, but PLUMED was compiled without dlopen\";\n}\n#endif\n\nPlumedHandle::~PlumedHandle() {\n#ifdef __PLUMED_HAS_DLOPEN\n  if(p) finalize_(p);\n#endif\n}\n\nPlumedHandle PlumedHandle::dlopen(const char* path) {\n  return PlumedHandle(path);\n}\n\nvoid PlumedHandle::cmd(const char*key,const void*ptr) {\n  if(local) local->cmd(key,ptr);\n  else if(p && cmd_) cmd_(p,key,ptr);\n  else plumed_error() << \"should never arrive here (either one or the other should work)\";\n}\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/src/tools/DLLoader.h": "/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n   Copyright (c) 2011-2020 The plumed team\n   (see the PEOPLE file at the root of the distribution for a list of names)\n\n   See http://www.plumed.org for more information.\n\n   This file is part of plumed, version 2.\n\n   plumed is free software: you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   plumed is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#ifndef __PLUMED_tools_DLLoader_h\n#define __PLUMED_tools_DLLoader_h\n\n#include <stack>\n#include <string>\n\nnamespace PLMD {\n\n/// \\ingroup TOOLBOX\n/// Class taking care of dynamic loading.\n/// It contains wrappers to the dlopen() routine.\n/// It is designed so that when an object of this class goes\n/// out of scope all the libraries loaded by it are unloaded. In this\n/// manner, loaded libraries are automatically unloaded at the end of\n/// execution. Libraries are loaded with RTDL_LOCAL option, which\n/// means that they are not accessible from outside. Still, if they\n/// contain self-registering classes, they will register themselves\n/// to the ActionRegister object.\nclass DLLoader {\n  std::stack<void*> handles;\n  std::string lastError;\n/// Deleted copy constructor\n  DLLoader(const DLLoader&) = delete;\n/// Deleted assignment\n  DLLoader&operator=(const DLLoader&) = delete;\npublic:\n/// Default constructor\n  DLLoader();\n/// Cleanup\n  ~DLLoader();\n/// Load a library, returning its handle\n  void* load(const std::string&);\n/// Returns the last error in dynamic loader\n  const std::string & error();\n/// Returns true if the dynamic loader is available (on some systems it may not).\n  static bool installed();\n};\n\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-make-wrappers/main.cpp": "#include \"plumed/wrapper/Plumed.h\"\n#include \"plumed/tools/Exception.h\"\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <memory>\n\nextern \"C\"{\n  void plumed_f_installed(int*i);\n  void plumed_f_ginitialized(int*i);\n  void plumed_f_gvalid(int*i);\n  void plumed_f_gcreate();\n  void plumed_f_gcmd(char* key,void* val);\n  void plumed_f_gfinalize();\n  void plumed_f_global(char*c);\n  void plumed_f_create(char*c);\n  void plumed_f_create_dlopen(char*p,char*c);\n  void plumed_f_create_reference(char*r,char*c);\n  void plumed_f_cmd(char*c,char* key,void* val);\n  void plumed_f_finalize(char*c);\n  void plumed_f_use_count(char*c,int*i);\n  void plumed_f_installed_(int*i);\n  void plumed_f_gvalid_(int*i);\n  void plumed_f_ginitialized_(int*i);\n  void plumed_f_gcreate_();\n  void plumed_f_gcmd_(char* key,void* val);\n  void plumed_f_gfinalize_();\n  void plumed_f_global_(char*c);\n  void plumed_f_create_(char*c);\n  void plumed_f_create_dlopen_(char*p,char*c);\n  void plumed_f_create_reference_(char*r,char*c);\n  void plumed_f_cmd_(char*c,char* key,void* val);\n  void plumed_f_finalize_(char*c);\n  void plumed_f_use_count_(char*c,int*i);\n  void plumed_f_installed__(int*i);\n  void plumed_f_gvalid__(int*i);\n  void plumed_f_ginitialized__(int*i);\n  void plumed_f_gcreate__();\n  void plumed_f_gcmd__(char* key,void* val);\n  void plumed_f_gfinalize__();\n  void plumed_f_global__(char*c);\n  void plumed_f_create__(char*c);\n  void plumed_f_create_dlopen__(char*p,char*c);\n  void plumed_f_create_reference__(char*r,char*c);\n  void plumed_f_cmd__(char*c,char* key,void* val);\n  void plumed_f_finalize__(char*c);\n  void plumed_f_use_count__(char*c,int*i);\n  void PLUMED_F_INSTALLED(int*);\n  void PLUMED_F_GINITIALIZED(int*);\n  void PLUMED_F_GVALID(int*);\n  void PLUMED_F_GCREATE();\n  void PLUMED_F_GCMD(char* key,void* val);\n  void PLUMED_F_GFINALIZE();\n  void PLUMED_F_GLOBAL(char*c);\n  void PLUMED_F_CREATE(char*c);\n  void PLUMED_F_CREATE_DLOPEN(char*p,char*c);\n  void PLUMED_F_CREATE_REFERENCE(char*r,char*c);\n  void PLUMED_F_CMD(char*c,char* key,void* val);\n  void PLUMED_F_FINALIZE(char*c);\n  void PLUMED_F_USE_COUNT(char*c,int*i);\n  void PLUMED_F_INSTALLED_(int*);\n  void PLUMED_F_GINITIALIZED_(int*);\n  void PLUMED_F_GVALID_(int*);\n  void PLUMED_F_GCREATE_();\n  void PLUMED_F_GCMD_(char* key,void* val);\n  void PLUMED_F_GFINALIZE_();\n  void PLUMED_F_GLOBAL_(char*c);\n  void PLUMED_F_CREATE_(char*c);\n  void PLUMED_F_CREATE_DLOPEN_(char*p,char*c);\n  void PLUMED_F_CREATE_REFERENCE_(char*r,char*c);\n  void PLUMED_F_CMD_(char*c,char* key,void* val);\n  void PLUMED_F_FINALIZE_(char*c);\n  void PLUMED_F_USE_COUNT_(char*c,int*i);\n  void PLUMED_F_INSTALLED__(int*);\n  void PLUMED_F_GINITIALIZED__(int*);\n  void PLUMED_F_GVALID__(int*);\n  void PLUMED_F_GCREATE__();\n  void PLUMED_F_GCMD__(char* key,void* val);\n  void PLUMED_F_GFINALIZE__();\n  void PLUMED_F_GLOBAL__(char*c);\n  void PLUMED_F_CREATE__(char*c);\n  void PLUMED_F_CREATE_DLOPEN__(char*p,char*c);\n  void PLUMED_F_CREATE_REFERENCE__(char*r,char*c);\n  void PLUMED_F_CMD__(char*c,char* key,void* val);\n  void PLUMED_F_FINALIZE__(char*c);\n  void PLUMED_F_USE_COUNT__(char*c,int*i);\n}\n\ntemplate<typename T,typename S>\nvoid testme(T p,S cmd){\n  int natoms=10;\n  std::vector<double> positions(3*natoms,0.0);\n  std::vector<double> masses(natoms,1.0);\n  std::vector<double> forces(3*natoms,0.0);\n  std::vector<double> virial(9,0.0);\n\n\n  cmd(p,(char*)\"setNatoms\",&natoms);\n  cmd(p,(char*)\"init\",NULL);\n  cmd(p,(char*)\"readInputLine\",(char*)\"d: DISTANCE ATOMS=1,2\");\n  cmd(p,(char*)\"readInputLine\",(char*)\"PRINT ARG=d FILE=COLVAR RESTART=YES\");\n  int step=1;\n  cmd(p,(char*)\"setStep\",&step);\n  cmd(p,(char*)\"setPositions\",&positions[0]);\n  cmd(p,(char*)\"setMasses\",&masses[0]);\n  cmd(p,(char*)\"setForces\",&forces[0]);\n  cmd(p,(char*)\"setVirial\",&virial[0]);\n  cmd(p,(char*)\"calc\",NULL);\n}\n\ntemplate<typename S>\nvoid testme(S cmd){\n  int natoms=10;\n  std::vector<double> positions(3*natoms,0.0);\n  std::vector<double> masses(natoms,1.0);\n  std::vector<double> forces(3*natoms,0.0);\n  std::vector<double> virial(9,0.0);\n\n\n  cmd((char*)\"setNatoms\",&natoms);\n  cmd((char*)\"init\",NULL);\n  cmd((char*)\"readInputLine\",(char*)\"d: DISTANCE ATOMS=1,2\");\n  cmd((char*)\"readInputLine\",(char*)\"PRINT ARG=d FILE=COLVAR RESTART=YES\");\n  int step=1;\n  cmd((char*)\"setStep\",&step);\n  cmd((char*)\"setPositions\",&positions[0]);\n  cmd((char*)\"setMasses\",&masses[0]);\n  cmd((char*)\"setForces\",&forces[0]);\n  cmd((char*)\"setVirial\",&virial[0]);\n  cmd((char*)\"calc\",NULL);\n}\n\nvoid testmecpp(PLMD::Plumed p){\n  int natoms=10;\n  std::vector<double> positions(3*natoms,0.0);\n  std::vector<double> masses(natoms,1.0);\n  std::vector<double> forces(3*natoms,0.0);\n  std::vector<double> virial(9,0.0);\n\n\n  p.cmd((char*)\"setNatoms\",&natoms);\n  p.cmd((char*)\"init\",NULL);\n  p.cmd((char*)\"readInputLine\",(char*)\"d: DISTANCE ATOMS=1,2\");\n  p.cmd((char*)\"readInputLine\",(char*)\"PRINT ARG=d FILE=COLVAR RESTART=YES\");\n  int step=1;\n  p.cmd((char*)\"setStep\",&step);\n  p.cmd((char*)\"setPositions\",&positions[0]);\n  p.cmd((char*)\"setMasses\",&masses[0]);\n  p.cmd((char*)\"setForces\",&forces[0]);\n  p.cmd((char*)\"setVirial\",&virial[0]);\n  p.cmd((char*)\"calc\",NULL);\n}\n\nint main(){\n  std::ofstream of(\"finished\");\n// C++ version\n  {\n    of<<\"C++\\n\";\n    if(!PLMD::Plumed::installed()) plumed_error();\n \n    {\n      PLMD::Plumed p;\n      if(!p) plumed_error();\n      if(!p.valid()) plumed_error();\n      testmecpp(p);\n    }\n\n// test valid\n    {\n      PLMD::Plumed p(PLMD::Plumed::makeInvalid());\n      if(p) plumed_error();\n    }\n\n// test conversions to void\n    {\n      PLMD::Plumed p;\n      void* x(p.toVoid());\n      PLMD::Plumed q(x);\n      testmecpp(q);\n    }\n\n// test copy\n    {\n      std::unique_ptr<PLMD::Plumed> p(new PLMD::Plumed());\n      PLMD::Plumed q;\n      testmecpp(q);\n      q=*p;\n      p.reset();\n      testmecpp(q);\n    }\n\n    {\n// test move semantics\n      PLMD::Plumed p;\n      PLMD::Plumed q(std::move(p));\n      testmecpp(q);\n    }\n\n    {\n      PLMD::Plumed p,q;\n      q=std::move(p);\n      testmecpp(q);\n    }\n\n    {\n// test dlopen\n      PLMD::Plumed p(PLMD::Plumed::dlopen(std::getenv(\"PLUMED_KERNEL\")));\n      testmecpp(p);\n    }\n// test use_count\n    {\n      std::unique_ptr<PLMD::Plumed> p(new PLMD::Plumed);\n      if(!*p) plumed_error();\n      if(p->useCount()!=1) plumed_error();\n      auto q=*p;\n      if(p->useCount()!=2) plumed_error();\n      p.reset();\n      if(q.useCount()!=1) plumed_error();\n      testmecpp(q);\n    }\n\n    if(PLMD::Plumed::ginitialized()) plumed_error();\n    PLMD::Plumed::gcreate();\n    if(!PLMD::Plumed::ginitialized()) plumed_error();\n    PLMD::Plumed fromglobal(PLMD::Plumed::global());\n    testmecpp(fromglobal);\n    PLMD::Plumed::gfinalize();\n    if(PLMD::Plumed::ginitialized()) plumed_error();\n\n    PLMD::Plumed::gcreate();\n    if(!PLMD::Plumed::gvalid()) plumed_error();\n    testme(PLMD::Plumed::gcmd);\n    PLMD::Plumed::gfinalize();\n  }\n  {\n    of<<\"C++ conversions\\n\";\n\n    {\n      char f[32];\n      PLMD::Plumed p;\n      p.toFortran(f);\n      testme(f,plumed_f_cmd);\n    }\n\n    {\n      char ff[32];\n      plumed_f_create(ff);\n      PLMD::Plumed fromf(ff);\n      testmecpp(fromf);\n      plumed_f_finalize(ff);\n\n      plumed c=plumed_create();\n      PLMD::Plumed fromc(c);\n      testmecpp(fromc);\n      plumed_finalize(c);\n    }\n    \n    {\n      char ff[32];\n      plumed_f_create(ff);\n// convert from fortran\n      PLMD::Plumed fromf(ff);\n      plumed_f_finalize(ff);\n      testmecpp(fromf);\n      if(!fromf || fromf.useCount()!=1) plumed_error();\n\n      plumed c=plumed_create();\n      PLMD::Plumed fromc(c);\n      plumed_finalize(c);\n      testmecpp(fromc);\n    }\n    \n  }\n  {\n// C version\n    of<<\"C\\n\";\n    if(!plumed_installed()) plumed_error();\n// test valid\n    {\n      plumed p=plumed_create_invalid();\n      if(plumed_valid(p)) plumed_error();\n      plumed_finalize(p);\n    }\n// test conversion to void\n    {\n      plumed p=plumed_create();\n      void* x=plumed_c2v(p);\n      plumed q=plumed_create_reference_v(x);\n      testme(q,plumed_cmd);\n      plumed_finalize(q);\n      plumed_finalize(p);\n    }\n    plumed p=plumed_create();\n    testme(p,plumed_cmd);\n    plumed_finalize(p);\n\n    {\n// test dlopen\n      plumed p=plumed_create_dlopen(std::getenv(\"PLUMED_KERNEL\"));\n      testme(p,plumed_cmd);\n      plumed_finalize(p);\n    }\n// test use_count\n    {\n      plumed p=plumed_create();\n      if(plumed_use_count(p)!=1) plumed_error();\n      plumed q=plumed_create_reference(p);\n      if(plumed_use_count(p)!=2) plumed_error();\n      plumed_finalize(p);\n      if(plumed_use_count(q)!=1) plumed_error();\n      testme(q,plumed_cmd);\n      plumed_finalize(q);\n    }\n\n    if(plumed_ginitialized()) plumed_error();\n    plumed_gcreate();\n    if(!plumed_gvalid()) plumed_error();\n    if(!plumed_ginitialized()) plumed_error();\n    testme(plumed_global(),plumed_cmd);\n    plumed_gfinalize();\n    if(plumed_ginitialized()) plumed_error();\n\n    plumed_gcreate();\n    testme(plumed_gcmd);\n    plumed_gfinalize();\n  }\n  {\n// C version with convertions from/to fortran\n    of<<\"C conversions\\n\";\n    char f[32];\n    plumed p=plumed_create();\n    plumed_c2f(p,f);\n    testme(f,plumed_f_cmd);\n    plumed_finalize(plumed_f2c(f));\n  }\n  {\n// Fortran version\n    of<<\"fortran\\n\";\n    int inst=0;\n    plumed_f_installed(&inst); if(!inst) plumed_error();\n    char p[32];\n    plumed_f_create(p);\n    testme(p,plumed_f_cmd);\n    plumed_f_finalize(p);\n\n    {\n// test dlopen\n      char p[32];\n      plumed_f_create_dlopen(std::getenv(\"PLUMED_KERNEL\"),p);\n      testme(p,plumed_f_cmd);\n      plumed_f_finalize(p);\n    }\n// test use_count\n    {\n      char p[32],q[32];\n      int count;\n      plumed_f_create(p);\n      plumed_f_use_count(p,&count);\n      if(count!=1) plumed_error();\n      plumed_f_create_reference(p,q);\n      plumed_f_use_count(p,&count);\n      if(count!=2) plumed_error();\n      plumed_f_finalize(p);\n      plumed_f_use_count(q,&count);\n      if(count!=1) plumed_error();\n      testme(q,plumed_f_cmd);\n      plumed_f_finalize(q);\n    }\n\n    char p2[32];\n    int ini;\n    plumed_f_ginitialized(&ini); if(ini) plumed_error();\n    plumed_f_gcreate();\n    plumed_f_ginitialized(&ini); if(!ini) plumed_error();\n    plumed_f_global(p2);\n    testme(p2,plumed_f_cmd);\n    plumed_f_gfinalize();\n    plumed_f_ginitialized(&ini); if(ini) plumed_error();\n\n    plumed_f_gcreate();\n    plumed_f_gvalid(&ini); if(!ini) plumed_error();\n    testme(plumed_f_gcmd);\n    plumed_f_gfinalize();\n  }\n  {\n// Fortran version _\n    of<<\"fortran_\\n\";\n    int inst=0;\n    plumed_f_installed_(&inst); if(!inst) plumed_error();\n    char p[32];\n    plumed_f_create_(p);\n    testme(p,plumed_f_cmd_);\n    plumed_f_finalize_(p);\n\n    {\n// test dlopen\n      char p[32];\n      plumed_f_create_dlopen_(std::getenv(\"PLUMED_KERNEL\"),p);\n      testme(p,plumed_f_cmd_);\n      plumed_f_finalize_(p);\n    }\n// test use_count\n    {\n      char p[32],q[32];\n      int count;\n      plumed_f_create_(p);\n      plumed_f_use_count_(p,&count);\n      if(count!=1) plumed_error();\n      plumed_f_create_reference_(p,q);\n      plumed_f_use_count_(p,&count);\n      if(count!=2) plumed_error();\n      plumed_f_finalize_(p);\n      plumed_f_use_count_(q,&count);\n      if(count!=1) plumed_error();\n      testme(q,plumed_f_cmd_);\n      plumed_f_finalize_(q);\n    }\n\n    char p2[32];\n    int ini;\n    plumed_f_ginitialized_(&ini); if(ini) plumed_error();\n    plumed_f_gcreate_();\n    plumed_f_ginitialized_(&ini); if(!ini) plumed_error();\n    plumed_f_global_(p2);\n    testme(p2,plumed_f_cmd_);\n    plumed_f_gfinalize_();\n    plumed_f_ginitialized_(&ini); if(ini) plumed_error();\n\n    plumed_f_gcreate_();\n    plumed_f_gvalid_(&ini); if(!ini) plumed_error();\n    testme(plumed_f_gcmd_);\n    plumed_f_gfinalize_();\n  }\n  {\n// Fortran version __\n    of<<\"fortran__\\n\";\n    int inst=0;\n    plumed_f_installed__(&inst); if(!inst) plumed_error();\n    char p[32];\n    plumed_f_create__(p);\n    testme(p,plumed_f_cmd__);\n    plumed_f_finalize__(p);\n\n    {\n// test dlopen\n      char p[32];\n      plumed_f_create_dlopen__(std::getenv(\"PLUMED_KERNEL\"),p);\n      testme(p,plumed_f_cmd__);\n      plumed_f_finalize__(p);\n    }\n// test use_count\n    {\n      char p[32],q[32];\n      int count;\n      plumed_f_create__(p);\n      plumed_f_use_count__(p,&count);\n      if(count!=1) plumed_error();\n      plumed_f_create_reference__(p,q);\n      plumed_f_use_count__(p,&count);\n      if(count!=2) plumed_error();\n      plumed_f_finalize__(p);\n      plumed_f_use_count__(q,&count);\n      if(count!=1) plumed_error();\n      testme(q,plumed_f_cmd__);\n      plumed_f_finalize__(q);\n    }\n\n    char p2[32];\n    int ini;\n    plumed_f_ginitialized__(&ini); if(ini) plumed_error();\n    plumed_f_gcreate__();\n    plumed_f_ginitialized__(&ini); if(!ini) plumed_error();\n    plumed_f_global__(p2);\n    testme(p2,plumed_f_cmd__);\n    plumed_f_gfinalize__();\n    plumed_f_ginitialized__(&ini); if(ini) plumed_error();\n\n    plumed_f_gcreate__();\n    plumed_f_gvalid__(&ini); if(!ini) plumed_error();\n    testme(plumed_f_gcmd__);\n    plumed_f_gfinalize__();\n  }\n  {\n// Fortran version\n    of<<\"FORTRAN\\n\";\n    int inst=0;\n    PLUMED_F_INSTALLED(&inst); if(!inst) plumed_error();\n    char p[32];\n    PLUMED_F_CREATE(p);\n    testme(p,PLUMED_F_CMD);\n    PLUMED_F_FINALIZE(p);\n\n    {\n// test dlopen\n      char p[32];\n      PLUMED_F_CREATE_DLOPEN(std::getenv(\"PLUMED_KERNEL\"),p);\n      testme(p,PLUMED_F_CMD);\n      PLUMED_F_FINALIZE(p);\n    }\n// test use_count\n    {\n      char p[32],q[32];\n      int count;\n      PLUMED_F_CREATE(p);\n      PLUMED_F_USE_COUNT(p,&count);\n      if(count!=1) plumed_error();\n      PLUMED_F_CREATE_REFERENCE(p,q);\n      PLUMED_F_USE_COUNT(p,&count);\n      if(count!=2) plumed_error();\n      PLUMED_F_FINALIZE(p);\n      PLUMED_F_USE_COUNT(q,&count);\n      if(count!=1) plumed_error();\n      testme(q,PLUMED_F_CMD);\n      PLUMED_F_FINALIZE(q);\n    }\n\n    char p2[32];\n    int ini;\n    PLUMED_F_GINITIALIZED(&ini); if(ini) plumed_error();\n    PLUMED_F_GCREATE();\n    PLUMED_F_GINITIALIZED(&ini); if(!ini) plumed_error();\n    PLUMED_F_GLOBAL(p2);\n    testme(p2,PLUMED_F_CMD);\n    PLUMED_F_GFINALIZE();\n    PLUMED_F_GINITIALIZED(&ini); if(ini) plumed_error();\n\n    PLUMED_F_GCREATE();\n    PLUMED_F_GVALID(&ini); if(!ini) plumed_error();\n    testme(PLUMED_F_GCMD);\n    PLUMED_F_GFINALIZE();\n  }\n  {\n// Fortran version _\n    of<<\"FORTRAN_\\n\";\n    int inst=0;\n    PLUMED_F_INSTALLED_(&inst); if(!inst) plumed_error();\n    char p[32];\n    PLUMED_F_CREATE_(p);\n    testme(p,PLUMED_F_CMD_);\n    PLUMED_F_FINALIZE_(p);\n\n    {\n// test dlopen\n      char p[32];\n      PLUMED_F_CREATE_DLOPEN_(std::getenv(\"PLUMED_KERNEL\"),p);\n      testme(p,PLUMED_F_CMD_);\n      PLUMED_F_FINALIZE_(p);\n    }\n// test use_count\n    {\n      char p[32],q[32];\n      int count;\n      PLUMED_F_CREATE_(p);\n      PLUMED_F_USE_COUNT_(p,&count);\n      if(count!=1) plumed_error();\n      PLUMED_F_CREATE_REFERENCE_(p,q);\n      PLUMED_F_USE_COUNT_(p,&count);\n      if(count!=2) plumed_error();\n      PLUMED_F_FINALIZE_(p);\n      PLUMED_F_USE_COUNT_(q,&count);\n      if(count!=1) plumed_error();\n      testme(q,PLUMED_F_CMD_);\n      PLUMED_F_FINALIZE_(q);\n    }\n\n    char p2[32];\n    int ini;\n    PLUMED_F_GINITIALIZED_(&ini); if(ini) plumed_error();\n    PLUMED_F_GCREATE_();\n    PLUMED_F_GINITIALIZED_(&ini); if(!ini) plumed_error();\n    PLUMED_F_GLOBAL_(p2);\n    testme(p2,PLUMED_F_CMD_);\n    PLUMED_F_GFINALIZE_();\n    PLUMED_F_GINITIALIZED_(&ini); if(ini) plumed_error();\n\n    PLUMED_F_GCREATE_();\n    PLUMED_F_GVALID_(&ini); if(!ini) plumed_error();\n    testme(PLUMED_F_GCMD_);\n    PLUMED_F_GFINALIZE_();\n  }\n  {\n// Fortran version __\n    of<<\"FORTRAN__\\n\";\n    int inst=0;\n    PLUMED_F_INSTALLED__(&inst); if(!inst) plumed_error();\n    char p[32];\n    PLUMED_F_CREATE__(p);\n    testme(p,PLUMED_F_CMD__);\n    PLUMED_F_FINALIZE__(p);\n\n    {\n// test dlopen\n      char p[32];\n      PLUMED_F_CREATE_DLOPEN__(std::getenv(\"PLUMED_KERNEL\"),p);\n      testme(p,PLUMED_F_CMD__);\n      PLUMED_F_FINALIZE__(p);\n    }\n// test use_count\n    {\n      char p[32],q[32];\n      int count;\n      PLUMED_F_CREATE__(p);\n      PLUMED_F_USE_COUNT__(p,&count);\n      if(count!=1) plumed_error();\n      PLUMED_F_CREATE_REFERENCE__(p,q);\n      PLUMED_F_USE_COUNT__(p,&count);\n      if(count!=2) plumed_error();\n      PLUMED_F_FINALIZE__(p);\n      PLUMED_F_USE_COUNT__(q,&count);\n      if(count!=1) plumed_error();\n      testme(q,PLUMED_F_CMD__);\n      PLUMED_F_FINALIZE__(q);\n    }\n\n    char p2[32];\n    int ini;\n    PLUMED_F_GINITIALIZED__(&ini); if(ini) plumed_error();\n    PLUMED_F_GCREATE__();\n    PLUMED_F_GINITIALIZED__(&ini); if(!ini) plumed_error();\n    PLUMED_F_GLOBAL__(p2);\n    testme(p2,PLUMED_F_CMD__);\n    PLUMED_F_GFINALIZE__();\n    PLUMED_F_GINITIALIZED_(&ini); if(ini) plumed_error();\n\n    PLUMED_F_GCREATE__();\n    PLUMED_F_GVALID_(&ini); if(!ini) plumed_error();\n    testme(PLUMED_F_GCMD__);\n    PLUMED_F_GFINALIZE__();\n  }\n\n  of<<\"finished\\n\";\n\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/patches/amber18.diff": "patch -u -l -b -F 5 -N --suffix=.preplumed \"./src/pmemd/src/f90depends\" << \\EOF_EOF\n--- ./src/pmemd/src/f90depends.preplumed\t2019-06-07 02:45:26.266309842 +0300\n+++ ./src/pmemd/src/f90depends\t2019-06-07 02:45:26.266309842 +0300\n@@ -1247,10 +1247,12 @@\n runmd$(OSFX): parallel_processor$(OSFX)\n runmd$(OSFX): pme_recip_midpoint$(OSFX)\n runmd$(OSFX): dbg_arrays$(OSFX)\n runmd$(OSFX): copyright.i\n runmd$(OSFX): dbg_arrays.i\n+runmd$(OSFX): Plumed_init.inc\n+runmd$(OSFX): Plumed_force.inc\n runmin$(OSFX): prmtop_dat$(OSFX)\n runmin$(OSFX): constraints$(OSFX)\n runmin$(OSFX): pmemd_lib$(OSFX)\n runmin$(OSFX): extra_pnts_nb14$(OSFX)\n runmin$(OSFX): file_io$(OSFX)\nEOF_EOF\npatch -u -l -b -F 5 -N --suffix=.preplumed \"./src/pmemd/src/Makefile\" << \\EOF_EOF\n--- ./src/pmemd/src/Makefile.preplumed\t2019-06-07 02:45:26.266309842 +0300\n+++ ./src/pmemd/src/Makefile\t2019-06-07 02:45:26.266309842 +0300\n@@ -29,10 +29,15 @@\n MIC_OFFLOAD_TOKEN=DMIC_offload\n \n # Platform-specific info should be found in ../../config.h\n include $(CONFIG_FILE)\n \n+# PLUMED\n+ifdef PLUMED_INCLUDE_FILE\n+include $(PLUMED_INCLUDE_FILE)\n+endif\n+\n .NOTPARALLEL: cuda_SPFP cuda_DPFP pmemd.cuda_SPFP$(SFX) pmemd.cuda_DPFP$(SFX)\n \n OBJS=   gbl_constants$(OSFX) gbl_datatypes$(OSFX) state_info$(OSFX) file_io_dat$(OSFX) \\\n         mdin_ctrl_dat$(OSFX) mdin_emil_dat$(OSFX) mdin_ewald_dat$(OSFX) mdin_debugf_dat$(OSFX) prmtop_dat$(OSFX) \\\n         inpcrd_dat$(OSFX) dynamics_dat$(OSFX) emil$(OSFX) img$(OSFX) nbips$(OSFX) offload_allocation$(OSFX) \\\n@@ -107,53 +112,59 @@\n \n mic2: configured_mic2 $(BINDIR)/pmemd.MPI$(SFX)\n \n mic_offload: configured_mic_offload $(BINDIR)/pmemd.mic_offload.MPI$(SFX)\n \n-$(BINDIR)/pmemd$(SFX): $(OBJS) $(EMIL) $(NFE_OBJECTS)\n+$(BINDIR)/pmemd$(SFX): $(OBJS) $(EMIL) $(NFE_OBJECTS) $(PLUMED_DEPENDENCIES)\n \t$(PMEMD_LD) $(PMEMD_FOPTFLAGS) $(LDOUT)$@ $(OBJS) -L$(LIBDIR) \\\n-    $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS)\n+    $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS) $(PLUMED_LOAD)\n \n-$(BINDIR)/pmemd.MPI$(SFX): $(OBJS) $(EMIL) $(NFE_OBJECTS)\n+$(BINDIR)/pmemd.MPI$(SFX): $(OBJS) $(EMIL) $(NFE_OBJECTS) $(PLUMED_DEPENDENCIES)\n \t$(PMEMD_LD) $(PMEMD_FOPTFLAGS) $(LDOUT)$@ $(OBJS) -L$(LIBDIR) \\\n-    $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS)\n+    $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS) $(PLUMED_LOAD)\n \n-$(BINDIR)/pmemd.mic_native$(SFX): $(OBJS) $(EMIL) $(NFE_OBJECTS)\n+$(BINDIR)/pmemd.mic_native$(SFX): $(OBJS) $(EMIL) $(NFE_OBJECTS) $(PLUMED_DEPENDENCIES)\n \t$(PMEMD_LD) $(PMEMD_FOPTFLAGS) $(LDOUT)$@ $(OBJS) -L$(LIBDIR) $(NETCDFLIBF) \\\n-      $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS)\n+      $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS) $(PLUMED_LOAD)\n \n-$(BINDIR)/pmemd.mic_offload.MPI$(SFX): $(OBJS) $(EMIL)\n+$(BINDIR)/pmemd.mic_offload.MPI$(SFX): $(OBJS) $(EMIL) $(PLUMED_DEPENDENCIES)\n \t$(PMEMD_LD) $(PMEMD_FOPTFLAGS) $(LDOUT)$@ $(OBJS) -L$(LIBDIR) $(NETCDFLIBF) \\\n-      $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS)\n+      $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS) $(PLUMED_LOAD)\n \n-$(BINDIR)/pmemd.mic_native.MPI$(SFX): $(OBJS) $(EMIL)\n+$(BINDIR)/pmemd.mic_native.MPI$(SFX): $(OBJS) $(EMIL) $(PLUMED_DEPENDENCIES)\n \t$(PMEMD_LD) $(PMEMD_FOPTFLAGS) $(LDOUT)$@ $(OBJS) -L$(LIBDIR) $(NETCDFLIBF) \\\n-      $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS)\n+      $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS) $(PLUMED_LOAD)\n \n-$(BINDIR)/pmemd.cuda_SPFP$(SFX): $(OBJS) cuda_spfp_libs $(EMIL) $(NFE_OBJECTS)\n+$(BINDIR)/pmemd.cuda_SPFP$(SFX): $(OBJS) cuda_spfp_libs $(EMIL) $(NFE_OBJECTS) $(PLUMED_DEPENDENCIES)\n \t$(PMEMD_LD) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(LDOUT)$@ $(OBJS) \\\n-      $(PMEMD_CU_LIBS) -L$(LIBDIR) $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS)\n+      $(PMEMD_CU_LIBS) -L$(LIBDIR) $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS) $(PLUMED_LOAD)\n \n-$(BINDIR)/pmemd.cuda_SPFP.MPI$(SFX): $(OBJS) cuda_spfp_libs $(EMIL) $(NFE_OBJECTS)\n+$(BINDIR)/pmemd.cuda_SPFP.MPI$(SFX): $(OBJS) cuda_spfp_libs $(EMIL) $(NFE_OBJECTS) $(PLUMED_DEPENDENCIES)\n \t$(PMEMD_LD) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(LDOUT)$@ $(OBJS) \\\n-     $(PMEMD_CU_LIBS) -L$(LIBDIR) $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS)\n+     $(PMEMD_CU_LIBS) -L$(LIBDIR) $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS) $(PLUMED_LOAD)\n \n-$(BINDIR)/pmemd.cuda_DPFP$(SFX): $(OBJS) cuda_dpfp_libs $(EMIL) $(NFE_OBJECTS)\n+$(BINDIR)/pmemd.cuda_DPFP$(SFX): $(OBJS) cuda_dpfp_libs $(EMIL) $(NFE_OBJECTS) $(PLUMED_DEPENDENCIES)\n \t$(PMEMD_LD) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(LDOUT)$@ $(OBJS) \\\n-      $(PMEMD_CU_LIBS) -L$(LIBDIR) $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS)\n+      $(PMEMD_CU_LIBS) -L$(LIBDIR) $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS) $(PLUMED_LOAD)\n \n-$(BINDIR)/pmemd.cuda_DPFP.MPI$(SFX): $(OBJS) cuda_dpfp_libs $(EMIL) $(NFE_OBJECTS)\n+$(BINDIR)/pmemd.cuda_DPFP.MPI$(SFX): $(OBJS) cuda_dpfp_libs $(EMIL) $(NFE_OBJECTS) $(PLUMED_DEPENDENCIES)\n \t$(PMEMD_LD) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(LDOUT)$@ $(OBJS) \\\n-     $(PMEMD_CU_LIBS) -L$(LIBDIR) $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS)\n+     $(PMEMD_CU_LIBS) -L$(LIBDIR) $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS) $(PLUMED_LOAD)\n \n-$(BINDIR)/pmemd.cuda_SPXP$(SFX): $(OBJS) cuda_spxp_libs $(EMIL) $(NFE_OBJECTS)\n+$(BINDIR)/pmemd.cuda_SPXP$(SFX): $(OBJS) cuda_spxp_libs $(EMIL) $(NFE_OBJECTS) $(PLUMED_DEPENDENCIES)\n \t$(PMEMD_LD) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(LDOUT)$@ $(OBJS) \\\n-      $(PMEMD_CU_LIBS) -L$(LIBDIR) $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS)\n+      $(PMEMD_CU_LIBS) -L$(LIBDIR) $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS) $(PLUMED_LOAD)\n \n-$(BINDIR)/pmemd.cuda_SPXP.MPI$(SFX): $(OBJS) cuda_spxp_libs $(EMIL) $(NFE_OBJECTS)\n+$(BINDIR)/pmemd.cuda_SPXP.MPI$(SFX): $(OBJS) cuda_spxp_libs $(EMIL) $(NFE_OBJECTS) $(PLUMED_DEPENDENCIES)\n \t$(PMEMD_LD) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(LDOUT)$@ $(OBJS) \\\n-     $(PMEMD_CU_LIBS) -L$(LIBDIR) $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS)\n+     $(PMEMD_CU_LIBS) -L$(LIBDIR) $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS) $(PLUMED_LOAD)\n+\n+# PLUMED\n+ifndef PLUMED_INCLUDE_FILE\n+Plumed.o: Plumed.c\n+\t$(PMEMD_CC) $(CFLAGS) $(AMBERCFLAGS) -o Plumed.o -c Plumed.c\n+endif\n \n EMIL:\n \t$(MAKE) -C ../../../AmberTools/src/emil install\n \n depends:\nEOF_EOF\npatch -u -l -b -F 5 -N --suffix=.preplumed \"./src/pmemd/src/mdin_ctrl_dat.F90\" << \\EOF_EOF\n--- ./src/pmemd/src/mdin_ctrl_dat.F90.preplumed\t2019-09-04 16:00:08.961863395 +0300\n+++ ./src/pmemd/src/mdin_ctrl_dat.F90\t2019-09-04 15:56:51.620251830 +0300\n@@ -35,10 +35,11 @@\n                                 scaledMD, icnstph, ntcnstph, ntrelax, icnste, &\n                                 ntcnste, ntrelaxe, ntwf, &\n                                 iphmd, & !PHMD\n                                 igamd,irest_gamd,iE,iVm,igamdlag,ntcmd,nteb, &\n                                 ntcmdprep,ntebprep, &\n+                                plumed, & ! PLUMED\n                                 w_amd, emil_do_calc,isgld,isgsta,isgend,fixcom, &\n                                 tishake, emil_sc,iemap, lj1264, efn,mcwat,mcint,&\n                                 nucat, & ! gbneck2nu: check if atom belong to nucleic or not\n                                 mcrescyc,nmd,nmc,mcverbosity, &\n                                 infe, & ! added by FENG PAN\n@@ -75,13 +76,14 @@\n                                 mask_from_ref, mbar_states,           &   ! 96\n                                 geq_nstep, ginit_vel,  gsyn_mass, & !99\n                                 gremd_acyc, gti_cpu_output, gti_add_sc, & !102\n                                 mcint,nmd,mcrescyc,nmc,mcverbosity, & !107\n                                 ineb,skmin,skmax,tmode,vv,nebfreq,  & !113\n-                                iphmd, midpoint !115\n+                                iphmd, midpoint, & !115\n+                                plumed !116 PLUMED\n \n-  integer, parameter    :: mdin_ctrl_int_cnt = 115\n+  integer, parameter    :: mdin_ctrl_int_cnt = 116 ! 115 + 1 (with PLUMED)\n \n   save  :: / mdin_ctrl_int /\n \n   ! Note - ndfmin is not intended to be settable by the user.  We permit it to\n   !        show up in the namelist but issue a warning and ignore it.\n@@ -177,10 +179,13 @@\n   ! Amber masks\n \n   character(256), public   :: restraintmask, bellymask, timask1, timask2, &\n                               crgmask, noshakemask, scmask1, scmask2\n \n+  ! PLUMED\n+  character(256), public   :: plumedfile\n+\n   ! Note - gb_alpha, gb_beta, gb_gamma, gb_fs_max, gb_kappa and gb_neckscale\n   !        would be better factored elsewhere, but as usual the sander order\n   !        of operations makes this difficult...\n \n   ! Master-only PMEMD-specific control variables:\n@@ -275,10 +280,11 @@\n                         lastist, lastrst, no_intermolecular_bonds, &\n                         ene_avg_sampling, &\n                         amber7_compat, amber8_mdout_format, &\n                         mdinfo_flush_interval, &\n                         mdout_flush_interval, &\n+                        plumed, plumedfile, & ! PLUMED\n                         dbg_atom_redistribution, &\n                         loadbal_verbose, &\n                         es_cutoff, vdw_cutoff, &\n                         dtemp, dxm, heat, alpb, arad, &\n                         ifqnt, icnstph, ntcnstph, solvph, ntrelax, &\n@@ -519,10 +525,15 @@\n   itgtmd = 0            ! not supported...\n   tgtrmsd = 0.d0        ! not actually used...\n   tgtmdfrc = 0.d0       ! not actually used...\n   tgtrmsmask = ''       ! not actually used...\n   tgtfitmask = ''       ! not actually used...\n+\n+  ! PLUMED\n+  plumed = 0\n+  plumedfile = 'plumed.dat'\n+\n   maxcyc = 1\n   ncyc = 10\n   ntmin = 1\n   dx0 = 0.01d0\n   drms = 1.0d-4\n@@ -1512,10 +1523,16 @@\n     write(mdout, '(a,a)') error_hdr, 'tgtfitmask is only used if itgtmd != 0!'\n     inerr = 1\n   end if\n #endif\n \n+  ! PLUMED\n+  if (plumed .eq. 1) then\n+      write(mdout, '(a)') 'PLUMED is on'\n+      write(mdout, '(a,a)') 'PLUMED file is ', plumedfile\n+  endif\n+\n   if (ifqnt .ne. 0) then\n     write(mdout, '(a,a)') error_hdr, 'ifqnt must == 0!'\n     write(mdout, '(a,a,a)') extra_line_hdr, prog_name, &\n       ' does not support QM/MM calculations.'\n     write(mdout, '(a)') use_sander\n@@ -2885,10 +2902,14 @@\n   call mpi_bcast(imin, mdin_ctrl_int_cnt, mpi_integer, 0, &\n                  pmemd_comm, err_code_mpi)\n   call mpi_bcast(dielc, mdin_ctrl_dbl_cnt, mpi_double_precision, 0, &\n                  pmemd_comm, err_code_mpi)\n \n+  ! PLUMED\n+  call mpi_bcast(plumed, 1, mpi_integer, 0, pmemd_comm, err_code_mpi)\n+  call mpi_bcast(plumedfile, 256, mpi_character, 0, pmemd_comm, err_code_mpi)\n+\n ! Broadcast the NO_NTT3_SYNC Flag\n   call mpi_bcast(no_ntt3_sync, 1, mpi_integer, 0, pmemd_comm, err_code_mpi)\n \n ! Broadcast usemidpoint\n   call mpi_bcast(usemidpoint, 1, mpi_logical, 0, mpi_comm_world, err_code_mpi)\nEOF_EOF\npatch -u -l -b -F 5 -N --suffix=.preplumed \"./src/pmemd/src/Plumed.c\" << \\EOF_EOF\n--- ./src/pmemd/src/Plumed.c.preplumed\t1970-01-01 03:00:00.000000000 +0300\n+++ ./src/pmemd/src/Plumed.c\t2019-09-04 17:01:33.015986691 +0300\n@@ -0,0 +1,44 @@\n+/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+   Copyright (c) 2011-2019 The plumed team\n+   (see the PEOPLE file at the root of the distribution for a list of names)\n+\n+   See http://www.plumed.org for more information.\n+\n+   This file is part of plumed, version 2.\n+\n+   plumed is free software: you can redistribute it and/or modify\n+   it under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   plumed is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License\n+   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n+\n+/*\n+  Do not link plumed directly but rather do it at runtime\n+*/\n+#define __PLUMED_WRAPPER_LINK_RUNTIME 1\n+\n+/*\n+  Make sure the inline C++ interface is not included here.\n+  Should not be necessary, but it doesn't hurt.\n+*/\n+#define __PLUMED_WRAPPER_CXX 0\n+\n+/*\n+  Tell Plumed.h to emit the whole implementation\n+*/\n+#define __PLUMED_WRAPPER_IMPLEMENTATION 1\n+\n+/*\n+  Emit fortran wrappers\n+*/\n+#define __PLUMED_WRAPPER_FORTRAN 1\n+\n+#include \"Plumed.h\"\nEOF_EOF\npatch -u -l -b -F 5 -N --suffix=.preplumed \"./src/pmemd/src/Plumed_force.inc\" << \\EOF_EOF\n--- ./src/pmemd/src/Plumed_force.inc.preplumed\t2019-09-04 17:37:24.883213440 +0300\n+++ ./src/pmemd/src/Plumed_force.inc\t2019-09-10 18:01:05.364825443 +0300\n@@ -0,0 +1,85 @@\n+    call plumed_f_gcmd(\"setPositions\"//char(0), crd)\n+    call plumed_f_gcmd(\"setMasses\"//char(0), mass)\n+    call plumed_f_gcmd(\"setCharges\"//char(0), atm_qterm)\n+\n+\n+    if (using_pme_potential) then\n+        call plumed_f_gcmd(\"setEnergy\"//char(0), pme_pot_ene)\n+    else if (using_gb_potential) then\n+        call plumed_f_gcmd(\"setEnergy\"//char(0), gb_pot_ene)\n+    end if\n+\n+\n+#ifdef CUDA\n+    if (plumed_need_pot_enes > 0) then\n+        call plumed_f_gcmd(\"setForces\"//char(0), frc)\n+    else\n+        plumed_frc(:,:) = 0.d0\n+        call plumed_f_gcmd(\"setForces\"//char(0), plumed_frc)\n+    end if\n+#else\n+    call plumed_f_gcmd(\"setForces\"//char(0), frc)\n+#endif\n+\n+\n+    call plumed_f_gcmd(\"setStopFlag\"//char(0), plumed_stopflag)\n+\n+\n+    plumed_box = 0.0\n+\n+    if (ifbox == 0) then\n+      continue\n+    else if (ifbox == 1) then\n+      plumed_box(1,1) = pbc_box(1)\n+      plumed_box(2,2) = pbc_box(2)\n+      plumed_box(3,3) = pbc_box(3)\n+    else if (ifbox == 2) then\n+\n+      ! For a truncated octahedron, corresponding to a bcc lattice\n+      ! in AMBER convention, box(1) is the length of the lattice vector\n+      ! a is defined so as the bcc lattice is (a/2,a/2,a/2) (-a/2,-a/2,a/2)\n+      ! (a/2,-a/2,-a/2).\n+      plumed_box(1,1) = sqrt(1.0/3.0)*pbc_box(1)\n+      plumed_box(2,1) = sqrt(1.0/3.0)*pbc_box(1)\n+      plumed_box(3,1) = sqrt(1.0/3.0)*pbc_box(1)\n+      plumed_box(1,2) = -sqrt(1.0/3.0)*pbc_box(1)\n+      plumed_box(2,2) = -sqrt(1.0/3.0)*pbc_box(1)\n+      plumed_box(3,2) = sqrt(1.0/3.0)*pbc_box(1)\n+      plumed_box(1,3) = sqrt(1.0/3.0)*pbc_box(1)\n+      plumed_box(2,3) = -sqrt(1.0/3.0)*pbc_box(1)\n+      plumed_box(3,3) = -sqrt(1.0/3.0)*pbc_box(1)\n+    else\n+      write (6,*) \"!!!!! PLUMED ERROR: Only orthorhombic and truncted &\n+                   &octahedron cells are supported in this release.\"\n+      write (6,*) \"!!!!! ABORTING RUN\"\n+      call mexit(6, 1)\n+    endif\n+\n+\n+    plumed_virial=0.0\n+\n+    ! It's not completely clear where the factor 2.0 comes from.\n+    ! Anyway, I was able to match a change in press of 1000 bar with\n+    ! a corresponding SLOPE=66.02 added to VOLUME CV in PLUMED GB.\n+    plumed_virial(1,1)=2.0*virial(1)\n+    plumed_virial(2,2)=2.0*virial(2)\n+    plumed_virial(3,3)=2.0*virial(3)\n+\n+\n+    call plumed_f_gcmd(\"setVirial\"//char(0), plumed_virial)\n+    call plumed_f_gcmd(\"setBox\"//char(0), plumed_box)\n+\n+\n+    call plumed_f_gcmd(\"shareData\"//char(0), 0)\n+    call plumed_f_gcmd(\"performCalc\"//char(0), 0)\n+\n+\n+#ifdef MPI\n+    ! This is required since PLUMED only updates virial on master processor\n+    call mpi_bcast(plumed_virial, 9, mpi_double_precision, 0, pmemd_comm, err_code_mpi)\n+#endif\n+\n+\n+    virial(1)=0.5*plumed_virial(1,1)\n+    virial(2)=0.5*plumed_virial(2,2)\n+    virial(3)=0.5*plumed_virial(3,3)\nEOF_EOF\npatch -u -l -b -F 5 -N --suffix=.preplumed \"./src/pmemd/src/Plumed.h\" << \\EOF_EOF\n--- ./src/pmemd/src/Plumed.h.preplumed\t1970-01-01 03:00:00.000000000 +0300\n+++ ./src/pmemd/src/Plumed.h\t2019-09-04 17:02:14.518947783 +0300\n@@ -0,0 +1,2818 @@\n+/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+   Copyright (c) 2011-2019 The plumed team\n+   (see the PEOPLE file at the root of the distribution for a list of names)\n+\n+   See http://www.plumed.org for more information.\n+\n+   This file is part of plumed, version 2.\n+\n+   plumed is free software: you can redistribute it and/or modify\n+   it under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   plumed is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License\n+   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n+#ifndef __PLUMED_wrapper_Plumed_h\n+#define __PLUMED_wrapper_Plumed_h\n+\n+/*\n+  This header might be included more than once in order to provide\n+  the declarations and the definitions. The guard is thus closed before the end of the file\n+  (match this brace) {\n+  and a new guard is added for the definitions.\n+*/\n+\n+/**\n+\\page ReferencePlumedH Reference for interfacing MD codes with PLUMED\n+\n+  Plumed.h and Plumed.c contain the external plumed interface, which is used to\n+  integrate it with MD engines. This interface is very general, and is expected\n+  not to change across plumed versions. Plumed.c also implements a dummy version\n+  of the interface, so as to allow a code to be fully linked even if the plumed\n+  library is not available yet. These files could be directly included in the official\n+  host MD distribution. In this manner, it will be sufficient to link the plumed\n+  library at link time (on all systems) or directly at runtime (on systems where\n+  dynamic loading is enabled) to include plumed features.\n+\n+  Notice that in PLUMED 2.5 this interface has been rewritten in order to allow\n+  more debugging features and a better behavior in multithread environments.\n+  The interface is almost perfectly backward compatible, although it implements\n+  a few additional functions. See more details below.\n+\n+  Why is Plumed.c written in C and not C++? The reason is that the resulting Plumed.o\n+  needs to be linked with the host MD code immediately (whereas the rest of plumed\n+  could be linked a posteriori). Imagine the MD code is written in FORTRAN: when we\n+  link the Plumed.o file we would like not to need any C++ library linked. In this\n+  manner, we do not need to know which C++ compiler will be used to compile plumed.\n+  The C++ library is only linked to the \"rest\" of plumed, which actually uses it.\n+  Anyway, Plumed.c is written in such a manner to allow its compilation also in C++\n+  (C++ is a bit stricter than C). This will\n+  allow e.g. MD codes written in C++ to just incorporate Plumed.c (maybe renamed into\n+  Plumed.cpp), without the need of configuring a plain C compiler.\n+\n+  Plumed interface can be used from C, C++ and FORTRAN. Everything concerning plumed\n+  is hidden inside a single object type, which is described in C by a structure\n+  (struct \\ref plumed), in C++ by a class (PLMD::Plumed) and in FORTRAN by a\n+  fixed-length string (CHARACTER(LEN=32)). Obviously C++ can use both struct\n+  and class interfaces, but the second should be preferred since it will automatically take\n+  care of objects constructions and destructions. The reference interface\n+  is the C one, whereas FORTRAN and C++ interfaces are implemented as wrappers\n+  around it.\n+  In the C++ interface, all the routines are implemented as methods of PLMD::Plumed.\n+  In the C and FORTRAN interfaces, all the routines are named plumed_*, to\n+  avoid potential name clashes. Notice that the entire plumed library\n+  is implemented in C++, and it is hidden inside the PLMD namespace.\n+\n+  Handlers to the plumed object can be converted among different representations,\n+  to allow inter-operability among languages. In C, there are tools to convert\n+  to/from FORTRAN, whereas in C++ there are tools to convert to/from FORTRAN and C.\n+\n+  These handlers only contain a pointer to the real structure, so that\n+  when a plumed object is brought from one language to another,\n+  it brings a reference to the same environment.\n+\n+  Moreover, to simplify life in all cases where a single Plumed object is\n+  required for the entire simulation (which covers many of the practical\n+  applications with conventional MD codes) it is possible to take advantage\n+  of a global interface, which is implicitly referring to a unique global instance.\n+  The global object should still be initialized and finalized properly.\n+  This global object is obviously not usable in a multithread context.\n+\n+  As of PLUMED 2.5, the interface contains a reference counter that allows\n+  for a better control of plumed initializations and deallocations.\n+  This is particularly useful for the C++ interface that now\n+  behaves similarly to a primitive shared pointer and can be thus copied.\n+  In other languages, to use the reference counter correctly it is sufficient to\n+  remember the following rule: for any `plumed_create*` call, there should be a corresponding\n+  `plumed_finalize` call. More examples can be found below.\n+\n+  The basic method to send a message to plumed is\n+\\verbatim\n+  (C) plumed_cmd\n+  (C++) PLMD::Plumed::cmd\n+  (FORTRAN)  PLUMED_F_CMD\n+\\endverbatim\n+\n+  To initialize a plumed object, use:\n+\\verbatim\n+  (C)        plumed_create\n+  (C++)      (constructor of PLMD::Plumed)\n+  (FORTRAN)  PLUMED_F_CREATE\n+\\endverbatim\n+\n+  As of PLUMED 2.5, you can also initialize a plumed object using the following functions,\n+  that load a specific kernel:\n+\\verbatim\n+  (C)        plumed_create_dlopen\n+  (C++)      PLMD::Plumed::dlopen\n+  (FORTRAN)  PLUMED_F_CREATE_DLOPEN\n+\\endverbatim\n+\n+  To finalize a plumed object, use\n+\\verbatim\n+  (C)        plumed_finalize\n+  (C++)      (destructor of PLMD::Plumed)\n+  (FORTRAN)  PLUMED_F_FINALIZE\n+\\endverbatim\n+\n+  To access to the global-object, use\n+\\verbatim\n+  (C)        plumed_gcreate, plumed_gfinalize, plumed_gcmd\n+  (C++)      PLMD::Plumed::gcreate, PLMD::Plumed::gfinalize, PLMD::Plumed::gcmd\n+  (FORTRAN)  PLUMED_F_GCREATE, PLUMED_F_GFINALIZE, PLUMED_F_GCMD\n+\\endverbatim\n+\n+  To check if the global object has been initialized, use\n+\\verbatim\n+  (C)        plumed_ginitialized\n+  (C++)      PLMD::Plumed::ginitialized\n+  (FORTRAN)  PLUMED_F_GINITIALIZED\n+\\endverbatim\n+\n+  Notice that when using runtime binding the plumed library might be not available.\n+  In this case, plumed_create (and plumed_gcreate) will still succeed, but a subsequent\n+  call to plumed_cmd (or plumed_gcmd) would exit. In order to avoid this\n+  unpleasant situation you have two options.\n+\n+  First, you can check if plumed library is available before actually creating an object\n+  using this function:\n+\\verbatim\n+  (C)        plumed_installed\n+  (C++)      PLMD::Plumed::installed\n+  (FORTRAN)  PLUMED_F_INSTALLED\n+\\endverbatim\n+\n+  Alternatively, as of PLUMED 2.5, you can interrogate the just created plumed\n+  object using the following function:\n+\\verbatim\n+  (C)        plumed_valid\n+  (C++)      PLMD::Plumed::valid\n+  (FORTRAN)  PLUMED_F_VALID\n+\\endverbatim\n+\n+  If you want to create on purpose an invalid Plumed object (useful in C++ to postpone\n+  the loading of the library) you can use `Plumed p(Plumed::makeInvalid());`.\n+\n+  To know if the global object is valid instead you should use the following function:\n+\\verbatim\n+  (C)        plumed_gvalid\n+  (C++)      PLMD::Plumed::gvalid\n+  (FORTRAN)  PLUMED_F_GVALID\n+\\endverbatim\n+\n+  To convert handlers between different languages, use\n+\\verbatim\n+  (C)        plumed_c2f                 (C to FORTRAN)\n+  (C)        plumed_f2c                 (FORTRAN to C)\n+  (C++)      Plumed(plumed) constructor (C to C++)\n+  (C++)      operator plumed() cast     (C++ to C)\n+  (C++)      Plumed(char*)  constructor (FORTRAN to C++)\n+  (C++)      toFortran(char*)           (C++ to FORTRAN)\n+\\endverbatim\n+\n+  As of PLUMED 2.5, when using C or C++ we allow a user to explicitly store a plumed object as\n+  a void pointer (indeed: that's the only thing contained in a plumed object).\n+  This might be useful in case you do not want to include the Plumed.h header in some\n+  of your headers. In order to convert to/from void pointers you can use the following functions\n+\\verbatim\n+  (C)        plumed_v2c                 (void* to C)\n+  (C)        plumed_c2v                 (C to void*)\n+  (C++)      Plumed(void*) constructor  (void* to C++)\n+  (C++)      toVoid()                   (C++ to void*)\n+\\endverbatim\n+  Using the functions above is much safer than accessing directly the pointer contained in the \\ref plumed struct\n+  since, when compiling with debug options, it will check if the void pointer actually points to a plumed object.\n+\n+  As of PLUMED 2.5, we added a reference count. It is in practice possible\n+  to create multiple `plumed` object that refer to the same environment.\n+  This is done using the following functions\n+\\verbatim\n+  (C)        plumed_create_reference     (from a C object)\n+  (C)        plumed_create_reference_f   (from a FORTRAN object)\n+  (C)        plumed_create_reference_v   (from a void pointer)\n+  (FORTRAN)  plumed_f_create_reference   (from a FORTRAN object)\n+\\endverbatim\n+  In C++ references are managed automatically by constructors and destructor.\n+  In addition, you can manually manage them (with care!) using incref() and decref().\n+\n+  The interface of the FORTRAN functions is very similar to that of the C functions\n+  and is listed below:\n+\n+\\verbatim\n+  FORTRAN interface\n+    SUBROUTINE PLUMED_F_CREATE(p)\n+      CHARACTER(LEN=32), INTENT(OUT)   :: p\n+    SUBROUTINE PLUMED_F_CREATE_DLOPEN(p,path)\n+      CHARACTER(LEN=32), INTENT(OUT)   :: p\n+      CHARACTER(LEN=*),  INTENT(IN)    :: path\n+    SUBROUTINE PLUMED_F_CREATE_REFERENCE(p,r)\n+      CHARACTER(LEN=32), INTENT(OUT)   :: p\n+      CHARACTER(LEN=32), INTENT(IN)    :: r\n+    SUBROUTINE PLUMED_F_CREATE_INVALID(p)\n+      CHARACTER(LEN=32), INTENT(OUT)   :: p\n+    SUBROUTINE PLUMED_F_CMD(p,key,val)\n+      CHARACTER(LEN=32), INTENT(IN)    :: p\n+      CHARACTER(LEN=*),  INTENT(IN)    :: key\n+      UNSPECIFIED_TYPE,  INTENT(INOUT) :: val(*)\n+    SUBROUTINE PLUMED_F_FINALIZE(p)\n+      CHARACTER(LEN=32), INTENT(IN)    :: p\n+    SUBROUTINE PLUMED_F_INSTALLED(i)\n+      INTEGER,           INTENT(OUT)   :: i\n+    SUBROUTINE PLUMED_F_VALID(p,i)\n+      CHARACTER(LEN=32), INTENT(IN)    :: p\n+      INTEGER,           INTENT(OUT)   :: i\n+    SUBROUTINE PLUMED_F_USE_COUNT(p,i)\n+      CHARACTER(LEN=32), INTENT(IN)    :: p\n+      INTEGER,           INTENT(OUT)   :: i\n+    SUBROUTINE PLUMED_F_GLOBAL(p)\n+      CHARACTER(LEN=32), INTENT(OUT)   :: p\n+    SUBROUTINE PLUMED_F_GINITIALIZED(i)\n+      INTEGER,           INTENT(OUT)   :: i\n+    SUBROUTINE PLUMED_F_GCREATE()\n+    SUBROUTINE PLUMED_F_GCMD(key,val)\n+      CHARACTER(LEN=*), INTENT(IN)     :: key\n+      UNSPECIFIED_TYPE, INTENT(INOUT)  :: val(*)\n+    SUBROUTINE PLUMED_F_GFINALIZE()\n+    SUBROUTINE PLUMED_F_GVALID(i)\n+      INTEGER,           INTENT(OUT)   :: i\n+\\endverbatim\n+\n+  Almost all C functions have a corresponding FORTRAN function.\n+  As a simple mnemonic, if you know the name of the C function you can obtain the\n+  corresponding FORTRAN subroutine by adding `F_` after the `PLUMED_` prefix.\n+  In addition, all `plumed` objects are replaced by `CHARACTER(LEN=32)` objects\n+  holding the same information. These pointers basically contain a text representation\n+  of the stored pointer, that is suitable to be contained in a string.\n+  Finally, whenever a C function returns a value,\n+  the corresponding FORTRAN subroutine will have an additional `INTENT(OUT)` parameter\n+  passed as the its last argument.\n+\n+  When you compile the FORTRAN interface, wrapper functions are added with several possible\n+  name manglings, so you should not experience problems linking the plumed library with a FORTRAN file.\n+\n+\\section ReferencePlumedH-exceptions Error handling\n+\n+  In case an error is detected by PLUMED, either because of some user error, some internal bug,\n+  or some mistake in using the library, an exception will be thrown. The behavior is different depending if you use\n+  PLUMED from C/FORTRAN or from C++.\n+\n+  First of all, notice that access to PLUMED goes through three functions:\n+  - plumed_create: this, as of PLUMED 2.5, is guaranteed not to throw any exception. If there is a problem, it will\n+    just return a NULL pointer\n+  - plumed_cmd: this function might throw exceptions.\n+  - plumed_finalize: this is a destructor and is guaranteed not to throw any exception.\n+\n+  The following discussion concerns all the exceptions thrown by plumed_cmd.\n+\n+  If you use C/FORTRAN, you will basically have no way to intercept the exception and the program will just terminate.\n+\n+  If you use C++ but you are calling the C interface (e.g. \\ref plumed_cmd), then you might be\n+  able to catch the exceptions thrown by PLUMED. Notice that all the exceptions thrown by PLUMED inherit from std::exception,\n+  so you might want to catch it by reference. Notice however that there is a C layer between your C++ code and the PLUMED\n+  library. In principle, the stack unwinding performed during exception handling is undefined in C and might lead to problems\n+  that are system and compiler dependent. In addition to this, there might be troubles when combining different compilers\n+  or different standard libraries. E.g., if you MD code is linked against a given C++ library and PLUMED is linked against\n+  another one, the two std::exception types will differ and you won't be able to catch exceptions raised by PLUMED.\n+\n+  If you use C++ and you are calling the C++ interface (e.g. \\ref Plumed::cmd), as of PLUMED 2.5 we implemented a complete\n+  remapping of the exceptions thrown by PLUMED.  This solves both the problems mentioned above. In particular:\n+  - Instead of throwing an exception, PLUMED will return (using a \\ref plumed_nothrow_handler) the details about the occurred error.\n+  - An equivalent exception will be thrown within the inline PLUMED interface compiled with your MD code.\n+\n+  As a consequence, you will be able to combine different compilers and avoid stack unwinding in the C layer.\n+\n+  Notice that, even if you use \\ref Plumed::cmd, if you are loading a kernel <=2.4 any exception generated by PLUMED will\n+  leak through the C layer. This might lead to undefined behavior. If you are lucky (with some compiler it works!) and\n+  the exception arrives to C, PLUMED will catch it and rethrow it as it would do if you were using a kernel >=2.5.\n+\n+  The remapping of exceptions takes care of all the standard C++ exceptions plus all the exceptions raised within\n+  PLUMED. Unexpected exceptions that are derived from std::exception will be rethrown as std::exception.\n+  Notice that this implies some loss of information, since the original exception might have been of a different type.\n+  However, it also implies that the virtual table of the original exception won't be needed anymore. This allows to\n+  completely decouple the MD code from the PLUMED library.\n+\n+\\section ReferencePlumedH-2-5 New in PLUMED 2.5\n+\n+  The wrappers in PLUMED 2.5 have been completely rewritten with several improvements.\n+  The interface is almost perfectly backward compatible, although the behavior of C++ constructors\n+  has been modified slightly.\n+  In addition, a few new functions are introduced (explicitly marked in the documentation).\n+  As a consequence, if your code uses some of the new functions, you will not be able\n+  to link it directly with an older PLUMED library (though you will still be able to load\n+  an older PLUMED library at runtime). In addition, the reference counter changes slightly\n+  the behavior of the C++ methods used to interoperate with C and FORTRAN.\n+\n+  An important novelty is in the way the runtime loader is implemented.\n+  In particular, the loader works also if the symbols of the main executable are not exported.\n+  The proper functions from the kernel are indeed searched explicitly now using `dlsym`.\n+\n+  Some additional features can be enabled using suitable environment variables. In particular:\n+  - `PLUMED_LOAD_DEBUG` can be set to report more information about the loading process.\n+  - `PLUMED_LOAD_NAMESPACE` can be set to `LOCAL` to load the PLUMED kernel in a separate\n+    namespace. The default is global namespace, which is the same behavior of PLUMED <=2.4,\n+    and is consistent with what happens when linking PLUMED as a shared library.\n+  - `PLUMED_LOAD_NODEEPBIND` can be set to load the PLUMED kernel in not-deepbind mode. Deepbind\n+    mode implies that the symbols defined in the library are preferred to other symbols with the same name.\n+    Only works on systems supporting `RTLD_DEEPBIND` and is mostly for debugging purposes.\n+\n+  Another difference is that the implementation of the wrappers is now completely contained in the `Plumed.h`\n+  file. You can see that the `Plumed.c` is much simpler now and just includes `Plumed.h`. With a similar\n+  procedure you could compile the wrappers directly into your code making it unnecessary to link\n+  the libplumedWrapper.a library. The corresponding macros are still subject to change and are not documented here.\n+\n+  As written above, the plumed object now implements a reference counter.  Consider the following example\n+\\verbatim\n+  plumed p=plumed_create();\n+  plumed_cmd(p,\"init\",NULL);\n+  plumed q=plumed_create_reference(p);\n+  plumed_finalize(p);\n+// at this stage, object q still exists\n+  plumed_cmd(q,\"whatever\",NULL);\n+  plumed_finalize(q);\n+// now plumed has been really finalized\n+\\endverbatim\n+\n+  In other words, every \\ref plumed_create, \\ref plumed_create_dlopen, \\ref plumed_create_reference,\n+  \\ref plumed_create_reference_f, and \\ref plumed_create_reference_v call must be matched by a \\ref plumed_finalize.\n+  Notice that in C++ whenever an object goes out of scope the reference counter\n+  will be decreased. In addition, consider that conversion from C/FORTRAN/void* to C++ implies calling a C++ constructor, that\n+  is increases the number of references by one. Converting from C++ to C/FORTRAN/void* instead does not call any constructor,\n+  that is the number of references is unchanged.\n+\n+  The change in the behavior of C++ constructors means that the following code will behave in a backward incompatible manner:\n+\\verbatim\n+  plumed p=plumed_create();\n+  plumed_cmd(p,\"init\",NULL);\n+  Plumed q(p);\n+  plumed_finalize(p);\n+// at this stage, object q still exists with PLUMED 2.5\n+// on the other hand, with PLUMED 2.4 object q refers to an\n+// already finalized object\n+  q.cmd(\"whatever\",NULL);\n+\\endverbatim\n+\n+  Another difference is that the value of the variable `PLUMED_KERNEL` is read every time a new\n+  plumed object is instantiated. So, you might even use it to load different plumed versions\n+  simultaneously, although the preferred way to do this is using the function \\ref plumed_create_dlopen.\n+  Notice that if you want to load multiple versions simultaneously you should load them in a local namespace.\n+  \\ref plumed_create_dlopen does it automatically, whereas loading through env var `PLUMED_KERNEL` only does it if\n+  you also set env var `PLUMED_NAMESPACE=LOCAL`.\n+\n+  Finally, a few functions have been added, namely:\n+  - Functions to find if a plumed object is valid\n+    (\\ref plumed_valid(), \\ref plumed_gvalid(), \\ref PLMD::Plumed::valid(), and \\ref PLMD::Plumed::gvalid()).\n+  - Functions to create a plumed object based on the path of a specific kernel\n+    (\\ref plumed_create_dlopen() and \\ref PLMD::Plumed::dlopen()).\n+  - Functions to create a plumed object referencing to another one, implementing a reference counter\n+    (\\ref plumed_create_reference(), \\ref plumed_create_reference_v(), \\ref plumed_create_reference_f().\n+\n+*/\n+\n+/* BEGINNING OF DECLARATIONS */\n+\n+/* SETTING DEFAULT VALUES FOR CONTROL MACROS */\n+\n+/*\n+  1: make the C wrapper functions extern (default)\n+  0: make the C wrapper functions static (C) or inline (C++)\n+\n+  If set to zero, it disables all functions that only make sense as extern, such as\n+  Fortran wrappers, global objects, and plumed_kernel_register.\n+\n+  It can be set to zero to include multiple copies of the wrapper implementation without worrying\n+  about duplicated symbols.\n+\n+  Notice that C++ wrappers are always inline. What this function controls is if the C wrappers\n+  (called by the C++ wrappers) is inline or not. Also consider that if this header is compiled\n+  with C++ and inline C wrappers, the C wrappers will be actually compiled with C++ linkage\n+  in the root namespace.\n+\n+  Used both in declarations (to know which functions to declare) and definitions (to know which functions to define).\n+*/\n+\n+#ifndef __PLUMED_WRAPPER_EXTERN\n+#define __PLUMED_WRAPPER_EXTERN 1\n+#endif\n+\n+/*\n+  1: emit global plumed object and related functions (default)\n+  0: do not emit global plumed object and related functions\n+\n+  Used both in declarations (to know which functions to declare) and definitions (to know which functions to define).\n+*/\n+\n+#ifndef __PLUMED_WRAPPER_GLOBAL\n+#define __PLUMED_WRAPPER_GLOBAL 1\n+#endif\n+\n+/*\n+  1: enable C++ wrapper (default)\n+  0: disable C++ wrapper\n+\n+  Only used in declarations, but affects the scope of the C interface also in definitions.\n+*/\n+\n+#ifndef __PLUMED_WRAPPER_CXX\n+#define __PLUMED_WRAPPER_CXX 1\n+#endif\n+\n+/*\n+  1: new headers such as cstdlib are included in C++ (default)\n+  0: old headers such as stdlib.h are included in C++\n+\n+  Should only be set to zero when including the Plumed.h file in a file using the\n+  old (stdlib.h) convention.\n+\n+  Used both in declarations and definitions.\n+*/\n+\n+#ifndef __PLUMED_WRAPPER_CXX_STD\n+#define __PLUMED_WRAPPER_CXX_STD 1\n+#endif\n+\n+/*\n+  1: place C++ wrappers in an anonymous namespace\n+  0: place C++ wrappers in the PLMD namespace (default)\n+\n+  It will make PLMD::Plumed a different class (though with the same name)\n+  in each of the translation units in which `Plumed.h` is included.\n+\n+  Can be used to completey separate C++ implementations. However, it will make\n+  it impossible to transfer Plumed objects between different translation units\n+  without converting to a void* or plumed object.\n+\n+  Only used in declarations, but affects the scope of the C interface also in definitions.\n+*/\n+\n+#ifndef __PLUMED_WRAPPER_CXX_ANONYMOUS_NAMESPACE\n+#define __PLUMED_WRAPPER_CXX_ANONYMOUS_NAMESPACE 0\n+#endif\n+\n+/*\n+  1: make PLMD::Plumed class polymorphic (default)\n+  0: make PLMD::Plumed class non-polymorphic\n+\n+  Only used in declarations.\n+*/\n+\n+#ifndef __PLUMED_WRAPPER_CXX_POLYMORPHIC\n+#define __PLUMED_WRAPPER_CXX_POLYMORPHIC 1\n+#endif\n+\n+/*\n+  1: make the default constructor create an invalid object\n+  0: make the default constructor create a valid object\n+\n+  Only for internal usage.\n+*/\n+#ifndef __PLUMED_WRAPPER_CXX_DEFAULT_INVALID\n+#define __PLUMED_WRAPPER_CXX_DEFAULT_INVALID 0\n+#endif\n+\n+/*\n+  Size of a buffer used to store message for exceptions with noexcept constructor.\n+  Should typically hold short messages. Anyway, as long as the stack size stays within the correct\n+  limits it does not seem to affect efficiency. Notice that there cannot be recursive calls of\n+  PLMD::Plumed::cmd, so that it should be in practice irrelevant.\n+*/\n+#ifndef __PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER\n+#define __PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER 512\n+#endif\n+\n+\n+/*\n+ By default, assume C++11 compliant library is not available.\n+*/\n+\n+#ifndef __PLUMED_WRAPPER_LIBCXX11\n+#define __PLUMED_WRAPPER_LIBCXX11 0\n+#endif\n+\n+/* The following macros are just to define shortcuts */\n+\n+/* Simplify addition of extern \"C\" blocks.  */\n+#ifdef __cplusplus\n+#define __PLUMED_WRAPPER_EXTERN_C_BEGIN extern \"C\" {\n+#define __PLUMED_WRAPPER_EXTERN_C_END }\n+#else\n+#define __PLUMED_WRAPPER_EXTERN_C_BEGIN\n+#define __PLUMED_WRAPPER_EXTERN_C_END\n+#endif\n+\n+/* Without C++, stdlib functions should not be prepended with ::std:: */\n+#ifndef __cplusplus\n+#undef __PLUMED_WRAPPER_CXX_STD\n+#define __PLUMED_WRAPPER_CXX_STD 0\n+#endif\n+\n+/* Set prefix for stdlib functions */\n+#if __PLUMED_WRAPPER_CXX_STD\n+#define __PLUMED_WRAPPER_STD ::std::\n+#else\n+#define __PLUMED_WRAPPER_STD\n+#endif\n+\n+/* Allow using noexcept, explicit, and override with C++11 compilers */\n+#if __cplusplus > 199711L\n+#define __PLUMED_WRAPPER_CXX_NOEXCEPT noexcept\n+#define __PLUMED_WRAPPER_CXX_EXPLICIT explicit\n+#define __PLUMED_WRAPPER_CXX_OVERRIDE override\n+#else\n+#define __PLUMED_WRAPPER_CXX_NOEXCEPT throw()\n+#define __PLUMED_WRAPPER_CXX_EXPLICIT\n+#define __PLUMED_WRAPPER_CXX_OVERRIDE\n+#endif\n+\n+/* Macros for anonymous namespace */\n+#if __PLUMED_WRAPPER_CXX_ANONYMOUS_NAMESPACE && defined(__cplusplus) /*{*/\n+#define __PLUMED_WRAPPER_ANONYMOUS_BEGIN namespace {\n+#define __PLUMED_WRAPPER_ANONYMOUS_END }\n+#else\n+#define __PLUMED_WRAPPER_ANONYMOUS_BEGIN\n+#define __PLUMED_WRAPPER_ANONYMOUS_END\n+#endif /*}*/\n+\n+#if __PLUMED_WRAPPER_EXTERN /*{*/\n+\n+#define __PLUMED_WRAPPER_C_BEGIN __PLUMED_WRAPPER_EXTERN_C_BEGIN extern\n+#define __PLUMED_WRAPPER_C_END __PLUMED_WRAPPER_EXTERN_C_END\n+#define __PLUMED_WRAPPER_INTERNALS_BEGIN __PLUMED_WRAPPER_EXTERN_C_BEGIN static\n+#define __PLUMED_WRAPPER_INTERNALS_END __PLUMED_WRAPPER_EXTERN_C_END\n+\n+#else\n+\n+#ifdef __cplusplus\n+#define __PLUMED_WRAPPER_C_BEGIN  __PLUMED_WRAPPER_ANONYMOUS_BEGIN inline\n+#define __PLUMED_WRAPPER_C_END __PLUMED_WRAPPER_ANONYMOUS_END\n+#else\n+#define __PLUMED_WRAPPER_C_BEGIN static\n+#define __PLUMED_WRAPPER_C_END\n+#endif\n+\n+#define __PLUMED_WRAPPER_INTERNALS_BEGIN __PLUMED_WRAPPER_C_BEGIN\n+#define __PLUMED_WRAPPER_INTERNALS_END __PLUMED_WRAPPER_C_END\n+\n+/* with an not-external interface, it does not make sense to define global functions */\n+#undef __PLUMED_WRAPPER_GLOBAL\n+#define __PLUMED_WRAPPER_GLOBAL 0\n+\n+#endif /*}*/\n+\n+/**\n+  \\brief Main plumed object\n+\n+  This is an object containing a Plumed instance, which should be used in\n+  the MD engine. It should first be initialized with plumed_create(),\n+  then it communicates with the MD engine using plumed_cmd(). Finally,\n+  before the termination, it should be deallocated with plumed_finalize().\n+  Its interface is very simple and general, and is expected\n+  not to change across plumed versions. See \\ref ReferencePlumedH.\n+*/\n+typedef struct {\n+  /**\n+    \\private\n+    \\brief Void pointer holding the real PlumedMain structure\n+\n+    To maintain binary compatibility, we should not add members to this structure.\n+    As of PLUMED 2.5, in order to add new components we do not store the pointer\n+    to \\ref PlumedMain here but rather a pointer to an intermediate private structure\n+    that contains all the details.\n+  */\n+  void*p;\n+} plumed;\n+\n+typedef struct {\n+  void* ptr;\n+  void (*handler)(void*,int,const char*,const void*);\n+} plumed_nothrow_handler;\n+\n+/** \\relates plumed\n+    \\brief Constructor\n+\n+    Constructs a plumed object.\n+\n+    Notice that if you are linking against libplumedWrapper.a, if you are\n+    using a code patched in runtime mode, or if you are including the `Plumed.c`\n+    file directly in your code, this constructor might return an invalid plumed\n+    object. In particular, this could happen if the `PLUMED_KERNEL` environment\n+    variable is not set or set incorrectly. In order to detect an incorrect\n+    plumed object you might use \\ref plumed_valid() on the resulting object.\n+    Alternatively, if you use \\ref plumed_cmd() on an invalid plumed object the code will exit.\n+    Also notice that to avoid memory leaks you should call \\ref plumed_finalize()\n+    to finalize a plumed object even if it is invalid:\n+\\verbatim\n+  plumed p=plumed_create();\n+  if(!plumed_valid(p)) {\n+// this will happen if the PLUMED_KERNEL variable is not set correctly\n+    plumed_finalize(p);\n+    return whatever;\n+  }\n+\\endverbatim\n+\n+    \\return The constructed plumed object\n+*/\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_create(void);\n+__PLUMED_WRAPPER_C_END\n+\n+/** \\relates plumed\n+    \\brief Constructor from path. Available as of PLUMED 2.5\n+\n+    It tries to construct a plumed object loading the kernel located at path.\n+    Notice that it could leave the resulting object in an invalid state.\n+    In order to detect an invalid\n+    plumed object you might use \\ref plumed_valid() on the resulting object.\n+    Alternatively, if you use \\ref plumed_cmd() on an invalid plumed object the code will exit.\n+\n+    Also notice that to avoid memory leaks you should call \\ref plumed_finalize()\n+    to finalize a plumed object even if it is invalid.\n+\\verbatim\n+  plumed p=plumed_create(path);\n+  if(!plumed_valid(p)) {\n+// this will happen if the path argument is not set correctly\n+    plumed_finalize(p);\n+    return whatever;\n+  }\n+\\endverbatim\n+\n+    \\return The constructed plumed object\n+*/\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_create_dlopen(const char*path);\n+__PLUMED_WRAPPER_C_END\n+\n+\n+/**\n+  \\brief Constructor from path. Available as of PLUMED 2.5\n+\n+  Same as \\ref plumed_create_dlopen, but also allows to specify the mode for dlopen.\n+\n+  \\warning\n+  Use with care, since not all the possible modes work correctly with PLUMED.\n+*/\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_create_dlopen2(const char*path,int mode);\n+__PLUMED_WRAPPER_C_END\n+\n+/** \\relates plumed\n+    Create a new reference to an existing object, increasing its reference count. Available as of PLUMED 2.5\n+\n+    Use it to increase by one the reference count of a plumed object.\n+    The resulting pointer might be identical to the one passed as an\n+    argument, but the reference count will be incremented by one.\n+    Notice that you should finalize the resulting object.\n+\\verbatim\n+  plumed p1;\n+  plumed p2;\n+  p1=plumed_create();\n+  p2=plumed_create_reference(p1);\n+  plumed_finalize(p1);\n+// now you can still use p2\n+  plumed_cmd(p2,\"init\",NULL);\n+  plumed_finalize(p2);\n+// now the underlying object is destroyed.\n+\\endverbatim\n+\n+    If the `p` object is invalid, also the returned object will be invalid.\n+\n+    \\param p The plumed object that will be referenced to.\n+    \\return The constructed plumed object\n+*/\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_create_reference(plumed p);\n+__PLUMED_WRAPPER_C_END\n+\n+/** \\relates plumed\n+    \\brief Create a new reference to an existing object passed as a void pointer, increasing its reference count. Available as of PLUMED 2.5\n+\n+  \\return The constructed plumed object\n+*/\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_create_reference_v(void*v);\n+__PLUMED_WRAPPER_C_END\n+\n+/** \\relates plumed\n+    \\brief Create a new reference to an existing object passed as a fortran string, increasing its reference count. Available as of PLUMED 2.5\n+\n+  \\return The constructed plumed object\n+*/\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_create_reference_f(const char*f);\n+__PLUMED_WRAPPER_C_END\n+\n+/** \\relates plumed\n+    \\brief Constructor as invalid. Available as of PLUMED 2.5\n+\n+   Can be used to create an object in the same state as if it was returned by\n+   plumed_create_dlopen with an incorrect path (or plumed_create using runtime binding\n+   and an incorrect PLUMED_KERNEL).\n+\n+   Can be used to initialize a plumed object to a well-defined state without explicitly\n+   creating it. The resulting object can be checked later with \\ref plumed_valid.\n+   Consider the following example\n+\\verbatim\n+    plumed p;\n+    p=plumed_create_invalid();\n+// at this point p is initialized to a well-defined (invalid) state.\n+    setenv(\"PLUMED_KERNEL\",\"/path/to/kernel/libplumedKernel.so\",1);\n+    plumed_finalize(p);\n+    p=plumed_create();\n+\\endverbatim\n+\n+    \\return The constructed plumed object\n+*/\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_create_invalid();\n+__PLUMED_WRAPPER_C_END\n+\n+/** \\relates plumed\n+    \\brief Tells p to execute a command.\n+\n+    If the object is not valid (see \\ref plumed_valid), this command will exit.\n+\n+    \\param p The plumed object on which command is acting\n+    \\param key The name of the command to be executed\n+    \\param val The argument. It is declared as const to allow calls like plumed_cmd(p,\"A\",\"B\"),\n+               but for some choice of key it can change the content.\n+\n+    Notice that within PLUMED we use a const_cast to remove any const qualifier from the second\n+    argument of \\ref plumed_cmd.\n+\n+    In some cases val can be omitted: just pass a NULL pointer (in C++, val is optional and can be omitted,\n+    or you can equivalently pass NULL or nullptr).\n+    The set of possible keys is the real API of the plumed library, and will be expanded with time.\n+    New commands will be added, but backward compatibility will be retained as long as possible.\n+*/\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+void plumed_cmd(plumed p,const char*key,const void*val);\n+__PLUMED_WRAPPER_C_END\n+\n+/**\n+  \\relates plumed\n+  \\brief Same as \\ref plumed_cmd, but does not throw exceptions.\n+\n+  This function is meant to be used when errors should be handled explicitly.\n+  if an exception is raised within PLUMED, the function nothrow.handler() will\n+  be called with arguments (nothrow.ptr,code,message,opt). This allows the C++ interface\n+  to correctly rethrow exceptions, but might be used from C as well. opt can be used\n+  to pass further information (not used yet).\n+*/\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+void plumed_cmd_nothrow(plumed p,const char*key,const void*val,plumed_nothrow_handler nothrow);\n+__PLUMED_WRAPPER_C_END\n+\n+/** \\relates plumed\n+    \\brief Destructor.\n+\n+    It must be used for any object created using \\ref plumed_create(),\n+    even if the created object is not valid.\n+\n+    \\param p The plumed object to be deallocated\n+*/\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+void plumed_finalize(plumed p);\n+__PLUMED_WRAPPER_C_END\n+\n+/** \\relates plumed\n+    \\brief Check if plumed is installed (for runtime binding).\n+\n+    Notice that this is equivalent to creating a dummy object and checking if it is valid.\n+\n+\\verbatim\n+  // this:\n+  //int a=plumed_installed();\n+  // is equivalent to this:\n+\n+  plumed p=plumed_create();\n+  int a=plumed_valid(p);\n+  plumed_finalize(p);\n+\n+\\endverbatim\n+\n+    This function is mostly provided for compatibility with PLUMED 2.4, where \\ref plumed_valid()\n+    was not available. Using \\ref plumed_valid() is now preferred since it creates a single object\n+    instead of creating a dummy object that is then discarded.\n+\n+    \\return 1 if plumed is installed, 0 otherwise\n+*/\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+int plumed_installed(void);\n+__PLUMED_WRAPPER_C_END\n+\n+/** \\relates plumed\n+    \\brief Check if plumed object is valid. Available as of PLUMED 2.5\n+\n+    It might return false if plumed is not available at runtime.\n+\n+    \\return 1 if plumed is valid, 0 otherwise\n+*/\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+int plumed_valid(plumed p);\n+__PLUMED_WRAPPER_C_END\n+\n+/** \\relates plumed\n+    \\brief Returns the number of references to the underlying object. Available as of PLUMED 2.5.\n+*/\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+int plumed_use_count(plumed p);\n+__PLUMED_WRAPPER_C_END\n+\n+\n+/* routines to convert char handler from/to plumed objects */\n+\n+/** \\related plumed\n+    \\brief Converts a C handler to a FORTRAN handler\n+\n+    \\param p The C handler\n+    \\param c The FORTRAN handler (a char[32])\n+\n+    This function can be used to convert a plumed object created in C to\n+    a plumed handler that can be used in FORTRAN. Notice that the reference counter\n+    is not incremented. In other words, the FORTRAN object will be a weak reference.\n+    If you later finalize the C handler, the FORTRAN handler will be invalid.\n+\\verbatim\n+#include <plumed/wrapper/Plumed.h>\n+int main(int argc,char*argv[]){\n+  plumed p;\n+  p=plumed_create();\n+  char fortran_handler[32];\n+  plumed_c2f(p,fortran_handler);\n+  printf(\"DEBUG: this is a string representation for the plumed handler: %s\\n\",fortran_handler);\n+  fortran_routine(fortran_handler);\n+  plumed_finalize(p);\n+  return 0;\n+}\n+\\endverbatim\n+  Here `fortran_routine` is a routine implemented in FORTRAN that manipulates the\n+  fortran_handler.\n+*/\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+void   plumed_c2f(plumed p,char* c);\n+__PLUMED_WRAPPER_C_END\n+\n+/** \\related plumed\n+    \\brief Converts a FORTRAN handler to a C handler\n+    \\param c The FORTRAN handler (a char[32])\n+    \\return The C handler\n+\n+    This function can be used to convert a plumed object created in FORTRAN\n+    to a plumed handler that can be used in C.  Notice that the reference counter\n+    is not incremented. In other words, the C object will be a weak reference.\n+    If you later finalize the FORTRAN handler, the C handler will be invalid.\n+\\verbatim\n+void c_routine(char handler[32]){\n+  plumed p;\n+  p=plumed_f2c(handler);\n+  plumed_cmd(p,\"init\",NULL);\n+}\n+\\endverbatim\n+  Here `c_routine` is a C function that can be called from FORTRAN\n+  and interact with the provided plumed handler.\n+*/\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_f2c(const char* c);\n+__PLUMED_WRAPPER_C_END\n+\n+/** \\related plumed\n+    \\brief Converts a plumed object to a void pointer. Available as of PLUMED 2.5.\n+\n+    It returns a void pointer that can be converted back to a plumed object using \\ref plumed_v2c.\n+    When compiling without NDEBUG, it checks if the plumed object was properly created.\n+    Notice that an invalid object (see \\ref plumed_valid) can be converted to void* and back.\n+\n+    Can be used to store a reference to a plumed object without including the Plumed.h header.\n+*/\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+void* plumed_c2v(plumed p);\n+__PLUMED_WRAPPER_C_END\n+\n+\n+/** \\related plumed\n+    \\brief Converts a void pointer to a plumed object. Available as of PLUMED 2.5.\n+\n+    It returns a plumed object from a void pointer obtained with \\ref plumed_c2v.\n+    When compiling without NDEBUG, it checks if the plumed object was properly created.\n+\n+    Can be used to store a reference to a plumed object without including the Plumed.h header.\n+*/\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_v2c(void*);\n+__PLUMED_WRAPPER_C_END\n+\n+\n+#if __PLUMED_WRAPPER_GLOBAL /*{*/\n+\n+/* Global C functions are always extern */\n+__PLUMED_WRAPPER_EXTERN_C_BEGIN /*{*/\n+\n+/** \\relates plumed\n+    \\brief Retrieves an handler to the global structure.\n+\n+  You can use this if you work on a code that uses the global structure and you want to\n+  pass to a generic routine an handler to the same structure. E.g.\n+\n+\\verbatim\n+  plumed p=plumed_global();\n+  some_routine(p);\n+\\endverbatim\n+*/\n+extern\n+plumed plumed_global(void);\n+\n+/** \\relates plumed\n+    \\brief Check if the global interface has been initialized.\n+\n+    \\return 1 if plumed has been initialized, 0 otherwise\n+*/\n+extern\n+int plumed_ginitialized(void);\n+\n+/** \\relates plumed\n+    \\brief Constructor for the global interface.\n+\n+    \\note Equivalent to plumed_create(), but initialize the static global plumed object\n+*/\n+extern\n+void plumed_gcreate(void);\n+\n+/** \\relates plumed\n+    \\brief Tells to the global interface to execute a command.\n+\n+    \\param key The name of the command to be executed\n+    \\param val The argument. It is declared as const to allow calls like plumed_gcmd(\"A\",\"B\"),\n+               but for some choice of key it can change the content\n+\n+    `plumed_gcmd(a,b);` is equivalent to `plumed_cmd(plumed_global(),a,b);`.\n+*/\n+extern\n+void plumed_gcmd(const char* key,const void* val);\n+\n+/** \\relates plumed\n+    \\brief Destructor for the global interface.\n+\n+    `plumed_gfinalize(a,b);` is similar to `plumed_finalize(plumed_global(),a,b);`, but not completely\n+    equivalent. In particular, plumed_gfinalize() also makes sure that the global object\n+    is reset to its initial status. After calling it, \\ref plumed_ginitialized() will thus return 0.\n+*/\n+extern\n+void plumed_gfinalize(void);\n+\n+/** \\relates plumed\n+    \\brief Check if global plumed object is valid. Available as of PLUMED 2.5\n+\n+    It might return zero if plumed is not available at runtime.\n+\n+    \\return 1 if plumed is valid, 0 otherwise.\n+*/\n+extern\n+int plumed_gvalid();\n+\n+__PLUMED_WRAPPER_EXTERN_C_END /*}*/\n+\n+#endif /*}*/\n+\n+#if defined( __cplusplus) && __PLUMED_WRAPPER_CXX /*{*/\n+\n+#if __PLUMED_WRAPPER_CXX_STD\n+#include <cstdlib> /* NULL getenv */\n+#include <cstring> /* strncat strlen */\n+#include <cstdio> /* fprintf */\n+#else\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stdio.h>\n+#endif\n+\n+#include <exception> /* exception bad_exception */\n+#include <stdexcept> /* runtime_error logic_error invalid_argument domain_error length_error out_of_range range_error overflow_error underflow_error */\n+#include <string> /* string */\n+#include <ios> /* iostream_category (C++11) ios_base::failure (C++11 and C++<11) */\n+#include <new> /* bad_alloc bad_array_new_length (C++11) */\n+#include <typeinfo> /* bad_typeid bad_cast */\n+#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n+#include <system_error> /* system_error generic_category system_category */\n+#include <future> /* future_category */\n+#include <memory> /* bad_weak_ptr */\n+#include <functional> /* bad_function_call */\n+#endif\n+\n+/* C++ interface is hidden in PLMD namespace (same as plumed library) */\n+namespace PLMD {\n+\n+/* Optionally, it is further hidden in an anonymous namespace */\n+\n+__PLUMED_WRAPPER_ANONYMOUS_BEGIN /*{*/\n+\n+/**\n+  C++ wrapper for \\ref plumed.\n+\n+  This class provides a C++ interface to PLUMED.\n+  It only containts a \\ref plumed object, but wraps it with a number of useful methods.\n+  All methods are inlined so as to avoid the compilation of an extra c++ file.\n+\n+*/\n+\n+class Plumed {\n+  /**\n+    C structure.\n+  */\n+  plumed main;\n+\n+  /**\n+    Error handler used to rethrow exceptions.\n+  */\n+\n+  struct NothrowHandler {\n+    /** code used for translating messages */\n+    int code;\n+    /** short message buffer for non-throwing exceptions */\n+    char exception_buffer[__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER];\n+    /** if exception_buffer='\\0', message stored as an allocatable string */\n+    ::std::string what;\n+    /** error code for system_error */\n+    int error_code;\n+  };\n+\n+  /**\n+    Callback function that sets the error handler.\n+\n+    opt argument is interpreted as the pointer to a null terminated array of void*.\n+    The number of non-null element is expected to be even, and there should be a null element\n+    that follows. Every pair of pointers should point\n+    to a char, identifying the type of argument passed, and an arbitrary object.\n+    Currently used to (optionally) pass error_code.\n+  */\n+  static void nothrow_handler(void*ptr,int code,const char*what,const void* opt) {\n+    NothrowHandler* h=(NothrowHandler*) ptr;\n+    h->code=code;\n+    h->exception_buffer[0]='\\0';\n+    h->what.clear();\n+    h->error_code=0;\n+    /*\n+       These codes correspond to exceptions that should not allocate a separate buffer but use the fixed one.\n+       Notice that a mismatch between the exceptions using the stack buffer here and those implementing\n+       the stack buffer would be in practice harmless. However, it makes sense to be consistent.\n+    */\n+    if(code==10000 || (code>=11000 && code<12000)) {\n+      __PLUMED_WRAPPER_STD strncat(h->exception_buffer,what,__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1);\n+    } else {\n+      h->what=what;\n+    }\n+\n+    /* interpret optional arguments */\n+    const void** options=(const void**)opt;\n+    if(options) while(*options) {\n+        if(*((char*)*options)=='c') h->error_code=*((int*)*(options+1));\n+        options+=2;\n+      }\n+\n+    static const char* debug=__PLUMED_WRAPPER_STD getenv(\"PLUMED_EXCEPTIONS_DEBUG\");\n+\n+    if(debug) {\n+      __PLUMED_WRAPPER_STD fprintf(stderr,\"+++ PLUMED_EXCEPTIONS_DEBUG\\n\");\n+      __PLUMED_WRAPPER_STD fprintf(stderr,\"+++ code: %d error_code: %d message:\\n%s\\n\",h->code,h->error_code,what);\n+      if(__PLUMED_WRAPPER_STD strlen(what) > __PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1) __PLUMED_WRAPPER_STD fprintf(stderr,\"+++ WARNING: message will be truncated\\n\");\n+      __PLUMED_WRAPPER_STD fprintf(stderr,\"+++ END PLUMED_EXCEPTIONS_DEBUG\\n\");\n+    }\n+\n+  }\n+\n+  /**\n+    Rethrow the exception based on the information saved in the NothrowHandler.\n+  */\n+\n+  static void rethrow(const NothrowHandler&h) {\n+    /* The interpretation of the codes should be kept in sync with core/PlumedMainInitializer.cpp */\n+    /* check if we are using a full string or a fixes size buffer */\n+    const char* msg=(h.exception_buffer[0]?h.exception_buffer:h.what.c_str());\n+    if(h.code==1) throw Plumed::Invalid(msg);\n+    /* logic errors */\n+    if(h.code>=10100 && h.code<10200) {\n+      if(h.code>=10105 && h.code<10110) throw ::std::invalid_argument(msg);\n+      if(h.code>=10110 && h.code<10115) throw ::std::domain_error(msg);\n+      if(h.code>=10115 && h.code<10120) throw ::std::length_error(msg);\n+      if(h.code>=10120 && h.code<10125) throw ::std::out_of_range(msg);\n+      throw ::std::logic_error(msg);\n+    }\n+    /* runtime errors */\n+    if(h.code>=10200 && h.code<10300) {\n+      if(h.code>=10205 && h.code<10210) throw ::std::range_error(msg);\n+      if(h.code>=10210 && h.code<10215) throw ::std::overflow_error(msg);\n+      if(h.code>=10215 && h.code<10220) throw ::std::underflow_error(msg);\n+#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n+      if(h.code==10220) throw ::std::system_error(h.error_code,::std::generic_category(),msg);\n+      if(h.code==10221) throw ::std::system_error(h.error_code,::std::system_category(),msg);\n+      if(h.code==10222) throw ::std::system_error(h.error_code,::std::iostream_category(),msg);\n+      if(h.code==10223) throw ::std::system_error(h.error_code,::std::future_category(),msg);\n+#endif\n+      if(h.code>=10230 && h.code<10240) {\n+#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n+// These cases are probably useless as it looks like this should always be std::iostream_category\n+        if(h.code==10230) throw ::std::ios_base::failure(msg,std::error_code(h.error_code,::std::generic_category()));\n+        if(h.code==10231) throw ::std::ios_base::failure(msg,std::error_code(h.error_code,::std::system_category()));\n+        if(h.code==10232) throw ::std::ios_base::failure(msg,std::error_code(h.error_code,::std::iostream_category()));\n+        if(h.code==10233) throw ::std::ios_base::failure(msg,std::error_code(h.error_code,::std::future_category()));\n+#endif\n+        throw ::std::ios_base::failure(msg);\n+      }\n+      throw ::std::runtime_error(msg);\n+    }\n+    /* \"bad\" errors */\n+    if(h.code>=11000 && h.code<11100) throw Plumed::std_bad_typeid(msg);\n+    if(h.code>=11100 && h.code<11200) throw Plumed::std_bad_cast(msg);\n+#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n+    if(h.code>=11200 && h.code<11300) throw Plumed::std_bad_weak_ptr(msg);\n+    if(h.code>=11300 && h.code<11400) throw Plumed::std_bad_function_call(msg);\n+#endif\n+    if(h.code>=11400 && h.code<11500) {\n+#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n+      if(h.code>=11410 && h.code<11420) throw Plumed::std_bad_array_new_length(msg);\n+#endif\n+      throw Plumed::std_bad_alloc(msg);\n+    }\n+    if(h.code>=11500 && h.code<11600) throw Plumed::std_bad_exception(msg);\n+    /* lepton error */\n+    if(h.code>=19900 && h.code<20000) throw Plumed::LeptonException(msg);\n+    /* plumed exceptions */\n+    if(h.code>=20000 && h.code<30000) {\n+      /* debug - only raised with debug options */\n+      if(h.code>=20100 && h.code<20200) throw Plumed::ExceptionDebug(msg);\n+      /* error - runtime check */\n+      if(h.code>=20200 && h.code<20300) throw Plumed::ExceptionError(msg);\n+      throw Plumed::Exception(msg);\n+    }\n+    /* fallback for any other exception */\n+    throw Plumed::std_exception(msg);\n+  }\n+\n+  /**\n+    Rethrow the current exception.\n+\n+    This is useful in order to handle an exception thrown by a kernel <=2.4.\n+    Only std exceptions are handled, though some of them are thrown as special\n+    Plumed exceptions in order to be attached a message.\n+  */\n+  static void rethrow() {\n+    try {\n+      throw;\n+    } catch(const ::std::bad_exception & e) {\n+      throw Plumed::std_bad_exception(e.what());\n+#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n+    } catch(const ::std::bad_array_new_length & e) {\n+      throw Plumed::std_bad_array_new_length(e.what());\n+#endif\n+    } catch(const ::std::bad_alloc & e) {\n+      throw Plumed::std_bad_alloc(e.what());\n+#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n+    } catch(const ::std::bad_function_call & e) {\n+      throw Plumed::std_bad_function_call(e.what());\n+    } catch(const ::std::bad_weak_ptr & e) {\n+      throw Plumed::std_bad_weak_ptr(e.what());\n+#endif\n+    } catch(const ::std::bad_cast & e) {\n+      throw Plumed::std_bad_cast(e.what());\n+    } catch(const ::std::bad_typeid & e) {\n+      throw Plumed::std_bad_typeid(e.what());\n+      // not implemented yet: std::regex_error\n+      // we do not allow regex yet due to portability problems with gcc 4.8\n+      // as soon as we transition to using <regex> it should be straightforward to add\n+    } catch(const ::std::ios_base::failure & e) {\n+#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n+      throw ::std::ios_base::failure(e.what(),e.code());\n+#else\n+      throw ::std::ios_base::failure(e.what());\n+#endif\n+#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n+    } catch(const ::std::system_error & e) {\n+      throw ::std::system_error(e.code(),e.what());\n+#endif\n+    } catch(const ::std::underflow_error &e) {\n+      throw ::std::underflow_error(e.what());\n+    } catch(const ::std::overflow_error &e) {\n+      throw ::std::overflow_error(e.what());\n+    } catch(const ::std::range_error &e) {\n+      throw ::std::range_error(e.what());\n+    } catch(const ::std::runtime_error & e) {\n+      throw ::std::runtime_error(e.what());\n+      // not implemented yet: std::future_error\n+      // not clear how useful it would be.\n+    } catch(const ::std::out_of_range & e) {\n+      throw ::std::out_of_range(e.what());\n+    } catch(const ::std::length_error & e) {\n+      throw ::std::length_error(e.what());\n+    } catch(const ::std::domain_error & e) {\n+      throw ::std::domain_error(e.what());\n+    } catch(const ::std::invalid_argument & e) {\n+      throw ::std::invalid_argument(e.what());\n+    } catch(const ::std::logic_error & e) {\n+      throw ::std::logic_error(e.what());\n+    } catch(const ::std::exception & e) {\n+      throw Plumed::std_exception(e.what());\n+    } catch(...) {\n+      throw Plumed::std_bad_exception(\"plumed could not translate exception\");\n+    }\n+  }\n+\n+public:\n+\n+  /**\n+    Base class used to rethrow PLUMED exceptions.\n+  */\n+\n+  class Exception :\n+    public ::std::exception\n+  {\n+    ::std::string msg;\n+  public:\n+    __PLUMED_WRAPPER_CXX_EXPLICIT Exception(const char* msg): msg(msg) {}\n+    const char* what() const __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {return msg.c_str();}\n+    /* Destructor should be declared in order to have the correct throw() */\n+    ~Exception() __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {}\n+  };\n+\n+  /**\n+    Used to rethrow a PLMD::ExceptionError\n+  */\n+\n+  class ExceptionError :\n+    public Exception {\n+  public:\n+    __PLUMED_WRAPPER_CXX_EXPLICIT ExceptionError(const char* msg): Exception(msg) {}\n+    /* Destructor should be declared in order to have the correct throw() */\n+    ~ExceptionError() __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {}\n+  };\n+\n+  /**\n+    Used to rethrow a PLMD::ExceptionDebug\n+  */\n+\n+  class ExceptionDebug :\n+    public Exception {\n+  public:\n+    __PLUMED_WRAPPER_CXX_EXPLICIT ExceptionDebug(const char* msg): Exception(msg) {}\n+    /* Destructor should be declared in order to have the correct throw() */\n+    ~ExceptionDebug() __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {}\n+  };\n+\n+  /**\n+    Thrown when trying to access an invalid plumed object\n+  */\n+\n+  class Invalid :\n+    public Exception {\n+  public:\n+    __PLUMED_WRAPPER_CXX_EXPLICIT Invalid(const char* msg): Exception(msg) {}\n+    /* Destructor should be declared in order to have the correct throw() */\n+    ~Invalid() __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {}\n+  };\n+\n+  /**\n+    Class used to rethrow Lepton exceptions.\n+  */\n+\n+  class LeptonException :\n+    public ::std::exception\n+  {\n+    ::std::string msg;\n+  public:\n+    __PLUMED_WRAPPER_CXX_EXPLICIT LeptonException(const char* msg): msg(msg) {}\n+    const char* what() const __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {return msg.c_str();}\n+    /* Destructor should be declared in order to have the correct throw() */\n+    ~LeptonException() __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {}\n+  };\n+\n+private:\n+  /*\n+    These exceptions are declared as private as they are not supposed to be\n+    catched by value. they only exist to allow a buffer to be attached to\n+    the std::exceptions that do not contain it already.\n+    Notice that these exceptions are those whose constructor should never throw, and as\n+    such they use a fixed size buffer.\n+  */\n+\n+#define __PLUMED_WRAPPER_NOSTRING_EXCEPTION(name) \\\n+  class std_ ## name : \\\n+    public ::std::name \\\n+  { \\\n+    char msg[__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER]; \\\n+  public: \\\n+    __PLUMED_WRAPPER_CXX_EXPLICIT std_ ## name(const char * msg) __PLUMED_WRAPPER_CXX_NOEXCEPT { \\\n+      this->msg[0]='\\0'; \\\n+      __PLUMED_WRAPPER_STD strncat(this->msg,msg,__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1); \\\n+      static const char* debug=__PLUMED_WRAPPER_STD getenv(\"PLUMED_EXCEPTIONS_DEBUG\"); \\\n+      if(debug && __PLUMED_WRAPPER_STD strlen(msg) > __PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1) __PLUMED_WRAPPER_STD fprintf(stderr,\"+++ WARNING: message will be truncated\\n\"); \\\n+    } \\\n+    std_ ## name(const std_ ## name & other) __PLUMED_WRAPPER_CXX_NOEXCEPT { \\\n+      msg[0]='\\0'; \\\n+      __PLUMED_WRAPPER_STD strncat(msg,other.msg,__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1); \\\n+    } \\\n+    std_ ## name & operator=(const std_ ## name & other) __PLUMED_WRAPPER_CXX_NOEXCEPT { \\\n+      if(this==&other) return *this;\\\n+      msg[0]='\\0'; \\\n+      __PLUMED_WRAPPER_STD strncat(msg,other.msg,__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1); \\\n+      return *this; \\\n+    } \\\n+    const char* what() const __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {return msg;} \\\n+    ~std_ ## name() __PLUMED_WRAPPER_CXX_NOEXCEPT __PLUMED_WRAPPER_CXX_OVERRIDE {} \\\n+  };\n+\n+  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_typeid)\n+  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_cast)\n+#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n+  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_weak_ptr)\n+  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_function_call)\n+#endif\n+  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_alloc)\n+#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n+  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_array_new_length)\n+#endif\n+  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_exception)\n+  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(exception)\n+\n+public:\n+\n+  /**\n+     Check if plumed is installed (for runtime binding)\n+     \\return true if plumed is installed, false otherwise\n+     \\note Equivalent to plumed_installed() but returns a bool\n+  */\n+  static bool installed() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+    return plumed_installed();\n+  }\n+  /**\n+     Check if Plumed object is valid. Available as of PLUMED 2.5\n+     \\return true if plumed is valid, false otherwise\n+     \\note Equivalent to plumed_valid() but returns a bool\n+  */\n+  bool valid() const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+    return plumed_valid(main);\n+  }\n+#if __cplusplus > 199711L\n+  /**\n+     Same as \\ref valid(). Available as of PLUMED 2.5.\n+\n+  Allow code such as\n+  \\verbatim\n+  Plumed p;\n+  if(!p) raise_error();\n+  p.cmd(\"init\");\n+  \\endverbatim\n+\n+  In order to avoid ambiguous conversions, this is only allowed when compiling with C++11\n+  where it is marked as explicit.\n+  */\n+  explicit\n+  operator bool() const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+    return plumed_valid(main);\n+  }\n+#endif\n+\n+  /**\n+     Returns the number of references to this object. Available as of PLUMED 2.5.\n+    \\note Equivalent to plumed_use_count()\n+  */\n+  int useCount() const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+    return plumed_use_count(main);\n+  }\n+\n+#if __PLUMED_WRAPPER_GLOBAL /*{*/\n+  /**\n+     Check if global-plumed has been initialized\n+     \\return true if global plumed object (see global()) is initialized (i.e. if gcreate() has been\n+             called), false otherwise.\n+     \\note Equivalent to plumed_ginitialized() but returns a bool\n+  */\n+  static bool ginitialized() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+    return plumed_ginitialized();\n+  }\n+  /**\n+     Check if global-plumed is valid\n+     \\return true if global plumed object (see global()) is valid.\n+     \\note Equivalent to plumed_gvalid() but returns a bool\n+  */\n+  static bool gvalid() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+    return plumed_gvalid();\n+  }\n+  /**\n+     Initialize global-plumed.\n+     \\note Equivalent to plumed_gcreate()\n+  */\n+  static void gcreate() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+    plumed_gcreate();\n+  }\n+  /**\n+     Send a command to global-plumed\n+      \\param key The name of the command to be executed\n+      \\param val The argument. It is declared as const to allow calls like gcmd(\"A\",\"B\"),\n+                 but for some choice of key it can change the content\n+     \\note Equivalent to plumed_gcmd()\n+  */\n+  static void gcmd(const char* key,const void* val=NULL) {\n+    global().cmd(key,val);\n+  }\n+  /**\n+     Finalize global-plumed\n+  */\n+  static void gfinalize() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+    plumed_gfinalize();\n+  }\n+  /**\n+     Returns the Plumed global object\n+\n+     Notice that the object is copied, thus increasing the reference counter of the\n+     global object. In this manner, the global object will survive after a call to\n+     \\ref gfinalize() if the resulting object is still in scope.\n+\n+     \\return The Plumed global object\n+  */\n+  static Plumed global() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+    return Plumed(plumed_global());\n+  }\n+#endif /*}*/\n+  /**\n+     Constructor.\n+\n+    Notice that when using runtime binding the constructed object might be\n+    invalid. One might check it using the \\ref valid() method.\n+\n+    \\note Performs the same task a plumed_create()\n+  */\n+Plumed()__PLUMED_WRAPPER_CXX_NOEXCEPT :\n+#if __PLUMED_WRAPPER_CXX_DEFAULT_INVALID\n+  main(plumed_create_invalid())\n+#else\n+  main(plumed_create())\n+#endif\n+  {\n+  }\n+\n+  /**\n+     Clone a Plumed object from a FORTRAN char* handler.\n+\n+     \\param c The FORTRAN handler (a char[32]).\n+\n+     The reference counter for the corresponding object will be increased\n+     to make sure that the object will be available after plumed_f_finalize is called\n+     if the created object is still in scope.\n+  */\n+__PLUMED_WRAPPER_CXX_EXPLICIT Plumed(const char*c)__PLUMED_WRAPPER_CXX_NOEXCEPT :\n+  main(plumed_create_reference_f(c))\n+  {\n+  }\n+\n+  /**\n+    Create a reference from a void* pointer. Available as of PLUMED 2.5.\n+  */\n+__PLUMED_WRAPPER_CXX_EXPLICIT Plumed(void*v)__PLUMED_WRAPPER_CXX_NOEXCEPT :\n+  main(plumed_create_reference_v(v))\n+  {\n+  }\n+\n+  /**\n+     Clone a Plumed object from a C plumed structure\n+\n+     \\param p The C plumed structure.\n+\n+     The reference counter for the corresponding object will be increased\n+     to make sure that the object will be available after plumed_finalize is called\n+     if the created object is still in scope.\n+  */\n+__PLUMED_WRAPPER_CXX_EXPLICIT Plumed(plumed p)__PLUMED_WRAPPER_CXX_NOEXCEPT :\n+  main(plumed_create_reference(p))\n+  {\n+  }\n+\n+  /** Copy constructor.\n+\n+    Takes a reference, incrementing the reference counter of the corresponding object.\n+  */\n+Plumed(const Plumed& p)__PLUMED_WRAPPER_CXX_NOEXCEPT :\n+  main(plumed_create_reference(p.main))\n+  {\n+  }\n+\n+  /** Assignment operator. Available as of PLUMED 2.5.\n+\n+    Takes a reference,incrementing the reference counter of the corresponding object.\n+  */\n+  Plumed&operator=(const Plumed&p) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+    if(this != &p) {\n+// the check is needed to avoid calling plumed_finalize on moved objects\n+      if(main.p) decref();\n+      main=plumed_create_reference(p.main);\n+    }\n+    return *this;\n+  }\n+\n+  /*\n+    PLUMED >= 2.4 requires a C++11 compiler.\n+    Anyway, since Plumed.h file might be redistributed with other codes\n+    and it should be possible to combine it with earlier PLUMED versions,\n+    we here explicitly check if C+11 is available before enabling move semantics.\n+  */\n+#if __cplusplus > 199711L\n+  /** Move constructor. Available as of PLUMED 2.5.\n+    Only if move semantics is enabled.\n+  */\n+Plumed(Plumed&&p)__PLUMED_WRAPPER_CXX_NOEXCEPT :\n+  main(p.main)\n+  {\n+    p.main.p=nullptr;\n+  }\n+  /** Move assignment. Available as of PLUMED 2.5.\n+    Only if move semantics is enabled.\n+  */\n+  Plumed& operator=(Plumed&&p)__PLUMED_WRAPPER_CXX_NOEXCEPT  {\n+    if(this != &p) {\n+// the check is needed to avoid calling plumed_finalize on moved objects\n+      if(main.p) decref();\n+      main=p.main;\n+      p.main.p=nullptr;\n+    }\n+    return *this;\n+  }\n+#endif\n+  /**\n+    Create a PLUMED object loading a specific kernel. Available as of PLUMED 2.5.\n+\n+    It returns an object created with \\ref plumed_create_dlopen. The object is owned and\n+    is then finalized in the destructor. It can be used as follows:\n+  \\verbatim\n+    PLMD::Plumed p = PLMD::Plumed::dlopen(\"/path/to/libplumedKernel.so\");\n+  // or, equivalenty:\n+  //    PLMD::Plumed p(PLMD::Plumed::dlopen(\"/path/to/libplumedKernel.so\"));\n+    p.cmd(\"init\");\n+  \\endverbatim\n+    or, equivalently, as\n+  \\verbatim\n+    auto p = PLMD::Plumed::dlopen(\"/path/to/libplumedKernel.so\");\n+    p.cmd(\"init\");\n+  \\endverbatim\n+  */\n+  static Plumed dlopen(const char* path)__PLUMED_WRAPPER_CXX_NOEXCEPT  {\n+// use decref to remove the extra reference\n+    return Plumed(plumed_create_dlopen(path)).decref();\n+  }\n+\n+  /**\n+    Create a PLUMED object loading a specific kernel. Available as of PLUMED 2.5.\n+\n+    Same as \\ref dlopen(const char* path), but allows a dlopen mode to be chosen explicitly.\n+  */\n+  static Plumed dlopen(const char* path,int mode)__PLUMED_WRAPPER_CXX_NOEXCEPT  {\n+// use decref to remove the extra reference\n+    return Plumed(plumed_create_dlopen2(path,mode)).decref();\n+  }\n+  /** Invalid constructor. Available as of PLUMED 2.5.\n+\n+    Can be used to initialize an invalid object. It might be useful to postpone\n+    the initialization of a Plumed object. Consider the following case\n+  \\verbatim\n+    Plumed p;\n+    setenv(\"PLUMED_KERNEL\",\"/path/to/kernel/libplumedKernel.so\",1);\n+    p.cmd(\"init\")\n+  \\endverbatim\n+    Here the `p` object will be initialized *before* the `PLUMED_KERNEL` env var has been set.\n+    This can be particularly problematic if `p` is stored in some high level class.\n+    The following case would do the job\n+  \\verbatim\n+    Plumed p;\n+    setenv(\"PLUMED_KERNEL\",\"/path/to/kernel/libplumedKernel.so\",1);\n+    p=Plumed();\n+    p.cmd(\"init\")\n+  \\endverbatim\n+    However, there will be some error reported related to the attempt to load the kernel\n+    when `p` is initialized. The following solution is the optimal one:\n+  \\verbatim\n+    Plumed p(Plumed::makeInvalid());\n+    setenv(\"PLUMED_KERNEL\",\"/path/to/kernel/libplumedKernel.so\",1);\n+    p=Plumed();\n+    p.cmd(\"init\")\n+  \\endverbatim\n+  */\n+  static Plumed makeInvalid() __PLUMED_WRAPPER_CXX_NOEXCEPT  {\n+// use decref to remove the extra reference\n+    return Plumed(plumed_create_invalid()).decref();\n+  }\n+\n+  /**\n+    Create a valid PLMD::Plumed object.\n+\n+    Can be used to create a valid object e.g. when Plumed.h was compiled with\n+    `-D__PLUMED_WRAPPER_CXX_DEFAULT_INVALID`. For internal usage.\n+  */\n+\n+  static Plumed makeValid()__PLUMED_WRAPPER_CXX_NOEXCEPT  {\n+// use decref to remove the extra reference\n+    return Plumed(plumed_create()).decref();\n+  }\n+\n+\n+  /**\n+     Retrieve the C plumed structure for this object.\n+\n+     Notice that the resulting plumed structure is a weak reference and\n+     should NOT be finalized, unless a new reference is explicitly added\n+  \\verbatim\n+  Plumed p;\n+  plumed c=p;\n+  plumed_finalize(c); // <- this is wrong\n+  \\endverbatim\n+  \\verbatim\n+  Plumed p;\n+  plumed c=plumed_create_reference(p);\n+  plumed_finalize(c); // <- this is right\n+  \\endverbatim\n+  */\n+  operator plumed()const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+    return main;\n+  }\n+\n+  /**\n+     Retrieve a FORTRAN handler for this object\n+      \\param c The FORTRAN handler (a char[32]).\n+    Notice that the resulting plumed structure is a weak reference and\n+    should NOT be finalized, unless a new reference is explicitly added.\n+  */\n+  void toFortran(char*c)const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+    plumed_c2f(main,c);\n+  }\n+\n+  /**\n+     Retrieve a void* handler for this object. Available as of PLUMED 2.5.\n+    Notice that the resulting plumed structure is a weak reference and\n+    should NOT be finalized, unless a new reference is explicitly added.\n+  */\n+  void* toVoid()const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+    return plumed_c2v(main);\n+  }\n+\n+  /**\n+    Increase reference counter. Available as of PLUMED 2.5.\n+\n+    Using this method improperly might interfere with correct object construction\n+    and destruction.\n+    If you want to play with this, also try to compile using `-D__PLUMED_WRAPPER_DEBUG_REFCOUNT=1` and see what happens.\n+\n+    A possible usage is to transfer the ownership of a temporary\n+    object when it is converted\n+  \\verbatim\n+  plumed p=Plumed::dlopen(path).incref()\n+  // without incref(), the just constructed object will be destroyed\n+  // when the temporary object is deleted.\n+  ... do stuff ...\n+  plumed_finalize(p);\n+  \\endverbatim\n+\n+  */\n+  Plumed& incref() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+    plumed_create_reference(main);\n+    return *this;\n+  }\n+\n+  /**\n+    Decrease reference counter. Available as of PLUMED 2.5.\n+\n+    Using this method improperly might interfere with correct object construction\n+    and destruction.\n+    If you want to play with this, also try to compile using `-D__PLUMED_WRAPPER_DEBUG_REFCOUNT=1` and see what happens.\n+  */\n+  Plumed& decref() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+// calling decref on a moved plumed object should give an error, so we do not check if main.p!=NULL here:\n+    plumed_finalize(main);\n+    return *this;\n+  }\n+\n+  /**\n+     Send a command to this plumed object\n+      \\param key The name of the command to be executed\n+      \\param val The argument. It is declared as const to allow calls like p.cmd(\"A\",\"B\"),\n+                 but for some choice of key it can change the content\n+      \\note Similar to \\ref plumed_cmd(). It actually called \\ref plumed_cmd_nothrow() and\n+            rethrow any exception raised within PLUMED.\n+  */\n+  void cmd(const char*key,const void*val=NULL) {\n+    NothrowHandler h;\n+    h.code=0;\n+    plumed_nothrow_handler nothrow= {&h,nothrow_handler};\n+    try {\n+      plumed_cmd_nothrow(main,key,val,nothrow);\n+    } catch (...) {\n+      /*\n+        When loading a kernel <=2.4, plumed_cmd_nothrow could throw an exception.\n+        If the exception is transmitted through the C interface and arrives here,\n+        we translate it so as to free the virtual tables of the loaded kernel.\n+      */\n+      rethrow();\n+    }\n+    if(h.code!=0) rethrow(h);\n+  }\n+\n+  /**\n+     Destructor\n+\n+     It calls \\ref plumed_finalize(). Notice that this is done also if the\n+     constructor failed (that is, if it returned an invalid object). This allows\n+     declaring Plumed objects also if PLUMED is actually not available, provided\n+     one does not use the \\ref cmd method.\n+\n+     Destructor is virtual so as to allow correct inheritance from Plumed object.\n+  */\n+#if __PLUMED_WRAPPER_CXX_POLYMORPHIC\n+  virtual\n+#endif\n+  ~Plumed() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+// the check is needed to avoid calling plumed_finalize on moved objects\n+    if(main.p) decref();\n+  }\n+};\n+\n+/**\n+  \\related Plumed\n+  Comparison operator. Available as of PLUMED 2.5.\n+*/\n+inline\n+bool operator==(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+  return a.toVoid()==b.toVoid();\n+}\n+\n+/**\n+  \\related Plumed\n+  Comparison operator. Available as of PLUMED 2.5.\n+*/\n+inline\n+bool operator!=(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+  return a.toVoid()!=b.toVoid();\n+}\n+\n+/**\n+  \\related Plumed\n+  Comparison operator. Available as of PLUMED 2.5.\n+*/\n+inline\n+bool operator<=(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+  return a.toVoid()<=b.toVoid();\n+}\n+\n+/**\n+  \\related Plumed\n+  Comparison operator. Available as of PLUMED 2.5.\n+*/\n+inline\n+bool operator<(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+  return a.toVoid()<b.toVoid();\n+}\n+\n+/**\n+  \\related Plumed\n+  Comparison operator. Available as of PLUMED 2.5.\n+*/\n+inline\n+bool operator>=(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+  return a.toVoid()>=b.toVoid();\n+}\n+\n+/**\n+  \\related Plumed\n+  Comparison operator. Available as of PLUMED 2.5.\n+*/\n+inline\n+bool operator>(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n+  return a.toVoid()>b.toVoid();\n+}\n+\n+__PLUMED_WRAPPER_ANONYMOUS_END /*}*/\n+\n+}\n+\n+#endif /*}*/\n+\n+#endif /*}*/\n+\n+/* END OF DECLARATIONS */\n+\n+/*\n+\n+  1: emit implementation\n+  0: do not emit implementation\n+\n+  Allows an implementation to be emitted together with the declarations.\n+\n+  Used to decide if definitions should be emitted. This macro could have a different\n+  value when Plumed.h is reincluded. As a consequence, we map it to a local\n+  macro (__PLUMED_WRAPPER_IMPLEMENTATION_) that is reset at the end of this file.\n+*/\n+\n+#ifdef __PLUMED_WRAPPER_IMPLEMENTATION\n+#define __PLUMED_WRAPPER_IMPLEMENTATION_ __PLUMED_WRAPPER_IMPLEMENTATION\n+#else\n+#define __PLUMED_WRAPPER_IMPLEMENTATION_ 0\n+#endif\n+\n+/* BEGINNING OF DEFINITIONS */\n+\n+#if __PLUMED_WRAPPER_IMPLEMENTATION_  /*{*/\n+#ifndef __PLUMED_wrapper_Plumed_implementation /*{*/\n+#define __PLUMED_wrapper_Plumed_implementation\n+\n+/*\n+  the following macros only control the implementation\n+*/\n+\n+/*\n+  1: enable the definition of plumed_symbol_table_reexport\n+  0: does not enable the definition of plumed_symbol_table_reexport\n+\n+  This is only needed in the official plumed library to make\n+  the symbol table available. This is a hack to reexport the function table\n+  and is only needed when creating the library libplumed.so.\n+*/\n+\n+#ifndef __PLUMED_WRAPPER_REEXPORT_SYMBOL_TABLE\n+#define __PLUMED_WRAPPER_REEXPORT_SYMBOL_TABLE 0\n+#endif\n+\n+/*\n+  1: write on stderr changes in reference counters\n+  0: do not write changes in reference counters\n+\n+  Used for debugging.\n+\n+  Only used in definitions.\n+*/\n+\n+#ifndef __PLUMED_WRAPPER_DEBUG_REFCOUNT\n+#define __PLUMED_WRAPPER_DEBUG_REFCOUNT 0\n+#endif\n+\n+/*\n+  1: emit plumed_kernel_register function (default)\n+  0: do not emit plumed_kernel_register function\n+\n+  This function is only needed to avoid an extra warning when loading old (<=2.4) kernels.\n+  We might change its default in the future.\n+\n+  Used only in definitions.\n+*/\n+\n+#ifndef __PLUMED_WRAPPER_KERNEL_REGISTER\n+#define __PLUMED_WRAPPER_KERNEL_REGISTER 1\n+#endif\n+\n+/*\n+  1: emit Fortran wrappers\n+  0: do not emit Fortran wrappers (default)\n+\n+  Used only in definitions.\n+*/\n+\n+#ifndef __PLUMED_WRAPPER_FORTRAN\n+#define __PLUMED_WRAPPER_FORTRAN 0\n+#endif\n+\n+/*\n+  With internal interface, it does not make sence to emit kernel register or fortran interfaces\n+*/\n+\n+#if ! __PLUMED_WRAPPER_EXTERN /*{*/\n+#undef __PLUMED_WRAPPER_KERNEL_REGISTER\n+#define __PLUMED_WRAPPER_KERNEL_REGISTER 0\n+#undef __PLUMED_WRAPPER_FORTRAN\n+#define __PLUMED_WRAPPER_FORTRAN 0\n+#endif /*}*/\n+\n+#ifdef __PLUMED_HAS_DLOPEN\n+#include <dlfcn.h> /* dlopen dlerror dlsym */\n+#endif\n+\n+#if __PLUMED_WRAPPER_CXX_STD\n+#include <cstdio>  /* fprintf */\n+#include <cstring> /* memcpy strlen strncpy memcmp memmove strcmp memcpy */\n+#include <cassert> /* assert */\n+#include <cstdlib> /* getenv malloc free abort exit */\n+#include <climits> /* CHAR_BIT */\n+#else\n+#include <stdio.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdlib.h>\n+#include <limits.h>\n+#endif\n+\n+/**\n+  Function pointer to plumed_create\n+*/\n+\n+typedef void*(*plumed_create_pointer)(void);\n+/**\n+  Function pointer to plumed_cmd\n+*/\n+typedef void(*plumed_cmd_pointer)(void*,const char*,const void*);\n+\n+/**\n+  Function pointer to plumed_finalize\n+*/\n+typedef void(*plumed_finalize_pointer)(void*);\n+\n+/**\n+   Holder for plumedmain function pointers.\n+*/\n+typedef struct {\n+  plumed_create_pointer create;\n+  plumed_cmd_pointer cmd;\n+  plumed_finalize_pointer finalize;\n+} plumed_plumedmain_function_holder;\n+\n+/**\n+  Holder for plumed symbol table.\n+\n+  The table contains pointers to function exported from plumed. Functions can be added increasing the version number.\n+  Notice that the default way to extend functionalities is by adding cmd strings. This is a last resort, and all new\n+  functions should be explicitly motivated. Here's the addition:\n+\n+  version=2, cmd_nothrow.\n+\n+  This function accepts an extra argument `plumed_nothrow_handler*handler`.\n+  In case an exception is thrown withint plumed, it just calls `handler->handler(handler->ptr,code,message,opt)` and return.\n+  An alternative would have been to install an error handler (with a call to cmd(\"setErrorHandler\")). However, the cost\n+  of doing it everytime Plumed::cmd is called is too high. On the other hand, installing it only at object construction\n+  is very risky since and object created in that way would not report any error if manipulated from the C interface.\n+  So, it looks like this is the only possibility.\n+\n+*/\n+typedef struct {\n+  /**\n+    Version number.\n+\n+    Minimum value is 1.\n+  */\n+  int version;\n+  /**\n+    Pointers to standard plumed functions (create/cmd/finalize).\n+\n+    Always available.\n+  */\n+  plumed_plumedmain_function_holder functions;\n+  /**\n+    Pointer to a cmd function guaranteed not to throw exceptions.\n+\n+    Available with version>=2.\n+  */\n+  void (*cmd_nothrow)(void*plumed,const char*key,const void*val,plumed_nothrow_handler);\n+} plumed_symbol_table_type;\n+\n+/* Utility to convert function pointers to pointers, just for the sake of printing them */\n+#define __PLUMED_CONVERT_FPTR(ptr,fptr) { ptr=NULL; __PLUMED_WRAPPER_STD memcpy(&ptr,&fptr,(sizeof(fptr)>sizeof(ptr)?sizeof(ptr):sizeof(fptr))); }\n+\n+#define __PLUMED_GETENV __PLUMED_WRAPPER_STD getenv\n+#define __PLUMED_FPRINTF __PLUMED_WRAPPER_STD fprintf\n+#define __PLUMED_MALLOC __PLUMED_WRAPPER_STD malloc\n+#define __PLUMED_FREE __PLUMED_WRAPPER_STD free\n+\n+/**\n+  Historically (PLUMED<=2.4) register for plumedmain function pointers.\n+  As of PLUMED>=2.5, this function does not do anything except for reporting the attempt to register\n+  something. It always returns NULL. The function should be here anyway to allow an incomplete\n+  libplumedKernel (<=2.4), expecting this function to be present, to be loaded correctly.\n+*/\n+#if __PLUMED_WRAPPER_KERNEL_REGISTER\n+/* Since it is only called from outside, it must be hardcoded to be extern */\n+__PLUMED_WRAPPER_EXTERN_C_BEGIN /*{*/\n+extern plumed_plumedmain_function_holder* plumed_kernel_register(const plumed_plumedmain_function_holder*);\n+plumed_plumedmain_function_holder* plumed_kernel_register(const plumed_plumedmain_function_holder* f) {\n+  void* tmpptr;\n+  if(f) {\n+    if(__PLUMED_GETENV(\"PLUMED_LOAD_DEBUG\")) {\n+      __PLUMED_FPRINTF(stderr,\"+++ Ignoring registration at %p (\",(void*)f);\n+      __PLUMED_CONVERT_FPTR(tmpptr,f->create);\n+      __PLUMED_FPRINTF(stderr,\"%p,\",tmpptr);\n+      __PLUMED_CONVERT_FPTR(tmpptr,f->cmd);\n+      __PLUMED_FPRINTF(stderr,\"%p,\",tmpptr);\n+      __PLUMED_CONVERT_FPTR(tmpptr,f->finalize);\n+      __PLUMED_FPRINTF(stderr,\"%p) +++\\n\",tmpptr);\n+    }\n+  }\n+  return NULL;\n+}\n+__PLUMED_WRAPPER_EXTERN_C_END /*}*/\n+#endif\n+\n+#if defined( __PLUMED_HAS_DLOPEN) /*{*/\n+/**\n+Try to dlopen a path with a given mode.\n+If the dlopen command fails, it tries to strip the `Kernel` part of the name.\n+\n+This function is declared static (internal linkage) so that it is not visible from outside.\n+It is first declared then defined to make sure it is a regular C static function.\n+*/\n+\n+__PLUMED_WRAPPER_INTERNALS_BEGIN\n+void* plumed_attempt_dlopen(const char*path,int mode) {\n+  char* pathcopy;\n+  void* p;\n+  char* pc;\n+  size_t strlenpath;\n+  FILE* fp;\n+  pathcopy=NULL;\n+  p=NULL;\n+  pc=NULL;\n+  strlenpath=0;\n+  fp=__PLUMED_WRAPPER_STD fopen(path,\"r\");\n+  if(!fp) {\n+    __PLUMED_FPRINTF(stderr,\"+++ File %s does not exist or cannot be read\\n\",path);\n+    return NULL;\n+  }\n+  __PLUMED_WRAPPER_STD fclose(fp);\n+  dlerror();\n+  p=dlopen(path,mode);\n+  if(!p) {\n+    /*\n+      Something went wrong. We try to remove \"Kernel\" string from the PLUMED_KERNEL variable\n+      and load directly the shared library. Notice that this particular path is only expected\n+      to be necessary when using PLUMED<=2.4 and the symbols in the main executable are\n+      not visible. All the other cases (either PLUMED>=2.5 or symbols in the main executable visible)\n+      should work correctly without entering here.\n+    */\n+    __PLUMED_FPRINTF(stderr,\"+++ An error occurred. Message from dlopen(): %s +++\\n\",dlerror());\n+    strlenpath=__PLUMED_WRAPPER_STD strlen(path);\n+    pathcopy=(char*) __PLUMED_MALLOC(strlenpath+1);\n+    __PLUMED_WRAPPER_STD strncpy(pathcopy,path,strlenpath+1);\n+    pc=pathcopy+strlenpath-6;\n+    while(pc>=pathcopy && __PLUMED_WRAPPER_STD memcmp(pc,\"Kernel\",6)) pc--;\n+    if(pc>=pathcopy) {\n+      __PLUMED_WRAPPER_STD memmove(pc, pc+6, __PLUMED_WRAPPER_STD strlen(pc)-5);\n+      __PLUMED_FPRINTF(stderr,\"+++ This error is expected if you are trying to load a kernel <=2.4\\n\");\n+      __PLUMED_FPRINTF(stderr,\"+++ Trying %s +++\\n\",pathcopy);\n+      fp=__PLUMED_WRAPPER_STD fopen(path,\"r\");\n+      if(!fp) {\n+        __PLUMED_FPRINTF(stderr,\"+++ File %s does not exist or cannot be read\\n\",pathcopy);\n+        __PLUMED_FREE(pathcopy);\n+        return NULL;\n+      }\n+      __PLUMED_WRAPPER_STD fclose(fp);\n+      dlerror();\n+      p=dlopen(pathcopy,mode);\n+      if(!p) __PLUMED_FPRINTF(stderr,\"+++ An error occurred. Message from dlopen(): %s +++\\n\",dlerror());\n+    }\n+    __PLUMED_FREE(pathcopy);\n+  }\n+  return p;\n+}\n+__PLUMED_WRAPPER_INTERNALS_END\n+\n+/**\n+  Utility to search for a function.\n+*/\n+#define __PLUMED_SEARCH_FUNCTION(tmpptr,handle,func,name,debug) \\\n+  if(!func) { \\\n+    tmpptr=dlsym(handle,name); \\\n+    if(tmpptr) { \\\n+      *(void **)(&func)=tmpptr; \\\n+      if(debug) __PLUMED_FPRINTF(stderr,\"+++ %s found at %p +++\\n\",name,tmpptr); \\\n+    } else { \\\n+      if(debug) __PLUMED_FPRINTF(stderr,\"+++ Function %s not found\\n\",name); \\\n+    } \\\n+  }\n+\n+/**\n+Search symbols in a dlopened library.\n+\n+This function is declared static (internal linkage) so that it is not visible from outside.\n+*/\n+__PLUMED_WRAPPER_INTERNALS_BEGIN\n+void plumed_search_symbols(void* handle, plumed_plumedmain_function_holder* f,plumed_symbol_table_type** table) {\n+  plumed_plumedmain_function_holder functions;\n+  plumed_symbol_table_type* table_ptr;\n+  void* tmpptr;\n+  char* debug;\n+  functions.create=NULL;\n+  functions.cmd=NULL;\n+  functions.finalize=NULL;\n+  table_ptr=NULL;\n+  tmpptr=NULL;\n+  /*\n+    Notice that as of PLUMED 2.5 we ignore self registrations.\n+    Pointers are searched in the form of a single pointer to a structure, which\n+    is the standard way in PLUMED 2.5, as well as using alternative names used in\n+    PLUMED 2.0 to 2.4 (e.g. plumedmain_create) and in some intermediate versions between\n+    PLUMED 2.4 and 2.5 (e.g. plumed_plumedmain_create). The last chance is probably\n+    unnecessary and might be removed at some point.\n+  */\n+  debug=__PLUMED_GETENV(\"PLUMED_LOAD_DEBUG\");\n+  table_ptr=(plumed_symbol_table_type*) dlsym(handle,\"plumed_symbol_table\");\n+  if(table_ptr) functions=table_ptr->functions;\n+  if(debug) {\n+    if(table_ptr) {\n+      __PLUMED_FPRINTF(stderr,\"+++ plumed_symbol_table version %i found at %p +++\\n\",table_ptr->version,(void*)table_ptr);\n+      __PLUMED_FPRINTF(stderr,\"+++ plumed_function_pointers found at %p (\",(void*)&table_ptr->functions);\n+      __PLUMED_CONVERT_FPTR(tmpptr,functions.create);\n+      __PLUMED_FPRINTF(stderr,\"%p,\",tmpptr);\n+      __PLUMED_CONVERT_FPTR(tmpptr,functions.cmd);\n+      __PLUMED_FPRINTF(stderr,\"%p,\",tmpptr);\n+      __PLUMED_CONVERT_FPTR(tmpptr,functions.finalize);\n+      __PLUMED_FPRINTF(stderr,\"%p) +++\\n\",tmpptr);\n+    } else {\n+      __PLUMED_FPRINTF(stderr,\"+++ plumed_symbol_table (available in PLUMED>=2.5) not found, perhaps kernel is older +++\\n\");\n+    }\n+  }\n+  /* only searches if they were not found already */\n+  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.create,\"plumedmain_create\",debug);\n+  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.create,\"plumed_plumedmain_create\",debug);\n+  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.cmd,\"plumedmain_cmd\",debug);\n+  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.cmd,\"plumed_plumedmain_cmd\",debug);\n+  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.finalize,\"plumedmain_finalize\",debug);\n+  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.finalize,\"plumed_plumedmain_finalize\",debug);\n+  if(functions.create && functions.cmd && functions.finalize) {\n+    if(debug) __PLUMED_FPRINTF(stderr,\"+++ PLUMED was loaded correctly +++\\n\");\n+    *f=functions;\n+    if(table) *table=table_ptr;\n+  } else {\n+    if(!functions.create) __PLUMED_FPRINTF(stderr,\"+++ Pointer to (plumed_)plumedmain_create not found +++\\n\");\n+    if(!functions.cmd) __PLUMED_FPRINTF(stderr,\"+++ Pointer to (plumed_)plumedmain_cmd not found +++\\n\");\n+    if(!functions.finalize) __PLUMED_FPRINTF(stderr,\"+++ Pointer to (plumed_)plumedmain_finalize not found +++\\n\");\n+    f->create=NULL;\n+    f->cmd=NULL;\n+    f->finalize=NULL;\n+    if(table) *table=NULL;\n+  }\n+}\n+__PLUMED_WRAPPER_INTERNALS_END\n+\n+#endif /*}*/\n+\n+\n+#if __PLUMED_WRAPPER_REEXPORT_SYMBOL_TABLE\n+\n+/*\n+  Here is the case where plumed_symbol_table is\n+  visible as extern. We first declare it (together with plumed_symbol_table_init) ...\n+*/\n+\n+__PLUMED_WRAPPER_EXTERN_C_BEGIN\n+extern\n+plumed_symbol_table_type plumed_symbol_table;\n+__PLUMED_WRAPPER_EXTERN_C_END\n+__PLUMED_WRAPPER_EXTERN_C_BEGIN\n+extern\n+void plumed_symbol_table_init(void);\n+__PLUMED_WRAPPER_EXTERN_C_END\n+\n+/*\n+  ... and then make available a function that returns the address\n+  of the symbol table.\n+*/\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed_symbol_table_type* plumed_symbol_table_reexport() {\n+  /* make sure the table is initialized */\n+  plumed_symbol_table_init();\n+  return &plumed_symbol_table;\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+#else\n+\n+/*\n+  Here is the case where plumed_symbol_table is not\n+  visible as extern. We thus assume that plumed_symbol_table_reexport is\n+  available.\n+*/\n+\n+__PLUMED_WRAPPER_EXTERN_C_BEGIN\n+extern plumed_symbol_table_type* plumed_symbol_table_reexport();\n+__PLUMED_WRAPPER_EXTERN_C_END\n+#endif\n+\n+\n+/*\n+  Returns the global pointers, either those available at link time or those\n+  found in the library loaded at PLUMED_KERNEL env var.\n+  If plumed_symbol_table_ptr is not NULL, it is used to return a pointer to the symbol table\n+  (if available).\n+  Notice that problems can be detected checking if the functions have a NULL ptr.\n+  On the other hand, the symbol table pointer might be NULL just because the plumed version is <=2.4.\n+  If handle is not NULL, it is used to return a dlopen handle that could be subsequently dlclosed.\n+*/\n+__PLUMED_WRAPPER_INTERNALS_BEGIN\n+void plumed_retrieve_functions(plumed_plumedmain_function_holder* functions, plumed_symbol_table_type** plumed_symbol_table_ptr,void** handle) {\n+#if ! __PLUMED_WRAPPER_LINK_RUNTIME\n+  /*\n+    Real interface, constructed using the symbol table obtained with plumed_symbol_table_reexport.\n+    This makes the symbols hardcoded and independent of a mis-set PLUMED_KERNEL variable.\n+  */\n+  plumed_symbol_table_type* ptr=plumed_symbol_table_reexport();\n+  if(plumed_symbol_table_ptr) *plumed_symbol_table_ptr=ptr;\n+  if(handle) *handle=NULL;\n+  if(functions) *functions=ptr->functions;\n+#elif ! defined(__PLUMED_HAS_DLOPEN)\n+  /*\n+    When dlopen is not available, we hard code them to NULL\n+  */\n+  fprintf(stderr,\"+++ PLUMED has been compiled without dlopen and without a static kernel +++\\n\");\n+  plumed_plumedmain_function_holder g= {NULL,NULL,NULL};\n+  if(plumed_symbol_table_ptr) *plumed_symbol_table_ptr=NULL;\n+  if(handle) *handle=NULL;\n+  if(functions) *functions=g;\n+#else\n+  /*\n+    On the other hand, for runtime binding, we use dlsym to find the relevant functions.\n+  */\n+  plumed_plumedmain_function_holder g;\n+  /* search is done once and only once */\n+  const char* path;\n+  void* p;\n+  char* debug;\n+  int dlopenmode;\n+  g.create=NULL;\n+  g.cmd=NULL;\n+  g.finalize=NULL;\n+  path=__PLUMED_GETENV(\"PLUMED_KERNEL\");\n+  p=NULL;\n+  debug=__PLUMED_GETENV(\"PLUMED_LOAD_DEBUG\");\n+  dlopenmode=0;\n+  if(plumed_symbol_table_ptr) *plumed_symbol_table_ptr=NULL;\n+  if(handle) *handle=NULL;\n+#ifdef __PLUMED_DEFAULT_KERNEL\n+  /*\n+    This variable allows a default path for the kernel to be hardcoded.\n+    Can be useful for hardcoding the predefined plumed location\n+    still allowing the user to override this choice setting PLUMED_KERNEL.\n+    The path should be chosen at compile time adding e.g.\n+    -D__PLUMED_DEFAULT_KERNEL=/opt/local/lib/libplumed.dylib\n+  */\n+  /* This is required to add quotes */\n+#define PLUMED_QUOTE_DIRECT(name) #name\n+#define PLUMED_QUOTE(macro) PLUMED_QUOTE_DIRECT(macro)\n+  if(! (path && (*path) )) path=PLUMED_QUOTE(__PLUMED_DEFAULT_KERNEL);\n+#endif\n+  if(path && (*path)) {\n+    fprintf(stderr,\"+++ Loading the PLUMED kernel runtime +++\\n\");\n+    fprintf(stderr,\"+++ PLUMED_KERNEL=\\\"%s\\\" +++\\n\",path);\n+    if(debug) __PLUMED_FPRINTF(stderr,\"+++ Loading with mode RTLD_NOW\");\n+    dlopenmode=RTLD_NOW;\n+    if(__PLUMED_GETENV(\"PLUMED_LOAD_NAMESPACE\") && !__PLUMED_WRAPPER_STD strcmp(__PLUMED_GETENV(\"PLUMED_LOAD_NAMESPACE\"),\"LOCAL\")) {\n+      dlopenmode=dlopenmode|RTLD_LOCAL;\n+      if(debug) __PLUMED_FPRINTF(stderr,\"|RTLD_LOCAL\");\n+    } else {\n+      dlopenmode=dlopenmode|RTLD_GLOBAL;\n+      if(debug) __PLUMED_FPRINTF(stderr,\"|RTLD_GLOBAL\");\n+    }\n+#ifdef RTLD_DEEPBIND\n+    if(!__PLUMED_GETENV(\"PLUMED_LOAD_NODEEPBIND\")) {\n+      dlopenmode=dlopenmode|RTLD_DEEPBIND;\n+      if(debug) __PLUMED_FPRINTF(stderr,\"|RTLD_DEEPBIND\");\n+    }\n+#endif\n+    if(debug) __PLUMED_FPRINTF(stderr,\" +++\\n\");\n+    p=plumed_attempt_dlopen(path,dlopenmode);\n+    if(p) plumed_search_symbols(p,&g,plumed_symbol_table_ptr);\n+  }\n+  if(handle) *handle=p;\n+  if(functions) *functions=g;\n+#endif\n+}\n+__PLUMED_WRAPPER_INTERNALS_END\n+\n+/**\n+  Implementation.\n+  Small object used to store pointers directly into the plumed object defined in Plumed.h.\n+  This allows avoiding the extra function call to plumed_retrieve_functions at every cmd,\n+  at the cost of an extra indirection.\n+*/\n+typedef struct {\n+  /* allows errors with pointers to be found when debugging */\n+  char magic[6];\n+  /* reference count */\n+  int refcount;\n+  /* handler to dlopened library. NULL if there was no library opened */\n+  void* dlhandle;\n+  /* non zero if, upon destruction, the library should be dlclosed */\n+  int dlclose;\n+  /* 1 if path to kernel was taken from PLUMED_KERNEL var, 0 otherwise */\n+  int used_plumed_kernel;\n+  /* function pointers */\n+  plumed_plumedmain_function_holder functions;\n+  /* pointer to the symbol table. NULL if kernel <=2.4 */\n+  plumed_symbol_table_type* table;\n+  /* pointer to plumed object */\n+  void* p;\n+} plumed_implementation;\n+\n+__PLUMED_WRAPPER_INTERNALS_BEGIN\n+plumed_implementation* plumed_malloc_pimpl() {\n+  plumed_implementation* pimpl;\n+  /* allocate space for implementation object. this is free-ed in plumed_finalize(). */\n+  pimpl=(plumed_implementation*) __PLUMED_MALLOC(sizeof(plumed_implementation));\n+  if(!pimpl) {\n+    __PLUMED_FPRINTF(stderr,\"+++ Allocation error +++\\n\");\n+    __PLUMED_WRAPPER_STD abort();\n+  }\n+  __PLUMED_WRAPPER_STD memcpy(pimpl->magic,\"pLuMEd\",6);\n+  pimpl->refcount=1;\n+#if __PLUMED_WRAPPER_DEBUG_REFCOUNT\n+  fprintf(stderr,\"refcount: new at %p\\n\",(void*)pimpl);\n+#endif\n+  pimpl->dlhandle=NULL;\n+  pimpl->dlclose=0;\n+  pimpl->used_plumed_kernel=0;\n+  pimpl->functions.create=NULL;\n+  pimpl->functions.cmd=NULL;\n+  pimpl->functions.finalize=NULL;\n+  pimpl->table=NULL;\n+  pimpl->p=NULL;\n+  return pimpl;\n+}\n+__PLUMED_WRAPPER_INTERNALS_END\n+\n+#ifndef NDEBUG\n+\n+__PLUMED_WRAPPER_INTERNALS_BEGIN\n+int plumed_check_pimpl(plumed_implementation*pimpl) {\n+  if(!pimpl) return 0;\n+  if(__PLUMED_WRAPPER_STD memcmp(pimpl->magic,\"pLuMEd\",6)) return 0;\n+  return 1;\n+}\n+__PLUMED_WRAPPER_INTERNALS_END\n+#endif\n+\n+/* C wrappers: */\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_create(void) {\n+  /* returned object */\n+  plumed p;\n+  /* pointer to implementation */\n+  plumed_implementation* pimpl;\n+  /* allocate space for implementation object. this is free-ed in plumed_finalize(). */\n+  pimpl=plumed_malloc_pimpl();\n+  /* store pointers in pimpl */\n+  plumed_retrieve_functions(&pimpl->functions,&pimpl->table,&pimpl->dlhandle);\n+#if __PLUMED_WRAPPER_LINK_RUNTIME\n+  /* note if PLUMED_KERNEL variable was used */\n+  pimpl->used_plumed_kernel=1;\n+#endif\n+  /* note if handle should not be dlclosed */\n+  pimpl->dlclose=1;\n+  if(__PLUMED_GETENV(\"PLUMED_LOAD_DLCLOSE\") && !__PLUMED_WRAPPER_STD strcmp(__PLUMED_GETENV(\"PLUMED_LOAD_DLCLOSE\"),\"no\")) pimpl->dlclose=0;\n+  /* in case of failure, return */\n+  /* the resulting object should be plumed_finalized, though you cannot use plumed_cmd */\n+  if(!pimpl->functions.create) {\n+    /* store pimpl in returned object */\n+    p.p=pimpl;\n+    return p;\n+  }\n+  assert(pimpl->functions.cmd);\n+  assert(pimpl->functions.finalize);\n+  /* obtain object */\n+  pimpl->p=(*(pimpl->functions.create))();\n+  /* notice: we do not assert pimpl->p since in principle it might be nullptr */\n+  /* user might identify this using plumed_valid() */\n+  /* store pimpl in returned object */\n+  p.p=pimpl;\n+  return p;\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_create_dlopen(const char*path) {\n+  int dlopenmode;\n+  /* plumed_create_dlopen always uses RTLD_LOCAL and, when possible, RTLD_DEEPBIND to allow multiple versions */\n+#ifdef __PLUMED_HAS_DLOPEN\n+  dlopenmode=RTLD_NOW|RTLD_LOCAL;\n+#ifdef RTLD_DEEPBIND\n+  dlopenmode=dlopenmode|RTLD_DEEPBIND;\n+#endif\n+#else\n+  dlopenmode=0;\n+#endif\n+  return plumed_create_dlopen2(path,dlopenmode);\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_create_dlopen2(const char*path,int mode) {\n+  /* returned object */\n+  plumed p;\n+  /* pointer to implementation */\n+  plumed_implementation* pimpl;\n+  /* allocate space for implementation object. this is free-ed in plumed_finalize(). */\n+  pimpl=plumed_malloc_pimpl();\n+#ifdef __PLUMED_HAS_DLOPEN\n+  if(path) pimpl->dlhandle=plumed_attempt_dlopen(path,mode);\n+  /* mark this library to be dlclosed when the object is finalized */\n+  pimpl->dlclose=1;\n+  if(pimpl->dlhandle) plumed_search_symbols(pimpl->dlhandle,&pimpl->functions,&pimpl->table);\n+#endif\n+  if(!pimpl->functions.create) {\n+    p.p=pimpl;\n+    return p;\n+  }\n+  assert(pimpl->functions.cmd);\n+  assert(pimpl->functions.finalize);\n+  /* obtain object */\n+  pimpl->p=(*(pimpl->functions.create))();\n+  /* notice: we do not assert pimpl->p since in principle it might be nullptr */\n+  /* user might identify this using plumed_valid() */\n+  /* store pimpl in returned object */\n+  p.p=pimpl;\n+  return p;\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_create_reference(plumed p) {\n+  plumed_implementation* pimpl;\n+  /* obtain pimpl */\n+  pimpl=(plumed_implementation*) p.p;\n+  assert(plumed_check_pimpl(pimpl));\n+  /* increase reference count */\n+  pimpl->refcount++;\n+#if __PLUMED_WRAPPER_DEBUG_REFCOUNT\n+  fprintf(stderr,\"refcount: increase at %p\\n\",(void*)pimpl);\n+#endif\n+  return p;\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_create_reference_v(void*v) {\n+  return plumed_create_reference(plumed_v2c(v));\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_create_reference_f(const char*f) {\n+  return plumed_create_reference(plumed_f2c(f));\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_create_invalid() {\n+  plumed p;\n+  plumed_implementation* pimpl;\n+  pimpl=plumed_malloc_pimpl();\n+  p.p=pimpl;\n+  return p;\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+void plumed_cmd(plumed p,const char*key,const void*val) {\n+  plumed_implementation* pimpl;\n+  /* obtain pimpl */\n+  pimpl=(plumed_implementation*) p.p;\n+  assert(plumed_check_pimpl(pimpl));\n+  if(!pimpl->p) {\n+    __PLUMED_FPRINTF(stderr,\"+++ ERROR: You are trying to use an invalid plumed object. +++\\n\");\n+    if(pimpl->used_plumed_kernel) __PLUMED_FPRINTF(stderr,\"+++ Check your PLUMED_KERNEL environment variable. +++\\n\");\n+    __PLUMED_WRAPPER_STD exit(1);\n+  }\n+  assert(pimpl->functions.create);\n+  assert(pimpl->functions.cmd);\n+  assert(pimpl->functions.finalize);\n+  /* execute */\n+  (*(pimpl->functions.cmd))(pimpl->p,key,val);\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+void plumed_cmd_nothrow(plumed p,const char*key,const void*val,plumed_nothrow_handler nothrow) {\n+  plumed_implementation* pimpl;\n+  /* obtain pimpl */\n+  pimpl=(plumed_implementation*) p.p;\n+  assert(plumed_check_pimpl(pimpl));\n+  if(!pimpl->p) {\n+    if(pimpl->used_plumed_kernel) {\n+      nothrow.handler(nothrow.ptr,1,\"You are trying to use plumed, but it is not available.\\nCheck your PLUMED_KERNEL environment variable.\",NULL);\n+    } else {\n+      nothrow.handler(nothrow.ptr,1,\"You are trying to use plumed, but it is not available.\",NULL);\n+    }\n+    return;\n+  }\n+  assert(pimpl->functions.create);\n+  assert(pimpl->functions.cmd);\n+  assert(pimpl->functions.finalize);\n+  /* execute */\n+  if(pimpl->table && pimpl->table->version>1) (*(pimpl->table->cmd_nothrow))(pimpl->p,key,val,nothrow);\n+  else (*(pimpl->functions.cmd))(pimpl->p,key,val);\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+void plumed_finalize(plumed p) {\n+  plumed_implementation* pimpl;\n+  /* obtain pimpl */\n+  pimpl=(plumed_implementation*) p.p;\n+  assert(plumed_check_pimpl(pimpl));\n+  /* decrease reference count */\n+  pimpl->refcount--;\n+#if __PLUMED_WRAPPER_DEBUG_REFCOUNT\n+  fprintf(stderr,\"refcount: decrease at %p\\n\",(void*)pimpl);\n+#endif\n+  if(pimpl->refcount>0) return;\n+  /* to allow finalizing an invalid plumed object, we only call\n+     finalize if the object is valid */\n+  if(pimpl->p) {\n+    assert(pimpl->functions.create);\n+    assert(pimpl->functions.cmd);\n+    assert(pimpl->functions.finalize);\n+    /* finalize */\n+    (*(pimpl->functions.finalize))(pimpl->p);\n+  }\n+#ifdef __PLUMED_HAS_DLOPEN\n+  /* dlclose library */\n+  if(pimpl->dlhandle && pimpl->dlclose) {\n+    if(__PLUMED_GETENV(\"PLUMED_LOAD_DEBUG\")) fprintf(stderr,\"+++ Unloading library\\n\");\n+    dlclose(pimpl->dlhandle);\n+  }\n+#endif\n+#if __PLUMED_WRAPPER_DEBUG_REFCOUNT\n+  fprintf(stderr,\"refcount: delete at %p\\n\",(void*)pimpl);\n+#endif\n+  /* free pimpl space */\n+  __PLUMED_FREE(pimpl);\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+int plumed_valid(plumed p) {\n+  plumed_implementation* pimpl;\n+  /* obtain pimpl */\n+  pimpl=(plumed_implementation*) p.p;\n+  assert(plumed_check_pimpl(pimpl));\n+  if(pimpl->p) return 1;\n+  else return 0;\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+int plumed_use_count(plumed p) {\n+  plumed_implementation* pimpl;\n+  /* obtain pimpl */\n+  pimpl=(plumed_implementation*) p.p;\n+  assert(plumed_check_pimpl(pimpl));\n+  return pimpl->refcount;\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+int plumed_installed(void) {\n+  plumed p;\n+  int result;\n+  p=plumed_create();\n+  result=plumed_valid(p);\n+  plumed_finalize(p);\n+  return result;\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+#if __PLUMED_WRAPPER_GLOBAL /*{*/\n+\n+__PLUMED_WRAPPER_EXTERN_C_BEGIN\n+\n+/* we declare a Plumed_g_main object here, in such a way that it is always available */\n+\n+static plumed plumed_gmain= {NULL};\n+\n+plumed plumed_global(void) {\n+  return plumed_gmain;\n+}\n+\n+void plumed_gcreate(void) {\n+  /* should be created once */\n+  assert(plumed_gmain.p==NULL);\n+  plumed_gmain=plumed_create();\n+}\n+\n+void plumed_gcmd(const char*key,const void*val) {\n+  plumed_cmd(plumed_gmain,key,val);\n+}\n+\n+void plumed_gfinalize(void) {\n+  plumed_finalize(plumed_gmain);\n+  plumed_gmain.p=NULL;\n+}\n+\n+int plumed_ginitialized(void) {\n+  if(plumed_gmain.p) return 1;\n+  else        return 0;\n+}\n+\n+int plumed_gvalid() {\n+  assert(plumed_gmain.p);\n+  return plumed_valid(plumed_gmain);\n+}\n+\n+__PLUMED_WRAPPER_EXTERN_C_END\n+\n+#endif /*}*/\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+void plumed_c2f(plumed p,char*c) {\n+  unsigned i;\n+  unsigned char* cc;\n+  /*\n+    Convert the address stored in p.p into a proper FORTRAN string\n+    made of only ASCII characters. For this to work, the two following\n+    assertions should be satisfied:\n+  */\n+  assert(CHAR_BIT<=12);\n+  assert(sizeof(p.p)<=16);\n+\n+  assert(c);\n+  cc=(unsigned char*)&p.p;\n+  for(i=0; i<sizeof(p.p); i++) {\n+    /*\n+      characters will range between '0' (ASCII 48) and 'o' (ASCII 111=48+63)\n+    */\n+    c[2*i]=cc[i]/64+48;\n+    c[2*i+1]=cc[i]%64+48;\n+  }\n+  for(; i<16; i++) {\n+    c[2*i]=' ';\n+    c[2*i+1]=' ';\n+  }\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_f2c(const char*c) {\n+  plumed p;\n+  unsigned i;\n+  unsigned char* cc;\n+\n+  assert(CHAR_BIT<=12);\n+  assert(sizeof(p.p)<=16);\n+\n+  assert(c);\n+  cc=(unsigned char*)&p.p;\n+  for(i=0; i<sizeof(p.p); i++) {\n+    assert(c[2*i]>=48 && c[2*i]<48+64);\n+    assert(c[2*i+1]>=48 && c[2*i+1]<48+64);\n+    /*\n+      perform the reversed transform\n+    */\n+    cc[i]=(c[2*i]-48)*64 + (c[2*i+1]-48);\n+  }\n+  for(; i<16; i++) {\n+    assert(c[2*i]==' ');\n+    assert(c[2*i+1]==' ');\n+  }\n+  return p;\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+void* plumed_c2v(plumed p) {\n+  assert(plumed_check_pimpl((plumed_implementation*)p.p));\n+  return p.p;\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+__PLUMED_WRAPPER_C_BEGIN\n+plumed plumed_v2c(void* v) {\n+  assert(plumed_check_pimpl((plumed_implementation*)v));\n+  plumed p;\n+  p.p=v;\n+  return p;\n+}\n+__PLUMED_WRAPPER_C_END\n+\n+#if __PLUMED_WRAPPER_FORTRAN /*{*/\n+\n+/*\n+  Fortran wrappers\n+  These are just like the global C wrappers. They are\n+  just defined here and not declared since they\n+  should not be used from c/c++ anyway.\n+\n+  We use a macro that does the following:\n+  - declare a static function named NAME_static\n+  - declare a number of functions named NAME_ etc, with all possible\n+    fortran mangling schemes (zero, one, or two underscores, lower and upper case)\n+  - define the NAME_static function.\n+\n+  The static function is used basically as an inline function in a C-compatible manner.\n+*/\n+\n+#define __PLUMED_IMPLEMENT_FORTRAN(lower,upper,arg1,arg2) \\\n+  static void lower ## _static arg1; \\\n+  extern void lower      arg1 {lower ## _static arg2;} \\\n+  extern void lower ##_  arg1 {lower ## _static arg2;} \\\n+  extern void lower ##__ arg1 {lower ## _static arg2;} \\\n+  extern void upper      arg1 {lower ## _static arg2;} \\\n+  extern void upper ##_  arg1 {lower ## _static arg2;} \\\n+  extern void upper ##__ arg1 {lower ## _static arg2;} \\\n+  static void lower ## _static arg1\n+\n+/* FORTRAN wrappers would only make sense as extern \"C\" */\n+\n+__PLUMED_WRAPPER_EXTERN_C_BEGIN\n+\n+__PLUMED_IMPLEMENT_FORTRAN(plumed_f_create,PLUMED_F_CREATE,(char*c),(c)) {\n+  plumed_c2f(plumed_create(),c);\n+}\n+\n+__PLUMED_IMPLEMENT_FORTRAN(plumed_f_create_dlopen,PLUMED_F_CREATE_DLOPEN,(char*path,char*c),(path,c)) {\n+  plumed_c2f(plumed_create_dlopen(path),c);\n+}\n+\n+__PLUMED_IMPLEMENT_FORTRAN(plumed_f_create_reference,PLUMED_F_CREATE_REFERENCE,(char* r,char*c),(r,c)) {\n+  plumed_c2f(plumed_create_reference_f(r),c);\n+}\n+\n+__PLUMED_IMPLEMENT_FORTRAN(plumed_f_create_invalid,PLUMED_F_CREATE_INVALID,(char* c),(c)) {\n+  plumed_c2f(plumed_create_invalid(),c);\n+}\n+\n+__PLUMED_IMPLEMENT_FORTRAN(plumed_f_cmd,PLUMED_F_CMD,(char*c,char*key,void*val),(c,key,val)) {\n+  plumed_cmd(plumed_f2c(c),key,val);\n+}\n+\n+__PLUMED_IMPLEMENT_FORTRAN(plumed_f_finalize,PLUMED_F_FINALIZE,(char*c),(c)) {\n+  plumed_finalize(plumed_f2c(c));\n+}\n+\n+__PLUMED_IMPLEMENT_FORTRAN(plumed_f_installed,PLUMED_F_INSTALLED,(int*i),(i)) {\n+  assert(i);\n+  *i=plumed_installed();\n+}\n+\n+/* New in PLUMED 2.5 */\n+__PLUMED_IMPLEMENT_FORTRAN(plumed_f_valid,PLUMED_F_VALID,(char*c,int*i),(c,i)) {\n+  assert(i);\n+  *i=plumed_valid(plumed_f2c(c));\n+}\n+\n+__PLUMED_IMPLEMENT_FORTRAN(plumed_f_use_count,PLUMED_F_USE_COUNT,(char*c,int*i),(c,i)) {\n+  assert(i);\n+  *i=plumed_use_count(plumed_f2c(c));\n+}\n+\n+#if __PLUMED_WRAPPER_GLOBAL /*{*/\n+\n+__PLUMED_IMPLEMENT_FORTRAN(plumed_f_global,PLUMED_F_GLOBAL,(char*c),(c)) {\n+  plumed_c2f(plumed_gmain,c);\n+}\n+\n+__PLUMED_IMPLEMENT_FORTRAN(plumed_f_ginitialized,PLUMED_F_GINITIALIZED,(int*i),(i)) {\n+  assert(i);\n+  *i=plumed_ginitialized();\n+}\n+\n+__PLUMED_IMPLEMENT_FORTRAN(plumed_f_gcreate,PLUMED_F_GCREATE,(void),()) {\n+  plumed_gcreate();\n+}\n+\n+__PLUMED_IMPLEMENT_FORTRAN(plumed_f_gcmd,PLUMED_F_GCMD,(char*key,void*val),(key,val)) {\n+  plumed_gcmd(key,val);\n+}\n+\n+__PLUMED_IMPLEMENT_FORTRAN(plumed_f_gfinalize,PLUMED_F_GFINALIZE,(void),()) {\n+  plumed_gfinalize();\n+}\n+\n+/* New in PLUMED 2.5 */\n+__PLUMED_IMPLEMENT_FORTRAN(plumed_f_gvalid,PLUMED_F_GVALID,(int*i),(i)) {\n+  assert(i);\n+  *i=plumed_gvalid();\n+}\n+\n+#endif /*}*/\n+\n+__PLUMED_WRAPPER_EXTERN_C_END\n+\n+#endif /*}*/\n+\n+#endif /*}*/\n+\n+#endif /*}*/\n+\n+/* END OF DEFINITIONS */\n+\n+/* reset variable to allow it to be redefined upon re-inclusion */\n+\n+#undef __PLUMED_WRAPPER_IMPLEMENTATION_\n+\nEOF_EOF\npatch -u -l -b -F 5 -N --suffix=.preplumed \"./src/pmemd/src/Plumed_init.inc\" << \\EOF_EOF\n--- ./src/pmemd/src/Plumed_init.inc.preplumed\t2019-06-07 02:43:25.010386429 +0300\n+++ ./src/pmemd/src/Plumed_init.inc\t2019-06-07 02:45:26.266309842 +0300\n@@ -0,0 +1,36 @@\n+!  to be included in runmd.F90\n+\n+    call plumed_f_gcreate()\n+    call plumed_f_gcmd(\"setRealPrecision\"//char(0), 8)\n+    call plumed_f_gcmd(\"getApiVersion\"//char(0), plumed_version)\n+    if (plumed_version>1) then\n+      plumed_kbt = 2.0 * temp0 * boltz2\n+      call plumed_f_gcmd(\"setKbT\"//char(0), plumed_kbt)\n+    endif\n+    plumed_energyUnits = 4.184\n+    plumed_lengthUnits = 0.1\n+    plumed_timeUnits = 1.0\n+    plumed_chargeUnits = 1.0/18.2223\n+    call plumed_f_gcmd(\"setMDEnergyUnits\"//char(0), plumed_energyUnits)\n+    call plumed_f_gcmd(\"setMDLengthUnits\"//char(0), plumed_lengthUnits)\n+    call plumed_f_gcmd(\"setMDTimeUnits\"//char(0), plumed_timeUnits)\n+    if (plumed_version > 3) then\n+      call plumed_f_gcmd(\"setMDChargeUnits\"//char(0), plumed_chargeUnits)\n+    endif\n+    call plumed_f_gcmd(\"setPlumedDat\"//char(0), &\n+                       trim(adjustl(plumedfile))//char(0))\n+    call plumed_f_gcmd(\"setNatoms\"//char(0), atm_cnt) ! natom\n+    call plumed_f_gcmd(\"setMDEngine\"//char(0), \"amber\")\n+    call plumed_f_gcmd(\"setTimestep\"//char(0), dt)\n+#  ifdef MPI\n+    call plumed_f_gcmd(\"setMPIFComm\"//char(0), pmemd_comm)\n+    if (numgroups>1) then\n+      call plumed_f_gcmd(\"GREX setMPIFIntracomm\"//char(0), pmemd_comm)\n+      if (master) then\n+        call plumed_f_gcmd(\"GREX setMPIFIntercomm\"//char(0), pmemd_master_comm)\n+      endif\n+      call plumed_f_gcmd(\"GREX init\"//char(0), 0)\n+    endif\n+#  endif\n+    call plumed_f_gcmd(\"init\"//char(0), 0)\n+\nEOF_EOF\npatch -u -l -b -F 5 -N --suffix=.preplumed \"./src/pmemd/src/runmd.F90\" << \\EOF_EOF\n--- ./src/pmemd/src/runmd.F90.preplumed\t2019-09-04 17:37:24.889880042 +0300\n+++ ./src/pmemd/src/runmd.F90\t2019-09-10 17:59:19.169107755 +0300\n@@ -255,10 +255,18 @@\n   logical               :: update_gamd\n   double precision      :: VmaxDt,VminDt,VavgDt,sigmaVDt\n   double precision      :: VmaxPt,VminPt,VavgPt,sigmaVPt\n   integer,save          :: counts=0\n \n+! PLUMED\n+  double precision      :: plumed_box(3,3), plumed_virial(3,3), plumed_kbt\n+  integer               :: plumed_version, plumed_stopflag\n+  double precision      :: plumed_energyUnits, plumed_timeUnits, plumed_lengthUnits\n+  double precision      :: plumed_chargeUnits\n+  integer               :: plumed_need_pot_enes\n+  double precision      :: plumed_frc(3,atm_cnt)\n+\n ! Runmd operates in kcal/mol units for energy, amu for masses,\n ! and angstoms for distances.  To convert the input time parameters\n ! from picoseconds to internal units, multiply by 20.455\n ! (which is 10.0 * sqrt(4.184)).\n \n@@ -493,10 +501,15 @@\n \n ! Clean up the velocity if belly run:\n \n   if (belly) call bellyf(atm_cnt, atm_igroup, vel)\n \n+! PLUMED\n+  if (plumed == 1) then\n+#   include \"Plumed_init.inc\"\n+  endif\n+\n ! Make a first dynamics step:\n \n   irespa = 1    ! PME respa step counter.\n   if (usemidpoint) then\n    proc_new_list = .true.\n@@ -515,10 +528,27 @@\n \n     if(.not.usemidpoint) then\n        if (infe .ne. 0) nfe_real_mdstep = .False.\n     end if\n \n+! PLUMED\n+  if (plumed == 1) then\n+    plumed_stopflag = 0\n+    plumed_need_pot_enes = 0\n+\n+    call plumed_f_gcmd(\"setStep\"//char(0), nstep)\n+    call plumed_f_gcmd(\"prepareDependencies\"//char(0), 0)\n+\n+    ! May be call to isEnergyNeeded isn't necessary here because of explicit assignment above.\n+    ! However, it could change in future so I'll let it be here\n+    call plumed_f_gcmd(\"isEnergyNeeded\"//char(0), plumed_need_pot_enes)\n+\n+    if (plumed_need_pot_enes > 0) then\n+      need_pot_enes = .true.\n+    end if\n+  end if\n+\n     ! Calculate the force.  This also does ekcmt if a regular pme run:\n \n     call update_time(runmd_time)\n \n     if (using_pme_potential) then\n@@ -648,10 +678,31 @@\n     ! local NMR step counter:\n     if (.not. usemidpoint) then\n       call nmrdcp\n     end if\n \n+! PLUMED\n+    if (plumed == 1) then\n+#ifdef CUDA\n+      call gpu_download_crd(crd)\n+\n+      if (plumed_need_pot_enes > 0) then\n+        call gpu_download_frc(frc)\n+      end if\n+#endif\n+\n+#     include \"Plumed_force.inc\"\n+\n+#ifdef CUDA\n+      if (plumed_need_pot_enes > 0) then\n+        call gpu_upload_frc(frc)\n+      else\n+        call gpu_upload_frc_add(plumed_frc)\n+      end if\n+#endif\n+    end if\n+\n     irespa = 1\n \n     ! The coordinates will not be changed between here and the next\n     ! run of force, so we can just set new_list to .false.\n \n@@ -1347,10 +1398,24 @@\n \n       ! Need the potential energy for MC barostat steps and SGLD reweighting\n       ! calculation\n       if (do_mcbar_trial .or. isgld .gt. 0) need_pot_enes = .true.\n \n+! PLUMED\n+      if (plumed == 1) then\n+        plumed_stopflag = 0\n+        plumed_need_pot_enes = 0\n+\n+        call plumed_f_gcmd(\"setStep\"//char(0), nstep)\n+        call plumed_f_gcmd(\"prepareDependencies\"//char(0), 0)\n+        call plumed_f_gcmd(\"isEnergyNeeded\"//char(0), plumed_need_pot_enes)\n+\n+        if (plumed_need_pot_enes > 0) then\n+          need_pot_enes = .true.\n+        end if\n+      end if\n+\n       call update_time(runmd_time)\n \n       if (using_pme_potential) then\n \n         ! Monte Carlo water movement and exchange - mcint > 0\n@@ -1547,10 +1612,32 @@\n #endif\n         end if\n         ti_ekin0(1) = ti_fac(1,1) * temp0\n         ti_ekin0(2) = ti_fac(2,1) * temp0\n       end if\n+\n+! PLUMED\n+      if (plumed == 1) then\n+#ifdef CUDA\n+        call gpu_download_crd(crd)\n+\n+        if (plumed_need_pot_enes > 0) then\n+          call gpu_download_frc(frc)\n+        end if\n+#endif\n+\n+#       include \"Plumed_force.inc\"\n+\n+#ifdef CUDA\n+        if (plumed_need_pot_enes > 0) then\n+          call gpu_upload_frc(frc)\n+        else\n+          call gpu_upload_frc_add(plumed_frc)\n+        end if\n+#endif\n+      end if\n+\n       ! Pressure coupling:\n \n       if (ntp .gt. 0) then\n \n         si(si_volume) = uc_volume\n@@ -4041,11 +4128,15 @@\n           end if\n         end if  ! end timlim check\n \n         call update_time(runmd_time)\n \n+! PLUMED\n+        if (plumed .ne. 0 .and. plumed_stopflag .ne. 0) goto 534\n       end do ! Major cycle back to new step unless we have reached our limit:\n+      \n+      534 continue\n \n #ifdef MPI\n       ! If timlim has been exceeded exit the REMD loop\n       if (timlim_exceeded .and.local_remd_method .ne. 0) then\n         local_numexchg = mdloop\n@@ -4174,10 +4265,13 @@\n \n   if (ti_mode .ne. 0) call ti_cleanup\n \n   call update_time(runmd_time)\n \n+! PLUMED\n+  if (plumed .ne. 0) call plumed_f_gfinalize()\n+\n   return\n \n   540 format(/5x, ' A V E R A G E S   O V E R ', i7, ' S T E P S', /)\n   541 format(/5x,' DV/DL, AVERAGES OVER ',i7,' STEPS',/)\n   542 format('|',79('='))\nEOF_EOF\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/patches/gromacs-2020.2.diff/src/gromacs/CMakeLists.txt.preplumed": "#\n# This file is part of the GROMACS molecular simulation package.\n#\n# Copyright (c) 2010,2011,2012,2013,2014,2015, The GROMACS development team.\n# Copyright (c) 2016,2017,2018,2019,2020, by the GROMACS development team, led by\n# Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,\n# and including many others, as listed in the AUTHORS file in the\n# top-level source directory and at http://www.gromacs.org.\n#\n# GROMACS is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public License\n# as published by the Free Software Foundation; either version 2.1\n# of the License, or (at your option) any later version.\n#\n# GROMACS is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with GROMACS; if not, see\n# http://www.gnu.org/licenses, or write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.\n#\n# If you want to redistribute modifications to GROMACS, please\n# consider that scientific software is very special. Version\n# control is crucial - bugs must be traceable. We will be happy to\n# consider code for inclusion in the official distribution, but\n# derived work must not be called official GROMACS. Details are found\n# in the README & COPYING files - if they are missing, get the\n# official version at http://www.gromacs.org.\n#\n# To help us fund GROMACS development, we humbly ask that you cite\n# the research papers on the package. Check out http://www.gromacs.org.\n\nset(LIBGROMACS_SOURCES)\n\nif (GMX_CLANG_CUDA)\n    include(gmxClangCudaUtils)\nendif()\n\nset_property(GLOBAL PROPERTY GMX_LIBGROMACS_SOURCES)\nset_property(GLOBAL PROPERTY GMX_LIBGROMACS_GPU_IMPL_SOURCES)\nset_property(GLOBAL PROPERTY GMX_INSTALLED_HEADERS)\nset_property(GLOBAL PROPERTY GMX_AVX_512_SOURCE)\n\nset(libgromacs_object_library_dependencies \"\")\nfunction (_gmx_add_files_to_property PROPERTY)\n    foreach (_file ${ARGN})\n        if (IS_ABSOLUTE \"${_file}\")\n            set_property(GLOBAL APPEND PROPERTY ${PROPERTY} ${_file})\n        else()\n            set_property(GLOBAL APPEND PROPERTY ${PROPERTY}\n                         ${CMAKE_CURRENT_LIST_DIR}/${_file})\n        endif()\n    endforeach()\nendfunction ()\n\nfunction (gmx_add_libgromacs_sources)\n    _gmx_add_files_to_property(GMX_LIBGROMACS_SOURCES ${ARGN})\nendfunction ()\n\n# TODO Reconsider this, as the CUDA driver API is probably a simpler\n# approach, at least for the build system. See Redmine #2530\nfunction (gmx_compile_cpp_as_cuda)\n    _gmx_add_files_to_property(GMX_LIBGROMACS_GPU_IMPL_SOURCES ${ARGN})\nendfunction ()\n\n# Add these contents first because linking their tests can take a lot\n# of time, so we want lots of parallel work still available after\n# linking starts.\nadd_subdirectory(utility)\n# Add normal contents\nadd_subdirectory(gmxlib)\nadd_subdirectory(mdlib)\nadd_subdirectory(applied_forces)\nadd_subdirectory(listed_forces)\nadd_subdirectory(nbnxm)\nadd_subdirectory(commandline)\nadd_subdirectory(domdec)\nadd_subdirectory(ewald)\nadd_subdirectory(fft)\nadd_subdirectory(gpu_utils)\nadd_subdirectory(hardware)\nadd_subdirectory(linearalgebra)\nadd_subdirectory(math)\nadd_subdirectory(mdrun)\nadd_subdirectory(mdrunutility)\nadd_subdirectory(mdspan)\nadd_subdirectory(mdtypes)\nadd_subdirectory(onlinehelp)\nadd_subdirectory(options)\nadd_subdirectory(pbcutil)\nadd_subdirectory(random)\nadd_subdirectory(restraint)\nadd_subdirectory(tables)\nadd_subdirectory(taskassignment)\nadd_subdirectory(timing)\nadd_subdirectory(topology)\nadd_subdirectory(trajectory)\nadd_subdirectory(swap)\nadd_subdirectory(essentialdynamics)\nadd_subdirectory(pulling)\nadd_subdirectory(awh)\nadd_subdirectory(simd)\nadd_subdirectory(imd)\nadd_subdirectory(compat)\nadd_subdirectory(mimic)\nadd_subdirectory(modularsimulator)\nif (NOT GMX_BUILD_MDRUN_ONLY)\n    add_subdirectory(gmxana)\n    add_subdirectory(gmxpreprocess)\n    add_subdirectory(correlationfunctions)\n    add_subdirectory(statistics)\n    add_subdirectory(analysisdata)\n    add_subdirectory(coordinateio)\n    add_subdirectory(trajectoryanalysis)\n    add_subdirectory(energyanalysis)\n    add_subdirectory(tools)\nendif()\n\nget_property(PROPERTY_SOURCES GLOBAL PROPERTY GMX_LIBGROMACS_SOURCES)\nlist(APPEND LIBGROMACS_SOURCES ${GMXLIB_SOURCES} ${MDLIB_SOURCES} ${PROPERTY_SOURCES})\n\n# This would be the standard way to include thread_mpi, but\n# we want libgromacs to link the functions directly\n#if(GMX_THREAD_MPI)\n#    add_subdirectory(thread_mpi)\n#endif()\n#target_link_libraries(gmx ${GMX_EXTRA_LIBRARIES} ${THREAD_MPI_LIB})\ntmpi_get_source_list(THREAD_MPI_SOURCES ${PROJECT_SOURCE_DIR}/src/external/thread_mpi/src)\nadd_library(thread_mpi OBJECT ${THREAD_MPI_SOURCES})\ntarget_compile_definitions(thread_mpi PRIVATE HAVE_CONFIG_H)\ngmx_target_compile_options(thread_mpi)\nif (WIN32)\n    gmx_target_warning_suppression(thread_mpi /wd4996 HAS_NO_MSVC_UNSAFE_FUNCTION)\nendif()\nlist(APPEND libgromacs_object_library_dependencies thread_mpi)\n\nconfigure_file(version.h.cmakein version.h)\nif(GMX_INSTALL_LEGACY_API)\n  install(FILES\n          ${CMAKE_CURRENT_BINARY_DIR}/version.h\n          DESTINATION include/gromacs)\nendif()\n\n# This code is here instead of utility/CMakeLists.txt, because CMake\n# custom commands and source file properties can only be set in the directory\n# that contains the target that uses them.\n# TODO: Generate a header instead that can be included from baseversion.cpp.\n# That probably simplifies things somewhat.\nset(GENERATED_VERSION_FILE utility/baseversion-gen.cpp)\ngmx_configure_version_file(\n    utility/baseversion-gen.cpp.cmakein ${GENERATED_VERSION_FILE}\n    REMOTE_HASH\n    EXTRA_VARS\n        GMX_SOURCE_DOI\n        GMX_RELEASE_HASH\n        GMX_SOURCE_HASH\n        )\nlist(APPEND LIBGROMACS_SOURCES ${GENERATED_VERSION_FILE})\n\n# Mark some shared GPU implementation files to compile with CUDA if needed\nif (GMX_USE_CUDA)\n    get_property(LIBGROMACS_GPU_IMPL_SOURCES GLOBAL PROPERTY GMX_LIBGROMACS_GPU_IMPL_SOURCES)\n    set_source_files_properties(${LIBGROMACS_GPU_IMPL_SOURCES} PROPERTIES CUDA_SOURCE_PROPERTY_FORMAT OBJ)\nendif()\n\n# set up CUDA compilation with clang\nif (GMX_CLANG_CUDA)\n    foreach (_file ${LIBGROMACS_SOURCES})\n        get_filename_component(_ext ${_file} EXT)\n        get_source_file_property(_cuda_source_format ${_file} CUDA_SOURCE_PROPERTY_FORMAT)\n        if (\"${_ext}\" STREQUAL \".cu\" OR _cuda_source_format)\n            gmx_compile_cuda_file_with_clang(${_file})\n        endif()\n    endforeach()\nendif()\n\nif (GMX_USE_CUDA)\n    # Work around FindCUDA that prevents using target_link_libraries()\n    # with keywords otherwise...\n    set(CUDA_LIBRARIES PRIVATE ${CUDA_LIBRARIES})\n    if (NOT GMX_CLANG_CUDA)\n        gmx_cuda_add_library(libgromacs ${LIBGROMACS_SOURCES})\n    else()\n        add_library(libgromacs ${LIBGROMACS_SOURCES})\n    endif()\n    target_link_libraries(libgromacs PRIVATE ${CUDA_CUFFT_LIBRARIES})\nelse()\n    add_library(libgromacs ${LIBGROMACS_SOURCES})\nendif()\n\n# Add these contents first because linking their tests can take a lot\n# of time, so we want lots of parallel work still available after\n# linking starts.\nadd_subdirectory(fileio)\nadd_subdirectory(selection)\n\n# Suppress a warning about our abuse of t_inputrec\ngmx_source_file_warning_suppression(mdtypes/inputrec.cpp -Wno-class-memaccess HAS_NO_CLASS_MEMACCESS)\n\n# Handle the object libraries that contain the source file\n# dependencies that need special handling because they are generated\n# or external code.\nforeach(object_library ${libgromacs_object_library_dependencies})\n    if (BUILD_SHARED_LIBS)\n        set_target_properties(${object_library} PROPERTIES POSITION_INDEPENDENT_CODE true)\n    endif()\n    target_include_directories(${object_library} SYSTEM BEFORE PRIVATE ${PROJECT_SOURCE_DIR}/src/external/thread_mpi/include)\n\n    # Add the sources from the object libraries to the main library.\n    target_sources(libgromacs PRIVATE $<TARGET_OBJECTS:${object_library}>)\nendforeach()\ngmx_target_compile_options(libgromacs)\ntarget_compile_definitions(libgromacs PRIVATE HAVE_CONFIG_H)\ntarget_include_directories(libgromacs SYSTEM BEFORE PRIVATE ${PROJECT_SOURCE_DIR}/src/external/thread_mpi/include)\n\nif (GMX_USE_OPENCL)\n    option(GMX_EXTERNAL_CLFFT \"True if an external clFFT is required to be used\" FALSE)\n    mark_as_advanced(GMX_EXTERNAL_CLFFT)\n\n    # Default to using clFFT found on the system\n    # switch to quiet at the second run.\n    if (DEFINED clFFT_LIBRARY)\n        set (clFFT_FIND_QUIETLY TRUE)\n    endif()\n    find_package(clFFT)\n    if (NOT clFFT_FOUND)\n        if (GMX_EXTERNAL_CLFFT)\n            message(FATAL_ERROR \"Did not find required external clFFT library, consider setting clFFT_ROOT_DIR\")\n        endif()\n\n        if(MSVC)\n            message(FATAL_ERROR\n\"An OpenCL build was requested with Visual Studio compiler, but GROMACS\nrequires clFFT, which was not found on your system. GROMACS does bundle\nclFFT to help with building for OpenCL, but that clFFT has not yet been\nported to the more recent versions of that compiler that GROMACS itself\nrequires. Thus for now, OpenCL is not available with MSVC and the internal\nbuild of clFFT in GROMACS 2019. Either change compiler, try installing\na clFFT package, or use the latest GROMACS 2018 point release.\")\n        endif()\n\n        # Fall back on the internal version\n        set (_clFFT_dir ../external/clFFT/src)\n        add_subdirectory(${_clFFT_dir} clFFT-build)\n        target_sources(libgromacs PRIVATE\n            $<TARGET_OBJECTS:clFFT>\n        )\n        target_include_directories(libgromacs SYSTEM PRIVATE ${_clFFT_dir}/include)\n        # Use the magic variable for how to link any library needed for\n        # dlopen, etc.  which is -ldl where needed, and empty otherwise\n        # (e.g. Windows, BSD, Mac).\n        target_link_libraries(libgromacs PRIVATE \"${CMAKE_DL_LIBS}\")\n    else()\n        target_link_libraries(libgromacs PRIVATE clFFT)\n    endif()\nendif()\n\n# Permit GROMACS code to include externally developed headers, such as\n# the functionality from the nonstd project that we use for\n# gmx::compat::optional. These are included as system headers so that\n# no warnings are issued from them.\n#\n# TODO Perhaps generalize this for all headers from src/external\ntarget_include_directories(libgromacs SYSTEM PRIVATE ${PROJECT_SOURCE_DIR}/src/external)\n\nif(SIMD_AVX_512_CXX_SUPPORTED AND NOT (\"${GMX_SIMD_ACTIVE}\" STREQUAL \"AVX_512_KNL\"))\n    # Since we might be overriding -march=core-avx2, add a flag so we don't warn for this specific file.\n    # On KNL this can cause illegal instruction because the compiler might use non KNL AVX instructions\n    # with the SIMD_AVX_512_CXX_FLAGS flags.\n    set_source_files_properties(hardware/identifyavx512fmaunits.cpp PROPERTIES COMPILE_FLAGS \"${SIMD_AVX_512_CXX_FLAGS} ${CXX_NO_UNUSED_OPTION_WARNING_FLAGS}\")\nendif()\n\ngmx_setup_tng_for_libgromacs()\n\ntarget_link_libraries(libgromacs\n                      PRIVATE\n                      ${EXTRAE_LIBRARIES}\n                      ${GMX_EXTRA_LIBRARIES}\n                      ${GMX_COMMON_LIBRARIES}\n                      ${FFT_LIBRARIES} ${LINEAR_ALGEBRA_LIBRARIES}\n                      ${THREAD_LIB} ${GMX_SHARED_LINKER_FLAGS}\n                      ${OpenCL_LIBRARIES}\n                      $<$<PLATFORM_ID:SunOS>:socket>\n                      PUBLIC\n                      ${GMX_PUBLIC_LIBRARIES}\n                      )\nif (GMX_OPENMP)\n    target_link_libraries(libgromacs PUBLIC OpenMP::OpenMP_CXX)\nendif()\nset_target_properties(libgromacs PROPERTIES\n                      OUTPUT_NAME \"gromacs${GMX_LIBS_SUFFIX}\"\n                      SOVERSION ${LIBRARY_SOVERSION_MAJOR}\n                      VERSION ${LIBRARY_VERSION}\n                      )\n\ngmx_manage_lmfit()\ntarget_link_libraries(libgromacs PRIVATE lmfit)\n\n# Fix everything found by the latest version of clang that we use in\n# Jenkins testing. This should be updated when we update the latest\n# tested version of clang.\nif (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" AND CMAKE_CXX_COMPILER_VERSION MATCHES \"^7\\.0\")\n   target_compile_options(libgromacs PRIVATE $<$<COMPILE_LANGUAGE:CXX>:-Weverything ${IGNORED_CLANG_ALL_WARNINGS}>)\nendif()\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"MSVC\")\n   target_compile_options(libgromacs PRIVATE $<$<COMPILE_LANGUAGE:CXX>:/analyze /analyze:stacksize 70000\n     #Control flow warnings are disabled because the commond line output is insufficient. There is no tool\n     #to convert the xml report to e.g. HTML and even in Visual Studio the viewer doesn't work with cmake support.\n     /wd6001  #unitialized memory\n     /wd6011  #derefencing NULL\n     /wd6053  #prior call not zero-terminate\n     /wd6054  #might not be zero-terminated\n     /wd6385  #reading invalid data\n     /wd6386  #buffer overrun\n     /wd6387  #could be '0'\n     /wd28199 #uninitialized memory\n     # For compile time constant (e.g. templates) the following warnings have flase postives\n     /wd6239  #(<non-zero> && <expr>)\n     /wd6240  #(<expr> && <non-zero>)\n     /wd6294  #Ill-defined for-loop\n     /wd6326  #comparison of constant with other constant\n     /wd28020 #expression involving paramter is not true\n     # Misc\n     /wd6330  #incorrect type to function (warns for char (instead of unsigned) for isspace/isalpha/isdigit/..))\n     /wd6993  #OpenMP ignored\n     #TODO\n     /wd6031  #return value ignored (important - mostly warnigns about sscanf)\n     /wd6244  #hides declaration (known issue - we ingore similar warnings for other compilers)\n     /wd6246  #hides declaration\n     >\n   )\nendif()\n\nif (GMX_CLANG_TIDY)\n   set_target_properties(libgromacs PROPERTIES CXX_CLANG_TIDY\n       \"${CLANG_TIDY_EXE};-warnings-as-errors=*\")\nendif()\n\n# clang-3.6 warns about a number of issues that are not reported by more modern compilers\n# and we know they are not real issues. So we only check that it can compile without error\n# but ignore all warnings.\nif (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" AND CMAKE_CXX_COMPILER_VERSION MATCHES \"^3\\.6\")\n    target_compile_options(libgromacs PRIVATE $<$<COMPILE_LANGUAGE:CXX>:-w>)\nendif()\n\n# Only install the library in mdrun-only mode if it is actually necessary\n# for the binary\nif (NOT GMX_BUILD_MDRUN_ONLY OR BUILD_SHARED_LIBS)\n    install(TARGETS libgromacs\n            EXPORT libgromacs\n            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n            RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n            INCLUDES DESTINATION include\n            COMPONENT libraries)\nendif()\n\nif (NOT GMX_BUILD_MDRUN_ONLY)\n    include(InstallLibInfo.cmake)\nendif()\n\n# Technically, the user could want to do this for an OpenCL build\n# using the CUDA runtime, but currently there's no reason to want to\n# do that.\nif (INSTALL_CUDART_LIB) #can be set manual by user\n    if (GMX_USE_CUDA)\n        foreach(CUDA_LIB ${CUDA_LIBRARIES})\n            string(REGEX MATCH \"cudart\" IS_CUDART ${CUDA_LIB})\n            if(IS_CUDART) #libcuda should not be installed\n                #install also name-links (linker uses those)\n                file(GLOB CUDA_LIBS ${CUDA_LIB}*)\n                install(FILES ${CUDA_LIBS} DESTINATION\n                    ${CMAKE_INSTALL_LIBDIR} COMPONENT libraries)\n            endif()\n        endforeach()\n    else()\n        message(WARNING \"INSTALL_CUDART_LIB only makes sense when configuring for CUDA support\")\n    endif()\nendif()\n\nif(GMX_USE_OPENCL)\n    # Install the utility headers\n    file(GLOB OPENCL_INSTALLED_FILES\n        gpu_utils/vectype_ops.clh\n        gpu_utils/device_utils.clh\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/gpu_utils\n        COMPONENT libraries)\n    file(GLOB OPENCL_INSTALLED_FILES\n        pbcutil/ishift.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/pbcutil\n        COMPONENT libraries)\n\n    # Install the NBNXM source and headers\n    file(GLOB OPENCL_INSTALLED_FILES\n        nbnxm/constants.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/nbnxm\n        COMPONENT libraries)\n    file(GLOB OPENCL_INSTALLED_FILES\n        nbnxm/opencl/nbnxm_ocl_kernels.cl\n        nbnxm/opencl/nbnxm_ocl_kernel.clh\n        nbnxm/opencl/nbnxm_ocl_kernel_pruneonly.clh\n        nbnxm/opencl/nbnxm_ocl_kernels.clh\n        nbnxm/opencl/nbnxm_ocl_kernels_fastgen.clh\n        nbnxm/opencl/nbnxm_ocl_kernels_fastgen_add_twincut.clh\n        nbnxm/opencl/nbnxm_ocl_kernel_utils.clh\n        nbnxm/opencl/nbnxm_ocl_consts.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/nbnxm/opencl\n        COMPONENT libraries)\n\n    # Install the PME source and headers\n    file(GLOB OPENCL_INSTALLED_FILES\n        ewald/pme_spread.clh\n        ewald/pme_solve.clh\n        ewald/pme_gather.clh\n        ewald/pme_gpu_utils.clh\n        ewald/pme_program.cl\n        ewald/pme_gpu_types.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/ewald\n        COMPONENT libraries)\nendif()\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/patches/gromacs-2020.2.diff/src/gromacs/CMakeLists.txt": "#\n# This file is part of the GROMACS molecular simulation package.\n#\n# Copyright (c) 2010,2011,2012,2013,2014,2015, The GROMACS development team.\n# Copyright (c) 2016,2017,2018,2019,2020, by the GROMACS development team, led by\n# Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,\n# and including many others, as listed in the AUTHORS file in the\n# top-level source directory and at http://www.gromacs.org.\n#\n# GROMACS is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public License\n# as published by the Free Software Foundation; either version 2.1\n# of the License, or (at your option) any later version.\n#\n# GROMACS is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with GROMACS; if not, see\n# http://www.gnu.org/licenses, or write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.\n#\n# If you want to redistribute modifications to GROMACS, please\n# consider that scientific software is very special. Version\n# control is crucial - bugs must be traceable. We will be happy to\n# consider code for inclusion in the official distribution, but\n# derived work must not be called official GROMACS. Details are found\n# in the README & COPYING files - if they are missing, get the\n# official version at http://www.gromacs.org.\n#\n# To help us fund GROMACS development, we humbly ask that you cite\n# the research papers on the package. Check out http://www.gromacs.org.\n\ninclude(${CMAKE_SOURCE_DIR}/Plumed.cmake)\n\nset(LIBGROMACS_SOURCES)\n\nif (GMX_CLANG_CUDA)\n    include(gmxClangCudaUtils)\nendif()\n\nset_property(GLOBAL PROPERTY GMX_LIBGROMACS_SOURCES)\nset_property(GLOBAL PROPERTY GMX_LIBGROMACS_GPU_IMPL_SOURCES)\nset_property(GLOBAL PROPERTY GMX_INSTALLED_HEADERS)\nset_property(GLOBAL PROPERTY GMX_AVX_512_SOURCE)\n\nset(libgromacs_object_library_dependencies \"\")\nfunction (_gmx_add_files_to_property PROPERTY)\n    foreach (_file ${ARGN})\n        if (IS_ABSOLUTE \"${_file}\")\n            set_property(GLOBAL APPEND PROPERTY ${PROPERTY} ${_file})\n        else()\n            set_property(GLOBAL APPEND PROPERTY ${PROPERTY}\n                         ${CMAKE_CURRENT_LIST_DIR}/${_file})\n        endif()\n    endforeach()\nendfunction ()\n\nfunction (gmx_add_libgromacs_sources)\n    _gmx_add_files_to_property(GMX_LIBGROMACS_SOURCES ${ARGN})\nendfunction ()\n\n# TODO Reconsider this, as the CUDA driver API is probably a simpler\n# approach, at least for the build system. See Redmine #2530\nfunction (gmx_compile_cpp_as_cuda)\n    _gmx_add_files_to_property(GMX_LIBGROMACS_GPU_IMPL_SOURCES ${ARGN})\nendfunction ()\n\n# Add these contents first because linking their tests can take a lot\n# of time, so we want lots of parallel work still available after\n# linking starts.\nadd_subdirectory(utility)\n# Add normal contents\nadd_subdirectory(gmxlib)\nadd_subdirectory(mdlib)\nadd_subdirectory(applied_forces)\nadd_subdirectory(listed_forces)\nadd_subdirectory(nbnxm)\nadd_subdirectory(commandline)\nadd_subdirectory(domdec)\nadd_subdirectory(ewald)\nadd_subdirectory(fft)\nadd_subdirectory(gpu_utils)\nadd_subdirectory(hardware)\nadd_subdirectory(linearalgebra)\nadd_subdirectory(math)\nadd_subdirectory(mdrun)\nadd_subdirectory(mdrunutility)\nadd_subdirectory(mdspan)\nadd_subdirectory(mdtypes)\nadd_subdirectory(onlinehelp)\nadd_subdirectory(options)\nadd_subdirectory(pbcutil)\nadd_subdirectory(random)\nadd_subdirectory(restraint)\nadd_subdirectory(tables)\nadd_subdirectory(taskassignment)\nadd_subdirectory(timing)\nadd_subdirectory(topology)\nadd_subdirectory(trajectory)\nadd_subdirectory(swap)\nadd_subdirectory(essentialdynamics)\nadd_subdirectory(pulling)\nadd_subdirectory(awh)\nadd_subdirectory(simd)\nadd_subdirectory(imd)\nadd_subdirectory(compat)\nadd_subdirectory(mimic)\nadd_subdirectory(modularsimulator)\nif (NOT GMX_BUILD_MDRUN_ONLY)\n    add_subdirectory(gmxana)\n    add_subdirectory(gmxpreprocess)\n    add_subdirectory(correlationfunctions)\n    add_subdirectory(statistics)\n    add_subdirectory(analysisdata)\n    add_subdirectory(coordinateio)\n    add_subdirectory(trajectoryanalysis)\n    add_subdirectory(energyanalysis)\n    add_subdirectory(tools)\nendif()\n\nget_property(PROPERTY_SOURCES GLOBAL PROPERTY GMX_LIBGROMACS_SOURCES)\nlist(APPEND LIBGROMACS_SOURCES ${GMXLIB_SOURCES} ${MDLIB_SOURCES} ${PROPERTY_SOURCES})\n\n# This would be the standard way to include thread_mpi, but\n# we want libgromacs to link the functions directly\n#if(GMX_THREAD_MPI)\n#    add_subdirectory(thread_mpi)\n#endif()\n#target_link_libraries(gmx ${GMX_EXTRA_LIBRARIES} ${THREAD_MPI_LIB})\ntmpi_get_source_list(THREAD_MPI_SOURCES ${PROJECT_SOURCE_DIR}/src/external/thread_mpi/src)\nadd_library(thread_mpi OBJECT ${THREAD_MPI_SOURCES})\ntarget_compile_definitions(thread_mpi PRIVATE HAVE_CONFIG_H)\ngmx_target_compile_options(thread_mpi)\nif (WIN32)\n    gmx_target_warning_suppression(thread_mpi /wd4996 HAS_NO_MSVC_UNSAFE_FUNCTION)\nendif()\nlist(APPEND libgromacs_object_library_dependencies thread_mpi)\n\nconfigure_file(version.h.cmakein version.h)\nif(GMX_INSTALL_LEGACY_API)\n  install(FILES\n          ${CMAKE_CURRENT_BINARY_DIR}/version.h\n          DESTINATION include/gromacs)\nendif()\n\n# This code is here instead of utility/CMakeLists.txt, because CMake\n# custom commands and source file properties can only be set in the directory\n# that contains the target that uses them.\n# TODO: Generate a header instead that can be included from baseversion.cpp.\n# That probably simplifies things somewhat.\nset(GENERATED_VERSION_FILE utility/baseversion-gen.cpp)\ngmx_configure_version_file(\n    utility/baseversion-gen.cpp.cmakein ${GENERATED_VERSION_FILE}\n    REMOTE_HASH\n    EXTRA_VARS\n        GMX_SOURCE_DOI\n        GMX_RELEASE_HASH\n        GMX_SOURCE_HASH\n        )\nlist(APPEND LIBGROMACS_SOURCES ${GENERATED_VERSION_FILE})\n\n# Mark some shared GPU implementation files to compile with CUDA if needed\nif (GMX_USE_CUDA)\n    get_property(LIBGROMACS_GPU_IMPL_SOURCES GLOBAL PROPERTY GMX_LIBGROMACS_GPU_IMPL_SOURCES)\n    set_source_files_properties(${LIBGROMACS_GPU_IMPL_SOURCES} PROPERTIES CUDA_SOURCE_PROPERTY_FORMAT OBJ)\nendif()\n\n# set up CUDA compilation with clang\nif (GMX_CLANG_CUDA)\n    foreach (_file ${LIBGROMACS_SOURCES})\n        get_filename_component(_ext ${_file} EXT)\n        get_source_file_property(_cuda_source_format ${_file} CUDA_SOURCE_PROPERTY_FORMAT)\n        if (\"${_ext}\" STREQUAL \".cu\" OR _cuda_source_format)\n            gmx_compile_cuda_file_with_clang(${_file})\n        endif()\n    endforeach()\nendif()\n\nif (GMX_USE_CUDA)\n    # Work around FindCUDA that prevents using target_link_libraries()\n    # with keywords otherwise...\n    set(CUDA_LIBRARIES PRIVATE ${CUDA_LIBRARIES})\n    if (NOT GMX_CLANG_CUDA)\n        gmx_cuda_add_library(libgromacs ${LIBGROMACS_SOURCES})\n    else()\n        add_library(libgromacs ${LIBGROMACS_SOURCES})\n    endif()\n    target_link_libraries(libgromacs PRIVATE ${CUDA_CUFFT_LIBRARIES})\nelse()\n    add_library(libgromacs ${LIBGROMACS_SOURCES})\nendif()\n\n# Add these contents first because linking their tests can take a lot\n# of time, so we want lots of parallel work still available after\n# linking starts.\nadd_subdirectory(fileio)\nadd_subdirectory(selection)\n\n# Suppress a warning about our abuse of t_inputrec\ngmx_source_file_warning_suppression(mdtypes/inputrec.cpp -Wno-class-memaccess HAS_NO_CLASS_MEMACCESS)\n\n# Handle the object libraries that contain the source file\n# dependencies that need special handling because they are generated\n# or external code.\nforeach(object_library ${libgromacs_object_library_dependencies})\n    if (BUILD_SHARED_LIBS)\n        set_target_properties(${object_library} PROPERTIES POSITION_INDEPENDENT_CODE true)\n    endif()\n    target_include_directories(${object_library} SYSTEM BEFORE PRIVATE ${PROJECT_SOURCE_DIR}/src/external/thread_mpi/include)\n\n    # Add the sources from the object libraries to the main library.\n    target_sources(libgromacs PRIVATE $<TARGET_OBJECTS:${object_library}>)\nendforeach()\ngmx_target_compile_options(libgromacs)\ntarget_compile_definitions(libgromacs PRIVATE HAVE_CONFIG_H)\ntarget_include_directories(libgromacs SYSTEM BEFORE PRIVATE ${PROJECT_SOURCE_DIR}/src/external/thread_mpi/include)\n\nif (GMX_USE_OPENCL)\n    option(GMX_EXTERNAL_CLFFT \"True if an external clFFT is required to be used\" FALSE)\n    mark_as_advanced(GMX_EXTERNAL_CLFFT)\n\n    # Default to using clFFT found on the system\n    # switch to quiet at the second run.\n    if (DEFINED clFFT_LIBRARY)\n        set (clFFT_FIND_QUIETLY TRUE)\n    endif()\n    find_package(clFFT)\n    if (NOT clFFT_FOUND)\n        if (GMX_EXTERNAL_CLFFT)\n            message(FATAL_ERROR \"Did not find required external clFFT library, consider setting clFFT_ROOT_DIR\")\n        endif()\n\n        if(MSVC)\n            message(FATAL_ERROR\n\"An OpenCL build was requested with Visual Studio compiler, but GROMACS\nrequires clFFT, which was not found on your system. GROMACS does bundle\nclFFT to help with building for OpenCL, but that clFFT has not yet been\nported to the more recent versions of that compiler that GROMACS itself\nrequires. Thus for now, OpenCL is not available with MSVC and the internal\nbuild of clFFT in GROMACS 2019. Either change compiler, try installing\na clFFT package, or use the latest GROMACS 2018 point release.\")\n        endif()\n\n        # Fall back on the internal version\n        set (_clFFT_dir ../external/clFFT/src)\n        add_subdirectory(${_clFFT_dir} clFFT-build)\n        target_sources(libgromacs PRIVATE\n            $<TARGET_OBJECTS:clFFT>\n        )\n        target_include_directories(libgromacs SYSTEM PRIVATE ${_clFFT_dir}/include)\n        # Use the magic variable for how to link any library needed for\n        # dlopen, etc.  which is -ldl where needed, and empty otherwise\n        # (e.g. Windows, BSD, Mac).\n        target_link_libraries(libgromacs PRIVATE \"${CMAKE_DL_LIBS}\")\n    else()\n        target_link_libraries(libgromacs PRIVATE clFFT)\n    endif()\nendif()\n\n# Permit GROMACS code to include externally developed headers, such as\n# the functionality from the nonstd project that we use for\n# gmx::compat::optional. These are included as system headers so that\n# no warnings are issued from them.\n#\n# TODO Perhaps generalize this for all headers from src/external\ntarget_include_directories(libgromacs SYSTEM PRIVATE ${PROJECT_SOURCE_DIR}/src/external)\n\nif(SIMD_AVX_512_CXX_SUPPORTED AND NOT (\"${GMX_SIMD_ACTIVE}\" STREQUAL \"AVX_512_KNL\"))\n    # Since we might be overriding -march=core-avx2, add a flag so we don't warn for this specific file.\n    # On KNL this can cause illegal instruction because the compiler might use non KNL AVX instructions\n    # with the SIMD_AVX_512_CXX_FLAGS flags.\n    set_source_files_properties(hardware/identifyavx512fmaunits.cpp PROPERTIES COMPILE_FLAGS \"${SIMD_AVX_512_CXX_FLAGS} ${CXX_NO_UNUSED_OPTION_WARNING_FLAGS}\")\nendif()\n\ngmx_setup_tng_for_libgromacs()\n\ntarget_link_libraries(libgromacs\n                      PRIVATE\n                      ${EXTRAE_LIBRARIES}\n                      ${GMX_EXTRA_LIBRARIES}\n                      ${GMX_COMMON_LIBRARIES}\n                      ${FFT_LIBRARIES} ${LINEAR_ALGEBRA_LIBRARIES}\n                      ${THREAD_LIB} ${GMX_SHARED_LINKER_FLAGS}\n                      ${OpenCL_LIBRARIES}\n                      $<$<PLATFORM_ID:SunOS>:socket>\n                      PUBLIC\n                      ${GMX_PUBLIC_LIBRARIES}\n                      ${PLUMED_LOAD}\n                      )\nif (GMX_OPENMP)\n    target_link_libraries(libgromacs PUBLIC OpenMP::OpenMP_CXX)\nendif()\nset_target_properties(libgromacs PROPERTIES\n                      OUTPUT_NAME \"gromacs${GMX_LIBS_SUFFIX}\"\n                      SOVERSION ${LIBRARY_SOVERSION_MAJOR}\n                      VERSION ${LIBRARY_VERSION}\n                      )\n\ngmx_manage_lmfit()\ntarget_link_libraries(libgromacs PRIVATE lmfit)\n\n# Fix everything found by the latest version of clang that we use in\n# Jenkins testing. This should be updated when we update the latest\n# tested version of clang.\nif (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" AND CMAKE_CXX_COMPILER_VERSION MATCHES \"^7\\.0\")\n   target_compile_options(libgromacs PRIVATE $<$<COMPILE_LANGUAGE:CXX>:-Weverything ${IGNORED_CLANG_ALL_WARNINGS}>)\nendif()\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"MSVC\")\n   target_compile_options(libgromacs PRIVATE $<$<COMPILE_LANGUAGE:CXX>:/analyze /analyze:stacksize 70000\n     #Control flow warnings are disabled because the commond line output is insufficient. There is no tool\n     #to convert the xml report to e.g. HTML and even in Visual Studio the viewer doesn't work with cmake support.\n     /wd6001  #unitialized memory\n     /wd6011  #derefencing NULL\n     /wd6053  #prior call not zero-terminate\n     /wd6054  #might not be zero-terminated\n     /wd6385  #reading invalid data\n     /wd6386  #buffer overrun\n     /wd6387  #could be '0'\n     /wd28199 #uninitialized memory\n     # For compile time constant (e.g. templates) the following warnings have flase postives\n     /wd6239  #(<non-zero> && <expr>)\n     /wd6240  #(<expr> && <non-zero>)\n     /wd6294  #Ill-defined for-loop\n     /wd6326  #comparison of constant with other constant\n     /wd28020 #expression involving paramter is not true\n     # Misc\n     /wd6330  #incorrect type to function (warns for char (instead of unsigned) for isspace/isalpha/isdigit/..))\n     /wd6993  #OpenMP ignored\n     #TODO\n     /wd6031  #return value ignored (important - mostly warnigns about sscanf)\n     /wd6244  #hides declaration (known issue - we ingore similar warnings for other compilers)\n     /wd6246  #hides declaration\n     >\n   )\nendif()\n\nif (GMX_CLANG_TIDY)\n   set_target_properties(libgromacs PROPERTIES CXX_CLANG_TIDY\n       \"${CLANG_TIDY_EXE};-warnings-as-errors=*\")\nendif()\n\n# clang-3.6 warns about a number of issues that are not reported by more modern compilers\n# and we know they are not real issues. So we only check that it can compile without error\n# but ignore all warnings.\nif (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" AND CMAKE_CXX_COMPILER_VERSION MATCHES \"^3\\.6\")\n    target_compile_options(libgromacs PRIVATE $<$<COMPILE_LANGUAGE:CXX>:-w>)\nendif()\n\n# Only install the library in mdrun-only mode if it is actually necessary\n# for the binary\nif (NOT GMX_BUILD_MDRUN_ONLY OR BUILD_SHARED_LIBS)\n    install(TARGETS libgromacs\n            EXPORT libgromacs\n            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n            RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n            INCLUDES DESTINATION include\n            COMPONENT libraries)\nendif()\n\nif (NOT GMX_BUILD_MDRUN_ONLY)\n    include(InstallLibInfo.cmake)\nendif()\n\n# Technically, the user could want to do this for an OpenCL build\n# using the CUDA runtime, but currently there's no reason to want to\n# do that.\nif (INSTALL_CUDART_LIB) #can be set manual by user\n    if (GMX_USE_CUDA)\n        foreach(CUDA_LIB ${CUDA_LIBRARIES})\n            string(REGEX MATCH \"cudart\" IS_CUDART ${CUDA_LIB})\n            if(IS_CUDART) #libcuda should not be installed\n                #install also name-links (linker uses those)\n                file(GLOB CUDA_LIBS ${CUDA_LIB}*)\n                install(FILES ${CUDA_LIBS} DESTINATION\n                    ${CMAKE_INSTALL_LIBDIR} COMPONENT libraries)\n            endif()\n        endforeach()\n    else()\n        message(WARNING \"INSTALL_CUDART_LIB only makes sense when configuring for CUDA support\")\n    endif()\nendif()\n\nif(GMX_USE_OPENCL)\n    # Install the utility headers\n    file(GLOB OPENCL_INSTALLED_FILES\n        gpu_utils/vectype_ops.clh\n        gpu_utils/device_utils.clh\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/gpu_utils\n        COMPONENT libraries)\n    file(GLOB OPENCL_INSTALLED_FILES\n        pbcutil/ishift.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/pbcutil\n        COMPONENT libraries)\n\n    # Install the NBNXM source and headers\n    file(GLOB OPENCL_INSTALLED_FILES\n        nbnxm/constants.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/nbnxm\n        COMPONENT libraries)\n    file(GLOB OPENCL_INSTALLED_FILES\n        nbnxm/opencl/nbnxm_ocl_kernels.cl\n        nbnxm/opencl/nbnxm_ocl_kernel.clh\n        nbnxm/opencl/nbnxm_ocl_kernel_pruneonly.clh\n        nbnxm/opencl/nbnxm_ocl_kernels.clh\n        nbnxm/opencl/nbnxm_ocl_kernels_fastgen.clh\n        nbnxm/opencl/nbnxm_ocl_kernels_fastgen_add_twincut.clh\n        nbnxm/opencl/nbnxm_ocl_kernel_utils.clh\n        nbnxm/opencl/nbnxm_ocl_consts.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/nbnxm/opencl\n        COMPONENT libraries)\n\n    # Install the PME source and headers\n    file(GLOB OPENCL_INSTALLED_FILES\n        ewald/pme_spread.clh\n        ewald/pme_solve.clh\n        ewald/pme_gather.clh\n        ewald/pme_gpu_utils.clh\n        ewald/pme_program.cl\n        ewald/pme_gpu_types.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/ewald\n        COMPONENT libraries)\nendif()\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/patches/gromacs-2019.6.diff/src/gromacs/CMakeLists.txt.preplumed": "#\n# This file is part of the GROMACS molecular simulation package.\n#\n# Copyright (c) 2010,2011,2012,2013,2014,2015,2016,2017,2018,2019, by the GROMACS development team, led by\n# Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,\n# and including many others, as listed in the AUTHORS file in the\n# top-level source directory and at http://www.gromacs.org.\n#\n# GROMACS is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public License\n# as published by the Free Software Foundation; either version 2.1\n# of the License, or (at your option) any later version.\n#\n# GROMACS is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with GROMACS; if not, see\n# http://www.gnu.org/licenses, or write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.\n#\n# If you want to redistribute modifications to GROMACS, please\n# consider that scientific software is very special. Version\n# control is crucial - bugs must be traceable. We will be happy to\n# consider code for inclusion in the official distribution, but\n# derived work must not be called official GROMACS. Details are found\n# in the README & COPYING files - if they are missing, get the\n# official version at http://www.gromacs.org.\n#\n# To help us fund GROMACS development, we humbly ask that you cite\n# the research papers on the package. Check out http://www.gromacs.org.\n\nset(LIBGROMACS_SOURCES)\n\nif (GMX_CLANG_CUDA)\n    include(gmxClangCudaUtils)\nendif()\n\nset_property(GLOBAL PROPERTY GMX_LIBGROMACS_SOURCES)\nset_property(GLOBAL PROPERTY GMX_LIBGROMACS_GPU_IMPL_SOURCES)\nset_property(GLOBAL PROPERTY GMX_INSTALLED_HEADERS)\nset_property(GLOBAL PROPERTY GMX_AVX_512_SOURCE)\n\nadd_library(libgromacs_external OBJECT \"\")\nif(CMAKE_COMPILER_IS_GNUCXX)\n    # Keep quiet about e.g. linearalgebra module\n    target_compile_options(libgromacs_external PRIVATE ${CXXFLAGS_NO_STRINGOP_TRUNCATION})\nendif()\n\nadd_library(libgromacs_generated OBJECT \"\")\nif (BUILD_SHARED_LIBS)\n    set_target_properties(libgromacs_external PROPERTIES POSITION_INDEPENDENT_CODE true)\n    set_target_properties(libgromacs_generated PROPERTIES POSITION_INDEPENDENT_CODE true)\nendif()\n\nfunction (_gmx_add_files_to_property PROPERTY)\n    foreach (_file ${ARGN})\n        if (IS_ABSOLUTE \"${_file}\")\n            set_property(GLOBAL APPEND PROPERTY ${PROPERTY} ${_file})\n        else()\n            set_property(GLOBAL APPEND PROPERTY ${PROPERTY}\n                         ${CMAKE_CURRENT_LIST_DIR}/${_file})\n        endif()\n    endforeach()\nendfunction ()\n\nfunction (gmx_add_libgromacs_sources)\n    _gmx_add_files_to_property(GMX_LIBGROMACS_SOURCES ${ARGN})\nendfunction ()\n\n# TODO Reconsider this, as the CUDA driver API is probably a simpler\n# approach, at least for the build system. See Redmine #2530\nfunction (gmx_compile_cpp_as_cuda)\n    _gmx_add_files_to_property(GMX_LIBGROMACS_GPU_IMPL_SOURCES ${ARGN})\nendfunction ()\n\nfunction (gmx_install_headers)\n    if (NOT GMX_BUILD_MDRUN_ONLY)\n        file(RELATIVE_PATH _dest ${PROJECT_SOURCE_DIR}/src ${CMAKE_CURRENT_LIST_DIR})\n        install(FILES       ${ARGN}\n                DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}/${_dest}\"\n                COMPONENT   development)\n    endif()\n    _gmx_add_files_to_property(GMX_INSTALLED_HEADERS ${ARGN})\nendfunction ()\n\nfunction (gmx_write_installed_header_list)\n    get_property(_list GLOBAL PROPERTY GMX_INSTALLED_HEADERS)\n    string(REPLACE \";\" \"\\n\" _list \"${_list}\")\n    # TODO: Make this only update the file timestamp if the contents actually change.\n    file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/installed-headers.txt \"${_list}\")\nendfunction()\n\nadd_subdirectory(gmxlib)\nadd_subdirectory(mdlib)\nadd_subdirectory(applied-forces)\nadd_subdirectory(listed-forces)\nadd_subdirectory(commandline)\nadd_subdirectory(domdec)\nadd_subdirectory(ewald)\nadd_subdirectory(fft)\nadd_subdirectory(gpu_utils)\nadd_subdirectory(hardware)\nadd_subdirectory(linearalgebra)\nadd_subdirectory(math)\nadd_subdirectory(mdrun)\nadd_subdirectory(mdrunutility)\nadd_subdirectory(mdtypes)\nadd_subdirectory(onlinehelp)\nadd_subdirectory(options)\nadd_subdirectory(pbcutil)\nadd_subdirectory(random)\nadd_subdirectory(restraint)\nadd_subdirectory(tables)\nadd_subdirectory(taskassignment)\nadd_subdirectory(timing)\nadd_subdirectory(topology)\nadd_subdirectory(trajectory)\nadd_subdirectory(utility)\nadd_subdirectory(fileio)\nadd_subdirectory(swap)\nadd_subdirectory(essentialdynamics)\nadd_subdirectory(pulling)\nadd_subdirectory(awh)\nadd_subdirectory(simd)\nadd_subdirectory(imd)\nadd_subdirectory(compat)\nadd_subdirectory(mimic)\nif (NOT GMX_BUILD_MDRUN_ONLY)\n    add_subdirectory(gmxana)\n    add_subdirectory(gmxpreprocess)\n    add_subdirectory(correlationfunctions)\n    add_subdirectory(statistics)\n    add_subdirectory(analysisdata)\n    add_subdirectory(selection)\n    add_subdirectory(trajectoryanalysis)\n    add_subdirectory(energyanalysis)\n    add_subdirectory(tools)\nendif()\n\nget_property(PROPERTY_SOURCES GLOBAL PROPERTY GMX_LIBGROMACS_SOURCES)\nlist(APPEND LIBGROMACS_SOURCES ${GMXLIB_SOURCES} ${MDLIB_SOURCES} ${PROPERTY_SOURCES})\n\n# This would be the standard way to include thread_mpi, but\n# we want libgromacs to link the functions directly\n#if(GMX_THREAD_MPI)\n#    add_subdirectory(thread_mpi)\n#endif()\n#target_link_libraries(gmx ${GMX_EXTRA_LIBRARIES} ${THREAD_MPI_LIB})\n\ntmpi_get_source_list(THREAD_MPI_SOURCES ${CMAKE_SOURCE_DIR}/src/external/thread_mpi/src)\ntarget_sources(libgromacs_external PRIVATE ${THREAD_MPI_SOURCES})\n\nconfigure_file(version.h.cmakein version.h)\ngmx_install_headers(\n    analysisdata.h\n    commandline.h\n    options.h\n    random.h\n    selection.h\n    trajectoryanalysis.h\n    utility.h\n    ${CMAKE_CURRENT_BINARY_DIR}/version.h\n    )\n\n# This code is here instead of utility/CMakeLists.txt, because CMake\n# custom commands and source file properties can only be set in the directory\n# that contains the target that uses them.\n# TODO: Generate a header instead that can be included from baseversion.c.\n# That probably simplifies things somewhat.\nset(GENERATED_VERSION_FILE utility/baseversion-gen.cpp)\ngmx_configure_version_file(\n    utility/baseversion-gen.cpp.cmakein ${GENERATED_VERSION_FILE}\n    REMOTE_HASH\n    EXTRA_VARS\n        GMX_SOURCE_DOI\n    )\nlist(APPEND LIBGROMACS_SOURCES ${GENERATED_VERSION_FILE}\n     $<TARGET_OBJECTS:libgromacs_external>\n     $<TARGET_OBJECTS:libgromacs_generated>)\n\n# Mark some shared GPU implementation files to compile with CUDA if needed\nif (GMX_USE_CUDA)\n    get_property(LIBGROMACS_GPU_IMPL_SOURCES GLOBAL PROPERTY GMX_LIBGROMACS_GPU_IMPL_SOURCES)\n    set_source_files_properties(${LIBGROMACS_GPU_IMPL_SOURCES} PROPERTIES CUDA_SOURCE_PROPERTY_FORMAT OBJ)\nendif()\n\n# set up CUDA compilation with clang\nif (GMX_CLANG_CUDA)\n    foreach (_file ${LIBGROMACS_SOURCES})\n        get_filename_component(_ext ${_file} EXT)\n        get_source_file_property(_cuda_source_format ${_file} CUDA_SOURCE_PROPERTY_FORMAT)\n        if (\"${_ext}\" STREQUAL \".cu\" OR _cuda_source_format)\n            gmx_compile_cuda_file_with_clang(${_file})\n        endif()\n    endforeach()\nendif()\n\nif (GMX_USE_CUDA)\n    # Work around FindCUDA that prevents using target_link_libraries()\n    # with keywords otherwise...\n    set(CUDA_LIBRARIES PRIVATE ${CUDA_LIBRARIES})\n    if (NOT GMX_CLANG_CUDA)\n        cuda_add_library(libgromacs ${LIBGROMACS_SOURCES})\n    else()\n        add_library(libgromacs ${LIBGROMACS_SOURCES})\n    endif()\n    target_link_libraries(libgromacs PRIVATE ${CUDA_CUFFT_LIBRARIES})\nelse()\n    add_library(libgromacs ${LIBGROMACS_SOURCES})\nendif()\n\nif (GMX_USE_OPENCL)\n    option(GMX_EXTERNAL_CLFFT \"True if an external clFFT is required to be used\" FALSE)\n    mark_as_advanced(GMX_EXTERNAL_CLFFT)\n\n    # Default to using clFFT found on the system\n    # switch to quiet at the second run.\n    if (DEFINED clFFT_LIBRARY)\n        set (clFFT_FIND_QUIETLY TRUE)\n    endif()\n    find_package(clFFT)\n    if (NOT clFFT_FOUND)\n        if (GMX_EXTERNAL_CLFFT)\n            message(FATAL_ERROR \"Did not find required external clFFT library, consider setting clFFT_ROOT_DIR\")\n        endif()\n\n        if(MSVC)\n            message(FATAL_ERROR\n\"An OpenCL build was requested with Visual Studio compiler, but GROMACS\nrequires clFFT, which was not found on your system. GROMACS does bundle\nclFFT to help with building for OpenCL, but that clFFT has not yet been\nported to the more recent versions of that compiler that GROMACS itself\nrequires. Thus for now, OpenCL is not available with MSVC and the internal\nbuild of clFFT in GROMACS 2019. Either change compiler, try installing\na clFFT package, or use the latest GROMACS 2018 point release.\")\n        endif()\n\n        # Fall back on the internal version\n        set (_clFFT_dir ../external/clFFT/src)\n        add_subdirectory(${_clFFT_dir} clFFT-build)\n        target_sources(libgromacs PRIVATE\n            $<TARGET_OBJECTS:clFFT>\n        )\n        target_include_directories(libgromacs SYSTEM PRIVATE ${_clFFT_dir}/include)\n        # Use the magic variable for how to link any library needed for\n        # dlopen, etc.  which is -ldl where needed, and empty otherwise\n        # (e.g. Windows, BSD, Mac).\n        target_link_libraries(libgromacs PRIVATE \"${CMAKE_DL_LIBS}\")\n    else()\n        target_link_libraries(libgromacs PRIVATE clFFT)\n    endif()\nendif()\n\n# Recent versions of gcc and clang give warnings on scanner.cpp, which\n# is a generated source file. These are awkward to suppress inline, so\n# we do it in the compilation command (after testing that the compiler\n# supports the suppressions). Same issue exists for nonbonded kernels\n# so we supress them for all generated files.\ninclude(CheckCXXCompilerFlag)\ncheck_cxx_compiler_flag(\"-Wno-unused -Wno-unused-parameter\" HAS_NO_UNUSED)\ncheck_cxx_compiler_flag(-Wno-missing-declarations HAS_NO_MISSING_DECL)\ncheck_cxx_compiler_flag(-Wno-missing-prototypes HAS_NO_MISSING_PROTO)\ncheck_cxx_compiler_flag(/wd4101 HAS_NO_MSVC_UNUSED)\nif (NOT MSVC)\n    check_cxx_compiler_flag(-wd1419 HAS_DECL_IN_SOURCE)\nendif()\nif (HAS_NO_UNUSED)\n    target_compile_options(libgromacs_generated PRIVATE \"-Wno-unused;-Wno-unused-parameter\")\nendif()\nif (HAS_NO_MISSING_DECL)\n    target_compile_options(libgromacs_generated PRIVATE \"-Wno-missing-declarations\")\nendif()\n# TODO The group scheme kernels don't use proper function prototype\n# declarations, and clang warns about such use, which we suppress\n# rather than fix. We would prefer to use no suppressions. However\n# other compilers do not support such a warning suppression for C++\n# source files, and issue warnings about that. Remove the use of\n# -Wno-missing-prototypes here and above when the group scheme is\n# removed.\nif (HAS_NO_MISSING_PROTO AND \"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"Clang\")\n    target_compile_options(libgromacs_generated PRIVATE \"-Wno-missing-prototypes\")\nendif()\nif (HAS_NO_MSVC_UNUSED)\n    target_compile_options(libgromacs_generated PRIVATE \"/wd4101\")\nendif()\nif (HAS_DECL_IN_SOURCE)\n    target_compile_options(libgromacs_generated PRIVATE \"-wd1419\")\nendif()\n\nif(SIMD_AVX_512_CXX_SUPPORTED AND NOT (\"${GMX_SIMD_ACTIVE}\" STREQUAL \"AVX_512_KNL\"))\n    # Since we might be overriding -march=core-avx2, add a flag so we don't warn for this specific file.\n    # On KNL this can cause illegal instruction because the compiler might use non KNL AVX instructions\n    # with the SIMD_AVX_512_CXX_FLAGS flags.\n    set_source_files_properties(hardware/identifyavx512fmaunits.cpp PROPERTIES COMPILE_FLAGS \"${SIMD_AVX_512_CXX_FLAGS} ${CXX_NO_UNUSED_OPTION_WARNING_FLAGS}\")\nendif()\n\ngmx_setup_tng_for_libgromacs()\n\ntarget_link_libraries(libgromacs\n                      PRIVATE\n                      ${EXTRAE_LIBRARIES}\n                      ${GMX_EXTRA_LIBRARIES}\n                      ${GMX_COMMON_LIBRARIES}\n                      ${FFT_LIBRARIES} ${LINEAR_ALGEBRA_LIBRARIES}\n                      ${THREAD_LIB} ${GMX_SHARED_LINKER_FLAGS}\n                      ${OpenCL_LIBRARIES}\n                      ${GMX_STDLIB_LIBRARIES}\n                      PUBLIC\n                      ${GMX_PUBLIC_LIBRARIES}\n                      )\nset_target_properties(libgromacs PROPERTIES\n                      OUTPUT_NAME \"gromacs${GMX_LIBS_SUFFIX}\"\n                      SOVERSION ${LIBRARY_SOVERSION_MAJOR}\n                      VERSION ${LIBRARY_VERSION}\n                      COMPILE_FLAGS \"${OpenMP_C_FLAGS}\")\n\ngmx_manage_lmfit()\ntarget_link_libraries(libgromacs PRIVATE lmfit)\n\nif (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" AND CMAKE_CXX_COMPILER_VERSION MATCHES \"^6\\.0\")\n   target_compile_options(libgromacs PRIVATE $<$<COMPILE_LANGUAGE:CXX>:-Weverything ${IGNORED_CLANG_ALL_WARNINGS}>)\nendif()\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"MSVC\")\n   target_compile_options(libgromacs PRIVATE $<$<COMPILE_LANGUAGE:CXX>:/analyze /analyze:stacksize 70000\n     #Control flow warnings are disabled because the commond line output is insufficient. There is no tool\n     #to convert the xml report to e.g. HTML and even in Visual Studio the viewer doesn't work with cmake support.\n     /wd6001  #unitialized memory\n     /wd6011  #derefencing NULL\n     /wd6053  #prior call not zero-terminate\n     /wd6054  #might not be zero-terminated\n     /wd6385  #reading invalid data\n     /wd6386  #buffer overrun\n     /wd6387  #could be '0'\n     /wd28199 #uninitialized memory\n     # For compile time constant (e.g. templates) the following warnings have flase postives\n     /wd6239  #(<non-zero> && <expr>)\n     /wd6240  #(<expr> && <non-zero>)\n     /wd6294  #Ill-defined for-loop\n     /wd6326  #comparison of constant with other constant\n     /wd28020 #expression involving paramter is not true\n     # Misc\n     /wd6330  #incorrect type to function (warns for char (instead of unsigned) for isspace/isalpha/isdigit/..))\n     /wd6993  #OpenMP ignored\n     #TODO\n     /wd6031  #return value ignored (important - mostly warnigns about sscanf)\n     /wd6244  #hides declaration (known issue - we ingore similar warnings for other compilers)\n     /wd6246  #hides declaration\n     >\n   )\nendif()\n\nif (GMX_CLANG_TIDY)\n   set_target_properties(libgromacs PROPERTIES CXX_CLANG_TIDY\n       \"${CLANG_TIDY_EXE};-warnings-as-errors=*\")\nendif()\n\ngmx_write_installed_header_list()\n\n# Only install the library in mdrun-only mode if it is actually necessary\n# for the binary\nif (NOT GMX_BUILD_MDRUN_ONLY OR BUILD_SHARED_LIBS)\n    install(TARGETS libgromacs\n            EXPORT libgromacs\n            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n            RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n            COMPONENT libraries)\nendif()\n\nif (NOT GMX_BUILD_MDRUN_ONLY)\n    include(InstallLibInfo.cmake)\nendif()\n\n# Technically, the user could want to do this for an OpenCL build\n# using the CUDA runtime, but currently there's no reason to want to\n# do that.\nif (INSTALL_CUDART_LIB) #can be set manual by user\n    if (GMX_USE_CUDA)\n        foreach(CUDA_LIB ${CUDA_LIBRARIES})\n            string(REGEX MATCH \"cudart\" IS_CUDART ${CUDA_LIB})\n            if(IS_CUDART) #libcuda should not be installed\n                #install also name-links (linker uses those)\n                file(GLOB CUDA_LIBS ${CUDA_LIB}*)\n                install(FILES ${CUDA_LIBS} DESTINATION\n                    ${CMAKE_INSTALL_LIBDIR} COMPONENT libraries)\n            endif()\n        endforeach()\n    else()\n        message(WARNING \"INSTALL_CUDART_LIB only makes sense when configuring for CUDA support\")\n    endif()\nendif()\n\nif(GMX_USE_OPENCL)\n    # Install the utility headers\n    file(GLOB OPENCL_INSTALLED_FILES\n        gpu_utils/vectype_ops.clh\n        gpu_utils/device_utils.clh\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/gpu_utils\n        COMPONENT libraries)\n    file(GLOB OPENCL_INSTALLED_FILES\n        pbcutil/ishift.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/pbcutil\n        COMPONENT libraries)\n\n    # Install the NB source and headers\n    file(GLOB OPENCL_INSTALLED_FILES\n        mdlib/nbnxn_consts.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/mdlib\n        COMPONENT libraries)\n    file(GLOB OPENCL_INSTALLED_FILES\n        mdlib/nbnxn_ocl/nbnxn_ocl_kernels.cl\n        mdlib/nbnxn_ocl/nbnxn_ocl_kernel.clh\n        mdlib/nbnxn_ocl/nbnxn_ocl_kernel_pruneonly.clh\n        mdlib/nbnxn_ocl/nbnxn_ocl_kernels.clh\n        mdlib/nbnxn_ocl/nbnxn_ocl_kernels_fastgen.clh\n        mdlib/nbnxn_ocl/nbnxn_ocl_kernels_fastgen_add_twincut.clh\n        mdlib/nbnxn_ocl/nbnxn_ocl_kernel_utils.clh\n        mdlib/nbnxn_ocl/nbnxn_ocl_consts.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/mdlib/nbnxn_ocl\n        COMPONENT libraries)\n\n    # Install the PME source and headers\n    file(GLOB OPENCL_INSTALLED_FILES\n        ewald/pme-spread.clh\n        ewald/pme-solve.clh\n        ewald/pme-gather.clh\n        ewald/pme-gpu-utils.clh\n        ewald/pme-program.cl\n        ewald/pme-gpu-types.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/ewald\n        COMPONENT libraries)\nendif()\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/patches/gromacs-2019.6.diff/src/gromacs/CMakeLists.txt": "#\n# This file is part of the GROMACS molecular simulation package.\n#\n# Copyright (c) 2010,2011,2012,2013,2014,2015,2016,2017,2018,2019, by the GROMACS development team, led by\n# Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,\n# and including many others, as listed in the AUTHORS file in the\n# top-level source directory and at http://www.gromacs.org.\n#\n# GROMACS is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public License\n# as published by the Free Software Foundation; either version 2.1\n# of the License, or (at your option) any later version.\n#\n# GROMACS is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with GROMACS; if not, see\n# http://www.gnu.org/licenses, or write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.\n#\n# If you want to redistribute modifications to GROMACS, please\n# consider that scientific software is very special. Version\n# control is crucial - bugs must be traceable. We will be happy to\n# consider code for inclusion in the official distribution, but\n# derived work must not be called official GROMACS. Details are found\n# in the README & COPYING files - if they are missing, get the\n# official version at http://www.gromacs.org.\n#\n# To help us fund GROMACS development, we humbly ask that you cite\n# the research papers on the package. Check out http://www.gromacs.org.\n\ninclude(${CMAKE_SOURCE_DIR}/Plumed.cmake)\n\nset(LIBGROMACS_SOURCES)\n\nif (GMX_CLANG_CUDA)\n    include(gmxClangCudaUtils)\nendif()\n\nset_property(GLOBAL PROPERTY GMX_LIBGROMACS_SOURCES)\nset_property(GLOBAL PROPERTY GMX_LIBGROMACS_GPU_IMPL_SOURCES)\nset_property(GLOBAL PROPERTY GMX_INSTALLED_HEADERS)\nset_property(GLOBAL PROPERTY GMX_AVX_512_SOURCE)\n\nadd_library(libgromacs_external OBJECT \"\")\nif(CMAKE_COMPILER_IS_GNUCXX)\n    # Keep quiet about e.g. linearalgebra module\n    target_compile_options(libgromacs_external PRIVATE ${CXXFLAGS_NO_STRINGOP_TRUNCATION})\nendif()\n\nadd_library(libgromacs_generated OBJECT \"\")\nif (BUILD_SHARED_LIBS)\n    set_target_properties(libgromacs_external PROPERTIES POSITION_INDEPENDENT_CODE true)\n    set_target_properties(libgromacs_generated PROPERTIES POSITION_INDEPENDENT_CODE true)\nendif()\n\nfunction (_gmx_add_files_to_property PROPERTY)\n    foreach (_file ${ARGN})\n        if (IS_ABSOLUTE \"${_file}\")\n            set_property(GLOBAL APPEND PROPERTY ${PROPERTY} ${_file})\n        else()\n            set_property(GLOBAL APPEND PROPERTY ${PROPERTY}\n                         ${CMAKE_CURRENT_LIST_DIR}/${_file})\n        endif()\n    endforeach()\nendfunction ()\n\nfunction (gmx_add_libgromacs_sources)\n    _gmx_add_files_to_property(GMX_LIBGROMACS_SOURCES ${ARGN})\nendfunction ()\n\n# TODO Reconsider this, as the CUDA driver API is probably a simpler\n# approach, at least for the build system. See Redmine #2530\nfunction (gmx_compile_cpp_as_cuda)\n    _gmx_add_files_to_property(GMX_LIBGROMACS_GPU_IMPL_SOURCES ${ARGN})\nendfunction ()\n\nfunction (gmx_install_headers)\n    if (NOT GMX_BUILD_MDRUN_ONLY)\n        file(RELATIVE_PATH _dest ${PROJECT_SOURCE_DIR}/src ${CMAKE_CURRENT_LIST_DIR})\n        install(FILES       ${ARGN}\n                DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}/${_dest}\"\n                COMPONENT   development)\n    endif()\n    _gmx_add_files_to_property(GMX_INSTALLED_HEADERS ${ARGN})\nendfunction ()\n\nfunction (gmx_write_installed_header_list)\n    get_property(_list GLOBAL PROPERTY GMX_INSTALLED_HEADERS)\n    string(REPLACE \";\" \"\\n\" _list \"${_list}\")\n    # TODO: Make this only update the file timestamp if the contents actually change.\n    file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/installed-headers.txt \"${_list}\")\nendfunction()\n\nadd_subdirectory(gmxlib)\nadd_subdirectory(mdlib)\nadd_subdirectory(applied-forces)\nadd_subdirectory(listed-forces)\nadd_subdirectory(commandline)\nadd_subdirectory(domdec)\nadd_subdirectory(ewald)\nadd_subdirectory(fft)\nadd_subdirectory(gpu_utils)\nadd_subdirectory(hardware)\nadd_subdirectory(linearalgebra)\nadd_subdirectory(math)\nadd_subdirectory(mdrun)\nadd_subdirectory(mdrunutility)\nadd_subdirectory(mdtypes)\nadd_subdirectory(onlinehelp)\nadd_subdirectory(options)\nadd_subdirectory(pbcutil)\nadd_subdirectory(random)\nadd_subdirectory(restraint)\nadd_subdirectory(tables)\nadd_subdirectory(taskassignment)\nadd_subdirectory(timing)\nadd_subdirectory(topology)\nadd_subdirectory(trajectory)\nadd_subdirectory(utility)\nadd_subdirectory(fileio)\nadd_subdirectory(swap)\nadd_subdirectory(essentialdynamics)\nadd_subdirectory(pulling)\nadd_subdirectory(awh)\nadd_subdirectory(simd)\nadd_subdirectory(imd)\nadd_subdirectory(compat)\nadd_subdirectory(mimic)\nif (NOT GMX_BUILD_MDRUN_ONLY)\n    add_subdirectory(gmxana)\n    add_subdirectory(gmxpreprocess)\n    add_subdirectory(correlationfunctions)\n    add_subdirectory(statistics)\n    add_subdirectory(analysisdata)\n    add_subdirectory(selection)\n    add_subdirectory(trajectoryanalysis)\n    add_subdirectory(energyanalysis)\n    add_subdirectory(tools)\nendif()\n\nget_property(PROPERTY_SOURCES GLOBAL PROPERTY GMX_LIBGROMACS_SOURCES)\nlist(APPEND LIBGROMACS_SOURCES ${GMXLIB_SOURCES} ${MDLIB_SOURCES} ${PROPERTY_SOURCES})\n\n# This would be the standard way to include thread_mpi, but\n# we want libgromacs to link the functions directly\n#if(GMX_THREAD_MPI)\n#    add_subdirectory(thread_mpi)\n#endif()\n#target_link_libraries(gmx ${GMX_EXTRA_LIBRARIES} ${THREAD_MPI_LIB})\n\ntmpi_get_source_list(THREAD_MPI_SOURCES ${CMAKE_SOURCE_DIR}/src/external/thread_mpi/src)\ntarget_sources(libgromacs_external PRIVATE ${THREAD_MPI_SOURCES})\n\nconfigure_file(version.h.cmakein version.h)\ngmx_install_headers(\n    analysisdata.h\n    commandline.h\n    options.h\n    random.h\n    selection.h\n    trajectoryanalysis.h\n    utility.h\n    ${CMAKE_CURRENT_BINARY_DIR}/version.h\n    )\n\n# This code is here instead of utility/CMakeLists.txt, because CMake\n# custom commands and source file properties can only be set in the directory\n# that contains the target that uses them.\n# TODO: Generate a header instead that can be included from baseversion.c.\n# That probably simplifies things somewhat.\nset(GENERATED_VERSION_FILE utility/baseversion-gen.cpp)\ngmx_configure_version_file(\n    utility/baseversion-gen.cpp.cmakein ${GENERATED_VERSION_FILE}\n    REMOTE_HASH\n    EXTRA_VARS\n        GMX_SOURCE_DOI\n    )\nlist(APPEND LIBGROMACS_SOURCES ${GENERATED_VERSION_FILE}\n     $<TARGET_OBJECTS:libgromacs_external>\n     $<TARGET_OBJECTS:libgromacs_generated>)\n\n# Mark some shared GPU implementation files to compile with CUDA if needed\nif (GMX_USE_CUDA)\n    get_property(LIBGROMACS_GPU_IMPL_SOURCES GLOBAL PROPERTY GMX_LIBGROMACS_GPU_IMPL_SOURCES)\n    set_source_files_properties(${LIBGROMACS_GPU_IMPL_SOURCES} PROPERTIES CUDA_SOURCE_PROPERTY_FORMAT OBJ)\nendif()\n\n# set up CUDA compilation with clang\nif (GMX_CLANG_CUDA)\n    foreach (_file ${LIBGROMACS_SOURCES})\n        get_filename_component(_ext ${_file} EXT)\n        get_source_file_property(_cuda_source_format ${_file} CUDA_SOURCE_PROPERTY_FORMAT)\n        if (\"${_ext}\" STREQUAL \".cu\" OR _cuda_source_format)\n            gmx_compile_cuda_file_with_clang(${_file})\n        endif()\n    endforeach()\nendif()\n\nif (GMX_USE_CUDA)\n    # Work around FindCUDA that prevents using target_link_libraries()\n    # with keywords otherwise...\n    set(CUDA_LIBRARIES PRIVATE ${CUDA_LIBRARIES})\n    if (NOT GMX_CLANG_CUDA)\n        cuda_add_library(libgromacs ${LIBGROMACS_SOURCES})\n    else()\n        add_library(libgromacs ${LIBGROMACS_SOURCES})\n    endif()\n    target_link_libraries(libgromacs PRIVATE ${CUDA_CUFFT_LIBRARIES})\nelse()\n    add_library(libgromacs ${LIBGROMACS_SOURCES})\nendif()\n\nif (GMX_USE_OPENCL)\n    option(GMX_EXTERNAL_CLFFT \"True if an external clFFT is required to be used\" FALSE)\n    mark_as_advanced(GMX_EXTERNAL_CLFFT)\n\n    # Default to using clFFT found on the system\n    # switch to quiet at the second run.\n    if (DEFINED clFFT_LIBRARY)\n        set (clFFT_FIND_QUIETLY TRUE)\n    endif()\n    find_package(clFFT)\n    if (NOT clFFT_FOUND)\n        if (GMX_EXTERNAL_CLFFT)\n            message(FATAL_ERROR \"Did not find required external clFFT library, consider setting clFFT_ROOT_DIR\")\n        endif()\n\n        if(MSVC)\n            message(FATAL_ERROR\n\"An OpenCL build was requested with Visual Studio compiler, but GROMACS\nrequires clFFT, which was not found on your system. GROMACS does bundle\nclFFT to help with building for OpenCL, but that clFFT has not yet been\nported to the more recent versions of that compiler that GROMACS itself\nrequires. Thus for now, OpenCL is not available with MSVC and the internal\nbuild of clFFT in GROMACS 2019. Either change compiler, try installing\na clFFT package, or use the latest GROMACS 2018 point release.\")\n        endif()\n\n        # Fall back on the internal version\n        set (_clFFT_dir ../external/clFFT/src)\n        add_subdirectory(${_clFFT_dir} clFFT-build)\n        target_sources(libgromacs PRIVATE\n            $<TARGET_OBJECTS:clFFT>\n        )\n        target_include_directories(libgromacs SYSTEM PRIVATE ${_clFFT_dir}/include)\n        # Use the magic variable for how to link any library needed for\n        # dlopen, etc.  which is -ldl where needed, and empty otherwise\n        # (e.g. Windows, BSD, Mac).\n        target_link_libraries(libgromacs PRIVATE \"${CMAKE_DL_LIBS}\")\n    else()\n        target_link_libraries(libgromacs PRIVATE clFFT)\n    endif()\nendif()\n\n# Recent versions of gcc and clang give warnings on scanner.cpp, which\n# is a generated source file. These are awkward to suppress inline, so\n# we do it in the compilation command (after testing that the compiler\n# supports the suppressions). Same issue exists for nonbonded kernels\n# so we supress them for all generated files.\ninclude(CheckCXXCompilerFlag)\ncheck_cxx_compiler_flag(\"-Wno-unused -Wno-unused-parameter\" HAS_NO_UNUSED)\ncheck_cxx_compiler_flag(-Wno-missing-declarations HAS_NO_MISSING_DECL)\ncheck_cxx_compiler_flag(-Wno-missing-prototypes HAS_NO_MISSING_PROTO)\ncheck_cxx_compiler_flag(/wd4101 HAS_NO_MSVC_UNUSED)\nif (NOT MSVC)\n    check_cxx_compiler_flag(-wd1419 HAS_DECL_IN_SOURCE)\nendif()\nif (HAS_NO_UNUSED)\n    target_compile_options(libgromacs_generated PRIVATE \"-Wno-unused;-Wno-unused-parameter\")\nendif()\nif (HAS_NO_MISSING_DECL)\n    target_compile_options(libgromacs_generated PRIVATE \"-Wno-missing-declarations\")\nendif()\n# TODO The group scheme kernels don't use proper function prototype\n# declarations, and clang warns about such use, which we suppress\n# rather than fix. We would prefer to use no suppressions. However\n# other compilers do not support such a warning suppression for C++\n# source files, and issue warnings about that. Remove the use of\n# -Wno-missing-prototypes here and above when the group scheme is\n# removed.\nif (HAS_NO_MISSING_PROTO AND \"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"Clang\")\n    target_compile_options(libgromacs_generated PRIVATE \"-Wno-missing-prototypes\")\nendif()\nif (HAS_NO_MSVC_UNUSED)\n    target_compile_options(libgromacs_generated PRIVATE \"/wd4101\")\nendif()\nif (HAS_DECL_IN_SOURCE)\n    target_compile_options(libgromacs_generated PRIVATE \"-wd1419\")\nendif()\n\nif(SIMD_AVX_512_CXX_SUPPORTED AND NOT (\"${GMX_SIMD_ACTIVE}\" STREQUAL \"AVX_512_KNL\"))\n    # Since we might be overriding -march=core-avx2, add a flag so we don't warn for this specific file.\n    # On KNL this can cause illegal instruction because the compiler might use non KNL AVX instructions\n    # with the SIMD_AVX_512_CXX_FLAGS flags.\n    set_source_files_properties(hardware/identifyavx512fmaunits.cpp PROPERTIES COMPILE_FLAGS \"${SIMD_AVX_512_CXX_FLAGS} ${CXX_NO_UNUSED_OPTION_WARNING_FLAGS}\")\nendif()\n\ngmx_setup_tng_for_libgromacs()\n\ntarget_link_libraries(libgromacs\n                      PRIVATE\n                      ${EXTRAE_LIBRARIES}\n                      ${GMX_EXTRA_LIBRARIES}\n                      ${GMX_COMMON_LIBRARIES}\n                      ${FFT_LIBRARIES} ${LINEAR_ALGEBRA_LIBRARIES}\n                      ${THREAD_LIB} ${GMX_SHARED_LINKER_FLAGS}\n                      ${OpenCL_LIBRARIES}\n                      ${GMX_STDLIB_LIBRARIES}\n                      PUBLIC\n                      ${GMX_PUBLIC_LIBRARIES}\n                      ${PLUMED_LOAD}\n                      )\nset_target_properties(libgromacs PROPERTIES\n                      OUTPUT_NAME \"gromacs${GMX_LIBS_SUFFIX}\"\n                      SOVERSION ${LIBRARY_SOVERSION_MAJOR}\n                      VERSION ${LIBRARY_VERSION}\n                      COMPILE_FLAGS \"${OpenMP_C_FLAGS}\")\n\ngmx_manage_lmfit()\ntarget_link_libraries(libgromacs PRIVATE lmfit)\n\nif (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" AND CMAKE_CXX_COMPILER_VERSION MATCHES \"^6\\.0\")\n   target_compile_options(libgromacs PRIVATE $<$<COMPILE_LANGUAGE:CXX>:-Weverything ${IGNORED_CLANG_ALL_WARNINGS}>)\nendif()\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"MSVC\")\n   target_compile_options(libgromacs PRIVATE $<$<COMPILE_LANGUAGE:CXX>:/analyze /analyze:stacksize 70000\n     #Control flow warnings are disabled because the commond line output is insufficient. There is no tool\n     #to convert the xml report to e.g. HTML and even in Visual Studio the viewer doesn't work with cmake support.\n     /wd6001  #unitialized memory\n     /wd6011  #derefencing NULL\n     /wd6053  #prior call not zero-terminate\n     /wd6054  #might not be zero-terminated\n     /wd6385  #reading invalid data\n     /wd6386  #buffer overrun\n     /wd6387  #could be '0'\n     /wd28199 #uninitialized memory\n     # For compile time constant (e.g. templates) the following warnings have flase postives\n     /wd6239  #(<non-zero> && <expr>)\n     /wd6240  #(<expr> && <non-zero>)\n     /wd6294  #Ill-defined for-loop\n     /wd6326  #comparison of constant with other constant\n     /wd28020 #expression involving paramter is not true\n     # Misc\n     /wd6330  #incorrect type to function (warns for char (instead of unsigned) for isspace/isalpha/isdigit/..))\n     /wd6993  #OpenMP ignored\n     #TODO\n     /wd6031  #return value ignored (important - mostly warnigns about sscanf)\n     /wd6244  #hides declaration (known issue - we ingore similar warnings for other compilers)\n     /wd6246  #hides declaration\n     >\n   )\nendif()\n\nif (GMX_CLANG_TIDY)\n   set_target_properties(libgromacs PROPERTIES CXX_CLANG_TIDY\n       \"${CLANG_TIDY_EXE};-warnings-as-errors=*\")\nendif()\n\ngmx_write_installed_header_list()\n\n# Only install the library in mdrun-only mode if it is actually necessary\n# for the binary\nif (NOT GMX_BUILD_MDRUN_ONLY OR BUILD_SHARED_LIBS)\n    install(TARGETS libgromacs\n            EXPORT libgromacs\n            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n            RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n            COMPONENT libraries)\nendif()\n\nif (NOT GMX_BUILD_MDRUN_ONLY)\n    include(InstallLibInfo.cmake)\nendif()\n\n# Technically, the user could want to do this for an OpenCL build\n# using the CUDA runtime, but currently there's no reason to want to\n# do that.\nif (INSTALL_CUDART_LIB) #can be set manual by user\n    if (GMX_USE_CUDA)\n        foreach(CUDA_LIB ${CUDA_LIBRARIES})\n            string(REGEX MATCH \"cudart\" IS_CUDART ${CUDA_LIB})\n            if(IS_CUDART) #libcuda should not be installed\n                #install also name-links (linker uses those)\n                file(GLOB CUDA_LIBS ${CUDA_LIB}*)\n                install(FILES ${CUDA_LIBS} DESTINATION\n                    ${CMAKE_INSTALL_LIBDIR} COMPONENT libraries)\n            endif()\n        endforeach()\n    else()\n        message(WARNING \"INSTALL_CUDART_LIB only makes sense when configuring for CUDA support\")\n    endif()\nendif()\n\nif(GMX_USE_OPENCL)\n    # Install the utility headers\n    file(GLOB OPENCL_INSTALLED_FILES\n        gpu_utils/vectype_ops.clh\n        gpu_utils/device_utils.clh\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/gpu_utils\n        COMPONENT libraries)\n    file(GLOB OPENCL_INSTALLED_FILES\n        pbcutil/ishift.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/pbcutil\n        COMPONENT libraries)\n\n    # Install the NB source and headers\n    file(GLOB OPENCL_INSTALLED_FILES\n        mdlib/nbnxn_consts.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/mdlib\n        COMPONENT libraries)\n    file(GLOB OPENCL_INSTALLED_FILES\n        mdlib/nbnxn_ocl/nbnxn_ocl_kernels.cl\n        mdlib/nbnxn_ocl/nbnxn_ocl_kernel.clh\n        mdlib/nbnxn_ocl/nbnxn_ocl_kernel_pruneonly.clh\n        mdlib/nbnxn_ocl/nbnxn_ocl_kernels.clh\n        mdlib/nbnxn_ocl/nbnxn_ocl_kernels_fastgen.clh\n        mdlib/nbnxn_ocl/nbnxn_ocl_kernels_fastgen_add_twincut.clh\n        mdlib/nbnxn_ocl/nbnxn_ocl_kernel_utils.clh\n        mdlib/nbnxn_ocl/nbnxn_ocl_consts.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/mdlib/nbnxn_ocl\n        COMPONENT libraries)\n\n    # Install the PME source and headers\n    file(GLOB OPENCL_INSTALLED_FILES\n        ewald/pme-spread.clh\n        ewald/pme-solve.clh\n        ewald/pme-gather.clh\n        ewald/pme-gpu-utils.clh\n        ewald/pme-program.cl\n        ewald/pme-gpu-types.h\n        )\n    install(FILES ${OPENCL_INSTALLED_FILES}\n        DESTINATION ${GMX_INSTALL_OCLDIR}/gromacs/ewald\n        COMPONENT libraries)\nendif()\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/developer-doc/Doc.txt": "// This document is formatted for Doxygen\n/**\n\\mainpage Plumed 2\n\nRoadmap:\n- Cloning most PLUMED1 features (to be defined)\n- Public beta release (to be defined)\n- 2.0 public release (to be defined)\n\n\\section FeaturesAndChanges Features and changes\n\nThis are some comments about the structure of the code:\n- Re-designed from scratch, hopefully better.\n- Input is conceptually similar but NON compatible. It is difficult to automatically\n  convert old input files, but we could provide a short transition guide.\n  The new plumed.dat is a sort of script containing a list of actions to be performed at each step.\n  Notable differences in input:\n  - An Action is composed of a line (possibly with continuations) of\n    space-separated words, and corresponds more-or-less to a directive in PLUMED1.\n\\verbatim\nDISTANCE ATOMS=0,300 LABEL=dist NOPBC\n\\endverbatim\n    The first word (DISTANCE here) defines the directive type, all other words are arguments\n    Most arguments are named, and has the form \"NAME=VALUE\" (ATOMS and LABEL in the example).\n    Others are flags (NOPBC in the example).\n  - Continuation can be done with \"...\" syntax (notice the space between DISTANCE and dots):\n\\verbatim\nDISTANCE ...\n  ATOMS=0,300\n  LABEL=dist\n  NOPBC\n... DISTANCE\n\\endverbatim\n  - All directives can be labeled (LABEL=dist in the example)\n  - A bias can only act on a labeled colvar:\n\\verbatim\nDISTANCE ATOMS=0,300 LABEL=dist\n# This is a harmonic restraint\nRESTRAINT ARG=dist KAPPA=1.0 AT=1.0\n\\endverbatim\n  - Some colvars have extra named values, which can be accessed with \".\" syntax\n\\verbatim\nDISTANCE ATOMS=1,10 LABEL=dist COMPONENTS\nRESTRAINT ARG=dist.x KAPPA=1.0 AT=1.0\n\\endverbatim\n    Here COMPONENTS is telling to DISTANCE to also compute the three components.\n    This is expected to be useful for variables which have multiple components\n    but that are heavy and we would like to compute only once (e.g. components\n    of the inertia tensor of a large molecule).\n    Also methods can have extra named values, such as the energy for a restraint.\n  - to print a COLVAR-like file (name can be changed), use PRINT directive\n\\verbatim\nPRINT ARG=d1,d1.x,d1.y,d1.z STRIDE=100 FILE=COLVAR\n# or\nPRINT ARG=d1.* STRIDE=100 FILE=COLVAR1\n# or, to print all the variables defined in the plumed.dat up to this point\nPRINT ARG=* STRIDE=100 FILE=COLVAR_ALL\n\\endverbatim\n- The library has been written in C++ for a more flexible structure:\n  - Extensive use of STL containers for things such as lists/vectors/maps/...\n  - Polymorphism for collective variables/free energy methods\n  However, for compatibility, its main interface is in plain C (with FORTRAN\n  and C++ wrappers). All the C++ definitions are hidden in a PLMD namespace.\n- Hierarchy of classes describing each possible Action performed by PLUMED.\n  There is a class for each CV (e.g. PLMD::ColvarDistance, PLMD::ColvarEnergy,\n  PLMD::ColvarVolume), a class for each bias (e.g. PLMD::BiasRestraint, PLMD::BiasMovingRestraint),\n  and a class for each function (e.g. PLMD::FunctionCombine).\n  There are also auxiliary classes to write the output (PLMD::Print),\n  to set the units (PLMD::Units), to print dedug information (PLMD::Debug),\n  to flush the open files (PLMD::Flush), etc.\n  More or less, there should be a class for each possible directive of \"plumed.dat\".\n  To see the full hierarchy, look at PLMD::Action.\n- It should be possible to program Actions independently from each other. To this\n  aim, there is a register (PLMD::ActionRegister, contained in the function\n  PLMD::actionRegister()) where, during C++ initialization, each\n  Action registers itself. Thus, if a new CV or bias is added, there is no need\n  for recompilation. If dlopen() is available on a system, it should be possible\n  to load Actions runtime (using LOAD directive).\n  In the long run we can imagine libraries of CVs\n  suitable for different problems and, possibly, released independently from\n  the kernel. On a mainframe, one could add CVs without recompiling neither plumed\n  nor the MD engine.\n- There is an option to load the plumed kernel at runtime. If you patch with\n  --runtime, the plumed kernel is looked for at the path in variable PLUMED_KERNEL.\n  If the variable is not set, basic (un-plumed) version of MD is used.\n  On a mainframe, one can have multiple installed plumed versions.\n- Ideally, inside the kernel there is nothing related to specific CVs or FE-methods. Thus, CVs and \n  methods are optional plugins for PLUMED. The only exception\n  are tools which are common to several CVs/methods, such as grid interpolators, etc.\n- Ideally, inside the kernel there is nothing related to specific MD code. The interface is kept\n  as standard as possibly. Anyway, all the details of the interaction PLUMED/MD are inside the\n  src/Atoms.cpp file.  E.g., there are two (templated) versionsi of class PLMD::MDAtoms,\n  one for double precision and the other\n  for single precision MD. Code specific tools could be added here. In the future, we may try to\n  design a plugin approach also for MD engines (similarly to CVs/methods).\n- To simplify interface, there is a single routine plumed_cmd which takes a string and a pointer.\n  It can be used to pass any information to plumed, such as:\n\\verbatim\nplumed p=plumed_create();\nplumed_cmd(p,\"setNatoms\",&natoms);\nplumed_cmd(p,\"setMDEngine\",\"gromacs\");\nplumed_cmd(p,\"init\",NULL);\n...\nplumed_cmd(plumedmain,\"setPositions\",pos);\nplumed_cmd(plumedmain,\"setBox\",box);\nplumed_cmd(plumedmain,\"setEnergy\",&energy);\nplumed_cmd(plumedmain,\"setForces\",forces);\nplumed_cmd(plumedmain,\"setVirial\",virial);\nplumed_cmd(plumedmain,\"calc\",NULL);\n...\nplumed_finalize(p);\n\\endverbatim\n  Fortran/C++ interfaces are similar (see src/Plumed.c for details), and are based on the C interface\n  (wrappers).\n- Units: PLUMED reads and writes only in its internal units, which, by default, are\n  nm and kj/mol. In plumed.dat it is possible to change it to other choices:\n\\verbatim\nUNITS ...\n  LENGTH=A\n  TIME=fs\n  ENERGY=kcal/mol\n... UNITS\n\\endverbatim\n  The MD code should specify to plumed its internal units, so as to allow proper conversion.\n  E.g., a code using angstrom and kcal should do the following calls\n\\verbatim\ndouble energyUnits=4.184;\ndouble lengthUnits=0.1;\nplumed_cmd(plumedmain,\"setMDEnergyUnits\",&energyUnits);\nplumed_cmd(plumedmain,\"setMDLengthUnits\",&lengthUnits);\n\\endverbatim\n- Other cool features:\n  - Functions of colvars (or functions of functions) can be used. For example, defining:\n\\verbatim\nCOMBINE LABEL=sum2     ARG=dist.x,dist.y,dist.z POWERS=2,2,2\nCOMBINE LABEL=sqrtsum2 ARG=sum2                 POWERS=0.5\n# The following two restraints are equivalent:\nRESTRAINT ARG=dist     AT=1.2 KAPPA=1.0\nRESTRAINT ARG=sqrtsum2 AT=1.2 KAPPA=1.0\n\\endverbatim\n  - Multiple-time-step: biases can be applied with multiple-time-step using a stride. This should\n    help for variables which are heavy to compute but smooth\n\\verbatim\nRESTRAINT ARG=dist AT=1.2 KAPPA=1.0 STRIDE=2\n\\endverbatim\n  - It is possible to include other files:\n\\verbatim\nINCLUDE FILE=anotherplumed.dat\n\\endverbatim\n  - It is possible to load shared libraries implementing new CVs and methods:\n\\verbatim\nLOAD FILE=share-object.so\n\\endverbatim\n\n\\section Install Install\n\n- Configure and compile your MD code\n- Configure and compile PLUMED, possibly using the same compiler:\n\\verbatim\n$ ./configure.sh\n... choose your compiler interactively here ...\n... it may be necessary to edit the Makefile.conf file ...\n$ make -j 4\n\\endverbatim\n- Source the ./sourceme.sh file\n\\verbatim\n$ source sourceme.sh\n\\endverbatim\n  \\attention This should be done on every shell where you want to patch/run plumed\n- Go to your MD code directory and do the patch\n\\verbatim\n$ plumed patch --patch\n\\endverbatim\n  (use -h to get information about other options).  Also experiment other linking modes (e.g. --runtime)\n- Recompile your MD code (without necessarily cleaning it)\n\n\\section Content Content\n\nsrc/\nPlumed library source code (C++) plus a two wrapper files (Plumed.c and PlumedStatic.cpp; the latter is just\nequivalent to the former but is compiled as cpp, for testing, and does not allow runtime binding).\nSources are compiled into a libplumed.so library and a libplumedKernel.so library\n(replace .so with .dylib on Mac).\nThe src/Plumed.inc file contains shortcuts for the compilation. Just include it in your makefile and:\n- link the src/Plumed.h file in an included directory\n- add to the linker command the $(PLUMED_LDFLAG) options, to have the proper link flags\n- add to the linker command the $(PLUMED_LIBS) variable, to link the proper external libraries\n- add to the linker command one of the following variables:\n  - (A) \\$(PLUMED_OBJ) : plumed will be statically bound\n  - (B) \\$(PLUMED_SHARED_OBJ) : plumed will be dynamically bound\n  - (C) \\$(PLUMED_WRAPPER) : behavior depend on runtime value of the PLUMED_KERNEL environment variable.\n    If set to the full path of the libplumedKernel.so library, plumed will be available.\n    If unset, or if set to a wrong file, plumed will not be available.\n- The difference between (A) and (B) is that in case (B) if you recompile plumed and rerun MD your code\n  is automatically up to date.\n  The difference between (B) and (C) is that in case (C) the MD code is able to run also if plumed is\n  not available. This allows to have a single compiled MD code for both plumed users and others.\n  Moreover, in case (C) it is trivial to change plumed version at execution time, by properly setting\n  the PLUMED_KERNEL environment variable.\n  Notice that in (B) case the full path of the plumed library is recorded, thus it should not\n  be changed after patching, and it should be reachable from computing nodes.\n  All these task can be done automatically with \"plumed patch\" using respectively the flags:\n  - (A) --static\n  - (B) --shared\n  - (C) --runtime\n   \nextensions/ \n   Plumed extensions (e.g. contributed collective variables, ...)\n   They are compiled into a libplumedExtensions.so file which can be loaded at runtime.\n   To load them, use LOAD command inside plumed.dat\n\ntest/link/\n   A few simple executables to test compilation/linking\n   Executables are:\n-  (A) XXX-static statically linked with src/*.o (except src/Plumed.o)\n-  (B) XXX        dynamically linked with libplumed.so\n-  (C) XXX-dummy  statically linked with src/Plumed.o\n\nuser-doc/\n   User documentation\n\ndeveloper-doc/\n   Developer documentation\n\n\\section Notes Notes\n\nInformation about C++\nhttp://www.parashift.com/c++-faq-lite/\n\nCompiler options to use shared libraries on many architectures:\nhttp://www.fortran-2000.com/ArnaudRecipes/sharedlib.html\n\n\\page HowToAddACollectiveVariable How to add a collective variable\n\n\\page HowToAddAFunction How to add a function\n\n\\page HowToAddABias How to add a biasing potential\n\n\n*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/python/plumed.pyx": "#/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#   Copyright (c) 2011-2016 The plumed team\n#   (see the PEOPLE file at the root of the distribution for a list of names)\n#\n#   See http://www.plumed.org for more information.\n#\n#   This file is part of plumed, version 2.\n#\n#   plumed is free software: you can redistribute it and/or modify\n#   it under the terms of the GNU Lesser General Public License as published by\n#   the Free Software Foundation, either version 3 of the License, or\n#   (at your option) any later version.\n#\n#   plumed is distributed in the hope that it will be useful,\n#   but WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#   GNU Lesser General Public License for more details.\n#\n#   You should have received a copy of the GNU Lesser General Public License\n#   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#\n# This is a cython wrapper for the main parts of the PLUMED interface - the constructor and cmd\n# The main purpose of this is to convert the python types to C types that PLUMED understands\n#\n\n# cython: binding=True\n\ncimport cplumed  # This imports information from pxd file - including contents of this file here causes name clashes\n\nfrom cpython cimport array\nimport array\nimport re\nimport gzip\nimport math\nimport sys\nimport warnings\n\nif sys.version_info < (3,):\n    raise ImportError(\"PLUMED 2.6 only supports Python 3\")\n\ntry:\n     import numpy as np\n     HAS_NUMPY=True\nexcept ImportError:\n     HAS_NUMPY=False\n\ncdef class Plumed:\n     cdef cplumed.Plumed c_plumed\n     def __cinit__(self,kernel=None):\n         cdef bytes py_kernel\n         cdef char* ckernel\n         if kernel is None:\n            self.c_plumed=cplumed.Plumed.makeValid()\n            if not self.c_plumed.valid():\n                 raise RuntimeError(\"PLUMED not available, check your PLUMED_KERNEL environment variable\")\n         else:\n            py_kernel= kernel.encode()\n            ckernel = py_kernel\n            self.c_plumed=cplumed.Plumed.dlopen(ckernel)\n            if not self.c_plumed.valid():\n                 raise RuntimeError(\"Error loading PLUMED kernel at path \" + kernel)\n         cdef int pres = 8\n         self.c_plumed.cmd( \"setRealPrecision\", <void*>&pres )\n     def finalize(self):\n         \"\"\" Explicitly finalize a Plumed object.\n\n             Can be used in cases where one wants to make sure the Plumed object is finalized\n             (so that all output files are flushed and all calculations are finalized) but there is\n             a dangling reference to that Plumed object. Notice that after this call the self object\n             will be invalid so that using cmd will raise an exception.\n\n             It is also called by __exit__ in order to allow the following usage:\n             ````\n             with plumed.Plumed() as p:\n                 p.cmd(\"init\")\n                 # ETC\n\n             # p object will be finalized when exiting from this context\n             ````\n         \"\"\"\n         self.c_plumed=cplumed.Plumed()\n     def __enter__(self):\n         return self\n     def __exit__(self, type, value, traceback):\n        self.finalize()\n     def cmd_ndarray_real(self, ckey, val):\n         cdef double [:] abuffer = val.ravel()\n         self.c_plumed.cmd( ckey, <void*>&abuffer[0])\n     def cmd_ndarray_int(self, ckey, val):\n         cdef long [:] abuffer = val.ravel()\n         self.c_plumed.cmd( ckey, <void*>&abuffer[0])\n     cdef cmd_float(self, ckey, double val ):\n         self.c_plumed.cmd( ckey, <void*>&val )\n     cdef cmd_int(self, ckey, int val):\n         self.c_plumed.cmd( ckey, <void*>&val)\n     def cmd( self, key, val=None ):\n         cdef bytes py_bytes = key.encode()\n         cdef char* ckey = py_bytes\n         cdef char* cval\n         cdef array.array ar\n         if val is None :\n            self.c_plumed.cmd( ckey, NULL )\n         elif isinstance(val, (int,long) ):\n            if key==\"getDataRank\" :\n               raise ValueError(\"when using cmd with getDataRank option value must a size one ndarray\")\n            self.cmd_int(ckey, val)\n         elif isinstance(val, float ) :\n            if key==\"getBias\" :\n               raise ValueError(\"when using cmd with getBias option value must be a size one ndarray\")\n            self.cmd_float(ckey, val)\n         elif HAS_NUMPY and isinstance(val, np.ndarray) :\n            if( val.dtype==\"float64\" ):\n               self.cmd_ndarray_real(ckey, val)\n            elif( val.dtype==\"int64\" ) :\n               self.cmd_ndarray_int(ckey, val)\n            else :\n               raise ValueError(\"ndarrys should be float64 or int64\")\n         elif isinstance(val, array.array) :\n            if( (val.typecode==\"d\" or val.typecode==\"f\") and val.itemsize==8):\n               ar = val\n               self.c_plumed.cmd( ckey, <void*> ar.data.as_voidptr)\n            elif( (val.typecode==\"i\" or val.typecode==\"I\") ) :\n               ar = val\n               self.c_plumed.cmd( ckey, <void*> ar.data.as_voidptr)\n            else :\n               raise ValueError(\"ndarrays should be double (size=8) or int\")\n         elif isinstance(val, str ) :\n              py_bytes = val.encode()\n              cval = py_bytes\n              self.c_plumed.cmd( ckey, <void*>cval )\n         else :\n            raise ValueError(\"Unknown value type ({})\".format(str(type(val))))\n\n\nclass FormatError(Exception):\n    \"\"\"Custom error reported by read_as_pandas.\n    \"\"\"\n    pass\n\ndef _fix_file(file,mode):\n    \"\"\"Internal utility: returns a file open with mode.\n\n       Takes care of opening file (if it receives a string)\n       and or unzipping (if the file has \".gz\" suffix).\n    \"\"\"\n# allow passing a string\n    if isinstance(file,str):\n        file=open(file,mode)\n# takes care of gzipped files\n    if re.match(\".*\\.gz\",file.name):\n        file = gzip.open(file.name,mode)\n    return file\n\ndef _build_convert_function(kernel=None):\n    \"\"\"Internal utility: returns a function that can be used for conversions.\n\n       kernel : Plumed instance or str\n           The object used to perform conversion.\n           Pass a string to load a Plumed() instance giving the\n           path to the libplumedKernel library, or pass None\n           to load the default Plumed() instance.\n\n       In case of failure, it writes a warning and returns None.\n\n       Notice that this function will store a reference to the passed Plumed() object,\n       thus potentially increasing its lifetime.\n    \"\"\"\n    try:\n# if necessary, load a kernel\n        if not isinstance(kernel,Plumed):\n            kernel=Plumed(kernel=kernel)\n    except Exception:\n        warnings.warn(\"cannot load PLUMED instance, conversions will not be available\")\n        return None\n    try:\n# define a function to convert data\n        def convert_func(a):\n            r=array.array('d',[float('nan')])\n            convert_func.kernel.cmd(\"convert \"+str(a),r)\n            if math.isnan(r[0]):\n               return a\n            return r[0];\n        convert_func.kernel=kernel\n# check if convert_func is working correctly\n        if (convert_func(\"pi\")==\"pi\"):\n            warnings.warn(\"PLUMED instance seems to have a non-working convert cmd, conversions do not work and will be disabled\")\n            return None\n# set convert\n        return convert_func\n    except Exception:\n        warnings.warn(\"PLUMED instance is too old, conversions do not work and will be disabled\")\n        return None\n\nclass Constants(list):\n   \"\"\"Custom class used to store plumed constants.\n   \"\"\"\n   def __init__(self,l,kernel=None,convert=None):\n       if(isinstance(l,dict)):\n           for k in l:\n              self.append((k,l[k]))\n       else:\n           self.extend(l)\n       for i in range(len(self)):\n           if(len(self[i])==2):\n               if not convert:\n                   convert=_build_convert_function(kernel)\n               if convert:\n                   self[i]=(self[i][0],convert(self[i][1]),str(self[i][1]))\n               else:\n                   self[i]=(self[i][0],self[i][1],str(self[i][1]))\n           elif(len(self[i])==3):\n               pass\n           else:\n               raise ValueError(\"plumed.Constants should be initialized with a list of 2- or 3-plets\")\n\ndef read_as_pandas(file_or_path,enable_constants=True,enable_conversion=True,kernel=None,chunksize=None,usecols=None,skiprows=None,nrows=None):\n    \"\"\"Import a plumed data file as a pandas dataset.\n\n       file_or_path : str or file\n           Either string containing the path of the file or an already opened file object.\n\n       enable_constants : str or boolean, optional (default is True)\n           If 'columns', constants are read and added as constant columns.\n           If 'metadata' or True, constants are read and stored as metadata.\n           If 'no' or False, constants are not read at all.\n       enable_conversion : str or boolean, optional (default is True)\n           If 'constant' or True, only constants are converted.\n           If 'all', all data are converted. Might be slow and probably useless.\n           If 'no' or False, no data are converted.\n       kernel : str or Plumed, optional\n           The Plumed kernel used for conversions. If a string, it is interpreted\n           as the path to a kernel. If None, the default Plumed loading procedure is used\n           (with PLUMED_KERNEL env val). If an existing Plumed object, a pointer is stored\n           and this object is used for conversion.\n\n       chunksize : int, optional\n           Return an iterable object. Useful to process large files in chunks.\n       usecols : list-like or callable, optional\n           Directly passed to pandas.\n       skiprows : list-like, int or callable, optional\n           Directly passed to pandas.\n       nrows : int, optional\n           Directly passed to pandas.\n\n       Returns\n       -------\n       By default, it returns a special subclass of pandas.DataFrame that includes\n       metadata with constant values in an attribute named `plumed_constants`.\n       If using `enable_constants='no'` or `enable_constants='columns'`,\n       it returns a plain pandas.DataFrame.\n\n       If `chunksize` is provided, it returns a special subclass of pandas.io.parsers.TextFileReader\n       that can be iterated in order to read a file in chunks. Every iteration returns an object\n       equivalent to the one that would have been returned with a call to\n       read_pandas with chunksize=None (that is: either a pandas.DataFrame\n       or a subclass of it).\n\n       Comments\n       --------\n\n       Gzipped files are supported and automatically detected when a file name ends with '.gz'.\n\n       `pandas` module is imported the first time this function is used. Since importing `pandas` is quite slow,\n       the first call to this function will be significantly slower than the following ones.\n       Following calls should be faster. The overall speed is comparable or better to loading with `numpy.loadtxt`.\n\n       Examples\n       --------\n\n       colvar=plumed.read_as_pandas(\"COLVAR\")\n       print(colvar) # show the datasheet\n       print(colvar.plumed_constants) # show the constant columns\n\n       colvar=plumed.read_as_pandas(\"COLVAR\",usecols=[0,4])\n       print(colvar) # show the datasheet\n       print(colvar.plumed_constants) # show the constant columns\n\n       colvar=plumed.read_as_pandas(\"COLVAR\",usecols=[\"time\",\"distance\"])\n       print(colvar) # show the datasheet\n       print(colvar.plumed_constants) # show the constant columns\n\n       colvar=plumed.read_as_pandas(\"COLVAR\",enable_constants='columns')\n       print(colvar) # this dataframe will contain extra columns with the constants\n\n       for chunk in plumed.read_as_pandas(\"COLVAR\",chunksize=10):\n           print(chunk) # show the datasheet. actually here you should process the chunk\n           print(chunk.plumed_constants) # show the constant columns\n\n       Limitations\n       -----------\n\n       Only the initial header is read, which implies that files resulting from concatenating\n       datasets with a different number of columns or different column names will not\n       be read correctly and that only constants set at the beginning of the file will be considered.\n\n       This issues might be solved using `PLMD::IFile` for reading,\n       which could be useful but possibly a bit complicated to implement.\n    \"\"\"\n\n# importing pandas is pretty slow, so we only do it when needed\n    import pandas as pd\n\n# special classes used to attach metadata\n# they are defined inside this function since they need pandas to be imported\n# see https://pandas.pydata.org/pandas-docs/stable/development/extending.html\n    class PlumedSeries(pd.Series):\n        @property\n        def _constructor(self):\n            return PlumedSeries\n        @property\n        def _constructor_expanddim(self):\n            return PlumedDataFrame\n\n    class PlumedDataFrame(pd.DataFrame):\n        _metadata=[\"plumed_constants\"]\n        @property\n        def _constructor(self):\n            return PlumedDataFrame\n        @property\n        def _constructor_sliced(self):\n            return PlumedSeries\n\n# auxiliary function to process a dataframe\n# it is defined here since it requires PlumedDataFrame to be defined\n    def process_dataframe(df,enable_constants,constants,convert_all):\n        if convert_all: df=df.applymap(convert_all)\n        if enable_constants=='columns':\n            for c in constants: df[c[0]]=c[1]\n        if enable_constants=='metadata':\n            df=PlumedDataFrame(df)\n            df.plumed_constants=Constants(constants)\n        return df\n\n# process arguments:\n    if enable_conversion is True:\n       enable_conversion='constants'\n    if enable_conversion is False:\n       enable_conversion='no'\n    if enable_constants is True:\n       enable_constants='metadata'\n    if enable_constants is False:\n       enable_constants='no'\n\n# check arguments:\n    if not (enable_conversion=='no' or enable_conversion=='constants' or enable_conversion=='all'):\n        raise ValueError(\"enable_conversion not valid\")\n    if not (enable_constants=='no' or enable_constants=='metadata' or enable_constants=='columns'):\n        raise ValueError(\"enable_conversion not valid\")\n\n# conversions functions:\n    convert=None\n    convert_all=None\n# only create them if needed\n    if (enable_conversion=='constants' and enable_constants) or enable_conversion=='all':\n        convert=_build_convert_function(kernel)\n# if necessary, set convert_all\n        if enable_conversion=='all': convert_all=convert\n         \n# handle file\n    file_or_path=_fix_file(file_or_path,'rt')\n\n# read first line\n    line = file_or_path.readline()\n    columns = line.split()\n\n# check header\n    if len(columns)<2:\n        raise FormatError(\"Error reading PLUMED file \"+file_or_path.name + \". Not enough columns\")\n    if columns[0] != \"#!\" or columns[1] != \"FIELDS\":\n        raise FormatError(\"Error reading PLUMED file\" +file_or_path.name + \". Columns: \"+columns[0]+\" \"+columns[1])\n\n# read column names\n    columns = columns[2:]\n\n# read constants\n    constants=[]\n    if enable_constants!='no':\n        while True:\n            pos=file_or_path.tell()\n            line = file_or_path.readline()\n            file_or_path.seek(pos)\n            if not line:\n                break\n            sets = line.split()\n            if len(sets) < 4:\n                break\n            if sets[0]!=\"#!\" or sets[1]!=\"SET\":\n                break\n            if(convert):\n                v=convert(sets[3])\n            else:\n                v=sets[3]\n# name / value / string\n            constants.append((sets[2],v,sets[3]))\n            file_or_path.readline() # read again to go to next line\n\n# read the rest of the file\n# notice that if chunksize was provided the result will be an iterable object\n    df=pd.read_csv(file_or_path, delim_whitespace=True, comment=\"#\", header=None,names=columns,\n                    usecols=usecols,skiprows=skiprows,nrows=nrows,chunksize=chunksize)\n\n    if chunksize is None:\n# just perform conversions and attach constants to the dataframe\n        return process_dataframe(df,enable_constants,constants,convert_all)\n    else:\n# declare an alternate class that is iterable to read the file in chunks\n        class TextFileReader(type(df)):\n            \"\"\"Subclass of pandas.io.TestFileReader, needed for storing constants\"\"\"\n# some information (constant values and conversion function)\n# should be stored in the class to be used while iterating on it\n            def __init__(self,reader,enable_constants,constants,convert_all):\n                self.TextFileReader=reader\n                self.enable_constants=enable_constants\n                self.constants=constants\n                self.convert_all=convert_all\n            def __next__(self):\n# override __next__\n                df=self.TextFileReader.__next__()\n                return process_dataframe(df,self.enable_constants,self.constants,self.convert_all)\n        return TextFileReader(df,enable_constants,constants,convert_all)\n\ndef write_pandas(df,file_or_path=None):\n    \"\"\"Save a pandas dataframe as a PLUMED file.\n\n       df: pandas dataframe or derived class\n           the dataframe. If it contains a list attribute `plumed_constants`, this is\n           interpreted as a list of constants and written with `SET` lines.\n\n       file_or_path: str, file, or None (default is None)\n           path to the file to be written, or already opened file object.\n           If None, stdout is used.\n\n       Examples\n       --------\n\n       colvar=plumed.read_as_colvar(\"COLVAR\")\n       colvar[\"distance\"]=colvar[\"distance\"]*2\n       plumed.write_pandas(colvar)\n      \n    \"\"\"\n# importing pandas is pretty slow, so we only do it when needed\n    import pandas as pd\n# handle file\n    if file_or_path is None:\n        file_or_path=sys.stdout\n    file_or_path=_fix_file(file_or_path,'wt')\n# write header\n    file_or_path.write(\"#! FIELDS\")\n    for n in df.columns:\n        file_or_path.write(\" \"+str(n))\n    file_or_path.write(\"\\n\")\n# write constants\n    if hasattr(df,\"plumed_constants\") and isinstance(df.plumed_constants,Constants):\n        for c in df.plumed_constants:\n# notice that string constants are written (e.g. pi) rather than the numeric ones (e.g. 3.14...)\n            file_or_path.write(\"#! SET \"+c[0]+\" \"+c[2]+\"\\n\")\n# write data\n    for i in range(df.shape[0]):\n        for j in df.columns:\n            file_or_path.write(\" \"+str(df[j][i]))\n        file_or_path.write(\"\\n\")\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/python/cplumed.pxd": "#/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#   Copyright (c) 2011-2016 The plumed team\n#   (see the PEOPLE file at the root of the distribution for a list of names)\n#\n#   See http://www.plumed.org for more information.\n#\n#   This file is part of plumed, version 2.\n#\n#   plumed is free software: you can redistribute it and/or modify\n#   it under the terms of the GNU Lesser General Public License as published by\n#   the Free Software Foundation, either version 3 of the License, or\n#   (at your option) any later version.\n#\n#   plumed is distributed in the hope that it will be useful,\n#   but WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#   GNU Lesser General Public License for more details.\n#\n#   You should have received a copy of the GNU Lesser General Public License\n#   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#\n# This create cython wrappers to the main bits of the PLUMED libraray\n#\n\nfrom libcpp cimport bool\n\n# Some of these functions are noexcept.\n# We anyway use except + in case this changes later.\ncdef extern from \"Plumed.h\" namespace \"PLMD\":\n     cdef cppclass Plumed:\n         Plumed() except +\n         void cmd(const char*key, const void*val) except +\n         void cmd(const char*key) except +\n         bool valid() except +\n         @staticmethod\n         Plumed dlopen(const char*path) except +\n         @staticmethod\n         Plumed makeValid() except +\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/conda/plumed/meta.yaml": "{% set name = \"plumed\" %}\n{% set version = environ['VERSION'] %}\n\npackage:\n  name: {{ name|lower }}\n  version: {{ version }}\n\nsource:\n  path: ../..\n\nbuild:\n  number: 0\n  skip: True  # [win]\n# Most programs should link libplumedWrapper.a so that libplumedKernel.so will be loaded\n# with dlopen. There is no need for pinning thus.\n# Programs linking libplumed.so should pin to min_pin='x.x', max_pin='x'.\n# Programs linking libplumedKernel.so should pin to min_pin='x.x.x'. max_pin='x.x.x'.\n\nrequirements:\n  build:\n    - {{ compiler('c') }}\n    - {{ compiler('cxx') }}\n    - llvm-openmp  # [osx]\n    - make\n# xxd is provided by package vim and used during build\n    - vim  # [linux]\n  host:\n    - fftw\n    - gsl\n    - libblas\n    - liblapack\n    - llvm-openmp  # [osx]\n    - xdrfile\n    - zlib\n  run:\n    - gawk\n    - llvm-openmp  # [osx]\n\ntest:\n  commands:\n    - plumed info --root\n    - plumed info --long-version\n    - plumed-patch -h\n    - plumed config has external_blas external_lapack fftw gsl xdrfile zlib\n    - $PREFIX/lib/plumed/plumed-runtime -h\n    - test -f $PREFIX/lib/libplumed$SHLIB_EXT\n    - test -f $PREFIX/lib/libplumedWrapper.a\n    - test -f $PREFIX/lib/libplumedKernel$SHLIB_EXT\n    - conda inspect linkages -p $PREFIX $PKG_NAME\n    - conda inspect objects -p $PREFIX $PKG_NAME  # [osx]\n\nabout:\n  home: http://www.plumed.org/\n  license: LGPL-3.0\n  license_family: GPL\n  license_file: COPYING.LESSER\n  summary: 'Free energy calculations in molecular systems'\n  description: |\n    PLUMED is an open source library for free energy calculations in\n    molecular systems which works together with some of the most\n    popular molecular dynamics engines.\n  doc_url: https://www.plumed.org/doc\n  dev_url: https://github.com/plumed/plumed2\n\nextra:\n  recipe-maintainers:\n    - GiovanniBussi\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/src/molfile/periodic_table.h",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/ves/rt-VesDeltaF-mwalkers/alanine.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/ves/rt-VesDeltaF/alanine.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/isdb/rt-jcouplings-mi/trajectory.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/isdb/rt-caliber/trajout.2.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/isdb/rt-caliber/trajout.1.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/isdb/rt-caliber/trajout.3.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/isdb/rt-caliber/trajout.0.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/isdb/rt-saxs-mi/traj.0.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/isdb/rt-saxs-mi/traj.1.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/drr/rt-divergence/eabf2dpbc.drrstate",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/drr/rt-extract2dpbc/eabf2dpbc.drrstate",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/drr/rt-extract/test.drrstate",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/drr/rt-merge/eabf_win1.drrstate",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/drr/rt-merge/eabf_win2.drrstate",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/drr/rt-restart/bck.eabf.drrstate.0.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/drr/rt-restart/eabf.drrstate",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/analysis/rt-wham/alltraj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/trajectories/molfile_plugin/traj.dcd",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/trajectories/molfile_plugin/traj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/crystallization/rt-sean-marks/some_frames.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/pamm/rt-hbpamm/example-hbpamm.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt19-mpi/HH.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt19-mpi/HH.0.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt19-mpi/input_colvar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt19-mpi/COLVAR.res.1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt19-mpi/HH.1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt19-mpi/COLVAR.res.0.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-maxent-3/traj.4.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-maxent-3/traj.2.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-maxent-3/traj.0.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-maxent-3/traj.5.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-maxent-3/traj.1.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-maxent-3/traj.3.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-mpi7b/grid.0.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-mpi7b/gridx.0.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-acc-1/aladip.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-maxent-5/traj.2.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-maxent-5/traj.0.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-maxent-5/traj.1.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-xdrfile-1/test.xtc.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-xdrfile-1/test.trr.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-xdrfile-1/traj.trr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt77-mpi/trajectory.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-maxent-1/traj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-molfile-3/test.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt54-xdrfile/helix.ttt.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt54-xdrfile/helix.trr.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt54-xdrfile/helix.xtc.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt54-xdrfile/helix-pr.xtc.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt54-xdrfile/traj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt19/COLVAR.res.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt19/HH.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt19/COLVAR.nores.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt19/input_colvar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt19/bck.0.COLVAR.nores.gz.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-ermsd/traj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-ermsd2/traj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-maxent-4/traj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-maxent-2/traj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-xdrfile-2/traj.1.trr.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-xdrfile-2/traj.0.trr.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-xdrfile-2/test.1.trr.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-xdrfile-2/traj.0.trr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-xdrfile-2/test.1.xtc.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-xdrfile-2/traj.1.trr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-xdrfile-2/test.0.trr.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt-xdrfile-2/test.0.xtc.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/regtest/basic/rt77/trajectory.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/developer-doc/octocat.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/developer-doc/developer-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/developer-doc/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/developer-doc/pigeon.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/user-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/octocat.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/pigeon.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-kinetics_figure-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/trieste-2-block-averages.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-7-pt2fes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves_basisf-chebyshev.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-2-bad-matrix.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/lugano-3-hysteresis.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/munster-usrem-phi-all.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/lugano-5-gismo.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-kinetics_figure-1B.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-2-transition.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-7-pt2temp.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/lugano-6b-ffdp.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-kinetics_figure-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/trieste-2-mc-autocorrelation.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/cambridge-2-deltaG.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-ves1_fesEvolution1.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/lugano-6b-ffcn.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-2-ab-sz.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-ves2_2D-fes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/munster-metad-phifest.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/cambridge-chignolin.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-7-ptwteene.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-metad_NaCl.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/trieste-5-demux-good.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-2-ala.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-metad_biasEvolution.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-7-ptmetadhidd.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/lugano-6d-gb.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/trieste-4-block-phi.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-metad_reweightBoth.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/cambridge-2-cvs.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/trieste-6-gb.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/trieste-2-autocorrelation.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/lyon-histograms-lowT.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves_basisf-legendre.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-2-ab-sz-nowhere.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-2-metadpath.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/trieste-2-histogram-errors.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-7-pt.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-7-ptdemux.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-ves1_reweight.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-ves2_well-tempered.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-ves1_biasedDistrib.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/munster-metad-phihills.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/trieste-5-demux-bad.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-5-work-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-2-ab.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/munster-usrem-phi-fes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves_basisf-legendre-scaled.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-metad_fesEvolution.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-2-metadpath-free.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-6-wtb6.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/trieste-5-colvars.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-metad_barrier.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-2-good-matrix.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/trieste-6-bard1.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-ves1_targetDistrib.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-8-convergence.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/lugano-6b-ffdc.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-2-cdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-7-pt2demux.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-5-doublesteer.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/munster-metad-phi.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/lyon-lj7-minima.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/trieste-6-cmycurea.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-ves2_targetDistrib.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/munster-metad-phifes-difft.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-kinetics_figure-1A.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/trieste-2-confidence.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/munster-usrem-psi-demux.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-6-phialone.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-7-ptfes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-2-metadpath-correction.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/lugano-6b-ffcnUB.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/lyon-time-series.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/munster-ala-traj-metad.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-2-good-vs-bad.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/lugano-6b-ffdnUB.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-4-meta.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/cambridge-2-fes1d.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-ves1_coeffs1.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/lugano-4-lj7-errors.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-6-phifes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/lugano-6b-fes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-6-hidden.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/trieste-3-histo-dimer.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-7-ptalaw.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-5-jarz.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-6-difft.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-metad_reweightDist.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/trieste-3-wdimer.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-6-phifest.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/trieste-5-weights.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/marvel-2-pca-coordinates.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-2-rama.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-6-metad.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/munster-usrem-psi-fes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-kinetics_StoneWales.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-7-ptmetadh.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-2-good-bad-path.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-6-wtdifft.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-6-wtb15.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/munster-metad-psi-phi.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/munster-metad-phifes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-7-ptwtediff.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/belfast-8-mg1.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/lyon-histograms-highT.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-ves2_2D-coeffs.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/marvel-2-trans-state.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/ves-lugano2017-ves1_fes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/munster-ala-traj.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/figs/cambridge-2-fes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/performance-optimization/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-8/first/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-8/first/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-8/first/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-8/first/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-8/second/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-8/second/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-8/second/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-8/second/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/cambridge-2/TOPO/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/cambridge-2/TOPO/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/cambridge-2/TOPO/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/cambridge-2/TOPO/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/cambridge-2/first/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/cambridge-2/first/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/cambridge-2/first/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/cambridge-2/first/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/trieste-5/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/trieste-5/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/trieste-5/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/trieste-5/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/trieste-3/wdimer/dimer.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/trieste-3/aladip/aladip.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/trieste-4/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-4/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/cineca/SETUP/topolA.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/cineca/SETUP/topolB.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-7/Exercise_4/TOPO/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-7/Exercise_4/TOPO/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-7/Exercise_4/TOPO/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-7/Exercise_4/TOPO/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-7/Exercise_1/TOPO/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-7/Exercise_1/TOPO/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-7/Exercise_2/TOPO/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-7/Exercise_2/TOPO/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-7/Exercise_2/TOPO/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-7/Exercise_2/TOPO/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-7/Exercise_3/TOPO/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-7/Exercise_3/TOPO/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-7/Exercise_3/TOPO/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-7/Exercise_3/TOPO/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/cambridge-3/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/cambridge-3/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/cambridge-3/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/cambridge-3/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-6/TOPO/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-9a/system/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-9a/third/topol7.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-9a/third/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-9a/third/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-9a/third/topol6.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-9a/third/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-9a/third/topol4.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-9a/third/topol5.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-9a/third/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-9a/first/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-9a/second/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-9a/second/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-9a/second/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/belfast-9a/second/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/trieste-1/traj-broken.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/trieste-1/traj-whole.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/old_tutorials/cambridge-1/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/master-ISDD-2/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/lugano-6d/GB1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/marvel-2/PCA-isocommittor/traj_comp.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/marvel-2/PATH-isocommittor/traj_comp.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/marvel-2/2CV-isocommittor/traj_comp.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/lugano-2/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/munster/TOPO/topolBwat.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/munster/TOPO/topolA.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/munster/TOPO/topolAwat.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/munster/TOPO/topolB.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/lugano-3/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-2/TUTORIAL_SAXS-AACG/samplextc.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew7.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew9.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew8.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew6.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew4.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew5.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew13.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew10.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew12.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew11.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/reference-impl/run.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew7.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew9.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew8.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew6.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew4.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew5.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew13.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew10.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew12.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew11.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/python/test/COLVAR_gzipped.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/astyle/doc/news.html",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/test/gromacs/cs2back/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/test/gromacs/cs2back/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/test/gromacs/cs2back/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.6.1-4txrk6ukgv57ezqamvxdoy623gs2once/spack-src/test/gromacs/cs2back/topol1.tpr"
    ],
    "total_files": 5459
}