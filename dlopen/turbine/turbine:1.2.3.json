{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-turbine-1.2.3-soykdadoljcv4nwcro5l66brgc2snyep/spack-src/src/tcl/python/tcl-python.c": "/*\n * Copyright 2013 University of Chicago and Argonne National Laboratory\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\n/*\n * tcl-python.c\n *\n *  Created on: May 22, 2013\n *      Author: wozniak\n *\n *  Tcl extension calling into Python interpreter\n */\n\n#include \"config.h\"\n#ifdef HAVE_SYS_PARAM_H\n// Python will try to redefine this:\n#undef HAVE_SYS_PARAM_H\n#endif\n\n#if HAVE_PYTHON==1\n#include \"Python.h\"\n#endif\n\n#include <dlfcn.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <mpi.h>\n#include <tcl.h>\n\n#include \"src/util/debug.h\"\n#include \"src/tcl/util.h\"\n\n#include \"tcl-python.h\"\n\n#if HAVE_PYTHON==1\n\n/** @return A Tcl return code */\nstatic int\nhandle_python_exception(bool exceptions_are_errors)\n{\n  printf(\"\\n\");\n  printf(\"PYTHON EXCEPTION:\\n\");\n\n  #if PY_MAJOR_VERSION >= 3\n\n  PyObject *exc,*val,*tb;\n  PyErr_Fetch(&exc,&val,&tb);\n  PyObject_Print(exc, stdout, Py_PRINT_RAW);\n  printf(\"\\n\");\n  PyObject_Print(val, stdout, Py_PRINT_RAW);\n  printf(\"\\n\");\n\n  #else // Python 2\n\n  PyErr_Print();\n\n  #endif\n\n  if (exceptions_are_errors)\n    return TCL_ERROR;\n  return TCL_OK;\n}\n\nstatic int\nhandle_python_non_string(PyObject* o)\n{\n  printf(\"python: expression did not return a string!\\n\");\n  fflush(stdout);\n  printf(\"python: expression evaluated to: \");\n  PyObject_Print(o, stdout, 0);\n  return TCL_ERROR;\n}\n\nstatic PyObject* main_module = NULL;\nstatic PyObject* main_dict   = NULL;\nstatic PyObject* local_dict  = NULL;\n\nstatic bool initialized = false;\n\nstatic int\npython_init(void)\n{\n/* Loading python library symbols so that dynamic extensions don't throw symbol not found error.\n           Ref Link: http://stackoverflow.com/questions/29880931/importerror-and-pyexc-systemerror-while-embedding-python-script-within-c-for-pam\n        */\n  char str_python_lib[32];\n#ifdef _WIN32\n  sprintf(str_python_lib, \"lib%s.dll\", PYTHON_NAME);\n#elif defined __unix__\n  sprintf(str_python_lib, \"lib%s.so\", PYTHON_NAME);\n#elif defined __APPLE__\n  sprintf(str_python_lib, \"lib%s.dylib\", PYTHON_NAME);\n#endif\n  dlopen(str_python_lib, RTLD_NOW | RTLD_GLOBAL);\n\n  if (initialized) return TCL_OK;\n  DEBUG_TCL_TURBINE(\"python: initializing...\");\n  Py_InitializeEx(1);\n  main_module  = PyImport_AddModule(\"__main__\");\n  if (main_module == NULL) return handle_python_exception(true);\n  main_dict = PyModule_GetDict(main_module);\n  if (main_dict == NULL) return handle_python_exception(true);\n  local_dict = PyDict_New();\n  if (local_dict == NULL) return handle_python_exception(true);\n  initialized = true;\n  return TCL_OK;\n}\n\nstatic void python_finalize(void);\n\nstatic char* python_result_default   = \"__NOTHING__\";\nstatic char* python_result_exception = \"__EXCEPTION__\";\n\n#define EXCEPTION(ee)                           \\\n  {                                             \\\n    *result = python_result_exception;          \\\n    return handle_python_exception(ee);         \\\n  }\n\n/**\n   @param persist: If true, retain the Python interpreter,\n                   else finalize it\n   @param exceptions_are_errors: If true, abort on Python exception\n   @param code: The multiline string of Python code.\n   @param expr: A Python expression to be evaluated to the returned result\n   @param result: Store result pointer here\n   @return Tcl return code\n */\nstatic int\npython_eval(bool persist, bool exceptions_are_errors,\n            const char* code, const char* expr, char** result)\n{\n  int rc;\n  char* s = python_result_default;\n\n  // Initialize:\n  rc = python_init();\n  TCL_CHECK(rc);\n\n  // Execute code:\n  DEBUG_TCL_TURBINE(\"python: code: %s\", code);\n  PyRun_String(code, Py_file_input, main_dict, local_dict);\n  if (PyErr_Occurred()) EXCEPTION(exceptions_are_errors);\n\n  // Evaluate expression:\n  DEBUG_TCL_TURBINE(\"python: expr: %s\", expr);\n  PyObject* o = PyRun_String(expr, Py_eval_input,\n                             main_dict, local_dict);\n  if (o == NULL) EXCEPTION(exceptions_are_errors);\n\n  // Convert Python result to C string\n  rc = PyArg_Parse(o, \"s\", &s);\n  if (rc != 1) return handle_python_non_string(o);\n  DEBUG_TCL_TURBINE(\"python: result: %s\\n\", s);\n  *result = strdup(s);\n\n  // Clean up and return:\n  Py_DECREF(o);\n  if (!persist) python_finalize();\n  return TCL_OK;\n}\n\nstatic void\npython_finalize(void)\n{\n  Py_Finalize();\n  initialized = false;\n}\n\nstatic int\nPython_Eval_Cmd(ClientData cdata, Tcl_Interp *interp,\n                int objc, Tcl_Obj *const objv[])\n{\n  TCL_ARGS(5);\n  int rc;\n  int persist;\n  int exceptions_are_errors;\n  rc = Tcl_GetBooleanFromObj(interp, objv[1], &persist);\n  TCL_CHECK_MSG(rc, \"python: argument persist should be integer!\");\n  rc = Tcl_GetBooleanFromObj(interp, objv[2], &exceptions_are_errors);\n  TCL_CHECK_MSG(rc,\n                \"python: argument exceptions_are_errors should be integer!\");\n  char* code = Tcl_GetString(objv[3]);\n  char* expr = Tcl_GetString(objv[4]);\n  char* output = NULL;\n  rc = python_eval(persist, exceptions_are_errors,\n                   code, expr, &output);\n  TCL_CHECK(rc);\n  Tcl_Obj* result = Tcl_NewStringObj(output, -1);\n  Tcl_SetObjResult(interp, result);\n  free(output);\n  return TCL_OK;\n}\n\nchar*\npython_parallel_persist(MPI_Comm comm, char* code, char* expr)\n{\n  int task_rank, task_size;\n  MPI_Comm_rank(comm, &task_rank);\n  MPI_Comm_size(comm, &task_size);\n  printf(\"In ppp(): rank: %i/%i\\n\", task_rank, task_size);\n  printf(\"code: %s\\n\", code);\n  printf(\"expr: %s\\n\", expr);\n\n  long long int task_comm_int = (long long int) comm;\n  char task_comm_string[64];\n  sprintf(task_comm_string, \"%lli\", task_comm_int);\n  setenv(\"task_comm\", task_comm_string, true);\n\n  int rc;\n  rc = python_init();\n  assert(rc == TCL_OK);\n\n  char* output;\n  rc = python_eval(true, true, code, expr, &output);\n  if (rc != TCL_OK)\n  {\n    printf(\"python parallel task failed!\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  printf(\"eval ok.\\n\");   fflush(stdout);\n\n  MPI_Comm_free(&comm);\n  if (task_rank == 0)\n    return output;\n  free(output);\n  return NULL;\n}\n\n\n#else // Python disabled\n\nstatic int\nPython_Eval_Cmd(ClientData cdata, Tcl_Interp *interp,\n                int objc, Tcl_Obj *const objv[])\n{\n  return turbine_user_errorv(interp,\n                     \"Turbine not compiled with Python support\");\n}\n\nchar*\npython_parallel_persist(MPI_Comm comm, char* code, char* expr)\n{\n  int task_rank, task_size;\n  MPI_Comm_rank(comm, &task_rank);\n  MPI_Comm_size(comm, &task_size);\n  printf(\"python_parallel_persist: \"\n         \"Turbine not compiled with Python support\");\n  if (task_rank == 0)\n    return strdup(\"__ERROR__\");\n  return NULL;\n}\n\n#endif\n\n\n/**\n   Called when Tcl loads this extension\n */\nint\nTclpython_Init(Tcl_Interp *interp)\n{\n  if (Tcl_InitStubs(interp, TCL_VERSION, 0) == NULL)\n    return TCL_ERROR;\n\n  if (Tcl_PkgProvide(interp, \"python\", \"0.1\") == TCL_ERROR)\n    return TCL_ERROR;\n\n  return TCL_OK;\n}\n\n/**\n   Shorten object creation lines.  python:: namespace is prepended\n */\n#define COMMAND(tcl_function, c_function) \\\n    Tcl_CreateObjCommand(interp, \"python::\" tcl_function, c_function, \\\n                         NULL, NULL);\n\nvoid\ntcl_python_init(Tcl_Interp* interp)\n{\n  COMMAND(\"eval\", Python_Eval_Cmd);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-turbine-1.2.3-soykdadoljcv4nwcro5l66brgc2snyep/spack-src/export/python.swift": "/*\n * Copyright 2013 University of Chicago and Argonne National Laboratory\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\n/**\n   To use Python compiled packages, you may have to modify Tcl\n   to use dlopen(..., RTLD_NOW | RTLD_GLOBAL)\n   Cf. http://stackoverflow.com/questions/8302810/undefined-symbol-in-c-when-loading-a-python-shared-library\n*/\n\n@dispatch=WORKER\n(string output) python(string code, string expr=\"\\\"\\\"\",\n                       boolean exceptions_are_errors=true)\n\"turbine\" \"0.1.0\"\n[ \"set <<output>> [ turbine::python 0 <<exceptions_are_errors>> <<code>> <<expr>>  ]\" ];\n\n@dispatch=WORKER\n(string output) python_persist(string code, string expr=\"\\\"\\\"\",\n                               boolean exceptions_are_errors=true)\n\"turbine\" \"0.1.0\"\n[ \"set <<output>> [ turbine::python 1 <<exceptions_are_errors>> <<code>> <<expr>> ]\" ];\n\n\n@par @dispatch=WORKER (string s)\npython_parallel_persist(string code, string expr)\n\"turbine\" \"1.0\" \"python_parallel_tcl\" ;\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-turbine-1.2.3-soykdadoljcv4nwcro5l66brgc2snyep/spack-src/tests/staticapp-bundled-1.2.data"
    ],
    "total_files": 438
}