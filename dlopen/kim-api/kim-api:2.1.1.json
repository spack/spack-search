{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.1.1-vkisw7kaqtde6u5frqgxmhp737qhl4xb/spack-src/utils/shared-library-test.cpp": "//\n// CDDL HEADER START\n//\n// The contents of this file are subject to the terms of the Common Development\n// and Distribution License Version 1.0 (the \"License\").\n//\n// You can obtain a copy of the license at\n// http://www.opensource.org/licenses/CDDL-1.0.  See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// When distributing Covered Code, include this CDDL HEADER in each file and\n// include the License file in a prominent location with the name LICENSE.CDDL.\n// If applicable, add the following below this CDDL HEADER, with the fields\n// enclosed by brackets \"[]\" replaced with your own identifying information:\n//\n// Portions Copyright (c) [yyyy] [name of copyright owner]. All rights reserved.\n//\n// CDDL HEADER END\n//\n\n//\n// Copyright (c) 2013--2019, Regents of the University of Minnesota.\n// All rights reserved.\n//\n// Contributors:\n//    Ryan S. Elliott\n//\n\n//\n// Release: This file is part of the kim-api-2.1.1 package.\n//\n\n#include \"KIM_Version.hpp\"\n#include <dlfcn.h>\n#include <iostream>\n#include <string>\n\nvoid usage(std::string name)\n{\n  size_t beg = name.find_last_of(\"/\");\n  if (beg != std::string::npos) name = name.substr(beg + 1, std::string::npos);\n\n  // Follows docopt.org format\n  std::cerr << \"Usage:\\n\"\n            << \"  \" << name << \" <shared-library-name>\\n\"\n            << \"  \" << name << \" --version\" << std::endl;\n  // note: this interface is likely to change in future kim-api releases\n}\n\nint IsFilePath(std::string const & filePath)\n{\n  // not very comperhensive but can be improved as needed\n  if (filePath.length() == 0) return false;\n  return true;\n}\n\nint main(int argc, char * argv[])\n{\n  if (argc != 2)\n  {\n    usage(argv[0]);\n    return 1;\n  }\n  else if (std::string(argv[1]) == \"--version\")\n  {\n    std::cout << KIM_VERSION_STRING << std::endl;\n    return 0;\n  }\n  else\n  {\n    std::string libFilePath(argv[1]);\n    if (!IsFilePath(libFilePath))  // validate lib path\n    {\n      std::cout << \"Invalid <shared-library-name>.\\n\" << std::endl;\n      return 2;\n    }\n\n    void * sharedLibraryHandle = dlopen(libFilePath.c_str(), RTLD_NOW);\n    if (sharedLibraryHandle == NULL)\n    {\n      std::cout << \"Unable to open shared library.\\n\" << dlerror() << std::endl;\n      return 3;\n    }\n    else\n    {\n      std::cout << \"Successfully opened shared library.\" << std::endl;\n      dlclose(sharedLibraryHandle);\n      return 0;\n    }\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.1.1-vkisw7kaqtde6u5frqgxmhp737qhl4xb/spack-src/cpp/src/KIM_SharedLibrary.cpp": "//\n// CDDL HEADER START\n//\n// The contents of this file are subject to the terms of the Common Development\n// and Distribution License Version 1.0 (the \"License\").\n//\n// You can obtain a copy of the license at\n// http://www.opensource.org/licenses/CDDL-1.0.  See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// When distributing Covered Code, include this CDDL HEADER in each file and\n// include the License file in a prominent location with the name LICENSE.CDDL.\n// If applicable, add the following below this CDDL HEADER, with the fields\n// enclosed by brackets \"[]\" replaced with your own identifying information:\n//\n// Portions Copyright (c) [yyyy] [name of copyright owner]. All rights reserved.\n//\n// CDDL HEADER END\n//\n\n//\n// Copyright (c) 2016--2019, Regents of the University of Minnesota.\n// All rights reserved.\n//\n// Contributors:\n//    Ryan S. Elliott\n//\n\n//\n// Release: This file is part of the kim-api-2.1.1 package.\n//\n\n#include <cstring>\n#include <dlfcn.h>\n#include <sstream>\n\n#ifndef KIM_SHARED_LIBRARY_HPP_\n#include \"KIM_SharedLibrary.hpp\"\n#endif\n\n#ifndef KIM_LOG_VERBOSITY_HPP_\n#include \"KIM_LogVerbosity.hpp\"\n#endif\n\n#ifndef KIM_LANGUAGE_NAME_HPP_\n#include \"KIM_LanguageName.hpp\"\n#endif\n\n#ifndef KIM_SHARED_LIBRARY_SCHEMA_HPP_\n#include \"KIM_SharedLibrarySchema.hpp\"\n#endif\n\nnamespace KIM\n{\n// log helpers\n#define SNUM(x)                                                \\\n  static_cast<std::ostringstream const &>(std::ostringstream() \\\n                                          << std::dec << x)    \\\n      .str()\n#define SPTR(x)                                                            \\\n  static_cast<std::ostringstream const &>(std::ostringstream()             \\\n                                          << static_cast<void const *>(x)) \\\n      .str()\n#define SFUNCP(x)                                                         \\\n  static_cast<std::ostringstream const &>(std::ostringstream()            \\\n                                          << static_cast<Function **>(x)) \\\n      .str()\n\n#include \"KIM_LogMacros.hpp\"\n#define KIM_LOGGER_OBJECT_NAME this\nSharedLibrary::SharedLibrary(Log * const log) :\n    sharedLibraryHandle_(NULL),\n    sharedLibrarySchemaVersion_(NULL),\n    itemName_(\"\"),\n    createRoutine_(NULL),\n    numberOfParameterFiles_(0),\n    numberOfMetadataFiles_(0),\n    log_(log)\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"SharedLibrary(\" + SPTR(log) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  LOG_DEBUG(\"Exit   \" + callString);\n}\n\nSharedLibrary::~SharedLibrary()\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"~SharedLibrary().\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  Close();\n\n  LOG_DEBUG(\"Exit   \" + callString);\n}\n\nint SharedLibrary::Open(std::string const & sharedLibraryName)\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"Open('\" + sharedLibraryName + \"').\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ != NULL)\n  {\n    LOG_ERROR(\"\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // already open\n  }\n\n  sharedLibraryName_ = sharedLibraryName;\n  sharedLibraryHandle_ = dlopen(sharedLibraryName_.c_str(), RTLD_NOW);\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Unable to open '\" + sharedLibraryName_ + \"'.\");\n    LOG_ERROR(dlerror());\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n  sharedLibrarySchemaVersion_ = reinterpret_cast<int const *>(\n      dlsym(sharedLibraryHandle_, \"kim_shared_library_schema_version\"));\n  if (sharedLibrarySchemaVersion_ == NULL)\n  {\n    LOG_ERROR(dlerror());\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n\n  if (*sharedLibrarySchemaVersion_ == 2)\n  {\n    using namespace SHARED_LIBRARY_SCHEMA;\n    SharedLibrarySchemaV2 const * const schemaV2\n        = reinterpret_cast<SharedLibrarySchemaV2 const *>(\n            dlsym(sharedLibraryHandle_, \"kim_shared_library_schema\"));\n    if (schemaV2 == NULL)\n    {\n      LOG_ERROR(dlerror());\n      LOG_DEBUG(\"Exit 1=\" + callString);\n      return true;\n    }\n\n    itemType_ = schemaV2->itemType;\n    createLanguageName_ = schemaV2->createLanguageName;\n    createRoutine_ = schemaV2->createRoutine;\n    driverName_ = ((schemaV2->driverName) ? schemaV2->driverName : \"\");\n\n    if (schemaV2->simulatorModelSpecificationFile)\n    {\n      simulatorModelSpecificationFile_.fileName\n          = schemaV2->simulatorModelSpecificationFile->fileName;\n      simulatorModelSpecificationFile_.fileLength\n          = schemaV2->simulatorModelSpecificationFile->fileLength;\n      simulatorModelSpecificationFile_.filePointer\n          = schemaV2->simulatorModelSpecificationFile->filePointer;\n    }\n\n    numberOfParameterFiles_ = schemaV2->numberOfParameterFiles;\n    for (int i = 0; i < numberOfParameterFiles_; ++i)\n    {\n      EmbeddedFile fl;\n      fl.fileName = schemaV2->parameterFiles[i].fileName;\n      fl.fileLength = schemaV2->parameterFiles[i].fileLength;\n      fl.filePointer = schemaV2->parameterFiles[i].filePointer;\n\n      parameterFiles_.push_back(fl);\n    }\n    numberOfMetadataFiles_ = schemaV2->numberOfMetadataFiles;\n    for (int i = 0; i < numberOfMetadataFiles_; ++i)\n    {\n      EmbeddedFile fl;\n      fl.fileName = schemaV2->metadataFiles[i].fileName;\n      fl.fileLength = schemaV2->metadataFiles[i].fileLength;\n      fl.filePointer = schemaV2->metadataFiles[i].filePointer;\n\n      metadataFiles_.push_back(fl);\n    }\n  }\n  else if (*sharedLibrarySchemaVersion_ == 1)\n  {\n    using namespace SHARED_LIBRARY_SCHEMA;\n    SharedLibrarySchemaV1 const * const schemaV1\n        = reinterpret_cast<SharedLibrarySchemaV1 const *>(\n            dlsym(sharedLibraryHandle_, \"kim_shared_library_schema\"));\n    if (schemaV1 == NULL)\n    {\n      LOG_ERROR(dlerror());\n      LOG_DEBUG(\"Exit 1=\" + callString);\n      return true;\n    }\n\n    if (schemaV1->itemType == SharedLibrarySchemaV1::STAND_ALONE_MODEL)\n    { itemType_ = COLLECTION_ITEM_TYPE::portableModel; }\n    else if (schemaV1->itemType == SharedLibrarySchemaV1::PARAMETERIZED_MODEL)\n    {\n      itemType_ = COLLECTION_ITEM_TYPE::portableModel;\n      // differentiated from above by driverName_\n    }\n    else if (schemaV1->itemType == SharedLibrarySchemaV1::SIMULATOR_MODEL)\n    {\n      itemType_ = COLLECTION_ITEM_TYPE::simulatorModel;\n    }\n    else if (schemaV1->itemType == SharedLibrarySchemaV1::MODEL_DRIVER)\n    {\n      itemType_ = COLLECTION_ITEM_TYPE::modelDriver;\n    }\n    else\n    {\n      LOG_ERROR(\"SHOULD NEVER GET HERE.\");\n      LOG_DEBUG(\"Exit 1=\" + callString);\n      return true;\n    }\n\n    createLanguageName_ = schemaV1->createLanguageName;\n    createRoutine_ = schemaV1->createRoutine;\n    driverName_ = ((schemaV1->driverName) ? schemaV1->driverName : \"\");\n\n    if (schemaV1->metadataFile)\n    {\n      simulatorModelSpecificationFile_.fileName\n          = schemaV1->metadataFile->fileName;\n      simulatorModelSpecificationFile_.fileLength\n          = schemaV1->metadataFile->fileLength;\n      simulatorModelSpecificationFile_.filePointer\n          = schemaV1->metadataFile->filePointer;\n    }\n\n    numberOfParameterFiles_ = schemaV1->numberOfParameterFiles;\n    for (int i = 0; i < numberOfParameterFiles_; ++i)\n    {\n      EmbeddedFile fl;\n      fl.fileName = schemaV1->parameterFiles[i].fileName;\n      fl.fileLength = schemaV1->parameterFiles[i].fileLength;\n      fl.filePointer = schemaV1->parameterFiles[i].filePointer;\n\n      parameterFiles_.push_back(fl);\n    }\n    numberOfMetadataFiles_ = 1;\n    EmbeddedFile fl;\n    fl.fileName = \"compiled-with-version.txt\";\n    fl.fileLength = strlen(schemaV1->compiledWithVersion);\n    fl.filePointer = reinterpret_cast<unsigned char const *>(\n        schemaV1->compiledWithVersion);\n    metadataFiles_.push_back(fl);\n  }\n  else\n  {\n    LOG_ERROR(\"Unknown KIM::SharedLibrarySchema version.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::Close()\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"Close().\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"SharedLibrary not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  sharedLibraryName_ = \"\";\n  sharedLibrarySchemaVersion_ = 0;\n  itemName_ = \"\";\n  createRoutine_ = NULL;\n  driverName_ = \"\";\n  simulatorModelSpecificationFile_.fileName = NULL;\n  simulatorModelSpecificationFile_.fileLength = 0;\n  simulatorModelSpecificationFile_.filePointer = NULL;\n  numberOfParameterFiles_ = 0;\n  parameterFiles_.clear();\n  numberOfMetadataFiles_ = 0;\n  metadataFiles_.clear();\n  int error = dlclose(sharedLibraryHandle_);\n  if (error)\n  {\n    LOG_ERROR(\"\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n  else\n  {\n    sharedLibraryHandle_ = NULL;\n  }\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetName(std::string * const name) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"GetName(\" + SPTR(name) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  *name = itemName_;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetType(CollectionItemType * const type) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"GetType(\" + SPTR(type) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  *type = itemType_;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetCreateFunctionPointer(\n    LanguageName * const languageName, Function ** const functionPointer) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"GetCreateFunctionPointer(\"\n                                 + SPTR(languageName) + \", \"\n                                 + SFUNCP(functionPointer) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if (languageName) *languageName = createLanguageName_;\n  if (functionPointer) *functionPointer = createRoutine_;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetNumberOfParameterFiles(\n    int * const numberOfParameterFiles) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString\n      = \"GetNumberOfParameterFiles(\" + SPTR(numberOfParameterFiles) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  *numberOfParameterFiles = numberOfParameterFiles_;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetParameterFile(\n    int const index,\n    std::string * const parameterFileName,\n    unsigned int * const parameterFileLength,\n    unsigned char const ** const parameterFileData) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"GetParameterFile(\" + SNUM(index) + \", \"\n                                 + SPTR(parameterFileName) + \", \"\n                                 + SPTR(parameterFileLength) + \", \"\n                                 + SPTR(parameterFileData) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if (((itemType_ == COLLECTION_ITEM_TYPE::portableModel)\n       && (driverName_ == \"\"))\n      || (itemType_ == COLLECTION_ITEM_TYPE::modelDriver))\n  {\n    LOG_ERROR(\"This item type does not have parameter files.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  if ((index < 0) || index >= numberOfParameterFiles_)\n  {\n    LOG_ERROR(\"Invalid parameter file index.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  if (parameterFileName) *parameterFileName = (parameterFiles_[index]).fileName;\n  if (parameterFileLength)\n    *parameterFileLength = (parameterFiles_[index]).fileLength;\n  if (parameterFileData)\n    *parameterFileData = (parameterFiles_[index]).filePointer;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetNumberOfMetadataFiles(\n    int * const numberOfMetadataFiles) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString\n      = \"GetNumberOfMetadataFiles(\" + SPTR(numberOfMetadataFiles) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  *numberOfMetadataFiles = numberOfMetadataFiles_;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetMetadataFile(\n    int const index,\n    std::string * const metadataFileName,\n    unsigned int * const metadataFileLength,\n    unsigned char const ** const metadataFileData) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString\n      = \"GetMetadataFile(\" + SNUM(index) + \", \" + SPTR(metadataFileName) + \", \"\n        + SPTR(metadataFileLength) + \", \" + SPTR(metadataFileData) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if ((index < 0) || index >= numberOfMetadataFiles_)\n  {\n    LOG_ERROR(\"Invalid metadata file index.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  if (metadataFileName) *metadataFileName = (metadataFiles_[index]).fileName;\n  if (metadataFileLength)\n    *metadataFileLength = (metadataFiles_[index]).fileLength;\n  if (metadataFileData) *metadataFileData = (metadataFiles_[index]).filePointer;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetSimulatorModelSpecificationFile(\n    std::string * const specFileName,\n    unsigned int * const specFileLength,\n    unsigned char const ** const specFileData) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString\n      = \"GetSimulatorModelSpecificationFile(, \" + SPTR(specFileName) + \", \"\n        + SPTR(specFileLength) + \", \" + SPTR(specFileData) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if (itemType_ != COLLECTION_ITEM_TYPE::simulatorModel)\n  {\n    LOG_ERROR(\n        \"This item type does not have a simulator model specification file.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  if (specFileName) *specFileName = (simulatorModelSpecificationFile_).fileName;\n  if (specFileLength)\n    *specFileLength = (simulatorModelSpecificationFile_).fileLength;\n  if (specFileData)\n    *specFileData = (simulatorModelSpecificationFile_).filePointer;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetDriverName(std::string * const driverName) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"GetDriverName(\" + SPTR(driverName) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if ((itemType_ != COLLECTION_ITEM_TYPE::portableModel) && (driverName_ != \"\"))\n  {\n    LOG_ERROR(\"This item type does not have an associated  model driver.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  *driverName = driverName_;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}  // namespace KIM\n\nvoid SharedLibrary::LogEntry(LogVerbosity const logVerbosity,\n                             std::string const & message,\n                             int const lineNumber,\n                             std::string const & fileName) const\n{\n  if (log_) log_->LogEntry(logVerbosity, message, lineNumber, fileName);\n}\n\n}  // namespace KIM\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.1.1-vkisw7kaqtde6u5frqgxmhp737qhl4xb/spack-src/examples/model-drivers/LennardJones612__MD_414112407348_003/LICENSE.CDDL",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.1.1-vkisw7kaqtde6u5frqgxmhp737qhl4xb/spack-src/examples/portable-models/LennardJones612_UniversalShifted__MO_959249795837_003/LICENSE.CDDL",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.1.1-vkisw7kaqtde6u5frqgxmhp737qhl4xb/spack-src/docs/src/asymptote-figures/square-lattice-configuration-1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.1.1-vkisw7kaqtde6u5frqgxmhp737qhl4xb/spack-src/docs/src/asymptote-figures/square-lattice-configuration-1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.1.1-vkisw7kaqtde6u5frqgxmhp737qhl4xb/spack-src/docs/src/asymptote-figures/square-lattice-configuration-2.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.1.1-vkisw7kaqtde6u5frqgxmhp737qhl4xb/spack-src/docs/src/asymptote-figures/square-lattice-configuration-2.jpg"
    ],
    "total_files": 342
}