{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.0.2-p7wi6jpe6po72dejnbqz2f4demhyc5u4/spack-src/utils/shared-library-test.cpp": "//\n// CDDL HEADER START\n//\n// The contents of this file are subject to the terms of the Common Development\n// and Distribution License Version 1.0 (the \"License\").\n//\n// You can obtain a copy of the license at\n// http://www.opensource.org/licenses/CDDL-1.0.  See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// When distributing Covered Code, include this CDDL HEADER in each file and\n// include the License file in a prominent location with the name LICENSE.CDDL.\n// If applicable, add the following below this CDDL HEADER, with the fields\n// enclosed by brackets \"[]\" replaced with your own identifying information:\n//\n// Portions Copyright (c) [yyyy] [name of copyright owner]. All rights reserved.\n//\n// CDDL HEADER END\n//\n\n//\n// Copyright (c) 2013--2019, Regents of the University of Minnesota.\n// All rights reserved.\n//\n// Contributors:\n//    Ryan S. Elliott\n//\n\n//\n// Release: This file is part of the kim-api-2.0.2 package.\n//\n\n#include \"KIM_Version.hpp\"\n#include <dlfcn.h>\n#include <iostream>\n#include <string>\n\nvoid usage(std::string name)\n{\n  size_t beg = name.find_last_of(\"/\");\n  if (beg != std::string::npos) name = name.substr(beg + 1, std::string::npos);\n\n  // Follows docopt.org format\n  std::cerr << \"Usage:\\n\"\n            << \"  \" << name << \" <shared-library-name>\\n\"\n            << \"  \" << name << \" --version\" << std::endl;\n  // note: this interface is likely to change in future kim-api releases\n}\n\nint IsFilePath(std::string const & filePath)\n{\n  // not very comperhensive but can be improved as needed\n  if (filePath.length() == 0) return false;\n  return true;\n}\n\nint main(int argc, char * argv[])\n{\n  if (argc != 2)\n  {\n    usage(argv[0]);\n    return 1;\n  }\n  else if (std::string(argv[1]) == \"--version\")\n  {\n    std::cout << KIM_VERSION_STRING << std::endl;\n    return 0;\n  }\n  else\n  {\n    std::string libFilePath(argv[1]);\n    if (!IsFilePath(libFilePath))  // validate lib path\n    {\n      std::cout << \"Invalid <shared-library-name>.\\n\" << std::endl;\n      return 2;\n    }\n\n    void * sharedLibraryHandle = dlopen(libFilePath.c_str(), RTLD_NOW);\n    if (sharedLibraryHandle == NULL)\n    {\n      std::cout << \"Unable to open shared library.\\n\" << dlerror() << std::endl;\n      return 3;\n    }\n    else\n    {\n      std::cout << \"Successfully opened shared library.\" << std::endl;\n      dlclose(sharedLibraryHandle);\n      return 0;\n    }\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.0.2-p7wi6jpe6po72dejnbqz2f4demhyc5u4/spack-src/cpp/src/KIM_SharedLibrary.cpp": "//\n// CDDL HEADER START\n//\n// The contents of this file are subject to the terms of the Common Development\n// and Distribution License Version 1.0 (the \"License\").\n//\n// You can obtain a copy of the license at\n// http://www.opensource.org/licenses/CDDL-1.0.  See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// When distributing Covered Code, include this CDDL HEADER in each file and\n// include the License file in a prominent location with the name LICENSE.CDDL.\n// If applicable, add the following below this CDDL HEADER, with the fields\n// enclosed by brackets \"[]\" replaced with your own identifying information:\n//\n// Portions Copyright (c) [yyyy] [name of copyright owner]. All rights reserved.\n//\n// CDDL HEADER END\n//\n\n//\n// Copyright (c) 2016--2019, Regents of the University of Minnesota.\n// All rights reserved.\n//\n// Contributors:\n//    Ryan S. Elliott\n//\n\n//\n// Release: This file is part of the kim-api-2.0.2 package.\n//\n\n#include <dlfcn.h>\n#include <sstream>\n\n#ifndef KIM_SHARED_LIBRARY_HPP_\n#include \"KIM_SharedLibrary.hpp\"\n#endif\n\n#ifndef KIM_LOG_VERBOSITY_HPP_\n#include \"KIM_LogVerbosity.hpp\"\n#endif\n\n#ifndef KIM_LANGUAGE_NAME_HPP_\n#include \"KIM_LanguageName.hpp\"\n#endif\n\n#ifndef KIM_SHARED_LIBRARY_SCHEMA_HPP_\n#include \"KIM_SharedLibrarySchema.hpp\"\n#endif\n\nnamespace KIM\n{\n// log helpers\n#define SNUM(x) \\\n  static_cast<std::ostringstream &>(std::ostringstream() << std::dec << x).str()\n#define SPTR(x)                                                      \\\n  static_cast<std::ostringstream &>(std::ostringstream()             \\\n                                    << static_cast<void const *>(x)) \\\n      .str()\n#define SFUNCP(x)                                                   \\\n  static_cast<std::ostringstream &>(std::ostringstream()            \\\n                                    << static_cast<Function **>(x)) \\\n      .str()\n\n#include \"KIM_LogMacros.hpp\"\n#define KIM_LOGGER_OBJECT_NAME this\nSharedLibrary::SharedLibrary(Log * const log) :\n    sharedLibraryHandle_(NULL),\n    sharedLibrarySchemaVersion_(NULL),\n    sharedLibrarySchema_(NULL),\n    log_(log)\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"SharedLibrary(\" + SPTR(log) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  LOG_DEBUG(\"Exit   \" + callString);\n}\n\nSharedLibrary::~SharedLibrary()\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"~SharedLibrary().\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  Close();\n\n  LOG_DEBUG(\"Exit   \" + callString);\n}\n\nint SharedLibrary::Open(std::string const & sharedLibraryName)\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"Open('\" + sharedLibraryName + \"').\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ != NULL)\n  {\n    LOG_ERROR(\"\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // already open\n  }\n\n  sharedLibraryName_ = sharedLibraryName;\n\n  sharedLibraryHandle_ = dlopen(sharedLibraryName_.c_str(), RTLD_NOW);\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Unable to open '\" + sharedLibraryName_ + \"'.\");\n    LOG_ERROR(dlerror());\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n\n  sharedLibrarySchemaVersion_ = reinterpret_cast<int const *>(\n      dlsym(sharedLibraryHandle_, \"kim_shared_library_schema_version\"));\n  if (sharedLibrarySchemaVersion_ == NULL)\n  {\n    LOG_ERROR(dlerror());\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  if (*sharedLibrarySchemaVersion_ == 1)\n  {\n    sharedLibrarySchema_ = reinterpret_cast<\n        SHARED_LIBRARY_SCHEMA::SharedLibrarySchemaV1 const *>(\n        dlsym(sharedLibraryHandle_, \"kim_shared_library_schema\"));\n    if (sharedLibrarySchema_ == NULL)\n    {\n      LOG_ERROR(dlerror());\n      LOG_DEBUG(\"Exit 1=\" + callString);\n      return true;\n    }\n  }\n  else\n  {\n    LOG_ERROR(\"Unknown KIM::SharedLibrarySchema version.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::Close()\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"Close().\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"SharedLibrary not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  sharedLibraryName_ = \"\";\n  int error = dlclose(sharedLibraryHandle_);\n  if (error)\n  {\n    LOG_ERROR(\"\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n  else\n  {\n    sharedLibraryHandle_ = NULL;\n  }\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetName(std::string * const name) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"GetName(\" + SPTR(name) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  *name = sharedLibrarySchema_->itemName;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetType(ITEM_TYPE * const type) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"GetType(\" + SPTR(type) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  *type = SIMULATOR_MODEL;  // dummy value\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if (*sharedLibrarySchemaVersion_ == 1)\n  {\n    using namespace KIM::SHARED_LIBRARY_SCHEMA;\n    SharedLibrarySchemaV1::ITEM_TYPE const KIM_ItemType\n        = sharedLibrarySchema_->itemType;\n\n    if (KIM_ItemType == SharedLibrarySchemaV1::STAND_ALONE_MODEL)\n    { *type = STAND_ALONE_MODEL; }\n    else if (KIM_ItemType == SharedLibrarySchemaV1::PARAMETERIZED_MODEL)\n    {\n      *type = PARAMETERIZED_MODEL;\n    }\n    else if (KIM_ItemType == SharedLibrarySchemaV1::SIMULATOR_MODEL)\n    {\n      *type = SIMULATOR_MODEL;\n    }\n    else if (KIM_ItemType == SharedLibrarySchemaV1::MODEL_DRIVER)\n    {\n      *type = MODEL_DRIVER;\n    }\n    else\n    {\n      LOG_ERROR(\"SHOULD NEVER GET HERE.\");\n      LOG_DEBUG(\"Exit 1=\" + callString);\n      return true;\n    }\n  }\n  else\n  {\n    LOG_ERROR(\"Unknown KIM::SharedLibrarySchema version.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetCreateFunctionPointer(\n    LanguageName * const languageName, Function ** const functionPointer) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"GetCreateFunctionPointer(\"\n                                 + SPTR(languageName) + \", \"\n                                 + SFUNCP(functionPointer) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if (*sharedLibrarySchemaVersion_ == 1)\n  {\n    *languageName = sharedLibrarySchema_->createLanguageName;\n    *functionPointer = sharedLibrarySchema_->createRoutine;\n  }\n  else\n  {\n    LOG_ERROR(\"Unknown KIM::SharedLibrarySchema version.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetNumberOfParameterFiles(\n    int * const numberOfParameterFiles) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString\n      = \"GetNumberOfParameterFiles(\" + SPTR(numberOfParameterFiles) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if (*sharedLibrarySchemaVersion_ == 1)\n  { *numberOfParameterFiles = sharedLibrarySchema_->numberOfParameterFiles; }\n  else\n  {\n    LOG_ERROR(\"Unknown KIM::SharedLibrarySchema version.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetParameterFile(\n    int const index,\n    std::string * const parameterFileName,\n    unsigned int * const parameterFileLength,\n    unsigned char const ** const parameterFileData) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"GetParameterFile(\" + SNUM(index) + \", \"\n                                 + SPTR(parameterFileName) + \", \"\n                                 + SPTR(parameterFileLength) + \", \"\n                                 + SPTR(parameterFileData) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  ITEM_TYPE itemType;\n  GetType(&itemType);\n  if ((itemType != PARAMETERIZED_MODEL) && (itemType != SIMULATOR_MODEL))\n  {\n    LOG_ERROR(\"This item type does not have parameter files.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  int numberOfParameterFiles;\n  GetNumberOfParameterFiles(&numberOfParameterFiles);\n  if ((index < 0) || index >= numberOfParameterFiles)\n  {\n    LOG_ERROR(\"Invalid parameter file index.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  if (*sharedLibrarySchemaVersion_ == 1)\n  {\n    if (parameterFileName)\n      *parameterFileName\n          = (sharedLibrarySchema_->parameterFiles[index]).fileName;\n    if (parameterFileLength)\n      *parameterFileLength\n          = (sharedLibrarySchema_->parameterFiles[index]).fileLength;\n    if (parameterFileData)\n      *parameterFileData\n          = (sharedLibrarySchema_->parameterFiles[index]).filePointer;\n  }\n  else\n  {\n    LOG_ERROR(\"Unknown KIM::SharedLibrarySchema version.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetMetadataFile(\n    std::string * const metadataFileName,\n    unsigned int * const metadataFileLength,\n    unsigned char const ** const metadataFileData) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"GetMetadataFile(, \" + SPTR(metadataFileName)\n                                 + \", \" + SPTR(metadataFileLength) + \", \"\n                                 + SPTR(metadataFileData) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  ITEM_TYPE itemType;\n  GetType(&itemType);\n  if (itemType != SIMULATOR_MODEL)\n  {\n    LOG_ERROR(\"This item type does not have a metadata file.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  if (*sharedLibrarySchemaVersion_ == 1)\n  {\n    if (metadataFileName)\n      *metadataFileName = (sharedLibrarySchema_->metadataFile)->fileName;\n    if (metadataFileLength)\n      *metadataFileLength = (sharedLibrarySchema_->metadataFile)->fileLength;\n    if (metadataFileData)\n      *metadataFileData = (sharedLibrarySchema_->metadataFile)->filePointer;\n  }\n  else\n  {\n    LOG_ERROR(\"Unknown KIM::SharedLibrarySchema version.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetDriverName(std::string * const driverName) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"GetDriverName(\" + SPTR(driverName) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if (*sharedLibrarySchemaVersion_ == 1)\n  {\n    ITEM_TYPE itemType;\n    GetType(&itemType);\n    if (itemType != PARAMETERIZED_MODEL)\n    {\n      LOG_DEBUG(\"Exit 1=\" + callString);\n      return true;\n    }\n\n    *driverName = sharedLibrarySchema_->driverName;\n  }\n  else\n  {\n    LOG_ERROR(\"Unknown KIM::SharedLibrarySchema version.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetCompiledWithVersion(\n    std::string * const versionString) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString\n      = \"GetCompiledWithVersion(\" + SPTR(versionString) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if (*sharedLibrarySchemaVersion_ == 1)\n  { *versionString = sharedLibrarySchema_->compiledWithVersion; }\n  else\n  {\n    LOG_ERROR(\"Unknown KIM::SharedLibrarySchema version.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  LOG_DEBUG(\"Exit 1=\" + callString);\n  return false;\n}\n\nvoid SharedLibrary::LogEntry(LogVerbosity const logVerbosity,\n                             std::string const & message,\n                             int const lineNumber,\n                             std::string const & fileName) const\n{\n  if (log_) log_->LogEntry(logVerbosity, message, lineNumber, fileName);\n}\n\n}  // namespace KIM\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.0.2-p7wi6jpe6po72dejnbqz2f4demhyc5u4/spack-src/examples/models/LennardJones612_UniversalShifted__MO_959249795837_003/LICENSE.CDDL",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.0.2-p7wi6jpe6po72dejnbqz2f4demhyc5u4/spack-src/examples/model-drivers/LennardJones612__MD_414112407348_003/LICENSE.CDDL",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.0.2-p7wi6jpe6po72dejnbqz2f4demhyc5u4/spack-src/docs/src/asymptote-figures/square-lattice-configuration-1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.0.2-p7wi6jpe6po72dejnbqz2f4demhyc5u4/spack-src/docs/src/asymptote-figures/square-lattice-configuration-1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.0.2-p7wi6jpe6po72dejnbqz2f4demhyc5u4/spack-src/docs/src/asymptote-figures/square-lattice-configuration-2.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.0.2-p7wi6jpe6po72dejnbqz2f4demhyc5u4/spack-src/docs/src/asymptote-figures/square-lattice-configuration-2.jpg"
    ],
    "total_files": 300
}