{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/cmake_nrnconf.h.in": "/* config.h.in.  Generated from configure.ac by autoheader.  */\n\n\n#ifndef H_nrnconf_included\n#define H_nrnconf_included 1\n\n\n/* Define if building universal (internal helper macro) */\n#undef AC_APPLE_UNIVERSAL_BUILD\n\n/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP\n   systems. This function is required for `alloca.c' support on those systems.\n   */\n#undef CRAY_STACKSEG_END\n\n/* define if using cygwin */\n#undef CYGWIN\n\n/* Define to 1 if using `alloca.c'. */\n#undef C_ALLOCA\n\n/* if mac os x */\n#undef DARWIN\n\n/* Define to 1 if you have `alloca', as a function or macro. */\n#undef HAVE_ALLOCA\n\n/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).\n   */\n#undef HAVE_ALLOCA_H\n\n/* Define to 1 if you have the `bcopy' function. */\n#undef HAVE_BCOPY\n\n/* Define to 1 if you have the `bzero' function. */\n#undef HAVE_BZERO\n\n/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.\n   */\n#undef HAVE_DIRENT_H\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#undef HAVE_DLFCN_H\n\n/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */\n#undef HAVE_DOPRNT\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n#undef HAVE_FCNTL_H\n\n/* Define to 1 if you have the <fenv.h> header file. */\n#undef HAVE_FENV_H\n\n/* Define to 1 if you have the `fesetround' function. */\n#undef HAVE_FESETROUND\n\n/* Define to 1 if you have the <float.h> header file. */\n#undef HAVE_FLOAT_H\n\n/* Define to 1 if you have the `ftime' function. */\n#undef HAVE_FTIME\n\n/* Define to 1 if you have the `getcwd' function. */\n#undef HAVE_GETCWD\n\n/* Define to 1 if you have the `gethostname' function. */\n#undef HAVE_GETHOSTNAME\n\n/* Define to 1 if you have the `getpw' function. */\n#undef HAVE_GETPW\n\n/* Define to 1 if you have the `gettimeofday' function. */\n#undef HAVE_GETTIMEOFDAY\n\n/* Define to 1 if you have the `index' function. */\n#undef HAVE_INDEX\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#undef HAVE_INTTYPES_H\n\n/* Define to 1 if you have the `isatty' function. */\n#undef HAVE_ISATTY\n\n/* define if using InterViews */\n#undef HAVE_IV\n\n/* Define to 1 if you have the <limits.h> header file. */\n#undef HAVE_LIMITS_H\n\n/* Define to 1 if you have the <locale.h> header file. */\n#undef HAVE_LOCALE_H\n\n/* Define to 1 if you have the `lockf' function. */\n#undef HAVE_LOCKF\n\n/* Define to 1 if you have the `mallinfo' function. */\n#undef HAVE_MALLINFO\n\n/* Define to 1 if you have the <malloc.h> header file. */\n#undef HAVE_MALLOC_H\n\n/* Define to 1 if you have the <math.h> header file. */\n#undef HAVE_MATH_H\n\n/* Define to 1 if you have the <memory.h> header file. */\n#undef HAVE_MEMORY_H\n\n/* Define to 1 if you have the `mkdir' function. */\n#undef HAVE_MKDIR\n\n/* Define to 1 if you have the `mkstemp' function. */\n#undef HAVE_MKSTEMP\n\n/* define if the compiler implements namespaces */\n#undef HAVE_NAMESPACES\n\n/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */\n#undef HAVE_NDIR_H\n\n/* Define to 1 if you have the `posix_memalign' function. */\n#undef HAVE_POSIX_MEMALIGN\n\n/* Define if you have POSIX threads libraries and header files. */\n#undef HAVE_PTHREAD\n\n/* Define to 1 if you have the <pthread.h> header file. */\n#undef HAVE_PTHREAD_H\n\n/* Define to 1 if you have the `putenv' function. */\n#undef HAVE_PUTENV\n\n/* Define to 1 if you have the `realpath' function. */\n#undef HAVE_REALPATH\n\n/* Define to 1 if you have the `select' function. */\n#undef HAVE_SELECT\n\n/* Define to 1 if you have the `setenv' function. */\n#undef HAVE_SETENV\n\n/* Define to 1 if you have the `setitimer' function. */\n#undef HAVE_SETITIMER\n\n/* Define to 1 if you have the <sgtty.h> header file. */\n#undef HAVE_SGTTY_H\n\n/* Define to 1 if you have the `sigaction' function. */\n#undef HAVE_SIGACTION\n\n/* (Define if this signal exists) */\n#undef HAVE_SIGBUS\n\n/* (Define if this signal exists) */\n#undef HAVE_SIGSEGV\n\n/* define if the compiler has stringstream */\n#undef HAVE_SSTREAM\n\n/* Define to 1 if you have the <stdarg.h> header file. */\n#undef HAVE_STDARG_H\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#undef HAVE_STDINT_H\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#undef HAVE_STDLIB_H\n\n/* Define to 1 if you have the `strdup' function. */\n#undef HAVE_STRDUP\n\n/* Define to 1 if you have the <stream.h> header file. */\n#undef HAVE_STREAM_H\n\n/* Define to 1 if you have the <strings.h> header file. */\n#undef HAVE_STRINGS_H\n\n/* Define to 1 if you have the <string.h> header file. */\n#undef HAVE_STRING_H\n\n/* Define to 1 if you have the <stropts.h> header file. */\n#undef HAVE_STROPTS_H\n\n/* Define to 1 if you have the `strstr' function. */\n#undef HAVE_STRSTR\n\n/* Define to 1 if you have the `stty' function. */\n#undef HAVE_STTY\n\n/* Define to 1 if you have the <sys/conf.h> header file. */\n#undef HAVE_SYS_CONF_H\n\n/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.\n   */\n#undef HAVE_SYS_DIR_H\n\n/* Define to 1 if you have the <sys/file.h> header file. */\n#undef HAVE_SYS_FILE_H\n\n/* Define to 1 if you have the <sys/ioctl.h> header file. */\n#undef HAVE_SYS_IOCTL_H\n\n/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.\n   */\n#undef HAVE_SYS_NDIR_H\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#undef HAVE_SYS_STAT_H\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#undef HAVE_SYS_TIME_H\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#undef HAVE_SYS_TYPES_H\n\n/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */\n#undef HAVE_SYS_WAIT_H\n\n/* Define to 1 if you have the <termio.h> header file. */\n#undef HAVE_TERMIO_H\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#undef HAVE_UNISTD_H\n\n/* Define to 1 if you have the <varargs.h> header file. */\n#undef HAVE_VARARGS_H\n\n/* Define to 1 if you have the `vprintf' function. */\n#undef HAVE_VPRINTF\n\n/* Define to 1 if you have the <_G_config.h> header file. */\n#undef HAVE__G_CONFIG_H\n\n/* define if can declare inline float abs(float) */\n#undef INLINE_FLOAT_ABS\n\n/* define if can declare inline long abs(long) */\n#undef INLINE_LONG_ABS\n\n/* undefined or ::fabs or std::fabs */\n#undef IVOS_FABS\n\n/* Define to the sub-directory where libtool stores uninstalled libraries. */\n#undef LT_OBJDIR\n\n/* 1 for legacy, undef for NIST (as of 2017), for FARADAY and R */\n#undef LegacyFR\n\n/* define if using mingw */\n#undef MINGW\n\n/* define if using Mike Neubig <neubig@salk.edu> contributions */\n#undef MikeNeubig\n\n/* where the lib hoc is */\n#undef NEURON_DATA_DIR\n\n/* host triplet */\n#undef NRNHOST\n\n/* cpu type consistent with nrnivmodl */\n#undef NRNHOSTCPU\n\n/* if 1 then dlopen nrnmech instead of special */\n#undef NRNMECH_DLL_STYLE\n\n/* if nrnoc can use X11 */\n#undef NRNOC_X11\n\n/* location of NEURON libraries */\n#undef NRN_LIBDIR\n\n/* Name of package */\n#undef PACKAGE\n\n/* Define to the address where bug reports for this package should be sent. */\n#undef PACKAGE_BUGREPORT\n\n/* Define to the full name of this package. */\n#undef PACKAGE_NAME\n\n/* Define to the full name and version of this package. */\n#undef PACKAGE_STRING\n\n/* Define to the one symbol short name of this package. */\n#undef PACKAGE_TARNAME\n\n/* Define to the home page for this package. */\n#undef PACKAGE_URL\n\n/* Define to the version of this package. */\n#undef PACKAGE_VERSION\n\n/* Define to necessary symbol if this constant uses a non-standard name on\n   your system. */\n#undef PTHREAD_CREATE_JOINABLE\n\n/* Define as the return type of signal handlers (`int' or `void'). */\n#undef RETSIGTYPE\n\n/* define if RETSIGTYPE(*)(int) is not the prototype for a signal handler */\n#undef SIGNAL_CAST\n\n/* If using the C implementation of alloca, define if you know the\n   direction of stack growth for your system; otherwise it will be\n   automatically deduced at runtime.\n\tSTACK_DIRECTION > 0 => grows toward higher addresses\n\tSTACK_DIRECTION < 0 => grows toward lower addresses\n\tSTACK_DIRECTION = 0 => direction of growth unknown */\n#undef STACK_DIRECTION\n\n/* Define to 1 if you have the ANSI C header files. */\n#undef STDC_HEADERS\n\n/* Define SUNDIALS data type 'realtype' as 'long double' */\n#undef SUNDIALS_DOUBLE_PRECISION\n\n/* Use generic math functions */\n#undef SUNDIALS_USE_GENERIC_MATH\n\n/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n#undef TIME_WITH_SYS_TIME\n\n/* Define to 1 if your <sys/time.h> declares `struct tm'. */\n#undef TM_IN_SYS_TIME\n\n/* Version number of package */\n#undef VERSION\n\n/* define if no terminal capabilities */\n#undef WITHOUT_MEMACS\n\n/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n   significant byte first (like Motorola and SPARC, unlike Intel). */\n#if defined AC_APPLE_UNIVERSAL_BUILD\n# if defined __BIG_ENDIAN__\n#  define WORDS_BIGENDIAN 1\n# endif\n#else\n# ifndef WORDS_BIGENDIAN\n#  undef WORDS_BIGENDIAN\n# endif\n#endif\n\n/* Define to 1 if the X Window System is missing or not being used. */\n#undef X_DISPLAY_MISSING\n\n/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a\n   `char[]'. */\n#undef YYTEXT_POINTER\n\n/* define if using Carbon libraries */\n#undef carbon\n\n/* Define to the type of a signed integer type of width exactly 64 bits if\n   such a type exists and the standard includes do not define it. */\n#undef int64_t\n\n/* Define to `long int' if <sys/types.h> does not define. */\n#undef off_t\n\n/* Define to `int' if <sys/types.h> does not define. */\n#undef pid_t\n\n/* Define to `unsigned int' if <sys/types.h> does not define. */\n#undef size_t\n\n\n#if defined(__cplusplus)\n#include <ivstream.h>\n#endif\n\n#if defined(CYGWIN) || defined(MINGW)\n#define WIN32 1\n#endif\n\n#if defined(MINGW)\n#define CYGWIN\n#endif\n\n#if defined(carbon) && defined(__cplusplus)\n#define MAC 1\n#include <Carbon/Carbon.h>\n#endif\n\n#endif /* H_nrnconf_included */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/configure.ac": "dnl Process this file with autoconf to produce a configure script.\n\ndnl disable caching. When configure fails, it is best to start from scratch.\ndefine([AC_CACHE_LOAD], )dnl\ndefine([AC_CACHE_SAVE], )dnl\n\ndnl PACKAGE_VERSION makes its way into git2nrnversion_h.sh, etc.\ndnl However 'git describe --tags' is used for the version string for\ndnl distribution file names, banner, nrniv --version, and\ndnl nrnversion(5). If the PACKAGE_VERSION changes then also do a\ndnl git tag -a major.minor.micro consistent with that.\n\nAC_INIT([nrn],[7.8])\nAC_CONFIG_MACRO_DIR([m4])\nAC_CONFIG_SRCDIR(src/memacs/main.c)\nAM_INIT_AUTOMAKE([foreign])\nAM_MAINTAINER_MODE([enable])\n\nm4_pattern_allow([^AC_MSG_ERROR$])\n\nAC_PROG_CC_STDC\nif test \"x$ac_cv_prog_cc_stdc\" = xno ; then\n  AC_MSG_ERROR([C compiler not ISO Standard C])\nfi\n\nPKG_PROG_PKG_CONFIG([0.22])\n\nUNQUOTED_PACKAGE_VERSION=$PACKAGE_VERSION\nAC_SUBST(UNQUOTED_PACKAGE_VERSION)\ndnl The following line causes us to make a config.h instead of putting all\ndnl the defines into the makefile.\nAC_CONFIG_HEADERS(config.h)\nAH_TOP([\n#ifndef H_nrnconf_included\n#define H_nrnconf_included 1\n])\nAH_BOTTOM([\n#if defined(__cplusplus)\n#include <ivstream.h>\n#endif\n\n#if defined(CYGWIN) || defined(MINGW)\n#define WIN32 1\n#endif\n\n#if defined(MINGW)\n#define CYGWIN\n#endif\n\n#if defined(carbon) && defined(__cplusplus)\n#define MAC 1\n#include <Carbon/Carbon.h>\n#endif\n\n#endif /* H_nrnconf_included */\n])\n\ndnl following does not seem to work in the sense of\ndnl causing problems with exec_prefix\nAC_PREFIX_DEFAULT(/usr/local/nrn)\ndnl so do it explicitly\nif test \"$prefix\" = NONE ; then\n        prefix=/usr/local/nrn\nfi\n\nif test \"$prefix\" = \"NONE\" ; then\nprefix=$ac_default_prefix\nfi\n\nAC_CANONICAL_HOST  dnl Make generic macros for the kind of system.\n\ndnl for later testing with regard to special work arounds\ndnl if the user has taken the trouble to set them then we don't want\ndnl to re-set them\nmlh_cc=\"$CC\"\nmlh_cflag=\"$CFLAGS\"\nmlh_cxx=\"$CXX\"\nmlh_cxxflag=\"$CXXFLAGS\"\nmlh_yacc=\"$YACC\"\nmlh_ldflag=\"$LDFLAGS\"\n\ndnl dont want prefix/share/nrn to be the default data directory\ndnl if test \"$datadir\" = '${prefix}/share' && test \"$prefix\" != '/usr/local' ; then\ndnl\tdatadir='${prefix}'\ndnl fi\n\nAC_ARG_ENABLE([UniversalMacBinary],\n\tAC_HELP_STRING([--enable-UniversalMacBinary], [combined binary for ppc and i386, fake arch is called umac]),[\n\tenable_dependency_tracking=no\n\tCFLAGS=\"$CFLAGS -arch ppc -arch i386\"\n\tCXXFLAGS=\"$CXXFLAGS -arch ppc -arch i386\"\n\thost_cpu=umac\n])\nAM_CONDITIONAL(UniversalMacBinary, test x$enable_UniversalMacBinary = xyes)\n\nAC_ARG_ENABLE([DiscreteEventObserver],\n\tAC_HELP_STRING([--disable-DiscreteEventObserver], [Save space, but danger of use of freed memory if any NetCon destroyed.]),[\n\tif test \"$enable_DiscreteEventObserver\" != \"no\" ; then\n\t\tenable_DiscreteEventObserver=\"yes\"\n\tfi\n],[\n\tenable_DiscreteEventObserver=yes\n])\nif test \"$enable_DiscreteEventObserver\" = \"yes\" ; then\n\tNRN_DEFINE(DISCRETE_EVENT_OBSERVER,1,[Undef if do not want Observer to be a subclass of DiscreteEvent])\nfi\n\nAC_ARG_WITH([nmodl-only],\n\tAC_HELP_STRING([--with-nmodl-only],[When cross compiling, nocmodl need to be compiled for the build machine]), [\n\tif test \"$with_nmodl_only\" = \"yes\" ; then\n\t\tnmodl_build=yes\n\tfi\n],[\n\twith_nmodl_only=no\n])\n\nAC_ARG_WITH([nmodl], \n\tAC_HELP_STRING([--without-nmodl],[When cross compiling, nocmodl should NOT be compiled for the host machine]), [\n\tif test \"$with_nmodl\" = \"yes\" ; then\n\t\tnmodl_build=yes\n\telse\n\t\tnmodl_build=no\n\tfi\n],[\n\tnmodl_build=yes\n])\n\nAC_NRN_BLUEGENE\n\nif test x$with_nmodl_only = xyes ; then\n\tnmodl_build=yes\nfi\nif test \"$nmodl_build\" != \"no\" ; then\n\tnmodl_build=yes\nfi\n\nAM_CONDITIONAL(NMODL_ONLY, test x$with_nmodl_only = xyes)\nAM_CONDITIONAL(NMODL_BUILD, test x$nmodl_build = xyes)\n\nAC_ARG_WITH([nrnpython-only],\n\tAC_HELP_STRING([--with-nrnpython-only],[configure and make only the nrnpython folder]), [\n],[\n\twith_nrnpython_only=no\n])\nAM_CONDITIONAL(NRNPYTHON_ONLY, test x$with_nrnpython_only = xyes)\n\nif test \"$always_call_mpi_init\" = \"yes\" ; then\n\tNRN_DEFINE(ALWAYS_CALL_MPI_INIT,1,[define if needed])\nfi\nif test \"$file_open_retry\" != \"\" ; then\n\tNRN_DEFINE_UNQUOTED(FILE_OPEN_RETRY,$file_open_retry,[Number of times to retry a failed open])\nfi\n\ndnl Use to be only when configured with mpi. Now always since it is so useful.\nNRN_DEFINE_UNQUOTED(DLL_DEFAULT_FNAME,\"$host_cpu/.libs/libnrnmech.so\",[Define if want a automatic dll load])\n\ndnl Some things are specific to the PGI compiler\nAM_CONDITIONAL(USING_PGI_COMPILER, $CC --version | grep -q pgcc)\n\ndnl there are some os dependent properties in nrn.defaults.\nnrndef_unix=\"//\"\nnrndef_mac=\"//\"\nnrndef_mswin=\"//\"\n\ncase $host_os in\n\tcygwin* ) CYGWIN=yes\n\t\t  MINGW=no;;\n\tmingw* )  MINGW=yes\n\t\t  CYGWIN=no;;\n\t* )\t  CYGWIN=no\n\t\t  MINGW=no;;\nesac\n\necho \"CYGWIN=$CYGWIN\"\necho \"MINGW=$MINGW\"\ndnl for mswin, rebase will be skipped only for mingw64\nnrnskip_rebase=''\n\nif test \"$CYGWIN\" = \"yes\" -o \"$MINGW\" = \"yes\" ; then\n\tnrndef_mswin=\"\"\nfi\n\ndnl for some unknown reason this is needed to tickle the use of mpic++\ndnl if requested later.\nAC_LANG_SAVE\nAC_LANG_CPLUSPLUS\nAC_TRY_COMPILE([],[return 0;],,)\nAC_LANG_RESTORE\n\nAM_CONDITIONAL(BUILD_CARBON, test x$enable_carbon = xyes)\n\nNRN_SRCDIR=$srcdir\nAC_SUBST(NRN_SRCDIR)\ndnl use the --enable-rpm-rules=yes\ndnl Following is not very good with respect to identification\ndnl as it is just the package version major.minor\ndnl but distribution file names will get the latest name.\nRPM_RELEASE=\"`export NSRC=$srcdir ; sh $srcdir/nrnversion.sh microdotnano`\"\nAC_SUBST(RPM_RELEASE)\nif test \"$rpm_extra_args\" = \"\" ; then\n\trpm_extra_args=\"-ba nrnrpm.spec\"\nfi\nAM_RPM_INIT\ndnl Enable or disable the rpm making rules in Makefile.am\nAM_CONDITIONAL(MAKE_RPMS, test x$make_rpms = xtrue)\ndnl rpm is most generic when linked statically\ndnl however we would need to deal with libnrnmech.so and dlopen\nif test x$make_rpms = xtrue ; then\ndnl\tAM_ENABLE_SHARED(no)\n\tAM_ENABLE_SHARED(yes)\nelif test x$CYGWIN = xyes ; then\ndnl shared libraries cannot have undefined names. src/mswin/nrncygso.sh\ndnl will combine .o files into a single nrniv.dll (-fPIC is not needed)\n\tAM_ENABLE_SHARED(no)\n\tAM_ENABLE_STATIC(yes)\nelif test x$MINGW = xyes ; then\n\tAM_ENABLE_SHARED(no)\n\tAM_ENABLE_STATIC(yes)\nelse\n\tAM_ENABLE_SHARED(yes)\n\tAM_ENABLE_STATIC(no)\nfi\n\ndnl Checks for programs.\nAC_PROG_CC\nAC_PROG_CPP\nAC_PROG_AWK\nAC_PROG_INSTALL\ndnl AM_PROG_LEX has a bug in it, but it's required by automake 1.4.  We\ndnl replace this by a call to AC_PROG_LEX.  See acinclude.m4.  This should\ndnl probably be undone for the next version of automake.\nAM_PROG_LEX\nAC_PROG_YACC\nAC_PROG_LN_S\ndnl following line allows java to be the controller for NEURON\nAC_LIBTOOL_DLOPEN\ndnl Older versions of automake insist on having the AM_PROG_LIBTOOL,\ndnl although it is now obsolete.  We used to leave it in here, and then define\ndnl AM_PROG_LIBTOOL to call AC_PROG_LIBTOOL, which is the modern\ndnl way of doing it.\n\ndnl Checks for libraries\nAC_CHECK_LIBM\nLIBS=\"$LIBS $LIBM\"\n\ndnl Python that runs on the build machine needed to create hocusr.h\nAC_CHECK_PROGS(PYTHON_BLD, python3 python, python3)\n\ndnl Python for cygwin and mingw has to be done early because later tests may\ndnl have to be done with a CFLAGS=\"-mno-cygwin\" (obsolete after gcc2.3)\ndnl What to do about Python\nAC_NRN_PYTHON\n\ndnl Only needed if making a distribution. In that case cython must work.\ndnl Otherwise, to make a distribution, need to modify\ndnl src/neuronmusic/Makefile.am and remove neuronmusic.cpp from the list\ndnl of extra dist files.\ndnl Also needed for neuron.rxd.geometry3d module\nAC_CHECK_PROGS(CYTHON, cython3 cython, \"no\")\nAM_CONDITIONAL(HAVE_CYTHON, test x$CYTHON != xno)\n\nBUILD_RX3D=0\nif test \"$ac_nrn_rx3d\" = \"yes\" ; then\n\tif test x$CYTHON != xno -o -f share/lib/python/neuron/rxd/geometry3d/ctng.cpp ; then\n\t\tBUILD_RX3D=1\n\telse\n\t\tBUILD_RX3D=0\n\tfi\nfi\nAC_SUBST(BUILD_RX3D)\nAM_CONDITIONAL(BUILD_RX3D, test \"x$BUILD_RX3D\" = \"x1\")\n\nMINGW_CFLAG=\"\"\nEXTRA_CYGWIN_FLAGS='$(EXTRA_CYGWIN)'\nif test \"$CYGWIN\" = \"yes\" ; then\n\tif test \"$ac_nrn_cygwin\" = no ; then\n\t\tAC_MSG_NOTICE([Build using MinGW.])\n\t\tMINGW_CFLAG=\"-mno-cygwin\"\n\t\tEXTRA_CYGWIN_FLAGS=''\n\t\tdnl following will be put back at end\n\t\tCFLAGS=\"-mno-cygwin $CFLAGS\"\n\t\tCXXFLAGS=\"-mno-cygwin $CXXFLAGS\"\n\tfi\nfi\nAC_SUBST(MINGW_CFLAG)\nAC_SUBST(EXTRA_CYGWIN_FLAGS)\n\nAC_NRN_MUSIC\nAC_NRN_PARANEURON\nAC_NRN_WITH_MPI\nAC_NRN_WITH_METIS\n\nAM_PROG_LIBTOOL\n\ndnl when purify is enabled then one can use\ndnl nrnivmodl -p\ndnl to create a special which linked with purify.\nif test \"$enable_purify\" = \"yes\" ; then\n\tdnl special is a program, not a shell script for nrniv -dll...\n\tlinux_nrnmech=\"no\"\ndnl I believe this is the way it should be done but then all the\ndnl CXX variables would have to be set\ndnl\txtagname=$tagname\ndnl\ttagname=purify\ndnl\tAC_LIBTOOL_CONFIG([purify])\ndnl\ttagname=$xtagname\ndnl On the other hand, this appends to the end and seems to work.\ndnl All we really wanted was to avoid the rpath args.\n\tcat << __EOF__ >> libtool\n# ### BEGIN LIBTOOL TAG CONFIG: purify\nhardcode_libdir_flag_spec=\"\"\n# ### END LIBTOOL TAG CONFIG: purify\n__EOF__\nfi\nAM_CONDITIONAL(NRNPURIFY, test x$enable_purify = xyes)\n\ndnl linux rpm works only with nrnmech.dll style\ncase \"$host_os\" in\n  *linux*)\n\tif test x${linux_nrnmech} = x ; then\n\t\tlinux_nrnmech=\"yes\"\n\t\taddlibdl=\"yes\"\n\tfi\n\tif test x${java_dlopen} = x ; then\n\t\tjava_dlopen=\"yes\"\n\t\taddlibdl=\"yes\"\n\tfi\n\t;;\nesac\n\ncase \"$host_os\" in\n  darwin*)\n\tAC_DEFINE(DARWIN, 1, [if mac os x])\n\tif test x${macdarwin} = x ; then\n\t\tmacdarwin=yes\n\tfi\n\tif test x${linux_nrnmech} = x ; then\n\t\tlinux_nrnmech=\"yes\"\n\tfi\n\tif test x${java_dlopen} = x ; then\n\t\tjava_dlopen=\"yes\"\n\tfi\n\tnrndef_mac=\"\"\n\t;;\nesac\n\nif test x${linux_nrnmech} = x ; then\n\t# set even for MINGW\n\tlinux_nrnmech=\"yes\"\nfi\n\nif test x${linux_nrnmech} = xyes ; then\n\tAC_DEFINE(NRNMECH_DLL_STYLE, 1,[if 1 then dlopen nrnmech instead of special])\n\tAC_MSG_NOTICE([Use the NRNMECH_DLL_STYLE for \"special\"])\nelse\n\tAC_MSG_NOTICE([Use the default unix style for \"special\" (not NRNMECH_DLL_STYLE)])\nfi\nAM_CONDITIONAL(NRNMECH_DLL_STYLE, test x${linux_nrnmech} = xyes)\nAM_CONDITIONAL(NRN_BINARY_SPECIAL, test x${linux_nrnmech} != xyes)\nAM_CONDITIONAL(MAC_DARWIN, test x${macdarwin} = xyes)\nAM_CONDITIONAL(USING_CMAKE, false)\n\nif test x${addlibdl} = xyes ; then\n\tLIBS=\"$LIBS -ldl\"\nfi\n\ndnl what to do with the readline library and memacs\nAC_NRN_READLINE\n\ndnl What to do about nrnjava\nAC_NRN_JAVA\n\ndnl CYGWIN or X11. Former takes precedence\nif test \"$CYGWIN\" = \"yes\" ; then\n\tno_x=yes\n\techo \" CYGWIN and no X11 so make MSWwin version\"\n\tbuild_cygwin=yes\n\tAC_DEFINE(CYGWIN,,[define if using cygwin])\n\tif test \"$marshal_dir\" = \"\" ; then\n\t\t#do not change without changing instal.sh and nrnsetup.nsi\n\t\tmarshal_dir=/cygdrive/c/marshalnrn\n\t\tbinsuffix=\"\"\n\tfi\n\tif  test \"$LDFLAGS\" = \"\" ; then\n\t\tLDFLAGS='-Wl,--enable-auto-import'\n\tfi\n\tAC_MSG_NOTICE(['make mswin' will marshal for building the installer in the marshal_dir = $marshal_dir])\n\tAC_SUBST(marshal_dir)\n\tAC_SUBST(binsuffix)\nelif test \"$MINGW\" = \"yes\" ; then\n\tno_x=yes\n\techo \" MINGW and no X11 so make MSWwin version\"\n\tbuild_mingw=yes\n\tAC_DEFINE(MINGW,,[define if using mingw])\n\tif test \"$marshal_dir\" = \"\" ; then\n\t\t#do not change without changing instalmingw.sh\n\t\t# and nrnsetupmingw.nsi\n\t\tif test \"$host_cpu\" = x86_64 ; then\n\t\t\tmarshal_dir='c:/marshalnrn64'\n\t\t\tWIN_MARSHAL_NRN_DIR='c:\\marshalnrn64\\nrn'\n\t\t\tbinsuffix=\"\"\n\t\t\tnrnskip_rebase='#'\n\t\telse\n\t\t\tmarshal_dir='c:/marshalnrn'\n\t\t\tWIN_MARSHAL_NRN_DIR='c:\\marshalnrn\\nrn'\n\t\t\tbinsuffix=\"\"\n\t\tfi\n\tfi\n\tAC_MSG_NOTICE(['make mswin' will marshal for building the installer in the marshal_dir = $marshal_dir])\n\tAC_SUBST(marshal_dir)\n\tAC_SUBST(WIN_MARSHAL_NRN_DIR)\n\tAC_SUBST(binsuffix)\nelif test \"$enable_carbon\" = \"yes\" ; then\n\tno_x=yes\n\techo \"Make the carbon version on max os x\"\n\tAC_DEFINE(carbon,1,[define if using Carbon libraries])\nelse\n\tAC_PATH_XTRA   dnl Find X11.\n\tif test \"$no_x\" = \"\" ; then\n\t\tX_LIBS=\"$X_LIBS -lX11\"\n\tfi\nfi\nAC_SUBST(enable_carbon)\nAC_SUBST(nrnskip_rebase)\n\ndnl Real time dynamic clamp\nAC_NRN_REALTIME\n\ndnl Contributions by collaborators\nif test \"$enable_MikeNeubig\" = \"yes\" ; then\n AC_DEFINE(MikeNeubig,1,[define if using Mike Neubig <neubig@salk.edu> contributions])\nfi\n\ndnl Checks for header files.\nAC_HEADER_DIRENT\nAC_HEADER_STDC\nAC_HEADER_SYS_WAIT\nAC_CHECK_HEADERS(fcntl.h limits.h malloc.h sgtty.h strings.h sys/file.h)\nAC_CHECK_HEADERS(sys/ioctl.h sys/time.h termio.h unistd.h stdarg.h varargs.h)\nAC_CHECK_HEADERS(stropts.h sys/conf.h locale.h fenv.h pthread.h)\n\ndnl but sometimes pthreads does not work so we use USE_PTHREAD\nif test \"$use_pthread\" != \"no\" ; then\nAC_TRY_COMPILE(\n\t[#include <pthread.h>],\n\t[\n\t\tpthread_cond_t cond;\n\t\tpthread_cond_init(&cond, (void*)0);\n\t],\n\tNRN_DEFINE(USE_PTHREAD,1,[Configure with use_pthead=no if you have pthread but do not want to use it])\n\t\tAC_MSG_NOTICE([Using pthreads.])\n\t,\n\tAC_MSG_NOTICE([Have pthread.h but not using threads.])\n)\ndnl here is a better way\nACX_PTHREAD([\n\tAC_MSG_NOTICE([successful.])\n\techo \"PTHREAD_LIBS=$PTHREAD_LIBS\"\n\techo \"PTHREAD_CFLAGS=$PTHREAD_CFLAGS\"\n\techo \"PTHREAD_CC=$PTHREAD_CC\"\n],[\n\tAC_MSG_NOTICE([did not succeed.])\n])\nfi\n\nAC_CHECK_HEADERS(float.h math.h)\nAC_DEFINE(SUNDIALS_DOUBLE_PRECISION, 1, [Define SUNDIALS data type 'realtype' as 'long double'])\nAC_DEFINE(SUNDIALS_USE_GENERIC_MATH, 1, [Use generic math functions])\n\nAC_LANG_PUSH([C++])\nAC_CHECK_HEADERS(stream.h)\nAC_LANG_POP([])\n\ndnl Checks for typedefs, structures, and compiler characteristics.\nAC_TYPE_OFF_T\nAC_TYPE_PID_T\nAC_TYPE_SIZE_T\nm4_pattern_allow([^AC_TYPE_INT32_T$])\nm4_pattern_allow([^AC_TYPE_UINT32_T$])\nAC_TYPE_INT64_T\n\ndnl This causes a warning message from automake and autoconf because, I\ndnl suppose, it hasn't been updated.  There's nothing that can be done about\ndnl this except to fix autoconf, since it comes from the autoconf distribution.\nAC_C_BIGENDIAN\n\nAC_HEADER_TIME\nAC_STRUCT_TM\n\ndnl Checks for library functions.\nAC_FUNC_ALLOCA\nAC_FUNC_MEMCMP\nAC_TYPE_SIGNAL\nAC_FUNC_VPRINTF\nAC_CHECK_FUNCS(ftime getcwd getpw gethostname gettimeofday mkdir putenv setenv select strdup strstr index bzero bcopy stty lockf isatty mkstemp)\nAC_CHECK_FUNCS(setitimer sigaction fesetround posix_memalign mallinfo realpath)\nNRN_CHECK_SIGNAL(SIGBUS)\nNRN_CHECK_SIGNAL(SIGSEGV)\ndnl Do this after the above checks, so they're run with the C compiler rather\ndnl than the C++ compiler.  This is only a problem with complex.h, which\ndnl always exists for the C++ compilers but meschach needs it for a C\ndnl compiler.\nAC_PROG_CXX\nAC_CHECK_HEADERS(_G_config.h)\n\ndnl std::fabs or ::fabs or explicitly declare\nNRN_FABS\n\ndnl Check for interviews.  If --with-iv=dir is specified, then \nAC_NRN_InterViews\n\n\nif test \"$nrndef_mac\" = \"//\" -a \"$nrndef_mswin\" = \"//\" ; then\n\tnrndef_unix=\"\"\nfi\n\ndnl put back the flags if mingw\nif test \"$CYGWIN\" = \"yes\" ; then\n\tif test \"$ac_nrn_cygwin\" = no ; then\n\t\tCFLAGS=\"$mlh_CFLAGS\"\n\t\tCXXFLAGS=\"$mlh_CXXFLAGS\"\n\tfi\nfi\n\ncase \"$exec_prefix\" in\n\tNONE*)  exec_prefix=\"${prefix}/${host_cpu}\"\n\t;;\nesac\n\ndnl allow the nrnivmodl created subfolder to be explicitly specified\nif test \"$modsubdir\" = \"\" ; then\n\tmodsubdir=$host_cpu\nfi\nAC_SUBST(modsubdir)\n\nAC_DEFINE_UNQUOTED(NRNHOSTCPU,\"$host_cpu\",[cpu type consistent with nrnivmodl])\nNRN_LIBDIR=$exec_prefix/lib\nAC_SUBST(NRN_LIBDIR)\nAC_DEFINE_UNQUOTED(NRN_LIBDIR,\"$NRN_LIBDIR\",[location of NEURON libraries])\n\nAC_SUBST(nrndef_unix)\nAC_SUBST(nrndef_mac)\nAC_SUBST(nrndef_mswin)\n\nAM_CONDITIONAL(BUILD_READLINE, test x$build_readline = xyes)\nAM_CONDITIONAL(BUILD_NRNJAVA, test x$build_nrnjava = xyes)\nAM_CONDITIONAL(BUILD_NRNIV, test x$build_nrniv = xyes)\nAM_CONDITIONAL(BUILD_IVOS, test x$use_ivos = xyes)\nAM_CONDITIONAL(BUILD_PARANEURON, test x$use_paranrn = xyes)\nAM_CONDITIONAL(BUILD_NRNMPI_DYNAMIC, test x$nrnmpi_dynamic = xyes)\nAM_CONDITIONAL(BUILD_CYGWIN, test x$build_cygwin = xyes)\nAM_CONDITIONAL(BUILD_MINGW, test x$build_mingw = xyes)\nAM_CONDITIONAL(BUILD_NRNPYTHON, test x$build_nrnpython = xyes)\nAM_CONDITIONAL(BUILD_NRNPYTHON_DYNAMIC, test x$build_nrnpython_dynamic = xyes)\n\ndnl special problem work arounds\nAC_NRN_ODDITIES\n\ndnl some configuration checking for ParallelContext\nAC_NRN_ParallelContext\n\ndnl This, in conjunction with a line in acconfig.h, causes the preprocessor\ndnl symbol NEURON_DATA_DIR to point to the neuron data directory.\nAC_DEFINE_UNQUOTED(NEURON_DATA_DIR, \"$prefix/share/$PACKAGE\", where the lib hoc is)\nAC_DEFINE_UNQUOTED(NRNHOST, \"$host\", host triplet)\n\nNRN_DEFINE_UNQUOTED(NRN_CONFIG_ARGS, \"${ac_configure_args}\", args given to configure)\n\nNRNOC_X11=1\nif test \"$with_nrnoc_x11\" = \"\" ; then\n\twith_nrnoc_x11=yes\nfi\n\nAC_ARG_WITH(nrnoc-x11,\nAC_HELP_STRING([--with-nrnoc-x11],[This is the default\n                                Add the x11 window code to NRNOC to allow\n                                the old style x11 window for plot, axis, etc.])\nAC_HELP_STRING([--without-nrnoc-x11],[Do not compile the old style nrnoc x11 window])\n,[\n\tif test \"$with_nrnoc_x11\" = \"no\" ; then\n\t\tNRNOC_X11=0\n\tfi\n])\nif test \"$no_x\" = \"yes\" ; then\n\tNRNOC_X11=0\nfi\necho \"NRNOC_X11 = $NRNOC_X11\"\nAC_DEFINE_UNQUOTED(NRNOC_X11,$NRNOC_X11, if nrnoc can use X11)\n\ndnl Use legacy values for FARADAY and R, or 2019 NIST values?\nAC_ARG_ENABLE([LegacyFR],\n\tAC_HELP_STRING([--enable-LegacyFR], [Use legacy instead of NIST (as of 2019) values for FARADAY and gas constant R. (default is legacy enabled)]),[\n\tif test \"$enable_LegacyFR\" != \"yes\" ; then\n\t\tenable_LegacyFR=\"no\"\n\tfi\n],[\n\tenable_LegacyFR=\"yes\"\n])\nif test \"$enable_LegacyFR\" = \"yes\" ; then\n\tLegacyY=\"\"\n\tLegacyN=\"/\"\n\tLegacyNPy=\"#\"\n\tLegacyYPy=\"\"\n\tLegacyFR=1\n\tAC_DEFINE_UNQUOTED(LegacyFR,1,[1 for legacy, undef for NIST (as of 2019), for FARADAY and R])\nelse\n\tLegacyY=\"/\"\n\tLegacyN=\"\"\n\tLegacyNPy=\"\"\n\tLegacyYPy=\"#\"\nfi\nAC_SUBST(LegacyY)\nAC_SUBST(LegacyN)\nAC_SUBST(LegacyYPy)\nAC_SUBST(LegacyNPy)\n\ndnl This list specifies what files configure actually makes.\nAC_CONFIG_FILES([\n\tMakefile src/Makefile\n])\nif test \"$nmodl_build\" = \"yes\" ; then\nAC_CONFIG_HEADERS([nmodlconf.h])\nAC_CONFIG_FILES([\n\tsrc/modlunit/Makefile src/nmodl/Makefile\n\tshare/lib/nrnunits.lib\n])\nfi\t\n\nif test \"$with_nmodl_only\" != \"yes\"; then\nAC_CONFIG_HEADERS([\n\tsrc/nrnpython/nrnpython_config.h\n])\nAC_CONFIG_FILES([\n\tbin/nrndiagnose.sh\n\tsrc/nrnpython/Makefile\n\tsrc/mswin/nrncygso.sh\n\tsrc/nrnpython/setup.py\n\tshare/lib/python/neuron/rxd/geometry3d/Makefile\n        share/lib/python/neuron/rxd/geometry3d/setup.py\n])\nfi\t\n\n\nif test \"$with_nmodl_only\" != \"yes\" -a \"$with_nrnpython_only\" != \"yes\" ; then\nAC_CONFIG_HEADERS([nrnconf.h])\nAC_CONFIG_HEADERS([src/nrnoc/nrnconfigargs.h])\nAC_CONFIG_HEADERS([src/oc/nrnmpiuse.h])\nAC_CONFIG_HEADERS([src/oc/nrnrtuse.h])\nAC_CONFIG_HEADERS([src/oc/nrnpthread.h])\nAC_CONFIG_HEADERS([src/parallel/bbsconf.h])\nAC_CONFIG_HEADERS([src/nrnjava/njconf.h])\nAC_CONFIG_HEADERS([src/nrncvode/nrnneosm.h])\nAC_CONFIG_HEADERS([src/sundials/sundials_config.h])\n\nAC_CONFIG_FILES([\n\tnrnrpm.spec\n\tsrc/sundials/Makefile src/sundials/shared/Makefile\n\tsrc/sundials/cvodes/Makefile src/sundials/ida/Makefile\n\tsrc/sparse/Makefile src/memacs/Makefile\n\tsrc/readline/Makefile src/sparse13/Makefile src/Random123/Makefile\n\tsrc/oc/Makefile\tsrc/scopmath/Makefile src/nrnoc/Makefile\n\tsrc/gnu/Makefile src/uxnrnbbs/Makefile src/mesch/Makefile\n\tsrc/uxnrnbbs/mos2nrn.h src/nrnmpi/Makefile\n\tsrc/ivoc/Makefile src/nrncvode/Makefile src/parallel/Makefile src/nrniv/Makefile\n\tsrc/ivos/Makefile src/ivos/InterViews/Makefile src/ivos/OS/Makefile\n\tsrc/nrnjava/Makefile src/nrnjava/nrnccmb/Makefile\n\tsrc/nrnjava/neuron/Makefile\n\tsrc/ni_pci_6229/Makefile\n\tsrc/mac/Makefile src/mswin/Makefile src/mswin/batch/Makefile\n\tsrc/mac/macdist.pkgproj src/mac/postinstall.sh\n\tsrc/mswin/nrnsetup.nsi src/mswin/lib/mknrndll.mak\n\tsrc/mswin/nrnsetupmingw.nsi\n\tsrc/mswin/extra/Makefile src/mswin/rdln/Makefile\n\tsrc/mswin/windll/Makefile\n\tsrc/mswin/wnrnbbs/Makefile src/mswin/lib/Makefile\n\tsrc/mswin/bin/Makefile src/neuronmusic/Makefile src/neuronmusic/setup.py\n\tshare/Makefile bin/nrnoc_makefile bin/nrniv_makefile bin/nrnmech_makefile\n\tshare/lib/Makefile share/lib/hoc/Makefile share/lib/python/Makefile\n\tshare/lib/hoc/celbild/Makefile share/lib/hoc/mulfit/Makefile\n\tshare/lib/hoc/netbild/Makefile share/lib/hoc/lincir/Makefile\n\tshare/lib/hoc/mview/Makefile share/lib/hoc/chanbild/Makefile\n\tshare/lib/hoc/import3d/Makefile\n\tshare/lib/auditscripts/Makefile\n\tshare/lib/nrn.defaults\n\tbin/Makefile bin/nrnocmodl bin/nrnivmodl bin/neurondemo\n\tbin/nrngui bin/bbswork.sh\n\tbin/mos2nrn2.sh bin/hel2mos1.sh\n\tshare/examples/Makefile share/examples/ivoc/Makefile\n\tshare/examples/nrniv/Makefile share/examples/nrniv/cable/Makefile\n\tshare/examples/nrniv/kkin/Makefile share/examples/nrniv/netcon/Makefile\n\tshare/examples/nrniv/netsyn/Makefile share/examples/nrniv/nmodl/Makefile\n\tshare/examples/nrniv/nrnoc/Makefile share/examples/nrniv/randomsyn/Makefile\n\tshare/examples/nrniv/soma/Makefile share/examples/nrniv/vrecorder/Makefile\n\tshare/examples/nrniv/xmech/Makefile\n\tshare/demo/Makefile share/demo/release/Makefile share/demo/dend3/Makefile\n\tshare/demo/sync/Makefile\n\tshare/lib/python/neuron/Makefile\n\tshare/lib/python/neuron/rxd/Makefile\n\tshare/lib/python/neuron/crxd/Makefile\n\tshare/lib/python/neuron/rxd/constants.py\n\t])\nfi\n\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/bin/nrnmech_makefile.in": "#\n# This makefile has the rules necessary for making a nrnmech library that\n# can be dlopen'd from nrniv.\n# The variable \"MODOBJFILES\" should\n# be set on the command line to list the .o files that are needed.\n\nincludedir = $(prefix)/include\ndatadir = $(prefix)/share\npkgdatadir = $(datadir)/@PACKAGE@\npkglibdir = $(libdir)/@PACKAGE@\npkgincludedir = $(includedir)/@PACKAGE@\nlibobjdir = $(libdir)\n\nDEFS = @DEFS@\nLDFLAGS = $(UserLDFLAGS) @LDFLAGS@\nLIBS = @LIBS@\nX_CFLAGS = @X_CFLAGS@\nX_LIBS = @X_LIBS@\nX_EXTRA_LIBS = @X_EXTRA_LIBS@\nX_PRE_LIBS = @X_PRE_LIBS@\n#IV_LIBS = @IV_LIBS_LIBTOOL@ $(X_PRE_LIBS) $(X_LIBS) $(X_EXTRA_LIBS)\nIV_LIBS =\nIVOS_LIB = @IVOS_LIB@\nPVM_LIBS = @PVM_LIBS@ @PVM_XTRA_LIBS@\nNJ_LIBS = @NRNJAVA_LIBS@\n#PY_LIBS = @NRNPYTHON_LIBS@\nPY_LIBS =\nNRNNI_LIBS = @NRNNI_LIBS@\n\nINCLUDES = -I. -I.. -I\"$(pkgincludedir)\" -I\"$(libdir)\" $(UserINCFLAGS) \n\nLIBTOOL = \"$(pkgdatadir)/libtool\" @LIBTOOLTAG@\nCC = @CC@\nCFLAGS = @CFLAGS@\n\nCOMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n        $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\nLTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) \\\n        $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\nCCLD = $(CC)\nLINK = $(LIBTOOL) --mode=link $(CCLD) -module $(AM_CFLAGS) $(CFLAGS) \\\n        $(AM_LDFLAGS) $(LDFLAGS) -o $@\n\n@BUILD_NRNMPI_DYNAMIC_TRUE@lnrnmpi =\n@BUILD_NRNMPI_DYNAMIC_FALSE@lnrnmpi = -lnrnmpi\n\nNRNOCLIBS = -L\"$(libdir)\" -lnrnoc -loc @MEMACSLIB@ \\\n\t$(lnrnmpi) -lscopmath -lsparse13 @READLINE_LIBS@\nNRNIVLIBS = -L\"$(libdir)\" -lnrniv -livoc \\\n\t-lneuron_gnu -lmeschach -lsundials \\\n\t$(IVOS_LIB) $(IV_LIBS) $(NJ_LIBS) $(PY_LIBS) $(NRNNI_LIBS) $(PVM_LIBS)\n\nNRNOCOBJS = \"$(libobjdir)/ocmain.o\" \"$(libobjdir)/nrnnoiv.o\" \"$(libobjdir)/ocnoiv.o\"\nNRNIVOBJS = \"$(libobjdir)/nrnmain.o\" \"$(libobjdir)/ivocmain.o\" \"$(libobjdir)/nvkludge.o\"\n\n.SUFFIXES:\n\n.SUFFIXES: .c .mod .lo\n#\n# How to make a .o file from a .mod file.  Note that we have to delete the\n# .c file, or else make will get confused.  We have to go directly from\n# a .mod to a .o file because otherwise GNU make will try to use a rule\n# involving m2c.  Argh!!  Why did they have to build in so many implicit\n# rules?\n# \n#.mod.o:\n#\t$(bindir)/nocmodl $* || (rm -f $*.c; exit 1)\n#\t$(COMPILE) -c $*.c\n#\trm -f $*.c\n#\n# some experimentation gave promising results for the following.\n# it remains to be seen how portable it is. It seems to work\n# for gnu make and the /usr/ccs/bin/make distributed with solaris.\n\n#%.o : %.mod\n\n.mod.c:\n\t\"$(bindir)/nocmodl\" $*\n\t\n.c.lo:\n\t$(LTCOMPILE) -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<\n\n.mod.lo:\n\t\"$(bindir)/nocmodl\" $*\n\t$(LTCOMPILE) -c -o $@ $*.c\n\nmod_func.lo: mod_func.c\n\t$(LTCOMPILE) -c -o $@ $*.c\n\nlibnrnmech_la_OBJECTS = $(MODOBJFILES) mod_func.lo $(COBJFILES)\nlibnrnmech_la_LIBADD = $(NRNOCLIBS) $(NRNIVLIBS)\n\nlibnrnmech.la: $(libnrnmech_la_OBJECTS) $(libnrnmech_la_DEPENDENCIES)\n\t$(LINK) -rpath \"$(libdir)\" $(libnrnmech_la_LDFLAGS) $(libnrnmech_la_OBJECTS) $(libnrnmech_la_LIBADD) $(LIBS)\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/nrnpython/setup.py.in": "#setup.py\nfrom distutils.core import setup, Extension\nfrom distutils.sysconfig import get_python_version\n\nimport sys\nimport os\n\n@USING_CMAKE_TRUE@using_cmake=True\n@USING_CMAKE_FALSE@using_cmake=False\n@USING_PGI_COMPILER_TRUE@using_pgi=True\n@USING_PGI_COMPILER_FALSE@using_pgi=False\n@BUILD_MINGW_TRUE@mingw = 1\n@BUILD_MINGW_FALSE@mingw = 0\n\n# TODO temporary workaround for mingw + cmake\n# When running with mingw-cmake, the path of the form C:/msys64/xyz\n# needs to be transformed to C:\\msys64/xyz.\ndef get_escaped_path(path):\n  if using_cmake and mingw:\n    return path.replace(\":/\", \":\\\\\")\n  else:\n    return path\n\n# NRNPYTHON_DEFINES which were enabled at configure time\nextern_defines = \"@NRNPYTHON_DEFINES@\"\nnrnpython_exec = get_escaped_path(\"@NRNPYTHON_EXEC@\")\nnrnpython_pyver = \"@NRNPYTHON_PYVER@\"\nnrnpython_pyver10 = \"nrnpython\"\n@USING_CMAKE_TRUE@use_libnrnpython_majorminor = @USE_LIBNRNPYTHON_MAJORMINOR@\nnrn_srcdir = get_escaped_path(\"@NRN_SRCDIR@\")\nbuild_rx3d = @BUILD_RX3D@\nivlibdir = get_escaped_path(\"@IV_LIBDIR@\")\nif ivlibdir == \"\" :\n    ivlibdir = '.'\n\ndestdir = os.getenv(\"DESTDIR\")\nif not destdir:\n  destdir = \"\"\n\n# autoconf install module in install prefix for cmake we install\n# into build directory and then copy to install prefix\n@USING_CMAKE_FALSE@instdir = destdir + get_escaped_path(\"@prefix@\")\n@USING_CMAKE_TRUE@instdir = destdir + get_escaped_path(\"@CMAKE_BINARY_DIR@\")\n\nif nrn_srcdir[0] != '/' :\n  if using_cmake and mingw:\n    nrn_srcdir = nrn_srcdir\n  else:\n    nrn_srcdir = '../../' + nrn_srcdir\n\nif using_cmake and \"@BUILD_NRNPYTHON_DYNAMIC_TRUE@\" == \"\":\n  # can do all the setup.py without re-configure.\n  nrnpython_pyver = get_python_version()\n  nrnpython_exec = sys.executable\n  nrnpython_pyver10 = \"nrnpython\" + str(sys.version_info[0])\n  if use_libnrnpython_majorminor == 1:\n    nrnpython_pyver10 = \"nrnpython\" + str(sys.version_info[0]) + str(sys.version_info[1])\n\nelse:\n  if nrnpython_pyver!=get_python_version():\n    print (\"Error:\")\n    print (\"NEURON configure time python: \"+nrnpython_exec+\"  \"+ nrnpython_pyver)\n    print (\"Python presently executing setup.py: \"+sys.executable+\"   \"+ get_python_version())\n    print (\"These do not match, and they should!\")\n    sys.exit(1)\n\n\nldefs = extern_defines.split('-D')\n\n# if using MPI then at least for linking need special paths and libraries\nmpicc_bin = get_escaped_path(\"@CC@\")\nmpicxx_bin = get_escaped_path(\"@CXX@\")\nimport os\nif using_pgi:\n  os.environ[\"CC\"]=mpicxx_bin\nelse:\n  os.environ[\"CC\"]=mpicc_bin\n\nos.environ[\"CXX\"]=mpicxx_bin\n\n# apparently we do not need the following\n#################################\n## following http://code.google.com/p/maroonmpi/wiki/Installation\n## hack into distutils to replace the compiler in \"linker_so\" with mpicxx_bin\n#\n#import distutils\n#import distutils.unixccompiler\n#\n#class MPI_UnixCCompiler(distutils.unixccompiler.UnixCCompiler):\n#    __set_executable = distutils.unixccompiler.UnixCCompiler.set_executable\n#\n#    def set_executable(self,key,value):\n#\tprint \"MPI_UnixCCompiler \", key, \" | \", value\n#        if key == 'linker_so' and type(value) == str:\n#            value = mpicxx_bin + ' ' + ' '.join(value.split()[1:])\n#\n#        return self.__set_executable(key,value)\n#    \n#distutils.unixccompiler.UnixCCompiler = MPI_UnixCCompiler\n#################################\n\n#include_dirs for hoc module\ninclude_dirs = [nrn_srcdir+'/src/oc', '../oc', nrn_srcdir+'/src/nrnmpi']\n#include dirs for all modules\n\ninclude_dirs_common = []\n\n#not needed with clang,clang++ and on my beta catalina does not\n#work anyway with /Library/Developer/CommandLineTools/usr/bin/cc\n#for the ctng module\n#@MAC_DARWIN_TRUE@include_dirs_common.append(\"@CMAKE_OSX_SYSROOT@/usr/include\")\n\ndefines = []\nif using_cmake:\n    defines.append((\"NRNCMAKE\", \"1\"))\n\nlibdirs = [destdir + get_escaped_path(\"@NRN_LIBDIR@\"),\n  ivlibdir\n]\n\n# prepare rpath flags for neuron and iv libs directories\nrpath_prefix_flag='-Wl,-R'\nextra_rpath_flags = [rpath_prefix_flag+lib_path for lib_path in libdirs]\n\n# as neuron module will be built during make, add build/lib\n# directory for linking. Note that build/lib shouldn't be\n# added to rpath to avoid issues with dlopen.\n@USING_CMAKE_TRUE@libdirs.append(destdir + get_escaped_path(\"@CMAKE_BINARY_DIR@/lib\"))\n\n@MAC_DARWIN_FALSE@readline=\"readline@READLINE_SOSUFFIX@\"\n@MAC_DARWIN_TRUE@readline=\"readline@READLINE_SOSUFFIX@\"\n\npgi_compiler_flags = \"-noswitcherror\"\n\nextra_link_args = []\nif using_cmake:\n  libs = [@BUILD_NRNPYTHON_DYNAMIC_TRUE@nrnpython_pyver10,\n    \"nrniv\"\n  ]\n  if \"@IVHINES@\" != \"\":\n    libs.append(\"@IVHINES@\")\n  extra_link_args.append(\"-Wl,-rpath,@loader_path/../../\")\n  extra_link_args.append(\"-Wl,-rpath,%s\" % ivlibdir)\n\nextra_compile_args = []\n\nif using_pgi:\n  extra_link_args.append(pgi_compiler_flags)\n  extra_rpath_flags.append(pgi_compiler_flags)\n  extra_compile_args.append(pgi_compiler_flags)\n\nhoc_module = Extension(\n    \"neuron.hoc\",\n    [\"inithoc.cpp\"],\n    library_dirs=libdirs,\n    @MAC_DARWIN_TRUE@extra_link_args = extra_link_args,\n    @setup_extra_link_args@ = extra_rpath_flags,\n    #extra_objects = [],\n    extra_compile_args = extra_compile_args,\n    libraries = libs if using_cmake else [\n        \"nrnpython@npy_pyver10@\",\n        \"nrnoc\", \"oc\", \"nrniv\", \"ivoc\",\n        @BUILD_MEMACS_TRUE@\"memacs\", readline,\n        \"meschach\", \"neuron_gnu\",\n        @BUILD_NRNMPI_DYNAMIC_FALSE@\"nrnmpi\",\n        \"scopmath\", \"sparse13\", \"sundials\",\n        \"@IVHINES@\",\n      ],\n      include_dirs = include_dirs+include_dirs_common,\n      define_macros=defines\n    )\n\n# specify that the data_files paths are relative to same place as python files\n# from http://stackoverflow.com/questions/1612733/including-non-python-files-with-setup-py\nfrom distutils.command.install import INSTALL_SCHEMES\nfor scheme in list(INSTALL_SCHEMES.values()):\n    scheme['data'] = scheme['purelib']\n\next_modules = [hoc_module]\n\n# The rx3d extensions are built using the setup.py.in in\n# nrn/share/lib/python/neuron/rxd/geometry3d which contains Cython pyx files\n# These files on Windows have to be compiled with the msvc compiler to avoid\n# issues with hypot, a #define, and some DL_IMPORT statements. At least for\n# Python3.5, the module must be built with the msvc toolchain to prevent a\n# crash, possibly due to incompatible c runtime libraries. The following\n# section is left here with the idea that someday the entire build on windows\n# may be done with the msvc toolchain. Note, although the extensions are not\n# built here, the python files are copied because of the call to setup here.\n\nif not using_cmake and build_rx3d:\n  try:\n    import numpy\n    # TODO: do we need to use os.path.join?\n    src_path = nrn_srcdir + '/share/lib/python/neuron/rxd/geometry3d/'\n    build_path = '../../share/lib/python/neuron/rxd/geometry3d/'\n    include_dirs = [nrn_srcdir + '/share/lib/python/neuron/rxd/geometry3d', '.', numpy.get_include()]\n    include_dirs += include_dirs_common\n    extra_compile_args=[\"-O0\"] # minimize compile time\n    if using_cmake:\n      extra_compile_args=[\"-O@NRN_RX3D_OPT_LEVEL@\"]\n    if using_pgi:\n      extra_compile_args.append(pgi_compiler_flags)\n    define_macros = []\n    if mingw:\n      #Avoid undefined __imp_Py_InitModule4 and hypot problem\n      define_macros.append((\"MS_WIN64\", None))\n    ext_modules=[hoc_module,\n                   Extension(\"neuron.rxd.geometry3d.graphicsPrimitives\",\n                             sources=[build_path + \"graphicsPrimitives.cpp\"],\n                             extra_compile_args = extra_compile_args,\n                             define_macros = define_macros,\n                             include_dirs=include_dirs),\n                   Extension(\"neuron.rxd.geometry3d.ctng\",\n                             sources=[build_path + \"ctng.cpp\"],\n                             extra_compile_args = extra_compile_args,\n                             define_macros = define_macros,\n                             include_dirs=include_dirs),\n                   Extension(\"neuron.rxd.geometry3d.surfaces\",\n                             sources=[build_path + \"surfaces.cpp\", nrn_srcdir + \"/src/nrnpython/rxd_marching_cubes.c\", nrn_srcdir + \"/src/nrnpython/rxd_llgramarea.c\"],\n                             define_macros = define_macros,\n                             extra_compile_args = extra_compile_args,\n                             include_dirs=include_dirs)]\n  except:\n    pass\n\npackages=['neuron','neuron.neuroml','neuron.tests', 'neuron.rxd', 'neuron.crxd', 'neuron.gui2']\nif build_rx3d:\n  packages +=['neuron.rxd.geometry3d']\n\nsetup(name=\"NEURON\", version=\"@PACKAGE_VERSION@\",\n      description = \"NEURON bindings for python\",\n      package_dir = {'':instdir+('/lib/python' if 'win32' in sys.platform else '/share/nrn/lib/python')},\n      packages=packages,\n      data_files = [('neuron', [nrn_srcdir + '/share/lib/python/neuron/help_data.dat'])],\n      ext_modules=ext_modules\n)\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/nrnjava/njconf.h.in": "#ifndef njconf_h\n\n/* define to 1 if want to use the Java virtual machine in NEURON */\n#undef USENRNJAVA\n\n/* define to 1 if version 0x00010001, 2 if JNI_VERSION_1_2 */\n#undef USEJVM\n\n/* define to 1 if have locale.h */\n#undef HAVE_LOCALE_H\n\n/* if defined then try to dlopen the jvm */\n#undef JVM_DLOPEN\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/nrnjava/njvm.cpp": "/*\n March 2001 modified by Michael Hines so that NEURON starts\n\tthe Java VM\n*/\n\n// nj_load() supports the load_java hoc command\n\n// nrn_InitializeJavaVM makes the Java virtual machine ready for use\n// this is done from ivocmain.cpp shortly after NEURON is launched.\n// Initializing just before the first load_java command did not work.\n// Mac and MSWIN dynamically load the jvm. \n\n#include <../../nrnconf.h>\n#ifdef WIN32\n#include <windows.h>\n#endif\n\n#include \"njconf.h\" // which jvm version to use\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <jni.h>\n#include <InterViews/resource.h>\n#include \"nrnoc2iv.h\"\n#include \"njvm.h\"\n#if HAVE_LOCALE_H\n// Java may set the locale so sprint(buf, \"%g\", 1.5) gives \"1,5\"\n// if so we will need to set it back.\n#include <locale.h>\n#endif\n#if defined(JVM_DLOPEN)\n#include <dlfcn.h>\njint nrn_CreateJavaVM(JavaVM **pvm, void **penv, void *args);\n#endif\n\n// Java virtual machine version\n// The Mac only has Java 1 via the MRJ. No reason not to always use\n// Java2 for mswin. Unix can use either (see njconf.h.in)\n// However, only Java2 is fully supported and allows additions to\n// the classpath from hoc.\n#if carbon\n#undef MAC\n#endif\n\n#ifndef USEJVM\n#if MAC\n#define USEJVM 1\n#else\n#define USEJVM 2\n#endif\n#endif\n\nextern \"C\" {\n// Java has threads and NEURON does not. It is important that when\n// Java calls a function in NEURON and then NEURON calls back a function\n// in Java that the proper thread environment is used. This is done\n// with the njvm.h macros jnisave and jnirestore that put the env into nrnjava_env\n// How are errors handled?\nJNIEnv* nrnjava_env;\nJNIEnv* nrnjava_root_env;\nJavaVM* nrnjava_vm; // CreateJavaVM fills this in but we do not use it.\nextern char* neuron_home;\nextern int(*p_hoc_load_java)();\nstatic int nj_load();\nextern void* (*p_java2nrn_cons)(Object*);\n\n#ifdef WIN32\n#undef _WIN32\n#define _WIN32\n#endif\n#ifdef _WIN32\nchar* hoc_back2forward(char*);\njint nrn_CreateJavaVM(JavaVM **pvm, void **penv, void *args);\n#endif\n#if MAC\nstatic jint nrn_GetDefaultJavaVMInitArgs(void*);\nstatic jint nrn_CreateJavaVM(JavaVM **pvm, JNIEnv **penv, void *args);\n#endif\n}\nint convertJavaClassToHoc(JNIEnv*, const char*, const char*, const char*);\nvoid nrnjava_init();\n\n#ifdef _WIN32\n#define PATH_SEPARATOR ';'\n#else /* UNIX */\n#define PATH_SEPARATOR ':'\n#endif\n\n#define NULL_CHECK(arg) nrn_assert((arg))\n#if USEJVM == 2\n/*\n * List of VM options to be specified when the VM is created.\n */\nstatic JavaVMOption *options;\nstatic int numOptions, maxOptions;\n#endif\n\nextern \"C\" { // needed by microsoft visual c++\n// support load_java command in hoc.\n// e.g. load_java(\"java.lang.String\", \"JString\")\n// p_hoc_load_java points to this\nstatic int nj_load() {\n\t// first time through, initialize\n\tif (!p_java2nrn_cons) {\n\t\tif (!nrnjava_root_env) {\n\t\t\thoc_execerror(\"The JavaVM is not available.\", 0);\n\t\t}\n\t\tnrnjava_init();\n\t\tif (!p_java2nrn_cons) {\n\t\t\thoc_execerror(\" Java portion of NEURON was not initialized.\", 0);\n\t\t}\n\t}\n\tchar* jname; // fully qualified name. e.g. java.lang.String\n\tchar* hname; // hoc name, e.g. JString\n\tchar* path = \"\"; // classpath addition to find jname. See NrnClassLoader.add\n\n\tjname = gargstr(1);\n\t// hocname same as jname if not specified as second arg\n\tif (ifarg(2)) {\n\t\thname = gargstr(2);\n\t}else{\n\t\thname = jname;\n\t}\n\tif (ifarg(3)) {\n\t\tpath = gargstr(3);\n\t}\n\t// see neuron/Neuron.java makeHocClass\n\treturn convertJavaClassToHoc(nrnjava_env, jname, hname, path);\n}\n}\n\n#if USEJVM == 2\n// copied from /usr/j2se/src.jar : src/launcher/java.c\n/*\n * Adds a new VM option with the given given name and value.\n */\nstatic void\nAddOption(char *str, void *info)\n{\n\tint i;\n    /*\n     * Expand options array if needed to accomodate at least one more\n     * VM option.\n     */\n    if (numOptions >= maxOptions) {\n\tif (options == 0) {\n\t    maxOptions = 4;\n\t    options = new JavaVMOption[maxOptions];\n\t} else {\n\t    JavaVMOption *tmp;\n\t    tmp = new JavaVMOption[maxOptions*2];\n\t    for (i=0; i < numOptions; ++i) {\n\t\ttmp[i].optionString = options[i].optionString;\n\t\ttmp[i].extraInfo = options[i].extraInfo;\n\t    }\n\t    maxOptions *= 2;\n\t    delete [] options;\n\t    options = tmp;\n\t}\n    }\n    options[numOptions].optionString = str;\n    options[numOptions++].extraInfo = info;\n}\n#endif\n\n// copied from /usr/j2se/src.jar : src/launcher/java.c\n/*\n * Prints the version information from the java.version and other properties.\n */\n\nstatic void\nPrintJavaVersion(JNIEnv *env)\n{\n    jclass ver;\n    jmethodID print;\n\n    NULL_CHECK(ver = (env)->FindClass(\"sun/misc/Version\"));\n    NULL_CHECK(print = (env)->GetStaticMethodID(ver, \"print\", \"()V\"));\n\n    (env)->CallStaticVoidMethod(ver, print);\n}\n\nstatic void myabort() {\n\tprintf(\"my abort\\n\");\n\texit(1);\n}\n\nstatic void myexit() {\n\tprintf(\"my exit\\n\");\n\texit(1);\n}\n\njint myvfprintf(FILE* fp, const char* format, va_list args);\n\njint myvfprintf(FILE* fp, const char* format, va_list args) {\n\tchar buf[1024];\n\tvsprintf(buf, format, args);\n\tprintf(\"%s\", buf);\n\treturn 1;\n}\n\n#if USEJVM == 1\n// allowing Mac classic dlopen and Unix static\nstatic void initialize_jvm1();\nstatic void initialize_jvm1() {\n\tchar* classpath;\n\tJDK1_1InitArgs args;\n\targs.version = 0x00010001;\n\t//args.debugging = 1;\n\t//args.vfprintf = myvfprintf;\n#if MAC\n\tif (nrn_GetDefaultJavaVMInitArgs(&args) < 0) {\n\t\treturn;\n\t}\n\tclasspath = new char[strlen(args.classpath) + 2*strlen(neuron_home) + 100];\n\t// following string for mac, then convert ; to :\n\tsprintf(classpath, \"%s;/%s/classes/neuron.jar\",\n\t args.classpath, neuron_home);\n\tfor (char* cp = classpath; *cp; ++cp) {\n\t\tif (*cp == ';') {\n\t\t\t*cp = ':';\n\t\t}else if (*cp == ':') {\n\t\t\t*cp = '/';\n\t\t}\n\t}\n#else\n\tJNI_GetDefaultJavaMVInitArgs(&args);\n\tconst char* ucpenv = getenv(\"CLASSPATH\");\n// Find classes first in the working directory where neuron was launched.\n// Then the users CLASSPATH\n// environment variable (if any). And lastly, the, $NEURONHOME/classes\n\tif (ucpenv == nil) {\n\t\tucpenv = \".\"; // can't hurt to have it twice\n\t}\n\tint len = strlen(args.classpath) + strlen(ucpenv) + 2*strlen(neuron_home) + 100;\n\tclasspath = new char[len];\n\t\t\n\tsprintf(classpath,\n\t\t\"%s%c.%c%s%c%s/classes/neuron.jar\",\n\t\targs.classpath, PATH_SEPARATOR, PATH_SEPARATOR,\n\t\tPATH_SEPARATOR, ucpenv, PATH_SEPARATOR,  neuron_home,\n\t);\n\n//printf(\"%s\\n\", classpath);\n\n\tsprintf(classpath, \"%s:.:%s/classes/neuron.jar\", args.classpath, neuron_home);\n#endif\n\targs.classpath = classpath;\n\t//for (int i = 0;  args.properties[i]; ++i) {\n\t\t//printf(\"properties |%s|\\n\", args.properties[i]);\n\t//}\n\t//args.debugging = 1;\n\t//args.vfprintf = myvfprintf;\n\tprintf(\"classpath |%s|\\n\", args.classpath);\n#if MAC\n\tjint res = nrn_CreateJavaVM(&nrnjava_vm, &nrnjava_root_env, (void*)&args);\n#else\n\tjint res = JNI_CreateJavaVM(&nrnjava_vm, (void**)&nrnjava_root_env, &args);\n#endif\n\tnrnjava_env = nrnjava_root_env;\n\tif (res < 0) {\n\t\tfprintf(stderr, \"JNI_CreateJavaVM returned %d\\n\", res);\n\t}else{\n\t\tp_hoc_load_java = nj_load;\n\t\tfprintf(stderr, \"Created Java VM\\n\");\n\t}\n}\n#endif\n\n#if USEJVM == 2\n// allowing mswin and unix dlopen and unix static\nstatic void initialize_jvm2();\nstatic void initialize_jvm2() {\n\tJavaVMInitArgs args;\n// Because we want to dynamically append to the classpath from hoc\n// we do all class loading through the neuron/NrnClassLoader in order\n// to defeat the security policy.\n\tchar* classpath;\n\tint len = strlen(neuron_home) + 100;\n\tclasspath = new char[len];\n\tsprintf(classpath, \"-Djava.class.path=%s/classes/nrnclsld.jar\",\tneuron_home);\n\n#if defined(_WIN32)\n\thoc_back2forward(classpath);\n#endif\n\n//printf(\"%s\\n\", classpath);\n\n\targs.version = JNI_VERSION_1_2;\n//printf(\"version = %lx\\n\", args.version);\n\t\n\tAddOption(classpath, nil);\n//\tAddOption(\"-verbose\", nil);\n//\tAddOption(\"abort\", myabort);\n//\tAddOption(\"exit\", myexit);\n\targs.nOptions = numOptions;\n\targs.options = options;\n\targs.ignoreUnrecognized = JNI_FALSE;\n\n#if defined(_WIN32) || defined(JVM_DLOPEN)\n\tjint res = nrn_CreateJavaVM(&nrnjava_vm, (void**)&nrnjava_root_env, &args);\n\tif (res == -10) { return; }\n#else\n\tjint res = JNI_CreateJavaVM(&nrnjava_vm, (void**)&nrnjava_root_env, &args);\n#endif\n\tnrnjava_env = nrnjava_root_env;\n\tdelete [] classpath;\n\tdelete [] options;\n\tif (res < 0) {\n\t\tswitch (res) {\n\t\tcase JNI_EVERSION:\n\t\t\tfprintf(stderr, \"JNI Version error. VM is not JNI_VERSION_1_2\\n\");\n\t\t\tbreak;\n\t\tcase JNI_ENOMEM:\n\t\t\tfprintf(stderr, \"Not enough memory\\n\");\n\t\t\tbreak;\n\t\tcase JNI_EINVAL:\n\t\t\tfprintf(stderr, \"invalid arguments\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"JNI_CreateJavaVM returned %d\\n\", res);\n\t\t\tbreak;\n\t\t}\n\t\tfprintf(stderr, \"Info: optional feature Java VM is not present.\\n\");\n\t}else{\n\t\tp_hoc_load_java = nj_load;\n\t\tif (nrn_istty_) {\n\t\t\tfprintf(stderr, \"Created Java VM\\n\");\n\t\t\tPrintJavaVersion(nrnjava_env);\n\t\t}\n\t}\n}\n#endif\n\nvoid nrn_InitializeJavaVM() {\n\tif (nrnjava_root_env) { // hmm. NEURON must have been loaded by java\n\t\tnrnjava_env = nrnjava_root_env;\n\t\tp_hoc_load_java = nj_load;\n\t} else {\n#if USEJVM == 2\n\t\tinitialize_jvm2();\n#else\n\t\tinitialize_jvm1();\n#endif\n\t}\n\n#if HAVE_LOCALE_H\n\t// in case Java set the locale such that the radix is a ',', set it\n\t// back to a '.'\n\tchar radixtest[50];\n\tsprintf(radixtest, \"%g\", 1.5);\n//printf(\"radixtest=|%s|\\n\", radixtest);\n\tif (strchr(radixtest, ',')) {\n\t\tsetlocale(LC_NUMERIC, \"C\");\n//\t\tsprintf(radixtest, \"%g\", 1.5);\n//printf(\"after setlocale(LC_NUMERIC, \\\"C\\\"), radixtest=|%s|\\n\", radixtest);\n\t}\n#endif\n}\n\n#if defined(JVM_DLOPEN)\n\n#include <InterViews/session.h>\n#include <OS/string.h>\n#include <InterViews/style.h>\ntypedef jint(*PCJVM)(JavaVM**, void**, void*);\n\njint nrn_CreateJavaVM(JavaVM **pvm, void **penv, void *args) {\n\tjint res;\n\n\t*pvm = 0;\n\t*penv = 0;\n\tSession* ses = Session::instance();\n\tString str(\"libjvm.so\");\n\tchar* name = \"jvmdll\";\n\tif (ses && !ses->style()->find_attribute(name, str)){\n//\t\tfprintf(stderr, \"\\\"%s\\\" not defined in nrn.defaults\\n\", name);\n\t\treturn -10;\n\t}\n\tvoid* handle = (void *) dlopen(str.string(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tfprintf(stderr, \"dlopen(\\\"%s\\\") failed: %s\\n\", str.string(), dlerror());\n\t\treturn -1;\n\t}\n#if defined(DARWIN)\n\tPCJVM addr = (PCJVM)dlsym(handle, \"JNI_CreateJavaVM_Impl\");\n#else\n\tPCJVM addr = (PCJVM)dlsym(handle, \"JNI_CreateJavaVM\");\n#endif\n\tif (!addr) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\treturn -1;\n\t}\n\tres = (*addr)(pvm, penv, args);\n\treturn res;\n}\n#endif\n\n#ifdef _WIN32\n#if _MSC_VER\n#undef bool\n#endif\n#if defined(__MWERKS__) && __MWERKS__ >= 7\n#undef bool\n#endif\n#include <InterViews/session.h>\n#include <OS/string.h>\n#include <InterViews/style.h>\nstatic int jerr_;\nstatic void *\ndlopen (const char *name, int)\n{\n  void *ret;\n\n    {\n      /* handle for the named library */\n      String str;\n\tjerr_ = 0;\n      if (!Session::instance()->style()->find_attribute(name, str)){\n      \t//fprintf(stderr, \"\\\"%s\\\" not defined in nrn.def\\n\", name);\n\tjerr_ = -10;\n        ret = NULL;\n      }else{\n          ret = (void *) LoadLibrary (str.string());\n          if (ret == NULL) {\n\t\tDWORD dw = GetLastError();\n            fprintf(stderr, \"LoadLibrary(\\\"%s\\\") failed with error %d\\n\", str.string(), dw);\n\t\tjerr_ = -1;\n\t  }\n      }\n    }\n\n  return ret;\n}\n\nstatic void *\ndlsym (void *handle, const char *name)\n{\n  void *ret = (void *) GetProcAddress ((HMODULE) handle, name);\n  if (!ret) {\n  \tfprintf(stderr, \"Could not GetProcAddress for \\\"%s\\\"\\n\", name);\n  }\n  return ret;\n}\n\n#if defined(_MSC_VER)\ntypedef jint(CALLBACK *PCJVM)(JavaVM**, void**, void*);\n#else\ntypedef jint(*PCJVM)(JavaVM**, void**, void*);\n#endif\n\njint nrn_CreateJavaVM(JavaVM **pvm, void **penv, void *args) {\n\tjint res;\n\n\t*pvm = 0;\n\t*penv = 0;\n\tvoid* handle = dlopen(\"jvmdll\", 0);\n\tif (!handle) { return jerr_; }\n\tPCJVM addr = (PCJVM)dlsym(handle, \"JNI_CreateJavaVM\");\n\tif (!addr) { return -1; }\n\tres = (*addr)(pvm, penv, args);\n\treturn res;\n}\n#endif\n\n#if MAC\nextern \"C\" {\nbool is_mac_dll(FSSpec*);\nextern OSErr __path2fss(const char* name, FSSpec*);\n}\ntypedef jint(*PCJVM)(JavaVM**, JNIEnv**, void*);\ntypedef jint(*PIJVM)(void*);\ntypedef CFragConnectionID(*PF)();\nstatic PCJVM caddr;\n\nstatic jint nrn_GetDefaultJavaVMInitArgs(void* args) {\n\tPIJVM iaddr = 0;\n\tlong i, cnt;\n\tCFragConnectionID id;\n\tCFragSymbolClass sc;\n\tPtr sa;\n\tStr255 sname;\n\tOSErr myErr;\n\tFSSpec fs;\n\tchar name[256];\n\t\n\tsprintf(name, \"%s:nrnjvmdll\", neuron_home);\n\t\n\tif ((__path2fss(name, &fs) == fnfErr) || !is_mac_dll(&fs)) {\n\t\tfprintf(stderr, \"%s is not the nrnjvmdll\\n\", name);\n\t\treturn -1;\n\t}\n\t\n\tmyErr = GetDiskFragment(&fs, 0, kCFragGoesToEOF,\n\t\t0, kLoadCFrag, &id, &sa, sname);\n\t//myErr = GetSharedLibrary(\"\\pMRJLib\", kPowerPCCFragArch, kLoadCFrag,\n\t//\t&id, &sa, sname);\n\tif (myErr) {\n\t\tsname[sname[0]+1]='\\0';\n\t\tfprintf(stderr, \"could not load the Java VM : %s\\n\", sname+1);\n\t\treturn -1;\n\t}\n\tsa = 0;\n\tmyErr = CountSymbols(id, &cnt);\n\t//printf(\"%d symbols exported\\n\", cnt);\n\tfor (i=0; i < cnt; ++i) {\n\t\tmyErr = GetIndSymbol(id, i, sname, &sa, &sc);\n\t\tsname[sname[0]+1] = '\\0';\n\t\t//printf(\"%d %s\\n\", i, sname+1);\n\t\tif (strcmp((char*)(sname+1), \"nrn2_GetDefaultJavaVMInitArgs\") == 0) {\n\t\t\tiaddr = (PIJVM)sa;\n\t\t}\n\t\tif (strcmp((char*)(sname+1), \"nrn2_CreateJavaVM\") == 0) {\n\t\t\tcaddr = (PCJVM)sa;\n\t\t}\n\t}\n\tif (iaddr) {\n\t\tjint res = (*iaddr)(args);\n\t\tif (res < 0) {\n\t\t\tfprintf(stderr, \"call to JNI_GetDefaultJavaVMInitArgs returned %d\\n\", res);\n\t\t}\n\t\treturn res;\n\t}\n\tfprintf(stderr, \"no address for JNI_GetDefaultJavaVMInitArgs\\n\");\n\treturn -1;\n}\n\nstatic jint nrn_CreateJavaVM(JavaVM **pvm, JNIEnv **penv, void *args) {\n\tjint res;\n\t*pvm = 0;\n\t*penv = 0;\n\tif (!caddr) {\n\t\tfprintf(stderr, \"no address for JNI_CreateJavaVM\\n\");\n\t\treturn -1;\n\t}\n\tres = (*caddr)(pvm, penv, args);\n\treturn res;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/oc/cygwinprt.c": "#include <../../nrnconf.h>\n#include <errno.h>\n#include <unistd.h>\n#if defined(CYGWIN) || defined(MINGW)\n\n#if !defined(__MINGW32__)\n#include \"system.c\"\n#define my_off64_t loff_t\n#else\n#define my_off64_t off64_t\n#endif\n\n#include \"mswinprt.c\"\n\nmy_off64_t lseek64(int fd, my_off64_t offset, int whence) {\n\tfprintf(stderr, \"called lseek64\\n\");\n\tabort();\n}\n\n/* mingw does not have dlfcn.h */\n#if !defined(HAVE_DLFCN_H) || defined(__MINGW32__)\n\nvoid* dlopen(const char *name, int mode) {\n\tvoid *ret;\n\t/* handle for the named library */\n\tret = (void *) LoadLibrary(name);\n        if (ret == NULL) {\n\t\tDWORD dw = GetLastError();\n\t\tfprintf(stderr, \"LoadLibrary(\\\"%s\\\") failed with error %d\\n\", name, dw);\n\t}\n\treturn ret;\n}\n\nvoid* dlopen_noerr(const char *name, int mode) {return (void*)LoadLibrary(name);}\n\nvoid* dlsym(void *handle, const char *name) {\n\tvoid *ret = (void *) GetProcAddress ((HMODULE) handle, name);\n\tif (!ret) {\n\t\tfprintf(stderr, \"Could not GetProcAddress for \\\"%s\\\"\\n\", name);\n\t}\n\treturn ret;\n}\n\nint dlclose(void* handle) {\n}\n\nstatic char* dler_=\"\";\nchar* dlerror() {\n\treturn dler_;\n}\n#endif /* HAVE_DLFCN_H */\n\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/oc/hoc_init.c": "#include <../../nrnconf.h>\n/* /local/src/master/nrn/src/oc/hoc_init.c,v 1.25 1999/11/08 17:48:58 hines Exp */\n\n#include \"hoc.h\"\n#include \"parse.h\"\n#include <math.h>\n#include \"equation.h\"\n\n#include \"ocfunc.h\"\nextern void hoc_nrnmpi_init();\n\n#if PVM\nextern int      numprocs(), myproc(), psync();\n#endif\n#if 0\nextern int\thoc_co();\n#endif\n#if\tDOS || defined(WIN32) /*|| defined(MAC)*/\nextern double\terf(), erfc();\t/* supplied by unix */\n#endif\n#if defined(WIN32)\nextern void hoc_winio_show(int b);\n#endif\n\n#if MAC\nstatic double Fabs(x) double x; { return (x>0.) ? x : -x; }\nstatic double Erf(x) double x; { return erf(x); }\nstatic double Erfc(x) double x; { return erfc(x); }\n#endif\n\nstatic struct { /* Keywords */\n\tchar\t*name;\n\tint\tkval;\n} keywords[] = {\n\t\"proc\",\t\tparsePROC,\n\t\"func\",\t\tFUNC,\n\t\"obfunc\",\tHOCOBJFUNC,\n\t\"return\",\tRETURN,\n\t\"break\",\tBREAK,\n\t\"continue\",\tCONTINUE,\n\t\"stop\",\t\tSTOPSTMT,\n\t\"if\",\t\tIF,\n\t\"else\",\t\tELSE,\n\t\"while\",\tWHILE,\n\t\"for\",\t\tFOR,\n\t\"print\",\tPRINT,\n\t\"delete\",\tparseDELETE,\n\t\"read\",\t\tREAD,\n\t\"debug\",\tDEBUG,\n\t\"double\",\tparseDOUBLE,\n\t\"em\",\t\tEDIT,\n\t\"depvar\",\tDEPENDENT,\n\t\"eqn\",\t\tEQUATION,\n\t\"local\",\tLOCAL,\n\t\"localobj\",\tLOCALOBJ,\n\t\"strdef\",\tSTRDEF,\n\t\"parallel\",\tPARALLEL,\n\t\"help\",\t\tHELP,\n\t\"iterator\",\tITERKEYWORD,\n\t\"iterator_statement\", ITERSTMT,\n#if CABLE\n\t\"create\",\tSECTIONKEYWORD,\n\t\"connect\",\tCONNECTKEYWORD,\n\t\"setpointer\",\tSETPOINTERKEYWORD,\n\t\"access\",\tACCESSKEYWORD,\n\t\"insert\",\tINSERTKEYWORD,\n\t\"uninsert\",\tUNINSERTKEYWORD,\n\t\"forall\",\tFORALL,\n\t\"ifsec\",\tIFSEC,\n\t\"forsec\",\tFORSEC,\n#endif /*CABLE*/\n#if OOP\n\t\"begintemplate\", BEGINTEMPLATE,\n\t\"endtemplate\", ENDTEMPLATE,\n\t\"objectvar\",\tOBJVARDECL,\n\t\"objref\",\tOBJVARDECL,\n\t\"public\",\tPUBLICDECL,\n\t\"external\",\tEXTERNALDECL,\n\t\"new\",\t\tNEW,\n#endif\n\t0,\t\t0\n};\nstatic struct {\t/* Constants */\n\tchar\t*name;\n\tdouble cval;\n} consts[] = {\n\t\"PI\",\t3.14159265358979323846,\n\t\"E\",\t2.71828182845904523536,\n\t\"GAMMA\",0.57721566490153286060,\t/* Euler */\n\t\"DEG\", 57.29577951308232087680,\t/* deg/radian */\n\t\"PHI\",\t1.61803398874989484820,\t/* golden ratio */\n#if defined(LegacyFR) && LegacyFR == 1\n\t\"FARADAY\", 96485.309,\t/*coulombs/mole*/\n\t\"R\", 8.31441,\t\t/*molar gas constant, joules/mole/deg-K*/\n#else\n\t/* Nov, 2017, from https://physics.nist.gov/cuu/Constants/index.html */\n\t/* also see FARADAY and gasconstant in ../nrnoc/eion.c */\n\t\"FARADAY\", 96485.33289,\t/*coulombs/mole*/\n\t\"R\", 8.3144598,\t\t/*molar gas constant, joules/mole/deg-K*/\n#endif\n\t0,\t0\n};\n\nstatic struct {\t/* Built-ins */\n\tchar\t*name;\n\tdouble\t(*func)();\n} builtins[] = {\n\t\"sin\",\tsin,\n\t\"cos\",\tcos,\n\t\"atan\",\tatan,\n\t\"tanh\", tanh,\n\t\"log\",\tLog,\t/* checks argument */\n\t\"log10\",Log10,\t/* checks argument */\n\t\"exp\",\thoc1_Exp,\t/* checks argument */\n\t\"sqrt\",\tSqrt,\t/* checks argument */\n\t\"int\",\tinteger,\n#if MAC\n\t\"abs\",\tFabs,\n\t\"erf\",\tErf,\n\t\"erfc\", Erfc,\n#else\n\t\"abs\",\tfabs,\n\t\"erf\",\terf,\n\t\"erfc\", erfc,\n#endif\n\t0,\t0\n};\nstatic struct { /* Builtin functions with multiple or variable args */\n\tchar \t*name;\n\tvoid\t(*fun_blt)(void);\n} fun_bltin[] = {\n\t\"atan2\",\thoc_atan2,\n\t\"system\",\thoc_System,\n\t\"prmat\",\thoc_Prmat,\n\t\"solve\",\thoc_solve,\n\t\"eqinit\",\thoc_eqinit,\n\t\"plt\",\t\thoc_Plt,\n\t\"axis\",\t\thoc_axis,\n\t\"plot\",\t\thoc_Plot,\n\t\"plotx\",\thoc_plotx,\n\t\"ploty\",\thoc_ploty,\n\t\"regraph\",\thoc_regraph,\n\t\"symbols\",\thoc_symbols,\n\t\"printf\",\thoc_PRintf,\n\t\"xred\",\t\thoc_Xred,\n\t\"sred\",\t\thoc_Sred,\n\t\"ropen\",\thoc_ropen,\n\t\"wopen\",\thoc_wopen,\n\t\"xopen\",\thoc_xopen,\n\t\"hoc_stdout\",\thoc_stdout,\n\t\"chdir\",\thoc_Chdir,\n\t\"fprint\",\thoc_Fprint,\n\t\"fscan\",\thoc_Fscan,\n\t\"sscanf\", hoc_sscanf,\n\t\"sprint\",\thoc_Sprint,\n\t\"graph\",\thoc_Graph,\n\t\"graphmode\",\thoc_Graphmode,\n\t\"fmenu\",\thoc_fmenu,\n\t\"lw\",\t\thoc_Lw,\n\t\"getstr\",\thoc_Getstr,\n\t\"strcmp\",\thoc_Strcmp,\n\t\"setcolor\",\thoc_Setcolor,\n\t\"startsw\",\thoc_startsw,\n\t\"stopsw\",\thoc_stopsw,\n\t\"object_id\",\thoc_object_id,\n\t\"allobjectvars\", hoc_allobjectvars,\n\t\"allobjects\",\thoc_allobjects,\n\t\"xpanel\",\thoc_xpanel,\n\t\"xbutton\",\thoc_xbutton,\n\t\"xcheckbox\",    hoc_xcheckbox,\n\t\"xstatebutton\", hoc_xstatebutton,\n\t\"xlabel\",\thoc_xlabel,\n\t\"xmenu\",\thoc_xmenu,\n\t\"xvalue\",\thoc_xvalue,\n\t\"xpvalue\",\thoc_xpvalue,\n\t\"xradiobutton\",\thoc_xradiobutton,\n\t\"xfixedvalue\",\thoc_xfixedvalue,\n\t\"xvarlabel\",\thoc_xvarlabel,\n\t\"xslider\",\thoc_xslider,\n\t\"boolean_dialog\",\thoc_boolean_dialog,\n\t\"continue_dialog\",\thoc_continue_dialog,\n\t\"string_dialog\",\thoc_string_dialog,\n\t\"doEvents\",\thoc_single_event_run,\n\t\"doNotify\",\thoc_notify_iv,\n\t\"nrniv_bind_thread\",\tnrniv_bind_thread,\n\t\"ivoc_style\",\tivoc_style,\n\t\"numarg\",\thoc_Numarg,\n\t\"argtype\",\thoc_Argtype,\n\t\"hoc_pointer_\",\thoc_pointer,\t\t/* for internal use */\n\t\"nrn_mallinfo\", hoc_mallinfo,\n\t\"execute\",\thoc_exec_cmd,\n\t\"execute1\",\thoc_execute1,\n\t\"load_proc\",\thoc_load_proc,\n\t\"load_func\",\thoc_load_func,\n\t\"load_template\", hoc_load_template,\n\t\"load_file\", hoc_load_file,\n\t\"load_java\", hoc_load_java,\n\t\"unix_mac_pc\", hoc_unix_mac_pc,\n\t\"show_winio\", hoc_show_winio,\n\t\"nrn_load_dll\", hoc_nrn_load_dll,\n\t\"machine_name\", hoc_machine_name,\n\t\"saveaudit\", hoc_Saveaudit,\n\t\"retrieveaudit\", hoc_Retrieveaudit,\n\t\"coredump_on_error\", hoc_coredump_on_error,\n\t\"checkpoint\", hoc_checkpoint,\n\t\"quit\",\t\t hoc_quit,\n\t\"object_push\",\thoc_object_push,\n\t\"object_pop\",\thoc_object_pop,\n\t\"pwman_place\",\thoc_pwman_place,\n\t\"save_session\", hoc_save_session,\n\t\"print_session\", hoc_print_session,\n\t\"show_errmess_always\", hoc_show_errmess_always,\n\t\"execerror\", hoc_Execerror,\n\t\"variable_domain\", hoc_Symbol_limits,\n\t\"name_declared\", hoc_name_declared,\n\t\"use_mcell_ran4\", hoc_usemcran4,\n\t\"mcell_ran4\", hoc_mcran4,\n\t\"mcell_ran4_init\", hoc_mcran4init,\n\t\"nrn_feenableexcept\", nrn_feenableexcept,\n\t\"nrnmpi_init\", hoc_nrnmpi_init,\n#if PVM\n        \"numprocs\", numprocs,\n        \"myproc\", myproc,\n        \"psync\", psync,\n#endif\n#if\tDOS\n\t\"settext\",\thoc_settext,\n#endif\n#if defined(WIN32)\n   \"WinExec\", hoc_win_exec,\n#endif\n\t0,\t0\n};\n\nstatic struct { /* functions that return a string */\n\tchar \t*name;\n\tvoid\t(*strfun_blt)(void);\n} strfun_bltin[] = {\n\t\"secname\",\thoc_secname,\n\t\"units\", hoc_Symbol_units,\n\t\"neuronhome\", hoc_neuronhome,\n\t\"getcwd\",\thoc_getcwd,\n\t\"nrnversion\", hoc_nrnversion,\n\t0,\t0\n};\n\nstatic struct { /* functions that return an object */\n\tchar \t*name;\n\tvoid\t(*objfun_blt)(void);\n} objfun_bltin[] = {\n\t\"object_pushed\", hoc_object_pushed,\n\t0,\t0\n};\n\ndouble hoc_epsilon = 1.e-11;\ndouble hoc_ac_; /*known to the interpreter to evaluate expressions with hoc_oc() */\ndouble* hoc_varpointer; /* executing hoc_pointer(&var) will put the address of\n\t\t\tthe variable in this location */\n\ndouble hoc_cross_x_, hoc_cross_y_; /* For Graph class in ivoc */\ndouble hoc_default_dll_loaded_;\n\nchar* neuron_home;\nchar* nrn_mech_dll; /* but actually only for NEURON mswin and linux */\nint nrn_noauto_dlopen_nrnmech; /* 0 except when binary special. */\nint use_mcell_ran4_;\nint nrn_xopen_broadcast_;\n\nvoid hoc_init(void)\t/* install constants and built-ins table */\n{\n\tint i;\n\tSymbol *s;\n\n\tuse_mcell_ran4_ = 0;\n\tnrn_xopen_broadcast_ = 255;\n\thoc_init_space();\n\tfor (i = 0; keywords[i].name; i++)\n\t\tIGNORE(install(keywords[i].name, keywords[i].kval, 0.0, &symlist));\n\tfor (i = 0; consts[i].name; i++) {\n\t\ts = install(consts[i].name, UNDEF, consts[i].cval, &symlist);\n\t\ts->type = VAR;\n\t\ts->u.pval = &consts[i].cval;\n\t\ts->subtype = USERDOUBLE;\n\t}\n\tfor (i = 0; builtins[i].name; i++)\n\t{\n\t\ts = install(builtins[i].name, BLTIN, 0.0, &symlist);\n\t\ts->u.ptr = builtins[i].func;\n\t}\n\tfor (i = 0; fun_bltin[i].name; i++)\n\t{\n\t\ts = install(fun_bltin[i].name, FUN_BLTIN, 0.0, &symlist);\n\t\ts->u.u_proc->defn.pf = fun_bltin[i].fun_blt;\n\t\ts->u.u_proc->nauto = 0;\n\t\ts->u.u_proc->nobjauto = 0;\n\t}\n\tfor (i = 0; strfun_bltin[i].name; i++)\n\t{\n\t\ts = install(strfun_bltin[i].name, FUN_BLTIN, 0.0, &symlist);\n\t\ts->type = STRINGFUNC;\n\t\ts->u.u_proc->defn.pf = strfun_bltin[i].strfun_blt;\n\t\ts->u.u_proc->nauto = 0;\n\t\ts->u.u_proc->nobjauto = 0;\n\t}\n\tfor (i = 0; objfun_bltin[i].name; i++)\n\t{\n\t\ts = install(objfun_bltin[i].name, FUN_BLTIN, 0.0, &symlist);\n\t\ts->type = OBJECTFUNC;\n\t\ts->u.u_proc->defn.pf = objfun_bltin[i].objfun_blt;\n\t\ts->u.u_proc->nauto = 0;\n\t}\n\t/* hoc_ac_ is a way to evaluate an expression using the interpreter */\n\thoc_install_var(\"hoc_ac_\", &hoc_ac_);\n\thoc_install_var(\"float_epsilon\", &hoc_epsilon);\n\thoc_install_var(\"hoc_cross_x_\", &hoc_cross_x_);\n\thoc_install_var(\"hoc_cross_y_\", &hoc_cross_y_);\n\thoc_install_var(\"default_dll_loaded_\", &hoc_default_dll_loaded_);\n\n\ts = install(\"xopen_broadcast_\", UNDEF, 0.0, &hoc_symlist);\n\ts->type = VAR;\n\ts->subtype = USERINT;\n\ts->u.pvalint = &nrn_xopen_broadcast_;\n\n\t/* initialize pointers ( why doesn't Vax do this?) */\n\thoc_access = (int *)0;\n\tspinit();\n#if OOP\n\thoc_class_registration();\n\t hoc_built_in_symlist = symlist;\n\t symlist = (Symlist *)0;\n\t /* start symlist and top level the same list */\n\t hoc_top_level_symlist = symlist = (Symlist *)emalloc(sizeof(Symlist));\n\t symlist->first = symlist->last = (Symbol *)0;\n\thoc_install_hoc_obj();\n#endif\n}\n\nvoid hoc_unix_mac_pc(void) {\n\thoc_ret();\n#if defined(DARWIN)\n\thoc_pushx(4.);\n#else\n#if MAC\n\thoc_pushx(2.);\n#else\n#if defined(WIN32)\n\thoc_pushx(3.);\n#else\n\thoc_pushx(1.);\n#endif\n#endif\n#endif\n}\nvoid hoc_show_winio(void) {\n    int b;\n    b = (int)chkarg(1, 0., 1.);\n#if MAC\n    hoc_sioux_show(b);\n#endif\n#if defined(WIN32)\n\thoc_winio_show(b);\n#endif\n    hoc_ret();\n    hoc_pushx(0.);\n}\n\nint nrn_main_launch;\n\nvoid hoc_nrnversion(void) {\n\textern char* nrn_version();\n\tstatic char* p;\n\tint i;\n\ti = 1;\n\tif (ifarg(1)) {\n\t\ti = (int)chkarg(1, 0., 20.);\n\t}\n\thoc_ret();\n\tp = nrn_version(i);\n\thoc_pushstr(&p);\n}\n\nvoid hoc_Execerror(void) {\n\tchar* c2 = (char*)0;\n\tif (ifarg(2)) {\n\t\tc2 = gargstr(2);\n\t}\n\tif (ifarg(1)) {\n\t\thoc_execerror(gargstr(1), c2);\n\t}else{\n\t\thoc_execerror_mes(c2, c2, 0);\n\t}\n\t/* never get here */\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/nrnoc/osxdlfcn.h": "/*\nCopyright (c) 2002 Jorge Acereda  <jacereda@users.sourceforge.net> &\n                   Peter O'Gorman <ogorman@users.sourceforge.net>\n                   \nPortions may be copyright others, see the AUTHORS file included with this\ndistribution.\n\nMaintained by Peter O'Gorman <ogorman@users.sourceforge.net>\n\nBug Reports and other queries should go to <ogorman@users.sourceforge.net>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n#ifndef _DLFCN_H_\n#define _DLFCN_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined (__GNUC__) && __GNUC__ > 3\n#define dl_restrict __restrict\n#else\n#define dl_restrict\n#endif\n/*\n * Structure filled in by dladdr().\n */\n\ntypedef struct dl_info {\n        const char      *dli_fname;     /* Pathname of shared object */\n        void            *dli_fbase;     /* Base address of shared object */\n        const char      *dli_sname;     /* Name of nearest symbol */\n        void            *dli_saddr;     /* Address of nearest symbol */\n} Dl_info;\n\nextern void * dlopen(const char *path, int mode);\nextern void * dlsym(void * dl_restrict handle, const char * dl_restrict symbol);\nextern const char * dlerror(void);\nextern int dlclose(void * handle);\nextern int dladdr(const void * dl_restrict, Dl_info * dl_restrict);\n\n#define RTLD_LAZY\t0x1\n#define RTLD_NOW\t0x2\n#define RTLD_LOCAL\t0x4\n#define RTLD_GLOBAL\t0x8\n#define RTLD_NOLOAD\t0x10\n#define RTLD_NODELETE\t0x80\n\n/*\n * Special handle arguments for dlsym().\n */\n#define\tRTLD_NEXT\t\t((void *) -1)\t/* Search subsequent objects. */\n#define\tRTLD_DEFAULT\t((void *) -2)\t/* Use default search algorithm. */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _DLFCN_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/nrnoc/init.c": "#include <../../nrnconf.h>\n#include <nrnmpiuse.h>\n\nextern char* nrn_version();\n\n/* change this to correspond to the ../nmodl/nocpout nmodl_version_ string*/\nstatic char nmodl_version_[] =\n\"7.7.0\";\n\nstatic char banner[] =\n\"Duke, Yale, and the BlueBrain Project -- Copyright 1984-2019\\n\\\nSee http://neuron.yale.edu/neuron/credits\\n\";\n\n# include\t<stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include \"section.h\"\n#include \"parse.h\"\n#include \"nrniv_mf.h\"\n#include \"cabvars.h\"\n#include \"neuron.h\"\n#include \"membdef.h\"\n#include \"nrnmpi.h\"\n\n#ifdef WIN32\n#if defined(HAVE_DLFCN_H) && !defined(__MINGW32__)\n#include <dlfcn.h>\n#else\n#define RTLD_NOW 0\nextern void* dlopen(const char* name, int mode);\nextern void* dlsym(void* handle, char* name);\nextern int dlclose(void* handle);\nextern char* dlerror();\n#endif\n/*#include \"../mswin/windll/dll.h\"*/\n/*static struct DLL* dll;*/\n#endif // WIN32\n\n#if defined(WIN32) || defined(NRNMECH_DLL_STYLE)\nextern char* nrn_mech_dll; /* declared in hoc_init.c so ivocmain.cpp can see it */\nextern int nrn_noauto_dlopen_nrnmech; /* default 0 declared in hoc_init.c */\n#endif\n\n#if defined(WIN32)\n#undef DLL_DEFAULT_FNAME\n#define DLL_DEFAULT_FNAME \"nrnmech.dll\"\n#endif // WIN32\n\n#if defined(NRNMECH_DLL_STYLE)\n#if defined(DARWIN)\n\n#ifndef DLL_DEFAULT_FNAME\n#define DLL_DEFAULT_FNAME \"libnrnmech.dylib\"\n#endif\n\n#if __GNUC__ < 4\n#include \"osxdlfcn.h\"\n#include \"osxdlfcn.c\"\n#else\n#include <dlfcn.h>\n#endif // __GNUC__\n\n#else\n\n#if defined(HAVE_DLFCN_H) && !defined(__MINGW32__)\n#include <dlfcn.h>\n#endif\n\n#ifndef DLL_DEFAULT_FNAME\n#define DLL_DEFAULT_FNAME \"./libnrnmech.so\"\n#endif\n#endif\n#else // !defined(NRNMECH_DLL_STYLE)\n#if defined(HAVE_DLFCN_H) && !defined(__MINGW32__)\n#include <dlfcn.h>\n#endif\n#endif\n\n# define\tCHECK(name)\tif (hoc_lookup(name) != (Symbol *)0){\\\n\t\tIGNORE(fprintf(stderr, CHKmes, name));\\\n\t\tnrn_exit(1);}\n\nstatic char\tCHKmes[] = \"The user defined name, %s, already exists\\n\";\n\nvoid (*nrnpy_reg_mech_p_)(int);\n\nint secondorder=0;\nint state_discon_allowed_;\nextern int nrn_nobanner_;\ndouble t, dt, clamp_resist, celsius, htablemin, htablemax;\nint nrn_netrec_state_adjust = 0;\nint nrn_sparse_partrans = 0;\nhoc_List* section_list;\nint nrn_global_ncell = 0; /* used to be rootnodecount */\nextern double hoc_default_dll_loaded_;\nextern int nrn_istty_;\nextern int nrn_nobanner_;\n\n#if FISHER\n#include <stdlib.h>\n#include \"fisher.h\"\ndouble id_number;              /* for rcs control, set in setup_id_info() */\nchar login_name[20];           /* store user's login for sys.c & rcs.c    */\nchar *pipe_filter = \"more\";    /* allow for running NEURON in emacs       */\n#endif\n\nstatic HocParmLimits _hoc_parm_limits[] = {\n\t\"Ra\", 1e-6, 1e9,\n\t\"L\", 1e-4, 1e20,\n\t\"diam\", 1e-9, 1e9,\n\t\"cm\", 0., 1e9,\n\t\"rallbranch\", 1., 1e9,\n\t\"nseg\", 1., 1e9,\n\t\"celsius\", -273., 1e6,\n\t\"dt\", 1e-9, 1e15,\n\t0, 0., 0.\n};\n\nstatic HocParmUnits _hoc_parm_units[] = {\n\t\"Ra\", \"ohm-cm\",\n\t\"L\", \"um\",\n\t\"diam\", \"um\",\n\t\"cm\", \"uF/cm2\",\n\t\"celsius\", \"degC\",\n\t\"dt\", \"ms\",\n\t\"t\", \"ms\",\n\t\"v\", \"mV\",\n\t\"i_cap\", \"mA/cm2\",\n\t0, 0\n};\n\nextern Symlist* nrn_load_dll_called_;\nextern int nrn_load_dll_recover_error();\nextern void nrn_load_name_check(const char* name);\nstatic int memb_func_size_;\nMemb_func* memb_func;\nMemb_list* memb_list;\nshort* memb_order_;\nSymbol** pointsym;\nPoint_process** point_process;\nchar* pnt_map;\t\t/* so prop_free can know its a point mech*/\nBAMech** bamech_;\n\nTemplate** nrn_pnt_template_; /* for finding artificial cells */\n/* for synaptic events. */\npnt_receive_t* pnt_receive;\npnt_receive_init_t* pnt_receive_init;\nshort* pnt_receive_size;\n\n /* values are type numbers of mechanisms which do net_send call */\nint nrn_has_net_event_cnt_;\nint* nrn_has_net_event_;\nint* nrn_prop_param_size_;\nint* nrn_prop_dparam_size_;\nint* nrn_dparam_ptr_start_;\nint* nrn_dparam_ptr_end_;\ntypedef int (*bbcore_write_t)(void*, int, int*, double*, Datum*, Datum*, NrnThread*);\nbbcore_write_t* nrn_bbcore_write_;\nvoid hoc_reg_bbcore_write(int type, bbcore_write_t f) {\n\tnrn_bbcore_write_[type] = f;\n}\n\nconst char** nrn_nmodl_text_;\nvoid hoc_reg_nmodl_text(int type, const char* txt) {\n\tnrn_nmodl_text_[type] = txt;\n}\n\nconst char** nrn_nmodl_filename_;\nvoid hoc_reg_nmodl_filename(int type, const char* filename) {\n\tnrn_nmodl_filename_[type] = filename;\n}\n\nvoid  add_nrn_has_net_event(type) int type; {\n\t++nrn_has_net_event_cnt_;\n\tnrn_has_net_event_ = (int*)erealloc(nrn_has_net_event_, nrn_has_net_event_cnt_*sizeof(int));\n\tnrn_has_net_event_[nrn_has_net_event_cnt_ - 1] = type;\n}\n\n/* values are type numbers of mechanisms which have FOR_NETCONS statement */\nint nrn_fornetcon_cnt_; /* how many models have a FOR_NETCONS statement */\nint* nrn_fornetcon_type_; /* what are the type numbers */\nint* nrn_fornetcon_index_; /* what is the index into the ppvar array */\n\nvoid add_nrn_fornetcons(int type, int indx) {\n\tint i = nrn_fornetcon_cnt_++;\n\tnrn_fornetcon_type_ = (int*)erealloc(nrn_fornetcon_type_, (i+1)*sizeof(int));\n\tnrn_fornetcon_index_ = (int*)erealloc(nrn_fornetcon_index_, (i+1)*sizeof(int));\n\tnrn_fornetcon_type_[i] = type;\n\tnrn_fornetcon_index_[i]= indx;\n}\n\n/* array is parallel to memb_func. All are 0 except 1 for ARTIFICIAL_CELL */\nshort* nrn_is_artificial_;\nshort* nrn_artcell_qindex_;\n\nvoid  add_nrn_artcell(int type, int qi) {\n\tnrn_is_artificial_[type] = 1;\n\tnrn_artcell_qindex_[type] = qi;\n}\n\nint nrn_is_artificial(int pnttype) {\n\treturn (int)nrn_is_artificial_[pointsym[pnttype]->subtype];\n}\n\nint nrn_is_cable(void) {return 1;}\n\nvoid* nrn_realpath_dlopen(const char* relpath, int flags) {\n  char* abspath = NULL;\n  void* handle = NULL;\n\n  /* use realpath or _fullpath even if is already a full path */\n\n#if defined(HAVE_REALPATH)\n  abspath = realpath(relpath, NULL);\n#else /* not HAVE_REALPATH */\n#if defined(__MINGW32__)\n  abspath = _fullpath(NULL, relpath, 0);\n#else /* not __MINGW32__ */\n  abspath = strdup(relpath);\n#endif /* not __MINGW32__ */\n#endif /* not HAVE_REALPATH */\n  if (abspath) {\n    handle = dlopen(abspath, flags);\n    free(abspath);\n  }else{\n    int patherr = errno;\n    handle = dlopen(relpath, flags);\n    if (!handle) {\n      Fprintf(stderr, \"realpath failed errno=%d (%s) and dlopen failed with %s\\n\", patherr, strerror(patherr), relpath);\n    }\n  }\n  return handle;\n}\n\nint mswin_load_dll(const char* cp1) {\n\tvoid* handle;\n\tif (nrnmpi_myid < 1) if (!nrn_nobanner_ && nrn_istty_) {\n\t\tfprintf(stderr, \"loading membrane mechanisms from %s\\n\", cp1);\n\t}\n#if DARWIN\n\thandle = nrn_realpath_dlopen(cp1, RTLD_NOW);\n#else\n\thandle = dlopen(cp1, RTLD_NOW);\n#endif\n\tif (handle) {\n\t\tPfrv mreg = (Pfrv)dlsym(handle, \"modl_reg\");\n\t\tif (mreg) {\n\t\t\t(*mreg)();\n\t\t}else{\n\t\t\tfprintf(stderr, \"dlsym _modl_reg failed\\n%s\\n\", dlerror());\n\t\t\tdlclose(handle);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}else{\n\t\tfprintf(stderr, \"dlopen failed - \\n%s\\n\", dlerror());\n\t}\n\treturn 0;\n}\n\nvoid hoc_nrn_load_dll(void) {\n\tint i;\n\tFILE* f;\n\tconst char* fn;\n\tfn = expand_env_var(gargstr(1));\n\tf = fopen(fn, \"rb\");\n\tif (f) {\n\t\tfclose(f);\n\t\tnrn_load_dll_called_ = hoc_symlist;\n\t\thoc_symlist = hoc_built_in_symlist;\n\t\thoc_built_in_symlist = (Symlist*)0;\n\t\t/* If hoc_execerror, recover before that call */\n\t\ti = mswin_load_dll(fn);\n\t\thoc_built_in_symlist = hoc_symlist;\n\t\thoc_symlist = nrn_load_dll_called_;\n\t\tnrn_load_dll_called_ = (Symlist*)0;\n\t\thoc_retpushx((double)i);\n\t}else{\n\t\thoc_retpushx(0.);\n\t}\t\n}\n\nextern void nrn_threads_create(int);\n\nstatic DoubScal scdoub[] = {\n\t\"t\", &t,\n\t\"dt\", &dt,\n\t0,0\n};\n\nvoid hoc_last_init(void)\n{\n\tint i;\n\tPfrv *m;\n\tSymbol *s;\n\n\thoc_register_var(scdoub, (DoubVec*)0, (VoidFunc*)0);\n\tnrn_threads_create(1);\n\n \tif (nrnmpi_myid < 1) if (nrn_nobanner_ == 0) { \n\t    Fprintf(stderr, \"%s\\n\", nrn_version(1));\n\t    Fprintf(stderr, \"%s\\n\", banner);\n\t    IGNORE(fflush(stderr));\n \t} \n\tmemb_func_size_ = 30;\n\tmemb_func = (Memb_func*)ecalloc(memb_func_size_, sizeof(Memb_func));\n\tmemb_list = (Memb_list*)ecalloc(memb_func_size_, sizeof(Memb_list));\n\tpointsym = (Symbol**)ecalloc(memb_func_size_, sizeof(Symbol*));\n\tpoint_process = (Point_process**)ecalloc(memb_func_size_, sizeof(Point_process*));\n\tpnt_map = (char*)ecalloc(memb_func_size_, sizeof(char));\n\tmemb_func[1].alloc = cab_alloc;\n\tnrn_pnt_template_ = (Template**)ecalloc(memb_func_size_, sizeof(Template*));\n\tpnt_receive = (pnt_receive_t*)ecalloc(memb_func_size_, sizeof(pnt_receive_t));\n\tpnt_receive_init = (pnt_receive_init_t*)ecalloc(memb_func_size_, sizeof(pnt_receive_init_t));\n\tpnt_receive_size = (short*)ecalloc(memb_func_size_, sizeof(short));\n\tnrn_is_artificial_ = (short*)ecalloc(memb_func_size_, sizeof(short));\n\tnrn_artcell_qindex_ = (short*)ecalloc(memb_func_size_, sizeof(short));\n\tnrn_prop_param_size_ = (int*)ecalloc(memb_func_size_, sizeof(int));\n\tnrn_prop_dparam_size_ = (int*)ecalloc(memb_func_size_, sizeof(int));\n\tnrn_dparam_ptr_start_ = (int*)ecalloc(memb_func_size_, sizeof(int));\n\tnrn_dparam_ptr_end_ = (int*)ecalloc(memb_func_size_, sizeof(int));\n\tmemb_order_ = (short*)ecalloc(memb_func_size_, sizeof(short));\n\tbamech_ = (BAMech**)ecalloc(BEFORE_AFTER_SIZE, sizeof(BAMech*));\n\tnrn_mk_prop_pools(memb_func_size_);\n\tnrn_bbcore_write_ = (bbcore_write_t*)ecalloc(memb_func_size_, sizeof(bbcore_write_t));\n\tnrn_nmodl_text_ = (const char**)ecalloc(memb_func_size_, sizeof(const char*));\n\tnrn_nmodl_filename_ = (const char**)ecalloc(memb_func_size_, sizeof(const char*));\n\t\n#if KEEP_NSEG_PARM\n\t{extern int keep_nseg_parm_; keep_nseg_parm_ = 1; }\n#endif\n#if FISHER\n\t/* get login_name from 'LOGNAME' */\n\tstrcpy(login_name, getenv(\"LOGNAME\"));\n\t\n\tif (getenv(\"CAT_PIPE\")) {\n\t    pipe_filter = \"cat\";   /* preferred for emacs environment */\n\t} else {\n\t    pipe_filter = \"more\";  /* preferred for xterm environment */\n\t}\n#endif\n\n\tsection_list = hoc_l_newlist();\n\t\n\tCHECK(\"v\");\n\ts = hoc_install(\"v\", RANGEVAR, 0.0, &hoc_symlist);\n\ts->u.rng.type = VINDEX;\n\n\tCHECK(\"i_membrane_\");\n\ts = hoc_install(\"i_membrane_\", RANGEVAR, 0.0, &hoc_symlist);\n\ts->u.rng.type = IMEMFAST;\n\t\n\tfor (i = 0; usrprop[i].name; i++) {\n\t\tCHECK(usrprop[i].name);\n\t\ts = hoc_install(usrprop[i].name, UNDEF, 0.0, &hoc_symlist);\n\t\ts->type = VAR;\n\t\ts->subtype = USERPROPERTY;\n\t\ts->u.rng.type = usrprop[i].type;\n\t\ts->u.rng.index = usrprop[i].index;\n\t}\n\tSectionList_reg();\n\tSectionRef_reg();\n\tregister_mech(morph_mech, morph_alloc, (Pvmi)0, (Pvmi)0, (Pvmi)0, (Pvmi)0, -1, 0);\n\thoc_register_prop_size(MORPHOLOGY, 1, 0);\n\tfor (m = mechanism; *m; m++) {\n\t\t(*m)();\n\t}\n#if !MAC && !defined(WIN32)\n\tmodl_reg();\n#endif\n\thoc_register_limits(0, _hoc_parm_limits);\n\thoc_register_units(0, _hoc_parm_units);\n#if defined(WIN32) || defined(NRNMECH_DLL_STYLE)\n\t/* use the default if it exists (and not a binary special) */\n\tif (!nrn_mech_dll && !nrn_noauto_dlopen_nrnmech) {\n\t\tFILE* ff = fopen(DLL_DEFAULT_FNAME, \"r\");\n\t\tif (ff) {\n\t\t\tfclose(ff);\n\t\t\tnrn_mech_dll = DLL_DEFAULT_FNAME;\n\t\t}\n\t}\n\tif (nrn_mech_dll) {\n\t\tchar *cp1, *cp2;\n\t\thoc_default_dll_loaded_ = 1.;\n#if defined(WIN32)\n/* Sometimes (windows 10 and launch recent enthought canopy) it seems that\nmswin_load_dll fails if the filename is not a full path to nrnmech.dll\n*/\nif (strcmp(nrn_mech_dll, \"nrnmech.dll\") == 0) {\n  char buf[5100];\n  char* retval = getcwd(buf, 4096);\n  if (retval) {\n    strncat(buf, \"\\\\\", 100);\n    strncat(buf, nrn_mech_dll, 100);\n    mswin_load_dll(buf);\n  }\n}else{\n#endif /*WIN32*/\n\t\tfor (cp1 = nrn_mech_dll; *cp1; cp1 = cp2) {\n\t\t\tfor (cp2 = cp1; *cp2; ++cp2) {\n\t\t\t\tif (*cp2 == ';') {\n\t\t\t\t\t*cp2 = '\\0';\n\t\t\t\t\t++cp2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmswin_load_dll(cp1);\n\t\t}\n#if defined(WIN32)\n}\n#endif /*WIN32*/\n\t}\n#endif /* WIN32 || NRNMECH_DLL_STYLE */\n\ts = hoc_lookup(\"section_owner\");\n\ts->type = OBJECTFUNC;\n\n\t/* verify that all ions have a defined CHARGE */\n\tnrn_verify_ion_charge_defined();\n}\n\nvoid initnrn(void) {\n\tsecondorder = DEF_secondorder;\t/* >0 means crank-nicolson. 2 means currents\n\t\t\t\t   adjusted to t+dt/2 */\n\tt = 0;\t\t/* msec */\n\tdt = DEF_dt;\t/* msec */\n\tclamp_resist = DEF_clamp_resist;\t/*megohm*/\n\tcelsius = DEF_celsius;\t/* degrees celsius */\n\thoc_retpushx(1.);\n}\n\nstatic int pointtype = 1; /* starts at 1 since 0 means not point in pnt_map*/\nint n_memb_func;\n\n/* if vectorized then thread_data_size added to it */\nvoid nrn_register_mech_common(\n\tconst char **m,\n\tPvmp alloc,\n\tPvmi cur,\n\tPvmi jacob,\n\tPvmi stat,\n\tPvmi initialize,\n\tint nrnpointerindex, /* if -1 then there are none */\n\tint vectorized\n){\n\tstatic int type = 2;\t/* 0 unused, 1 for cable section */\n\tint j, k, modltype, pindx, modltypemax;\n\tSymbol *s;\n\tconst char **m2;\n\n\tnrn_load_name_check(m[1]);\n\n\tif (type >= memb_func_size_) {\n\t\tmemb_func_size_ += 20;\n\t\tmemb_func = (Memb_func*)erealloc(memb_func, memb_func_size_*sizeof(Memb_func));\n\t\tmemb_list = (Memb_list*)erealloc(memb_list, memb_func_size_*sizeof(Memb_list));\n\t\tpointsym = (Symbol**)erealloc(pointsym, memb_func_size_*sizeof(Symbol*));\n\t\tpoint_process = (Point_process**)erealloc(point_process, memb_func_size_*sizeof(Point_process*));\n\t\tpnt_map = (char*)erealloc(pnt_map, memb_func_size_*sizeof(char));\n\t\tnrn_pnt_template_ = (Template**)erealloc(nrn_pnt_template_, memb_func_size_*sizeof(Template*));\n\t\tpnt_receive = (pnt_receive_t*)erealloc(pnt_receive, memb_func_size_*sizeof(pnt_receive_t));\n\t\tpnt_receive_init = (pnt_receive_init_t*)erealloc(pnt_receive_init, memb_func_size_*sizeof(pnt_receive_init_t));\n\t\tpnt_receive_size = (short*)erealloc(pnt_receive_size, memb_func_size_*sizeof(short));\n\t\tnrn_is_artificial_ = (short*)erealloc(nrn_is_artificial_, memb_func_size_*sizeof(short));\n\t\tnrn_artcell_qindex_ = (short*)erealloc(nrn_artcell_qindex_, memb_func_size_*sizeof(short));\n\t\tnrn_prop_param_size_ = (int*)erealloc(nrn_prop_param_size_, memb_func_size_*sizeof(int));\n\t\tnrn_prop_dparam_size_ = (int*)erealloc(nrn_prop_dparam_size_, memb_func_size_*sizeof(int));\n\t\tnrn_dparam_ptr_start_ = (int*)erealloc(nrn_dparam_ptr_start_, memb_func_size_*sizeof(int));\n\t\tnrn_dparam_ptr_end_ = (int*)erealloc(nrn_dparam_ptr_end_, memb_func_size_*sizeof(int));\n\t\tmemb_order_ = (short*)erealloc(memb_order_, memb_func_size_*sizeof(short));\n\t\tnrn_bbcore_write_ = (bbcore_write_t*)erealloc(nrn_bbcore_write_, memb_func_size_*sizeof(bbcore_write_t));\n\t\tnrn_nmodl_text_ = (const char**)erealloc(nrn_nmodl_text_, memb_func_size_*sizeof(const char*));\n\t\tnrn_nmodl_filename_ = (const char**)erealloc(nrn_nmodl_filename_, memb_func_size_*sizeof(const char*));\n\t\tfor (j=memb_func_size_ - 20; j < memb_func_size_; ++j) {\n\t\t\tpnt_map[j] = 0;\n\t\t\tpoint_process[j] = (Point_process*)0;\n\t\t\tpointsym[j] = (Symbol*)0;\n\t\t\tnrn_pnt_template_[j] = (Template*)0;\n\t\t\tpnt_receive[j] = (pnt_receive_t)0;\n\t\t\tpnt_receive_init[j] = (pnt_receive_init_t)0;\n\t\t\tpnt_receive_size[j] = 0;\n\t\t\tnrn_is_artificial_[j] = 0;\n\t\t\tnrn_artcell_qindex_[j] = 0;\n\t\t\tmemb_order_[j] = 0;\n\t\t\tnrn_bbcore_write_[j] = (bbcore_write_t)0;\n\t\t\tnrn_nmodl_text_[j] = (const char*)0;\n\t\t\tnrn_nmodl_filename_[j] = (const char*) 0;\n\t\t}\n\t\tnrn_mk_prop_pools(memb_func_size_);\n\t}\n\n\tnrn_prop_param_size_[type] = 0; /* fill in later */\n\tnrn_prop_dparam_size_[type] = 0; /* fill in later */\n\tnrn_dparam_ptr_start_[type] = 0; /* fill in later */\n\tnrn_dparam_ptr_end_[type] = 0; /* fill in later */\n\tmemb_func[type].current = cur;\n\tmemb_func[type].jacob = jacob;\n\tmemb_func[type].alloc = alloc;\n\tmemb_func[type].state = stat;\n\tmemb_func[type].initialize = initialize;\n\tmemb_func[type].destructor = (void*)0;\n#if VECTORIZE\n\tmemb_func[type].vectorized = vectorized ? 1:0;\n\tmemb_func[type].thread_size_ = vectorized ? (vectorized - 1) : 0;\n\tmemb_func[type].thread_mem_init_ = (void*)0;\n\tmemb_func[type].thread_cleanup_ = (void*)0;\n\tmemb_func[type].thread_table_check_ = (void*)0;\n\tmemb_func[type]._update_ion_pointers = (void*)0;\n\tmemb_func[type].is_point = 0;\n\tmemb_func[type].hoc_mech = (void*)0;\n\tmemb_func[type].setdata_ = (void*)0;\n\tmemb_func[type].dparam_semantics = (int*)0;\n\tmemb_list[type].nodecount = 0;\n\tmemb_list[type]._thread = (Datum*)0;\n\tmemb_order_[type] = type;\n#endif\n#if CVODE\n\tmemb_func[type].ode_count = (void*)0;\n\tmemb_func[type].ode_map = (void*)0;\n\tmemb_func[type].ode_spec = (void*)0;\n\tmemb_func[type].ode_matsol = (void*)0;\n\tmemb_func[type].ode_synonym = (void*)0;\n\tmemb_func[type].singchan_ = (void*)0;\n#endif\n\t/* as of 5.2 nmodl translates so that the version string\n\t   is the first string in m. This allows the neuron application\n\t   to determine if nmodl c files are compatible with this version\n\t   Note that internal mechanisms have a version of \"0\" and are\n\t   by nature consistent.\n\t*/\n\t\n/*printf(\"%s %s\\n\", m[0], m[1]);*/\n\tif (strcmp(m[0], \"0\") == 0) { /* valid by nature */\n\t}else if (m[0][0] > '9') { /* must be 5.1 or before */\nFprintf(stderr, \"Mechanism %s needs to be re-translated.\\n\\\nIt's pre version 6.0 \\\"c\\\" code is incompatible with this neuron version.\\n\", m[0]);\n\t\tif (nrn_load_dll_recover_error()) {\n\t\t\thoc_execerror(\"Mechanism needs to be retranslated:\", m[0]);\n\t\t}else{\n\t\t\tnrn_exit(1);\n\t\t}\n\t}else if (strcmp(m[0], nmodl_version_) != 0){\nFprintf(stderr, \"Mechanism %s needs to be re-translated.\\n\\\nIt's version %s \\\"c\\\" code is incompatible with this neuron version.\\n\",\nm[1], m[0]);\n\t\tif (nrn_load_dll_recover_error()) {\n\t\t\thoc_execerror(\"Mechanism needs to be retranslated:\", m[1]);\n\t\t}else{\n\t\t\tnrn_exit(1);\n\t\t}\n\t}\n\n\ts = hoc_install(m[1], MECHANISM, 0.0, &hoc_symlist);\n\ts->subtype = type;\n\tmemb_func[type].sym = s;\n/*\tprintf(\"%s type=%d\\n\", s->name, type);*/\n\tm2 = m + 2;\n\tif (nrnpointerindex == -1) {\n\t\tmodltypemax = STATE;\n\t} else {\n\t\tmodltypemax = NRNPOINTER;\n\t}\n\tfor (k=0, j=0, modltype=nrnocCONST; modltype<=modltypemax; modltype++, j++){\n\t\t/*EMPTY*/\n\t\tfor (; m2[j]; j++, k++) {\n\t\t\t;\n\t\t}\n\t}\n\ts->s_varn = k;\n\ts->u.ppsym = (Symbol **) emalloc((unsigned)(j*sizeof(Symbol *)));\n/* this is set up for the possiblility of overloading range variables.\nWe are currently not allowing this. Hence the #if.\nIf never overloaded then no reason for list of symbols for each mechanism.\n*/\n/* the indexing is confusing because k refers to index in the range indx list\nand j refers to index in mechanism list which has 0 elements to separate\nnrnocCONST, DEPENDENT, and STATE */\n/* variable pointers added on at end, if they exist */\n/* allowing range variable arrays. Must extract dimension info from name[%d]*/\n/* pindx refers to index into the p-array */\n\tpindx = 0;\n\tfor (j=0, k=0, modltype=nrnocCONST; modltype <= modltypemax; modltype++, j++) {\n\t\tfor (; m2[j]; j++, k++) {\n\t\t\tSymbol *s2;\n\t\t\tchar buf[200], *cp; int indx; unsigned nsub=0;\n\t\t\tstrcpy(buf, m2[j]); /* not allowed to change constant string */\n\t\t\tindx = 1;\n\t\t\tcp = strchr(buf, '[');\n\t\t\tif (cp) {\n#if EXTRACELLULAR\n\t\t\t\tif (cp[1] == 'N') {\n\t\t\t\t\tindx = nlayer;\n\t\t\t\t}else\n#endif\n\t\t\t\t{\n\t\t\t\t\tsscanf(cp+1, \"%d\", &indx);\n\t\t\t\t}\n\t\t\t\tnsub = 1;\n\t\t\t\t*cp = '\\0';\n\t\t\t}\n\t\t\t/*SUPPRESS 624*/\n\t\t\tif ((s2 = hoc_lookup(buf))) {\n#if 0\n\t\t\t\tif (s2->subtype != RANGEVAR) {\n\t\t\t\t\tIGNORE(fprintf(stderr, CHKmes,\n\t\t\t\t\tbuf));\n\t\t\t\t}\n#else\nIGNORE(fprintf(stderr, CHKmes, buf));\n#endif\n\t\t\t}else{\n\t\t\t  s2 = hoc_install(buf, RANGEVAR, 0.0, &hoc_symlist);\n\t\t\t\ts2->subtype = modltype;\n\t\t\t\ts2->u.rng.type = type;\n\t\t\t\ts2->public = 1;\n\t\t\t\tif (modltype == NRNPOINTER) { /* not in p array */\n\t\t\t\t\ts2->u.rng.index = nrnpointerindex;\n\t\t\t\t} else {\n\t\t\t\t\ts2->u.rng.index = pindx;\n\t\t\t\t}\n\t\t\t  if (nsub) {\n\t\t\t\ts2->arayinfo = (Arrayinfo *) emalloc(\n\t\t\t\t  sizeof(Arrayinfo) + nsub * sizeof(int));\n\t\t\t\ts2->arayinfo->a_varn = (unsigned *)0;\n\t\t\t\ts2->arayinfo->refcount = 1;\n\t\t\t\ts2->arayinfo->nsub = nsub;\n\t\t\t\ts2->arayinfo->sub[0] = indx;\n\t\t\t  }\n\t\t\t  if (modltype == NRNPOINTER) {\n\t\t\t\tif (nrn_dparam_ptr_end_[type] == 0) {\n\t\t\t\t\tnrn_dparam_ptr_start_[type] = nrnpointerindex;\n\t\t\t\t}\n\t\t\t\tnrnpointerindex += indx;\n\t\t\t\tnrn_dparam_ptr_end_[type] = nrnpointerindex;\n\t\t\t  }else {\n\t\t\t\tpindx += indx;\n\t\t\t  }\n\t\t\t}\n\t\t\ts->u.ppsym[k] = s2;\n\t\t}\n\t}\n\t++type;\n\tn_memb_func = type;\n}\n\nvoid register_mech(\n\tconst char **m,\n\tPvmp alloc,\n\tPvmi cur,\n\tPvmi jacob,\n\tPvmi stat,\n\tPvmi initialize,\n\tint nrnpointerindex, /* if -1 then there are none */\n\tint vectorized\n){\n\tint type = n_memb_func;\n\tnrn_register_mech_common(m, alloc, cur, jacob, stat, initialize,\n\t\tnrnpointerindex, vectorized);\n\tif (nrnpy_reg_mech_p_) {\n\t\t(*nrnpy_reg_mech_p_)(type);\n\t}\n}\n\nvoid nrn_writes_conc(int type, int unused) {\n\tstatic int lastion = EXTRACELL+1;\n\tint i;\n\tfor (i=n_memb_func - 2; i >= lastion; --i) {\n\t\tmemb_order_[i+1] = memb_order_[i];\n\t}\n\tmemb_order_[lastion] = type;\n#if 0\n\tprintf(\"%s reordered from %d to %d\\n\", memb_func[type].sym->name, type, lastion);\n#endif\n\tif (nrn_is_ion(type)) {\n\t\t++lastion;\n\t}\n}\n\nvoid hoc_register_prop_size(int type, int psize, int dpsize) {\n\tnrn_prop_param_size_[type] = psize;\n\tnrn_prop_dparam_size_[type] = dpsize;\n\tif (memb_func[type].dparam_semantics) {\n\t\tfree(memb_func[type].dparam_semantics);\n\t\tmemb_func[type].dparam_semantics = (int*)0;\n\t}\n\tif (dpsize) {\n\t  memb_func[type].dparam_semantics = (int*)ecalloc(dpsize, sizeof(int));\n\t}\n}\nvoid hoc_register_dparam_semantics(int type, int ix, const char* name) {\n\t/* only interested in area, iontype, cvode_ieq,\n\t   netsend, pointer, pntproc, bbcorepointer, watch, diam,\n\t   fornetcon,\n\t   xx_ion and #xx_ion which will get\n\t   a semantics value of -1, -2, -3,\n\t   -4, -5, -6, -7, -8, -9, -10\n\t   type, and type+1000 respectively\n\t*/\n\tif (strcmp(name, \"area\") == 0) {\n\t\tmemb_func[type].dparam_semantics[ix] = -1;\n\t}else if (strcmp(name, \"iontype\") == 0) {\n\t\tmemb_func[type].dparam_semantics[ix] = -2;\n\t}else if (strcmp(name, \"cvodeieq\") == 0) {\n\t\tmemb_func[type].dparam_semantics[ix] = -3;\n\t}else if (strcmp(name, \"netsend\") == 0) {\n\t\tmemb_func[type].dparam_semantics[ix] = -4;\n\t}else if (strcmp(name, \"pointer\") == 0) {\n\t\tmemb_func[type].dparam_semantics[ix] = -5;\n\t}else if (strcmp(name, \"pntproc\") == 0) {\n\t\tmemb_func[type].dparam_semantics[ix] = -6;\n\t}else if (strcmp(name, \"bbcorepointer\") == 0) {\n\t\tmemb_func[type].dparam_semantics[ix] = -7;\n\t}else if (strcmp(name, \"watch\") == 0) {\n\t\tmemb_func[type].dparam_semantics[ix] = -8;\n\t}else if (strcmp(name, \"diam\") == 0) {\n\t\tmemb_func[type].dparam_semantics[ix] = -9;\n\t}else if (strcmp(name, \"fornetcon\") == 0) {\n\t\tmemb_func[type].dparam_semantics[ix] = -10;\n\t}else{\n\t\tint i = 0;\n\t\tif (name[0] == '#') { i = 1; }\n\t\tSymbol* s = hoc_lookup(name+i);\n\t\tif (s && s->type == MECHANISM) {\n\t\t\tmemb_func[type].dparam_semantics[ix] = s->subtype + i*1000;\n\t\t}else{\nfprintf(stderr, \"mechanism %s : unknown semantics for %s\\n\", memb_func[type].sym->name, name);\nassert(0);\n\t\t}\n\t}\n#if 0   \n\tprintf(\"dparam semantics %s ix=%d %s %d\\n\", memb_func[type].sym->name,\n\t  ix, name, memb_func[type].dparam_semantics[ix]);\n#endif\n}\n\n#if CVODE\nvoid hoc_register_cvode(\n\tint i,\n\tnrn_ode_count_t cnt,\n\tnrn_ode_map_t map,\n\tPvmi spec,\n\tPvmi matsol\n){\n\tmemb_func[i].ode_count = cnt;\n\tmemb_func[i].ode_map = map;\n\tmemb_func[i].ode_spec = spec;\n\tmemb_func[i].ode_matsol = matsol;\n}\nvoid hoc_register_synonym(int i, void (*syn)(int, double**, Datum**)){\n\tmemb_func[i].ode_synonym = syn;\n}\n#endif\n\nvoid register_destructor(Pvmp d) {\n\tmemb_func[n_memb_func - 1].destructor = d;\n}\n\nint point_reg_helper(Symbol* s2) {\n\tpointsym[pointtype] = s2;\n\ts2->public = 0;\n\tpnt_map[n_memb_func-1] = pointtype;\n\tmemb_func[n_memb_func-1].is_point = 1;\n\tif (nrnpy_reg_mech_p_) {\n\t\t(*nrnpy_reg_mech_p_)(n_memb_func-1);\n\t}\n\treturn pointtype++;\n}\n\nint point_register_mech(\n\tconst char **m,\n\tPvmp alloc,\n\tPvmi cur,\n\tPvmi jacob,\n\tPvmi stat,\n\tPvmi initialize,\n\tint nrnpointerindex,\n\tint vectorized,\n\n\tvoid* (*constructor)(Object*),\n\tvoid (*destructor)(void*),\n\tMember_func* fmember\n){\n\textern void steer_point_process();\n\tSymlist* sl;\n\tSymbol* s, *s2;\n\tvoid class2oc();\n\tnrn_load_name_check(m[1]);\n\tclass2oc(m[1], constructor, destructor, fmember, (void*)0, (void*)0, (void*)0);\n\ts = hoc_lookup(m[1]);\n\tsl = hoc_symlist;\n\thoc_symlist = s->u.template->symtable;\n\ts->u.template->steer = steer_point_process;\n\ts->u.template->is_point_ = pointtype;\n\tnrn_register_mech_common(m, alloc, cur, jacob, stat, initialize,\n\t\tnrnpointerindex, vectorized);\n\tnrn_pnt_template_[n_memb_func-1] = s->u.template;\n\ts2 = hoc_lookup(m[1]);\n\thoc_symlist = sl;\n\treturn point_reg_helper(s2);\n}\n\n/* some stuff from scopmath needed for built-in models */\n \n#if 0\ndouble* makevector(int nrows)\n{\n        double* v;\n        v = (double*)emalloc((unsigned)(nrows*sizeof(double)));\n        return v;\n}\n#endif\n  \nint _ninits;\nvoid _modl_cleanup(void){}\n\n#if 1\nvoid _modl_set_dt(double newdt) {\n\tdt = newdt;\n\tnrn_threads->_dt = newdt;\n}\nvoid _modl_set_dt_thread(double newdt, NrnThread* nt) {\n\tnt->_dt = newdt;\n}\ndouble _modl_get_dt_thread(NrnThread* nt) {\n\treturn nt->_dt;\n}\n#endif\t\n\nint nrn_pointing(double* pd) {\n\treturn pd ? 1 : 0;\n}\n\nint state_discon_flag_ = 0;\nvoid state_discontinuity(int i, double* pd, double d) {\n\tif (state_discon_allowed_ && state_discon_flag_ == 0) {\n\t\t*pd = d;\n/*printf(\"state_discontinuity t=%g pd=%lx d=%g\\n\", t, (long)pd, d);*/\n\t}\n}\n\nvoid hoc_register_limits(int type, HocParmLimits* limits)\n{\n\tint i;\n\tSymbol* sym;\n\tfor (i=0; limits[i].name; ++i) {\n\t\tsym = (Symbol*)0;\n\t\tif (type && memb_func[type].is_point) {\n\t\t\tSymbol* t;\n\t\t\tt = hoc_lookup(memb_func[type].sym->name);\n\t\t\tsym = hoc_table_lookup(\n\t\t\t\tlimits[i].name,\n\t\t\t\tt->u.template->symtable\n\t\t\t);\n\t\t}\n\t\tif (!sym) {\n\t\t\tsym = hoc_lookup(limits[i].name);\n\t\t}\n\t\thoc_symbol_limits(sym, limits[i].bnd[0], limits[i].bnd[1]);\n\t}\n}\n\nvoid hoc_register_units(int type, HocParmUnits* units)\n{\n\tint i;\n\tSymbol* sym;\n\tfor (i=0; units[i].name; ++i) {\n\t\tsym = (Symbol*)0;\n\t\tif (type && memb_func[type].is_point) {\n\t\t\tSymbol* t;\n\t\t\tt = hoc_lookup(memb_func[type].sym->name);\n\t\t\tsym = hoc_table_lookup(\n\t\t\t\tunits[i].name,\n\t\t\t\tt->u.template->symtable\n\t\t\t);\n\t\t}\n\t\tif (!sym) {\n\t\t\tsym = hoc_lookup(units[i].name);\n\t\t}\n\t\thoc_symbol_units(sym, units[i].units);\n\t}\n}\n\nvoid hoc_reg_ba(int mt, nrn_bamech_t f, int type)\n{\n\tBAMech* bam;\n\tswitch (type) { /* see bablk in src/nmodl/nocpout.c */\n\tcase 11: type = BEFORE_BREAKPOINT; break;\n\tcase 22: type = AFTER_SOLVE; break;\n\tcase 13: type = BEFORE_INITIAL; break;\n\tcase 23: type = AFTER_INITIAL; break;\n\tcase 14: type = BEFORE_STEP; break;\n\tdefault:\nprintf(\"before-after processing type %d for %s not implemented\\n\", type, memb_func[mt].sym->name);\n\t\tnrn_exit(1);\n\t}\n\tbam = (BAMech*)emalloc(sizeof(BAMech));\n\tbam->f = f;\n\tbam->type = mt;\n\tbam->next = bamech_[type];\n\tbamech_[type] = bam;\n}\n\nvoid _cvode_abstol(Symbol** s, double* tol, int i)\n{\n#if CVODE\n\tif (s && s[i]->extra) {\n\t\tdouble x;\n\t\tx = s[i]->extra->tolerance;\n\t\tif (x != 0) {\n\t\t\ttol[i] *= x;\n\t\t}\n\t}\n#endif\n}\n\nvoid hoc_register_tolerance(int type, HocStateTolerance* tol, Symbol*** stol)\n{\n#if CVODE\n\tint i;\n\tSymbol* sym;\n/*printf(\"register tolerance for %s\\n\", memb_func[type].sym->name);*/\n\tfor (i = 0; tol[i].name; ++i) {\n\t\tif (memb_func[type].is_point) {\n\t\t\tSymbol* t;\n\t\t\tt = hoc_lookup(memb_func[type].sym->name);\n\t\t\tsym = hoc_table_lookup(\n\t\t\t\ttol[i].name,\n\t\t\t\tt->u.template->symtable\n\t\t\t);\n\t\t}else{\n\t\t\tsym = hoc_lookup(tol[i].name);\n\t\t}\n\t\thoc_symbol_tolerance(sym, tol[i].tolerance);\n\t}\t\t\t\n\n\tif (memb_func[type].ode_count) {\n\t\tSymbol** psym, *msym, *vsym;\n\t\tdouble **pv;\n\t\tNode** pnode;\n\t\tProp* p;\n\t\textern Node** node_construct();\n\t\tint i, j, k, n, na, index=0;\n\t\t\n\t\tn = (*memb_func[type].ode_count)(type);\n\t\tif (n > 0) {\n\t\t\tpsym = (Symbol**)ecalloc(n, sizeof(Symbol*));\n\t\t\tpv = (double**)ecalloc(2*n, sizeof(double*));\n\t\t\tpnode = node_construct(1);\nprop_alloc(&(pnode[0]->prop), MORPHOLOGY, pnode[0]); /* in case we need diam */\np = prop_alloc(&(pnode[0]->prop), type, pnode[0]); /* this and any ions */\n(*memb_func[type].ode_map)(0, pv, pv+n, p->param, p->dparam, (double*)0, type);\n\t\t\tfor (i=0; i < n; ++i) {\n\t\t\t\tfor (p = pnode[0]->prop; p; p = p->next) {\n\t\t\t\t\tif (pv[i] >= p->param && pv[i] < (p->param + p->param_size)) {\n\t\t\t\t\t\tindex = pv[i] - p->param;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* p is the prop and index is the index\n\t\t\t\t\tinto the p->param array */\n\t\t\t\tassert(p);\n\t\t\t\t/* need to find symbol for this */\n\t\t\t\tmsym = memb_func[p->type].sym;\n\t\t\t\tfor (j=0; j < msym->s_varn; ++j) {\n\t\t\t\t\tvsym = msym->u.ppsym[j];\n\t\t\t\t\tif (vsym->type == RANGEVAR && vsym->u.rng.index == index) {\n\t\t\t\t\t\tpsym[i] = vsym;\n/*printf(\"identified %s at index %d of %s\\n\", vsym->name, index, msym->name);*/\n\t\t\t\t\t\tif (ISARRAY(vsym)) {\n\t\t\t\t\t\t\tna = vsym->arayinfo->sub[0];\n\t\t\t\t\t\t\tfor (k=1; k < na; ++k) {\n\t\t\t\t\t\t\t\tpsym[++i] = vsym;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t\tassert (j < msym->s_varn);\n\t\t\t}\n\t\t\t\t\t\n\t\t\tnode_destruct(pnode, 1);\n\t\t\t*stol = psym;\n\t\t\tfree (pv);\n\t\t}\n\t}\n#endif\n}\n\nvoid _nrn_thread_reg(int i, int cons, void(*f)(Datum*)) {\n\tif (cons == 1) {\n\t\tmemb_func[i].thread_mem_init_ = f;\n\t}else if (cons == 0) {\n\t\tmemb_func[i].thread_cleanup_ = f;\n\t}else if (cons == 2) {\n\t\tmemb_func[i]._update_ion_pointers = f;\n\t}\n}\n\nvoid _nrn_thread_table_reg(int i, void(*f)(double*, Datum*, Datum*, void*, int)) {\n\tmemb_func[i].thread_table_check_ = f;\n}\n\nvoid _nrn_setdata_reg(int i, void(*call)(Prop*)) {\n\tmemb_func[i].setdata_ = call;\n}\n/* there is some question about the _extcall_thread variables, if any. */\ndouble nrn_call_mech_func(Symbol* s, int narg, Prop* p, int type) {\n\tdouble x;\t\n\textern double hoc_call_func(Symbol*, int);\n\tvoid (*call)(Prop*) = memb_func[type].setdata_;\n\tif (call) {\n\t\t(*call)(p);\n\t}\n\tx = hoc_call_func(s, narg);\n\treturn x;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/nrnoc/osxdlfcn.c": "/*\nCopyright (c) 2002 Peter O'Gorman <ogorman@users.sourceforge.net>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n/* Just to prove that it isn't that hard to add Mac calls to your code :)\n   This works with pretty much everything, including kde3 xemacs and the gimp,\n   I'd guess that it'd work in at least 95% of cases, use this as your starting\n   point, rather than the mess that is dlfcn.c, assuming that your code does not\n   require ref counting or symbol lookups in dependent libraries\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <mach-o/dyld.h>\n#include \"osxdlfcn.h\"\n\n#define ERR_STR_LEN 256\nstatic void *dlsymIntern(void *handle, const char *symbol);\nstatic const char *error(int setget, const char *str, ...);\n\n\n\n/* Set and get the error string for use by dlerror */\nstatic const char *error(int setget, const char *str, ...)\n{\n\tstatic char errstr[ERR_STR_LEN];\n\tstatic int err_filled = 0;\n\tconst char *retval;\n\tNSLinkEditErrors ler;\n\tint lerno;\n\tconst char *dylderrstr;\n\tconst char *file;\n\tva_list arg;\n\tif (setget <= 0)\n\t{\n\t\tva_start(arg, str);\n\t\tstrncpy(errstr, \"dlsimple: \", ERR_STR_LEN);\n\t\tvsnprintf(errstr + 10, ERR_STR_LEN - 10, str, arg);\n\t\tva_end(arg);\n\t/* We prefer to use the dyld error string if getset is 1*/\n\t\tif (setget == 0) {\n\t\t\tNSLinkEditError(&ler, &lerno, &file, &dylderrstr);\n\t\t\tfprintf(stderr,\"dyld: %s\\n\",dylderrstr);\n\t\t\tif (dylderrstr && strlen(dylderrstr))\n\t\t\t\tstrncpy(errstr,dylderrstr,ERR_STR_LEN);\n\t\t}\t\t\n\t\terr_filled = 1;\n\t\tretval = NULL;\n\t}\n\telse\n\t{\n\t\tif (!err_filled)\n\t\t\tretval = NULL;\n\t\telse\n\t\t\tretval = errstr;\n\t\terr_filled = 0;\n\t}\n\treturn retval;\n}\n\n/* dlopen */\nvoid *dlopen(const char *path, int mode)\n{\n\tvoid *module = 0;\n\tNSObjectFileImage ofi = 0;\n\tNSObjectFileImageReturnCode ofirc;\n\tstatic int (*make_private_module_public) (NSModule module) = 0;\n\tunsigned int flags =  NSLINKMODULE_OPTION_RETURN_ON_ERROR | NSLINKMODULE_OPTION_PRIVATE;\n\n\t/* If we got no path, the app wants the global namespace, use -1 as the marker\n\t   in this case */\n\tif (!path)\n\t\treturn (void *)-1;\n\n\t/* Create the object file image, works for things linked with the -bundle arg to ld */\n\tofirc = NSCreateObjectFileImageFromFile(path, &ofi);\n\tswitch (ofirc)\n\t{\n\t\tcase NSObjectFileImageSuccess:\n\t\t\t/* It was okay, so use NSLinkModule to link in the image */\n\t\t\tif (!(mode & RTLD_LAZY)) flags += NSLINKMODULE_OPTION_BINDNOW;\n\t\t\tmodule = NSLinkModule(ofi, path,flags);\n\t\t\t/* Don't forget to destroy the object file image, unless you like leaks */\n\t\t\tNSDestroyObjectFileImage(ofi);\n\t\t\t/* If the mode was global, then change the module, this avoids\n\t\t\t   multiply defined symbol errors to first load private then make\n\t\t\t   global. Silly, isn't it. */\n\t\t\tif ((mode & RTLD_GLOBAL))\n\t\t\t{\n\t\t\t  if (!make_private_module_public)\n\t\t\t  {\n\t\t\t    _dyld_func_lookup(\"__dyld_NSMakePrivateModulePublic\", \n\t\t\t\t(unsigned long *)&make_private_module_public);\n\t\t\t  }\n\t\t\t  make_private_module_public(module);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NSObjectFileImageInappropriateFile:\n\t\t\t/* It may have been a dynamic library rather than a bundle, try to load it */\n\t\t\tmodule = (void *)NSAddImage(path, NSADDIMAGE_OPTION_RETURN_ON_ERROR);\n\t\t\tbreak;\n\t\tcase NSObjectFileImageFailure:\n\t\t\terror(0,\"Object file setup failure :  \\\"%s\\\"\", path);\n\t\t\treturn 0;\n\t\tcase NSObjectFileImageArch:\n\t\t\terror(0,\"No object for this architecture :  \\\"%s\\\"\", path);\n\t\t\treturn 0;\n\t\tcase NSObjectFileImageFormat:\n\t\t\terror(0,\"Bad object file format :  \\\"%s\\\"\", path);\n\t\t\treturn 0;\n\t\tcase NSObjectFileImageAccess:\n\t\t\terror(0,\"Can't read object file :  \\\"%s\\\"\", path);\n\t\t\treturn 0;\t\t\n\t}\n\tif (!module)\n\t\terror(0, \"Can not open \\\"%s\\\"\", path);\n\treturn module;\n}\n\n/* dlsymIntern is used by dlsym to find the symbol */\nvoid *dlsymIntern(void *handle, const char *symbol)\n{\n\tNSSymbol *nssym = 0;\n\t/* If the handle is -1, if is the app global context */\n\tif (handle == (void *)-1)\n\t{\n\t\t/* Global context, use NSLookupAndBindSymbol */\n\t\tif (NSIsSymbolNameDefined(symbol))\n\t\t{\n\t\t\tnssym = NSLookupAndBindSymbol(symbol);\n\t\t}\n\n\t}\n\t/* Now see if the handle is a struch mach_header* or not, use NSLookupSymbol in image\n\t   for libraries, and NSLookupSymbolInModule for bundles */\n\telse\n\t{\n\t\t/* Check for both possible magic numbers depending on x86/ppc byte order */\n\t\tif ((((struct mach_header *)handle)->magic == MH_MAGIC) ||\n\t\t\t(((struct mach_header *)handle)->magic == MH_CIGAM))\n\t\t{\n\t\t\tif (NSIsSymbolNameDefinedInImage((struct mach_header *)handle, symbol))\n\t\t\t{\n\t\t\t\tnssym = NSLookupSymbolInImage((struct mach_header *)handle,\n\t\t\t\t\t\t\t\t\t\t\t  symbol,\n\t\t\t\t\t\t\t\t\t\t\t  NSLOOKUPSYMBOLINIMAGE_OPTION_BIND\n\t\t\t\t\t\t\t\t\t\t\t  | NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR);\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnssym = NSLookupSymbolInModule(handle, symbol);\n\t\t}\n\t}\n\tif (!nssym)\n\t{\n\t\terror(0, \"Symbol \\\"%s\\\" Not found\", symbol);\n\t\treturn NULL;\n\t}\n\treturn NSAddressOfSymbol(nssym);\n}\n\nconst char *dlerror(void)\n{\n\treturn error(1, (char *)NULL);\n}\n\nint dlclose(void *handle)\n{\n\tif ((((struct mach_header *)handle)->magic == MH_MAGIC) ||\n\t\t(((struct mach_header *)handle)->magic == MH_CIGAM))\n\t{\n\t\terror(-1, \"Can't remove dynamic libraries on darwin\");\n\t\treturn 0;\n\t}\n\tif (!NSUnLinkModule(handle, 0))\n\t{\n\t\terror(0, \"unable to unlink module %s\", NSNameOfModule(handle));\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\n/* dlsym, prepend the underscore and call dlsymIntern */\nvoid *dlsym(void *handle, const char *symbol)\n{\n\tstatic char undersym[257];\t/* Saves calls to malloc(3) */\n\tint sym_len = strlen(symbol);\n\tvoid *value = NULL;\n\tchar *malloc_sym = NULL;\n\n\tif (sym_len < 256)\n\t{\n\t\tsnprintf(undersym, 256, \"_%s\", symbol);\n\t\tvalue = dlsymIntern(handle, undersym);\n\t}\n\telse\n\t{\n\t\tmalloc_sym = malloc(sym_len + 2);\n\t\tif (malloc_sym)\n\t\t{\n\t\t\tsprintf(malloc_sym, \"_%s\", symbol);\n\t\t\tvalue = dlsymIntern(handle, malloc_sym);\n\t\t\tfree(malloc_sym);\n\t\t}\n\t\telse\n\t\t{\n\t\t\terror(-1, \"Unable to allocate memory\");\n\t\t}\n\t}\n\treturn value;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/nrniv/nrnpy.cpp": "#include <../../nrnconf.h>\n// For Linux and Max OS X,\n// Solve the problem of not knowing what version of Python the user has by\n// possibly deferring linking to libnrnpython.so to run time using the proper\n// Python interface\n\n#include <../nrnpython/nrnpython_config.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <InterViews/resource.h>\n#include \"nrnoc2iv.h\"\n#include \"classreg.h\"\n#include \"nonvintblock.h\"\n#include \"nrnmpi.h\"\n\nextern \"C\" {\nextern int nrn_nopython;\nextern int nrnpy_nositeflag;\nextern char* nrnpy_pyexe;\nextern int nrn_is_python_extension;\nint* nrnpy_site_problem_p;\nextern void (*p_nrnpython_start)(int);\nvoid nrnpython();\nstatic void (*p_nrnpython_real)();\nstatic void (*p_nrnpython_reg_real)();\nchar* hoc_back2forward(char* s);\nchar* hoc_forward2back(char* s);\n}\n\n// following is undefined or else has the value of sys.api_version\n// at time of configure (using the python first in the PATH).\n#if defined(NRNPYTHON_DYNAMICLOAD)\n\n#if defined(NRNCMAKE)\n// CMAKE installs libnrnpythonx.so not in <prefix>/x86_64/lib but <prefix>/lib\n#undef NRNHOSTCPU\n#define NRNHOSTCPU \".\"\n#endif\n\n#ifdef MINGW\n#define RTLD_NOW 0\n#define RTLD_GLOBAL 0\n#define RTLD_NOLOAD 0\nextern \"C\" {\nextern void* dlopen_noerr(const char* name, int mode);\n#define dlopen dlopen_noerr\nextern void* dlsym(void* handle, const char* name);\nextern int dlclose(void* handle);\nextern char* dlerror();\n}\n#else\n//#define _GNU_SOURCE\n#include <dlfcn.h>\n#endif\n\nextern \"C\" {\nextern char* neuron_home;\n}\n\n#if NRNPYTHON_DYNAMICLOAD >= 20 && NRNPYTHON_DYNAMICLOAD < 30\n\n#ifdef MINGW\nstatic const char* ver[] = {\"2.7\", 0};\n#else\nstatic const char* ver[] = {\"2.7\", \"2.6\", \"2.5\", 0};\n#endif // !MINGW\n\n#elif NRNPYTHON_DYNAMICLOAD >= 30\n\n#ifdef MINGW\nstatic const char* ver[] = {\"3.5\", 0};\n#else\nstatic const char* ver[] = {\"3.6\", \"3.5\", \"3.4\", 0};\n#endif // !MINGW\n\n#else //NRNPYTHON_DYNAMICLOAD < 20\n\nstatic const char* ver[] = {0};\n\n#endif //NRNPYTHON_DYNAMICLOAD < 20\n\nstatic int iver; // which python is loaded?\nstatic void* python_already_loaded();\nstatic void* load_python();\nstatic void load_nrnpython(int, const char*);\n#else //!defined(NRNPYTHON_DYNAMICLOAD)\nextern \"C\" {\nextern void nrnpython_start(int);\nextern void nrnpython_reg_real();\nextern void nrnpython_real();\n}\n#endif //defined(NRNPYTHON_DYNAMICLOAD)\n\nchar* nrnpy_pyhome;\n\nvoid nrnpython() {\n#if USE_PYTHON\n\tif (p_nrnpython_real) {\n\t\t(*p_nrnpython_real)();\n\t\treturn;\n\t}\n#endif\t\n\thoc_retpushx(0.);\n}\n\n// Stub class for when Python does not exist\nstatic void* p_cons(Object*) {\n\treturn 0;\n}\nstatic void p_destruct(void* v) {\n}\nstatic Member_func p_members[] = {0,0};\n\n#if NRNPYTHON_DYNAMICLOAD\nstatic char* nrnpy_pylib;\n\nstatic void siteprob(void) {\n\tif (nrnpy_site_problem_p && (*nrnpy_site_problem_p)) {\nprintf(\"Py_Initialize exited. PYTHONHOME probably needs to be set correctly.\\n\");\n\t\tif(nrnpy_pyhome) {\nprintf(\"The value of PYTHONHOME or our automatic guess based on the output of nrnpyenv.sh:\\n    export PYTHONHOME=%s\\ndid not work.\\n\", nrnpy_pyhome);\n\t\t}\nprintf(\"It will help to examine the output of:\\nnrnpyenv.sh\\n\\\nand set the indicated environment variables, or avoid python by adding\\n\\\nnopython: on\\n\\\nto %s/lib/nrn.defaults (or .nrn.defaults in your $HOME directory)\\n\",\nneuron_home);\n\t}\n}\n\nstatic void set_nrnpylib() {\n  nrnpy_pylib = getenv(\"NRN_PYLIB\");\n  nrnpy_pyhome = getenv(\"PYTHONHOME\");\n  if (nrnpy_pylib && nrnpy_pyhome) { return; }\n  // copy allows free of the copy if needed\n  if (nrnpy_pylib) { nrnpy_pylib = strdup(nrnpy_pylib); }\n  if (nrnpy_pyhome) { nrnpy_pyhome = strdup(nrnpy_pyhome); }\n\n  if (nrnmpi_myid_world == 0) {\n    int linesz = 1024 + (nrnpy_pyexe ? strlen(nrnpy_pyexe) : 0);\n    #ifdef MINGW\n    linesz += 3*strlen(neuron_home);\n    char* line = new char[linesz+1];\n    char* bnrnhome = strdup(neuron_home);\n    char* fnrnhome = strdup(neuron_home);\n    hoc_forward2back(bnrnhome);\n    hoc_back2forward(fnrnhome);\n    sprintf(line, \"%s\\\\mingw\\\\usr\\\\bin\\\\bash %s/bin/nrnpyenv.sh %s --NEURON_HOME=%s\",\n      bnrnhome,\n      fnrnhome,\n      (nrnpy_pyexe && strlen(nrnpy_pyexe) > 0) ? nrnpy_pyexe : \"\",\n      fnrnhome);\n    free(fnrnhome);\n    free(bnrnhome);\n    #else\n    char* line = new char[linesz+1];\n#if defined(NRNCMAKE)\n    sprintf(line, \"bash %s/../../bin/nrnpyenv.sh %s\",\n     neuron_home,\n#else\n    sprintf(line, \"bash %s/../../%s/bin/nrnpyenv.sh %s\",\n     neuron_home, NRNHOSTCPU,\n#endif\n      (nrnpy_pyexe && strlen(nrnpy_pyexe) > 0) ? nrnpy_pyexe : \"\");\n   #endif\n    FILE* p = popen(line, \"r\");\n    if (!p) {\n      printf(\"could not popen '%s'\\n\", line);\n    }else{\n      if (!fgets(line, linesz, p)) {\n        printf(\"failed: %s\\n\", line);\n      }\n      while(fgets(line, linesz, p)) {\n        char* cp;\n        // must get rid of beginning '\"' and trailing '\"\\n'\n        if (!nrnpy_pyhome && (cp = strstr(line, \"export PYTHONHOME=\"))) {\n          cp += 19;\n          cp[strlen(cp) - 2] = '\\0';\n          if (nrnpy_pyhome) { free(nrnpy_pyhome); }\n          nrnpy_pyhome = strdup(cp);\n        }else if (!nrnpy_pylib && (cp = strstr(line, \"export NRN_PYLIB=\"))) {\n          cp += 18;\n          cp[strlen(cp) - 2] = '\\0';\n          if (nrnpy_pylib) { free(nrnpy_pylib); }\n          nrnpy_pylib = strdup(cp);\n        }\n      }\n      pclose(p);\n    }\n    delete [] line;\n  }\n#if NRNMPI\n  if (nrnmpi_numprocs_world > 1) { // 0 broadcasts to everyone else.\n    nrnmpi_char_broadcast_world(&nrnpy_pylib, 0);\n    nrnmpi_char_broadcast_world(&nrnpy_pyhome, 0);\n  }\n#endif\n}\n\n#if 0\nstatic void set_pythonhome(void* handle){\n\tif (nrnmpi_myid == 0) {atexit(siteprob);}\n#ifdef MINGW\n#else\n\tif (getenv(\"PYTHONHOME\") || nrnpy_nositeflag) { return; }\n\tif (nrnpy_pyhome) {\n\t\tint res = setenv(\"PYTHONHOME\", nrnpy_pyhome, 1);\n\t\tassert(res == 0);\n\t\treturn;\n\t}\n\n\tDl_info dl_info;\n\tvoid* s = dlsym(handle, \"Py_Initialize\");\n        assert(s != NULL);\n\tint success = dladdr(s, &dl_info);\n\tif (success) {\n\t\t//printf(\"%s\\n\", dl_info.dli_fname);\n\t\tnrnpy_pyhome = strdup(dl_info.dli_fname);\n\t\tchar* p = nrnpy_pyhome;\n\t\tint n = strlen(p);\n\t\tint seen = 0;\n\t\tfor (int i = n-1; i > 0; --i) {\n\t\t\tif (p[i] == '/') {\n\t\t\t\tif (++seen >= 2) {\n\t\t\t\t\tp[i] = '\\0' ;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = setenv(\"PYTHONHOME\", p, 1);\n\t\tassert(res == 0);\n\t}\n#endif\n}\n#endif // if 0\n#endif\n\nvoid nrnpython_reg() {\n\t//printf(\"nrnpython_reg in nrnpy.cpp\\n\");\n#if USE_PYTHON\n    if (nrn_nopython) {\n\tp_nrnpython_start = 0;\n\tp_nrnpython_real = 0;\n\tp_nrnpython_reg_real = 0;\n    }else{\n#if NRNPYTHON_DYNAMICLOAD\n\tvoid* handle = NULL;\n\n      if (!nrn_is_python_extension) {\n\t// As last resort (or for python3) load $NRN_PYLIB\n\tset_nrnpylib();\n\t//printf(\"nrnpy_pylib %s\\n\", nrnpy_pylib);\n\t//printf(\"nrnpy_pyhome %s\\n\", nrnpy_pyhome);\n\tif (nrnpy_pylib) {\n\t\thandle = dlopen(nrnpy_pylib, RTLD_NOW|RTLD_GLOBAL);\n\t\tif (!handle) {\n\t\t\tfprintf(stderr, \"Could not dlopen NRN_PYLIB: %s\\n\", nrnpy_pylib);\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (!handle) { python_already_loaded();}\n\tif (!handle) { // embed python\n\t\thandle = load_python();\n\t}\n#if 0\n\t// No longer do this as Py_SetPythonHome is used\n\tif (handle) {\n\t\t// need to worry about the site.py problem\n\t\t// can fix with a proper PYTHONHOME but need to know\n\t\t// what path was used to load the python library.\n\t\tset_pythonhome(handle);\n\t}\n#endif\n      }else{\n        //printf(\"nrn_is_python_extension = %d\\n\", nrn_is_python_extension);\n      }\n\t// for some mysterious reason on max osx 10.12\n\t// (perhaps due to System Integrity Protection?) when python is\n\t// launched, python_already_loaded() returns a NULL handle unless\n\t// the full path to the dylib is used. Since we know it is loaded\n\t// in these circumstances, it is sufficient to go ahead and dlopen\n\t// the nrnpython interface library\n\tif (handle || nrn_is_python_extension) {\n\t\tload_nrnpython(nrn_is_python_extension, nrnpy_pylib);\n\t}\n#else\n\tp_nrnpython_start = nrnpython_start;\n\tp_nrnpython_real = nrnpython_real;\n\tp_nrnpython_reg_real = nrnpython_reg_real;\n#endif\n    }\n\tif (p_nrnpython_reg_real) {\n\t\t(*p_nrnpython_reg_real)();\n\t\tif (nrnpy_site_problem_p) {\n\t\t\t*nrnpy_site_problem_p = 1;\n\t\t}\n\t\treturn;\n\t}\n#endif\n\tclass2oc(\"PythonObject\", p_cons, p_destruct, p_members, NULL, NULL, NULL);\n}\n\n#if NRNPYTHON_DYNAMICLOAD // to end of file\n\n// important dlopen flags :\n// RTLD_NOLOAD returns NULL if not open, or handle if it is resident.\n\nstatic void* ver_dlo(int flag) {\n\tfor (int i = 0; ver[i]; ++i) {\n\t\tchar name[100];\n#ifdef MINGW\n\t\tsprintf(name, \"python%c%c.dll\", ver[i][0], ver[i][2]);\n#else\t\n#if DARWIN\n\t\tsprintf(name, \"libpython%s.dylib\", ver[i]);\n#else\n\t\tsprintf(name, \"libpython%s.so\", ver[i]);\n#endif\n#endif\n\t\tvoid* handle = dlopen(name, flag);\n\t\tiver = i;\n\t\tif (handle) {\n\t\t\treturn handle;\n\t\t}\n\t}\n\tiver = -1;\n\treturn NULL;\n}\n\nstatic void* python_already_loaded() {\n\tvoid* handle = ver_dlo(RTLD_NOW|RTLD_GLOBAL|RTLD_NOLOAD);\n\t//printf(\"python_already_loaded %d\\n\", iver);\n\treturn handle;\n}\n\nstatic void* load_python() {\n\tvoid* handle = ver_dlo(RTLD_NOW|RTLD_GLOBAL);\n\t//printf(\"load_python %d\\n\", iver);\n\treturn handle;\n}\n\nstatic void* load_sym(void* handle, const char* name) {\n\tvoid* p = dlsym(handle, name);\n\tif (!p) {\n\t\tprintf(\"Could not load %s\\n\", name);\n\t\texit(1);\n\t}\n\treturn p;\n}\n\nstatic void* load_nrnpython_helper(const char* npylib) {\n\tchar name[2048];\n#ifdef MINGW\n\tsprintf(name, \"%s.dll\", npylib);\n#else // !MINGW\n#if DARWIN\n#if defined(NRNCMAKE)\n\tsprintf(name, \"%s/../../lib/%s.dylib\", neuron_home, npylib);\n#else // !NRNCMAKE\n\tsprintf(name, \"%s/../../%s/lib/%s.dylib\", neuron_home, NRNHOSTCPU, npylib);\n#endif // NRNCMAKE\n#else // !DARWIN\n#if defined(NRNCMAKE)\n\tsprintf(name, \"%s/../../lib/%s.so\", neuron_home, npylib);\n#else // !NRNCMAKE\n\tsprintf(name, \"%s/../../%s/lib/%s.so\", neuron_home, NRNHOSTCPU, npylib);\n#endif // NRNCMAKE\n#endif // DARWIN\n#endif // MINGW\n\tvoid* handle = dlopen(name, RTLD_NOW);\n\treturn handle;\n}\n\nint digit_to_int(char ch) {\n  int d = ch - '0';\n  if ((unsigned) d < 10) {\n    return d;\n  }\n  d = ch - 'a';\n  if ((unsigned) d < 6) {\n    return d + 10;\n  }\n  d = ch - 'A';\n  if ((unsigned) d < 6) {\n    return d + 10;\n  }\n  return -1;\n}\n\nstatic int pylib2pyver10(const char* pylib) {\n  // check backwards for N.N or NN // obvious limitations\n  int n1 = -1; int n2 = -1;\n  for (const char* cp = pylib + strlen(pylib) -1 ; cp > pylib; --cp) {\n    if (isdigit(*cp)) {\n      if (n2 < 0) {\n        n2 = digit_to_int(*cp);\n      } else {\n        n1 = digit_to_int(*cp);\n        return n1*10 + n2;\n      }\n    }else if (*cp == '.') {\n      // skip\n    }else{ //\n      // start over\n      n2 = -1;\n    }\n  }\n  return 0;\n}\n\nstatic void load_nrnpython(int pyver10, const char* pylib) {\n\tvoid* handle = NULL;\n#if (defined(__MINGW32__) || (defined(USE_LIBNRNPYTHON_MAJORMINOR) && USE_LIBNRNPYTHON_MAJORMINOR == 1))\n\tchar name[256];\n\tint pv10 = pyver10;\n\tif (pyver10 < 1 && pylib) {\n\t\tpv10 = pylib2pyver10(pylib);\n\t}\n\tsprintf(name, \"libnrnpython%d\", pv10);\n\thandle = load_nrnpython_helper(name);\n\tif (!handle) {\n        printf(\"Could not load %s\\n\", name);\n        printf(\"pyver10=%d pylib=%s\\n\", pyver10, pylib ? pylib : \"NULL\");\n        return;\n\t}\n#else\n    handle = load_nrnpython_helper(\"libnrnpython3\");\n    if (!handle) {\n        handle = load_nrnpython_helper(\"libnrnpython2\");\n        if (!handle) {\n            printf(\"Could not load either libnrnpython3 or libnrnpython2\\n\");\n            printf(\"pyver10=%d pylib=%s\\n\", pyver10, pylib ? pylib : \"NULL\");\n            return;\n        }\n    }\n#endif\n\tp_nrnpython_start = (void(*)(int))load_sym(handle, \"nrnpython_start\");\n\tp_nrnpython_real = (void(*)())load_sym(handle, \"nrnpython_real\");\n\tp_nrnpython_reg_real = (void(*)())load_sym(handle, \"nrnpython_reg_real\");\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/nrniv/nrnbbcore_write.cpp": "#include <../../nrnconf.h>\n// A model built using NEURON is heavyweight in memory usage and that\n// prevents maximizing the number of cells that can be simulated on\n// a process. On the other hand, a tiny version of NEURON that contains\n// only the cache efficient structures, minimal memory usage arrays,\n// needed to do a simulation (no interpreter, hoc Objects, Section, etc.)\n// lacks the model building flexibility of NEURON.\n// Ideally, the only arrays needed for a tiny version simulation are those\n// enumerated in the NrnThread structure in src/nrnoc/multicore.h up to,\n// but not including, the Node** arrays. Also tiny versions of POINT_PROCESS,\n// PreSyn, NetCon, and SUFFIX mechanisms will be stripped down from\n// their full NEURON definitions and, it seems certain, many of the\n// double fields will be converted to some other, less memory using, types.\n// With this in mind, we envision that NEURON will incrementally construct\n// cache efficient whole cell structures which can be saved and read with\n// minimal processing into the tiny simulator. Note that this is a petabyte\n// level of data volume. Consider, for example, 128K cores each\n// preparing model data for several thousand cells using full NEURON where\n// there is not enough space for the simultaneous existence of\n// those several thousand cells --- but there is with the tiny version.\n\n// Several assumptions with regard to the nrnbbcore_read reader.\n// Since memory is filled with cells, whole cell\n// load balance should be adequate and so there is no provision for\n// multisplit. A process gets a list of the gid owned by that process\n// and allocates the needed\n// memory based on size variables for each gid, i.e.\n// number of nodes, number of instances of each mechanism type, and number\n// of NetCon instances. Also the offsets are calculated for where the\n// cell information is to reside in the cache efficient arrays.\n// The rest of the cell information is then copied\n// into memory with the proper offsets. Pointers to data, used in the old\n// NEURON world are converted to integer indices into a common data array.\n\n// A good deal of conceptual confusion resulted in earlier implementations\n// with regard to ordering of synapses and\n// artificial cells with and without gids. The ordering of the property\n// data for those is defined by the order in the NrnThread.tml list where\n// every Memb_list.data has an easily found index relative to its 'nodecount'.\n// (For artificial cells, since those are not ordered in a cache efficient\n// array, we get the index using int nrncore_art2index(double* param)\n// which looks up the index in a hash table. Earlier implementations\n// handled 'artificial cells without gids' specially which also\n// necessitated special handling of their NetCons and disallowed artificial\n// cells with gids. We now handle all artificial cells in a thread\n// in the same way as any other synapse (the assumption still holds that\n// any artificial cell without a gid in a thread can connect only to\n// targets in the same thread. Thus, a single NrnThread.synapses now contains\n// all synapses and all artificial cells belonging to that thread. All\n// the synapses and artificial cells are in NrnThread.tml order. So there\n// are no exceptions in filling Point_process pointers from the data indices\n// on the coreneuron side. PreSyn ordering is a bit more delicate.\n// From netpar.cpp, the gid2out_ hash table defines an output_gid\n// ordering and gives us all the PreSyn\n// associated with real and artificial cells having gids. But those are\n// randomly ordered and interleaved with 'no gid instances'\n// relative to the tml ordering.\n// Since the number of output PreSyn >= number of output_gid it makes sense\n// to order the PreSyn in the same way as defined by the tml ordering.\n// Thus, even though artificial cells with and without gids are mixed,\n// at least it is convenient to fill the PreSyn.psrc field.\n// Synapses are first but the artificial cells with and without gids are\n// mixed. The problem that needs to\n// be explicitly overcome is associating output gids with the proper PreSyn\n// and that can be done with a list parallel to the acell part of the\n// output_gid list that specifies the PreSyn list indices.\n// Note that allocation of large arrays allows considerable space savings\n// by eliminating overhead involved in allocation of many individual\n// instances.\n/*\nAssumptions regarding the scope of possible models.(Incomplete list)\nAll real cells have gids.\nArtificial cells without gids connect only to cells in the same thread.\nNo POINTER to data outside of NrnThread.\nNo POINTER to data in ARTIFICIAL_CELL (that data is not cache_efficient)\nnt->tml->pdata is not cache_efficient\n*/\n// See coreneuron/nrniv/nrn_setup.cpp for a description of\n// the file format written by this file.\n\n/*\nSupport direct transfer of model to dynamically loaded coreneuron library.\nTo do this we factored all major file writing components into a series\nof functions that return data that can be called from the coreneuron\nlibrary. The file writing functionality is kept by also calling those\nfunctions here as well.\nDirect transfer mode disables error checking with regard to every thread\nhaving a real cell with a gid. Of course real and artificial cells without\ngids do not have spike information in the output raster file. Trajectory\ncorrectness has not been validated for cells without gids.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\n// for idDirExist and makePath\n#include <ocfile.h>\n\n#include <nrnran123.h> // globalindex written to globals.dat\n#include <section.h>\n#include <parse.h>\n#include <nrnmpi.h>\n#include <netcon.h>\n#include <nrndae_c.h>\n#include <unistd.h>\n#include <algorithm>\n#include <nrnhash_alt.h>\n#include <nrnbbcore_write.h>\n#include <netcvode.h> // for nrnbbcore_vecplay_write\n#include <vrecitem.h> // for nrnbbcore_vecplay_write\n#include <nrnsection_mapping.h>\n#include <fstream>\n#include <sstream>\n\n#if defined(HAVE_DLFCN_H)\n#include <dlfcn.h>\n#endif\n\nextern NetCvode* net_cvode_instance;\n\nextern \"C\" { // to end of file\n\nextern void hoc_execerror(const char*, const char*);\nextern int* nrn_prop_param_size_;\nextern int* nrn_prop_dparam_size_;\nstatic int* bbcore_dparam_size; // cvodeieq not present\nextern char* pnt_map;\nextern short* nrn_is_artificial_;\nextern int nrn_is_ion(int type);\nextern double nrn_ion_charge(Symbol* sym);\nextern Symbol* hoc_lookup(const char*);\nextern int secondorder, diam_changed, v_structure_change, tree_changed;\n\n/* not NULL, need to write gap information */\nextern void (*nrnthread_v_transfer_)(NrnThread*);\nextern size_t nrnbbcore_gap_write(const char* path, int* group_ids);\n\n/* access the neuron.coreneuron pure python module */\nint (*nrnpy_nrncore_enable_value_p_)();\nchar* (*nrnpy_nrncore_arg_p_)(double tstop);\n\ntypedef void (*bbcore_write_t)(double*, int*, int*, int*, double*, Datum*, Datum*, NrnThread*);\nextern bbcore_write_t* nrn_bbcore_write_;\n\nstatic CellGroup* cellgroups_;\nstatic CellGroup* mk_cellgroups(); // gid, PreSyn, NetCon, Point_process relation.\nstatic void datumtransform(CellGroup*); // Datum.pval to int\nstatic void datumindex_fill(int, CellGroup&, DatumIndices&, Memb_list*); //helper\nstatic void write_byteswap1(const char* fname);\nstatic void write_memb_mech_types(const char* fname);\nstatic void write_memb_mech_types_direct(std::ostream& s);\nstatic void write_globals(const char* fname);\nstatic int get_global_int_item(const char* name);\nstatic void* get_global_dbl_item(void* p, const char* & name, int& size, double*& val);\nstatic void write_nrnthread(const char* fname, NrnThread& nt, CellGroup& cg);\n\nstatic void nrnthread_group_ids(int* groupids);\nstatic int nrnthread_dat1(int tid, int& n_presyn, int& n_netcon,\n  int*& output_gid, int*& netcon_srcgid);\nstatic int nrnthread_dat2_1(int tid, int& ngid, int& n_real_gid, int& nnode, int& ndiam,\n  int& nmech, int*& tml_index, int*& ml_nodecount, int& nidata,\n  int& nvdata, int& nweight);\nstatic int nrnthread_dat2_2(int tid, int*& v_parent_index, double*& a, double*& b,\n  double*& area, double*& v, double*& diamvec);\nstatic int nrnthread_dat2_mech(int tid, size_t i, int dsz_inst, int*& nodeindices,\n  double*& data, int*& pdata);\nstatic int nrnthread_dat2_3(int tid, int nweight, int*& output_vindex, double*& output_threshold,\n  int*& netcon_pnttype, int*& netcon_pntindex, double*& weights, double*& delays);\nstatic int nrnthread_dat2_corepointer(int tid, int& n);\nstatic int nrnthread_dat2_corepointer_mech(int tid, int type,\n  int& icnt, int& dcnt, int*& iarray, double*& darray);\nstatic int nrnthread_dat2_vecplay(int tid, int& n);\nstatic int nrnthread_dat2_vecplay_inst(int tid, int i, int& vptype, int& mtype,\n  int& ix, int& sz, double*& yvec, double*& tvec);\n\nstatic void write_nrnthread_task(const char*, CellGroup* cgs);\nstatic int* datum2int(int type, Memb_list* ml, NrnThread& nt, CellGroup& cg, DatumIndices& di, int ml_vdata_offset);\nstatic void setup_nrn_has_net_event();\nstatic int chkpnt;\n\n// Up to now all the artificial cells have been left out of the processing.\n// Since most processing is in the context of iteration over nt.tml it\n// might be easiest to transform the loops using a\n// copy of nt.tml with artificial cell types belonging to nt at the end.\n// Treat these artificial cell memb_list as much as possible like the others.\n// The only issue is that data for artificial cells is not in cache order\n// (after all there is no BREAKPOINT or SOLVE block for ARTIFICIAL_CELLs)\n// so we assume there will be no POINTER usage into that data.\n// Also, note that ml.nodecount for artificial cell does not refer to\n// a list of voltage nodes but just to the count of instances.\nstatic void mk_tml_with_art(void); // set up MlWithArt CellGroup.mlwithart\n\ndeclareNrnHash(PVoid2Int, void*, int)\nimplementNrnHash(PVoid2Int, void*, int)\nPVoid2Int* artdata2index_;\n\n/** mapping information */\nstatic NrnMappingInfo mapinfo;\n\n// to avoid incompatible dataset between neuron and coreneuron\n// add version string to the dataset files\nconst char *bbcore_write_version = \"1.2\";\n\n// direct transfer or via files? The latter makes use of group_gid for\n// filename construction.\nstatic bool corenrn_direct;\n\nstatic size_t part1();\nstatic void part2(const char*);\n\n// prerequisites for a NEURON model to be transferred to CoreNEURON.\nstatic void model_ready() {\n  // Do the model type checks first as some of them prevent the success\n  // of cvode.cache_efficient(1) and the error message associated with\n  // !use_cachevec would be misleading. \n  if (!nrndae_list_is_empty()) {\n    hoc_execerror(\"CoreNEURON cannot simulate a model that contains extra LinearMechanism or RxD equations\", NULL);\n  }\n  if (nrn_threads[0]._ecell_memb_list) {\n    hoc_execerror(\"CoreNEURON cannot simulate a model that contains the extracellular mechanism\", NULL);\n  }\n  if (corenrn_direct) {\n    if (cvode_active_) {\n      hoc_execerror(\"CoreNEURON can only use fixed step method.\", NULL);\n    }\n  }\n\n  if (!use_cachevec) {\n    hoc_execerror(\"NEURON model for CoreNEURON requires cvode.cache_efficient(1)\", NULL);\n  }\n  if (tree_changed || v_structure_change || diam_changed) {\n    hoc_execerror(\"NEURON model internal structures for CoreNEURON are out of date. Make sure call to finitialize(...) is after cvode.cache_efficient(1))\", NULL);\n  }\n}\n\n// accessible from ParallelContext.total_bytes()\nsize_t nrnbbcore_write() {\n  corenrn_direct = false;\n  model_ready();\n  char fname[1024];\n  std::string path(\".\");\n  if (ifarg(1)) {\n    path = hoc_gargstr(1);\n    if (nrnmpi_myid == 0) {\n      if (!isDirExist(path)) {\n        if (!makePath(path)) {\n          hoc_execerror(path.c_str(), \"directory did not exist and makePath for it failed\");\n        }\n      }\n    }\n#ifdef NRNMPI\n    nrnmpi_barrier();\n#endif\n  }\n\n  size_t rankbytes = part1(); // can arrange to be just before part2\n\n  nrn_assert(snprintf(fname, 1024, \"%s/%s\", path.c_str(), \"byteswap1.dat\") < 1024);\n  write_byteswap1(fname);\n\n  nrn_assert(snprintf(fname, 1024, \"%s/%s\", path.c_str(), \"bbcore_mech.dat\") < 1024);\n  write_memb_mech_types(fname);\n\n  nrn_assert(snprintf(fname, 1024, \"%s/%s\", path.c_str(), \"globals.dat\") < 1024);\n  write_globals(fname);\n\n  part2(path.c_str());\n  return rankbytes;\n}\n\nstatic size_t part1() {\n  size_t rankbytes = 0;\n  size_t nbytes;\n  NrnThread* nt;\n  NrnThreadMembList* tml;\n  if (!bbcore_dparam_size) {\n    bbcore_dparam_size = new int[n_memb_func];\n  }\n  for (int i=0; i < n_memb_func; ++i) {\n    int sz = nrn_prop_dparam_size_[i];\n    bbcore_dparam_size[i] = sz;\n    Memb_func* mf = memb_func + i;\n    if (mf && mf->dparam_semantics && sz && mf->dparam_semantics[sz-1] == -3) {\n        // cvode_ieq in NEURON but not CoreNEURON\n        bbcore_dparam_size[i] = sz - 1;\n    }\n  }\n  setup_nrn_has_net_event();\n  cellgroups_ = new CellGroup[nrn_nthread]; // here because following needs mlwithart\n  mk_tml_with_art();\n\n  FOR_THREADS(nt) {\n    size_t threadbytes = 0;\n    size_t npnt = 0;\n    size_t nart = 0;\n    int ith = nt->id;\n    //printf(\"rank %d thread %d\\n\", nrnmpi_myid, ith);\n    //printf(\"  ncell=%d nnode=%d\\n\", nt->ncell, nt->end);\n    //v_parent_index, _actual_a, _actual_b, _actual_area\n    nbytes = nt->end * (1*sizeof(int) + 3*sizeof(double));\n    threadbytes += nbytes;\n\n    int mechcnt = 0;\n    size_t mechcnt_instances = 0;\n    MlWithArt& mla = cellgroups_[ith].mlwithart;\n    for (size_t i = 0; i < mla.size(); ++i) {\n      int type = mla[i].first;\n      Memb_list* ml = mla[i].second;\n      ++mechcnt;\n      mechcnt_instances += ml->nodecount;\n      npnt += (memb_func[type].is_point ? ml->nodecount : 0);\n      int psize = nrn_prop_param_size_[type];\n      int dpsize = nrn_prop_dparam_size_[type]; // includes cvodeieq if present\n      //printf(\"%d %s ispnt %d  cnt %d  psize %d  dpsize %d\\n\",tml->index, memb_func[type].sym->name,\n      //memb_func[type].is_point, ml->nodecount, psize, dpsize);\n      // nodeindices, data, pdata + pnt with prop\n      int notart = nrn_is_artificial_[type] ? 0 : 1;\n      if (nrn_is_artificial_[type]) {\n        nart += ml->nodecount;\n      }\n      nbytes = ml->nodecount * (notart*sizeof(int) + 1*sizeof(double*) +\n        1*sizeof(Datum*) + psize*sizeof(double) + dpsize*sizeof(Datum));\n      threadbytes += nbytes;\n    }\n    nbytes += npnt * (sizeof(Point_process) + sizeof(Prop));\n    //printf(\"  mech in use %d  Point instances %ld  artcells %ld  total instances %ld\\n\",\n    //mechcnt, npnt, nart, mechcnt_instances);\n    //printf(\"  thread bytes %ld\\n\", threadbytes);\n    rankbytes += threadbytes;\n  }\n  \n  rankbytes += nrncore_netpar_bytes();\n  //printf(\"%d bytes %ld\\n\", nrnmpi_myid, rankbytes);\n  CellGroup* cgs = mk_cellgroups();\n\n  datumtransform(cgs);\n  return rankbytes;\n}\n\nstatic void part2_clean() {\n  if (artdata2index_) {\n    delete artdata2index_;\n    artdata2index_ = NULL;\n  }\n  delete [] cellgroups_;\n  cellgroups_ = NULL;\n}\n\nstatic void part2(const char* path) {\n  CellGroup* cgs = cellgroups_;\n  for (int i=0; i < nrn_nthread; ++i) {\n    chkpnt = 0;\n    write_nrnthread(path, nrn_threads[i], cgs[i]);\n  }\n\n  /** write mapping information */\n  if(mapinfo.size()) {\n    int gid = cgs[0].group_id;\n    nrn_write_mapping_info(path, gid, mapinfo);\n    mapinfo.clear();\n  }\n\n  if (nrnthread_v_transfer_) {\n    // see partrans.cpp. nrn_nthread files of path/icg_gap.dat\n    int* group_ids = new int[nrn_nthread];\n    for (int i=0; i < nrn_nthread; ++i) {\n      group_ids[i] = cgs[i].group_id;\n    }\n    nrnbbcore_gap_write(path, group_ids);\n    delete [] group_ids;\n  }\n\n  // filename data might have to be collected at hoc level since\n  // pc.nrnbbcore_write might be called\n  // many times per rank since model may be built as series of submodels.\n  if (ifarg(2)) {\n    Vect* cgidvec = vector_arg(2);\n    vector_resize(cgidvec, nrn_nthread);\n    double* px = vector_vec(cgidvec);\n    for (int i=0; i < nrn_nthread; ++i) {\n      px[i] = double(cgs[i].group_id);\n    }\n  }else{\n    write_nrnthread_task(path, cgs);\n  }\n\n  // clean up the art Memb_list of CellGroup[].mlwithart\n  for (int ith=0; ith < nrn_nthread; ++ith) {\n    MlWithArt& mla = cgs[ith].mlwithart;\n    for (size_t i = 0; i < mla.size(); ++i) {\n      int type = mla[i].first;\n      Memb_list* ml = mla[i].second;\n      if (nrn_is_artificial_[type]) {\n        delete [] ml->data;\n        delete [] ml->pdata;\n        delete ml;\n      }\n    }\n  }\n\n  part2_clean();\n}\n\nint nrncore_art2index(double* d) {\n  int i;\n  int result = artdata2index_->find(d, i);\n  assert(result);\n  return i;\n}\n\nextern \"C\" {\nextern int nrn_has_net_event_cnt_;\nextern int* nrn_has_net_event_;\n}\n\nstatic int* has_net_event_;\nstatic void setup_nrn_has_net_event() {\n  if (has_net_event_) { return; }\n  has_net_event_ = new int[n_memb_func];\n  for (int i=0; i < n_memb_func; ++i) {\n    has_net_event_[i] = 0;\n  }\n  for(int i=0; i < nrn_has_net_event_cnt_; ++i) {\n    has_net_event_[nrn_has_net_event_[i]] = 1;\n  }\n}\n\nstatic int nrn_has_net_event(int type) {\n  return has_net_event_[type];\n}\n\nvoid mk_tml_with_art() {\n  // copy NrnThread tml list and append ARTIFICIAL cell types \n  // but do not include PatternStim\n  // Now using cgs[tid].mlwithart instead of\n  // tml_with_art = new NrnThreadMembList*[nrn_nthread];\n  // to allow fast retrieval of type and Memb_list* given index into the vector.\n  CellGroup* cgs = cellgroups_;\n  // copy from NrnThread\n  for (int id = 0; id < nrn_nthread; ++id) {\n    MlWithArt& mla = cgs[id].mlwithart;\n    for (NrnThreadMembList* tml = nrn_threads[id].tml; tml; tml = tml->next) {\n      mla.push_back(MlWithArtItem(tml->index, tml->ml));\n    }\n  }\n  int *acnt = new int[nrn_nthread];\n  artdata2index_ = new PVoid2Int(1000);\n\n  for (int i = 0; i < n_memb_func; ++i) {\n    if (nrn_is_artificial_[i] && memb_list[i].nodecount) {\n      // skip PatternStim\n      if (strcmp(memb_func[i].sym->name, \"PatternStim\") == 0) { continue; }\n      if (strcmp(memb_func[i].sym->name, \"HDF5Reader\") == 0) { continue; }\n      Memb_list* ml = memb_list + i;\n      // how many artificial in each thread\n      for (int id = 0; id < nrn_nthread; ++id) {acnt[id] = 0;}\n      for (int j = 0; j < memb_list[i].nodecount; ++j) {\n        Point_process* pnt = (Point_process*)memb_list[i].pdata[j][1]._pvoid;\n        int id = ((NrnThread*)pnt->_vnt)->id;\n        ++acnt[id];\n      }\n\n      // allocate\n      for (int id = 0; id < nrn_nthread; ++id) {\n        if (acnt[id]) {\n          MlWithArt& mla = cgs[id].mlwithart;\n          ml = new Memb_list;\n          mla.push_back(MlWithArtItem(i, ml)); // need to delete ml when mla destroyed.\n          ml->nodecount = acnt[id];\n          ml->nodelist = NULL;\n          ml->nodeindices = NULL;\n          ml->prop = NULL;\n          ml->_thread = NULL;\n          ml->data = new double*[acnt[id]];\n          ml->pdata = new Datum*[acnt[id]];\n        }\n      }\n      // fill data and pdata pointers\n      // and fill the artdata2index hash table\n      for (int id = 0; id < nrn_nthread; ++id) {acnt[id] = 0;}\n      for (int j = 0; j < memb_list[i].nodecount; ++j) {\n        Point_process* pnt = (Point_process*)memb_list[i].pdata[j][1]._pvoid;\n        int id = ((NrnThread*)pnt->_vnt)->id;\n        Memb_list* ml = cgs[id].mlwithart.back().second;\n        ml->data[acnt[id]] = memb_list[i].data[j];\n        ml->pdata[acnt[id]] = memb_list[i].pdata[j];\n        artdata2index_->insert(ml->data[acnt[id]], acnt[id]);\n        ++acnt[id];\n      }\n    }\n  }\n  delete [] acnt;\n}\n\nCellGroup::CellGroup() {\n  n_output = n_real_output = n_presyn = n_netcon = n_mech = ntype = 0;\n  group_id = -1;\n  output_gid = output_vindex = 0;\n  netcons = 0; output_ps = 0;\n  ndiam = 0;\n  netcon_srcgid = netcon_pnttype = netcon_pntindex = 0;\n  datumindices = 0;\n  type2ml = new Memb_list*[n_memb_func];\n  for (int i=0; i < n_memb_func; ++i) {\n    type2ml[i] = 0;\n  }\n  ml_vdata_offset = NULL;\n}\n\nCellGroup::~CellGroup() {\n  if (output_gid) delete [] output_gid;\n  if (output_vindex) delete [] output_vindex;\n  if (netcon_srcgid) delete [] netcon_srcgid;\n  if (netcon_pnttype) delete [] netcon_pnttype;\n  if (netcon_pntindex) delete [] netcon_pntindex;\n  if (datumindices) delete [] datumindices;\n  if (netcons) delete [] netcons;\n  if (output_ps) delete [] output_ps;\n  if (ml_vdata_offset) delete [] ml_vdata_offset;\n  delete [] type2ml;\n}\n\nDatumIndices::DatumIndices() {\n  type = -1;\n  ion_type = ion_index = 0;\n}\n\nDatumIndices::~DatumIndices() {\n  if (ion_type) delete [] ion_type;\n  if (ion_index) delete [] ion_index;\n}\n\n// use the Hoc NetCon object list to segregate according to threads\n// and fill the CellGroup netcons, netcon_srcgid, netcon_pnttype, and\n// netcon_pntindex (called at end of mk_cellgroups);\nstatic void mk_cgs_netcon_info(CellGroup* cgs) {\n  // count the netcons for each thread\n  int* nccnt = new int[nrn_nthread];\n  for (int i=0; i < nrn_nthread; ++i) {\n    nccnt[i] = 0;\n  }\n  Symbol* ncsym = hoc_lookup(\"NetCon\");\n  hoc_List* ncl = ncsym->u.ctemplate->olist;\n  hoc_Item* q;\n  ITERATE(q, ncl) {\n    Object* ho = (Object*)VOIDITM(q);\n    NetCon* nc = (NetCon*)ho->u.this_pointer;\n    int ith = 0; // if no _vnt, put in thread 0\n    if (nc->target_ && nc->target_->_vnt) {\n      ith = ((NrnThread*)(nc->target_->_vnt))->id;\n    }\n    ++nccnt[ith];\n  }\n\n  // allocate\n  for (int i=0; i < nrn_nthread; ++i) {\n    cgs[i].n_netcon = nccnt[i];\n    cgs[i].netcons = new NetCon*[nccnt[i]+1];\n    cgs[i].netcon_srcgid = new int[nccnt[i]+1];\n    cgs[i].netcon_pnttype = new int[nccnt[i]+1];\n    cgs[i].netcon_pntindex = new int[nccnt[i]+1];\n  }\n\n  // reset counts and fill\n  for (int i=0; i < nrn_nthread; ++i) {\n    nccnt[i] = 0;\n  }\n  ITERATE(q, ncl) {\n    Object* ho = (Object*)VOIDITM(q);\n    NetCon* nc = (NetCon*)ho->u.this_pointer;\n    int ith = 0; // if no _vnt, put in thread 0\n    if (nc->target_ && nc->target_->_vnt) {\n      ith = ((NrnThread*)(nc->target_->_vnt))->id;\n    }\n    int i = nccnt[ith];\n    cgs[ith].netcons[i] = nc;\n\n    if (nc->target_) {\n      int type = nc->target_->prop->type;\n      cgs[ith].netcon_pnttype[i] = type;\n      if (nrn_is_artificial_[type]) {\n        cgs[ith].netcon_pntindex[i] = nrncore_art2index(nc->target_->prop->param);\n      }else{\n        // cache efficient so can calculate index from pointer\n        Memb_list* ml = cgs[ith].type2ml[type];\n        int sz = nrn_prop_param_size_[type];\n        double* d1 = ml->data[0];\n        double* d2 = nc->target_->prop->param;\n        assert(d2 >= d1 && d2 < (d1 + (sz*ml->nodecount)));\n        int ix = (d2 - d1)/sz;\n        cgs[ith].netcon_pntindex[i] = ix;\n      }\n    }else{\n      cgs[ith].netcon_pnttype[i] = 0;\n      cgs[ith].netcon_pntindex[i] = -1;\n    }\n\n    if (nc->src_) {\n      PreSyn* ps = nc->src_;\n      if (ps->gid_ >= 0) {\n        cgs[ith].netcon_srcgid[i] = ps->gid_;\n      }else{\n        if (ps->osrc_) {\n          assert(ps->thvar_ == NULL);\n          Point_process* pnt = (Point_process*)ps->osrc_->u.this_pointer;\n          int type = pnt->prop->type;\n          if (nrn_is_artificial_[type]) {\n            int ix = nrncore_art2index(pnt->prop->param);\n            cgs[ith].netcon_srcgid[i] = -(type + 1000*ix);\n          }else{\n            assert(nrn_has_net_event(type));\n            Memb_list* ml = cgs[ith].type2ml[type];\n            int sz = nrn_prop_param_size_[type];\n            double* d1 = ml->data[0];\n            double* d2 = pnt->prop->param;\n            assert(d2 >= d1 && d2 < (d1 + (sz*ml->nodecount)));\n            int ix = (d2 - d1)/sz;\n            cgs[ith].netcon_srcgid[i] = -(type + 1000*ix);\n          }\n        }else{\n          cgs[ith].netcon_srcgid[i] = -1;\n        }\n      }\n    }else{\n      cgs[ith].netcon_srcgid[i] = -1;\n    }\n    ++nccnt[ith];\n  }\n  delete [] nccnt;\n}\n\nCellGroup* mk_cellgroups() {\n  CellGroup* cgs = cellgroups_;\n  for (int i=0; i < nrn_nthread; ++i) {\n    int ncell = nrn_threads[i].ncell; // real cell count\n    int npre = ncell;\n    MlWithArt& mla = cgs[i].mlwithart;\n    for (size_t j = 0; j < mla.size(); ++j) {\n      int type = mla[j].first;\n      Memb_list* ml = mla[j].second;\n      cgs[i].type2ml[type] = ml;\n      if (nrn_has_net_event(type)) {\n        npre += ml->nodecount;\n      }\n    }\n    cgs[i].n_presyn = npre;\n    cgs[i].n_real_output = ncell;\n    cgs[i].output_ps = new PreSyn*[npre];\n    cgs[i].output_gid = new int[npre];\n    cgs[i].output_vindex = new int[npre];\n    // in case some cells do not have voltage presyns (eg threshold detection\n    // computed from a POINT_PROCESS NET_RECEIVE with WATCH and net_event)\n    // initialize as unused.\n    for (int j=0; j < npre; ++j) {\n      cgs[i].output_ps[j] = NULL;\n      cgs[i].output_gid[j] = -1;\n      cgs[i].output_vindex[j] = -1;\n    }\n\n    // fill in the artcell info\n    npre = ncell;\n    cgs[i].n_output = ncell; // add artcell (and PP with net_event) with gid in following loop\n    for (size_t j = 0; j < mla.size(); ++j) {\n      int type = mla[j].first;\n      Memb_list* ml = mla[j].second;\n      if (nrn_has_net_event(type)) {\n        for (int j=0; j < ml->nodecount; ++j) {\n          Point_process* pnt = (Point_process*)ml->pdata[j][1]._pvoid;\n          PreSyn* ps = (PreSyn*)pnt->presyn_;\n          cgs[i].output_ps[npre] = ps;\n          int agid = -1;\n          if (nrn_is_artificial_[type]) {\n            agid = -(type + 1000*nrncore_art2index(pnt->prop->param));\n          }else{ // POINT_PROCESS with net_event\n            int sz = nrn_prop_param_size_[type];\n            double* d1 = ml->data[0];\n            double* d2 = pnt->prop->param;\n            assert(d2 >= d1 && d2 < (d1 + (sz*ml->nodecount)));\n            int ix = (d2 - d1)/sz;\n            agid = -(type + 1000*ix);\n          }\n          if (ps) {\n            if (ps->output_index_ >= 0) { // has gid\n              cgs[i].output_gid[npre] = ps->output_index_;\n              if (cgs[i].group_id < 0) {\n                cgs[i].group_id = ps->output_index_;\n              }\n              ++cgs[i].n_output;\n            }else{\n              cgs[i].output_gid[npre] = agid;\n            }\n          }else{ // if an acell is never a source, it will not have a presyn\n            cgs[i].output_gid[npre] = -1;\n          }\n          // the way we associate an acell PreSyn with the Point_process.\n          cgs[i].output_vindex[npre] = agid;\n          ++npre;\n        }\n      }\n    }\n  }\n  // work at netpar.cpp because we don't have the output gid hash tables here.\n  // fill in the output_ps, output_gid, and output_vindex for the real cells.\n  nrncore_netpar_cellgroups_helper(cgs);\n\n  // use first real cell gid, if it exists, as the group_id\n  if (corenrn_direct == false) for (int i=0; i < nrn_nthread; ++i) {\n    if (cgs[i].n_real_output && cgs[i].output_gid[0] >= 0) {\n      cgs[i].group_id = cgs[i].output_gid[0];\n    }else if (cgs[i].group_id >= 0) {\n      // set above to first artificial cell with a ps->output_index >= 0\n    }else{\n      // Don't die yet as the thread may be empty. That just means no files\n      // output for this thread and no mention in files.dat.\n      // Can check for empty near end of datatransform(CellGroup* cgs)\n    }\n  }\n\n  // use the Hoc NetCon object list to segregate according to threads\n  // and fill the CellGroup netcons, netcon_srcgid, netcon_pnttype, and\n  // netcon_pntindex\n  mk_cgs_netcon_info(cgs);\n\n  return cgs;\n}\n\nvoid datumtransform(CellGroup* cgs) {\n  // ions, area, and POINTER to v.\n  for (int ith=0; ith < nrn_nthread; ++ith) {\n    NrnThread& nt = nrn_threads[ith];\n    CellGroup& cg = cgs[ith];\n    // how many mechanisms in use and how many DatumIndices do we need.\n    MlWithArt& mla = cgs[ith].mlwithart;\n    for (size_t j = 0; j < mla.size(); ++j) {\n      Memb_list* ml = mla[j].second;\n      ++cg.n_mech;\n      if (ml->pdata[0]) {\n        ++cg.ntype;\n      }\n    }\n    cg.datumindices = new DatumIndices[cg.ntype];\n    // specify type, allocate the space, and fill the indices\n    int i=0;\n    for (size_t j = 0; j < mla.size(); ++j) {\n      int type = mla[j].first;\n      Memb_list* ml = mla[j].second;\n      int sz = bbcore_dparam_size[type];\n      if (sz) {\n        DatumIndices& di = cg.datumindices[i++];\n        di.type = type;\n        int n = ml->nodecount * sz;\n        di.ion_type = new int[n];\n        di.ion_index = new int[n];\n        // fill the indices.\n        // had tointroduce a memb_func[i].dparam_semantics registered by each mod file.\n        datumindex_fill(ith, cg, di, ml);\n      }\n    }\n    // if model is being transferred via files, and\n    //   if there are no gids in the thread (group_id < 0), and\n    //     if the thread is not empty (mechanisms exist, n_mech > 0)\n    if (corenrn_direct == false && cg.group_id < 0 && cg.n_mech > 0) {\n      hoc_execerror(\"A nonempty thread has no real cell or ARTIFICIAL_CELL with a gid\", NULL);\n    }\n  }\n}\n\n// This function is related to stdindex2ptr in CoreNeuron to determine which values should\n// be transferred from CoreNeuron. Types correspond to the value to be transferred based on\n// mech_type enum or non-artificial cell mechanisms.\n// Limited to pointers to voltage, nt._nrn_fast_imem->_nrn_sav_rhs (fast_imem value) or\n// data of non-artificial cell mechanisms.\n// Requires cache_efficient mode.\n// Input double* and NrnThread. Output type and index.\n// type == 0 means could not determine index.\nint nrn_dblpntr2nrncore(double* pd, NrnThread& nt, int& type, int& index) {\n  assert(use_cachevec);\n  int nnode = nt.end;\n  type = 0;\n  if (pd >= nt._actual_v && pd < (nt._actual_v + nnode)) {\n    type = voltage; // signifies an index into voltage array portion of _data\n    index = pd - nt._actual_v;\n  } else if (pd >= nt._nrn_fast_imem->_nrn_sav_rhs && pd < (nt._nrn_fast_imem->_nrn_sav_rhs + nnode)) {\n    type = i_membrane_; // signifies an index into i_membrane_ array portion of _data\n    index = pd - nt._nrn_fast_imem->_nrn_sav_rhs;\n  }else{\n    for (NrnThreadMembList* tml = nt.tml; tml; tml = tml->next) {\n      if (nrn_is_artificial_[tml->index]) { continue; }\n      Memb_list* ml1 = tml->ml;\n      int nn = nrn_prop_param_size_[tml->index] * ml1->nodecount;\n      if (pd >= ml1->data[0] && pd < (ml1->data[0] + nn)) {\n        type = tml->index;\n        index = pd - ml1->data[0];\n        break;\n      }\n    }\n  }\n  return type == 0 ? 1 : 0;\n}\n\nvoid datumindex_fill(int ith, CellGroup& cg, DatumIndices& di, Memb_list* ml) {\n  NrnThread& nt = nrn_threads[ith];\n  double* a = nt._actual_area;\n  int nnode = nt.end;\n  int mcnt = ml->nodecount;\n  int dsize = bbcore_dparam_size[di.type];\n  if (dsize == 0) { return; }\n  int* dmap = memb_func[di.type].dparam_semantics;\n  assert(dmap);\n  // what is the size of the nt._vdata portion needed for a single ml->dparam[i]\n  int vdata_size = 0;\n  for (int i=0; i < dsize; ++i) {\n    int* ds = memb_func[di.type].dparam_semantics;\n    if (ds[i] == -4 || ds[i] == -6 || ds[i] == -7 || ds[i] == 0) {\n      ++vdata_size;\n    }\n  }\n\n  int isart = nrn_is_artificial_[di.type];\n  for (int i=0; i < mcnt; ++i) {\n    // Prop* datum instance arrays are not in cache efficient order\n    // ie. ml->pdata[i] are not laid out end to end in memory.\n    // Also, ml->data for artificial cells is not in cache efficient order\n    // but in the artcell case there are no pointers to doubles and\n    // the _actual_area pointer should be left unfilled.\n    Datum* dparam = ml->pdata[i];\n    int offset = i*dsize;\n    int vdata_offset = i*vdata_size;\n    for (int j=0; j < dsize; ++j) {\n      int etype = -100; // uninterpreted\n      int eindex = -1;\n      if (dmap[j] == -1) { // double* into _actual_area\n        if (isart) {\n          etype = -1;\n          eindex = -1; // the signal to ignore in bbcore.\n        }else{\n          if (dparam[j].pval == &ml->nodelist[i]->_area) {\n            // possibility it points directly into Node._area instead of\n            // _actual_area. For our purposes we need to figure out the\n            // _actual_area index.\n            etype = -1;\n            eindex = ml->nodeindices[i];\n            assert(a[ml->nodeindices[i]] == *dparam[j].pval);\n          }else{\n            if (dparam[j].pval < a || dparam[j].pval >= (a + nnode)){\n              printf(\"%s dparam=%p a=%p a+nnode=%p j=%d\\n\",\n                  memb_func[di.type].sym->name, dparam[j].pval, a, a+nnode, j);\n              abort();\n            }\n            assert(dparam[j].pval >= a && dparam[j].pval < (a + nnode));\n            etype = -1;\n            eindex = dparam[j].pval - a;\n          }\n        }\n      }else if (dmap[j] == -2) { // this is an ion and dparam[j][0].i is the iontype\n        etype = -2;\n        eindex = dparam[j].i;\n      }else if (dmap[j] == -3) { // cvodeieq is always last and never seen\n        assert(dmap[j] != -3);\n      }else if (dmap[j] == -4) { // netsend (_tqitem pointer)\n        // eventually index into nt->_vdata\n        etype = -4;\n        eindex = vdata_offset++;\n      }else if (dmap[j] == -6) { // pntproc\n        // eventually index into nt->_vdata\n        etype = -6;\n        eindex = vdata_offset++;\n      }else if (dmap[j] == -7) { // bbcorepointer\n        // eventually index into nt->_vdata\n        etype = -6;\n        eindex = vdata_offset++;\n      }else if (dmap[j] == -8) { // watch\n        etype = -8;\n        eindex = 0;\n      }else if (dmap[j] == -9) { // diam\n        cg.ndiam = nt.end;\n        etype = -9;\n        // Rare for a mechanism to use dparam pointing to diam.\n        // MORPHOLOGY was never made cache efficient. And\n        // is not in the tml_with_art. \n        // Need to determine this node and then simple to search its\n        // mechanism list for MORPHOLOGY and then know the diam.\n        Node* nd = ml->nodelist[i];\n        double* pdiam = NULL;\n        for (Prop* p = nd->prop; p; p = p->next) {\n          if (p->type == MORPHOLOGY) {\n            pdiam = p->param;\n            break;\n          }\n        }\n        assert(dparam[j].pval == pdiam);\n        eindex = ml->nodeindices[i];\n      }else if (dmap[j] == -5) { // POINTER\n        // must be a pointer into nt->_data. Handling is similar to eion so\n        // give proper index into the type.\n        double* pd = dparam[j].pval;\n\tnrn_dblpntr2nrncore(pd, nt, etype, eindex);\n        if (etype == 0) {\n          fprintf(stderr, \"POINTER is not pointing to voltage or mechanism data. Perhaps it should be a BBCOREPOINTER\\n\");\n        }\n        assert(etype != 0);\n        // pointer into one of the tml types?\n      }else if (dmap[j] > 0 && dmap[j] < 1000) { // double* into eion type data\n        Memb_list* eml = cg.type2ml[dmap[j]];\n        assert(eml);\n        if(dparam[j].pval < eml->data[0]){\n          printf(\"%s dparam=%p data=%p j=%d etype=%d %s\\n\",\n              memb_func[di.type].sym->name, dparam[j].pval, eml->data[0], j,\n              dmap[j], memb_func[dmap[j]].sym->name);\n          abort();\n        }\n        assert(dparam[j].pval >= eml->data[0]);\n        etype = dmap[j];\n        if (dparam[j].pval >= (eml->data[0] +\n              (nrn_prop_param_size_[etype] * eml->nodecount))) {\n          printf(\"%s dparam=%p data=%p j=%d psize=%d nodecount=%d etype=%d %s\\n\",\n              memb_func[di.type].sym->name, dparam[j].pval, eml->data[0], j,\n              nrn_prop_param_size_[etype],\n              eml->nodecount, etype, memb_func[etype].sym->name);\n        }\n        assert(dparam[j].pval < (eml->data[0] +\n              (nrn_prop_param_size_[etype] * eml->nodecount)));\n        eindex = dparam[j].pval - eml->data[0];\n      }else if (dmap[j] > 1000) {//int* into ion dparam[xxx][0]\n        //store the actual ionstyle\n        etype = dmap[j];\n        eindex = *((int*)dparam[j]._pvoid);\n      } else {\n        char errmes[100];\n        sprintf(errmes, \"Unknown semantics type %d for dparam item %d of\", dmap[j], j);\n        hoc_execerror(errmes, memb_func[di.type].sym->name);\n      }\n      di.ion_type[offset + j] = etype;\n      di.ion_index[offset + j] = eindex;\n    }\n  }\n}\n\nstatic void write_byteswap1(const char* fname) {\n  if (nrnmpi_myid > 0) { return; } // only rank 0 writes this file\n  FILE* f = fopen(fname, \"wb\");\n  if (!f) {\n    hoc_execerror(\"nrnbbcore_write write_byteswap1 could not open for writing: %s\\n\", fname);\n  }\n  // write an endian sentinal value so reader can determine if byteswap needed.\n  int32_t x = 1;\n  fwrite(&x, sizeof(int32_t), 1, f);\n  fclose(f);\n}\n\nstatic void write_memb_mech_types(const char* fname) {\n  if (nrnmpi_myid > 0) { return; } // only rank 0 writes this file\n  std::ofstream fs(fname);\n  if (!fs.good()) {\n    hoc_execerror(\"nrnbbcore_write write_mem_mech_types could not open for writing: %s\\n\", fname);\n  }\n  write_memb_mech_types_direct(fs);\n}\n\nstatic void write_memb_mech_types_direct(std::ostream& s) {\n  // list of Memb_func names, types, point type info, is_ion\n  // and data, pdata instance sizes. If the mechanism is an eion type,\n  // the following line is the charge.\n  // Not all Memb_func are necessarily used in the model.\n  s << bbcore_write_version << std::endl;\n  s << n_memb_func << std::endl;\n  for (int type=2; type < n_memb_func; ++type) {\n    const char* w = \" \";\n    Memb_func& mf = memb_func[type];\n    s << mf.sym->name << w << type << w\n      << int(pnt_map[type]) << w // the pointtype, 0 means not a POINT_PROCESS\n      << nrn_is_artificial_[type] << w\n      << nrn_is_ion(type) << w\n      << nrn_prop_param_size_[type] << w << bbcore_dparam_size[type] << std::endl;\n\n    if (nrn_is_ion(type)) {\n        s << nrn_ion_charge(mf.sym) << std::endl;\n    }\n  }\n}\n\n// format is name value\n// with last line of 0 0\n//In case of an array, the line is name[num] with num lines following with\n// one value per line.  Values are %.20g format.\nstatic void write_globals(const char* fname) {\n\n  if (nrnmpi_myid > 0) { return; } // only rank 0 writes this file\n\n  FILE* f = fopen(fname, \"w\");\n  if (!f) {\n    hoc_execerror(\"nrnbbcore_write write_globals could not open for writing: %s\\n\", fname);\n  }\n\n  fprintf(f, \"%s\\n\", bbcore_write_version);\n  const char* name;\n  int size; // 0 means scalar, is 0 will still allocated one element for val.\n  double* val; // Allocated by new in get_global_item, must be delete [] here.\n  for (void* sp = NULL;\n        (sp = get_global_dbl_item(sp, name, size, val)) != NULL;) {\n    if (size) {\n      fprintf(f, \"%s[%d]\\n\", name, size);\n      for (int i=0; i < size; ++i) {\n        fprintf(f, \"%.20g\\n\", val[i]);\n      }\n    }else{\n      fprintf(f, \"%s %.20g\\n\", name, val[0]);\n    }\n    delete [] val;\n  }\n  fprintf(f, \"0 0\\n\"); \n  fprintf(f, \"secondorder %d\\n\", secondorder);\n  fprintf(f, \"Random123_globalindex %d\\n\", nrnran123_get_globalindex());\n\n  fclose(f);\n}\n\n// just for secondorder and Random123_globalindex\nstatic int get_global_int_item(const char* name) {\n  if (strcmp(name, \"secondorder\") == 0) {\n    return secondorder;\n  }else if(strcmp(name, \"Random123_global_index\") == 0) {\n    return nrnran123_get_globalindex();\n  }\n  return 0;\n}\n\n// successively return global double info. Begin with p==NULL.\n// Done when return NULL.\nstatic void* get_global_dbl_item(void* p, const char* & name, int& size, double*& val) {\n  Symbol* sp = (Symbol*)p;\n  if (sp == NULL) {\n    sp = hoc_built_in_symlist->first;\n  }\n  for (; sp; sp = sp->next) {\n    if (sp->type == VAR && sp->subtype == USERDOUBLE) {\n      name = sp->name;\n      if (ISARRAY(sp)) {\n        Arrayinfo* a = sp->arayinfo;\n        if (a->nsub == 1) {\n          size = a->sub[0];\n          val = new double[size];\n          for (int i=0; i < a->sub[0]; ++i) {\n            char n[256];\n            sprintf(n, \"%s[%d]\", sp->name, i);\n            val[i] =  *hoc_val_pointer(n);\n          }\n        }\n      }else{\n        size = 0;\n        val = new double[1];\n        val[0] = *sp->u.pval;\n      }\n      return sp->next;\n    }\n  }\n  return NULL;\n}\n\nvoid writeint_(int* p, size_t size, FILE* f) {\n  fprintf(f, \"chkpnt %d\\n\", chkpnt++);\n  size_t n = fwrite(p, sizeof(int), size, f);\n  assert(n == size);\n}\n\nvoid writedbl_(double* p, size_t size, FILE* f) {\n  fprintf(f, \"chkpnt %d\\n\", chkpnt++);\n  size_t n = fwrite(p, sizeof(double), size, f);\n  assert(n == size);\n}\n\n#define writeint(p,size) writeint_(p, size, f)\n#define writedbl(p,size) writedbl_(p, size, f)\n\nstatic void write_contiguous_art_data(double** data, int nitem, int szitem, FILE* f) {\n  fprintf(f, \"chkpnt %d\\n\", chkpnt++);\n  // the assumption is that an fwrite of nitem groups of szitem doubles can be\n  // fread as a single group of nitem*szitem doubles.\n  for (int i = 0; i < nitem; ++i) {\n    size_t n = fwrite(data[i], sizeof(double), szitem, f);\n    assert(n == szitem);\n  }\n}\n\nstatic double* contiguous_art_data(double** data, int nitem, int szitem) {\n  double* d1 = new double[nitem*szitem];\n  int k = 0;\n  for (int i = 0; i < nitem; ++i) {\n    for (int j=0; j < szitem; ++j) {\n      d1[k++] = data[i][j];\n    }\n  }\n  return d1;\n}\n\n// Vector.play information.\n// Must play into a data element in this thread\n// File format is # of play instances in this thread (generally VecPlayContinuous)\n// For each Play instance\n// VecPlayContinuousType (4), pd (index), y.size, yvec, tvec\n// Other VecPlay instance types are possible, such as VecPlayContinuous with\n// a discon vector or VecPlayStep with a DT or tvec, but are not implemented\n// at present. Assertion errors are generated if not type 0 of if we\n// cannot determine the index into the NrnThread._data .\n\nstatic int nrnthread_dat2_vecplay(int tid, int& n) {\n  if (tid >= nrn_nthread) { return 0; }\n  NrnThread& nt = nrn_threads[tid];\n\n  // count the instances for this thread\n  // error if not a VecPlayContinuous with no discon vector\n  n = 0;\n  PlayRecList* fp = net_cvode_instance->fixed_play_;\n  for (int i=0; i < fp->count(); ++i){\n    if (fp->item(i)->type() == VecPlayContinuousType) {\n      VecPlayContinuous* vp = (VecPlayContinuous*)fp->item(i);\n      if (vp->discon_indices_ == NULL) {\n        if (vp->ith_ == nt.id) {\n          assert(vp->y_ && vp->t_);\n          ++n;\n        }\n      }else{\n        assert(0);\n      }\n    }else{\n      assert(0);\n    }\n  }\n\n  return 1;\n}\n\nstatic int nrnthread_dat2_vecplay_inst(int tid, int i, int& vptype, int& mtype,\n  int& ix, int& sz, double*& yvec, double*& tvec) {\n\n  if (tid >= nrn_nthread) { return 0; }\n  NrnThread& nt = nrn_threads[tid];\n\n    PlayRecList* fp = net_cvode_instance->fixed_play_;\n    if (fp->item(i)->type() == VecPlayContinuousType) {\n      VecPlayContinuous* vp = (VecPlayContinuous*)fp->item(i);\n      if (vp->discon_indices_ == NULL) {\n        if (vp->ith_ == nt.id) {\n          double* pd = vp->pd_;\n          int found = 0;\n          vptype = vp->type();\n          for (NrnThreadMembList* tml = nt.tml; tml; tml = tml->next) {\n            if (nrn_is_artificial_[tml->index]) { continue; }\n            Memb_list* ml = tml->ml;\n            int nn = nrn_prop_param_size_[tml->index] * ml->nodecount;\n            if (pd >= ml->data[0] && pd < (ml->data[0] + nn)) {\n              mtype = tml->index;\n              ix = (pd - ml->data[0]);\n              sz = vector_capacity(vp->y_);\n              yvec = vector_vec(vp->y_);\n              tvec = vector_vec(vp->t_);\n              found = 1;\n              break;\n            }\n          }\n          assert(found);\n          return 1;\n        }\n      }\n    }\n\n  return 0;\n}\n\nstatic void nrnbbcore_vecplay_write(FILE* f, NrnThread& nt) {\n  // count the instances for this thread\n  // error if not a VecPlayContinuous with no discon vector\n  int n;\n  nrnthread_dat2_vecplay(nt.id, n);\n  fprintf(f, \"%d VecPlay instances\\n\", n);\n  PlayRecList* fp = net_cvode_instance->fixed_play_;\n  for (int i=0; i < fp->count(); ++i) {\n    int vptype, mtype, ix, sz; double *yvec, *tvec;\n    if (nrnthread_dat2_vecplay_inst(nt.id, i, vptype, mtype, ix, sz, yvec, tvec)) {\n      fprintf(f, \"%d\\n\", vptype);\n      fprintf(f, \"%d\\n\", mtype);\n      fprintf(f, \"%d\\n\", ix);\n      fprintf(f, \"%d\\n\", sz);\n      writedbl(yvec, sz);\n      writedbl(tvec, sz);\n    }\n  }\n}\n\nstatic int nrnthread_dat1(int tid, int& n_presyn, int& n_netcon,\n  int*& output_gid, int*& netcon_srcgid) {\n\n  if (tid >= nrn_nthread) { return 0; }\n  CellGroup& cg = cellgroups_[tid];\n  n_presyn = cg.n_presyn;\n  n_netcon = cg.n_netcon;\n  output_gid = cg.output_gid;  cg.output_gid = NULL;\n  netcon_srcgid = cg.netcon_srcgid;  cg.netcon_srcgid = NULL;\n  return 1;\n}\n\n// sizes and total data count\nstatic int nrnthread_dat2_1(int tid, int& ngid, int& n_real_gid, int& nnode, int& ndiam,\n  int& nmech, int*& tml_index, int*& ml_nodecount, int& nidata, int& nvdata, int& nweight) {\n  \n  if (tid >= nrn_nthread) { return 0; }\n  CellGroup& cg = cellgroups_[tid];\n  NrnThread& nt = nrn_threads[tid];\n\n  ngid = cg.n_output;\n  n_real_gid = cg.n_real_output;\n  nnode = nt.end;\n  ndiam = cg.ndiam;\n  nmech = cg.n_mech;\n\n  cg.ml_vdata_offset = new int[nmech];\n  int vdata_offset = 0;\n  tml_index = new int[nmech];\n  ml_nodecount = new int[nmech];\n  MlWithArt& mla = cg.mlwithart;\n  for (size_t j = 0; j < mla.size(); ++j) {\n    int type = mla[j].first;\n    Memb_list* ml = mla[j].second;\n    tml_index[j] = type;\n    ml_nodecount[j] = ml->nodecount;\n    cg.ml_vdata_offset[j] = vdata_offset;\n    int* ds = memb_func[type].dparam_semantics;\n    for (int psz=0; psz < bbcore_dparam_size[type]; ++psz) {\n      if (ds[psz] == -4 || ds[psz] == -6 || ds[psz] == -7 || ds[psz] == 0) {\n        //printf(\"%s ds[%d]=%d vdata_offset=%d\\n\", memb_func[type].sym->name, psz, ds[psz], vdata_offset);\n        vdata_offset += ml->nodecount;\n      }\n    }\n  }\n  nvdata = vdata_offset;\n  nidata = 0;\n  //  printf(\"nidata=%d nvdata=%d nnetcon=%d\\n\", nidata, nvdata, cg.n_netcon);\n  nweight = 0;\n  for (int i=0; i < cg.n_netcon; ++i) {\n    nweight += cg.netcons[i]->cnt_;\n  }\n\n  return 1;\n}\n\nstatic int nrnthread_dat2_2(int tid, int*& v_parent_index, double*& a, double*& b,\n  double*& area, double*& v, double*& diamvec) {\n\n  if (tid >= nrn_nthread) { return 0; }\n  CellGroup& cg = cellgroups_[tid];\n  NrnThread& nt = nrn_threads[tid];\n\n  assert(cg.n_real_output == nt.ncell);\n\n  // if not NULL then copy (for direct transfer target space already allocated)\n  bool copy = v_parent_index ? true : false;\n  int n = nt.end;\n  if (copy) {\n    for (int i=0; i < nt.end; ++i) {\n      v_parent_index[i] = nt._v_parent_index[i];\n      a[i] = nt._actual_a[i];\n      b[i] = nt._actual_b[i];\n      area[i] = nt._actual_area[i];\n      v[i] = nt._actual_v[i];\n    }\n  }else{\n    v_parent_index = nt._v_parent_index;\n    a = nt._actual_a;\n    b = nt._actual_b;\n    area = nt._actual_area;\n    v = nt._actual_v;\n  }\n  if (cg.ndiam) {\n    if (!copy) {\n      diamvec = new double[nt.end];\n    }\n    for (int i=0; i < nt.end; ++i) {\n      Node* nd = nt._v_node[i];\n      double diam = 0.0;\n      for (Prop* p = nd->prop; p; p = p->next) {\n        if (p->type == MORPHOLOGY) {\n          diam = p->param[0];\n          break;\n        }\n      }\n      diamvec[i] = diam;\n    }\n  }\n  return 1;\n}\n\nstatic int nrnthread_dat2_mech(int tid, size_t i, int dsz_inst, int*& nodeindices,\n  double*& data, int*& pdata) {\n\n  if (tid >= nrn_nthread) { return 0; }\n  CellGroup& cg = cellgroups_[tid];\n  NrnThread& nt = nrn_threads[tid];\n  MlWithArtItem& mlai = cg.mlwithart[i];\n  int type = mlai.first;\n  Memb_list* ml = mlai.second;\n  // for direct transfer, data=NULL means copy into passed space for nodeindices, data, and pdata\n  bool copy = data ? true : false;\n\n    int vdata_offset = cg.ml_vdata_offset[i];\n    int isart = nrn_is_artificial_[type];\n    int n = ml->nodecount;\n    int sz = nrn_prop_param_size_[type];\n    double* data1;\n    if (isart) { // data may not be contiguous\n      data1 = contiguous_art_data(ml->data, n, sz); // delete after use\n      nodeindices = NULL;\n    }else{\n      nodeindices = ml->nodeindices; // allocated below if copy\n      data1 = ml->data[0]; // do not delete after use\n    }\n    if (copy) {\n      if (!isart) {\n        nodeindices = (int*)emalloc(n*sizeof(int));\n        for (int i=0; i < n; ++i) {\n          nodeindices[i] = ml->nodeindices[i];\n        }\n      }\n      int nn = n*sz;\n      for (int i = 0; i < nn; ++i) {\n        data[i] = data1[i];\n      }\n      if (isart) {\n        delete [] data1;\n      }\n    }else{\n      data = data1;\n    }\n\n    sz = bbcore_dparam_size[type]; // nrn_prop_dparam_size off by 1 if cvode_ieq.\n    if (sz) {\n      int* pdata1;\n      pdata1 = datum2int(type, ml, nt, cg, cg.datumindices[dsz_inst], vdata_offset);\n      if (copy) {\n        int nn = n*sz;\n        for (int i=0; i < nn; ++i) {\n          pdata[i] = pdata1[i];\n        }\n        delete [] pdata1;\n      }else{\n        pdata = pdata1;\n      }\n    }else{\n      pdata = NULL;\n    }\n\n    return 1;\n}\n\nstatic int nrnthread_dat2_3(int tid, int nweight, int*& output_vindex, double*& output_threshold,\n  int*& netcon_pnttype, int*& netcon_pntindex, double*& weights, double*& delays) {\n\n  if (tid >= nrn_nthread) { return 0; }\n  CellGroup& cg = cellgroups_[tid];\n  NrnThread& nt = nrn_threads[tid];\n\n  output_vindex = new int[cg.n_presyn];\n  output_threshold = new double[cg.n_real_output];\n  for (int i=0; i < cg.n_presyn; ++i) {\n    output_vindex[i] = cg.output_vindex[i];\n  }\n  for (int i=0; i < cg.n_real_output; ++i) {\n    output_threshold[i] = cg.output_ps[i] ? cg.output_ps[i]->threshold_ : 0.0;\n  }\n\n  // connections\n  int n = cg.n_netcon;\n  //printf(\"n_netcon=%d nweight=%d\\n\", n, nweight);\n  netcon_pnttype = cg.netcon_pnttype; cg.netcon_pnttype = NULL;\n  netcon_pntindex = cg.netcon_pntindex; cg.netcon_pntindex = NULL;\n  // alloc a weight array and write netcon weights\n  weights = new double[nweight];\n  int iw = 0;\n  for (int i=0; i < n; ++ i) {\n    NetCon* nc = cg.netcons[i];\n    for (int j=0; j < nc->cnt_; ++j) {\n      weights[iw++] = nc->weight_[j];\n    }\n  }\n  // alloc a delay array and write netcon delays\n  delays = new double[n];\n  for (int i=0; i < n; ++ i) {\n    NetCon* nc = cg.netcons[i];\n    delays[i] = nc->delay_;\n  }\n\n  return 1;\n}\n\nstatic int nrnthread_dat2_corepointer(int tid, int& n) {\n\n  if (tid >= nrn_nthread) { return 0; }\n  NrnThread& nt = nrn_threads[tid];\n\n  n = 0;\n  MlWithArt& mla = cellgroups_[tid].mlwithart;\n  for (size_t i = 0; i < mla.size(); ++i) {\n    if (nrn_bbcore_write_[mla[i].first]) {\n      ++n;\n    }\n  }\n\n  return 1;\n}\n\nstatic int nrnthread_dat2_corepointer_mech(int tid, int type,\n int& icnt, int& dcnt, int*& iArray, double*& dArray) {\n\n  if (tid >= nrn_nthread) { return 0; }\n  NrnThread& nt = nrn_threads[tid];\n  CellGroup& cg = cellgroups_[tid];\n  Memb_list* ml = cg.type2ml[type];\n\n      dcnt = 0;\n      icnt = 0;\n      // data size and allocate\n      for (int i = 0; i < ml->nodecount; ++i) {\n        (*nrn_bbcore_write_[type])(NULL, NULL, &dcnt, &icnt, ml->data[i], ml->pdata[i], ml->_thread, &nt);\n      }\n      dArray = NULL;\n      iArray = NULL;\n      if (icnt)\n      {\n        iArray = new int[icnt];\n      }\n      if (dcnt)\n      {\n        dArray = new double[dcnt];\n      }\n      icnt = dcnt = 0;\n      // data values\n      for (int i = 0; i < ml->nodecount; ++i) {\n        (*nrn_bbcore_write_[type])(dArray, iArray, &dcnt, &icnt, ml->data[i], ml->pdata[i], ml->_thread, &nt);\n      }\n\n  return 1;\n}\n\nvoid nrnthread_group_ids(int* grp) {\n  for (int i = 0; i < nrn_nthread; ++i) {\n    grp[i] = cellgroups_[i].group_id;\n  }\n}\n\nvoid write_nrnthread(const char* path, NrnThread& nt, CellGroup& cg) {\n  char fname[1000];\n  if (cg.n_output <= 0) { return; }\n  assert(cg.group_id >= 0);\n  nrn_assert(snprintf(fname, 1000, \"%s/%d_1.dat\", path, cg.group_id) < 1000);\n  FILE* f = fopen(fname, \"wb\");\n  if (!f) {\n    hoc_execerror(\"nrnbbcore_write write_nrnthread could not open for writing:\", fname);\n  }\n  fprintf(f, \"%s\\n\", bbcore_write_version);\n\n  //nrnthread_dat1(int tid, int& n_presyn, int& n_netcon, int*& output_gid, int*& netcon_srcgid);\n  fprintf(f, \"%d npresyn\\n\", cg.n_presyn);\n  fprintf(f, \"%d nnetcon\\n\", cg.n_netcon);\n  writeint(cg.output_gid, cg.n_presyn);\n  writeint(cg.netcon_srcgid, cg.n_netcon);\n\n  if (cg.output_gid) {delete [] cg.output_gid; cg.output_gid = NULL; }\n  if (cg.netcon_srcgid) {delete [] cg.netcon_srcgid; cg.netcon_srcgid = NULL; }\n  fclose(f);\n\n  nrn_assert(snprintf(fname, 1000, \"%s/%d_2.dat\", path, cg.group_id) < 1000);\n  f = fopen(fname, \"w\");\n  if (!f) {\n    hoc_execerror(\"nrnbbcore_write write_nrnthread could not open for writing:\", fname);\n  }\n\n  fprintf(f, \"%s\\n\", bbcore_write_version);\n\n  // sizes and total data count\n  int ngid, n_real_gid, nnode, ndiam, nmech, *tml_index, *ml_nodecount, nidata,\n    nvdata, nweight;\n  nrnthread_dat2_1(nt.id, ngid, n_real_gid, nnode, ndiam,\n    nmech, tml_index, ml_nodecount, nidata, nvdata, nweight);\n\n  fprintf(f, \"%d ngid\\n\", ngid);\n  fprintf(f, \"%d n_real_gid\\n\", n_real_gid);\n  fprintf(f, \"%d nnode\\n\", nnode);\n  fprintf(f, \"%d ndiam\\n\", ndiam);\n  fprintf(f, \"%d nmech\\n\", nmech);\n\n  for (int i=0; i < nmech; ++i) {\n    fprintf(f, \"%d\\n\", tml_index[i]);\n    fprintf(f, \"%d\\n\", ml_nodecount[i]);\n  }\n  delete [] tml_index;\n  delete [] ml_nodecount;\n\n  fprintf(f, \"%d nidata\\n\", 0);\n  fprintf(f, \"%d nvdata\\n\", nvdata);\n  fprintf(f, \"%d nweight\\n\", nweight);\n\n  // data\n  int *v_parent_index=NULL; double *a=NULL, *b=NULL, *area=NULL, *v=NULL, *diamvec=NULL;\n  nrnthread_dat2_2(nt.id, v_parent_index, a, b, area, v, diamvec);\n  assert(cg.n_real_output == nt.ncell);\n  writeint(nt._v_parent_index, nt.end);\n  writedbl(nt._actual_a, nt.end);\n  writedbl(nt._actual_b, nt.end);\n  writedbl(nt._actual_area, nt.end);\n  writedbl(nt._actual_v, nt.end);\n  if (cg.ndiam) {\n    writedbl(diamvec, nt.end);\n    delete [] diamvec;\n  }\n\n  // mechanism data\n  int dsz_inst = 0;\n  MlWithArt& mla = cg.mlwithart;\n  for (size_t i = 0; i < mla.size(); ++i) {\n    int type = mla[i].first;\n    int *nodeindices=NULL, *pdata=NULL; double* data=NULL;\n    nrnthread_dat2_mech(nt.id, i, dsz_inst, nodeindices, data, pdata);\n    Memb_list* ml = mla[i].second;\n    int n = ml->nodecount;\n    int sz = nrn_prop_param_size_[type];\n    if (nodeindices) {\n      writeint(nodeindices, n);\n    }\n    writedbl(data, n * sz);\n    if (nrn_is_artificial_[type]) {\n      delete [] data;\n    }\n    sz = bbcore_dparam_size[type];\n    if (pdata) {\n      ++dsz_inst;\n      writeint(pdata, n * sz);\n      delete [] pdata;\n    }\n  }\n\n  int *output_vindex, *netcon_pnttype, *netcon_pntindex;\n  double *output_threshold, *weights, *delays;\n  nrnthread_dat2_3(nt.id, nweight, output_vindex, output_threshold,\n    netcon_pnttype, netcon_pntindex, weights, delays);\n  writeint(output_vindex, cg.n_presyn);\n  writedbl(output_threshold, cg.n_real_output);\n  delete [] output_threshold;\n\n  // connections\n  int n = cg.n_netcon;\n//printf(\"n_netcon=%d nweight=%d\\n\", n, nweight);\n  writeint(netcon_pnttype, n);\n  delete [] netcon_pnttype;\n  writeint(netcon_pntindex, n);\n  delete [] netcon_pntindex;\n  writedbl(weights, nweight);\n  delete [] weights;\n  writedbl(delays, n);\n  delete [] delays;\n\n  // special handling for BBCOREPOINTER\n  // how many mechanisms require it\n  nrnthread_dat2_corepointer(nt.id, n);\n  fprintf(f, \"%d bbcorepointer\\n\", n);\n  // for each of those, what is the mech type and data size\n  // and what is the data\n  for (size_t i = 0; i < mla.size(); ++i) {\n    int type = mla[i].first;\n    if (nrn_bbcore_write_[type]) {\n      int icnt, dcnt, *iArray; double* dArray;\n      nrnthread_dat2_corepointer_mech(nt.id, type, icnt, dcnt, iArray, dArray);\n      fprintf(f, \"%d\\n\", type);\n      fprintf(f, \"%d\\n%d\\n\", icnt, dcnt);\n      if (icnt) {\n        writeint(iArray, icnt);\n        delete [] iArray;\n      }\n      if (dcnt) \n      {\n        writedbl(dArray, dcnt);\n        delete [] dArray;\n      }\n    }\n  }\n\n  nrnbbcore_vecplay_write(f, nt);\n\n  fclose(f);\n}\n\n\n/** Write all dataset ids to files.dat.\n *\n * Format of the files.dat file is:\n *\n *     version string\n *     -1 (if model uses gap junction)\n *     n (number of datasets)\n *     id1\n *     id2\n *     ...\n *     idN\n */\nvoid write_nrnthread_task(const char* path, CellGroup* cgs)\n{\n  // ids of datasets that will be created\n  std::vector<int> iSend;\n\n  // ignore empty nrnthread (has -1 id)\n  for (int iInt = 0; iInt < nrn_nthread; ++iInt)\n  {\n    if ( cgs[iInt].group_id >= 0) {\n        iSend.push_back(cgs[iInt].group_id);\n    }\n  }\n\n  // receive and displacement buffers for mpi\n  std::vector<int> iRecv, iDispl;\n\n  if (nrnmpi_myid == 0)\n  {\n    iRecv.resize(nrnmpi_numprocs);\n    iDispl.resize(nrnmpi_numprocs);\n  }\n\n  // number of datasets on the current rank\n  int num_datasets = iSend.size();\n\n#ifdef NRNMPI\n  // gather number of datasets from each task\n  if (nrnmpi_numprocs > 1) {\n    nrnmpi_int_gather(&num_datasets, begin_ptr(iRecv), 1, 0);\n  }else{\n    iRecv[0] = num_datasets;\n  }\n#else\n  iRecv[0] = num_datasets;\n#endif\n\n  // total number of datasets across all ranks\n  int iSumThread = 0;\n\n  // calculate mpi displacements\n  if (nrnmpi_myid == 0)\n  {\n    for (int iInt = 0; iInt < nrnmpi_numprocs; ++iInt)\n    {\n      iDispl[iInt] = iSumThread;\n      iSumThread += iRecv[iInt];\n    }\n  }\n\n  // buffer for receiving all dataset ids\n  std::vector<int> iRecvVec(iSumThread);\n\n#ifdef NRNMPI\n  // gather ids into the array with correspondent offsets\n  if (nrnmpi_numprocs > 1) {\n    nrnmpi_int_gatherv(begin_ptr(iSend), num_datasets, begin_ptr(iRecvVec), begin_ptr(iRecv), begin_ptr(iDispl), 0);\n  }else{\n    for (int iInt = 0; iInt < num_datasets; ++iInt)\n    {\n      iRecvVec[iInt] = iSend[iInt];\n    }\n  }\n#else\n  for (int iInt = 0; iInt < num_datasets; ++iInt)\n  {\n    iRecvVec[iInt] = iSend[iInt];\n  }\n#endif\n\n  /// Writing the file with task, correspondent number of threads and list of correspondent first gids\n  if (nrnmpi_myid == 0)\n  {\n    std::stringstream ss;\n    ss << path << \"/files.dat\";\n\n    std::string filename = ss.str();\n\n    FILE *fp = fopen(filename.c_str(), \"w\");\n    if (!fp) {\n      hoc_execerror(\"nrnbbcore_write write_nrnthread_task could not open for writing:\", filename.c_str());\n    }\n\n    fprintf(fp, \"%s\\n\", bbcore_write_version);\n\n    // notify coreneuron that this model involves gap junctions\n    if (nrnthread_v_transfer_) {\n      fprintf(fp, \"-1\\n\");\n    }\n\n    // total number of datasets\n    fprintf(fp, \"%d\\n\", iSumThread);\n\n    // write all dataset ids\n    for (int i = 0; i < iRecvVec.size(); ++i)\n    {\n        fprintf(fp, \"%d\\n\", iRecvVec[i]);\n    }\n\n    fclose(fp);\n  }\n\n}\n\n\nint* datum2int(int type, Memb_list* ml, NrnThread& nt, CellGroup& cg, DatumIndices& di, int ml_vdata_offset) {\n  int isart = nrn_is_artificial_[di.type];\n  int sz = bbcore_dparam_size[type];\n  int* pdata = new int[ml->nodecount * sz];\n  for (int i=0; i < ml->nodecount; ++i) {\n    Datum* d = ml->pdata[i];\n    int ioff = i*sz;\n    for (int j = 0; j < sz; ++j) {\n      int jj = ioff + j;\n      int etype = di.ion_type[jj];\n      int eindex = di.ion_index[jj];\n      if (etype == -1) {\n        if (isart) {\n          pdata[jj] = -1; // maybe save this space eventually. but not many of these in bb models\n        }else{\n          pdata[jj] = eindex;\n        }\n      }else if (etype == -9) {\n        pdata[jj] = eindex;\n      }else if (etype > 0 && etype < 1000){//ion pointer and also POINTER\n        pdata[jj] = eindex;\n      }else if (etype > 1000 && etype < 2000) { //ionstyle can be explicit instead of pointer to int*\n        pdata[jj] = eindex;\n      }else if (etype == -2) { // an ion and this is the iontype\n        pdata[jj] = eindex;\n      }else if (etype == -4) { // netsend (_tqitem)\n        pdata[jj] = ml_vdata_offset + eindex;\n        //printf(\"etype %d jj=%d eindex=%d pdata=%d\\n\", etype, jj, eindex, pdata[jj]);\n      }else if (etype == -6) { // pntproc\n        pdata[jj] = ml_vdata_offset + eindex;\n        //printf(\"etype %d jj=%d eindex=%d pdata=%d\\n\", etype, jj, eindex, pdata[jj]);\n      }else if (etype == -7) { // bbcorepointer\n        pdata[jj] = ml_vdata_offset + eindex;\n        //printf(\"etype %d jj=%d eindex=%d pdata=%d\\n\", etype, jj, eindex, pdata[jj]);\n      }else if (etype == -5) { // POINTER to voltage\n        pdata[jj] = eindex;\n        //printf(\"etype %d\\n\", etype);\n      }else{ //uninterpreted\n        assert(eindex != -3); // avoided if last\n        pdata[jj] = 0;\n      }\n    }\n  }\n  return pdata;\n}\n\n\n/** @brief Count number of unique elements in the array.\n *  there is a copy of the vector but we are primarily\n *  using it for small section list vectors.\n */\nint count_distinct(double *data, int len) {\n    if( len == 0)\n        return 0;\n    std::vector<double> v;\n    v.assign(data, data + len);\n    std::sort(v.begin(), v.end());\n    return std::unique(v.begin(), v.end()) - v.begin();\n}\n\n/** @brief For BBP use case, we want to write section-segment\n *  mapping to gid_3.dat file. This information will be\n *  provided through neurodamus HOC interface with following\n *  format:\n *      gid : number of non-empty neurons in the cellgroup\n *      name : name of section list (like soma, axon, apic)\n *      nsec : number of sections\n *      sections : list of sections\n *      segments : list of segments\n */\nvoid nrnbbcore_register_mapping() {\n\n    // gid of a cell\n    int gid = *hoc_getarg(1);\n\n    // name of section list\n    std::string name = std::string(hoc_gargstr(2));\n\n    // hoc vectors: sections and segments\n    Vect* sec = vector_arg(3);\n    Vect* seg = vector_arg(4);\n\n    double* sections  = vector_vec(sec);\n    double* segments  = vector_vec(seg);\n\n    int nsec = vector_capacity(sec);\n    int nseg = vector_capacity(seg);\n\n    if( nsec != nseg ) {\n        std::cout << \"Error: Section and Segment mapping vectors should have same size!\\n\";\n        abort();\n    }\n\n    // number of unique sections\n    nsec = count_distinct(sections, nsec);\n\n    SecMapping *smap = new SecMapping(nsec, name);\n    smap->sections.assign(sections, sections+nseg);\n    smap->segments.assign(segments, segments+nseg);\n\n    // store mapping information\n    mapinfo.add_sec_mapping(gid, smap);\n}\n\n/** @brief dump mapping information to gid_3.dat file */\nvoid nrn_write_mapping_info(const char *path, int gid, NrnMappingInfo &minfo) {\n\n    /** full path of mapping file */\n    std::stringstream ss;\n    ss << path << \"/\" << gid << \"_3.dat\";\n\n    std::string fname(ss.str());\n    FILE *f = fopen(fname.c_str(), \"w\");\n\n    if (!f) {\n        hoc_execerror(\"nrnbbcore_write could not open for writing:\", fname.c_str());\n    }\n\n    fprintf(f, \"%s\\n\", bbcore_write_version);\n\n    /** number of gids in NrnThread */\n    fprintf(f, \"%zd\\n\", minfo.size());\n\n    /** all cells mapping information in NrnThread */\n    for(size_t i = 0; i < minfo.size(); i++) {\n        CellMapping *c = minfo.mapping[i];\n\n        /** gid, #section, #compartments,  #sectionlists */\n        fprintf(f, \"%d %d %d %zd\\n\", c->gid, c->num_sections(), c->num_segments(), c->size());\n\n        for(size_t j = 0; j < c->size(); j++) {\n            SecMapping* s = c->secmapping[j];\n            /** section list name, number of sections, number of segments */\n            fprintf(f, \"%s %d %zd\\n\", s->name.c_str(), s->nsec, s->size());\n\n            /** section - segment mapping */\n            if(s->size()) {\n                writeint(&(s->sections.front()), s->size());\n                writeint(&(s->segments.front()), s->size());\n            }\n        }\n    }\n    fclose(f);\n}\n\ntypedef void*(*CNB)(...);\ntypedef struct core2nrn_callback_t {\n  const char* name;\n  CNB f;\n} core2nrn_callback_t;\n\n// from partrans.cpp\nextern \"C\" {\nextern void get_partrans_setup_info(int, int&, int&, int&, int&, int*&, int*&, int*&);\n}\n\nextern \"C\" {\nvoid nrnthread_get_trajectory_requests(int tid, int& bsize, int& ntrajec, void**& vpr, int*& types, int*& indices, double**& pvars, double**& varrays);\nvoid nrnthread_trajectory_values(int tid, int n_pr, void** vpr, double t);\nvoid nrnthread_trajectory_return(int tid, int n_pr, int vecsz, void** vpr, double t);\n}\n\nstatic core2nrn_callback_t cnbs[]  = {\n  {\"nrn2core_group_ids_\", (CNB)nrnthread_group_ids},\n  {\"nrn2core_mkmech_info_\", (CNB)write_memb_mech_types_direct},\n  {\"nrn2core_get_global_dbl_item_\", (CNB)get_global_dbl_item},\n  {\"nrn2core_get_global_int_item_\", (CNB)get_global_int_item},\n  {\"nrn2core_get_partrans_setup_info_\", (CNB)get_partrans_setup_info},\n  {\"nrn2core_get_dat1_\", (CNB)nrnthread_dat1},\n  {\"nrn2core_get_dat2_1_\", (CNB)nrnthread_dat2_1},\n  {\"nrn2core_get_dat2_2_\", (CNB)nrnthread_dat2_2},\n  {\"nrn2core_get_dat2_mech_\", (CNB)nrnthread_dat2_mech},\n  {\"nrn2core_get_dat2_3_\", (CNB)nrnthread_dat2_3},\n  {\"nrn2core_get_dat2_corepointer_\", (CNB)nrnthread_dat2_corepointer},\n  {\"nrn2core_get_dat2_corepointer_mech_\", (CNB)nrnthread_dat2_corepointer_mech},\n  {\"nrn2core_get_dat2_vecplay_\", (CNB)nrnthread_dat2_vecplay},\n  {\"nrn2core_get_dat2_vecplay_inst_\", (CNB)nrnthread_dat2_vecplay_inst},\n  {\"nrn2core_part2_clean_\", (CNB)part2_clean},\n\n  {\"nrn2core_get_trajectory_requests_\", (CNB)nrnthread_get_trajectory_requests},\n  {\"nrn2core_trajectory_values_\", (CNB)nrnthread_trajectory_values},\n  {\"nrn2core_trajectory_return_\", (CNB)nrnthread_trajectory_return},\n  {NULL, NULL}\n};\n\n#if defined(HAVE_DLFCN_H)\n\nextern int nrn_use_fast_imem;\nextern char* neuron_home;\n\n/** Check if coreneuron is loaded into memory */\nbool is_coreneuron_loaded() {\n    bool is_loaded = false;\n    // check if corenrn_version symbol can be found\n    void * handle = dlopen(NULL, RTLD_NOW | RTLD_GLOBAL);\n    if (handle) {\n        void* fn = dlsym(handle, \"corenrn_version\");\n        is_loaded = fn == NULL ? false : true;\n        dlclose(handle);\n    }\n    return is_loaded;\n}\n\n/** Check if file with given path exist */\nbool file_exist(const std::string& path) {\n    std::ifstream f(path.c_str());\n    return f.good();\n}\n\n/** Open library with given path and return dlopen handle **/\nvoid* get_handle_for_lib(const char* path) {\n    void* handle = dlopen(path, RTLD_NOW|RTLD_GLOBAL);\n    if (!handle) {\n      fputs(dlerror(), stderr);\n      fputs(\"\\n\", stderr);\n      hoc_execerror(\"Could not dlopen CoreNEURON mechanism library : \", path);\n    }\n    return handle;\n}\n\n/** Get CoreNEURON mechanism library */\nvoid* get_coreneuron_handle() {\n\t// if already loaded into memory, directly return handle\n\tif (is_coreneuron_loaded()) {\n\t\treturn dlopen(NULL, RTLD_NOW|RTLD_GLOBAL);\n\t}\n\n\t// env variable get highest preference\n\tconst char* corenrn_lib = getenv(\"CORENEURONLIB\");\n\tif (corenrn_lib && file_exist(corenrn_lib)) {\n\t\treturn get_handle_for_lib(corenrn_lib);\n\t}\n\n\t// name of coreneuron library based on platform\n\t#if defined(MINGW)\n\tstd::string corenrn_mechlib_name(\"libcorenrnmech.dll\");\n\t#elif defined(DARWIN)\n\tstd::string corenrn_mechlib_name(\"libcorenrnmech.dylib\");\n\t#else\n\tstd::string corenrn_mechlib_name(\"libcorenrnmech.so\");\n\t#endif\n\n\t// first check if coreneuron specific library exist in <arch>/.libs\n\t// note that we need to get full path especially for OSX\n\tchar pwd[FILENAME_MAX];\n\tgetcwd(pwd, FILENAME_MAX);\n\n\tstd::stringstream s_path;\n\ts_path << pwd << \"/\" << NRNHOSTCPU << \"/\" << corenrn_mechlib_name;\n\tstd::string path = s_path.str();\n\n\tif (file_exist(path)) {\n\t\treturn get_handle_for_lib(path.c_str());\n\t}\n\n\t// last fallback is minimal library with internal mechanisms\n\ts_path.str(\"\");\n\t#if defined(MINGW)\n\ts_path << neuron_home << \"/lib/\" << corenrn_mechlib_name;\n\t#else\n\ts_path << neuron_home << \"/../../lib/\" << corenrn_mechlib_name;\n\t#endif\n\tpath = s_path.str();\n\n\t// if this last path doesn't exist then it's an error\n\tif (!file_exist(path)) {\n        hoc_execerror(\"Could not find CoreNEURON library\", NULL);\n\t}\n\n\treturn get_handle_for_lib(path.c_str());\n}\n\n/** Check if neuron & coreneuron are compatible */\nvoid check_coreneuron_compatibility(void* handle) {\n    // get handle to function in coreneuron\n    void* cn_version_sym = dlsym(handle, \"corenrn_version\");\n    if (!cn_version_sym) {\n      hoc_execerror(\"Could not get symbol corenrn_version from CoreNEURON\", NULL);\n    }\n    // call coreneuron function and get version string\n    const char* cn_bbcore_read_version = (*(const char*(*)())cn_version_sym)();\n\n    // make sure neuron and coreneuron version are same; otherwise throw an error\n    if (strcmp(bbcore_write_version, cn_bbcore_read_version) != 0) {\n      std::stringstream s_path;\n      s_path << bbcore_write_version << \" vs \" << cn_bbcore_read_version;\n      hoc_execerror(\"Incompatible NEURON and CoreNEURON versions :\", s_path.str().c_str());\n    }\n}\n\n/** Populate function pointers by mapping function pointers for callback */\nvoid map_coreneuron_callbacks(void* handle) {\n    for (int i=0; cnbs[i].name; ++i) {\n        void* sym = dlsym(handle, cnbs[i].name);\n        if (!sym) {\n            fprintf(stderr, \"Could not get symbol %s from CoreNEURON\\n\", cnbs[i].name);\n            hoc_execerror(\"dlsym returned NULL\", NULL);\n        }\n        void** c = (void**)sym;\n        *c = (void*)(cnbs[i].f);\n    }\n}\n\n/** Launch CoreNEURON in direct memory mode */\nint nrncore_run(const char* arg) {\n    // using direct memory mode\n    corenrn_direct = true;\n\n    // check that model can be transferred\n    model_ready();\n\n    // get coreneuron library handle\n    void* handle = get_coreneuron_handle();\n\n    // make sure coreneuron & neuron are compatible\n    check_coreneuron_compatibility(handle);\n\n    // setup the callback functions between neuron & coreneuron\n    map_coreneuron_callbacks(handle);\n\n    // lookup symbol from coreneuron for launching\n    void* launcher_sym = dlsym(handle, \"corenrn_embedded_run\");\n    if (!launcher_sym) {\n        hoc_execerror(\"Could not get symbol corenrn_embedded_run from\", NULL);\n    }\n\n    // prepare the model\n    part1();\n\n    int have_gap = nrnthread_v_transfer_ ? 1 : 0;\n#if !NRNMPI\n#define nrnmpi_use 0\n#endif\n\n    // typecast function pointer pointer\n    int (*coreneuron_launcher)(int, int, int, int, const char*) = (int (*)(int, int, int, int, const char*))launcher_sym;\n\n    // launch coreneuron\n    int result = coreneuron_launcher(nrn_nthread, have_gap, nrnmpi_use, nrn_use_fast_imem, arg);\n\n    // close handle and return result\n    dlclose(handle);\n    return result;\n}\n\n/** Return neuron.coreneuron.enable */\nint nrncore_is_enabled() {\n  if (nrnpy_nrncore_enable_value_p_) {\n    int b = (*nrnpy_nrncore_enable_value_p_)();\n    return b;\n  }\n  return 0;\n}\n\n/** Run coreneuron with arg string from neuron.coreneuron.nrncore_arg(tstop)\n *  Return 0 on success\n*/\nint nrncore_psolve(double tstop) {\n  if (nrnpy_nrncore_arg_p_) {\n    char* arg = (*nrnpy_nrncore_arg_p_)(tstop);\n    if (arg) {\n      nrncore_run(arg);\n      free(arg);\n      return 0;\n    }\n  }\n  return -1;\n}\n\n#else // !HAVE_DLFCN_H\n\nint nrncore_run(const char*) {\n  return -1;\n}\n\nint nrncore_is_enabled() {\n  return 0;\n}\n\nint nrncore_psolve(double tstop) {\n  return 0;\n}\n\n#endif //!HAVE_DLFCN_H\n\n} // end of extern \"C\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/nrniv/CMakeLists.txt": "# =============================================================================\n# Build nrniv binary and corresponding library\n# =============================================================================\n\n# ~~~\n# The old build (autoconf) built executables in oc, nrnoc, ivoc, nrniv as\n# well as libraries there and in a dozen or so other places. For cmake we\n# are experimenting with a single libnrniv.so that combines many of files\n# in those folders, both for simplicity, and to avoid issues of dependency\n# among the old libraries.\n# Also the oc, nrnoc, and ivoc executables are pretty well useless these\n# days. Other groups can, and should be, factored out.\n# ~~~\n\n# =============================================================================\n# Build modlunit : Mod file units checker\n# =============================================================================\nflex_target(modlunitlexer ${NRN_MODLUNIT_SRC_DIR}/lex.l ${NRN_MODLUNIT_SRC_DIR}/lex.c)\n\nbison_target(modlunitparser ${NRN_MODLUNIT_SRC_DIR}/parse1.y ${NRN_MODLUNIT_SRC_DIR}/parse1.c\n             DEFINES_FILE ${NRN_MODLUNIT_SRC_DIR}/parse1.h)\n\nset_property(\n  SOURCE ${NRN_MODLUNIT_SRC_FILES}\n  APPEND\n  PROPERTY COMPILE_DEFINITIONS NRNUNIT=1)\n\nadd_executable(modlunit ${NRN_MODLUNIT_SRC_FILES})\n\n# =============================================================================\n# Build nocmodl : source-to-source compiler for NMODL\n# =============================================================================\nflex_target(nocmodllexer ${NRN_NMODL_SRC_DIR}/lex.l ${NRN_NMODL_SRC_DIR}/lex.c)\n\nbison_target(nocmodlparser ${NRN_NMODL_SRC_DIR}/parse1.y ${NRN_NMODL_SRC_DIR}/parse1.c DEFINES_FILE\n             ${NRN_NMODL_SRC_DIR}/parse1.h)\n\nbison_target(nocmodlparser ${NRN_NMODL_SRC_DIR}/diffeq.y ${NRN_NMODL_SRC_DIR}/diffeq.c DEFINES_FILE\n             ${NRN_NMODL_SRC_DIR}/diffeq.h)\n\nset_property(\n  SOURCE ${NRN_NMODL_SRC_FILES}\n  APPEND\n  PROPERTY COMPILE_DEFINITIONS NMODL=1 NOCMODL=1 CVODE=1 VECTORIZE=1)\n\nadd_executable(nocmodl ${NRN_NMODL_SRC_FILES})\n\n# =============================================================================\n# Translate all MOD files to C and mark them generated\n# =============================================================================\nforeach(modfile ${NRN_MODFILE_BASE_NAMES})\n  nocmodl_mod_to_c(${modfile})\n  list(APPEND NRN_MODFILE_C ${modfile}.c)\nendforeach()\n\nset_source_files_properties(${NRN_MODFILE_C} PROPERTIES GENERATED TRUE)\n\n# =============================================================================\n# Bison parser for HOC interpreter\n# =============================================================================\nbison_target(ocparser ${NRN_OC_SRC_DIR}/parse.y ${NRN_OC_SRC_DIR}/parse.c DEFINES_FILE\n             ${NRN_OC_SRC_DIR}/parse.h)\n\n# =============================================================================\n# Source code lists\n# =============================================================================\nset(NRN_BASE_SRC_FILES ${NRN_IVOC_SRC_FILES} ${NRN_NRNIV_SRC_FILES} ${NRN_NRNOC_SRC_FILES}\n                       ${NRN_OC_SRC_FILES})\n\nset(NRN_NRNIV_LIB_SRC_FILES\n    ${NRN_BASE_SRC_FILES}\n    ${NRN_MEMACS_SRC_FILES}\n    ${NRN_MESCH_SRC_FILES}\n    ${NRN_MODFILE_C}\n    ${NRN_NRNGNU_SRC_FILES}\n    ${NRN_SCOPMATH_SRC_FILES}\n    ${NRN_SPARSE13_SRC_FILES}\n    ${NRN_SUNDIALS_SRC_FILES})\n\nif(NRN_ENABLE_MPI)\n  list(APPEND NRN_NRNIV_LIB_SRC_FILES ${NRN_PARALLEL_SRC_FILES})\nendif()\n\nif(NRN_ENABLE_MPI_DYNAMIC)\n  list(APPEND NRN_NRNIV_LIB_SRC_FILES ${PROJECT_SOURCE_DIR}/src/nrnmpi/nrnmpi_dynam.c)\nelse()\n  list(APPEND NRN_NRNIV_LIB_SRC_FILES ${NRN_NRNMPI_SRC_FILES})\nendif()\n\n# NRN_ENABLE_MODULE_INSTALL will create a separate nrnpython lib\nif(NRN_ENABLE_PYTHON AND NOT NRN_ENABLE_PYTHON_DYNAMIC)\n  # Include nrnpython in nrniv - useful for single lib neuron and wheels\n  list(APPEND NRN_NRNIV_LIB_SRC_FILES ${NRN_NRNPYTHON_SRC_FILES})\nendif()\n\nif(NOT NRN_ENABLE_INTERVIEWS)\n  list(APPEND NRN_NRNIV_LIB_SRC_FILES ${NRN_IVOS_SRC_FILES})\nendif()\n\n# =============================================================================\n# Include directories for #include <../../nrnconf.h>\n# =============================================================================\nset(NRN_INCLUDE_DIRS\n    ${NRN_IVOC_SRC_DIR}\n    ${NRN_NRNIV_SRC_DIR}\n    ${NRN_NRNOC_SRC_DIR}\n    ${NRN_OC_SRC_DIR}\n    ${PROJECT_BINARY_DIR}\n    ${PROJECT_BINARY_DIR}/src/nrncvode\n    ${PROJECT_BINARY_DIR}/src/nrnjava\n    ${PROJECT_BINARY_DIR}/src/nrnoc\n    ${PROJECT_BINARY_DIR}/src/nrnpython\n    ${PROJECT_BINARY_DIR}/src/oc\n    ${PROJECT_BINARY_DIR}/src/parallel\n    ${PROJECT_BINARY_DIR}/src/sundials\n    ${PROJECT_BINARY_DIR}/src/sundials/shared\n    ${PROJECT_SOURCE_DIR}/src\n    ${PROJECT_SOURCE_DIR}/src/gnu\n    ${PROJECT_SOURCE_DIR}/src/memacs\n    ${PROJECT_SOURCE_DIR}/src/mesch\n    ${PROJECT_SOURCE_DIR}/src/nrncvode\n    ${PROJECT_SOURCE_DIR}/src/nrnmpi\n    ${PROJECT_SOURCE_DIR}/src/nrnpython\n    ${PROJECT_SOURCE_DIR}/src/parallel\n    ${PROJECT_SOURCE_DIR}/src/sparse\n    ${PROJECT_SOURCE_DIR}/src/sparse13\n    ${PROJECT_SOURCE_DIR}/src/sundials\n    ${PROJECT_SOURCE_DIR}/src/sundials/cvodes\n    ${PROJECT_SOURCE_DIR}/src/sundials/ida\n    ${PROJECT_SOURCE_DIR}/src/sundials/shared)\n\n# =============================================================================\n# Helper commands : generate various headers\n# =============================================================================\n# ~~~\n# generate version information file\n# nrnversion.h does not depend on another file but on the output of\n# git2version_h.sh and nrnversion.h should only be changed if that output\n# is different from the contents of nrnversion.h\n# ~~~\nadd_custom_target(\n  nrnversion_h ${PROJECT_SOURCE_DIR}/git2nrnversion_h.sh ${PROJECT_SOURCE_DIR} > nrnversion.h.tmp\n  COMMAND ${CMAKE_COMMAND} -E copy_if_different nrnversion.h.tmp ${NRN_NRNOC_SRC_DIR}/nrnversion.h\n  DEPENDS ${PROJECT_SOURCE_DIR}/git2nrnversion_h.sh)\n\nadd_custom_command(OUTPUT ${NRN_NRNOC_SRC_DIR}/nrnversion.h DEPENDS nrnversion_h)\n\n# avoid error with nvector_serial.c for #include <../../../nrnconf.h>\nfile(MAKE_DIRECTORY ${PROJECT_BINARY_DIR}/src/sundials/shared)\n\n# generate hocusr.h\nadd_custom_command(\n  OUTPUT ${PROJECT_BINARY_DIR}/src/nrnoc/hocusr.h\n  COMMAND\n    ${CMAKE_C_COMPILER} -E -I${NRN_NRNOC_SRC_DIR} -I${NRN_OC_SRC_DIR} ${NRN_NRNOC_SRC_DIR}/neuron.h\n    > neuron.tmp1\n  COMMAND sed \"/^#/d\" neuron.tmp1 > neuron.tmp2\n  COMMAND ${PYTHON_EXECUTABLE} ${NRN_OC_SRC_DIR}/mk_hocusr_h.py < neuron.tmp2 > temp2hoc\n  COMMAND sed \"s/\\\\\\\"nrnhoc_topology\\\\\\\"/\\\\\\\"topology\\\\\\\"/\" temp2hoc >\n          ${PROJECT_BINARY_DIR}/src/nrnoc/hocusr.h\n  DEPENDS ${NRN_NRNOC_SRC_DIR}/neuron.h ${NRN_OC_SRC_DIR}/mk_hocusr_h.py)\n\n# header for dynamic mpi\nif(NRN_ENABLE_MPI_DYNAMIC)\n  add_custom_command(\n    OUTPUT ${NRNMPI_DYNAMIC_INCLUDE_FILE}\n    COMMAND sh mkdynam.sh\n    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}/src/nrnmpi\n    DEPENDS ${PROJECT_SOURCE_DIR}/src/nrnmpi/mkdynam.sh\n            ${PROJECT_SOURCE_DIR}/src/nrnmpi/nrnmpidec.h)\nendif()\n\n# =============================================================================\n# Various macro definitions for compiling different files\n# =============================================================================\nset_property(\n  SOURCE ${NRN_OC_SRC_FILES}\n  APPEND\n  PROPERTY COMPILE_DEFINITIONS OOP=1 HOC=1 INTERVIEWS=1)\n\nset_property(\n  SOURCE ${NRN_NRNOC_SRC_DIR}/code.c ${NRN_NRNOC_SRC_DIR}/hoc_init.c ${NRN_NRNOC_SRC_DIR}/hoc_oop.c\n  APPEND\n  PROPERTY COMPILE_DEFINITIONS CABLE=1)\n\nset_property(\n  SOURCE ${PROJECT_SOURCE_DIR}/src/nrniv/nrnpy.cpp\n         ${PROJECT_SOURCE_DIR}/src/nrnmpi/nrnmpi_dynam.c\n         ${PROJECT_SOURCE_DIR}/src/nrnpython/nrnpython.cpp\n  APPEND\n  PROPERTY COMPILE_DEFINITIONS NRNCMAKE)\n\nset_property(\n  SOURCE ${PROJECT_SOURCE_DIR}/src/nrniv/nrnpy.cpp\n  APPEND\n  PROPERTY COMPILE_DEFINITIONS USE_LIBNRNPYTHON_MAJORMINOR=${USE_LIBNRNPYTHON_MAJORMINOR})\n\nset_property(\n  SOURCE ${NRN_IVOC_SRC_FILES}\n  APPEND\n  PROPERTY COMPILE_DEFINITIONS USEMATRIX=1 USEGNU=1 USEBBS=1)\n\nset_property(\n  SOURCE ${NRN_NRNIV_SRC_FILES}\n  APPEND\n  PROPERTY COMPILE_DEFINITIONS USEMATRIX=1 USECVODE=1 CABLE=1 USEBBS=1 OOP=1)\n\nset_property(\n  SOURCE ${NRN_SCOPMATH_SRC_FILES}\n  APPEND\n  PROPERTY COMPILE_DEFINITIONS HOC=1)\n\nset_property(\n  SOURCE ${NRN_SCOPMATH_SRC_FILES}\n  APPEND\n  PROPERTY COMPILE_FLAGS \"-I${PROJECT_SOURCE_DIR}/src/scopmath\")\n\nif(DEF_RL_GETC_FUNCTION)\n  set_property(\n    SOURCE ${NRN_OC_SRC_DIR}/hoc.c\n    APPEND\n    PROPERTY COMPILE_DEFINITIONS ${DEF_RL_GETC_FUNCTION})\nendif()\n\nset_source_files_properties(${NRN_NRNOC_SRC_DIR}/code.c PROPERTIES OBJECT_DEPENDS\n                            ${NRN_OC_SRC_DIR}/parse.h)\n\nset_source_files_properties(${NRN_NRNOC_SRC_DIR}/nrnversion.c PROPERTIES OBJECT_DEPENDS\n                            ${PROJECT_SOURCE_DIR}/src/nrnoc/nrnversion.h)\n\nset_source_files_properties(${NRN_OC_SRC_DIR}/hocusr.c PROPERTIES OBJECT_DEPENDS\n                            ${PROJECT_BINARY_DIR}/src/nrnoc/hocusr.h)\n\nif(NRN_ENABLE_MPI_DYNAMIC)\n  set_source_files_properties(${PROJECT_SOURCE_DIR}/src/nrnmpi/nrnmpi_dynam.c PROPERTIES\n                              OBJECT_DEPENDS ${NRNMPI_DYNAMIC_INCLUDE_FILE})\n  set_source_files_properties(${PROJECT_SOURCE_DIR}/src/nrnmpi/nrnmpi.c PROPERTIES OBJECT_DEPENDS\n                              ${NRNMPI_DYNAMIC_INCLUDE_FILE})\n  set_source_files_properties(${PROJECT_SOURCE_DIR}/src/nrnmpi/bbsmpipack.c PROPERTIES\n                              OBJECT_DEPENDS ${NRNMPI_DYNAMIC_INCLUDE_FILE})\nendif()\n\n# =============================================================================\n# All source directories to include\n# =============================================================================\ninclude_directories(${NRN_INCLUDE_DIRS})\nif(NRN_ENABLE_PYTHON)\n  include_directories(${PYTHON_INCLUDE_DIRS})\nendif()\n\n# =============================================================================\n# All source directories to include\n# =============================================================================\nadd_library(nrniv_lib ${NRN_LIBRARY_TYPE} ${NRN_NRNIV_LIB_SRC_FILES})\nif(NRN_WINDOWS_BUILD)\n  target_link_libraries(nrniv_lib ${TERMCAP_LIBRARIES} ${Readline_LIBRARY})\nelse()\n  if(READLINE_FOUND)\n    target_link_libraries(nrniv_lib ${Readline_LIBRARY})\n  else()\n    target_link_libraries(nrniv_lib readline)\n  endif()\n\n  if(CURSES_FOUND)\n    target_link_libraries(nrniv_lib ${CURSES_LIBRARIES})\n  elseif(TERMCAP_FOUND)\n    target_link_libraries(nrniv_lib ${TERMCAP_LIBRARIES})\n  endif()\nendif()\n\nset_property(TARGET nrniv_lib PROPERTY OUTPUT_NAME nrniv)\n\n# =============================================================================\n# Link with all libraries\n# =============================================================================\nif(NRN_ENABLE_PYTHON AND NOT NRN_ENABLE_PYTHON_DYNAMIC)\n  target_link_libraries(nrniv_lib ${PYTHON_LIBRARIES})\nendif()\n\nif(NRN_ENABLE_MPI)\n  if(NRN_ENABLE_MPI_DYNAMIC)\n    list(LENGTH NRN_MPI_LIBNAME_LIST _num_mpi)\n    math(EXPR num_mpi \"${_num_mpi} - 1\")\n    foreach(val RANGE ${num_mpi})\n      list(GET NRN_MPI_INCLUDE_LIST ${val} include)\n      list(GET NRN_MPI_LIBNAME_LIST ${val} libname)\n\n      add_library(${libname}_lib SHARED ${NRN_NRNMPI_SRC_FILES})\n      target_include_directories(${libname}_lib PUBLIC ${include})\n      # Note that we do not link here to libmpi. That is dlopen first.\n      if(MINGW) # type msmpi only\n        add_dependencies(${libname}_lib nrniv_lib)\n        target_link_libraries(${libname}_lib ${MPI_C_LIBRARIES})\n        target_link_libraries(${libname}_lib nrniv_lib)\n      endif()\n      set_property(TARGET ${libname}_lib PROPERTY OUTPUT_NAME ${libname})\n      install(TARGETS ${libname}_lib DESTINATION ${NRN_INSTALL_SHARE_LIB_DIR})\n    endforeach(val)\n  else()\n    target_link_libraries(nrniv_lib ${MPI_C_LIBRARIES})\n    target_include_directories(nrniv_lib PUBLIC ${MPI_INCLUDE_PATH})\n  endif()\nendif()\n\nif(NRN_ENABLE_INTERVIEWS)\n  include_directories(${IV_INCLUDE_DIR})\n  target_link_libraries(nrniv_lib interviews)\nelse()\n  include_directories(nrniv_lib ${NRN_IVOS_SRC_DIR} ${PROJECT_BINARY_DIR}/src/ivos)\nendif()\n\nif(IV_ENABLE_X11_DYNAMIC)\n  # ~~~\n  # by defining IVX11_DYNAM in ivocmain.cpp, the latter can call ivx11_dyload and\n  # if that fails, set hoc_usegui = 0 which avoids all InterViews calls.\n  # ~~~\n  set_property(\n    SOURCE ${PROJECT_SOURCE_DIR}/src/ivoc/ivocmain.cpp ${PROJECT_SOURCE_DIR}/src/pwman/xdep.cpp\n           ${PROJECT_SOURCE_DIR}/src/ivoc/xdep.cpp ${PROJECT_SOURCE_DIR}/src/oc/x.c\n    APPEND\n    PROPERTY COMPILE_DEFINITIONS IVX11_DYNAM)\n  if((NOT IV_ENABLE_SHARED) AND IV_LIB_DIR)\n    # ~~~\n    # IV_LIB_DIR is not set when IV is a submodule and not yet installed but\n    # libivx11dynam is already in its proper place at POST_BUILD. When\n    # IV_ENABLE_SHARED=ON, libivx11dynam is found in IV_LIB_DIR (the location\n    # of libinterviews). When OFF, libivx11dynam needs to be copied to the\n    # location of libnrniv. The goal is that if libnrniv is loaded, the system\n    # can find libivx11dynam independent of CMAKE_INSTALL_PREFIX.\n    # ~~~\n    set(_suffix ${CMAKE_SHARED_LIBRARY_SUFFIX})\n    set(LIBIVX11DYNAM_NAME libivx11dynam${_suffix})\n    add_custom_command(\n      TARGET nrniv_lib POST_BUILD\n      COMMAND ${CMAKE_COMMAND} -E copy ${IV_LIB_DIR}/${LIBIVX11DYNAM_NAME}\n              ${PROJECT_BINARY_DIR}/lib/${LIBIVX11DYNAM_NAME})\n  endif()\nelse()\n  target_link_libraries(nrniv_lib ${X11_LIBRARIES})\nendif()\n\n# =============================================================================\n# Final executable\n# =============================================================================\nadd_executable(nrniv ${NRN_BIN_SRC_FILES})\ntarget_link_libraries(nrniv nrniv_lib ${INTERNAL_READLINE} ${CMAKE_THREAD_LIBS_INIT})\nif(NOT MINGW)\n  target_link_libraries(nrniv ${CMAKE_DL_LIBS})\nendif()\n\n# TODO: unset in top level CMake is not working\nif(NOT NRN_MACOS_BUILD AND READLINE_FOUND)\n  target_link_libraries(nrniv ${Readline_LIBRARY})\nendif()\n\n\n# =============================================================================\n# Install binary and library targets\n# =============================================================================\n# ~~~\n# classically, the autotools windows version installed dlls in <inst>/bin\n# For now, we keep this distinction as it reduces the PATH and is\n# expected when ctypes looks for dlls\n# ~~~\ninstall(TARGETS nrniv nocmodl modlunit DESTINATION bin)\ninstall(TARGETS nrniv_lib DESTINATION ${NRN_INSTALL_SHARE_LIB_DIR})\nif (LIBIVX11DYNAM_NAME)\n  install(FILES ${PROJECT_BINARY_DIR}/lib/${LIBIVX11DYNAM_NAME} DESTINATION lib)\nendif()\n\n# =============================================================================\n# Install / copy cpp and required headers for binary special flavor\n# =============================================================================\n\n# For testneuron CTest\nfile(COPY ${PROJECT_SOURCE_DIR}/src/ivoc/nrnmain.cpp DESTINATION ${CMAKE_BINARY_DIR}/share/nrn)\nfile(COPY ${PROJECT_BINARY_DIR}/src/oc/nrnmpiuse.h DESTINATION ${CMAKE_BINARY_DIR}/include)\nfile(COPY ${PROJECT_BINARY_DIR}/src/nrncvode/nrnneosm.h DESTINATION ${CMAKE_BINARY_DIR}/include/nrncvode)\nfile(COPY ${PROJECT_BINARY_DIR}/nrnconf.h DESTINATION ${CMAKE_BINARY_DIR}/include)\n\n# For the installation\ninstall(FILES ${PROJECT_SOURCE_DIR}/src/ivoc/nrnmain.cpp DESTINATION share/nrn)\ninstall(FILES ${PROJECT_BINARY_DIR}/src/oc/nrnmpiuse.h DESTINATION include)\ninstall(FILES ${PROJECT_BINARY_DIR}/src/nrncvode/nrnneosm.h DESTINATION include/nrncvode)\ninstall(FILES ${PROJECT_BINARY_DIR}/nrnconf.h DESTINATION include)\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/ivoc/nrnmain.cpp": "#include <nrnconf.h>\n#include <stdio.h>\n#include <string.h>\n#include \"../nrncvode/nrnneosm.h\"\n#include <nrnmpi.h>\n#include <errno.h>\n\nextern \"C\" {\n\tint nrn_isdouble(double*, double, double);\n\tint ivocmain(int, const char**, const char**);\n\textern int nrn_main_launch;\n\textern int nrn_noauto_dlopen_nrnmech;\n#if NRNMPI_DYNAMICLOAD\n\textern void nrnmpi_stubs();\n\textern char* nrnmpi_load(int is_python);\n#endif\n#if BLUEGENE_CHECKPOINT\n\tvoid BGLCheckpointInit(char* chkptDirPath);\n\t// note: get the path from the environment variable BGL_CHKPT_DIR_PATH\n\t// otherwise from $HOME/checkpoint, otherwise $HOME\n#endif\t\n}\n\nint main(int argc, char** argv, char** env) {\n\tnrn_isdouble(0,0,0);\n\tnrn_main_launch = 1;\n\n#if defined(AUTO_DLOPEN_NRNMECH) && AUTO_DLOPEN_NRNMECH == 0\n\tnrn_noauto_dlopen_nrnmech = 1;\n#endif\n\n#if 0\nprintf(\"argc=%d\\n\", argc);\nfor (int i=0; i < argc; ++i) {\nprintf(\"argv[%d]=|%s|\\n\", i, argv[i]);\n}\n#endif\n#if NRNMPI\n#if NRNMPI_DYNAMICLOAD\n\tnrnmpi_stubs();\n\tfor (int i=0; i < argc; ++i) {\n\t\tif (strcmp(\"-mpi\", argv[i]) == 0) {\n\t\t\tchar* pmes;\n\t\t\tpmes = nrnmpi_load(0);\n\t\t\tif (pmes) {\n\t\t\t\tprintf(\"%s\\n\", pmes);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\tnrnmpi_init(1, &argc, &argv); // may change argc and argv\n#endif\t\n#if BLUEGENE_CHECKPOINT\n\tBGLCheckpointInit((char*)0);\n#endif\n\terrno = 0;\n\treturn ivocmain(argc, (const char**)argv, (const char**)env);\n}\n\n#if USENCS\nextern \"C\" {\nvoid nrn2ncs_outputevent(int, double){}\n}\n#endif\n\n// moving following to src/oc/ockludge.c since on\n// Darwin Kernel Version 8.9.1 on apple i686 (and the newest config.guess\n// thinks it is a i386, but that is a different story)\n// including mpi.h gives some errors like:\n// /Users/hines/mpich2-1.0.5p4/instl/include/mpicxx.h:26:2: error: #error \n// SEEK_SET is #defined but must not be for the C++ binding of MPI\"\n\n#if 0 && NRNMPI && DARWIN\n// For DARWIN I do not really know the proper way to avoid\n// dyld: lazy symbol binding failed: Symbol not found: _MPI_Init\n// when the MPI functions are all used in the libnrnmpi.dylib\n// but the libmpi.a is statically linked. Therefore I am forcing\n// the linking here by listing all the MPI functions being used.\n#include <mpi.h>\nstatic void work_around() {\n\tMPI_Comm c = MPI_COMM_WORLD;\n\tMPI_Init(0, 0);\n\tMPI_Comm_rank(c, 0);\n\tMPI_Comm_size(c, 0);\n\tMPI_Wtime();\n\tMPI_Finalize();\n\tMPI_Unpack(0, 0, 0, 0, 0, 0, c);\n\tMPI_Pack(0, 0, 0, 0, 0, 0, c);\n\tMPI_Pack_size(0, 0, c, 0);\n\tMPI_Send(0,0,0,0,0,c);\n\tMPI_Probe(0, 0, c, 0);\n\tMPI_Get_count(0, 0, 0);\n\tMPI_Recv(0,0,0,0,0,c,0);\n\tMPI_Sendrecv(0,0,0,0,0,0,0,0,0,0,c,0);\n\tMPI_Iprobe(0,0,c,0,0);\n\tMPI_Get_address(0,0);\n\tMPI_Type_create_struct(0,0,0,0,0);\n\tMPI_Type_commit(0);\n\tMPI_Allgather(0,0,0,0,0,0,c);\n\tMPI_Allgatherv(0,0,0,0,0,0,0,c);\n\tMPI_Allreduce(0,0,0,0,0,c);\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/ivoc/ivocmain.cpp": "#include <../../nrnconf.h>\n#include <../nrnpython/nrnpython_config.h>\n\nextern \"C\" {\nlong hoc_nframe, hoc_nstack;\n}\n\n#if !HAVE_IV\n#define Session void\nextern \"C\" {\n\tint hoc_main1(int, const char**, const char**);\n\tvoid hoc_main1_init(const char*, const char**);\n}\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#if !defined (__APPLE__)\nextern char** environ;\n#else\n#include <crt_externs.h>\n#endif\n#endif\n\n#if HAVE_IV\n#ifdef WIN32\n#include <IV-Win/MWlib.h>\nvoid iv_display_scale(float);\n#endif\n\n#include <ivstream.h>\n#include <assert.h>\n#include \"ivoc.h\"\n#include \"idraw.h\"\n#include <InterViews/style.h>\n#endif\n#include <OS/string.h>\n#include \"string.h\"\n#include \"oc2iv.h\"\n#include \"nrnmpi.h\"\n#include \"nrnrt.h\"\n\n#if defined(IVX11_DYNAM)\n#include <IV-X11/ivx11_dynam.h>\n#endif\n\n#if defined(carbon)\n#undef MAC\n#endif\n\n#if MAC || defined(WIN32)\n#include \"njconf.h\"\n#else\n#include \"../nrnjava/njconf.h\"\n#endif\n\n#if 1\nextern \"C\" { void pr_profile(); }\n#define PR_PROFILE pr_profile();\n#else\n#define PR_PROFILE /**/\n#endif\n/*****************************************************************************/\n\n#if HAVE_IV\nstatic PropertyData properties[] = {\n{\"*gui\", \"sgimotif\"},\n{\"*PopupWindow*overlay\", \"true\"},\n{\"*PopupWindow*saveUnder\", \"on\"},\n{\"*TransientWindow*saveUnder\", \"on\"},\n{\"*background\", \"#ffffff\"},\n{\"*brush_width\", \"0\"},\n{\"*double_buffered\", \"on\"},\n{\"*flat\", \"#aaaaaa\"},\n#if defined(WIN32)|| defined(CYGWIN)\n{\"*font\", \"*Arial*bold*--12*\"},\n{\"*MenuBar*font\", \"*Arial*bold*--12*\"},\n{\"*MenuItem*font\", \"*Arial*bold*--12*\"},\n#endif\n{\"*foreground\", \"#000000\"},\n{\"*synchronous\", \"off\"},\n{\"*malloc_debug\", \"on\"},\n\n{\"*Scene_background\", \"#ffffff\"},\n{\"*Scene_foreground\", \"#000000\"},\n{\"*FieldEditor*background\", \"#ffffff\"},\n//{\"*background\", \"#cfffff\"},\n{\"*default_brush\", \"0\"},\n{\"*view_margin\", \".25\"},\n{\"*pwm_dismiss_button\", \"Iconify\"},\n{\"*dismiss_button\", \"Close\"},\n{\"*use_transient_windows\", \"yes\"},\n{\"*nrn_library\", \" $(NEURONHOME)/lib\"},\n{\"*view_pick_epsilon\", \"2\"},\n{\"*pwm_canvas_height\", \"120\"},\n{\"*pwm_paper_height\", \"11\"},\n{\"*pwm_paper_width\", \"8.5\"},\n{\"*pwm_paper_resolution\", \".5\"},\n{\"*pwm_pixel_resolution\", \"0\"},\n{\"*window_manager_offset_x\", \"5.\"},\n{\"*window_manager_offset_y\", \"26.\"},\n{\"*pwm_print_file_filter\", \"*.ps\"},\n{\"*pwm_idraw_file_filter\", \"*.id\"},\n{\"*pwm_ascii_file_filter\", \"*\"},\n{\"*pwm_save_file_filter\", \"*.ses\"},\n{\"*pwm_idraw_prologue\", \"$(NEURONHOME)/lib/prologue.id\"},\n{\"*pwm_postscript_filter\", \"sed 's;/Adobe-;/;'\"},\n{\"*SlowSlider*autorepeatStart\", \"0.\"},\n{\"*scene_print_border\", \"1\"},\n{\"*radioScale\", \".9\"},\n{\"*stepper_size\", \"20.\"},\n{\"*xvalue_field_size_increase\", \"10.\"},\n{\"*xvalue_format\", \"%.5g\"},\n{\"*graph_axis_default\", \"0\"},\n{\"*shape_scale_file\", \"$(NEURONHOME)/lib/shape.cm2\"},\n{\"*shape_quadedge\", \"0\"},\n{\"*CBWidget_ncolor\", \"10\"},\n{\"*CBWidget_nbrush\", \"10\"},\n{\"*units_on_flag\", \"on\"},\n{\"*NFRAME\", \"0\"}, // see src/oc/code.c for the default value\n{\"*NSTACK\", \"0\"}, // see src/oc/code.c for the default value\n{\"*Py_NoSiteFlag\", \"0\"}, \n{\"*python\", \"off\"},\n{\"*nopython\", \"off\"},\n{\"*err_dialog\", \"off\"},\n{\"*banner\", \"on\"},\n{\"*pyexe\", \"\"},\n\t { NULL }\n};\n\nstatic OptionDesc options[] = {\n{\"-dismissbutton\", \"*dismiss_button\", OptionValueImplicit, \"Close\"},\n{\"-extrapipeinput\", \"*extrapipeinput\", OptionValueNext},\n{\"-dll\", \"*nrnmechdll\", OptionValueNext},\n{\"-showwinio\", \"*showwinio\", OptionValueImplicit, \"on\"},\n{\"-hidewinio\", \"*showwinio\", OptionValueImplicit, \"off\"},\n{\"-isatty\", \"*isatty\", OptionValueImplicit, \"1\"},\n{\"-notatty\", \"*isatty\", OptionValueImplicit, \"-1\"},\n{\"-neosim\", \"*neosim\", OptionValueImplicit, \"on\"},\n{\"-bbs_nhost\", \"*bbs_nhost\", OptionValueNext},\n{\"-NSTACK\", \"*NSTACK\", OptionValueNext},\n{\"-NFRAME\", \"*NFRAME\", OptionValueNext},\n{\"--version\", \"*print_nrn_version\", OptionValueImplicit, \"on\"},\n{\"-python\", \"*python\", OptionValueImplicit, \"on\"},\n{\"-nopython\", \"*nopython\", OptionValueImplicit, \"on\"},\n{\"-pyexe\", \"*pyexe\", OptionValueNext},\n{\"-Py_NoSiteFlag\", \"*Py_NoSiteFlag\", OptionValueImplicit, \"1\"},\n{\"-nobanner\", \"*banner\", OptionValueImplicit, \"off\"},\n#if defined(WIN32)\n{\"-mswin_scale\", \"*mswin_scale\", OptionValueNext},\n#endif\n\t { NULL }\n};\n#endif // HAVE_IV\n\nextern \"C\" {\n\textern int hoc_obj_run(const char*, Object*);\n\textern int nrn_istty_;\n\textern char* nrn_version(int);\n\textern int nrn_nobanner_;\n\textern void hoc_final_exit();\n\tvoid ivoc_final_exit();\n#if (defined(NRNMECH_DLL_STYLE) || defined(WIN32))\n\textern const char* nrn_mech_dll;\n#endif\n#if defined(USE_PYTHON)\n\tint nrn_nopython;\n\textern int use_python_interpreter;\n\textern void (*p_nrnpython_start)(int);\n\tchar* nrnpy_pyexe;\n#endif\n}\n\n/*****************************************************************************/\n//exported initialized data so shared libraries can have assert pure-text\n#if HAVE_IV\nint Oc::refcnt_ = 0;\nSession* Oc::session_ = 0;\nHandleStdin* Oc::handleStdin_ = 0;\nostream* OcIdraw::idraw_stream = 0;\n#endif\n/*****************************************************************************/\nextern void ivoc_cleanup();\n#if OCSMALL\nstatic char* ocsmall_argv[] = {0, \"difus.hoc\"};\n#endif\n#if defined(WIN32) && HAVE_IV\nextern \"C\" {\nextern HWND hCurrWnd;\n}\n#endif\n\n\nextern \"C\" {\n\textern void setneuronhome(const char*);\n\textern const char* neuron_home;\n\tint hoc_xopen1(const char* filename, const char* rcs);\n\textern int units_on_flag_;\n\textern double hoc_default_dll_loaded_;\n\textern int hoc_print_first_instance;\n\tint nrnpy_nositeflag;\n}\n\n#if !defined(WIN32) && !MAC && !defined(CYGWIN)\nvoid setneuronhome(const char*) {\n\tneuron_home = getenv(\"NEURONHOME\");\n}\n#endif\n\n#if 0\nvoid penv() {\n\tint i;\n\tfor (i=0; environ[i]; ++i) {\n\t\tprintf(\"%p %s\\n\", environ[i], environ[i]);\n\t}\n}\n#endif\n\nextern \"C\" {\n#if DARWIN || defined(__linux__)\n#include <dlfcn.h>\n#include <string>\n\n/* It is definitely now the case on mac and I think sometimes the case on\nlinux that dlopen needs a full path to the file. A path to the binary\nis not necessarily sufficent as one may launch python or nrniv on the\ntarget machine and the lib folder cannot be derived from the location of\nthe python executable.This seems to be robust if nrn_version is inside a\nshared library.\nThe return value ends with a '/' and if the prefix cannot be determined\nthe return value is \"\".\n*/\nconst char* path_prefix_to_libnrniv() {\n  static char* path_prefix_to_libnrniv_ = NULL;\n  if (!path_prefix_to_libnrniv_) {\n    Dl_info info;\n    int rval = dladdr((void*)nrn_version, &info);\n    std::string name;\n    if (rval) {\n      if (info.dli_fname) {\n        name = info.dli_fname;\n        if (info.dli_fname[0] == '/') { // likely full path\n          size_t last_slash = name.rfind(\"/\");\n          path_prefix_to_libnrniv_ = strndup(name.c_str(), last_slash+1);\n          path_prefix_to_libnrniv_[last_slash+1] = '\\0';\n        }\n      }\n    }\n    if (!path_prefix_to_libnrniv_) {\n      path_prefix_to_libnrniv_ = strdup(\"\");\n    }\n  }\n  return path_prefix_to_libnrniv_;\n}\n#endif // DARWIN || defined(__linux__)\n} // extern \"C\"\n\n#if MAC\n#include <string.h>\n#include <sioux.h>\nextern bool mac_load_dll(const char*);\nextern \"C\" {\nvoid mac_open_doc(const char* s) {\n\t// only chdir and load dll on the first opendoc\n\tstatic bool done = false;\n\tchar cs[256];\n\tstrncpy(cs, s, 256);\n\tchar* cp  = strrchr(cs, ':');\n\tif (cp && !done) {\n\t\t*cp = '\\0';\n\t\t if (chdir(cs) == 0) {\n\t\t \tdone = true;\n\t\t\tprintf(\"current directory is \\\"%s\\\"\\n\", cs);\n\t\t\tif (mac_load_dll(\"nrnmac.dll\")) {\n\t\t\t\thoc_default_dll_loaded_ = 1.;\n\t\t\t}\n\t\t}\n\t}\t\t\n\thoc_xopen1(s, 0);\n}\nvoid mac_open_app(){\n\thoc_xopen1(\":lib:hoc:macload.hoc\", 0);\n}\n}\n#endif\n\n#ifdef MAC\n#pragma export on\n#endif\n\nextern \"C\" {\n        int ivocmain(int, const char**, const char**);\n        int ivocmain_session(int, const char**, const char**, int start_session);\n        int (*p_neosim_main)(int, const char**, const char**);\n\textern int nrn_global_argc;\n\textern const char** nrn_global_argv;\n\tint always_false;\n\textern int nrn_is_python_extension;\n\textern void hoc_nrnmpi_init();\n#if NRNMPI_DYNAMICLOAD\n        extern void nrnmpi_stubs();\n        extern char* nrnmpi_load(int is_python);\n#endif\n}\n\n// some things are defined in libraries earlier than they are used so...\n#include <nrnisaac.h>\nstatic void force_load() {\n\tif (always_false) {\n\t\tnrnisaac_new();\n\t}\n}\n\n#if defined(CYGWIN)\n// see iv/src/OS/directory.cpp\n#include <sys/stat.h>\nstatic bool isdir(const char* p) {\n\tstruct stat st;\n\tbool b =  stat((char*)p, &st) == 0 && S_ISDIR(st.st_mode);\n\t//printf(\"isdir %s returns %d\\n\", p, b);\n\treturn b;\n}\n#endif\n\n#ifdef MAC\n#pragma export off\n#endif\n\n// in case we are running without IV then get some important args this way\nstatic bool nrn_optarg_on(const char* opt, int* argc, char** argv);\nstatic char* nrn_optarg(const char* opt, int* argc, char** argv);\nstatic int nrn_optargint(const char* opt, int* argc, char** argv, int dflt);\n\nstatic bool nrn_optarg_on(const char* opt, int* pargc, const char** argv) {\n\tchar* a;\n\tint i;\n\tfor (i=0; i < *pargc; ++i) {\n\t\tif (strcmp(opt, argv[i]) == 0) {\n\t\t\t*pargc -= 1;\n\t\t\tfor (; i < *pargc; ++i) {\n\t\t\t\targv[i] = argv[i+1];\n\t\t\t}\n//\t\t\tprintf(\"nrn_optarg_on %s  return true\\n\", opt);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic const char* nrn_optarg(const char* opt, int* pargc, const char** argv) {\n\tconst char* a;\n\tint i;\n\tfor (i=0; i < *pargc - 1; ++i) {\n\t\tif (strcmp(opt, argv[i]) == 0) {\n\t\t\ta = argv[i+1];\n\t\t\t*pargc -= 2;\n\t\t\tfor (; i < *pargc; ++i) {\n\t\t\t\targv[i] = argv[i+2];\n\t\t\t}\n//\t\t\tprintf(\"nrn_optarg %s  return %s\\n\", opt, a);\n\t\t\treturn a;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int nrn_optargint(const char* opt, int* pargc, const char** argv, int dflt) {\n\tconst char* a;\n\tint i;\n\ti = dflt;\n\ta = nrn_optarg(opt, pargc, argv);\n\tif (a) {\n\t\tsscanf(a, \"%d\", &i);\n\t}\n//\tprintf(\"nrn_optargint %s return %d\\n\", opt, i);\n\treturn i;\n}\n\n#if USENRNJAVA\nvoid nrn_InitializeJavaVM();\t\n#endif\n\n#if 0 //for debugging\nvoid prargs(const char* s, int argc, const char** argv) {\n\tint i;\n\tprintf(\"%s argc=%d\\n\", s, argc);\n\tfor (i=0; i < argc; ++i) {\n\t\tprintf(\" %d |%s|\\n\", i, argv[i]);\n\t}\n}\n#endif\n\nvoid hoc_nrnmpi_init() {\n#if NRNMPI\n  if (!nrnmpi_use) {\n#if NRNMPI_DYNAMICLOAD\n    nrnmpi_stubs();\n    const char* pmes = nrnmpi_load(1);\n    if (pmes) {\n      printf(\"%s\\n\", pmes);\n    }\n#endif\n    \n    char** foo = (char**)nrn_global_argv;\n    nrnmpi_init(2, &nrn_global_argc, &foo);\n    //if (nrnmpi_myid == 0) {printf(\"hoc_nrnmpi_init called nrnmpi_init\\n\");}\n  }\n#endif\n  hoc_ret();\n  hoc_pushx(0.0);\n}\n\n/**\n * Main entrypoint function into the HOC interpeter\n *\n * This function simply calls ivocmain_session with the \\c start_session = 1.\n *\n * \\note This is part of NEURON's public interface\n *\n * \\note \\c env argument should not be used as it might become invalid\n *\n * \\param argc argument count as found in C/C++ \\c main functions\n * \\param argv argument vector as found in C/C++ \\c main functions\n * \\param env environment variable array as optionally found in main functions.\n * \\return 0 on success, otherwise error code.\n */\nint ivocmain (int argc, const char** argv, const char** env) {\n\n  return ivocmain_session(argc, argv, env, 1);\n\n}\n/**\n * This used to be ivocmain, the main entrypoint to the HOC interpreter\n *\n * ivocmain_session parses command line argument, calls of initialization\n * functions and drops into an interactive HOC session.\n * This function is called for example by the \"real main\" in \\c nrnmain.cpp ,\n * but can be also called from other external user applications that use\n * NEURON.\n * Additionally to the original implemenation a new parameter \\c start_session\n * was introduced to control whether an interactive HOC session shoudl be started\n * or simply NEURON and all data structures be initialized and control returned\n * to the caller.\n *\n * \\note \\c env argument should not be used as it might become invalid\n *\n * \\param argc argument count as found in C/C++ \\c main functions\n * \\param argv argument vector as found in C/C++ \\c main functions\n * \\param env environment variable array as optionally found in main functions.\n * \\param start_session set to 1 for default behavior (drop into interactive HOC session\n * otherwise set to 0. If set to 1, but compiled with python support this function will\n * still directly return (since in that mode we don't need an interactive HOC session\n * either.\n * \\return 0 on success, otherwise error code.\n */\nint ivocmain_session (int argc, const char** argv, const char** env, int start_session) {\n// third arg should not be used as it might become invalid\n// after putenv or setenv. Instead, if necessary use\n// #include <unistd.h>\n// extern char** environ;\n\tint i;\n//\tprargs(\"at beginning\", argc, argv);\n\tforce_load();\n\tnrn_global_argc = argc;\n\tnrn_global_argv = new const char*[argc];\n\tfor (i = 0; i < argc; ++i) {\n\t\tnrn_global_argv[i] = argv[i];\n\t}\n\tif (nrn_optarg_on(\"-help\", &argc, argv)\n\t    || nrn_optarg_on(\"-h\", &argc, argv)) {\n\t\tprintf(\"nrniv [options] [fileargs]\\n\\\n  options:\\n\\\n    -dll filename    dynamically load the linked mod files.\\n\\\n    -h               print this help message\\n\\\n    -help            print this help message\\n\\\n    -isatty          unbuffered stdout, print prompt when waiting for stdin\\n\\\n    -mpi             launched by mpirun or mpiexec, in parallel environment\\n\\\n    -mswin_scale float   scales gui on screen\\n\\\n    -music           launched as a process of the  MUlti SImulator Coordinator\\n\\\n    -NSTACK integer  size of stack (default 1000)\\n\\\n    -NFRAME integer  depth of function call nesting (default 200)\\n\\\n    -nobanner        do not print startup banner\\n\\\n    -nogui           do not send any gui info to screen\\n\\\n    -notatty         buffered stdout and no prompt\\n\\\n    -python          Python is the interpreter\\n\\\n    -pyexe path      Python to use if python (or python3 fallback) not right.\\n\\\n    -nopython        Do not initialize Python\\n\\\n    -Py_NoSiteFlag   Set Py_NoSiteFlag=1 before initializing Python\\n\\\n    -realtime        For hard real-time simulation for dynamic clamp\\n\\\n    --version        print version info\\n\\\n    and all InterViews and X11 options\\n\\\n  fileargs:          any number of following\\n\\\n    -                input from stdin til ^D (end of file)\\n\\\n    -c \\\"statement\\\"    execute next statement\\n\\\n    filename         execute contents of filename\\n\\\n\");\n\t\texit(0);\n\t}\n\tif (nrn_optarg_on(\"--version\", &argc, argv)) {\n\t\tprintf(\"%s\\n\", nrn_version(1));\n\t\texit(0);\n\t}\n\tif (nrn_optarg_on(\"-nobanner\", &argc, argv)) {\n\t\tnrn_nobanner_ = 1;\n\t}\n\tif (nrn_optarg_on(\"-Py_NoSiteFlag\", &argc, argv)) {\n\t\tnrnpy_nositeflag = 1;\n\t}\n\n\tnrnmpi_numprocs = nrn_optargint(\"-bbs_nhost\", &argc, argv, nrnmpi_numprocs);\n\thoc_usegui = 1;\n\tif (nrn_optarg_on(\"-nogui\", &argc, argv)) {\n\t\thoc_usegui = 0;\n\t\thoc_print_first_instance = 0;\n\t}\n\tif (nrnmpi_numprocs > 1) {\n\t\thoc_usegui = 0;\n\t\thoc_print_first_instance = 0;\n\t}\n#if NRNMPI\n\tif (nrnmpi_use) {\n\t\thoc_usegui = 0;\n\t\thoc_print_first_instance = 0;\n\t}\n#else\n\n// check if user is trying to use -mpi or -p4 when it was not\n// enabled at build time.  If so, issue a warning.\n\n\tint b;\n\tb = 0;\n\tfor (i=0; i < argc; ++i) {\n\t  if (strncmp(\"-p4\", (argv)[i], 3) == 0) {\n\t    b = 1;\n\t    break;\n\t  }\n\t  if (strcmp(\"-mpi\", (argv)[i]) == 0) {\n\t    b = 1;\n\t    break;\n\t  }\n\t}\n\tif (b) {\n\t  printf(\"Warning: detected user attempt to enable MPI, but MPI support was disabled at build time.\\n\");\n\t}\n\n#endif \t\t\n\n#if defined(IVX11_DYNAM)\n\tif (hoc_usegui && ivx11_dyload()) {\n\t\thoc_usegui = 0;\n\t\thoc_print_first_instance = 0;\n\t}\n#endif\n\n#if NRN_MUSIC\n\tnrn_optarg_on(\"-music\", &argc, argv);\n#else\n\tif (nrn_optarg_on(\"-music\", &argc, argv)) {\n\t  printf(\"Warning: attempt to enable MUSIC but MUSIC support was disabled at build time.\\n\");\n\t}\n#endif\n\n#if NRN_REALTIME\n\tif (nrn_optarg_on(\"-realtime\", &argc, argv)) {\n\t\tnrn_realtime_ = 1;\n\t\tnrn_setscheduler();\n\t}\n\tif (nrn_optarg_on(\"-schedfifo\", &argc, argv)) {\n\t\tif (nrn_realtime_ != 1) {\n\t\t\tnrn_setscheduler();\n\t\t}\n\t}\n\n#endif\n#if !HAVE_IV\n\thoc_usegui = 0;\n\thoc_print_first_instance = 0;\n#endif\n\tint our_argc = argc;\n\tconst char** our_argv = argv;\n\tint exit_status = 0;\n\tSession* session = NULL;\n#if !defined(WIN32)&&!defined(MAC) && !defined(CYGWIN)\n// Gary Holt's first pass at this was:\n//\n// Set the NEURONHOME environment variable.  This should override any setting\n// in the environment, so someone doesn't accidently use data files from an\n// old version of neuron.\n//\n// But I have decided to use the environment variable if it exists\n\tneuron_home = getenv(\"NEURONHOME\");\n\tif (!neuron_home) {\n#if defined(HAVE_PUTENV)\n\t\t// the only reason the following is static is to prevent valgrind\n\t\t// from complaining it is a memory leak.\n\t\tstatic char* buffer = new char[strlen(NEURON_DATA_DIR) + 12];\n\t\tsprintf(buffer, \"NEURONHOME=%s\", NEURON_DATA_DIR);\n\t\tputenv(buffer);\n\t\tneuron_home = NEURON_DATA_DIR;\n#elif defined(HAVE_SETENV)\n\t\tsetenv(\"NEURONHOME\", NEURON_DATA_DIR, 1);\n\t\tneuron_home = NEURON_DATA_DIR;\n#else\n#error \"I don't know how to set environment variables.\"\n// Maybe in this case the user will have to set it by hand.\n#endif\n\t\t// putenv and setenv may invalidate env but we no longer\n\t\t// use it so following should not be needed\n#if 0\n#if HAVE_UNISTD_H && !defined(__APPLE__)\n\tenv = environ;\n#endif\n#if defined (__APPLE__)\n\tenv = (*_NSGetEnviron());\n#endif\n#endif\n\t}\n\n#else // Not unix:\n\tneuron_home = getenv(\"NEURONHOME\");\n\tif (!neuron_home) {\n\t\tsetneuronhome((argc > 0)?argv[0]:0);\n\t}\n\tif (!neuron_home) {\n#if defined(WIN32) && HAVE_IV\n\t\tMessageBox(0, \"No NEURONHOME environment variable.\", \"NEURON Incomplete Installation\", MB_OK);\n#else\n\t\tneuron_home = \".\";\n\t\tfprintf(stderr, \"Warning: no NEURONHOME environment variable-- setting\\\n to %s\\n\", neuron_home);\n#endif\n\t}\n#endif // !unix.\n\n#if HAVE_IV\n#if OCSMALL\n\tour_argc = 2;\n\tour_argv = new char*[2];\n\tour_argv[0] = \"Neuron\";\n\tour_argv[1] = \":lib:hoc:macload.hoc\";\n\tsession = new Session(\"NEURON\", our_argc, our_argv, options, properties);\n#else\n#if MAC\n\tour_argc = 1;\n\tour_argv = new char*[1];\n\tour_argv[0] = \"Neuron\";\n\tsession = new Session(\"NEURON\", our_argc, our_argv, options, properties);\n\tSIOUXSettings.asktosaveonclose = false;\n#else\n#if defined(WIN32) || carbon\nIFGUI\n\tsession = new Session(\"NEURON\", our_argc, (char**)our_argv, options, properties);\nENDGUI\n#else\nIFGUI\n\tif (getenv(\"DISPLAY\")) {\n\t\tsession = new Session(\"NEURON\", our_argc, (char**)our_argv, options, properties);\n\t}else{\n\t\tfprintf(stderr, \"Warning: no DISPLAY environment variable.\\\n\\n--No graphics will be displayed.\\n\");\n\t\thoc_usegui = 0;\n\t}\nENDGUI\n#endif\n#endif\n\tchar* nrn_props;\n\tnrn_props = new char[strlen(neuron_home) + 20];\n\tif (session) {\n\t\tsprintf(nrn_props, \"%s/%s\", neuron_home, \"lib/nrn.defaults\");\n#ifdef WIN32\n\t\tFILE* f;\n\t\tif ((f = fopen(nrn_props, \"r\")) != (FILE*)0) {\n\t\t\tfclose(f);\n\t\t\tsession->style()->load_file(String(nrn_props), -5);\n\t\t}else{\n#if defined(CYGWIN)\n\t\t\tsprintf(nrn_props, \"%s/%s\", neuron_home, \"lib/nrn.def\");\n#else\n\t\t\tsprintf(nrn_props, \"%s\\\\%s\", neuron_home, \"lib\\\\nrn.def\");\n#endif\n\t\t\tif ((f = fopen(nrn_props, \"r\")) != (FILE*)0) {\n\t\t\t\tfclose(f);\n\t\t\t\tsession->style()->load_file(String(nrn_props), -5);\n\t\t\t}else{\n\t\t\t\tchar buf[256];\n\t\t\t\tsprintf(buf, \"Can't load NEURON resources from %s[aults]\",\n\t\t\t\t\tnrn_props);\n\t\t\t\tprintf(\"%s\\n\", buf);\n\t\t\t}\n\t\t}\n#else\n\t\t session->style()->load_file(String(nrn_props), -5);\n#endif\n#if ! MAC\n\t\tchar* h = getenv(\"HOME\");\n\t\tif (h) {\n\t\t    \tsprintf(nrn_props, \"%s/%s\", h, \".nrn.defaults\");\n\t\t    \tsession->style()->load_file(String(nrn_props), -5);\n\t\t}\n#endif\n\t}\n\tdelete [] nrn_props;\n\n#endif /*OCSMALL*/\n\n\tif (session) {\n\t\tsession->style()->find_attribute(\"NSTACK\", hoc_nstack);\n\t\tsession->style()->find_attribute(\"NFRAME\", hoc_nframe);\nIFGUI\n\t\tif (session->style()->value_is_on(\"err_dialog\")) {\n\t\t\tnrn_err_dialog_active_ = 1;\n\t\t}\nENDGUI\n\t}else\n#endif //HAVE_IV\n\t{\n\t\thoc_nstack = nrn_optargint(\"-NSTACK\", &our_argc, our_argv, 0);\n\t\thoc_nframe = nrn_optargint(\"-NFRAME\", &our_argc, our_argv, 0);\n\t}\n\n#if defined(USE_PYTHON)\n\tnrn_nopython = 0;\n\tif (!nrn_is_python_extension) {\n#if HAVE_IV\n\t\tif (session) {\n\t\t\tif (session->style()->value_is_on(\"nopython\")) {\n\t\t\t\tnrn_nopython = 1;\n\t\t\t}\n\t\t\tString str;\n\t\t\tif (session->style()->find_attribute(\"pyexe\", str)) {\n\t\t\t\tnrnpy_pyexe = strdup(str.string());\n\t\t\t}\n\t\t}else\n#endif\n\t\t{\n\t\t\tif (nrn_optarg_on(\"-nopython\", &our_argc, our_argv)) {\n\t\t\t\tnrn_nopython = 1;\n\t\t\t}\n\t\t\tconst char* buf = nrn_optarg(\"-pyexe\", &our_argc, our_argv);\n\t\t\tif (buf) {nrnpy_pyexe = strdup(buf);}\n\t\t}\n\t}\n#endif //USE_PYTHON\n\n#if defined(WIN32) && HAVE_IV\nIFGUI\n\tdouble scale = 1.;\n\tint pw = GetSystemMetrics(SM_CXVIRTUALSCREEN);\n\tif (pw < 1100) {\n\t\tscale = 1200./double(pw);\n\t}\n\tsession->style()->find_attribute(\"mswin_scale\", scale); \n\tiv_display_scale(float(scale));\nENDGUI\n#endif\n\n\t// just eliminate from arg list\n\tnrn_optarg_on(\"-mpi\", &our_argc, our_argv);\n\n#if (defined(NRNMECH_DLL_STYLE) || defined(WIN32))\n\tString str;\n#if HAVE_IV\n\tif (session) {\n\t\tif (session->style()->find_attribute(\"nrnmechdll\", str)) {\n\t\t\tnrn_mech_dll = str.string();\n\t\t}\n\t}else\n#endif\n\t{ // if running without IV.\n\t\tnrn_mech_dll = nrn_optarg(\"-dll\", &our_argc, our_argv);\n\t\t// may be duplicated since nrnbbs adds all args to special\n\t\t// which is often a script that adds a -dll arg\n\t\tnrn_optarg(\"-dll\", &our_argc, our_argv);\n\t}\n#if NRNMPI\n\tif (nrnmpi_use && !nrn_mech_dll) {\n\t\t// for heterogeneous clusters, mpirun allows different programs\n\t\t// but not different arguments. So the -dll is insufficient.\n\t\t// Therefore we check to see if it makes sense to load\n\t\t// a dll from the usual location.\n\t\t// Actually this is done by default in src/nrnoc/init.c\n\t}\n#endif\n\n#endif //NRNMECH_DLL_STYLE\n\n\n#if HAVE_IV\n\tif (session) {\n\t\tlong i;\n\t\tif (session->style()->find_attribute(\"isatty\", i)) {\n\t\t\tnrn_istty_ = i;\n\t\t}\t\t\n\t}else\n#endif\n\t{\n\t\tnrn_istty_ = nrn_optarg_on(\"-isatty\", &our_argc, our_argv);\n\t\tif (nrn_istty_ == 0) {\n\t\t\tnrn_istty_ = nrn_optarg_on(\"-notatty\", &our_argc, our_argv);\n\t\t\tif (nrn_istty_ == 1) { nrn_istty_ = -1; }\n\t\t}\n\t}\n\n#if HAVE_IV\n\tif (session && session->style()->value_is_on(\"units_on_flag\")) {\n\t\tunits_on_flag_ = 1;\n\t}\n        Oc oc(session, our_argv[0], env);\n#if defined(WIN32) && !defined(CYGWIN)\n\tif (session->style()->find_attribute(\"showwinio\", str)\n      && !session->style()->value_is_on(\"showwinio\")\n\t) {\n\t\tShowWindow(hCurrWnd, SW_HIDE);\n\t\thoc_obj_run(\"pwman_place(100,100)\\n\", 0);\n\t}\n#endif\n#else\n\thoc_main1_init(our_argv[0], env);\n#endif //HAVE_IV\n\n#if USENRNJAVA\n\tnrn_InitializeJavaVM();\t\n#endif\n#if OCSMALL\n\tif (argc == 1) {\n\t\tocsmall_argv[0] = our_argv[0];\n\t\toc.run(2, ocsmall_argv);\n\t}else\n#endif\n#if defined(USE_PYTHON)\n#if HAVE_IV\n\tif (session && session->style()->value_is_on(\"python\")) {\n\t\tuse_python_interpreter = 1;\n\t}\n#endif\n\tif (nrn_optarg_on(\"-python\", &our_argc, our_argv)) {\n\t\tuse_python_interpreter = 1;\n\t}\n\n\tif (nrn_is_python_extension) { return 0; }\n#if defined(CYGWIN) && defined(HAVE_SETENV)\n\tif (!isdir(\"/usr/lib/python2.5\")) {\n\t\tchar* buf = new char[strlen(neuron_home) + 20];\n\t\tsprintf(buf, \"%s/lib/%s\", neuron_home, \"python2.5\");\n\t\tif (isdir(buf)) {\n\t\t\tsetenv(\"PYTHONHOME\", neuron_home, 0);\n\t\t}\n\t\tdelete [] buf;\n\n\t}\n#endif\n\t//printf(\"p_nrnpython_start = %p\\n\", p_nrnpython_start);\n\tif (p_nrnpython_start) { (*p_nrnpython_start)(1); }\n\tif (use_python_interpreter && !p_nrnpython_start) {\n\t\tfprintf(stderr, \"Python not available\\n\");\n\t\texit(1);\n\t}\n#endif\n#if NRN_REALTIME\n\tnrn_maintask_init();\n#endif\n       if (start_session) {\n#if HAVE_IV\n        oc.run(our_argc, our_argv);\n#else\n\thoc_main1(our_argc, our_argv, env);\n#endif\n       } else {\n         return 0;\n       }\n#if HAVE_IV\n\tif (session && session->style()->value_is_on(\"neosim\")) {\n\t\tif (p_neosim_main) {\n\t\t\t(*p_neosim_main)(argc, argv, env);\n\t\t}else{\n\t\t\tprintf(\"neosim not available.\\nModify nrn/src/nrniv/Imakefile and remove nrniv/$CPU/netcvode.o\\n\");\n\t\t}\n\t}\n#endif\nPR_PROFILE\n#if defined(USE_PYTHON)\n\tif (use_python_interpreter) {\n\t\t// process the .py files and an interactive interpreter\n\t\tif (p_nrnpython_start) {(*p_nrnpython_start)(2);}\n\t}\n\tif (p_nrnpython_start) { (*p_nrnpython_start)(0); }\n#endif\n\thoc_final_exit();\n\tivoc_final_exit();\n\treturn exit_status;\n}\n\nvoid ivoc_final_exit() {\n#if NRNMPI\n\tnrnmpi_terminate();\n#endif\n#if NRN_REALTIME\n\tnrn_maintask_delete();\n#endif\n}\n\nextern \"C\" {\n\nextern void hoc_ret(), hoc_pushx(double);\nextern double *getarg(int i);\nextern int ifarg(int);\n\nvoid hoc_single_event_run() {\n#if HAVE_IV\nIFGUI\n\tvoid single_event_run();\n\t\n\tsingle_event_run();\nENDGUI\n#endif\n\thoc_ret();\n\thoc_pushx(1.);\n}\n\n#if !HAVE_IV\nint run_til_stdin() {return 1;}\nvoid hoc_notify_value(){}\n#endif\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/nrnmpi/nrnmpi_dynam.c": "#include <../../nrnconf.h>\n#include \"nrnmpiuse.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <assert.h>\n\n#if NRNMPI_DYNAMICLOAD /* to end of file */\n\n#ifdef MINGW\n#define RTLD_NOW 0\n#define RTLD_GLOBAL 0\n#define RTLD_NOLOAD 0\nextern void* dlopen_noerr(const char* name, int mode);\n#define dlopen dlopen_noerr\nextern void* dlsym(void* handle, const char* name);\nextern int dlclose(void* handle);\nextern char* dlerror();\n#else\n#include <dlfcn.h>\n#endif\n\n#include \"nrnmpi.h\"\n\nextern char* cxx_char_alloc(int);\n\n#if DARWIN || defined(__linux__)\nextern const char* path_prefix_to_libnrniv();\n#endif\n\n#include \"mpispike.h\"\n#include \"nrnmpi_def_cinc\" /* nrnmpi global variables */\n#include \"nrnmpi_dynam_cinc\" /* autogenerated file */\n#include \"nrnmpi_dynam_wrappers.inc\" /* autogenerated file */\n#include \"nrnmpi_dynam_stubs.c\"\n\nstatic void* load_mpi(const char* name, char* mes) {\n\tint flag = RTLD_NOW | RTLD_GLOBAL;\n\tvoid* handle = dlopen(name, flag);\n\tif (!handle) {\n\t\tsprintf(mes, \"load_mpi: %s\\n\", dlerror());\n\t}else{\n\t\tsprintf(mes, \"load_mpi: %s successful\\n\", name);\n\t}\n\treturn handle;\n}\n\nstatic void* load_nrnmpi(const char* name, char* mes) {\n\tint i;\n\tint flag = RTLD_NOW | RTLD_GLOBAL;\n\tvoid* handle = dlopen(name, flag);\n\tif (!handle) {\n\t\tsprintf(mes, \"load_nrnmpi: %s\\n\", dlerror());\n\t\treturn 0;\n\t}\t\n\tsprintf(mes, \"load_nrnmpi: %s successful\\n\", name);\n\tfor (i = 0; ftable[i].name; ++i) {\n\t\tvoid* p = dlsym(handle, ftable[i].name);\n\t\tif (!p) {\n\t\t\tsprintf(mes+strlen(mes), \"load_nrnmpi: %s\\n\", dlerror());\n\t\t\treturn 0;\n\t\t}\t\n\t\t*ftable[i].ppf = p;\n\t}\n\t{\n\t\tchar* (**p)(int) = (char* (**)(int))dlsym(handle, \"p_cxx_char_alloc\");\n\t\tif (!p) {\n\t\t\tsprintf(mes+strlen(mes), \"load_nrnmpi: %s\\n\", dlerror());\n\t\t\treturn 0;\n\t\t}\n\t\t*p = cxx_char_alloc;\n\t}\n\treturn handle;\n}\n\nchar* nrnmpi_load(int is_python) {\n\tint ismes=0;\n\tchar* pmes;\n\tvoid* handle = NULL;\n\tpmes = (char*)malloc(4096);\n\tassert(pmes);\n\tpmes[0]='\\0';\n#if DARWIN\n\tsprintf(pmes, \"Try loading libmpi\\n\");\n\thandle = load_mpi(\"libmpi.dylib\", pmes+strlen(pmes));\n    /**\n     * If libmpi.dylib is not in the standard location and dlopen fails\n     * then try to use user provided or ctypes.find_library() provided\n     * mpi library path.\n     */\n    if(!handle) {\n        const char* mpi_lib_path = getenv(\"MPI_LIB_NRN_PATH\");\n        if (mpi_lib_path) {\n            handle = load_mpi(mpi_lib_path, pmes+strlen(pmes));\n            if (!handle) {\n                sprintf(pmes, \"Can not load libmpi.dylib and %s\", mpi_lib_path);\n            }\n        }\n    }\n#if defined(NRNCMAKE)\n\tif (handle) {\n\t\t/* loaded but is it openmpi or mpich */\n\t\tif (dlsym(handle, \"ompi_mpi_init\")) { /* it is openmpi */\n\t\t/* see man dyld */\n\t\t\tif (!load_nrnmpi(\"@loader_path/libnrnmpi_ompi.dylib\", pmes+strlen(pmes))) {\n\t\t\t\treturn pmes;\n\t\t\t}\n\t\t}else{ /* must be mpich. Could check for MPID_nem_mpich_init...*/\n\t\t\tif (!load_nrnmpi(\"@loader_path/libnrnmpi_mpich.dylib\", pmes+strlen(pmes))) {\n\t\t\t\treturn pmes;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tismes = 1;\nsprintf(pmes+strlen(pmes), \"Is openmpi or mpich installed? If not in default location, \"\n                           \"need a LD_LIBRARY_PATH on Linux or DYLD_LIBRARY_PATH on Mac OS. \"\n                           \"On Mac OS, full path to a MPI library can be provided via \"\n                           \"environmental variable MPI_LIB_NRN_PATH\\n\");\n\t}\n#else /* autotools has only a libnrnmpi that is likely only for openmpi */\n\tif (handle) {\n\t\tif (!load_nrnmpi(\"@loader_path/libnrnmpi.dylib\", pmes+strlen(pmes))) {\n\t\t\treturn pmes;\n\t\t}\n\t}else{\n\t\tismes = 1;\nsprintf(pmes+strlen(pmes), \"Is openmpi installed? If not in default location, need a LD_LIBRARY_PATH.\\n\");\n\t}\n#endif /* not defined (NRNCMAKE) */\n#else /*not DARWIN*/\n#if defined(MINGW)\n\tsprintf(pmes, \"Try loading msmpi\\n\");\n\thandle = load_mpi(\"msmpi.dll\", pmes+strlen(pmes));\n\tif (handle) {\n#if defined(NRNCMAKE)\n\t\tif (!load_nrnmpi(\"libnrnmpi_msmpi.dll\", pmes+strlen(pmes))){\n#else\n\t\tif (!load_nrnmpi(\"libnrnmpi.dll\", pmes+strlen(pmes))){\n#endif\n\t\t\treturn pmes;\n\t\t}\n\t}else{\n\t\tismes = 1;\n\t\treturn pmes;\n\t}\n#else /*not MINGW so must be __linux__*/\n\n\t/**\n\t * libmpi.so is not standard but used by most of the implemenntation\n\t * (mpich, openmpi, intel-mpi, parastation-mpi, hpe-mpt) but not cray-mpich.\n\t * we first load libmpi and then libmpich.so as a fallaback for cray system.\n\t */\n\tsprintf(pmes, \"Try loading libmpi\\n\");\n\thandle = load_mpi(\"libmpi.so\", pmes+strlen(pmes));\n\tif (!handle) {\n\t    sprintf(pmes, \"Try loading libmpi and libmpich\\n\");\n\t    handle = load_mpi(\"libmpich.so\", pmes+strlen(pmes));\n\t}\n\n#if defined(NRNCMAKE)\n\tif (handle) {\n\t\t/* with CMAKE the problem of Python launch on LINUX not resolving\n\t\t   variables from already loaded shared libraries has returned.\n\t\t*/\n\t\tif (!dlopen(\"libnrniv.so\", RTLD_NOW | RTLD_NOLOAD | RTLD_GLOBAL)) {\n\t\t\tfprintf(stderr, \"Did not promote libnrniv.so to RTLD_GLOBAL: %s\\n\", dlerror());\n\t\t}\n\n\t\t/* safest to use full path for libnrnmpi... */\n\t\tconst char* prefix = path_prefix_to_libnrniv();\n\t\t/* enough space for prefix + \"libnrnmpi...\" */\n\t\tchar* lname = malloc(strlen(prefix) + 50);\n\t\tassert(lname);\n\t\t/* loaded but is it openmpi or mpich */\n\t\tif (dlsym(handle, \"ompi_mpi_init\")) { /* it is openmpi */\n\t\t\tsprintf(lname, \"%slibnrnmpi_ompi.so\", prefix);\n\t\t}else if (dlsym(handle, \"MPI_SGI_init\")) { /* it is sgi-mpt */\n\t\t\tsprintf(lname, \"%slibnrnmpi_mpt.so\", prefix);\n\t\t}else{ /* must be mpich. Could check for MPID_nem_mpich_init...*/\n\t\t\tsprintf(lname, \"%slibnrnmpi_mpich.so\", prefix);\n\t\t}\n\t\tif (!load_nrnmpi(lname, pmes+strlen(pmes))) {\n\t\t\tfree(lname);\n\t\t\treturn pmes;\n\t\t}\n\t\tfree(lname);\n\t}else{\n\t\tismes = 1;\nsprintf(pmes+strlen(pmes), \"Is openmpi, mpich, intel-mpi, sgi-mpt etc. installed? If not in default location, need a LD_LIBRARY_PATH.\\n\");\n\t}\n#else /* autotools */\n\tif (handle){\n\t\tif (!load_nrnmpi(NRN_LIBDIR\"/libnrnmpi.so\", pmes+strlen(pmes))){\n\t\t\treturn pmes;\n\t\t}\n\t}else{\n\t\tsprintf(pmes+strlen(pmes), \"Try loading mpich2\\n\");\n\t\thandle = load_mpi(\"libmpl.so\", pmes+strlen(pmes));\n\t\thandle = load_mpi(\"libmpich.so\", pmes+strlen(pmes));\n#if 0\n/* Not needed because the issue of Python launch on LINUX not resolving\n   variables from already loaded shared libraries (due to loading them with\n   RTLD_LOCAL) was solved at the src/nrnmpi/Makefile.am level via a change\n   to libnrnmpi_la_LIBADD\n*/\nif (!dlopen(\"liboc.so\", RTLD_NOW | RTLD_NOLOAD | RTLD_GLOBAL)) {\n\tfprintf(stderr, \"Did not promote liboc.so to RTLD_GLOBAL: %s\\n\", dlerror());\n}\nif (!dlopen(\"libnrniv.so\", RTLD_NOW | RTLD_NOLOAD | RTLD_GLOBAL)) {\n\tfprintf(stderr, \"Did not promote libnrniv.so to RTLD_GLOBAL: %s\\n\", dlerror());\n}\n#endif\n\t\tif(!load_nrnmpi(\"libnrnmpi.so\", pmes+strlen(pmes))){\n\t\t\treturn pmes;\n\t\t}\n\t}\n#endif /* not NRNCMAKE */\n#endif /*not MINGW*/\n#endif /* not DARWIN */\n\tif (!handle) {\n\t\tsprintf(pmes+strlen(pmes), \"could not dynamically load libmpi.so or libmpich.so\\n\");\n\t\treturn pmes;\n\t}\t\n\tfree(pmes);\n\treturn 0;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/m4/nrnbg.m4": "AC_DEFUN([AC_NRN_BLUEGENE],[\n\nAC_ARG_ENABLE([bluegene],\n\tAC_HELP_STRING([--enable-bluegene],[For BlueGene/L, supplies many extra configuration options]),[\n\tif test \"$enable_bluegene\" = \"yes\" ; then\n\t\twith_x=\"no\"\n\t\twith_memacs=\"no\"\n\t\tenable_shared=\"no\"\n\t\tenable_pysetup=\"no\"\n\t\twith_readline=\"no\"\n\t\tjava_dlopen=\"no\"\n\t\tlinux_nrnmech=\"no\"\n\t\tif test x$with_nmodl_only != xyes ; then\n\t\t\tnmodl_build=\"no\"\n\t\t\tif test \"$BGLSYS\" = \"\" ; then\n\t\t\t\tBGLSYS=/bgl/BlueLight/ppcfloor/bglsys\n\t\t\tfi\n\t\t\tif test \"$CC\" = \"\" ; then\n\t\t\t\tCC=blrts_xlc\n\t\t\tfi\n\t\t\tif test \"$CXX\" = \"\" ; then\n\t\t\t\tCXX=blrts_xlc++\n\t\t\tfi\n\t\t\tif test \"$MPICC\" = \"\" ; then\n\t\t\t\tMPICC=$CC\n\t\t\tfi\n\t\t\tif test \"$MPICXX\" = \"\" ; then\n\t\t\t\tMPICXX=$CXX\n\t\t\tfi\n\t\t\tif test \"$OPTFLAGS\" = \"\" ; then\n\t\t\t\tOPTFLAGS=\"-qarch=440d -qtune=440 -O3 -qstrict -qhot\"\n\t\t\tfi\n\t\t\tif test \"$CFLAGS\" = \"\" ; then\n\t\t\t\tCFLAGS=\"$OPTFLAGS -g -I$BGLSYS/include\"\n\t\t\tfi\n\t\t\tif test \"$CXXFLAGS\" = \"\" ; then\n\t\t\t\tCXXFLAGS=$CFLAGS\n\t\t\tfi\n\t\t\tif test \"$BGL_LIBS\" = \"\" ; then\n\t\t\t\tBGL_LIBS=\"-lmpich.rts -lmsglayer.rts -lrts.rts -ldevices.rts -ldevices.rts -L/opt/ibmcmp/xlmass/bg/4.3/blrts_lib -lmass\"\n\t\t\tfi\n\t\t\tif test \"$BG_CHECKPOINT\" = \"yes\" ; then\n                        \tNRN_DEFINE(BLUEGENE_CHECKPOINT,1,[enable the checkpointing on BlueGene hardware])\n                        \tBGL_LIBS = \"-lchkpt.rts $BGL_LIBS\"\n                \tfi\n\t\t\tif test \"$LIBS\" = \"\" ; then\n\t\t\t\tLIBS=\"-L$BGLSYS/lib $BGL_LIBS\"\n\t\t\tfi\n\t\t\tam_cv_CC_dependencies_compiler_type=xlc\n\t\t\tam_cv_CXX_dependencies_compiler_type=xlc\n\t\telse\n\t\t\tnmodl_build=\"yes\"\n\t\tfi\n\t\talways_call_mpi_init=yes\n\t\tif test \"$file_open_retry\" = \"\" ; then\n\t\t\tfile_open_retry=1\n\t\tfi\n\t\tNRN_DEFINE(BLUEGENE,1,[define if cross compiling for IBM BlueGene])\n\tfi\n])\n\nAC_ARG_ENABLE([bluegeneP],\n\tAC_HELP_STRING([--enable-bluegeneP],[For BlueGene/P, supplies many extra configuration options]),[\n\tif test \"$enable_bluegeneP\" = \"yes\" ; then\n\t\twith_x=\"no\"\n\t\twith_memacs=\"no\"\n\t\tenable_pysetup=\"no\"\n\t\tenable_shared=\"no\"\n\t\twith_readline=\"no\"\n\t\tjava_dlopen=\"no\"\n\t\tlinux_nrnmech=\"no\"\n\t\tif test x$with_nmodl_only != xyes ; then\n\t\t\tnmodl_build=\"no\"\n\t\t\tif test \"$BG_BASE\" = \"\" ; then\n\t\t\t\tBG_BASE=\"/bgsys/drivers/ppcfloor/\"\n\t\t\tfi\n\t\t\tif test \"$BG_INCLUDE\" = \"\" ; then\n\t\t\t\tBG_INCLUDE=\"-I$BG_BASE/comm/include -I$BG_BASE/arch/include\"\n\t\t\tfi\n\t\t\tif test \"$PYINCDIR\" = \"\" ; then\n\t\t\t\tPYINCDIR=\"$BG_BASE/gnu-linux/include/python2.6\"\n\t\t\tfi\n\t\t\tif test \"$PYLIB\" = \"\" ; then\n\t\t\t\tPYLIB=\"-L$BG_BASE/gnu-linux/lib -lpython2.6\"\n\t\t\t\tPYLIBDIR=\"$BG_BASE/gnu-linux/lib\"\n\t\t\t\tPYLIBLINK=\"-L$BG_BASE/gnu-linux/lib -lpython2.6\"\n\t\t\tfi\n\t\t\tif test \"$LIBS\" = \"\" ; then\n\t\t\t\tLIBS='-lmass'\n\t\t\tfi\n\t\t\tif test \"$LDFLAGS\" = \"\" ; then\n\t\t\t\tLDFLAGS='-qsmp -qnostaticlink'\n\t\t\tfi\n\t\t\tif test \"$with_multisend\" = \"\" ; then\n\t\t\t\twith_multisend=bgp\n\t\t\tfi\n\t\t\tif test \"$CC\" = \"\" ; then\n\t\t\t\tCC=mpixlc\n\t\t\tfi\n\t\t\tif test \"$CXX\" = \"\" ; then\n\t\t\t\tCXX=mpixlcxx\n\t\t\tfi\n\t\t\tif test \"$MPICC\" = \"\" ; then\n\t\t\t\tMPICC=$CC\n\t\t\tfi\n\t\t\tif test \"$MPICXX\" = \"\" ; then\n\t\t\t\tMPICXX=$CXX\n\t\t\tfi\n\t\t\tif test \"$OPTFLAGS\" = \"\" ; then\n\t\t\t\tOPTFLAGS=\"-O3 -qarch=450d\"\n\t\t\tfi\n\t\t\tif test \"$CFLAGS\" = \"\" ; then\n\t\t\t\tCFLAGS=\"$OPTFLAGS $BG_INCLUDE\"\n\t\t\tfi\n\t\t\tif test \"$CXXFLAGS\" = \"\" ; then\n\t\t\t\tCXXFLAGS=$CFLAGS\n\t\t\tfi\n\t\t\tif test \"$BG_CHECKPOINT\" = \"yes\" ; then\n                        \tNRN_DEFINE(BLUEGENE_CHECKPOINT,1,[enable the checkpointing on BlueGene hardware])\n                        \tBGL_LIBS = \"-lchkpt.rts $BGL_LIBS\"\n                \tfi\n\t\t\tif test \"$deptype\" = \"\" ; then\n\t\t\t\tam_cv_CC_dependencies_compiler_type=xlc\n\t\t\t\tam_cv_CXX_dependencies_compiler_type=xlc\n\t\t\tfi\n\t\telse\n\t\t\tnmodl_build=\"yes\"\n\t\tfi\n\t\talways_call_mpi_init=yes\n\t\tif test \"$file_open_retry\" = \"\" ; then\n\t\t\tfile_open_retry=1\n\t\tfi\n\t\tNRN_DEFINE(BLUEGENE,1,[define if cross compiling for IBM BlueGene L or P])\n\t\tNRN_DEFINE(BLUEGENEP,1,[define if cross compiling for IBM BlueGene/P])\n\tfi\n])\n\nAC_ARG_ENABLE([bgPlinux],\n\tAC_HELP_STRING([--enable-bgPlinux],[For BlueGene/P mpicc, supplies many extra configuration options]),[\n\tif test \"$enable_bgPlinux\" = \"yes\" ; then\n\t\twith_x=\"no\"\n\t\twith_memacs=\"no\"\n#\t\tenable_shared=\"no\"\n\t\tenable_pysetup=\"no\"\n\t\twith_readline=\"no\"\n\t\tjava_dlopen=\"no\"\n\t\tlinux_nrnmech=\"no\"\n\t\tif test x$with_nmodl_only != xyes ; then\n\t\t\tnmodl_build=\"no\"\n\t\t\tif test \"$BG_BASE\" = \"\" ; then\n\t\t\t\tBG_BASE=\"/bgsys/drivers/ppcfloor\"\n\t\t\tfi\n\t\t\tBG_INCLUDE=\"-I$BG_BASE/comm/include -I$BG_BASE/arch/include\"\n\t\t\tif test \"$PYINCDIR\" = \"\" ; then\n\t\t\t\tPYINCDIR=\"$BG_BASE/gnu-linux/include/python2.5\"\n\t\t\tfi\n\t\t\tif test \"$PYLIB\" = \"\" ; then\n\t\t\t\tPYLIB=\"-L$BG_BASE/gnu-linux/lib -lpython2.5\"\n\t\t\t\tPYLIBDIR=\"$BG_BASE/gnu-linux/lib\"\n\t\t\t\tPYLIBLINK=\"-L$BG_BASE/gnu-linux/lib -lpython2.5\"\n\t\t\tfi\n\t\t\tif test \"$with_multisend\" = \"\" ; then\n\t\t\t\twith_multisend=bgp\n\t\t\tfi\n\t\t\tif test \"$CC\" = \"\" ; then\n\t\t\t\tCC=mpicc\n\t\t\tfi\n\t\t\tif test \"$CXX\" = \"\" ; then\n\t\t\t\tCXX=mpicxx\n\t\t\tfi\n\t\t\tif test \"$MPICC\" = \"\" ; then\n\t\t\t\tMPICC=$CC\n\t\t\tfi\n\t\t\tif test \"$MPICXX\" = \"\" ; then\n\t\t\t\tMPICXX=$CXX\n\t\t\tfi\n\t\t\tif test \"$OPTFLAGS\" = \"\" ; then\n\t\t\t\tOPTFLAGS=\"-O3 -g\"\n\t\t\tfi\n\t\t\tif test \"$CFLAGS\" = \"\" ; then\n\t\t\t\tCFLAGS=\"$OPTFLAGS $BG_INCLUDE\"\n\t\t\tfi\n\t\t\tif test \"$CXXFLAGS\" = \"\" ; then\n\t\t\t\tCXXFLAGS=$CFLAGS\n\t\t\tfi\n\t\t\tif test \"$BG_CHECKPOINT\" = \"yes\" ; then\n                        \tNRN_DEFINE(BLUEGENE_CHECKPOINT,1,[enable the checkpointing on BlueGene hardware])\n                        \tBGL_LIBS = \"-lchkpt.rts $BGL_LIBS\"\n                \tfi\n#\t\t\tif test \"$LDFLAGS\" = \"\" ; then\n#\t\t\t\tLDFLAGS=\"-shared\"\n#\t\t\tfi\n\t\telse\n\t\t\tnmodl_build=\"yes\"\n\t\tfi\n\t\talways_call_mpi_init=yes\n\t\tif test \"$file_open_retry\" = \"\" ; then\n\t\t\tfile_open_retry=1\n\t\tfi\n\t\tNRN_DEFINE(BLUEGENE,1,[define if cross compiling for IBM BlueGene L or P])\n\t\tNRN_DEFINE(BLUEGENEP,1,[define if cross compiling for IBM BlueGene/P])\n\tfi\n])\n\nAC_ARG_ENABLE([bluegeneQ],\n        AC_HELP_STRING([--enable-bluegeneQ],[For BlueGene/Q, supplies many extra configuration options]),[\n        if test \"$enable_bluegeneQ\" = \"yes\" ; then\n                with_x=\"no\"\n                with_memacs=\"no\"\n                enable_shared=\"no\"                \n\t\tenable_pysetup=\"no\"\n                with_readline=\"no\"\n                java_dlopen=\"no\"\n                linux_nrnmech=\"no\"\n                if test x$with_nmodl_only != xyes ; then\n                        nmodl_build=\"no\"\n                        if test \"$BG_BASE\" = \"\" ; then\n                                BG_BASE=\"/bgsys/drivers/ppcfloor/\"\n                        fi\n                        if test \"$BG_INCLUDE\" = \"\" ; then\n                                BG_INCLUDE=\"-I$BG_BASE/comm/include -I$BG_BASE/arch/include\"\n                        fi\n\t\t\tPYBASE=$BG_BASE/tools/python/bldsrc-2.6.7/Python-2.6.7\n                        if test \"$PYINCDIR\" = \"\" ; then\n                                PYINCDIR=\"$PYBASE/Include -I$PYBASE\"\n                        fi\n                        if test \"$PYLIB\" = \"\" ; then\n\t\t\t\tPYLIB=\"-L$PYBASE -lpython2.6\"\n\t\t\t\tPYLIBDIR=\"$PYBASE\"\n\t\t\t\tPYLIBLINK=\"$PYLIB\"\n                        fi\n                        if test \"$LIBS\" = \"\" ; then\n                                LIBS='-lmass'\n                        fi\n                        if test \"$LDFLAGS\" = \"\" ; then\n                                LDFLAGS='-qsmp -qnostaticlink'\n                        fi\n                        if test \"$with_multisend\" = \"\" ; then\n                                with_multisend=yes\n                        fi\n                        if test \"$CC\" = \"\" ; then\n                                CC=mpixlc\n                        fi\n                        if test \"$CXX\" = \"\" ; then\n                                CXX=mpixlcxx\n                        fi\n                        if test \"$MPICC\" = \"\" ; then\n                                MPICC=$CC\n                        fi\n                        if test \"$MPICXX\" = \"\" ; then\n                                MPICXX=$CXX\n                        fi\n                        if test \"$OPTFLAGS\" = \"\" ; then\n                                OPTFLAGS=\"-O3 -qarch=qp -q64 -qstrict -qnohot\"\n                        fi\n                        if test \"$CFLAGS\" = \"\" ; then\n                                CFLAGS=\"$OPTFLAGS $BG_INCLUDE\"\n                        fi\n                        if test \"$CXXFLAGS\" = \"\" ; then\n                                CXXFLAGS=$CFLAGS\n                        fi\n                        if test \"$BG_CHECKPOINT\" = \"yes\" ; then\n                                NRN_DEFINE(BLUEGENE_CHECKPOINT,1,[enable the checkpointing on BlueGene hardware])\n                                BGL_LIBS = \"-lchkpt.rts $BGL_LIBS\"\n                        fi\n                        if test \"$deptype\" = \"\" ; then\n                                am_cv_CC_dependencies_compiler_type=xlc\n                                am_cv_CXX_dependencies_compiler_type=xlc\n                        fi\n                else\n                        nmodl_build=\"yes\"\n                fi\n                always_call_mpi_init=yes\n                if test \"$file_open_retry\" = \"\" ; then\n                        file_open_retry=1\n                fi\n                NRN_DEFINE(BLUEGENE,1,[define if cross compiling for IBM BlueGene L or P])\n                NRN_DEFINE(BLUEGENEQ,1,[define if cross compiling for IBM BlueGene/Q])\n        fi\n])\n\n]) dnl end of AC_NRN_BLUEGENE\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/m4/nrnjava.m4": "dnl --with-nrnjava is the default and means that libnrnjava.so will\ndnl be built so that neuron can be dlopened by java\n\nAC_DEFUN([AC_JVM2_CREATE], [\nAC_MSG_CHECKING([checking whether the java 2 virtual machine can be created])\nxLD_LIBRARY_PATH=${LD_LIBRARY_PATH}\nLD_LIBRARY_PATH=\"${LD_LIBRARY_PATH}:${JLIBDIR}:${JVMLIBDIR}\"\nexport LD_LIBRARY_PATH\nzzzCFLAGS=$CFLAGS\nzzzLIBS=$LIBS\nCFLAGS=\"$CFLAGS $JCFLAGS\"\nLIBS=\"$JLFLAGS $LIBS\"\nAC_TRY_RUN([\n#include <stdlib.h>\n#include <jni.h>\nint main() {\n\tjint res;\n\tvoid* jenv;\n\tJavaVM* jvm;\n\tJavaVMInitArgs args;\n\targs.version = JNI_VERSION_1_2;\n\targs.nOptions = 0;\n\targs.options = 0;\n\targs.ignoreUnrecognized = JNI_FALSE;\n\tres = JNI_CreateJavaVM(&jvm, &jenv, &args);\n\tprintf(\"JNI_CreateJavaVM returned %d\\n\", res);\n\tif (res < 0) {\n\t\texit(res);\n\t}else{\n\t\texit(0);\n\t}\n\treturn 0;\n}\n],[\necho \"The present configuration allows initialization of the java 2 virtual\"\necho \" machine to succeed.\"\njvmcreate=yes\n],[\necho \"The test program that tests initialization of the java 2 virtual machine,\"\necho \" failed. See config.log .\"\necho \"  It may be that linking requires some more -l libraries\"\necho \"  or extended LD_LIBRARY_PATH\"\necho \"  or perhaps the java vm is not JNI_VERSION_1_2.\"\njvmcreate=no\n],[\necho \"cross compiling not allowed.\"\nexit 1\n])\necho \"JCFLAGS=${JCFLAGS}\"\necho \"JLFLAGS=${JLFLAGS}\"\nCFLAGS=$zzzCFLAGS\nLIBS=$zzzLIBS\nLD_LIBRARY_PATH=${xLD_LIBRARY_PATH}\nexport LD_LIBRARY_PATH\n]) dnl end of AC_JVM2_CREATE\n\nAC_DEFUN([AC_JVM1_CREATE], [\nAC_MSG_CHECKING([checking whether the java 1 virtual machine can be created])\nxLD_LIBRARY_PATH=${LD_LIBRARY_PATH}\nLD_LIBRARY_PATH=\"${LD_LIBRARY_PATH}:${JLIBDIR}:${JVMLIBDIR}\"\nexport LD_LIBRARY_PATH\nzzzCFLAGS=$CFLAGS\nCFLAGS=\"$CFLAGS $JCFLAGS $JLFLAGS\"\nAC_TRY_RUN([\n#include <stdlib.h>\n#include <jni.h>\nint main() {\n\tjint res;\n\tvoid* jenv;\n\tJavaVM* jvm;\n\tJDK1_1InitArgs args;\n\targs.version = 0x00010001;\n\tJNI_GetDefaultJavaVMInitArgs(&args);\n\tres = JNI_CreateJavaVM(&jvm, &jenv, &args);\n\tprintf(\"JNI_CreateJavaVM returned %d\\n\", res);\n\tif (res < 0) {\n\t\texit(res);\n\t}else{\n\t\texit(0);\n\t}\n\treturn 0;\n}\n],[\necho \"The present configuration allows initialization of the java 1 virtual\"\necho \" machine to succeed.\"\njvmcreate=yes\n],[\necho \"The test program that tests initialization of the java 1 virtual machine,\"\necho \" failed. See config.log .\"\necho \"  It may be that linking requires some more -l libraries\"\necho \"  or extended LD_LIBRARY_PATH\"\necho \"  or perhaps the java vm is not 0x00010001.\"\njvmcreate=no\n],[\necho \"cross compiling not allowed.\"\nexit 1\n])\necho \"JCFLAGS=${JCFLAGS}\"\necho \"JLFLAGS=${JLFLAGS}\"\nCFLAGS=$zzzCFLAGS\nLD_LIBRARY_PATH=${xLD_LIBRARY_PATH}\nexport LD_LIBRARY_PATH\n]) dnl end of AC_JVM1_CREATE\n\nAC_DEFUN([AC_NRN_JAVA], [\n\nif test \"$with_nrnjava\" = \"\" ; then\n  with_nrnjava=no\t\t\t# Maybe someday it will be the default\nfi\n\ndnl however if neosim is requested then nrnjava is not optional\n\nif test \"$with_neosim\" = \"\" ; then\n  with_neosim=no\nfi\n\nAC_ARG_WITH([neosim],\nAC_HELP_STRING([--with-neosim],[Compile with USENEOSIM defined])\nAC_HELP_STRING([--without-neosim],[This is the default])\n,[\n\tif test \"[$with_neosim]\" = \"yes\" ; then\n\t\techo \"Allow use of neosim. This also forces with-nrnjava.\"\n\t\tNRN_DEFINE([USENEOSIM], 1, [define if want to use NEOSIM])\n\t\twith_nrnjava=yes\n\telse\n\t\techo \"Do not compile neosim specific code.\"\n\tfi\n])dnl\n\nAC_ARG_ENABLE([ncs],\nAC_HELP_STRING([--enable-ncs],[Compile with USENCS defined - Allows NCS to use NEURON])\nAC_HELP_STRING([--disable-ncs],[This is the default])\n,[\n\tif test \"$enable_ncs\" = \"yes\" ; then\n\t\tif test \"[$with_neosim]\" = \"yes\" ; then\nAC_MSG_ERROR([Cannot combine enable-ncs and with-neosim])\n\t\telse\n\t\t\techo \"Allow NCS to use NEURON.\"\nNRN_DEFINE([USENCS], 1, [define if want to be usable by NCS])\n\t\tfi\n\telse\n\t\techo \"Do not compile NCS specific code.\"\n\tfi\n])dnl\n\nAC_ARG_WITH(nrnjava,\nAC_HELP_STRING([--with-nrnjava],[Must explicitly use it if you want it.\n                             Enable the java interface. This builds\n                             libnrnjava.so and makes the NrnJava\n                             class available in hoc.])\nAC_HELP_STRING([--without-nrnjava],[No java interface. This is the default])\n,[\n\tif test \"$with_nrnjava\" = \"no\" ; then\n\t\tdnl take away with the left what has been given with the right\n\t\techo \"Not building the nrnjava interface\"\n\t\tbuild_nrnjava=no\n\telse\n\t\tbuild_nrnjava=yes\n\tfi\n])\n\nif test \"$build_nrnjava\" = \"yes\" ; then\n\techo \"Build the nrnjava interface\"\ndnl EXEEXT is used by java tests and that does not work if not using C\nAC_LANG_PUSH([C])\n\nif test \"$JAVAC\" = \"\" ; then\n\tJAVAC=javac\nfi\nif test \"$JAVA\" = \"\" ; then\n\tJAVA=java\nfi\nif test \"$JAVAH\" = \"\" ; then\n\tJAVAH=javah\nfi\n\nif test \"$JNI_INCLUDE_FLAGS\" = \"\" ; then\n\tAC_JNI_INCLUDE_DIR\n\tJNI_INCLUDE_DIR=\"\"\n\tfor JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS ; do\n\t\tJNI_INCLUDE_FLAGS=\"$JNI_INCLUDE_FLAGS -I$JNI_INCLUDE_DIR\"\n\tdone\n\tJDKDIR=\"$_JTOPDIR\"\nfi\n\necho \"JDKDIR=$JDKDIR\"\n\njvm_do_test=yes\nif test $host_os = cygwin ; then\n\tjvm_do_test=no\n\tNRN_DEFINE(USEJVM,2,[1 then version 0x00010001, 2 then JNI_VERSION_1_2])\n\tNRN_DEFINE(USENRNJAVA,1,[if 1 then NrnJava will be a class in hoc])\nfi\n\nif test \"$JVM_LIB_FLAGS\" = \"\" ; then\n\tcase \"$host_os\" in\n\t  darwin*)\n\t\tJVM_LIB_FLAGS=\"-framework JavaVM\"\n\t\tJVM_RPATH=\"\"\n\t\t;;\n\t  cygwin*)\n\t\tJVM_LIB_FLAGS=\"\"\n\t\tJVM_RPATH=\"\"\n\t\t;;\n\t  *)\n\t\tif test -z \"$JVMLIBDIR\" ; then\n\t\t\tif test -z \"$JDKDIR\" ; then\n\t\t\t\techo \"Cannot determine JVMLIBDIR without JDKDIR\"\n\t\t\t\texit 1\n\t\t\tfi\n\t\t\txjava=`find $JDKDIR/jre -name libjvm\\* -print|sed -n 1p`\n\t\t\techo \"Found a path to the libjvm\"\n\t\t\techo \"$xjava\"\n\t\t\txjava=`echo $xjava | sed -n 's;\\(.*\\)/libjvm.*;\\1;p'`\n\t\t\tJVMLIBDIR=$xjava\n\t\t\techo \"Determined JVMLIBDIR=$JVMLIBDIR\"\n\t\tfi\n\t\tJLIBDIR=`echo $JVMLIBDIR | sed 's;/[[^/]]*$;;'`\n\t\techo \"JLIBDIR=$JLIBDIR\"\n\t\tJVM_LIB_FLAGS=\"-L$JLIBDIR -L$JVMLIBDIR -ljvm -lpthread\"\n\t\tJVM_RPATH=\"-R $JLIBDIR -R $JVMLIBDIR\"\n\t\t;;\n\tesac\nfi\n\necho \"Using JNI_INCLUDE_FLAGS=\\\"${JNI_INCLUDE_FLAGS}\\\"\"\necho \"Using JVM_LIB_FLAGS=\\\"${JVM_LIB_FLAGS}\\\"\"\n\ndnl Test if the java virtual machine version 2 can be created\ndnl returns jvmcreate as yes or no\n\nif test $jvm_do_test = \"yes\" ; then\n\nJCFLAGS=\"$JNI_INCLUDE_FLAGS\"\nJLFLAGS=\"$JVM_LIB_FLAGS\"\nAC_JVM2_CREATE\nif test \"$jvmcreate\" = \"no\" ; then\n\tJCFLAGS=\"$JNI_INCLUDE_FLAGS\"\n\tJLFLAGS=\"$JVM_LIB_FLAGS\"\n\tAC_JVM1_CREATE\n\tif test \"$jvmcreate\" = \"no\" ; then\necho \"Assuming that the test failed because\"\necho \"JVMLIBS=\\\"${JVMLIBS}\\\"\"\necho \"is missing some paths and/or libraries\", look\necho \"for examples of machine and java specific values for JVMLIBS in\"\necho \"ftp://ftp.neuron.yale.edu/neuron/unix/jvmlibs\"\necho \"If you don't see yours in the list and you figure out the\"\necho \"correct value send it to me at michael.hines@yale.edu.\"\n\t\texit 1\n\telse\nNRN_DEFINE(USEJVM,1,[1 then version 0x00010001, 2 then JNI_VERSION_1_2])\nNRN_DEFINE(USENRNJAVA,1,[if 1 then NrnJava will be a class in hoc])\n\tfi\nelse\nNRN_DEFINE(USEJVM,2,[1 then version 0x00010001, 2 then JNI_VERSION_1_2])\nNRN_DEFINE(USENRNJAVA,1,[if 1 then NrnJava will be a class in hoc])\nfi\nfi\n\nif test \"$java_dlopen\" = \"yes\" ; then\n\tAC_MSG_NOTICE([Use the dlopen technique to load the jvm])\n\tNRN_DEFINE(JVM_DLOPEN,1,[if defined then try to dlopen the jvm])\n\tNRNJAVA_LIBS=\"-lnrnjava\"\n\tNRNJAVA_LIBLA=\"../nrnjava/libnrnjava.la\"\nelse\n\tNRNJAVA_LIBS=\"-lnrnjava $JLFLAGS $JVM_RPATH\"\n\tNRNJAVA_LIBLA=\"../nrnjava/libnrnjava.la $JLFLAGS $JVM_RPATH\"\nfi\nNRNJAVA_DEP=\"../nrnjava/libnrnjava.la\"\n\nAC_CHECK_CLASSPATH\nAC_PROG_JAVAC\nAC_PROG_JAVA\n\nAC_SUBST(JAVAH)\nAC_SUBST(JDKDIR)\nAC_SUBST(JNI_INCLUDE_FLAGS)\nAC_LANG_POP([])\nelse\n\tNRNJAVA_LIBS=\"\"\n\tNRNJAVA_LIBLA=\"\"\n\tNRNJAVA_DEP=\"\"\nfi\nAC_SUBST(NRNJAVA_LIBLA)\nAC_SUBST(NRNJAVA_LIBS)\nAC_SUBST(NRNJAVA_DEP)\n\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/__init__.py": "\"\"\"\n\nneuron\n======\n\nFor empirically-based simulations of neurons and networks of neurons in Python.\n\nThis is the top-level module of the official python interface to\nthe NEURON simulation environment (http://neuron.yale.edu/neuron/).\n\nDocumentation is available in the docstrings.\n\nFor a list of available names, try dir(neuron).\n\nExample:\n\n$ ipython\nIn [1]: import neuron\nNEURON -- VERSION 6.2 2008-08-22\nDuke, Yale, and the BlueBrain Project -- Copyright 1984-2007\nSee http://neuron.yale.edu/credits.html\n\n\nIn [2]: neuron.h ?\n\n\n\n\n\n\nImportant names and sub-packages\n---------------------\n\nFor help on these useful functions, see their docstrings:\n\n  neuron.init, run, psection, load_mechanisms\n\n\nneuron.h\n\n   The top-level Hoc interpreter.\n\n   Execute Hoc commands by calling h with a string argument:\n\n   >>> h('objref myobj')\n   >>> h('myobj = new Vector(10)')\n\n   All Hoc defined variables are accessible by attribute access to h.\n\n   Example:\n\n   >>> print h.myobj.x[9]\n\n   Hoc Classes are also defined, for example:\n\n   >>> v = h.Vector([1,2,3])\n   >>> soma = h.Section()\n\n   More help is available for the respective class by looking in the object docstring:\n\n   >>> help(h.Vector)\n\n\n\nneuron.gui\n\n   Import this package if you are using NEURON as an extension to Python,\n   and you would like to use the NEURON GUI.\n\n   If you are using NEURON with embedded python, \"nrniv -python\",\n   use rather \"nrngui -python\" if you would like to use the NEURON GUI.\n\n$Id: __init__.py,v 1.1 2008/05/26 11:39:44 hines Exp hines $\n\n\"\"\"\n\n## With Python launched under Linux, shared libraries are apparently imported\n## using RTLD_LOCAL. For --with-paranrn=dynamic, this caused a failure when\n## libnrnmpi.so is dynamically loaded because nrnmpi_myid (and other global\n## variables in src/nrnmpi/nrnmpi_def_cinc) were not resolved --- even though\n## all those variables are defined in src/oc/nrnmpi_dynam.c and that\n## does a dlopen(\"libnrnmpi.so\", RTLD_NOW | RTLD_GLOBAL) .\n## In this case setting the dlopenflags below fixes the problem. But it\n## seems that DLFCN is often not available.\n## This situation is conceptually puzzling because there\n## never seems to be a problem dynamically loading libnrnmech.so, though it\n## obviously makes use of many names in the rest of NEURON. Anyway,\n## we make the following available in case it is ever needed at least to\n## verify that some import problem is traceable to this issue.\n## The problem can be resolved in two ways. 1) see src/nrnmpi/nrnmpi_dynam.c\n## which promotes liboc.so and libnrniv.so to RTLD_GLOBAL  (commented out).\n## 2) The better way of specifying those libraries to libnrnmpi_la_LIBADD\n## in src/nrnmpi/Makefile.am . This latter also explains why libnrnmech.so\n## does not have this problem.\n#try:\n#  import sys\n#  import DLFCN\n#  sys.setdlopenflags(DLFCN.RTLD_NOW | DLFCN.RTLD_GLOBAL)\n#except:\n#  pass\n\nimport sys\nimport os\n\nembedded = True if 'hoc' in sys.modules else False\n\ntry: # needed since python 3.8 on windows if python launched\n  # do this here as NEURONHOME may be changed below\n  nrnbindir = os.path.abspath(os.environ[\"NEURONHOME\"] + \"/bin\")\n  os.add_dll_directory(nrnbindir)\nexcept:\n  pass\n\n# With pip we need to rewrite the NEURONHOME\nnrn_path = os.path.abspath(os.path.join(os.path.dirname(__file__), \".data/share/nrn\"))\nif (os.path.isdir(nrn_path)):\n  os.environ[\"NEURONHOME\"] = nrn_path\n\n# On OSX, dlopen might fail if not using full library path\ntry:\n  from sys import platform\n  if platform == \"darwin\":\n    from ctypes.util import find_library\n    mpi_library_path = find_library('mpi')\n    if mpi_library_path and 'MPI_LIB_NRN_PATH' not in os.environ:\n      os.environ[\"MPI_LIB_NRN_PATH\"] = mpi_library_path\nexcept:\n  pass\n\ntry:\n  import hoc\nexcept:\n  try:\n    #Python3.1 extending needs to look into the module explicitly\n    import neuron.hoc\n  except: # mingw autotools name strategy\n    exec(\"import neuron.hoc%d%d as hoc\" % (sys.version_info[0], sys.version_info[1]))\n\nimport nrn\nimport _neuron_section\nh  = hoc.HocObject()\nversion = h.nrnversion(5)\n__version__ = version\n_original_hoc_file = None\nif not hasattr(hoc, \"__file__\"):\n  # first try is to derive from neuron.__file__\n  origin = None # path to neuron/__init__.py\n  if sys.version_info[0] == 2:\n    # python 2 seems to have hoc.__file__ already filled in so never get here.\n    try:\n      import imp\n      mspec = imp.find_module(\"neuron\")\n      origin = mspec[1]\n    except:\n      pass\n  else:\n    from importlib import util\n    mspec = util.find_spec(\"neuron\")\n    if mspec:\n      origin = mspec.origin\n  if origin is not None:\n    import sysconfig\n    hoc_path = origin.rstrip(\"__init__.py\") + \"hoc\" + sysconfig.get_config_var('SO')\n    setattr(hoc, \"__file__\", hoc_path)\n  else:\n    # if the above is robust, maybe all this can be removed.\n    # next try is to derive from nrnversion(6) (only works for autotools build)\n    import platform\n    import os\n    p = h.nrnversion(6)\n    if \"--prefix=\" in p:\n      p = p[p.find('--prefix=') + 9:]\n      p = p[:p.find(\"'\")]\n    else:\n      p = \"/usr/local/nrn\"\n    if sys.version_info >= (3, 0):\n      import sysconfig\n      hoc_path = p + \"/lib/python/neuron/hoc%s\" % sysconfig.get_config_var('SO')\n    else:\n      hoc_path = p + \"/lib/python/neuron/hoc.so\"\n    if not os.path.isfile(hoc_path):\n      hoc_path = p + \"/%s/lib/libnrnpython%d.so\" % (platform.machine(), sys.version_info[0])\n    if not os.path.isfile(hoc_path):\n      hoc_path = p + \"/%s/lib/libnrnpython.so\" % platform.machine()\n    setattr(hoc, \"__file__\", hoc_path)\nelse:\n  _original_hoc_file = hoc.__file__\n# As a workaround to importing doc at neuron import time\n# (which leads to chicken and egg issues on some platforms)\n# define a dummy help function which imports doc,\n# calls the real help function, and reassigns neuron.help to doc.help\n# (thus replacing the dummy)\ndef help(request=None):\n    global help\n    from neuron import doc\n    doc.help(request)\n    help = doc.help\n\ntry:\n  import pydoc\n  pydoc.help = help\nexcept:\n  pass\n\n# Global test-suite function\n\ndef test(exitOnError=True):\n    \"\"\" Runs a global battery of unit tests on the neuron module.\"\"\"\n    import neuron.tests\n    import unittest\n\n    runner = unittest.TextTestRunner(verbosity=2)\n    result = runner.run(neuron.tests.suite()).wasSuccessful()\n    if exitOnError and result is False:\n        sys.exit(1)\n    return result\n\ndef test_rxd(exitOnError=True):\n    \"\"\" Runs a tests on the rxd and crxd modules.\"\"\"\n    import neuron.tests\n    import unittest\n\n    runner = unittest.TextTestRunner(verbosity=2)\n    result = runner.run(neuron.tests.test_rxd.suite()).wasSuccessful()\n    if exitOnError and result is False:\n        sys.exit(1)\n    return result\n\n\n# ------------------------------------------------------------------------------\n# class factory for subclassing h.anyclass\n# h.anyclass methods may be overridden. If so the base method can be called\n# using the idiom self.basemethod = self.baseattr('methodname')\n# ------------------------------------------------------------------------------\n\nif sys.version_info[0] == 2:\n  from neuron.hclass2 import hclass\nelse:\n  from neuron.hclass3 import hclass\n\n# global list of paths already loaded by load_mechanisms\nnrn_dll_loaded = []\n\ndef load_mechanisms(path, warn_if_already_loaded=True):\n    \"\"\"\n    load_mechanisms(path)\n\n    Search for and load NMODL mechanisms from the path given.\n\n    This function will not load a mechanism path twice.\n\n    The path should specify the directory in which nrnivmodl or mknrndll was run,\n    and in which the directory 'i686' (or 'x86_64' or 'powerpc' depending on your platform)\n    was created\"\"\"\n\n    import platform\n\n    global nrn_dll_loaded\n    if path in nrn_dll_loaded:\n        if warn_if_already_loaded:\n            print(\"Mechanisms already loaded from path: %s.  Aborting.\" % path)\n        return True\n\n    # in case NEURON is assuming a different architecture to Python,\n    # we try multiple possibilities\n\n    libname = 'libnrnmech.so'\n    libsubdir = '.libs'\n    arch_list = [platform.machine(), 'i686', 'x86_64', 'powerpc', 'umac']\n\n    # windows loads nrnmech.dll\n    if h.unix_mac_pc() == 3:\n        libname = 'nrnmech.dll'\n        libsubdir = ''\n        arch_list = ['']\n\n    for arch in arch_list:\n        lib_path = os.path.join(path, arch, libsubdir, libname)\n        if os.path.exists(lib_path):\n            h.nrn_load_dll(lib_path)\n            nrn_dll_loaded.append(path)\n            return True\n    print(\"NEURON mechanisms not found in %s.\" % path)\n    return False\n\nimport os,sys\nif 'NRN_NMODL_PATH' in os.environ:\n    nrn_nmodl_path = os.environ['NRN_NMODL_PATH'].split(':')\n    print('Auto-loading mechanisms:')\n    print('NRN_NMODL_PATH=%s' % os.environ['NRN_NMODL_PATH'])\n    for x in nrn_nmodl_path:\n        #print \"from path %s:\" % x\n        load_mechanisms(x)\n        #print \"\\n\"\n    print(\"Done.\\n\")\n\n\n\n# ------------------------------------------------------------------------------\n# Python classes and functions without a Hoc equivalent, mainly for internal\n# use within this file.\n# ------------------------------------------------------------------------------\n\nclass HocError(Exception): pass\n\nclass Wrapper(object):\n    \"\"\"Base class to provide attribute access for HocObjects.\"\"\"\n    def __getattr__(self, name):\n        if name == 'hoc_obj':\n            return self.__dict__['hoc_obj']\n        else:\n            try:\n                return self.__getattribute__(name)\n            except AttributeError:\n                return self.hoc_obj.__getattribute__(name)\n\n    def __setattr__(self, name, value):\n        try:\n            self.hoc_obj.__setattr__(name, value)\n        except LookupError:\n            object.__setattr__(self, name, value)\n\ndef new_point_process(name,doc=None):\n    \"\"\"\n    Returns a Python-wrapped hoc class where the object needs to be associated\n    with a section.\n\n    doc - specify a docstring for the new pointprocess class\n    \"\"\"\n    h('obfunc new_%s() { return new %s($1) }' % (name, name))\n    class someclass(Wrapper):\n        __doc__ = doc\n        def __init__(self, section, position=0.5):\n            assert 0 <= position <= 1\n            section.push()\n            self.__dict__['hoc_obj'] = getattr(h, 'new_%s' % name)(position) # have to put directly in __dict__ to avoid infinite recursion with __getattr__\n            h.pop_section()\n    someclass.__name__ = name\n    return someclass\n\ndef new_hoc_class(name,doc=None):\n    \"\"\"\n    Returns a Python-wrapped hoc class where the object does not need to be\n    associated with a section.\n\n    doc - specify a docstring for the new hoc class\n    \"\"\"\n    h('obfunc new_%s() { return new %s() }' % (name, name))\n    class someclass(Wrapper):\n        __doc__ = doc\n        def __init__(self, **kwargs):\n            self.__dict__['hoc_obj'] = getattr(h, 'new_%s' % name)()\n            for k,v in list(kwargs.items()):\n                setattr(self.hoc_obj, k, v)\n    someclass.__name__ = name\n    return someclass\n\n# ------------------------------------------------------------------------------\n# Python equivalents to Hoc functions\n# ------------------------------------------------------------------------------\n\nxopen = h.xopen\nquit = h.quit\n\ndef hoc_execute(hoc_commands, comment=None):\n    assert isinstance(hoc_commands,list)\n    if comment:\n        logging.debug(comment)\n    for cmd in hoc_commands:\n        logging.debug(cmd)\n        success = hoc.execute(cmd)\n        if not success:\n            raise HocError('Error produced by hoc command \"%s\"' % cmd)\n\ndef hoc_comment(comment):\n    logging.debug(comment)\n\ndef psection(section):\n    \"\"\"\n    function psection(section):\n\n    Print info about section in a hoc format which is executable.\n    (length, parent, diameter, membrane information)\n\n    Use section.psection() instead to get a data structure that\n    contains the same information and more.\n\n    See:\n\n    https://www.neuron.yale.edu/neuron/static/py_doc/modelspec/programmatic/topology.html?#psection\n\n    \"\"\"\n    h.psection(sec=section)\n\ndef init():\n    \"\"\"\n    function init():\n\n    Initialize the simulation kernel.  This should be called before a run(tstop) call.\n\n    ** This function exists for historical purposes. Use in new code is not recommended. **\n\n    Use h.finitialize() instead, which allows you to specify the membrane potential\n    to initialize to; via e.g. h.finitialize(-65)\n    \n    By default, the units used by h.finitialize are in mV, but you can be explicit using\n    NEURON's unit's library, e.g.\n    \n    .. code-block:: python\n    \n        from neuron.units import mV\n        h.finitialize(-65 * mV)\n\n    https://www.neuron.yale.edu/neuron/static/py_doc/simctrl/programmatic.html?#finitialize\n\n    \"\"\"\n    h.finitialize()\n\ndef run(tstop):\n    \"\"\"\n    function run(tstop)\n\n    Run the simulation (advance the solver) until tstop [ms]\n    \n    `h.run()` and `h.continuerun(tstop)` are more powerful solutions defined in the `stdrun.hoc` library.\n    \n    ** This function exists for historical purposes. Use in new code is not recommended. **\n    \n    For running a simulation, consider doing the following instead:\n    \n    Begin your code with\n    \n    .. code-block:: python\n    \n        from neuron import h\n        from neuron.units import ms, mV\n        h.load_file('stdrun.hoc')\n    \n    Then when it is time to initialize and run the simulation:\n    \n    .. code-block:: python\n    \n        h.finitialize(-65 * mV)\n        h.continuerun(100 * ms)\n    \n    where the initial membrane potential and the simulation run time are adjusted as appropriate\n    for your model.\n\n    \"\"\"\n    h('tstop = %g' % tstop)\n    h('while (t < tstop) { fadvance() }')\n    # what about pc.psolve(tstop)?\n\n_nrn_dll = None\n_nrn_hocobj_ptr = None\n_double_ptr = None\n_double_size = None\ndef numpy_element_ref(numpy_array, index):\n    \"\"\"Return a HOC reference into a numpy array.\n\n    Parameters\n    ----------\n    numpy_array : :class:`numpy.ndarray`\n        the numpy array\n    index : int\n        the index into the numpy array\n\n    .. warning::\n\n        No bounds checking.\n\n    .. warning::\n\n        Assumes a contiguous array of doubles. In particular, be careful when\n        using slices. If the array is multi-dimensional,\n        the user must figure out the integer index to the desired element.\n    \"\"\"\n    global _nrn_dll, _double_ptr, _double_size, _nrn_hocobj_ptr\n    import ctypes\n    if _nrn_hocobj_ptr is None:\n        _nrn_hocobj_ptr = nrn_dll_sym('nrn_hocobj_ptr')\n        _nrn_hocobj_ptr.restype = ctypes.py_object\n        _double_ptr = ctypes.POINTER(ctypes.c_double)\n        _double_size = ctypes.sizeof(ctypes.c_double)\n    void_p = ctypes.cast(numpy_array.ctypes.data_as(_double_ptr), ctypes.c_voidp).value + index * _double_size\n    return _nrn_hocobj_ptr(ctypes.cast(void_p, _double_ptr))\n\ndef nrn_dll_sym(name, type=None):\n    \"\"\"return the specified object from the NEURON dlls.\n\n    Parameters\n    ----------\n    name : string\n        the name of the object (function, integer, etc...)\n    type : None or ctypes type (e.g. ctypes.c_int)\n        the type of the object (if None, assumes function pointer)\n    \"\"\"\n    # TODO: this won't work under Windows; will need to search through until\n    #       can find the right dll (should we cache the results of the search?)\n    import os\n    if os.name == 'nt':\n      return nrn_dll_sym_nt(name, type)\n    dll = nrn_dll()\n    if type is None:\n        return dll.__getattr__(name)\n    else:\n        return type.in_dll(dll, name)\n\nnt_dlls = []\ndef nrn_dll_sym_nt(name, type):\n    \"\"\"return the specified object from the NEURON dlls.\n    helper for nrn_dll_sym(name, type). Try to find the name in either\n    nrniv.dll or libnrnpython1013.dll\n    \"\"\"\n    global nt_dlls\n    import ctypes\n    import os\n    if len(nt_dlls) == 0:\n      b = 'bin'\n      if h.nrnversion(8).find('i686') == 0:\n        b = 'bin'\n      path = os.path.join(h.neuronhome().replace('/','\\\\'), b)\n      p = sys.version_info[0]*10 + sys.version_info[1]\n      for dllname in ['libnrniv.dll', 'libnrnpython%d.dll'%p]:\n        p = os.path.join(path, dllname)\n        try:\n          nt_dlls.append(ctypes.cdll[p])\n        except:\n          pass\n    for dll in nt_dlls:\n      try:\n        a = dll.__getattr__(name)\n      except:\n        a = None\n      if a:\n        if type is None:\n          return a\n        else:\n          return type.in_dll(dll, name)\n    raise Exception('unable to connect to the NEURON library containing '+name)\n\ndef nrn_dll(printpath=False):\n    \"\"\"Return a ctypes object corresponding to the NEURON library.\n\n    .. warning::\n\n        This provides access to the C-language internals of NEURON and should\n        be used with care.\n    \"\"\"\n    import ctypes\n    import os\n    import platform\n    import glob\n\n    try:\n        #extended? if there is a __file__, then use that\n        if printpath: print (\"hoc.__file__ %s\" % _original_hoc_file)\n        the_dll = ctypes.cdll[_original_hoc_file]\n        return the_dll\n    except:\n        pass\n\n\n    success = False\n    if sys.platform == 'msys' or sys.platform == 'win32':\n      p = 'hoc%d%d' % (sys.version_info[0], sys.version_info[1])\n    else:\n      p = 'hoc'\n\n    try:\n        # maybe hoc.so in this neuron module\n        base_path = os.path.join(os.path.split(__file__)[0], p)\n        dlls = glob.glob(base_path + '*.*')\n        for dll in dlls:\n            try:\n                the_dll = ctypes.cdll[dll]\n                if printpath : print(dll)\n                return the_dll\n            except:\n                pass\n    except:\n        pass\n    # maybe old default module location\n    neuron_home = os.path.split(os.path.split(h.neuronhome())[0])[0]\n    base_path = os.path.join(neuron_home, 'lib' , 'python', 'neuron', p)\n    for extension in ['', '.dll', '.so', '.dylib']:\n        dlls = glob.glob(base_path + '*' + extension)\n        for dll in dlls:\n            try:\n                the_dll = ctypes.cdll[dll]\n                if printpath : print(dll)\n                success = True\n            except:\n                pass\n            if success: break\n        if success: break\n    else:\n        raise Exception('unable to connect to the NEURON library')\n    return the_dll\n\ndef _modelview_mechanism_docstrings(dmech, tree):\n  if dmech.name not in ('Ra', 'capacitance'):\n    docs = getattr(h, dmech.name).__doc__\n    if docs.strip():\n      for line in docs.split(\"\\n\"):\n        tree.append(line, dmech.location, 0)\n\n# TODO: put this someplace else\n#       can't be in rxd because that would break things if no scipy\n_sec_db = {}\ndef _declare_contour(secobj, secname):\n    j = secobj.first\n    center_vec = secobj.contourcenter(secobj.raw.getrow(0), secobj.raw.getrow(1), secobj.raw.getrow(2))\n    x0, y0, z0 = [center_vec.x[i] for i in range(3)]\n    # (is_stack, x, y, z, xcenter, ycenter, zcenter)\n    _sec_db[secname] = (True if secobj.contour_list else False, secobj.raw.getrow(0).c(j), secobj.raw.getrow(1).c(j), secobj.raw.getrow(2).c(j), x0, y0, z0)\n\ndef _create_all_list(obj):\n    # used by import3d\n    obj.all = []\n\ndef _create_sections_in_obj(obj, name, numsecs):\n    # used by import3d to instantiate inside of a Python object\n    setattr(obj, name, [h.Section(name=\"%s[%d]\" % (name, i), cell=obj) for i in range(int(numsecs))])\n\ndef _connect_sections_in_obj(obj, childsecname, childx, parentsecname, parentx):\n    # used by import3d\n    childarray, childi = _parse_import3d_name(childsecname)\n    parentarray, parenti = _parse_import3d_name(parentsecname)\n    getattr(obj, childarray)[childi].connect(getattr(obj, parentarray)[parenti](parentx), childx)\n\ndef _parse_import3d_name(name):\n    if '[' in name:\n        import re\n        array, i = re.search(r'(.*)\\[(\\d*)\\]', name).groups()\n        i = int(i)\n    else:\n        array = name\n        i = 0\n    return array, i\n\ndef _pt3dstyle_in_obj(obj, name, x, y, z):\n    # used by import3d\n    array, i = _parse_import3d_name(name)\n    h.pt3dstyle(1, x, y, z, sec=getattr(obj, array)[i])\n\ndef _pt3dadd_in_obj(obj, name, x, y, z, d):\n    array, i = _parse_import3d_name(name)\n    h.pt3dadd(x, y, z, d, sec=getattr(obj, array)[i])\n\n\ndef numpy_from_pointer(cpointer, size):\n    if sys.version_info.major < 3:\n        return numpy.frombuffer(numpy.core.multiarray.int_asbuffer(\n            ctypes.addressof(cpointer.contents),\n            size * numpy.dtype(float).itemsize))\n    else:\n        buf_from_mem = ctypes.pythonapi.PyMemoryView_FromMemory\n        buf_from_mem.restype = ctypes.py_object\n        buf_from_mem.argtypes = (ctypes.c_void_p, ctypes.c_int, ctypes.c_int)\n        cbuffer = buf_from_mem(\n            cpointer, size * numpy.dtype(float).itemsize, 0x200)\n        return numpy.ndarray((size,), numpy.float, cbuffer, order='C')\n\n\ntry:\n  import ctypes\n  import numpy\n  import traceback\n  vec_to_numpy_prototype = ctypes.CFUNCTYPE(ctypes.py_object, ctypes.c_int, ctypes.POINTER(ctypes.c_double))\n  def vec2numpy(size, data):\n    try:\n      return numpy_from_pointer(data, size)\n    except:\n      traceback.print_exc()\n      return None\n  vec_to_numpy_callback = vec_to_numpy_prototype(vec2numpy)\n  set_vec_as_numpy = nrn_dll_sym('nrnpy_set_vec_as_numpy')\n  set_vec_as_numpy(vec_to_numpy_callback)\nexcept:\n  pass\n\n\nclass _WrapperPlot:\n  def __init__(self, data):\n    '''do not call directly'''\n    self._data = data\n  def __repr__(self):\n    return '{}.plot()'.format(repr(self._data))\n\nclass _RangeVarPlot(_WrapperPlot):\n  \"\"\"Plots the current state of the RangeVarPlot on the graph.\n\n  Additional arguments and keyword arguments are passed to the graph's\n  plotting method.\n\n  Example, showing plotting to NEURON graphics, bokeh, matplotlib,\n  plotnine/ggplot, and plotly:\n\n  .. code::\n\n    from matplotlib import pyplot\n    from neuron import h, gui\n    import bokeh.plotting as b\n    import plotly\n    import plotly.graph_objects as go\n    import plotnine as p9\n    import math\n\n    dend = h.Section(name='dend')\n    dend.nseg = 55\n    dend.L = 6.28\n\n    # looping over dend.allseg instead of dend to set 0 and 1 ends\n    for seg in dend.allseg():\n        seg.v = math.sin(dend.L * seg.x)\n\n    r = h.RangeVarPlot('v', dend(0), dend(1))\n\n    # matplotlib\n    graph = pyplot.gca()\n    r.plot(graph, linewidth=10, color='r')\n\n    # NEURON Interviews graph\n    g = h.Graph()\n    r.plot(g, 2, 3)\n    g.exec_menu('View = plot')\n\n    # Bokeh\n    bg = b.Figure()\n    r.plot(bg, line_width=10)\n    b.show(bg)\n\n    # plotly\n    r.plot(plotly).show()\n\n    # also plotly\n    fig = go.Figure()\n    r.plot(fig)\n    fig.show()\n\n    pyplot.show()\n    \n    # plotnine/ggplot\n    p9.ggplot() + r.plot(p9)\n\n    # alternative plotnine/ggplot\n    r.plot(p9.ggplot())\n    \"\"\"\n\n  def __call__(self, graph, *args, **kwargs):\n      yvec = h.Vector()\n      xvec = h.Vector()\n      self._data.to_vector(yvec, xvec)\n      if isinstance(graph, hoc.HocObject):\n        return yvec.line(graph, xvec, *args)\n      str_type_graph = str(type(graph))\n      if str_type_graph == \"<class 'plotly.graph_objs._figure.Figure'>\":\n        # plotly figure\n        import plotly.graph_objects as go\n        kwargs.setdefault('mode', 'lines')\n        return graph.add_trace(go.Scatter(x=xvec, y=yvec, *args, **kwargs))\n      if str_type_graph == \"<class 'plotnine.ggplot.ggplot'>\":\n        # ggplot object\n        import plotnine as p9\n        import pandas as pd\n        return graph + p9.geom_line(*args, data=pd.DataFrame({'x': xvec, 'y': yvec}), mapping=p9.aes(x='x', y='y'), **kwargs)\n      str_graph = str(graph)\n      if str_graph.startswith(\"<module 'plotly' from \"):\n        # plotly module\n        import plotly.graph_objects as go\n        fig = go.Figure()\n        kwargs.setdefault('mode', 'lines')\n        return fig.add_trace(go.Scatter(x=xvec, y=yvec, *args, **kwargs))\n      if str_graph.startswith(\"<module 'plotnine' from \"):\n        # plotnine module (contains ggplot)\n        import plotnine as p9\n        import pandas as pd\n        return p9.geom_line(*args, data=pd.DataFrame({'x': xvec, 'y': yvec}), mapping=p9.aes(x='x', y='y'), **kwargs)\n      if hasattr(graph, 'plot'):\n        # works with e.g. pyplot or a matplotlib axis\n        return graph.plot(xvec, yvec, *args, **kwargs)\n      if hasattr(graph, 'line'):\n        # works with e.g. bokeh\n        return graph.line(xvec, yvec, *args, **kwargs)\n      if str_type_graph == \"<class 'matplotlib.figure.Figure'>\":\n        raise Exception('plot to a matplotlib axis not a matplotlib figure')\n      raise Exception('Unable to plot to graphs of type {}'.format(type(graph)))\n\n\nclass _PlotShapePlot(_WrapperPlot):\n  '''Plots the currently selected data on an object.\n\n  Currently only pyplot is supported, e.g.\n\n  from matplotlib import pyplot\n  ps = h.PlotShape(False)\n  ps.variable('v')\n  ps.plot(pyplot)\n  pyplot.show()\n\n  Limitations: many. Currently only supports plotting a full cell colored based on a variable.'''\n  # TODO: handle pointmark, specified sections, color\n  def __call__(self, graph, *args, **kwargs):\n    from neuron.gui2.utilities import _segment_3d_pts\n\n    def _get_pyplot_axis3d(fig):\n      '''requires matplotlib'''\n      from matplotlib.pyplot import cm\n      import matplotlib.pyplot as plt\n      from mpl_toolkits.mplot3d import Axes3D\n      import numpy as np\n\n      class Axis3DWithNEURON(Axes3D):\n          def auto_aspect(self):\n              \"\"\"sets the x, y, and z range symmetric around the center\n\n              Probably needs a square figure to preserve lengths as you rotate.\"\"\"\n              bounds = [self.get_xlim(), self.get_ylim(), self.get_zlim()]\n              half_delta_max = max([(item[1] - item[0]) / 2 for item in bounds])\n              xmid = sum(bounds[0]) / 2\n              ymid = sum(bounds[1]) / 2\n              zmid = sum(bounds[2]) / 2\n              self.auto_scale_xyz([xmid - half_delta_max, xmid + half_delta_max],\n                                  [ymid - half_delta_max, ymid + half_delta_max],\n                                  [zmid - half_delta_max, zmid + half_delta_max])\n\n          def mark(self, segment, marker='or', **kwargs):\n              \"\"\"plot a marker on a segment\n\n              Args:\n                  segment = the segment to mark\n                  marker = matplotlib marker\n                  **kwargs = passed to matplotlib's plot\n              \"\"\"\n              x, y, z = _get_3d_pt(segment)\n              self.plot([x], [y], [z], marker)\n              return self\n\n          def _do_plot(self, val_min, val_max,\n                      sections,\n                      variable,\n                      cmap=cm.cool,\n                      **kwargs):\n              \"\"\"\n              Plots a 3D shapeplot\n              Args:\n                  sections = list of h.Section() objects to be plotted\n                  **kwargs passes on to matplotlib (e.g. linewidth=2 for thick lines)\n              Returns:\n                  lines = list of line objects making up shapeplot\n              \"\"\"\n              # Adapted from\n              # https://github.com/ahwillia/PyNeuron-Toolbox/blob/master/PyNeuronToolbox/morphology.py\n              # Accessed 2019-04-11, which had an MIT license\n\n              # Default is to plot all sections.\n              if sections is None:\n                  sections = list(h.allsec())\n\n              h.define_shape()\n\n              # default color is black\n              kwargs.setdefault('color', 'black')\n\n              # Plot each segement as a line\n              lines = {}\n              lines_list = []\n              vals = []\n              for sec in sections:\n                  all_seg_pts = _segment_3d_pts(sec)\n                  for seg, (xs, ys, zs, _, _) in zip(sec, all_seg_pts):\n                      line, = self.plot(xs, ys, zs, '-', **kwargs)\n                      if variable is not None:\n                        val = _get_variable_seg(seg, variable)\n                        vals.append(val)\n                        if val is not None:\n                          lines[line] = '%s at %s' % (val, seg)\n                        else:\n                          lines[line] = str(seg)\n                      else:\n                        lines[line] = str(seg)\n                      lines_list.append(line)\n              if variable is not None:\n                  val_range = val_max - val_min\n                  if val_range:\n                      for sec in sections:\n                          for line, val in zip(lines_list, vals):\n                              if val is not None:\n                                col = _get_color(variable, val, cmap, val_min, val_max, val_range)\n                                line.set_color(col)\n              return lines\n      return Axis3DWithNEURON(fig)\n\n    def _get_variable_seg(seg, variable):\n      if isinstance(variable, str):\n        try:\n          if '.' in variable:\n              mech, var = variable.split('.')\n              val = getattr(getattr(seg, mech), var)\n          else:\n              val = getattr(seg, variable)\n        except AttributeError:\n          # leave default color if no variable found\n          val = None\n      else:\n        try:\n          vals = variable.nodes(seg).concentration\n          val = sum(vals) / len(vals)\n        except:\n          val = None\n\n      return val\n\n    def _get_3d_pt(segment):\n      import numpy as np\n      # TODO: there has to be a better way to do this\n      sec = segment.sec\n      n3d = sec.n3d()\n      arc3d = [sec.arc3d(i) for i in range(n3d)]\n      x3d = np.array([sec.x3d(i) for i in range(n3d)])\n      y3d = np.array([sec.y3d(i) for i in range(n3d)])\n      z3d = np.array([sec.z3d(i) for i in range(n3d)])\n      seg_l = sec.L * segment.x\n      x = np.interp(seg_l, arc3d, x3d)\n      y = np.interp(seg_l, arc3d, y3d)\n      z = np.interp(seg_l, arc3d, z3d)\n      return x, y, z\n\n    def _do_plot_on_matplotlib_figure(fig):\n      import ctypes\n      get_plotshape_data = nrn_dll_sym('get_plotshape_data')\n      get_plotshape_data.restype = ctypes.py_object\n      variable, varobj, lo, hi, secs = get_plotshape_data(ctypes.py_object(self._data))\n      if varobj is not None:\n        variable = varobj\n      kwargs.setdefault('picker', 2)\n      result = _get_pyplot_axis3d(fig)\n      _lines = result._do_plot(lo, hi, secs, variable, *args, **kwargs)\n      result._mouseover_text = ''\n      def _onpick(event):\n        if event.artist in _lines:\n          result._mouseover_text = _lines[event.artist]\n        else:\n          result._mouseover_text = ''\n        return True\n      result.auto_aspect()\n      fig.canvas.mpl_connect('pick_event', _onpick)\n      def format_coord(*args):\n        return result._mouseover_text\n      result.format_coord = format_coord\n      return result\n\n    def _get_color(variable, val, cmap, lo, hi, val_range):\n      if variable is None or val is None:\n        col = 'black'\n      elif val_range == 0:\n        if val < lo:\n          col = color_to_hex(cmap(0))\n        elif val > hi:\n          col = color_to_hex(cmap(255))\n        else:\n          val = color_to_hex(128)\n      else:\n        col = color_to_hex(cmap(int(255 * (min(max(val, lo), hi) - lo) / (val_range))))\n      return col\n\n    def color_to_hex(col):\n      items = [hex(int(255 * col_item))[2:] for col_item in col][:-1]\n      return '#' + ''.join([item if len(item) == 2 else '0' +item for item in items])\n\n\n    def _do_plot_on_plotly():\n      \"\"\"requires matplotlib for colormaps if not specified explicitly\"\"\"\n      import ctypes\n      import plotly.graph_objects as go\n\n      class FigureWidgetWithNEURON(go.FigureWidget):\n        def mark(self, segment, marker='or', **kwargs):\n            \"\"\"plot a marker on a segment\n\n            Args:\n                segment = the segment to mark\n                **kwargs = passed to go.Scatter3D plot\n            \"\"\"\n            x, y, z = _get_3d_pt(segment)\n            # approximately match the appearance of the matplotlib defaults\n            kwargs.setdefault('marker_size', 5)\n            kwargs.setdefault('marker_color', 'red')\n            kwargs.setdefault('marker_opacity', 1)\n\n            self.add_trace(\n              go.Scatter3d(\n                x=[x], y=[y], z=[z], name='', hovertemplate=str(segment), **kwargs\n              )\n            )\n            return self\n\n      get_plotshape_data = nrn_dll_sym('get_plotshape_data')\n      get_plotshape_data.restype = ctypes.py_object\n      variable, varobj, lo, hi, secs = get_plotshape_data(ctypes.py_object(self._data))\n      if varobj is not None:\n        variable = varobj\n      if secs is None:\n        secs = list(h.allsec())\n\n      \n      if variable is None:\n        kwargs.setdefault('color', 'black')\n        \n        data = []\n        for sec in secs:\n          xs = [sec.x3d(i) for i in range(sec.n3d())]\n          ys = [sec.y3d(i) for i in range(sec.n3d())]\n          zs = [sec.z3d(i) for i in range(sec.n3d())]\n          data.append(\n            go.Scatter3d(\n              x=xs,\n              y=ys,\n              z=zs,\n              name='',\n              hovertemplate=str(sec),\n              mode=\"lines\",\n              line=go.scatter3d.Line(\n                  color=kwargs['color'],\n                  width=2\n              ))\n          )\n        return FigureWidgetWithNEURON(data=data, layout={'showlegend': False})\n\n      else:\n        if 'cmap' not in kwargs:\n          # use same default colormap as the matplotlib version\n          from matplotlib.pyplot import cm\n          kwargs['cmap'] = cm.cool\n\n        cmap = kwargs['cmap']\n        show_diam = False\n\n        # calculate bounds\n\n        val_range = hi - lo\n\n        data = []\n        for sec in secs:\n          all_seg_pts = _segment_3d_pts(sec)\n          for seg, (xs, ys, zs, _, _) in zip(sec, all_seg_pts):\n            val = _get_variable_seg(seg, variable)\n            hover_template = str(seg)\n            if val is not None:\n              hover_template += '<br>' + ('%.3f' % val)\n            col = _get_color(variable, val, cmap, lo, hi, val_range)\n            if show_diam:\n              diam = seg.diam\n            else:\n              diam = 2\n            data.append(\n              go.Scatter3d(\n                x=xs,\n                y=ys,\n                z=zs,\n                name='',\n                hovertemplate=hover_template,\n                mode=\"lines\",\n                line=go.scatter3d.Line(\n                    color=col,\n                    width=diam\n                ))\n            )\n\n        return FigureWidgetWithNEURON(data=data, layout={'showlegend': False})\n\n    if hasattr(graph, '__name__'):\n      if graph.__name__ == 'matplotlib.pyplot':\n        fig = graph.figure()\n        return _do_plot_on_matplotlib_figure(fig)\n      elif graph.__name__ == 'plotly':\n        return _do_plot_on_plotly()\n    elif str(type(graph)) == \"<class 'matplotlib.figure.Figure'>\":\n      return _do_plot_on_matplotlib_figure(graph)\n    raise NotImplementedError\n\ndef _nmodl():\n  try:\n    import nmodl.dsl as nmodl\n    return nmodl\n  except ModuleNotFoundError:\n    raise Exception(\"Missing nmodl module; install from https://github.com/bluebrain/nmodl\")\n\nclass DensityMechanism:\n  def __init__(self, name):\n    \"\"\"Initialize the DensityMechanism.\n\n    Takes the name of a range mechanism; call via e.g. neuron.DensityMechanism('hh')\n    \"\"\"\n    self.__name = name\n    self.__mt = h.MechanismType(0)\n    self.__mt.select(-1)\n    self.__mt.select(name)\n    if self.__mt.selected() == -1:\n      raise Exception(\"No DensityMechanism: \" + name)\n    self.__has_nmodl = False\n    self.__ast = None\n    self.__ions = None\n    try:\n      import nmodl\n      self.__has_nmodl = True\n    except ModuleNotFoundError:\n      pass\n\n  def __repr__(self):\n    return 'neuron.DensityMechanism(%r)' % self.__name\n\n  def __dir__(self):\n    my_dir = ['code', 'file', 'insert', 'uninsert', '__repr__', '__str__']\n    if self.__has_nmodl:\n      my_dir += ['ast', 'ions', 'ontology_ids']\n    return sorted(my_dir)\n\n  @property\n  def ast(self):\n    \"\"\"Abstract Syntax Tree representation.\n\n    Requires the nmodl module, available from: https://github.com/bluebrain/nmodl\n\n    The model is parsed on first access, and the results are cached for quick reaccess\n    using the same neuron.DensityMechanism instance.\n    \"\"\"\n    if self.__ast is None:\n      nmodl = _nmodl()\n      driver = nmodl.NmodlDriver()\n      self.__ast = driver.parse_string(self.code)\n    return self.__ast\n\n  @property\n  def code(self):\n    \"\"\"source code\"\"\"\n    return self.__mt.code()\n\n  @property\n  def file(self):\n    \"\"\"source file path\"\"\"\n    return self.__mt.file()\n\n  def insert(self, secs):\n    \"\"\"insert this mechanism into a section or iterable of sections\"\"\"\n    if isinstance(secs, nrn.Section):\n      secs = [secs]\n    for sec in secs:\n      sec.insert(self.__name)\n\n  def uninsert(self, secs):\n    \"\"\"uninsert (remove) this mechanism from a section or iterable of sections\"\"\"\n    if isinstance(secs, nrn.Section):\n      secs = [secs]\n    for sec in secs:\n      sec.uninsert(self.__name)\n\n  @property\n  def ions(self):\n    \"\"\"Dictionary of the ions involved in this mechanism\"\"\"\n    if self.__ions is None:\n      nmodl = _nmodl()\n      lookup_visitor = nmodl.visitor.AstLookupVisitor()\n      ions = lookup_visitor.lookup(self.ast, nmodl.ast.AstNodeType.USEION)\n      result = {}\n      for ion in ions:\n        name = nmodl.to_nmodl(ion.name)\n        read = [nmodl.to_nmodl(item) for item in ion.readlist]\n        write = [nmodl.to_nmodl(item) for item in ion.writelist]\n        if ion.valence:\n          valence = int(nmodl.to_nmodl(ion.valence.value))\n        else:\n          valence = None\n        ontology_id = None\n        try:\n          ontology_id = ion.ontology_id\n        except:\n          # older versions of the NMODL library didn't support .ontology_id\n          pass\n        result[name] = {'read': read, 'write': write, 'charge': valence, 'ontology_id': nmodl.to_nmodl(ontology_id)}\n      self.__ions = result\n    # return a copy\n    return dict(self.__ions)\n\n  @property\n  def ontology_ids(self):\n    nmodl = _nmodl()\n    lookup_visitor = nmodl.visitor.AstLookupVisitor()\n\n    try:\n      onts = lookup_visitor.lookup(self.ast, nmodl.ast.AstNodeType.ONTOLOGY_STATEMENT)\n    except AttributeError:\n      raise Exception(\"nmodl module out of date; missing support for ontology declarations\")\n\n    return [nmodl.to_nmodl(ont.ontology_id) for ont in onts]\n\n\ntry:\n  import ctypes\n  def _rvp_plot(rvp):\n    return _RangeVarPlot(rvp)\n\n  def _plotshape_plot(ps):\n    h.define_shape()\n    return _PlotShapePlot(ps)\n\n  _mech_classes = {}\n\n  def _get_mech_object(name):\n    if name in _mech_classes:\n      my_class = _mech_classes[name]\n    else:\n      code = DensityMechanism(name).code\n      # docstring is the title and a leading comment, if any\n      inside_comment = False\n      title = ''\n      comment = []\n      for line in code.split('\\n'):\n        line_s = line.strip()\n        lower = line_s.lower()\n        if inside_comment:\n          if lower.startswith('endcomment'):\n            break\n          comment.append(line)\n        elif lower.startswith('title '):\n          title = line_s[6:]\n        elif lower.startswith('comment'):\n          inside_comment = True\n        elif line_s:\n          break\n\n      docstring = title + '\\n\\n'\n\n      docstring += '\\n'.join(comment)\n      docstring = docstring.strip()\n\n      clsdict = {'__doc__': docstring, 'title': title}\n      my_class = type(name, (DensityMechanism,), clsdict)\n      _mech_classes[name] = my_class\n    return my_class(name)\n\n\n  set_toplevel_callbacks = nrn_dll_sym('nrnpy_set_toplevel_callbacks')\n  _rvp_plot_callback = ctypes.py_object(_rvp_plot)\n  _plotshape_plot_callback = ctypes.py_object(_plotshape_plot)\n  _get_mech_object_callback = ctypes.py_object(_get_mech_object)\n  set_toplevel_callbacks(_rvp_plot_callback, _plotshape_plot_callback, _get_mech_object_callback)\nexcept:\n  pass\n\ndef _has_scipy():\n    \"\"\"\n    to check for scipy:\n\n    has_scipy = 0\n    objref p\n    if (nrnpython(\"import neuron\")) {\n        p = new PythonObject()\n        has_scipy = p.neuron._has_scipy()\n    }\n    \"\"\"\n    try:\n        import scipy\n    except:\n        return 0\n    return 1\n\n\ndef _pkl(arg):\n  #print 'neuron._pkl arg is ', arg\n  return h.Vector(0)\n\ndef nrnpy_pass():\n  return 1\n\ndef nrnpy_pr(stdoe, s):\n  if stdoe == 1:\n    sys.stdout.write(s.decode())\n  else:\n    sys.stderr.write(s.decode())\n  return 0\n\nif not embedded:\n  try:\n    # nrnpy_pr callback in place of hoc printf\n    # ensures consistent with python stdout even with jupyter notebook.\n    # nrnpy_pass callback used by h.doNotify() in MINGW when not called from\n    # gui thread in order to allow the gui thread to run.\n\n    nrnpy_set_pr_etal = nrn_dll_sym('nrnpy_set_pr_etal')\n\n    nrnpy_pr_proto = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_char_p)\n    nrnpy_pass_proto = ctypes.CFUNCTYPE(ctypes.c_int)\n    nrnpy_set_pr_etal.argtypes = [nrnpy_pr_proto, nrnpy_pass_proto]\n\n    nrnpy_pr_callback = nrnpy_pr_proto(nrnpy_pr)\n    nrnpy_pass_callback = nrnpy_pass_proto(nrnpy_pass)\n    nrnpy_set_pr_etal(nrnpy_pr_callback, nrnpy_pass_callback)\n  except:\n    print(\"Failed to setup nrnpy_pr\")\n    pass\n\n\ndef nrnpy_vec_math(op, flag, arg1, arg2=None):\n  import numbers\n  valid_types = (numbers.Number, hoc.HocObject)\n  if isinstance(arg1, valid_types):\n    if flag == 2:\n      # unary\n      arg1 = arg1.c()\n      if op == 'uneg':\n        return arg1.mul(-1)\n      if op == 'upos':\n        return arg1\n      if op == 'uabs':\n        return arg1.abs()\n    elif isinstance(arg2, valid_types):\n      if flag == 1:\n        # either reversed (flag=1) or unary (flag=2)\n        arg2 = arg2.c()\n        if op in ('mul', 'add'):\n          return getattr(arg2, op)(arg1)\n        if op == 'div':\n          return arg2.pow(-1).mul(arg1)\n        if op == 'sub':\n          return arg2.mul(-1).add(arg1)\n      else:\n        arg1 = arg1.c()\n        return getattr(arg1, op)(arg2)\n\n  return NotImplemented\n\ntry:\n  nrnpy_vec_math_register = nrn_dll_sym('nrnpy_vec_math_register')\n  nrnpy_vec_math_register(ctypes.py_object(nrnpy_vec_math))\nexcept:\n  print(\"Failed to setup nrnpy_vec_math\")\n\ntry:\n  from neuron.psection import psection\n  nrn.set_psection(psection)\nexcept:\n  print(\"Failed to setup nrn.Section.psection\")\npass\n\nimport atexit as _atexit\n@_atexit.register\ndef clear_gui_callback():\n  try:\n    nrnpy_set_gui_callback = nrn_dll_sym('nrnpy_set_gui_callback')\n    nrnpy_set_gui_callback(None)\n  except:\n    pass\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/coreneuron/mechanism/mech/enginemech.cpp": "/**\n * \\file\n * \\brief Provides interface function for CoreNEURON mechanism library and NEURON\n *\n * libcorenrnmech is a interface library provided to building standalone executable\n * special-core. Also, it is used by NEURON to run CoreNEURON via dlopen to execute\n * models via in-memory transfer.\n */\n\n#include <cstdlib>\n#include <coreneuron/engine.h>\n\nnamespace coreneuron {\n\n/** Mechanism registration function\n *\n * If external mechanisms present then use modl_reg function generated\n * in mod_func.cpp otherwise use empty one.\n */\n#ifdef ADDITIONAL_MECHS\nextern void modl_reg();\n#else\nvoid modl_reg() {\n}\n#endif\n\n/// variables defined in coreneuron library\nextern bool nrn_have_gaps;\nextern bool nrn_use_fast_imem;\n\n}  // namespace coreneuron\n\n/** Initialize mechanisms and run simulation using CoreNEURON\n *\n * This is mainly used to build nrniv-core executable\n */\nint solve_core(int argc, char** argv) {\n    mk_mech_init(argc, argv);\n    coreneuron::modl_reg();\n    return run_solve_core(argc, argv);\n}\n\nextern \"C\" {\n\n/// global variables from coreneuron library\nextern bool corenrn_embedded;\nextern int corenrn_embedded_nthread;\n\n/// parse arguments from neuron and prepare new one for coreneuron\nchar* prepare_args(int& argc, char**& argv, int use_mpi, const char* nrn_arg);\n\n/// initialize standard mechanisms from coreneuron\nvoid mk_mech_init(int argc, char** argv);\n\n/// set openmp threads equal to neuron's pthread\nvoid set_openmp_threads(int nthread);\n\n/** Run CoreNEURON in embedded mode with NEURON\n *\n * @param nthread Number of Pthreads on NEURON side\n * @param have_gaps True if gap junctions are used\n * @param use_mpi True if MPI is used on NEURON side\n * @param use_fast_imem True if fast imembrance calculation enabled\n * @param nrn_arg Command line arguments passed by NEURON\n * @return 1 if embedded mode is used otherwise 0\n * \\todo Change return type semantics\n */\nint corenrn_embedded_run(int nthread,\n                         int have_gaps,\n                         int use_mpi,\n                         int use_fast_imem,\n                         const char* nrn_arg) {\n    // set coreneuron's internal variable based on neuron arguments\n    corenrn_embedded = true;\n    corenrn_embedded_nthread = nthread;\n    coreneuron::nrn_have_gaps = have_gaps != 0;\n\n    if (use_fast_imem != 0) {\n        coreneuron::nrn_use_fast_imem = true;\n    }\n\n    // set number of openmp threads\n    set_openmp_threads(nthread);\n\n    // pre-process argumnets from neuron and prepare new for coreneuron\n    int argc;\n    char** argv;\n    char* new_arg = prepare_args(argc, argv, use_mpi, nrn_arg);\n\n    // initialize internal arguments\n    mk_mech_init(argc, argv);\n\n    // initialize extra arguments built into special-core\n    coreneuron::modl_reg();\n\n    // run simulation\n    run_solve_core(argc, argv);\n\n    // free temporary string created from prepare_args\n    free(new_arg);\n\n    // delete array for argv\n    delete[] argv;\n\n    return corenrn_embedded ? 1 : 0;\n}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/src/pybind/pyembed.cpp": "/*************************************************************************\n * Copyright (C) 2018-2019 Blue Brain Project\n *\n * This file is part of NMODL distributed under the terms of the GNU\n * Lesser General Public License. See top-level LICENSE file for details.\n *************************************************************************/\n\n#include <cstdlib>\n#include <dlfcn.h>\n\n#include \"pybind/pyembed.hpp\"\n#include \"utils/logger.hpp\"\n\nnamespace nmodl {\n\nnamespace pybind_wrappers {\n\nbool EmbeddedPythonLoader::have_wrappers() {\n#if defined(NMODL_STATIC_PYWRAPPER)\n    static auto wrapper_api = nmodl::pybind_wrappers::init_pybind_wrap_api();\n    wrappers = &wrapper_api;\n    return true;\n#else\n    wrappers = static_cast<pybind_wrap_api*>(dlsym(RTLD_DEFAULT, \"nmodl_wrapper_api\"));\n    return wrappers != nullptr;\n#endif\n}\n\nvoid EmbeddedPythonLoader::load_libraries() {\n    const auto pylib_env = std::getenv(\"NMODL_PYLIB\");\n    if (!pylib_env) {\n        logger->critical(\"NMODL_PYLIB environment variable must be set to load embedded python\");\n        throw std::runtime_error(\"NMODL_PYLIB not set\");\n    }\n    const auto dlopen_opts = RTLD_NOW | RTLD_GLOBAL;\n    dlerror();  // reset old error conditions\n    pylib_handle = dlopen(pylib_env, dlopen_opts);\n    if (!pylib_handle) {\n        const auto errstr = dlerror();\n        logger->critical(\"Tried but failed to load {}\", pylib_env);\n        logger->critical(errstr);\n        throw std::runtime_error(\"Failed to dlopen\");\n    }\n    const auto pybind_wraplib_env = std::getenv(\"NMODL_WRAPLIB\");\n    if (!pybind_wraplib_env) {\n        logger->critical(\n            \"NMODL_WRAPLIB environment variable must be set to load the pybind wrapper library\");\n        throw std::runtime_error(\"NMODL_WRAPLIB not set\");\n    }\n    pybind_wrapper_handle = dlopen(pybind_wraplib_env, dlopen_opts);\n    if (!pybind_wrapper_handle) {\n        const auto errstr = dlerror();\n        logger->critical(\"Tried but failed to load {}\", pybind_wraplib_env);\n        logger->critical(errstr);\n        throw std::runtime_error(\"Failed to dlopen\");\n    }\n}\n\nvoid EmbeddedPythonLoader::populate_symbols() {\n    wrappers = static_cast<pybind_wrap_api*>(dlsym(pybind_wrapper_handle, \"nmodl_wrapper_api\"));\n    if (!wrappers) {\n        const auto errstr = dlerror();\n        logger->critical(\"Tried but failed to load pybind wrapper symbols\");\n        logger->critical(errstr);\n        throw std::runtime_error(\"Failed to dlsym\");\n    }\n}\n\nvoid EmbeddedPythonLoader::unload() {\n    if (pybind_wrapper_handle) {\n        dlclose(pybind_wrapper_handle);\n    }\n    if (pylib_handle) {\n        dlclose(pylib_handle);\n    }\n}\n\nconst pybind_wrap_api* EmbeddedPythonLoader::api() {\n    return wrappers;\n}\n\n\n}  // namespace pybind_wrappers\n\n}  // namespace nmodl\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/pybind11/include/pybind11/detail/internals.h": "/*\n    pybind11/detail/internals.h: Internal data structure and related functions\n\n    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>\n\n    All rights reserved. Use of this source code is governed by a\n    BSD-style license that can be found in the LICENSE file.\n*/\n\n#pragma once\n\n#include \"../pytypes.h\"\n\nNAMESPACE_BEGIN(PYBIND11_NAMESPACE)\nNAMESPACE_BEGIN(detail)\n// Forward declarations\ninline PyTypeObject *make_static_property_type();\ninline PyTypeObject *make_default_metaclass();\ninline PyObject *make_object_base_type(PyTypeObject *metaclass);\n\n// The old Python Thread Local Storage (TLS) API is deprecated in Python 3.7 in favor of the new\n// Thread Specific Storage (TSS) API.\n#if PY_VERSION_HEX >= 0x03070000\n#    define PYBIND11_TLS_KEY_INIT(var) Py_tss_t *var = nullptr\n#    define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get((key))\n#    define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set((key), (value))\n#    define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set((key), nullptr)\n#    define PYBIND11_TLS_FREE(key) PyThread_tss_free(key)\n#else\n    // Usually an int but a long on Cygwin64 with Python 3.x\n#    define PYBIND11_TLS_KEY_INIT(var) decltype(PyThread_create_key()) var = 0\n#    define PYBIND11_TLS_GET_VALUE(key) PyThread_get_key_value((key))\n#    if PY_MAJOR_VERSION < 3\n#        define PYBIND11_TLS_DELETE_VALUE(key)                               \\\n             PyThread_delete_key_value(key)\n#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \\\n             do {                                                            \\\n                 PyThread_delete_key_value((key));                           \\\n                 PyThread_set_key_value((key), (value));                     \\\n             } while (false)\n#    else\n#        define PYBIND11_TLS_DELETE_VALUE(key)                               \\\n             PyThread_set_key_value((key), nullptr)\n#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \\\n             PyThread_set_key_value((key), (value))\n#    endif\n#    define PYBIND11_TLS_FREE(key) (void)key\n#endif\n\n// Python loads modules by default with dlopen with the RTLD_LOCAL flag; under libc++ and possibly\n// other STLs, this means `typeid(A)` from one module won't equal `typeid(A)` from another module\n// even when `A` is the same, non-hidden-visibility type (e.g. from a common include).  Under\n// libstdc++, this doesn't happen: equality and the type_index hash are based on the type name,\n// which works.  If not under a known-good stl, provide our own name-based hash and equality\n// functions that use the type name.\n#if defined(__GLIBCXX__)\ninline bool same_type(const std::type_info &lhs, const std::type_info &rhs) { return lhs == rhs; }\nusing type_hash = std::hash<std::type_index>;\nusing type_equal_to = std::equal_to<std::type_index>;\n#else\ninline bool same_type(const std::type_info &lhs, const std::type_info &rhs) {\n    return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n}\n\nstruct type_hash {\n    size_t operator()(const std::type_index &t) const {\n        size_t hash = 5381;\n        const char *ptr = t.name();\n        while (auto c = static_cast<unsigned char>(*ptr++))\n            hash = (hash * 33) ^ c;\n        return hash;\n    }\n};\n\nstruct type_equal_to {\n    bool operator()(const std::type_index &lhs, const std::type_index &rhs) const {\n        return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n    }\n};\n#endif\n\ntemplate <typename value_type>\nusing type_map = std::unordered_map<std::type_index, value_type, type_hash, type_equal_to>;\n\nstruct overload_hash {\n    inline size_t operator()(const std::pair<const PyObject *, const char *>& v) const {\n        size_t value = std::hash<const void *>()(v.first);\n        value ^= std::hash<const void *>()(v.second)  + 0x9e3779b9 + (value<<6) + (value>>2);\n        return value;\n    }\n};\n\n/// Internal data structure used to track registered instances and types.\n/// Whenever binary incompatible changes are made to this structure,\n/// `PYBIND11_INTERNALS_VERSION` must be incremented.\nstruct internals {\n    type_map<type_info *> registered_types_cpp; // std::type_index -> pybind11's type information\n    std::unordered_map<PyTypeObject *, std::vector<type_info *>> registered_types_py; // PyTypeObject* -> base type_info(s)\n    std::unordered_multimap<const void *, instance*> registered_instances; // void * -> instance*\n    std::unordered_set<std::pair<const PyObject *, const char *>, overload_hash> inactive_overload_cache;\n    type_map<std::vector<bool (*)(PyObject *, void *&)>> direct_conversions;\n    std::unordered_map<const PyObject *, std::vector<PyObject *>> patients;\n    std::forward_list<void (*) (std::exception_ptr)> registered_exception_translators;\n    std::unordered_map<std::string, void *> shared_data; // Custom data to be shared across extensions\n    std::vector<PyObject *> loader_patient_stack; // Used by `loader_life_support`\n    std::forward_list<std::string> static_strings; // Stores the std::strings backing detail::c_str()\n    PyTypeObject *static_property_type;\n    PyTypeObject *default_metaclass;\n    PyObject *instance_base;\n#if defined(WITH_THREAD)\n    PYBIND11_TLS_KEY_INIT(tstate);\n    PyInterpreterState *istate = nullptr;\n    ~internals() {\n        // This destructor is called *after* Py_Finalize() in finalize_interpreter().\n        // That *SHOULD BE* fine. The following details what happens whe PyThread_tss_free is called.\n        // PYBIND11_TLS_FREE is PyThread_tss_free on python 3.7+. On older python, it does nothing.\n        // PyThread_tss_free calls PyThread_tss_delete and PyMem_RawFree.\n        // PyThread_tss_delete just calls TlsFree (on Windows) or pthread_key_delete (on *NIX). Neither\n        // of those have anything to do with CPython internals.\n        // PyMem_RawFree *requires* that the `tstate` be allocated with the CPython allocator.\n        PYBIND11_TLS_FREE(tstate);\n    }\n#endif\n};\n\n/// Additional type information which does not fit into the PyTypeObject.\n/// Changes to this struct also require bumping `PYBIND11_INTERNALS_VERSION`.\nstruct type_info {\n    PyTypeObject *type;\n    const std::type_info *cpptype;\n    size_t type_size, type_align, holder_size_in_ptrs;\n    void *(*operator_new)(size_t);\n    void (*init_instance)(instance *, const void *);\n    void (*dealloc)(value_and_holder &v_h);\n    std::vector<PyObject *(*)(PyObject *, PyTypeObject *)> implicit_conversions;\n    std::vector<std::pair<const std::type_info *, void *(*)(void *)>> implicit_casts;\n    std::vector<bool (*)(PyObject *, void *&)> *direct_conversions;\n    buffer_info *(*get_buffer)(PyObject *, void *) = nullptr;\n    void *get_buffer_data = nullptr;\n    void *(*module_local_load)(PyObject *, const type_info *) = nullptr;\n    /* A simple type never occurs as a (direct or indirect) parent\n     * of a class that makes use of multiple inheritance */\n    bool simple_type : 1;\n    /* True if there is no multiple inheritance in this type's inheritance tree */\n    bool simple_ancestors : 1;\n    /* for base vs derived holder_type checks */\n    bool default_holder : 1;\n    /* true if this is a type registered with py::module_local */\n    bool module_local : 1;\n};\n\n/// Tracks the `internals` and `type_info` ABI version independent of the main library version\n#define PYBIND11_INTERNALS_VERSION 4\n\n/// On MSVC, debug and release builds are not ABI-compatible!\n#if defined(_MSC_VER) && defined(_DEBUG)\n#   define PYBIND11_BUILD_TYPE \"_debug\"\n#else\n#   define PYBIND11_BUILD_TYPE \"\"\n#endif\n\n/// Let's assume that different compilers are ABI-incompatible.\n#if defined(_MSC_VER)\n#   define PYBIND11_COMPILER_TYPE \"_msvc\"\n#elif defined(__INTEL_COMPILER)\n#   define PYBIND11_COMPILER_TYPE \"_icc\"\n#elif defined(__clang__)\n#   define PYBIND11_COMPILER_TYPE \"_clang\"\n#elif defined(__PGI)\n#   define PYBIND11_COMPILER_TYPE \"_pgi\"\n#elif defined(__MINGW32__)\n#   define PYBIND11_COMPILER_TYPE \"_mingw\"\n#elif defined(__CYGWIN__)\n#   define PYBIND11_COMPILER_TYPE \"_gcc_cygwin\"\n#elif defined(__GNUC__)\n#   define PYBIND11_COMPILER_TYPE \"_gcc\"\n#else\n#   define PYBIND11_COMPILER_TYPE \"_unknown\"\n#endif\n\n#if defined(_LIBCPP_VERSION)\n#  define PYBIND11_STDLIB \"_libcpp\"\n#elif defined(__GLIBCXX__) || defined(__GLIBCPP__)\n#  define PYBIND11_STDLIB \"_libstdcpp\"\n#else\n#  define PYBIND11_STDLIB \"\"\n#endif\n\n/// On Linux/OSX, changes in __GXX_ABI_VERSION__ indicate ABI incompatibility.\n#if defined(__GXX_ABI_VERSION)\n#  define PYBIND11_BUILD_ABI \"_cxxabi\" PYBIND11_TOSTRING(__GXX_ABI_VERSION)\n#else\n#  define PYBIND11_BUILD_ABI \"\"\n#endif\n\n#if defined(WITH_THREAD)\n#  define PYBIND11_INTERNALS_KIND \"\"\n#else\n#  define PYBIND11_INTERNALS_KIND \"_without_thread\"\n#endif\n\n#define PYBIND11_INTERNALS_ID \"__pybind11_internals_v\" \\\n    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI PYBIND11_BUILD_TYPE \"__\"\n\n#define PYBIND11_MODULE_LOCAL_ID \"__pybind11_module_local_v\" \\\n    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI PYBIND11_BUILD_TYPE \"__\"\n\n/// Each module locally stores a pointer to the `internals` data. The data\n/// itself is shared among modules with the same `PYBIND11_INTERNALS_ID`.\ninline internals **&get_internals_pp() {\n    static internals **internals_pp = nullptr;\n    return internals_pp;\n}\n\ninline void translate_exception(std::exception_ptr p) {\n    try {\n        if (p) std::rethrow_exception(p);\n    } catch (error_already_set &e)           { e.restore();                                    return;\n    } catch (const builtin_exception &e)     { e.set_error();                                  return;\n    } catch (const std::bad_alloc &e)        { PyErr_SetString(PyExc_MemoryError,   e.what()); return;\n    } catch (const std::domain_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n    } catch (const std::invalid_argument &e) { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n    } catch (const std::length_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n    } catch (const std::out_of_range &e)     { PyErr_SetString(PyExc_IndexError,    e.what()); return;\n    } catch (const std::range_error &e)      { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n    } catch (const std::overflow_error &e)   { PyErr_SetString(PyExc_OverflowError, e.what()); return;\n    } catch (const std::exception &e)        { PyErr_SetString(PyExc_RuntimeError,  e.what()); return;\n    } catch (...) {\n        PyErr_SetString(PyExc_RuntimeError, \"Caught an unknown exception!\");\n        return;\n    }\n}\n\n#if !defined(__GLIBCXX__)\ninline void translate_local_exception(std::exception_ptr p) {\n    try {\n        if (p) std::rethrow_exception(p);\n    } catch (error_already_set &e)       { e.restore();   return;\n    } catch (const builtin_exception &e) { e.set_error(); return;\n    }\n}\n#endif\n\n/// Return a reference to the current `internals` data\nPYBIND11_NOINLINE inline internals &get_internals() {\n    auto **&internals_pp = get_internals_pp();\n    if (internals_pp && *internals_pp)\n        return **internals_pp;\n\n    // Ensure that the GIL is held since we will need to make Python calls.\n    // Cannot use py::gil_scoped_acquire here since that constructor calls get_internals.\n    struct gil_scoped_acquire_local {\n        gil_scoped_acquire_local() : state (PyGILState_Ensure()) {}\n        ~gil_scoped_acquire_local() { PyGILState_Release(state); }\n        const PyGILState_STATE state;\n    } gil;\n\n    constexpr auto *id = PYBIND11_INTERNALS_ID;\n    auto builtins = handle(PyEval_GetBuiltins());\n    if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {\n        internals_pp = static_cast<internals **>(capsule(builtins[id]));\n\n        // We loaded builtins through python's builtins, which means that our `error_already_set`\n        // and `builtin_exception` may be different local classes than the ones set up in the\n        // initial exception translator, below, so add another for our local exception classes.\n        //\n        // libstdc++ doesn't require this (types there are identified only by name)\n#if !defined(__GLIBCXX__)\n        (*internals_pp)->registered_exception_translators.push_front(&translate_local_exception);\n#endif\n    } else {\n        if (!internals_pp) internals_pp = new internals*();\n        auto *&internals_ptr = *internals_pp;\n        internals_ptr = new internals();\n#if defined(WITH_THREAD)\n        PyEval_InitThreads();\n        PyThreadState *tstate = PyThreadState_Get();\n        #if PY_VERSION_HEX >= 0x03070000\n            internals_ptr->tstate = PyThread_tss_alloc();\n            if (!internals_ptr->tstate || PyThread_tss_create(internals_ptr->tstate))\n                pybind11_fail(\"get_internals: could not successfully initialize the TSS key!\");\n            PyThread_tss_set(internals_ptr->tstate, tstate);\n        #else\n            internals_ptr->tstate = PyThread_create_key();\n            if (internals_ptr->tstate == -1)\n                pybind11_fail(\"get_internals: could not successfully initialize the TLS key!\");\n            PyThread_set_key_value(internals_ptr->tstate, tstate);\n        #endif\n        internals_ptr->istate = tstate->interp;\n#endif\n        builtins[id] = capsule(internals_pp);\n        internals_ptr->registered_exception_translators.push_front(&translate_exception);\n        internals_ptr->static_property_type = make_static_property_type();\n        internals_ptr->default_metaclass = make_default_metaclass();\n        internals_ptr->instance_base = make_object_base_type(internals_ptr->default_metaclass);\n    }\n    return **internals_pp;\n}\n\n/// Works like `internals.registered_types_cpp`, but for module-local registered types:\ninline type_map<type_info *> &registered_local_types_cpp() {\n    static type_map<type_info *> locals{};\n    return locals;\n}\n\n/// Constructs a std::string with the given arguments, stores it in `internals`, and returns its\n/// `c_str()`.  Such strings objects have a long storage duration -- the internal strings are only\n/// cleared when the program exits or after interpreter shutdown (when embedding), and so are\n/// suitable for c-style strings needed by Python internals (such as PyTypeObject's tp_name).\ntemplate <typename... Args>\nconst char *c_str(Args &&...args) {\n    auto &strings = get_internals().static_strings;\n    strings.emplace_front(std::forward<Args>(args)...);\n    return strings.front().c_str();\n}\n\nNAMESPACE_END(detail)\n\n/// Returns a named pointer that is shared among all extension modules (using the same\n/// pybind11 version) running in the current interpreter. Names starting with underscores\n/// are reserved for internal usage. Returns `nullptr` if no matching entry was found.\ninline PYBIND11_NOINLINE void *get_shared_data(const std::string &name) {\n    auto &internals = detail::get_internals();\n    auto it = internals.shared_data.find(name);\n    return it != internals.shared_data.end() ? it->second : nullptr;\n}\n\n/// Set the shared data that can be later recovered by `get_shared_data()`.\ninline PYBIND11_NOINLINE void *set_shared_data(const std::string &name, void *data) {\n    detail::get_internals().shared_data[name] = data;\n    return data;\n}\n\n/// Returns a typed reference to a shared data entry (by using `get_shared_data()`) if\n/// such entry exists. Otherwise, a new object of default-constructible type `T` is\n/// added to the shared data under the given name and a reference to it is returned.\ntemplate<typename T>\nT &get_or_create_shared_data(const std::string &name) {\n    auto &internals = detail::get_internals();\n    auto it = internals.shared_data.find(name);\n    T *ptr = (T *) (it != internals.shared_data.end() ? it->second : nullptr);\n    if (!ptr) {\n        ptr = new T();\n        internals.shared_data[name] = ptr;\n    }\n    return *ptr;\n}\n\nNAMESPACE_END(PYBIND11_NAMESPACE)\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/pybind11/docs/faq.rst": "Frequently asked questions\n##########################\n\n\"ImportError: dynamic module does not define init function\"\n===========================================================\n\n1. Make sure that the name specified in PYBIND11_MODULE is identical to the\nfilename of the extension library (without prefixes such as .so)\n\n2. If the above did not fix the issue, you are likely using an incompatible\nversion of Python (for instance, the extension library was compiled against\nPython 2, while the interpreter is running on top of some version of Python\n3, or vice versa).\n\n\"Symbol not found: ``__Py_ZeroStruct`` / ``_PyInstanceMethod_Type``\"\n========================================================================\n\nSee the first answer.\n\n\"SystemError: dynamic module not initialized properly\"\n======================================================\n\nSee the first answer.\n\nThe Python interpreter immediately crashes when importing my module\n===================================================================\n\nSee the first answer.\n\nCMake doesn't detect the right Python version\n=============================================\n\nThe CMake-based build system will try to automatically detect the installed\nversion of Python and link against that. When this fails, or when there are\nmultiple versions of Python and it finds the wrong one, delete\n``CMakeCache.txt`` and then invoke CMake as follows:\n\n.. code-block:: bash\n\n    cmake -DPYTHON_EXECUTABLE:FILEPATH=<path-to-python-executable> .\n\n.. _faq_reference_arguments:\n\nLimitations involving reference arguments\n=========================================\n\nIn C++, it's fairly common to pass arguments using mutable references or\nmutable pointers, which allows both read and write access to the value\nsupplied by the caller. This is sometimes done for efficiency reasons, or to\nrealize functions that have multiple return values. Here are two very basic\nexamples:\n\n.. code-block:: cpp\n\n    void increment(int &i) { i++; }\n    void increment_ptr(int *i) { (*i)++; }\n\nIn Python, all arguments are passed by reference, so there is no general\nissue in binding such code from Python.\n\nHowever, certain basic Python types (like ``str``, ``int``, ``bool``,\n``float``, etc.) are **immutable**. This means that the following attempt\nto port the function to Python doesn't have the same effect on the value\nprovided by the caller -- in fact, it does nothing at all.\n\n.. code-block:: python\n\n    def increment(i):\n        i += 1 # nope..\n\npybind11 is also affected by such language-level conventions, which means that\nbinding ``increment`` or ``increment_ptr`` will also create Python functions\nthat don't modify their arguments.\n\nAlthough inconvenient, one workaround is to encapsulate the immutable types in\na custom type that does allow modifications.\n\nAn other alternative involves binding a small wrapper lambda function that\nreturns a tuple with all output arguments (see the remainder of the\ndocumentation for examples on binding lambda functions). An example:\n\n.. code-block:: cpp\n\n    int foo(int &i) { i++; return 123; }\n\nand the binding code\n\n.. code-block:: cpp\n\n   m.def(\"foo\", [](int i) { int rv = foo(i); return std::make_tuple(rv, i); });\n\n\nHow can I reduce the build time?\n================================\n\nIt's good practice to split binding code over multiple files, as in the\nfollowing example:\n\n:file:`example.cpp`:\n\n.. code-block:: cpp\n\n    void init_ex1(py::module &);\n    void init_ex2(py::module &);\n    /* ... */\n\n    PYBIND11_MODULE(example, m) {\n        init_ex1(m);\n        init_ex2(m);\n        /* ... */\n    }\n\n:file:`ex1.cpp`:\n\n.. code-block:: cpp\n\n    void init_ex1(py::module &m) {\n        m.def(\"add\", [](int a, int b) { return a + b; });\n    }\n\n:file:`ex2.cpp`:\n\n.. code-block:: cpp\n\n    void init_ex2(py::module &m) {\n        m.def(\"sub\", [](int a, int b) { return a - b; });\n    }\n\n:command:`python`:\n\n.. code-block:: pycon\n\n    >>> import example\n    >>> example.add(1, 2)\n    3\n    >>> example.sub(1, 1)\n    0\n\nAs shown above, the various ``init_ex`` functions should be contained in\nseparate files that can be compiled independently from one another, and then\nlinked together into the same final shared object.  Following this approach\nwill:\n\n1. reduce memory requirements per compilation unit.\n\n2. enable parallel builds (if desired).\n\n3. allow for faster incremental builds. For instance, when a single class\n   definition is changed, only a subset of the binding code will generally need\n   to be recompiled.\n\n\"recursive template instantiation exceeded maximum depth of 256\"\n================================================================\n\nIf you receive an error about excessive recursive template evaluation, try\nspecifying a larger value, e.g. ``-ftemplate-depth=1024`` on GCC/Clang. The\nculprit is generally the generation of function signatures at compile time\nusing C++14 template metaprogramming.\n\n.. _`faq:hidden_visibility`:\n\n\"\u2018SomeClass\u2019 declared with greater visibility than the type of its field \u2018SomeClass::member\u2019 [-Wattributes]\"\n============================================================================================================\n\nThis error typically indicates that you are compiling without the required\n``-fvisibility`` flag.  pybind11 code internally forces hidden visibility on\nall internal code, but if non-hidden (and thus *exported*) code attempts to\ninclude a pybind type (for example, ``py::object`` or ``py::list``) you can run\ninto this warning.\n\nTo avoid it, make sure you are specifying ``-fvisibility=hidden`` when\ncompiling pybind code.\n\nAs to why ``-fvisibility=hidden`` is necessary, because pybind modules could\nhave been compiled under different versions of pybind itself, it is also\nimportant that the symbols defined in one module do not clash with the\npotentially-incompatible symbols defined in another.  While Python extension\nmodules are usually loaded with localized symbols (under POSIX systems\ntypically using ``dlopen`` with the ``RTLD_LOCAL`` flag), this Python default\ncan be changed, but even if it isn't it is not always enough to guarantee\ncomplete independence of the symbols involved when not using\n``-fvisibility=hidden``.\n\nAdditionally, ``-fvisiblity=hidden`` can deliver considerably binary size\nsavings.  (See the following section for more details).\n\n\n.. _`faq:symhidden`:\n\nHow can I create smaller binaries?\n==================================\n\nTo do its job, pybind11 extensively relies on a programming technique known as\n*template metaprogramming*, which is a way of performing computation at compile\ntime using type information. Template metaprogamming usually instantiates code\ninvolving significant numbers of deeply nested types that are either completely\nremoved or reduced to just a few instructions during the compiler's optimization\nphase. However, due to the nested nature of these types, the resulting symbol\nnames in the compiled extension library can be extremely long. For instance,\nthe included test suite contains the following symbol:\n\n.. only:: html\n\n    .. code-block:: none\n\n        _\u200b_\u200bZ\u200bN\u200b8\u200bp\u200by\u200bb\u200bi\u200bn\u200bd\u200b1\u200b1\u200b1\u200b2\u200bc\u200bp\u200bp\u200b_\u200bf\u200bu\u200bn\u200bc\u200bt\u200bi\u200bo\u200bn\u200bC\u200b1\u200bI\u200bv\u200b8\u200bE\u200bx\u200ba\u200bm\u200bp\u200bl\u200be\u200b2\u200bJ\u200bR\u200bN\u200bS\u200bt\u200b3\u200b_\u200b_\u200b1\u200b6\u200bv\u200be\u200bc\u200bt\u200bo\u200br\u200bI\u200bN\u200bS\u200b3\u200b_\u200b1\u200b2\u200bb\u200ba\u200bs\u200bi\u200bc\u200b_\u200bs\u200bt\u200br\u200bi\u200bn\u200bg\u200bI\u200bw\u200bN\u200bS\u200b3\u200b_\u200b1\u200b1\u200bc\u200bh\u200ba\u200br\u200b_\u200bt\u200br\u200ba\u200bi\u200bt\u200bs\u200bI\u200bw\u200bE\u200bE\u200bN\u200bS\u200b3\u200b_\u200b9\u200ba\u200bl\u200bl\u200bo\u200bc\u200ba\u200bt\u200bo\u200br\u200bI\u200bw\u200bE\u200bE\u200bE\u200bE\u200bN\u200bS\u200b8\u200b_\u200bI\u200bS\u200bA\u200b_\u200bE\u200bE\u200bE\u200bE\u200bE\u200bJ\u200bN\u200bS\u200b_\u200b4\u200bn\u200ba\u200bm\u200be\u200bE\u200bN\u200bS\u200b_\u200b7\u200bs\u200bi\u200bb\u200bl\u200bi\u200bn\u200bg\u200bE\u200bN\u200bS\u200b_\u200b9\u200bi\u200bs\u200b_\u200bm\u200be\u200bt\u200bh\u200bo\u200bd\u200bE\u200bA\u200b2\u200b8\u200b_\u200bc\u200bE\u200bE\u200bE\u200bM\u200bT\u200b0\u200b_\u200bF\u200bT\u200b_\u200bD\u200bp\u200bT\u200b1\u200b_\u200bE\u200bD\u200bp\u200bR\u200bK\u200bT\u200b2\u200b_\n\n.. only:: not html\n\n    .. code-block:: cpp\n\n        __ZN8pybind1112cpp_functionC1Iv8Example2JRNSt3__16vectorINS3_12basic_stringIwNS3_11char_traitsIwEENS3_9allocatorIwEEEENS8_ISA_EEEEEJNS_4nameENS_7siblingENS_9is_methodEA28_cEEEMT0_FT_DpT1_EDpRKT2_\n\nwhich is the mangled form of the following function type:\n\n.. code-block:: cpp\n\n    pybind11::cpp_function::cpp_function<void, Example2, std::__1::vector<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >, std::__1::allocator<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> > > >&, pybind11::name, pybind11::sibling, pybind11::is_method, char [28]>(void (Example2::*)(std::__1::vector<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >, std::__1::allocator<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> > > >&), pybind11::name const&, pybind11::sibling const&, pybind11::is_method const&, char const (&) [28])\n\nThe memory needed to store just the mangled name of this function (196 bytes)\nis larger than the actual piece of code (111 bytes) it represents! On the other\nhand, it's silly to even give this function a name -- after all, it's just a\ntiny cog in a bigger piece of machinery that is not exposed to the outside\nworld. So we'll generally only want to export symbols for those functions which\nare actually called from the outside.\n\nThis can be achieved by specifying the parameter ``-fvisibility=hidden`` to GCC\nand Clang, which sets the default symbol visibility to *hidden*, which has a\ntremendous impact on the final binary size of the resulting extension library.\n(On Visual Studio, symbols are already hidden by default, so nothing needs to\nbe done there.)\n\nIn addition to decreasing binary size, ``-fvisibility=hidden`` also avoids\npotential serious issues when loading multiple modules and is required for\nproper pybind operation.  See the previous FAQ entry for more details.\n\nWorking with ancient Visual Studio 2008 builds on Windows\n=========================================================\n\nThe official Windows distributions of Python are compiled using truly\nancient versions of Visual Studio that lack good C++11 support. Some users\nimplicitly assume that it would be impossible to load a plugin built with\nVisual Studio 2015 into a Python distribution that was compiled using Visual\nStudio 2008. However, no such issue exists: it's perfectly legitimate to\ninterface DLLs that are built with different compilers and/or C libraries.\nCommon gotchas to watch out for involve not ``free()``-ing memory region\nthat that were ``malloc()``-ed in another shared library, using data\nstructures with incompatible ABIs, and so on. pybind11 is very careful not\nto make these types of mistakes.\n\nHow can I properly handle Ctrl-C in long-running functions?\n===========================================================\n\nCtrl-C is received by the Python interpreter, and holds it until the GIL\nis released, so a long-running function won't be interrupted.\n\nTo interrupt from inside your function, you can use the ``PyErr_CheckSignals()``\nfunction, that will tell if a signal has been raised on the Python side.  This\nfunction merely checks a flag, so its impact is negligible. When a signal has\nbeen received, you must either explicitly interrupt execution by throwing\n``py::error_already_set`` (which will propagate the existing\n``KeyboardInterrupt``), or clear the error (which you usually will not want):\n\n.. code-block:: cpp\n\n    PYBIND11_MODULE(example, m)\n    {\n        m.def(\"long running_func\", []()\n        {\n            for (;;) {\n                if (PyErr_CheckSignals() != 0)\n                    throw py::error_already_set();\n                // Long running iteration\n            }\n        });\n    }\n\nInconsistent detection of Python version in CMake and pybind11\n==============================================================\n\nThe functions ``find_package(PythonInterp)`` and ``find_package(PythonLibs)`` provided by CMake\nfor Python version detection are not used by pybind11 due to unreliability and limitations that make\nthem unsuitable for pybind11's needs. Instead pybind provides its own, more reliable Python detection\nCMake code. Conflicts can arise, however, when using pybind11 in a project that *also* uses the CMake\nPython detection in a system with several Python versions installed.\n\nThis difference may cause inconsistencies and errors if *both* mechanisms are used in the same project. Consider the following\nCmake code executed in a system with Python 2.7 and 3.x installed:\n\n.. code-block:: cmake\n\n    find_package(PythonInterp)\n    find_package(PythonLibs)\n    find_package(pybind11)\n\nIt will detect Python 2.7 and pybind11 will pick it as well.\n\nIn contrast this code:\n\n.. code-block:: cmake\n\n    find_package(pybind11)\n    find_package(PythonInterp)\n    find_package(PythonLibs)\n\nwill detect Python 3.x for pybind11 and may crash on ``find_package(PythonLibs)`` afterwards.\n\nIt is advised to avoid using ``find_package(PythonInterp)`` and ``find_package(PythonLibs)`` from CMake and rely\non pybind11 in detecting Python version. If this is not possible CMake machinery should be called *before* including pybind11.\n\nHow to cite this project?\n=========================\n\nWe suggest the following BibTeX template to cite pybind11 in scientific\ndiscourse:\n\n.. code-block:: bash\n\n    @misc{pybind11,\n       author = {Wenzel Jakob and Jason Rhinelander and Dean Moldovan},\n       year = {2017},\n       note = {https://github.com/pybind/pybind11},\n       title = {pybind11 -- Seamless operability between C++11 and Python}\n    }\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/mod2c/src/mod2c_core/nmodlconf.h": "/* nmodlconf.h.  Generated from nmodlconf.h.in by configure.  */\n/* config.h.in.  Generated from configure.in by autoheader.  */\n\n\n#ifndef H_nrnconf_included\n#define H_nrnconf_included 1\n\n\n/* Define if building universal (internal helper macro) */\n/* #undef AC_APPLE_UNIVERSAL_BUILD */\n\n/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP\n   systems. This function is required for `alloca.c' support on those systems.\n   */\n/* #undef CRAY_STACKSEG_END */\n\n/* define if using cygwin */\n/* #undef CYGWIN */\n\n/* Define to 1 if using `alloca.c'. */\n/* #undef C_ALLOCA */\n\n/* if mac os x */\n/* #undef DARWIN */\n\n/* Define to 1 if you have `alloca', as a function or macro. */\n#define HAVE_ALLOCA 1\n\n/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).\n   */\n#define HAVE_ALLOCA_H 1\n\n/* Define to 1 if you have the `bcopy' function. */\n#define HAVE_BCOPY 1\n\n/* Define to 1 if you have the `bzero' function. */\n#define HAVE_BZERO 1\n\n/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.\n   */\n#define HAVE_DIRENT_H 1\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#define HAVE_DLFCN_H 1\n\n/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */\n/* #undef HAVE_DOPRNT */\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n#define HAVE_FCNTL_H 1\n\n/* Define to 1 if you have the <fenv.h> header file. */\n#define HAVE_FENV_H 1\n\n/* Define to 1 if you have the `fesetround' function. */\n/* #undef HAVE_FESETROUND */\n\n/* Define to 1 if you have the <float.h> header file. */\n#define HAVE_FLOAT_H 1\n\n/* Define to 1 if you have the `ftime' function. */\n#define HAVE_FTIME 1\n\n/* Define to 1 if you have the `getcwd' function. */\n#define HAVE_GETCWD 1\n\n/* Define to 1 if you have the `gethostname' function. */\n#define HAVE_GETHOSTNAME 1\n\n/* Define to 1 if you have the `getpw' function. */\n#define HAVE_GETPW 1\n\n/* Define to 1 if you have the `gettimeofday' function. */\n#define HAVE_GETTIMEOFDAY 1\n\n/* Define to 1 if you have the `index' function. */\n#define HAVE_INDEX 1\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#define HAVE_INTTYPES_H 1\n\n/* Define to 1 if you have the `isatty' function. */\n#define HAVE_ISATTY 1\n\n/* define if using InterViews */\n#define HAVE_IV 0\n\n/* Define to 1 if you have the `imf' library (-limf). */\n/* #undef HAVE_LIBIMF */\n\n/* Define to 1 if you have the `m' library (-lm). */\n/* #undef HAVE_LIBM */\n\n/* Define to 1 if you have the `mass' library (-lmass). */\n/* #undef HAVE_LIBMASS */\n\n/* Define to 1 if you have the <limits.h> header file. */\n#define HAVE_LIMITS_H 1\n\n/* Define to 1 if you have the <locale.h> header file. */\n#define HAVE_LOCALE_H 1\n\n/* Define to 1 if you have the `lockf' function. */\n#define HAVE_LOCKF 1\n\n/* Define to 1 if you have the `mallinfo' function. */\n#define HAVE_MALLINFO 1\n\n/* Define to 1 if you have the <malloc.h> header file. */\n#define HAVE_MALLOC_H 1\n\n/* Define to 1 if you have the <math.h> header file. */\n#define HAVE_MATH_H 1\n\n/* Define to 1 if you have the <memory.h> header file. */\n#define HAVE_MEMORY_H 1\n\n/* Define to 1 if you have the `mkdir' function. */\n#define HAVE_MKDIR 1\n\n/* Define to 1 if you have the `mkstemp' function. */\n#define HAVE_MKSTEMP 1\n\n/* define if the compiler implements namespaces */\n#define HAVE_NAMESPACES /**/\n\n/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */\n/* #undef HAVE_NDIR_H */\n\n/* Define to 1 if you have the `posix_memalign' function. */\n#define HAVE_POSIX_MEMALIGN 1\n\n/* Define if you have POSIX threads libraries and header files. */\n/* #undef HAVE_PTHREAD */\n\n/* Define to 1 if you have the <pthread.h> header file. */\n#define HAVE_PTHREAD_H 1\n\n/* Define to 1 if you have the `putenv' function. */\n#define HAVE_PUTENV 1\n\n/* Define to 1 if you have the `select' function. */\n#define HAVE_SELECT 1\n\n/* Define to 1 if you have the `setenv' function. */\n#define HAVE_SETENV 1\n\n/* Define to 1 if you have the `setitimer' function. */\n#define HAVE_SETITIMER 1\n\n/* Define to 1 if you have the <sgtty.h> header file. */\n#define HAVE_SGTTY_H 1\n\n/* Define to 1 if you have the `sigaction' function. */\n#define HAVE_SIGACTION 1\n\n/* (Define if this signal exists) */\n#define HAVE_SIGBUS 1\n\n/* (Define if this signal exists) */\n#define HAVE_SIGSEGV 1\n\n/* define if the compiler has stringstream */\n#define HAVE_SSTREAM /**/\n\n/* Define to 1 if you have the <stdarg.h> header file. */\n#define HAVE_STDARG_H 1\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#define HAVE_STDINT_H 1\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#define HAVE_STDLIB_H 1\n\n/* Define to 1 if you have the `strdup' function. */\n#define HAVE_STRDUP 1\n\n/* Define to 1 if you have the <stream.h> header file. */\n/* #undef HAVE_STREAM_H */\n\n/* Define to 1 if you have the <strings.h> header file. */\n#define HAVE_STRINGS_H 1\n\n/* Define to 1 if you have the <string.h> header file. */\n#define HAVE_STRING_H 1\n\n/* Define to 1 if you have the <stropts.h> header file. */\n#define HAVE_STROPTS_H 1\n\n/* Define to 1 if you have the `strstr' function. */\n#define HAVE_STRSTR 1\n\n/* Define to 1 if you have the `stty' function. */\n/* #undef HAVE_STTY */\n\n/* Define to 1 if you have the <sys/conf.h> header file. */\n/* #undef HAVE_SYS_CONF_H */\n\n/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.\n   */\n/* #undef HAVE_SYS_DIR_H */\n\n/* Define to 1 if you have the <sys/file.h> header file. */\n#define HAVE_SYS_FILE_H 1\n\n/* Define to 1 if you have the <sys/ioctl.h> header file. */\n#define HAVE_SYS_IOCTL_H 1\n\n/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.\n   */\n/* #undef HAVE_SYS_NDIR_H */\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#define HAVE_SYS_STAT_H 1\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#define HAVE_SYS_TIME_H 1\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#define HAVE_SYS_TYPES_H 1\n\n/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */\n#define HAVE_SYS_WAIT_H 1\n\n/* Define to 1 if you have the <termio.h> header file. */\n#define HAVE_TERMIO_H 1\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#define HAVE_UNISTD_H 1\n\n/* Define to 1 if you have the <varargs.h> header file. */\n/* #undef HAVE_VARARGS_H */\n\n/* Define to 1 if you have the `vprintf' function. */\n#define HAVE_VPRINTF 1\n\n/* Define to 1 if you have the <_G_config.h> header file. */\n#define HAVE__G_CONFIG_H 1\n\n/* define if can declare inline float abs(float) */\n#define INLINE_FLOAT_ABS 1\n\n/* define if can declare inline long abs(long) */\n#define INLINE_LONG_ABS 1\n\n/* undefined or ::fabs or std::fabs */\n#define IVOS_FABS ::fabs\n\n/* Define to the sub-directory in which libtool stores uninstalled libraries.\n   */\n#define LT_OBJDIR \".libs/\"\n\n/* define if using mingw */\n/* #undef MINGW */\n\n/* define if using Mike Neubig <neubig@salk.edu> contributions */\n/* #undef MikeNeubig */\n\n/* where the lib hoc is */\n#define NEURON_DATA_DIR \"/usr/local/nrn/share/nrn\"\n\n/* host triplet */\n#define NRNHOST \"x86_64-unknown-linux-gnu\"\n\n/* cpu type consistent with nrnivmodl */\n#define NRNHOSTCPU \"x86_64\"\n\n/* if 1 then dlopen nrnmech instead of special */\n#define NRNMECH_DLL_STYLE 1\n\n/* if nrnoc can use X11 */\n#define NRNOC_X11 1\n\n/* Name of package */\n#define PACKAGE \"nrn\"\n\n/* Define to the address where bug reports for this package should be sent. */\n#define PACKAGE_BUGREPORT \"\"\n\n/* Define to the full name of this package. */\n#define PACKAGE_NAME \"nrn\"\n\n/* Define to the full name and version of this package. */\n#define PACKAGE_STRING \"nrn 7.4\"\n\n/* Define to the one symbol short name of this package. */\n#define PACKAGE_TARNAME \"nrn\"\n\n/* Define to the home page for this package. */\n#define PACKAGE_URL \"\"\n\n/* Define to the version of this package. */\n#define PACKAGE_VERSION \"7.4\"\n\n/* Define to necessary symbol if this constant uses a non-standard name on\n   your system. */\n/* #undef PTHREAD_CREATE_JOINABLE */\n\n/* Define as the return type of signal handlers (`int' or `void'). */\n#define RETSIGTYPE void\n\n/* define if RETSIGTYPE(*)(int) is not the prototype for a signal handler */\n/* #undef SIGNAL_CAST */\n\n/* If using the C implementation of alloca, define if you know the\n   direction of stack growth for your system; otherwise it will be\n   automatically deduced at runtime.\n\tSTACK_DIRECTION > 0 => grows toward higher addresses\n\tSTACK_DIRECTION < 0 => grows toward lower addresses\n\tSTACK_DIRECTION = 0 => direction of growth unknown */\n/* #undef STACK_DIRECTION */\n\n/* Define to 1 if you have the ANSI C header files. */\n#define STDC_HEADERS 1\n\n/* Define SUNDIALS data type 'realtype' as 'long double' */\n#define SUNDIALS_DOUBLE_PRECISION 1\n\n/* Use generic math functions */\n#define SUNDIALS_USE_GENERIC_MATH 1\n\n/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n#define TIME_WITH_SYS_TIME 1\n\n/* Define to 1 if your <sys/time.h> declares `struct tm'. */\n/* #undef TM_IN_SYS_TIME */\n\n/* Version number of package */\n#define VERSION \"7.4\"\n\n/* define if no terminal capabilities */\n/* #undef WITHOUT_MEMACS */\n\n/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n   significant byte first (like Motorola and SPARC, unlike Intel). */\n#if defined AC_APPLE_UNIVERSAL_BUILD\n# if defined __BIG_ENDIAN__\n#  define WORDS_BIGENDIAN 1\n# endif\n#else\n# ifndef WORDS_BIGENDIAN\n/* #  undef WORDS_BIGENDIAN */\n# endif\n#endif\n\n/* Define to 1 if the X Window System is missing or not being used. */\n/* #undef X_DISPLAY_MISSING */\n\n/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a\n   `char[]'. */\n#define YYTEXT_POINTER 1\n\n/* define if using Carbon libraries */\n/* #undef carbon */\n\n/* Define to the type of a signed integer type of width exactly 64 bits if\n   such a type exists and the standard includes do not define it. */\n/* #undef int64_t */\n\n/* Define to `long int' if <sys/types.h> does not define. */\n/* #undef off_t */\n\n/* Define to `int' if <sys/types.h> does not define. */\n/* #undef pid_t */\n\n/* Define to `unsigned int' if <sys/types.h> does not define. */\n/* #undef size_t */\n\n\n#if defined(__cplusplus)\n#include <ivstream.h>\n#endif\n\n#if defined(CYGWIN) || defined(MINGW)\n#define WIN32 1\n#endif\n\n#if defined(MINGW)\n#define CYGWIN\n#endif\n\n#endif /* H_nrnconf_included */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/iv/CMakeLists.txt": "cmake_minimum_required(VERSION 3.3.0 FATAL_ERROR)\nproject(INTERVIEWS C CXX)\n\n# =============================================================================\n# CMake common project settings\n# =============================================================================\nset(PROJECT_VERSION_MAJOR 0)\nset(PROJECT_VERSION_MINOR 1)\n\nset(CMAKE_CXX_STANDARD 98)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS OFF)\n\nset(PROJECT_VERSION ${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR})\n\n\n# =============================================================================\n# To be able to use project as submodule, avoid using PROJECT_SOURCE_DIR\n# =============================================================================\nset(IV_PROJECT_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR})\nset(IV_PROJECT_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR})\n# For future target customization\nset(IV_AS_SUBPROJECT OFF)\nif (NOT CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)\n  set(IV_AS_SUBPROJECT ON)\nendif()\n\n# =============================================================================\n# Project build options\n# =============================================================================\noption(IV_ENABLE_SHARED \"Build libraries shared or static\" OFF)\n# Useful for MAC if XQuartz not installed on user machine.\noption(IV_ENABLE_X11_DYNAMIC \"dlopen X11 after launch\" OFF)\n# Use only if X11 API changes (Uses very brittle script).\noption(IV_ENABLE_X11_DYNAMIC_MAKE_HEADERS \"Remake the X11 dynamic .h files.\" OFF)\n\n# =============================================================================\n# CMake build settings\n# =============================================================================\nset(allowableBuildTypes Debug Release RelWithDebInfo)\nif(NOT CMAKE_BUILD_TYPE)\n  set(CMAKE_BUILD_TYPE\n      RelWithDebInfo\n      CACHE STRING \"Empty or one of ${allowableBuildTypes}\" FORCE)\nelseif(NOT CMAKE_BUILD_TYPE IN_LIST allowableBuildTypes)\n  message(FATAL_ERROR \"Invalid build type: ${CMAKE_BUILD_TYPE} : Must be one of ${allowableBuildTypes}\")\nendif()\n\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/bin)\n\nif(NOT IV_ENABLE_SHARED)\n  set(CMAKE_POSITION_INDEPENDENT_CODE ON)\n  set(IV_LIB_TYPE \"STATIC\")\nelse()\n  set(IV_LIB_TYPE \"SHARED\")\nendif()\n\n# CYGWIN macros is used in the code\nif(${CMAKE_SYSTEM_NAME} MATCHES \"CYGWIN\")\n  set(CYGWIN 1)\nendif()\n\n# =============================================================================\n# Include cmake modules\n# =============================================================================\nlist(APPEND CMAKE_MODULE_PATH ${IV_PROJECT_SOURCE_DIR}/cmake)\ninclude(HelperFunctions)\n# do not conflict with nrn PlatformHelper.cmake when submodule.\ninclude(${IV_PROJECT_SOURCE_DIR}/cmake/PlatformHelper.cmake)\ninclude(RpathHelper)\ninclude(CheckIncludeFiles)\ninclude(CheckFunctionExists)\n\n# =============================================================================\n# Find dependencies\n# =============================================================================\nfind_package(X11)\n\nif(NOT X11_FOUND AND NOT IV_WINDOWS_BUILD)\n  if(APPLE)\n    message(FATAL_ERROR \"Install XQuartz from https://www.xquartz.org/ to build iv\")\n  else()\n    message(FATAL_ERROR \"Install X11 to build iv (e.g. 'apt install libx11-dev libxcomposite-dev' on Ubuntu\")\n  endif()\nendif()\n\nif(NOT X11_Xcomposite_FOUND AND NOT IV_WINDOWS_BUILD)\n  message(FATAL_ERROR \"libXcomposite is required for X11 support (e.g. 'apt install libxcomposite-dev' on Ubuntu)\")\nendif()\n\nif(IV_ENABLE_X11_DYNAMIC AND NOT X11_FOUND)\n    message(FATAL_ERROR \"Cannot IV_ENABLE_X11_DYNAMIC without X11 installed\")\nendif()\n\nif (IV_ENABLE_X11_DYNAMIC_MAKE_HEADERS)\n  # need any Python to run mkdynam.py to generate some .h files\n  find_package(PythonInterp REQUIRED)\n  if (NOT X11_FOUND)\n    message(FATAL_ERROR \"Cannot IV_ENABLE_X11_DYNAMIC_MAKE_HEADERS without X11 installed\")\n  endif()\nendif()\n\n# =============================================================================\n# Check existance of various headers, functions and directories\n# =============================================================================\nset(CMAKE_REQUIRED_QUIET TRUE)\nmessage(STATUS \"Checking for include files\")\ncheck_include_files(fcntl.h HAVE_FCNTL_H)\ncheck_include_files(malloc.h HAVE_MALLOC_H)\ncheck_include_files(memory.h HAVE_MEMORY_H)\ncheck_include_files(osfcn.h HAVE_OSFCN_H)\ncheck_include_files(socket.h HAVE_SOCKET_H)\ncheck_include_files(stdint.h HAVE_STDINT_H)\ncheck_include_files(stdlib.h HAVE_STDLIB_H)\ncheck_include_files(string.h HAVE_STRING_H)\ncheck_include_files(strings.h HAVE_STRINGS_H)\ncheck_include_files(stropts.h HAVE_STROPTS_H)\ncheck_include_files(stream.h HAVE_STREAM_H)\ncheck_include_files(sys/conf.h HAVE_SYS_CONF_H)\ncheck_include_files(sys/file.h HAVE_SYS_FILE_H)\ncheck_include_files(sys/ioctl.h HAVE_SYS_IOCTL_H)\ncheck_include_files(sys/mman.h HAVE_SYS_MMAN_H)\ncheck_include_files(sys/param.h HAVE_SYS_PARAM_H)\ncheck_include_files(sys/stat.h HAVE_SYS_STAT_H)\ncheck_include_files(sys/time.h HAVE_SYS_TIME_H)\ncheck_include_files(unistd.h HAVE_UNISTD_H)\n\nmessage(STATUS \"Checking for functions\")\ncheck_function_exists(getcwd HAVE_GETCWD)\ncheck_function_exists(gettimeofday HAVE_GETTIMEOFDAY)\ncheck_function_exists(mmap HAVE_MMAP)\ncheck_function_exists(sigprocmask HAVE_POSIX_SIGNALS)\ncheck_function_exists(socket HAVE_SOCKET)\ncheck_function_exists(strcspn HAVE_STRCSPN)\ncheck_function_exists(strerror HAVE_STRERROR)\ncheck_function_exists(strtod HAVE_STRTOD)\ncheck_function_exists(strtol HAVE_STRTOL)\ncheck_function_exists(uname HAVE_UNAME)\n\nmessage(STATUS \"Checking for include directories\")\niv_check_dir_exists(dirent.h HAVE_DIRENT_H)\niv_check_dir_exists(ndir.h HAVE_NDIR_H)\niv_check_dir_exists(sys/dir.h HAVE_SYS_DIR_H)\niv_check_dir_exists(sys/ndir.h HAVE_SYS_NDIR_H)\n\nmessage(STATUS \"Checking for types\")\niv_check_type_exists(sys/types.h gid_t int gid_t)\niv_check_type_exists(sys/types.h off_t \"long int\" off_t)\niv_check_type_exists(sys/types.h pid_t int pid_t)\niv_check_type_exists(sys/types.h size_t \"unsigned int\" size_t)\niv_check_type_exists(sys/types.h uid_t int uid_t)\n\n# =============================================================================\n# Check if signals support\n# =============================================================================\n# NOTE: check_function_exists(sigsetmask HAVE_BSD_SIGNALS) made obsolete by sigprocmask(2).\n# sigsetmask exists but the usage generates a variety of errors. See the old autoconf acinclude.m4\n# AC_DEFUN([BASH_SIGNAL_CHECK] For now, use only if don't have posix signals.\nif(NOT ${HAVE_POSIX_SIGNALS})\n  set(HAVE_BSD_SIGNALS 1)\nelse()\n  set(HAVE_BSD_SIGNALS 0)\nendif()\n\n# =============================================================================\n# Set return type of signal in RETSIGTYPE\n# =============================================================================\niv_check_signal_return_type(RETSIGTYPE)\n\n# =============================================================================\n# Generate config.h after all checks\n# =============================================================================\nadd_definitions(-DHAVE_CONFIG_H)\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/config.h.in ${CMAKE_CURRENT_BINARY_DIR}/config.h)\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/cmake/iv-config.cmake.in ${CMAKE_CURRENT_BINARY_DIR}/cmake/iv-config.cmake @ONLY)\n\n# =============================================================================\n# Include source directories\n# =============================================================================\ninclude_directories(${IV_PROJECT_SOURCE_DIR}/src/include ${IV_PROJECT_BINARY_DIR}/src/lib)\nadd_subdirectory(src/lib)\nadd_subdirectory(src/bin)\n\n# =============================================================================\n# Install binaries and headers\n# =============================================================================\ninstall(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/src/include/ DESTINATION include)\nif(NOT IV_AS_SUBPROJECT)\n  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/cmake/iv-config.cmake DESTINATION share/cmake)\n  install(EXPORT iv DESTINATION share/cmake)\nendif()\n\n# =============================================================================\n# Print build status\n# =============================================================================\nmessage(STATUS \"\")\nmessage(STATUS \"Configured INTERVIEWS ${PROJECT_VERSION}\")\nmessage(STATUS \"\")\nstring(TOLOWER \"${CMAKE_GENERATOR}\" cmake_generator_tolower)\nif(cmake_generator_tolower MATCHES \"makefile\")\n  message(STATUS \"Some things you can do now:\")\n  message(STATUS \"--------------+--------------------------------------------------------------\")\n  message(STATUS \"Command       |   Description\")\n  message(STATUS \"--------------+--------------------------------------------------------------\")\n  message(STATUS \"make install  | Will install INTERVIEWS to: ${CMAKE_INSTALL_PREFIX}\")\n  message(STATUS \"              | Change the install location of NEURON using:\")\n  message(STATUS \"              |     cmake <src_path> -DCMAKE_INSTALL_PREFIX=<install_path>\")\n  message(STATUS \"--------------+--------------------------------------------------------------\")\n  message(STATUS \"Build option  | Status\")\n  message(STATUS \"--------------+--------------------------------------------------------------\")\n  message(STATUS \"BUILD_TYPE    | ${CMAKE_BUILD_TYPE} (allowed: ${allowableBuildTypes})\")\n  message(STATUS \"SHARED        | ${IV_ENABLE_SHARED}\")\n  if (X11_FOUND)\n    message(STATUS \"X11_DYNAMIC   | ${IV_ENABLE_X11_DYNAMIC}\")\n    if (IV_ENABLE_X11_DYNAMIC_MAKE_HEADERS)\n    message(STATUS \"              |   ...MAKE_HEADERS=${IV_ENABLE_X11_DYNAMIC_MAKE_HEADERS}\")\n    endif()\n  endif()\n  message(STATUS \"--------------+--------------------------------------------------------------\")\n  message(STATUS \" See more : https://github.com/neuronsimulator/iv\")\n  message(STATUS \"--------------+--------------------------------------------------------------\")\nendif()\nmessage(STATUS \"\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/iv/src/lib/x11_dynam/ivx11_dynam.cpp": "extern \"C\" {\n\n/* All X11 structures, declarations, etc. */\n/* Do not know if this is needed here. */\n#define XUTIL_DEFINE_FUNCTIONS\n\n/* X11 structures, #define, and pointer definitions corresponding\n * to all extern X globals.\n*/\n#include <IV-X11/ivx11_declare.h>\n#define IVX11EXTERN /**/\n#include <IV-X11/ivx11_define.h>\n\n}\n\n#include <stdio.h>\n#include <dlfcn.h>\n#include <string>\n#include <IV-X11/ivx11_dynam.h>\n\nstatic void (*p_ivx11_assign)();\n\n/** @brief dlopen libivx11dynam.so and call its ivx11_assign.\n *  The library must be in the same directory as the shared library\n *  that contains the address of ivx11_dyload.\n */\nint ivx11_dyload() { // return 0 on success\n  /* only load once */\n  if (p_ivx11_assign) {\n    return 0;\n  }\n\n  /* see if ivx11_assign already loaded and if so use that */\n  p_ivx11_assign = (void(*)())dlsym(RTLD_DEFAULT, \"ivx11_assign\");\n  if (p_ivx11_assign) {\n    (*p_ivx11_assign)();\n    return 0;\n  }\n  /* dynamically load libivx11dynam.so and call its ivx11_assign() */\n\n  /* figure out path of libivx11dynam.so\n   * Assumes that library is in the same location as the library containing\n   * this function.\n   */\n  Dl_info info;\n  int rval = dladdr((void*)ivx11_dyload, &info);\n  std::string name;\n  if (rval) {\n    if (info.dli_fname) {\n      name = info.dli_fname;\n      if (info.dli_fname[0] == '/') { // likely full path\n        // dlopen this with RTLD_GLOBAL to make sure the dlopen of libivx11dynam\n        // will get its externs resolved (needed when launch python).\n        if (!dlopen(name.c_str(), RTLD_NOW | RTLD_NOLOAD | RTLD_GLOBAL)) {\n          printf(\"%s: RTLD_GLOBAL for %s\\n\", dlerror(), name.c_str());\n          return -1;\n        }\n\n        /* From the last '/' to the next '.' gets replaced by libivx11dynam */\n        size_t last_slash = name.rfind(\"/\");\n        size_t dot = name.find(\".\", last_slash);\n        if (dot == std::string::npos) {\n            printf(\"Can't determine the basename (last '/' to next '.') in \\\"%s\\\"\\n\", name.c_str());\n            return -1;\n        }\n        size_t len = dot - (last_slash + 1);\n        name.replace(last_slash+1, len, \"libivx11dynam\"); // keeps the .so or .dylib\n      }else{\n        printf(\"Not a full path \\\"%s\\\"\\n\", name.c_str());\n        return -1;\n      }\n    }else{\n      printf(\"dladdr no DL_info.dli_fname\\n\");\n      return -1;\n    }\n  }else{\n    printf(\"%s\\n\", dlerror());\n    return -1;\n  }\n\n  int flag = RTLD_NOW | RTLD_GLOBAL;\n  void* handle = dlopen(name.c_str(), flag);\n  if (!handle) {\n    //be quiet\n    //printf(\"%s: for %s\\n\", dlerror(), name.c_str());\n    return -1;\n  }\n  p_ivx11_assign = (void(*)())dlsym(handle, \"ivx11_assign\");\n  if (p_ivx11_assign) {\n    (*p_ivx11_assign)();\n  }else{\n    return -1;\n  }\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/iv/src/include/IV-X11/ivx11_dynam.h": "/* If libX11 is not available, an Application can still work without it.\n * Everything works normally if it is available.\n */\n \n#ifndef ivx11_dynam_h\n#define ivx11_dynam_h\n\nextern \"C\" {\n\n#if defined(IVX11_DYNAM)\n/** @brief dlopen libivx11dynam.so and call its ivx11_assign.\n *  The library must be in the same directory as the shared library\n *  that contains the address of ivx11_dyload.\n *  Return 0 if libivx11dynam is successfully loaded.\n *  InterViews must be built with the cmake option\n *  -DIV_ENABLE_X11_DYNAMIC=ON\n */\nint ivx11_dyload();\n#endif\n\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/CMakeLists.txt": "set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin/test)\n\ninclude_directories(${PROJECT_SOURCE_DIR}/test ${PROJECT_SOURCE_DIR}/src/nrnoc\n                    ${PROJECT_SOURCE_DIR}/src/nrniv ${PROJECT_SOURCE_DIR}/src/oc)\n\n# =============================================================================\n# Test executables\n# =============================================================================\nset(TEST_SOURCES unit_tests/oc/hoc_interpreter.cpp)\nadd_executable(testneuron unit_tests/unit_test.cpp ${TEST_SOURCES})\ntarget_compile_features(testneuron PUBLIC cxx_std_11)\ntarget_link_libraries(testneuron Catch2::Catch2 nrniv_lib ${CMAKE_THREAD_LIBS_INIT})\nif(NOT MINGW)\n  target_link_libraries(testneuron ${CMAKE_DL_LIBS})\nendif()\n\n# =============================================================================\n# Copy necessary hoc files to build directory if they have not been copied yet\n# =============================================================================\nadd_custom_command(\n  TARGET testneuron POST_BUILD\n  COMMAND ${CMAKE_COMMAND} -E copy_directory ${PROJECT_SOURCE_DIR}/share/lib\n          ${PROJECT_BINARY_DIR}/share/nrn/lib)\n\n# Note that DYLD_LIBRARY_PATH is not required and interfere with dlopen\nset(TEST_ENV\n    NEURONHOME=${PROJECT_BINARY_DIR}/share/nrn NRNHOME=${PROJECT_BINARY_DIR}\n    LD_LIBRARY_PATH=${PROJECT_BINARY_DIR}/lib:$ENV{LD_LIBRARY_PATH})\nif(NRN_ENABLE_PYTHON)\n  list(\n    APPEND\n      TEST_ENV\n      PYTHONPATH=${PROJECT_BINARY_DIR}/lib/python:${PROJECT_SOURCE_DIR}/test/rxd:$ENV{PYTHONPATH})\nendif()\n\nset(TESTS \"\")\n\n# =============================================================================\n# Use add_test method and set environment for testneuron (NEURONHOME env variable needs to be set to\n# run testneuron and other tests based on nrniv)\n# =============================================================================\nforeach(test_name testneuron)\n  add_test(NAME ${test_name} COMMAND ${test_name})\n  list(APPEND TESTS ${test_name})\nendforeach()\n\n# =============================================================================\n# Add ringtest\n# =============================================================================\nset(RINGTEST_DIR ${PROJECT_SOURCE_DIR}/test/ringtest)\nadd_test(\n  ringtest\n  ${CMAKE_COMMAND}\n  -Dexecutable=${CMAKE_BINARY_DIR}/bin/nrniv\n  -Dexec_arg=ring.hoc\n  -Dout_file=out.dat\n  -Dref_file=out.dat.ref\n  -Dwork_dir=${RINGTEST_DIR}\n  -P\n  ${PROJECT_SOURCE_DIR}/cmake/RunHOCTest.cmake)\nlist(APPEND TESTS ringtest)\n\n# =============================================================================\n# Add small hoc test\n# =============================================================================\nset(HOCTEST_DIR ${PROJECT_SOURCE_DIR}/test/hoc_tests/connect_dend)\nif(NRN_ENABLE_CORENEURON)\n  set(REF_FILE cell3soma.core.dat.ref)\nelse()\n  set(REF_FILE cell3soma.dat.ref)\nendif()\nadd_test(\n  connect_dend\n  ${CMAKE_COMMAND}\n  -Dexecutable=${CMAKE_BINARY_DIR}/bin/nrniv\n  -Dexec_arg=connect_dend.hoc\n  -Dout_file=cell3soma.dat\n  -Dref_file=${REF_FILE}\n  -Dwork_dir=${HOCTEST_DIR}\n  -P\n  ${PROJECT_SOURCE_DIR}/cmake/RunHOCTest.cmake)\nlist(APPEND TESTS connect_dend)\n\n# =============================================================================\n# Add pytest\n# =============================================================================\nif(NRN_ENABLE_PYTHON AND PYTEST_FOUND)\n  add_test(NAME basic_tests COMMAND ${PYTHON_EXECUTABLE} -m pytest ${PROJECT_SOURCE_DIR}/test/pynrn)\n  add_custom_target(\n    rxdmod ALL\n    COMMAND\n      ${CMAKE_COMMAND} -E env ${TEST_ENV} $ENV{SHELL} ${CMAKE_BINARY_DIR}/bin/nrnivmodl ./ecs\n    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}/test/rxd)\n  add_dependencies(rxdmod nrniv)\n  add_test(NAME rxd_tests COMMAND ${PYTHON_EXECUTABLE} -m pytest ${PROJECT_SOURCE_DIR}/test/rxd)\n  list(APPEND TESTS basic_tests rxd_tests)\n  if(NRN_ENABLE_MPI)\n    find_python_module(mpi4py)\n    if(mpi4py_FOUND)\n      add_test(\n        NAME rxd_mpi_tests\n        COMMAND\n          ${MPIEXEC} -np 1 ${PYTHON_EXECUTABLE} -m pytest ${PROJECT_SOURCE_DIR}/test/rxd --mpi)\n      list(APPEND TESTS rxd_mpi_tests)\n    endif()\n  endif()\n\n  if(NRN_ENABLE_CORENEURON)\n    file(COPY ${PROJECT_SOURCE_DIR}/test/coreneuron/mod DESTINATION ${PROJECT_BINARY_DIR}/test/)\n    add_custom_target(\n      coreneuron_mod ALL\n      COMMAND\n        ${CMAKE_COMMAND} -E env ${TEST_ENV} $ENV{SHELL} ${CMAKE_BINARY_DIR}/bin/nrnivmodl .\n      COMMAND\n        ${CMAKE_COMMAND} -E env ${TEST_ENV} $ENV{SHELL} ${CMAKE_BINARY_DIR}/bin/nrnivmodl-core .\n       WORKING_DIRECTORY ${PROJECT_BINARY_DIR}/test/mod)\n    add_dependencies(coreneuron_mod nrniv nrniv-core)\n\n    add_test(NAME coreneuron_direct_py COMMAND ${PYTHON_EXECUTABLE}\n                                            ${PROJECT_SOURCE_DIR}/test/coreneuron/test_direct.py\n                                    WORKING_DIRECTORY ${PROJECT_BINARY_DIR}/test/mod)\n    add_test(NAME coreneuron_direct_hoc COMMAND ${CMAKE_BINARY_DIR}/bin/nrniv\n                                            ${PROJECT_SOURCE_DIR}/test/coreneuron/test_direct.hoc\n                                    WORKING_DIRECTORY ${PROJECT_BINARY_DIR}/test/mod)\n    list(APPEND TESTS coreneuron_direct_py coreneuron_direct_hoc)\n  endif()\nendif()\nset_tests_properties(${TESTS} PROPERTIES ENVIRONMENT \"${TEST_ENV}\")\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/mac/nrngui.icns",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/mac/nrniv.icns",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/mac/neurondemo.icns",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/mac/modlunit.icns",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/mac/mos2nrn.icns",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/mac/idraw.icns",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/mac/mknrndll.icns",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/mswin/nmodl2a.ico",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/mswin/nrniv10.ico",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/mswin/nrniv.ico",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/mswin/bin/mkdllbox.bat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/mswin/bin/instlzp.bat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/src/mswin/wnrnbbs/ddesrvr.ico",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/objects/pack/pack-5e5f04cba74deee667782831c6b4dec0d83c4a14.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/objects/pack/pack-5e5f04cba74deee667782831c6b4dec0d83c4a14.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/objects/pack/pack-3d0769e8bc9d53ffebfb101da3b5add8c7852883.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/objects/pack/pack-3d0769e8bc9d53ffebfb101da3b5add8c7852883.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/Random123/objects/pack/pack-b5b66c51dc254902cf72f01cf1d62856d7067ee6.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/Random123/objects/pack/pack-b5b66c51dc254902cf72f01cf1d62856d7067ee6.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/objects/pack/pack-5973e548386cf6d3893a3e202219e52ca3d58d99.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/objects/pack/pack-5973e548386cf6d3893a3e202219e52ca3d58d99.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/ext/fmt/objects/pack/pack-4060648ae22672e32d5a02c79864b8a66a1abfbc.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/ext/fmt/objects/pack/pack-4060648ae22672e32d5a02c79864b8a66a1abfbc.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/ext/cli11/objects/pack/pack-624313f1a2bd00e50211131e51d636aed411c23a.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/ext/cli11/objects/pack/pack-624313f1a2bd00e50211131e51d636aed411c23a.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/ext/cli11/modules/extern/googletest/objects/pack/pack-38551824259614d687467a17022493ef286019e5.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/ext/cli11/modules/extern/googletest/objects/pack/pack-38551824259614d687467a17022493ef286019e5.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/ext/pybind11/objects/pack/pack-1c6bb409b17f18c7b285f8ecefe7b1f2e887dd2d.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/ext/pybind11/objects/pack/pack-1c6bb409b17f18c7b285f8ecefe7b1f2e887dd2d.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/ext/pybind11/modules/tools/clang/objects/pack/pack-7a1f279894ad4c01ef7af9ab88b9f2fc048559a6.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/ext/pybind11/modules/tools/clang/objects/pack/pack-7a1f279894ad4c01ef7af9ab88b9f2fc048559a6.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/ext/eigen/objects/pack/pack-0dc859b63e90f8f066567120afea9cb3270d15cc.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/ext/eigen/objects/pack/pack-0dc859b63e90f8f066567120afea9cb3270d15cc.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/ext/spdlog/objects/pack/pack-7e5bba86348285057abf33b6741c4242572a5a98.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/ext/spdlog/objects/pack/pack-7e5bba86348285057abf33b6741c4242572a5a98.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/cmake/hpc-coding-conventions/objects/pack/pack-a55444b573a5f6675552b568fce6e021f7504ce0.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/nmodl/modules/cmake/hpc-coding-conventions/objects/pack/pack-a55444b573a5f6675552b568fce6e021f7504ce0.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/CLI11/objects/pack/pack-624313f1a2bd00e50211131e51d636aed411c23a.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/CLI11/objects/pack/pack-624313f1a2bd00e50211131e51d636aed411c23a.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/CLI11/modules/extern/googletest/objects/pack/pack-3454c027b2259102d773c5396a18d51457b1c2d7.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/CLI11/modules/extern/googletest/objects/pack/pack-3454c027b2259102d773c5396a18d51457b1c2d7.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/mod2c/objects/pack/pack-c464cf19c92fa3808845793b5fc8200a6fe21edb.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coreneuron/modules/external/mod2c/objects/pack/pack-c464cf19c92fa3808845793b5fc8200a6fe21edb.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coding-conventions/objects/pack/pack-a55444b573a5f6675552b568fce6e021f7504ce0.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/coding-conventions/objects/pack/pack-a55444b573a5f6675552b568fce6e021f7504ce0.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/catch2/objects/pack/pack-ff8b0f92986b4f1447fa0076f948c3b4ef40a59b.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/external/catch2/objects/pack/pack-ff8b0f92986b4f1447fa0076f948c3b4ef40a59b.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/docs/new_doc/objects/pack/pack-04d128d18076a32445c8b8eb52aeadbb2c3ebd7a.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/docs/new_doc/objects/pack/pack-04d128d18076a32445c8b8eb52aeadbb2c3ebd7a.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/docs/py_doc/objects/pack/pack-ad6da48f67ca62e63160741f372bc5639668ca16.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/docs/py_doc/objects/pack/pack-ad6da48f67ca62e63160741f372bc5639668ca16.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/docs/tutorials/objects/pack/pack-7fbbdbe88315ff70789beea080ec568eebc93db2.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/docs/tutorials/objects/pack/pack-7fbbdbe88315ff70789beea080ec568eebc93db2.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/modules/iv/objects/pack/pack-3a2ec595026a3a2bb9c5394224273c4bc39247da.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/.git/modules/modules/iv/objects/pack/pack-3a2ec595026a3a2bb9c5394224273c4bc39247da.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/help_data.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/pure_diffusion_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/hh.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/ca_pump.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/react_region_specified.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/hh_param_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/hh_morph.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/nodes_update.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/hh_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/reaction_test.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/reaction_null_dest.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/include_flux_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/include_flux.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/cabuf.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/reaction_param_test.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/verify_no_initialization_order_issue.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/multicompartment_reactions_with_v.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/multicompartment_reactions_del.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/hh_param.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/cabuf_fixed_step.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/pure_diffusion.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/IraHH.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/multicompartment_reactions.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/multicompartment_mebrane_mismatch.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/wave1d/wave1d_taper_125_1.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/wave1d/wave1d_125_1.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/wave1d/wave1d_tree_125_1.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/wave1d/wave1d_tree2_125_1.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/wave1d/wave1d_25_5.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/wave1d/wave1d_tree2_25_5.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/wave1d/wave1d_tree_25_5.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/wave1d/wave1d_taper_25_5.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/ecs/ecs_example.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/ecs/ecs_multi_example_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/ecs/ecs_example_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/ecs/ecs_multi_example.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/ecs/ecs_before_sections.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/ecs/ecs_include_flux_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/ecs/ecs_include_flux.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/3d/pure_diffusion_3d_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/3d/include_flux3d_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/3d/circadian_rhythm.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/3d/pure_diffusion_3d.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/3d/include_flux3d.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/3d/multicompartment_reactions.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/hybrid/bistable_hybrid.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/hybrid/pure_diffusion_hybrid.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/hybrid/bistable_hybrid_cvode_change_nthread.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/hybrid/bistable_hybrid_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/hybrid/pure_diffusion_hybrid_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/share/lib/python/neuron/rxdtests/correct_data/hybrid/bistable_hybrid_change_nthread.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/tests/integration/ring/12_1.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/tests/integration/ring/13_2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/tests/integration/ring/12_2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/tests/integration/ring_gap/12_1.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/tests/integration/ring_gap/13_2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/tests/integration/ring_gap/12_2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/structr123_1_1AESNI4x32__R.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2mo.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2splitbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/nav_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2pnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/tab_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/structr123_1_1AESNI1xm128i.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/tab_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2mlastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2folderopen.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/tab_a.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2plastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2vertline.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2lastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/sync_on.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2blank.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2link.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/structr123_1_1AESNI4x32.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/open.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2folderclosed.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/bdwn.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/nav_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2ns.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2cl.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/structr123_1_1AESNI1xm128i__R.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/sync_off.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2mnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/closed.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/ftv2node.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/search/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/search/search_m.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/search/search_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/search/mag_sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/Random123/docs/html/search/search_l.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/fmt/doc/_static/fonts/glyphicons-halflings-regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/fmt/doc/_static/fonts/glyphicons-halflings-regular.eot",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/fmt/doc/_static/fonts/glyphicons-halflings-regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/cli11/docs/CLI11_300.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/cli11/docs/CLI11_100.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/pybind11/docs/pybind11_vs_boost_python1.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/pybind11/docs/pybind11-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/pybind11/docs/pybind11_vs_boost_python2.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/eigen/bench/btl/generic_bench/timers/STL_timer.hh",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/eigen/bench/btl/generic_bench/timers/mixed_perf_analyzer.hh",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/eigen/bench/btl/generic_bench/timers/STL_perf_analyzer.hh",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/eigen/bench/btl/generic_bench/utils/size_lin_log.hh",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/eigen/bench/btl/generic_bench/static/intel_bench_fixed_size.hh",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/eigen/bench/btl/generic_bench/static/static_size_generator.hh",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/eigen/doc/ftv2pnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/eigen/doc/Eigen_Silly_Professor_64x64.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/ext/eigen/doc/ftv2node.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/docs/background.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/docs/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/docs/logo.graffle",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/docs/images/nmodl-perf-stats.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/nmodl/docs/images/nmodl.ast.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/CLI11/docs/CLI11_300.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/external/CLI11/docs/CLI11_100.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/coreneuron/doc/binary_file_format.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/catch2/artwork/catch2-c-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/catch2/artwork/catch2-hand-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/external/catch2/artwork/catch2-logo-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_example.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_2d_tort.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_example_cvode_alpha.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_example_alpha_tort.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_2d_alpha_tort.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_example_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d_anisotropic_x_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_example_cvode_alpha_tort.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_include_flux_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_hybrid.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d_anisotropic_y_inhom_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d_anisotropic_z_inhom_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d_anisotropic_x_inhom_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/include_flux3d_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_1d_cvode_tort.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_1d_alpha.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ics_currents_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_1d_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/include_flux.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_2d_alpha.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_1d_cvode_alpha_tort.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d_anisotropic_z.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_2d_cvode_tort.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_hybrid_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_1d.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_2d.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_2d_cvode_alpha.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d_anisotropic_y_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_2d_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/include_flux3d.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_2d_cvode_alpha_tort.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d_anisotropic_x.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_1d_cvode_alpha.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_1d_alpha_tort.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_example_cvode_tort.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ics_currents.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d_anisotropic_z_inhom.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d_inhom.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d_inhom_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_diffusion_1d_tort.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d_anisotropic_x_inhom.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/currents.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_include_flux.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d_anisotropic_y.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/currents_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_example_tort.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/multicompartment_reactions.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d_anisotropic_z_cvode.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/pure_diffusion_3d_anisotropic_y_inhom.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/test/rxd/correct_data/ecs_example_alpha.dat",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/new_doc/images/svclmp.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/new_doc/customthemes/notdefault/static/sidebar.js",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/oldgrph.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/xstatebutton.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/glyphcircle.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/xmenu2.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/random-normal.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/rangevarplot1.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/geometry4.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/graph-align.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/deck-constructor.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/list-browser1.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/texteditor-map.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/boolean_dialog.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/guiwidgets-example.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/list-browser2b.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/section-connection.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/xvalue.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/graph-vector.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/mcran4-graph1.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/xslider.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/xbutton2.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/graph-xexpr.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/random-mcellran4.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/random-negexp.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/VectorPlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/secbrows-select.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/filechooser.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/secbrows-sectionList.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/value_panel.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/mcran4-graph2.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/xvarlabel.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/xradiobutton.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/makeFamily.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/xpvalue.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/xbutton.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/random-lognormal.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/rangevarplot2.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/xmenu1.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/linmod.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/plotsin2.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/random-binomial.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/vector-psth.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/plotsin.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/geometry1.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/graph-menuaction.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/mcran4-xvalue.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/geometry3.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/graph-fastflush.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/vbox-intercept.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/GatherVec.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/ExecCommand.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/vector-line.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/list-browser2.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/svclmp.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/fft2.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/string_dialog.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/symchooser.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/mechanismstandard.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/VecWrap.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/continue_dialog.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/geometry5.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/impedanx-logavsx.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/graph-constructor.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/vector-ploterr.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/geometry2.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/vector-histogram.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/graph-addexpr.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/random-geometric.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/random-poisson.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/vector-plot.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/py_doc/images/fft1.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/scm/images/image8.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/scm/images/image5.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/scm/images/image2.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/scm/images/image1.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/scm/images/image4.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/scm/images/image7.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/scm/images/image3.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/scm/images/image6.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/dev/HOCInterpreter/images/58788144.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/dev/HOCInterpreter/images/51567144.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/dev/HOCInterpreter/images/58788147.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/dev/HOCInterpreter/images/58786474.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/dev/HOCInterpreter/images/58791210.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/dev/HOCInterpreter/images/58791244.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/dev/HOCInterpreter/images/58791243.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/dev/HOCInterpreter/images/51567124.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/dev/HOCInterpreter/images/58788141.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/dev/HOCInterpreter/images/51567143.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/dev/HOCInterpreter/images/58788080.png",
        "/tmp/vanessa/spack-stage/spack-stage-neuron-7.8.1-p7ko6q5qokzi4f5kiigr62vmtm2rz2re/spack-src/docs/dev/HOCInterpreter/images/51567142.png"
    ],
    "total_files": 8022
}