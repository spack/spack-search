{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-icarus-v10_3-zkwcunjz5niqq3sdcjowpzxp4d6ea3ar/spack-src/macosx.txt": "\nThis file describes the procedure to build and install Icarus Verilog\non Mac OS X.  I assume that you have experience with Unix and\nTerminal.app and a basic knowledge of how to download, compile and\ninstall software from source form.\n\nYasuhisa Kato wrote another set of instructions that has also been\nknown to work: <http://adwis.com/verilog/index.html>. You may try\nthose instructions instead of these, although they are essentially\nquite similar.\n\n1)  Obtain and install a libdl compatibility library.\n\n  If you don't already have /usr/local/lib/libdl.{a,dylib} and\n  /usr/local/include/dlfcn.h, you can obtain the source for a\n  compatibility layer from at least one of two places:\n\n  http://download.sourceforge.net/fink/dlcompat-20010831.tar.gz\n  http://www.omnigroup.com/~bungi/dlcompat-20010831.tar.gz\n\n  Unpack this tar file and read the README and Makefile.  Install the\n  library according to the instructions.  Installation in /usr/local\n  is strongly recommended since otherwise autoconf very likely won't\n  be able to find it.\n\n2) Make sure you have a copy of the 'gperf' tool.  This does not come\n   with the Mac OS X 10.1 developer tools, so you probably don't.  You\n   can check with:\n\n     %  which gperf\n\n  If not found, grab a gperf source package and install it. See \"GPERF\n   FOR MACOSX\" below.\n\n  Snapshots of Icarus Verilog source now come with the\n  lexor_keyword.cc file pre-made, so if you have trouble with gperf,\n  then just make sure the distributed lexor_keyword.cc is newer than\n  lexor_keyword.gperf, and use that.\n\n3) If working with source from git, you must run autoconf in the top\n   directory.  This is simplified by the 'autoconf.sh' script at the\n   top of the source tree:\n\n   sh ./autoconf.sh\n\n   This will also run the gperf command, so make sure you've completed\n   step #2 first.\n\n4)  Configure, build and install the Icarus Verilog sources as normal.\n\n  The only change you need to make here is to use a configure command like:\n\n    % CC=\"cc -no-cpp-precomp\" ./configure\n\n  This assumes you are using 'sh', 'zsh', or 'bash'.  If you are using\n  'csh' or 'tcsh', then you'll want something like:\n\n    % setenv CC \"cc -no-cpp-precomp\"\n    % ./configure\n\n  You can, of course, add other configure options.\n\n6) NOTE: 'make check' will not work until after 'make install' has been run\n   since dynamically loaded code is searched for in the install location\n   rather than the build location.  The dlopen emulation library doesn't\n   support a search path option.\n\n   If you are worried about overwriting a working installation with a new,\n   potentially broken one, you can always configure using --prefix=\"/some/path\",\n   and install there to make sure everything is working and then re-configure\n   with the real path you want to install at, make clean, and make install.\n\n5) Done!\n\n\nGPERF FOR MACOSX\n\n  Get version 2.7.2 of gperf from here:\n\n    <ftp://ftp.gnu.org/gnu/gperf/gperf-2.7.2.tar.gz>\n\n  Get a MacosX patch from here:\n\n    http://www.eternal.nest.or.jp/~shiro/binaries/gperf-2.7.2-macosx-patch.gz\n\n  Apply the patch to the gperf-2.7.2 source that you previously\n  downloaded, then follow the remaining gperf installation\n  instructions.\n",
        "/tmp/vanessa/spack-stage/spack-stage-icarus-v10_3-zkwcunjz5niqq3sdcjowpzxp4d6ea3ar/spack-src/t-dll.cc": "/*\n * Copyright (c) 2000-2018 Stephen Williams (steve@icarus.com)\n * Copyright CERN 2013 / Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include \"config.h\"\n\n# include  <iostream>\n\n# include  <cstring>\n# include  <cstdio> // sprintf()\n# include  \"compiler.h\"\n# include  \"t-dll.h\"\n# include  \"netclass.h\"\n# include  \"netmisc.h\"\n# include  \"discipline.h\"\n# include  <cstdlib>\n# include  \"ivl_assert.h\"\n# include  \"ivl_alloc.h\"\n\nstruct dll_target dll_target_obj;\n\n#if defined(__WIN32__)\n\ninline ivl_dll_t ivl_dlopen(const char *name)\n{\n      ivl_dll_t res =  (ivl_dll_t) LoadLibrary(name);\n      return res;\n}\n\n\ninline void * ivl_dlsym(ivl_dll_t dll, const char *nm)\n{\n      return (void*)GetProcAddress((HMODULE)dll, nm);\n}\n\ninline void ivl_dlclose(ivl_dll_t dll)\n{\n      FreeLibrary((HMODULE)dll);\n}\n\nconst char *dlerror(void)\n{\n  static char msg[256];\n  unsigned long err = GetLastError();\n  FormatMessage(\n\t\tFORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\tNULL,\n\t\terr,\n\t\tMAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language\n\t\t(LPTSTR) &msg,\n\t\tsizeof(msg) - 1,\n\t\tNULL\n\t\t);\n  return msg;\n}\n#elif defined(HAVE_DLFCN_H)\ninline ivl_dll_t ivl_dlopen(const char*name)\n{ return dlopen(name,RTLD_LAZY); }\n\ninline void* ivl_dlsym(ivl_dll_t dll, const char*nm)\n{\n      void*sym = dlsym(dll, nm);\n\t/* Not found? try without the leading _ */\n      if (sym == 0 && nm[0] == '_')\n\t    sym = dlsym(dll, nm+1);\n      return sym;\n}\n\ninline void ivl_dlclose(ivl_dll_t dll)\n{ dlclose(dll); }\n\n#elif defined(HAVE_DL_H)\ninline ivl_dll_t ivl_dlopen(const char*name)\n{ return shl_load(name, BIND_IMMEDIATE, 0); }\n\ninline void* ivl_dlsym(ivl_dll_t dll, const char*nm)\n{\n      void*sym;\n      int rc = shl_findsym(&dll, nm, TYPE_PROCEDURE, &sym);\n      return (rc == 0) ? sym : 0;\n}\n\ninline void ivl_dlclose(ivl_dll_t dll)\n{ shl_unload(dll); }\n\ninline const char*dlerror(void)\n{ return strerror( errno ); }\n#endif\n\n/*\n * The custom new operator for the ivl_nexus_s type allows us to\n * allocate nexus objects in blocks. There are generally lots of them\n * permanently allocated, and allocating them in blocks reduces the\n * allocation overhead.\n */\n\ntemplate <class TYPE> void* pool_permalloc(size_t s)\n{\n      static TYPE * pool_ptr = 0;\n      static int pool_remaining = 0;\n      static const size_t POOL_SIZE = 4096;\n\n      assert(s == sizeof(TYPE));\n      if (pool_remaining <= 0) {\n\t    pool_ptr = new TYPE[POOL_SIZE];\n\t    pool_remaining = POOL_SIZE;\n      }\n\n      TYPE*tmp = pool_ptr;\n      pool_ptr += 1;\n      pool_remaining -= 1;\n\n      return tmp;\n}\n\nvoid* ivl_nexus_s::operator new(size_t s)\n{\n      return pool_permalloc<struct ivl_nexus_s>(s);\n}\n\nvoid ivl_nexus_s::operator delete(void*, size_t)\n{\n      assert(0);\n}\n\nvoid* ivl_net_const_s::operator new(size_t s)\n{\n      return pool_permalloc<struct ivl_net_const_s>(s);\n}\n\nvoid ivl_net_const_s::operator delete(void*, size_t)\n{\n      assert(0);\n}\n\nstatic StringHeapLex net_const_strings;\n\nstatic perm_string make_scope_name(const hname_t&name)\n{\n      if (! name.has_numbers())\n\t    return name.peek_name();\n\n      char buf[1024];\n      snprintf(buf, sizeof buf, \"%s\", name.peek_name().str());\n\n      char*cp = buf + strlen(buf);\n      size_t ncp = sizeof buf - (cp-buf);\n\n      for (size_t idx = 0 ; idx < name.has_numbers() ; idx += 1) {\n\t    int len = snprintf(cp, ncp, \"[%d]\", name.peek_number(idx));\n\t    cp += len;\n\t    ncp -= len;\n      }\n\n      return lex_strings.make(buf);\n}\n\nstatic void drive_from_link(const Link&lnk, ivl_drive_t&drv0, ivl_drive_t&drv1)\n{\n      drv0 = lnk.drive0();\n      drv1 = lnk.drive1();\n}\n\nivl_attribute_s* dll_target::fill_in_attributes(const Attrib*net)\n{\n      ivl_attribute_s*attr;\n      unsigned nattr = net->attr_cnt();\n\n      if (nattr == 0)\n\t    return 0;\n\n      attr = new struct ivl_attribute_s[nattr];\n\n      for (unsigned idx = 0 ;  idx < nattr ;  idx += 1) {\n\t    verinum tmp = net->attr_value(idx);\n\t    attr[idx].key = net->attr_key(idx);\n\t    if (tmp.is_string()) {\n\t\t  attr[idx].type = IVL_ATT_STR;\n\t\t  attr[idx].val.str = strings_.add(tmp.as_string().c_str());\n\n\t    } else if (tmp == verinum()) {\n\t\t  attr[idx].type = IVL_ATT_VOID;\n\n\t    } else {\n\t\t  attr[idx].type = IVL_ATT_NUM;\n\t\t  attr[idx].val.num = tmp.as_long();\n\t    }\n      }\n\n      return attr;\n}\n\n/*\n * This function locates an ivl_scope_t object that matches the\n * NetScope object. The search works by looking for the parent scope,\n * then scanning the parent scope for the NetScope object.\n */\nstatic ivl_scope_t find_scope_from_root(ivl_scope_t root, const NetScope*cur)\n{\n      if (const NetScope*par = cur->parent()) {\n\t    ivl_scope_t parent = find_scope_from_root(root, par);\n\t    if (parent == 0) {\n\t\t  return 0;\n\t    }\n\n\t    map<hname_t,ivl_scope_t>::iterator idx = parent->children.find(cur->fullname());\n\t    if (idx == parent->children.end())\n\t\t  return 0;\n\t    else\n\t\t  return idx->second;\n\n      } else {\n\t    perm_string cur_name = make_scope_name(cur->fullname());\n\t    if (strcmp(root->name_, cur_name) == 0)\n\t\t  return root;\n      }\n\n      return 0;\n}\n\nivl_scope_t dll_target::find_scope(ivl_design_s &des, const NetScope*cur)\n{\n      assert(cur);\n\n\t// If the scope is a PACKAGE, then it is a special kind of\n\t// root scope and it in the packages array instead.\n      if (cur->type() == NetScope::PACKAGE) {\n\t    perm_string cur_name = cur->module_name();\n\t    for (size_t idx = 0 ; idx < des.packages.size() ; idx += 1) {\n\t\t  if (des.packages[idx]->name_ == cur_name)\n\t\t\treturn des.packages[idx];\n\t    }\n\t    return 0;\n      }\n\n      if (cur->type() == NetScope::CLASS) {\n\t    ivl_scope_t tmp = des.classes[cur];\n\t    return tmp;\n      }\n\n      if (cur->type()==NetScope::TASK || cur->type()==NetScope::FUNC) {\n\t    map<const NetScope*,ivl_scope_t>::const_iterator idx = des.root_tasks.find(cur);\n\t    if (idx != des.root_tasks.end())\n\t\t  return idx->second;\n      }\n\n      for (unsigned idx = 0; idx < des.roots.size(); idx += 1) {\n\t    assert(des.roots[idx]);\n\t    ivl_scope_t scope = find_scope_from_root(des.roots[idx], cur);\n\t    if (scope)\n\t\t  return scope;\n      }\n\n      for (size_t idx = 0; idx < des.packages.size(); idx += 1) {\n\t    assert(des.packages[idx]);\n\t    ivl_scope_t scope = find_scope_from_root(des.packages[idx], cur);\n\t    if (scope)\n\t\t  return scope;\n      }\n\n      for (map<const NetScope*,ivl_scope_t>::iterator idx = des.classes.begin()\n\t\t ; idx != des.classes.end() ; ++ idx) {\n\t    ivl_scope_t scope = find_scope_from_root(idx->second, cur);\n\t    if (scope)\n\t\t  return scope;\n      }\n\n      for (map<const NetScope*,ivl_scope_t>::iterator idx = des.root_tasks.begin()\n\t\t ; idx != des.root_tasks.end() ; ++ idx) {\n\t    ivl_scope_t scope = find_scope_from_root(idx->second, cur);\n\t    if (scope)\n\t\t  return scope;\n      }\n\n      return 0;\n}\n\nivl_scope_t dll_target::lookup_scope_(const NetScope*cur)\n{\n      return find_scope(des_, cur);\n}\n\n/*\n * This is a convenience function to locate an ivl_signal_t object\n * given the NetESignal that has the signal name.\n */\nivl_signal_t dll_target::find_signal(ivl_design_s &des, const NetNet*net)\n{\n      ivl_scope_t scope = find_scope(des, net->scope());\n      assert(scope);\n\n      perm_string nname = net->name();\n\n      for (unsigned idx = 0 ;  idx < scope->sigs_.size() ;  idx += 1) {\n\t    if (strcmp(scope->sigs_[idx]->name_, nname) == 0)\n\t\t  return scope->sigs_[idx];\n      }\n\n      assert(0);\n      return 0;\n}\n\nstatic ivl_nexus_t nexus_sig_make(ivl_signal_t net, unsigned pin)\n{\n      ivl_nexus_t tmp = new struct ivl_nexus_s;\n      tmp->ptrs_.resize(1);\n      tmp->ptrs_[0].pin_   = pin;\n      tmp->ptrs_[0].type_  = __NEXUS_PTR_SIG;\n      tmp->ptrs_[0].l.sig  = net;\n\n      ivl_drive_t drive = IVL_DR_HiZ;\n      switch (ivl_signal_type(net)) {\n\t  case IVL_SIT_REG:\n\t    drive = IVL_DR_STRONG;\n\t    break;\n\t  default:\n\t    break;\n      }\n      tmp->ptrs_[0].drive0 = drive;\n      tmp->ptrs_[0].drive1 = drive;\n\n      return tmp;\n}\n\nstatic void nexus_sig_add(ivl_nexus_t nex, ivl_signal_t net, unsigned pin)\n{\n      unsigned top = nex->ptrs_.size();\n      nex->ptrs_.resize(top+1);\n      ivl_drive_t drive = IVL_DR_HiZ;\n      switch (ivl_signal_type(net)) {\n\t  case IVL_SIT_REG:\n\t    drive = IVL_DR_STRONG;\n\t    break;\n\t  default:\n\t    break;\n      }\n\n      nex->ptrs_[top].type_= __NEXUS_PTR_SIG;\n      nex->ptrs_[top].drive0 = drive;\n      nex->ptrs_[top].drive1 = drive;\n      nex->ptrs_[top].pin_ = pin;\n      nex->ptrs_[top].l.sig= net;\n}\n\nstatic void nexus_bra_add(ivl_nexus_t nex, ivl_branch_t net, unsigned pin)\n{\n      unsigned top = nex->ptrs_.size();\n      nex->ptrs_.resize(top+1);\n      nex->ptrs_[top].type_= __NEXUS_PTR_BRA;\n      nex->ptrs_[top].drive0 = 0;\n      nex->ptrs_[top].drive1 = 0;\n      nex->ptrs_[top].pin_ = pin;\n      nex->ptrs_[top].l.bra= net;\n}\n\n/*\n * Add the pin of the logic object to the nexus, and return the nexus\n * pointer used for the pin.\n *\n * NOTE: This pointer is only valid until another pin is added to the\n * nexus.\n */\nstatic ivl_nexus_ptr_t nexus_log_add(ivl_nexus_t nex,\n\t\t\t\t     ivl_net_logic_t net,\n\t\t\t\t     unsigned pin)\n{\n      unsigned top = nex->ptrs_.size();\n      nex->ptrs_.resize(top+1);\n\n      nex->ptrs_[top].type_= __NEXUS_PTR_LOG;\n      nex->ptrs_[top].drive0 = (pin == 0)? IVL_DR_STRONG : IVL_DR_HiZ;\n      nex->ptrs_[top].drive1 = (pin == 0)? IVL_DR_STRONG : IVL_DR_HiZ;\n      nex->ptrs_[top].pin_ = pin;\n      nex->ptrs_[top].l.log= net;\n\n      return & (nex->ptrs_[top]);\n}\n\nstatic void nexus_con_add(ivl_nexus_t nex, ivl_net_const_t net, unsigned pin,\n\t\t\t  ivl_drive_t drive0, ivl_drive_t drive1)\n{\n      unsigned top = nex->ptrs_.size();\n      nex->ptrs_.resize(top+1);\n\n      nex->ptrs_[top].type_= __NEXUS_PTR_CON;\n      nex->ptrs_[top].drive0 = drive0;\n      nex->ptrs_[top].drive1 = drive1;\n      nex->ptrs_[top].pin_ = pin;\n      nex->ptrs_[top].l.con= net;\n}\n\nstatic void nexus_lpm_add(ivl_nexus_t nex, ivl_lpm_t net, unsigned pin,\n\t\t\t  ivl_drive_t drive0, ivl_drive_t drive1)\n{\n      unsigned top = nex->ptrs_.size();\n      nex->ptrs_.resize(top+1);\n\n      nex->ptrs_[top].type_= __NEXUS_PTR_LPM;\n      nex->ptrs_[top].drive0 = drive0;\n      nex->ptrs_[top].drive1 = drive1;\n      nex->ptrs_[top].pin_ = pin;\n      nex->ptrs_[top].l.lpm= net;\n}\n\nstatic void nexus_switch_add(ivl_nexus_t nex, ivl_switch_t net, unsigned pin)\n{\n      unsigned top = nex->ptrs_.size();\n      nex->ptrs_.resize(top+1);\n\n      nex->ptrs_[top].type_= __NEXUS_PTR_SWI;\n      nex->ptrs_[top].drive0 = IVL_DR_HiZ;\n      nex->ptrs_[top].drive1 = IVL_DR_HiZ;\n      nex->ptrs_[top].pin_ = pin;\n      nex->ptrs_[top].l.swi= net;\n}\n\nvoid scope_add_logic(ivl_scope_t scope, ivl_net_logic_t net)\n{\n      if (scope->nlog_ == 0) {\n\t    scope->nlog_ = 1;\n\t    scope->log_ = (ivl_net_logic_t*)malloc(sizeof(ivl_net_logic_t));\n\t    scope->log_[0] = net;\n\n      } else {\n\t    scope->nlog_ += 1;\n\t    scope->log_ = (ivl_net_logic_t*)\n\t\t  realloc(scope->log_, scope->nlog_*sizeof(ivl_net_logic_t));\n\t    scope->log_[scope->nlog_-1] = net;\n      }\n\n}\n\nvoid scope_add_event(ivl_scope_t scope, ivl_event_t net)\n{\n      if (scope->nevent_ == 0) {\n\t    scope->nevent_ = 1;\n\t    scope->event_ = (ivl_event_t*)malloc(sizeof(ivl_event_t));\n\t    scope->event_[0] = net;\n\n      } else {\n\t    scope->nevent_ += 1;\n\t    scope->event_ = (ivl_event_t*)\n\t\t  realloc(scope->event_, scope->nevent_*sizeof(ivl_event_t));\n\t    scope->event_[scope->nevent_-1] = net;\n      }\n\n}\n\nstatic void scope_add_lpm(ivl_scope_t scope, ivl_lpm_t net)\n{\n      if (scope->nlpm_ == 0) {\n\t    assert(scope->lpm_ == 0);\n\t    scope->nlpm_ = 1;\n\t    scope->lpm_ = (ivl_lpm_t*)malloc(sizeof(ivl_lpm_t));\n\t    scope->lpm_[0] = net;\n\n      } else {\n\t    assert(scope->lpm_);\n\t    scope->nlpm_ += 1;\n\t    scope->lpm_   = (ivl_lpm_t*)\n\t\t  realloc(scope->lpm_,\n\t\t\t  scope->nlpm_*sizeof(ivl_lpm_t));\n\t    scope->lpm_[scope->nlpm_-1] = net;\n      }\n}\n\nstatic void scope_add_switch(ivl_scope_t scope, ivl_switch_t net)\n{\n      scope->switches.push_back(net);\n}\n\nivl_parameter_t dll_target::scope_find_param(ivl_scope_t scope,\n\t\t\t\t\t     const char*name)\n{\n      unsigned idx = 0;\n      while (idx < scope->param.size()) {\n\t    if (strcmp(name, scope->param[idx].basename) == 0)\n\t\t  return &scope->param[idx];\n\n\t    idx += 1;\n      }\n\n      return 0;\n}\n\n/*\n * This method scans the parameters of the scope, and makes\n * ivl_parameter_t objects. This involves saving the name and scanning\n * the expression value.\n */\nvoid dll_target::make_scope_parameters(ivl_scope_t scop, const NetScope*net)\n{\n      if (net->parameters.empty()) {\n\t    scop->param.clear();\n\t    return;\n      }\n\n      scop->param.resize(net->parameters.size());\n\n      unsigned idx = 0;\n      typedef map<perm_string,NetScope::param_expr_t>::const_iterator pit_t;\n\n      for (pit_t cur_pit = net->parameters.begin()\n\t\t ; cur_pit != net->parameters.end() ; ++ cur_pit ) {\n\n\t    assert(idx < scop->param.size());\n\t    ivl_parameter_t cur_par = &scop->param[idx];\n\t    cur_par->basename = cur_pit->first;\n            cur_par->local = cur_pit->second.local_flag;\n\t      /* Either both the MSB and LSB expressions are provided or\n\t       * neither are provided. */\n\t    if (cur_pit->second.msb) {\n\t\t  assert(cur_pit->second.lsb);\n\t\t  /* The MSB and LSB expressions must be integral constants. */\n\t\t  const NetEConst *msbc =\n\t\t         dynamic_cast<const NetEConst*>(cur_pit->second.msb);\n\t\t  const NetEConst *lsbc =\n\t\t         dynamic_cast<const NetEConst*>(cur_pit->second.lsb);\n\t\t  assert(msbc);\n\t\t  assert(lsbc);\n\t\t  cur_par->msb = msbc->value().as_long();\n\t\t  cur_par->lsb = lsbc->value().as_long();\n\t    } else {\n\t\t  assert(! cur_pit->second.lsb);\n\t\t  cur_par->msb = cur_pit->second.val->expr_width() - 1;\n\t\t  assert(cur_par->msb >= 0);\n\t\t  cur_par->lsb = 0;\n\t    }\n\t    cur_par->signed_flag = cur_pit->second.signed_flag;\n\t    cur_par->scope = scop;\n\t    FILE_NAME(cur_par, &(cur_pit->second));\n\n\t    NetExpr*etmp = cur_pit->second.val;\n\t    if (etmp == 0) {\n\t\t  cerr << \"?:?: internal error: What is the parameter \"\n\t\t       << \"expression for \" << cur_pit->first\n\t\t       << \" in \" << net->fullname() << \"?\" << endl;\n\t    }\n\t    assert(etmp);\n\t    make_scope_param_expr(cur_par, etmp);\n\t    idx += 1;\n      }\n}\n\nvoid dll_target::make_scope_param_expr(ivl_parameter_t cur_par, NetExpr*etmp)\n{\n      if (const NetEConst*e = dynamic_cast<const NetEConst*>(etmp)) {\n\n\t    expr_const(e);\n\t    assert(expr_);\n\n\t    switch (expr_->type_) {\n\t\tcase IVL_EX_STRING:\n\t\t  expr_->u_.string_.parameter = cur_par;\n\t\t  break;\n\t\tcase IVL_EX_NUMBER:\n\t\t  expr_->u_.number_.parameter = cur_par;\n\t\t  break;\n\t\tdefault:\n\t\t  assert(0);\n\t    }\n\n      } else if (const NetECReal*er = dynamic_cast<const NetECReal*>(etmp)) {\n\n\t    expr_creal(er);\n\t    assert(expr_);\n\t    assert(expr_->type_ == IVL_EX_REALNUM);\n\t    expr_->u_.real_.parameter = cur_par;\n\n      }\n\n      if (expr_ == 0) {\n\t    cerr << etmp->get_fileline() << \": internal error: \"\n\t\t << \"Parameter expression not reduced to constant? \"\n\t\t << *etmp << endl;\n      }\n      ivl_assert(*etmp, expr_);\n\n      cur_par->value = expr_;\n      expr_ = 0;\n}\n\nvoid dll_target::add_root(const NetScope *s)\n{\n      ivl_scope_t root_ = new struct ivl_scope_s;\n      perm_string name = s->basename();\n      root_->name_ = name;\n      FILE_NAME(root_, s);\n      root_->parent = 0;\n      root_->nlog_ = 0;\n      root_->log_ = 0;\n      root_->nevent_ = 0;\n      root_->event_ = 0;\n      root_->nlpm_ = 0;\n      root_->lpm_ = 0;\n      root_->def = 0;\n      make_scope_parameters(root_, s);\n      root_->tname_ = root_->name_;\n      root_->time_precision = s->time_precision();\n      root_->time_units = s->time_unit();\n      root_->nattr = s->attr_cnt();\n      root_->attr  = fill_in_attributes(s);\n      root_->is_auto = 0;\n      root_->is_cell = s->is_cell();\n      switch (s->type()) {\n\t  case NetScope::PACKAGE:\n\t    root_->type_ = IVL_SCT_PACKAGE;\n\t    break;\n\t  case NetScope::MODULE:\n\t    root_->type_ = IVL_SCT_MODULE;\n\t    break;\n\t  case NetScope::CLASS:\n\t    root_->type_ = IVL_SCT_CLASS;\n\t    break;\n\t  case NetScope::TASK: {\n\t\tconst NetTaskDef*def = s->task_def();\n\t\tif (def == 0) {\n\t\t      cerr << \"?:?\" << \": internal error: \"\n\t\t\t   << \"task \" << root_->name_\n\t\t\t   << \" has no definition.\" << endl;\n\t\t}\n\t\tassert(def);\n\t\troot_->type_ = IVL_SCT_TASK;\n\t\troot_->tname_ = def->scope()->basename();\n\t\tbreak;\n\t  }\n\t    break;\n\t  case NetScope::FUNC:\n\t    root_->type_ = IVL_SCT_FUNCTION;\n\t    break;\n\t  default:\n\t    assert(0);\n      }\n\n      switch (s->type()) {\n\t  case NetScope::MODULE:\n\t    root_->ports = s->module_port_nets();\n\t    if (root_->ports > 0) {\n\t\t  root_->u_.net = new NetNet*[root_->ports];\n\t\t  for (unsigned idx = 0; idx < root_->ports; idx += 1) {\n\t\t\troot_->u_.net[idx] = s->module_port_net(idx);\n\t\t  }\n\t    }\n\t    root_->module_ports_info = s->module_port_info();\n\n\t    des_.roots.push_back(root_);\n\t    break;\n\n\t  case NetScope::PACKAGE:\n\t    root_->ports = 0;\n\t    des_.packages.push_back(root_);\n\t    break;\n\n\t  case NetScope::CLASS:\n\t    root_->ports = 0;\n\t    des_.classes[s] = root_;\n\t    break;\n\n\t  case NetScope::TASK:\n\t  case NetScope::FUNC:\n\t    des_.root_tasks[s] = root_;\n\t    break;\n\n\t  default:\n\t    assert(0);\n\t    break;\n      }\n}\n\nbool dll_target::start_design(const Design*des)\n{\n      const char*dll_path_ = des->get_flag(\"DLL\");\n\n      dll_ = ivl_dlopen(dll_path_);\n\n      if ((dll_ == 0) && (dll_path_[0] != '/')) {\n\t    size_t len = strlen(basedir) + 1 + strlen(dll_path_) + 1;\n\t    char*tmp = new char[len];\n\t    sprintf(tmp, \"%s/%s\", basedir, dll_path_);\n\t    dll_ = ivl_dlopen(tmp);\n\t    delete[]tmp;\n      }\n\n      if (dll_ == 0) {\n\t    cerr << \"error: \" << dll_path_ << \" failed to load.\" << endl;\n\t    cerr << dll_path_ << \": \" << dlerror() << endl;\n\t    return false;\n      }\n\n      stmt_cur_ = 0;\n\n\t// Initialize the design object.\n      des_.self = des;\n      des_.time_precision = des->get_precision();\n\n      des_.disciplines.resize(disciplines.size());\n      unsigned idx = 0;\n      for (map<perm_string,ivl_discipline_t>::const_iterator cur = disciplines.begin()\n\t\t ; cur != disciplines.end() ; ++ cur ) {\n\t    des_.disciplines[idx] = cur->second;\n\t    idx += 1;\n      }\n      assert(idx == des_.disciplines.size());\n\n      list<NetScope *> scope_list = des->find_roottask_scopes();\n      for (list<NetScope*>::const_iterator cur = scope_list.begin()\n\t\t ; cur != scope_list.end() ; ++ cur) {\n\t    add_root(*cur);\n      }\n\n      scope_list = des->find_package_scopes();\n      for (list<NetScope*>::const_iterator cur = scope_list.begin()\n\t\t ; cur != scope_list.end(); ++ cur ) {\n\t    add_root(*cur);\n      }\n\n      scope_list = des->find_root_scopes();\n      for (list<NetScope*>::const_iterator cur = scope_list.begin()\n\t\t ; cur != scope_list.end(); ++ cur ) {\n\t    add_root(*cur);\n      }\n\n      target_ = (target_design_f)ivl_dlsym(dll_, LU \"target_design\" TU);\n      if (target_ == 0) {\n\t    cerr << dll_path_ << \": error: target_design entry \"\n\t\t  \"point is missing.\" << endl;\n\t    return false;\n      }\n\n      return true;\n}\n\n/*\n * Here ivl is telling us that the design is scanned completely, and\n * here is where we call the API to process the constructed design.\n */\nint dll_target::end_design(const Design*)\n{\n      int rc;\n      if (errors == 0) {\n\t    if (verbose_flag) {\n\t\t  cout << \" ... invoking target_design\" << endl;\n\t    }\n\n\t    rc = (target_)(&des_);\n      } else {\n\t    if (verbose_flag) {\n\t\t  cout << \" ... skipping target_design due to errors.\" << endl;\n\t    }\n\t    rc = errors;\n      }\n\n      ivl_dlclose(dll_);\n      return rc;\n}\n\nvoid dll_target::switch_attributes(struct ivl_switch_s *obj,\n\t\t\t\t   const NetNode*net)\n{\n      obj->nattr = net->attr_cnt();\n      obj->attr  = fill_in_attributes(net);\n}\n\nvoid dll_target::logic_attributes(struct ivl_net_logic_s *obj,\n\t\t\t\t  const NetNode*net)\n{\n      obj->nattr = net->attr_cnt();\n      obj->attr  = fill_in_attributes(net);\n}\n\nvoid dll_target::make_delays_(ivl_expr_t*delay, const NetObj*net)\n{\n      delay[0] = 0;\n      delay[1] = 0;\n      delay[2] = 0;\n\n\t/* Translate delay expressions to ivl_target form. Try to\n\t   preserve pointer equality, not as a rule but to save on\n\t   expression trees. */\n      if (net->rise_time()) {\n\t    expr_ = 0;\n\t    net->rise_time()->expr_scan(this);\n\t    delay[0] = expr_;\n\t    expr_ = 0;\n      }\n      if (net->fall_time()) {\n\t    if (net->fall_time() == net->rise_time()) {\n\t\t  delay[1] = delay[0];\n\t    } else {\n\t\t  expr_ = 0;\n\t\t  net->fall_time()->expr_scan(this);\n\t\t  delay[1] = expr_;\n\t\t  expr_ = 0;\n\t    }\n      }\n      if (net->decay_time()) {\n\t    if (net->decay_time() == net->rise_time()) {\n\t\t  delay[2] = delay[0];\n\t    } else {\n\t\t  expr_ = 0;\n\t\t  net->decay_time()->expr_scan(this);\n\t\t  delay[2] = expr_;\n\t\t  expr_ = 0;\n\t    }\n      }\n}\n\nvoid dll_target::make_logic_delays_(struct ivl_net_logic_s*obj,\n                                    const NetObj*net)\n{\n      make_delays_(obj->delay, net);\n}\n\nvoid dll_target::make_switch_delays_(struct ivl_switch_s*obj,\n                                    const NetObj*net)\n{\n      make_delays_(obj->delay, net);\n}\n\nvoid dll_target::make_lpm_delays_(struct ivl_lpm_s*obj,\n\t\t\t\t  const NetObj*net)\n{\n      make_delays_(obj->delay, net);\n}\n\nvoid dll_target::make_const_delays_(struct ivl_net_const_s*obj,\n\t\t\t\t    const NetObj*net)\n{\n      make_delays_(obj->delay, net);\n}\n\nbool dll_target::branch(const NetBranch*net)\n{\n      struct ivl_branch_s*obj = net->target_obj();\n      ivl_assert(*net, net->pin_count() == 2);\n\n      assert(net->pin(0).nexus()->t_cookie());\n      obj->pins[0] = net->pin(0).nexus()->t_cookie();\n      nexus_bra_add(obj->pins[0], obj, 0);\n\n      assert(net->pin(1).nexus()->t_cookie());\n      obj->pins[1] = net->pin(1).nexus()->t_cookie();\n      nexus_bra_add(obj->pins[1], obj, 1);\n\n      obj->island = net->get_island();\n\n      return true;\n}\n\n/*\n * Add a bufz object to the scope that contains it.\n *\n * Note that in the ivl_target API a BUFZ device is a special kind of\n * ivl_net_logic_t device, so create an ivl_net_logic_t cookie to\n * handle it.\n */\nbool dll_target::bufz(const NetBUFZ*net)\n{\n      struct ivl_net_logic_s *obj = new struct ivl_net_logic_s;\n\n      assert(net->pin_count() == 2);\n\n      obj->type_ = net->transparent()? IVL_LO_BUFT : IVL_LO_BUFZ;\n      obj->width_= net->width();\n      obj->is_cassign = 0;\n      obj->npins_= 2;\n      obj->pins_ = new ivl_nexus_t[2];\n      FILE_NAME(obj, net);\n\n\t/* Get the ivl_nexus_t objects connected to the two pins.\n\n\t   (We know a priori that the ivl_nexus_t objects have been\n\t   allocated, because the signals have been scanned before\n\t   me. This saves me the trouble of allocating them.) */\n\n      assert(net->pin(0).nexus()->t_cookie());\n      obj->pins_[0] = net->pin(0).nexus()->t_cookie();\n      ivl_nexus_ptr_t out_ptr = nexus_log_add(obj->pins_[0], obj, 0);\n\n      out_ptr->drive0 = net->pin(0).drive0();\n      out_ptr->drive1 = net->pin(0).drive1();\n\n      assert(net->pin(1).nexus()->t_cookie());\n      obj->pins_[1] = net->pin(1).nexus()->t_cookie();\n      nexus_log_add(obj->pins_[1], obj, 1);\n\n\t/* Attach the logic device to the scope that contains it. */\n\n      assert(net->scope());\n      ivl_scope_t scop = find_scope(des_, net->scope());\n      assert(scop);\n\n      obj->scope_ = scop;\n\n      obj->name_ = net->name();\n      logic_attributes(obj, net);\n\n      make_logic_delays_(obj, net);\n\n      scope_add_logic(scop, obj);\n\n      return true;\n}\n\nbool dll_target::class_type(const NetScope*in_scope, netclass_t*net)\n{\n      ivl_scope_t use_scope = find_scope(des_, in_scope);\n      use_scope->classes.push_back(net);\n      return true;\n}\n\nbool dll_target::enumeration(const NetScope*in_scope, netenum_t*net)\n{\n      ivl_scope_t use_scope = find_scope(des_, in_scope);\n      use_scope->enumerations_.push_back(net);\n      return true;\n}\n\nvoid dll_target::event(const NetEvent*net)\n{\n      struct ivl_event_s *obj = new struct ivl_event_s;\n\n      FILE_NAME(obj, net);\n\n      ivl_scope_t scop = find_scope(des_, net->scope());\n      obj->name = net->name();\n      obj->scope = scop;\n      scope_add_event(scop, obj);\n\n      obj->nany = 0;\n      obj->nneg = 0;\n      obj->npos = 0;\n\n      if (net->nprobe() >= 1) {\n\n\t    for (unsigned idx = 0 ;  idx < net->nprobe() ;  idx += 1) {\n\t\t  const NetEvProbe*pr = net->probe(idx);\n\t\t  switch (pr->edge()) {\n\t\t      case NetEvProbe::ANYEDGE:\n\t\t\tobj->nany += pr->pin_count();\n\t\t\tbreak;\n\t\t      case NetEvProbe::NEGEDGE:\n\t\t\tobj->nneg += pr->pin_count();\n\t\t\tbreak;\n\t\t      case NetEvProbe::POSEDGE:\n\t\t\tobj->npos += pr->pin_count();\n\t\t\tbreak;\n\t\t  }\n\t    }\n\n\t    unsigned npins = obj->nany + obj->nneg + obj->npos;\n\t    obj->pins = (ivl_nexus_t*)calloc(npins, sizeof(ivl_nexus_t));\n\n      } else {\n\t    obj->pins  = 0;\n      }\n\n}\n\nvoid dll_target::logic(const NetLogic*net)\n{\n      struct ivl_net_logic_s *obj = new struct ivl_net_logic_s;\n\n      obj->width_ = net->width();\n\n      FILE_NAME(obj, net);\n\n      switch (net->type()) {\n\t  case NetLogic::AND:\n\t    obj->type_ = IVL_LO_AND;\n\t    break;\n\t  case NetLogic::BUF:\n\t    obj->type_ = IVL_LO_BUF;\n\t    break;\n\t  case NetLogic::BUFIF0:\n\t    obj->type_ = IVL_LO_BUFIF0;\n\t    break;\n\t  case NetLogic::BUFIF1:\n\t    obj->type_ = IVL_LO_BUFIF1;\n\t    break;\n\t  case NetLogic::CMOS:\n\t    obj->type_ = IVL_LO_CMOS;\n\t    break;\n\t  case NetLogic::NAND:\n\t    obj->type_ = IVL_LO_NAND;\n\t    break;\n\t  case NetLogic::NMOS:\n\t    obj->type_ = IVL_LO_NMOS;\n\t    break;\n\t  case NetLogic::NOR:\n\t    obj->type_ = IVL_LO_NOR;\n\t    break;\n\t  case NetLogic::NOT:\n\t    obj->type_ = IVL_LO_NOT;\n\t    break;\n\t  case NetLogic::NOTIF0:\n\t    obj->type_ = IVL_LO_NOTIF0;\n\t    break;\n\t  case NetLogic::NOTIF1:\n\t    obj->type_ = IVL_LO_NOTIF1;\n\t    break;\n\t  case NetLogic::OR:\n\t    obj->type_ = IVL_LO_OR;\n\t    break;\n\t  case NetLogic::PULLDOWN:\n\t    obj->type_ = IVL_LO_PULLDOWN;\n\t    break;\n\t  case NetLogic::PULLUP:\n\t    obj->type_ = IVL_LO_PULLUP;\n\t    break;\n\t  case NetLogic::RCMOS:\n\t    obj->type_ = IVL_LO_RCMOS;\n\t    break;\n\t  case NetLogic::RNMOS:\n\t    obj->type_ = IVL_LO_RNMOS;\n\t    break;\n\t  case NetLogic::RPMOS:\n\t    obj->type_ = IVL_LO_RPMOS;\n\t    break;\n\t  case NetLogic::PMOS:\n\t    obj->type_ = IVL_LO_PMOS;\n\t    break;\n\t  case NetLogic::XNOR:\n\t    obj->type_ = IVL_LO_XNOR;\n\t    break;\n\t  case NetLogic::XOR:\n\t    obj->type_ = IVL_LO_XOR;\n\t    break;\n\t  default:\n\t    assert(0);\n\t    obj->type_ = IVL_LO_NONE;\n\t    break;\n      }\n\t/* Some of the logical gates are used to represent operators in a\n\t * continuous assignment, so set a flag if that is the case. */\n      obj->is_cassign = net->is_cassign();\n\n\t/* Connect all the ivl_nexus_t objects to the pins of the\n\t   device. */\n\n      obj->npins_ = net->pin_count();\n      obj->pins_ = new ivl_nexus_t[obj->npins_];\n\n      for (unsigned idx = 0 ;  idx < obj->npins_ ;  idx += 1) {\n\t    const Nexus*nex = net->pin(idx).nexus();\n\t    assert(nex->t_cookie());\n\t    obj->pins_[idx] = nex->t_cookie();\n\t    ivl_nexus_ptr_t tmp = nexus_log_add(obj->pins_[idx], obj, idx);\n\t    if (idx == 0) {\n\t\t  tmp->drive0 = net->pin(0).drive0();\n\t\t  tmp->drive1 = net->pin(0).drive1();\n\t    }\n      }\n\n      assert(net->scope());\n      ivl_scope_t scop = find_scope(des_, net->scope());\n      assert(scop);\n\n      obj->scope_= scop;\n      obj->name_ = net->name();\n\n      logic_attributes(obj, net);\n\n      make_logic_delays_(obj, net);\n\n      scope_add_logic(scop, obj);\n}\n\nbool dll_target::tran(const NetTran*net)\n{\n      struct ivl_switch_s*obj = new struct ivl_switch_s;\n      obj->type = net->type();\n      obj->width = net->vector_width();\n      obj->part = 0;\n      obj->offset = 0;\n      obj->name = net->name();\n      obj->scope = find_scope(des_, net->scope());\n      obj->island = net->get_island();\n      assert(obj->scope);\n      assert(obj->island);\n      FILE_NAME(obj, net);\n\n      const Nexus*nex;\n\n      nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n      obj->pins[0] = nex->t_cookie();\n\n      nex = net->pin(1).nexus();\n      assert(nex->t_cookie());\n      obj->pins[1] = nex->t_cookie();\n\n      nexus_switch_add(obj->pins[0], obj, 0);\n      nexus_switch_add(obj->pins[1], obj, 1);\n\n      if (net->pin_count() > 2) {\n\t    nex = net->pin(2).nexus();\n\t    assert(nex->t_cookie());\n\t    obj->pins[2] = nex->t_cookie();\n\t    nexus_switch_add(obj->pins[2], obj, 2);\n      } else {\n\t    obj->pins[2] = 0;\n      }\n\n      if (obj->type == IVL_SW_TRAN_VP) {\n\t    obj->part  = net->part_width();\n\t    obj->offset= net->part_offset();\n      }\n\n      switch_attributes(obj, net);\n      make_switch_delays_(obj, net);\n      scope_add_switch(obj->scope, obj);\n\n      return true;\n}\n\nbool dll_target::substitute(const NetSubstitute*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_SUBSTITUTE;\n      obj->name = net->name();\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = net->width();\n      obj->u_.substitute.base = net->base();\n\n      obj->u_.substitute.q = net->pin(0).nexus()->t_cookie();\n      obj->u_.substitute.a = net->pin(1).nexus()->t_cookie();\n      obj->u_.substitute.s = net->pin(2).nexus()->t_cookie();\n      nexus_lpm_add(obj->u_.substitute.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n      nexus_lpm_add(obj->u_.substitute.a, obj, 0, IVL_DR_HiZ,    IVL_DR_HiZ);\n      nexus_lpm_add(obj->u_.substitute.s, obj, 0, IVL_DR_HiZ,    IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\nbool dll_target::sign_extend(const NetSignExtend*net)\n{\n      struct ivl_lpm_s*obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_SIGN_EXT;\n      obj->width = net->width();\n      obj->name = net->name();\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      const Nexus*nex;\n\n      nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.reduce.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.reduce.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin(1).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.reduce.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.reduce.a, obj, 1, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\nbool dll_target::ureduce(const NetUReduce*net)\n{\n      struct ivl_lpm_s*obj = new struct ivl_lpm_s;\n      switch (net->type()) {\n\t  case NetUReduce::NONE:\n\t    assert(0);\n\t    delete obj;\n\t    return false;\n\t  case NetUReduce::AND:\n\t    obj->type = IVL_LPM_RE_AND;\n\t    break;\n\t  case NetUReduce::OR:\n\t    obj->type = IVL_LPM_RE_OR;\n\t    break;\n\t  case NetUReduce::XOR:\n\t    obj->type = IVL_LPM_RE_XOR;\n\t    break;\n\t  case NetUReduce::NAND:\n\t    obj->type = IVL_LPM_RE_NAND;\n\t    break;\n\t  case NetUReduce::NOR:\n\t    obj->type = IVL_LPM_RE_NOR;\n\t    break;\n\t  case NetUReduce::XNOR:\n\t    obj->type = IVL_LPM_RE_XNOR;\n\t    break;\n      }\n\n      obj->name = net->name();\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = net->width();\n\n      const Nexus*nex;\n\n      nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.reduce.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.reduce.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin(1).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.reduce.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.reduce.a, obj, 1, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\nvoid dll_target::net_case_cmp(const NetCaseCmp*net)\n{\n      struct ivl_lpm_s*obj = new struct ivl_lpm_s;\n      switch (net->kind()) {\n\t  case NetCaseCmp::EEQ:\n\t    obj->type = IVL_LPM_CMP_EEQ;\n\t    break;\n\t  case NetCaseCmp::NEQ:\n\t    obj->type = IVL_LPM_CMP_NEE;\n\t    break;\n\t  case NetCaseCmp::XEQ:\n\t      obj->type = IVL_LPM_CMP_EQX;\n\t    break;\n\t  case NetCaseCmp::ZEQ:\n\t    obj->type = IVL_LPM_CMP_EQZ;\n\t    break;\n      }\n      obj->name  = net->name();\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = net->width();\n      obj->u_.arith.signed_flag = 0;\n\n      const Nexus*nex;\n\n      nex = net->pin(1).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin(2).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.b = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.b, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nivl_event_t dll_target::make_lpm_trigger(const NetEvWait*net)\n{\n      ivl_event_t trigger = 0;\n      if (net) {\n            const NetEvent*ev = net->event(0);\n\n              /* Locate the event by name. */\n            ivl_scope_t ev_scope = lookup_scope_(ev->scope());\n\n            assert(ev_scope);\n            assert(ev_scope->nevent_ > 0);\n            for (unsigned idx = 0;  idx < ev_scope->nevent_; idx += 1) {\n                  const char*ename =\n                        ivl_event_basename(ev_scope->event_[idx]);\n                  if (strcmp(ev->name(), ename) == 0) {\n                        trigger = ev_scope->event_[idx];\n                        break;\n                  }\n            }\n\n              /* Connect up the probe pins. This wasn't done during the\n                 ::event method because the signals weren't scanned yet. */\n            assert(ev->nprobe() == 1);\n            const NetEvProbe*pr = ev->probe(0);\n            for (unsigned bit = 0; bit < pr->pin_count(); bit += 1) {\n                  ivl_nexus_t nex = (ivl_nexus_t)\n                        pr->pin(bit).nexus()->t_cookie();\n                  assert(nex);\n                  trigger->pins[bit] = nex;\n            }\n      }\n      return trigger;\n}\n\nbool dll_target::net_sysfunction(const NetSysFunc*net)\n{\n      unsigned idx;\n      const Nexus*nex;\n\n      struct ivl_lpm_s*obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_SFUNC;\n      obj->name  = net->name();\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->u_.sfunc.ports = net->pin_count();\n\n      assert(net->pin_count() >= 1);\n      obj->width = net->vector_width();\n\n      obj->u_.sfunc.fun_name = net->func_name();\n\n      obj->u_.sfunc.pins = new ivl_nexus_t[net->pin_count()];\n\n      nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.sfunc.pins[0] = nex->t_cookie();\n      nexus_lpm_add(obj->u_.sfunc.pins[0], obj, 0,\n\t\t    IVL_DR_STRONG, IVL_DR_STRONG);\n\n      for (idx = 1 ;  idx < net->pin_count() ;  idx += 1) {\n\t    nex = net->pin(idx).nexus();\n\t    assert(nex->t_cookie());\n\n\t    obj->u_.sfunc.pins[idx] = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.sfunc.pins[idx], obj, 0,\n\t\t\t  IVL_DR_HiZ, IVL_DR_HiZ);\n      }\n\n\t/* Save information about the trigger event if it exists. */\n      obj->u_.sfunc.trigger = make_lpm_trigger(net->trigger());\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n      return true;\n}\n\n/*\n * An IVL_LPM_UFUNC represents a node in a combinational expression\n * that calls a user defined function. I create an LPM object that has\n * the right connections, and refers to the ivl_scope_t of the\n * definition.\n */\nbool dll_target::net_function(const NetUserFunc*net)\n{\n      struct ivl_lpm_s*obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_UFUNC;\n      obj->name  = net->name();\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n\t/* Get the definition of the function and save it. */\n      const NetScope*def = net->def();\n      assert(def);\n\n      obj->u_.ufunc.def = lookup_scope_(def);\n\n\t/* Save information about the ports in the ivl_lpm_s\n\t   structure. Note that port 0 is the return value. */\n      obj->u_.ufunc.ports = net->pin_count();\n\n      assert(net->pin_count() >= 1);\n      obj->width = net->port_width(0);\n\n\t/* Now collect all the pins and connect them to the nexa of\n\t   the net. The output pins have strong drive, and the\n\t   remaining input pins are HiZ. */\n\n      obj->u_.ufunc.pins = new ivl_nexus_t[net->pin_count()];\n\n      for (unsigned idx = 0 ;  idx < net->pin_count() ;  idx += 1) {\n\t    const Nexus*nex = net->pin(idx).nexus();\n\t    assert(nex->t_cookie());\n\t    ivl_nexus_t nn = nex->t_cookie();\n\t    assert(nn);\n\n\t    obj->u_.ufunc.pins[idx] = nn;\n\t    ivl_drive_t drive = idx == 0 ? IVL_DR_STRONG : IVL_DR_HiZ;\n\t    nexus_lpm_add(obj->u_.ufunc.pins[idx], obj, idx, drive, drive);\n      }\n\n\t/* Save information about the trigger event if it exists. */\n      obj->u_.ufunc.trigger = make_lpm_trigger(net->trigger());\n\n      make_lpm_delays_(obj, net);\n\n\t/* All done. Add this LPM to the scope. */\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\nvoid dll_target::udp(const NetUDP*net)\n{\n      struct ivl_net_logic_s *obj = new struct ivl_net_logic_s;\n\n      obj->type_ = IVL_LO_UDP;\n      FILE_NAME(obj, net);\n\n\t/* The NetUDP class hasn't learned about width yet, so we\n\t   assume a width of 1. */\n      obj->width_ = 1;\n      obj->is_cassign = 0;\n\n      static map<perm_string,ivl_udp_t> udps;\n      ivl_udp_t u;\n\n      if (udps.find(net->udp_name()) != udps.end()) {\n\t    u = udps[net->udp_name()];\n      } else {\n\t    u = new struct ivl_udp_s;\n\t    u->nrows = net->rows();\n\t    u->table = (ivl_udp_s::ccharp_t*)malloc((u->nrows+1)*sizeof(char*));\n\t    u->table[u->nrows] = 0x0;\n\t    u->nin = net->nin();\n\t    u->sequ = net->is_sequential();\n\t    u->file = net->udp_file();\n\t    u->lineno = net->udp_lineno();\n\t    if (u->sequ) u->init = net->get_initial();\n\t    else u->init = 'x';\n\t    u->name = net->udp_name();\n\t    string inp;\n\t    char out;\n\t    unsigned int i = 0;\n\t    if (net->first(inp, out)) do {\n\t\t  string tt = inp+out;\n\t\t  u->table[i++] = strings_.add(tt.c_str());\n\t    } while (net->next(inp, out));\n\t    assert(i==u->nrows);\n\t    assert((u->nin + 1) == net->port_count());\n\t    u->ports = new string [u->nin + 1];\n\t    for(unsigned idx = 0; idx <= u->nin; idx += 1) {\n\t\t  u->ports[idx] = net->port_name(idx);\n\t    }\n\n\t    udps[net->udp_name()] = u;\n      }\n\n      obj->udp = u;\n\n      // Some duplication of code here, see: dll_target::logic()\n\n        /* Connect all the ivl_nexus_t objects to the pins of the\n\t   device. */\n\n      obj->npins_ = net->pin_count();\n      obj->pins_ = new ivl_nexus_t[obj->npins_];\n      for (unsigned idx = 0 ;  idx < obj->npins_ ;  idx += 1) {\n\t      /* Skip unconnected input pins. These will take on HiZ\n\t\t values by the code generators. */\n\t    if (! net->pin(idx).is_linked()) {\n\t\t  obj->pins_[idx] = 0;\n\t\t  continue;\n\t    }\n\n\t    const Nexus*nex = net->pin(idx).nexus();\n\t    ivl_assert(*net, nex && nex->t_cookie());\n\t    obj->pins_[idx] = nex->t_cookie();\n\t    nexus_log_add(obj->pins_[idx], obj, idx);\n      }\n\n      assert(net->scope());\n      ivl_scope_t scop = find_scope(des_, net->scope());\n      assert(scop);\n\n      obj->scope_= scop;\n      obj->name_ = net->name();\n      FILE_NAME(obj, net);\n\n      make_logic_delays_(obj, net);\n\n      obj->nattr = 0;\n      obj->attr = 0;\n\n      scope_add_logic(scop, obj);\n}\n\nvoid dll_target::lpm_abs(const NetAbs*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_ABS;\n      obj->name = net->name(); // NetAddSub names are permallocated.\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->u_.arith.signed_flag = 0;\n      obj->width = net->width();\n\n      const Nexus*nex;\n\t/* the output is pin(0) */\n      nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin(1).nexus();\n      assert(nex->t_cookie());\n\n\t/* pin(1) is the input data. */\n      obj->u_.arith.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nvoid dll_target::lpm_add_sub(const NetAddSub*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      if (net->attribute(perm_string::literal(\"LPM_Direction\")) == verinum(\"SUB\"))\n\t    obj->type = IVL_LPM_SUB;\n      else\n\t    obj->type = IVL_LPM_ADD;\n      obj->name = net->name(); // NetAddSub names are permallocated.\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->u_.arith.signed_flag = 0;\n\n\t/* Choose the width of the adder. If the carry bit is\n\t   connected, then widen the adder by one and plan on leaving\n\t   the fake inputs unconnected. */\n      obj->width = net->width();\n      if (net->pin_Cout().is_linked()) {\n\t    obj->width += 1;\n      }\n\n\n      const Nexus*nex;\n\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin_DataA().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin_DataB().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.b = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.b, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n\t/* If the carry output is connected, then connect the extra Q\n\t   pin to the carry nexus and zero the a and b inputs. */\n      if (net->pin_Cout().is_linked()) {\n\t    cerr << \"XXXX: t-dll.cc: Forgot how to connect cout.\" << endl;\n      }\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nbool dll_target::lpm_array_dq(const NetArrayDq*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_ARRAY;\n      obj->name = net->name();\n      obj->u_.array.sig = find_signal(des_, net->mem());\n      assert(obj->u_.array.sig);\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n      obj->width = net->width();\n      obj->u_.array.swid = net->awidth();\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      const Nexus*nex;\n\n      nex = net->pin_Address().nexus();\n      assert(nex->t_cookie());\n      obj->u_.array.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.array.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n      obj->u_.array.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.array.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      return true;\n}\n\n/*\n * The lpm_clshift device represents both left and right shifts,\n * depending on what is connected to the Direction pin. We convert\n * this device into SHIFTL or SHIFTR devices.\n */\nvoid dll_target::lpm_clshift(const NetCLShift*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_SHIFTL;\n      obj->name = net->name();\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n\t/* Look at the direction input of the device, and select the\n\t   shift direction accordingly. */\n      if (net->right_flag())\n\t    obj->type = IVL_LPM_SHIFTR;\n      if (net->signed_flag())\n\t    obj->u_.shift.signed_flag = 1;\n      else\n\t    obj->u_.shift.signed_flag = 0;\n\n      obj->width = net->width();\n      obj->u_.shift.select = net->width_dist();\n\n      const Nexus*nex;\n\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.shift.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.shift.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin_Data().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.shift.d = nex->t_cookie();\n      nexus_lpm_add(obj->u_.shift.d, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin_Distance().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.shift.s = nex->t_cookie();\n      nexus_lpm_add(obj->u_.shift.s, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nbool dll_target::lpm_arith1_(ivl_lpm_type_t lpm_type, unsigned width, bool signed_flag, const NetNode*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type = lpm_type;\n      obj->name = net->name(); // NetCastInt2 names are permallocated\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = width;\n      obj->u_.arith.signed_flag = signed_flag? 1 : 0;\n\n      const Nexus*nex;\n\n      nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n\n      nex = net->pin(1).nexus();\n      assert(nex->t_cookie());\n      obj->u_.arith.a = nex->t_cookie();\n\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\nbool dll_target::lpm_cast_int2(const NetCastInt2*net)\n{\n      return lpm_arith1_(IVL_LPM_CAST_INT2, net->width(), true, net);\n}\n\nbool dll_target::lpm_cast_int4(const NetCastInt4*net)\n{\n      return lpm_arith1_(IVL_LPM_CAST_INT, net->width(), true, net);\n}\n\nbool dll_target::lpm_cast_real(const NetCastReal*net)\n{\n      return lpm_arith1_(IVL_LPM_CAST_REAL, 0, net->signed_flag(), net);\n}\n\n/*\n * Make out of the NetCompare object an ivl_lpm_s object. The\n * comparators in ivl_target do not support < or <=, but they can be\n * trivially converted to > and >= by swapping the operands.\n */\nvoid dll_target::lpm_compare(const NetCompare*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->name = net->name(); // NetCompare names are permallocated\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      bool swap_operands = false;\n\n      obj->width = net->width();\n      obj->u_.arith.signed_flag = net->get_signed()? 1 : 0;\n\n      const Nexus*nex;\n\n      nex = net->pin_DataA().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.a = nex->t_cookie();\n\n      nex = net->pin_DataB().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.b = nex->t_cookie();\n\n\n      if (net->pin_AGEB().is_linked()) {\n\t    nex = net->pin_AGEB().nexus();\n\t    obj->type = IVL_LPM_CMP_GE;\n\n\t    assert(nex->t_cookie());\n\t    obj->u_.arith.q = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.arith.q, obj, 0,\n\t\t\t  IVL_DR_STRONG, IVL_DR_STRONG);\n\n      } else if (net->pin_AGB().is_linked()) {\n\t    nex = net->pin_AGB().nexus();\n\t    obj->type = IVL_LPM_CMP_GT;\n\n\t    assert(nex->t_cookie());\n\t    obj->u_.arith.q = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.arith.q, obj, 0,\n\t\t\t  IVL_DR_STRONG, IVL_DR_STRONG);\n\n      } else if (net->pin_ALEB().is_linked()) {\n\t    nex = net->pin_ALEB().nexus();\n\t    obj->type = IVL_LPM_CMP_GE;\n\n\t    assert(nex->t_cookie());\n\t    obj->u_.arith.q = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.arith.q, obj, 0,\n\t\t\t  IVL_DR_STRONG, IVL_DR_STRONG);\n\n\t    swap_operands = true;\n\n      } else if (net->pin_ALB().is_linked()) {\n\t    nex = net->pin_ALB().nexus();\n\t    obj->type = IVL_LPM_CMP_GT;\n\n\t    assert(nex->t_cookie());\n\t    obj->u_.arith.q = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.arith.q, obj, 0,\n\t\t\t  IVL_DR_STRONG, IVL_DR_STRONG);\n\n\t    swap_operands = true;\n\n      } else if (net->pin_AEB().is_linked()) {\n\t    nex = net->pin_AEB().nexus();\n\t    obj->type = IVL_LPM_CMP_EQ;\n\n\t    assert(nex->t_cookie());\n\t    obj->u_.arith.q = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.arith.q, obj, 0,\n\t\t\t  IVL_DR_STRONG, IVL_DR_STRONG);\n\n      } else if (net->pin_ANEB().is_linked()) {\n\t    nex = net->pin_ANEB().nexus();\n\t    obj->type = IVL_LPM_CMP_NE;\n\n\t    assert(nex->t_cookie());\n\t    obj->u_.arith.q = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.arith.q, obj, 0,\n\t\t\t  IVL_DR_STRONG, IVL_DR_STRONG);\n\n      } else {\n\t    assert(0);\n      }\n\n      if (swap_operands) {\n\t    ivl_nexus_t tmp = obj->u_.arith.a;\n\t    obj->u_.arith.a = obj->u_.arith.b;\n\t    obj->u_.arith.b = tmp;\n      }\n\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n      nexus_lpm_add(obj->u_.arith.b, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nvoid dll_target::lpm_divide(const NetDivide*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type  = IVL_LPM_DIVIDE;\n      obj->name  = net->name();\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      unsigned wid = net->width_r();\n\n      obj->width = wid;\n      obj->u_.arith.signed_flag = net->get_signed()? 1 : 0;\n\n      const Nexus*nex;\n\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin_DataA().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin_DataB().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.b = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.b, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nvoid dll_target::lpm_modulo(const NetModulo*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type  = IVL_LPM_MOD;\n      obj->name  = net->name();\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      unsigned wid = net->width_r();\n\n      obj->width = wid;\n      obj->u_.arith.signed_flag = net->get_signed()? 1 : 0;\n\n      const Nexus*nex;\n\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin_DataA().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin_DataB().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.b = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.b, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nvoid dll_target::lpm_ff(const NetFF*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type  = IVL_LPM_FF;\n      obj->name  = net->name();\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = net->width();\n\n      scope_add_lpm(obj->scope, obj);\n\n      const Nexus*nex;\n\n\t/* Set the clock polarity. */\n      obj->u_.ff.negedge_flag = net->is_negedge();\n\n\t/* Set the clk signal to point to the nexus, and the nexus to\n\t   point back to this device. */\n      nex = net->pin_Clock().nexus();\n      assert(nex->t_cookie());\n      obj->u_.ff.clk = nex->t_cookie();\n      assert(obj->u_.ff.clk);\n      nexus_lpm_add(obj->u_.ff.clk, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n\t/* If there is a clock enable, then connect it up to the FF\n\t   device. */\n      if (net->pin_Enable().is_linked()) {\n\t    nex = net->pin_Enable().nexus();\n\t    assert(nex->t_cookie());\n\t    obj->u_.ff.we = nex->t_cookie();\n\t    assert(obj->u_.ff.we);\n\t    nexus_lpm_add(obj->u_.ff.we, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n      } else {\n\t    obj->u_.ff.we = 0;\n      }\n\n      if (net->pin_Aclr().is_linked()) {\n\t    nex = net->pin_Aclr().nexus();\n\t    assert(nex->t_cookie());\n\t    obj->u_.ff.aclr = nex->t_cookie();\n\t    assert(obj->u_.ff.aclr);\n\t    nexus_lpm_add(obj->u_.ff.aclr, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n      } else {\n\t    obj->u_.ff.aclr = 0;\n      }\n\n      if (net->pin_Aset().is_linked()) {\n\t    nex = net->pin_Aset().nexus();\n\t    assert(nex->t_cookie());\n\t    obj->u_.ff.aset = nex->t_cookie();\n\t    assert(obj->u_.ff.aset);\n\t    nexus_lpm_add(obj->u_.ff.aset, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n\t    verinum tmp = net->aset_value();\n\t    if (tmp.len() > 0)\n\t\t  obj->u_.ff.aset_value = expr_from_value_(tmp);\n\t    else\n\t\t  obj->u_.ff.aset_value = 0;\n\n      } else {\n\t    obj->u_.ff.aset = 0;\n\t    obj->u_.ff.aset_value = 0;\n      }\n\n      if (net->pin_Sclr().is_linked()) {\n\t    nex = net->pin_Sclr().nexus();\n\t    assert(nex->t_cookie());\n\t    obj->u_.ff.sclr = nex->t_cookie();\n\t    assert(obj->u_.ff.sclr);\n\t    nexus_lpm_add(obj->u_.ff.sclr, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n      } else {\n\t    obj->u_.ff.sclr = 0;\n      }\n\n      if (net->pin_Sset().is_linked()) {\n\t    nex = net->pin_Sset().nexus();\n\t    assert(nex->t_cookie());\n\t    obj->u_.ff.sset = nex->t_cookie();\n\t    assert(obj->u_.ff.sset);\n\t    nexus_lpm_add(obj->u_.ff.sset, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n\t    verinum tmp = net->sset_value();\n\t    if (tmp.len() > 0)\n\t\t  obj->u_.ff.sset_value = expr_from_value_(tmp);\n\t    else\n\t\t  obj->u_.ff.sset_value = 0;\n\n      } else {\n\t    obj->u_.ff.sset = 0;\n\t    obj->u_.ff.sset_value = 0;\n      }\n\n      nex = net->pin_Q().nexus();\n      assert(nex->t_cookie());\n      obj->u_.ff.q.pin = nex->t_cookie();\n      nexus_lpm_add(obj->u_.ff.q.pin, obj, 0,\n\t\t    IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin_Data().nexus();\n      assert(nex->t_cookie());\n      obj->u_.ff.d.pin = nex->t_cookie();\n      nexus_lpm_add(obj->u_.ff.d.pin, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n}\n\n/*\n * Make the NetMult object into an IVL_LPM_MULT node.\n */\nvoid dll_target::lpm_mult(const NetMult*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type  = IVL_LPM_MULT;\n      obj->name  = net->name();\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      unsigned wid = net->width_r();\n\n      obj->width = wid;\n      obj->u_.arith.signed_flag = 0;\n\n      const Nexus*nex;\n\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin_DataA().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin_DataB().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.b = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.b, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\n/*\n * Hook up the mux devices so that the select expression selects the\n * correct sub-expression with the ivl_lpm_data2 function.\n */\nvoid dll_target::lpm_mux(const NetMux*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type  = IVL_LPM_MUX;\n      obj->name  = net->name(); // The NetMux permallocates its name.\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = net->width();\n      obj->u_.mux.size  = net->size();\n      obj->u_.mux.swid  = net->sel_width();\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      const Nexus*nex;\n\n\t/* Connect the output bits. */\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n      obj->u_.mux.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.mux.q, obj, 0,\n\t\t    net->pin_Result().drive0(),\n\t\t    net->pin_Result().drive1());\n\n\t/* Connect the select bits. */\n      nex = net->pin_Sel().nexus();\n      assert(nex->t_cookie());\n      obj->u_.mux.s = nex->t_cookie();\n      nexus_lpm_add(obj->u_.mux.s, obj, 0,\n\t\t    IVL_DR_HiZ, IVL_DR_HiZ);\n\n      unsigned selects = obj->u_.mux.size;\n\n      obj->u_.mux.d = new ivl_nexus_t [selects];\n\n      for (unsigned sdx = 0 ;  sdx < selects ;  sdx += 1) {\n\t    nex = net->pin_Data(sdx).nexus();\n\t    ivl_nexus_t tmp = nex->t_cookie();\n\t    obj->u_.mux.d[sdx] = tmp;\n\t    if (tmp == 0) {\n\t\t  cerr << net->get_fileline() << \": internal error: \"\n\t\t       << \"dll_target::lpm_mux: \"\n\t\t       << \"Missing data port \" << sdx\n\t\t       << \" of mux \" << obj->name << \".\" << endl;\n\t    }\n\t    ivl_assert(*net, tmp);\n\t    nexus_lpm_add(tmp, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n      }\n\n}\n\n/*\n * Make the NetPow object into an IVL_LPM_POW node.\n */\nvoid dll_target::lpm_pow(const NetPow*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type  = IVL_LPM_POW;\n      FILE_NAME(obj, net);\n      obj->name  = net->name();\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      unsigned wid = net->width_r();\n      obj->u_.arith.signed_flag = net->get_signed()? 1 : 0;\n\n      obj->width = wid;\n\n      const Nexus*nex;\n\n      nex = net->pin_Result().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n\n      nex = net->pin_DataA().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      nex = net->pin_DataB().nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.arith.b = nex->t_cookie();\n      nexus_lpm_add(obj->u_.arith.b, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n}\n\nbool dll_target::concat(const NetConcat*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type = net->transparent()? IVL_LPM_CONCATZ : IVL_LPM_CONCAT;\n      obj->name = net->name(); // NetConcat names are permallocated\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = net->width();\n\n      obj->u_.concat.inputs = net->pin_count() - 1;\n      obj->u_.concat.pins = new ivl_nexus_t[obj->u_.concat.inputs+1];\n\n      for (unsigned idx = 0 ;  idx < obj->u_.concat.inputs+1 ; idx += 1) {\n\t    ivl_drive_t dr = idx == 0? IVL_DR_STRONG : IVL_DR_HiZ;\n\t    const Nexus*nex = net->pin(idx).nexus();\n\t    assert(nex->t_cookie());\n\n\t    obj->u_.concat.pins[idx] = nex->t_cookie();\n\t    nexus_lpm_add(obj->u_.concat.pins[idx], obj, 0, dr, dr);\n      }\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\nbool dll_target::part_select(const NetPartSelect*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      switch (net->dir()) {\n\t  case NetPartSelect::VP:\n\t    obj->type = IVL_LPM_PART_VP;\n\t    break;\n\t  case NetPartSelect::PV:\n\t    obj->type = IVL_LPM_PART_PV;\n\t    break;\n      }\n      obj->name = net->name(); // NetPartSelect names are permallocated.\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n\t/* Part selects are always unsigned, so we use this to indicate\n\t * if the part select base signal is signed or not. */\n      if (net->signed_flag())\n\t    obj->u_.part.signed_flag = 1;\n      else\n\t    obj->u_.part.signed_flag = 0;\n\n\t/* Choose the width of the part select. */\n      obj->width = net->width();\n      obj->u_.part.base  = net->base();\n      obj->u_.part.s = 0;\n\n      const Nexus*nex;\n\n      switch (obj->type) {\n\t  case IVL_LPM_PART_VP:\n\t      /* NetPartSelect:pin(0) is the output pin. */\n\t    nex = net->pin(0).nexus();\n\t    assert(nex->t_cookie());\n\n\t    obj->u_.part.q = nex->t_cookie();\n\n\t      /* NetPartSelect:pin(1) is the input pin. */\n\t    nex = net->pin(1).nexus();\n\t    assert(nex->t_cookie());\n\n\t    obj->u_.part.a = nex->t_cookie();\n\n\t      /* If the part select has an additional pin, that pin is\n\t\t a variable select base. */\n\t    if (net->pin_count() >= 3) {\n\t\t  nex = net->pin(2).nexus();\n\t\t  assert(nex->t_cookie());\n\t\t  obj->u_.part.s = nex->t_cookie();\n\t    }\n\t    break;\n\n\t  case IVL_LPM_PART_PV:\n\t      /* NetPartSelect:pin(1) is the output pin. */\n\t    nex = net->pin(1).nexus();\n\t    assert(nex->t_cookie());\n\n\t    obj->u_.part.q = nex->t_cookie();\n\n\t      /* NetPartSelect:pin(0) is the input pin. */\n\t    nex = net->pin(0).nexus();\n\t    assert(nex->t_cookie());\n\n\t    obj->u_.part.a = nex->t_cookie();\n\t    break;\n\n\t  default:\n\t    assert(0);\n      }\n\n      nexus_lpm_add(obj->u_.part.q, obj, 0, IVL_DR_STRONG, IVL_DR_STRONG);\n      nexus_lpm_add(obj->u_.part.a, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n\t/* The select input is optional. */\n      if (obj->u_.part.s)\n\t  nexus_lpm_add(obj->u_.part.s, obj, 0, IVL_DR_HiZ, IVL_DR_HiZ);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\nbool dll_target::replicate(const NetReplicate*net)\n{\n      ivl_lpm_t obj = new struct ivl_lpm_s;\n      obj->type = IVL_LPM_REPEAT;\n      obj->name = net->name();\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      assert(obj->scope);\n      FILE_NAME(obj, net);\n\n      obj->width = net->width();\n      obj->u_.repeat.count = net->repeat();\n\n      ivl_drive_t dr = IVL_DR_STRONG;\n      const Nexus*nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.repeat.q = nex->t_cookie();\n      nexus_lpm_add(obj->u_.repeat.q, obj, 0, dr, dr);\n\n      dr = IVL_DR_HiZ;\n      nex = net->pin(1).nexus();\n      assert(nex->t_cookie());\n\n      obj->u_.repeat.a = nex->t_cookie();\n      nexus_lpm_add(obj->u_.repeat.a, obj, 0, dr, dr);\n\n      make_lpm_delays_(obj, net);\n\n      scope_add_lpm(obj->scope, obj);\n\n      return true;\n}\n\n/*\n * The assignment l-values are captured by the assignment statements\n * themselves in the process handling.\n */\nvoid dll_target::net_assign(const NetAssign_*) const\n{\n}\n\nbool dll_target::net_const(const NetConst*net)\n{\n      unsigned idx;\n      char*bits;\n      static char*bits_tmp = 0;\n      static unsigned bits_cnt = 0;\n\n      struct ivl_net_const_s *obj = new struct ivl_net_const_s;\n\n      if (net->is_string()) {\n\t    obj->type = IVL_VT_STRING;\n\t    assert((net->width() % 8) == 0);\n      } else obj->type = IVL_VT_BOOL;\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      FILE_NAME(obj, net);\n\n\t/* constants have a single vector output. */\n      assert(net->pin_count() == 1);\n\n      obj->width_ = net->width();\n      obj->signed_ = net->value().has_sign();\n      if (obj->width_ <= sizeof(obj->b.bit_)) {\n\t    bits = obj->b.bit_;\n\n      } else {\n\t    if (obj->width_ >= bits_cnt) {\n\t\t  bits_tmp = (char*)realloc(bits_tmp, obj->width_+1);\n\t\t  bits_cnt = obj->width_+1;\n\t    }\n\t    bits = bits_tmp;\n      }\n\n      for (idx = 0 ;  idx < obj->width_ ;  idx += 1)\n\t    switch (net->value(idx)) {\n\t\tcase verinum::V0:\n\t\t  bits[idx] = '0';\n\t\t  break;\n\t\tcase verinum::V1:\n\t\t  bits[idx] = '1';\n\t\t  break;\n\t\tcase verinum::Vx:\n\t\t  if (obj->type == IVL_VT_BOOL)\n\t\t\tobj->type = IVL_VT_LOGIC;\n\t\t  bits[idx] = 'x';\n\t\t  assert(! net->is_string());\n\t\t  break;\n\t\tcase verinum::Vz:\n\t\t  if (obj->type == IVL_VT_BOOL)\n\t\t\tobj->type = IVL_VT_LOGIC;\n\t\t  bits[idx] = 'z';\n\t\t  assert(! net->is_string());\n\t\t  break;\n\t    }\n\n      if (obj->width_ > sizeof(obj->b.bit_)) {\n\t    bits[obj->width_] = 0;\n\t    obj->b.bits_ = net_const_strings.make(bits);\n      }\n\n\t/* Connect to all the nexus objects. Note that the one-bit\n\t   case can be handled more efficiently without allocating\n\t   array space. */\n\n      ivl_drive_t drv0, drv1;\n      drive_from_link(net->pin(0), drv0, drv1);\n      const Nexus*nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n      obj->pin_ = nex->t_cookie();\n      nexus_con_add(obj->pin_, obj, 0, drv0, drv1);\n\n      des_.consts.push_back(obj);\n\n      make_const_delays_(obj, net);\n\n      return true;\n}\n\nbool dll_target::net_literal(const NetLiteral*net)\n{\n\n      struct ivl_net_const_s *obj = new struct ivl_net_const_s;\n\n      obj->type = IVL_VT_REAL;\n      assert(net->scope());\n      obj->scope = find_scope(des_, net->scope());\n      FILE_NAME(obj, net);\n      obj->width_  = 1;\n      obj->signed_ = 1;\n      obj->b.real_value = net->value_real().as_double();\n\n\t/* Connect to all the nexus objects. Note that the one-bit\n\t   case can be handled more efficiently without allocating\n\t   array space. */\n\n      ivl_drive_t drv0, drv1;\n      drive_from_link(net->pin(0), drv0, drv1);\n      const Nexus*nex = net->pin(0).nexus();\n      assert(nex->t_cookie());\n      obj->pin_ = nex->t_cookie();\n      nexus_con_add(obj->pin_, obj, 0, drv0, drv1);\n\n      des_.consts.push_back(obj);\n\n      make_const_delays_(obj, net);\n\n      return true;\n}\n\nvoid dll_target::net_probe(const NetEvProbe*)\n{\n}\n\nvoid dll_target::scope(const NetScope*net)\n{\n      if (net->parent()==0 && net->type()==NetScope::CLASS) {\n\n\t    if (debug_emit) {\n\t\t  cerr << \"dll_target::scope: \"\n\t\t       << \"Add class \" << scope_path(net)\n\t\t       << \" as a root scope.\" << endl;\n\t    }\n\t    add_root(net);\n\n      } if (net->parent() == 0) {\n\n\t      // Root scopes are already created...\n\n      } else {\n\t    perm_string sname = make_scope_name(net->fullname());\n\t    ivl_scope_t scop = new struct ivl_scope_s;\n\t    scop->name_ = sname;\n\t    FILE_NAME(scop, net);\n\t    scop->parent = find_scope(des_, net->parent());\n\t    assert(scop->parent);\n\t    scop->parent->children[net->fullname()] = scop;\n\t    scop->parent->child .push_back(scop);\n\t    scop->nlog_ = 0;\n\t    scop->log_ = 0;\n\t    scop->nevent_ = 0;\n\t    scop->event_ = 0;\n\t    scop->nlpm_ = 0;\n\t    scop->lpm_ = 0;\n\t    scop->def = 0;\n\t    make_scope_parameters(scop, net);\n\t    scop->time_precision = net->time_precision();\n\t    scop->time_units = net->time_unit();\n\t    scop->nattr = net->attr_cnt();\n\t    scop->attr = fill_in_attributes(net);\n\t    scop->is_auto = net->is_auto();\n\t    scop->is_cell = net->is_cell();\n\n\t    switch (net->type()) {\n\t\tcase NetScope::PACKAGE:\n\t\t  cerr << \"?:?\" << \": internal error: \"\n\t\t       << \"Package scopes should not have parents.\" << endl;\n\t\t  // fallthrough\n\t\tcase NetScope::MODULE:\n\t\t  scop->type_ = IVL_SCT_MODULE;\n\t\t  scop->tname_ = net->module_name();\n\t\t  scop->ports = net->module_port_nets();\n\t\t  if (scop->ports > 0) {\n\t\t\tscop->u_.net = new NetNet*[scop->ports];\n\t\t\tfor (unsigned idx = 0; idx < scop->ports; idx += 1) {\n\t\t\t      scop->u_.net[idx] = net->module_port_net(idx);\n\t\t\t}\n\t\t  }\n\t\t  scop->module_ports_info = net->module_port_info();\n\t\t  break;\n\n\t\tcase NetScope::TASK: {\n\t\t      const NetTaskDef*def = net->task_def();\n\t\t      if (def == 0) {\n\t\t\t    cerr <<  \"?:?\" << \": internal error: \"\n\t\t\t\t << \"task \" << scop->name_\n\t\t\t\t << \" has no definition.\" << endl;\n\t\t      }\n\t\t      assert(def);\n\t\t      scop->type_ = IVL_SCT_TASK;\n\t\t      scop->tname_ = def->scope()->basename();\n\t\t      break;\n\t\t}\n\t\tcase NetScope::FUNC:\n\t\t  scop->type_ = IVL_SCT_FUNCTION;\n\t\t  scop->tname_ = net->func_def()->scope()->basename();\n\t\t  break;\n\t\tcase NetScope::BEGIN_END:\n\t\t  scop->type_ = IVL_SCT_BEGIN;\n\t\t  scop->tname_ = scop->name_;\n\t\t  break;\n\t\tcase NetScope::FORK_JOIN:\n\t\t  scop->type_ = IVL_SCT_FORK;\n\t\t  scop->tname_ = scop->name_;\n\t\t  break;\n\t\tcase NetScope::GENBLOCK:\n\t\t  scop->type_ = IVL_SCT_GENERATE;\n\t\t  scop->tname_ = scop->name_;\n\t\t  break;\n\t\tcase NetScope::CLASS:\n\t\t  assert(0);\n\t\t  break;\n\t    }\n      }\n}\n\nvoid dll_target::convert_module_ports(const NetScope*net)\n{\n      ivl_scope_t scop = find_scope(des_, net);\n      if (scop->ports > 0) {\n\t    NetNet**nets = scop->u_.net;\n\t    scop->u_.nex = new ivl_nexus_t[scop->ports];\n\t    for (unsigned idx = 0; idx < scop->ports; idx += 1) {\n\t\t  ivl_signal_t sig = find_signal(des_, nets[idx]);\n\t\t  scop->u_.nex[idx] = nexus_sig_make(sig, 0);\n\t    }\n\t    delete [] nets;\n      }\n}\n\nvoid dll_target::signal(const NetNet*net)\n{\n      ivl_signal_t obj = new struct ivl_signal_s;\n\n      obj->name_ = net->name();\n\n\t/* Attach the signal to the ivl_scope_t object that contains\n\t   it. This involves growing the sigs_ array in the scope\n\t   object, or creating the sigs_ array if this is the first\n\t   signal. */\n      obj->scope_ = find_scope(des_, net->scope());\n      assert(obj->scope_);\n      FILE_NAME(obj, net);\n\n      obj->scope_->sigs_.push_back(obj);\n\n\n\t/* Save the primitive properties of the signal in the\n\t   ivl_signal_t object. */\n\n      { size_t idx = 0;\n\tvector<netrange_t>::const_iterator cur;\n\tobj->packed_dims.resize(net->packed_dims().size());\n\tfor (cur = net->packed_dims().begin(), idx = 0\n\t\t   ; cur != net->packed_dims().end() ; ++cur, idx += 1) {\n\t    obj->packed_dims[idx] = *cur;\n\t}\n      }\n\n      obj->net_type = net->net_type();\n      obj->local_ = net->local_flag()? 1 : 0;\n      obj->forced_net_ = (net->type() != NetNet::REG) &&\n                         (net->peek_lref() > 0) ? 1 : 0;\n      obj->discipline = net->get_discipline();\n\n      obj->array_dimensions_ = net->unpacked_dimensions();\n      assert(obj->array_dimensions_ == net->unpacked_dimensions());\n\n      switch (net->port_type()) {\n\n\t  case NetNet::PINPUT:\n\t    obj->port_ = IVL_SIP_INPUT;\n\t    break;\n\n\t  case NetNet::POUTPUT:\n\t    obj->port_ = IVL_SIP_OUTPUT;\n\t    break;\n\n\t  case NetNet::PINOUT:\n\t    obj->port_ = IVL_SIP_INOUT;\n\t    break;\n\n\t  default:\n\t    obj->port_ = IVL_SIP_NONE;\n\t    break;\n      }\n\n      obj->module_port_index_ = net->get_module_port_index();\n\n      switch (net->type()) {\n\n\t  case NetNet::REG:\n\t    obj->type_ = IVL_SIT_REG;\n\t    break;\n\n\t      /* The SUPPLY0/1 net types are replaced with pulldown/up\n\t\t by elaborate. They should not make it here. */\n\t  case NetNet::SUPPLY0:\n\t    assert(0);\n\t    break;\n\t  case NetNet::SUPPLY1:\n\t    assert(0);\n\t    break;\n\n\t      /* We will convert this to a TRI after we check that there\n\t\t is only one driver. */\n\t  case NetNet::UNRESOLVED_WIRE:\n\t    obj->type_ = IVL_SIT_UWIRE;\n\t    break;\n\n\t  case NetNet::TRI:\n\t  case NetNet::WIRE:\n\t  case NetNet::IMPLICIT:\n\t    obj->type_ = IVL_SIT_TRI;\n\t    break;\n\n\t  case NetNet::TRI0:\n\t    obj->type_ = IVL_SIT_TRI0;\n\t    break;\n\n\t  case NetNet::TRI1:\n\t    obj->type_ = IVL_SIT_TRI1;\n\t    break;\n\n\t  case NetNet::TRIAND:\n\t  case NetNet::WAND:\n\t    obj->type_ = IVL_SIT_TRIAND;\n\t    break;\n\n\t  case NetNet::TRIOR:\n\t  case NetNet::WOR:\n\t    obj->type_ = IVL_SIT_TRIOR;\n\t    break;\n\n\t  default:\n\t    obj->type_ = IVL_SIT_NONE;\n\t    break;\n      }\n\n\t/* Initialize the path fields to be filled in later. */\n      obj->npath = 0;\n      obj->path = 0;\n\n      obj->nattr = net->attr_cnt();\n      obj->attr = fill_in_attributes(net);\n\n\t/* Get the nexus objects for all the pins of the signal. If\n\t   the signal has only one pin, then write the single\n\t   ivl_nexus_t object into n.pin_. Otherwise, make an array of\n\t   ivl_nexus_t cookies.\n\n\t   When I create an ivl_nexus_t object, store it in the\n\t   t_cookie of the Nexus object so that I find it again when I\n\t   next encounter the nexus. */\n\n      if (obj->array_dimensions_ == 1) {\n\t    const vector<netrange_t>& dims = net->unpacked_dims();\n\t    if (dims[0].get_msb() < dims[0].get_lsb()) {\n\t\t  obj->array_base = dims[0].get_msb();\n\t\t  obj->array_addr_swapped = false;\n\t    } else {\n\t\t  obj->array_base = dims[0].get_lsb();\n\t\t  obj->array_addr_swapped = true;\n\t    }\n\t    obj->array_words = net->unpacked_count();\n      } else {\n\t      // The back-end API doesn't yet support multi-dimension\n\t      // unpacked arrays, so just report the canonical dimensions.\n\t    obj->array_base = 0;\n\t    obj->array_words = net->unpacked_count();\n\t    obj->array_addr_swapped = 0;\n      }\n\n      ivl_assert(*net, obj->array_words == net->pin_count());\n      if (debug_optimizer && obj->array_words > 1000) cerr << \"debug: \"\n\t    \"t-dll creating nexus array \" << obj->array_words << \" long\" << endl;\n      if (obj->array_words > 1 && net->pins_are_virtual()) {\n\t    obj->pins = NULL;\n\t    if (debug_optimizer && obj->array_words > 1000) cerr << \"debug: \"\n\t\t\"t-dll used NULL for big nexus array\" << endl;\n\t    return;\n      }\n      if (obj->array_words > 1)\n\t    obj->pins = new ivl_nexus_t[obj->array_words];\n\n      for (unsigned idx = 0 ;  idx < obj->array_words ;  idx += 1) {\n\n\t    const Nexus*nex = net->pins_are_virtual() ? 0 : net->pin(idx).nexus();\n\t    if (nex == 0) {\n\t\t    // Special case: This pin is connected to\n\t\t    // nothing. This can happen, for example, if the\n\t\t    // variable is only used in behavioral\n\t\t    // code. Create a stub nexus.\n\t\t  ivl_nexus_t tmp = nexus_sig_make(obj, idx);\n\t\t  tmp->nexus_ = nex;\n\t\t  tmp->name_ = 0;\n\t\t  if (obj->array_words > 1)\n\t\t\tobj->pins[idx] = tmp;\n\t\t  else\n\t\t\tobj->pin = tmp;\n\t    } else if (nex->t_cookie()) {\n\t\t  if (obj->array_words > 1) {\n\t\t\tobj->pins[idx] = nex->t_cookie();\n\t\t\tnexus_sig_add(obj->pins[idx], obj, idx);\n\t\t  } else {\n\t\t\tobj->pin = nex->t_cookie();\n\t\t\tnexus_sig_add(obj->pin, obj, idx);\n\t\t  }\n\t    } else {\n\t\t  ivl_nexus_t tmp = nexus_sig_make(obj, idx);\n\t\t  tmp->nexus_ = nex;\n\t\t  tmp->name_ = 0;\n\t\t  nex->t_cookie(tmp);\n\t\t  if (obj->array_words > 1)\n\t\t\tobj->pins[idx] = tmp;\n\t\t  else\n\t\t\tobj->pin = tmp;\n\t    }\n      }\n      if (debug_optimizer && obj->array_words > 1000) cerr << \"debug: t-dll done with big nexus array\" << endl;\n}\n\nbool dll_target::signal_paths(const NetNet*net)\n{\n\t/* Nothing to do if there are no paths for this signal. */\n      if (net->delay_paths() == 0)\n\t    return true;\n\n      ivl_signal_t obj = find_signal(des_, net);\n      assert(obj);\n\n\t/* We cannot have already set up the paths for this signal. */\n      assert(obj->npath == 0);\n      assert(obj->path == 0);\n\n         /* Figure out how many paths there really are. */\n      for (unsigned idx = 0 ;  idx < net->delay_paths() ;  idx += 1) {\n\t    const NetDelaySrc*src = net->delay_path(idx);\n\t    obj->npath += src->src_count();\n      }\n\n      obj->path = new struct ivl_delaypath_s[obj->npath];\n\n      unsigned ptr = 0;\n      for (unsigned idx = 0 ;  idx < net->delay_paths() ;  idx += 1) {\n\t    const NetDelaySrc*src = net->delay_path(idx);\n\n\t      /* If this path has a condition, then hook it up. */\n\t    ivl_nexus_t path_condit = 0;\n\t    if (src->has_condit()) {\n\t\t  const Nexus*nt = src->condit_pin().nexus();\n\t\t  path_condit = nt->t_cookie();\n\t    }\n\n\t    for (unsigned pin = 0; pin < src->src_count(); pin += 1) {\n\t\t  const Nexus*nex = src->src_pin(pin).nexus();\n\t\t  if (! nex->t_cookie()) {\n\t\t\tcerr << src->get_fileline() << \": internal error: \"\n\t\t\t     << \"No signal connected to pin \" << pin\n\t\t\t     << \" of delay path to \" << net->name()\n\t\t\t     << \".\" << endl;\n\t\t  }\n\t\t  assert(nex->t_cookie());\n\t\t  obj->path[ptr].scope = lookup_scope_(src->scope());\n\t\t  obj->path[ptr].src = nex->t_cookie();\n\t\t  obj->path[ptr].condit = path_condit;\n\t\t  obj->path[ptr].conditional = src->is_condit();\n\t\t  obj->path[ptr].posedge = src->is_posedge();\n\t\t  obj->path[ptr].negedge = src->is_negedge();\n\t\t  for (unsigned pe = 0 ;  pe < 12 ;  pe += 1) {\n\t\t\tobj->path[ptr].delay[pe] = src->get_delay(pe);\n\t\t  }\n\n\t\t  ptr += 1;\n\t    }\n\n      }\n\n      return true;\n}\n\n\nvoid dll_target::test_version(const char*target_name)\n{\n      dll_ = ivl_dlopen(target_name);\n\n      if ((dll_ == 0) && (target_name[0] != '/')) {\n\t    size_t len = strlen(basedir) + 1 + strlen(target_name) + 1;\n\t    char*tmp = new char[len];\n\t    sprintf(tmp, \"%s/%s\", basedir, target_name);\n\t    dll_ = ivl_dlopen(tmp);\n\t    delete[]tmp;\n      }\n\n      if (dll_ == 0) {\n\t    cout << \"\\n\\nUnable to load \" << target_name\n\t\t << \" for version details.\" << endl;\n\t    return;\n      }\n\n      target_query_f target_query = (target_query_f)ivl_dlsym(dll_, LU \"target_query\" TU);\n      if (target_query == 0) {\n\t    cerr << \"Target \" << target_name\n\t\t << \" has no version hooks.\" << endl;\n\t    return;\n      }\n\n      const char*version_string = (*target_query) (\"version\");\n      if (version_string == 0) {\n\t    cerr << \"Target \" << target_name\n\t\t << \" has no version string\" << endl;\n\t    return;\n      }\n\n      cout << target_name << \": \" << version_string << endl;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icarus-v10_3-zkwcunjz5niqq3sdcjowpzxp4d6ea3ar/spack-src/configure.in": "dnl Process this file with autoconf to produce a configure script.\nAC_INIT(netlist.h)\nAC_CONFIG_HEADER(config.h)\nAC_CONFIG_HEADER(_pli_types.h)\nAC_CONFIG_HEADER(vhdlpp/vhdlpp_config.h)\nAC_CONFIG_HEADER(vvp/config.h)\nAC_CONFIG_HEADER(vpi/vpi_config.h)\nAC_CONFIG_HEADER(libveriuser/config.h)\nAC_CONFIG_HEADER(tgt-vvp/vvp_config.h)\nAC_CONFIG_HEADER(tgt-vhdl/vhdl_config.h)\nAC_CONFIG_HEADER(tgt-pcb/pcb_config.h)\n\nAC_CANONICAL_HOST\ndnl Checks for programs.\nAC_PROG_CC\n# AC_PROG_CC_C99 is only available in autoconf version 2.60 and later.\nAC_PREREQ([2.60])\nAC_PROG_CC_C99\nAC_PROG_CXX\nAC_PROG_RANLIB\nAC_CHECK_TOOL(LD, ld, false)\nAC_CHECK_TOOL(AR, ar, false)\nAC_CHECK_TOOL(DLLTOOL, dlltool, false)\nAC_CHECK_TOOL(STRIP, strip, true)\nAC_CHECK_TOOL(WINDRES,windres,false)\nAC_CHECK_PROGS(XGPERF,gperf,none)\nAC_CHECK_PROGS(MAN,man,none)\nAC_CHECK_PROGS(PS2PDF,ps2pdf,none)\nAC_CHECK_PROGS(GIT,git,none)\nif test \"$XGPERF\" = \"none\"\nthen\n\techo \"\"\n        echo \"*** Warning: No suitable gperf found. ***\"\n\techo \"    The gperf package is essential for building ivl from\"\n\techo \"    git sources, or modifying the parse engine of ivl itself.\"\n\techo \"    You can get away without it when simply building from\"\n\techo \"    snapshots or major releases.\"\n\techo \"\"\nfi\n\nAC_CHECK_PROGS(LEX,flex,none)\nif test \"$LEX\" = \"none\"\nthen\n\techo \"*** Error: No suitable flex found. ***\"\n        echo \"    Please install the 'flex' package.\"\n        exit 1\nfi\n\nAC_CHECK_PROGS(YACC,bison,none)\nif test \"$YACC\" = \"none\"\nthen\n\techo \"*** Error: No suitable bison found. ***\"\n        echo \"    Please install the 'bison' package.\"\n        exit 1\nfi\n\nAC_EXEEXT\nAC_SUBST(EXEEXT)\n\n# Combined check for Microsoft-related bogosities; sets WIN32 if found\nAX_WIN32\n\n# Check to see if we are using the Sun compiler. If so then configure\n# some of the flags to match the Sun compiler syntax. This is also used\n# in the aclocal.m4 file to configure the flags used to build and link\n# dynamic libraries\nAC_CHECK_DECL(__SUNPRO_C, using_sunpro_c=1, using_sunpro_c=0)\nif test ${using_sunpro_c} = 1\nthen\nAC_SUBST(DEPENDENCY_FLAG, [-xMMD])\nAC_SUBST(WARNING_FLAGS, [\"\"])\nAC_SUBST(WARNING_FLAGS_CXX, [\"\"])\nelse\n# Check to see if -Wextra is supported.\niverilog_temp_cflags=\"$CFLAGS\"\nCFLAGS=\"-Wextra $CFLAGS\"\nAC_MSG_CHECKING(if gcc supports -Wextra)\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[]])],\n   [[iverilog_wextra_flag=\"-Wextra\";] AC_MSG_RESULT(yes)],\n   [[iverilog_wextra_flag=\"-W\";] AC_MSG_RESULT(no)])\nCFLAGS=\"$iverilog_temp_cflags\"\n\nAC_SUBST(DEPENDENCY_FLAG, [-MD])\nAC_SUBST(WARNING_FLAGS, [\"-Wall $iverilog_wextra_flag -Wshadow\"])\nAC_SUBST(WARNING_FLAGS_CC, [\"-Wstrict-prototypes\"])\nAC_SUBST(WARNING_FLAGS_CXX, [\"\"])\nfi\n\nAC_LANG(C++)\n\nAC_ARG_WITH([m32], [AC_HELP_STRING([--with-m32], [Compile 32-bit on x86_64])],\n            [ with_m32=yes ],[ with_m32=no ])\n\nAS_IF( [test \"x$with_m32\" = xyes],\n    [ AC_MSG_NOTICE([Compiling for 32-bit environment - needs gcc on x86_64])\n      LDTARGETFLAGS=\"-m elf_i386\"\n      CTARGETFLAGS=\"-m32\"\n    ],\n    [])\n\nCFLAGS=\"$CTARGETFLAGS $CFLAGS\"\nCXXFLAGS=\"$CTARGETFLAGS $CXXFLAGS\"\nLDFLAGS=\"$CTARGETFLAGS $LDFLAGS\"\n\n# Check that we are using either the GNU compilers or the Sun compilers\n# but not a mixture of the two (not currently supported).\nAC_CHECK_DECL(__SUNPRO_CC, using_sunpro_cc=1, using_sunpro_cc=0)\nif test ${using_sunpro_c} = 1\nthen\n  if test ${using_sunpro_cc} = 0\n  then\n    echo \"*** Error: No support for mixing GNU and Sun compilers. ***\"\n    echo \"           Using Sun C compiler and GNU C++ compiler..\"\n    exit 1\n  fi\nelse\n  if test ${using_sunpro_cc} = 1\n  then\n    echo \"*** Error: No support for mixing GNU and Sun compilers. ***\"\n    echo \"           Using GNU C compiler and Sun C++ compiler..\"\n    exit 1\n  fi\nfi\n\niverilog_temp_cxxflags=\"$CXXFLAGS\"\nCXXFLAGS=\"-DHAVE_DECL_BASENAME $CXXFLAGS\"\n\nAC_CHECK_HEADERS(getopt.h inttypes.h libiberty.h iosfwd sys/wait.h)\nCXXFLAGS=\"$iverilog_temp_cxxflags\"\n\nAC_CHECK_SIZEOF(unsigned long long)\nAC_CHECK_SIZEOF(unsigned long)\nAC_CHECK_SIZEOF(unsigned)\n\n# vvp uses these...\nAC_CHECK_LIB(termcap, tputs)\nAC_CHECK_LIB(readline, readline)\nAC_CHECK_LIB(history, add_history)\nAC_CHECK_HEADERS(readline/readline.h readline/history.h sys/resource.h)\ncase \"${host}\" in *linux*) AC_DEFINE([LINUX], [1], [Host operating system is Linux.]) ;; esac\n\n# vpi uses these\nAC_CHECK_LIB(pthread, pthread_create)\nAC_CHECK_LIB(z, gzwrite)\nAC_CHECK_LIB(z, gzwrite, HAVE_LIBZ=yes, HAVE_LIBZ=no)\nAC_SUBST(HAVE_LIBZ)\nif test \"$WIN32\" = \"yes\"; then\nAC_CHECK_LIB(bz2, main)\nAC_CHECK_LIB(bz2, main, HAVE_LIBBZ2=yes, HAVE_LIBBZ2=no)\nelse\nAC_CHECK_LIB(bz2, BZ2_bzdopen)\nAC_CHECK_LIB(bz2, BZ2_bzdopen, HAVE_LIBBZ2=yes, HAVE_LIBBZ2=no)\nfi\nAC_SUBST(HAVE_LIBBZ2)\n\n# The lxt/lxt2 files from GTKWave use these...\n\nAC_FUNC_ALLOCA\nAC_FUNC_FSEEKO\n\n# valgrind checks\nAC_ARG_WITH([valgrind], [AC_HELP_STRING([--with-valgrind],\n                                        [Add valgrind hooks])],\n            [], [check_valgrind=yes])\n\nAS_IF([test \"x$check_valgrind\" = xyes],\n      [AC_MSG_NOTICE([Not using valgrind hooks])],\n      [AC_CHECK_HEADER([valgrind/memcheck.h],\n                       [AC_DEFINE([CHECK_WITH_VALGRIND], [1],\n                                  [Define to one to use the valgrind hooks])],\n                       [AC_MSG_ERROR([Could not find <valgrind/memcheck.h>])])])\n\nAC_MSG_CHECKING(for sys/times)\nAC_TRY_LINK(\n#include <unistd.h>\n#include <sys/times.h>\n,{clock_t a = times(0)/sysconf(_SC_CLK_TCK);},\ndo_times=yes\nAC_DEFINE([HAVE_TIMES], [1], [The times system call is available in the host operating system.]),\ndo_times=no\n)\nAC_MSG_RESULT($do_times)\n\n# --\n# Look for a dl library to use. First look for the standard dlopen\n# functions, and failing that look for the HP specific shl_load function.\n\nAC_CHECK_HEADERS(dlfcn.h dl.h, break)\n\nDLLIB=''\nAC_CHECK_LIB(dl,dlopen,[DLLIB=-ldl])\nif test -z \"$DLLIB\" ; then\nAC_CHECK_LIB(dld,shl_load,[DLLIB=-ldld])\nfi\nAC_SUBST(DLLIB)\nAC_SUBST(LDRELOCFLAGS)\n\nAC_SUBST(CTARGETFLAGS)\nAC_SUBST(LDTARGETFLAGS)\n\n\nAC_PROG_INSTALL\n\nAC_LANG(C)\nAC_C_BIGENDIAN\n\n# $host\n\nAX_ENABLE_SUFFIX\n\nAX_LD_EXTRALIBS\n\n# Compiler option for position independent code, needed when making shared objects.\n# CFLAGS inherited by cadpli/Makefile?\nAX_C_PICFLAG\n\n# may modify LDFLAGS\nAX_C99_STRTOD\n\n# Processor specific compile flags\ncase \"${host}\" in\n    alpha*-*-linux*)\n\tCPPFLAGS=\"-mieee $CPPFLAGS\"\n\tCFLAGS=\"-mieee $CFLAGS\"\n\t;;\n    *-*-mingw*)\n\tCXXFLAGS=\"-D__USE_MINGW_ANSI_STDIO=1 $CXXFLAGS\"\n\tCFLAGS=\"-D__USE_MINGW_ANSI_STDIO=1 $CFLAGS\"\n\t;;\nesac\n\n# Do some more operating system specific setup. We put the file64_support\n# define in a substitution instead of simply a define because there\n# are source files (namely lxt support files) that don't include any\n# config.h header file.\nfile64_support=''\ncase \"${host}\" in\n    *-*-linux*)\n\tAC_DEFINE([_LARGEFILE_SOURCE], [1], [Indicates LFS (i.e. the ability to create files larger than 2 GiB on 32-bit operating systems).])\n\tfile64_support='-D_LARGEFILE_SOURCE=1 -D_FILE_OFFSET_BITS=64'\n\t;;\nesac\nAC_SUBST(file64_support)\n\n# fstapi.c (from GTKWave) needs this define.\nAC_CHECK_FUNCS(realpath)\n\n# Check that these functions exist. They are mostly C99\n# functions that older compilers may not yet support.\nAC_CHECK_FUNCS(fopen64)\n# The following math functions may be defined in the math library so look\n# in the default libraries first and then look in -lm for them. On some\n# systems we may need to use the compiler in C99 mode to get a definition.\n# We requested C99 mode earlier with AC_PROG_CC_C99.\nAC_SEARCH_LIBS([lround], [m], [AC_DEFINE([HAVE_LROUND], [1])])\nAC_SEARCH_LIBS([llround], [m], [AC_DEFINE([HAVE_LLROUND], [1])])\nAC_SEARCH_LIBS([nan], [m], [AC_DEFINE([HAVE_NAN], [1])])\nAC_SEARCH_LIBS([fmin], [m], [AC_DEFINE([HAVE_FMIN], [1])])\nAC_SEARCH_LIBS([fmax], [m], [AC_DEFINE([HAVE_FMAX], [1])])\n\n# Check to see if an unsigned long and uint64_t are the same from\n# a compiler perspective. We can not just check that they are the\n# same size since unsigned long and unsigned long long are not the\n# same from an overloading perspective even though they could be\n# the same size on some 64 bit machines. The result from this test\n# is only used if inttypes.h is available, so if the test fails for\n# that reason we don't care.\nAC_LANG(C++)\nAC_MSG_CHECKING(if uint64_t and unsigned long are identical)\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include \"inttypes.h\"\nstatic bool check(unsigned long val)\n{\n  return val != 0;\n}\nstatic bool check(uint64_t val)\n{\n  return val != 0;\n}]], [[unsigned long ulval = 1;\nbool result = check(ulval);\nuint64_t uival = 1;\nresult &= check(uival);\nreturn !result;]])],\n   [AC_MSG_RESULT(no)],\n   [AC_DEFINE([UINT64_T_AND_ULONG_SAME], [1]) AC_MSG_RESULT(yes)])\n\n# Linker option used when compiling the target\nAX_LD_RDYNAMIC\n\n# linker options when building a shared library\nAX_LD_SHAREDLIB_OPTS\n\n#######################\n## test for underscores. The vpi module loader needs to know this\n## in order to know the name of the start symbol for the .vpi module.\n#######################\n\nAX_C_UNDERSCORES_LEADING\nAX_C_UNDERSCORES_TRAILING\n\n#######################\n## end of test for underscores\n#######################\n\n#######################\n# Sanity check the configured results\n#######################\n\nAC_MSG_CHECKING(for sanity of prefix)\nif test `echo \"$prefix\" | wc -w` != 1\nthen\nAC_MSG_ERROR(cannot configure white space in prefix: $prefix)\nfi\nAC_MSG_RESULT(ok)\n\nAC_MSG_CHECKING(for sanity of exec_prefix)\nif test `echo \"$exec_prefix\" | wc -w` != 1\nthen\nAC_MSG_ERROR(cannot configure white space in exec_prefix: $exec_prefix)\nfi\nAC_MSG_RESULT(ok)\n\nAC_MSG_CHECKING(for sanity of libdir)\nif test `echo \"$libdir\" | wc -w` != 1\nthen\nAC_MSG_ERROR(cannot configure white space in libdir: $libdir)\nfi\nAC_MSG_RESULT(ok)\n\nAC_OUTPUT(Makefile ivlpp/Makefile vhdlpp/Makefile vvp/Makefile vpi/Makefile driver/Makefile driver-vpi/Makefile cadpli/Makefile libveriuser/Makefile tgt-null/Makefile tgt-stub/Makefile tgt-vvp/Makefile tgt-vhdl/Makefile tgt-fpga/Makefile tgt-verilog/Makefile tgt-pal/Makefile tgt-vlog95/Makefile tgt-pcb/Makefile tgt-blif/Makefile tgt-sizer/Makefile)\n",
        "/tmp/vanessa/spack-stage/spack-stage-icarus-v10_3-zkwcunjz5niqq3sdcjowpzxp4d6ea3ar/spack-src/vvp/vpi_modules.cc": "/*\n * Copyright (c) 2001-2010 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  \"config.h\"\n# include  \"vpi_priv.h\"\n# include  \"ivl_dlfcn.h\"\n# include  \"vvp_cleanup.h\"\n# include  <cstdio>\n# include  <cstring>\n# include  <sys/types.h>\n# include  <sys/stat.h>\n# include  \"ivl_alloc.h\"\n\nstatic ivl_dll_t*dll_list = 0;\nstatic unsigned dll_list_cnt = 0;\n\ntypedef void (*vlog_startup_routines_t)(void);\n\n\nconst char* vpip_module_path[64] = {\n#ifdef MODULE_DIR1\n      MODULE_DIR1,\n#endif\n#ifdef MODULE_DIR2\n      MODULE_DIR2,\n#endif\n      0\n};\n\nunsigned vpip_module_path_cnt = 0\n#ifdef MODULE_DIR1\n         + 1\n#endif\n#ifdef MODULE_DIR2\n         + 1\n#endif\n;\n\nvoid load_module_delete(void)\n{\n      for (unsigned idx = 0; idx < dll_list_cnt; idx += 1) {\n\t    ivl_dlclose(dll_list[idx]);\n      }\n      free(dll_list);\n      dll_list = 0;\n      dll_list_cnt = 0;\n}\n\nvoid vpip_load_module(const char*name)\n{\n      struct stat sb;\n      int rc;\n      bool export_flag = false;\n      char buf[4096];\n\n#ifdef __MINGW32__\n      const char sep = '\\\\';\n#else\n      const char sep = '/';\n#endif\n\n      ivl_dll_t dll = 0;\n      buf[0] = 0;                     /* terminate the string */\n      if (strchr(name, sep)) {\n\t      /* If the name has at least one directory character in\n\t\t it, then assume it is a complete name, maybe including any\n\t\t possible .vpi suffix. */\n\t    export_flag = false;\n\t    rc = stat(name, &sb);\n\n\t    if (rc != 0) {            /* did we find a file? */\n\t          /* no, try with a .vpi suffix too */\n\t\t  export_flag = false;\n\t\t  sprintf(buf, \"%s.vpi\", name);\n\t\t  rc = stat(buf, &sb);\n\n\t\t    /* Try also with the .vpl suffix. */\n\t\t  if (rc != 0) {\n\t\t\texport_flag = true;\n\t\t\tsprintf(buf, \"%s.vpl\", name);\n\t\t\trc = stat(buf, &sb);\n\t\t  }\n\n\t\t  if (rc != 0) {\n\t\t\tfprintf(stderr, \"%s: Unable to find module file `%s' \"\n\t\t\t\t\"or `%s.vpi'.\\n\", name,name,buf);\n\t\t\treturn;\n\t\t  }\n\t    } else {\n\t      strcpy(buf,name);   /* yes copy the name into the buffer */\n\t    }\n\n      } else {\n\t    rc = -1;\n\t    for (unsigned idx = 0\n\t\t       ; (rc != 0) && (idx < vpip_module_path_cnt)\n\t\t       ;  idx += 1) {\n\t\t  export_flag = false;\n\t\t  sprintf(buf, \"%s%c%s.vpi\", vpip_module_path[idx], sep, name);\n\t\t  rc = stat(buf,&sb);\n\n\t\t  if (rc != 0) {\n\t\t\texport_flag = true;\n\t\t\tsprintf(buf, \"%s%c%s.vpl\",\n\t\t\t\tvpip_module_path[idx], sep, name);\n\t\t\trc = stat(buf,&sb);\n\t\t  }\n\t    }\n\n\t    if (rc != 0) {\n\t\t  fprintf(stderr, \"%s: Unable to find a \"\n\t\t\t  \"`%s.vpi' module on the search path.\\n\",\n\t\t\t  name, name);\n\t\t  return;\n\t    }\n\n      }\n\n      /* must have found some file that could possibly be a vpi module\n       * try to open it as a shared object.\n       */\n      dll = ivl_dlopen(buf, export_flag);\n      if(dll==0) {\n\t/* hmm, this failed, let the user know what has really gone wrong */\n\tfprintf(stderr,\"%s:`%s' failed to open using dlopen() because:\\n\"\n\t\t\"    %s.\\n\",name,buf,dlerror());\n\n\treturn;\n      }\n\n\n#ifdef __MINGW32__\n\t/* For this check MinGW does not want the leading underscore! */\n      void*table = ivl_dlsym(dll, \"vlog_startup_routines\");\n#else\n      void*table = ivl_dlsym(dll, LU \"vlog_startup_routines\" TU);\n#endif\n      if (table == 0) {\n\t    fprintf(stderr, \"%s: no vlog_startup_routines\\n\", name);\n\t    ivl_dlclose(dll);\n\t    return;\n      }\n\n\t/* Add the dll to the list so it can be closed when we are done. */\n      dll_list_cnt += 1;\n      dll_list = (ivl_dll_t*)realloc(dll_list, dll_list_cnt*sizeof(ivl_dll_t));\n      dll_list[dll_list_cnt-1] = dll;\n\n      vpi_mode_flag = VPI_MODE_REGISTER;\n      vlog_startup_routines_t*routines = (vlog_startup_routines_t*)table;\n      for (unsigned tmp = 0 ;  routines[tmp] ;  tmp += 1)\n\t    (routines[tmp])();\n      vpi_mode_flag = VPI_MODE_NONE;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icarus-v10_3-zkwcunjz5niqq3sdcjowpzxp4d6ea3ar/spack-src/vvp/ivl_dlfcn.h": "#ifndef IVL_ivl_dlfcn_H\n#define IVL_ivl_dlfcn_H\n/*\n * Copyright (c) 2001-2014 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n#if defined(__MINGW32__)\n# include <windows.h>\n# include <cstdio>\ntypedef void * ivl_dll_t;\n#elif defined(HAVE_DLFCN_H)\n# include  <dlfcn.h>\ntypedef void* ivl_dll_t;\n#elif defined(HAVE_DL_H)\n# include  <dl.h>\ntypedef shl_t ivl_dll_t;\n#endif\n\n#if defined(__MINGW32__)\ninline ivl_dll_t ivl_dlopen(const char *name, bool)\n{\n      static char full_name[4096];\n      unsigned long length = GetFullPathName(name, sizeof(full_name),\n                                             full_name, NULL);\n      if ((length == 0) || (length > sizeof(full_name)))\n            return 0;\n\n      return (void *)LoadLibrary(full_name);\n}\n\ninline void *ivl_dlsym(ivl_dll_t dll, const char *nm)\n{ return (void *)GetProcAddress((HINSTANCE)dll,nm);}\n\ninline void ivl_dlclose(ivl_dll_t dll)\n{ (void)FreeLibrary((HINSTANCE)dll);}\n\ninline const char *dlerror(void)\n{\n  static char msg[256];\n  unsigned long err = GetLastError();\n  FormatMessage(\n\t\tFORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\tNULL,\n\t\terr,\n\t\tMAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language\n\t\t(LPTSTR) &msg,\n\t\tsizeof(msg) - 1,\n\t\tNULL\n\t\t);\n  return msg;\n}\n\n#elif defined(HAVE_DLFCN_H)\ninline ivl_dll_t ivl_dlopen(const char*name, bool global_flag)\n{ return dlopen(name,RTLD_LAZY|(global_flag?RTLD_GLOBAL:0)); }\n\ninline void* ivl_dlsym(ivl_dll_t dll, const char*nm)\n{\n      void*sym = dlsym(dll, nm);\n\t/* Not found? try without the leading _ */\n      if (sym == 0 && nm[0] == '_')\n\t    sym = dlsym(dll, nm+1);\n      return sym;\n}\n\ninline void ivl_dlclose(ivl_dll_t dll)\n{ dlclose(dll); }\n\n#elif defined(HAVE_DL_H)\ninline ivl_dll_t ivl_dlopen(const char*name)\n{ return shl_load(name, BIND_IMMEDIATE, 0); }\n\ninline void* ivl_dlsym(ivl_dll_t dll, const char*nm)\n{\n      void*sym;\n      int rc = shl_findsym(&dll, nm, TYPE_PROCEDURE, &sym);\n      return (rc == 0) ? sym : 0;\n}\n\ninline void ivl_dlclose(ivl_dll_t dll)\n{ shl_unload(dll); }\n\ninline const char*dlerror(void)\n{ return strerror( errno ); }\n#endif\n\n#endif /* IVL_ivl_dlfcn_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-icarus-v10_3-zkwcunjz5niqq3sdcjowpzxp4d6ea3ar/spack-src/cadpli/cadpli.c": "/*\n * Copyright (c) 2003-2010 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n# include  <vpi_user.h>\n# include  <veriuser.h>\n# include  <stdlib.h>\n# include  <string.h>\n# include  <assert.h>\n# include  \"config.h\"\n# include  \"ivl_dlfcn.h\"\n# include  \"ivl_alloc.h\"\n\ntypedef void* (*funcvp)(void);\n\nstatic void thunker_register(void)\n{\n      struct t_vpi_vlog_info vlog_info;\n      void*mod;\n      void*boot;\n      struct t_tfcell*tf;\n      int idx;\n\n      vpi_get_vlog_info(&vlog_info);\n\n      for (idx = 0 ;  idx < vlog_info.argc ;  idx += 1) {\n\t    char*module, *cp, *bp;\n\t    if (strncmp(\"-cadpli=\", vlog_info.argv[idx], 8) != 0)\n\t\t  continue;\n\n\t    cp = vlog_info.argv[idx] + 8;\n\t    assert(cp);\n\n\t    bp = strchr(cp, ':');\n\t    assert(bp);\n\n\t    module = malloc(bp-cp+1);\n\t    strncpy(module, cp, bp-cp);\n\t    module[bp-cp] = 0;\n\n\t    mod = ivl_dlopen(module);\n\t    if (mod == 0) {\n\t\t  vpi_printf(\"%s link: %s\\n\", vlog_info.argv[idx], dlerror());\n\t\t  free(module);\n\t\t  continue;\n\t    }\n\n\t    bp += 1;\n\t    boot = ivl_dlsym(mod, bp);\n\t    if (boot == 0) {\n\t\t  vpi_printf(\"%s: Symbol %s not found.\\n\",\n\t\t\t     vlog_info.argv[idx], bp);\n\t\t  free(module);\n\t\t  continue;\n\t    }\n\n\t    free(module);\n\t    assert(boot);\n\n\t    tf = (*((funcvp)boot))();\n\t    assert(tf);\n\n\t    veriusertfs_register_table(tf);\n      }\n}\n\nvoid (*vlog_startup_routines[])(void) = {\n      thunker_register,\n      0\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-icarus-v10_3-zkwcunjz5niqq3sdcjowpzxp4d6ea3ar/spack-src/cadpli/ivl_dlfcn.h": "#ifndef IVL_ivl_dlfcn_H\n#define IVL_ivl_dlfcn_H\n/*\n * Copyright (c) 2001-2014 Stephen Williams (steve@icarus.com)\n *\n *    This source code is free software; you can redistribute it\n *    and/or modify it in source code form under the terms of the GNU\n *    General Public License as published by the Free Software\n *    Foundation; either version 2 of the License, or (at your option)\n *    any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n#if defined(__MINGW32__)\n# include <windows.h>\n# include <stdio.h>\ntypedef void * ivl_dll_t;\n#elif defined(HAVE_DLFCN_H)\n# include  <dlfcn.h>\ntypedef void* ivl_dll_t;\n#elif defined(HAVE_DL_H)\n# include  <dl.h>\ntypedef shl_t ivl_dll_t;\n#endif\n\n#if defined(__MINGW32__)\nstatic __inline__ ivl_dll_t ivl_dlopen(const char *name)\n{ return (void *)LoadLibrary(name); }\n\nstatic __inline__ void *ivl_dlsym(ivl_dll_t dll, const char *nm)\n{ return (void *)GetProcAddress((HINSTANCE)dll,nm);}\n\nstatic __inline__ void ivl_dlclose(ivl_dll_t dll)\n{ (void)FreeLibrary((HINSTANCE)dll);}\n\nstatic __inline__ const char *dlerror(void)\n{\n  static char msg[256];\n  unsigned long err = GetLastError();\n  FormatMessage(\n\t\tFORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\tNULL,\n\t\terr,\n\t\tMAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language\n\t\t(LPTSTR) &msg,\n\t\tsizeof(msg) - 1,\n\t\tNULL\n\t\t);\n  return msg;\n}\n\n#elif defined(HAVE_DLFCN_H)\nstatic __inline__ ivl_dll_t ivl_dlopen(const char*name)\n{ return dlopen(name,RTLD_LAZY); }\n\nstatic __inline__ void* ivl_dlsym(ivl_dll_t dll, const char*nm)\n{\n      void*sym = dlsym(dll, nm);\n\t/* Not found? try without the leading _ */\n      if (sym == 0 && nm[0] == '_')\n\t    sym = dlsym(dll, nm+1);\n      return sym;\n}\n\nstatic __inline__ void ivl_dlclose(ivl_dll_t dll)\n{ dlclose(dll); }\n\n#elif defined(HAVE_DL_H)\nstatic __inline__ ivl_dll_t ivl_dlopen(const char*name)\n{ return shl_load(name, BIND_IMMEDIATE, 0); }\n\nstatic __inline__ void* ivl_dlsym(ivl_dll_t dll, const char*nm)\n{\n      void*sym;\n      int rc = shl_findsym(&dll, nm, TYPE_PROCEDURE, &sym);\n      return (rc == 0) ? sym : 0;\n}\n\nstatic __inline__ void ivl_dlclose(ivl_dll_t dll)\n{ shl_unload(dll); }\n\nstatic __inline__ const char*dlerror(void)\n{ return strerror( errno ); }\n#endif\n\n#endif /* IVL_ivl_dlfcn_H */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-icarus-v10_3-zkwcunjz5niqq3sdcjowpzxp4d6ea3ar/spack-src/.git/objects/pack/pack-f8d314ac61b9bb88ae8db3c546ef78be03ea3c50.pack",
        "/tmp/vanessa/spack-stage/spack-stage-icarus-v10_3-zkwcunjz5niqq3sdcjowpzxp4d6ea3ar/spack-src/.git/objects/pack/pack-f8d314ac61b9bb88ae8db3c546ef78be03ea3c50.idx"
    ],
    "total_files": 728
}