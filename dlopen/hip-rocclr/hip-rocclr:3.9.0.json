{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.9.0-neudjleb7hiztwlofocdddh3xyfxtn44/spack-src/device/pal/paldevicegl.cpp": "/* Copyright (c) 2015-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#include \"platform/context.hpp\"\n#include \"device/device.hpp\"\n#include \"platform/runtime.hpp\"\n#include \"platform/agent.hpp\"\n#ifdef _WIN32\n#include <d3d10_1.h>\n#include \"CL/cl_d3d10.h\"\n#include \"CL/cl_d3d11.h\"\n#endif  // _WIN32\n\n#include <GL/gl.h>\n#include <GL/glext.h>\n#include \"CL/cl_gl.h\"\n#include \"paldevice.hpp\"\n//#include \"cwddeci.h\"\n#include <GL/gl.h>\n#include \"GL/glATIInternal.h\"\n#ifdef ATI_OS_LINUX\n#include <stdlib.h>\n#include <dlfcn.h>\n#include \"GL/glx.h\"\n#include \"GL/glxext.h\"\n#include \"GL/glXATIPrivate.h\"\n#else\n#include \"GL/wglATIPrivate.h\"\n#endif\n\n/**\n * Device information returned by Mesa/Orca.\n */\ntypedef struct _mesa_glinterop_device_info {\n  uint32_t size; /* size of this structure */\n\n  /* PCI location */\n  uint32_t pci_segment_group;\n  uint32_t pci_bus;\n  uint32_t pci_device;\n  uint32_t pci_function;\n\n  /* Device identification */\n  uint32_t vendor_id;\n  uint32_t device_id;\n} mesa_glinterop_device_info;\n\n#ifdef ATI_OS_LINUX\ntypedef void* (*PFNGlxGetProcAddress)(const GLubyte* procName);\nstatic PFNGlxGetProcAddress pfnGlxGetProcAddress = nullptr;\ntypedef int(APIENTRYP PFNMesaGLInteropGLXQueryDeviceInfo)(Display* dpy, GLXContext context,\n                                                          mesa_glinterop_device_info* out);\nstatic PFNMesaGLInteropGLXQueryDeviceInfo pfnMesaGLInteropGLXQueryDeviceInfo = nullptr;\nstatic PFNGLXBEGINCLINTEROPAMD glXBeginCLInteropAMD = nullptr;\nstatic PFNGLXENDCLINTEROPAMD glXEndCLInteropAMD = nullptr;\nstatic PFNGLXRESOURCEATTACHAMD glXResourceAttachAMD = nullptr;\nstatic PFNGLXRESOURCEDETACHAMD glxResourceAcquireAMD = nullptr;\nstatic PFNGLXRESOURCEDETACHAMD glxResourceReleaseAMD = nullptr;\nstatic PFNGLXRESOURCEDETACHAMD glXResourceDetachAMD = nullptr;\nstatic PFNGLXGETCONTEXTMVPUINFOAMD glXGetContextMVPUInfoAMD = nullptr;\n#else\nstatic PFNWGLBEGINCLINTEROPAMD wglBeginCLInteropAMD = nullptr;\nstatic PFNWGLENDCLINTEROPAMD wglEndCLInteropAMD = nullptr;\nstatic PFNWGLRESOURCEATTACHAMD wglResourceAttachAMD = nullptr;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceAcquireAMD = nullptr;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceReleaseAMD = nullptr;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceDetachAMD = nullptr;\nstatic PFNWGLGETCONTEXTGPUINFOAMD wglGetContextGPUInfoAMD = nullptr;\n#endif\n\nnamespace pal {\n\n//\n/// GSL Surface Formats as per defined in cmSurfFmtEnum enum in\n/// //depot/stg/ugl/drivers/ugl/src/include/cm_enum.h\n//\ntypedef enum cmSurfFmtEnum {\n  CM_SURF_FMT_NOOVERRIDE = -1,\n  CM_SURF_FMT_LUMINANCE8,    ///< Luminance,  8 bits per element packed as (@c LLLLLLLL)\n  CM_SURF_FMT_LUMINANCE16,   ///< Luminance, 16 bits per element packed as (@c LLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE16F,  ///< Luminance, 16 bits per element packed as (@c LLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE32F,  ///< Luminance, 32 bits per element packed as (@c\n                             ///< LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_INTENSITY8,    ///< Intensity,  8 bits per element packed as (@c IIIIIIII)\n  CM_SURF_FMT_INTENSITY16,   ///< Intensity, 16 bits per element packed as (@c IIIIIIIIIIIIIIII)\n  CM_SURF_FMT_INTENSITY16F,  ///< Intensity, 16 bits per element packed as (@c IIIIIIIIIIIIIIII)\n  CM_SURF_FMT_INTENSITY32F,  ///< Intensity, 32 bits per element packed as (@c\n                             ///< IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII)\n  CM_SURF_FMT_ALPHA8,        ///< Alpha,      8 bits per element packed as (@c AAAAAAAA)\n  CM_SURF_FMT_ALPHA16,       ///< Alpha,     16 bits per element packed as (@c AAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_ALPHA16F,      ///< Alpha,     16 bits per element packed as (@c AAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_ALPHA32F,      ///< Alpha,     32 bits per element packed as (@c\n                             ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_LUMINANCE8_ALPHA8,      ///< Luminance Alpha, 16 bits per element packed as (@c\n                                      ///< AAAAAAAALLLLLLLL)\n  CM_SURF_FMT_LUMINANCE16_ALPHA16,    ///< Luminance Alpha, 32 bits per element packed as (@c\n                                      ///< AAAAAAAAAAAAAAAALLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE16F_ALPHA16F,  ///< Luminance Alpha, 32 bits per element packed as (@c\n                                      ///< AAAAAAAAAAAAAAAALLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE32F_ALPHA32F,  ///< Luminance Alpha, 64 bits per element packed as (@c\n                                      ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_B2_G3_R3,  ///< RGB,    8 bits per element packed as (@c RRRGGGBB)\n  CM_SURF_FMT_B5_G6_R5,  ///< RGB,   16 bits per element packed as (@c RRRRRGGGGGGBBBBB)\n  CM_SURF_FMT_BGRX4,     ///< RGB,   16 bits per element packed as (@c XXXXRRRRGGGGBBBB)\n  CM_SURF_FMT_BGR5_X1,   ///< RGB,   16 bits per element packed as (@c XRRRRRGGGGGBBBBB)\n  CM_SURF_FMT_BGRX8,     ///< RGB,   32 bits per element packed as (@c\n                         ///< XXXXXXXXRRRRRRRRGGGGGGGGBBBBBBBB) - XXX unused by current driver\n  CM_SURF_FMT_BGR10_X2,  ///< RGB,   32 bits per element packed as (@c\n                         ///< XXRRRRRRRRRRGGGGGGGGGGBBBBBBBBBB)\n  CM_SURF_FMT_BGRX16,    ///< RGB,   64 bits per element packed as (@c\n                         ///< XXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_BGRX16F,   ///< RGB,   64 bits per element packed as (@c\n                         ///< XXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_BGRX32F,   ///< RGB,  128 bits per element packed as (@c\n                        ///< XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_RGBX4,     ///< RGB,   16 bits per element packed as (@c XXXXBBBBGGGGRRRR)\n  CM_SURF_FMT_RGB5_X1,   ///< RGB,   16 bits per element packed as (@c XBBBBBGGGGGRRRRR)\n  CM_SURF_FMT_RGBX8,     ///< RGB,   32 bits per element packed as (@c\n                         ///< XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGB10_X2,  ///< RGB,   32 bits per element packed as (@c\n                         ///< XXBBBBBBBBBBGGGGGGGGGGRRRRRRRRRR)\n  CM_SURF_FMT_RGBX16,    ///< RGB,   64 bits per element packed as (@c\n                         ///< XXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBX16F,   ///< RGB,   64 bits per element packed as (@c\n                         ///< XXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBX32F,   ///< RGB,  128 bits per element packed as (@c\n                        ///< XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_BGRA4,     ///< RGBA,  16 bits per element packed as (@c AAAARRRRGGGGBBBB)\n  CM_SURF_FMT_BGR5_A1,   ///< RGBA,  16 bits per element packed as (@c ARRRRRGGGGGBBBBB)\n  CM_SURF_FMT_BGRA8,     ///< RGBA,  32 bits per element packed as (@c\n                         ///< AAAAAAAARRRRRRRRGGGGGGGGBBBBBBBB)\n  CM_SURF_FMT_BGR10_A2,  ///< RGBA,  32 bits per element packed as (@c\n                         ///< AARRRRRRRRRRGGGGGGGGGGBBBBBBBBBB)\n  CM_SURF_FMT_BGRA16,    ///< RGBA,  64 bits per element packed as (@c\n                         ///< AAAAAAAAAAAAAAAARRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_BGRA16F,   ///< RGBA,  64 bits per element packed as (@c\n                         ///< AAAAAAAAAAAAAAAARRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_BGRA32F,   ///< RGBA, 128 bits per element packed as (@c\n                        ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_RGBA4,     ///< RGBA,  16 bits per element packed as (@c AAAABBBBGGGGRRRR)\n  CM_SURF_FMT_RGB5_A1,   ///< RGBA,  16 bits per element packed as (@c ABBBBBGGGGGRRRRR)\n  CM_SURF_FMT_RGBA8,     ///< RGBA,  32 bits per element packed as (@c\n                         ///< AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGB10_A2,  ///< RGBA,  32 bits per element packed as (@c\n                         ///< AABBBBBBBBBBGGGGGGGGGGRRRRRRRRRR)\n  CM_SURF_FMT_RGBA16,    ///< RGBA,  64 bits per element packed as (@c\n                         ///< AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBA16F,   ///< RGBA,  64 bits per element packed as (@c\n                         ///< AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBA32I,   ///< RGBA, 128 bits per element packed as (@c\n                        ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBA32F,  ///< RGBA, 128 bits per element packed as (@c\n                        ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_DUDV8,    ///< DUDV   16 bits per element packed as (@c VVVVVVVVUUUUUUUU)\n  CM_SURF_FMT_DXT1,     ///< compressed, DXT1\n  CM_SURF_FMT_DXT2_3,   ///< compressed, DXT2_3\n  CM_SURF_FMT_DXT4_5,   ///< compressed, DXT4_5\n  CM_SURF_FMT_ATI1N,    ///< compressed, 1 component\n  CM_SURF_FMT_ATI2N,    ///< compressed, 2 component\n  CM_SURF_FMT_DEPTH16,  ///< depth, 16 bits per element packed as (@c DDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH16F,            ///< depth, 16 bits per element packed as (@c DDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH24_X8,          ///< depth, 32 bits per element packed as (@c\n                                   ///< XXXXXXXXDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH24F_X8,         ///< depth, 32 bits per element packed as (@c\n                                   ///< SSSSSSSSDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH24_STEN8,       ///< depth + stencil, 32 bits per element packed as (@c\n                                   ///< SSSSSSSSDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH24F_STEN8,      ///< depth + stencil, 32 bits per element packed as (@c\n                                   ///< SSSSSSSSDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH32F_X24_STEN8,  ///< depth + stencil, 64 bits per element packed as (@c\n                                   ///< XXXXXXXXXXXXXXXXXXXXXXXXSSSSSSSSDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH32F,        ///< depth, 32 bits per element packed as (@c\n                               ///< DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_sR11_sG11_sB10,  ///< RGB,   32 bits per element packed as (@c\n                               ///< RRRRRRRRRRRGGGGGGGGGGGBBBBBBBBBB)\n  CM_SURF_FMT_sU16,            ///<\n  CM_SURF_FMT_sUV16,           ///<\n  CM_SURF_FMT_sUVWQ16,         ///<\n  CM_SURF_FMT_RG16,  ///< RG,    32 bits per element packed as (@c RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_RG16F,     ///< RG,    32 bits per element packed as (@c\n                         ///< RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_RG32F,     ///< RG,    64 bits per element packed as (@c\n                         ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_ABGR4,     ///< RGBA,  16 bits per element packed as (@c RRRRGGGGBBBBAAAA)\n  CM_SURF_FMT_A1_BGR5,   ///< RGBA,  16 bits per element packed as (@c RRRRRGGGGGBBBBBA)\n  CM_SURF_FMT_ABGR8,     ///< RGBA,  32 bits per element packed as (@c\n                         ///< RRRRRRRRGGGGGGGGBBBBBBBBAAAAAAAA)\n  CM_SURF_FMT_A2_BGR10,  ///< RGBA,  32 bits per element packed as (@c\n                         ///< RRRRRRRRRRGGGGGGGGGGBBBBBBBBBBAA)\n  CM_SURF_FMT_ABGR16,    ///< RGBA,  64 bits per element packed as (@c\n                         ///< RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_ABGR16F,   ///< RGBA,  64 bits per element packed as (@c\n                         ///< RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_ABGR32F,   ///< RGBA, 128 bits per element packed as (@c\n                        ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_DXT1A,\n  CM_SURF_FMT_sRGB10_A2,  ///< RGBA,  32  bits per element packed as signed (@c\n                          ///< AABBBBBBBBBBGGGGGGGGGGRRRRRRRRRR)\n  CM_SURF_FMT_sR8,        ///< R,     8   bits per element packed as signed (@c RRRRRRRR)\n  CM_SURF_FMT_sRG8,       ///< RG,    16  bits per element packed as signed (@c RRRRRRRRGGGGGGGG)\n  CM_SURF_FMT_sR32I,      ///< R,     32  bits per element packed as signed (@c\n                          ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_sRG32I,     ///< RG,    64  bits per element packed as signed (@c\n                          ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_sRGBA32I,   ///< RGBA,  128 bits per element packed as signed (@c\n                         ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_R32I,    ///< R,     32  bits per element packed as (@c\n                       ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RG32I,   ///< RG,    64  bits per element packed as (@c\n                       ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_RG8,     ///< RG8,   16 bits per element packed as (@c RRRRRRRRGGGGGGGG)\n  CM_SURF_FMT_sRGBA8,  ///< RGBA8, 32 bits per element packed as signed (@c\n                       ///< RRRRRRRRGGGGGGGGBBBBBBBBAAAAAAAA)\n  CM_SURF_FMT_R11F_G11F_B10F,                ///< RGB,   32 bits per element packed as (@c\n                                             ///< BBBBBBBBBBGGGGGGGGGGGRRRRRRRRRRR)\n  CM_SURF_FMT_RGB9_E5,                       ///< RGB,   32 bits per element packed as (@c\n                                             ///< EEEEEBBBBBBBBBGGGGGGGGGRRRRRRRRR)\n  CM_SURF_FMT_LUMINANCE_LATC1,               ///< compressed LATC1\n  CM_SURF_FMT_SIGNED_LUMINANCE_LATC1,        ///< compressed signed LATC1\n  CM_SURF_FMT_LUMINANCE_ALPHA_LATC2,         ///< compressed LATC2\n  CM_SURF_FMT_SIGNED_LUMINANCE_ALPHA_LATC2,  ///< compressed signed LATC2\n  CM_SURF_FMT_RED_RGTC1,                     ///< compressed RGTC1\n  CM_SURF_FMT_SIGNED_RED_RGTC1,              ///< compressed signed RGTC1\n  CM_SURF_FMT_RED_GREEN_RGTC2,               ///< compressed RGTC2\n  CM_SURF_FMT_SIGNED_RED_GREEN_RGTC2,        ///< compressed signed RGTC2\n  CM_SURF_FMT_R8,                            ///< R,     8   bits per element packed (@c RRRRRRRR)\n  CM_SURF_FMT_R16,     ///< R,    16   bits per element packed (@c RRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_R16F,    ///< R,    16   bits per element packed (@c RRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_R32F,    ///< R,    32   bits per element packed (@c RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_R8I,     ///< R,     8   bits per element packed (@c RRRRRRRR)\n  CM_SURF_FMT_sR8I,    ///< R,     8   bits per element packed as signed (@c RRRRRRRR)\n  CM_SURF_FMT_RG8I,    ///< RG,   16   bits per element packed (@c RRRRRRRRGGGGGGGG)\n  CM_SURF_FMT_sRG8I,   ///< RG,   16   bits per element packed as signed (@c RRRRRRRRGGGGGGGG)\n  CM_SURF_FMT_R16I,    ///< R,    16   bits per element packed (@c RRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_sR16I,   ///< R,    16   bits per element packed as signed (@c RRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RG16I,   ///< RG,   32   bits per element packed (@c RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_sRG16I,  ///< RG,   32   bits per element packed as signed (@c\n                       ///< RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_RGBA32UI,  ///< RGBA, 128 bits per element packed as (@c\n                         ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_RGBX32UI,  ///< RGBX,  128 bits per element packed as(@c\n                         ///< XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_ALPHA32UI,            ///< Alpha, 32 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_INTENSITY32UI,        ///< Intensity, 32 bits per element packed as (@c\n                                    ///< IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII)\n  CM_SURF_FMT_LUMINANCE32UI,        ///< Luminance, 32 bits per element packed as (@c\n                                    ///< LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE_ALPHA32UI,  ///< Luminance Alpha, 64 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_RGBA16UI,       ///< RGBA,  64 bits per element packed as (@c\n                              ///< AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBX16UI,       ///< RGB,   64 bits per element packed as (@c\n                              ///< XXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_ALPHA16UI,      ///< Alpha, 16 bits per element packed as (@c AAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_INTENSITY16UI,  ///< Intensity, 16 bits per element packed as (@c IIIIIIIIIIIIIIII)\n  CM_SURF_FMT_LUMINANCE16UI,  ///< Luminance, 16 bits per element packed as (@c LLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE_ALPHA16UI,  ///< Luminance Alpha, 32 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAALLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_RGBA8UI,              ///< RGBA,  32 bits per element packed as (@c\n                                    ///< AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGBX8UI,              ///< RGB,   32 bits per element packed as (@c\n                                    ///< XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_ALPHA8UI,             ///< Alpha, 8 bits per element packed as (@c AAAAAAAA)\n  CM_SURF_FMT_INTENSITY8UI,         ///< Intensity, 8 bits per element packed as (@c IIIIIIII)\n  CM_SURF_FMT_LUMINANCE8UI,         ///< Luminance, 8 bits per element packed as (@c LLLLLLLL)\n  CM_SURF_FMT_LUMINANCE_ALPHA8UI,   ///< Luminance Alpha, 32 bits per element packed as (@c\n                                    ///< AAAAAAAALLLLLLLL)\n  CM_SURF_FMT_sRGBX32I,             ///< RGBX,  128 bits per element packed as(@c\n                         ///< XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_sALPHA32I,            ///< Alpha, 32 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_sINTENSITY32I,        ///< Intensity, 32 bits per element packed as (@c\n                                    ///< IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII)\n  CM_SURF_FMT_sLUMINANCE32I,        ///< Luminance, 32 bits per element packed as (@c\n                                    ///< LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_sLUMINANCE_ALPHA32I,  ///< Luminance Alpha, 64 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_sRGBA16I,       ///< RGBA,  64 bits per element packed as (@c\n                              ///< AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_sRGBX16I,       ///< RGB,   64 bits per element packed as (@c\n                              ///< XXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_sALPHA16I,      ///< Alpha, 16 bits per element packed as (@c AAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_sINTENSITY16I,  ///< Intensity, 16 bits per element packed as (@c IIIIIIIIIIIIIIII)\n  CM_SURF_FMT_sLUMINANCE16I,  ///< Luminance, 16 bits per element packed as (@c LLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_sLUMINANCE_ALPHA16I,  ///< Luminance Alpha, 32 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAALLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_sRGBA8I,              ///< RGBA,  32 bits per element packed as (@c\n                                    ///< AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_sRGBX8I,              ///< RGB,   32 bits per element packed as (@c\n                                    ///< XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_sALPHA8I,             ///< Alpha, 8 bits per element packed as (@c AAAAAAAA)\n  CM_SURF_FMT_sINTENSITY8I,         ///< Intensity, 8 bits per element packed as (@c IIIIIIII)\n  CM_SURF_FMT_sLUMINANCE8I,         ///< Luminance, 8 bits per element packed as (@c LLLLLLLL)\n  CM_SURF_FMT_sLUMINANCE_ALPHA8I,   ///< Alpha, 8 bits per element packed as (@c AAAAAAAA)\n  CM_SURF_FMT_sDXT6,                ///< compressed, CM_SURF_FMT_sDXT6\n  CM_SURF_FMT_DXT6,                 ///< compressed, CM_SURF_FMT_DXT6\n  CM_SURF_FMT_DXT7,                 ///< compressed, DXT7\n  CM_SURF_FMT_LUMINANCE8_SNORM,   ///< Luminance,  8 bits per element packed as signed (@c LLLLLLLL)\n  CM_SURF_FMT_LUMINANCE16_SNORM,  ///< Luminance, 16 bits per element packed as signed (@c\n                                  ///< LLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_INTENSITY8_SNORM,   ///< Intensity,  8 bits per element packed as signed (@c IIIIIIII)\n  CM_SURF_FMT_INTENSITY16_SNORM,  ///< Intensity, 16 bits per element packed as signed (@c\n                                  ///< IIIIIIIIIIIIIIII)\n  CM_SURF_FMT_ALPHA8_SNORM,       ///< Alpha,      8 bits per element packed as signed (@c AAAAAAAA)\n  CM_SURF_FMT_ALPHA16_SNORM,      ///< Alpha,     16 bits per element packed as signed (@c\n                                  ///< AAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_LUMINANCE_ALPHA8_SNORM,   ///< Luminance Alpha, 16 bits per element packed as signed\n                                        ///< (@c AAAAAAAALLLLLLLL)\n  CM_SURF_FMT_LUMINANCE_ALPHA16_SNORM,  ///< Luminance Alpha, 32 bits per element packed as signed\n                                        ///< (@c AAAAAAAAAAAAAAAALLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_R8_SNORM,      ///< R,     8   bits per element packed as signed (@c RRRRRRRR)\n  CM_SURF_FMT_R16_SNORM,     ///< R,    16   bits per element packed as signed (@c RRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RG8_SNORM,     ///< RG8,   16 bits per element packed as signed (@c RRRRRRRRGGGGGGGG)\n  CM_SURF_FMT_RG16_SNORM,    ///< RG,    32 bits per element packed as signed (@c\n                             ///< RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_RGBX8_SNORM,   ///< RGB,   32 bits per element packed as signed (@c\n                             ///< XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGBX16_SNORM,  ///< RGB,   64 bits per element packed as signed (@c\n                             ///< XXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBA8_SNORM,   ///< RGBA,  32 bits per element packed as signed (@c\n                             ///< AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGBA16_SNORM,  ///< RGBA,  64 bits per element packed as signed (@c\n                             ///< AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGB10_A2UI,    ///< RGBA,  32 bits per element packed as (@c\n                             ///< AABBBBBBBBBBGGGGGGGGGGRRRRRRRRRR)\n  CM_SURF_FMT_RGB32F,        ///< RGB, float, 96 bits per element packed as (@c\n                       ///< BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGB32I,  ///< RGB, unnormalized int, 96 bits per element packed as (@c\n                       ///< BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGB32UI,  ///< RGB, unnormalized uint, 96 bits per element packed as (@c\n                        ///< BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBX8_SRGB,             ///< RGB,   32 bits per element packed as (@c\n                                      ///< XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGBA8_SRGB,             ///< RGBA,  32 bits per element packed as (@c\n                                      ///< AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_DXT1_SRGB,              ///< compressed, DXT1\n  CM_SURF_FMT_DXT1A_SRGB,             ///<\n  CM_SURF_FMT_DXT2_3_SRGB,            ///< compressed, DXT2_3\n  CM_SURF_FMT_DXT4_5_SRGB,            ///< compressed, DXT4_5\n  CM_SURF_FMT_DXT7_SRGB,              ///< compressed, DXT7\n  CM_SURF_FMT_RGB8_ETC2,              ///< ETC2 compressed, RGB8 in 64 bits\n  CM_SURF_FMT_SRGB8_ETC2,             ///< ETC2 compressed, SRGB8 in 64 bits\n  CM_SURF_FMT_RGB8_PT_ALPHA1_ETC2,    ///< ETC2 compressed, RGB8 in 64 bits\n  CM_SURF_FMT_SRGB8_PT_ALPHA1_ETC2,   ///< ETC2 compressed, sRGB8A1 in 64 bits\n  CM_SURF_FMT_RGBA8_ETC2_EAC,         ///< ETC2 compressed, RGBA8 in 128 bits\n  CM_SURF_FMT_SRGB8_ALPHA8_ETC2_EAC,  ///< ETC2 compressed, sRGBA8 in 128 bits\n  CM_SURF_FMT_R11_EAC,                ///< EAC compressed, R11 in 64 bits\n  CM_SURF_FMT_SIGNED_R11_EAC,         ///< EAC compressed, signed R11 in 64 bits\n  CM_SURF_FMT_RG11_EAC,               ///< EAC compressed, RG11 in 128 bits\n  CM_SURF_FMT_SIGNED_RG11_EAC,        ///< EAC compressed, signed RG11 in 128 bits\n\n  CM_SURF_FMT_RGBA8_ASTC_4x4,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_5x4,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_5x5,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_6x5,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_6x6,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_8x5,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_8x6,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_8x8,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_10x5,   ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_10x6,   ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_10x8,   ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_10x10,  ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_12x10,  ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_12x12,  ///< ASTC compressed RGBA8 in 128 bits block\n\n  CM_SURF_FMT_SRGBA8_ASTC_4x4,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_5x4,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_5x5,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_6x5,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_6x6,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_8x5,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_8x6,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_8x8,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_10x5,   ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_10x6,   ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_10x8,   ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_10x10,  ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_12x10,  ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_12x12,  ///< ASTC compressed SRGBA8 in 128 bits block\n\n  CM_SURF_FMT_BGR10_A2UI,  ///< RGBA,  32 bits per element packed as (@c\n                           ///< AARRRRRRRRRRGGGGGGGGGGBBBBBBBBBB)\n  CM_SURF_FMT_A2_BGR10UI,  ///< RGBA,  32 bits per element packed as (@c\n                           ///< RRRRRRRRRRGGGGGGGGGGBBBBBBBBBBAA)\n  CM_SURF_FMT_A2_RGB10UI,  ///< RGBA,  32 bits per element packed as (@c\n                           ///< BBBBBBBBBBGGGGGGGGGGRRRRRRRRRRAA)\n  CM_SURF_FMT_B5_G6_R5UI,  ///< RGB,   16 bits per element packed as (@c BBBBBGGGGGGRRRRR)\n  CM_SURF_FMT_R5_G6_B5UI,  ///< RGB,   16 bits per element packed as (@c RRRRRGGGGGGBBBBB)\n\n  CM_SURF_FMT_DEPTH32F_X24_STEN8_UNCLAMPED,  ///< depth + stencil, 64 bits per element packed as (@c\n                                             ///< XXXXXXXXXXXXXXXXXXXXXXXXSSSSSSSSDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH32F_UNCLAMPED,  ///< depth, 32 bits per element packed as (@c\n                                   ///< DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD)\n\n  CM_SURF_FMT_L8_X16_A8_SRGB,  ///< Sluminance Alpha,  32 bits per element packed as (@c\n                               ///< AAAAAAAAXXXXXXXXXXXXXXXXLLLLLLLL)\n  CM_SURF_FMT_L8_X24_SRGB,     ///< Sluminance,        32 bits per element packed as (@c\n                               ///< XXXXXXXXXXXXXXXXXXXXXXXXLLLLLLLL)\n\n  CM_SURF_FMT_STENCIL8,  ///< stencil, 32 bits per element packed as (@c\n                         ///< SSSSSSSSXXXXXXXXXXXXXXXXXXXXXXXX)\n\n\n  // non-native surface formats after this line, will be ignored by HWL\n  // all non-native surface formats should use the _NN suffix to distinguish\n  // them from potential corresponding native formats added in the future\n  CM_SURF_FMT_I420_NN,                              ///< 4:2:0 Planar Y-U-V format\n  CM_SURF_FMT_YV12_NN,                              ///< 4:2:0 Planar Y-V-U format\n  CM_SURF_FMT_NV12_NN,                              ///< 4:2:0 Semi-planar Y-UV format\n  CM_SURF_FMT_NV21_NN,                              ///< 4:2:0 Semi-planar Y-VU format\n  cmSurfFmt_FIRST = CM_SURF_FMT_LUMINANCE8,         ///< First surface format\n  cmSurfFmt_LAST = CM_SURF_FMT_STENCIL8,            ///< Last native surface format\n  cmSurfFmt_LAST_NON_NATIVE = CM_SURF_FMT_NV21_NN,  ///< Last non-native surface format\n} cmSurfFmt;\n\ntypedef struct cmFormatXlateRec {\n  cmSurfFmt raw_cmFormat;\n  cl_channel_type image_channel_data_type;\n  cl_channel_order image_channel_order;\n} cmFormatXlateParams;\n\n// relates full range of cm surface formats to those supported by CAL\nstatic const cmFormatXlateParams cmFormatXlateTable[] = {\n    {CM_SURF_FMT_LUMINANCE8, CL_UNORM_INT8, CL_LUMINANCE},\n    {CM_SURF_FMT_LUMINANCE16, CL_UNORM_INT16, CL_LUMINANCE},\n    {CM_SURF_FMT_LUMINANCE16F, CL_HALF_FLOAT, CL_LUMINANCE},\n    {CM_SURF_FMT_LUMINANCE32F, CL_FLOAT, CL_LUMINANCE},\n    {CM_SURF_FMT_INTENSITY8, CL_UNORM_INT8, CL_INTENSITY},\n    {CM_SURF_FMT_INTENSITY16, CL_UNORM_INT16, CL_INTENSITY},\n    {CM_SURF_FMT_INTENSITY16F, CL_HALF_FLOAT, CL_INTENSITY},\n    {CM_SURF_FMT_INTENSITY32F, CL_FLOAT, CL_INTENSITY},\n    {CM_SURF_FMT_ALPHA8, CL_UNSIGNED_INT8, CL_A},\n    {CM_SURF_FMT_ALPHA16, CL_UNORM_INT16, CL_A},\n    {CM_SURF_FMT_ALPHA16F, CL_HALF_FLOAT, CL_A},\n    {CM_SURF_FMT_ALPHA32F, CL_FLOAT, CL_A},\n    {CM_SURF_FMT_LUMINANCE8_ALPHA8, CL_UNSIGNED_INT8, CL_RG},\n    {CM_SURF_FMT_LUMINANCE16_ALPHA16, CL_UNSIGNED_INT16, CL_RG},\n    {CM_SURF_FMT_LUMINANCE16F_ALPHA16F, CL_HALF_FLOAT, CL_RG},\n    {CM_SURF_FMT_LUMINANCE32F_ALPHA32F, CL_FLOAT, CL_RG},\n    {CM_SURF_FMT_B2_G3_R3, 500, CL_R},\n    {CM_SURF_FMT_B5_G6_R5, CL_UNSIGNED_INT16, CL_RGB},\n    {CM_SURF_FMT_BGRX4, 500, CL_BGRA},\n    {CM_SURF_FMT_BGR5_X1, CL_UNSIGNED_INT16, CL_RGB},\n    {CM_SURF_FMT_BGRX8, CL_UNORM_INT8, CL_BGRA},\n    {CM_SURF_FMT_BGR10_X2, CL_UNORM_INT_101010, CL_RGB},\n    {CM_SURF_FMT_BGRX16, CL_UNORM_INT16, CL_BGRA},\n    {CM_SURF_FMT_BGRX16F, CL_HALF_FLOAT, CL_BGRA},\n    {CM_SURF_FMT_BGRX32F, CL_FLOAT, CL_BGRA},\n    {CM_SURF_FMT_RGBX4, 500, CL_RGB},\n    {CM_SURF_FMT_RGB5_X1, CL_UNORM_INT16, CL_BGRA},\n    {CM_SURF_FMT_RGBX8, CL_UNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_RGB10_X2, CL_UNORM_INT_101010, CL_RGBA},\n    {CM_SURF_FMT_RGBX16, CL_UNORM_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGBX16F, CL_HALF_FLOAT, CL_RGBA},\n    {CM_SURF_FMT_RGBX32F, CL_FLOAT, CL_RGBA},\n    {CM_SURF_FMT_BGRA4, 500, CL_BGRA},\n    {CM_SURF_FMT_BGR5_A1, CL_UNSIGNED_INT16, CL_BGRA},\n    {CM_SURF_FMT_BGRA8, CL_UNORM_INT8, CL_BGRA},\n    {CM_SURF_FMT_BGR10_A2, 500, CL_BGRA},\n    {CM_SURF_FMT_BGRA16, CL_UNORM_INT16, CL_BGRA},\n    {CM_SURF_FMT_BGRA16F, CL_UNORM_INT16, CL_BGRA},\n    {CM_SURF_FMT_BGRA32F, CL_FLOAT, CL_BGRA},\n    {CM_SURF_FMT_RGBA4, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB5_A1, CL_UNSIGNED_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGBA8, CL_UNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_RGB10_A2, CL_UNORM_INT_101010, CL_RGB},\n    {CM_SURF_FMT_RGBA16, CL_UNORM_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGBA16F, CL_HALF_FLOAT, CL_RGBA},\n    {CM_SURF_FMT_RGBA32I, CL_UNSIGNED_INT32, CL_RGBA},\n    {CM_SURF_FMT_RGBA32F, CL_FLOAT, CL_RGBA},\n    {CM_SURF_FMT_DUDV8, CL_UNSIGNED_INT8, CL_RG},\n    {CM_SURF_FMT_DXT1, 500, CL_R},\n    {CM_SURF_FMT_DXT2_3, 500, CL_R},\n    {CM_SURF_FMT_DXT4_5, 500, CL_R},\n    {CM_SURF_FMT_ATI1N, 500, CL_R},\n    {CM_SURF_FMT_ATI2N, 500, CL_R},\n    {CM_SURF_FMT_DEPTH16, CL_UNORM_INT16, CL_DEPTH},\n    {CM_SURF_FMT_DEPTH16F, CL_HALF_FLOAT, CL_DEPTH},\n    {CM_SURF_FMT_DEPTH24_X8, 500, CL_DEPTH},\n    {CM_SURF_FMT_DEPTH24F_X8, 500, CL_DEPTH},\n    {CM_SURF_FMT_DEPTH24_STEN8, CL_UNORM_INT24, CL_DEPTH_STENCIL},\n    {CM_SURF_FMT_DEPTH24F_STEN8, 500, CL_DEPTH_STENCIL},\n    {CM_SURF_FMT_DEPTH32F_X24_STEN8, CL_FLOAT, CL_DEPTH_STENCIL},\n    {CM_SURF_FMT_DEPTH32F, CL_FLOAT, CL_DEPTH},\n    {CM_SURF_FMT_sR11_sG11_sB10, 500, CL_R},\n    {CM_SURF_FMT_sU16, CL_SNORM_INT16, CL_R},\n    {CM_SURF_FMT_sUV16, CL_SNORM_INT16, CL_RG},\n    {CM_SURF_FMT_sUVWQ16, CL_SNORM_INT16, CL_RGBA},\n    {CM_SURF_FMT_RG16, CL_UNORM_INT16, CL_RG},\n    {CM_SURF_FMT_RG16F, CL_HALF_FLOAT, CL_RG},\n    {CM_SURF_FMT_RG32F, CL_FLOAT, CL_RG},\n    {CM_SURF_FMT_ABGR4, 500, CL_ARGB},\n    {CM_SURF_FMT_A1_BGR5, CL_UNSIGNED_INT16, CL_ARGB},\n    {CM_SURF_FMT_ABGR8, CL_UNORM_INT8, CL_ARGB},\n    {CM_SURF_FMT_A2_BGR10, CL_UNORM_INT_101010, CL_RGB},\n    {CM_SURF_FMT_ABGR16, CL_UNORM_INT16, CL_ARGB},\n    {CM_SURF_FMT_ABGR16F, CL_HALF_FLOAT, CL_ARGB},\n    {CM_SURF_FMT_ABGR32F, CL_FLOAT, CL_ARGB},\n    {CM_SURF_FMT_DXT1A, 500, CL_R},\n    {CM_SURF_FMT_sRGB10_A2, 500, CL_RGBA},\n    {CM_SURF_FMT_sR8, CL_SNORM_INT8, CL_R},\n    {CM_SURF_FMT_sRG8, CL_SNORM_INT8, CL_RG},\n    {CM_SURF_FMT_sR32I, CL_SIGNED_INT32, CL_R},\n    {CM_SURF_FMT_sRG32I, CL_SIGNED_INT32, CL_RG},\n    {CM_SURF_FMT_sRGBA32I, CL_SIGNED_INT32, CL_RGBA},\n    {CM_SURF_FMT_R32I, CL_UNSIGNED_INT32, CL_R},\n    {CM_SURF_FMT_RG32I, CL_UNSIGNED_INT32, CL_RG},\n    {CM_SURF_FMT_RG8, CL_UNORM_INT8, CL_RG},\n    {CM_SURF_FMT_sRGBA8, CL_SNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_R11F_G11F_B10F, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB9_E5, CL_UNORM_INT8, CL_ARGB},\n    {CM_SURF_FMT_LUMINANCE_LATC1, 500, CL_RGBA},\n    {CM_SURF_FMT_SIGNED_LUMINANCE_LATC1, 500, CL_RGBA},\n    {CM_SURF_FMT_LUMINANCE_ALPHA_LATC2, 500, CL_RGBA},\n    {CM_SURF_FMT_SIGNED_LUMINANCE_ALPHA_LATC2, 500, CL_RGBA},\n    {CM_SURF_FMT_RED_RGTC1, 500, CL_RGBA},\n    {CM_SURF_FMT_SIGNED_RED_RGTC1, 500, CL_RGBA},\n    {CM_SURF_FMT_RED_GREEN_RGTC2, 500, CL_RGBA},\n    {CM_SURF_FMT_SIGNED_RED_GREEN_RGTC2, 500, CL_RGBA},\n    {CM_SURF_FMT_R8, CL_UNORM_INT8, CL_R},\n    {CM_SURF_FMT_R16, CL_UNORM_INT16, CL_R},\n    {CM_SURF_FMT_R16F, CL_HALF_FLOAT, CL_R},\n    {CM_SURF_FMT_R32F, CL_FLOAT, CL_R},\n    {CM_SURF_FMT_R8I, CL_UNSIGNED_INT8, CL_R},\n    {CM_SURF_FMT_sR8I, CL_SIGNED_INT8, CL_R},\n    {CM_SURF_FMT_RG8I, CL_UNSIGNED_INT8, CL_RG},\n    {CM_SURF_FMT_sRG8I, CL_SIGNED_INT8, CL_RG},\n    {CM_SURF_FMT_R16I, CL_UNSIGNED_INT16, CL_R},\n    {CM_SURF_FMT_sR16I, CL_SIGNED_INT16, CL_R},\n    {CM_SURF_FMT_RG16I, CL_UNSIGNED_INT16, CL_RG},\n    {CM_SURF_FMT_sRG16I, CL_SIGNED_INT16, CL_RG},\n    {CM_SURF_FMT_RGBA32UI, CL_UNSIGNED_INT32, CL_RGBA},\n    {CM_SURF_FMT_RGBX32UI, CL_UNSIGNED_INT32, CL_RGBA},\n    {CM_SURF_FMT_ALPHA32UI, CL_UNSIGNED_INT32, CL_R},\n    {CM_SURF_FMT_INTENSITY32UI, CL_UNSIGNED_INT32, CL_R},\n    {CM_SURF_FMT_LUMINANCE32UI, CL_UNSIGNED_INT32, CL_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA32UI, CL_UNSIGNED_INT32, CL_RG},\n    {CM_SURF_FMT_RGBA16UI, CL_UNSIGNED_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGBX16UI, CL_UNSIGNED_INT16, CL_RGBA},\n    {CM_SURF_FMT_ALPHA16UI, CL_UNSIGNED_INT16, CL_R},\n    {CM_SURF_FMT_INTENSITY16UI, CL_UNSIGNED_INT16, CL_R},\n    {CM_SURF_FMT_LUMINANCE16UI, CL_UNSIGNED_INT16, CL_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA16UI, CL_UNSIGNED_INT32, CL_RG},\n    {CM_SURF_FMT_RGBA8UI, CL_UNSIGNED_INT8, CL_RGBA},\n    {CM_SURF_FMT_RGBX8UI, CL_UNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_ALPHA8UI, CL_UNSIGNED_INT8, CL_R},\n    {CM_SURF_FMT_INTENSITY8UI, CL_UNSIGNED_INT8, CL_R},\n    {CM_SURF_FMT_LUMINANCE8UI, CL_UNSIGNED_INT8, CL_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA8UI, CL_UNSIGNED_INT8, CL_RG},\n    {CM_SURF_FMT_sRGBX32I, CL_SIGNED_INT32, CL_RGBA},\n    {CM_SURF_FMT_sALPHA32I, CL_SIGNED_INT32, CL_R},\n    {CM_SURF_FMT_sINTENSITY32I, CL_SIGNED_INT32, CL_R},\n    {CM_SURF_FMT_sLUMINANCE32I, CL_SIGNED_INT32, CL_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA32I, CL_SIGNED_INT32, CL_RG},\n    {CM_SURF_FMT_sRGBA16I, CL_SIGNED_INT16, CL_RGBA},\n    {CM_SURF_FMT_sRGBX16I, CL_SIGNED_INT16, CL_RGBA},\n    {CM_SURF_FMT_sALPHA16I, CL_SIGNED_INT16, CL_R},\n    {CM_SURF_FMT_sINTENSITY16I, CL_SIGNED_INT16, CL_R},\n    {CM_SURF_FMT_sLUMINANCE16I, CL_SIGNED_INT16, CL_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA16I, CL_SIGNED_INT16, CL_RG},\n    {CM_SURF_FMT_sRGBA8I, CL_SIGNED_INT8, CL_RGBA},\n    {CM_SURF_FMT_sRGBX8I, CL_SIGNED_INT8, CL_RGBA},\n    {CM_SURF_FMT_sALPHA8I, CL_SIGNED_INT8, CL_R},\n    {CM_SURF_FMT_sINTENSITY8I, CL_SIGNED_INT8, CL_R},\n    {CM_SURF_FMT_sLUMINANCE8I, CL_SIGNED_INT8, CL_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA8I, CM_SURF_FMT_sRG8I, CL_RG},\n    {CM_SURF_FMT_sDXT6, 500, CL_R},\n    {CM_SURF_FMT_DXT6, 500, CL_R},\n    {CM_SURF_FMT_DXT7, 500, CL_R},\n    {CM_SURF_FMT_LUMINANCE8_SNORM, CL_SNORM_INT8, CL_R},\n    {CM_SURF_FMT_LUMINANCE16_SNORM, CL_SNORM_INT16, CL_R},\n    {CM_SURF_FMT_INTENSITY8_SNORM, CL_SNORM_INT8, CL_R},\n    {CM_SURF_FMT_INTENSITY16_SNORM, CL_SNORM_INT16, CL_R},\n    {CM_SURF_FMT_ALPHA8_SNORM, CL_SNORM_INT8, CL_R},\n    {CM_SURF_FMT_ALPHA16_SNORM, CL_SNORM_INT16, CL_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA8_SNORM, CL_SNORM_INT8, CL_RG},\n    {CM_SURF_FMT_LUMINANCE_ALPHA16_SNORM, CL_SNORM_INT16, CL_RG},\n    {CM_SURF_FMT_R8_SNORM, CL_SNORM_INT8, CL_R},\n    {CM_SURF_FMT_R16_SNORM, CL_SNORM_INT16, CL_R},\n    {CM_SURF_FMT_RG8_SNORM, CL_SNORM_INT8, CL_RG},\n    {CM_SURF_FMT_RG16_SNORM, CL_SNORM_INT16, CL_RG},\n    {CM_SURF_FMT_RGBX8_SNORM, CL_SNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_RGBX16_SNORM, CL_SNORM_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_SNORM, CL_SNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_RGBA16_SNORM, CL_SNORM_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGB10_A2UI, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB32F, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB32I, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB32UI, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBX8_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_DXT1_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_DXT1A_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_DXT2_3_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_DXT4_5_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_DXT7_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB8_ETC2, 500, CL_RGB},\n    {CM_SURF_FMT_SRGB8_ETC2, 500, CL_RGB},\n    {CM_SURF_FMT_RGB8_PT_ALPHA1_ETC2, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGB8_PT_ALPHA1_ETC2, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ETC2_EAC, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGB8_ALPHA8_ETC2_EAC, 500, CL_RGBA},\n    {CM_SURF_FMT_R11_EAC, 500, CL_R},\n    {CM_SURF_FMT_SIGNED_R11_EAC, 500, CL_R},\n    {CM_SURF_FMT_RG11_EAC, 500, CL_RG},\n    {CM_SURF_FMT_SIGNED_RG11_EAC, 500, CL_RG},\n    {CM_SURF_FMT_RGBA8_ASTC_4x4, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_5x4, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_5x5, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_6x5, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_6x6, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x5, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x6, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x8, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x5, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x6, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x8, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x10, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_12x10, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_12x12, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_4x4, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_5x4, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_5x5, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_6x5, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_6x6, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x5, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x6, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x8, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x5, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x6, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x8, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x10, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_12x10, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_12x12, 500, CL_RGBA},\n    {CM_SURF_FMT_BGR10_A2UI, 500, CL_BGRA},\n    {CM_SURF_FMT_A2_BGR10UI, 500, CL_ARGB},\n    {CM_SURF_FMT_A2_RGB10UI, 500, CL_ABGR},\n    {CM_SURF_FMT_B5_G6_R5UI, 500, CL_BGRA},\n    {CM_SURF_FMT_R5_G6_B5UI, 500, CL_RGBA},\n    {CM_SURF_FMT_DEPTH32F_X24_STEN8_UNCLAMPED, CL_UNSIGNED_INT32, CL_R},\n    {CM_SURF_FMT_DEPTH32F_UNCLAMPED, CL_FLOAT, CL_R},\n    {CM_SURF_FMT_L8_X16_A8_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_L8_X24_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_STENCIL8, CL_UNSIGNED_INT8, CL_R},\n};\n\nbool Device::initGLInteropPrivateExt(void* GLplatformContext, void* GLdeviceContext) const {\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  void* pModule = dlopen(\"libGL.so.1\", RTLD_NOW);\n\n  if (nullptr == pModule) {\n    return false;\n  }\n  pfnGlxGetProcAddress = (PFNGlxGetProcAddress)dlsym(pModule, \"glXGetProcAddress\");\n  if (nullptr == pfnGlxGetProcAddress) {\n    return false;\n  }\n\n  pfnMesaGLInteropGLXQueryDeviceInfo =\n      (PFNMesaGLInteropGLXQueryDeviceInfo)dlsym(pModule, \"MesaGLInteropGLXQueryDeviceInfo\");\n  if (nullptr == pfnMesaGLInteropGLXQueryDeviceInfo) {\n    return false;\n  }\n\n  if (!glXBeginCLInteropAMD || !glXEndCLInteropAMD || !glXResourceAttachAMD ||\n      !glXResourceDetachAMD || !glXGetContextMVPUInfoAMD) {\n    glXBeginCLInteropAMD = (PFNGLXBEGINCLINTEROPAMD)pfnGlxGetProcAddress(\n        (const GLubyte*)\"glXBeginCLInteroperabilityAMD\");\n    glXEndCLInteropAMD =\n        (PFNGLXENDCLINTEROPAMD)pfnGlxGetProcAddress((const GLubyte*)\"glXEndCLInteroperabilityAMD\");\n    glXResourceAttachAMD =\n        (PFNGLXRESOURCEATTACHAMD)pfnGlxGetProcAddress((const GLubyte*)\"glXResourceAttachAMD\");\n    glxResourceAcquireAMD =\n        (PFNGLXRESOURCEDETACHAMD)pfnGlxGetProcAddress((const GLubyte*)\"glXResourceAcquireAMD\");\n    glxResourceReleaseAMD =\n        (PFNGLXRESOURCEDETACHAMD)pfnGlxGetProcAddress((const GLubyte*)\"glXResourceReleaseAMD\");\n    glXResourceDetachAMD =\n        (PFNGLXRESOURCEDETACHAMD)pfnGlxGetProcAddress((const GLubyte*)\"glXResourceDetachAMD\");\n    glXGetContextMVPUInfoAMD = (PFNGLXGETCONTEXTMVPUINFOAMD)pfnGlxGetProcAddress(\n        (const GLubyte*)\"glXGetContextMVPUInfoAMD\");\n  }\n\n  if (!glXBeginCLInteropAMD || !glXEndCLInteropAMD || !glXResourceAttachAMD ||\n      !glXResourceDetachAMD || !glXGetContextMVPUInfoAMD) {\n    return false;\n  }\n#else\n  if (!wglBeginCLInteropAMD || !wglEndCLInteropAMD || !wglResourceAttachAMD ||\n      !wglResourceDetachAMD || !wglGetContextGPUInfoAMD) {\n    HGLRC fakeRC = nullptr;\n\n    if (!wglGetCurrentContext()) {\n      fakeRC = wglCreateContext((HDC)GLdeviceContext);\n      wglMakeCurrent((HDC)GLdeviceContext, fakeRC);\n    }\n\n    wglBeginCLInteropAMD =\n        (PFNWGLBEGINCLINTEROPAMD)wglGetProcAddress(\"wglBeginCLInteroperabilityAMD\");\n    wglEndCLInteropAMD = (PFNWGLENDCLINTEROPAMD)wglGetProcAddress(\"wglEndCLInteroperabilityAMD\");\n    wglResourceAttachAMD = (PFNWGLRESOURCEATTACHAMD)wglGetProcAddress(\"wglResourceAttachAMD\");\n    wglResourceAcquireAMD = (PFNWGLRESOURCEDETACHAMD)wglGetProcAddress(\"wglResourceAcquireAMD\");\n    wglResourceReleaseAMD = (PFNWGLRESOURCEDETACHAMD)wglGetProcAddress(\"wglResourceReleaseAMD\");\n    wglResourceDetachAMD = (PFNWGLRESOURCEDETACHAMD)wglGetProcAddress(\"wglResourceDetachAMD\");\n    wglGetContextGPUInfoAMD =\n        (PFNWGLGETCONTEXTGPUINFOAMD)wglGetProcAddress(\"wglGetContextGPUInfoAMD\");\n\n    if (fakeRC) {\n      wglMakeCurrent(nullptr, nullptr);\n      wglDeleteContext(fakeRC);\n    }\n  }\n  if (!wglBeginCLInteropAMD || !wglEndCLInteropAMD || !wglResourceAttachAMD ||\n      !wglResourceDetachAMD || !wglGetContextGPUInfoAMD) {\n    return false;\n  }\n#endif\n  return true;\n}\n\nbool Device::glCanInterop(void* GLplatformContext, void* GLdeviceContext) const {\n  bool canInteroperate = false;\n\n#ifdef ATI_OS_WIN\n  LUID glAdapterLuid = {0, 0};\n  UINT glChainBitMask = 0;\n  HGLRC hRC = (HGLRC)GLplatformContext;\n\n  // get GL context's LUID and chainBitMask from UGL\n  if (wglGetContextGPUInfoAMD(hRC, &glAdapterLuid, &glChainBitMask)) {\n    // match the adapter\n    canInteroperate = (properties().osProperties.luidHighPart == glAdapterLuid.HighPart) &&\n        (properties().osProperties.luidLowPart == glAdapterLuid.LowPart) &&\n        ((1 << properties().gpuIndex) == glChainBitMask);\n  }\n#else\n  GLuint glDeviceId = 0;\n  GLuint glChainMask = 0;\n  GLXContext ctx = static_cast<GLXContext>(GLplatformContext);\n  Display* disp = static_cast<Display*>(GLdeviceContext);\n\n\n  if (glXGetContextMVPUInfoAMD(ctx, &glDeviceId, &glChainMask)) {\n    mesa_glinterop_device_info info = {};\n    if (pfnMesaGLInteropGLXQueryDeviceInfo(disp, ctx, &info) == 0) {\n      // match the adapter\n      canInteroperate = (properties().pciProperties.busNumber == info.pci_bus) &&\n          (properties().pciProperties.deviceNumber == info.pci_device) &&\n          (properties().pciProperties.functionNumber == info.pci_function) &&\n          (static_cast<GLuint>(1 << properties().gpuIndex) == glChainMask);\n    }\n  }\n#endif\n  return canInteroperate;\n}\n\nbool Device::glAssociate(void* GLplatformContext, void* GLdeviceContext) const {\n  // initialize pointers to the gl extension that supports interoperability\n  if (!initGLInteropPrivateExt(GLplatformContext, GLdeviceContext) ||\n      !glCanInterop(GLplatformContext, GLdeviceContext)) {\n    return false;\n  }\n\n/*\n    if (m_adp->pAsicInfo->svmFineGrainSystem)\n    {\n        flags = GL_INTEROP_SVM;\n    }\n*/\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  return (glXBeginCLInteropAMD(ctx, 0)) ? true : false;\n#else\n  HGLRC hRC = (HGLRC)GLplatformContext;\n  return (wglBeginCLInteropAMD(hRC, 0)) ? true : false;\n#endif\n}\n\nbool Device::glDissociate(void* GLplatformContext, void* GLdeviceContext) const {\n/*\n    if (m_adp->pAsicInfo->svmFineGrainSystem)\n    {\n        flags = GL_INTEROP_SVM;\n    }\n*/\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  return (glXEndCLInteropAMD(ctx, 0)) ? true : false;\n#else\n  HGLRC hRC = (HGLRC)GLplatformContext;\n  return (wglEndCLInteropAMD(hRC, 0)) ? true : false;\n#endif\n}\n\nbool Device::resGLAssociate(void* GLContext, uint name, uint type, Pal::OsExternalHandle* handle,\n                            void** mbResHandle, size_t* offset, cl_image_format& newClFormat\n#ifdef ATI_OS_WIN\n                            ,\n                            Pal::DoppDesktopInfo& doppDesktopInfo\n#endif\n                            ) const {\n  amd::ScopedLock lk(lockPAL());\n\n  GLResource hRes = {};\n  GLResourceData hData = {};\n\n  bool status = false;\n\n  hRes.type = type;\n  hRes.name = name;\n\n  hData.version = GL_RESOURCE_DATA_VERSION;\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLContext;\n  if (glXResourceAttachAMD(ctx, &hRes, &hData)) {\n    status = true;\n  }\n#else\n  HGLRC hRC = (HGLRC)GLContext;\n  if (wglResourceAttachAMD(hRC, &hRes, &hData)) {\n    status = true;\n  }\n#endif\n\n  if (!status) {\n    return false;\n  }\n\n  *mbResHandle = reinterpret_cast<void*>(hData.mbResHandle);\n  *offset = static_cast<size_t>(hData.offset);\n#ifdef ATI_OS_WIN\n  *handle = reinterpret_cast<Pal::OsExternalHandle>(hData.handle);\n  if (hData.isDoppDesktopTexture) {\n    doppDesktopInfo.gpuVirtAddr = hData.cardAddr;\n    doppDesktopInfo.vidPnSourceId = hData.vidpnSourceId;\n  } else {\n    doppDesktopInfo.gpuVirtAddr = 0;\n    doppDesktopInfo.vidPnSourceId = 0;\n  }\n#else\n  *handle = static_cast<Pal::OsExternalHandle>(hData.sharedBufferID);\n#endif\n\n  // OCL supports only a limited number of cm_surf formats, so we\n  // have to translate incoming cm_surf formats\n  uint index = hData.format - (uint)CM_SURF_FMT_LUMINANCE8;\n  if (index >= sizeof(cmFormatXlateTable) / sizeof(cmFormatXlateParams)) {\n    LogError(\"\\nInvalid GL surface reported in hData\\n\");\n    return status;\n  }\n  assert(static_cast<cmSurfFmt>(hData.format) == cmFormatXlateTable[index].raw_cmFormat);\n  cl_channel_type imageDataType;\n  imageDataType = cmFormatXlateTable[index].image_channel_data_type;\n  if (imageDataType == 500) {\n    LogError(\"\\nGL surface is not supported by OCL\\n\");\n    return status;\n  }\n\n  newClFormat.image_channel_data_type = cmFormatXlateTable[index].image_channel_data_type;\n  newClFormat.image_channel_order = cmFormatXlateTable[index].image_channel_order;\n\n  return status;\n}\n\nbool Device::resGLAcquire(void* GLplatformContext, void* mbResHandle, uint type) const {\n  amd::ScopedLock lk(lockPAL());\n\n  GLResource hRes = {};\n  hRes.mbResHandle = (GLuintp)mbResHandle;\n  hRes.type = type;\n\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  return (glxResourceAcquireAMD(ctx, &hRes)) ? true : false;\n#else\n  HGLRC hRC = wglGetCurrentContext();\n  //! @todo A temporary workaround for MT issue in conformance fence_sync\n  if (0 == hRC) {\n    return true;\n  }\n  return (wglResourceAcquireAMD(hRC, &hRes)) ? true : false;\n#endif\n}\n\nbool Device::resGLRelease(void* GLplatformContext, void* mbResHandle, uint type) const {\n  amd::ScopedLock lk(lockPAL());\n\n  GLResource hRes = {};\n  hRes.mbResHandle = (GLuintp)mbResHandle;\n  hRes.type = type;\n#ifdef ATI_OS_LINUX\n  // TODO : make sure the application GL context is current. if not no\n  // point calling into the GL RT.\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  return (glxResourceReleaseAMD(ctx, &hRes)) ? true : false;\n#else\n  // Make the call into the GL driver only if the application GL context is current\n  HGLRC hRC = wglGetCurrentContext();\n  //! @todo A temporary workaround for MT issue in conformance fence_sync\n  if (0 == hRC) {\n    return true;\n  }\n  return (wglResourceReleaseAMD(hRC, &hRes)) ? true : false;\n#endif\n}\n\nbool Device::resGLFree(void* GLplatformContext, void* mbResHandle, uint type) const {\n  amd::ScopedLock lk(lockPAL());\n\n  GLResource hRes = {};\n  hRes.mbResHandle = (GLuintp)mbResHandle;\n  hRes.type = type;\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  return (glXResourceDetachAMD(ctx, &hRes)) ? true : false;\n#else\n  HGLRC hRC = (HGLRC)GLplatformContext;\n  return (wglResourceDetachAMD(hRC, &hRes)) ? true : false;\n#endif\n}\n\n}  // namespace pal\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.9.0-neudjleb7hiztwlofocdddh3xyfxtn44/spack-src/device/gpu/gslbe/src/rt/GSLDeviceGL.cpp": " /* Copyright (c) 2008-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#include \"gsl_ctx.h\"\n#include \"GSLDevice.h\"\n#include \"component_types.h\"\n#include \"cwddeci.h\"\n#include <GL/gl.h>\n#include \"GL/glATIInternal.h\"\n#ifdef ATI_OS_LINUX\n#include <stdlib.h>\n#include <dlfcn.h>\n#include \"GL/glx.h\"\n#include \"GL/glxext.h\"\n#include \"GL/glXATIPrivate.h\"\n#else\n#include \"GL/wglATIPrivate.h\"\n#endif\n#include \"memory/MemObject.h\"\n\ntypedef struct cmFormatXlateRec{\n    cmSurfFmt   raw_cmFormat;\n    cmSurfFmt   cal_cmFormat;\n    gslChannelOrder channelOrder;\n} cmFormatXlateParams;\n\n// relates full range of cm surface formats to those supported by CAL\nstatic constexpr cmFormatXlateParams cmFormatXlateTable [] = {\n    {CM_SURF_FMT_LUMINANCE8,            CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE16,           CM_SURF_FMT_R16,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE16F,          CM_SURF_FMT_R16F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE32F,          CM_SURF_FMT_R32F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY8,            CM_SURF_FMT_INTENSITY8, GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_INTENSITY16,           CM_SURF_FMT_R16,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY16F,          CM_SURF_FMT_R16F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY32F,          CM_SURF_FMT_R32F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA8,                CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA16,               CM_SURF_FMT_R16,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA16F,              CM_SURF_FMT_R16F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA32F,              CM_SURF_FMT_R32F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE8_ALPHA8,     CM_SURF_FMT_RG8I,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_LUMINANCE16_ALPHA16,   CM_SURF_FMT_RG16I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_LUMINANCE16F_ALPHA16F, CM_SURF_FMT_RG16F,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_LUMINANCE32F_ALPHA32F, CM_SURF_FMT_RG16F,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_B2_G3_R3,              (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_B5_G6_R5,              CM_SURF_FMT_B5_G6_R5,   GSL_CHANNEL_ORDER_RGB},\n    {CM_SURF_FMT_BGRX4,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGR5_X1,               CM_SURF_FMT_BGR5_X1,    GSL_CHANNEL_ORDER_RGB},\n    {CM_SURF_FMT_BGRX8,                 CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGR10_X2,              CM_SURF_FMT_BGR10_X2,   GSL_CHANNEL_ORDER_RGB},\n    {CM_SURF_FMT_BGRX16,                CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRX16F,               CM_SURF_FMT_RGBA16F,    GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRX32F,               CM_SURF_FMT_RGBA32F,    GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_RGBX4,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB5_X1,               CM_SURF_FMT_BGR5_X1,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX8,                 CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB10_X2,              CM_SURF_FMT_RGB10_X2,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX16,                CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX16F,               CM_SURF_FMT_RGBA16F,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX32F,               CM_SURF_FMT_RGBA32F,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_BGRA4,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGR5_A1,               CM_SURF_FMT_BGR5_X1,    GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRA8,                 CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGR10_A2,              CM_SURF_FMT_BGR10_X2,   GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRA16,                CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRA16F,               CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRA32F,               CM_SURF_FMT_RGBA32F,    GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_RGBA4,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB5_A1,               CM_SURF_FMT_BGR5_X1,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8,                 CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB10_A2,              CM_SURF_FMT_BGR10_X2,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA16,                CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA16F,               CM_SURF_FMT_RGBA16F,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA32I,               CM_SURF_FMT_RGBA32I,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA32F,               CM_SURF_FMT_RGBA32F,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_DUDV8,                 CM_SURF_FMT_RG8I,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_DXT1,                  (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DXT2_3,                (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DXT4_5,                (cmSurfFmt)00,          GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ATI1N,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ATI2N,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DEPTH16,               CM_SURF_FMT_DEPTH16,    GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_DEPTH16F,              CM_SURF_FMT_R16F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DEPTH24_X8,            (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DEPTH24F_X8,           (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DEPTH24_STEN8,         CM_SURF_FMT_DEPTH24_STEN8, GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_DEPTH24F_STEN8,        (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DEPTH32F_X24_STEN8,    CM_SURF_FMT_DEPTH32F_X24_STEN8, GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_DEPTH32F,              CM_SURF_FMT_DEPTH32F,   GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_sR11_sG11_sB10,        (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sU16,                  CM_SURF_FMT_sU16,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sUV16,                 CM_SURF_FMT_sUV16,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sUVWQ16,               CM_SURF_FMT_sUVWQ16,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RG16,                  CM_SURF_FMT_RG16,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RG16F,                 CM_SURF_FMT_RG16F,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RG32F,                 CM_SURF_FMT_RG32F,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_ABGR4,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_A1_BGR5,               CM_SURF_FMT_BGR5_X1,    GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_ABGR8,                 CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_A2_BGR10,              CM_SURF_FMT_BGR10_X2,   GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_ABGR16,                CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_ABGR16F,               CM_SURF_FMT_RGBA16F,    GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_ABGR32F,               CM_SURF_FMT_RGBA32F,    GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_DXT1A,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sRGB10_A2,             (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sR8,                   CM_SURF_FMT_sR8,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sRG8,                  CM_SURF_FMT_sRG8,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sR32I,                 CM_SURF_FMT_sR32I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sRG32I,                CM_SURF_FMT_sRG32I,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRGBA32I,              CM_SURF_FMT_sRGBA32I,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_R32I,                  CM_SURF_FMT_R32I,       GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_RG32I,                 CM_SURF_FMT_RG32I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RG8,                   CM_SURF_FMT_RG8,        GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRGBA8,                CM_SURF_FMT_sRGBA8,     GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_R11F_G11F_B10F,        (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB9_E5,               CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_LUMINANCE_LATC1,       (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SIGNED_LUMINANCE_LATC1,(cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_LUMINANCE_ALPHA_LATC2, (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SIGNED_LUMINANCE_ALPHA_LATC2, (cmSurfFmt)500,  GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RED_RGTC1,             (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SIGNED_RED_RGTC1,      (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RED_GREEN_RGTC2,       (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SIGNED_RED_GREEN_RGTC2,(cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_R8,                    CM_SURF_FMT_INTENSITY8, GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R16,                   CM_SURF_FMT_R16,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R16F,                  CM_SURF_FMT_R16F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R32F,                  CM_SURF_FMT_R32F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R8I,                   CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sR8I,                  CM_SURF_FMT_sR8I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_RG8I,                  CM_SURF_FMT_RG8I,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRG8I,                 CM_SURF_FMT_sRG8I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_R16I,                  CM_SURF_FMT_R16I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sR16I,                 CM_SURF_FMT_sR16I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_RG16I,                 CM_SURF_FMT_RG16I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRG16I,                CM_SURF_FMT_sRG16I,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RGBA32UI,              CM_SURF_FMT_RGBA32UI,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX32UI,              CM_SURF_FMT_RGBA32UI,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_ALPHA32UI,             CM_SURF_FMT_R32I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY32UI,         CM_SURF_FMT_R32I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE32UI,         CM_SURF_FMT_R32I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA32UI,   CM_SURF_FMT_RG32I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RGBA16UI,              CM_SURF_FMT_RGBA16UI,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX16UI,              CM_SURF_FMT_RGBA16UI,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_ALPHA16UI,             CM_SURF_FMT_R16I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY16UI,         CM_SURF_FMT_R16I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE16UI,         CM_SURF_FMT_R16I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA16UI,   CM_SURF_FMT_R32I,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RGBA8UI,               CM_SURF_FMT_RGBA8UI,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX8UI,               CM_SURF_FMT_RGBA8UI,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_ALPHA8UI,              CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY8UI,          CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE8UI,          CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA8UI,    CM_SURF_FMT_RG8I,       GSL_CHANNEL_ORDER_RG},\n#ifndef CM_SURF_FMT_sRGBA32I_EXT_HAS_BEEN_REMOVED\n    {CM_SURF_FMT_sRGBA32I_EXT,          CM_SURF_FMT_sRGBA32I,   GSL_CHANNEL_ORDER_RGBA},\n#endif\n    {CM_SURF_FMT_sRGBX32I,              CM_SURF_FMT_sRGBA32I,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sALPHA32I,             CM_SURF_FMT_sR32I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sINTENSITY32I,         CM_SURF_FMT_sR32I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE32I,         CM_SURF_FMT_sR32I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA32I,   CM_SURF_FMT_sRG32I,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRGBA16I,              CM_SURF_FMT_sRGBA16I,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sRGBX16I,              CM_SURF_FMT_sRGBA16I,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sALPHA16I,             CM_SURF_FMT_sR16I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sINTENSITY16I,         CM_SURF_FMT_sR16I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE16I,         CM_SURF_FMT_sR16I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA16I,   CM_SURF_FMT_sRG16I,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRGBA8I,               CM_SURF_FMT_sRGBA8I,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sRGBX8I,               CM_SURF_FMT_sRGBA8I,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sALPHA8I,              CM_SURF_FMT_sR8I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sINTENSITY8I,          CM_SURF_FMT_sR8I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE8I,          CM_SURF_FMT_sR8I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA8I,    CM_SURF_FMT_sRG8I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sDXT6,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DXT6,                  (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DXT7,                  (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE8_SNORM,      CM_SURF_FMT_sR8,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE16_SNORM,     CM_SURF_FMT_sU16,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY8_SNORM,      CM_SURF_FMT_sR8,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY16_SNORM,     CM_SURF_FMT_sU16,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA8_SNORM,          CM_SURF_FMT_sR8,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA16_SNORM,         CM_SURF_FMT_sU16,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA8_SNORM,CM_SURF_FMT_sRG8,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_LUMINANCE_ALPHA16_SNORM,CM_SURF_FMT_sUV16,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_R8_SNORM,               CM_SURF_FMT_sR8,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R16_SNORM,              CM_SURF_FMT_sU16,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_RG8_SNORM,              CM_SURF_FMT_sRG8,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RG16_SNORM,             CM_SURF_FMT_sUV16,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RGBX8_SNORM,            CM_SURF_FMT_sRGBA8,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX16_SNORM,           CM_SURF_FMT_sUVWQ16,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_SNORM,            CM_SURF_FMT_sRGBA8,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA16_SNORM,           CM_SURF_FMT_sUVWQ16,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB8_ETC2,              (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGB},\n    {CM_SURF_FMT_SRGB8_ETC2,             (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGB},\n    {CM_SURF_FMT_RGB8_PT_ALPHA1_ETC2,    (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGB8_PT_ALPHA1_ETC2,   (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ETC2_EAC,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGB8_ALPHA8_ETC2_EAC,  (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_R11_EAC,                (cmSurfFmt)500,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_SIGNED_R11_EAC,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_RG11_EAC,               (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_SIGNED_RG11_EAC,        (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RGBA8_ASTC_4x4,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_5x4,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_5x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_6x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_6x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x8,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x8,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x10,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_12x10,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_12x12,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n\n    {CM_SURF_FMT_SRGBA8_ASTC_4x4,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_5x4,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_5x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_6x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_6x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x8,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x8,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x10,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_12x10,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_12x12,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_BGR10_A2UI,             (cmSurfFmt)501,        GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_A2_BGR10UI,             (cmSurfFmt)501,        GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_A2_RGB10UI,             (cmSurfFmt)501,        GSL_CHANNEL_ORDER_ABGR},\n    {CM_SURF_FMT_B5_G6_R5UI,             (cmSurfFmt)500,        GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_R5_G6_B5UI,             (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_DEPTH32F_X24_STEN8_UNCLAMPED, CM_SURF_FMT_RG32I, GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_DEPTH32F_UNCLAMPED,    CM_SURF_FMT_R32F,       GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_L8_X16_A8_SRGB,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_L8_X24_SRGB,            (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_STENCIL8,               CM_SURF_FMT_R8I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_L8_SRGB,                (cmSurfFmt)500,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R8_SRGB,                (cmSurfFmt)500,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_RG8_SRGB,               (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RG},\n    };\n\nFINLINE void\ndummyAssertIfCmSurfFmtChanges(void)\n{\n    //\n    //  Assert if cmSurfFmt defined in ugl/src/include/cmndefs.h changes.\n    //\n    COMPILE_TIME_ASSERT(cmSurfFmt_FIRST == CM_SURF_FMT_LUMINANCE8);\n    COMPILE_TIME_ASSERT(  0 == CM_SURF_FMT_LUMINANCE8);\n    COMPILE_TIME_ASSERT(  1 == CM_SURF_FMT_LUMINANCE16);\n    COMPILE_TIME_ASSERT(  2 == CM_SURF_FMT_LUMINANCE16F);\n    COMPILE_TIME_ASSERT(  3 == CM_SURF_FMT_LUMINANCE32F);\n    COMPILE_TIME_ASSERT(  4 == CM_SURF_FMT_INTENSITY8);\n    COMPILE_TIME_ASSERT(  5 == CM_SURF_FMT_INTENSITY16);\n    COMPILE_TIME_ASSERT(  6 == CM_SURF_FMT_INTENSITY16F);\n    COMPILE_TIME_ASSERT(  7 == CM_SURF_FMT_INTENSITY32F);\n    COMPILE_TIME_ASSERT(  8 == CM_SURF_FMT_ALPHA8);\n    COMPILE_TIME_ASSERT(  9 == CM_SURF_FMT_ALPHA16);\n    COMPILE_TIME_ASSERT( 10 == CM_SURF_FMT_ALPHA16F);\n    COMPILE_TIME_ASSERT( 11 == CM_SURF_FMT_ALPHA32F);\n    COMPILE_TIME_ASSERT( 12 == CM_SURF_FMT_LUMINANCE8_ALPHA8);\n    COMPILE_TIME_ASSERT( 13 == CM_SURF_FMT_LUMINANCE16_ALPHA16);\n    COMPILE_TIME_ASSERT( 14 == CM_SURF_FMT_LUMINANCE16F_ALPHA16F);\n    COMPILE_TIME_ASSERT( 15 == CM_SURF_FMT_LUMINANCE32F_ALPHA32F);\n    COMPILE_TIME_ASSERT( 16 == CM_SURF_FMT_B2_G3_R3);\n    COMPILE_TIME_ASSERT( 17 == CM_SURF_FMT_B5_G6_R5);\n    COMPILE_TIME_ASSERT( 18 == CM_SURF_FMT_BGRX4);\n    COMPILE_TIME_ASSERT( 19 == CM_SURF_FMT_BGR5_X1);\n    COMPILE_TIME_ASSERT( 20 == CM_SURF_FMT_BGRX8);\n    COMPILE_TIME_ASSERT( 21 == CM_SURF_FMT_BGR10_X2);\n    COMPILE_TIME_ASSERT( 22 == CM_SURF_FMT_BGRX16);\n    COMPILE_TIME_ASSERT( 23 == CM_SURF_FMT_BGRX16F);\n    COMPILE_TIME_ASSERT( 24 == CM_SURF_FMT_BGRX32F);\n    COMPILE_TIME_ASSERT( 25 == CM_SURF_FMT_RGBX4);\n    COMPILE_TIME_ASSERT( 26 == CM_SURF_FMT_RGB5_X1);\n    COMPILE_TIME_ASSERT( 27 == CM_SURF_FMT_RGBX8);\n    COMPILE_TIME_ASSERT( 28 == CM_SURF_FMT_RGB10_X2);\n    COMPILE_TIME_ASSERT( 29 == CM_SURF_FMT_RGBX16);\n    COMPILE_TIME_ASSERT( 30 == CM_SURF_FMT_RGBX16F);\n    COMPILE_TIME_ASSERT( 31 == CM_SURF_FMT_RGBX32F);\n    COMPILE_TIME_ASSERT( 32 == CM_SURF_FMT_BGRA4);\n    COMPILE_TIME_ASSERT( 33 == CM_SURF_FMT_BGR5_A1);\n    COMPILE_TIME_ASSERT( 34 == CM_SURF_FMT_BGRA8);\n    COMPILE_TIME_ASSERT( 35 == CM_SURF_FMT_BGR10_A2);\n    COMPILE_TIME_ASSERT( 36 == CM_SURF_FMT_BGRA16);\n    COMPILE_TIME_ASSERT( 37 == CM_SURF_FMT_BGRA16F);\n    COMPILE_TIME_ASSERT( 38 == CM_SURF_FMT_BGRA32F);\n    COMPILE_TIME_ASSERT( 39 == CM_SURF_FMT_RGBA4);\n    COMPILE_TIME_ASSERT( 40 == CM_SURF_FMT_RGB5_A1);\n    COMPILE_TIME_ASSERT( 41 == CM_SURF_FMT_RGBA8);\n    COMPILE_TIME_ASSERT( 42 == CM_SURF_FMT_RGB10_A2);\n    COMPILE_TIME_ASSERT( 43 == CM_SURF_FMT_RGBA16);\n    COMPILE_TIME_ASSERT( 44 == CM_SURF_FMT_RGBA16F);\n    COMPILE_TIME_ASSERT( 45 == CM_SURF_FMT_RGBA32I);\n    COMPILE_TIME_ASSERT( 46 == CM_SURF_FMT_RGBA32F);\n    COMPILE_TIME_ASSERT( 47 == CM_SURF_FMT_DUDV8);\n    COMPILE_TIME_ASSERT( 48 == CM_SURF_FMT_DXT1);\n    COMPILE_TIME_ASSERT( 49 == CM_SURF_FMT_DXT2_3);\n    COMPILE_TIME_ASSERT( 50 == CM_SURF_FMT_DXT4_5);\n    COMPILE_TIME_ASSERT( 51 == CM_SURF_FMT_ATI1N);\n    COMPILE_TIME_ASSERT( 52 == CM_SURF_FMT_ATI2N);\n    COMPILE_TIME_ASSERT( 53 == CM_SURF_FMT_DEPTH16);\n    COMPILE_TIME_ASSERT( 54 == CM_SURF_FMT_DEPTH16F);\n    COMPILE_TIME_ASSERT( 55 == CM_SURF_FMT_DEPTH24_X8);\n    COMPILE_TIME_ASSERT( 56 == CM_SURF_FMT_DEPTH24F_X8);\n    COMPILE_TIME_ASSERT( 57 == CM_SURF_FMT_DEPTH24_STEN8);\n    COMPILE_TIME_ASSERT( 58 == CM_SURF_FMT_DEPTH24F_STEN8);\n    COMPILE_TIME_ASSERT( 59 == CM_SURF_FMT_DEPTH32F_X24_STEN8);\n    COMPILE_TIME_ASSERT( 60 == CM_SURF_FMT_DEPTH32F);\n    COMPILE_TIME_ASSERT( 61 == CM_SURF_FMT_sR11_sG11_sB10);\n    COMPILE_TIME_ASSERT( 62 == CM_SURF_FMT_sU16);\n    COMPILE_TIME_ASSERT( 63 == CM_SURF_FMT_sUV16);\n    COMPILE_TIME_ASSERT( 64 == CM_SURF_FMT_sUVWQ16);\n    COMPILE_TIME_ASSERT( 65 == CM_SURF_FMT_RG16);\n    COMPILE_TIME_ASSERT( 66 == CM_SURF_FMT_RG16F);\n    COMPILE_TIME_ASSERT( 67 == CM_SURF_FMT_RG32F);\n    COMPILE_TIME_ASSERT( 68 == CM_SURF_FMT_ABGR4);\n    COMPILE_TIME_ASSERT( 69 == CM_SURF_FMT_A1_BGR5);\n    COMPILE_TIME_ASSERT( 70 == CM_SURF_FMT_ABGR8);\n    COMPILE_TIME_ASSERT( 71 == CM_SURF_FMT_A2_BGR10);\n    COMPILE_TIME_ASSERT( 72 == CM_SURF_FMT_ABGR16);\n    COMPILE_TIME_ASSERT( 73 == CM_SURF_FMT_ABGR16F);\n    COMPILE_TIME_ASSERT( 74 == CM_SURF_FMT_ABGR32F);\n    COMPILE_TIME_ASSERT( 75 == CM_SURF_FMT_DXT1A);\n    COMPILE_TIME_ASSERT( 76 == CM_SURF_FMT_sRGB10_A2);\n    COMPILE_TIME_ASSERT( 77 == CM_SURF_FMT_sR8);\n    COMPILE_TIME_ASSERT( 78 == CM_SURF_FMT_sRG8);\n    COMPILE_TIME_ASSERT( 79 == CM_SURF_FMT_sR32I);\n    COMPILE_TIME_ASSERT( 80 == CM_SURF_FMT_sRG32I);\n    COMPILE_TIME_ASSERT( 81 == CM_SURF_FMT_sRGBA32I);\n    COMPILE_TIME_ASSERT( 82 == CM_SURF_FMT_R32I);\n    COMPILE_TIME_ASSERT( 83 == CM_SURF_FMT_RG32I);\n    COMPILE_TIME_ASSERT( 84 == CM_SURF_FMT_RG8);\n    COMPILE_TIME_ASSERT( 85 == CM_SURF_FMT_sRGBA8);\n    COMPILE_TIME_ASSERT( 86 == CM_SURF_FMT_R11F_G11F_B10F);\n    COMPILE_TIME_ASSERT( 87 == CM_SURF_FMT_RGB9_E5);\n    COMPILE_TIME_ASSERT( 88 == CM_SURF_FMT_LUMINANCE_LATC1);\n    COMPILE_TIME_ASSERT( 89 == CM_SURF_FMT_SIGNED_LUMINANCE_LATC1);\n    COMPILE_TIME_ASSERT( 90 == CM_SURF_FMT_LUMINANCE_ALPHA_LATC2);\n    COMPILE_TIME_ASSERT( 91 == CM_SURF_FMT_SIGNED_LUMINANCE_ALPHA_LATC2);\n    COMPILE_TIME_ASSERT( 92 == CM_SURF_FMT_RED_RGTC1);\n    COMPILE_TIME_ASSERT( 93 == CM_SURF_FMT_SIGNED_RED_RGTC1);\n    COMPILE_TIME_ASSERT( 94 == CM_SURF_FMT_RED_GREEN_RGTC2);\n    COMPILE_TIME_ASSERT( 95 == CM_SURF_FMT_SIGNED_RED_GREEN_RGTC2);\n    COMPILE_TIME_ASSERT( 96 == CM_SURF_FMT_R8);\n    COMPILE_TIME_ASSERT( 97 == CM_SURF_FMT_R16);\n    COMPILE_TIME_ASSERT( 98 == CM_SURF_FMT_R16F);\n    COMPILE_TIME_ASSERT( 99 == CM_SURF_FMT_R32F);\n    COMPILE_TIME_ASSERT(100 == CM_SURF_FMT_R8I);\n    COMPILE_TIME_ASSERT(101 == CM_SURF_FMT_sR8I);\n    COMPILE_TIME_ASSERT(102 == CM_SURF_FMT_RG8I);\n    COMPILE_TIME_ASSERT(103 == CM_SURF_FMT_sRG8I);\n    COMPILE_TIME_ASSERT(104 == CM_SURF_FMT_R16I);\n    COMPILE_TIME_ASSERT(105 == CM_SURF_FMT_sR16I);\n    COMPILE_TIME_ASSERT(106 == CM_SURF_FMT_RG16I);\n    COMPILE_TIME_ASSERT(107 == CM_SURF_FMT_sRG16I);\n    COMPILE_TIME_ASSERT(108 == CM_SURF_FMT_RGBA32UI);\n    COMPILE_TIME_ASSERT(109 == CM_SURF_FMT_RGBX32UI);\n    COMPILE_TIME_ASSERT(110 == CM_SURF_FMT_ALPHA32UI);\n    COMPILE_TIME_ASSERT(111 == CM_SURF_FMT_INTENSITY32UI);\n    COMPILE_TIME_ASSERT(112 == CM_SURF_FMT_LUMINANCE32UI);\n    COMPILE_TIME_ASSERT(113 == CM_SURF_FMT_LUMINANCE_ALPHA32UI);\n    COMPILE_TIME_ASSERT(114 == CM_SURF_FMT_RGBA16UI);\n    COMPILE_TIME_ASSERT(115 == CM_SURF_FMT_RGBX16UI);\n    COMPILE_TIME_ASSERT(116 == CM_SURF_FMT_ALPHA16UI);\n    COMPILE_TIME_ASSERT(117 == CM_SURF_FMT_INTENSITY16UI);\n    COMPILE_TIME_ASSERT(118 == CM_SURF_FMT_LUMINANCE16UI);\n    COMPILE_TIME_ASSERT(119 == CM_SURF_FMT_LUMINANCE_ALPHA16UI);\n    COMPILE_TIME_ASSERT(120 == CM_SURF_FMT_RGBA8UI);\n    COMPILE_TIME_ASSERT(121 == CM_SURF_FMT_RGBX8UI);\n    COMPILE_TIME_ASSERT(122 == CM_SURF_FMT_ALPHA8UI);\n    COMPILE_TIME_ASSERT(123 == CM_SURF_FMT_INTENSITY8UI);\n    COMPILE_TIME_ASSERT(124 == CM_SURF_FMT_LUMINANCE8UI);\n    COMPILE_TIME_ASSERT(125 == CM_SURF_FMT_LUMINANCE_ALPHA8UI);\n#ifndef CM_SURF_FMT_sRGBA32I_EXT_HAS_BEEN_REMOVED\n    COMPILE_TIME_ASSERT(126 == CM_SURF_FMT_sRGBA32I_EXT);\n    COMPILE_TIME_ASSERT(127 == CM_SURF_FMT_sRGBX32I);\n    COMPILE_TIME_ASSERT(128 == CM_SURF_FMT_sALPHA32I);\n    COMPILE_TIME_ASSERT(129 == CM_SURF_FMT_sINTENSITY32I);\n    COMPILE_TIME_ASSERT(130 == CM_SURF_FMT_sLUMINANCE32I);\n    COMPILE_TIME_ASSERT(131 == CM_SURF_FMT_sLUMINANCE_ALPHA32I);\n    COMPILE_TIME_ASSERT(132 == CM_SURF_FMT_sRGBA16I);\n    COMPILE_TIME_ASSERT(133 == CM_SURF_FMT_sRGBX16I);\n    COMPILE_TIME_ASSERT(134 == CM_SURF_FMT_sALPHA16I);\n    COMPILE_TIME_ASSERT(135 == CM_SURF_FMT_sINTENSITY16I);\n    COMPILE_TIME_ASSERT(136 == CM_SURF_FMT_sLUMINANCE16I);\n    COMPILE_TIME_ASSERT(137 == CM_SURF_FMT_sLUMINANCE_ALPHA16I);\n    COMPILE_TIME_ASSERT(138 == CM_SURF_FMT_sRGBA8I);\n    COMPILE_TIME_ASSERT(139 == CM_SURF_FMT_sRGBX8I);\n    COMPILE_TIME_ASSERT(140 == CM_SURF_FMT_sALPHA8I);\n    COMPILE_TIME_ASSERT(141 == CM_SURF_FMT_sINTENSITY8I);\n    COMPILE_TIME_ASSERT(142 == CM_SURF_FMT_sLUMINANCE8I);\n    COMPILE_TIME_ASSERT(143 == CM_SURF_FMT_sLUMINANCE_ALPHA8I);\n    COMPILE_TIME_ASSERT(144 == CM_SURF_FMT_sDXT6);\n    COMPILE_TIME_ASSERT(145 == CM_SURF_FMT_DXT6);\n    COMPILE_TIME_ASSERT(146 == CM_SURF_FMT_DXT7);\n    COMPILE_TIME_ASSERT(147 == CM_SURF_FMT_LUMINANCE8_SNORM);\n    COMPILE_TIME_ASSERT(148 == CM_SURF_FMT_LUMINANCE16_SNORM);\n    COMPILE_TIME_ASSERT(149 == CM_SURF_FMT_INTENSITY8_SNORM);\n    COMPILE_TIME_ASSERT(150 == CM_SURF_FMT_INTENSITY16_SNORM);\n    COMPILE_TIME_ASSERT(151 == CM_SURF_FMT_ALPHA8_SNORM);\n    COMPILE_TIME_ASSERT(152 == CM_SURF_FMT_ALPHA16_SNORM);\n    COMPILE_TIME_ASSERT(153 == CM_SURF_FMT_LUMINANCE_ALPHA8_SNORM);\n    COMPILE_TIME_ASSERT(154 == CM_SURF_FMT_LUMINANCE_ALPHA16_SNORM);\n    COMPILE_TIME_ASSERT(155 == CM_SURF_FMT_R8_SNORM);\n    COMPILE_TIME_ASSERT(156 == CM_SURF_FMT_R16_SNORM);\n    COMPILE_TIME_ASSERT(157 == CM_SURF_FMT_RG8_SNORM);\n    COMPILE_TIME_ASSERT(158 == CM_SURF_FMT_RG16_SNORM);\n    COMPILE_TIME_ASSERT(159 == CM_SURF_FMT_RGBX8_SNORM);\n    COMPILE_TIME_ASSERT(160 == CM_SURF_FMT_RGBX16_SNORM);\n    COMPILE_TIME_ASSERT(161 == CM_SURF_FMT_RGBA8_SNORM);\n    COMPILE_TIME_ASSERT(162 == CM_SURF_FMT_RGBA16_SNORM);\n    COMPILE_TIME_ASSERT(163 == CM_SURF_FMT_RGB10_A2UI);\n    COMPILE_TIME_ASSERT(164 == CM_SURF_FMT_RGB32F);\n    COMPILE_TIME_ASSERT(165 == CM_SURF_FMT_RGB32I);\n    COMPILE_TIME_ASSERT(166 == CM_SURF_FMT_RGB32UI);\n    COMPILE_TIME_ASSERT(167 == CM_SURF_FMT_RGBX8_SRGB);\n    COMPILE_TIME_ASSERT(168 == CM_SURF_FMT_RGBA8_SRGB);\n    COMPILE_TIME_ASSERT(169 == CM_SURF_FMT_DXT1_SRGB);\n    COMPILE_TIME_ASSERT(170 == CM_SURF_FMT_DXT1A_SRGB);\n    COMPILE_TIME_ASSERT(171 == CM_SURF_FMT_DXT2_3_SRGB);\n    COMPILE_TIME_ASSERT(172 == CM_SURF_FMT_DXT4_5_SRGB);\n    COMPILE_TIME_ASSERT(173 == CM_SURF_FMT_DXT7_SRGB);\n    COMPILE_TIME_ASSERT(174 == CM_SURF_FMT_RGB8_ETC2);\n    COMPILE_TIME_ASSERT(175 == CM_SURF_FMT_SRGB8_ETC2);\n    COMPILE_TIME_ASSERT(176 == CM_SURF_FMT_RGB8_PT_ALPHA1_ETC2);\n    COMPILE_TIME_ASSERT(177 == CM_SURF_FMT_SRGB8_PT_ALPHA1_ETC2);\n    COMPILE_TIME_ASSERT(178 == CM_SURF_FMT_RGBA8_ETC2_EAC);\n    COMPILE_TIME_ASSERT(179 == CM_SURF_FMT_SRGB8_ALPHA8_ETC2_EAC);\n    COMPILE_TIME_ASSERT(180 == CM_SURF_FMT_R11_EAC);\n    COMPILE_TIME_ASSERT(181 == CM_SURF_FMT_SIGNED_R11_EAC);\n    COMPILE_TIME_ASSERT(182 == CM_SURF_FMT_RG11_EAC);\n    COMPILE_TIME_ASSERT(183 == CM_SURF_FMT_SIGNED_RG11_EAC);\n    COMPILE_TIME_ASSERT(184 == CM_SURF_FMT_RGBA8_ASTC_4x4);\n    COMPILE_TIME_ASSERT(185 == CM_SURF_FMT_RGBA8_ASTC_5x4);\n    COMPILE_TIME_ASSERT(186 == CM_SURF_FMT_RGBA8_ASTC_5x5);\n    COMPILE_TIME_ASSERT(187 == CM_SURF_FMT_RGBA8_ASTC_6x5);\n    COMPILE_TIME_ASSERT(188 == CM_SURF_FMT_RGBA8_ASTC_6x6);\n    COMPILE_TIME_ASSERT(189 == CM_SURF_FMT_RGBA8_ASTC_8x5);\n    COMPILE_TIME_ASSERT(190 == CM_SURF_FMT_RGBA8_ASTC_8x6);\n    COMPILE_TIME_ASSERT(191 == CM_SURF_FMT_RGBA8_ASTC_8x8);\n    COMPILE_TIME_ASSERT(192 == CM_SURF_FMT_RGBA8_ASTC_10x5);\n    COMPILE_TIME_ASSERT(193 == CM_SURF_FMT_RGBA8_ASTC_10x6);\n    COMPILE_TIME_ASSERT(194 == CM_SURF_FMT_RGBA8_ASTC_10x8);\n    COMPILE_TIME_ASSERT(195 == CM_SURF_FMT_RGBA8_ASTC_10x10);\n    COMPILE_TIME_ASSERT(196 == CM_SURF_FMT_RGBA8_ASTC_12x10);\n    COMPILE_TIME_ASSERT(197 == CM_SURF_FMT_RGBA8_ASTC_12x12);\n    COMPILE_TIME_ASSERT(198 == CM_SURF_FMT_SRGBA8_ASTC_4x4);\n    COMPILE_TIME_ASSERT(199 == CM_SURF_FMT_SRGBA8_ASTC_5x4);\n    COMPILE_TIME_ASSERT(200 == CM_SURF_FMT_SRGBA8_ASTC_5x5);\n    COMPILE_TIME_ASSERT(201 == CM_SURF_FMT_SRGBA8_ASTC_6x5);\n    COMPILE_TIME_ASSERT(202 == CM_SURF_FMT_SRGBA8_ASTC_6x6);\n    COMPILE_TIME_ASSERT(203 == CM_SURF_FMT_SRGBA8_ASTC_8x5);\n    COMPILE_TIME_ASSERT(204 == CM_SURF_FMT_SRGBA8_ASTC_8x6);\n    COMPILE_TIME_ASSERT(205 == CM_SURF_FMT_SRGBA8_ASTC_8x8);\n    COMPILE_TIME_ASSERT(206 == CM_SURF_FMT_SRGBA8_ASTC_10x5);\n    COMPILE_TIME_ASSERT(207 == CM_SURF_FMT_SRGBA8_ASTC_10x6);\n    COMPILE_TIME_ASSERT(208 == CM_SURF_FMT_SRGBA8_ASTC_10x8);\n    COMPILE_TIME_ASSERT(209 == CM_SURF_FMT_SRGBA8_ASTC_10x10);\n    COMPILE_TIME_ASSERT(210 == CM_SURF_FMT_SRGBA8_ASTC_12x10);\n    COMPILE_TIME_ASSERT(211 == CM_SURF_FMT_SRGBA8_ASTC_12x12);\n    COMPILE_TIME_ASSERT(212 == CM_SURF_FMT_BGR10_A2UI);\n    COMPILE_TIME_ASSERT(213 == CM_SURF_FMT_A2_BGR10UI);\n    COMPILE_TIME_ASSERT(214 == CM_SURF_FMT_A2_RGB10UI);\n    COMPILE_TIME_ASSERT(215 == CM_SURF_FMT_B5_G6_R5UI);\n    COMPILE_TIME_ASSERT(216 == CM_SURF_FMT_R5_G6_B5UI);\n    COMPILE_TIME_ASSERT(217 == CM_SURF_FMT_DEPTH32F_X24_STEN8_UNCLAMPED);\n    COMPILE_TIME_ASSERT(218 == CM_SURF_FMT_DEPTH32F_UNCLAMPED);\n    COMPILE_TIME_ASSERT(219 == CM_SURF_FMT_L8_X16_A8_SRGB);\n    COMPILE_TIME_ASSERT(220 == CM_SURF_FMT_L8_X24_SRGB);\n    COMPILE_TIME_ASSERT(221 == CM_SURF_FMT_STENCIL8);\n    COMPILE_TIME_ASSERT(222 == CM_SURF_FMT_L8_SRGB);\n    COMPILE_TIME_ASSERT(223 == CM_SURF_FMT_R8_SRGB);\n    COMPILE_TIME_ASSERT(224 == CM_SURF_FMT_RG8_SRGB);\n#else\n    COMPILE_TIME_ASSERT(126 == CM_SURF_FMT_sRGBX32I);\n    COMPILE_TIME_ASSERT(127 == CM_SURF_FMT_sALPHA32I);\n    COMPILE_TIME_ASSERT(128 == CM_SURF_FMT_sINTENSITY32I);\n    COMPILE_TIME_ASSERT(129 == CM_SURF_FMT_sLUMINANCE32I);\n    COMPILE_TIME_ASSERT(130 == CM_SURF_FMT_sLUMINANCE_ALPHA32I);\n    COMPILE_TIME_ASSERT(131 == CM_SURF_FMT_sRGBA16I);\n    COMPILE_TIME_ASSERT(132 == CM_SURF_FMT_sRGBX16I);\n    COMPILE_TIME_ASSERT(133 == CM_SURF_FMT_sALPHA16I);\n    COMPILE_TIME_ASSERT(134 == CM_SURF_FMT_sINTENSITY16I);\n    COMPILE_TIME_ASSERT(135 == CM_SURF_FMT_sLUMINANCE16I);\n    COMPILE_TIME_ASSERT(136 == CM_SURF_FMT_sLUMINANCE_ALPHA16I);\n    COMPILE_TIME_ASSERT(137 == CM_SURF_FMT_sRGBA8I);\n    COMPILE_TIME_ASSERT(138 == CM_SURF_FMT_sRGBX8I);\n    COMPILE_TIME_ASSERT(139 == CM_SURF_FMT_sALPHA8I);\n    COMPILE_TIME_ASSERT(140 == CM_SURF_FMT_sINTENSITY8I);\n    COMPILE_TIME_ASSERT(141 == CM_SURF_FMT_sLUMINANCE8I);\n    COMPILE_TIME_ASSERT(142 == CM_SURF_FMT_sLUMINANCE_ALPHA8I);\n    COMPILE_TIME_ASSERT(143 == CM_SURF_FMT_sDXT6);\n    COMPILE_TIME_ASSERT(144 == CM_SURF_FMT_DXT6);\n    COMPILE_TIME_ASSERT(145 == CM_SURF_FMT_DXT7);\n    COMPILE_TIME_ASSERT(146 == CM_SURF_FMT_LUMINANCE8_SNORM);\n    COMPILE_TIME_ASSERT(147 == CM_SURF_FMT_LUMINANCE16_SNORM);\n    COMPILE_TIME_ASSERT(148 == CM_SURF_FMT_INTENSITY8_SNORM);\n    COMPILE_TIME_ASSERT(149 == CM_SURF_FMT_INTENSITY16_SNORM);\n    COMPILE_TIME_ASSERT(150 == CM_SURF_FMT_ALPHA8_SNORM);\n    COMPILE_TIME_ASSERT(151 == CM_SURF_FMT_ALPHA16_SNORM);\n    COMPILE_TIME_ASSERT(152 == CM_SURF_FMT_LUMINANCE_ALPHA8_SNORM);\n    COMPILE_TIME_ASSERT(153 == CM_SURF_FMT_LUMINANCE_ALPHA16_SNORM);\n    COMPILE_TIME_ASSERT(154 == CM_SURF_FMT_R8_SNORM);\n    COMPILE_TIME_ASSERT(155 == CM_SURF_FMT_R16_SNORM);\n    COMPILE_TIME_ASSERT(156 == CM_SURF_FMT_RG8_SNORM);\n    COMPILE_TIME_ASSERT(157 == CM_SURF_FMT_RG16_SNORM);\n    COMPILE_TIME_ASSERT(158 == CM_SURF_FMT_RGBX8_SNORM);\n    COMPILE_TIME_ASSERT(159 == CM_SURF_FMT_RGBX16_SNORM);\n    COMPILE_TIME_ASSERT(160 == CM_SURF_FMT_RGBA8_SNORM);\n    COMPILE_TIME_ASSERT(161 == CM_SURF_FMT_RGBA16_SNORM);\n    COMPILE_TIME_ASSERT(162 == CM_SURF_FMT_RGB10_A2UI);\n    COMPILE_TIME_ASSERT(163 == CM_SURF_FMT_RGB32F);\n    COMPILE_TIME_ASSERT(164 == CM_SURF_FMT_RGB32I);\n    COMPILE_TIME_ASSERT(165 == CM_SURF_FMT_RGB32UI);\n    COMPILE_TIME_ASSERT(166 == CM_SURF_FMT_RGBX8_SRGB);\n    COMPILE_TIME_ASSERT(167 == CM_SURF_FMT_RGBA8_SRGB);\n    COMPILE_TIME_ASSERT(168 == CM_SURF_FMT_DXT1_SRGB);\n    COMPILE_TIME_ASSERT(169 == CM_SURF_FMT_DXT1A_SRGB);\n    COMPILE_TIME_ASSERT(170 == CM_SURF_FMT_DXT2_3_SRGB);\n    COMPILE_TIME_ASSERT(171 == CM_SURF_FMT_DXT4_5_SRGB);\n    COMPILE_TIME_ASSERT(172 == CM_SURF_FMT_DXT7_SRGB);\n    COMPILE_TIME_ASSERT(173 == CM_SURF_FMT_RGB8_ETC2);\n    COMPILE_TIME_ASSERT(174 == CM_SURF_FMT_SRGB8_ETC2);\n    COMPILE_TIME_ASSERT(175 == CM_SURF_FMT_RGB8_PT_ALPHA1_ETC2);\n    COMPILE_TIME_ASSERT(176 == CM_SURF_FMT_SRGB8_PT_ALPHA1_ETC2);\n    COMPILE_TIME_ASSERT(177 == CM_SURF_FMT_RGBA8_ETC2_EAC);\n    COMPILE_TIME_ASSERT(178 == CM_SURF_FMT_SRGB8_ALPHA8_ETC2_EAC);\n    COMPILE_TIME_ASSERT(179 == CM_SURF_FMT_R11_EAC);\n    COMPILE_TIME_ASSERT(180 == CM_SURF_FMT_SIGNED_R11_EAC);\n    COMPILE_TIME_ASSERT(181 == CM_SURF_FMT_RG11_EAC);\n    COMPILE_TIME_ASSERT(182 == CM_SURF_FMT_SIGNED_RG11_EAC);\n    COMPILE_TIME_ASSERT(183 == CM_SURF_FMT_RGBA8_ASTC_4x4);\n    COMPILE_TIME_ASSERT(184 == CM_SURF_FMT_RGBA8_ASTC_5x4);\n    COMPILE_TIME_ASSERT(185 == CM_SURF_FMT_RGBA8_ASTC_5x5);\n    COMPILE_TIME_ASSERT(186 == CM_SURF_FMT_RGBA8_ASTC_6x5);\n    COMPILE_TIME_ASSERT(187 == CM_SURF_FMT_RGBA8_ASTC_6x6);\n    COMPILE_TIME_ASSERT(188 == CM_SURF_FMT_RGBA8_ASTC_8x5);\n    COMPILE_TIME_ASSERT(189 == CM_SURF_FMT_RGBA8_ASTC_8x6);\n    COMPILE_TIME_ASSERT(190 == CM_SURF_FMT_RGBA8_ASTC_8x8);\n    COMPILE_TIME_ASSERT(191 == CM_SURF_FMT_RGBA8_ASTC_10x5);\n    COMPILE_TIME_ASSERT(192 == CM_SURF_FMT_RGBA8_ASTC_10x6);\n    COMPILE_TIME_ASSERT(193 == CM_SURF_FMT_RGBA8_ASTC_10x8);\n    COMPILE_TIME_ASSERT(194 == CM_SURF_FMT_RGBA8_ASTC_10x10);\n    COMPILE_TIME_ASSERT(195 == CM_SURF_FMT_RGBA8_ASTC_12x10);\n    COMPILE_TIME_ASSERT(196 == CM_SURF_FMT_RGBA8_ASTC_12x12);\n    COMPILE_TIME_ASSERT(197 == CM_SURF_FMT_SRGBA8_ASTC_4x4);\n    COMPILE_TIME_ASSERT(198 == CM_SURF_FMT_SRGBA8_ASTC_5x4);\n    COMPILE_TIME_ASSERT(199 == CM_SURF_FMT_SRGBA8_ASTC_5x5);\n    COMPILE_TIME_ASSERT(200 == CM_SURF_FMT_SRGBA8_ASTC_6x5);\n    COMPILE_TIME_ASSERT(201 == CM_SURF_FMT_SRGBA8_ASTC_6x6);\n    COMPILE_TIME_ASSERT(202 == CM_SURF_FMT_SRGBA8_ASTC_8x5);\n    COMPILE_TIME_ASSERT(203 == CM_SURF_FMT_SRGBA8_ASTC_8x6);\n    COMPILE_TIME_ASSERT(204 == CM_SURF_FMT_SRGBA8_ASTC_8x8);\n    COMPILE_TIME_ASSERT(205 == CM_SURF_FMT_SRGBA8_ASTC_10x5);\n    COMPILE_TIME_ASSERT(206 == CM_SURF_FMT_SRGBA8_ASTC_10x6);\n    COMPILE_TIME_ASSERT(207 == CM_SURF_FMT_SRGBA8_ASTC_10x8);\n    COMPILE_TIME_ASSERT(208 == CM_SURF_FMT_SRGBA8_ASTC_10x10);\n    COMPILE_TIME_ASSERT(209 == CM_SURF_FMT_SRGBA8_ASTC_12x10);\n    COMPILE_TIME_ASSERT(210 == CM_SURF_FMT_SRGBA8_ASTC_12x12);\n    COMPILE_TIME_ASSERT(211 == CM_SURF_FMT_BGR10_A2UI);\n    COMPILE_TIME_ASSERT(212 == CM_SURF_FMT_A2_BGR10UI);\n    COMPILE_TIME_ASSERT(213 == CM_SURF_FMT_A2_RGB10UI);\n    COMPILE_TIME_ASSERT(214 == CM_SURF_FMT_B5_G6_R5UI);\n    COMPILE_TIME_ASSERT(215 == CM_SURF_FMT_R5_G6_B5UI);\n    COMPILE_TIME_ASSERT(216 == CM_SURF_FMT_DEPTH32F_X24_STEN8_UNCLAMPED);\n    COMPILE_TIME_ASSERT(217 == CM_SURF_FMT_DEPTH32F_UNCLAMPED);\n    COMPILE_TIME_ASSERT(218 == CM_SURF_FMT_L8_X16_A8_SRGB);\n    COMPILE_TIME_ASSERT(219 == CM_SURF_FMT_L8_X24_SRGB);\n    COMPILE_TIME_ASSERT(220 == CM_SURF_FMT_STENCIL8);\n    COMPILE_TIME_ASSERT(221 == CM_SURF_FMT_L8_SRGB);\n    COMPILE_TIME_ASSERT(222 == CM_SURF_FMT_R8_SRGB);\n    COMPILE_TIME_ASSERT(223 == CM_SURF_FMT_RG8_SRGB);\n#endif\n    COMPILE_TIME_ASSERT(cmSurfFmt_LAST  == CM_SURF_FMT_RG8_SRGB);\n    COMPILE_TIME_ASSERT(cmSurfFmt_LAST < 501);\n}\n\n#ifdef ATI_OS_LINUX\ntypedef void* (*PFNGlxGetProcAddress)(const GLubyte* procName);\nstatic PFNGlxGetProcAddress    pfnGlxGetProcAddress=NULL;\nstatic PFNGLXBEGINCLINTEROPAMD glXBeginCLInteropAMD = NULL;\nstatic PFNGLXENDCLINTEROPAMD glXEndCLInteropAMD = NULL;\nstatic PFNGLXRESOURCEATTACHAMD glXResourceAttachAMD = NULL;\nstatic PFNGLXRESOURCEDETACHAMD glxResourceAcquireAMD = NULL;\nstatic PFNGLXRESOURCEDETACHAMD glxResourceReleaseAMD = NULL;\nstatic PFNGLXRESOURCEDETACHAMD glXResourceDetachAMD = NULL;\nstatic PFNGLXGETCONTEXTMVPUINFOAMD glXGetContextMVPUInfoAMD = NULL;\n#else\nstatic PFNWGLBEGINCLINTEROPAMD wglBeginCLInteropAMD = NULL;\nstatic PFNWGLENDCLINTEROPAMD wglEndCLInteropAMD = NULL;\nstatic PFNWGLRESOURCEATTACHAMD wglResourceAttachAMD = NULL;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceAcquireAMD = NULL;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceReleaseAMD = NULL;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceDetachAMD = NULL;\nstatic PFNWGLGETCONTEXTGPUINFOAMD wglGetContextGPUInfoAMD = NULL;\n#endif\n\nbool\nCALGSLDevice::initGLInteropPrivateExt(CALvoid* GLplatformContext, CALvoid* GLdeviceContext) const\n{\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext)GLplatformContext;\n    void * pModule = dlopen(\"libGL.so.1\",RTLD_NOW);\n\n    if(NULL == pModule){\n        return false;\n    }\n    pfnGlxGetProcAddress = (PFNGlxGetProcAddress) dlsym(pModule,\"glXGetProcAddress\");\n\n    if (NULL == pfnGlxGetProcAddress){\n        return false;\n    }\n\n    if (!glXBeginCLInteropAMD || !glXEndCLInteropAMD || !glXResourceAttachAMD ||\n        !glXResourceDetachAMD || !glXGetContextMVPUInfoAMD)\n    {\n        glXBeginCLInteropAMD = (PFNGLXBEGINCLINTEROPAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXBeginCLInteroperabilityAMD\");\n        glXEndCLInteropAMD = (PFNGLXENDCLINTEROPAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXEndCLInteroperabilityAMD\");\n        glXResourceAttachAMD = (PFNGLXRESOURCEATTACHAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXResourceAttachAMD\");\n        glxResourceAcquireAMD = (PFNGLXRESOURCEDETACHAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXResourceAcquireAMD\");\n        glxResourceReleaseAMD = (PFNGLXRESOURCEDETACHAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXResourceReleaseAMD\");\n        glXResourceDetachAMD = (PFNGLXRESOURCEDETACHAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXResourceDetachAMD\");\n        glXGetContextMVPUInfoAMD = (PFNGLXGETCONTEXTMVPUINFOAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXGetContextMVPUInfoAMD\");\n    }\n\n    if (!glXBeginCLInteropAMD || !glXEndCLInteropAMD || !glXResourceAttachAMD ||\n        !glXResourceDetachAMD\n#ifndef BRAHMA\n        || !glXGetContextMVPUInfoAMD\n#endif\n        )\n    {\n        return false;\n    }\n#else\n    if (!wglBeginCLInteropAMD || !wglEndCLInteropAMD || !wglResourceAttachAMD ||\n        !wglResourceDetachAMD || !wglGetContextGPUInfoAMD)\n    {\n        HGLRC fakeRC = NULL;\n\n        if (!wglGetCurrentContext())\n        {\n            fakeRC = wglCreateContext((HDC)GLdeviceContext);\n            wglMakeCurrent((HDC)GLdeviceContext, fakeRC);\n        }\n\n        wglBeginCLInteropAMD = (PFNWGLBEGINCLINTEROPAMD) wglGetProcAddress (\"wglBeginCLInteroperabilityAMD\");\n        wglEndCLInteropAMD = (PFNWGLENDCLINTEROPAMD) wglGetProcAddress (\"wglEndCLInteroperabilityAMD\");\n        wglResourceAttachAMD = (PFNWGLRESOURCEATTACHAMD) wglGetProcAddress (\"wglResourceAttachAMD\");\n        wglResourceAcquireAMD = (PFNWGLRESOURCEDETACHAMD) wglGetProcAddress (\"wglResourceAcquireAMD\");\n        wglResourceReleaseAMD = (PFNWGLRESOURCEDETACHAMD) wglGetProcAddress (\"wglResourceReleaseAMD\");\n        wglResourceDetachAMD = (PFNWGLRESOURCEDETACHAMD) wglGetProcAddress (\"wglResourceDetachAMD\");\n        wglGetContextGPUInfoAMD = (PFNWGLGETCONTEXTGPUINFOAMD) wglGetProcAddress (\"wglGetContextGPUInfoAMD\");\n\n        if (fakeRC)\n        {\n            wglMakeCurrent(NULL, NULL);\n            wglDeleteContext(fakeRC);\n        }\n    }\n    if (!wglBeginCLInteropAMD || !wglEndCLInteropAMD || !wglResourceAttachAMD ||\n        !wglResourceDetachAMD || !wglGetContextGPUInfoAMD)\n    {\n        return false;\n    }\n#endif\n    return true;\n}\n\nbool\nCALGSLDevice::glCanInterop(CALvoid* GLplatformContext, CALvoid* GLdeviceContext)\n{\n    bool canInteroperate = false;\n\n#ifdef ATI_OS_WIN\n    LUID glAdapterLuid = {0, 0};\n    UINT glChainBitMask = 0;\n\n    LUID calAdapterLuid = {0, 0};\n    UINT calChainBitMask = 0;\n\n    HGLRC hRC = (HGLRC)GLplatformContext;\n\n    //get GL context's LUID and chainBitMask from UGL\n    if (wglGetContextGPUInfoAMD(hRC, &glAdapterLuid, &glChainBitMask))\n    {\n        //now check against the CAL device' LUID and chainBitMask.\n        if (m_adp->getMVPUinfo(&calAdapterLuid, &calChainBitMask))\n        {\n            canInteroperate = ((glAdapterLuid.HighPart == calAdapterLuid.HighPart) &&\n                               (glAdapterLuid.LowPart == calAdapterLuid.LowPart) &&\n                               (glChainBitMask == calChainBitMask));\n        }\n    }\n#elif defined (ATI_OS_LINUX)\n#ifdef BRAHMA\n    canInteroperate = true;\n#else\n    GLuint glDeviceId = 0 ;\n    GLuint glChainMask = 0 ;\n    GLXContext ctx = (GLXContext)GLplatformContext;\n    \n    if (glXGetContextMVPUInfoAMD(ctx,&glDeviceId,&glChainMask)){\n        GLuint deviceId = 0 ;\n        GLuint chainMask = 0 ;\n\n        if (m_adp->getMVPUinfo(&deviceId, &chainMask))\n        {\n        // we allow intoperability only with GL context\n        // reside on a single GPU\n            if (deviceId == glDeviceId && chainMask == glChainMask){\n                    canInteroperate = true;\n            }\n        }\n    }\n#endif\n#endif\n    return canInteroperate;\n}\n\nbool\nCALGSLDevice::glAssociate(CALvoid* GLplatformContext, CALvoid* GLdeviceContext)\n{\n    //initialize pointers to the gl extension that supports interoperability\n    if (!initGLInteropPrivateExt(GLplatformContext, GLdeviceContext) ||\n        !glCanInterop(GLplatformContext, GLdeviceContext))\n    {\n        return false;\n    }\n\n    int flags = 0;\n\n    if (m_adp->pAsicInfo->svmFineGrainSystem)\n    {\n        flags = GL_INTEROP_SVM;\n    }\n\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext)GLplatformContext;\n    return (glXBeginCLInteropAMD(ctx, 0)) ? true : false;\n#else\n    HGLRC hRC = (HGLRC)GLplatformContext;\n    return (wglBeginCLInteropAMD(hRC, flags)) ? true : false;\n#endif\n}\n\nbool\nCALGSLDevice::glDissociate(CALvoid* GLplatformContext, CALvoid* GLdeviceContext)\n{\n    int flags = 0;\n\n    if (m_adp->pAsicInfo->svmFineGrainSystem)\n    {\n        flags = GL_INTEROP_SVM;\n    }\n\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext)GLplatformContext;\n    return (glXEndCLInteropAMD(ctx, 0)) ? true : false;\n#else\n    HGLRC hRC = (HGLRC)GLplatformContext;\n    return (wglEndCLInteropAMD(hRC, flags)) ? true : false;\n#endif\n}\n\nbool\nCALGSLDevice::resGLAssociate(GLResAssociate & resData) const\n{\n    //! @note: GSL device isn't thread safe\n    amd::ScopedLock k(gslDeviceOps());\n\n    GLResource hRes = {0};\n    bool status = false;\n    cmSurfFmt cal_cmFormat;\n    uint32 depth;\n\n    gslMemObjectAttribs attribs(\n        GSL_MOA_TEXTURE_2D,      // type\n        GSL_MOA_MEMORY_ALIAS,    // location\n        GSL_MOA_TILING_TILED,    // tiling\n        GSL_MOA_DISPLAYABLE_NO,  // displayable\n        ATIGL_FALSE,             // mipmap\n        1,                       // samples\n        0,                       // cpu_address\n        GSL_MOA_SIGNED_NO,       // signed_format\n        GSL_MOA_FORMAT_DERIVED,  // numFormat\n        DRIVER_MODULE_GLL,       // module\n        GSL_ALLOCATION_INSTANCED // alloc_type\n    );\n\n    hRes.type = resData.type;\n\n    GLResourceData* hData = new GLResourceData;\n    if (NULL == hData)\n    {\n        return false;\n    }\n    memset(hData, 0, sizeof(GLResourceData));\n\n    hRes.name = resData.name;\n    hRes.flags = resData.flags;\n    hData->version = GL_RESOURCE_DATA_VERSION;\n\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext)resData.GLContext;\n    if (glXResourceAttachAMD(ctx, &hRes, hData))\n    {\n        attribs.dynamicSharedBufferID = hData->sharedBufferID;\n        status = true;\n    }\n#else\n    HGLRC hRC = (HGLRC)resData.GLContext;\n    if (wglResourceAttachAMD(hRC, &hRes, hData))\n    {\n        status =  true;\n    }\n#endif\n\n    if (!status)\n    {\n        return false;\n    }\n\n    // for now, to be safe, allow only textures to have a depth other than 1\n    if (hRes.type == GL_RESOURCE_ATTACH_TEXTURE_AMD)\n    {\n        depth = hData->rawDimensions.depth;\n    }\n    else\n    {\n        depth = 1;\n    }\n\n    attribs.type = static_cast<gslMemObjectAttribType>(hData->objectAttribType);\n\n    osAssert(depth <= GLRDATA_MAX_LAYERS);\n    osAssert(depth >= 1);\n    attribs.alias_swizzles = (uint32*)malloc(depth * 2 * sizeof(uint32));\n    osAssert(attribs.alias_swizzles);\n    memcpy (attribs.alias_swizzles, hData->swizzles, sizeof(uint32) * depth);\n    if (hData->levels > 1)\n    {\n        attribs.mipmap = ATIGL_TRUE;\n        attribs.levels = static_cast<GLuint>(hData->levels);\n        memcpy (&attribs.alias_swizzles[depth], hData->swizzlesMip, sizeof(uint32) * depth);\n    }\n\n    attribs.cpu_address = (void*)hData->handle;\n    attribs.alias_subtile = hData->tilingMode;\n    attribs.mcaddress = hData->cardAddr;\n    if (hData->isDoppDesktopTexture == GL_TRUE || (hData->isDoppPresentTexture == GL_TRUE) ||\n        (hData->isDisplayable == GL_TRUE))\n    {\n        attribs.isDOPPDesktopTexture = (hData->isDoppDesktopTexture == GL_TRUE);\n        attribs.displayable = hData->isTilingRotated\n                                  ? GSL_MOA_DISPLAYABLE_PORTRAIT_ROTATED : GSL_MOA_DISPLAYABLE_LAYOUT;\n    }\n    attribs.doppVidpnSourceId = hData->vidpnSourceId;\n\n    // VBOs are hardcoded to have a UINT8 type format\n    if (hRes.type == GL_RESOURCE_ATTACH_VERTEXBUFFER_AMD)\n    {\n        hData->format = CM_SURF_FMT_LUMINANCE8;\n    }\n    // CAL supports only a limited number of cm_surf formats, so we\n    // have to translate incoming cm_surf formats\n    uint32 index = hData->format - (uint32)CM_SURF_FMT_LUMINANCE8;\n    if (index >= sizeof(cmFormatXlateTable)/sizeof(cmFormatXlateParams))\n    {\n        free(attribs.alias_swizzles);\n        delete hData;\n        return false;\n    }\n    osAssert(static_cast<cmSurfFmt>(hData->format) == cmFormatXlateTable[index].raw_cmFormat);\n    cal_cmFormat = cmFormatXlateTable[index].cal_cmFormat;\n    if (cal_cmFormat == 500)\n    {\n        free(attribs.alias_swizzles);\n        delete hData;\n        return false;  // format is not supported by CAL\n    }\n    attribs.channelOrder = cmFormatXlateTable[index].channelOrder;\n    attribs.alias_perSurfTileInfo = hData->perSurfTileInfo;\n    attribs.alias_GLInterop = ATIGL_TRUE;\n    attribs.numFormat = GSL_MOA_FORMAT_DERIVED;\n\n    gslMemObject    mem;\n\n    if (hData->offset != 0)\n    {\n        osAssert((hData->rawDimensions.height == 1) && (depth == 1));\n        mem = m_cs->createMemObject2D(CM_SURF_FMT_LUMINANCE8, hData->surfaceSize, 1, &attribs);\n    }\n    else\n    {\n        mem = m_cs->createMemObject3D(cal_cmFormat, hData->paddedDimensions.width,\n            hData->rawDimensions.height, depth, &attribs);\n    }\n    if (hRes.type == GL_RESOURCE_ATTACH_VERTEXBUFFER_AMD)\n    {\n        attribs.tiling = mem->getAttribs().tiling;\n        resData.mem_base = mem;\n        mem  = m_cs->createOffsetMemObject2D(resData.mem_base, (static_cast<uintp>(hData->offset)),\n                                                                cal_cmFormat,\n                                                                hData->paddedDimensions.width,\n                                                                1, &attribs);\n    }\n    else if ((hData->offset != 0) && (hData->rawDimensions.height == 1) && (depth == 1))\n    {\n        resData.mem_base = mem;\n        attribs.tiling = mem->getAttribs().tiling;\n        mem = m_cs->createOffsetMemObject3D(resData.mem_base, (static_cast<uintp>(hData->offset)),\n            cal_cmFormat, hData->paddedDimensions.width,\n            hData->rawDimensions.height, depth, &attribs);\n    }\n    free (attribs.alias_swizzles);\n    resData.mbResHandle = (CALvoid*)hData->mbResHandle;\n    resData.memObject = mem;\n    delete hData;\n    return mem != 0;\n}\n\nbool\nCALGSLDevice::resGLAcquire(CALvoid* GLplatformContext,\n    CALvoid* mbResHandle,\n    CALuint type) const\n{\n    //! @note: GSL device isn't thread safe\n    amd::ScopedLock k(gslDeviceOps());\n\n    GLResource hRes = {0};\n    osAssert(mbResHandle);\n    hRes.mbResHandle = (GLuintp)mbResHandle;\n    hRes.type = type;\n\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext) GLplatformContext;\n    return (glxResourceAcquireAMD(ctx, &hRes)) ? true : false;\n#else\n    HGLRC hRC = wglGetCurrentContext();\n    //! @todo A temporary workaround for MT issue in conformance fence_sync\n    if (0 == hRC) {\n        return true;\n    }\n    return (wglResourceAcquireAMD(hRC, &hRes)) ? true : false;\n#endif\n}\n\nbool\nCALGSLDevice::resGLRelease(CALvoid* GLplatformContext,\n    CALvoid* mbResHandle,\n    CALuint type) const\n{\n    //! @note: GSL device isn't thread safe\n    amd::ScopedLock k(gslDeviceOps());\n\n    GLResource hRes = {0};\n    osAssert(mbResHandle);\n    hRes.mbResHandle = (GLuintp)mbResHandle;\n    hRes.type = type;\n\n#ifdef ATI_OS_LINUX\n    //TODO : make sure the application GL context is current. if not no\n    // point calling into the GL RT.\n    GLXContext ctx = (GLXContext) GLplatformContext;\n    return (glxResourceReleaseAMD(ctx, &hRes)) ? true : false;\n#else\n    // Make the call into the GL driver only if the application GL context is current\n    HGLRC hRC = wglGetCurrentContext();\n    //! @todo A temporary workaround for MT issue in conformance fence_sync\n    if (0 == hRC) {\n        return true;\n    }\n    return (wglResourceReleaseAMD(hRC, &hRes)) ? true : false;\n#endif\n}\n\nbool\nCALGSLDevice::resGLFree (\n    CALvoid* GLplatformContext,\n    CALvoid* GLdeviceContext,\n    gslMemObject mem,\n    gslMemObject mem_base,\n    CALvoid* mbResHandle,\n    CALuint type) const\n{\n    //! @note: GSL device isn't thread safe\n    amd::ScopedLock k(gslDeviceOps());\n\n    GLResource hRes = {0};\n\n    osAssert(mbResHandle);\n    hRes.mbResHandle = (GLuintp)mbResHandle;\n    hRes.type = type;\n\n    if (mem_base)\n    {\n        m_cs->destroyMemObject(mem_base);\n    }\n    m_cs->destroyMemObject(mem);\n\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext)GLplatformContext;\n    return (glXResourceDetachAMD(ctx, &hRes)) ? true : false;\n#else\n    HGLRC hRC = (HGLRC)GLplatformContext;\n    return (wglResourceDetachAMD(hRC, &hRes)) ? true : false;\n#endif\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.9.0-neudjleb7hiztwlofocdddh3xyfxtn44/spack-src/device/rocm/pro/prodevice.cpp": "/* Copyright (c) 2017-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#ifndef WITHOUT_HSA_BACKEND\n\n#include \"hsa_ext_amd.h\"\n#include \"lnxheaders.h\"\n#include \"prodevice.hpp\"\n#include \"amdgpu_drm.h\"\n\nnamespace roc {\n\nconstexpr uint32_t kMaxDevices  = 32;\nconstexpr uint32_t kAtiVendorId = 0x1002;\n\nvoid*      ProDevice::lib_drm_handle_ = nullptr;\nbool       ProDevice::initialized_ = false;\ndrm::Funcs ProDevice::funcs_;\n\nIProDevice* IProDevice::Init(uint32_t bus, uint32_t dev, uint32_t func)\n{\n  // Make sure DRM lib is initialized\n  if (!ProDevice::DrmInit()) {\n    return nullptr;\n  }\n\n  ProDevice* pro_device = new ProDevice();\n\n  if (pro_device == nullptr || !pro_device->Create(bus, dev, func)) {\n    delete pro_device;\n    return nullptr;\n  }\n  return pro_device;\n}\n\nProDevice::~ProDevice() {\n  delete alloc_ops_;\n\n  if (dev_handle_ != nullptr) {\n    Funcs().AmdgpuDeviceDeinitialize(dev_handle_);\n  }\n  if (file_desc_ > 0) {\n    close(file_desc_);\n  }\n}\n\nbool ProDevice::DrmInit()\n{\n  if (initialized_ == false) {\n    // Find symbols in libdrm_amdgpu.so.1\n    lib_drm_handle_ = dlopen(\"libdrm_amdgpu.so.1\", RTLD_NOW);\n    if (lib_drm_handle_ == nullptr) {\n      return false;\n    } else {\n      funcs_.DrmGetDevices = reinterpret_cast<drm::DrmGetDevices>(dlsym(\n                             lib_drm_handle_,\n                             \"drmGetDevices\"));\n      if (funcs_.DrmGetDevices == nullptr) return false;\n      funcs_.AmdgpuDeviceInitialize = reinterpret_cast<drm::AmdgpuDeviceInitialize>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_device_initialize\"));\n      if (funcs_.AmdgpuDeviceInitialize == nullptr) return false;\n      funcs_.AmdgpuDeviceDeinitialize = reinterpret_cast<drm::AmdgpuDeviceDeinitialize>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_device_deinitialize\"));\n      if (funcs_.AmdgpuDeviceDeinitialize == nullptr) return false;\n      funcs_.AmdgpuQueryGpuInfo = reinterpret_cast<drm::AmdgpuQueryGpuInfo>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_query_gpu_info\"));\n      if (funcs_.AmdgpuQueryGpuInfo == nullptr) return false;\n      funcs_.AmdgpuQueryInfo = reinterpret_cast<drm::AmdgpuQueryInfo>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_query_info\"));\n      if (funcs_.AmdgpuQueryInfo == nullptr) return false;\n      funcs_.AmdgpuBoAlloc = reinterpret_cast<drm::AmdgpuBoAlloc>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_bo_alloc\"));\n      if (funcs_.AmdgpuBoAlloc == nullptr) return false;\n      funcs_.AmdgpuBoExport = reinterpret_cast<drm::AmdgpuBoExport>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_bo_export\"));\n      if (funcs_.AmdgpuBoExport == nullptr) return false;\n      funcs_.AmdgpuBoFree = reinterpret_cast<drm::AmdgpuBoFree>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_bo_free\"));\n      if (funcs_.AmdgpuBoFree == nullptr) return false;\n      funcs_.AmdgpuBoCpuMap = reinterpret_cast<drm::AmdgpuBoCpuMap>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_bo_cpu_map\"));\n      if (funcs_.AmdgpuBoCpuMap == nullptr) return false;\n      funcs_.AmdgpuBoCpuUnmap = reinterpret_cast<drm::AmdgpuBoCpuUnmap>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_bo_cpu_unmap\"));\n      if (funcs_.AmdgpuBoCpuUnmap == nullptr) return false;\n    }\n  }\n\n  initialized_ = true;\n  return true;\n}\n\n#ifndef AMDGPU_CAPABILITY_SSG_FLAG\n#define AMDGPU_CAPABILITY_SSG_FLAG 4\n#endif\n\n// ================================================================================================\n// Open drm device and initialize it. And also get the drm information.\nbool ProDevice::Create(uint32_t bus, uint32_t device, uint32_t func) {\n  drmDevicePtr  devices[kMaxDevices] = { };\n  int32_t device_count = Funcs().DrmGetDevices(devices, kMaxDevices);\n  bool    result = false;\n\n  for (int32_t i = 0; i < device_count; i++) {\n    // Check if the device vendor is AMD\n    if (devices[i]->deviceinfo.pci->vendor_id != kAtiVendorId) {\n      continue;\n    }\n    if ((devices[i]->businfo.pci->bus == bus) &&\n        (devices[i]->businfo.pci->dev == device) &&\n        (devices[i]->businfo.pci->func == func)) {\n\n      // pDevices[i]->nodes[DRM_NODE_PRIMARY];\n      // Using render node here so that we can do the off-screen rendering without authentication\n      file_desc_ = open(devices[i]->nodes[DRM_NODE_RENDER], O_RDWR, 0);\n\n      if (file_desc_ > 0) {\n        void* data, *file, *cap;\n\n        // Initialize the admgpu device.\n        if (Funcs().AmdgpuDeviceInitialize(file_desc_, &major_ver_,\n                                           &minor_ver_, &dev_handle_) == 0) {\n          uint32_t version = 0;\n          // amdgpu_query_gpu_info will never fail only if it is initialized\n          Funcs().AmdgpuQueryGpuInfo(dev_handle_, &gpu_info_);\n\n          drm_amdgpu_capability cap = {};\n          Funcs().AmdgpuQueryInfo(dev_handle_, AMDGPU_INFO_CAPABILITY, sizeof(drm_amdgpu_capability), &cap);\n\n          // Check if DGMA and SSG are available\n          if ((cap.flag & (AMDGPU_CAPABILITY_DIRECT_GMA_FLAG | AMDGPU_CAPABILITY_SSG_FLAG)) == \n              (AMDGPU_CAPABILITY_DIRECT_GMA_FLAG | AMDGPU_CAPABILITY_SSG_FLAG)) {\n            result = true;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  if (result) {\n    alloc_ops_ = new amd::Monitor(\"DGMA mem alloc lock\", true);\n    if (nullptr == alloc_ops_) {\n      return true;\n    }\n  }\n\n  return result;\n}\n\nvoid* ProDevice::AllocDmaBuffer(hsa_agent_t agent, size_t size, void** host_ptr) const\n{\n  amd::ScopedLock l(alloc_ops_);\n  void* ptr = nullptr;\n  amdgpu_bo_handle buf_handle = 0;\n  amdgpu_bo_alloc_request req = {0};\n  *host_ptr = nullptr;\n\n  req.alloc_size = size;\n  req.phys_alignment = 64 * Ki;\n  req.preferred_heap = AMDGPU_GEM_DOMAIN_DGMA;\n\n  // Allocate buffer in DGMA heap\n  if (0 == Funcs().AmdgpuBoAlloc(dev_handle_, &req, &buf_handle)) {\n    amdgpu_bo_handle_type type = amdgpu_bo_handle_type_dma_buf_fd;\n    uint32_t shared_handle = 0;\n    // Find the base driver handle\n    if (0 == Funcs().AmdgpuBoExport(buf_handle, type, &shared_handle)) {\n      uint32_t  flags = 0;\n      size_t    buf_size = 0;\n      // Map memory object to HSA device\n      if (0 == hsa_amd_interop_map_buffer(1, &agent, shared_handle,\n                                          flags, &buf_size, &ptr, nullptr, nullptr)) {\n        // Ask GPUPro driver to provide CPU access to allocation\n        if (0 == Funcs().AmdgpuBoCpuMap(buf_handle, host_ptr)) {\n          allocs_.insert({ptr, {buf_handle, shared_handle}});\n        }\n        else {\n          hsa_amd_interop_unmap_buffer(ptr);\n          close(shared_handle);\n          Funcs().AmdgpuBoFree(buf_handle);\n        }\n      }\n      else {\n        close(shared_handle);\n        Funcs().AmdgpuBoFree(buf_handle);\n      }\n    }\n    else {\n      Funcs().AmdgpuBoFree(buf_handle);\n    }\n  }\n\n  return ptr;\n}\n\nvoid ProDevice::FreeDmaBuffer(void* ptr) const\n{\n  amd::ScopedLock l(alloc_ops_);\n  auto it = allocs_.find(ptr);\n  if (it != allocs_.end()) {\n    Funcs().AmdgpuBoCpuUnmap(it->second.first);\n    // Unmap memory from HSA device\n    hsa_amd_interop_unmap_buffer(ptr);\n    // Close shared handle\n    close(it->second.second);\n    int error = Funcs().AmdgpuBoFree(it->second.first);\n    allocs_.erase(it);\n  }\n}\n\n}\n\n#endif  // WITHOUT_HSA_BACKEND\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.9.0-neudjleb7hiztwlofocdddh3xyfxtn44/spack-src/os/os_posix.cpp": "/* Copyright (c) 2008-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#if !defined(_WIN32) && !defined(__CYGWIN__)\n\n#include \"os/os.hpp\"\n#include \"thread/thread.hpp\"\n#include \"utils/util.hpp\"\n\n#include <iostream>\n#include <stdarg.h>\n\n#include <sys/mman.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/sysinfo.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <dlfcn.h>\n#include <signal.h>\n\n#include <sys/prctl.h>\n\n#include <link.h>\n#include <time.h>\n#ifndef DT_GNU_HASH\n#define DT_GNU_HASH 0x6ffffef5\n#endif  // DT_GNU_HASH\n\n#include <atomic>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cstring>  // for strncmp\n#include <cstdlib>\n#include <cstdio>  // for tempnam\n#include <limits.h>\n#include <memory>\n#include <algorithm>\n#include <mutex>\n\n\nnamespace amd {\n\nstatic struct sigaction oldSigAction;\n\nstatic bool callOldSignalHandler(int sig, siginfo_t* info, void* ptr) {\n  if (oldSigAction.sa_handler == SIG_DFL) {\n    // no signal handler was previously installed.\n    return false;\n  } else if (oldSigAction.sa_handler != SIG_IGN) {\n    if ((oldSigAction.sa_flags & SA_NODEFER) == 0) {\n      sigaddset(&oldSigAction.sa_mask, sig);\n    }\n\n    void (*handler)(int) = oldSigAction.sa_handler;\n    if (oldSigAction.sa_flags & SA_RESETHAND) {\n      oldSigAction.sa_handler = SIG_DFL;\n    }\n\n    sigset_t savedSigSet;\n    pthread_sigmask(SIG_SETMASK, &oldSigAction.sa_mask, &savedSigSet);\n\n    if (oldSigAction.sa_flags & SA_SIGINFO) {\n      oldSigAction.sa_sigaction(sig, info, ptr);\n    } else {\n      handler(sig);\n    }\n\n    pthread_sigmask(SIG_SETMASK, &savedSigSet, NULL);\n  }\n\n  return true;\n}\n\nstatic void divisionErrorHandler(int sig, siginfo_t* info, void* ptr) {\n  assert(info != NULL && ptr != NULL && \"just checking\");\n  ucontext_t* uc = (ucontext_t*)ptr;\n  address insn;\n\n#if defined(ATI_ARCH_X86)\n  insn = (address)uc->uc_mcontext.gregs[LP64_SWITCH(REG_EIP, REG_RIP)];\n#else\n  assert(!\"Unimplemented\");\n#endif\n\n  if (Thread::current()->isWorkerThread()) {\n    if (Os::skipIDIV(insn)) {\n#if defined(ATI_ARCH_X86)\n      uc->uc_mcontext.gregs[LP64_SWITCH(REG_EIP, REG_RIP)] = (greg_t)insn;\n#else\n      assert(!\"Unimplemented\");\n#endif\n      return;\n    }\n  }\n\n  // Call the chained signal handler\n  if (callOldSignalHandler(sig, info, ptr)) {\n    return;\n  }\n\n\n  std::cerr << \"Unhandled signal in divisionErrorHandler()\" << std::endl;\n  ::abort();\n}\n\ntypedef int (*pthread_setaffinity_fn)(pthread_t, size_t, const cpu_set_t*);\nstatic pthread_setaffinity_fn pthread_setaffinity_fptr;\n\nstatic void init() __attribute__((constructor(101)));\nstatic void init() { Os::init(); }\n\nbool Os::installSigfpeHandler() {\n  // Install a SIGFPE signal handler @todo: Chain the handlers\n  struct sigaction sa;\n  sigfillset(&sa.sa_mask);\n  sa.sa_handler = SIG_DFL;\n  sa.sa_sigaction = divisionErrorHandler;\n  sa.sa_flags = SA_SIGINFO | SA_RESTART;\n\n  if (sigaction(SIGFPE, &sa, &oldSigAction) != 0) {\n    return false;\n  }\n  return true;\n}\n\nvoid Os::uninstallSigfpeHandler() {}\n\nbool Os::init() {\n  static bool initialized_ = false;\n\n  // We could use pthread_once here:\n  if (initialized_) {\n    return true;\n  }\n  initialized_ = true;\n\n  pageSize_ = (size_t)::sysconf(_SC_PAGESIZE);\n  processorCount_ = ::sysconf(_SC_NPROCESSORS_CONF);\n\n  pthread_setaffinity_fptr = (pthread_setaffinity_fn)dlsym(RTLD_NEXT, \"pthread_setaffinity_np\");\n\n  return Thread::init();\n}\n\nstatic void __exit() __attribute__((destructor(101)));\nstatic void __exit() { Os::tearDown(); }\n\nvoid Os::tearDown() { Thread::tearDown(); }\n\nvoid* Os::loadLibrary_(const char* filename) {\n  return (*filename == '\\0') ? NULL : ::dlopen(filename, RTLD_LAZY);\n}\n\nvoid Os::unloadLibrary(void* handle) { ::dlclose(handle); }\n\nvoid* Os::getSymbol(void* handle, const char* name) { return ::dlsym(handle, name); }\n\nstatic inline int memProtToOsProt(Os::MemProt prot) {\n  switch (prot) {\n    case Os::MEM_PROT_NONE:\n      return PROT_NONE;\n    case Os::MEM_PROT_READ:\n      return PROT_READ;\n    case Os::MEM_PROT_RW:\n      return PROT_READ | PROT_WRITE;\n    case Os::MEM_PROT_RWX:\n      return PROT_READ | PROT_WRITE | PROT_EXEC;\n    default:\n      break;\n  }\n  ShouldNotReachHere();\n  return -1;\n}\n\naddress Os::reserveMemory(address start, size_t size, size_t alignment, MemProt prot) {\n  size = alignUp(size, pageSize());\n  alignment = std::max(pageSize(), alignUp(alignment, pageSize()));\n  assert(isPowerOfTwo(alignment) && \"not a power of 2\");\n\n  size_t requested = size + alignment - pageSize();\n  address mem = (address)::mmap(start, requested, memProtToOsProt(prot),\n                                MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS, 0, 0);\n\n  // check for out of memory\n  if (mem == NULL) return NULL;\n\n  address aligned = alignUp(mem, alignment);\n\n  // return the unused leading pages to the free state\n  if (&aligned[0] != &mem[0]) {\n    assert(&aligned[0] > &mem[0] && \"check this code\");\n    if (::munmap(&mem[0], &aligned[0] - &mem[0]) != 0) {\n      assert(!\"::munmap failed\");\n    }\n  }\n  // return the unused trailing pages to the free state\n  if (&aligned[size] != &mem[requested]) {\n    assert(&aligned[size] < &mem[requested] && \"check this code\");\n    if (::munmap(&aligned[size], &mem[requested] - &aligned[size]) != 0) {\n      assert(!\"::munmap failed\");\n    }\n  }\n\n  return aligned;\n}\n\nbool Os::releaseMemory(void* addr, size_t size) {\n  assert(isMultipleOf(addr, pageSize()) && \"not page aligned!\");\n  size = alignUp(size, pageSize());\n\n  return 0 == ::munmap(addr, size);\n}\n\nbool Os::commitMemory(void* addr, size_t size, MemProt prot) {\n  assert(isMultipleOf(addr, pageSize()) && \"not page aligned!\");\n  size = alignUp(size, pageSize());\n\n  return ::mmap(addr, size, memProtToOsProt(prot), MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1,\n                0) != MAP_FAILED;\n}\n\nbool Os::uncommitMemory(void* addr, size_t size) {\n  assert(isMultipleOf(addr, pageSize()) && \"not page aligned!\");\n  size = alignUp(size, pageSize());\n\n  return ::mmap(addr, size, PROT_NONE, MAP_PRIVATE | MAP_FIXED | MAP_NORESERVE | MAP_ANONYMOUS, -1,\n                0) != MAP_FAILED;\n}\n\nbool Os::protectMemory(void* addr, size_t size, MemProt prot) {\n  assert(isMultipleOf(addr, pageSize()) && \"not page aligned!\");\n  size = alignUp(size, pageSize());\n\n  return 0 == ::mprotect(addr, size, memProtToOsProt(prot));\n}\n\nuint64_t Os::hostTotalPhysicalMemory() {\n  static uint64_t totalPhys = 0;\n\n  if (totalPhys != 0) {\n    return totalPhys;\n  }\n\n  totalPhys = sysconf(_SC_PAGESIZE) * sysconf(_SC_PHYS_PAGES);\n  return totalPhys;\n}\n\nvoid* Os::alignedMalloc(size_t size, size_t alignment) {\n  void* ptr = NULL;\n  if (0 == ::posix_memalign(&ptr, alignment, size)) {\n    return ptr;\n  }\n  return NULL;\n}\n\nvoid Os::alignedFree(void* mem) { ::free(mem); }\n\nvoid Os::currentStackInfo(address* base, size_t* size) {\n  // There could be some issue trying to get the pthread_attr of\n  // the primordial thread if the pthread library is not present\n  // at load time (a binary loads the OpenCL/HIP app/runtime dynamically.\n  // We should look into this... -laurent\n\n  pthread_t self = ::pthread_self();\n\n  pthread_attr_t threadAttr;\n  if (0 != ::pthread_getattr_np(self, &threadAttr)) {\n    fatal(\"pthread_getattr_np() failed\");\n  }\n\n  if (0 != ::pthread_attr_getstack(&threadAttr, (void**)base, size)) {\n    fatal(\"pthread_attr_getstack() failed\");\n  }\n  *base += *size;\n\n  ::pthread_attr_destroy(&threadAttr);\n\n  assert(Os::currentStackPtr() >= *base - *size && Os::currentStackPtr() < *base &&\n         \"just checking\");\n}\n\nvoid Os::setCurrentThreadName(const char* name) { ::prctl(PR_SET_NAME, name); }\n\n\nvoid* Thread::entry(Thread* thread) {\n  sigset_t set;\n\n  sigfillset(&set);\n  pthread_sigmask(SIG_BLOCK, &set, NULL);\n\n  sigemptyset(&set);\n  sigaddset(&set, SIGFPE);\n  pthread_sigmask(SIG_UNBLOCK, &set, NULL);\n\n  return thread->main();\n}\n\nbool Os::isThreadAlive(const Thread& thread) {\n  return ::pthread_kill((pthread_t)thread.handle(), 0) == 0;\n}\n\nstatic size_t tlsSize = 0;\n\n// Try to guess the size of TLS (plus some frames)\nvoid* guessTlsSizeThread(void* param) {\n  address stackBase;\n  address currentFrame;\n  size_t stackSize;\n  Os::currentStackInfo(&stackBase, &stackSize);\n  currentFrame = reinterpret_cast<address>(&stackSize);\n  tlsSize = stackBase - currentFrame;\n  // align up to page boundary\n  tlsSize = alignUp(tlsSize, amd::Os::pageSize());\n  return NULL;\n}\n\nstatic void guessTlsSize(void) {\n  int retval;\n  pthread_t handle;\n  pthread_attr_t threadAttr;\n\n  ::pthread_attr_init(&threadAttr);\n  retval = ::pthread_create(&handle, &threadAttr, guessTlsSizeThread, NULL);\n  if (retval == 0) {\n    pthread_join(handle, NULL);\n  } else {\n    fatal(\"pthread_create() failed with default stack size\");\n  }\n  ::pthread_attr_destroy(&threadAttr);\n}\n\nconst void* Os::createOsThread(amd::Thread* thread) {\n  pthread_attr_t threadAttr;\n  ::pthread_attr_init(&threadAttr);\n\n  if (thread->stackSize_ != 0) {\n    size_t guardsize = 0;\n    if (0 != ::pthread_attr_getguardsize(&threadAttr, &guardsize)) {\n      fatal(\"pthread_attr_getguardsize() failed\");\n    }\n\n    static std::once_flag initOnce;\n    std::call_once(initOnce, guessTlsSize);\n    ::pthread_attr_setstacksize(&threadAttr, thread->stackSize_ + guardsize + tlsSize);\n  }\n\n  // We never plan the use join, so free the resources now.\n  ::pthread_attr_setdetachstate(&threadAttr, PTHREAD_CREATE_DETACHED);\n  cpu_set_t cpuset;\n  if (processorCount_ > 0) {\n    CPU_ZERO(&cpuset);\n    for (int i = 0; i < processorCount_; i++) {\n      CPU_SET(i, &cpuset);\n    }\n    if (0 != pthread_attr_setaffinity_np(&threadAttr, sizeof(cpu_set_t), &cpuset)) {\n      fatal(\"pthread_attr_setaffinity_np failed to set affinity\");\n    }\n  }\n\n  pthread_t handle = 0;\n  if (0 != ::pthread_create(&handle, &threadAttr, (void* (*)(void*)) & Thread::entry, thread)) {\n    thread->setState(Thread::FAILED);\n  }\n\n  ::pthread_attr_destroy(&threadAttr);\n  return reinterpret_cast<const void*>(handle);\n}\n\n\nvoid Os::setThreadAffinity(const void* handle, const Os::ThreadAffinityMask& mask) {\n  if (pthread_setaffinity_fptr != NULL) {\n    pthread_setaffinity_fptr((pthread_t)handle, sizeof(cpu_set_t), &mask.mask_);\n  }\n}\n\nvoid Os::yield() { ::sched_yield(); }\n\nuint64_t Os::timeNanos() {\n  struct timespec tp;\n  ::clock_gettime(CLOCK_MONOTONIC, &tp);\n  return (uint64_t)tp.tv_sec * (1000ULL * 1000ULL * 1000ULL) + (uint64_t)tp.tv_nsec;\n}\n\nuint64_t Os::timerResolutionNanos() {\n  static uint64_t resolution = 0;\n  if (resolution == 0) {\n    struct timespec tp;\n    ::clock_getres(CLOCK_MONOTONIC, &tp);\n    resolution = (uint64_t)tp.tv_sec * (1000ULL * 1000ULL * 1000ULL) + (uint64_t)tp.tv_nsec;\n  }\n  return resolution;\n}\n\n\nconst char* Os::libraryExtension() { return MACOS_SWITCH(\".dylib\", \".so\"); }\n\nconst char* Os::libraryPrefix() { return \"lib\"; }\n\nconst char* Os::objectExtension() { return \".o\"; }\n\nchar Os::fileSeparator() { return '/'; }\n\nchar Os::pathSeparator() { return ':'; }\n\nbool Os::pathExists(const std::string& path) {\n  struct stat st;\n  if (stat(path.c_str(), &st) != 0) return false;\n  return S_ISDIR(st.st_mode);\n}\n\nbool Os::createPath(const std::string& path) {\n  mode_t mode = S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH;\n  size_t pos = 0;\n  while (true) {\n    pos = path.find(fileSeparator(), pos);\n    const std::string currPath = path.substr(0, pos);\n    if (!currPath.empty() && !pathExists(currPath)) {\n      int ret = mkdir(currPath.c_str(), mode);\n      if (ret == -1) return false;\n    }\n    if (pos == std::string::npos) break;\n    ++pos;\n  }\n  return true;\n}\n\nbool Os::removePath(const std::string& path) {\n  size_t pos = std::string::npos;\n  bool removed = false;\n  while (true) {\n    const std::string currPath = path.substr(0, pos);\n    if (!currPath.empty()) {\n      int ret = rmdir(currPath.c_str());\n      if (ret == -1) return removed;\n      removed = true;\n    }\n    if (pos == 0) break;\n    pos = path.rfind(fileSeparator(), pos == std::string::npos ? pos : pos - 1);\n    if (pos == std::string::npos) break;\n  }\n  return true;\n}\n\nint Os::printf(const char* fmt, ...) {\n  va_list ap;\n\n  va_start(ap, fmt);\n  int len = ::vprintf(fmt, ap);\n  va_end(ap);\n\n  return len;\n}\n\n// Os::systemCall()\n// ================\n// Execute a program and return the program exitcode or -1 if there were problems.\n// The input argument 'command' is expected to be a space separated string of\n// command-line arguments with arguments containing spaces between double-quotes.\n//\n// In order to avoid duplication of memory, we use vfork()+exec(). vfork() has\n// potiential security risks; read the following for details:\n//\n//     https://www.securecoding.cert.org/confluence/display/seccode/POS33-C.+Do+not+use+vfork()\n//\n// In spite of these risks, the alternatives (system() or fork()) create resource\n// issues when running conformance test_allocation which stretches the system\n// memory to its limits. Thus we will accept this compromise under the condition\n// that the runtime will soon remove any need to call out to external commands.\n//\n// Note that stdin/stdout/stderr of the command are sent to /dev/null.\n//\nint Os::systemCall(const std::string& command) {\n#if 1\n  size_t len = command.size();\n  char* cmd = new char[len + 1];\n  fastMemcpy(cmd, command.c_str(), len);\n  cmd[len] = 0;\n\n  // Split the command into arguments. This is a very\n  // simple parser that only takes care of quotes and\n  // doesn't support escaping with back-slash. In\n  // the future, Os::systemCall() will either\n  // disappear or it will be replaced with an\n  // argc/argv interface. This parser also assumes\n  // that if an argument is quoted, the whole\n  // argument starts and ends with a double-quote.\n  bool inQuote = false;\n  int argLength = 0;\n  int n = 0;\n  char* cp = cmd;\n  while (*cp) {\n    switch (static_cast<int>(*cp)) {\n      case ' ':\n        if (inQuote) {\n          ++argLength;\n        } else {\n          *cp = '\\0';\n          argLength = 0;\n        }\n        break;\n      case '\"':\n        if (inQuote) {\n          inQuote = false;\n          *cp = '\\0';\n        } else {\n          inQuote = true;\n          *cp = '\\0';\n          argLength = 1;\n          ++n;\n        }\n        break;\n      default:\n        if (++argLength == 1) {\n          ++n;\n        }\n        break;\n    }\n    ++cp;\n  }\n\n  char** argv = new char*[n + 1];\n  int argc = 0;\n  cp = cmd;\n  do {\n    while ('\\0' == *cp) {\n      ++cp;\n    }\n    argv[argc++] = cp;\n    while ('\\0' != *cp) {\n      ++cp;\n    }\n  } while (argc < n);\n  argv[argc] = NULL;\n\n  int ret = -1;\n  pid_t pid = vfork();\n  if (0 == pid) {\n    // Child. Redirect stdin/stdout/stderr to /dev/null\n    int fdIn = open(\"/dev/null\", O_RDONLY);\n    int fdOut = open(\"/dev/null\", O_WRONLY);\n    if (0 <= fdIn || 0 <= fdOut) {\n      dup2(fdIn, 0);\n      dup2(fdOut, 1);\n      dup2(fdOut, 2);\n\n      // Execute the program\n      execvp(argv[0], argv);\n    }\n    _exit(-1);\n  } else if (0 > pid) {\n    // Can't vfork\n  } else {\n    // Parent - wait for program to complete and get exit code.\n    int exitCode;\n    if (0 <= waitpid(pid, &exitCode, 0)) {\n      ret = exitCode;\n    }\n  }\n  delete[] argv;\n  delete[] cmd;\n\n  return ret;\n#else\n  return ::system(command.c_str());\n#endif\n}\n\nstd::string Os::getEnvironment(const std::string& name) {\n  char* dstBuf;\n\n  dstBuf = ::getenv(name.c_str());\n  if (dstBuf == NULL) {\n    return std::string(\"\");\n  }\n  return std::string(dstBuf);\n}\n\nstd::string Os::getTempPath() {\n  std::string tempFolder = amd::Os::getEnvironment(\"TEMP\");\n  if (tempFolder.empty()) {\n    tempFolder = amd::Os::getEnvironment(\"TMP\");\n  }\n\n  if (tempFolder.empty()) {\n    tempFolder = \"/tmp\";\n    ;\n  }\n  return tempFolder;\n}\n\nstd::string Os::getTempFileName() {\n  static std::atomic_size_t counter(0);\n\n  std::string tempPath = getTempPath();\n  std::stringstream tempFileName;\n\n  tempFileName << tempPath << \"/OCL\" << ::getpid() << 'T' << counter++;\n  return tempFileName.str();\n}\n\nint Os::unlink(const std::string& path) { return ::unlink(path.c_str()); }\n\n#if defined(ATI_ARCH_X86)\nvoid Os::cpuid(int regs[4], int info) {\n#ifdef _LP64\n  __asm__ __volatile__(\n      \"movq %%rbx, %%rsi;\"\n      \"cpuid;\"\n      \"xchgq %%rbx, %%rsi;\"\n      : \"=a\"(regs[0]), \"=S\"(regs[1]), \"=c\"(regs[2]), \"=d\"(regs[3])\n      : \"a\"(info));\n#else\n  __asm__ __volatile__(\n      \"movl %%ebx, %%esi;\"\n      \"cpuid;\"\n      \"xchgl %%ebx, %%esi;\"\n      : \"=a\"(regs[0]), \"=S\"(regs[1]), \"=c\"(regs[2]), \"=d\"(regs[3])\n      : \"a\"(info));\n#endif\n}\n\nuint64_t Os::xgetbv(uint32_t ecx) {\n  uint32_t eax, edx;\n\n  __asm__ __volatile__(\".byte 0x0f,0x01,0xd0\"  // in case assembler doesn't recognize xgetbv\n                       : \"=a\"(eax), \"=d\"(edx)\n                       : \"c\"(ecx));\n\n  return ((uint64_t)edx << 32) | (uint64_t)eax;\n}\n#endif  // ATI_ARCH_X86\n\nvoid* Os::fastMemcpy(void* dest, const void* src, size_t n) { return memcpy(dest, src, n); }\n\nuint64_t Os::offsetToEpochNanos() {\n  static uint64_t offset = 0;\n\n  if (offset != 0) {\n    return offset;\n  }\n\n  struct timeval now;\n  if (::gettimeofday(&now, NULL) != 0) {\n    return 0;\n  }\n\n  offset = (now.tv_sec * UINT64_C(1000000) + now.tv_usec) * UINT64_C(1000) - timeNanos();\n\n  return offset;\n}\n\nvoid Os::setCurrentStackPtr(address sp) {\n  sp -= sizeof(void*);\n  *(void**)sp = __builtin_return_address(0);\n\n#if defined(ATI_ARCH_ARM)\n  assert(!\"Unimplemented\");\n#else\n  __asm__ __volatile__(\n#if !defined(OMIT_FRAME_POINTER)\n      LP64_SWITCH(\"movl (%%ebp),%%ebp;\", \"movq (%%rbp),%%rbp;\")\n#endif  // !OMIT_FRAME_POINTER\n          LP64_SWITCH(\"movl %0,%%esp; ret;\", \"movq %0,%%rsp; ret;\")::\"r\"(sp));\n#endif\n}\n\nsize_t Os::getPhysicalMemSize() {\n  struct ::sysinfo si;\n\n  if (::sysinfo(&si) != 0) {\n    return 0;\n  }\n\n  if (si.mem_unit == 0) {\n    // Linux kernels prior to 2.3.23 return sizes in bytes.\n    si.mem_unit = 1;\n  }\n\n  return (size_t)si.totalram * si.mem_unit;\n}\n\nvoid Os::getAppPathAndFileName(std::string& appName, std::string& appPathAndName) {\n  std::unique_ptr<char[]> buff(new char[FILE_PATH_MAX_LENGTH]());\n\n  if (readlink(\"/proc/self/exe\", buff.get(), FILE_PATH_MAX_LENGTH) > 0) {\n    // Get filename without path and extension.\n    appName = std::string(basename(buff.get()));\n    appPathAndName = std::string(buff.get());\n  }\n  else {\n    appName = \"\";\n    appPathAndName = \"\";\n  }\n  return;\n}\n\n\nbool Os::GetURIFromMemory(const void* image, size_t image_size, std::string& uri) {\n  pid_t pid = getpid();\n  std::ostringstream uri_stream;\n  //Create a unique resource indicator to the memory address\n  uri_stream << \"memory://\" << pid\n             << \"#offset=0x\" << std::hex << (uintptr_t)image << std::dec\n             << \"&size=\" << image_size;\n  uri = uri_stream.str();\n  return true;\n}\n\nbool Os::CloseFileHandle(FileDesc fdesc) {\n  // Return false if close system call fails\n  if(close(fdesc) < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nbool Os::GetFileHandle(const char* fname, FileDesc* fd_ptr, size_t* sz_ptr) {\n  if ((fd_ptr == nullptr) || (sz_ptr == nullptr)) {\n    return false;\n  }\n\n  // open system function call, return false on fail\n  struct stat stat_buf;\n  *fd_ptr = open(fname, O_RDONLY);\n  if (*fd_ptr < 0) {\n    return false;\n  }\n\n  //Retrieve stat info and size\n  if (fstat(*fd_ptr, &stat_buf) != 0) {\n    close(*fd_ptr);\n    return false;\n  }\n\n  *sz_ptr = stat_buf.st_size;\n\n  return true;\n}\n\nbool Os::MemoryMapFileDesc(FileDesc fdesc, size_t fsize, size_t foffset, const void** mmap_ptr) {\n  if (fdesc <= 0) {\n    return false;\n  }\n\n  // If the offset is not aligned then align it\n  // and recalculate the new size\n  if (foffset > 0) {\n    size_t old_foffset = foffset;\n    foffset = alignUp(foffset, pageSize());\n    fsize += (foffset - old_foffset);\n  }\n\n  *mmap_ptr = mmap(NULL, fsize, PROT_READ, MAP_SHARED, fdesc, foffset);\n  return true;\n}\n\nbool Os::MemoryUnmapFile(const void* mmap_ptr, size_t mmap_size) {\n  if (munmap(const_cast<void*>(mmap_ptr), mmap_size) != 0) {\n    return false;\n  }\n\n  return true;\n}\n\nbool Os::MemoryMapFile(const char* fname, const void** mmap_ptr, size_t* mmap_size) {\n  if ((mmap_ptr == nullptr) || (mmap_size == nullptr)) {\n    return false;\n  }\n\n  struct stat stat_buf;\n  int fd = open(fname, O_RDONLY);\n  if (fd < 0 ) {\n    return false;\n  }\n\n  if (fstat(fd, &stat_buf) != 0) {\n    close(fd);\n    return false;\n  }\n\n  *mmap_size = stat_buf.st_size;\n  *mmap_ptr = mmap(NULL, stat_buf.st_size, PROT_READ, MAP_SHARED, fd, 0);\n\n  close(fd);\n\n  if (*mmap_ptr == nullptr) {\n    return false;\n  }\n\n  return true;\n}\n\n}  // namespace amd\n\n#endif  // !defined(_WIN32) && !defined(__CYGWIN__)\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.9.0-neudjleb7hiztwlofocdddh3xyfxtn44/spack-src/opencl-on-vdi/amdocl/cl_icd.cpp": "/* Copyright (c) 2008-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#include \"cl_common.hpp\"\n#include \"vdi_common.hpp\"\n#ifdef _WIN32\n#include <d3d10_1.h>\n#include \"cl_d3d9_amd.hpp\"\n#include \"cl_d3d10_amd.hpp\"\n#include \"cl_d3d11_amd.hpp\"\n#endif  //_WIN32\n\n#include <icd/loader/icd_dispatch.h>\n\n#include <mutex>\n\namd::PlatformIDS amd::PlatformID::Platform =  //{ NULL };\n    {amd::ICDDispatchedObject::icdVendorDispatch_};\n\nstatic cl_int CL_API_CALL icdGetPlatformInfo(cl_platform_id platform, cl_platform_info param_name,\n                                             size_t param_value_size, void* param_value,\n                                             size_t* param_value_size_ret) {\n  return clGetPlatformInfo(NULL, param_name, param_value_size, param_value, param_value_size_ret);\n}\n\nstatic cl_int CL_API_CALL icdGetDeviceIDs(cl_platform_id platform, cl_device_type device_type,\n                                          cl_uint num_entries, cl_device_id* devices,\n                                          cl_uint* num_devices) {\n  return clGetDeviceIDs(NULL, device_type, num_entries, devices, num_devices);\n}\n\nstatic cl_int CL_API_CALL icdGetDeviceInfo(cl_device_id device, cl_device_info param_name,\n                                           size_t param_value_size, void* param_value,\n                                           size_t* param_value_size_ret) {\n  if (param_name == CL_DEVICE_PLATFORM) {\n    // Return the ICD platform instead of the default NULL platform.\n    cl_platform_id platform = reinterpret_cast<cl_platform_id>(&amd::PlatformID::Platform);\n    return amd::clGetInfo(platform, param_value_size, param_value, param_value_size_ret);\n  }\n\n  return clGetDeviceInfo(device, param_name, param_value_size, param_value, param_value_size_ret);\n}\n\ncl_icd_dispatch amd::ICDDispatchedObject::icdVendorDispatch_[] = {\n    {NULL /* should not get called */, icdGetPlatformInfo, icdGetDeviceIDs, icdGetDeviceInfo,\n     clCreateContext, clCreateContextFromType, clRetainContext, clReleaseContext, clGetContextInfo,\n     clCreateCommandQueue, clRetainCommandQueue, clReleaseCommandQueue, clGetCommandQueueInfo,\n     clSetCommandQueueProperty, clCreateBuffer, clCreateImage2D, clCreateImage3D, clRetainMemObject,\n     clReleaseMemObject, clGetSupportedImageFormats, clGetMemObjectInfo, clGetImageInfo,\n     clCreateSampler, clRetainSampler, clReleaseSampler, clGetSamplerInfo,\n     clCreateProgramWithSource, clCreateProgramWithBinary, clRetainProgram, clReleaseProgram,\n     clBuildProgram, clUnloadCompiler, clGetProgramInfo, clGetProgramBuildInfo, clCreateKernel,\n     clCreateKernelsInProgram, clRetainKernel, clReleaseKernel, clSetKernelArg, clGetKernelInfo,\n     clGetKernelWorkGroupInfo, clWaitForEvents, clGetEventInfo, clRetainEvent, clReleaseEvent,\n     clGetEventProfilingInfo, clFlush, clFinish, clEnqueueReadBuffer, clEnqueueWriteBuffer,\n     clEnqueueCopyBuffer, clEnqueueReadImage, clEnqueueWriteImage, clEnqueueCopyImage,\n     clEnqueueCopyImageToBuffer, clEnqueueCopyBufferToImage, clEnqueueMapBuffer, clEnqueueMapImage,\n     clEnqueueUnmapMemObject, clEnqueueNDRangeKernel, clEnqueueTask, clEnqueueNativeKernel,\n     clEnqueueMarker, clEnqueueWaitForEvents, clEnqueueBarrier, clGetExtensionFunctionAddress,\n     clCreateFromGLBuffer, clCreateFromGLTexture2D, clCreateFromGLTexture3D,\n     clCreateFromGLRenderbuffer, clGetGLObjectInfo, clGetGLTextureInfo, clEnqueueAcquireGLObjects,\n     clEnqueueReleaseGLObjects, clGetGLContextInfoKHR,\n     WINDOWS_SWITCH(clGetDeviceIDsFromD3D10KHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10BufferKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10Texture2DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10Texture3DKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueAcquireD3D10ObjectsKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueReleaseD3D10ObjectsKHR, NULL), clSetEventCallback, clCreateSubBuffer,\n     clSetMemObjectDestructorCallback, clCreateUserEvent, clSetUserEventStatus,\n     clEnqueueReadBufferRect, clEnqueueWriteBufferRect, clEnqueueCopyBufferRect,\n     NULL, NULL, NULL, clCreateEventFromGLsyncKHR,\n\n     /* OpenCL 1.2*/\n     clCreateSubDevices, clRetainDevice, clReleaseDevice, clCreateImage,\n     clCreateProgramWithBuiltInKernels, clCompileProgram, clLinkProgram, clUnloadPlatformCompiler,\n     clGetKernelArgInfo, clEnqueueFillBuffer, clEnqueueFillImage, clEnqueueMigrateMemObjects,\n     clEnqueueMarkerWithWaitList, clEnqueueBarrierWithWaitList,\n     clGetExtensionFunctionAddressForPlatform, clCreateFromGLTexture,\n\n     WINDOWS_SWITCH(clGetDeviceIDsFromD3D11KHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11BufferKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11Texture2DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11Texture3DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromDX9MediaSurfaceKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueAcquireD3D11ObjectsKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueReleaseD3D11ObjectsKHR, NULL),\n\n     WINDOWS_SWITCH(clGetDeviceIDsFromDX9MediaAdapterKHR,\n                    NULL),  // KHRpfn_clGetDeviceIDsFromDX9MediaAdapterKHR\n                            // clGetDeviceIDsFromDX9MediaAdapterKHR;\n     WINDOWS_SWITCH(\n         clEnqueueAcquireDX9MediaSurfacesKHR,\n         NULL),  // KHRpfn_clEnqueueAcquireDX9MediaSurfacesKHR clEnqueueAcquireDX9MediaSurfacesKHR;\n     WINDOWS_SWITCH(\n         clEnqueueReleaseDX9MediaSurfacesKHR,\n         NULL),  // KHRpfn_clEnqueueReleaseDX9MediaSurfacesKHR clEnqueueReleaseDX9MediaSurfacesKHR;\n\n     NULL,\n     NULL, NULL, NULL,\n\n     clCreateCommandQueueWithProperties, clCreatePipe, clGetPipeInfo, clSVMAlloc, clSVMFree,\n     clEnqueueSVMFree, clEnqueueSVMMemcpy, clEnqueueSVMMemFill, clEnqueueSVMMap, clEnqueueSVMUnmap,\n     clCreateSamplerWithProperties, clSetKernelArgSVMPointer, clSetKernelExecInfo,\n     clGetKernelSubGroupInfo,\n     clCloneKernel,\n     clCreateProgramWithIL,\n     clEnqueueSVMMigrateMem,\n     clGetDeviceAndHostTimer,\n     clGetHostTimer,\n     clGetKernelSubGroupInfo,\n     clSetDefaultDeviceCommandQueue,\n\n     clSetProgramReleaseCallback,\n     clSetProgramSpecializationConstant }};\n\n#if defined(ATI_OS_WIN)\n#include <Shlwapi.h>\n\n#pragma comment(lib, \"shlwapi.lib\")\n\nstatic bool ShouldLoadPlatform() {\n  // Get the OpenCL ICD registry values\n  HKEY platformsKey = NULL;\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Khronos\\\\OpenCL\\\\Vendors\", 0, KEY_READ,\n                    &platformsKey) != ERROR_SUCCESS)\n    return true;\n\n  std::vector<std::string> registryValues;\n  DWORD dwIndex = 0;\n  while (true) {\n    char cszLibraryName[1024] = {0};\n    DWORD dwLibraryNameSize = sizeof(cszLibraryName);\n    DWORD dwLibraryNameType = 0;\n    DWORD dwValue = 0;\n    DWORD dwValueSize = sizeof(dwValue);\n\n    if (RegEnumValueA(platformsKey, dwIndex++, cszLibraryName, &dwLibraryNameSize, NULL,\n                      &dwLibraryNameType, (LPBYTE)&dwValue, &dwValueSize) != ERROR_SUCCESS)\n      break;\n    // Require that the value be a DWORD and equal zero\n    if (dwLibraryNameType != REG_DWORD || dwValue != 0) {\n      continue;\n    }\n    registryValues.push_back(cszLibraryName);\n  }\n  RegCloseKey(platformsKey);\n\n  HMODULE hm = NULL;\n  if (!GetModuleHandleExA(\n          GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n          (LPCSTR)&ShouldLoadPlatform, &hm))\n    return true;\n\n  char cszDllPath[1024] = {0};\n  if (!GetModuleFileNameA(hm, cszDllPath, sizeof(cszDllPath))) return true;\n\n  // If we are loaded from the DriverStore, then there should be a registry\n  // value matching our current module absolute path.\n  if (std::find(registryValues.begin(), registryValues.end(), cszDllPath) == registryValues.end())\n    return true;\n\n  LPSTR cszFileName;\n  char buffer[1024] = {0};\n  if (!GetFullPathNameA(cszDllPath, sizeof(buffer), buffer, &cszFileName)) return true;\n\n  // We found an absolute path in the registry that matched this DLL, now\n  // check if there is also an entry with the same filename.\n  if (std::find(registryValues.begin(), registryValues.end(), cszFileName) == registryValues.end())\n    return true;\n\n  // Lastly, check if there is a DLL with the same name in the System folder.\n  char cszSystemPath[1024] = {0};\n#if defined(ATI_BITS_32)\n  if (!GetSystemWow64DirectoryA(cszSystemPath, sizeof(cszSystemPath)))\n#endif  // defined(ATI_BITS_32)\n    if (!GetSystemDirectoryA(cszSystemPath, sizeof(cszSystemPath))) return true;\n\n  std::string systemDllPath;\n  systemDllPath.append(cszSystemPath).append(\"\\\\\").append(cszFileName);\n  if (!PathFileExistsA(systemDllPath.c_str())) {\n    return true;\n  }\n\n  // If we get here, then all 3 conditions are true:\n  // - An entry in the registry with an absolute path matches the current DLL\n  // - An entry in the registry with a relative path matches the current DLL\n  // - A DLL with the same name was found in the system directory\n  //\n  // We should not load this platform!\n\n  return false;\n}\n\n#else\n\n#include <dlfcn.h>\n\n// If there is only one platform, load it.\n// If there is more than one platform, only load platforms that have visible devices\n// If all platforms have no devices available, only load the PAL platform\nstatic bool ShouldLoadPlatform() {\n  bool shouldLoad = true;\n\n  if (!amd::Runtime::initialized()) {\n    amd::Runtime::init();\n  }\n  const int numDevices = amd::Device::numDevices(CL_DEVICE_TYPE_GPU, false);\n\n  void *otherPlatform = nullptr;\n  if (amd::IS_LEGACY) {\n    otherPlatform = dlopen(\"libamdocl64.so\", RTLD_LAZY);\n    if (otherPlatform != nullptr) { // Present platform exists\n      shouldLoad = numDevices > 0;\n    }\n  } else {\n    otherPlatform = dlopen(\"libamdocl-orca64.so\", RTLD_LAZY);\n    if (otherPlatform != nullptr) { // Legacy platform exists\n      // gcc4.8 doesn't support casting void* to a function pointer\n      // Work around this by creating a typedef untill we upgrade the compiler\n      typedef void*(*clGetFunctionAddress_t)(const char *);\n      typedef cl_int(*clIcdGetPlatformIDs_t)(cl_uint, cl_platform_id *, cl_uint *);\n\n      clGetFunctionAddress_t legacyGetFunctionAddress =\n        reinterpret_cast<clGetFunctionAddress_t>(dlsym(otherPlatform, \"clGetExtensionFunctionAddress\"));\n      clIcdGetPlatformIDs_t legacyGetPlatformIDs =\n        reinterpret_cast<clIcdGetPlatformIDs_t>(legacyGetFunctionAddress(\"clIcdGetPlatformIDsKHR\"));\n\n      cl_uint numLegacyPlatforms = 0;\n      legacyGetPlatformIDs(0, nullptr, &numLegacyPlatforms);\n\n      shouldLoad = (numDevices > 0) || (numLegacyPlatforms == 0);\n    }\n  }\n\n  if (otherPlatform != nullptr) {\n    dlclose(otherPlatform);\n  }\n\n  return shouldLoad;\n}\n\n#endif // defined(ATI_OS_WIN)\n\nCL_API_ENTRY cl_int CL_API_CALL clIcdGetPlatformIDsKHR(cl_uint num_entries,\n                                                       cl_platform_id* platforms,\n                                                       cl_uint* num_platforms) {\n  if (((num_entries > 0 || num_platforms == NULL) && platforms == NULL) ||\n      (num_entries == 0 && platforms != NULL)) {\n    return CL_INVALID_VALUE;\n  }\n\n  static bool shouldLoad = true;\n\n  static std::once_flag initOnce;\n  std::call_once(initOnce, [](){ shouldLoad = ShouldLoadPlatform(); });\n\n  if (!shouldLoad) {\n    *not_null(num_platforms) = 0;\n    return CL_SUCCESS;\n  }\n\n  if (!amd::Runtime::initialized()) {\n    amd::Runtime::init();\n  }\n\n  if (num_platforms != NULL && platforms == NULL) {\n    *num_platforms = 1;\n    return CL_SUCCESS;\n  }\n\n  assert(platforms != NULL && \"check the code above\");\n  *platforms = reinterpret_cast<cl_platform_id>(&amd::PlatformID::Platform);\n\n  *not_null(num_platforms) = 1;\n  return CL_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.9.0-neudjleb7hiztwlofocdddh3xyfxtn44/spack-src/opencl-on-vdi/tests/ocltst/env/ocltst.cpp": "/* Copyright (c) 2010-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n/////////////////////////////////////////////////////////////////////////////\n\n#include <CL/cl.h>\n\n#ifdef ATI_OS_WIN\n#include <windows.h>\n\n#include \"Window.h\"\ntypedef HMODULE ModuleHandle;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n\n#ifdef ATI_OS_LINUX\n#include <dlfcn.h>\ntypedef void* ModuleHandle;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n\n#include \"BaseTestImp.h\"\n#include \"Module.h\"\n#include \"OCLLog.h\"\n#include \"OCLTest.h\"\n#include \"OCLTestImp.h\"\n#include \"OCLTestList.h\"\n#include \"OCLWrapper.h\"\n#include \"Timer.h\"\n#include \"Worker.h\"\n#include \"getopt.h\"\n#include \"oclsysinfo.h\"\n#include \"pfm.h\"\n\n//! Including OCLutilities Thread utility\n#include \"OCL/Thread.h\"\n\n//! Lock that needs to be obtained to access the global\n//! module variable\nstatic OCLutil::Lock moduleLock;\n\n#include <assert.h>\n#include <stdio.h>\n\n#include <algorithm>\n#include <memory>\n#include <string>\n#include <vector>\n\n/////////////////////////////////////////////////////////////////////////////\n\n#ifdef ATI_OS_WIN\nstatic LONG WINAPI xFilter(LPEXCEPTION_POINTERS xEP);\nvoid serviceStubCall();\n#endif\n\n#define MAX_DEVICES 16\n#undef CHECK_RESULT\n#define CHECK_RESULT(test, msg) \\\n  if ((test)) {                 \\\n    printf(\"\\n%s\\n\", msg);      \\\n    exit(1);                    \\\n  }\n\n//! Declaration of a function that find devices of a specific type for the\n//! chosen platform\nint findAdapters(unsigned int platformIdx, bool useCPU, cl_platform_id*);\n\n//! class App that is used to run the tests on the system\nclass App {\n public:\n  static bool m_reRunFailed;\n  static bool m_svcMsg;\n  //! Constructor for App\n  App(unsigned int platform)\n      : m_list(false),\n        m_console(true),\n        m_useCPU(false),\n        m_dump(false),\n        m_perflab(false),\n        m_noSysInfoPrint(false),\n        m_numItr(1),\n        mp_testOrder(NULL),\n        m_rndOrder(false),\n        m_spawned(0),\n        m_threads(1),\n        m_runthread(0),\n        m_width(512),\n        m_height(512),\n        m_window(0),\n        m_platform(platform) {\n    // initialize OCLWrapper reference\n    m_wrapper = new OCLWrapper();\n\n    // m_workers = Set of worker objects that are used to run a subtest from a\n    // module\n    for (unsigned int i = 0; i < 256; i++) m_workers[i] = 0;\n\n    // Setting the number of devices\n    /*\n     * Force caltst to use 1 thread at a time in Windows\n     * only contextual calls are thread safe currently\n     */\n    m_numDevices = findAdapters(m_platform, m_useCPU, NULL);\n    // m_numDevices = 1;\n\n    // Report structure used to store the results of the tests\n#if 0\n            testReport = (Report **)malloc(sizeof(Report *) * m_numDevices);\n            for(unsigned int i = 0; i < m_numDevices; i++)\n            {\n                testReport[i] = new Report;\n            }\n#else\n    testReport = (Report**)malloc(sizeof(Report*));\n    testReport[0] = new Report;\n#endif\n  }\n\n  //! Destructor for App\n  ~App() {\n    // Deleting the Worker objects\n    for (unsigned int i = 0; i < 256; i++) {\n      if (m_workers[i]) {\n        delete m_workers[i];\n        m_workers[i] = 0;\n      }\n    }\n\n    // Deleting the report structures\n    // for(unsigned int i = 0; i < m_numDevices; i++)\n    for (unsigned int i = 0; i < 1; i++) {\n      delete testReport[i];\n    }\n    free(testReport);\n    m_wrapper->clUnloadPlatformAMD(mpform_id);\n\n    delete m_wrapper;\n  }\n\n  //! Function used to create a worker object corresponding to a subtest in a\n  //! module\n  void SetWorker(unsigned int index, OCLWrapper* wrapper, Module* module,\n                 TestMethod run, unsigned int id, unsigned int subtest,\n                 unsigned int test, bool dump, bool view, bool useCPU,\n                 void* window, unsigned int x, unsigned int y, bool perflab,\n                 unsigned int deviceId, unsigned int platform) {\n    if (index >= 256) return;\n\n    if (m_workers[index]) delete m_workers[index];\n\n    m_workers[index] =\n        new Worker(wrapper, module, run, id, subtest, test, dump, view, useCPU,\n                   window, x, y, perflab, deviceId, platform);\n\n    assert(m_workers[index] != 0);\n    // oclTestLog(OCLTEST_LOG_ALWAYS, \"Worker Device Id = %d\\n\",\n    // m_workers[index]->getDeviceId());\n  }\n\n  //! Function to return the 'index'th m_workers\n  Worker* GetWorker(unsigned int index) {\n    if (index >= 256) return 0;\n\n    return m_workers[index];\n  }\n\n  //! Create a thread to run the subtest\n  void AddThread(unsigned int workerindex, unsigned int usage) {\n    Worker* worker = GetWorker(workerindex);\n    if (worker == 0) {\n      return;\n    }\n\n    // usage = Whether to use threads or not\n    if (usage != 0) {\n      // Creating a thread\n      // getTestMethod = runSubTest here\n      // which takes a Worker object as an argument\n      m_pool[workerindex].create(worker->getTestMethod(), (void*)(worker));\n      m_spawned++;\n    } else {\n      // Same as above without using threads\n      TestMethod run = worker->getTestMethod();\n      if (run) {\n        run(worker);\n        UpdateTestReport(workerindex, worker->getResult());\n      }\n    }\n    return;\n  }\n\n  //! Function which waits for all threads to execute and also updates the\n  //! report\n  void WaitAllThreads() {\n    for (unsigned int w = 0; w < m_spawned; w++) {\n      m_pool[w].join();\n      UpdateTestReport(w, m_workers[w]->getResult());\n    }\n    m_spawned = 0;\n  }\n\n  //! Function to add a worker thread so as to run a subtest of a module\n  //! @param run = runSubtest function\n  //! @param index = index of the module in m_modules\n  //! @param subtest = the subtest number to run\n  //! @param usage = whether to use threads or not\n  //! @param test = The test in the module to be executed\n  void AddWorkerThread(unsigned int index, unsigned int subtest,\n                       unsigned int test, unsigned int usage, TestMethod run) {\n    if (m_spawned > m_threads) {\n      WaitAllThreads();\n    }\n\n    // Creating a worker thread for each device\n#if 0\n            for(unsigned int i = 0; i < m_numDevices; i++)\n            {\n                SetWorker(i,\n                          m_wrapper,\n                          &m_modules[index],\n                          run,\n                          m_spawned,\n                          subtest,\n                          test,\n                          m_dump,\n                          !m_console,\n                          m_useCPU,\n                          m_window,\n                          m_width,\n                          m_height,\n                          m_perflab,\n                          i,\n                          m_platform);            \n            }\n#else\n    for (unsigned int i = 0; i < 1; i++) {\n      SetWorker(i, m_wrapper, &m_modules[index], run, m_spawned, subtest, test,\n                m_dump, !m_console, m_useCPU, m_window, m_width, m_height,\n                m_perflab, m_deviceId, m_platform);\n    }\n#endif\n\n    // Creating and executing a thread for each device\n    // for(unsigned int i = 0; i < m_numDevices; i++)\n    for (unsigned int i = 0; i < 1; i++) {\n      AddThread(i, usage);\n    }\n  }\n\n  void printOCLinfo(void);\n\n  //! Function to process the commandline arguments\n  void CommandLine(unsigned int argc, char** argv);\n\n  //! Function to scan for the different tests in the module\n  void ScanForTests();\n\n  //! Function to run all the specified tests\n  void RunAllTests();\n\n  //! Free memory\n  void CleanUp();\n\n  //! Function to set the order in which test are executed.\n  void SetTestRunOrder(int);\n\n  //! Function to print the test order\n  void PrintTestOrder(int);\n\n  //! Function to get the number of iterations.\n  int GetNumItr(void) { return m_numItr; }\n\n private:\n  typedef std::vector<unsigned int> TestIndexList;\n  typedef std::vector<std::string> StringList;\n\n  void AddToList(StringList& strlist, const char* str);\n  void LoadList(StringList& strlist, const char* filename);\n\n  bool TestInList(StringList& strlist, const char* testname);\n\n  //! Array storing the report for each device\n  Report** testReport;\n\n  //! Function to update the result of each device\n  void UpdateTestReport(int index, TestResult* result) {\n    if (result != NULL) {\n      if (result->passed) {\n        if (testReport[index]->max->value < result->value) {\n          testReport[index]->max->value = result->value;\n          testReport[index]->max->resultString = result->resultString;\n        }\n        if (testReport[index]->min->value > result->value) {\n          testReport[index]->min->value = result->value;\n          testReport[index]->min->resultString = result->resultString;\n        }\n      } else {\n        testReport[index]->numFailedTests++;\n        testReport[index]->success = false;\n      }\n    } else {\n      testReport[index]->numFailedTests++;\n      testReport[index]->success = false;\n    }\n  }\n\n  //! Functions used to find the range of the tests to be run\n  void GetTestIndexList(TestIndexList& testIndices, StringList& testList,\n                        const char* szModuleTestname, int maxIndex);\n  void PruneTestIndexList(TestIndexList& testIndices,\n                          TestIndexList& avoidIndices,\n                          TestIndexList& erasedIndices);\n\n  StringList m_paths;\n  StringList m_tests;\n  StringList m_avoid;\n  std::vector<Module> m_modules;\n  bool m_list;\n  bool m_console;\n  bool m_useCPU;\n  bool m_dump;\n  bool m_perflab;\n  bool m_noSysInfoPrint;\n  int m_numItr;\n  int* mp_testOrder;\n  bool m_rndOrder;\n\n  //! m_pool = Various threads created to execute tests on multiple devices\n  OCLutil::Thread m_pool[256];\n\n  Worker* m_workers[256];\n\n  //! Number of threads spawned\n  unsigned int m_spawned;\n\n  //! Upper limit on the number of threads that can be spawned\n  unsigned int m_threads;\n  unsigned int m_runthread;\n  unsigned int m_width;\n  unsigned int m_height;\n  void* m_window;\n\n  //! which index/platform id from the platforms vector returned by\n  //! cl::Platform::get we should run on\n  unsigned int m_platform;\n  cl_platform_id mpform_id;\n\n  //! Number of devices on the system\n  unsigned int m_numDevices;\n  //\n  //! Device ID to use on the system\n  unsigned int m_deviceId;\n\n  // OCLWrapper reference\n  OCLWrapper* m_wrapper;\n};\n\nvoid App::printOCLinfo(void) {\n  std::string calinfo;\n  if (!m_noSysInfoPrint) {\n    oclSysInfo(calinfo, m_useCPU, m_deviceId, m_platform);\n    oclTestLog(OCLTEST_LOG_ALWAYS, calinfo.c_str());\n  }\n}\n\n/*-----------------------------------------------------\nFunction to randomize the order in which tests are executed\n-------------------------------------------------------*/\n#ifdef ATI_OS_WIN\n#include <time.h>\n#endif\n// void App::SetTestRunOrder(int test_count)\nvoid App::SetTestRunOrder(int mod_index) {\n  assert(mp_testOrder != NULL);\n  unsigned int test_count = m_modules[mod_index].get_count();\n\n  StringList uniqueTests;\n  for (unsigned int i = 0; i < m_tests.size(); ++i) {\n    // see if the tests are being run using indices\n    size_t nFirstBracket = m_tests[i].find(\"[\");\n    // set the test name\n    std::string szTestName = m_tests[i];\n\n    // order of execution is set based on base name so get the base name\n    if (nFirstBracket != std::string::npos)\n      szTestName = szTestName.substr(0, nFirstBracket);\n\n    bool bTestExists = false;\n    for (unsigned int j = 0; j < uniqueTests.size(); ++j) {\n      if (strcmp(szTestName.c_str(), uniqueTests[j].c_str()) == 0) {\n        bTestExists = true;\n        break;\n      }\n    }\n\n    if (!bTestExists) {\n      AddToList(uniqueTests, szTestName.c_str());\n    }\n  }\n\n  for (unsigned int i = 0; i < test_count && i < uniqueTests.size(); i++) {\n    for (unsigned int j = 0; j < test_count; j++) {\n      unsigned int index = i;\n      // add all the prev test indices\n      for (int k = 0; k < mod_index; k++) index += m_modules[k].get_count();\n\n      std::string szTestName = uniqueTests[index];\n\n      if (strcmp(szTestName.c_str(), m_modules[mod_index].get_name(j)) == 0) {\n        mp_testOrder[i] = j;\n        break;\n      }\n    }\n  }\n\n  if (m_rndOrder) {\n    srand((unsigned int)time(NULL));\n    for (unsigned int i = 0; i < test_count; i++) {\n      // find two random indices\n      int index1 = (int)((float)test_count * (rand() / (RAND_MAX + 1.0)));\n      int index2 = (int)((float)test_count * (rand() / (RAND_MAX + 1.0)));\n      // swap the data\n      int tmp = mp_testOrder[index1];\n      mp_testOrder[index1] = mp_testOrder[index2];\n      mp_testOrder[index2] = tmp;\n    }\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\n// Process device string. Returns true if there is a primary ATI Radeon device\n// adapter, false otherwise\nstatic bool procDevString(const char* devString) {\n  // Search for the string \"Radeon\" inside the device string\n  if (strstr(devString, \"Radeon\") || strstr(devString, \"R600\") ||\n      strstr(devString, \"RV630\") || strstr(devString, \"RV670\") ||\n      (strstr(devString, \"Stream\") && strstr(devString, \"Processor\"))) {\n    // Ignore if the device is a secondary device, i.e., not an adapter\n    if (strstr(devString, \"Secondary\")) {\n      return false;\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n}\n\n//!\n//! Function to find the total number of adapters on the system\n//!\nint findAdapters(unsigned int platformIdx, bool useCPU,\n                 cl_platform_id* mpform) {\n  unsigned int numOfAdapters = 0;\n  cl_int error = 0;\n  cl_uint numPlatforms = 0;\n\n  error = clGetPlatformIDs(0, NULL, &numPlatforms);\n  CHECK_RESULT((error != CL_SUCCESS), \"clGetPlatformIDs failed\");\n\n  CHECK_RESULT((platformIdx >= numPlatforms), \"Invalid platform\");\n\n  cl_platform_id* platforms = new cl_platform_id[numPlatforms];\n  error = clGetPlatformIDs(numPlatforms, platforms, NULL);\n  CHECK_RESULT(error != CL_SUCCESS, \"clGetPlatformIDs failed\");\n\n  cl_platform_id platform = 0;\n\n  platform = platforms[platformIdx];\n\n  delete[] platforms;\n\n  cl_device_type devType = CL_DEVICE_TYPE_GPU;\n  if (useCPU) devType = CL_DEVICE_TYPE_CPU;\n  error = clGetDeviceIDs(platform, devType, 0, 0, &numOfAdapters);\n  CHECK_RESULT((error != CL_SUCCESS), \"clGetDeviceIDs failed\");\n  if (mpform) {\n    (*mpform) = platform;\n  }\n\n  return (int)numOfAdapters;\n}\n\nint calibrate(OCLTest* test) {\n  int n = 1;\n\n#if 0\n    while (1)\n    {\n        double timer = run(test, n);\n        if (timer > 2.)\n        {\n            break;\n        }\n        n *= 2;\n    }\n#endif\n\n  return n;\n}\n\nvoid* dummyThread(void* argv) {\n  unsigned int counter = 0;\n  while (counter < 1000000) counter++;\n\n  return argv;\n}\n\n//! Function used to run the test specified\n//! It would look something like OCLPerfInputspeed[0]\ndouble run(OCLTest* test, int passes) {\n  CPerfCounter counter;\n\n  counter.Reset();\n  counter.Start();\n  int i;\n  for (i = 0; i < passes; i++) {\n    test->run();\n  }\n  counter.Stop();\n  double timer = counter.GetElapsedTime();\n  counter.Reset();\n\n  return timer;\n}\n\n//! Function to display the result after a test is finished\n//! It also stores the result in a TestResult object\nvoid report(Worker* w, const char* testname, int testnum, unsigned int crc,\n            const char* errorMsg, float timer, TestResult* tr,\n            const char* testDesc) {\n  unsigned int thread = w->getId();\n  bool perflab = w->getPerflab();\n  unsigned int deviceId = w->getDeviceId();\n\n  char tmpUnits[256];\n  if (perflab) {\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"%10.3f\\n\", timer);\n  } else {\n    const char* passedOrFailed[] = {\"FAILED\", \"PASSED\"};\n\n    // char teststring[256];\n    // sprintf(teststring, \"%s[%d]\", testname, testnum);\n    // sprintf(tmpUnits, \"Device[%d]:\\t%-32s:\\t%s\\n\", deviceId, teststring,\n    // ((tr->passed) ? passedOrFailed[1] : passedOrFailed[0]));\n    // If crc is not 0 or errorMsg is not empty, print the full stats\n    if ((crc != 0) || (errorMsg && (errorMsg[0] != '\\0'))) {\n      sprintf(tmpUnits,\n              \"%s %s: %s[%d] T[%1d] [%3d], %10.3f %-20s (chksum 0x%08x)\\n\",\n              testDesc, ((tr->passed) ? passedOrFailed[1] : passedOrFailed[0]),\n              w->isCPUEnabled() ? \"CPU\" : \"GPU\", deviceId, thread, testnum,\n              timer, errorMsg, crc);\n    } else {\n      sprintf(tmpUnits, \"%s %s: %s[%d] T[%1d] [%3d], %10.3f\\n\", testDesc,\n              ((tr->passed) ? passedOrFailed[1] : passedOrFailed[0]),\n              w->isCPUEnabled() ? \"CPU\" : \"GPU\", deviceId, thread, testnum,\n              timer);\n    }\n\n    oclTestLog(OCLTEST_LOG_ALWAYS, tmpUnits);\n\n    tr->value = timer;\n    tr->resultString.assign(tmpUnits);\n\n    if (App::m_svcMsg && !tr->passed) {\n      char escaped[2 * sizeof(tmpUnits)];\n\n      char* ptr = escaped;\n      for (int i = 0; tmpUnits[i] != '\\0'; ++i) {\n        switch (tmpUnits[i]) {\n          case '\\n':\n            *ptr++ = '|';\n            *ptr++ = 'n';\n            break;\n          case '\\r':\n            *ptr++ = '|';\n            *ptr++ = 'r';\n            break;\n          case '\\'':\n          case '|':\n          case ']':\n          case '[':\n            *ptr++ = '|';\n          default:\n            *ptr++ = tmpUnits[i];\n        }\n      }\n      *ptr = '\\0';\n\n      oclTestLog(OCLTEST_LOG_ALWAYS,\n                 \"##teamcity[testFailed name='%s.%s.%d' message='FAILED' \"\n                 \"details='%s']\\n\",\n                 w->getModule()->get_libname(), testname, testnum, escaped);\n    }\n  }\n}\n\n//! Thread Entry point\nvoid* runSubtest(void* worker) {\n  char units[256];\n  double conversion;\n  unsigned int crc = 0;\n  bool second_run = false;\n\n  // Getting the worker object that is running in this thread\n  Worker* w = (Worker*)worker;\n\n  if (w == 0) return NULL;\n\n  unsigned int test = w->getTestIndex();\n  unsigned int subtest = w->getSubTest();\n  unsigned int deviceId = w->getDeviceId();\n  unsigned int platformIndex = w->getPlatformID();\n  TestResult* result = w->getResult();\n\nRERUN_TEST:\n  // Acquiring lock on the 'module' object common to all threads\n  moduleLock.lock();\n  Module* m = w->getModule();\n  if (m == 0 || m->create_test == 0) return NULL;\n  // If we can, used the cached version,\n  // otherwise create the test.\n  OCLTest* pt = (m->cached_test ? m->cached_test[subtest] : NULL);\n  if (!pt) {\n    pt = m->create_test(subtest);\n    if (pt->cache_test() && m->cached_test) {\n      m->cached_test[subtest] = pt;\n    }\n  }\n  pt->clearError();\n  OCLTestImp* tmp = pt->toOCLTestImp();\n  if (tmp) {\n    tmp->setOCLWrapper(w->getOCLWrapper());\n  }\n  std::string subtestName = m->get_name(subtest);\n  moduleLock.unlock();\n\n  if (pt == 0) return NULL;\n\n  pt->resetDescString();\n  if (App::m_svcMsg) {\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"##teamcity[testStarted name='%s.%s.%d' \"\n               \"captureStandardOutput='true']\\n\",\n               m->get_libname(), subtestName.c_str(), test);\n  }\n  // setting the type to CPU.\n  if (w->isCPUEnabled()) {\n    pt->useCPU();\n  }\n  // Setting the device according to the worker thread\n  pt->setDeviceId(w->getDeviceId());\n  pt->setPlatformIndex(w->getPlatformID());\n  // Opening the 'test'th subtest of 'pt'\n  pt->open(test, units, conversion, deviceId);\n  pt->clearPerfInfo();\n\n  char buffer[256];\n  sprintf(buffer, \"%s[%3d]\", subtestName.c_str(), test);\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"%-32s\", buffer);\n\n  if (pt->hasErrorOccured()) {\n    result->passed = false;\n    report(w, subtestName.c_str(), test, crc, pt->getErrorMsg(),\n           pt->getPerfInfo(), result, pt->testDescString.c_str());\n  } else {\n    unsigned int n = calibrate(pt);\n    double timer = run(pt, n);\n    crc = pt->close();\n\n    if (pt->hasErrorOccured()) {\n      // run second time if the test fails the first time.\n      if (!second_run && App::m_reRunFailed && !App::m_svcMsg) {\n        second_run = true;\n\n        // Destroying a test object\n        moduleLock.lock();\n        if (!pt->cache_test()) {\n          m->destroy_test(pt);\n        }\n        moduleLock.unlock();\n\n        pt->clearError();\n        goto RERUN_TEST;\n      }\n    }\n    result->passed = !pt->hasErrorOccured();\n    /// print conditional pass if it is passes the second time.\n    if (second_run && result->passed) {\n      report(w, subtestName.c_str(), test, crc, \"Conditional PASS\",\n             pt->getPerfInfo(), result, pt->testDescString.c_str());\n    } else {\n      report(w, subtestName.c_str(), test, crc, pt->getErrorMsg(),\n             pt->getPerfInfo(), result, pt->testDescString.c_str());\n    }\n  }\n  if (App::m_svcMsg) {\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"##teamcity[testFinished name='%s.%s.%d']\\n\",\n               m->get_libname(), subtestName.c_str(), test);\n  }\n\n  // Make sure we clear the error after we report that there was an error.\n  pt->clearError();\n\n  // Destroying a test object\n  moduleLock.lock();\n  if (!pt->cache_test()) {\n    m->destroy_test(pt);\n  }\n  moduleLock.unlock();\n  return NULL;\n}\n\nvoid App::PrintTestOrder(int mod_index) {\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"Module: %s (%d tests)\\n\",\n             m_modules[mod_index].name.c_str(),\n             m_modules[mod_index].get_count());\n\n  for (unsigned int j = 0; j < m_modules[mod_index].get_count(); j++) {\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"%s\\n\",\n               m_modules[mod_index].get_name(mp_testOrder[j]));\n  }\n}\n\n//! Function that runs all the tests specified in the command-line\nvoid App::RunAllTests() {\n#ifdef ATI_OS_WIN\n\n  if (!m_console) m_window = new Window(\"Test\", 100, 100, m_width, m_height, 0);\n#endif\n\n  //\n  //  Add all tests to run list if none specified\n  //\n  if (m_tests.size() < 1) {\n    for (unsigned int i = 0; i < m_modules.size(); i++) {\n      for (unsigned int j = 0; j < m_modules[i].get_count(); j++) {\n        AddToList(m_tests, m_modules[i].get_name(j));\n      }\n    }\n  }\n\n  unsigned int num_passes = 0;\n  unsigned int num_failures = 0;\n\n  if (App::m_svcMsg) {\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"##teamcity[testSuiteStarted name='ocltst']\\n\");\n  }\n\n  //\n  //  Run each test\n  //\n  for (unsigned int i = 0; i < m_modules.size(); i++) {\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"\\n-------------------------------------------------\\n\");\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"The OpenCL Testing Module %s Version = %d \\n\",\n               m_modules[i].get_libname(), m_modules[i].get_version());\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"------------------------------\\n\");\n\n    // array to keep track of order of test execution.\n    int test_count = m_modules[i].get_count();\n    mp_testOrder = new int[test_count];\n    memset((void*)mp_testOrder, 0, sizeof(*mp_testOrder) * test_count);\n    SetTestRunOrder(i);\n\n    //\n    //  List all tests first if the option was turned on\n    //\n    if (m_list) {\n      PrintTestOrder(i);\n      delete[] mp_testOrder;\n      continue;\n      // return;\n    }\n\n    for (unsigned int itr_var = 0; itr_var < m_modules[i].get_count();\n         itr_var++) {\n      // done for random order generation\n      unsigned int subtest = mp_testOrder[itr_var];\n\n      const char* name = m_modules[i].get_name(subtest);\n      if (itr_var < m_tests.size() && TestInList(m_tests, name)) {\n        OCLTest* pt = NULL;\n        if (m_modules[i].cached_test) {\n          pt = m_modules[i].cached_test[subtest];\n        }\n        // Try to use the cached version first!\n        if (!pt) {\n          pt = m_modules[i].create_test(subtest);\n          if (pt->cache_test() && m_modules[i].cached_test) {\n            m_modules[i].cached_test[subtest] = pt;\n          }\n        }\n\n        int numSubTests = pt->getNumSubTests();\n        assert(numSubTests > 0);\n\n        TestIndexList testIndices;\n        GetTestIndexList(testIndices, m_tests, name, numSubTests - 1);\n\n        TestIndexList avoidIndices;\n        GetTestIndexList(avoidIndices, m_avoid, name, numSubTests - 1);\n\n        TestIndexList erasedIndices;\n        PruneTestIndexList(testIndices, avoidIndices, erasedIndices);\n\n        int numTestsRun = 0;\n        for (unsigned int j = 0; j < testIndices.size(); j++) {\n          unsigned int test = testIndices[j];\n\n          WaitAllThreads();\n          AddWorkerThread(i, subtest, test, pt->getThreadUsage(), runSubtest);\n\n          for (unsigned int thread = 1;\n               (thread < m_threads) && (thread < m_modules.size()); thread++) {\n            AddWorkerThread(thread, subtest, test, pt->getThreadUsage(),\n                            dummyThread);\n          }\n\n          numTestsRun++;\n        }\n\n        WaitAllThreads();\n        // Printing the test report\n        // First checking whether the number of subtests is greater than 1.\n        // No point printing report for a one subtest test\n\n        if (numTestsRun > 0) {\n          if (testReport[0]->success) {\n            num_passes++;\n          } else {\n            num_failures++;\n          }\n        }\n        if (App::m_svcMsg) {\n          for (unsigned int j = 0; j < erasedIndices.size(); j++) {\n            oclTestLog(OCLTEST_LOG_ALWAYS,\n                       \"##teamcity[testIgnored name='%s.%s.%d']\\n\",\n                       m_modules[i].get_libname(), name, erasedIndices[j]);\n          }\n        }\n\n        // Resetting the values of the test reports\n        // for(unsigned int j = 0; j < m_numDevices; j++)\n        for (unsigned int j = 0; j < 1; j++) {\n          testReport[j]->reset();\n        }\n        m_modules[i].destroy_test(pt);\n        if (m_modules[i].cached_test) {\n          m_modules[i].cached_test[subtest] = NULL;\n        }\n      }\n    }\n\n    // print the order in which the test are executed if they are\n    // randomized.\n    if (m_rndOrder) {\n      PrintTestOrder(i);\n    }\n    // deleting the test order\n    delete[] mp_testOrder;\n  }\n\n  if (App::m_svcMsg) {\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"##teamcity[testSuiteFinished name='ocltst']\\n\");\n  }\n\n#ifdef ATI_OS_WIN\n  if (!m_console && m_window) {\n    ((Window*)m_window)->ConsumeEvents();\n  }\n#endif\n  float total_tests = (float)(num_passes + num_failures);\n\n  float percent_passed = 0.0f;\n  float percent_failed = 0.0f;\n  float percent_total = 0.0f;\n  if (total_tests > 0) {\n    percent_passed = 100.0f * ((float)num_passes / total_tests);\n    percent_failed = 100.0f * ((float)num_failures / total_tests);\n    percent_total = 100.0f * ((float)total_tests / total_tests);\n  }\n\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"\\n\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"----------------------------------------\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"Total Passed Tests:  %8d (%6.2f%s)\\n\",\n             num_passes, percent_passed, \"%\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"Total Failed Tests:  %8d (%6.2f%s)\\n\",\n             num_failures, percent_failed, \"%\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"----------------------------------------\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"Total Run Tests:     %8d (%6.2f%s)\\n\",\n             (int)total_tests, percent_total, \"%\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"\\n\\n\");\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\nvoid App::AddToList(StringList& strlist, const char* str) {\n  std::string s(str);\n\n  strlist.push_back(s);\n}\n\nvoid App::LoadList(StringList& strlist, const char* filename) {\n  char buffer[1024];\n\n  FILE* fp = fopen(filename, \"r\");\n\n  if (fp == NULL) return;\n\n  while (fgets(buffer, 1000, fp) != NULL) {\n    size_t length = strlen(buffer);\n    if (length > 0) {\n      if (buffer[length - 1] != '\\n') {\n        length++;\n      }\n      buffer[length - 1] = 0;\n      AddToList(strlist, buffer);\n    }\n  }\n\n  fclose(fp);\n}\n\nstatic void Help(const char* name) {\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"%s (-w | -v | -m | -M | -l | -t | -T | -p | -d | -x | -y | -g| \"\n             \"-o | -n )\\n\",\n             name);\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"   -w            : enable window mode\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -v            : enable TeamCity service messages\\n\");\n  oclTestLog(\n      OCLTEST_LOG_ALWAYS,\n      \"   -d            : dump test output to portable float map (pfm)\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -m <module>   : specify a DLL module with tests\\n\");\n  oclTestLog(\n      OCLTEST_LOG_ALWAYS,\n      \"   -M <filename> : specify a text file with one DLL module per line\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -l            : list test names in DLL modules and exit\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -s <count>    : number of threads to spawn\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"   -t <testname> : run test\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -T <filename> : specify a text file with one test per line\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -a <testname> : specify a test to avoid\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -A <filename> : specify a text file of tests to avoid with \"\n             \"one test per line\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -p <platform> : specify a platform to run on, 'amd','nvidia' \"\n             \"or 'intel'\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"   -h            : this help text\\n\");\n  oclTestLog(\n      OCLTEST_LOG_ALWAYS,\n      \"   -x            : x dimension for debug output image (and window)\\n\");\n  oclTestLog(\n      OCLTEST_LOG_ALWAYS,\n      \"   -y            : y dimension for debug output image (and window)\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -P            : Perflab mode (just print the result without \"\n             \"any supplementary information)\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -n #number    : run the tests specified with -m, -M, -t or -T \"\n             \"options multiple times\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -r            : Option to Randomize the order in which the \"\n             \"tests are executed.\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -R            : Option to ReRun failed tests for conditional \"\n             \"pass.\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -i            : Don't print system information\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -g <GPUid>    : GPUid to run the tests on\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -o <filename> : dump the output to a specified file\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -c            : Run the test on the CPU device.\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"                 : \\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"                 : To run only one subtest of a test, append the \"\n             \"subtest to\\n\");\n  oclTestLog(\n      OCLTEST_LOG_ALWAYS,\n      \"                 : the end of the test name in brackets. i.e. test[1]\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"\\n\");\n\n  exit(0);\n}\n\nunsigned int getPlatformID(const char* str) {\n  std::string strOfCLVendor(str);\n  std::string strOfCLPlatformName;\n  unsigned int platform = 0;\n\n  // currently, the only input values amd,nvidia and intel are supported\n  if (strOfCLVendor == \"amd\") {\n    strOfCLPlatformName = \"Advanced Micro Devices, Inc.\";\n  } else if (strOfCLVendor == \"intel\") {\n    strOfCLPlatformName = \"Intel(R) Corporation\";\n  } else if (strOfCLVendor == \"nvidia\") {\n    strOfCLPlatformName = \"NVIDIA Corporation\";\n  } else {\n    // fall-back on platform index 0\n    return platform;\n  }\n\n  cl_int status;\n  cl_uint numPlatforms = 0;\n\n  status = clGetPlatformIDs(0, NULL, &numPlatforms);\n  if (status != CL_SUCCESS) {\n    return platform;\n  }\n\n  cl_platform_id* platforms = new cl_platform_id[numPlatforms];\n  status = clGetPlatformIDs(numPlatforms, platforms, NULL);\n\n  if (status == CL_SUCCESS) {\n    unsigned int i;\n    for (i = 0; i < numPlatforms; ++i) {\n      char buff[200];\n      status = clGetPlatformInfo(platforms[i], CL_PLATFORM_VENDOR, sizeof(buff),\n                                 buff, NULL);\n      if (status != CL_SUCCESS) {\n        break;\n      }\n      if (strcmp(buff, strOfCLPlatformName.c_str()) == 0) {\n        platform = i;\n        break;\n      }\n    }\n  }\n\n  delete[] platforms;\n  return platform;\n}\n\nunsigned int parseCommandLineForPlatform(unsigned int argc, char** argv) {\n  int c;\n  unsigned int platform = 0;\n\n  while ((c = getopt(argc, argv, \"dg:lm:M:o:Ps:t:T:a:A:p:v:wxy:in:rcRV\")) !=\n         -1) {\n    switch (c) {\n      case 'p':\n        platform = getPlatformID(optarg);\n        break;\n      default:\n        break;\n    }\n  }\n  return platform;\n}\n\nvoid App::CommandLine(unsigned int argc, char** argv) {\n  unsigned int i = 1;\n  int c;\n  bool hasOption = false;\n  unsigned int tmpNumDevices = 0;\n  unsigned int tmpDeviceId = 0;\n  m_deviceId = 0;\n  int tmp;\n\n  while ((c = getopt(argc, argv, \"dg:lm:M:o:Ps:t:T:a:A:p:v:wxy:in:rcRV\")) !=\n         -1) {\n    switch (c) {\n      case 'c':\n        m_useCPU = true;\n        break;\n\n      case 'p':\n        break;\n\n      case 'w':\n        m_console = false;\n        hasOption = true;\n        break;\n\n      case 'V':\n        m_svcMsg = true;\n        break;\n\n      case 'd':\n        m_dump = true;\n        hasOption = true;\n        break;\n\n      case 'm':\n        AddToList(m_paths, optarg);\n        hasOption = true;\n        break;\n\n      case 'M':\n        LoadList(m_paths, optarg);\n        hasOption = true;\n        break;\n\n      case 'a':\n        AddToList(m_avoid, optarg);\n        hasOption = true;\n        break;\n\n      case 'A':\n        LoadList(m_avoid, optarg);\n        hasOption = true;\n        break;\n\n      case 'l':\n        m_list = true;\n        hasOption = true;\n        break;\n\n      // command line switch to loop execution of any specified test or tests n\n      // number of times\n      case 'n':\n        m_numItr = atoi(optarg);\n        break;\n\n      // command line switch to randomize the order of test execution in OCLTest\n      case 'r':\n        m_rndOrder = true;\n        break;\n\n      // command line switch to rerun the failed tests to see if they pass on\n      // second run\n      case 'R': {\n        m_reRunFailed = true;\n        break;\n      }\n      case 't':\n        AddToList(m_tests, optarg);\n        hasOption = true;\n        break;\n\n      case 'T':\n        LoadList(m_tests, optarg);\n        hasOption = true;\n        break;\n\n      case 's':\n        m_threads = atoi(optarg);\n        hasOption = true;\n        break;\n\n      case 'h':\n        Help(argv[0]);\n        break;\n\n      case 'x':\n        m_width = atoi(optarg);\n        hasOption = true;\n        break;\n\n      case 'y':\n        m_height = atoi(optarg);\n        hasOption = true;\n        break;\n\n      case 'P':\n        m_perflab = true;\n        hasOption = true;\n        break;\n      case 'g':\n#if 0\n            tmpNumDevices = (unsigned int)atoi(optarg);\n            if(m_numDevices < tmpNumDevices)\n            {\n                oclTestLog(OCLTEST_LOG_ALWAYS, \"Number of Devices(%d) less than specified by the user(%d).  Using %d devices.\\n\", m_numDevices, tmpNumDevices, m_numDevices);\n            }\n            else\n            {\n                m_numDevices = tmpNumDevices;\n            }\n#else\n        tmpDeviceId = (unsigned int)atoi(optarg);\n#endif\n        break;\n      case 'v':\n        tmp = atoi(optarg);\n        if (tmp >= 0 && tmp < 100) {\n          oclTestSetLogLevel(atoi(optarg));\n        } else {\n          oclTestLog(OCLTEST_LOG_ALWAYS, \"Invalid verbose level\\n\");\n        }\n        break;\n      case 'o': {\n        hasOption = true;\n        oclTestEnableLogToFile(optarg);\n      } break;\n      case 'i':\n        m_noSysInfoPrint = true;\n        break;\n      default:\n        Help(argv[0]);\n        break;\n    }\n  }\n\n  // Reset devices in case user overrode defaults\n  m_numDevices = findAdapters(m_platform, m_useCPU, &mpform_id);\n  if (m_numDevices < (tmpDeviceId + 1)) {\n    m_deviceId = 0;\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"User specified deviceId(%d) exceedes the number of \"\n               \"Devices(%d).  Using device %d.\\n\",\n               tmpDeviceId, m_numDevices, m_deviceId);\n  } else {\n    m_deviceId = tmpDeviceId;\n  }\n\n  if (!hasOption) {\n    Help(argv[0]);\n  }\n}\n\nbool App::TestInList(StringList& strlist, const char* szModuleTestname) {\n  if (szModuleTestname == NULL) {\n    return false;\n  }\n  for (unsigned int i = 0; i < strlist.size(); i++) {\n    // check to see if an index is specified for this test name\n    int nIndex = -1;\n    std::string szTestName = strlist[i];\n    if (szTestName.find(\"[\") != std::string::npos) {\n      size_t nFirstBracket = szTestName.find(\"[\");\n      size_t nLastBracket = szTestName.find(\"]\");\n      if ((nFirstBracket != std::string::npos) &&\n          (nLastBracket != std::string::npos) &&\n          (nLastBracket > nFirstBracket)) {\n        szTestName = szTestName.substr(0, nFirstBracket);\n      }\n    }\n    if (strcmp(szModuleTestname, szTestName.c_str()) == 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvoid App::GetTestIndexList(TestIndexList& testIndices, StringList& testList,\n                           const char* szModuleTestname, int maxIndex) {\n  for (unsigned int i = 0; i < testList.size(); i++) {\n    IndicesRange nIndex = {0, maxIndex};\n\n    // If the test name string ends with [...] parse the text\n    // between the brackets to determine the index range.\n    std::string szTestName = testList[i];\n    if (szTestName.find(\"[\") != std::string::npos) {\n      size_t nFirstBracket = szTestName.find(\"[\");\n      size_t nLastBracket = szTestName.find(\"]\");\n      if ((nFirstBracket != std::string::npos) &&\n          (nLastBracket != std::string::npos) &&\n          (nLastBracket > nFirstBracket)) {\n        // Getting the string between the brackets '[' and ']'\n        // The values can be one of the following:-\n        // [a-b] - Run tests from a to b\n        // [a-] - Run tests from subtest a to subtest total_tests\n        // [-b] - Run tests from subtest 0 to subtest b\n        // a and b are indices of the tests to run\n\n        std::string nIndexString = szTestName.substr(\n            nFirstBracket + 1, nLastBracket - nFirstBracket - 1);\n        size_t nIntermediateHyphen = szTestName.find(\"-\");\n        if ((nIntermediateHyphen != std::string::npos) &&\n            (nIntermediateHyphen < nLastBracket) &&\n            (nIntermediateHyphen > nFirstBracket)) {\n          // Getting the start index\n          if ((nIntermediateHyphen - 1) == nFirstBracket) {\n            nIndex.startIndex = 0;\n          } else {\n            nIndex.startIndex =\n                atoi(szTestName\n                         .substr(nFirstBracket + 1,\n                                 nIntermediateHyphen - nFirstBracket - 1)\n                         .c_str());\n          }\n\n          // Getting the end index\n          if ((nIntermediateHyphen + 1) == nLastBracket) {\n            nIndex.endIndex = maxIndex;\n          } else {\n            nIndex.endIndex =\n                atoi(szTestName\n                         .substr(nIntermediateHyphen + 1,\n                                 nLastBracket - nIntermediateHyphen - 1)\n                         .c_str());\n          }\n        } else {\n          nIndex.startIndex = atoi(\n              szTestName\n                  .substr(nFirstBracket + 1, nLastBracket - nFirstBracket - 1)\n                  .c_str());\n          nIndex.endIndex = nIndex.startIndex;\n        }\n      }\n\n      szTestName = szTestName.substr(0, nFirstBracket);\n    }\n\n    if (strcmp(szModuleTestname, szTestName.c_str()) == 0) {\n      // If the values are out of order, swap them.\n      if (nIndex.startIndex > nIndex.endIndex) {\n        int tmp = nIndex.startIndex;\n        nIndex.startIndex = nIndex.endIndex;\n        nIndex.endIndex = tmp;\n      }\n\n      // Add the indices in the specified range to the list.\n      for (int i = nIndex.startIndex; i <= nIndex.endIndex; ++i) {\n        if (i <= maxIndex) {\n          testIndices.push_back(i);\n        } else {\n          oclTestLog(OCLTEST_LOG_ALWAYS,\n                     \"Error: Invalid test index for subtest: %s!\\n\",\n                     szModuleTestname);\n        }\n      }\n\n      // Now sort and prune duplicates.\n      std::sort(testIndices.begin(), testIndices.end());\n      std::unique(testIndices.begin(), testIndices.end());\n    }\n  }\n}\n\nvoid App::PruneTestIndexList(TestIndexList& testIndices,\n                             TestIndexList& avoidIndices,\n                             TestIndexList& erasedIndices) {\n  for (TestIndexList::iterator it = testIndices.begin();\n       it != testIndices.end();) {\n    unsigned int index = *it;\n    TestIndexList::iterator result =\n        std::find(avoidIndices.begin(), avoidIndices.end(), index);\n    if (result != avoidIndices.end()) {\n      it = testIndices.erase(it);\n      erasedIndices.push_back(index);\n    } else {\n      ++it;\n    }\n  }\n}\n\nvoid App::ScanForTests() {\n  for (unsigned int i = 0; i < m_paths.size(); i++) {\n    Module mod;\n\n#ifdef ATI_OS_WIN\n    std::string::iterator myIter;\n    myIter = m_paths[i].end();\n    myIter--;\n    if (*myIter == 0x0a) m_paths[i].erase(myIter);\n\n    mod.hmodule = LoadLibrary(m_paths[i].c_str());\n#endif\n#ifdef ATI_OS_LINUX\n    mod.hmodule = dlopen(m_paths[i].c_str(), RTLD_NOW);\n#endif\n\n    if (mod.hmodule == NULL) {\n      fprintf(stderr, \"Could not load module: %s\\n\", m_paths[i].c_str());\n#ifdef ATI_OS_LINUX\n      fprintf(stderr, \"Error : %s\\n\", dlerror());\n#else\n#endif\n    } else {\n      mod.name = m_paths[i];\n\n#ifdef ATI_OS_WIN\n      mod.get_count = (TestCountFuncPtr)GetProcAddress(mod.hmodule,\n                                                       \"OCLTestList_TestCount\");\n      mod.get_name =\n          (TestNameFuncPtr)GetProcAddress(mod.hmodule, \"OCLTestList_TestName\");\n      mod.create_test = (CreateTestFuncPtr)GetProcAddress(\n          mod.hmodule, \"OCLTestList_CreateTest\");\n      mod.destroy_test = (DestroyTestFuncPtr)GetProcAddress(\n          mod.hmodule, \"OCLTestList_DestroyTest\");\n      mod.get_version = (TestVersionFuncPtr)GetProcAddress(\n          mod.hmodule, \"OCLTestList_TestLibVersion\");\n      mod.get_libname = (TestLibNameFuncPtr)GetProcAddress(\n          mod.hmodule, \"OCLTestList_TestLibName\");\n#endif\n#ifdef ATI_OS_LINUX\n      mod.get_count =\n          (TestCountFuncPtr)dlsym(mod.hmodule, \"OCLTestList_TestCount\");\n      mod.get_name =\n          (TestNameFuncPtr)dlsym(mod.hmodule, \"OCLTestList_TestName\");\n      mod.create_test =\n          (CreateTestFuncPtr)dlsym(mod.hmodule, \"OCLTestList_CreateTest\");\n      mod.destroy_test =\n          (DestroyTestFuncPtr)dlsym(mod.hmodule, \"OCLTestList_DestroyTest\");\n      mod.get_version =\n          (TestVersionFuncPtr)dlsym(mod.hmodule, \"OCLTestList_TestLibVersion\");\n      mod.get_libname =\n          (TestLibNameFuncPtr)dlsym(mod.hmodule, \"OCLTestList_TestLibName\");\n#endif\n      mod.cached_test = new OCLTest*[mod.get_count()];\n      for (int x = 0, y = mod.get_count(); x < y; ++x) {\n        mod.cached_test[x] = NULL;\n      }\n      m_modules.push_back(mod);\n    }\n  }\n}\n\nvoid App::CleanUp() {\n  for (unsigned int i = 0; i < m_modules.size(); i++) {\n    if (m_modules[i].cached_test) {\n      delete[] m_modules[i].cached_test;\n    }\n#ifdef ATI_OS_WIN\n    FreeLibrary(m_modules[i].hmodule);\n#endif\n#ifdef ATI_OS_LINUX\n    dlclose(m_modules[i].hmodule);\n#endif\n  }\n\n#ifdef ATI_OS_WIN\n  if (m_window) delete m_window;\n  m_window = 0;\n#endif\n}\n\nextern int optind;\n/////////////////////////////////////////////////////////////////////////////\nbool App::m_reRunFailed = false;\nbool App::m_svcMsg = false;\nint main(int argc, char** argv) {\n  unsigned int platform = 0;\n  platform = parseCommandLineForPlatform(argc, argv);\n  // reset optind as we really didn't parse the full command line\n  optind = 0;\n  App app(platform);\n#ifdef ATI_OS_WIN\n  // this function is registers windows service routine when ocltst is launched\n  // by the OS on service initialization. On other scenarios, this function does\n  // nothing.\n  serviceStubCall();\n  // SetErrorMode(SEM_NOGPFAULTERRORBOX);\n  // const LPTOP_LEVEL_EXCEPTION_FILTER oldFilter =\n  // SetUnhandledExceptionFilter(xFilter);\n#endif  // ATI_OS_WIN\n#ifdef AUTO_REGRESS\n  try {\n#endif /* AUTO_REGRESS */\n    app.CommandLine(argc, argv);\n    app.printOCLinfo();\n    app.ScanForTests();\n    for (int i = 0; i < app.GetNumItr(); i++) {\n      app.RunAllTests();\n    }\n    app.CleanUp();\n#ifdef AUTO_REGRESS\n  } catch (...) {\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"Exiting due to unhandled exception!\\n\");\n    return (-1);\n  }\n#endif /* AUTO_REGRESS */\n\n  return 0;\n}\n\n#ifdef ATI_OS_WIN\n\n#include <dbghelp.h>\n\ntypedef unsigned int uint32;\ntypedef size_t uintp;\n\nstruct StackEntry {\n  uintp addr;\n  uint32 line;\n  uint32 disp;\n  char symbol[128];\n  char file[128];\n};\n\nstatic const unsigned int MAX_DEPTH_PER_NODE = 24;\nstruct Info {\n  bool operator==(const Info& b) const { return key == b.key; }\n\n  uintp key;  // pointer, handle, whatever\n  StackEntry stack[MAX_DEPTH_PER_NODE];\n};\n\nstatic void dumpTraceBack(CONTEXT& context) {\n  Info info;\n\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"Exception: exiting!\\n\");\n  HANDLE process = GetCurrentProcess();\n\n  STACKFRAME64 stackframe;\n  memset(&stackframe, 0, sizeof(STACKFRAME64));\n\n#if defined(_WIN64)\n  stackframe.AddrPC.Offset = context.Rip;\n  stackframe.AddrPC.Mode = AddrModeFlat;\n  stackframe.AddrStack.Offset = context.Rsp;\n  stackframe.AddrStack.Mode = AddrModeFlat;\n  stackframe.AddrFrame.Offset = context.Rbp;\n  stackframe.AddrFrame.Mode = AddrModeFlat;\n#else\n  stackframe.AddrPC.Offset = context.Eip;\n  stackframe.AddrPC.Mode = AddrModeFlat;\n  stackframe.AddrStack.Offset = context.Esp;\n  stackframe.AddrStack.Mode = AddrModeFlat;\n  stackframe.AddrFrame.Offset = context.Ebp;\n  stackframe.AddrFrame.Mode = AddrModeFlat;\n#endif\n  unsigned int depth = 0;\n\n  if (SymInitialize(process, NULL, true)) {\n    while ((depth < MAX_DEPTH_PER_NODE) &&\n           StackWalk64(IMAGE_FILE_MACHINE_I386, process, GetCurrentThread(),\n                       &stackframe, &context, NULL, SymFunctionTableAccess64,\n                       SymGetModuleBase64, NULL)) {\n      if (stackframe.AddrPC.Offset != 0) {\n        //\n        //  we don't want to evaluate the names/lines yet\n        //  so just record the address\n        //\n        info.stack[depth].addr = (uintp)stackframe.AddrPC.Offset;\n\n        DWORD64 disp64;\n        DWORD disp;\n        IMAGEHLP_SYMBOL64* symInfo;\n        IMAGEHLP_LINE64 lineInfo;\n        uintp addr = (uintp)stackframe.AddrPC.Offset;\n        char buffer[128];\n\n        symInfo = (IMAGEHLP_SYMBOL64*)&buffer[0];\n        symInfo->SizeOfStruct = sizeof(symInfo);\n        symInfo->MaxNameLength = (sizeof(buffer) - sizeof(IMAGEHLP_SYMBOL64));\n\n        lineInfo.SizeOfStruct = sizeof(lineInfo);\n\n        if (SymGetSymFromAddr64(process, addr, &disp64, symInfo)) {\n          sprintf(info.stack[depth].symbol, \"%s\", symInfo->Name);\n          info.stack[depth].disp = (uint32)disp64;\n        } else {\n          sprintf(info.stack[depth].symbol, \"\");\n        }\n\n        if (SymGetLineFromAddr64(process, addr, &disp, &lineInfo)) {\n          sprintf(info.stack[depth].file, \"%s\", lineInfo.FileName);\n          info.stack[depth].line = lineInfo.LineNumber;\n        } else {\n          info.stack[depth].file[0] = '\\0';\n        }\n        depth++;\n      }\n    }\n  }\n\n  SymCleanup(process);\n\n  int j = 0;\n  while (j < MAX_DEPTH_PER_NODE && info.stack[j].addr != 0) {\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"        %s()+%d (0x%.8x)  %s:%d\\n\",\n               info.stack[j].symbol, info.stack[j].disp, info.stack[j].addr,\n               info.stack[j].file, info.stack[j].line);\n\n    j++;\n  }\n}\n\nstatic LONG WINAPI xFilter(LPEXCEPTION_POINTERS xEP) {\n  CONTEXT context;\n  CONTEXT* xCtx = &context;\n  memset(xCtx, 0, sizeof(CONTEXT));\n  context.ContextFlags = CONTEXT_FULL;\n  memcpy(xCtx, xEP->ContextRecord, sizeof(CONTEXT));\n\n  dumpTraceBack(context);\n\n  return (EXCEPTION_EXECUTE_HANDLER);\n}\n#undef CHECK_RESULT\n#endif  // WIN_OS\n\n/////////////////////////////////////////////////////////////////////////////\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.9.0-neudjleb7hiztwlofocdddh3xyfxtn44/spack-src/opencl-on-vdi/khronos/icd/loader/linux/icd_linux.c": "/*\n * Copyright (c) 2016-2019 The Khronos Group Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * OpenCL is a trademark of Apple Inc. used under license by Khronos.\n */\n\n#include \"icd.h\"\n#include \"icd_envvars.h\"\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <pthread.h>\n\nstatic pthread_once_t initialized = PTHREAD_ONCE_INIT;\n\n/*\n * \n * Vendor enumeration functions\n *\n */\n\n// go through the list of vendors in the two configuration files\nvoid khrIcdOsVendorsEnumerate(void)\n{\n    DIR *dir = NULL;\n    struct dirent *dirEntry = NULL;\n    char* vendorPath = ICD_VENDOR_PATH;\n    char* envPath = NULL;\n\n    khrIcdVendorsEnumerateEnv();\n\n    envPath = khrIcd_secure_getenv(\"OCL_ICD_VENDORS\");\n    if (NULL != envPath)\n    {\n        vendorPath = envPath;\n    }\n\n    dir = opendir(vendorPath);\n    if (NULL == dir) \n    {\n        KHR_ICD_TRACE(\"Failed to open path %s, continuing\\n\", vendorPath);\n    }\n    else\n    {\n        // attempt to load all files in the directory\n        for (dirEntry = readdir(dir); dirEntry; dirEntry = readdir(dir) )\n        {\n            switch(dirEntry->d_type)\n            {\n            case DT_UNKNOWN:\n            case DT_REG:\n            case DT_LNK:\n                {\n                    const char* extension = \".icd\";\n                    FILE *fin = NULL;\n                    char* fileName = NULL;\n                    char* buffer = NULL;\n                    long bufferSize = 0;\n\n                    // make sure the file name ends in .icd\n                    if (strlen(extension) > strlen(dirEntry->d_name) )\n                    {\n                        break;\n                    }\n                    if (strcmp(dirEntry->d_name + strlen(dirEntry->d_name) - strlen(extension), extension) )\n                    {\n                        break;\n                    }\n\n                    // allocate space for the full path of the vendor library name\n                    fileName = malloc(strlen(dirEntry->d_name) + strlen(vendorPath) + 1);\n                    if (!fileName)\n                    {\n                        KHR_ICD_TRACE(\"Failed allocate space for ICD file path\\n\");\n                        break;\n                    }\n                    sprintf(fileName, \"%s%s\", vendorPath, dirEntry->d_name);\n\n                    // open the file and read its contents\n                    fin = fopen(fileName, \"r\");\n                    if (!fin)\n                    {\n                        free(fileName);\n                        break;\n                    }\n                    fseek(fin, 0, SEEK_END);\n                    bufferSize = ftell(fin);\n\n                    buffer = malloc(bufferSize+1);\n                    if (!buffer)\n                    {\n                        free(fileName);\n                        fclose(fin);\n                        break;\n                    }\n                    memset(buffer, 0, bufferSize+1);\n                    fseek(fin, 0, SEEK_SET);\n                    if (bufferSize != (long)fread(buffer, 1, bufferSize, fin) )\n                    {\n                        free(fileName);\n                        free(buffer);\n                        fclose(fin);\n                        break;\n                    }\n                    // ignore a newline at the end of the file\n                    if (buffer[bufferSize-1] == '\\n') buffer[bufferSize-1] = '\\0';\n\n                    // load the string read from the file\n                    khrIcdVendorAdd(buffer);\n\n                    free(fileName);\n                    free(buffer);\n                    fclose(fin);\n                }\n                break;\n            default:\n                break;\n            }\n        }\n\n        closedir(dir);\n    }\n\n    if (NULL != envPath)\n    {\n        khrIcd_free_getenv(envPath);\n    }\n}\n\n// go through the list of vendors only once\nvoid khrIcdOsVendorsEnumerateOnce(void)\n{\n    pthread_once(&initialized, khrIcdOsVendorsEnumerate);\n}\n\n/*\n * \n * Dynamic library loading functions\n *\n */\n\n// dynamically load a library.  returns NULL on failure\nvoid *khrIcdOsLibraryLoad(const char *libraryName)\n{\n    void *retVal = dlopen (libraryName, RTLD_NOW);\n\n    if (NULL == retVal) {\n        printf(\"dlerror: %s\\n\", dlerror());\n    }\n\n    return retVal;\n}\n\n// get a function pointer from a loaded library.  returns NULL on failure.\nvoid *khrIcdOsLibraryGetFunctionAddress(void *library, const char *functionName)\n{\n    return dlsym(library, functionName);\n}\n\n// unload a library\nvoid khrIcdOsLibraryUnload(void *library)\n{\n    dlclose(library);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.9.0-neudjleb7hiztwlofocdddh3xyfxtn44/spack-src/device/pal/palsched.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.9.0-neudjleb7hiztwlofocdddh3xyfxtn44/spack-src/device/gpu/gpusched.hpp"
    ],
    "total_files": 741
}