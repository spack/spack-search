{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.7.0-6twwcw3rjraboiuw75ysfcdddj55uxkg/spack-src/elf/utils/common/elfdefinitions.h": "/*-\n * Copyright (c) 2010 Joseph Koshy\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * $Id: elfdefinitions.h 2064 2011-10-26 15:12:32Z jkoshy $\n */\n\n/*\n * These definitions are based on:\n * - The public specification of the ELF format as defined in the\n *   October 2009 draft of System V ABI.\n *   See: http://www.sco.com/developers/gabi/latest/ch4.intro.html\n * - The May 1998 (version 1.5) draft of \"The ELF-64 object format\".\n * - Processor-specific ELF ABI definitions for sparc, i386, amd64, mips,\n *   ia64, and powerpc processors.\n * - The \"Linkers and Libraries Guide\", from Sun Microsystems.\n */\n\n#ifndef _ELFDEFINITIONS_H_\n#define _ELFDEFINITIONS_H_\n\n#ifdef WIN32\n#include \"compat.h\"\n#else\n#include <stdint.h>\n#endif\n\n/*\n * Types of capabilities.\n */\n\n#define\t_ELF_DEFINE_CAPABILITIES()\t\t\t\t\\\n_ELF_DEFINE_CA(CA_SUNW_NULL,\t0,\t\"ignored\")\t\t\\\n_ELF_DEFINE_CA(CA_SUNW_HW_1,\t1,\t\"hardware capability\")\t\\\n_ELF_DEFINE_CA(CA_SUNW_SW_1,\t2,\t\"software capability\")\n\n#undef\t_ELF_DEFINE_CA\n#define\t_ELF_DEFINE_CA(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_CAPABILITIES()\n\tCA__LAST__\n};\n\n/*\n * Flags used with dynamic linking entries.\n */\n\n#define\t_ELF_DEFINE_DYN_FLAGS()\t\t\t\t\t\\\n_ELF_DEFINE_DF(DF_ORIGIN,           0x1,\t\t\t\\\n\t\"object being loaded may refer to $ORIGIN\")\t\t\\\n_ELF_DEFINE_DF(DF_SYMBOLIC,         0x2,\t\t\t\\\n\t\"search library for references before executable\")\t\\\n_ELF_DEFINE_DF(DF_TEXTREL,          0x4,\t\t\t\\\n\t\"relocation entries may modify text segment\")\t\t\\\n_ELF_DEFINE_DF(DF_BIND_NOW,         0x8,\t\t\t\\\n\t\"process relocation entries at load time\")\t\t\\\n_ELF_DEFINE_DF(DF_STATIC_TLS,       0x10,\t\t\t\\\n\t\"uses static thread-local storage\")\n#undef\t_ELF_DEFINE_DF\n#define\t_ELF_DEFINE_DF(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_DYN_FLAGS()\n\tDF__LAST__\n};\n\n\n/*\n * Dynamic linking entry types.\n */\n\n#define\t_ELF_DEFINE_DYN_TYPES()\t\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_NULL,             0, \"end of array\")\t\t\t\\\n_ELF_DEFINE_DT(DT_NEEDED,           1, \"names a needed library\")\t\\\n_ELF_DEFINE_DT(DT_PLTRELSZ,         2,\t\t\t\t\t\\\n\t\"size in bytes of associated relocation entries\")\t\t\\\n_ELF_DEFINE_DT(DT_PLTGOT,           3,\t\t\t\t\t\\\n\t\"address associated with the procedure linkage table\")\t\t\\\n_ELF_DEFINE_DT(DT_HASH,             4,\t\t\t\t\t\\\n\t\"address of the symbol hash table\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_STRTAB,           5,\t\t\t\t\t\\\n\t\"address of the string table\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_SYMTAB,           6,\t\t\t\t\t\\\n\t\"address of the symbol table\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_RELA,             7,\t\t\t\t\t\\\n\t\"address of the relocation table\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_RELASZ,           8, \"size of the DT_RELA table\")\t\\\n_ELF_DEFINE_DT(DT_RELAENT,          9, \"size of each DT_RELA entry\")\t\\\n_ELF_DEFINE_DT(DT_STRSZ,            10, \"size of the string table\")\t\\\n_ELF_DEFINE_DT(DT_SYMENT,           11,\t\t\t\t\t\\\n\t\"size of a symbol table entry\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_INIT,             12,\t\t\t\t\t\\\n\t\"address of the initialization function\")\t\t\t\\\n_ELF_DEFINE_DT(DT_FINI,             13,\t\t\t\t\t\\\n\t\"address of the finalization function\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_SONAME,           14, \"names the shared object\")\t\\\n_ELF_DEFINE_DT(DT_RPATH,            15,\t\t\t\t\t\\\n\t\"runtime library search path\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_SYMBOLIC,         16,\t\t\t\t\t\\\n\t\"alter symbol resolution algorithm\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_REL,              17,\t\t\t\t\t\\\n\t\"address of the DT_REL table\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_RELSZ,            18, \"size of the DT_REL table\")\t\\\n_ELF_DEFINE_DT(DT_RELENT,           19, \"size of each DT_REL entry\")\t\\\n_ELF_DEFINE_DT(DT_PLTREL,           20,\t\t\t\t\t\\\n\t\"type of relocation entry in the procedure linkage table\")\t\\\n_ELF_DEFINE_DT(DT_DEBUG,            21, \"used for debugging\")\t\t\\\n_ELF_DEFINE_DT(DT_TEXTREL,          22,\t\t\t\t\t\\\n\t\"text segment may be written to during relocation\")\t\t\\\n_ELF_DEFINE_DT(DT_JMPREL,           23,\t\t\t\t\t\\\n\t\"address of relocation entries associated with the procedure linkage table\") \\\n_ELF_DEFINE_DT(DT_BIND_NOW,         24,\t\t\t\t\t\\\n\t\"bind symbols at loading time\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_INIT_ARRAY,       25,\t\t\t\t\t\\\n\t\"pointers to initialization functions\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_FINI_ARRAY,       26,\t\t\t\t\t\\\n\t\"pointers to termination functions\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_INIT_ARRAYSZ,     27, \"size of the DT_INIT_ARRAY\")\t\\\n_ELF_DEFINE_DT(DT_FINI_ARRAYSZ,     28, \"size of the DT_FINI_ARRAY\")\t\\\n_ELF_DEFINE_DT(DT_RUNPATH,          29,\t\t\t\t\t\\\n\t\"index of library search path string\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_FLAGS,            30,\t\t\t\t\t\\\n\t\"flags specific to the object being loaded\")\t\t\t\\\n_ELF_DEFINE_DT(DT_ENCODING,         32, \"standard semantics\")\t\t\\\n_ELF_DEFINE_DT(DT_PREINIT_ARRAY,    32,\t\t\t\t\t\\\n\t\"pointers to pre-initialization functions\")\t\t\t\\\n_ELF_DEFINE_DT(DT_PREINIT_ARRAYSZ,  33,\t\t\t\t\t\\\n\t\"size of pre-initialization array\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MAXPOSTAGS,\t    34,\t\t\t\t\t\\\n\t\"the number of positive tags\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_LOOS,             0x6000000DUL,\t\t\t\\\n\t\"start of OS-specific types\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_SUNW_AUXILIARY,   0x6000000DUL,\t\t\t\\\n\t\"offset of string naming auxiliary filtees\")\t\t\t\\\n_ELF_DEFINE_DT(DT_SUNW_RTLDINF,     0x6000000EUL, \"rtld internal use\")\t\\\n_ELF_DEFINE_DT(DT_SUNW_FILTER,      0x6000000FUL,\t\t\t\\\n\t\"offset of string naming standard filtees\")\t\t\t\\\n_ELF_DEFINE_DT(DT_SUNW_CAP,         0x60000010UL,\t\t\t\\\n\t\"address of hardware capabilities section\")\t\t\t\\\n_ELF_DEFINE_DT(DT_HIOS,             0x6FFFF000UL,\t\t\t\\\n\t\"end of OS-specific types\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_VALRNGLO,         0x6FFFFD00UL,\t\t\t\\\n\t\"start of range using the d_val field\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_GNU_PRELINKED,    0x6FFFFDF5UL,\t\t\t\\\n\t\"prelinking timestamp\")\t\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_GNU_CONFLICTSZ,   0x6FFFFDF6UL,\t\t\t\\\n\t\"size of conflict section\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_GNU_LIBLISTSZ,    0x6FFFFDF7UL,\t\t\t\\\n\t\"size of library list\")\t\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_CHECKSUM,         0x6FFFFDF8UL,\t\t\t\\\n\t\"checksum for the object\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_PLTPADSZ,         0x6FFFFDF9UL,\t\t\t\\\n\t\"size of PLT padding\")\t\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MOVEENT,          0x6FFFFDFAUL,\t\t\t\\\n\t\"size of DT_MOVETAB entries\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MOVESZ,           0x6FFFFDFBUL,\t\t\t\\\n\t\"total size of the MOVETAB table\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_FEATURE_1,        0x6FFFFDFCUL, \"feature values\")\t\\\n_ELF_DEFINE_DT(DT_POSFLAG_1,        0x6FFFFDFDUL,\t\t\t\\\n\t\"dynamic position flags\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_SYMINSZ,          0x6FFFFDFEUL,\t\t\t\\\n\t\"size of the DT_SYMINFO table\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_SYMINENT,         0x6FFFFDFFUL,\t\t\t\\\n\t\"size of a DT_SYMINFO entry\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_VALRNGHI,         0x6FFFFDFFUL,\t\t\t\\\n\t\"end of range using the d_val field\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_ADDRRNGLO,        0x6FFFFE00UL,\t\t\t\\\n\t\"start of range using the d_ptr field\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_GNU_HASH,\t    0x6FFFFEF5UL,\t\t\t\\\n\t\"GNU style hash tables\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_GNU_CONFLICT,     0x6FFFFEF8UL,\t\t\t\\\n\t\"address of conflict section\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_GNU_LIBLIST,      0x6FFFFEF9UL,\t\t\t\\\n\t\"address of conflict section\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_CONFIG,           0x6FFFFEFAUL,\t\t\t\\\n\t\"configuration file\")\t\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_DEPAUDIT,         0x6FFFFEFBUL,\t\t\t\\\n\t\"string defining audit libraries\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_AUDIT,            0x6FFFFEFCUL,\t\t\t\\\n\t\"string defining audit libraries\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_PLTPAD,           0x6FFFFEFDUL, \"PLT padding\")\t\\\n_ELF_DEFINE_DT(DT_MOVETAB,          0x6FFFFEFEUL,\t\t\t\\\n\t\"address of a move table\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_SYMINFO,          0x6FFFFEFFUL,\t\t\t\\\n\t\"address of the symbol information table\")\t\t\t\\\n_ELF_DEFINE_DT(DT_ADDRRNGHI,        0x6FFFFEFFUL,\t\t\t\\\n\t\"end of range using the d_ptr field\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_VERSYM,\t    0x6FFFFFF0UL,\t\t\t\\\n\t\"address of the version section\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_RELACOUNT,        0x6FFFFFF9UL,\t\t\t\\\n\t\"count of RELA relocations\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_RELCOUNT,         0x6FFFFFFAUL,\t\t\t\\\n\t\"count of REL relocations\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_FLAGS_1,          0x6FFFFFFBUL, \"flag values\")\t\\\n_ELF_DEFINE_DT(DT_VERDEF,\t    0x6FFFFFFCUL,\t\t\t\\\n\t\"address of the version definition segment\")\t\t\t\\\n_ELF_DEFINE_DT(DT_VERDEFNUM,\t    0x6FFFFFFDUL,\t\t\t\\\n\t\"the number of version definition entries\")\t\t\t\\\n_ELF_DEFINE_DT(DT_VERNEED,\t    0x6FFFFFFEUL,\t\t\t\\\n\t\"address of section with needed versions\")\t\t\t\\\n_ELF_DEFINE_DT(DT_VERNEEDNUM,       0x6FFFFFFFUL,\t\t\t\\\n\t\"the number of version needed entries\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_LOPROC,           0x70000000UL,\t\t\t\\\n\t\"start of processor-specific types\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_ARM_SYMTABSZ,\t    0x70000001UL,\t\t\t\\\n\t\"number of entries in the dynamic symbol table\")\t\t\\\n_ELF_DEFINE_DT(DT_SPARC_REGISTER,   0x70000001UL,\t\t\t\\\n\t\"index of an STT_SPARC_REGISTER symbol\")\t\t\t\\\n_ELF_DEFINE_DT(DT_ARM_PREEMPTMAP,   0x70000002UL,\t\t\t\\\n\t\"address of the preemption map\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_RLD_VERSION, 0x70000001UL,\t\t\t\\\n\t\"version ID for runtime linker interface\")\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_TIME_STAMP,  0x70000002UL,\t\t\t\\\n\t\"timestamp\")\t\t\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_ICHECKSUM,   0x70000003UL,\t\t\t\\\n\t\"checksum of all external strings and common sizes\")\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_IVERSION,    0x70000004UL,\t\t\t\\\n\t\"string table index of a version string\")\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_FLAGS,       0x70000005UL,\t\t\t\\\n\t\"MIPS-specific flags\")\t\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_BASE_ADDRESS, 0x70000006UL,\t\t\t\\\n\t\"base address for the executable/DSO\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_CONFLICT,    0x70000008UL,\t\t\t\\\n\t\"address of .conflict section\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_LIBLIST,     0x70000009UL,\t\t\t\\\n\t\"address of .liblist section\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_LOCAL_GOTNO, 0x7000000AUL,\t\t\t\\\n\t\"number of local GOT entries\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_CONFLICTNO,  0x7000000BUL,\t\t\t\\\n\t\"number of entries in the .conflict section\")\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_LIBLISTNO,   0x70000010UL,\t\t\t\\\n\t\"number of entries in the .liblist section\")\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_SYMTABNO,    0x70000011UL,\t\t\t\\\n\t\"number of entries in the .dynsym section\")\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_UNREFEXTNO,  0x70000012UL,\t\t\t\\\n\t\"index of first external dynamic symbol not ref'ed locally\")\t\\\n_ELF_DEFINE_DT(DT_MIPS_GOTSYM,      0x70000013UL,\t\t\t\\\n\t\"index of first dynamic symbol corresponds to a GOT entry\")\t\\\n_ELF_DEFINE_DT(DT_MIPS_HIPAGENO,    0x70000014UL,\t\t\t\\\n\t\"number of page table entries in GOT\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_RLD_MAP,     0x70000016UL,\t\t\t\\\n\t\"address of runtime linker map\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_DELTA_CLASS, 0x70000017UL,\t\t\t\\\n\t\"Delta C++ class definition\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_DELTA_CLASS_NO, 0x70000018UL,\t\t\t\\\n\t\"number of entries in DT_MIPS_DELTA_CLASS\")\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_DELTA_INSTANCE, 0x70000019UL,\t\t\t\\\n\t\"Delta C++ class instances\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_DELTA_INSTANCE_NO, 0x7000001AUL,\t\t\t\\\n\t\"number of entries in DT_MIPS_DELTA_INSTANCE\")\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_DELTA_RELOC, 0x7000001BUL,\t\t\t\\\n\t\"Delta relocations\")\t\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_DELTA_RELOC_NO, 0x7000001CUL,\t\t\t\\\n\t\"number of entries in DT_MIPS_DELTA_RELOC\")\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_DELTA_SYM,   0x7000001DUL,\t\t\t\\\n\t\"Delta symbols refered by Delta relocations\")\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_DELTA_SYM_NO, 0x7000001EUL,\t\t\t\\\n\t\"number of entries in DT_MIPS_DELTA_SYM\")\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_DELTA_CLASSSYM, 0x70000020UL,\t\t\t\\\n\t\"Delta symbols for class declarations\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_DELTA_CLASSSYM_NO, 0x70000021UL,\t\t\t\\\n\t\"number of entries in DT_MIPS_DELTA_CLASSSYM\")\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_CXX_FLAGS,   0x70000022UL,\t\t\t\\\n\t\"C++ flavor flags\")\t\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_PIXIE_INIT,  0x70000023UL,\t\t\t\\\n\t\"address of an initialization routine created by pixie\")\t\\\n_ELF_DEFINE_DT(DT_MIPS_SYMBOL_LIB,  0x70000024UL,\t\t\t\\\n\t\"address of .MIPS.symlib section\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_LOCALPAGE_GOTIDX, 0x70000025UL,\t\t\t\\\n\t\"GOT index of first page table entry for a segment\")\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_LOCAL_GOTIDX, 0x70000026UL,\t\t\t\\\n\t\"GOT index of first page table entry for a local symbol\")\t\\\n_ELF_DEFINE_DT(DT_MIPS_HIDDEN_GOTIDX, 0x70000027UL,\t\t\t\\\n\t\"GOT index of first page table entry for a hidden symbol\")\t\\\n_ELF_DEFINE_DT(DT_MIPS_PROTECTED_GOTIDX, 0x70000028UL,\t\t\t\\\n\t\"GOT index of first page table entry for a protected symbol\")\t\\\n_ELF_DEFINE_DT(DT_MIPS_OPTIONS,     0x70000029UL,\t\t\t\\\n\t\"address of .MIPS.options section\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_INTERFACE,   0x7000002AUL,\t\t\t\\\n\t\"address of .MIPS.interface section\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_DYNSTR_ALIGN, 0x7000002BUL, \"???\")\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_INTERFACE_SIZE, 0x7000002CUL,\t\t\t\\\n\t\"size of .MIPS.interface section\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_RLD_TEXT_RESOLVE_ADDR, 0x7000002DUL,\t\t\\\n\t\"address of _rld_text_resolve in GOT\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_PERF_SUFFIX, 0x7000002EUL,\t\t\t\\\n\t\"default suffix of DSO to be appended by dlopen\")\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_COMPACT_SIZE, 0x7000002FUL,\t\t\t\\\n\t\"size of a ucode compact relocation record (o32)\")\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_GP_VALUE,    0x70000030UL,\t\t\t\\\n\t\"GP value of a specified GP relative range\")\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_AUX_DYNAMIC, 0x70000031UL,\t\t\t\\\n\t\"address of an auxiliary dynamic table\")\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_PLTGOT,      0x70000032UL,\t\t\t\\\n\t\"address of the PLTGOT\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_RLD_OBJ_UPDATE, 0x70000033UL,\t\t\t\\\n\t\"object list update callback\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_MIPS_RWPLT,       0x70000034UL,\t\t\t\\\n\t\"address of a writable PLT\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_PPC_GOT,          0x70000000UL,\t\t\t\\\n\t\"value of _GLOBAL_OFFSET_TABLE_\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_PPC_TLSOPT,       0x70000001UL,\t\t\t\\\n\t\"TLS descriptor should be optimized\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_PPC64_GLINK,      0x70000000UL,\t\t\t\\\n\t\"address of .glink section\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_PPC64_OPD,        0x70000001UL,\t\t\t\\\n\t\"address of .opd section\")\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_PPC64_OPDSZ,      0x70000002UL,\t\t\t\\\n\t\"size of .opd section\")\t\t\t\t\t\t\\\n_ELF_DEFINE_DT(DT_PPC64_TLSOPT,     0x70000003UL,\t\t\t\\\n\t\"TLS descriptor should be optimized\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_AUXILIARY,        0x7FFFFFFDUL,\t\t\t\\\n\t\"offset of string naming auxiliary filtees\")\t\t\t\\\n_ELF_DEFINE_DT(DT_USED,             0x7FFFFFFEUL, \"ignored\")\t\t\\\n_ELF_DEFINE_DT(DT_FILTER,           0x7FFFFFFFUL,\t\t\t\\\n\t\"index of string naming filtees\")\t\t\t\t\\\n_ELF_DEFINE_DT(DT_HIPROC,           0x7FFFFFFFUL,\t\t\t\\\n\t\"end of processor-specific types\")\n\n#undef\t_ELF_DEFINE_DT\n#define\t_ELF_DEFINE_DT(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_DYN_TYPES()\n\tDT__LAST__ = DT_HIPROC\n};\n#ifndef DT_DEPRECATED_SPARC_REGISTER\n#define\tDT_DEPRECATED_SPARC_REGISTER\tDT_SPARC_REGISTER\n#endif\n\n/*\n * Flags used in the executable header (field: e_flags).\n */\n#define\t_ELF_DEFINE_EHDR_FLAGS()\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_ARM_RELEXEC,      0x00000001UL,\t\t\t\\\n\t\"dynamic segment describes only how to relocate segments\")\t\\\n_ELF_DEFINE_EF(EF_ARM_HASENTRY,     0x00000002UL,\t\t\t\\\n\t\"e_entry contains a program entry point\")\t\t\t\\\n_ELF_DEFINE_EF(EF_ARM_SYMSARESORTED, 0x00000004UL,\t\t\t\\\n\t\"subsection of symbol table is sorted by symbol value\")\t\t\\\n_ELF_DEFINE_EF(EF_ARM_DYNSYMSUSESEGIDX, 0x00000008UL,\t\t\t\\\n\t\"dynamic symbol st_shndx = containing segment index + 1\")\t\\\n_ELF_DEFINE_EF(EF_ARM_MAPSYMSFIRST, 0x00000010UL,\t\t\t\\\n\t\"mapping symbols precede other local symbols in symtab\")\t\\\n_ELF_DEFINE_EF(EF_ARM_BE8,          0x00800000UL,\t\t\t\\\n\t\"file contains BE-8 code\")\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_ARM_LE8,          0x00400000UL,\t\t\t\\\n\t\"file contains LE-8 code\")\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_ARM_EABIMASK,     0xFF000000UL,\t\t\t\\\n\t\"mask for ARM EABI version number (0 denotes GNU or unknown)\")\t\\\n_ELF_DEFINE_EF(EF_ARM_INTERWORK,    0x00000004UL,\t\t\t\\\n\t\"GNU EABI extension\")\t\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_ARM_APCS_26,      0x00000008UL,\t\t\t\\\n\t\"GNU EABI extension\")\t\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_ARM_APCS_FLOAT,   0x00000010UL,\t\t\t\\\n\t\"GNU EABI extension\")\t\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_ARM_PIC,          0x00000020UL,\t\t\t\\\n\t\"GNU EABI extension\")\t\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_ARM_ALIGN8,       0x00000040UL,\t\t\t\\\n\t\"GNU EABI extension\")\t\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_ARM_NEW_ABI,      0x00000080UL,\t\t\t\\\n\t\"GNU EABI extension\")\t\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_ARM_OLD_ABI,      0x00000100UL,\t\t\t\\\n\t\"GNU EABI extension\")\t\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_ARM_SOFT_FLOAT,   0x00000200UL,\t\t\t\\\n\t\"GNU EABI extension\")\t\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_ARM_VFP_FLOAT,    0x00000400UL,\t\t\t\\\n\t\"GNU EABI extension\")\t\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_ARM_MAVERICK_FLOAT, 0x00000800UL,\t\t\t\\\n\t\"GNU EABI extension\")\t\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_MIPS_NOREORDER,   0x00000001UL,\t\t\t\\\n\t\"at least one .noreorder directive appeared in the source\")\t\\\n_ELF_DEFINE_EF(EF_MIPS_PIC,         0x00000002UL,\t\t\t\\\n\t\"file contains position independent code\")\t\t\t\\\n_ELF_DEFINE_EF(EF_MIPS_CPIC,        0x00000004UL,\t\t\t\\\n\t\"file's code uses standard conventions for calling PIC\")\t\\\n_ELF_DEFINE_EF(EF_MIPS_UCODE,       0x00000010UL,\t\t\t\\\n\t\"file contains UCODE (obsolete)\")\t\t\t\t\\\n_ELF_DEFINE_EF(EF_MIPS_ABI2,        0x00000020UL,\t\t\t\\\n\t\"file follows MIPS III 32-bit ABI\")\t\t\t\t\\\n_ELF_DEFINE_EF(EF_MIPS_OPTIONS_FIRST, 0x00000080UL,\t\t\t\\\n\t\"ld(1) should process .MIPS.options section first\")\t\t\\\n_ELF_DEFINE_EF(EF_MIPS_ARCH_ASE,    0x0F000000UL,\t\t\t\\\n\t\"file uses application-specific architectural extensions\")\t\\\n_ELF_DEFINE_EF(EF_MIPS_ARCH_ASE_MDMX, 0x08000000UL,\t\t\t\\\n\t\"file uses MDMX multimedia extensions\")\t\t\t\t\\\n_ELF_DEFINE_EF(EF_MIPS_ARCH_ASE_M16, 0x04000000UL,\t\t\t\\\n\t\"file uses MIPS-16 ISA extensions\")\t\t\t\t\\\n_ELF_DEFINE_EF(EF_MIPS_ARCH,         0xF0000000UL,\t\t\t\\\n\t\"4-bit MIPS architecture field\")\t\t\t\t\\\n_ELF_DEFINE_EF(EF_SPARC_EXT_MASK,   0x00ffff00UL,\t\t\t\\\n\t\"Vendor Extension mask\")\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_SPARC_32PLUS,     0x00000100UL,\t\t\t\\\n\t\"Generic V8+ features\")\t\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_SPARC_SUN_US1,    0x00000200UL,\t\t\t\\\n\t\"Sun UltraSPARCTM 1 Extensions\")\t\t\t\t\\\n_ELF_DEFINE_EF(EF_SPARC_HAL_R1,     0x00000400UL, \"HAL R1 Extensions\")\t\\\n_ELF_DEFINE_EF(EF_SPARC_SUN_US3,    0x00000800UL,\t\t\t\\\n\t\"Sun UltraSPARC 3 Extensions\")\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_SPARCV9_MM,       0x00000003UL,\t\t\t\\\n\t\"Mask for Memory Model\")\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_SPARCV9_TSO,      0x00000000UL,\t\t\t\\\n\t\"Total Store Ordering\")\t\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_SPARCV9_PSO,      0x00000001UL,\t\t\t\\\n\t\"Partial Store Ordering\")\t\t\t\t\t\\\n_ELF_DEFINE_EF(EF_SPARCV9_RMO,      0x00000002UL,\t\t\t\\\n\t\"Relaxed Memory Ordering\")\n\n#undef\t_ELF_DEFINE_EF\n#define\t_ELF_DEFINE_EF(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_EHDR_FLAGS()\n\tEF__LAST__\n};\n\n/*\n * Offsets in the `ei_ident[]` field of an ELF executable header.\n */\n#define\t_ELF_DEFINE_EI_OFFSETS()\t\t\t\\\n_ELF_DEFINE_EI(EI_MAG0,     0, \"magic number\")\t\t\\\n_ELF_DEFINE_EI(EI_MAG1,     1, \"magic number\")\t\t\\\n_ELF_DEFINE_EI(EI_MAG2,     2, \"magic number\")\t\t\\\n_ELF_DEFINE_EI(EI_MAG3,     3, \"magic number\")\t\t\\\n_ELF_DEFINE_EI(EI_CLASS,    4, \"file class\")\t\t\\\n_ELF_DEFINE_EI(EI_DATA,     5, \"data encoding\")\t\t\\\n_ELF_DEFINE_EI(EI_VERSION,  6, \"file version\")\t\t\\\n_ELF_DEFINE_EI(EI_OSABI,    7, \"OS ABI kind\")\t\t\\\n_ELF_DEFINE_EI(EI_ABIVERSION, 8, \"OS ABI version\")\t\\\n_ELF_DEFINE_EI(EI_PAD,\t    9, \"padding start\")\t\t\\\n_ELF_DEFINE_EI(EI_NIDENT,  16, \"total size\")\n\n#undef\t_ELF_DEFINE_EI\n#define\t_ELF_DEFINE_EI(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_EI_OFFSETS()\n\tEI__LAST__\n};\n\n/*\n * The ELF class of an object.\n */\n#define\t_ELF_DEFINE_ELFCLASS()\t\t\t\t\\\n_ELF_DEFINE_EC(ELFCLASSNONE, 0, \"Unknown ELF class\")\t\\\n_ELF_DEFINE_EC(ELFCLASS32,   1, \"32 bit objects\")\t\\\n_ELF_DEFINE_EC(ELFCLASS64,   2, \"64 bit objects\")\n\n#undef\t_ELF_DEFINE_EC\n#define\t_ELF_DEFINE_EC(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_ELFCLASS()\n\tEC__LAST__\n};\n\n/*\n * Endianness of data in an ELF object.\n */\n\n#define\t_ELF_DEFINE_ELF_DATA_ENDIANNESS()\t\t\t\\\n_ELF_DEFINE_ED(ELFDATANONE, 0, \"Unknown data endianness\")\t\\\n_ELF_DEFINE_ED(ELFDATA2LSB, 1, \"little endian\")\t\t\t\\\n_ELF_DEFINE_ED(ELFDATA2MSB, 2, \"big endian\")\n\n#undef\t_ELF_DEFINE_ED\n#define\t_ELF_DEFINE_ED(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_ELF_DATA_ENDIANNESS()\n\tED__LAST__\n};\n\n/*\n * Values of the magic numbers used in identification array.\n */\n#define\t_ELF_DEFINE_ELF_MAGIC()\t\t\t\\\n_ELF_DEFINE_EMAG(ELFMAG0, 0x7FU)\t\t\\\n_ELF_DEFINE_EMAG(ELFMAG1, 'E')\t\t\t\\\n_ELF_DEFINE_EMAG(ELFMAG2, 'L')\t\t\t\\\n_ELF_DEFINE_EMAG(ELFMAG3, 'F')\n\n#undef\t_ELF_DEFINE_EMAG\n#define\t_ELF_DEFINE_EMAG(N, V)\t\tN = V ,\nenum {\n\t_ELF_DEFINE_ELF_MAGIC()\n\tELFMAG__LAST__\n};\n\n/*\n * ELF OS ABI field.\n */\n#define\t_ELF_DEFINE_ELF_OSABI()\t\t\t\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_NONE,       0,\t\t\t\t\\\n\t\"No extensions or unspecified\")\t\t\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_SYSV,       0, \"SYSV\")\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_HPUX,       1, \"Hewlett-Packard HP-UX\")\t\\\n_ELF_DEFINE_EABI(ELFOSABI_NETBSD,     2, \"NetBSD\")\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_GNU,        3, \"GNU\")\t\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_HURD,       4, \"GNU/HURD\")\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_86OPEN,     5, \"86Open Common ABI\")\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_SOLARIS,    6, \"Sun Solaris\")\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_AIX,        7, \"AIX\")\t\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_IRIX,       8, \"IRIX\")\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_FREEBSD,    9, \"FreeBSD\")\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_TRU64,      10, \"Compaq TRU64 UNIX\")\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_MODESTO,    11, \"Novell Modesto\")\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_OPENBSD,    12, \"Open BSD\")\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_OPENVMS,    13, \"Open VMS\")\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_NSK,        14,\t\t\t\t\\\n\t\"Hewlett-Packard Non-Stop Kernel\")\t\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_AROS,       15, \"Amiga Research OS\")\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_FENIXOS,    16,\t\t\t\t\\\n\t\"The FenixOS highly scalable multi-core OS\")\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_ARM_AEABI,  64,\t\t\t\t\\\n\t\"ARM specific symbol versioning extensions\")\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_ARM,        97, \"ARM ABI\")\t\t\t\\\n_ELF_DEFINE_EABI(ELFOSABI_AMD_OPENCL, 201, \"AMD OpenCL Runtime ABI\") \\\n_ELF_DEFINE_EABI(ELFOSABI_HSAIL,      202, \"AMD HSAIL Runtime ABI\") \\\n_ELF_DEFINE_EABI(ELFOSABI_AMDIL,      203, \"AMD CAL Runtime ABI\") \\\n_ELF_DEFINE_EABI(ELFOSABI_STANDALONE, 255,\t\t\t\t\\\n\t\"Standalone (embedded) application\")\n\n#undef\t_ELF_DEFINE_EABI\n#define\t_ELF_DEFINE_EABI(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_ELF_OSABI()\n\tELFOSABI__LAST__\n};\n#ifndef ELFOSABI_LINUX\n#define\tELFOSABI_LINUX\t\t\tELFOSABI_GNU\n#endif\n\n/*\n * ELF Machine types: (EM_*).\n */\n#define\t_ELF_DEFINE_ELF_MACHINES()\t\t\t\t\t\\\n_ELF_DEFINE_EM(EM_NONE,             0, \"No machine\")\t\t\t\\\n_ELF_DEFINE_EM(EM_M32,              1, \"AT&T WE 32100\")\t\t\t\\\n_ELF_DEFINE_EM(EM_SPARC,            2, \"SPARC\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_386,              3, \"Intel 80386\")\t\t\t\\\n_ELF_DEFINE_EM(EM_68K,              4, \"Motorola 68000\")\t\t\\\n_ELF_DEFINE_EM(EM_88K,              5, \"Motorola 88000\")\t\t\\\n_ELF_DEFINE_EM(EM_860,              7, \"Intel 80860\")\t\t\t\\\n_ELF_DEFINE_EM(EM_MIPS,             8, \"MIPS I Architecture\")\t\t\\\n_ELF_DEFINE_EM(EM_S370,             9, \"IBM System/370 Processor\")\t\\\n_ELF_DEFINE_EM(EM_MIPS_RS3_LE,      10, \"MIPS RS3000 Little-endian\")\t\\\n_ELF_DEFINE_EM(EM_PARISC,           15, \"Hewlett-Packard PA-RISC\")\t\\\n_ELF_DEFINE_EM(EM_VPP500,           17, \"Fujitsu VPP500\")\t\t\\\n_ELF_DEFINE_EM(EM_SPARC32PLUS,      18,\t\t\t\t\t\\\n\t\"Enhanced instruction set SPARC\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_960,              19, \"Intel 80960\")\t\t\t\\\n_ELF_DEFINE_EM(EM_PPC,              20, \"PowerPC\")\t\t\t\\\n_ELF_DEFINE_EM(EM_PPC64,            21, \"64-bit PowerPC\")\t\t\\\n_ELF_DEFINE_EM(EM_S390,             22, \"IBM System/390 Processor\")\t\\\n_ELF_DEFINE_EM(EM_SPU,              23, \"IBM SPU/SPC\")\t\t\t\\\n_ELF_DEFINE_EM(EM_V800,             36, \"NEC V800\")\t\t\t\\\n_ELF_DEFINE_EM(EM_FR20,             37, \"Fujitsu FR20\")\t\t\t\\\n_ELF_DEFINE_EM(EM_RH32,             38, \"TRW RH-32\")\t\t\t\\\n_ELF_DEFINE_EM(EM_RCE,              39, \"Motorola RCE\")\t\t\t\\\n_ELF_DEFINE_EM(EM_ARM,              40, \"Advanced RISC Machines ARM\")\t\\\n_ELF_DEFINE_EM(EM_ALPHA,            41, \"Digital Alpha\")\t\t\\\n_ELF_DEFINE_EM(EM_SH,               42, \"Hitachi SH\")\t\t\t\\\n_ELF_DEFINE_EM(EM_SPARCV9,          43, \"SPARC Version 9\")\t\t\\\n_ELF_DEFINE_EM(EM_TRICORE,          44,\t\t\t\t\t\\\n\t\"Siemens TriCore embedded processor\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_ARC,              45,\t\t\t\t\t\\\n\t\"Argonaut RISC Core, Argonaut Technologies Inc.\")\t\t\\\n_ELF_DEFINE_EM(EM_H8_300,           46, \"Hitachi H8/300\")\t\t\\\n_ELF_DEFINE_EM(EM_H8_300H,          47, \"Hitachi H8/300H\")\t\t\\\n_ELF_DEFINE_EM(EM_H8S,              48, \"Hitachi H8S\")\t\t\t\\\n_ELF_DEFINE_EM(EM_H8_500,           49, \"Hitachi H8/500\")\t\t\\\n_ELF_DEFINE_EM(EM_IA_64,            50,\t\t\t\t\t\\\n\t\"Intel IA-64 processor architecture\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_MIPS_X,           51, \"Stanford MIPS-X\")\t\t\\\n_ELF_DEFINE_EM(EM_COLDFIRE,         52, \"Motorola ColdFire\")\t\t\\\n_ELF_DEFINE_EM(EM_68HC12,           53, \"Motorola M68HC12\")\t\t\\\n_ELF_DEFINE_EM(EM_MMA,              54,\t\t\t\t\t\\\n\t\"Fujitsu MMA Multimedia Accelerator\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_PCP,              55, \"Siemens PCP\")\t\t\t\\\n_ELF_DEFINE_EM(EM_NCPU,             56,\t\t\t\t\t\\\n\t\"Sony nCPU embedded RISC processor\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_NDR1,             57, \"Denso NDR1 microprocessor\")\t\\\n_ELF_DEFINE_EM(EM_STARCORE,         58, \"Motorola Star*Core processor\")\t\\\n_ELF_DEFINE_EM(EM_ME16,             59, \"Toyota ME16 processor\")\t\\\n_ELF_DEFINE_EM(EM_ST100,            60,\t\t\t\t\t\\\n\t\"STMicroelectronics ST100 processor\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_TINYJ,            61,\t\t\t\t\t\\\n\t\"Advanced Logic Corp. TinyJ embedded processor family\")\t\t\\\n_ELF_DEFINE_EM(EM_X86_64,           62, \"AMD x86-64 architecture\")\t\\\n_ELF_DEFINE_EM(EM_PDSP,             63, \"Sony DSP Processor\")\t\t\\\n_ELF_DEFINE_EM(EM_PDP10,            64,\t\t\t\t\t\\\n\t\"Digital Equipment Corp. PDP-10\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_PDP11,            65,\t\t\t\t\t\\\n\t\"Digital Equipment Corp. PDP-11\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_FX66,             66, \"Siemens FX66 microcontroller\")\t\\\n_ELF_DEFINE_EM(EM_ST9PLUS,          67,\t\t\t\t\t\\\n\t\"STMicroelectronics ST9+ 8/16 bit microcontroller\")\t\t\\\n_ELF_DEFINE_EM(EM_ST7,              68,\t\t\t\t\t\\\n\t\"STMicroelectronics ST7 8-bit microcontroller\")\t\t\t\\\n_ELF_DEFINE_EM(EM_68HC16,           69,\t\t\t\t\t\\\n\t\"Motorola MC68HC16 Microcontroller\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_68HC11,           70,\t\t\t\t\t\\\n\t\"Motorola MC68HC11 Microcontroller\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_68HC08,           71,\t\t\t\t\t\\\n\t\"Motorola MC68HC08 Microcontroller\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_68HC05,           72,\t\t\t\t\t\\\n\t\"Motorola MC68HC05 Microcontroller\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_SVX,              73, \"Silicon Graphics SVx\")\t\t\\\n_ELF_DEFINE_EM(EM_ST19,             74,\t\t\t\t\t\\\n\t\"STMicroelectronics ST19 8-bit microcontroller\")\t\t\\\n_ELF_DEFINE_EM(EM_VAX,              75, \"Digital VAX\")\t\t\t\\\n_ELF_DEFINE_EM(EM_CRIS,             76,\t\t\t\t\t\\\n\t\"Axis Communications 32-bit embedded processor\")\t\t\\\n_ELF_DEFINE_EM(EM_JAVELIN,          77,\t\t\t\t\t\\\n\t\"Infineon Technologies 32-bit embedded processor\")\t\t\\\n_ELF_DEFINE_EM(EM_FIREPATH,         78,\t\t\t\t\t\\\n\t\"Element 14 64-bit DSP Processor\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_ZSP,              79,\t\t\t\t\t\\\n\t\"LSI Logic 16-bit DSP Processor\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_MMIX,             80,\t\t\t\t\t\\\n\t\"Donald Knuth's educational 64-bit processor\")\t\t\t\\\n_ELF_DEFINE_EM(EM_HUANY,            81,\t\t\t\t\t\\\n\t\"Harvard University machine-independent object files\")\t\t\\\n_ELF_DEFINE_EM(EM_PRISM,            82, \"SiTera Prism\")\t\t\t\\\n_ELF_DEFINE_EM(EM_AVR,              83,\t\t\t\t\t\\\n\t\"Atmel AVR 8-bit microcontroller\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_FR30,             84, \"Fujitsu FR30\")\t\t\t\\\n_ELF_DEFINE_EM(EM_D10V,             85, \"Mitsubishi D10V\")\t\t\\\n_ELF_DEFINE_EM(EM_D30V,             86, \"Mitsubishi D30V\")\t\t\\\n_ELF_DEFINE_EM(EM_V850,             87, \"NEC v850\")\t\t\t\\\n_ELF_DEFINE_EM(EM_M32R,             88, \"Mitsubishi M32R\")\t\t\\\n_ELF_DEFINE_EM(EM_MN10300,          89, \"Matsushita MN10300\")\t\t\\\n_ELF_DEFINE_EM(EM_MN10200,          90, \"Matsushita MN10200\")\t\t\\\n_ELF_DEFINE_EM(EM_PJ,               91, \"picoJava\")\t\t\t\\\n_ELF_DEFINE_EM(EM_OPENRISC,         92,\t\t\t\t\t\\\n\t\"OpenRISC 32-bit embedded processor\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_ARC_COMPACT,      93,\t\t\t\t\t\\\n\t\"ARC International ARCompact processor\")\t\t\t\\\n_ELF_DEFINE_EM(EM_XTENSA,           94,\t\t\t\t\t\\\n\t\"Tensilica Xtensa Architecture\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_VIDEOCORE,        95,\t\t\t\t\t\\\n\t\"Alphamosaic VideoCore processor\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_TMM_GPP,          96,\t\t\t\t\t\\\n\t\"Thompson Multimedia General Purpose Processor\")\t\t\\\n_ELF_DEFINE_EM(EM_NS32K,            97,\t\t\t\t\t\\\n\t\"National Semiconductor 32000 series\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_TPC,              98, \"Tenor Network TPC processor\")\t\\\n_ELF_DEFINE_EM(EM_SNP1K,            99, \"Trebia SNP 1000 processor\")\t\\\n_ELF_DEFINE_EM(EM_ST200,            100,\t\t\t\t\\\n\t\"STMicroelectronics (www.st.com) ST200 microcontroller\")\t\\\n_ELF_DEFINE_EM(EM_IP2K,             101,\t\t\t\t\\\n\t\"Ubicom IP2xxx microcontroller family\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_MAX,              102, \"MAX Processor\")\t\t\\\n_ELF_DEFINE_EM(EM_CR,               103,\t\t\t\t\\\n\t\"National Semiconductor CompactRISC microprocessor\")\t\t\\\n_ELF_DEFINE_EM(EM_F2MC16,           104, \"Fujitsu F2MC16\")\t\t\\\n_ELF_DEFINE_EM(EM_MSP430,           105,\t\t\t\t\\\n\t\"Texas Instruments embedded microcontroller msp430\")\t\t\\\n_ELF_DEFINE_EM(EM_BLACKFIN,         106,\t\t\t\t\\\n\t\"Analog Devices Blackfin (DSP) processor\")\t\t\t\\\n_ELF_DEFINE_EM(EM_SE_C33,           107,\t\t\t\t\\\n\t\"S1C33 Family of Seiko Epson processors\")\t\t\t\\\n_ELF_DEFINE_EM(EM_SEP,              108,\t\t\t\t\\\n\t\"Sharp embedded microprocessor\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_ARCA,             109, \"Arca RISC Microprocessor\")\t\\\n_ELF_DEFINE_EM(EM_UNICORE,          110,\t\t\t\t\\\n\t\"Microprocessor series from PKU-Unity Ltd. and MPRC of Peking University\") \\\n_ELF_DEFINE_EM(EM_EXCESS,           111,\t\t\t\t\\\n\t\"eXcess: 16/32/64-bit configurable embedded CPU\")\t\t\\\n_ELF_DEFINE_EM(EM_DXP,              112,\t\t\t\t\\\n\t\"Icera Semiconductor Inc. Deep Execution Processor\")\t\t\\\n_ELF_DEFINE_EM(EM_ALTERA_NIOS2,     113,\t\t\t\t\\\n\t\"Altera Nios II soft-core processor\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_CRX,              114,\t\t\t\t\\\n\t\"National Semiconductor CompactRISC CRX microprocessor\")\t\\\n_ELF_DEFINE_EM(EM_XGATE,            115,\t\t\t\t\\\n\t\"Motorola XGATE embedded processor\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_C166,             116,\t\t\t\t\\\n\t\"Infineon C16x/XC16x processor\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_M16C,             117,\t\t\t\t\\\n\t\"Renesas M16C series microprocessors\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_DSPIC30F,         118,\t\t\t\t\\\n\t\"Microchip Technology dsPIC30F Digital Signal Controller\")\t\\\n_ELF_DEFINE_EM(EM_CE,               119,\t\t\t\t\\\n\t\"Freescale Communication Engine RISC core\")\t\t\t\\\n_ELF_DEFINE_EM(EM_M32C,             120,\t\t\t\t\\\n\t\"Renesas M32C series microprocessors\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_TSK3000,          131, \"Altium TSK3000 core\")\t\t\\\n_ELF_DEFINE_EM(EM_RS08,             132,\t\t\t\t\\\n\t\"Freescale RS08 embedded processor\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_SHARC,            133,\t\t\t\t\\\n\t\"Analog Devices SHARC family of 32-bit DSP processors\")\t\t\\\n_ELF_DEFINE_EM(EM_ECOG2,            134,\t\t\t\t\\\n\t\"Cyan Technology eCOG2 microprocessor\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_SCORE7,           135,\t\t\t\t\\\n\t\"Sunplus S+core7 RISC processor\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_DSP24,            136,\t\t\t\t\\\n\t\"New Japan Radio (NJR) 24-bit DSP Processor\")\t\t\t\\\n_ELF_DEFINE_EM(EM_VIDEOCORE3,       137,\t\t\t\t\\\n\t\"Broadcom VideoCore III processor\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_LATTICEMICO32,    138,\t\t\t\t\\\n\t\"RISC processor for Lattice FPGA architecture\")\t\t\t\\\n_ELF_DEFINE_EM(EM_SE_C17,           139, \"Seiko Epson C17 family\")\t\\\n_ELF_DEFINE_EM(EM_TI_C6000,         140,\t\t\t\t\\\n\t\"The Texas Instruments TMS320C6000 DSP family\")\t\t\t\\\n_ELF_DEFINE_EM(EM_TI_C2000,         141,\t\t\t\t\\\n\t\"The Texas Instruments TMS320C2000 DSP family\")\t\t\t\\\n_ELF_DEFINE_EM(EM_TI_C5500,         142,\t\t\t\t\\\n\t\"The Texas Instruments TMS320C55x DSP family\")\t\t\t\\\n_ELF_DEFINE_EM(EM_MMDSP_PLUS,       160,\t\t\t\t\\\n\t\"STMicroelectronics 64bit VLIW Data Signal Processor\")\t\t\\\n_ELF_DEFINE_EM(EM_CYPRESS_M8C,      161, \"Cypress M8C microprocessor\")\t\\\n_ELF_DEFINE_EM(EM_R32C,             162,\t\t\t\t\\\n\t\"Renesas R32C series microprocessors\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_TRIMEDIA,         163,\t\t\t\t\\\n\t\"NXP Semiconductors TriMedia architecture family\")\t\t\\\n_ELF_DEFINE_EM(EM_QDSP6,            164, \"QUALCOMM DSP6 Processor\")\t\\\n_ELF_DEFINE_EM(EM_8051,             165, \"Intel 8051 and variants\")\t\\\n_ELF_DEFINE_EM(EM_STXP7X,           166,\t\t\t\t\\\n\t\"STMicroelectronics STxP7x family of configurable and extensible RISC processors\") \\\n_ELF_DEFINE_EM(EM_NDS32,            167,\t\t\t\t\\\n\t\"Andes Technology compact code size embedded RISC processor family\") \\\n_ELF_DEFINE_EM(EM_ECOG1,            168,\t\t\t\t\\\n\t\"Cyan Technology eCOG1X family\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_ECOG1X,           168,\t\t\t\t\\\n\t\"Cyan Technology eCOG1X family\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_MAXQ30,           169,\t\t\t\t\\\n\t\"Dallas Semiconductor MAXQ30 Core Micro-controllers\")\t\t\\\n_ELF_DEFINE_EM(EM_XIMO16,           170,\t\t\t\t\\\n\t\"New Japan Radio (NJR) 16-bit DSP Processor\")\t\t\t\\\n_ELF_DEFINE_EM(EM_MANIK,            171,\t\t\t\t\\\n\t\"M2000 Reconfigurable RISC Microprocessor\")\t\t\t\\\n_ELF_DEFINE_EM(EM_CRAYNV2,          172,\t\t\t\t\\\n\t\"Cray Inc. NV2 vector architecture\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_RX,               173, \"Renesas RX family\")\t\t\\\n_ELF_DEFINE_EM(EM_METAG,            174,\t\t\t\t\\\n\t\"Imagination Technologies META processor architecture\")\t\t\\\n_ELF_DEFINE_EM(EM_MCST_ELBRUS,      175,\t\t\t\t\\\n\t\"MCST Elbrus general purpose hardware architecture\")\t\t\\\n_ELF_DEFINE_EM(EM_ECOG16,           176,\t\t\t\t\\\n\t\"Cyan Technology eCOG16 family\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_CR16,             177,\t\t\t\t\\\n\t\"National Semiconductor CompactRISC CR16 16-bit microprocessor\") \\\n_ELF_DEFINE_EM(EM_ETPU,             178,\t\t\t\t\\\n\t\"Freescale Extended Time Processing Unit\")\t\t\t\\\n_ELF_DEFINE_EM(EM_SLE9X,            179,\t\t\t\t\\\n\t\"Infineon Technologies SLE9X core\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_AVR32,            185,\t\t\t\t\\\n\t\"Atmel Corporation 32-bit microprocessor family\")\t\t\\\n_ELF_DEFINE_EM(EM_STM8,             186,\t\t\t\t\\\n\t\"STMicroeletronics STM8 8-bit microcontroller\")\t\t\t\\\n_ELF_DEFINE_EM(EM_TILE64,           187,\t\t\t\t\\\n\t\"Tilera TILE64 multicore architecture family\")\t\t\t\\\n_ELF_DEFINE_EM(EM_TILEPRO,          188,\t\t\t\t\\\n\t\"Tilera TILEPro multicore architecture family\")\t\t\t\\\n_ELF_DEFINE_EM(EM_MICROBLAZE,       189,\t\t\t\t\\\n\t\"Xilinx MicroBlaze 32-bit RISC soft processor core\")\t\t\\\n_ELF_DEFINE_EM(EM_CUDA,             190, \"NVIDIA CUDA architecture\")\t\\\n_ELF_DEFINE_EM(EM_TILEGX,           191,\t\t\t\t\\\n\t\"Tilera TILE-Gx multicore architecture family\")\t\t\t\\\n_ELF_DEFINE_EM(EM_CLOUDSHIELD,      192,\t\t\t\t\\\n\t\"CloudShield architecture family\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_COREA_1ST,        193,\t\t\t\t\\\n\t\"KIPO-KAIST Core-A 1st generation processor family\")\t\t\\\n_ELF_DEFINE_EM(EM_COREA_2ND,        194,\t\t\t\t\\\n\t\"KIPO-KAIST Core-A 2nd generation processor family\")\t\t\\\n_ELF_DEFINE_EM(EM_ARC_COMPACT2,     195, \"Synopsys ARCompact V2\")\t\\\n_ELF_DEFINE_EM(EM_OPEN8,            196,\t\t\t\t\\\n\t\"Open8 8-bit RISC soft processor core\")\t\t\t\t\\\n_ELF_DEFINE_EM(EM_RL78,             197, \"Renesas RL78 family\")\t\t\\\n_ELF_DEFINE_EM(EM_VIDEOCORE5,       198, \"Broadcom VideoCore V processor\") \\\n_ELF_DEFINE_EM(EM_78KOR,            199, \"Renesas 78KOR family\") \\\n_ELF_DEFINE_EM(EM_AMDIL,         0x4154, \"AMD Intermediate Language Target\") \\\n_ELF_DEFINE_EM(EM_HSAIL,         0xAF5A, \"HSA Intermediate Language Target\") \\\n_ELF_DEFINE_EM(EM_AMDIL_64,      0x4155, \"AMD64 Intermediate Language Target\") \\\n_ELF_DEFINE_EM(EM_HSAIL_64,      0xAF5B, \"HSA64 Intermediate Language Target\") \\\n_ELF_DEFINE_EM(EM_ARM_64,        0xAA64, \"Advanced RISC Machines ARM 64\")\n\n\n#undef\t_ELF_DEFINE_EM\n#define\t_ELF_DEFINE_EM(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_ELF_MACHINES()\n\tEM__LAST__\n};\n\n/* Older synonyms. */\n#ifndef EM_ARC_A5\n#define\tEM_ARC_A5\t\tEM_ARC_COMPACT\n#endif\n\n/*\n * ELF file types: (ET_*).\n */\n#define\t_ELF_DEFINE_ELF_TYPES()\t\t\t\t\t\t\\\n_ELF_DEFINE_ET(ET_NONE,   0,\t    \"No file type\")\t\t\t\\\n_ELF_DEFINE_ET(ET_REL,    1, \t    \"Relocatable object\")\t\t\\\n_ELF_DEFINE_ET(ET_EXEC,   2, \t    \"Executable\")\t\t\t\\\n_ELF_DEFINE_ET(ET_DYN,    3, \t    \"Shared object\")\t\t\t\\\n_ELF_DEFINE_ET(ET_CORE,   4, \t    \"Core file\")\t\t\t\\\n_ELF_DEFINE_ET(ET_LOOS,   0xFE00U,  \"Begin OS-specific range\")\t\t\\\n_ELF_DEFINE_ET(ET_HIOS,   0xFEFFU,  \"End OS-specific range\")\t\t\\\n_ELF_DEFINE_ET(ET_LOPROC, 0xFF00U,  \"Begin processor-specific range\")\t\\\n_ELF_DEFINE_ET(ET_HIPROC, 0xFFFFU,  \"End processor-specific range\")\n\n#undef\t_ELF_DEFINE_ET\n#define\t_ELF_DEFINE_ET(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_ELF_TYPES()\n\tET__LAST__\n};\n\n/* ELF file format version numbers. */\n#define\tEV_NONE\t\t0\n#define\tEV_CURRENT\t1\n\n/*\n * Flags for section groups.\n */\n#define\tGRP_COMDAT \t0x1\t\t/* COMDAT semantics */\n#define\tGRP_MASKOS \t0x0ff00000\t/* OS-specific flags */\n#define\tGRP_MASKPROC \t0xf0000000\t/* processor-specific flags */\n\n/*\n * Flags used by program header table entries.\n */\n\n#define\t_ELF_DEFINE_PHDR_FLAGS()\t\t\t\t\t\\\n_ELF_DEFINE_PF(PF_X,                0x1, \"Execute\")\t\t\t\\\n_ELF_DEFINE_PF(PF_W,                0x2, \"Write\")\t\t\t\\\n_ELF_DEFINE_PF(PF_R,                0x4, \"Read\")\t\t\t\\\n_ELF_DEFINE_PF(PF_MASKOS,           0x0ff00000, \"OS-specific flags\")\t\\\n_ELF_DEFINE_PF(PF_MASKPROC,         0xf0000000, \"Processor-specific flags\") \\\n_ELF_DEFINE_PF(PF_ARM_SB,           0x10000000,\t\t\t\t\\\n\t\"segment contains the location addressed by the static base\")\t\\\n_ELF_DEFINE_PF(PF_ARM_PI,           0x20000000,\t\t\t\t\\\n\t\"segment is position-independent\")\t\t\t\t\\\n_ELF_DEFINE_PF(PF_ARM_ABS,          0x40000000,\t\t\t\t\\\n\t\"segment must be loaded at its base address\")\n\n#undef\t_ELF_DEFINE_PF\n#define\t_ELF_DEFINE_PF(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_PHDR_FLAGS()\n\tPF__LAST__\n};\n\n/*\n * Types of program header table entries.\n */\n\n#define\t_ELF_DEFINE_PHDR_TYPES()\t\t\t\t\\\n_ELF_DEFINE_PT(PT_NULL,             0, \"ignored entry\")\t\t\\\n_ELF_DEFINE_PT(PT_LOAD,             1, \"loadable segment\")\t\\\n_ELF_DEFINE_PT(PT_DYNAMIC,          2,\t\t\t\t\\\n\t\"contains dynamic linking information\")\t\t\t\\\n_ELF_DEFINE_PT(PT_INTERP,           3, \"names an interpreter\")\t\\\n_ELF_DEFINE_PT(PT_NOTE,             4, \"auxiliary information\")\t\\\n_ELF_DEFINE_PT(PT_SHLIB,            5, \"reserved\")\t\t\\\n_ELF_DEFINE_PT(PT_PHDR,             6,\t\t\t\t\\\n\t\"describes the program header itself\")\t\t\t\\\n_ELF_DEFINE_PT(PT_TLS,              7, \"thread local storage\")\t\\\n_ELF_DEFINE_PT(PT_LOOS,             0x60000000UL,\t\t\\\n\t\"start of OS-specific range\")\t\t\t\t\\\n_ELF_DEFINE_PT(PT_GNU_EH_FRAME,     0x6474E550UL,\t\t\\\n\t\"GCC generated .eh_frame_hdr segment \")\t\t\t\\\n_ELF_DEFINE_PT(PT_GNU_STACK,\t    0x6474E551UL,\t\t\\\n\t\"Stack flags\")\t\t\t\t\t\t\\\n_ELF_DEFINE_PT(PT_GNU_RELRO,\t    0x6474E552UL,\t\t\\\n\t\"Segment becomes read-only after relocation\")\t\t\\\n_ELF_DEFINE_PT(PT_HIOS,             0x6FFFFFFFUL,\t\t\\\n\t\"end of OS-specific range\")\t\t\t\t\\\n_ELF_DEFINE_PT(PT_LOPROC,           0x70000000UL,\t\t\\\n\t\"start of processor-specific range\")\t\t\t\\\n_ELF_DEFINE_PT(PT_ARM_ARCHEXT,      0x70000000UL,\t\t\\\n\t\"platform architecture compatibility information\")\t\\\n_ELF_DEFINE_PT(PT_ARM_EXIDX,        0x70000001UL,\t\t\\\n\t\"exception unwind tables\")\t\t\t\t\\\n_ELF_DEFINE_PT(PT_MIPS_REGINFO,     0x70000000UL,\t\t\\\n\t\"register usage information\")\t\t\t\t\\\n_ELF_DEFINE_PT(PT_MIPS_RTPROC,      0x70000001UL,\t\t\\\n\t\"runtime procedure table\")\t\t\t\t\\\n_ELF_DEFINE_PT(PT_MIPS_OPTIONS,     0x70000002UL,\t\t\\\n\t\"options segment\")\t\t\t\t\t\\\n_ELF_DEFINE_PT(PT_HIPROC,           0x7FFFFFFFUL,\t\t\\\n\t\"end of processor-specific range\")\n\n#undef\t_ELF_DEFINE_PT\n#define\t_ELF_DEFINE_PT(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_PHDR_TYPES()\n\tPT__LAST__ = PT_HIPROC\n};\n\n/* synonyms. */\n#define\tPT_ARM_UNWIND\tPT_ARM_EXIDX\n\n/*\n * Section flags.\n */\n\n#define\t_ELF_DEFINE_SECTION_FLAGS()\t\t\t\t\t\\\n_ELF_DEFINE_SHF(SHF_WRITE,           0x1,\t\t\t\t\\\n\t\"writable during program execution\")\t\t\t\t\\\n_ELF_DEFINE_SHF(SHF_ALLOC,           0x2,\t\t\t\t\\\n\t\"occupies memory during program execution\")\t\t\t\\\n_ELF_DEFINE_SHF(SHF_EXECINSTR,       0x4, \"executable instructions\")\t\\\n_ELF_DEFINE_SHF(SHF_MERGE,           0x10,\t\t\t\t\\\n\t\"may be merged to prevent duplication\")\t\t\t\t\\\n_ELF_DEFINE_SHF(SHF_STRINGS,         0x20,\t\t\t\t\\\n\t\"NUL-terminated character strings\")\t\t\t\t\\\n_ELF_DEFINE_SHF(SHF_INFO_LINK,       0x40,\t\t\t\t\\\n\t\"the sh_info field holds a link\")\t\t\t\t\\\n_ELF_DEFINE_SHF(SHF_LINK_ORDER,      0x80,\t\t\t\t\\\n\t\"special ordering requirements during linking\")\t\t\t\\\n_ELF_DEFINE_SHF(SHF_OS_NONCONFORMING, 0x100,\t\t\t\t\\\n\t\"requires OS-specific processing during linking\")\t\t\\\n_ELF_DEFINE_SHF(SHF_GROUP,           0x200,\t\t\t\t\\\n\t\"member of a section group\")\t\t\t\t\t\\\n_ELF_DEFINE_SHF(SHF_TLS,             0x400,\t\t\t\t\\\n\t\"holds thread-local storage\")\t\t\t\t\t\\\n_ELF_DEFINE_SHF(SHF_MASKOS,          0x0FF00000UL,\t\t\t\\\n\t\"bits reserved for OS-specific semantics\")\t\t\t\\\n_ELF_DEFINE_SHF(SHF_AMD64_LARGE,     0x10000000UL,\t\t\t\\\n\t\"section uses large code model\")\t\t\t\t\\\n_ELF_DEFINE_SHF(SHF_ENTRYSECT,       0x10000000UL,\t\t\t\\\n\t\"section contains an entry point (ARM)\")\t\t\t\\\n_ELF_DEFINE_SHF(SHF_COMDEF,          0x80000000UL,\t\t\t\\\n\t\"section may be multiply defined in input to link step (ARM)\")\t\\\n_ELF_DEFINE_SHF(SHF_MIPS_GPREL,      0x10000000UL,\t\t\t\\\n\t\"section must be part of global data area\")\t\t\t\\\n_ELF_DEFINE_SHF(SHF_MIPS_MERGE,      0x20000000UL,\t\t\t\\\n\t\"section data should be merged to eliminate duplication\")\t\\\n_ELF_DEFINE_SHF(SHF_MIPS_ADDR,       0x40000000UL,\t\t\t\\\n\t\"section data is addressed by default\")\t\t\t\t\\\n_ELF_DEFINE_SHF(SHF_MIPS_STRING,     0x80000000UL,\t\t\t\\\n\t\"section data is string data by default\")\t\t\t\\\n_ELF_DEFINE_SHF(SHF_MIPS_NOSTRIP,    0x08000000UL,\t\t\t\\\n\t\"section data may not be stripped\")\t\t\t\t\\\n_ELF_DEFINE_SHF(SHF_MIPS_LOCAL,      0x04000000UL,\t\t\t\\\n\t\"section data local to process\")\t\t\t\t\\\n_ELF_DEFINE_SHF(SHF_MIPS_NAMES,      0x02000000UL,\t\t\t\\\n\t\"linker must generate implicit hidden weak names\")\t\t\\\n_ELF_DEFINE_SHF(SHF_MIPS_NODUPE,     0x01000000UL,\t\t\t\\\n\t\"linker must retain only one copy\")\t\t\t\t\\\n_ELF_DEFINE_SHF(SHF_ORDERED,         0x40000000UL,\t\t\t\\\n\t\"section is ordered with respect to other sections\")\t\t\\\n_ELF_DEFINE_SHF(SHF_EXCLUDE,\t     0x80000000UL,\t\t\t\\\n\t\"section is excluded from executables and shared objects\")\t\\\n_ELF_DEFINE_SHF(SHF_MASKPROC,        0xF0000000UL,\t\t\t\\\n\t\"bits reserved for processor-specific semantics\")\n\n#undef\t_ELF_DEFINE_SHF\n#define\t_ELF_DEFINE_SHF(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_SECTION_FLAGS()\n\tSHF__LAST__\n};\n\n/*\n * Special section indices.\n */\n#define _ELF_DEFINE_SECTION_INDICES()\t\t\t\t\t\\\n_ELF_DEFINE_SHN(SHN_UNDEF, \t0, \t \"undefined section\")\t\t\\\n_ELF_DEFINE_SHN(SHN_LORESERVE, \t0xFF00U, \"start of reserved area\")\t\\\n_ELF_DEFINE_SHN(SHN_LOPROC, \t0xFF00U,\t\t\t\t\\\n\t\"start of processor-specific range\")\t\t\t\t\\\n_ELF_DEFINE_SHN(SHN_BEFORE,\t0xFF00U, \"used for section ordering\")\t\\\n_ELF_DEFINE_SHN(SHN_AFTER,\t0xFF01U, \"used for section ordering\")\t\\\n_ELF_DEFINE_SHN(SHN_AMD64_LCOMMON, 0xFF02U, \"large common block label\") \\\n_ELF_DEFINE_SHN(SHN_MIPS_ACOMMON, 0xFF00U,\t\t\t\t\\\n\t\"allocated common symbols in a DSO\")\t\t\t\t\\\n_ELF_DEFINE_SHN(SHN_MIPS_TEXT,\t0xFF01U, \"Reserved (obsolete)\")\t\t\\\n_ELF_DEFINE_SHN(SHN_MIPS_DATA,\t0xFF02U, \"Reserved (obsolete)\")\t\t\\\n_ELF_DEFINE_SHN(SHN_MIPS_SCOMMON, 0xFF03U,\t\t\t\t\\\n\t\"gp-addressable common symbols\")\t\t\t\t\\\n_ELF_DEFINE_SHN(SHN_MIPS_SUNDEFINED, 0xFF04U,\t\t\t\t\\\n\t\"gp-addressable undefined symbols\")\t\t\t\t\\\n_ELF_DEFINE_SHN(SHN_MIPS_LCOMMON, 0xFF05U, \"local common symbols\")\t\\\n_ELF_DEFINE_SHN(SHN_MIPS_LUNDEFINED, 0xFF06U,\t\t\t\t\\\n\t\"local undefined symbols\")\t\t\t\t\t\\\n_ELF_DEFINE_SHN(SHN_HIPROC, \t0xFF1FU,\t\t\t\t\\\n\t\"end of processor-specific range\")\t\t\t\t\\\n_ELF_DEFINE_SHN(SHN_LOOS, \t0xFF20U,\t\t\t\t\\\n\t\"start of OS-specific range\")\t\t\t\t\t\\\n_ELF_DEFINE_SHN(SHN_SUNW_IGNORE, 0xFF3FU, \"used by dtrace\")\t\t\\\n_ELF_DEFINE_SHN(SHN_HIOS, \t0xFF3FU,\t\t\t\t\\\n\t\"end of OS-specific range\")\t\t\t\t\t\\\n_ELF_DEFINE_SHN(SHN_ABS, \t0xFFF1U, \"absolute references\")\t\t\\\n_ELF_DEFINE_SHN(SHN_COMMON, \t0xFFF2U, \"references to COMMON areas\")\t\\\n_ELF_DEFINE_SHN(SHN_XINDEX, \t0xFFFFU, \"extended index\")\t\t\\\n_ELF_DEFINE_SHN(SHN_HIRESERVE, \t0xFFFFU, \"end of reserved area\")\n\n#undef\t_ELF_DEFINE_SHN\n#define\t_ELF_DEFINE_SHN(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_SECTION_INDICES()\n\tSHN__LAST__\n};\n\n/*\n * Section types.\n */\n\n#define\t_ELF_DEFINE_SECTION_TYPES()\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_NULL,            0, \"inactive header\")\t\t\\\n_ELF_DEFINE_SHT(SHT_PROGBITS,        1, \"program defined information\")\t\\\n_ELF_DEFINE_SHT(SHT_SYMTAB,          2, \"symbol table\")\t\t\t\\\n_ELF_DEFINE_SHT(SHT_STRTAB,          3, \"string table\")\t\t\t\\\n_ELF_DEFINE_SHT(SHT_RELA,            4,\t\t\t\t\t\\\n\t\"relocation entries with addends\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_HASH,            5, \"symbol hash table\")\t\t\\\n_ELF_DEFINE_SHT(SHT_DYNAMIC,         6,\t\t\t\t\t\\\n\t\"information for dynamic linking\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_NOTE,            7, \"additional notes\")\t\t\\\n_ELF_DEFINE_SHT(SHT_NOBITS,          8, \"section occupying no space\")\t\\\n_ELF_DEFINE_SHT(SHT_REL,             9,\t\t\t\t\t\\\n\t\"relocation entries without addends\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_SHLIB,           10, \"reserved\")\t\t\t\\\n_ELF_DEFINE_SHT(SHT_DYNSYM,          11, \"symbol table\")\t\t\\\n_ELF_DEFINE_SHT(SHT_INIT_ARRAY,      14,\t\t\t\t\\\n\t\"pointers to initialization functions\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_FINI_ARRAY,      15,\t\t\t\t\\\n\t\"pointers to termination functions\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_PREINIT_ARRAY,   16,\t\t\t\t\\\n\t\"pointers to functions called before initialization\")\t\t\\\n_ELF_DEFINE_SHT(SHT_GROUP,           17, \"defines a section group\")\t\\\n_ELF_DEFINE_SHT(SHT_SYMTAB_SHNDX,    18,\t\t\t\t\\\n\t\"used for extended section numbering\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_LOOS,            0x60000000UL,\t\t\t\\\n\t\"start of OS-specific range\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_SUNW_dof,\t     0x6FFFFFF4UL,\t\t\t\\\n\t\"used by dtrace\")\t\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_SUNW_cap,\t     0x6FFFFFF5UL,\t\t\t\\\n\t\"capability requirements\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_GNU_ATTRIBUTES,  0x6FFFFFF5UL,\t\t\t\\\n\t\"object attributes\")\t\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_SUNW_SIGNATURE,  0x6FFFFFF6UL,\t\t\t\\\n\t\"module verification signature\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_GNU_HASH,\t     0x6FFFFFF6UL,\t\t\t\\\n\t\"GNU Hash sections\")\t\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_GNU_LIBLIST,     0x6FFFFFF7UL,\t\t\t\\\n\t\"List of libraries to be prelinked\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_SUNW_ANNOTATE,   0x6FFFFFF7UL,\t\t\t\\\n\t\"special section where unresolved references are allowed\")\t\\\n_ELF_DEFINE_SHT(SHT_SUNW_DEBUGSTR,   0x6FFFFFF8UL,\t\t\t\\\n\t\"debugging information\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_CHECKSUM, \t     0x6FFFFFF8UL,\t\t\t\\\n\t\"checksum for dynamic shared objects\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_SUNW_DEBUG,      0x6FFFFFF9UL,\t\t\t\\\n\t\"debugging information\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_SUNW_move,       0x6FFFFFFAUL,\t\t\t\\\n\t\"information to handle partially initialized symbols\")\t\t\\\n_ELF_DEFINE_SHT(SHT_SUNW_COMDAT,     0x6FFFFFFBUL,\t\t\t\\\n\t\"section supporting merging of multiple copies of data\")\t\\\n_ELF_DEFINE_SHT(SHT_SUNW_syminfo,    0x6FFFFFFCUL,\t\t\t\\\n\t\"additional symbol information\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_SUNW_verdef,     0x6FFFFFFDUL,\t\t\t\\\n\t\"symbol versioning information\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_SUNW_verneed,    0x6FFFFFFEUL,\t\t\t\\\n\t\"symbol versioning requirements\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_SUNW_versym,     0x6FFFFFFFUL,\t\t\t\\\n\t\"symbol versioning table\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_HIOS,            0x6FFFFFFFUL,\t\t\t\\\n\t\"end of OS-specific range\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_LOPROC,          0x70000000UL,\t\t\t\\\n\t\"start of processor-specific range\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_ARM_EXIDX,       0x70000001UL,\t\t\t\\\n\t\"exception index table\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_ARM_PREEMPTMAP,  0x70000002UL,\t\t\t\\\n\t\"BPABI DLL dynamic linking preemption map\")\t\t\t\\\n_ELF_DEFINE_SHT(SHT_ARM_ATTRIBUTES,  0x70000003UL,\t\t\t\\\n\t\"object file compatibility attributes\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_ARM_DEBUGOVERLAY, 0x70000004UL,\t\t\t\\\n\t\"overlay debug information\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_ARM_OVERLAYSECTION, 0x70000005UL,\t\t\t\\\n\t\"overlay debug information\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_LIBLIST,    0x70000000UL,\t\t\t\\\n\t\"DSO library information used in link\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_MSYM,       0x70000001UL,\t\t\t\\\n\t\"MIPS symbol table extension\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_CONFLICT,   0x70000002UL,\t\t\t\\\n\t\"symbol conflicting with DSO-defined symbols \")\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_GPTAB,      0x70000003UL,\t\t\t\\\n\t\"global pointer table\")\t\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_UCODE,      0x70000004UL,\t\t\t\\\n\t\"reserved\")\t\t\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_DEBUG,      0x70000005UL,\t\t\t\\\n\t\"reserved (obsolete debug information)\")\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_REGINFO,    0x70000006UL,\t\t\t\\\n\t\"register usage information\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_PACKAGE,    0x70000007UL,\t\t\t\\\n\t\"OSF reserved\")\t\t\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_PACKSYM,    0x70000008UL,\t\t\t\\\n\t\"OSF reserved\")\t\t\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_RELD,       0x70000009UL,\t\t\t\\\n\t\"dynamic relocation\")\t\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_IFACE,      0x7000000BUL,\t\t\t\\\n\t\"subprogram interface information\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_CONTENT,    0x7000000CUL,\t\t\t\\\n\t\"section content classification\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_OPTIONS,     0x7000000DUL,\t\t\t\\\n\t\"general options\")\t\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_DELTASYM,   0x7000001BUL,\t\t\t\\\n\t\"Delta C++: symbol table\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_DELTAINST,  0x7000001CUL,\t\t\t\\\n\t\"Delta C++: instance table\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_DELTACLASS, 0x7000001DUL,\t\t\t\\\n\t\"Delta C++: class table\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_DWARF,      0x7000001EUL,\t\t\t\\\n\t\"DWARF debug information\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_DELTADECL,  0x7000001FUL,\t\t\t\\\n\t\"Delta C++: declarations\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_SYMBOL_LIB, 0x70000020UL,\t\t\t\\\n\t\"symbol-to-library mapping\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_EVENTS,     0x70000021UL,\t\t\t\\\n\t\"event locations\")\t\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_TRANSLATE,  0x70000022UL,\t\t\t\\\n\t\"???\")\t\t\t\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_PIXIE,      0x70000023UL,\t\t\t\\\n\t\"special pixie sections\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_XLATE,      0x70000024UL,\t\t\t\\\n\t\"address translation table\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_XLATE_DEBUG, 0x70000025UL,\t\t\t\\\n\t\"SGI internal address translation table\")\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_WHIRL,      0x70000026UL,\t\t\t\\\n\t\"intermediate code\")\t\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_EH_REGION,  0x70000027UL,\t\t\t\\\n\t\"C++ exception handling region info\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_XLATE_OLD,  0x70000028UL,\t\t\t\\\n\t\"obsolete\")\t\t\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_MIPS_PDR_EXCEPTION, 0x70000029UL,\t\t\t\\\n\t\"runtime procedure descriptor table exception information\")\t\\\n_ELF_DEFINE_SHT(SHT_SPARC_GOTDATA,   0x70000000UL,\t\t\t\\\n\t\"SPARC-specific data\")\t\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_AMD64_UNWIND,    0x70000001UL,\t\t\t\\\n\t\"unwind tables for the AMD64\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_ORDERED,         0x7FFFFFFFUL,\t\t\t\\\n\t\"sort entries in the section\")\t\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_HIPROC,          0x7FFFFFFFUL,\t\t\t\\\n\t\"end of processor-specific range\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_LOUSER,          0x80000000UL,\t\t\t\\\n\t\"start of application-specific range\")\t\t\t\t\\\n_ELF_DEFINE_SHT(SHT_HIUSER,          0xFFFFFFFFUL,\t\t\t\\\n\t\"end of application-specific range\")\n\n#undef\t_ELF_DEFINE_SHT\n#define\t_ELF_DEFINE_SHT(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_SECTION_TYPES()\n\tSHT__LAST__ = SHT_HIUSER\n};\n\n/* Aliases for section types. */\n#ifndef SHT_GNU_verdef\n#define\tSHT_GNU_verdef\t\tSHT_SUNW_verdef\n#endif\n#ifndef SHT_GNU_verneed\n#define\tSHT_GNU_verneed\t\tSHT_SUNW_verneed\n#endif\n#ifndef SHT_GNU_versym\n#define\tSHT_GNU_versym\t\tSHT_SUNW_versym\n#endif\n\n/*\n * Symbol binding information.\n */\n\n#define\t_ELF_DEFINE_SYMBOL_BINDING()\t\t\t\t\t\\\n_ELF_DEFINE_STB(STB_LOCAL,           0,\t\t\t\t\t\\\n\t\"not visible outside defining object file\")\t\t\t\\\n_ELF_DEFINE_STB(STB_GLOBAL,          1,\t\t\t\t\t\\\n\t\"visible across all object files being combined\")\t\t\\\n_ELF_DEFINE_STB(STB_WEAK,            2,\t\t\t\t\t\\\n\t\"visible across all object files but with low precedence\")\t\\\n_ELF_DEFINE_STB(STB_LOOS,            10, \"start of OS-specific range\")\t\\\n_ELF_DEFINE_STB(STB_HIOS,            12, \"end of OS-specific range\")\t\\\n_ELF_DEFINE_STB(STB_LOPROC,          13,\t\t\t\t\\\n\t\"start of processor-specific range\")\t\t\t\t\\\n_ELF_DEFINE_STB(STB_HIPROC,          15,\t\t\t\t\\\n\t\"end of processor-specific range\")\n\n#undef\t_ELF_DEFINE_STB\n#define\t_ELF_DEFINE_STB(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_SYMBOL_BINDING()\n\tSTB__LAST__\n};\n\n/*\n * Symbol types\n */\n\n#define\t_ELF_DEFINE_SYMBOL_TYPES()\t\t\t\t\t\\\n_ELF_DEFINE_STT(STT_NOTYPE,          0, \"unspecified type\")\t\t\\\n_ELF_DEFINE_STT(STT_OBJECT,          1, \"data object\")\t\t\t\\\n_ELF_DEFINE_STT(STT_FUNC,            2, \"executable code\")\t\t\\\n_ELF_DEFINE_STT(STT_SECTION,         3, \"section\")\t\t\t\\\n_ELF_DEFINE_STT(STT_FILE,            4, \"source file\")\t\t\t\\\n_ELF_DEFINE_STT(STT_COMMON,          5, \"uninitialized common block\")\t\\\n_ELF_DEFINE_STT(STT_TLS,             6, \"thread local storage\")\t\t\\\n_ELF_DEFINE_STT(STT_LOOS,            10, \"start of OS-specific types\")\t\\\n_ELF_DEFINE_STT(STT_HIOS,            12, \"end of OS-specific types\")\t\\\n_ELF_DEFINE_STT(STT_LOPROC,          13,\t\t\t\t\\\n\t\"start of processor-specific types\")\t\t\t\t\\\n_ELF_DEFINE_STT(STT_ARM_TFUNC,       13, \"Thumb function (GNU)\")\t\\\n_ELF_DEFINE_STT(STT_ARM_16BIT,       15, \"Thumb label (GNU)\")\t\t\\\n_ELF_DEFINE_STT(STT_HIPROC,          15,\t\t\t\t\\\n\t\"end of processor-specific types\")\n\n#undef\t_ELF_DEFINE_STT\n#define\t_ELF_DEFINE_STT(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_SYMBOL_TYPES()\n\tSTT__LAST__\n};\n\n/*\n * Symbol binding.\n */\n\n#define\t_ELF_DEFINE_SYMBOL_BINDING_KINDS()\t\t\\\n_ELF_DEFINE_SYB(SYMINFO_BT_SELF,\t0xFFFFU,\t\\\n\t\"bound to self\")\t\t\t\t\\\n_ELF_DEFINE_SYB(SYMINFO_BT_PARENT,\t0xFFFEU,\t\\\n\t\"bound to parent\")\t\t\t\t\\\n_ELF_DEFINE_SYB(SYMINFO_BT_NONE,\t0xFFFDU,\t\\\n\t\"no special binding\")\n\n#undef\t_ELF_DEFINE_SYB\n#define\t_ELF_DEFINE_SYB(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_SYMBOL_BINDING_KINDS()\n\tSYMINFO__LAST__\n};\n\n/*\n * Symbol visibility.\n */\n\n#define\t_ELF_DEFINE_SYMBOL_VISIBILITY()\t\t\\\n_ELF_DEFINE_STV(STV_DEFAULT,         0,\t\t\\\n\t\"as specified by symbol type\")\t\t\\\n_ELF_DEFINE_STV(STV_INTERNAL,        1,\t\t\\\n\t\"as defined by processor semantics\")\t\\\n_ELF_DEFINE_STV(STV_HIDDEN,          2,\t\t\\\n\t\"hidden from other components\")\t\t\\\n_ELF_DEFINE_STV(STV_PROTECTED,       3,\t\t\\\n\t\"local references are not preemptable\")\n\n#undef\t_ELF_DEFINE_STV\n#define\t_ELF_DEFINE_STV(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_SYMBOL_VISIBILITY()\n\tSTV__LAST__\n};\n\n/*\n * Symbol flags.\n */\n#define\t_ELF_DEFINE_SYMBOL_FLAGS()\t\t\\\n_ELF_DEFINE_SYF(SYMINFO_FLG_DIRECT,\t0x01,\t\\\n\t\"directly assocated reference\")\t\t\\\n_ELF_DEFINE_SYF(SYMINFO_FLG_COPY,\t0x04,\t\\\n\t\"definition by copy-relocation\")\t\\\n_ELF_DEFINE_SYF(SYMINFO_FLG_LAZYLOAD,\t0x08,\t\\\n\t\"object should be lazily loaded\")\t\\\n_ELF_DEFINE_SYF(SYMINFO_FLG_DIRECTBIND,\t0x10,\t\\\n\t\"reference should be directly bound\")\t\\\n_ELF_DEFINE_SYF(SYMINFO_FLG_NOEXTDIRECT, 0x20,\t\\\n\t\"external references not allowed to bind to definition\")\n\n#undef\t_ELF_DEFINE_SYF\n#define\t_ELF_DEFINE_SYF(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_SYMBOL_FLAGS()\n\tSYMINFO_FLG__LAST__\n};\n\n/*\n * Version dependencies.\n */\n#define\t_ELF_DEFINE_VERSIONING_DEPENDENCIES()\t\t\t\\\n_ELF_DEFINE_VERD(VER_NDX_LOCAL,\t\t0,\t\"local scope\")\t\\\n_ELF_DEFINE_VERD(VER_NDX_GLOBAL,\t1,\t\"global scope\")\n#undef\t_ELF_DEFINE_VERD\n#define\t_ELF_DEFINE_VERD(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_VERSIONING_DEPENDENCIES()\n\tVER_NDX__LAST__\n};\n\n/*\n * Version flags.\n */\n#define\t_ELF_DEFINE_VERSIONING_FLAGS()\t\t\t\t\\\n_ELF_DEFINE_VERF(VER_FLG_BASE,\t\t0x1,\t\"file version\") \\\n_ELF_DEFINE_VERF(VER_FLG_WEAK,\t\t0x2,\t\"weak version\")\n#undef\t_ELF_DEFINE_VERF\n#define\t_ELF_DEFINE_VERF(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_VERSIONING_FLAGS()\n\tVER_FLG__LAST__\n};\n\n/*\n * Version needs\n */\n#define\t_ELF_DEFINE_VERSIONING_NEEDS()\t\t\t\t\t\\\n_ELF_DEFINE_VRN(VER_NEED_NONE,\t\t0,\t\"invalid version\")\t\\\n_ELF_DEFINE_VRN(VER_NEED_CURRENT,\t1,\t\"current version\")\n#undef\t_ELF_DEFINE_VRN\n#define\t_ELF_DEFINE_VRN(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_VERSIONING_NEEDS()\n\tVER_NEED__LAST__\n};\n\n/*\n * Version numbers.\n */\n#define\t_ELF_DEFINE_VERSIONING_NUMBERS()\t\t\t\t\\\n_ELF_DEFINE_VRNU(VER_DEF_NONE,\t\t0,\t\"invalid version\")\t\\\n_ELF_DEFINE_VRNU(VER_DEF_CURRENT,\t1, \t\"current version\")\n#undef\t_ELF_DEFINE_VRNU\n#define\t_ELF_DEFINE_VRNU(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_VERSIONING_NUMBERS()\n\tVER_DEF__LAST__\n};\n\n/**\n ** Relocation types.\n **/\n\n#define\t_ELF_DEFINE_386_RELOCATIONS()\t\t\\\n_ELF_DEFINE_RELOC(R_386_NONE,\t\t0)\t\\\n_ELF_DEFINE_RELOC(R_386_32,\t\t1)\t\\\n_ELF_DEFINE_RELOC(R_386_PC32,\t\t2)\t\\\n_ELF_DEFINE_RELOC(R_386_GOT32,\t\t3)\t\\\n_ELF_DEFINE_RELOC(R_386_PLT32,\t\t4)\t\\\n_ELF_DEFINE_RELOC(R_386_COPY,\t\t5)\t\\\n_ELF_DEFINE_RELOC(R_386_GLOB_DAT,\t6)\t\\\n_ELF_DEFINE_RELOC(R_386_JMP_SLOT,\t7)\t\\\n_ELF_DEFINE_RELOC(R_386_RELATIVE,\t8)\t\\\n_ELF_DEFINE_RELOC(R_386_GOTOFF,\t\t9)\t\\\n_ELF_DEFINE_RELOC(R_386_GOTPC,\t\t10)\t\\\n_ELF_DEFINE_RELOC(R_386_32PLT,\t\t11)\t\\\n_ELF_DEFINE_RELOC(R_386_16,\t\t20)\t\\\n_ELF_DEFINE_RELOC(R_386_PC16,\t\t21)\t\\\n_ELF_DEFINE_RELOC(R_386_8,\t\t22)\t\\\n_ELF_DEFINE_RELOC(R_386_PC8,\t\t23)\n\n/*\n * These are the symbols used in the Sun ``Linkers and Loaders\n * Guide'', Document No: 817-1984-17.  See the X86_64 relocations list\n * below for the spellings used in the ELF specification.\n */\n#define\t_ELF_DEFINE_AMD64_RELOCATIONS()\t\t\\\n_ELF_DEFINE_RELOC(R_AMD64_NONE,\t\t0)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_64,\t\t1)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_PC32,\t\t2)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_GOT32,\t3)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_PLT32,\t4)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_COPY,\t\t5)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_GLOB_DAT,\t6)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_JUMP_SLOT,\t7)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_RELATIVE,\t8)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_GOTPCREL,\t9)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_32,\t\t10)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_32S,\t\t11)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_16,\t\t12)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_PC16,\t\t13)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_8,\t\t14)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_PC8,\t\t15)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_PC64,\t\t24)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_GOTOFF64,\t25)\t\\\n_ELF_DEFINE_RELOC(R_AMD64_GOTPC32,\t26)\n\n#define\t_ELF_DEFINE_ARM_RELOCATIONS()\t\t\t\\\n_ELF_DEFINE_RELOC(R_ARM_NONE,\t\t\t0)\t\\\n_ELF_DEFINE_RELOC(R_ARM_PC24,\t\t\t1)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ABS32,\t\t\t2)\t\\\n_ELF_DEFINE_RELOC(R_ARM_REL32,\t\t\t3)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDR_PC_G0,\t\t4)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ABS16,\t\t\t5)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ABS12,\t\t\t6)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_ABS5,\t\t7)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ABS8,\t\t\t8)\t\\\n_ELF_DEFINE_RELOC(R_ARM_SBREL32,\t\t9)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_CALL,\t\t10)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_PC8,\t\t11)\t\\\n_ELF_DEFINE_RELOC(R_ARM_BREL_ADJ,\t\t12)\t\\\n_ELF_DEFINE_RELOC(R_ARM_SWI24,\t\t\t13)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_SWI8,\t\t14)\t\\\n_ELF_DEFINE_RELOC(R_ARM_XPC25,\t\t\t15)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_XPC22,\t\t16)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TLS_DTPMOD32,\t\t17)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TLS_DTPOFF32,\t\t18)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TLS_TPOFF32,\t\t19)\t\\\n_ELF_DEFINE_RELOC(R_ARM_COPY,\t\t\t20)\t\\\n_ELF_DEFINE_RELOC(R_ARM_GLOB_DAT,\t\t21)\t\\\n_ELF_DEFINE_RELOC(R_ARM_JUMP_SLOT,\t\t22)\t\\\n_ELF_DEFINE_RELOC(R_ARM_RELATIVE,\t\t23)\t\\\n_ELF_DEFINE_RELOC(R_ARM_GOTOFF32,\t\t24)\t\\\n_ELF_DEFINE_RELOC(R_ARM_BASE_PREL,\t\t25)\t\\\n_ELF_DEFINE_RELOC(R_ARM_GOT_BREL,\t\t26)\t\\\n_ELF_DEFINE_RELOC(R_ARM_PLT32,\t\t\t27)\t\\\n_ELF_DEFINE_RELOC(R_ARM_CALL,\t\t\t28)\t\\\n_ELF_DEFINE_RELOC(R_ARM_JUMP24,\t\t\t29)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_JUMP24,\t\t30)\t\\\n_ELF_DEFINE_RELOC(R_ARM_BASE_ABS,\t\t31)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ALU_PCREL7_0,\t\t32)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ALU_PCREL15_8,\t\t33)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ALU_PCREL23_15,\t\t34)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDR_SBREL_11_0,\t\t35)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ALU_SBREL_19_12,\t36)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ALU_SBREL_27_20,\t37)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TARGET1,\t\t38)\t\\\n_ELF_DEFINE_RELOC(R_ARM_SBREL31,\t\t39)\t\\\n_ELF_DEFINE_RELOC(R_ARM_V4BX,\t\t\t40)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TARGET2,\t\t41)\t\\\n_ELF_DEFINE_RELOC(R_ARM_PREL31,\t\t\t42)\t\\\n_ELF_DEFINE_RELOC(R_ARM_MOVW_ABS_NC,\t\t43)\t\\\n_ELF_DEFINE_RELOC(R_ARM_MOVT_ABS,\t\t44)\t\\\n_ELF_DEFINE_RELOC(R_ARM_MOVW_PREL_NC,\t\t45)\t\\\n_ELF_DEFINE_RELOC(R_ARM_MOVT_PREL,\t\t46)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_MOVW_ABS_NC,\t47)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_MOVT_ABS,\t\t48)\t\\\n_ELF_DEFINE_RELOC(R_ARM_MOVW_PREL_NC,\t\t49)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_MOVT_PREL,\t\t50)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_JUMP19,\t\t51)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_JUMP6,\t\t52)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_ALU_PREL_11_0,\t53)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_PC12,\t\t54)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ABS32_NOI,\t\t55)\t\\\n_ELF_DEFINE_RELOC(R_ARM_REL32_NOI,\t\t56)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ALU_PC_G0_NC,\t\t57)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ALU_PC_G0,\t\t58)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ALU_PC_G1_NC,\t\t59)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ALU_PC_G1,\t\t60)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ALU_PC_G2,\t\t61)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDR_PC_G1,\t\t62)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDR_PC_G2,\t\t63)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDRS_PC_G0,\t\t64)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDRS_PC_G1,\t\t65)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDRS_PC_G2,\t\t66)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDC_PC_G0,\t\t67)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDC_PC_G1,\t\t68)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDC_PC_G2,\t\t69)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ALU_SB_G0_NC,\t\t70)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ALU_SB_G0,\t\t71)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ALU_SB_G1_NC,\t\t72)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ALU_SB_G1,\t\t73)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ALU_SB_G2,\t\t74)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDR_SB_G0,\t\t75)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDR_SB_G1,\t\t76)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDR_SB_G2,\t\t77)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDRS_SB_G0,\t\t78)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDRS_SB_G1,\t\t79)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDRS_SB_G2,\t\t80)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDC_SB_G0,\t\t81)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDC_SB_G1,\t\t82)\t\\\n_ELF_DEFINE_RELOC(R_ARM_LDC_SB_G2,\t\t83)\t\\\n_ELF_DEFINE_RELOC(R_ARM_MOVW_BREL_NC,\t\t84)\t\\\n_ELF_DEFINE_RELOC(R_ARM_MOVT_BREL,\t\t85)\t\\\n_ELF_DEFINE_RELOC(R_ARM_MOVW_BREL,\t\t86)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_MOVW_BREL_NC,\t87)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_MOVT_BREL,\t\t88)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_MOVW_BREL,\t\t89)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TLS_GOTDESC,\t\t90)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TLS_CALL,\t\t91)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TLS_DESCSEQ,\t\t92)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_TLS_CALL,\t\t93)\t\\\n_ELF_DEFINE_RELOC(R_ARM_PLT32_ABS,\t\t94)\t\\\n_ELF_DEFINE_RELOC(R_ARM_GOT_ABS,\t\t95)\t\\\n_ELF_DEFINE_RELOC(R_ARM_GOT_PREL,\t\t96)\t\\\n_ELF_DEFINE_RELOC(R_ARM_GOT_BREL12,\t\t97)\t\\\n_ELF_DEFINE_RELOC(R_ARM_GOTOFF12,\t\t98)\t\\\n_ELF_DEFINE_RELOC(R_ARM_GOTRELAX,\t\t99)\t\\\n_ELF_DEFINE_RELOC(R_ARM_GNU_VTENTRY,\t\t100)\t\\\n_ELF_DEFINE_RELOC(R_ARM_GNU_VTINHERIT,\t\t101)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_JUMP11,\t\t102)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_JUMP8,\t\t103)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TLS_GD32,\t\t104)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TLS_LDM32,\t\t105)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TLS_LDO32,\t\t106)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TLS_IE32,\t\t107)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TLS_LE32,\t\t108)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TLS_LDO12,\t\t109)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TLS_LE12,\t\t110)\t\\\n_ELF_DEFINE_RELOC(R_ARM_TLS_IE12GP,\t\t111)\t\\\n_ELF_DEFINE_RELOC(R_ARM_ME_TOO,\t\t\t128)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_TLS_DESCSEQ16,\t129)\t\\\n_ELF_DEFINE_RELOC(R_ARM_THM_TLS_DESCSEQ32,\t130)\n\n#define\t_ELF_DEFINE_IA64_RELOCATIONS()\t\t\t\\\n_ELF_DEFINE_RELOC(R_IA_64_NONE,\t\t\t0)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_IMM14,\t\t0x21)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_IMM22,\t\t0x22)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_IMM64,\t\t0x23)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_DIR32MSB,\t\t0x24)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_DIR32LSB,\t\t0x25)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_DIR64MSB,\t\t0x26)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_DIR64LSB,\t\t0x27)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_GPREL22,\t\t0x2a)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_GPREL64I,\t\t0x2b)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_GPREL32MSB,\t\t0x2c)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_GPREL32LSB,\t\t0x2d)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_GPREL64MSB,\t\t0x2e)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_GPREL64LSB,\t\t0x2f)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTOFF22,\t\t0x32)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTOFF64I,\t\t0x33)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_PLTOFF22,\t\t0x3a)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_PLTOFF64I,\t\t0x3b)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_PLTOFF64MSB,\t\t0x3e)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_PLTOFF64LSB,\t\t0x3f)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_FPTR64I,\t\t0x43)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_FPTR32MSB,\t\t0x44)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_FPTR32LSB,\t\t0x45)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_FPTR64MSB,\t\t0x46)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_FPTR64LSB,\t\t0x47)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_PCREL60B,\t\t0x48)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_PCREL21B,\t\t0x49)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_PCREL21M,\t\t0x4a)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_PCREL21F,\t\t0x4b)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_PCREL32MSB,\t\t0x4c)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_PCREL32LSB,\t\t0x4d)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_PCREL64MSB,\t\t0x4e)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_PCREL64LSB,\t\t0x4f)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTOFF_FPTR22,\t\t0x52)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTOFF_FPTR64I,\t0x53)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTOFF_FPTR32MSB,\t0x54)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTOFF_FPTR32LSB,\t0x55)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTOFF_FPTR64MSB,\t0x56)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTOFF_FPTR64LSB,\t0x57)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_SEGREL32MSB,\t\t0x5c)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_SEGREL32LSB,\t\t0x5d)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_SEGREL64MSB,\t\t0x5e)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_SEGREL64LSB,\t\t0x5f)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_SECREL32MSB,\t\t0x64)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_SECREL32LSB,\t\t0x65)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_SECREL64MSB,\t\t0x66)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_SECREL64LSB,\t\t0x67)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_REL32MSB,\t\t0x6c)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_REL32LSB,\t\t0x6d)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_REL64MSB,\t\t0x6e)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_REL64LSB,\t\t0x6f)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTV32MSB,\t\t0x74)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTV32LSB,\t\t0x75)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTV64MSB,\t\t0x76)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTV64LSB,\t\t0x77)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_PCREL21BIa,\t\t0x79)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_PCREL22,\t\t0x7A)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_PCREL64I,\t\t0x7B)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_IPLTMSB,\t\t0x80)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_IPLTLSB,\t\t0x81)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_SUB,\t\t\t0x85)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTOFF22X,\t\t0x86)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LDXMOV,\t\t0x87)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_TPREL14,\t\t0x91)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_TPREL22,\t\t0x92)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_TPREL64I,\t\t0x93)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_TPREL64MSB,\t\t0x96)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_TPREL64LSB,\t\t0x97)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTOFF_TPREL22,\t0x9A)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_DTPMOD64MSB,\t\t0xA6)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_DTPMOD64LSB,\t\t0xA7)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTOFF_DTPMOD22,\t0xAA)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_DTPREL14,\t\t0xB1)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_DTPREL22,\t\t0xB2)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_DTPREL64I,\t\t0xB3)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_DTPREL32MSB,\t\t0xB4)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_DTPREL32LSB,\t\t0xB5)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_DTPREL64MSB,\t\t0xB6)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_DTPREL64LSB,\t\t0xB7)\t\\\n_ELF_DEFINE_RELOC(R_IA_64_LTOFF_DTPREL22,\t0xBA)\n\n#define\t_ELF_DEFINE_MIPS_RELOCATIONS()\t\t\\\n_ELF_DEFINE_RELOC(R_MIPS_NONE,\t\t0)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_16,\t\t1)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_32,\t\t2)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_REL32,\t\t3)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_26,\t\t4)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_HI16,\t\t5)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_LO16,\t\t6)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_GPREL16,\t7)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_LITERAL, \t8)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_GOT16,\t\t9)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_PC16,\t\t10)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_CALL16,\t11)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_GPREL32,\t12)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_64,\t\t18)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_GOTHI16,\t21)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_GOTLO16,\t22)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_CALLHI16,\t30)\t\\\n_ELF_DEFINE_RELOC(R_MIPS_CALLLO16,\t31)\n\n#define\t_ELF_DEFINE_PPC32_RELOCATIONS()\t\t\\\n_ELF_DEFINE_RELOC(R_PPC_NONE,\t\t0)\t\\\n_ELF_DEFINE_RELOC(R_PPC_ADDR32,\t\t1)\t\\\n_ELF_DEFINE_RELOC(R_PPC_ADDR24,\t\t2)\t\\\n_ELF_DEFINE_RELOC(R_PPC_ADDR16,\t\t3)\t\\\n_ELF_DEFINE_RELOC(R_PPC_ADDR16_LO,\t4)\t\\\n_ELF_DEFINE_RELOC(R_PPC_ADDR16_HI,\t5)\t\\\n_ELF_DEFINE_RELOC(R_PPC_ADDR16_HA,\t6)\t\\\n_ELF_DEFINE_RELOC(R_PPC_ADDR14,\t\t7)\t\\\n_ELF_DEFINE_RELOC(R_PPC_ADDR14_BRTAKEN,\t8)\t\\\n_ELF_DEFINE_RELOC(R_PPC_ADDR14_BRNTAKEN, 9)\t\\\n_ELF_DEFINE_RELOC(R_PPC_REL24,\t\t10)\t\\\n_ELF_DEFINE_RELOC(R_PPC_REL14,\t\t11)\t\\\n_ELF_DEFINE_RELOC(R_PPC_REL14_BRTAKEN,\t12)\t\\\n_ELF_DEFINE_RELOC(R_PPC_REL14_BRNTAKEN,\t13)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT16,\t\t14)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT16_LO,\t15)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT16_HI,\t16)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT16_HA,\t17)\t\\\n_ELF_DEFINE_RELOC(R_PPC_PLTREL24,\t18)\t\\\n_ELF_DEFINE_RELOC(R_PPC_COPY,\t\t19)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GLOB_DAT,\t20)\t\\\n_ELF_DEFINE_RELOC(R_PPC_JMP_SLOT,\t21)\t\\\n_ELF_DEFINE_RELOC(R_PPC_RELATIVE,\t22)\t\\\n_ELF_DEFINE_RELOC(R_PPC_LOCAL24PC,\t23)\t\\\n_ELF_DEFINE_RELOC(R_PPC_UADDR32,\t24)\t\\\n_ELF_DEFINE_RELOC(R_PPC_UADDR16,\t25)\t\\\n_ELF_DEFINE_RELOC(R_PPC_REL32,\t\t26)\t\\\n_ELF_DEFINE_RELOC(R_PPC_PLT32,\t\t27)\t\\\n_ELF_DEFINE_RELOC(R_PPC_PLTREL32,\t28)\t\\\n_ELF_DEFINE_RELOC(R_PPC_PLT16_LO,\t29)\t\\\n_ELF_DEFINE_RELOC(R_PPL_PLT16_HI,\t30)\t\\\n_ELF_DEFINE_RELOC(R_PPC_PLT16_HA,\t31)\t\\\n_ELF_DEFINE_RELOC(R_PPC_SDAREL16,\t32)\t\\\n_ELF_DEFINE_RELOC(R_PPC_SECTOFF,\t33)\t\\\n_ELF_DEFINE_RELOC(R_PPC_SECTOFF_LO,\t34)\t\\\n_ELF_DEFINE_RELOC(R_PPC_SECTOFF_HI,\t35)\t\\\n_ELF_DEFINE_RELOC(R_PPC_SECTOFF_HA,\t36)\t\\\n_ELF_DEFINE_RELOC(R_PPC_ADDR30,\t\t37)\t\\\n_ELF_DEFINE_RELOC(R_PPC_TLS,\t\t67)\t\\\n_ELF_DEFINE_RELOC(R_PPC_DTPMOD32,\t68)\t\\\n_ELF_DEFINE_RELOC(R_PPC_TPREL16,\t69)\t\\\n_ELF_DEFINE_RELOC(R_PPC_TPREL16_LO,\t70)\t\\\n_ELF_DEFINE_RELOC(R_PPC_TPREL16_HI,\t71)\t\\\n_ELF_DEFINE_RELOC(R_PPC_TPREL16_HA,\t72)\t\\\n_ELF_DEFINE_RELOC(R_PPC_TPREL32,\t73)\t\\\n_ELF_DEFINE_RELOC(R_PPC_DTPREL16,\t74)\t\\\n_ELF_DEFINE_RELOC(R_PPC_DTPREL16_LO,\t75)\t\\\n_ELF_DEFINE_RELOC(R_PPC_DTPREL16_HI,\t76)\t\\\n_ELF_DEFINE_RELOC(R_PPC_DTPREL16_HA,\t77)\t\\\n_ELF_DEFINE_RELOC(R_PPC_DTPREL32,\t78)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_TLSGD16,\t79)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_TLSGD16_LO,\t80)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_TLSGD16_HI,\t81)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_TLSGD16_HA,\t82)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_TLSLD16,\t83)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_TLSLD16_LO,\t84)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_TLSLD16_HI,\t85)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_TLSLD16_HA,\t86)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_TPREL16,\t87)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_TPREL16_LO,\t88)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_TPREL16_HI,\t89)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_TPREL16_HA,\t90)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_DTPREL16,\t91)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_DTPREL16_LO, 92)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_DTPREL16_HI, 93)\t\\\n_ELF_DEFINE_RELOC(R_PPC_GOT_DTPREL16_HA, 94)\t\\\n_ELF_DEFINE_RELOC(R_PPC_TLSGD,\t\t95)\t\\\n_ELF_DEFINE_RELOC(R_PPC_TLSLD,\t\t96)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_NADDR32,\t101)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_NADDR16,\t102)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_NADDR16_LO,\t103)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_NADDR16_HI,\t104)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_NADDR16_HA,\t105)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_SDAI16,\t106)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_SDA2I16,\t107)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_SDA2REL,\t108)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_SDA21,\t109)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_MRKREF,\t110)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_RELSEC16,\t111)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_RELST_LO,\t112)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_RELST_HI,\t113)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_RELST_HA,\t114)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_BIT_FLD,\t115)\t\\\n_ELF_DEFINE_RELOC(R_PPC_EMB_RELSDA,\t116)\t\\\n\n#define\t_ELF_DEFINE_PPC64_RELOCATIONS()\t\t\t\\\n_ELF_DEFINE_RELOC(R_PPC64_NONE,\t\t\t0)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR32,\t\t1)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR24,\t\t2)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR16,\t\t3)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR16_LO,\t\t4)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR16_HI,\t\t5)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR16_HA,\t\t6)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR14,\t\t7)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR14_BRTAKEN,\t8)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR14_BRNTAKEN,\t9)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_REL24,\t\t10)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_REL14,\t\t11)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_REL14_BRTAKEN,\t12)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_REL14_BRNTAKEN,\t13)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT16,\t\t14)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT16_LO,\t\t15)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT16_HI,\t\t16)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT16_HA,\t\t17)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_COPY,\t\t\t19)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GLOB_DAT,\t\t20)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_JMP_SLOT,\t\t21)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_RELATIVE,\t\t22)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_UADDR32,\t\t24)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_UADDR16,\t\t25)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_REL32,\t\t26)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_PLT32,\t\t27)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_PLTREL32,\t\t28)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_PLT16_LO,\t\t29)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_PLT16_HI,\t\t30)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_PLT16_HA,\t\t31)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_SECTOFF,\t\t33)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_SECTOFF_LO,\t\t34)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_SECTOFF_HI,\t\t35)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_SECTOFF_HA,\t\t36)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR30,\t\t37)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR64,\t\t38)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR16_HIGHER,\t39)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR16_HIGHERA,\t40)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR16_HIGHEST,\t41)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR16_HIGHESTA,\t42)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_UADDR64,\t\t43)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_REL64,\t\t44)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_PLT64,\t\t45)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_PLTREL64,\t\t46)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TOC16,\t\t47)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TOC16_LO,\t\t48)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TOC16_HI,\t\t49)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TOC16_HA,\t\t50)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TOC,\t\t\t51)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_PLTGOT16,\t\t52)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_PLTGOT16_LO,\t\t53)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_PLTGOT16_HI,\t\t54)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_PLTGOT16_HA,\t\t55)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR16_DS,\t\t56)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_ADDR16_LO_DS,\t\t57)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT16_DS,\t\t58)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT16_LO_DS,\t\t59)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_PLT16_LO_DS,\t\t60)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_SECTOFF_DS,\t\t61)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_SECTOFF_LO_DS,\t62)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TOC16_DS,\t\t63)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TOC16_LO_DS,\t\t64)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_PLTGOT16_DS,\t\t65)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_PLTGOT16_LO_DS,\t66)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TLS,\t\t\t67)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_DTPMOD64,\t\t68)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TPREL16,\t\t69)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TPREL16_LO,\t\t60)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TPREL16_HI,\t\t71)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TPREL16_HA,\t\t72)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TPREL64,\t\t73)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_DTPREL16,\t\t74)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_DTPREL16_LO,\t\t75)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_DTPREL16_HI,\t\t76)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_DTPREL16_HA,\t\t77)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_DTPREL64,\t\t78)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_TLSGD16,\t\t79)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_TLSGD16_LO,\t80)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_TLSGD16_HI,\t81)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_TLSGD16_HA,\t82)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_TLSLD16,\t\t83)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_TLSLD16_LO,\t84)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_TLSLD16_HI,\t85)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_TLSLD16_HA,\t86)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_TPREL16_DS,\t87)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_TPREL16_LO_DS,\t88)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_TPREL16_HI,\t89)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_TPREL16_HA,\t90)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_DTPREL16_DS,\t91)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_DTPREL16_LO_DS,\t92)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_DTPREL16_HI,\t93)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_GOT_DTPREL16_HA,\t94)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TPREL16_DS,\t\t95)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TPREL16_LO_DS,\t96)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TPREL16_HIGHER,\t97)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TPREL16_HIGHERA,\t98)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TPREL16_HIGHEST,\t99)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TPREL16_HIGHESTA,\t100)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_DTPREL16_DS,\t\t101)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_DTPREL16_LO_DS,\t102)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_DTPREL16_HIGHER,\t103)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_DTPREL16_HIGHERA,\t104)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_DTPREL16_HIGHEST,\t105)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_DTPREL16_HIGHESTA,\t106)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TLSGD,\t\t107)\t\\\n_ELF_DEFINE_RELOC(R_PPC64_TLSLD,\t\t108)\n\n#define\t_ELF_DEFINE_SPARC_RELOCATIONS()\t\t\\\n_ELF_DEFINE_RELOC(R_SPARC_NONE,\t\t0)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_8,\t\t1)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_16,\t\t2)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_32, \t\t3)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_DISP8,\t4)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_DISP16,\t5)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_DISP32,\t6)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_WDISP30,\t7)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_WDISP22,\t8)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_HI22,\t\t9)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_22,\t\t10)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_13,\t\t11)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_LO10,\t\t12)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_GOT10,\t13)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_GOT13,\t14)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_GOT22,\t15)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_PC10,\t\t16)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_PC22,\t\t17)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_WPLT30,\t18)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_COPY,\t\t19)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_GLOB_DAT,\t20)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_JMP_SLOT,\t21)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_RELATIVE,\t22)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_UA32,\t\t23)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_PLT32,\t24)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_HIPLT22,\t25)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_LOPLT10,\t26)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_PCPLT32,\t27)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_PCPLT22,\t28)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_PCPLT10,\t29)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_10,\t\t30)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_11,\t\t31)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_64,\t\t32)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_OLO10,\t33)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_HH22,\t\t34)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_HM10,\t\t35)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_LM22,\t\t36)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_PC_HH22,\t37)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_PC_HM10,\t38)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_PC_LM22,\t39)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_WDISP16,\t40)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_WDISP19,\t41)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_7,\t\t43)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_5,\t\t44)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_6,\t\t45)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_DISP64,\t46)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_PLT64,\t47)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_HIX22,\t48)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_LOX10,\t49)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_H44,\t\t50)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_M44,\t\t51)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_L44,\t\t52)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_REGISTER,\t53)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_UA64,\t\t54)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_UA16,\t\t55)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_GOTDATA_HIX22, 80)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_GOTDATA_LOX10, 81)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_GOTDATA_OP_HIX22, 82)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_GOTDATA_OP_LOX10, 83)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_GOTDATA_OP,\t84)\t\\\n_ELF_DEFINE_RELOC(R_SPARC_H34,\t\t85)\n\n#define\t_ELF_DEFINE_X86_64_RELOCATIONS()\t\\\n_ELF_DEFINE_RELOC(R_X86_64_NONE,\t0)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_64,\t\t1)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_PC32,\t2)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_GOT32,\t3)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_PLT32,\t4)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_COPY,\t5)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_GLOB_DAT,\t6)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_JUMP_SLOT,\t7)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_RELATIVE,\t8)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_GOTPCREL,\t9)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_32,\t\t10)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_32S,\t\t11)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_16,\t\t12)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_PC16,\t13)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_8,\t\t14)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_PC8,\t\t15)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_DTPMOD64,\t16)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_DTPOFF64,\t17)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_TPOFF64,\t18)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_TLSGD,\t19)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_TLSLD,\t20)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_DTPOFF32,\t21)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_GOTTPOFF,\t22)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_TPOFF32,\t23)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_PC64,\t24)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_GOTOFF64,\t25)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_GOTPC32,\t26)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_SIZE32,\t32)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_SIZE64,\t33)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_GOTPC32_TLSDESC, 34)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_TLSDESC_CALL, 35)\t\\\n_ELF_DEFINE_RELOC(R_X86_64_TLSDESC,\t36)\n\n#define _ELF_DEFINE_HSAIL_RELOCATIONS() \\\n    _ELF_DEFINE_RELOC(R_HSA_NONE, 0)  \\\n    _ELF_DEFINE_RELOC(R_HSA_RESERVED_TYPE1, 1) /*reserved to use in BRIG linker */\\\n    _ELF_DEFINE_RELOC(R_HSA_RESERVED_TYPE2, 2) /*reserved to use in BRIG linker */\\\n    _ELF_DEFINE_RELOC(R_HSA_DWARF_32, 3) \\\n    _ELF_DEFINE_RELOC(R_HSA_DWARF_TO_BRIG_CODE32, 4) \\\n    _ELF_DEFINE_RELOC(R_HSA_DWARF_TO_BRIG_DIRECTIVES32, 5) \\\n    _ELF_DEFINE_RELOC(R_HSA_DWARF_64, 6) \\\n    _ELF_DEFINE_RELOC(R_HSA_DWARF_TO_BRIG_CODE64, 7) \\\n    _ELF_DEFINE_RELOC(R_HSA_DWARF_TO_BRIG_DIRECTIVES64, 8)\n\n#define\t_ELF_DEFINE_RELOCATIONS()\t\t\\\n_ELF_DEFINE_386_RELOCATIONS()\t\t\t\\\n_ELF_DEFINE_AMD64_RELOCATIONS()\t\t\t\\\n_ELF_DEFINE_IA64_RELOCATIONS()\t\t\t\\\n_ELF_DEFINE_MIPS_RELOCATIONS()\t\t\t\\\n_ELF_DEFINE_PPC32_RELOCATIONS()\t\t\t\\\n_ELF_DEFINE_PPC64_RELOCATIONS()\t\t\t\\\n_ELF_DEFINE_SPARC_RELOCATIONS()\t\t\t\\\n_ELF_DEFINE_X86_64_RELOCATIONS()\t\t\\\n_ELF_DEFINE_HSAIL_RELOCATIONS()\n\n#undef\t_ELF_DEFINE_RELOC\n#define\t_ELF_DEFINE_RELOC(N, V)\t\tN = V ,\nenum {\n\t_ELF_DEFINE_RELOCATIONS()\n\tR__LAST__\n};\n\n#define\tPN_XNUM\t\t\t0xFFFFU /* Use extended section numbering. */\n\n/**\n ** ELF Types.\n **/\n\ntypedef uint32_t\tElf32_Addr;\t/* Program address. */\ntypedef uint8_t\t\tElf32_Byte;\t/* Unsigned tiny integer. */\ntypedef uint16_t\tElf32_Half;\t/* Unsigned medium integer. */\ntypedef uint32_t\tElf32_Off;\t/* File offset. */\ntypedef uint16_t\tElf32_Section;\t/* Section index. */\ntypedef int32_t\t\tElf32_Sword;\t/* Signed integer. */\ntypedef uint32_t\tElf32_Word;\t/* Unsigned integer. */\ntypedef uint64_t\tElf32_Lword;\t/* Unsigned long integer. */\n\ntypedef uint64_t\tElf64_Addr;\t/* Program address. */\ntypedef uint8_t\t\tElf64_Byte;\t/* Unsigned tiny integer. */\ntypedef uint16_t\tElf64_Half;\t/* Unsigned medium integer. */\ntypedef uint64_t\tElf64_Off;\t/* File offset. */\ntypedef uint16_t\tElf64_Section;\t/* Section index. */\ntypedef int32_t\t\tElf64_Sword;\t/* Signed integer. */\ntypedef uint32_t\tElf64_Word;\t/* Unsigned integer. */\ntypedef uint64_t\tElf64_Lword;\t/* Unsigned long integer. */\ntypedef uint64_t\tElf64_Xword;\t/* Unsigned long integer. */\ntypedef int64_t\t\tElf64_Sxword;\t/* Signed long integer. */\n\n\n/*\n * Capability descriptors.\n */\n\n/* 32-bit capability descriptor. */\ntypedef struct {\n\tElf32_Word\tc_tag;\t     /* Type of entry. */\n\tunion {\n\t\tElf32_Word\tc_val; /* Integer value. */\n\t\tElf32_Addr\tc_ptr; /* Pointer value. */\n\t} c_un;\n} Elf32_Cap;\n\n/* 64-bit capability descriptor. */\ntypedef struct {\n\tElf64_Xword\tc_tag;\t     /* Type of entry. */\n\tunion {\n\t\tElf64_Xword\tc_val; /* Integer value. */\n\t\tElf64_Addr\tc_ptr; /* Pointer value. */\n\t} c_un;\n} Elf64_Cap;\n\n/*\n * MIPS .conflict section entries.\n */\n\n/* 32-bit entry. */\ntypedef struct {\n\tElf32_Addr\tc_index;\n} Elf32_Conflict;\n\n/* 64-bit entry. */\ntypedef struct {\n\tElf64_Addr\tc_index;\n} Elf64_Conflict;\n\n/*\n * Dynamic section entries.\n */\n\n/* 32-bit entry. */\ntypedef struct {\n\tElf32_Sword\td_tag;\t     /* Type of entry. */\n\tunion {\n\t\tElf32_Word\td_val; /* Integer value. */\n\t\tElf32_Addr\td_ptr; /* Pointer value. */\n\t} d_un;\n} Elf32_Dyn;\n\n/* 64-bit entry. */\ntypedef struct {\n\tElf64_Sxword\td_tag;\t     /* Type of entry. */\n\tunion {\n\t\tElf64_Xword\td_val; /* Integer value. */\n\t\tElf64_Addr\td_ptr; /* Pointer value; */\n\t} d_un;\n} Elf64_Dyn;\n\n\n/*\n * The executable header (EHDR).\n */\n\n/* 32 bit EHDR. */\ntypedef struct {\n\tunsigned char   e_ident[EI_NIDENT]; /* ELF identification. */\n\tElf32_Half      e_type;\t     /* Object file type (ET_*). */\n\tElf32_Half      e_machine;   /* Machine type (EM_*). */\n\tElf32_Word      e_version;   /* File format version (EV_*). */\n\tElf32_Addr      e_entry;     /* Start address. */\n\tElf32_Off       e_phoff;     /* File offset to the PHDR table. */\n\tElf32_Off       e_shoff;     /* File offset to the SHDRheader. */\n\tElf32_Word      e_flags;     /* Flags (EF_*). */\n\tElf32_Half      e_ehsize;    /* Elf header size in bytes. */\n\tElf32_Half      e_phentsize; /* PHDR table entry size in bytes. */\n\tElf32_Half      e_phnum;     /* Number of PHDR entries. */\n\tElf32_Half      e_shentsize; /* SHDR table entry size in bytes. */\n\tElf32_Half      e_shnum;     /* Number of SHDR entries. */\n\tElf32_Half      e_shstrndx;  /* Index of section name string table. */\n} Elf32_Ehdr;\n\n\n/* 64 bit EHDR. */\ntypedef struct {\n\tunsigned char   e_ident[EI_NIDENT]; /* ELF identification. */\n\tElf64_Half      e_type;\t     /* Object file type (ET_*). */\n\tElf64_Half      e_machine;   /* Machine type (EM_*). */\n\tElf64_Word      e_version;   /* File format version (EV_*). */\n\tElf64_Addr      e_entry;     /* Start address. */\n\tElf64_Off       e_phoff;     /* File offset to the PHDR table. */\n\tElf64_Off       e_shoff;     /* File offset to the SHDRheader. */\n\tElf64_Word      e_flags;     /* Flags (EF_*). */\n\tElf64_Half      e_ehsize;    /* Elf header size in bytes. */\n\tElf64_Half      e_phentsize; /* PHDR table entry size in bytes. */\n\tElf64_Half      e_phnum;     /* Number of PHDR entries. */\n\tElf64_Half      e_shentsize; /* SHDR table entry size in bytes. */\n\tElf64_Half      e_shnum;     /* Number of SHDR entries. */\n\tElf64_Half      e_shstrndx;  /* Index of section name string table. */\n} Elf64_Ehdr;\n\n\n/*\n * Shared object information.\n */\n\n/* 32-bit entry. */\ntypedef struct {\n\tElf32_Word l_name;\t     /* The name of a shared object. */\n\tElf32_Word l_time_stamp;     /* 32-bit timestamp. */\n\tElf32_Word l_checksum;\t     /* Checksum of visible symbols, sizes. */\n\tElf32_Word l_version;\t     /* Interface version string index. */\n\tElf32_Word l_flags;\t     /* Flags (LL_*). */\n} Elf32_Lib;\n\n/* 64-bit entry. */\ntypedef struct {\n\tElf64_Word l_name;\n\tElf64_Word l_time_stamp;\n\tElf64_Word l_checksum;\n\tElf64_Word l_version;\n\tElf64_Word l_flags;\n} Elf64_Lib;\n\n#define\t_ELF_DEFINE_LL_FLAGS()\t\t\t\\\n_ELF_DEFINE_LL(LL_NONE,\t\t\t0,\t\\\n\t\"no flags\")\t\t\t\t\\\n_ELF_DEFINE_LL(LL_EXACT_MATCH,\t\t0x1,\t\\\n\t\"require an exact match\")\t\t\\\n_ELF_DEFINE_LL(LL_IGNORE_INT_VER,\t0x2,\t\\\n\t\"ignore version incompatibilities\")\t\\\n_ELF_DEFINE_LL(LL_REQUIRE_MINOR,\t0x4,\t\\\n\t\"\")\t\t\t\t\t\\\n_ELF_DEFINE_LL(LL_EXPORTS,\t\t0x8,\t\\\n\t\"\")\t\t\t\t\t\\\n_ELF_DEFINE_LL(LL_DELAY_LOAD,\t\t0x10,\t\\\n\t\"\")\t\t\t\t\t\\\n_ELF_DEFINE_LL(LL_DELTA,\t\t0x20,\t\\\n\t\"\")\n\n#undef\t_ELF_DEFINE_LL\n#define\t_ELF_DEFINE_LL(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_LL_FLAGS()\n\tLL__LAST__\n};\n\n/*\n * Note tags\n */\n\n#define\t_ELF_DEFINE_NOTE_ENTRY_TYPES()\t\t\t\t\t\\\n_ELF_DEFINE_NT(NT_ABI_TAG,\t1,\t\"Tag indicating the ABI\")\t\\\n_ELF_DEFINE_NT(NT_GNU_HWCAP,\t2,\t\"Hardware capabilities\")\t\\\n_ELF_DEFINE_NT(NT_GNU_BUILD_ID,\t3,\t\"Build id, set by ld(1)\")\t\\\n_ELF_DEFINE_NT(NT_GNU_GOLD_VERSION, 4,\t\t\t\t\t\\\n\t\"Version number of the GNU gold linker\")\t\t\t\\\n_ELF_DEFINE_NT(NT_PRSTATUS,\t1,\t\"Process status\")\t\t\\\n_ELF_DEFINE_NT(NT_FPREGSET,\t2,\t\"Floating point information\")\t\\\n_ELF_DEFINE_NT(NT_PRPSINFO,\t3,\t\"Process information\")\t\t\\\n_ELF_DEFINE_NT(NT_AUXV,\t\t6,\t\"Auxiliary vector\")\t\t\\\n_ELF_DEFINE_NT(NT_PRXFPREG,\t0x46E62B7FUL,\t\t\t\t\\\n\t\"Linux user_xfpregs structure\")\t\t\t\t\t\\\n_ELF_DEFINE_NT(NT_PSTATUS,\t10,\t\"Linux process status\")\t\t\\\n_ELF_DEFINE_NT(NT_FPREGS,\t12,\t\"Linux floating point regset\")\t\\\n_ELF_DEFINE_NT(NT_PSINFO,\t13,\t\"Linux process information\")\t\\\n_ELF_DEFINE_NT(NT_LWPSTATUS,\t16,\t\"Linux lwpstatus_t type\")\t\\\n_ELF_DEFINE_NT(NT_LWPSINFO,\t17,\t\"Linux lwpinfo_t type\")\n\n#undef\t_ELF_DEFINE_NT\n#define\t_ELF_DEFINE_NT(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_NOTE_ENTRY_TYPES()\n\tNT__LAST__\n};\n\n/* Aliases for the ABI tag. */\n#define\tNT_FREEBSD_ABI_TAG\tNT_ABI_TAG\n#define\tNT_GNU_ABI_TAG\t\tNT_ABI_TAG\n#define\tNT_NETBSD_IDENT\t\tNT_ABI_TAG\n#define\tNT_OPENBSD_IDENT\tNT_ABI_TAG\n\n/*\n * Note descriptors.\n */\n\ntypedef\tstruct {\n\tuint32_t\tn_namesz;    /* Length of note's name. */\n\tuint32_t\tn_descsz;    /* Length of note's value. */\n\tuint32_t\tn_type;\t     /* Type of note. */\n} Elf_Note;\n\ntypedef Elf_Note Elf32_Nhdr;\t     /* 32-bit note header. */\ntypedef Elf_Note Elf64_Nhdr;\t     /* 64-bit note header. */\n\n/*\n * MIPS ELF options descriptor header.\n */\n\ntypedef struct {\n\tElf64_Byte\tkind;        /* Type of options. */\n\tElf64_Byte     \tsize;\t     /* Size of option descriptor. */\n\tElf64_Half\tsection;     /* Index of section affected. */\n\tElf64_Word\tinfo;        /* Kind-specific information. */\n} Elf_Options;\n\n/*\n * Option kinds.\n */\n\n#define\t_ELF_DEFINE_OPTION_KINDS()\t\t\t\t\t\\\n_ELF_DEFINE_ODK(ODK_NULL,       0,      \"undefined\")\t\t\t\\\n_ELF_DEFINE_ODK(ODK_REGINFO,    1,      \"register usage info\")\t\t\\\n_ELF_DEFINE_ODK(ODK_EXCEPTIONS, 2,      \"exception processing info\")\t\\\n_ELF_DEFINE_ODK(ODK_PAD,        3,      \"section padding\")\t\t\\\n_ELF_DEFINE_ODK(ODK_HWPATCH,    4,      \"hardware patch applied\")\t\\\n_ELF_DEFINE_ODK(ODK_FILL,       5,      \"fill value used by linker\")\t\\\n_ELF_DEFINE_ODK(ODK_TAGS,       6,      \"reserved space for tools\")\t\\\n_ELF_DEFINE_ODK(ODK_HWAND,      7,      \"hardware AND patch applied\")\t\\\n_ELF_DEFINE_ODK(ODK_HWOR,       8,      \"hardware OR patch applied\")\t\\\n_ELF_DEFINE_ODK(ODK_GP_GROUP,   9,\t\t\t\t\t\\\n\t\"GP group to use for text/data sections\")\t\t\t\\\n_ELF_DEFINE_ODK(ODK_IDENT,      10,     \"ID information\")\t\t\\\n_ELF_DEFINE_ODK(ODK_PAGESIZE,   11,     \"page size infomation\")\n\n#undef\t_ELF_DEFINE_ODK\n#define\t_ELF_DEFINE_ODK(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_OPTION_KINDS()\n\tODK__LAST__\n};\n\n/*\n * ODK_EXCEPTIONS info field masks.\n */\n\n#define\t_ELF_DEFINE_ODK_EXCEPTIONS_MASK()\t\t\t\t\\\n_ELF_DEFINE_OEX(OEX_FPU_MIN,    0x0000001FUL,\t\t\t\t\\\n\t\"minimum FPU exception which must be enabled\")\t\t\t\\\n_ELF_DEFINE_OEX(OEX_FPU_MAX,    0x00001F00UL,\t\t\t\t\\\n\t\"maximum FPU exception which can be enabled\")\t\t\t\\\n_ELF_DEFINE_OEX(OEX_PAGE0,      0x00010000UL,\t\t\t\t\\\n\t\"page zero must be mapped\")\t\t\t\t\t\\\n_ELF_DEFINE_OEX(OEX_SMM,        0x00020000UL,\t\t\t\t\\\n\t\"run in sequential memory mode\")\t\t\t\t\\\n_ELF_DEFINE_OEX(OEX_PRECISEFP,  0x00040000UL,\t\t\t\t\\\n\t\"run in precise FP exception mode\")\t\t\t\t\\\n_ELF_DEFINE_OEX(OEX_DISMISS,    0x00080000UL,\t\t\t\t\\\n\t\"dismiss invalid address traps\")\n\n#undef\t_ELF_DEFINE_OEX\n#define\t_ELF_DEFINE_OEX(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_ODK_EXCEPTIONS_MASK()\n\tOEX__LAST__\n};\n\n/*\n * ODK_PAD info field masks.\n */\n\n#define\t_ELF_DEFINE_ODK_PAD_MASK()\t\t\t\t\t\\\n_ELF_DEFINE_OPAD(OPAD_PREFIX,   0x0001)\t\t\t\t\t\\\n_ELF_DEFINE_OPAD(OPAD_POSTFIX,  0x0002)\t\t\t\t\t\\\n_ELF_DEFINE_OPAD(OPAD_SYMBOL,   0x0004)\n\n#undef\t_ELF_DEFINE_OPAD\n#define\t_ELF_DEFINE_OPAD(N, V)\t\tN = V ,\nenum {\n\t_ELF_DEFINE_ODK_PAD_MASK()\n\tOPAD__LAST__\n};\n\n/*\n * ODK_HWPATCH info field masks.\n */\n\n#define\t_ELF_DEFINE_ODK_HWPATCH_MASK()\t\t\t\t\t\\\n_ELF_DEFINE_OHW(OHW_R4KEOP,     0x00000001UL,\t\t\t\t\\\n\t\"patch for R4000 branch at end-of-page bug\")\t\t\t\\\n_ELF_DEFINE_OHW(OHW_R8KPFETCH,  0x00000002UL,\t\t\t\t\\\n\t\"R8000 prefetch bug may occur\")\t\t\t\t\t\\\n_ELF_DEFINE_OHW(OHW_R5KEOP,     0x00000004UL,\t\t\t\t\\\n\t\"patch for R5000 branch at end-of-page bug\")\t\t\t\\\n_ELF_DEFINE_OHW(OHW_R5KCVTL,    0x00000008UL,\t\t\t\t\\\n\t\"R5000 cvt.[ds].l bug: clean == 1\")\t\t\t\t\\\n_ELF_DEFINE_OHW(OHW_R10KLDL,    0x00000010UL,\t\t\t\t\\\n\t\"needd patch for R10000 misaligned load\")\n\n#undef\t_ELF_DEFINE_OHW\n#define\t_ELF_DEFINE_OHW(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_ODK_HWPATCH_MASK()\n\tOHW__LAST__\n};\n\n/*\n * ODK_HWAND/ODK_HWOR info field and hwp_flags[12] masks.\n */\n\n#define\t_ELF_DEFINE_ODK_HWP_MASK()\t\t\t\t\t\\\n_ELF_DEFINE_HWP(OHWA0_R4KEOP_CHECKED, 0x00000001UL,\t\t\t\\\n\t\"object checked for R4000 end-of-page bug\")\t\t\t\\\n_ELF_DEFINE_HWP(OHWA0_R4KEOP_CLEAN, 0x00000002UL,\t\t\t\\\n\t\"object verified clean for R4000 end-of-page bug\")\t\t\\\n_ELF_DEFINE_HWP(OHWO0_FIXADE,   0x00000001UL,\t\t\t\t\\\n\t\"object requires call to fixade\")\n\n#undef\t_ELF_DEFINE_HWP\n#define\t_ELF_DEFINE_HWP(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_ODK_HWP_MASK()\n\tOHWX0__LAST__\n};\n\n/*\n * ODK_IDENT/ODK_GP_GROUP info field masks.\n */\n\n#define\t_ELF_DEFINE_ODK_GP_MASK()\t\t\t\t\t\\\n_ELF_DEFINE_OGP(OGP_GROUP,      0x0000FFFFUL, \"GP group number\")\t\\\n_ELF_DEFINE_OGP(OGP_SELF,       0x00010000UL,\t\t\t\t\\\n\t\"GP group is self-contained\")\n\n#undef\t_ELF_DEFINE_OGP\n#define\t_ELF_DEFINE_OGP(N, V, DESCR)\tN = V ,\nenum {\n\t_ELF_DEFINE_ODK_GP_MASK()\n\tOGP__LAST__\n};\n\n/*\n * MIPS ELF register info descriptor.\n */\n\n/* 32 bit RegInfo entry. */\ntypedef struct {\n\tElf32_Word\tri_gprmask;  /* Mask of general register used. */\n\tElf32_Word\tri_cprmask[4]; /* Mask of coprocessor register used. */\n\tElf32_Addr\tri_gp_value; /* GP register value. */\n} Elf32_RegInfo;\n\n/* 64 bit RegInfo entry. */\ntypedef struct {\n\tElf64_Word\tri_gprmask;  /* Mask of general register used. */\n\tElf64_Word\tri_pad;\t     /* Padding. */\n\tElf64_Word\tri_cprmask[4]; /* Mask of coprocessor register used. */\n\tElf64_Addr\tri_gp_value; /* GP register value. */\n} Elf64_RegInfo;\n\n/*\n * Program Header Table (PHDR) entries.\n */\n\n/* 32 bit PHDR entry. */\ntypedef struct {\n\tElf32_Word\tp_type;\t     /* Type of segment. */\n\tElf32_Off\tp_offset;    /* File offset to segment. */\n\tElf32_Addr\tp_vaddr;     /* Virtual address in memory. */\n\tElf32_Addr\tp_paddr;     /* Physical address (if relevant). */\n\tElf32_Word\tp_filesz;    /* Size of segment in file. */\n\tElf32_Word\tp_memsz;     /* Size of segment in memory. */\n\tElf32_Word\tp_flags;     /* Segment flags. */\n\tElf32_Word\tp_align;     /* Alignment constraints. */\n} Elf32_Phdr;\n\n/* 64 bit PHDR entry. */\ntypedef struct {\n\tElf64_Word\tp_type;\t     /* Type of segment. */\n\tElf64_Word\tp_flags;     /* File offset to segment. */\n\tElf64_Off\tp_offset;    /* Virtual address in memory. */\n\tElf64_Addr\tp_vaddr;     /* Physical address (if relevant). */\n\tElf64_Addr\tp_paddr;     /* Size of segment in file. */\n\tElf64_Xword\tp_filesz;    /* Size of segment in memory. */\n\tElf64_Xword\tp_memsz;     /* Segment flags. */\n\tElf64_Xword\tp_align;     /* Alignment constraints. */\n} Elf64_Phdr;\n\n\n/*\n * Move entries, for describing data in COMMON blocks in a compact\n * manner.\n */\n\n/* 32-bit move entry. */\ntypedef struct {\n\tElf32_Lword\tm_value;     /* Initialization value. */\n\tElf32_Word \tm_info;\t     /* Encoded size and index. */\n\tElf32_Word\tm_poffset;   /* Offset relative to symbol. */\n\tElf32_Half\tm_repeat;    /* Repeat count. */\n\tElf32_Half\tm_stride;    /* Number of units to skip. */\n} Elf32_Move;\n\n/* 64-bit move entry. */\ntypedef struct {\n\tElf64_Lword\tm_value;     /* Initialization value. */\n\tElf64_Xword \tm_info;\t     /* Encoded size and index. */\n\tElf64_Xword\tm_poffset;   /* Offset relative to symbol. */\n\tElf64_Half\tm_repeat;    /* Repeat count. */\n\tElf64_Half\tm_stride;    /* Number of units to skip. */\n} Elf64_Move;\n#ifndef ELF32_M_SYM\n#define ELF32_M_SYM(I)\t\t((I) >> 8)\n#endif\n#ifndef ELF32_M_SIZE\n#define ELF32_M_SIZE(I)\t\t((unsigned char) (I))\n#endif\n#ifndef ELF32_M_INFO\n#define ELF32_M_INFO(M, S)\t(((M) << 8) + (unsigned char) (S))\n#endif\n\n#ifndef ELF64_M_SYM\n#define ELF64_M_SYM(I)\t\t((I) >> 8)\n#endif\n#ifndef ELF64_M_SIZE\n#define ELF64_M_SIZE(I)\t\t((unsigned char) (I))\n#endif\n#ifndef ELF64_M_INFO\n#define ELF64_M_INFO(M, S)\t(((M) << 8) + (unsigned char) (S))\n#endif\n\n/*\n * Section Header Table (SHDR) entries.\n */\n\n/* 32 bit SHDR */\ntypedef struct {\n\tElf32_Word\tsh_name;     /* index of section name */\n\tElf32_Word\tsh_type;     /* section type */\n\tElf32_Word\tsh_flags;    /* section flags */\n\tElf32_Addr\tsh_addr;     /* in-memory address of section */\n\tElf32_Off\tsh_offset;   /* file offset of section */\n\tElf32_Word\tsh_size;     /* section size in bytes */\n\tElf32_Word\tsh_link;     /* section header table link */\n\tElf32_Word\tsh_info;     /* extra information */\n\tElf32_Word\tsh_addralign; /* alignment constraint */\n\tElf32_Word\tsh_entsize;   /* size for fixed-size entries */\n} Elf32_Shdr;\n\n/* 64 bit SHDR */\ntypedef struct {\n\tElf64_Word\tsh_name;     /* index of section name */\n\tElf64_Word\tsh_type;     /* section type */\n\tElf64_Xword\tsh_flags;    /* section flags */\n\tElf64_Addr\tsh_addr;     /* in-memory address of section */\n\tElf64_Off\tsh_offset;   /* file offset of section */\n\tElf64_Xword\tsh_size;     /* section size in bytes */\n\tElf64_Word\tsh_link;     /* section header table link */\n\tElf64_Word\tsh_info;     /* extra information */\n\tElf64_Xword\tsh_addralign; /* alignment constraint */\n\tElf64_Xword\tsh_entsize;  /* size for fixed-size entries */\n} Elf64_Shdr;\n\n\n/*\n * Symbol table entries.\n */\n\ntypedef struct {\n\tElf32_Word\tst_name;     /* index of symbol's name */\n\tElf32_Addr\tst_value;    /* value for the symbol */\n\tElf32_Word\tst_size;     /* size of associated data */\n\tunsigned char\tst_info;     /* type and binding attributes */\n\tunsigned char\tst_other;    /* visibility */\n\tElf32_Half\tst_shndx;    /* index of related section */\n} Elf32_Sym;\n\ntypedef struct {\n\tElf64_Word\tst_name;     /* index of symbol's name */\n\tunsigned char\tst_info;     /* value for the symbol */\n\tunsigned char\tst_other;    /* size of associated data */\n\tElf64_Half\tst_shndx;    /* type and binding attributes */\n\tElf64_Addr\tst_value;    /* visibility */\n\tElf64_Xword\tst_size;     /* index of related section */\n} Elf64_Sym;\n#ifndef ELF32_ST_BIND\n#define ELF32_ST_BIND(I)\t((I) >> 4)\n#endif\n#ifndef ELF32_ST_TYPE\n#define ELF32_ST_TYPE(I)\t((I) & 0xFU)\n#endif\n#ifndef ELF32_ST_INFO\n#define ELF32_ST_INFO(B,T)\t(((B) << 4) + ((T) & 0xF))\n#endif\n\n#ifndef ELF64_ST_BIND\n#define ELF64_ST_BIND(I)\t((I) >> 4)\n#endif\n#ifndef ELF64_ST_TYPE\n#define ELF64_ST_TYPE(I)\t((I) & 0xFU)\n#endif\n#ifndef ELF64_ST_INFO\n#define ELF64_ST_INFO(B,T)\t(((B) << 4) + ((T) & 0xF))\n#endif\n\n#ifndef ELF32_ST_VISIBILITY\n#define ELF32_ST_VISIBILITY(O)\t((O) & 0x3)\n#endif\n\n#ifndef ELF64_ST_VISIBILITY\n#define ELF64_ST_VISIBILITY(O)\t((O) & 0x3)\n#endif\n\n/*\n * Syminfo descriptors, containing additional symbol information.\n */\n\n/* 32-bit entry. */\ntypedef struct {\n\tElf32_Half\tsi_boundto;  /* Entry index with additional flags. */\n\tElf32_Half\tsi_flags;    /* Flags. */\n} Elf32_Syminfo;\n\n/* 64-bit entry. */\ntypedef struct {\n\tElf64_Half\tsi_boundto;  /* Entry index with additional flags. */\n\tElf64_Half\tsi_flags;    /* Flags. */\n} Elf64_Syminfo;\n\n/*\n * Relocation descriptors.\n */\n\ntypedef struct {\n\tElf32_Addr\tr_offset;    /* location to apply relocation to */\n\tElf32_Word\tr_info;\t     /* type+section for relocation */\n} Elf32_Rel;\n\ntypedef struct {\n\tElf32_Addr\tr_offset;    /* location to apply relocation to */\n\tElf32_Word\tr_info;      /* type+section for relocation */\n\tElf32_Sword\tr_addend;    /* constant addend */\n} Elf32_Rela;\n\ntypedef struct {\n\tElf64_Addr\tr_offset;    /* location to apply relocation to */\n\tElf64_Xword\tr_info;      /* type+section for relocation */\n} Elf64_Rel;\n\ntypedef struct {\n\tElf64_Addr\tr_offset;    /* location to apply relocation to */\n\tElf64_Xword\tr_info;      /* type+section for relocation */\n\tElf64_Sxword\tr_addend;    /* constant addend */\n} Elf64_Rela;\n\n#ifndef ELF32_R_SYM\n#define ELF32_R_SYM(I)\t\t((I) >> 8)\n#endif\n#ifndef ELF32_R_TYPE\n#define ELF32_R_TYPE(I)\t\t((unsigned char) (I))\n#endif\n#ifndef ELF32_R_INFO\n#define ELF32_R_INFO(S,T)\t(((S) << 8) + (unsigned char) (T))\n#endif\n#ifndef ELF64_R_SYM\n#define ELF64_R_SYM(I)\t\t((I) >> 32)\n#endif\n#ifndef ELF64_R_TYPE\n#define ELF64_R_TYPE(I)\t\t((I) & 0xFFFFFFFFUL)\n#endif\n#ifndef ELF64_R_INFO\n#define ELF64_R_INFO(S,T)\t(((S) << 32) + ((T) & 0xFFFFFFFFUL))\n#endif\n\n/*\n * Symbol versioning structures.\n */\n\n/* 32-bit structures. */\ntypedef struct\n{\n\tElf32_Word\tvda_name;    /* Index to name. */\n\tElf32_Word\tvda_next;    /* Offset to next entry. */\n} Elf32_Verdaux;\n\ntypedef struct\n{\n\tElf32_Word\tvna_hash;    /* Hash value of dependency name. */\n\tElf32_Half\tvna_flags;   /* Flags. */\n\tElf32_Half\tvna_other;   /* Unused. */\n\tElf32_Word\tvna_name;    /* Offset to dependency name. */\n\tElf32_Word\tvna_next;    /* Offset to next vernaux entry. */\n} Elf32_Vernaux;\n\ntypedef struct\n{\n\tElf32_Half\tvd_version;  /* Version information. */\n\tElf32_Half\tvd_flags;    /* Flags. */\n\tElf32_Half\tvd_ndx;\t     /* Index into the versym section. */\n\tElf32_Half\tvd_cnt;\t     /* Number of aux entries. */\n\tElf32_Word\tvd_hash;     /* Hash value of name. */\n\tElf32_Word\tvd_aux;\t     /* Offset to aux entries. */\n\tElf32_Word\tvd_next;     /* Offset to next version definition. */\n} Elf32_Verdef;\n\ntypedef struct\n{\n\tElf32_Half\tvn_version;  /* Version number. */\n\tElf32_Half\tvn_cnt;\t     /* Number of aux entries. */\n\tElf32_Word\tvn_file;     /* Offset of associated file name. */\n\tElf32_Word\tvn_aux;\t     /* Offset of vernaux array. */\n\tElf32_Word\tvn_next;     /* Offset of next verneed entry. */\n} Elf32_Verneed;\n\ntypedef Elf32_Half\tElf32_Versym;\n\n/* 64-bit structures. */\n\ntypedef struct {\n\tElf64_Word\tvda_name;    /* Index to name. */\n\tElf64_Word\tvda_next;    /* Offset to next entry. */\n} Elf64_Verdaux;\n\ntypedef struct {\n\tElf64_Word\tvna_hash;    /* Hash value of dependency name. */\n\tElf64_Half\tvna_flags;   /* Flags. */\n\tElf64_Half\tvna_other;   /* Unused. */\n\tElf64_Word\tvna_name;    /* Offset to dependency name. */\n\tElf64_Word\tvna_next;    /* Offset to next vernaux entry. */\n} Elf64_Vernaux;\n\ntypedef struct {\n\tElf64_Half\tvd_version;  /* Version information. */\n\tElf64_Half\tvd_flags;    /* Flags. */\n\tElf64_Half\tvd_ndx;\t     /* Index into the versym section. */\n\tElf64_Half\tvd_cnt;\t     /* Number of aux entries. */\n\tElf64_Word\tvd_hash;     /* Hash value of name. */\n\tElf64_Word\tvd_aux;\t     /* Offset to aux entries. */\n\tElf64_Word\tvd_next;     /* Offset to next version definition. */\n} Elf64_Verdef;\n\ntypedef struct {\n\tElf64_Half\tvn_version;  /* Version number. */\n\tElf64_Half\tvn_cnt;\t     /* Number of aux entries. */\n\tElf64_Word\tvn_file;     /* Offset of associated file name. */\n\tElf64_Word\tvn_aux;\t     /* Offset of vernaux array. */\n\tElf64_Word\tvn_next;     /* Offset of next verneed entry. */\n} Elf64_Verneed;\n\ntypedef Elf64_Half\tElf64_Versym;\n\n\n#ifndef\tLIBELF_CONFIG_GNUHASH\n#define\tLIBELF_CONFIG_GNUHASH\t1\n\n/*\n * The header for GNU-style hash sections.\n */\n\ntypedef struct {\n\tuint32_t\tgh_nbuckets;\t/* Number of hash buckets. */\n\tuint32_t\tgh_symndx;\t/* First visible symbol in .dynsym. */\n\tuint32_t\tgh_maskwords;\t/* #maskwords used in bloom filter. */\n\tuint32_t\tgh_shift2;\t/* Bloom filter shift count. */\n} Elf_GNU_Hash_Header;\n#endif\n\n#endif\t/* _ELFDEFINITIONS_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.7.0-6twwcw3rjraboiuw75ysfcdddj55uxkg/spack-src/device/pal/paldevicegl.cpp": "/* Copyright (c) 2015-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#include \"platform/context.hpp\"\n#include \"device/device.hpp\"\n#include \"platform/runtime.hpp\"\n#include \"platform/agent.hpp\"\n#ifdef _WIN32\n#include <d3d10_1.h>\n#include \"CL/cl_d3d10.h\"\n#include \"CL/cl_d3d11.h\"\n#endif  // _WIN32\n\n#include <GL/gl.h>\n#include <GL/glext.h>\n#include \"CL/cl_gl.h\"\n#include \"paldevice.hpp\"\n//#include \"cwddeci.h\"\n#include <GL/gl.h>\n#include \"GL/glATIInternal.h\"\n#ifdef ATI_OS_LINUX\n#include <stdlib.h>\n#include <dlfcn.h>\n#include \"GL/glx.h\"\n#include \"GL/glxext.h\"\n#include \"GL/glXATIPrivate.h\"\n#else\n#include \"GL/wglATIPrivate.h\"\n#endif\n\n/**\n * Device information returned by Mesa/Orca.\n */\ntypedef struct _mesa_glinterop_device_info {\n  uint32_t size; /* size of this structure */\n\n  /* PCI location */\n  uint32_t pci_segment_group;\n  uint32_t pci_bus;\n  uint32_t pci_device;\n  uint32_t pci_function;\n\n  /* Device identification */\n  uint32_t vendor_id;\n  uint32_t device_id;\n} mesa_glinterop_device_info;\n\n#ifdef ATI_OS_LINUX\ntypedef void* (*PFNGlxGetProcAddress)(const GLubyte* procName);\nstatic PFNGlxGetProcAddress pfnGlxGetProcAddress = nullptr;\ntypedef int(APIENTRYP PFNMesaGLInteropGLXQueryDeviceInfo)(Display* dpy, GLXContext context,\n                                                          mesa_glinterop_device_info* out);\nstatic PFNMesaGLInteropGLXQueryDeviceInfo pfnMesaGLInteropGLXQueryDeviceInfo = nullptr;\nstatic PFNGLXBEGINCLINTEROPAMD glXBeginCLInteropAMD = nullptr;\nstatic PFNGLXENDCLINTEROPAMD glXEndCLInteropAMD = nullptr;\nstatic PFNGLXRESOURCEATTACHAMD glXResourceAttachAMD = nullptr;\nstatic PFNGLXRESOURCEDETACHAMD glxResourceAcquireAMD = nullptr;\nstatic PFNGLXRESOURCEDETACHAMD glxResourceReleaseAMD = nullptr;\nstatic PFNGLXRESOURCEDETACHAMD glXResourceDetachAMD = nullptr;\nstatic PFNGLXGETCONTEXTMVPUINFOAMD glXGetContextMVPUInfoAMD = nullptr;\n#else\nstatic PFNWGLBEGINCLINTEROPAMD wglBeginCLInteropAMD = nullptr;\nstatic PFNWGLENDCLINTEROPAMD wglEndCLInteropAMD = nullptr;\nstatic PFNWGLRESOURCEATTACHAMD wglResourceAttachAMD = nullptr;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceAcquireAMD = nullptr;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceReleaseAMD = nullptr;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceDetachAMD = nullptr;\nstatic PFNWGLGETCONTEXTGPUINFOAMD wglGetContextGPUInfoAMD = nullptr;\n#endif\n\nnamespace pal {\n\n//\n/// GSL Surface Formats as per defined in cmSurfFmtEnum enum in\n/// //depot/stg/ugl/drivers/ugl/src/include/cm_enum.h\n//\ntypedef enum cmSurfFmtEnum {\n  CM_SURF_FMT_NOOVERRIDE = -1,\n  CM_SURF_FMT_LUMINANCE8,    ///< Luminance,  8 bits per element packed as (@c LLLLLLLL)\n  CM_SURF_FMT_LUMINANCE16,   ///< Luminance, 16 bits per element packed as (@c LLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE16F,  ///< Luminance, 16 bits per element packed as (@c LLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE32F,  ///< Luminance, 32 bits per element packed as (@c\n                             ///< LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_INTENSITY8,    ///< Intensity,  8 bits per element packed as (@c IIIIIIII)\n  CM_SURF_FMT_INTENSITY16,   ///< Intensity, 16 bits per element packed as (@c IIIIIIIIIIIIIIII)\n  CM_SURF_FMT_INTENSITY16F,  ///< Intensity, 16 bits per element packed as (@c IIIIIIIIIIIIIIII)\n  CM_SURF_FMT_INTENSITY32F,  ///< Intensity, 32 bits per element packed as (@c\n                             ///< IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII)\n  CM_SURF_FMT_ALPHA8,        ///< Alpha,      8 bits per element packed as (@c AAAAAAAA)\n  CM_SURF_FMT_ALPHA16,       ///< Alpha,     16 bits per element packed as (@c AAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_ALPHA16F,      ///< Alpha,     16 bits per element packed as (@c AAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_ALPHA32F,      ///< Alpha,     32 bits per element packed as (@c\n                             ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_LUMINANCE8_ALPHA8,      ///< Luminance Alpha, 16 bits per element packed as (@c\n                                      ///< AAAAAAAALLLLLLLL)\n  CM_SURF_FMT_LUMINANCE16_ALPHA16,    ///< Luminance Alpha, 32 bits per element packed as (@c\n                                      ///< AAAAAAAAAAAAAAAALLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE16F_ALPHA16F,  ///< Luminance Alpha, 32 bits per element packed as (@c\n                                      ///< AAAAAAAAAAAAAAAALLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE32F_ALPHA32F,  ///< Luminance Alpha, 64 bits per element packed as (@c\n                                      ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_B2_G3_R3,  ///< RGB,    8 bits per element packed as (@c RRRGGGBB)\n  CM_SURF_FMT_B5_G6_R5,  ///< RGB,   16 bits per element packed as (@c RRRRRGGGGGGBBBBB)\n  CM_SURF_FMT_BGRX4,     ///< RGB,   16 bits per element packed as (@c XXXXRRRRGGGGBBBB)\n  CM_SURF_FMT_BGR5_X1,   ///< RGB,   16 bits per element packed as (@c XRRRRRGGGGGBBBBB)\n  CM_SURF_FMT_BGRX8,     ///< RGB,   32 bits per element packed as (@c\n                         ///< XXXXXXXXRRRRRRRRGGGGGGGGBBBBBBBB) - XXX unused by current driver\n  CM_SURF_FMT_BGR10_X2,  ///< RGB,   32 bits per element packed as (@c\n                         ///< XXRRRRRRRRRRGGGGGGGGGGBBBBBBBBBB)\n  CM_SURF_FMT_BGRX16,    ///< RGB,   64 bits per element packed as (@c\n                         ///< XXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_BGRX16F,   ///< RGB,   64 bits per element packed as (@c\n                         ///< XXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_BGRX32F,   ///< RGB,  128 bits per element packed as (@c\n                        ///< XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_RGBX4,     ///< RGB,   16 bits per element packed as (@c XXXXBBBBGGGGRRRR)\n  CM_SURF_FMT_RGB5_X1,   ///< RGB,   16 bits per element packed as (@c XBBBBBGGGGGRRRRR)\n  CM_SURF_FMT_RGBX8,     ///< RGB,   32 bits per element packed as (@c\n                         ///< XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGB10_X2,  ///< RGB,   32 bits per element packed as (@c\n                         ///< XXBBBBBBBBBBGGGGGGGGGGRRRRRRRRRR)\n  CM_SURF_FMT_RGBX16,    ///< RGB,   64 bits per element packed as (@c\n                         ///< XXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBX16F,   ///< RGB,   64 bits per element packed as (@c\n                         ///< XXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBX32F,   ///< RGB,  128 bits per element packed as (@c\n                        ///< XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_BGRA4,     ///< RGBA,  16 bits per element packed as (@c AAAARRRRGGGGBBBB)\n  CM_SURF_FMT_BGR5_A1,   ///< RGBA,  16 bits per element packed as (@c ARRRRRGGGGGBBBBB)\n  CM_SURF_FMT_BGRA8,     ///< RGBA,  32 bits per element packed as (@c\n                         ///< AAAAAAAARRRRRRRRGGGGGGGGBBBBBBBB)\n  CM_SURF_FMT_BGR10_A2,  ///< RGBA,  32 bits per element packed as (@c\n                         ///< AARRRRRRRRRRGGGGGGGGGGBBBBBBBBBB)\n  CM_SURF_FMT_BGRA16,    ///< RGBA,  64 bits per element packed as (@c\n                         ///< AAAAAAAAAAAAAAAARRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_BGRA16F,   ///< RGBA,  64 bits per element packed as (@c\n                         ///< AAAAAAAAAAAAAAAARRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_BGRA32F,   ///< RGBA, 128 bits per element packed as (@c\n                        ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_RGBA4,     ///< RGBA,  16 bits per element packed as (@c AAAABBBBGGGGRRRR)\n  CM_SURF_FMT_RGB5_A1,   ///< RGBA,  16 bits per element packed as (@c ABBBBBGGGGGRRRRR)\n  CM_SURF_FMT_RGBA8,     ///< RGBA,  32 bits per element packed as (@c\n                         ///< AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGB10_A2,  ///< RGBA,  32 bits per element packed as (@c\n                         ///< AABBBBBBBBBBGGGGGGGGGGRRRRRRRRRR)\n  CM_SURF_FMT_RGBA16,    ///< RGBA,  64 bits per element packed as (@c\n                         ///< AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBA16F,   ///< RGBA,  64 bits per element packed as (@c\n                         ///< AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBA32I,   ///< RGBA, 128 bits per element packed as (@c\n                        ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBA32F,  ///< RGBA, 128 bits per element packed as (@c\n                        ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_DUDV8,    ///< DUDV   16 bits per element packed as (@c VVVVVVVVUUUUUUUU)\n  CM_SURF_FMT_DXT1,     ///< compressed, DXT1\n  CM_SURF_FMT_DXT2_3,   ///< compressed, DXT2_3\n  CM_SURF_FMT_DXT4_5,   ///< compressed, DXT4_5\n  CM_SURF_FMT_ATI1N,    ///< compressed, 1 component\n  CM_SURF_FMT_ATI2N,    ///< compressed, 2 component\n  CM_SURF_FMT_DEPTH16,  ///< depth, 16 bits per element packed as (@c DDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH16F,            ///< depth, 16 bits per element packed as (@c DDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH24_X8,          ///< depth, 32 bits per element packed as (@c\n                                   ///< XXXXXXXXDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH24F_X8,         ///< depth, 32 bits per element packed as (@c\n                                   ///< SSSSSSSSDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH24_STEN8,       ///< depth + stencil, 32 bits per element packed as (@c\n                                   ///< SSSSSSSSDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH24F_STEN8,      ///< depth + stencil, 32 bits per element packed as (@c\n                                   ///< SSSSSSSSDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH32F_X24_STEN8,  ///< depth + stencil, 64 bits per element packed as (@c\n                                   ///< XXXXXXXXXXXXXXXXXXXXXXXXSSSSSSSSDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH32F,        ///< depth, 32 bits per element packed as (@c\n                               ///< DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_sR11_sG11_sB10,  ///< RGB,   32 bits per element packed as (@c\n                               ///< RRRRRRRRRRRGGGGGGGGGGGBBBBBBBBBB)\n  CM_SURF_FMT_sU16,            ///<\n  CM_SURF_FMT_sUV16,           ///<\n  CM_SURF_FMT_sUVWQ16,         ///<\n  CM_SURF_FMT_RG16,  ///< RG,    32 bits per element packed as (@c RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_RG16F,     ///< RG,    32 bits per element packed as (@c\n                         ///< RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_RG32F,     ///< RG,    64 bits per element packed as (@c\n                         ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_ABGR4,     ///< RGBA,  16 bits per element packed as (@c RRRRGGGGBBBBAAAA)\n  CM_SURF_FMT_A1_BGR5,   ///< RGBA,  16 bits per element packed as (@c RRRRRGGGGGBBBBBA)\n  CM_SURF_FMT_ABGR8,     ///< RGBA,  32 bits per element packed as (@c\n                         ///< RRRRRRRRGGGGGGGGBBBBBBBBAAAAAAAA)\n  CM_SURF_FMT_A2_BGR10,  ///< RGBA,  32 bits per element packed as (@c\n                         ///< RRRRRRRRRRGGGGGGGGGGBBBBBBBBBBAA)\n  CM_SURF_FMT_ABGR16,    ///< RGBA,  64 bits per element packed as (@c\n                         ///< RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_ABGR16F,   ///< RGBA,  64 bits per element packed as (@c\n                         ///< RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_ABGR32F,   ///< RGBA, 128 bits per element packed as (@c\n                        ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_DXT1A,\n  CM_SURF_FMT_sRGB10_A2,  ///< RGBA,  32  bits per element packed as signed (@c\n                          ///< AABBBBBBBBBBGGGGGGGGGGRRRRRRRRRR)\n  CM_SURF_FMT_sR8,        ///< R,     8   bits per element packed as signed (@c RRRRRRRR)\n  CM_SURF_FMT_sRG8,       ///< RG,    16  bits per element packed as signed (@c RRRRRRRRGGGGGGGG)\n  CM_SURF_FMT_sR32I,      ///< R,     32  bits per element packed as signed (@c\n                          ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_sRG32I,     ///< RG,    64  bits per element packed as signed (@c\n                          ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_sRGBA32I,   ///< RGBA,  128 bits per element packed as signed (@c\n                         ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_R32I,    ///< R,     32  bits per element packed as (@c\n                       ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RG32I,   ///< RG,    64  bits per element packed as (@c\n                       ///< RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_RG8,     ///< RG8,   16 bits per element packed as (@c RRRRRRRRGGGGGGGG)\n  CM_SURF_FMT_sRGBA8,  ///< RGBA8, 32 bits per element packed as signed (@c\n                       ///< RRRRRRRRGGGGGGGGBBBBBBBBAAAAAAAA)\n  CM_SURF_FMT_R11F_G11F_B10F,                ///< RGB,   32 bits per element packed as (@c\n                                             ///< BBBBBBBBBBGGGGGGGGGGGRRRRRRRRRRR)\n  CM_SURF_FMT_RGB9_E5,                       ///< RGB,   32 bits per element packed as (@c\n                                             ///< EEEEEBBBBBBBBBGGGGGGGGGRRRRRRRRR)\n  CM_SURF_FMT_LUMINANCE_LATC1,               ///< compressed LATC1\n  CM_SURF_FMT_SIGNED_LUMINANCE_LATC1,        ///< compressed signed LATC1\n  CM_SURF_FMT_LUMINANCE_ALPHA_LATC2,         ///< compressed LATC2\n  CM_SURF_FMT_SIGNED_LUMINANCE_ALPHA_LATC2,  ///< compressed signed LATC2\n  CM_SURF_FMT_RED_RGTC1,                     ///< compressed RGTC1\n  CM_SURF_FMT_SIGNED_RED_RGTC1,              ///< compressed signed RGTC1\n  CM_SURF_FMT_RED_GREEN_RGTC2,               ///< compressed RGTC2\n  CM_SURF_FMT_SIGNED_RED_GREEN_RGTC2,        ///< compressed signed RGTC2\n  CM_SURF_FMT_R8,                            ///< R,     8   bits per element packed (@c RRRRRRRR)\n  CM_SURF_FMT_R16,     ///< R,    16   bits per element packed (@c RRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_R16F,    ///< R,    16   bits per element packed (@c RRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_R32F,    ///< R,    32   bits per element packed (@c RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_R8I,     ///< R,     8   bits per element packed (@c RRRRRRRR)\n  CM_SURF_FMT_sR8I,    ///< R,     8   bits per element packed as signed (@c RRRRRRRR)\n  CM_SURF_FMT_RG8I,    ///< RG,   16   bits per element packed (@c RRRRRRRRGGGGGGGG)\n  CM_SURF_FMT_sRG8I,   ///< RG,   16   bits per element packed as signed (@c RRRRRRRRGGGGGGGG)\n  CM_SURF_FMT_R16I,    ///< R,    16   bits per element packed (@c RRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_sR16I,   ///< R,    16   bits per element packed as signed (@c RRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RG16I,   ///< RG,   32   bits per element packed (@c RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_sRG16I,  ///< RG,   32   bits per element packed as signed (@c\n                       ///< RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_RGBA32UI,  ///< RGBA, 128 bits per element packed as (@c\n                         ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_RGBX32UI,  ///< RGBX,  128 bits per element packed as(@c\n                         ///< XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_ALPHA32UI,            ///< Alpha, 32 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_INTENSITY32UI,        ///< Intensity, 32 bits per element packed as (@c\n                                    ///< IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII)\n  CM_SURF_FMT_LUMINANCE32UI,        ///< Luminance, 32 bits per element packed as (@c\n                                    ///< LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE_ALPHA32UI,  ///< Luminance Alpha, 64 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_RGBA16UI,       ///< RGBA,  64 bits per element packed as (@c\n                              ///< AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBX16UI,       ///< RGB,   64 bits per element packed as (@c\n                              ///< XXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_ALPHA16UI,      ///< Alpha, 16 bits per element packed as (@c AAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_INTENSITY16UI,  ///< Intensity, 16 bits per element packed as (@c IIIIIIIIIIIIIIII)\n  CM_SURF_FMT_LUMINANCE16UI,  ///< Luminance, 16 bits per element packed as (@c LLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_LUMINANCE_ALPHA16UI,  ///< Luminance Alpha, 32 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAALLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_RGBA8UI,              ///< RGBA,  32 bits per element packed as (@c\n                                    ///< AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGBX8UI,              ///< RGB,   32 bits per element packed as (@c\n                                    ///< XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_ALPHA8UI,             ///< Alpha, 8 bits per element packed as (@c AAAAAAAA)\n  CM_SURF_FMT_INTENSITY8UI,         ///< Intensity, 8 bits per element packed as (@c IIIIIIII)\n  CM_SURF_FMT_LUMINANCE8UI,         ///< Luminance, 8 bits per element packed as (@c LLLLLLLL)\n  CM_SURF_FMT_LUMINANCE_ALPHA8UI,   ///< Luminance Alpha, 32 bits per element packed as (@c\n                                    ///< AAAAAAAALLLLLLLL)\n  CM_SURF_FMT_sRGBX32I,             ///< RGBX,  128 bits per element packed as(@c\n                         ///< XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n  CM_SURF_FMT_sALPHA32I,            ///< Alpha, 32 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_sINTENSITY32I,        ///< Intensity, 32 bits per element packed as (@c\n                                    ///< IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII)\n  CM_SURF_FMT_sLUMINANCE32I,        ///< Luminance, 32 bits per element packed as (@c\n                                    ///< LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_sLUMINANCE_ALPHA32I,  ///< Luminance Alpha, 64 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_sRGBA16I,       ///< RGBA,  64 bits per element packed as (@c\n                              ///< AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_sRGBX16I,       ///< RGB,   64 bits per element packed as (@c\n                              ///< XXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_sALPHA16I,      ///< Alpha, 16 bits per element packed as (@c AAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_sINTENSITY16I,  ///< Intensity, 16 bits per element packed as (@c IIIIIIIIIIIIIIII)\n  CM_SURF_FMT_sLUMINANCE16I,  ///< Luminance, 16 bits per element packed as (@c LLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_sLUMINANCE_ALPHA16I,  ///< Luminance Alpha, 32 bits per element packed as (@c\n                                    ///< AAAAAAAAAAAAAAAALLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_sRGBA8I,              ///< RGBA,  32 bits per element packed as (@c\n                                    ///< AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_sRGBX8I,              ///< RGB,   32 bits per element packed as (@c\n                                    ///< XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_sALPHA8I,             ///< Alpha, 8 bits per element packed as (@c AAAAAAAA)\n  CM_SURF_FMT_sINTENSITY8I,         ///< Intensity, 8 bits per element packed as (@c IIIIIIII)\n  CM_SURF_FMT_sLUMINANCE8I,         ///< Luminance, 8 bits per element packed as (@c LLLLLLLL)\n  CM_SURF_FMT_sLUMINANCE_ALPHA8I,   ///< Alpha, 8 bits per element packed as (@c AAAAAAAA)\n  CM_SURF_FMT_sDXT6,                ///< compressed, CM_SURF_FMT_sDXT6\n  CM_SURF_FMT_DXT6,                 ///< compressed, CM_SURF_FMT_DXT6\n  CM_SURF_FMT_DXT7,                 ///< compressed, DXT7\n  CM_SURF_FMT_LUMINANCE8_SNORM,   ///< Luminance,  8 bits per element packed as signed (@c LLLLLLLL)\n  CM_SURF_FMT_LUMINANCE16_SNORM,  ///< Luminance, 16 bits per element packed as signed (@c\n                                  ///< LLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_INTENSITY8_SNORM,   ///< Intensity,  8 bits per element packed as signed (@c IIIIIIII)\n  CM_SURF_FMT_INTENSITY16_SNORM,  ///< Intensity, 16 bits per element packed as signed (@c\n                                  ///< IIIIIIIIIIIIIIII)\n  CM_SURF_FMT_ALPHA8_SNORM,       ///< Alpha,      8 bits per element packed as signed (@c AAAAAAAA)\n  CM_SURF_FMT_ALPHA16_SNORM,      ///< Alpha,     16 bits per element packed as signed (@c\n                                  ///< AAAAAAAAAAAAAAAA)\n  CM_SURF_FMT_LUMINANCE_ALPHA8_SNORM,   ///< Luminance Alpha, 16 bits per element packed as signed\n                                        ///< (@c AAAAAAAALLLLLLLL)\n  CM_SURF_FMT_LUMINANCE_ALPHA16_SNORM,  ///< Luminance Alpha, 32 bits per element packed as signed\n                                        ///< (@c AAAAAAAAAAAAAAAALLLLLLLLLLLLLLLL)\n  CM_SURF_FMT_R8_SNORM,      ///< R,     8   bits per element packed as signed (@c RRRRRRRR)\n  CM_SURF_FMT_R16_SNORM,     ///< R,    16   bits per element packed as signed (@c RRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RG8_SNORM,     ///< RG8,   16 bits per element packed as signed (@c RRRRRRRRGGGGGGGG)\n  CM_SURF_FMT_RG16_SNORM,    ///< RG,    32 bits per element packed as signed (@c\n                             ///< RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGG)\n  CM_SURF_FMT_RGBX8_SNORM,   ///< RGB,   32 bits per element packed as signed (@c\n                             ///< XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGBX16_SNORM,  ///< RGB,   64 bits per element packed as signed (@c\n                             ///< XXXXXXXXXXXXXXXXBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBA8_SNORM,   ///< RGBA,  32 bits per element packed as signed (@c\n                             ///< AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGBA16_SNORM,  ///< RGBA,  64 bits per element packed as signed (@c\n                             ///< AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGB10_A2UI,    ///< RGBA,  32 bits per element packed as (@c\n                             ///< AABBBBBBBBBBGGGGGGGGGGRRRRRRRRRR)\n  CM_SURF_FMT_RGB32F,        ///< RGB, float, 96 bits per element packed as (@c\n                       ///< BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGB32I,  ///< RGB, unnormalized int, 96 bits per element packed as (@c\n                       ///< BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGB32UI,  ///< RGB, unnormalized uint, 96 bits per element packed as (@c\n                        ///< BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR)\n  CM_SURF_FMT_RGBX8_SRGB,             ///< RGB,   32 bits per element packed as (@c\n                                      ///< XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_RGBA8_SRGB,             ///< RGBA,  32 bits per element packed as (@c\n                                      ///< AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR)\n  CM_SURF_FMT_DXT1_SRGB,              ///< compressed, DXT1\n  CM_SURF_FMT_DXT1A_SRGB,             ///<\n  CM_SURF_FMT_DXT2_3_SRGB,            ///< compressed, DXT2_3\n  CM_SURF_FMT_DXT4_5_SRGB,            ///< compressed, DXT4_5\n  CM_SURF_FMT_DXT7_SRGB,              ///< compressed, DXT7\n  CM_SURF_FMT_RGB8_ETC2,              ///< ETC2 compressed, RGB8 in 64 bits\n  CM_SURF_FMT_SRGB8_ETC2,             ///< ETC2 compressed, SRGB8 in 64 bits\n  CM_SURF_FMT_RGB8_PT_ALPHA1_ETC2,    ///< ETC2 compressed, RGB8 in 64 bits\n  CM_SURF_FMT_SRGB8_PT_ALPHA1_ETC2,   ///< ETC2 compressed, sRGB8A1 in 64 bits\n  CM_SURF_FMT_RGBA8_ETC2_EAC,         ///< ETC2 compressed, RGBA8 in 128 bits\n  CM_SURF_FMT_SRGB8_ALPHA8_ETC2_EAC,  ///< ETC2 compressed, sRGBA8 in 128 bits\n  CM_SURF_FMT_R11_EAC,                ///< EAC compressed, R11 in 64 bits\n  CM_SURF_FMT_SIGNED_R11_EAC,         ///< EAC compressed, signed R11 in 64 bits\n  CM_SURF_FMT_RG11_EAC,               ///< EAC compressed, RG11 in 128 bits\n  CM_SURF_FMT_SIGNED_RG11_EAC,        ///< EAC compressed, signed RG11 in 128 bits\n\n  CM_SURF_FMT_RGBA8_ASTC_4x4,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_5x4,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_5x5,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_6x5,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_6x6,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_8x5,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_8x6,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_8x8,    ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_10x5,   ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_10x6,   ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_10x8,   ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_10x10,  ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_12x10,  ///< ASTC compressed RGBA8 in 128 bits block\n  CM_SURF_FMT_RGBA8_ASTC_12x12,  ///< ASTC compressed RGBA8 in 128 bits block\n\n  CM_SURF_FMT_SRGBA8_ASTC_4x4,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_5x4,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_5x5,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_6x5,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_6x6,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_8x5,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_8x6,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_8x8,    ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_10x5,   ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_10x6,   ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_10x8,   ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_10x10,  ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_12x10,  ///< ASTC compressed SRGBA8 in 128 bits block\n  CM_SURF_FMT_SRGBA8_ASTC_12x12,  ///< ASTC compressed SRGBA8 in 128 bits block\n\n  CM_SURF_FMT_BGR10_A2UI,  ///< RGBA,  32 bits per element packed as (@c\n                           ///< AARRRRRRRRRRGGGGGGGGGGBBBBBBBBBB)\n  CM_SURF_FMT_A2_BGR10UI,  ///< RGBA,  32 bits per element packed as (@c\n                           ///< RRRRRRRRRRGGGGGGGGGGBBBBBBBBBBAA)\n  CM_SURF_FMT_A2_RGB10UI,  ///< RGBA,  32 bits per element packed as (@c\n                           ///< BBBBBBBBBBGGGGGGGGGGRRRRRRRRRRAA)\n  CM_SURF_FMT_B5_G6_R5UI,  ///< RGB,   16 bits per element packed as (@c BBBBBGGGGGGRRRRR)\n  CM_SURF_FMT_R5_G6_B5UI,  ///< RGB,   16 bits per element packed as (@c RRRRRGGGGGGBBBBB)\n\n  CM_SURF_FMT_DEPTH32F_X24_STEN8_UNCLAMPED,  ///< depth + stencil, 64 bits per element packed as (@c\n                                             ///< XXXXXXXXXXXXXXXXXXXXXXXXSSSSSSSSDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD)\n  CM_SURF_FMT_DEPTH32F_UNCLAMPED,  ///< depth, 32 bits per element packed as (@c\n                                   ///< DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD)\n\n  CM_SURF_FMT_L8_X16_A8_SRGB,  ///< Sluminance Alpha,  32 bits per element packed as (@c\n                               ///< AAAAAAAAXXXXXXXXXXXXXXXXLLLLLLLL)\n  CM_SURF_FMT_L8_X24_SRGB,     ///< Sluminance,        32 bits per element packed as (@c\n                               ///< XXXXXXXXXXXXXXXXXXXXXXXXLLLLLLLL)\n\n  CM_SURF_FMT_STENCIL8,  ///< stencil, 32 bits per element packed as (@c\n                         ///< SSSSSSSSXXXXXXXXXXXXXXXXXXXXXXXX)\n\n\n  // non-native surface formats after this line, will be ignored by HWL\n  // all non-native surface formats should use the _NN suffix to distinguish\n  // them from potential corresponding native formats added in the future\n  CM_SURF_FMT_I420_NN,                              ///< 4:2:0 Planar Y-U-V format\n  CM_SURF_FMT_YV12_NN,                              ///< 4:2:0 Planar Y-V-U format\n  CM_SURF_FMT_NV12_NN,                              ///< 4:2:0 Semi-planar Y-UV format\n  CM_SURF_FMT_NV21_NN,                              ///< 4:2:0 Semi-planar Y-VU format\n  cmSurfFmt_FIRST = CM_SURF_FMT_LUMINANCE8,         ///< First surface format\n  cmSurfFmt_LAST = CM_SURF_FMT_STENCIL8,            ///< Last native surface format\n  cmSurfFmt_LAST_NON_NATIVE = CM_SURF_FMT_NV21_NN,  ///< Last non-native surface format\n} cmSurfFmt;\n\ntypedef struct cmFormatXlateRec {\n  cmSurfFmt raw_cmFormat;\n  cl_channel_type image_channel_data_type;\n  cl_channel_order image_channel_order;\n} cmFormatXlateParams;\n\n// relates full range of cm surface formats to those supported by CAL\nstatic const cmFormatXlateParams cmFormatXlateTable[] = {\n    {CM_SURF_FMT_LUMINANCE8, CL_UNORM_INT8, CL_LUMINANCE},\n    {CM_SURF_FMT_LUMINANCE16, CL_UNORM_INT16, CL_LUMINANCE},\n    {CM_SURF_FMT_LUMINANCE16F, CL_HALF_FLOAT, CL_LUMINANCE},\n    {CM_SURF_FMT_LUMINANCE32F, CL_FLOAT, CL_LUMINANCE},\n    {CM_SURF_FMT_INTENSITY8, CL_UNORM_INT8, CL_INTENSITY},\n    {CM_SURF_FMT_INTENSITY16, CL_UNORM_INT16, CL_INTENSITY},\n    {CM_SURF_FMT_INTENSITY16F, CL_HALF_FLOAT, CL_INTENSITY},\n    {CM_SURF_FMT_INTENSITY32F, CL_FLOAT, CL_INTENSITY},\n    {CM_SURF_FMT_ALPHA8, CL_UNSIGNED_INT8, CL_A},\n    {CM_SURF_FMT_ALPHA16, CL_UNORM_INT16, CL_A},\n    {CM_SURF_FMT_ALPHA16F, CL_HALF_FLOAT, CL_A},\n    {CM_SURF_FMT_ALPHA32F, CL_FLOAT, CL_A},\n    {CM_SURF_FMT_LUMINANCE8_ALPHA8, CL_UNSIGNED_INT8, CL_RG},\n    {CM_SURF_FMT_LUMINANCE16_ALPHA16, CL_UNSIGNED_INT16, CL_RG},\n    {CM_SURF_FMT_LUMINANCE16F_ALPHA16F, CL_HALF_FLOAT, CL_RG},\n    {CM_SURF_FMT_LUMINANCE32F_ALPHA32F, CL_FLOAT, CL_RG},\n    {CM_SURF_FMT_B2_G3_R3, 500, CL_R},\n    {CM_SURF_FMT_B5_G6_R5, CL_UNSIGNED_INT16, CL_RGB},\n    {CM_SURF_FMT_BGRX4, 500, CL_BGRA},\n    {CM_SURF_FMT_BGR5_X1, CL_UNSIGNED_INT16, CL_RGB},\n    {CM_SURF_FMT_BGRX8, CL_UNORM_INT8, CL_BGRA},\n    {CM_SURF_FMT_BGR10_X2, CL_UNORM_INT_101010, CL_RGB},\n    {CM_SURF_FMT_BGRX16, CL_UNORM_INT16, CL_BGRA},\n    {CM_SURF_FMT_BGRX16F, CL_HALF_FLOAT, CL_BGRA},\n    {CM_SURF_FMT_BGRX32F, CL_FLOAT, CL_BGRA},\n    {CM_SURF_FMT_RGBX4, 500, CL_RGB},\n    {CM_SURF_FMT_RGB5_X1, CL_UNORM_INT16, CL_BGRA},\n    {CM_SURF_FMT_RGBX8, CL_UNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_RGB10_X2, CL_UNORM_INT_101010, CL_RGBA},\n    {CM_SURF_FMT_RGBX16, CL_UNORM_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGBX16F, CL_HALF_FLOAT, CL_RGBA},\n    {CM_SURF_FMT_RGBX32F, CL_FLOAT, CL_RGBA},\n    {CM_SURF_FMT_BGRA4, 500, CL_BGRA},\n    {CM_SURF_FMT_BGR5_A1, CL_UNSIGNED_INT16, CL_BGRA},\n    {CM_SURF_FMT_BGRA8, CL_UNORM_INT8, CL_BGRA},\n    {CM_SURF_FMT_BGR10_A2, 500, CL_BGRA},\n    {CM_SURF_FMT_BGRA16, CL_UNORM_INT16, CL_BGRA},\n    {CM_SURF_FMT_BGRA16F, CL_UNORM_INT16, CL_BGRA},\n    {CM_SURF_FMT_BGRA32F, CL_FLOAT, CL_BGRA},\n    {CM_SURF_FMT_RGBA4, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB5_A1, CL_UNSIGNED_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGBA8, CL_UNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_RGB10_A2, CL_UNORM_INT_101010, CL_RGB},\n    {CM_SURF_FMT_RGBA16, CL_UNORM_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGBA16F, CL_HALF_FLOAT, CL_RGBA},\n    {CM_SURF_FMT_RGBA32I, CL_UNSIGNED_INT32, CL_RGBA},\n    {CM_SURF_FMT_RGBA32F, CL_FLOAT, CL_RGBA},\n    {CM_SURF_FMT_DUDV8, CL_UNSIGNED_INT8, CL_RG},\n    {CM_SURF_FMT_DXT1, 500, CL_R},\n    {CM_SURF_FMT_DXT2_3, 500, CL_R},\n    {CM_SURF_FMT_DXT4_5, 500, CL_R},\n    {CM_SURF_FMT_ATI1N, 500, CL_R},\n    {CM_SURF_FMT_ATI2N, 500, CL_R},\n    {CM_SURF_FMT_DEPTH16, CL_UNORM_INT16, CL_DEPTH},\n    {CM_SURF_FMT_DEPTH16F, CL_HALF_FLOAT, CL_DEPTH},\n    {CM_SURF_FMT_DEPTH24_X8, 500, CL_DEPTH},\n    {CM_SURF_FMT_DEPTH24F_X8, 500, CL_DEPTH},\n    {CM_SURF_FMT_DEPTH24_STEN8, CL_UNORM_INT24, CL_DEPTH_STENCIL},\n    {CM_SURF_FMT_DEPTH24F_STEN8, 500, CL_DEPTH_STENCIL},\n    {CM_SURF_FMT_DEPTH32F_X24_STEN8, CL_FLOAT, CL_DEPTH_STENCIL},\n    {CM_SURF_FMT_DEPTH32F, CL_FLOAT, CL_DEPTH},\n    {CM_SURF_FMT_sR11_sG11_sB10, 500, CL_R},\n    {CM_SURF_FMT_sU16, CL_SNORM_INT16, CL_R},\n    {CM_SURF_FMT_sUV16, CL_SNORM_INT16, CL_RG},\n    {CM_SURF_FMT_sUVWQ16, CL_SNORM_INT16, CL_RGBA},\n    {CM_SURF_FMT_RG16, CL_UNORM_INT16, CL_RG},\n    {CM_SURF_FMT_RG16F, CL_HALF_FLOAT, CL_RG},\n    {CM_SURF_FMT_RG32F, CL_FLOAT, CL_RG},\n    {CM_SURF_FMT_ABGR4, 500, CL_ARGB},\n    {CM_SURF_FMT_A1_BGR5, CL_UNSIGNED_INT16, CL_ARGB},\n    {CM_SURF_FMT_ABGR8, CL_UNORM_INT8, CL_ARGB},\n    {CM_SURF_FMT_A2_BGR10, CL_UNORM_INT_101010, CL_RGB},\n    {CM_SURF_FMT_ABGR16, CL_UNORM_INT16, CL_ARGB},\n    {CM_SURF_FMT_ABGR16F, CL_HALF_FLOAT, CL_ARGB},\n    {CM_SURF_FMT_ABGR32F, CL_FLOAT, CL_ARGB},\n    {CM_SURF_FMT_DXT1A, 500, CL_R},\n    {CM_SURF_FMT_sRGB10_A2, 500, CL_RGBA},\n    {CM_SURF_FMT_sR8, CL_SNORM_INT8, CL_R},\n    {CM_SURF_FMT_sRG8, CL_SNORM_INT8, CL_RG},\n    {CM_SURF_FMT_sR32I, CL_SIGNED_INT32, CL_R},\n    {CM_SURF_FMT_sRG32I, CL_SIGNED_INT32, CL_RG},\n    {CM_SURF_FMT_sRGBA32I, CL_SIGNED_INT32, CL_RGBA},\n    {CM_SURF_FMT_R32I, CL_UNSIGNED_INT32, CL_R},\n    {CM_SURF_FMT_RG32I, CL_UNSIGNED_INT32, CL_RG},\n    {CM_SURF_FMT_RG8, CL_UNORM_INT8, CL_RG},\n    {CM_SURF_FMT_sRGBA8, CL_SNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_R11F_G11F_B10F, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB9_E5, CL_UNORM_INT8, CL_ARGB},\n    {CM_SURF_FMT_LUMINANCE_LATC1, 500, CL_RGBA},\n    {CM_SURF_FMT_SIGNED_LUMINANCE_LATC1, 500, CL_RGBA},\n    {CM_SURF_FMT_LUMINANCE_ALPHA_LATC2, 500, CL_RGBA},\n    {CM_SURF_FMT_SIGNED_LUMINANCE_ALPHA_LATC2, 500, CL_RGBA},\n    {CM_SURF_FMT_RED_RGTC1, 500, CL_RGBA},\n    {CM_SURF_FMT_SIGNED_RED_RGTC1, 500, CL_RGBA},\n    {CM_SURF_FMT_RED_GREEN_RGTC2, 500, CL_RGBA},\n    {CM_SURF_FMT_SIGNED_RED_GREEN_RGTC2, 500, CL_RGBA},\n    {CM_SURF_FMT_R8, CL_UNORM_INT8, CL_R},\n    {CM_SURF_FMT_R16, CL_UNORM_INT16, CL_R},\n    {CM_SURF_FMT_R16F, CL_HALF_FLOAT, CL_R},\n    {CM_SURF_FMT_R32F, CL_FLOAT, CL_R},\n    {CM_SURF_FMT_R8I, CL_UNSIGNED_INT8, CL_R},\n    {CM_SURF_FMT_sR8I, CL_SIGNED_INT8, CL_R},\n    {CM_SURF_FMT_RG8I, CL_UNSIGNED_INT8, CL_RG},\n    {CM_SURF_FMT_sRG8I, CL_SIGNED_INT8, CL_RG},\n    {CM_SURF_FMT_R16I, CL_UNSIGNED_INT16, CL_R},\n    {CM_SURF_FMT_sR16I, CL_SIGNED_INT16, CL_R},\n    {CM_SURF_FMT_RG16I, CL_UNSIGNED_INT16, CL_RG},\n    {CM_SURF_FMT_sRG16I, CL_SIGNED_INT16, CL_RG},\n    {CM_SURF_FMT_RGBA32UI, CL_UNSIGNED_INT32, CL_RGBA},\n    {CM_SURF_FMT_RGBX32UI, CL_UNSIGNED_INT32, CL_RGBA},\n    {CM_SURF_FMT_ALPHA32UI, CL_UNSIGNED_INT32, CL_R},\n    {CM_SURF_FMT_INTENSITY32UI, CL_UNSIGNED_INT32, CL_R},\n    {CM_SURF_FMT_LUMINANCE32UI, CL_UNSIGNED_INT32, CL_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA32UI, CL_UNSIGNED_INT32, CL_RG},\n    {CM_SURF_FMT_RGBA16UI, CL_UNSIGNED_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGBX16UI, CL_UNSIGNED_INT16, CL_RGBA},\n    {CM_SURF_FMT_ALPHA16UI, CL_UNSIGNED_INT16, CL_R},\n    {CM_SURF_FMT_INTENSITY16UI, CL_UNSIGNED_INT16, CL_R},\n    {CM_SURF_FMT_LUMINANCE16UI, CL_UNSIGNED_INT16, CL_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA16UI, CL_UNSIGNED_INT32, CL_RG},\n    {CM_SURF_FMT_RGBA8UI, CL_UNSIGNED_INT8, CL_RGBA},\n    {CM_SURF_FMT_RGBX8UI, CL_UNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_ALPHA8UI, CL_UNSIGNED_INT8, CL_R},\n    {CM_SURF_FMT_INTENSITY8UI, CL_UNSIGNED_INT8, CL_R},\n    {CM_SURF_FMT_LUMINANCE8UI, CL_UNSIGNED_INT8, CL_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA8UI, CL_UNSIGNED_INT8, CL_RG},\n    {CM_SURF_FMT_sRGBX32I, CL_SIGNED_INT32, CL_RGBA},\n    {CM_SURF_FMT_sALPHA32I, CL_SIGNED_INT32, CL_R},\n    {CM_SURF_FMT_sINTENSITY32I, CL_SIGNED_INT32, CL_R},\n    {CM_SURF_FMT_sLUMINANCE32I, CL_SIGNED_INT32, CL_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA32I, CL_SIGNED_INT32, CL_RG},\n    {CM_SURF_FMT_sRGBA16I, CL_SIGNED_INT16, CL_RGBA},\n    {CM_SURF_FMT_sRGBX16I, CL_SIGNED_INT16, CL_RGBA},\n    {CM_SURF_FMT_sALPHA16I, CL_SIGNED_INT16, CL_R},\n    {CM_SURF_FMT_sINTENSITY16I, CL_SIGNED_INT16, CL_R},\n    {CM_SURF_FMT_sLUMINANCE16I, CL_SIGNED_INT16, CL_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA16I, CL_SIGNED_INT16, CL_RG},\n    {CM_SURF_FMT_sRGBA8I, CL_SIGNED_INT8, CL_RGBA},\n    {CM_SURF_FMT_sRGBX8I, CL_SIGNED_INT8, CL_RGBA},\n    {CM_SURF_FMT_sALPHA8I, CL_SIGNED_INT8, CL_R},\n    {CM_SURF_FMT_sINTENSITY8I, CL_SIGNED_INT8, CL_R},\n    {CM_SURF_FMT_sLUMINANCE8I, CL_SIGNED_INT8, CL_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA8I, CM_SURF_FMT_sRG8I, CL_RG},\n    {CM_SURF_FMT_sDXT6, 500, CL_R},\n    {CM_SURF_FMT_DXT6, 500, CL_R},\n    {CM_SURF_FMT_DXT7, 500, CL_R},\n    {CM_SURF_FMT_LUMINANCE8_SNORM, CL_SNORM_INT8, CL_R},\n    {CM_SURF_FMT_LUMINANCE16_SNORM, CL_SNORM_INT16, CL_R},\n    {CM_SURF_FMT_INTENSITY8_SNORM, CL_SNORM_INT8, CL_R},\n    {CM_SURF_FMT_INTENSITY16_SNORM, CL_SNORM_INT16, CL_R},\n    {CM_SURF_FMT_ALPHA8_SNORM, CL_SNORM_INT8, CL_R},\n    {CM_SURF_FMT_ALPHA16_SNORM, CL_SNORM_INT16, CL_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA8_SNORM, CL_SNORM_INT8, CL_RG},\n    {CM_SURF_FMT_LUMINANCE_ALPHA16_SNORM, CL_SNORM_INT16, CL_RG},\n    {CM_SURF_FMT_R8_SNORM, CL_SNORM_INT8, CL_R},\n    {CM_SURF_FMT_R16_SNORM, CL_SNORM_INT16, CL_R},\n    {CM_SURF_FMT_RG8_SNORM, CL_SNORM_INT8, CL_RG},\n    {CM_SURF_FMT_RG16_SNORM, CL_SNORM_INT16, CL_RG},\n    {CM_SURF_FMT_RGBX8_SNORM, CL_SNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_RGBX16_SNORM, CL_SNORM_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_SNORM, CL_SNORM_INT8, CL_RGBA},\n    {CM_SURF_FMT_RGBA16_SNORM, CL_SNORM_INT16, CL_RGBA},\n    {CM_SURF_FMT_RGB10_A2UI, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB32F, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB32I, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB32UI, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBX8_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_DXT1_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_DXT1A_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_DXT2_3_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_DXT4_5_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_DXT7_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_RGB8_ETC2, 500, CL_RGB},\n    {CM_SURF_FMT_SRGB8_ETC2, 500, CL_RGB},\n    {CM_SURF_FMT_RGB8_PT_ALPHA1_ETC2, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGB8_PT_ALPHA1_ETC2, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ETC2_EAC, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGB8_ALPHA8_ETC2_EAC, 500, CL_RGBA},\n    {CM_SURF_FMT_R11_EAC, 500, CL_R},\n    {CM_SURF_FMT_SIGNED_R11_EAC, 500, CL_R},\n    {CM_SURF_FMT_RG11_EAC, 500, CL_RG},\n    {CM_SURF_FMT_SIGNED_RG11_EAC, 500, CL_RG},\n    {CM_SURF_FMT_RGBA8_ASTC_4x4, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_5x4, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_5x5, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_6x5, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_6x6, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x5, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x6, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x8, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x5, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x6, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x8, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x10, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_12x10, 500, CL_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_12x12, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_4x4, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_5x4, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_5x5, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_6x5, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_6x6, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x5, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x6, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x8, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x5, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x6, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x8, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x10, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_12x10, 500, CL_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_12x12, 500, CL_RGBA},\n    {CM_SURF_FMT_BGR10_A2UI, 500, CL_BGRA},\n    {CM_SURF_FMT_A2_BGR10UI, 500, CL_ARGB},\n    {CM_SURF_FMT_A2_RGB10UI, 500, CL_ABGR},\n    {CM_SURF_FMT_B5_G6_R5UI, 500, CL_BGRA},\n    {CM_SURF_FMT_R5_G6_B5UI, 500, CL_RGBA},\n    {CM_SURF_FMT_DEPTH32F_X24_STEN8_UNCLAMPED, CL_UNSIGNED_INT32, CL_R},\n    {CM_SURF_FMT_DEPTH32F_UNCLAMPED, CL_FLOAT, CL_R},\n    {CM_SURF_FMT_L8_X16_A8_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_L8_X24_SRGB, 500, CL_RGBA},\n    {CM_SURF_FMT_STENCIL8, CL_UNSIGNED_INT8, CL_R},\n};\n\nbool Device::initGLInteropPrivateExt(void* GLplatformContext, void* GLdeviceContext) const {\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  void* pModule = dlopen(\"libGL.so.1\", RTLD_NOW);\n\n  if (nullptr == pModule) {\n    return false;\n  }\n  pfnGlxGetProcAddress = (PFNGlxGetProcAddress)dlsym(pModule, \"glXGetProcAddress\");\n  if (nullptr == pfnGlxGetProcAddress) {\n    return false;\n  }\n\n  pfnMesaGLInteropGLXQueryDeviceInfo =\n      (PFNMesaGLInteropGLXQueryDeviceInfo)dlsym(pModule, \"MesaGLInteropGLXQueryDeviceInfo\");\n  if (nullptr == pfnMesaGLInteropGLXQueryDeviceInfo) {\n    return false;\n  }\n\n  if (!glXBeginCLInteropAMD || !glXEndCLInteropAMD || !glXResourceAttachAMD ||\n      !glXResourceDetachAMD || !glXGetContextMVPUInfoAMD) {\n    glXBeginCLInteropAMD = (PFNGLXBEGINCLINTEROPAMD)pfnGlxGetProcAddress(\n        (const GLubyte*)\"glXBeginCLInteroperabilityAMD\");\n    glXEndCLInteropAMD =\n        (PFNGLXENDCLINTEROPAMD)pfnGlxGetProcAddress((const GLubyte*)\"glXEndCLInteroperabilityAMD\");\n    glXResourceAttachAMD =\n        (PFNGLXRESOURCEATTACHAMD)pfnGlxGetProcAddress((const GLubyte*)\"glXResourceAttachAMD\");\n    glxResourceAcquireAMD =\n        (PFNGLXRESOURCEDETACHAMD)pfnGlxGetProcAddress((const GLubyte*)\"glXResourceAcquireAMD\");\n    glxResourceReleaseAMD =\n        (PFNGLXRESOURCEDETACHAMD)pfnGlxGetProcAddress((const GLubyte*)\"glXResourceReleaseAMD\");\n    glXResourceDetachAMD =\n        (PFNGLXRESOURCEDETACHAMD)pfnGlxGetProcAddress((const GLubyte*)\"glXResourceDetachAMD\");\n    glXGetContextMVPUInfoAMD = (PFNGLXGETCONTEXTMVPUINFOAMD)pfnGlxGetProcAddress(\n        (const GLubyte*)\"glXGetContextMVPUInfoAMD\");\n  }\n\n  if (!glXBeginCLInteropAMD || !glXEndCLInteropAMD || !glXResourceAttachAMD ||\n      !glXResourceDetachAMD || !glXGetContextMVPUInfoAMD) {\n    return false;\n  }\n#else\n  if (!wglBeginCLInteropAMD || !wglEndCLInteropAMD || !wglResourceAttachAMD ||\n      !wglResourceDetachAMD || !wglGetContextGPUInfoAMD) {\n    HGLRC fakeRC = nullptr;\n\n    if (!wglGetCurrentContext()) {\n      fakeRC = wglCreateContext((HDC)GLdeviceContext);\n      wglMakeCurrent((HDC)GLdeviceContext, fakeRC);\n    }\n\n    wglBeginCLInteropAMD =\n        (PFNWGLBEGINCLINTEROPAMD)wglGetProcAddress(\"wglBeginCLInteroperabilityAMD\");\n    wglEndCLInteropAMD = (PFNWGLENDCLINTEROPAMD)wglGetProcAddress(\"wglEndCLInteroperabilityAMD\");\n    wglResourceAttachAMD = (PFNWGLRESOURCEATTACHAMD)wglGetProcAddress(\"wglResourceAttachAMD\");\n    wglResourceAcquireAMD = (PFNWGLRESOURCEDETACHAMD)wglGetProcAddress(\"wglResourceAcquireAMD\");\n    wglResourceReleaseAMD = (PFNWGLRESOURCEDETACHAMD)wglGetProcAddress(\"wglResourceReleaseAMD\");\n    wglResourceDetachAMD = (PFNWGLRESOURCEDETACHAMD)wglGetProcAddress(\"wglResourceDetachAMD\");\n    wglGetContextGPUInfoAMD =\n        (PFNWGLGETCONTEXTGPUINFOAMD)wglGetProcAddress(\"wglGetContextGPUInfoAMD\");\n\n    if (fakeRC) {\n      wglMakeCurrent(nullptr, nullptr);\n      wglDeleteContext(fakeRC);\n    }\n  }\n  if (!wglBeginCLInteropAMD || !wglEndCLInteropAMD || !wglResourceAttachAMD ||\n      !wglResourceDetachAMD || !wglGetContextGPUInfoAMD) {\n    return false;\n  }\n#endif\n  return true;\n}\n\nbool Device::glCanInterop(void* GLplatformContext, void* GLdeviceContext) const {\n  bool canInteroperate = false;\n\n#ifdef ATI_OS_WIN\n  LUID glAdapterLuid = {0, 0};\n  UINT glChainBitMask = 0;\n  HGLRC hRC = (HGLRC)GLplatformContext;\n\n  // get GL context's LUID and chainBitMask from UGL\n  if (wglGetContextGPUInfoAMD(hRC, &glAdapterLuid, &glChainBitMask)) {\n    // match the adapter\n    canInteroperate = (properties().osProperties.luidHighPart == glAdapterLuid.HighPart) &&\n        (properties().osProperties.luidLowPart == glAdapterLuid.LowPart) &&\n        ((1 << properties().gpuIndex) == glChainBitMask);\n  }\n#else\n  GLuint glDeviceId = 0;\n  GLuint glChainMask = 0;\n  GLXContext ctx = static_cast<GLXContext>(GLplatformContext);\n  Display* disp = static_cast<Display*>(GLdeviceContext);\n\n\n  if (glXGetContextMVPUInfoAMD(ctx, &glDeviceId, &glChainMask)) {\n    mesa_glinterop_device_info info = {};\n    if (pfnMesaGLInteropGLXQueryDeviceInfo(disp, ctx, &info) == 0) {\n      // match the adapter\n      canInteroperate = (properties().pciProperties.busNumber == info.pci_bus) &&\n          (properties().pciProperties.deviceNumber == info.pci_device) &&\n          (properties().pciProperties.functionNumber == info.pci_function) &&\n          (static_cast<GLuint>(1 << properties().gpuIndex) == glChainMask);\n    }\n  }\n#endif\n  return canInteroperate;\n}\n\nbool Device::glAssociate(void* GLplatformContext, void* GLdeviceContext) const {\n  // initialize pointers to the gl extension that supports interoperability\n  if (!initGLInteropPrivateExt(GLplatformContext, GLdeviceContext) ||\n      !glCanInterop(GLplatformContext, GLdeviceContext)) {\n    return false;\n  }\n\n/*\n    if (m_adp->pAsicInfo->svmFineGrainSystem)\n    {\n        flags = GL_INTEROP_SVM;\n    }\n*/\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  return (glXBeginCLInteropAMD(ctx, 0)) ? true : false;\n#else\n  HGLRC hRC = (HGLRC)GLplatformContext;\n  return (wglBeginCLInteropAMD(hRC, 0)) ? true : false;\n#endif\n}\n\nbool Device::glDissociate(void* GLplatformContext, void* GLdeviceContext) const {\n/*\n    if (m_adp->pAsicInfo->svmFineGrainSystem)\n    {\n        flags = GL_INTEROP_SVM;\n    }\n*/\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  return (glXEndCLInteropAMD(ctx, 0)) ? true : false;\n#else\n  HGLRC hRC = (HGLRC)GLplatformContext;\n  return (wglEndCLInteropAMD(hRC, 0)) ? true : false;\n#endif\n}\n\nbool Device::resGLAssociate(void* GLContext, uint name, uint type, Pal::OsExternalHandle* handle,\n                            void** mbResHandle, size_t* offset, cl_image_format& newClFormat\n#ifdef ATI_OS_WIN\n                            ,\n                            Pal::DoppDesktopInfo& doppDesktopInfo\n#endif\n                            ) const {\n  amd::ScopedLock lk(lockPAL());\n\n  GLResource hRes = {};\n  GLResourceData hData = {};\n\n  bool status = false;\n\n  hRes.type = type;\n  hRes.name = name;\n\n  hData.version = GL_RESOURCE_DATA_VERSION;\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLContext;\n  if (glXResourceAttachAMD(ctx, &hRes, &hData)) {\n    status = true;\n  }\n#else\n  HGLRC hRC = (HGLRC)GLContext;\n  if (wglResourceAttachAMD(hRC, &hRes, &hData)) {\n    status = true;\n  }\n#endif\n\n  if (!status) {\n    return false;\n  }\n\n  *mbResHandle = reinterpret_cast<void*>(hData.mbResHandle);\n  *offset = static_cast<size_t>(hData.offset);\n#ifdef ATI_OS_WIN\n  *handle = reinterpret_cast<Pal::OsExternalHandle>(hData.handle);\n  if (hData.isDoppDesktopTexture) {\n    doppDesktopInfo.gpuVirtAddr = hData.cardAddr;\n    doppDesktopInfo.vidPnSourceId = hData.vidpnSourceId;\n  } else {\n    doppDesktopInfo.gpuVirtAddr = 0;\n    doppDesktopInfo.vidPnSourceId = 0;\n  }\n#else\n  *handle = static_cast<Pal::OsExternalHandle>(hData.sharedBufferID);\n#endif\n\n  // OCL supports only a limited number of cm_surf formats, so we\n  // have to translate incoming cm_surf formats\n  uint index = hData.format - (uint)CM_SURF_FMT_LUMINANCE8;\n  if (index >= sizeof(cmFormatXlateTable) / sizeof(cmFormatXlateParams)) {\n    LogError(\"\\nInvalid GL surface reported in hData\\n\");\n    return status;\n  }\n  assert(static_cast<cmSurfFmt>(hData.format) == cmFormatXlateTable[index].raw_cmFormat);\n  cl_channel_type imageDataType;\n  imageDataType = cmFormatXlateTable[index].image_channel_data_type;\n  if (imageDataType == 500) {\n    LogError(\"\\nGL surface is not supported by OCL\\n\");\n    return status;\n  }\n\n  newClFormat.image_channel_data_type = cmFormatXlateTable[index].image_channel_data_type;\n  newClFormat.image_channel_order = cmFormatXlateTable[index].image_channel_order;\n\n  return status;\n}\n\nbool Device::resGLAcquire(void* GLplatformContext, void* mbResHandle, uint type) const {\n  amd::ScopedLock lk(lockPAL());\n\n  GLResource hRes = {};\n  hRes.mbResHandle = (GLuintp)mbResHandle;\n  hRes.type = type;\n\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  return (glxResourceAcquireAMD(ctx, &hRes)) ? true : false;\n#else\n  HGLRC hRC = wglGetCurrentContext();\n  //! @todo A temporary workaround for MT issue in conformance fence_sync\n  if (0 == hRC) {\n    return true;\n  }\n  return (wglResourceAcquireAMD(hRC, &hRes)) ? true : false;\n#endif\n}\n\nbool Device::resGLRelease(void* GLplatformContext, void* mbResHandle, uint type) const {\n  amd::ScopedLock lk(lockPAL());\n\n  GLResource hRes = {};\n  hRes.mbResHandle = (GLuintp)mbResHandle;\n  hRes.type = type;\n#ifdef ATI_OS_LINUX\n  // TODO : make sure the application GL context is current. if not no\n  // point calling into the GL RT.\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  return (glxResourceReleaseAMD(ctx, &hRes)) ? true : false;\n#else\n  // Make the call into the GL driver only if the application GL context is current\n  HGLRC hRC = wglGetCurrentContext();\n  //! @todo A temporary workaround for MT issue in conformance fence_sync\n  if (0 == hRC) {\n    return true;\n  }\n  return (wglResourceReleaseAMD(hRC, &hRes)) ? true : false;\n#endif\n}\n\nbool Device::resGLFree(void* GLplatformContext, void* mbResHandle, uint type) const {\n  amd::ScopedLock lk(lockPAL());\n\n  GLResource hRes = {};\n  hRes.mbResHandle = (GLuintp)mbResHandle;\n  hRes.type = type;\n#ifdef ATI_OS_LINUX\n  GLXContext ctx = (GLXContext)GLplatformContext;\n  return (glXResourceDetachAMD(ctx, &hRes)) ? true : false;\n#else\n  HGLRC hRC = (HGLRC)GLplatformContext;\n  return (wglResourceDetachAMD(hRC, &hRes)) ? true : false;\n#endif\n}\n\n}  // namespace pal\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.7.0-6twwcw3rjraboiuw75ysfcdddj55uxkg/spack-src/device/gpu/gslbe/src/rt/GSLDeviceGL.cpp": " /* Copyright (c) 2008-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#include \"gsl_ctx.h\"\n#include \"GSLDevice.h\"\n#include \"component_types.h\"\n#include \"cwddeci.h\"\n#include <GL/gl.h>\n#include \"GL/glATIInternal.h\"\n#ifdef ATI_OS_LINUX\n#include <stdlib.h>\n#include <dlfcn.h>\n#include \"GL/glx.h\"\n#include \"GL/glxext.h\"\n#include \"GL/glXATIPrivate.h\"\n#else\n#include \"GL/wglATIPrivate.h\"\n#endif\n#include \"memory/MemObject.h\"\n\ntypedef struct cmFormatXlateRec{\n    cmSurfFmt   raw_cmFormat;\n    cmSurfFmt   cal_cmFormat;\n    gslChannelOrder channelOrder;\n} cmFormatXlateParams;\n\n// relates full range of cm surface formats to those supported by CAL\nstatic const   cmFormatXlateParams cmFormatXlateTable [] = {\n    {CM_SURF_FMT_LUMINANCE8,            CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE16,           CM_SURF_FMT_R16,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE16F,          CM_SURF_FMT_R16F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE32F,          CM_SURF_FMT_R32F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY8,            CM_SURF_FMT_INTENSITY8, GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_INTENSITY16,           CM_SURF_FMT_R16,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY16F,          CM_SURF_FMT_R16F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY32F,          CM_SURF_FMT_R32F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA8,                CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA16,               CM_SURF_FMT_R16,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA16F,              CM_SURF_FMT_R16F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA32F,              CM_SURF_FMT_R32F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE8_ALPHA8,     CM_SURF_FMT_RG8I,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_LUMINANCE16_ALPHA16,   CM_SURF_FMT_RG16I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_LUMINANCE16F_ALPHA16F, CM_SURF_FMT_RG16F,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_LUMINANCE32F_ALPHA32F, CM_SURF_FMT_RG16F,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_B2_G3_R3,              (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_B5_G6_R5,              CM_SURF_FMT_B5_G6_R5,   GSL_CHANNEL_ORDER_RGB},\n    {CM_SURF_FMT_BGRX4,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGR5_X1,               CM_SURF_FMT_BGR5_X1,    GSL_CHANNEL_ORDER_RGB},\n    {CM_SURF_FMT_BGRX8,                 CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGR10_X2,              CM_SURF_FMT_BGR10_X2,   GSL_CHANNEL_ORDER_RGB},\n    {CM_SURF_FMT_BGRX16,                CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRX16F,               CM_SURF_FMT_RGBA16F,    GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRX32F,               CM_SURF_FMT_RGBA32F,    GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_RGBX4,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB5_X1,               CM_SURF_FMT_BGR5_X1,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX8,                 CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB10_X2,              CM_SURF_FMT_RGB10_X2,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX16,                CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX16F,               CM_SURF_FMT_RGBA16F,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX32F,               CM_SURF_FMT_RGBA32F,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_BGRA4,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGR5_A1,               CM_SURF_FMT_BGR5_X1,    GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRA8,                 CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGR10_A2,              CM_SURF_FMT_BGR10_X2,   GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRA16,                CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRA16F,               CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_BGRA32F,               CM_SURF_FMT_RGBA32F,    GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_RGBA4,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB5_A1,               CM_SURF_FMT_BGR5_X1,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8,                 CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB10_A2,              CM_SURF_FMT_BGR10_X2,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA16,                CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA16F,               CM_SURF_FMT_RGBA16F,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA32I,               CM_SURF_FMT_RGBA32I,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA32F,               CM_SURF_FMT_RGBA32F,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_DUDV8,                 CM_SURF_FMT_RG8I,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_DXT1,                  (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DXT2_3,                (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DXT4_5,                (cmSurfFmt)00,          GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ATI1N,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ATI2N,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DEPTH16,               CM_SURF_FMT_DEPTH16,    GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_DEPTH16F,              CM_SURF_FMT_R16F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DEPTH24_X8,            (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DEPTH24F_X8,           (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DEPTH24_STEN8,         CM_SURF_FMT_DEPTH24_STEN8, GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_DEPTH24F_STEN8,        (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DEPTH32F_X24_STEN8,    CM_SURF_FMT_DEPTH32F_X24_STEN8, GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_DEPTH32F,              CM_SURF_FMT_DEPTH32F,   GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_sR11_sG11_sB10,        (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sU16,                  CM_SURF_FMT_sU16,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sUV16,                 CM_SURF_FMT_sUV16,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sUVWQ16,               CM_SURF_FMT_sUVWQ16,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RG16,                  CM_SURF_FMT_RG16,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RG16F,                 CM_SURF_FMT_RG16F,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RG32F,                 CM_SURF_FMT_RG32F,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_ABGR4,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_A1_BGR5,               CM_SURF_FMT_BGR5_X1,    GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_ABGR8,                 CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_A2_BGR10,              CM_SURF_FMT_BGR10_X2,   GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_ABGR16,                CM_SURF_FMT_RGBA16,     GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_ABGR16F,               CM_SURF_FMT_RGBA16F,    GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_ABGR32F,               CM_SURF_FMT_RGBA32F,    GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_DXT1A,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sRGB10_A2,             (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sR8,                   CM_SURF_FMT_sR8,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sRG8,                  CM_SURF_FMT_sRG8,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sR32I,                 CM_SURF_FMT_sR32I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sRG32I,                CM_SURF_FMT_sRG32I,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRGBA32I,              CM_SURF_FMT_sRGBA32I,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_R32I,                  CM_SURF_FMT_R32I,       GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_RG32I,                 CM_SURF_FMT_RG32I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RG8,                   CM_SURF_FMT_RG8,        GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRGBA8,                CM_SURF_FMT_sRGBA8,     GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_R11F_G11F_B10F,        (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB9_E5,               CM_SURF_FMT_RGBA8,      GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_LUMINANCE_LATC1,       (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SIGNED_LUMINANCE_LATC1,(cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_LUMINANCE_ALPHA_LATC2, (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SIGNED_LUMINANCE_ALPHA_LATC2, (cmSurfFmt)500,  GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RED_RGTC1,             (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SIGNED_RED_RGTC1,      (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RED_GREEN_RGTC2,       (cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SIGNED_RED_GREEN_RGTC2,(cmSurfFmt)500,         GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_R8,                    CM_SURF_FMT_INTENSITY8, GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R16,                   CM_SURF_FMT_R16,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R16F,                  CM_SURF_FMT_R16F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R32F,                  CM_SURF_FMT_R32F,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R8I,                   CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sR8I,                  CM_SURF_FMT_sR8I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_RG8I,                  CM_SURF_FMT_RG8I,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRG8I,                 CM_SURF_FMT_sRG8I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_R16I,                  CM_SURF_FMT_R16I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sR16I,                 CM_SURF_FMT_sR16I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_RG16I,                 CM_SURF_FMT_RG16I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRG16I,                CM_SURF_FMT_sRG16I,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RGBA32UI,              CM_SURF_FMT_RGBA32UI,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX32UI,              CM_SURF_FMT_RGBA32UI,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_ALPHA32UI,             CM_SURF_FMT_R32I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY32UI,         CM_SURF_FMT_R32I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE32UI,         CM_SURF_FMT_R32I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA32UI,   CM_SURF_FMT_RG32I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RGBA16UI,              CM_SURF_FMT_RGBA16UI,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX16UI,              CM_SURF_FMT_RGBA16UI,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_ALPHA16UI,             CM_SURF_FMT_R16I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY16UI,         CM_SURF_FMT_R16I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE16UI,         CM_SURF_FMT_R16I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA16UI,   CM_SURF_FMT_R32I,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RGBA8UI,               CM_SURF_FMT_RGBA8UI,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX8UI,               CM_SURF_FMT_RGBA8UI,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_ALPHA8UI,              CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY8UI,          CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE8UI,          CM_SURF_FMT_R8I,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA8UI,    CM_SURF_FMT_RG8I,       GSL_CHANNEL_ORDER_RG},\n#ifndef CM_SURF_FMT_sRGBA32I_EXT_HAS_BEEN_REMOVED\n    {CM_SURF_FMT_sRGBA32I_EXT,          CM_SURF_FMT_sRGBA32I,   GSL_CHANNEL_ORDER_RGBA},\n#endif\n    {CM_SURF_FMT_sRGBX32I,              CM_SURF_FMT_sRGBA32I,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sALPHA32I,             CM_SURF_FMT_sR32I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sINTENSITY32I,         CM_SURF_FMT_sR32I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE32I,         CM_SURF_FMT_sR32I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA32I,   CM_SURF_FMT_sRG32I,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRGBA16I,              CM_SURF_FMT_sRGBA16I,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sRGBX16I,              CM_SURF_FMT_sRGBA16I,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sALPHA16I,             CM_SURF_FMT_sR16I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sINTENSITY16I,         CM_SURF_FMT_sR16I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE16I,         CM_SURF_FMT_sR16I,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA16I,   CM_SURF_FMT_sRG16I,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sRGBA8I,               CM_SURF_FMT_sRGBA8I,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sRGBX8I,               CM_SURF_FMT_sRGBA8I,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_sALPHA8I,              CM_SURF_FMT_sR8I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sINTENSITY8I,          CM_SURF_FMT_sR8I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE8I,          CM_SURF_FMT_sR8I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_sLUMINANCE_ALPHA8I,    CM_SURF_FMT_sRG8I,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_sDXT6,                 (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DXT6,                  (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_DXT7,                  (cmSurfFmt)500,         GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE8_SNORM,      CM_SURF_FMT_sR8,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE16_SNORM,     CM_SURF_FMT_sU16,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY8_SNORM,      CM_SURF_FMT_sR8,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_INTENSITY16_SNORM,     CM_SURF_FMT_sU16,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA8_SNORM,          CM_SURF_FMT_sR8,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_ALPHA16_SNORM,         CM_SURF_FMT_sU16,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_LUMINANCE_ALPHA8_SNORM,CM_SURF_FMT_sRG8,       GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_LUMINANCE_ALPHA16_SNORM,CM_SURF_FMT_sUV16,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_R8_SNORM,               CM_SURF_FMT_sR8,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R16_SNORM,              CM_SURF_FMT_sU16,      GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_RG8_SNORM,              CM_SURF_FMT_sRG8,      GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RG16_SNORM,             CM_SURF_FMT_sUV16,     GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RGBX8_SNORM,            CM_SURF_FMT_sRGBA8,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBX16_SNORM,           CM_SURF_FMT_sUVWQ16,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_SNORM,            CM_SURF_FMT_sRGBA8,    GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA16_SNORM,           CM_SURF_FMT_sUVWQ16,   GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGB8_ETC2,              (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGB},\n    {CM_SURF_FMT_SRGB8_ETC2,             (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGB},\n    {CM_SURF_FMT_RGB8_PT_ALPHA1_ETC2,    (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGB8_PT_ALPHA1_ETC2,   (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ETC2_EAC,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGB8_ALPHA8_ETC2_EAC,  (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_R11_EAC,                (cmSurfFmt)500,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_SIGNED_R11_EAC,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_RG11_EAC,               (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_SIGNED_RG11_EAC,        (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RG},\n    {CM_SURF_FMT_RGBA8_ASTC_4x4,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_5x4,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_5x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_6x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_6x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_8x8,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x8,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_10x10,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_12x10,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_RGBA8_ASTC_12x12,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n\n    {CM_SURF_FMT_SRGBA8_ASTC_4x4,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_5x4,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_5x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_6x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_6x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_8x8,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x5,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x6,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x8,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_10x10,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_12x10,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_SRGBA8_ASTC_12x12,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_BGR10_A2UI,             (cmSurfFmt)501,        GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_A2_BGR10UI,             (cmSurfFmt)501,        GSL_CHANNEL_ORDER_ARGB},\n    {CM_SURF_FMT_A2_RGB10UI,             (cmSurfFmt)501,        GSL_CHANNEL_ORDER_ABGR},\n    {CM_SURF_FMT_B5_G6_R5UI,             (cmSurfFmt)500,        GSL_CHANNEL_ORDER_BGRA},\n    {CM_SURF_FMT_R5_G6_B5UI,             (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_DEPTH32F_X24_STEN8_UNCLAMPED, CM_SURF_FMT_RG32I, GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_DEPTH32F_UNCLAMPED,    CM_SURF_FMT_R32F,       GSL_CHANNEL_ORDER_REPLICATE_R},\n    {CM_SURF_FMT_L8_X16_A8_SRGB,         (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_L8_X24_SRGB,            (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RGBA},\n    {CM_SURF_FMT_STENCIL8,               CM_SURF_FMT_R8I,       GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_L8_SRGB,                (cmSurfFmt)500,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_R8_SRGB,                (cmSurfFmt)500,        GSL_CHANNEL_ORDER_R},\n    {CM_SURF_FMT_RG8_SRGB,               (cmSurfFmt)500,        GSL_CHANNEL_ORDER_RG},\n    };\n\nFINLINE void\ndummyAssertIfCmSurfFmtChanges(void)\n{\n    //\n    //  Assert if cmSurfFmt defined in ugl/src/include/cmndefs.h changes.\n    //\n    COMPILE_TIME_ASSERT(cmSurfFmt_FIRST == CM_SURF_FMT_LUMINANCE8);\n    COMPILE_TIME_ASSERT(  0 == CM_SURF_FMT_LUMINANCE8);\n    COMPILE_TIME_ASSERT(  1 == CM_SURF_FMT_LUMINANCE16);\n    COMPILE_TIME_ASSERT(  2 == CM_SURF_FMT_LUMINANCE16F);\n    COMPILE_TIME_ASSERT(  3 == CM_SURF_FMT_LUMINANCE32F);\n    COMPILE_TIME_ASSERT(  4 == CM_SURF_FMT_INTENSITY8);\n    COMPILE_TIME_ASSERT(  5 == CM_SURF_FMT_INTENSITY16);\n    COMPILE_TIME_ASSERT(  6 == CM_SURF_FMT_INTENSITY16F);\n    COMPILE_TIME_ASSERT(  7 == CM_SURF_FMT_INTENSITY32F);\n    COMPILE_TIME_ASSERT(  8 == CM_SURF_FMT_ALPHA8);\n    COMPILE_TIME_ASSERT(  9 == CM_SURF_FMT_ALPHA16);\n    COMPILE_TIME_ASSERT( 10 == CM_SURF_FMT_ALPHA16F);\n    COMPILE_TIME_ASSERT( 11 == CM_SURF_FMT_ALPHA32F);\n    COMPILE_TIME_ASSERT( 12 == CM_SURF_FMT_LUMINANCE8_ALPHA8);\n    COMPILE_TIME_ASSERT( 13 == CM_SURF_FMT_LUMINANCE16_ALPHA16);\n    COMPILE_TIME_ASSERT( 14 == CM_SURF_FMT_LUMINANCE16F_ALPHA16F);\n    COMPILE_TIME_ASSERT( 15 == CM_SURF_FMT_LUMINANCE32F_ALPHA32F);\n    COMPILE_TIME_ASSERT( 16 == CM_SURF_FMT_B2_G3_R3);\n    COMPILE_TIME_ASSERT( 17 == CM_SURF_FMT_B5_G6_R5);\n    COMPILE_TIME_ASSERT( 18 == CM_SURF_FMT_BGRX4);\n    COMPILE_TIME_ASSERT( 19 == CM_SURF_FMT_BGR5_X1);\n    COMPILE_TIME_ASSERT( 20 == CM_SURF_FMT_BGRX8);\n    COMPILE_TIME_ASSERT( 21 == CM_SURF_FMT_BGR10_X2);\n    COMPILE_TIME_ASSERT( 22 == CM_SURF_FMT_BGRX16);\n    COMPILE_TIME_ASSERT( 23 == CM_SURF_FMT_BGRX16F);\n    COMPILE_TIME_ASSERT( 24 == CM_SURF_FMT_BGRX32F);\n    COMPILE_TIME_ASSERT( 25 == CM_SURF_FMT_RGBX4);\n    COMPILE_TIME_ASSERT( 26 == CM_SURF_FMT_RGB5_X1);\n    COMPILE_TIME_ASSERT( 27 == CM_SURF_FMT_RGBX8);\n    COMPILE_TIME_ASSERT( 28 == CM_SURF_FMT_RGB10_X2);\n    COMPILE_TIME_ASSERT( 29 == CM_SURF_FMT_RGBX16);\n    COMPILE_TIME_ASSERT( 30 == CM_SURF_FMT_RGBX16F);\n    COMPILE_TIME_ASSERT( 31 == CM_SURF_FMT_RGBX32F);\n    COMPILE_TIME_ASSERT( 32 == CM_SURF_FMT_BGRA4);\n    COMPILE_TIME_ASSERT( 33 == CM_SURF_FMT_BGR5_A1);\n    COMPILE_TIME_ASSERT( 34 == CM_SURF_FMT_BGRA8);\n    COMPILE_TIME_ASSERT( 35 == CM_SURF_FMT_BGR10_A2);\n    COMPILE_TIME_ASSERT( 36 == CM_SURF_FMT_BGRA16);\n    COMPILE_TIME_ASSERT( 37 == CM_SURF_FMT_BGRA16F);\n    COMPILE_TIME_ASSERT( 38 == CM_SURF_FMT_BGRA32F);\n    COMPILE_TIME_ASSERT( 39 == CM_SURF_FMT_RGBA4);\n    COMPILE_TIME_ASSERT( 40 == CM_SURF_FMT_RGB5_A1);\n    COMPILE_TIME_ASSERT( 41 == CM_SURF_FMT_RGBA8);\n    COMPILE_TIME_ASSERT( 42 == CM_SURF_FMT_RGB10_A2);\n    COMPILE_TIME_ASSERT( 43 == CM_SURF_FMT_RGBA16);\n    COMPILE_TIME_ASSERT( 44 == CM_SURF_FMT_RGBA16F);\n    COMPILE_TIME_ASSERT( 45 == CM_SURF_FMT_RGBA32I);\n    COMPILE_TIME_ASSERT( 46 == CM_SURF_FMT_RGBA32F);\n    COMPILE_TIME_ASSERT( 47 == CM_SURF_FMT_DUDV8);\n    COMPILE_TIME_ASSERT( 48 == CM_SURF_FMT_DXT1);\n    COMPILE_TIME_ASSERT( 49 == CM_SURF_FMT_DXT2_3);\n    COMPILE_TIME_ASSERT( 50 == CM_SURF_FMT_DXT4_5);\n    COMPILE_TIME_ASSERT( 51 == CM_SURF_FMT_ATI1N);\n    COMPILE_TIME_ASSERT( 52 == CM_SURF_FMT_ATI2N);\n    COMPILE_TIME_ASSERT( 53 == CM_SURF_FMT_DEPTH16);\n    COMPILE_TIME_ASSERT( 54 == CM_SURF_FMT_DEPTH16F);\n    COMPILE_TIME_ASSERT( 55 == CM_SURF_FMT_DEPTH24_X8);\n    COMPILE_TIME_ASSERT( 56 == CM_SURF_FMT_DEPTH24F_X8);\n    COMPILE_TIME_ASSERT( 57 == CM_SURF_FMT_DEPTH24_STEN8);\n    COMPILE_TIME_ASSERT( 58 == CM_SURF_FMT_DEPTH24F_STEN8);\n    COMPILE_TIME_ASSERT( 59 == CM_SURF_FMT_DEPTH32F_X24_STEN8);\n    COMPILE_TIME_ASSERT( 60 == CM_SURF_FMT_DEPTH32F);\n    COMPILE_TIME_ASSERT( 61 == CM_SURF_FMT_sR11_sG11_sB10);\n    COMPILE_TIME_ASSERT( 62 == CM_SURF_FMT_sU16);\n    COMPILE_TIME_ASSERT( 63 == CM_SURF_FMT_sUV16);\n    COMPILE_TIME_ASSERT( 64 == CM_SURF_FMT_sUVWQ16);\n    COMPILE_TIME_ASSERT( 65 == CM_SURF_FMT_RG16);\n    COMPILE_TIME_ASSERT( 66 == CM_SURF_FMT_RG16F);\n    COMPILE_TIME_ASSERT( 67 == CM_SURF_FMT_RG32F);\n    COMPILE_TIME_ASSERT( 68 == CM_SURF_FMT_ABGR4);\n    COMPILE_TIME_ASSERT( 69 == CM_SURF_FMT_A1_BGR5);\n    COMPILE_TIME_ASSERT( 70 == CM_SURF_FMT_ABGR8);\n    COMPILE_TIME_ASSERT( 71 == CM_SURF_FMT_A2_BGR10);\n    COMPILE_TIME_ASSERT( 72 == CM_SURF_FMT_ABGR16);\n    COMPILE_TIME_ASSERT( 73 == CM_SURF_FMT_ABGR16F);\n    COMPILE_TIME_ASSERT( 74 == CM_SURF_FMT_ABGR32F);\n    COMPILE_TIME_ASSERT( 75 == CM_SURF_FMT_DXT1A);\n    COMPILE_TIME_ASSERT( 76 == CM_SURF_FMT_sRGB10_A2);\n    COMPILE_TIME_ASSERT( 77 == CM_SURF_FMT_sR8);\n    COMPILE_TIME_ASSERT( 78 == CM_SURF_FMT_sRG8);\n    COMPILE_TIME_ASSERT( 79 == CM_SURF_FMT_sR32I);\n    COMPILE_TIME_ASSERT( 80 == CM_SURF_FMT_sRG32I);\n    COMPILE_TIME_ASSERT( 81 == CM_SURF_FMT_sRGBA32I);\n    COMPILE_TIME_ASSERT( 82 == CM_SURF_FMT_R32I);\n    COMPILE_TIME_ASSERT( 83 == CM_SURF_FMT_RG32I);\n    COMPILE_TIME_ASSERT( 84 == CM_SURF_FMT_RG8);\n    COMPILE_TIME_ASSERT( 85 == CM_SURF_FMT_sRGBA8);\n    COMPILE_TIME_ASSERT( 86 == CM_SURF_FMT_R11F_G11F_B10F);\n    COMPILE_TIME_ASSERT( 87 == CM_SURF_FMT_RGB9_E5);\n    COMPILE_TIME_ASSERT( 88 == CM_SURF_FMT_LUMINANCE_LATC1);\n    COMPILE_TIME_ASSERT( 89 == CM_SURF_FMT_SIGNED_LUMINANCE_LATC1);\n    COMPILE_TIME_ASSERT( 90 == CM_SURF_FMT_LUMINANCE_ALPHA_LATC2);\n    COMPILE_TIME_ASSERT( 91 == CM_SURF_FMT_SIGNED_LUMINANCE_ALPHA_LATC2);\n    COMPILE_TIME_ASSERT( 92 == CM_SURF_FMT_RED_RGTC1);\n    COMPILE_TIME_ASSERT( 93 == CM_SURF_FMT_SIGNED_RED_RGTC1);\n    COMPILE_TIME_ASSERT( 94 == CM_SURF_FMT_RED_GREEN_RGTC2);\n    COMPILE_TIME_ASSERT( 95 == CM_SURF_FMT_SIGNED_RED_GREEN_RGTC2);\n    COMPILE_TIME_ASSERT( 96 == CM_SURF_FMT_R8);\n    COMPILE_TIME_ASSERT( 97 == CM_SURF_FMT_R16);\n    COMPILE_TIME_ASSERT( 98 == CM_SURF_FMT_R16F);\n    COMPILE_TIME_ASSERT( 99 == CM_SURF_FMT_R32F);\n    COMPILE_TIME_ASSERT(100 == CM_SURF_FMT_R8I);\n    COMPILE_TIME_ASSERT(101 == CM_SURF_FMT_sR8I);\n    COMPILE_TIME_ASSERT(102 == CM_SURF_FMT_RG8I);\n    COMPILE_TIME_ASSERT(103 == CM_SURF_FMT_sRG8I);\n    COMPILE_TIME_ASSERT(104 == CM_SURF_FMT_R16I);\n    COMPILE_TIME_ASSERT(105 == CM_SURF_FMT_sR16I);\n    COMPILE_TIME_ASSERT(106 == CM_SURF_FMT_RG16I);\n    COMPILE_TIME_ASSERT(107 == CM_SURF_FMT_sRG16I);\n    COMPILE_TIME_ASSERT(108 == CM_SURF_FMT_RGBA32UI);\n    COMPILE_TIME_ASSERT(109 == CM_SURF_FMT_RGBX32UI);\n    COMPILE_TIME_ASSERT(110 == CM_SURF_FMT_ALPHA32UI);\n    COMPILE_TIME_ASSERT(111 == CM_SURF_FMT_INTENSITY32UI);\n    COMPILE_TIME_ASSERT(112 == CM_SURF_FMT_LUMINANCE32UI);\n    COMPILE_TIME_ASSERT(113 == CM_SURF_FMT_LUMINANCE_ALPHA32UI);\n    COMPILE_TIME_ASSERT(114 == CM_SURF_FMT_RGBA16UI);\n    COMPILE_TIME_ASSERT(115 == CM_SURF_FMT_RGBX16UI);\n    COMPILE_TIME_ASSERT(116 == CM_SURF_FMT_ALPHA16UI);\n    COMPILE_TIME_ASSERT(117 == CM_SURF_FMT_INTENSITY16UI);\n    COMPILE_TIME_ASSERT(118 == CM_SURF_FMT_LUMINANCE16UI);\n    COMPILE_TIME_ASSERT(119 == CM_SURF_FMT_LUMINANCE_ALPHA16UI);\n    COMPILE_TIME_ASSERT(120 == CM_SURF_FMT_RGBA8UI);\n    COMPILE_TIME_ASSERT(121 == CM_SURF_FMT_RGBX8UI);\n    COMPILE_TIME_ASSERT(122 == CM_SURF_FMT_ALPHA8UI);\n    COMPILE_TIME_ASSERT(123 == CM_SURF_FMT_INTENSITY8UI);\n    COMPILE_TIME_ASSERT(124 == CM_SURF_FMT_LUMINANCE8UI);\n    COMPILE_TIME_ASSERT(125 == CM_SURF_FMT_LUMINANCE_ALPHA8UI);\n#ifndef CM_SURF_FMT_sRGBA32I_EXT_HAS_BEEN_REMOVED\n    COMPILE_TIME_ASSERT(126 == CM_SURF_FMT_sRGBA32I_EXT);\n    COMPILE_TIME_ASSERT(127 == CM_SURF_FMT_sRGBX32I);\n    COMPILE_TIME_ASSERT(128 == CM_SURF_FMT_sALPHA32I);\n    COMPILE_TIME_ASSERT(129 == CM_SURF_FMT_sINTENSITY32I);\n    COMPILE_TIME_ASSERT(130 == CM_SURF_FMT_sLUMINANCE32I);\n    COMPILE_TIME_ASSERT(131 == CM_SURF_FMT_sLUMINANCE_ALPHA32I);\n    COMPILE_TIME_ASSERT(132 == CM_SURF_FMT_sRGBA16I);\n    COMPILE_TIME_ASSERT(133 == CM_SURF_FMT_sRGBX16I);\n    COMPILE_TIME_ASSERT(134 == CM_SURF_FMT_sALPHA16I);\n    COMPILE_TIME_ASSERT(135 == CM_SURF_FMT_sINTENSITY16I);\n    COMPILE_TIME_ASSERT(136 == CM_SURF_FMT_sLUMINANCE16I);\n    COMPILE_TIME_ASSERT(137 == CM_SURF_FMT_sLUMINANCE_ALPHA16I);\n    COMPILE_TIME_ASSERT(138 == CM_SURF_FMT_sRGBA8I);\n    COMPILE_TIME_ASSERT(139 == CM_SURF_FMT_sRGBX8I);\n    COMPILE_TIME_ASSERT(140 == CM_SURF_FMT_sALPHA8I);\n    COMPILE_TIME_ASSERT(141 == CM_SURF_FMT_sINTENSITY8I);\n    COMPILE_TIME_ASSERT(142 == CM_SURF_FMT_sLUMINANCE8I);\n    COMPILE_TIME_ASSERT(143 == CM_SURF_FMT_sLUMINANCE_ALPHA8I);\n    COMPILE_TIME_ASSERT(144 == CM_SURF_FMT_sDXT6);\n    COMPILE_TIME_ASSERT(145 == CM_SURF_FMT_DXT6);\n    COMPILE_TIME_ASSERT(146 == CM_SURF_FMT_DXT7);\n    COMPILE_TIME_ASSERT(147 == CM_SURF_FMT_LUMINANCE8_SNORM);\n    COMPILE_TIME_ASSERT(148 == CM_SURF_FMT_LUMINANCE16_SNORM);\n    COMPILE_TIME_ASSERT(149 == CM_SURF_FMT_INTENSITY8_SNORM);\n    COMPILE_TIME_ASSERT(150 == CM_SURF_FMT_INTENSITY16_SNORM);\n    COMPILE_TIME_ASSERT(151 == CM_SURF_FMT_ALPHA8_SNORM);\n    COMPILE_TIME_ASSERT(152 == CM_SURF_FMT_ALPHA16_SNORM);\n    COMPILE_TIME_ASSERT(153 == CM_SURF_FMT_LUMINANCE_ALPHA8_SNORM);\n    COMPILE_TIME_ASSERT(154 == CM_SURF_FMT_LUMINANCE_ALPHA16_SNORM);\n    COMPILE_TIME_ASSERT(155 == CM_SURF_FMT_R8_SNORM);\n    COMPILE_TIME_ASSERT(156 == CM_SURF_FMT_R16_SNORM);\n    COMPILE_TIME_ASSERT(157 == CM_SURF_FMT_RG8_SNORM);\n    COMPILE_TIME_ASSERT(158 == CM_SURF_FMT_RG16_SNORM);\n    COMPILE_TIME_ASSERT(159 == CM_SURF_FMT_RGBX8_SNORM);\n    COMPILE_TIME_ASSERT(160 == CM_SURF_FMT_RGBX16_SNORM);\n    COMPILE_TIME_ASSERT(161 == CM_SURF_FMT_RGBA8_SNORM);\n    COMPILE_TIME_ASSERT(162 == CM_SURF_FMT_RGBA16_SNORM);\n    COMPILE_TIME_ASSERT(163 == CM_SURF_FMT_RGB10_A2UI);\n    COMPILE_TIME_ASSERT(164 == CM_SURF_FMT_RGB32F);\n    COMPILE_TIME_ASSERT(165 == CM_SURF_FMT_RGB32I);\n    COMPILE_TIME_ASSERT(166 == CM_SURF_FMT_RGB32UI);\n    COMPILE_TIME_ASSERT(167 == CM_SURF_FMT_RGBX8_SRGB);\n    COMPILE_TIME_ASSERT(168 == CM_SURF_FMT_RGBA8_SRGB);\n    COMPILE_TIME_ASSERT(169 == CM_SURF_FMT_DXT1_SRGB);\n    COMPILE_TIME_ASSERT(170 == CM_SURF_FMT_DXT1A_SRGB);\n    COMPILE_TIME_ASSERT(171 == CM_SURF_FMT_DXT2_3_SRGB);\n    COMPILE_TIME_ASSERT(172 == CM_SURF_FMT_DXT4_5_SRGB);\n    COMPILE_TIME_ASSERT(173 == CM_SURF_FMT_DXT7_SRGB);\n    COMPILE_TIME_ASSERT(174 == CM_SURF_FMT_RGB8_ETC2);\n    COMPILE_TIME_ASSERT(175 == CM_SURF_FMT_SRGB8_ETC2);\n    COMPILE_TIME_ASSERT(176 == CM_SURF_FMT_RGB8_PT_ALPHA1_ETC2);\n    COMPILE_TIME_ASSERT(177 == CM_SURF_FMT_SRGB8_PT_ALPHA1_ETC2);\n    COMPILE_TIME_ASSERT(178 == CM_SURF_FMT_RGBA8_ETC2_EAC);\n    COMPILE_TIME_ASSERT(179 == CM_SURF_FMT_SRGB8_ALPHA8_ETC2_EAC);\n    COMPILE_TIME_ASSERT(180 == CM_SURF_FMT_R11_EAC);\n    COMPILE_TIME_ASSERT(181 == CM_SURF_FMT_SIGNED_R11_EAC);\n    COMPILE_TIME_ASSERT(182 == CM_SURF_FMT_RG11_EAC);\n    COMPILE_TIME_ASSERT(183 == CM_SURF_FMT_SIGNED_RG11_EAC);\n    COMPILE_TIME_ASSERT(184 == CM_SURF_FMT_RGBA8_ASTC_4x4);\n    COMPILE_TIME_ASSERT(185 == CM_SURF_FMT_RGBA8_ASTC_5x4);\n    COMPILE_TIME_ASSERT(186 == CM_SURF_FMT_RGBA8_ASTC_5x5);\n    COMPILE_TIME_ASSERT(187 == CM_SURF_FMT_RGBA8_ASTC_6x5);\n    COMPILE_TIME_ASSERT(188 == CM_SURF_FMT_RGBA8_ASTC_6x6);\n    COMPILE_TIME_ASSERT(189 == CM_SURF_FMT_RGBA8_ASTC_8x5);\n    COMPILE_TIME_ASSERT(190 == CM_SURF_FMT_RGBA8_ASTC_8x6);\n    COMPILE_TIME_ASSERT(191 == CM_SURF_FMT_RGBA8_ASTC_8x8);\n    COMPILE_TIME_ASSERT(192 == CM_SURF_FMT_RGBA8_ASTC_10x5);\n    COMPILE_TIME_ASSERT(193 == CM_SURF_FMT_RGBA8_ASTC_10x6);\n    COMPILE_TIME_ASSERT(194 == CM_SURF_FMT_RGBA8_ASTC_10x8);\n    COMPILE_TIME_ASSERT(195 == CM_SURF_FMT_RGBA8_ASTC_10x10);\n    COMPILE_TIME_ASSERT(196 == CM_SURF_FMT_RGBA8_ASTC_12x10);\n    COMPILE_TIME_ASSERT(197 == CM_SURF_FMT_RGBA8_ASTC_12x12);\n    COMPILE_TIME_ASSERT(198 == CM_SURF_FMT_SRGBA8_ASTC_4x4);\n    COMPILE_TIME_ASSERT(199 == CM_SURF_FMT_SRGBA8_ASTC_5x4);\n    COMPILE_TIME_ASSERT(200 == CM_SURF_FMT_SRGBA8_ASTC_5x5);\n    COMPILE_TIME_ASSERT(201 == CM_SURF_FMT_SRGBA8_ASTC_6x5);\n    COMPILE_TIME_ASSERT(202 == CM_SURF_FMT_SRGBA8_ASTC_6x6);\n    COMPILE_TIME_ASSERT(203 == CM_SURF_FMT_SRGBA8_ASTC_8x5);\n    COMPILE_TIME_ASSERT(204 == CM_SURF_FMT_SRGBA8_ASTC_8x6);\n    COMPILE_TIME_ASSERT(205 == CM_SURF_FMT_SRGBA8_ASTC_8x8);\n    COMPILE_TIME_ASSERT(206 == CM_SURF_FMT_SRGBA8_ASTC_10x5);\n    COMPILE_TIME_ASSERT(207 == CM_SURF_FMT_SRGBA8_ASTC_10x6);\n    COMPILE_TIME_ASSERT(208 == CM_SURF_FMT_SRGBA8_ASTC_10x8);\n    COMPILE_TIME_ASSERT(209 == CM_SURF_FMT_SRGBA8_ASTC_10x10);\n    COMPILE_TIME_ASSERT(210 == CM_SURF_FMT_SRGBA8_ASTC_12x10);\n    COMPILE_TIME_ASSERT(211 == CM_SURF_FMT_SRGBA8_ASTC_12x12);\n    COMPILE_TIME_ASSERT(212 == CM_SURF_FMT_BGR10_A2UI);\n    COMPILE_TIME_ASSERT(213 == CM_SURF_FMT_A2_BGR10UI);\n    COMPILE_TIME_ASSERT(214 == CM_SURF_FMT_A2_RGB10UI);\n    COMPILE_TIME_ASSERT(215 == CM_SURF_FMT_B5_G6_R5UI);\n    COMPILE_TIME_ASSERT(216 == CM_SURF_FMT_R5_G6_B5UI);\n    COMPILE_TIME_ASSERT(217 == CM_SURF_FMT_DEPTH32F_X24_STEN8_UNCLAMPED);\n    COMPILE_TIME_ASSERT(218 == CM_SURF_FMT_DEPTH32F_UNCLAMPED);\n    COMPILE_TIME_ASSERT(219 == CM_SURF_FMT_L8_X16_A8_SRGB);\n    COMPILE_TIME_ASSERT(220 == CM_SURF_FMT_L8_X24_SRGB);\n    COMPILE_TIME_ASSERT(221 == CM_SURF_FMT_STENCIL8);\n    COMPILE_TIME_ASSERT(222 == CM_SURF_FMT_L8_SRGB);\n    COMPILE_TIME_ASSERT(223 == CM_SURF_FMT_R8_SRGB);\n    COMPILE_TIME_ASSERT(224 == CM_SURF_FMT_RG8_SRGB);\n#else\n    COMPILE_TIME_ASSERT(126 == CM_SURF_FMT_sRGBX32I);\n    COMPILE_TIME_ASSERT(127 == CM_SURF_FMT_sALPHA32I);\n    COMPILE_TIME_ASSERT(128 == CM_SURF_FMT_sINTENSITY32I);\n    COMPILE_TIME_ASSERT(129 == CM_SURF_FMT_sLUMINANCE32I);\n    COMPILE_TIME_ASSERT(130 == CM_SURF_FMT_sLUMINANCE_ALPHA32I);\n    COMPILE_TIME_ASSERT(131 == CM_SURF_FMT_sRGBA16I);\n    COMPILE_TIME_ASSERT(132 == CM_SURF_FMT_sRGBX16I);\n    COMPILE_TIME_ASSERT(133 == CM_SURF_FMT_sALPHA16I);\n    COMPILE_TIME_ASSERT(134 == CM_SURF_FMT_sINTENSITY16I);\n    COMPILE_TIME_ASSERT(135 == CM_SURF_FMT_sLUMINANCE16I);\n    COMPILE_TIME_ASSERT(136 == CM_SURF_FMT_sLUMINANCE_ALPHA16I);\n    COMPILE_TIME_ASSERT(137 == CM_SURF_FMT_sRGBA8I);\n    COMPILE_TIME_ASSERT(138 == CM_SURF_FMT_sRGBX8I);\n    COMPILE_TIME_ASSERT(139 == CM_SURF_FMT_sALPHA8I);\n    COMPILE_TIME_ASSERT(140 == CM_SURF_FMT_sINTENSITY8I);\n    COMPILE_TIME_ASSERT(141 == CM_SURF_FMT_sLUMINANCE8I);\n    COMPILE_TIME_ASSERT(142 == CM_SURF_FMT_sLUMINANCE_ALPHA8I);\n    COMPILE_TIME_ASSERT(143 == CM_SURF_FMT_sDXT6);\n    COMPILE_TIME_ASSERT(144 == CM_SURF_FMT_DXT6);\n    COMPILE_TIME_ASSERT(145 == CM_SURF_FMT_DXT7);\n    COMPILE_TIME_ASSERT(146 == CM_SURF_FMT_LUMINANCE8_SNORM);\n    COMPILE_TIME_ASSERT(147 == CM_SURF_FMT_LUMINANCE16_SNORM);\n    COMPILE_TIME_ASSERT(148 == CM_SURF_FMT_INTENSITY8_SNORM);\n    COMPILE_TIME_ASSERT(149 == CM_SURF_FMT_INTENSITY16_SNORM);\n    COMPILE_TIME_ASSERT(150 == CM_SURF_FMT_ALPHA8_SNORM);\n    COMPILE_TIME_ASSERT(151 == CM_SURF_FMT_ALPHA16_SNORM);\n    COMPILE_TIME_ASSERT(152 == CM_SURF_FMT_LUMINANCE_ALPHA8_SNORM);\n    COMPILE_TIME_ASSERT(153 == CM_SURF_FMT_LUMINANCE_ALPHA16_SNORM);\n    COMPILE_TIME_ASSERT(154 == CM_SURF_FMT_R8_SNORM);\n    COMPILE_TIME_ASSERT(155 == CM_SURF_FMT_R16_SNORM);\n    COMPILE_TIME_ASSERT(156 == CM_SURF_FMT_RG8_SNORM);\n    COMPILE_TIME_ASSERT(157 == CM_SURF_FMT_RG16_SNORM);\n    COMPILE_TIME_ASSERT(158 == CM_SURF_FMT_RGBX8_SNORM);\n    COMPILE_TIME_ASSERT(159 == CM_SURF_FMT_RGBX16_SNORM);\n    COMPILE_TIME_ASSERT(160 == CM_SURF_FMT_RGBA8_SNORM);\n    COMPILE_TIME_ASSERT(161 == CM_SURF_FMT_RGBA16_SNORM);\n    COMPILE_TIME_ASSERT(162 == CM_SURF_FMT_RGB10_A2UI);\n    COMPILE_TIME_ASSERT(163 == CM_SURF_FMT_RGB32F);\n    COMPILE_TIME_ASSERT(164 == CM_SURF_FMT_RGB32I);\n    COMPILE_TIME_ASSERT(165 == CM_SURF_FMT_RGB32UI);\n    COMPILE_TIME_ASSERT(166 == CM_SURF_FMT_RGBX8_SRGB);\n    COMPILE_TIME_ASSERT(167 == CM_SURF_FMT_RGBA8_SRGB);\n    COMPILE_TIME_ASSERT(168 == CM_SURF_FMT_DXT1_SRGB);\n    COMPILE_TIME_ASSERT(169 == CM_SURF_FMT_DXT1A_SRGB);\n    COMPILE_TIME_ASSERT(170 == CM_SURF_FMT_DXT2_3_SRGB);\n    COMPILE_TIME_ASSERT(171 == CM_SURF_FMT_DXT4_5_SRGB);\n    COMPILE_TIME_ASSERT(172 == CM_SURF_FMT_DXT7_SRGB);\n    COMPILE_TIME_ASSERT(173 == CM_SURF_FMT_RGB8_ETC2);\n    COMPILE_TIME_ASSERT(174 == CM_SURF_FMT_SRGB8_ETC2);\n    COMPILE_TIME_ASSERT(175 == CM_SURF_FMT_RGB8_PT_ALPHA1_ETC2);\n    COMPILE_TIME_ASSERT(176 == CM_SURF_FMT_SRGB8_PT_ALPHA1_ETC2);\n    COMPILE_TIME_ASSERT(177 == CM_SURF_FMT_RGBA8_ETC2_EAC);\n    COMPILE_TIME_ASSERT(178 == CM_SURF_FMT_SRGB8_ALPHA8_ETC2_EAC);\n    COMPILE_TIME_ASSERT(179 == CM_SURF_FMT_R11_EAC);\n    COMPILE_TIME_ASSERT(180 == CM_SURF_FMT_SIGNED_R11_EAC);\n    COMPILE_TIME_ASSERT(181 == CM_SURF_FMT_RG11_EAC);\n    COMPILE_TIME_ASSERT(182 == CM_SURF_FMT_SIGNED_RG11_EAC);\n    COMPILE_TIME_ASSERT(183 == CM_SURF_FMT_RGBA8_ASTC_4x4);\n    COMPILE_TIME_ASSERT(184 == CM_SURF_FMT_RGBA8_ASTC_5x4);\n    COMPILE_TIME_ASSERT(185 == CM_SURF_FMT_RGBA8_ASTC_5x5);\n    COMPILE_TIME_ASSERT(186 == CM_SURF_FMT_RGBA8_ASTC_6x5);\n    COMPILE_TIME_ASSERT(187 == CM_SURF_FMT_RGBA8_ASTC_6x6);\n    COMPILE_TIME_ASSERT(188 == CM_SURF_FMT_RGBA8_ASTC_8x5);\n    COMPILE_TIME_ASSERT(189 == CM_SURF_FMT_RGBA8_ASTC_8x6);\n    COMPILE_TIME_ASSERT(190 == CM_SURF_FMT_RGBA8_ASTC_8x8);\n    COMPILE_TIME_ASSERT(191 == CM_SURF_FMT_RGBA8_ASTC_10x5);\n    COMPILE_TIME_ASSERT(192 == CM_SURF_FMT_RGBA8_ASTC_10x6);\n    COMPILE_TIME_ASSERT(193 == CM_SURF_FMT_RGBA8_ASTC_10x8);\n    COMPILE_TIME_ASSERT(194 == CM_SURF_FMT_RGBA8_ASTC_10x10);\n    COMPILE_TIME_ASSERT(195 == CM_SURF_FMT_RGBA8_ASTC_12x10);\n    COMPILE_TIME_ASSERT(196 == CM_SURF_FMT_RGBA8_ASTC_12x12);\n    COMPILE_TIME_ASSERT(197 == CM_SURF_FMT_SRGBA8_ASTC_4x4);\n    COMPILE_TIME_ASSERT(198 == CM_SURF_FMT_SRGBA8_ASTC_5x4);\n    COMPILE_TIME_ASSERT(199 == CM_SURF_FMT_SRGBA8_ASTC_5x5);\n    COMPILE_TIME_ASSERT(200 == CM_SURF_FMT_SRGBA8_ASTC_6x5);\n    COMPILE_TIME_ASSERT(201 == CM_SURF_FMT_SRGBA8_ASTC_6x6);\n    COMPILE_TIME_ASSERT(202 == CM_SURF_FMT_SRGBA8_ASTC_8x5);\n    COMPILE_TIME_ASSERT(203 == CM_SURF_FMT_SRGBA8_ASTC_8x6);\n    COMPILE_TIME_ASSERT(204 == CM_SURF_FMT_SRGBA8_ASTC_8x8);\n    COMPILE_TIME_ASSERT(205 == CM_SURF_FMT_SRGBA8_ASTC_10x5);\n    COMPILE_TIME_ASSERT(206 == CM_SURF_FMT_SRGBA8_ASTC_10x6);\n    COMPILE_TIME_ASSERT(207 == CM_SURF_FMT_SRGBA8_ASTC_10x8);\n    COMPILE_TIME_ASSERT(208 == CM_SURF_FMT_SRGBA8_ASTC_10x10);\n    COMPILE_TIME_ASSERT(209 == CM_SURF_FMT_SRGBA8_ASTC_12x10);\n    COMPILE_TIME_ASSERT(210 == CM_SURF_FMT_SRGBA8_ASTC_12x12);\n    COMPILE_TIME_ASSERT(211 == CM_SURF_FMT_BGR10_A2UI);\n    COMPILE_TIME_ASSERT(212 == CM_SURF_FMT_A2_BGR10UI);\n    COMPILE_TIME_ASSERT(213 == CM_SURF_FMT_A2_RGB10UI);\n    COMPILE_TIME_ASSERT(214 == CM_SURF_FMT_B5_G6_R5UI);\n    COMPILE_TIME_ASSERT(215 == CM_SURF_FMT_R5_G6_B5UI);\n    COMPILE_TIME_ASSERT(216 == CM_SURF_FMT_DEPTH32F_X24_STEN8_UNCLAMPED);\n    COMPILE_TIME_ASSERT(217 == CM_SURF_FMT_DEPTH32F_UNCLAMPED);\n    COMPILE_TIME_ASSERT(218 == CM_SURF_FMT_L8_X16_A8_SRGB);\n    COMPILE_TIME_ASSERT(219 == CM_SURF_FMT_L8_X24_SRGB);\n    COMPILE_TIME_ASSERT(220 == CM_SURF_FMT_STENCIL8);\n    COMPILE_TIME_ASSERT(221 == CM_SURF_FMT_L8_SRGB);\n    COMPILE_TIME_ASSERT(222 == CM_SURF_FMT_R8_SRGB);\n    COMPILE_TIME_ASSERT(223 == CM_SURF_FMT_RG8_SRGB);\n#endif\n    COMPILE_TIME_ASSERT(cmSurfFmt_LAST  == CM_SURF_FMT_RG8_SRGB);\n    COMPILE_TIME_ASSERT(cmSurfFmt_LAST < 501);\n}\n\n#ifdef ATI_OS_LINUX\ntypedef void* (*PFNGlxGetProcAddress)(const GLubyte* procName);\nstatic PFNGlxGetProcAddress    pfnGlxGetProcAddress=NULL;\nstatic PFNGLXBEGINCLINTEROPAMD glXBeginCLInteropAMD = NULL;\nstatic PFNGLXENDCLINTEROPAMD glXEndCLInteropAMD = NULL;\nstatic PFNGLXRESOURCEATTACHAMD glXResourceAttachAMD = NULL;\nstatic PFNGLXRESOURCEDETACHAMD glxResourceAcquireAMD = NULL;\nstatic PFNGLXRESOURCEDETACHAMD glxResourceReleaseAMD = NULL;\nstatic PFNGLXRESOURCEDETACHAMD glXResourceDetachAMD = NULL;\nstatic PFNGLXGETCONTEXTMVPUINFOAMD glXGetContextMVPUInfoAMD = NULL;\n#else\nstatic PFNWGLBEGINCLINTEROPAMD wglBeginCLInteropAMD = NULL;\nstatic PFNWGLENDCLINTEROPAMD wglEndCLInteropAMD = NULL;\nstatic PFNWGLRESOURCEATTACHAMD wglResourceAttachAMD = NULL;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceAcquireAMD = NULL;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceReleaseAMD = NULL;\nstatic PFNWGLRESOURCEDETACHAMD wglResourceDetachAMD = NULL;\nstatic PFNWGLGETCONTEXTGPUINFOAMD wglGetContextGPUInfoAMD = NULL;\n#endif\n\nbool\nCALGSLDevice::initGLInteropPrivateExt(CALvoid* GLplatformContext, CALvoid* GLdeviceContext) const\n{\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext)GLplatformContext;\n    void * pModule = dlopen(\"libGL.so.1\",RTLD_NOW);\n\n    if(NULL == pModule){\n        return false;\n    }\n    pfnGlxGetProcAddress = (PFNGlxGetProcAddress) dlsym(pModule,\"glXGetProcAddress\");\n\n    if (NULL == pfnGlxGetProcAddress){\n        return false;\n    }\n\n    if (!glXBeginCLInteropAMD || !glXEndCLInteropAMD || !glXResourceAttachAMD ||\n        !glXResourceDetachAMD || !glXGetContextMVPUInfoAMD)\n    {\n        glXBeginCLInteropAMD = (PFNGLXBEGINCLINTEROPAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXBeginCLInteroperabilityAMD\");\n        glXEndCLInteropAMD = (PFNGLXENDCLINTEROPAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXEndCLInteroperabilityAMD\");\n        glXResourceAttachAMD = (PFNGLXRESOURCEATTACHAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXResourceAttachAMD\");\n        glxResourceAcquireAMD = (PFNGLXRESOURCEDETACHAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXResourceAcquireAMD\");\n        glxResourceReleaseAMD = (PFNGLXRESOURCEDETACHAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXResourceReleaseAMD\");\n        glXResourceDetachAMD = (PFNGLXRESOURCEDETACHAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXResourceDetachAMD\");\n        glXGetContextMVPUInfoAMD = (PFNGLXGETCONTEXTMVPUINFOAMD) pfnGlxGetProcAddress ((const GLubyte *)\"glXGetContextMVPUInfoAMD\");\n    }\n\n    if (!glXBeginCLInteropAMD || !glXEndCLInteropAMD || !glXResourceAttachAMD ||\n        !glXResourceDetachAMD\n#ifndef BRAHMA\n        || !glXGetContextMVPUInfoAMD\n#endif\n        )\n    {\n        return false;\n    }\n#else\n    if (!wglBeginCLInteropAMD || !wglEndCLInteropAMD || !wglResourceAttachAMD ||\n        !wglResourceDetachAMD || !wglGetContextGPUInfoAMD)\n    {\n        HGLRC fakeRC = NULL;\n\n        if (!wglGetCurrentContext())\n        {\n            fakeRC = wglCreateContext((HDC)GLdeviceContext);\n            wglMakeCurrent((HDC)GLdeviceContext, fakeRC);\n        }\n\n        wglBeginCLInteropAMD = (PFNWGLBEGINCLINTEROPAMD) wglGetProcAddress (\"wglBeginCLInteroperabilityAMD\");\n        wglEndCLInteropAMD = (PFNWGLENDCLINTEROPAMD) wglGetProcAddress (\"wglEndCLInteroperabilityAMD\");\n        wglResourceAttachAMD = (PFNWGLRESOURCEATTACHAMD) wglGetProcAddress (\"wglResourceAttachAMD\");\n        wglResourceAcquireAMD = (PFNWGLRESOURCEDETACHAMD) wglGetProcAddress (\"wglResourceAcquireAMD\");\n        wglResourceReleaseAMD = (PFNWGLRESOURCEDETACHAMD) wglGetProcAddress (\"wglResourceReleaseAMD\");\n        wglResourceDetachAMD = (PFNWGLRESOURCEDETACHAMD) wglGetProcAddress (\"wglResourceDetachAMD\");\n        wglGetContextGPUInfoAMD = (PFNWGLGETCONTEXTGPUINFOAMD) wglGetProcAddress (\"wglGetContextGPUInfoAMD\");\n\n        if (fakeRC)\n        {\n            wglMakeCurrent(NULL, NULL);\n            wglDeleteContext(fakeRC);\n        }\n    }\n    if (!wglBeginCLInteropAMD || !wglEndCLInteropAMD || !wglResourceAttachAMD ||\n        !wglResourceDetachAMD || !wglGetContextGPUInfoAMD)\n    {\n        return false;\n    }\n#endif\n    return true;\n}\n\nbool\nCALGSLDevice::glCanInterop(CALvoid* GLplatformContext, CALvoid* GLdeviceContext)\n{\n    bool canInteroperate = false;\n\n#ifdef ATI_OS_WIN\n    LUID glAdapterLuid = {0, 0};\n    UINT glChainBitMask = 0;\n\n    LUID calAdapterLuid = {0, 0};\n    UINT calChainBitMask = 0;\n\n    HGLRC hRC = (HGLRC)GLplatformContext;\n\n    //get GL context's LUID and chainBitMask from UGL\n    if (wglGetContextGPUInfoAMD(hRC, &glAdapterLuid, &glChainBitMask))\n    {\n        //now check against the CAL device' LUID and chainBitMask.\n        if (m_adp->getMVPUinfo(&calAdapterLuid, &calChainBitMask))\n        {\n            canInteroperate = ((glAdapterLuid.HighPart == calAdapterLuid.HighPart) &&\n                               (glAdapterLuid.LowPart == calAdapterLuid.LowPart) &&\n                               (glChainBitMask == calChainBitMask));\n        }\n    }\n#elif defined (ATI_OS_LINUX)\n#ifdef BRAHMA\n    canInteroperate = true;\n#else\n    GLuint glDeviceId = 0 ;\n    GLuint glChainMask = 0 ;\n    GLXContext ctx = (GLXContext)GLplatformContext;\n    \n    if (glXGetContextMVPUInfoAMD(ctx,&glDeviceId,&glChainMask)){\n        GLuint deviceId = 0 ;\n        GLuint chainMask = 0 ;\n\n        if (m_adp->getMVPUinfo(&deviceId, &chainMask))\n        {\n        // we allow intoperability only with GL context\n        // reside on a single GPU\n            if (deviceId == glDeviceId && chainMask == glChainMask){\n                    canInteroperate = true;\n            }\n        }\n    }\n#endif\n#endif\n    return canInteroperate;\n}\n\nbool\nCALGSLDevice::glAssociate(CALvoid* GLplatformContext, CALvoid* GLdeviceContext)\n{\n    //initialize pointers to the gl extension that supports interoperability\n    if (!initGLInteropPrivateExt(GLplatformContext, GLdeviceContext) ||\n        !glCanInterop(GLplatformContext, GLdeviceContext))\n    {\n        return false;\n    }\n\n    int flags = 0;\n\n    if (m_adp->pAsicInfo->svmFineGrainSystem)\n    {\n        flags = GL_INTEROP_SVM;\n    }\n\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext)GLplatformContext;\n    return (glXBeginCLInteropAMD(ctx, 0)) ? true : false;\n#else\n    HGLRC hRC = (HGLRC)GLplatformContext;\n    return (wglBeginCLInteropAMD(hRC, flags)) ? true : false;\n#endif\n}\n\nbool\nCALGSLDevice::glDissociate(CALvoid* GLplatformContext, CALvoid* GLdeviceContext)\n{\n    int flags = 0;\n\n    if (m_adp->pAsicInfo->svmFineGrainSystem)\n    {\n        flags = GL_INTEROP_SVM;\n    }\n\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext)GLplatformContext;\n    return (glXEndCLInteropAMD(ctx, 0)) ? true : false;\n#else\n    HGLRC hRC = (HGLRC)GLplatformContext;\n    return (wglEndCLInteropAMD(hRC, flags)) ? true : false;\n#endif\n}\n\nbool\nCALGSLDevice::resGLAssociate(GLResAssociate & resData) const\n{\n    //! @note: GSL device isn't thread safe\n    amd::ScopedLock k(gslDeviceOps());\n\n    GLResource hRes = {0};\n    bool status = false;\n    cmSurfFmt cal_cmFormat;\n    uint32 depth;\n\n    gslMemObjectAttribs attribs(\n        GSL_MOA_TEXTURE_2D,      // type\n        GSL_MOA_MEMORY_ALIAS,    // location\n        GSL_MOA_TILING_TILED,    // tiling\n        GSL_MOA_DISPLAYABLE_NO,  // displayable\n        ATIGL_FALSE,             // mipmap\n        1,                       // samples\n        0,                       // cpu_address\n        GSL_MOA_SIGNED_NO,       // signed_format\n        GSL_MOA_FORMAT_DERIVED,  // numFormat\n        DRIVER_MODULE_GLL,       // module\n        GSL_ALLOCATION_INSTANCED // alloc_type\n    );\n\n    hRes.type = resData.type;\n\n    GLResourceData* hData = new GLResourceData;\n    if (NULL == hData)\n    {\n        return false;\n    }\n    memset(hData, 0, sizeof(GLResourceData));\n\n    hRes.name = resData.name;\n    hRes.flags = resData.flags;\n    hData->version = GL_RESOURCE_DATA_VERSION;\n\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext)resData.GLContext;\n    if (glXResourceAttachAMD(ctx, &hRes, hData))\n    {\n        attribs.dynamicSharedBufferID = hData->sharedBufferID;\n        status = true;\n    }\n#else\n    HGLRC hRC = (HGLRC)resData.GLContext;\n    if (wglResourceAttachAMD(hRC, &hRes, hData))\n    {\n        status =  true;\n    }\n#endif\n\n    if (!status)\n    {\n        return false;\n    }\n\n    // for now, to be safe, allow only textures to have a depth other than 1\n    if (hRes.type == GL_RESOURCE_ATTACH_TEXTURE_AMD)\n    {\n        depth = hData->rawDimensions.depth;\n    }\n    else\n    {\n        depth = 1;\n    }\n\n    attribs.type = static_cast<gslMemObjectAttribType>(hData->objectAttribType);\n\n    osAssert(depth <= GLRDATA_MAX_LAYERS);\n    osAssert(depth >= 1);\n    attribs.alias_swizzles = (uint32*)malloc(depth * 2 * sizeof(uint32));\n    osAssert(attribs.alias_swizzles);\n    memcpy (attribs.alias_swizzles, hData->swizzles, sizeof(uint32) * depth);\n    if (hData->levels > 1)\n    {\n        attribs.mipmap = ATIGL_TRUE;\n        attribs.levels = static_cast<GLuint>(hData->levels);\n        memcpy (&attribs.alias_swizzles[depth], hData->swizzlesMip, sizeof(uint32) * depth);\n    }\n\n    attribs.cpu_address = (void*)hData->handle;\n    attribs.alias_subtile = hData->tilingMode;\n    attribs.mcaddress = hData->cardAddr;\n    if (hData->isDoppDesktopTexture == GL_TRUE || (hData->isDoppPresentTexture == GL_TRUE) ||\n        (hData->isDisplayable == GL_TRUE))\n    {\n        attribs.isDOPPDesktopTexture = (hData->isDoppDesktopTexture == GL_TRUE);\n        attribs.displayable = hData->isTilingRotated\n                                  ? GSL_MOA_DISPLAYABLE_PORTRAIT_ROTATED : GSL_MOA_DISPLAYABLE_LAYOUT;\n    }\n    attribs.doppVidpnSourceId = hData->vidpnSourceId;\n\n    // VBOs are hardcoded to have a UINT8 type format\n    if (hRes.type == GL_RESOURCE_ATTACH_VERTEXBUFFER_AMD)\n    {\n        hData->format = CM_SURF_FMT_LUMINANCE8;\n    }\n    // CAL supports only a limited number of cm_surf formats, so we\n    // have to translate incoming cm_surf formats\n    uint32 index = hData->format - (uint32)CM_SURF_FMT_LUMINANCE8;\n    if (index >= sizeof(cmFormatXlateTable)/sizeof(cmFormatXlateParams))\n    {\n        free(attribs.alias_swizzles);\n        delete hData;\n        return false;\n    }\n    osAssert(static_cast<cmSurfFmt>(hData->format) == cmFormatXlateTable[index].raw_cmFormat);\n    cal_cmFormat = cmFormatXlateTable[index].cal_cmFormat;\n    if (cal_cmFormat == 500)\n    {\n        free(attribs.alias_swizzles);\n        delete hData;\n        return false;  // format is not supported by CAL\n    }\n    attribs.channelOrder = cmFormatXlateTable[index].channelOrder;\n    attribs.alias_perSurfTileInfo = hData->perSurfTileInfo;\n    attribs.alias_GLInterop = ATIGL_TRUE;\n    attribs.numFormat = GSL_MOA_FORMAT_DERIVED;\n\n    gslMemObject    mem;\n\n    if (hData->offset != 0)\n    {\n        osAssert((hData->rawDimensions.height == 1) && (depth == 1));\n        mem = m_cs->createMemObject2D(CM_SURF_FMT_LUMINANCE8, hData->surfaceSize, 1, &attribs);\n    }\n    else\n    {\n        mem = m_cs->createMemObject3D(cal_cmFormat, hData->paddedDimensions.width,\n            hData->rawDimensions.height, depth, &attribs);\n    }\n    if (hRes.type == GL_RESOURCE_ATTACH_VERTEXBUFFER_AMD)\n    {\n        attribs.tiling = mem->getAttribs().tiling;\n        resData.mem_base = mem;\n        mem  = m_cs->createOffsetMemObject2D(resData.mem_base, (static_cast<uintp>(hData->offset)),\n                                                                cal_cmFormat,\n                                                                hData->paddedDimensions.width,\n                                                                1, &attribs);\n    }\n    else if ((hData->offset != 0) && (hData->rawDimensions.height == 1) && (depth == 1))\n    {\n        resData.mem_base = mem;\n        attribs.tiling = mem->getAttribs().tiling;\n        mem = m_cs->createOffsetMemObject3D(resData.mem_base, (static_cast<uintp>(hData->offset)),\n            cal_cmFormat, hData->paddedDimensions.width,\n            hData->rawDimensions.height, depth, &attribs);\n    }\n    free (attribs.alias_swizzles);\n    resData.mbResHandle = (CALvoid*)hData->mbResHandle;\n    resData.memObject = mem;\n    delete hData;\n    return mem != 0;\n}\n\nbool\nCALGSLDevice::resGLAcquire(CALvoid* GLplatformContext,\n    CALvoid* mbResHandle,\n    CALuint type) const\n{\n    //! @note: GSL device isn't thread safe\n    amd::ScopedLock k(gslDeviceOps());\n\n    GLResource hRes = {0};\n    osAssert(mbResHandle);\n    hRes.mbResHandle = (GLuintp)mbResHandle;\n    hRes.type = type;\n\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext) GLplatformContext;\n    return (glxResourceAcquireAMD(ctx, &hRes)) ? true : false;\n#else\n    HGLRC hRC = wglGetCurrentContext();\n    //! @todo A temporary workaround for MT issue in conformance fence_sync\n    if (0 == hRC) {\n        return true;\n    }\n    return (wglResourceAcquireAMD(hRC, &hRes)) ? true : false;\n#endif\n}\n\nbool\nCALGSLDevice::resGLRelease(CALvoid* GLplatformContext,\n    CALvoid* mbResHandle,\n    CALuint type) const\n{\n    //! @note: GSL device isn't thread safe\n    amd::ScopedLock k(gslDeviceOps());\n\n    GLResource hRes = {0};\n    osAssert(mbResHandle);\n    hRes.mbResHandle = (GLuintp)mbResHandle;\n    hRes.type = type;\n\n#ifdef ATI_OS_LINUX\n    //TODO : make sure the application GL context is current. if not no\n    // point calling into the GL RT.\n    GLXContext ctx = (GLXContext) GLplatformContext;\n    return (glxResourceReleaseAMD(ctx, &hRes)) ? true : false;\n#else\n    // Make the call into the GL driver only if the application GL context is current\n    HGLRC hRC = wglGetCurrentContext();\n    //! @todo A temporary workaround for MT issue in conformance fence_sync\n    if (0 == hRC) {\n        return true;\n    }\n    return (wglResourceReleaseAMD(hRC, &hRes)) ? true : false;\n#endif\n}\n\nbool\nCALGSLDevice::resGLFree (\n    CALvoid* GLplatformContext,\n    CALvoid* GLdeviceContext,\n    gslMemObject mem,\n    gslMemObject mem_base,\n    CALvoid* mbResHandle,\n    CALuint type) const\n{\n    //! @note: GSL device isn't thread safe\n    amd::ScopedLock k(gslDeviceOps());\n\n    GLResource hRes = {0};\n\n    osAssert(mbResHandle);\n    hRes.mbResHandle = (GLuintp)mbResHandle;\n    hRes.type = type;\n\n    if (mem_base)\n    {\n        m_cs->destroyMemObject(mem_base);\n    }\n    m_cs->destroyMemObject(mem);\n\n#ifdef ATI_OS_LINUX\n    GLXContext ctx = (GLXContext)GLplatformContext;\n    return (glXResourceDetachAMD(ctx, &hRes)) ? true : false;\n#else\n    HGLRC hRC = (HGLRC)GLplatformContext;\n    return (wglResourceDetachAMD(hRC, &hRes)) ? true : false;\n#endif\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.7.0-6twwcw3rjraboiuw75ysfcdddj55uxkg/spack-src/device/rocm/pro/prodevice.cpp": "/* Copyright (c) 2017-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#ifndef WITHOUT_HSA_BACKEND\n\n#include \"hsa_ext_amd.h\"\n#include \"lnxheaders.h\"\n#include \"prodevice.hpp\"\n#include \"amdgpu_drm.h\"\n\nnamespace roc {\n\nconstexpr uint32_t kMaxDevices  = 32;\nconstexpr uint32_t kAtiVendorId = 0x1002;\n\nvoid*      ProDevice::lib_drm_handle_ = nullptr;\nbool       ProDevice::initialized_ = false;\ndrm::Funcs ProDevice::funcs_;\n\nIProDevice* IProDevice::Init(uint32_t bus, uint32_t dev, uint32_t func)\n{\n  // Make sure DRM lib is initialized\n  if (!ProDevice::DrmInit()) {\n    return nullptr;\n  }\n\n  ProDevice* pro_device = new ProDevice();\n\n  if (pro_device == nullptr || !pro_device->Create(bus, dev, func)) {\n    delete pro_device;\n    return nullptr;\n  }\n  return pro_device;\n}\n\nProDevice::~ProDevice() {\n  delete alloc_ops_;\n\n  if (dev_handle_ != nullptr) {\n    Funcs().AmdgpuDeviceDeinitialize(dev_handle_);\n  }\n  if (file_desc_ > 0) {\n    close(file_desc_);\n  }\n}\n\nbool ProDevice::DrmInit()\n{\n  if (initialized_ == false) {\n    // Find symbols in libdrm_amdgpu.so.1\n    lib_drm_handle_ = dlopen(\"libdrm_amdgpu.so.1\", RTLD_NOW);\n    if (lib_drm_handle_ == nullptr) {\n      return false;\n    } else {\n      funcs_.DrmGetDevices = reinterpret_cast<drm::DrmGetDevices>(dlsym(\n                             lib_drm_handle_,\n                             \"drmGetDevices\"));\n      if (funcs_.DrmGetDevices == nullptr) return false;\n      funcs_.AmdgpuDeviceInitialize = reinterpret_cast<drm::AmdgpuDeviceInitialize>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_device_initialize\"));\n      if (funcs_.AmdgpuDeviceInitialize == nullptr) return false;\n      funcs_.AmdgpuDeviceDeinitialize = reinterpret_cast<drm::AmdgpuDeviceDeinitialize>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_device_deinitialize\"));\n      if (funcs_.AmdgpuDeviceDeinitialize == nullptr) return false;\n      funcs_.AmdgpuQueryGpuInfo = reinterpret_cast<drm::AmdgpuQueryGpuInfo>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_query_gpu_info\"));\n      if (funcs_.AmdgpuQueryGpuInfo == nullptr) return false;\n      funcs_.AmdgpuQueryInfo = reinterpret_cast<drm::AmdgpuQueryInfo>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_query_info\"));\n      if (funcs_.AmdgpuQueryInfo == nullptr) return false;\n      funcs_.AmdgpuBoAlloc = reinterpret_cast<drm::AmdgpuBoAlloc>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_bo_alloc\"));\n      if (funcs_.AmdgpuBoAlloc == nullptr) return false;\n      funcs_.AmdgpuBoExport = reinterpret_cast<drm::AmdgpuBoExport>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_bo_export\"));\n      if (funcs_.AmdgpuBoExport == nullptr) return false;\n      funcs_.AmdgpuBoFree = reinterpret_cast<drm::AmdgpuBoFree>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_bo_free\"));\n      if (funcs_.AmdgpuBoFree == nullptr) return false;\n      funcs_.AmdgpuBoCpuMap = reinterpret_cast<drm::AmdgpuBoCpuMap>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_bo_cpu_map\"));\n      if (funcs_.AmdgpuBoCpuMap == nullptr) return false;\n      funcs_.AmdgpuBoCpuUnmap = reinterpret_cast<drm::AmdgpuBoCpuUnmap>(dlsym(\n                             lib_drm_handle_,\n                             \"amdgpu_bo_cpu_unmap\"));\n      if (funcs_.AmdgpuBoCpuUnmap == nullptr) return false;\n    }\n  }\n\n  initialized_ = true;\n  return true;\n}\n\n#ifndef AMDGPU_CAPABILITY_SSG_FLAG\n#define AMDGPU_CAPABILITY_SSG_FLAG 4\n#endif\n\n// ================================================================================================\n// Open drm device and initialize it. And also get the drm information.\nbool ProDevice::Create(uint32_t bus, uint32_t device, uint32_t func) {\n  drmDevicePtr  devices[kMaxDevices] = { };\n  int32_t device_count = Funcs().DrmGetDevices(devices, kMaxDevices);\n  bool    result = false;\n\n  for (int32_t i = 0; i < device_count; i++) {\n    // Check if the device vendor is AMD\n    if (devices[i]->deviceinfo.pci->vendor_id != kAtiVendorId) {\n      continue;\n    }\n    if ((devices[i]->businfo.pci->bus == bus) &&\n        (devices[i]->businfo.pci->dev == device) &&\n        (devices[i]->businfo.pci->func == func)) {\n\n      // pDevices[i]->nodes[DRM_NODE_PRIMARY];\n      // Using render node here so that we can do the off-screen rendering without authentication\n      file_desc_ = open(devices[i]->nodes[DRM_NODE_RENDER], O_RDWR, 0);\n\n      if (file_desc_ > 0) {\n        void* data, *file, *cap;\n\n        // Initialize the admgpu device.\n        if (Funcs().AmdgpuDeviceInitialize(file_desc_, &major_ver_,\n                                           &minor_ver_, &dev_handle_) == 0) {\n          uint32_t version = 0;\n          // amdgpu_query_gpu_info will never fail only if it is initialized\n          Funcs().AmdgpuQueryGpuInfo(dev_handle_, &gpu_info_);\n\n          drm_amdgpu_capability cap = {};\n          Funcs().AmdgpuQueryInfo(dev_handle_, AMDGPU_INFO_CAPABILITY, sizeof(drm_amdgpu_capability), &cap);\n\n          // Check if DGMA and SSG are available\n          if ((cap.flag & (AMDGPU_CAPABILITY_DIRECT_GMA_FLAG | AMDGPU_CAPABILITY_SSG_FLAG)) == \n              (AMDGPU_CAPABILITY_DIRECT_GMA_FLAG | AMDGPU_CAPABILITY_SSG_FLAG)) {\n            result = true;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  if (result) {\n    alloc_ops_ = new amd::Monitor(\"DGMA mem alloc lock\", true);\n    if (nullptr == alloc_ops_) {\n      return true;\n    }\n  }\n\n  return result;\n}\n\nvoid* ProDevice::AllocDmaBuffer(hsa_agent_t agent, size_t size, void** host_ptr) const\n{\n  amd::ScopedLock l(alloc_ops_);\n  void* ptr = nullptr;\n  amdgpu_bo_handle buf_handle = 0;\n  amdgpu_bo_alloc_request req = {0};\n  *host_ptr = nullptr;\n\n  req.alloc_size = size;\n  req.phys_alignment = 64 * Ki;\n  req.preferred_heap = AMDGPU_GEM_DOMAIN_DGMA;\n\n  // Allocate buffer in DGMA heap\n  if (0 == Funcs().AmdgpuBoAlloc(dev_handle_, &req, &buf_handle)) {\n    amdgpu_bo_handle_type type = amdgpu_bo_handle_type_dma_buf_fd;\n    uint32_t shared_handle = 0;\n    // Find the base driver handle\n    if (0 == Funcs().AmdgpuBoExport(buf_handle, type, &shared_handle)) {\n      uint32_t  flags = 0;\n      size_t    buf_size = 0;\n      // Map memory object to HSA device\n      if (0 == hsa_amd_interop_map_buffer(1, &agent, shared_handle,\n                                          flags, &buf_size, &ptr, nullptr, nullptr)) {\n        // Ask GPUPro driver to provide CPU access to allocation\n        if (0 == Funcs().AmdgpuBoCpuMap(buf_handle, host_ptr)) {\n          allocs_.insert({ptr, {buf_handle, shared_handle}});\n        }\n        else {\n          hsa_amd_interop_unmap_buffer(ptr);\n          close(shared_handle);\n          Funcs().AmdgpuBoFree(buf_handle);\n        }\n      }\n      else {\n        close(shared_handle);\n        Funcs().AmdgpuBoFree(buf_handle);\n      }\n    }\n    else {\n      Funcs().AmdgpuBoFree(buf_handle);\n    }\n  }\n\n  return ptr;\n}\n\nvoid ProDevice::FreeDmaBuffer(void* ptr) const\n{\n  amd::ScopedLock l(alloc_ops_);\n  auto it = allocs_.find(ptr);\n  if (it != allocs_.end()) {\n    Funcs().AmdgpuBoCpuUnmap(it->second.first);\n    // Unmap memory from HSA device\n    hsa_amd_interop_unmap_buffer(ptr);\n    // Close shared handle\n    close(it->second.second);\n    int error = Funcs().AmdgpuBoFree(it->second.first);\n    allocs_.erase(it);\n  }\n}\n\n}\n\n#endif  // WITHOUT_HSA_BACKEND\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.7.0-6twwcw3rjraboiuw75ysfcdddj55uxkg/spack-src/os/os_posix.cpp": "/* Copyright (c) 2008-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#if !defined(_WIN32) && !defined(__CYGWIN__)\n\n#include \"os/os.hpp\"\n#include \"thread/thread.hpp\"\n#include \"utils/util.hpp\"\n\n#include <iostream>\n#include <stdarg.h>\n\n#include <sys/mman.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/sysinfo.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <dlfcn.h>\n#include <signal.h>\n\n#include <sys/prctl.h>\n\n#include <link.h>\n#include <time.h>\n#include <elf.h>\n#ifndef DT_GNU_HASH\n#define DT_GNU_HASH 0x6ffffef5\n#endif  // DT_GNU_HASH\n\n#include <atomic>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cstring>  // for strncmp\n#include <cstdlib>\n#include <cstdio>  // for tempnam\n#include <limits.h>\n#include <memory>\n#include <algorithm>\n#include <mutex>\n\n\nnamespace amd {\n\nstatic struct sigaction oldSigAction;\n\nstatic bool callOldSignalHandler(int sig, siginfo_t* info, void* ptr) {\n  if (oldSigAction.sa_handler == SIG_DFL) {\n    // no signal handler was previously installed.\n    return false;\n  } else if (oldSigAction.sa_handler != SIG_IGN) {\n    if ((oldSigAction.sa_flags & SA_NODEFER) == 0) {\n      sigaddset(&oldSigAction.sa_mask, sig);\n    }\n\n    void (*handler)(int) = oldSigAction.sa_handler;\n    if (oldSigAction.sa_flags & SA_RESETHAND) {\n      oldSigAction.sa_handler = SIG_DFL;\n    }\n\n    sigset_t savedSigSet;\n    pthread_sigmask(SIG_SETMASK, &oldSigAction.sa_mask, &savedSigSet);\n\n    if (oldSigAction.sa_flags & SA_SIGINFO) {\n      oldSigAction.sa_sigaction(sig, info, ptr);\n    } else {\n      handler(sig);\n    }\n\n    pthread_sigmask(SIG_SETMASK, &savedSigSet, NULL);\n  }\n\n  return true;\n}\n\nstatic void divisionErrorHandler(int sig, siginfo_t* info, void* ptr) {\n  assert(info != NULL && ptr != NULL && \"just checking\");\n  ucontext_t* uc = (ucontext_t*)ptr;\n  address insn;\n\n#if defined(ATI_ARCH_X86)\n  insn = (address)uc->uc_mcontext.gregs[LP64_SWITCH(REG_EIP, REG_RIP)];\n#else\n  assert(!\"Unimplemented\");\n#endif\n\n  if (Thread::current()->isWorkerThread()) {\n    if (Os::skipIDIV(insn)) {\n#if defined(ATI_ARCH_X86)\n      uc->uc_mcontext.gregs[LP64_SWITCH(REG_EIP, REG_RIP)] = (greg_t)insn;\n#else\n      assert(!\"Unimplemented\");\n#endif\n      return;\n    }\n  }\n\n  // Call the chained signal handler\n  if (callOldSignalHandler(sig, info, ptr)) {\n    return;\n  }\n\n\n  std::cerr << \"Unhandled signal in divisionErrorHandler()\" << std::endl;\n  ::abort();\n}\n\ntypedef int (*pthread_setaffinity_fn)(pthread_t, size_t, const cpu_set_t*);\nstatic pthread_setaffinity_fn pthread_setaffinity_fptr;\n\nstatic void init() __attribute__((constructor(101)));\nstatic void init() { Os::init(); }\n\nbool Os::installSigfpeHandler() {\n  // Install a SIGFPE signal handler @todo: Chain the handlers\n  struct sigaction sa;\n  sigfillset(&sa.sa_mask);\n  sa.sa_handler = SIG_DFL;\n  sa.sa_sigaction = divisionErrorHandler;\n  sa.sa_flags = SA_SIGINFO | SA_RESTART;\n\n  if (sigaction(SIGFPE, &sa, &oldSigAction) != 0) {\n    return false;\n  }\n  return true;\n}\n\nvoid Os::uninstallSigfpeHandler() {}\n\nbool Os::init() {\n  static bool initialized_ = false;\n\n  // We could use pthread_once here:\n  if (initialized_) {\n    return true;\n  }\n  initialized_ = true;\n\n  pageSize_ = (size_t)::sysconf(_SC_PAGESIZE);\n  processorCount_ = ::sysconf(_SC_NPROCESSORS_CONF);\n\n  pthread_setaffinity_fptr = (pthread_setaffinity_fn)dlsym(RTLD_NEXT, \"pthread_setaffinity_np\");\n\n  return Thread::init();\n}\n\nstatic void __exit() __attribute__((destructor(101)));\nstatic void __exit() { Os::tearDown(); }\n\nvoid Os::tearDown() { Thread::tearDown(); }\n\nvoid* Os::loadLibrary_(const char* filename) {\n  return (*filename == '\\0') ? NULL : ::dlopen(filename, RTLD_LAZY);\n}\n\nvoid Os::unloadLibrary(void* handle) { ::dlclose(handle); }\n\nvoid* Os::getSymbol(void* handle, const char* name) { return ::dlsym(handle, name); }\n\nstatic inline int memProtToOsProt(Os::MemProt prot) {\n  switch (prot) {\n    case Os::MEM_PROT_NONE:\n      return PROT_NONE;\n    case Os::MEM_PROT_READ:\n      return PROT_READ;\n    case Os::MEM_PROT_RW:\n      return PROT_READ | PROT_WRITE;\n    case Os::MEM_PROT_RWX:\n      return PROT_READ | PROT_WRITE | PROT_EXEC;\n    default:\n      break;\n  }\n  ShouldNotReachHere();\n  return -1;\n}\n\naddress Os::reserveMemory(address start, size_t size, size_t alignment, MemProt prot) {\n  size = alignUp(size, pageSize());\n  alignment = std::max(pageSize(), alignUp(alignment, pageSize()));\n  assert(isPowerOfTwo(alignment) && \"not a power of 2\");\n\n  size_t requested = size + alignment - pageSize();\n  address mem = (address)::mmap(start, requested, memProtToOsProt(prot),\n                                MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS, 0, 0);\n\n  // check for out of memory\n  if (mem == NULL) return NULL;\n\n  address aligned = alignUp(mem, alignment);\n\n  // return the unused leading pages to the free state\n  if (&aligned[0] != &mem[0]) {\n    assert(&aligned[0] > &mem[0] && \"check this code\");\n    if (::munmap(&mem[0], &aligned[0] - &mem[0]) != 0) {\n      assert(!\"::munmap failed\");\n    }\n  }\n  // return the unused trailing pages to the free state\n  if (&aligned[size] != &mem[requested]) {\n    assert(&aligned[size] < &mem[requested] && \"check this code\");\n    if (::munmap(&aligned[size], &mem[requested] - &aligned[size]) != 0) {\n      assert(!\"::munmap failed\");\n    }\n  }\n\n  return aligned;\n}\n\nbool Os::releaseMemory(void* addr, size_t size) {\n  assert(isMultipleOf(addr, pageSize()) && \"not page aligned!\");\n  size = alignUp(size, pageSize());\n\n  return 0 == ::munmap(addr, size);\n}\n\nbool Os::commitMemory(void* addr, size_t size, MemProt prot) {\n  assert(isMultipleOf(addr, pageSize()) && \"not page aligned!\");\n  size = alignUp(size, pageSize());\n\n  return ::mmap(addr, size, memProtToOsProt(prot), MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1,\n                0) != MAP_FAILED;\n}\n\nbool Os::uncommitMemory(void* addr, size_t size) {\n  assert(isMultipleOf(addr, pageSize()) && \"not page aligned!\");\n  size = alignUp(size, pageSize());\n\n  return ::mmap(addr, size, PROT_NONE, MAP_PRIVATE | MAP_FIXED | MAP_NORESERVE | MAP_ANONYMOUS, -1,\n                0) != MAP_FAILED;\n}\n\nbool Os::protectMemory(void* addr, size_t size, MemProt prot) {\n  assert(isMultipleOf(addr, pageSize()) && \"not page aligned!\");\n  size = alignUp(size, pageSize());\n\n  return 0 == ::mprotect(addr, size, memProtToOsProt(prot));\n}\n\nuint64_t Os::hostTotalPhysicalMemory() {\n  static uint64_t totalPhys = 0;\n\n  if (totalPhys != 0) {\n    return totalPhys;\n  }\n\n  totalPhys = sysconf(_SC_PAGESIZE) * sysconf(_SC_PHYS_PAGES);\n  return totalPhys;\n}\n\nvoid* Os::alignedMalloc(size_t size, size_t alignment) {\n  void* ptr = NULL;\n  if (0 == ::posix_memalign(&ptr, alignment, size)) {\n    return ptr;\n  }\n  return NULL;\n}\n\nvoid Os::alignedFree(void* mem) { ::free(mem); }\n\nvoid Os::currentStackInfo(address* base, size_t* size) {\n  // There could be some issue trying to get the pthread_attr of\n  // the primordial thread if the pthread library is not present\n  // at load time (a binary loads the OpenCL/HIP app/runtime dynamically.\n  // We should look into this... -laurent\n\n  pthread_t self = ::pthread_self();\n\n  pthread_attr_t threadAttr;\n  if (0 != ::pthread_getattr_np(self, &threadAttr)) {\n    fatal(\"pthread_getattr_np() failed\");\n  }\n\n  if (0 != ::pthread_attr_getstack(&threadAttr, (void**)base, size)) {\n    fatal(\"pthread_attr_getstack() failed\");\n  }\n  *base += *size;\n\n  ::pthread_attr_destroy(&threadAttr);\n\n  assert(Os::currentStackPtr() >= *base - *size && Os::currentStackPtr() < *base &&\n         \"just checking\");\n}\n\nvoid Os::setCurrentThreadName(const char* name) { ::prctl(PR_SET_NAME, name); }\n\n\nvoid* Thread::entry(Thread* thread) {\n  sigset_t set;\n\n  sigfillset(&set);\n  pthread_sigmask(SIG_BLOCK, &set, NULL);\n\n  sigemptyset(&set);\n  sigaddset(&set, SIGFPE);\n  pthread_sigmask(SIG_UNBLOCK, &set, NULL);\n\n  return thread->main();\n}\n\nbool Os::isThreadAlive(const Thread& thread) {\n  return ::pthread_kill((pthread_t)thread.handle(), 0) == 0;\n}\n\nstatic size_t tlsSize = 0;\n\n// Try to guess the size of TLS (plus some frames)\nvoid* guessTlsSizeThread(void* param) {\n  address stackBase;\n  address currentFrame;\n  size_t stackSize;\n  Os::currentStackInfo(&stackBase, &stackSize);\n  currentFrame = reinterpret_cast<address>(&stackSize);\n  tlsSize = stackBase - currentFrame;\n  // align up to page boundary\n  tlsSize = alignUp(tlsSize, amd::Os::pageSize());\n  return NULL;\n}\n\nstatic void guessTlsSize(void) {\n  int retval;\n  pthread_t handle;\n  pthread_attr_t threadAttr;\n\n  ::pthread_attr_init(&threadAttr);\n  retval = ::pthread_create(&handle, &threadAttr, guessTlsSizeThread, NULL);\n  if (retval == 0) {\n    pthread_join(handle, NULL);\n  } else {\n    fatal(\"pthread_create() failed with default stack size\");\n  }\n  ::pthread_attr_destroy(&threadAttr);\n}\n\nconst void* Os::createOsThread(amd::Thread* thread) {\n  pthread_attr_t threadAttr;\n  ::pthread_attr_init(&threadAttr);\n\n  if (thread->stackSize_ != 0) {\n    size_t guardsize = 0;\n    if (0 != ::pthread_attr_getguardsize(&threadAttr, &guardsize)) {\n      fatal(\"pthread_attr_getguardsize() failed\");\n    }\n\n    static std::once_flag initOnce;\n    std::call_once(initOnce, guessTlsSize);\n    ::pthread_attr_setstacksize(&threadAttr, thread->stackSize_ + guardsize + tlsSize);\n  }\n\n  // We never plan the use join, so free the resources now.\n  ::pthread_attr_setdetachstate(&threadAttr, PTHREAD_CREATE_DETACHED);\n  cpu_set_t cpuset;\n  if (processorCount_ > 0) {\n    CPU_ZERO(&cpuset);\n    for (int i = 0; i < processorCount_; i++) {\n      CPU_SET(i, &cpuset);\n    }\n    if (0 != pthread_attr_setaffinity_np(&threadAttr, sizeof(cpu_set_t), &cpuset)) {\n      fatal(\"pthread_attr_setaffinity_np failed to set affinity\");\n    }\n  }\n\n  pthread_t handle = 0;\n  if (0 != ::pthread_create(&handle, &threadAttr, (void* (*)(void*)) & Thread::entry, thread)) {\n    thread->setState(Thread::FAILED);\n  }\n\n  ::pthread_attr_destroy(&threadAttr);\n  return reinterpret_cast<const void*>(handle);\n}\n\n\nvoid Os::setThreadAffinity(const void* handle, const Os::ThreadAffinityMask& mask) {\n  if (pthread_setaffinity_fptr != NULL) {\n    pthread_setaffinity_fptr((pthread_t)handle, sizeof(cpu_set_t), &mask.mask_);\n  }\n}\n\nvoid Os::yield() { ::sched_yield(); }\n\nuint64_t Os::timeNanos() {\n  struct timespec tp;\n  ::clock_gettime(CLOCK_MONOTONIC, &tp);\n  return (uint64_t)tp.tv_sec * (1000ULL * 1000ULL * 1000ULL) + (uint64_t)tp.tv_nsec;\n}\n\nuint64_t Os::timerResolutionNanos() {\n  static uint64_t resolution = 0;\n  if (resolution == 0) {\n    struct timespec tp;\n    ::clock_getres(CLOCK_MONOTONIC, &tp);\n    resolution = (uint64_t)tp.tv_sec * (1000ULL * 1000ULL * 1000ULL) + (uint64_t)tp.tv_nsec;\n  }\n  return resolution;\n}\n\n\nconst char* Os::libraryExtension() { return MACOS_SWITCH(\".dylib\", \".so\"); }\n\nconst char* Os::libraryPrefix() { return \"lib\"; }\n\nconst char* Os::objectExtension() { return \".o\"; }\n\nchar Os::fileSeparator() { return '/'; }\n\nchar Os::pathSeparator() { return ':'; }\n\nbool Os::pathExists(const std::string& path) {\n  struct stat st;\n  if (stat(path.c_str(), &st) != 0) return false;\n  return S_ISDIR(st.st_mode);\n}\n\nbool Os::createPath(const std::string& path) {\n  mode_t mode = S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH;\n  size_t pos = 0;\n  while (true) {\n    pos = path.find(fileSeparator(), pos);\n    const std::string currPath = path.substr(0, pos);\n    if (!currPath.empty() && !pathExists(currPath)) {\n      int ret = mkdir(currPath.c_str(), mode);\n      if (ret == -1) return false;\n    }\n    if (pos == std::string::npos) break;\n    ++pos;\n  }\n  return true;\n}\n\nbool Os::removePath(const std::string& path) {\n  size_t pos = std::string::npos;\n  bool removed = false;\n  while (true) {\n    const std::string currPath = path.substr(0, pos);\n    if (!currPath.empty()) {\n      int ret = rmdir(currPath.c_str());\n      if (ret == -1) return removed;\n      removed = true;\n    }\n    if (pos == 0) break;\n    pos = path.rfind(fileSeparator(), pos == std::string::npos ? pos : pos - 1);\n    if (pos == std::string::npos) break;\n  }\n  return true;\n}\n\nint Os::printf(const char* fmt, ...) {\n  va_list ap;\n\n  va_start(ap, fmt);\n  int len = ::vprintf(fmt, ap);\n  va_end(ap);\n\n  return len;\n}\n\n// Os::systemCall()\n// ================\n// Execute a program and return the program exitcode or -1 if there were problems.\n// The input argument 'command' is expected to be a space separated string of\n// command-line arguments with arguments containing spaces between double-quotes.\n//\n// In order to avoid duplication of memory, we use vfork()+exec(). vfork() has\n// potiential security risks; read the following for details:\n//\n//     https://www.securecoding.cert.org/confluence/display/seccode/POS33-C.+Do+not+use+vfork()\n//\n// In spite of these risks, the alternatives (system() or fork()) create resource\n// issues when running conformance test_allocation which stretches the system\n// memory to its limits. Thus we will accept this compromise under the condition\n// that the runtime will soon remove any need to call out to external commands.\n//\n// Note that stdin/stdout/stderr of the command are sent to /dev/null.\n//\nint Os::systemCall(const std::string& command) {\n#if 1\n  size_t len = command.size();\n  char* cmd = new char[len + 1];\n  fastMemcpy(cmd, command.c_str(), len);\n  cmd[len] = 0;\n\n  // Split the command into arguments. This is a very\n  // simple parser that only takes care of quotes and\n  // doesn't support escaping with back-slash. In\n  // the future, Os::systemCall() will either\n  // disappear or it will be replaced with an\n  // argc/argv interface. This parser also assumes\n  // that if an argument is quoted, the whole\n  // argument starts and ends with a double-quote.\n  bool inQuote = false;\n  int argLength = 0;\n  int n = 0;\n  char* cp = cmd;\n  while (*cp) {\n    switch (static_cast<int>(*cp)) {\n      case ' ':\n        if (inQuote) {\n          ++argLength;\n        } else {\n          *cp = '\\0';\n          argLength = 0;\n        }\n        break;\n      case '\"':\n        if (inQuote) {\n          inQuote = false;\n          *cp = '\\0';\n        } else {\n          inQuote = true;\n          *cp = '\\0';\n          argLength = 1;\n          ++n;\n        }\n        break;\n      default:\n        if (++argLength == 1) {\n          ++n;\n        }\n        break;\n    }\n    ++cp;\n  }\n\n  char** argv = new char*[n + 1];\n  int argc = 0;\n  cp = cmd;\n  do {\n    while ('\\0' == *cp) {\n      ++cp;\n    }\n    argv[argc++] = cp;\n    while ('\\0' != *cp) {\n      ++cp;\n    }\n  } while (argc < n);\n  argv[argc] = NULL;\n\n  int ret = -1;\n  pid_t pid = vfork();\n  if (0 == pid) {\n    // Child. Redirect stdin/stdout/stderr to /dev/null\n    int fdIn = open(\"/dev/null\", O_RDONLY);\n    int fdOut = open(\"/dev/null\", O_WRONLY);\n    if (0 <= fdIn || 0 <= fdOut) {\n      dup2(fdIn, 0);\n      dup2(fdOut, 1);\n      dup2(fdOut, 2);\n\n      // Execute the program\n      execvp(argv[0], argv);\n    }\n    _exit(-1);\n  } else if (0 > pid) {\n    // Can't vfork\n  } else {\n    // Parent - wait for program to complete and get exit code.\n    int exitCode;\n    if (0 <= waitpid(pid, &exitCode, 0)) {\n      ret = exitCode;\n    }\n  }\n  delete[] argv;\n  delete[] cmd;\n\n  return ret;\n#else\n  return ::system(command.c_str());\n#endif\n}\n\nstd::string Os::getEnvironment(const std::string& name) {\n  char* dstBuf;\n\n  dstBuf = ::getenv(name.c_str());\n  if (dstBuf == NULL) {\n    return std::string(\"\");\n  }\n  return std::string(dstBuf);\n}\n\nstd::string Os::getTempPath() {\n  std::string tempFolder = amd::Os::getEnvironment(\"TEMP\");\n  if (tempFolder.empty()) {\n    tempFolder = amd::Os::getEnvironment(\"TMP\");\n  }\n\n  if (tempFolder.empty()) {\n    tempFolder = \"/tmp\";\n    ;\n  }\n  return tempFolder;\n}\n\nstd::string Os::getTempFileName() {\n  static std::atomic_size_t counter(0);\n\n  std::string tempPath = getTempPath();\n  std::stringstream tempFileName;\n\n  tempFileName << tempPath << \"/OCL\" << ::getpid() << 'T' << counter++;\n  return tempFileName.str();\n}\n\nint Os::unlink(const std::string& path) { return ::unlink(path.c_str()); }\n\n#if defined(ATI_ARCH_X86)\nvoid Os::cpuid(int regs[4], int info) {\n#ifdef _LP64\n  __asm__ __volatile__(\n      \"movq %%rbx, %%rsi;\"\n      \"cpuid;\"\n      \"xchgq %%rbx, %%rsi;\"\n      : \"=a\"(regs[0]), \"=S\"(regs[1]), \"=c\"(regs[2]), \"=d\"(regs[3])\n      : \"a\"(info));\n#else\n  __asm__ __volatile__(\n      \"movl %%ebx, %%esi;\"\n      \"cpuid;\"\n      \"xchgl %%ebx, %%esi;\"\n      : \"=a\"(regs[0]), \"=S\"(regs[1]), \"=c\"(regs[2]), \"=d\"(regs[3])\n      : \"a\"(info));\n#endif\n}\n\nuint64_t Os::xgetbv(uint32_t ecx) {\n  uint32_t eax, edx;\n\n  __asm__ __volatile__(\".byte 0x0f,0x01,0xd0\"  // in case assembler doesn't recognize xgetbv\n                       : \"=a\"(eax), \"=d\"(edx)\n                       : \"c\"(ecx));\n\n  return ((uint64_t)edx << 32) | (uint64_t)eax;\n}\n#endif  // ATI_ARCH_X86\n\nvoid* Os::fastMemcpy(void* dest, const void* src, size_t n) { return memcpy(dest, src, n); }\n\nuint64_t Os::offsetToEpochNanos() {\n  static uint64_t offset = 0;\n\n  if (offset != 0) {\n    return offset;\n  }\n\n  struct timeval now;\n  if (::gettimeofday(&now, NULL) != 0) {\n    return 0;\n  }\n\n  offset = (now.tv_sec * UINT64_C(1000000) + now.tv_usec) * UINT64_C(1000) - timeNanos();\n\n  return offset;\n}\n\nvoid Os::setCurrentStackPtr(address sp) {\n  sp -= sizeof(void*);\n  *(void**)sp = __builtin_return_address(0);\n\n#if defined(ATI_ARCH_ARM)\n  assert(!\"Unimplemented\");\n#else\n  __asm__ __volatile__(\n#if !defined(OMIT_FRAME_POINTER)\n      LP64_SWITCH(\"movl (%%ebp),%%ebp;\", \"movq (%%rbp),%%rbp;\")\n#endif  // !OMIT_FRAME_POINTER\n          LP64_SWITCH(\"movl %0,%%esp; ret;\", \"movq %0,%%rsp; ret;\")::\"r\"(sp));\n#endif\n}\n\nsize_t Os::getPhysicalMemSize() {\n  struct ::sysinfo si;\n\n  if (::sysinfo(&si) != 0) {\n    return 0;\n  }\n\n  if (si.mem_unit == 0) {\n    // Linux kernels prior to 2.3.23 return sizes in bytes.\n    si.mem_unit = 1;\n  }\n\n  return (size_t)si.totalram * si.mem_unit;\n}\n\nvoid Os::getAppPathAndFileName(std::string& appName, std::string& appPathAndName) {\n  std::unique_ptr<char[]> buff(new char[FILE_PATH_MAX_LENGTH]());\n\n  if (readlink(\"/proc/self/exe\", buff.get(), FILE_PATH_MAX_LENGTH) > 0) {\n    // Get filename without path and extension.\n    appName = std::string(basename(buff.get()));\n    appPathAndName = std::string(buff.get());\n  }\n  else {\n    appName = \"\";\n    appPathAndName = \"\";\n  }\n  return;\n}\n\nbool Os::MemoryUnmapFile(const void* mmap_ptr, size_t mmap_size) {\n  if(munmap(const_cast<void*>(mmap_ptr), mmap_size) != 0) {\n    return false;\n  }\n\n  return true;\n}\n\nbool Os::MemoryMapFile(const char* fname, const void** mmap_ptr, size_t* mmap_size) {\n  if ((mmap_ptr == nullptr) || (mmap_size == nullptr)) {\n    return false;\n  }\n\n  struct stat stat_buf;\n  int fd = open(fname, O_RDONLY);\n  if (fd < 0 ) {\n    return false;\n  }\n\n  if(fstat(fd, &stat_buf) != 0) {\n    close(fd);\n    return false;\n  }\n\n  *mmap_size = stat_buf.st_size;\n  *mmap_ptr = mmap(NULL, stat_buf.st_size, PROT_READ, MAP_SHARED, fd, 0);\n\n  close(fd);\n\n  if (*mmap_ptr == nullptr) {\n    return false;\n  }\n\n  return true;\n}\n\n}  // namespace amd\n\n#endif  // !defined(_WIN32) && !defined(__CYGWIN__)\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.7.0-6twwcw3rjraboiuw75ysfcdddj55uxkg/spack-src/opencl-on-vdi/amdocl/cl_icd.cpp": "/* Copyright (c) 2008-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#include \"cl_common.hpp\"\n#include \"vdi_common.hpp\"\n#ifdef _WIN32\n#include <d3d10_1.h>\n#include \"cl_d3d9_amd.hpp\"\n#include \"cl_d3d10_amd.hpp\"\n#include \"cl_d3d11_amd.hpp\"\n#endif  //_WIN32\n\n#include <icd/loader/icd_dispatch.h>\n\n#include <mutex>\n\namd::PlatformIDS amd::PlatformID::Platform =  //{ NULL };\n    {amd::ICDDispatchedObject::icdVendorDispatch_};\n\nstatic cl_int CL_API_CALL icdGetPlatformInfo(cl_platform_id platform, cl_platform_info param_name,\n                                             size_t param_value_size, void* param_value,\n                                             size_t* param_value_size_ret) {\n  return clGetPlatformInfo(NULL, param_name, param_value_size, param_value, param_value_size_ret);\n}\n\nstatic cl_int CL_API_CALL icdGetDeviceIDs(cl_platform_id platform, cl_device_type device_type,\n                                          cl_uint num_entries, cl_device_id* devices,\n                                          cl_uint* num_devices) {\n  return clGetDeviceIDs(NULL, device_type, num_entries, devices, num_devices);\n}\n\nstatic cl_int CL_API_CALL icdGetDeviceInfo(cl_device_id device, cl_device_info param_name,\n                                           size_t param_value_size, void* param_value,\n                                           size_t* param_value_size_ret) {\n  if (param_name == CL_DEVICE_PLATFORM) {\n    // Return the ICD platform instead of the default NULL platform.\n    cl_platform_id platform = reinterpret_cast<cl_platform_id>(&amd::PlatformID::Platform);\n    return amd::clGetInfo(platform, param_value_size, param_value, param_value_size_ret);\n  }\n\n  return clGetDeviceInfo(device, param_name, param_value_size, param_value, param_value_size_ret);\n}\n\ncl_icd_dispatch amd::ICDDispatchedObject::icdVendorDispatch_[] = {\n    {NULL /* should not get called */, icdGetPlatformInfo, icdGetDeviceIDs, icdGetDeviceInfo,\n     clCreateContext, clCreateContextFromType, clRetainContext, clReleaseContext, clGetContextInfo,\n     clCreateCommandQueue, clRetainCommandQueue, clReleaseCommandQueue, clGetCommandQueueInfo,\n     clSetCommandQueueProperty, clCreateBuffer, clCreateImage2D, clCreateImage3D, clRetainMemObject,\n     clReleaseMemObject, clGetSupportedImageFormats, clGetMemObjectInfo, clGetImageInfo,\n     clCreateSampler, clRetainSampler, clReleaseSampler, clGetSamplerInfo,\n     clCreateProgramWithSource, clCreateProgramWithBinary, clRetainProgram, clReleaseProgram,\n     clBuildProgram, clUnloadCompiler, clGetProgramInfo, clGetProgramBuildInfo, clCreateKernel,\n     clCreateKernelsInProgram, clRetainKernel, clReleaseKernel, clSetKernelArg, clGetKernelInfo,\n     clGetKernelWorkGroupInfo, clWaitForEvents, clGetEventInfo, clRetainEvent, clReleaseEvent,\n     clGetEventProfilingInfo, clFlush, clFinish, clEnqueueReadBuffer, clEnqueueWriteBuffer,\n     clEnqueueCopyBuffer, clEnqueueReadImage, clEnqueueWriteImage, clEnqueueCopyImage,\n     clEnqueueCopyImageToBuffer, clEnqueueCopyBufferToImage, clEnqueueMapBuffer, clEnqueueMapImage,\n     clEnqueueUnmapMemObject, clEnqueueNDRangeKernel, clEnqueueTask, clEnqueueNativeKernel,\n     clEnqueueMarker, clEnqueueWaitForEvents, clEnqueueBarrier, clGetExtensionFunctionAddress,\n     clCreateFromGLBuffer, clCreateFromGLTexture2D, clCreateFromGLTexture3D,\n     clCreateFromGLRenderbuffer, clGetGLObjectInfo, clGetGLTextureInfo, clEnqueueAcquireGLObjects,\n     clEnqueueReleaseGLObjects, clGetGLContextInfoKHR,\n     WINDOWS_SWITCH(clGetDeviceIDsFromD3D10KHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10BufferKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10Texture2DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10Texture3DKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueAcquireD3D10ObjectsKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueReleaseD3D10ObjectsKHR, NULL), clSetEventCallback, clCreateSubBuffer,\n     clSetMemObjectDestructorCallback, clCreateUserEvent, clSetUserEventStatus,\n     clEnqueueReadBufferRect, clEnqueueWriteBufferRect, clEnqueueCopyBufferRect,\n     NULL, NULL, NULL, clCreateEventFromGLsyncKHR,\n\n     /* OpenCL 1.2*/\n     clCreateSubDevices, clRetainDevice, clReleaseDevice, clCreateImage,\n     clCreateProgramWithBuiltInKernels, clCompileProgram, clLinkProgram, clUnloadPlatformCompiler,\n     clGetKernelArgInfo, clEnqueueFillBuffer, clEnqueueFillImage, clEnqueueMigrateMemObjects,\n     clEnqueueMarkerWithWaitList, clEnqueueBarrierWithWaitList,\n     clGetExtensionFunctionAddressForPlatform, clCreateFromGLTexture,\n\n     WINDOWS_SWITCH(clGetDeviceIDsFromD3D11KHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11BufferKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11Texture2DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11Texture3DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromDX9MediaSurfaceKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueAcquireD3D11ObjectsKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueReleaseD3D11ObjectsKHR, NULL),\n\n     WINDOWS_SWITCH(clGetDeviceIDsFromDX9MediaAdapterKHR,\n                    NULL),  // KHRpfn_clGetDeviceIDsFromDX9MediaAdapterKHR\n                            // clGetDeviceIDsFromDX9MediaAdapterKHR;\n     WINDOWS_SWITCH(\n         clEnqueueAcquireDX9MediaSurfacesKHR,\n         NULL),  // KHRpfn_clEnqueueAcquireDX9MediaSurfacesKHR clEnqueueAcquireDX9MediaSurfacesKHR;\n     WINDOWS_SWITCH(\n         clEnqueueReleaseDX9MediaSurfacesKHR,\n         NULL),  // KHRpfn_clEnqueueReleaseDX9MediaSurfacesKHR clEnqueueReleaseDX9MediaSurfacesKHR;\n\n     NULL,\n     NULL, NULL, NULL,\n\n     clCreateCommandQueueWithProperties, clCreatePipe, clGetPipeInfo, clSVMAlloc, clSVMFree,\n     clEnqueueSVMFree, clEnqueueSVMMemcpy, clEnqueueSVMMemFill, clEnqueueSVMMap, clEnqueueSVMUnmap,\n     clCreateSamplerWithProperties, clSetKernelArgSVMPointer, clSetKernelExecInfo,\n     clGetKernelSubGroupInfo,\n     clCloneKernel,\n     clCreateProgramWithIL,\n     clEnqueueSVMMigrateMem,\n     clGetDeviceAndHostTimer,\n     clGetHostTimer,\n     clGetKernelSubGroupInfo,\n     clSetDefaultDeviceCommandQueue,\n\n     clSetProgramReleaseCallback,\n     clSetProgramSpecializationConstant }};\n\n#if defined(ATI_OS_WIN)\n#include <Shlwapi.h>\n\n#pragma comment(lib, \"shlwapi.lib\")\n\nstatic bool ShouldLoadPlatform() {\n  // Get the OpenCL ICD registry values\n  HKEY platformsKey = NULL;\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Khronos\\\\OpenCL\\\\Vendors\", 0, KEY_READ,\n                    &platformsKey) != ERROR_SUCCESS)\n    return true;\n\n  std::vector<std::string> registryValues;\n  DWORD dwIndex = 0;\n  while (true) {\n    char cszLibraryName[1024] = {0};\n    DWORD dwLibraryNameSize = sizeof(cszLibraryName);\n    DWORD dwLibraryNameType = 0;\n    DWORD dwValue = 0;\n    DWORD dwValueSize = sizeof(dwValue);\n\n    if (RegEnumValueA(platformsKey, dwIndex++, cszLibraryName, &dwLibraryNameSize, NULL,\n                      &dwLibraryNameType, (LPBYTE)&dwValue, &dwValueSize) != ERROR_SUCCESS)\n      break;\n    // Require that the value be a DWORD and equal zero\n    if (dwLibraryNameType != REG_DWORD || dwValue != 0) {\n      continue;\n    }\n    registryValues.push_back(cszLibraryName);\n  }\n  RegCloseKey(platformsKey);\n\n  HMODULE hm = NULL;\n  if (!GetModuleHandleExA(\n          GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n          (LPCSTR)&ShouldLoadPlatform, &hm))\n    return true;\n\n  char cszDllPath[1024] = {0};\n  if (!GetModuleFileNameA(hm, cszDllPath, sizeof(cszDllPath))) return true;\n\n  // If we are loaded from the DriverStore, then there should be a registry\n  // value matching our current module absolute path.\n  if (std::find(registryValues.begin(), registryValues.end(), cszDllPath) == registryValues.end())\n    return true;\n\n  LPSTR cszFileName;\n  char buffer[1024] = {0};\n  if (!GetFullPathNameA(cszDllPath, sizeof(buffer), buffer, &cszFileName)) return true;\n\n  // We found an absolute path in the registry that matched this DLL, now\n  // check if there is also an entry with the same filename.\n  if (std::find(registryValues.begin(), registryValues.end(), cszFileName) == registryValues.end())\n    return true;\n\n  // Lastly, check if there is a DLL with the same name in the System folder.\n  char cszSystemPath[1024] = {0};\n#if defined(ATI_BITS_32)\n  if (!GetSystemWow64DirectoryA(cszSystemPath, sizeof(cszSystemPath)))\n#endif  // defined(ATI_BITS_32)\n    if (!GetSystemDirectoryA(cszSystemPath, sizeof(cszSystemPath))) return true;\n\n  std::string systemDllPath;\n  systemDllPath.append(cszSystemPath).append(\"\\\\\").append(cszFileName);\n  if (!PathFileExistsA(systemDllPath.c_str())) {\n    return true;\n  }\n\n  // If we get here, then all 3 conditions are true:\n  // - An entry in the registry with an absolute path matches the current DLL\n  // - An entry in the registry with a relative path matches the current DLL\n  // - A DLL with the same name was found in the system directory\n  //\n  // We should not load this platform!\n\n  return false;\n}\n\n#else\n\n#include <dlfcn.h>\n\n// If there is only one platform, load it.\n// If there is more than one platform, only load platforms that have visible devices\n// If all platforms have no devices available, only load the PAL platform\nstatic bool ShouldLoadPlatform() {\n  bool shouldLoad = true;\n\n  if (!amd::Runtime::initialized()) {\n    amd::Runtime::init();\n  }\n  const int numDevices = amd::Device::numDevices(CL_DEVICE_TYPE_GPU, false);\n\n  void *otherPlatform = nullptr;\n  if (amd::IS_LEGACY) {\n    otherPlatform = dlopen(\"libamdocl64.so\", RTLD_LAZY);\n    if (otherPlatform != nullptr) { // Present platform exists\n      shouldLoad = numDevices > 0;\n    }\n  } else {\n    otherPlatform = dlopen(\"libamdocl-orca64.so\", RTLD_LAZY);\n    if (otherPlatform != nullptr) { // Legacy platform exists\n      // gcc4.8 doesn't support casting void* to a function pointer\n      // Work around this by creating a typedef untill we upgrade the compiler\n      typedef void*(*clGetFunctionAddress_t)(const char *);\n      typedef cl_int(*clIcdGetPlatformIDs_t)(cl_uint, cl_platform_id *, cl_uint *);\n\n      clGetFunctionAddress_t legacyGetFunctionAddress =\n        reinterpret_cast<clGetFunctionAddress_t>(dlsym(otherPlatform, \"clGetExtensionFunctionAddress\"));\n      clIcdGetPlatformIDs_t legacyGetPlatformIDs =\n        reinterpret_cast<clIcdGetPlatformIDs_t>(legacyGetFunctionAddress(\"clIcdGetPlatformIDsKHR\"));\n\n      cl_uint numLegacyPlatforms = 0;\n      legacyGetPlatformIDs(0, nullptr, &numLegacyPlatforms);\n\n      shouldLoad = (numDevices > 0) || (numLegacyPlatforms == 0);\n    }\n  }\n\n  if (otherPlatform != nullptr) {\n    dlclose(otherPlatform);\n  }\n\n  return shouldLoad;\n}\n\n#endif // defined(ATI_OS_WIN)\n\nCL_API_ENTRY cl_int CL_API_CALL clIcdGetPlatformIDsKHR(cl_uint num_entries,\n                                                       cl_platform_id* platforms,\n                                                       cl_uint* num_platforms) {\n  if (((num_entries > 0 || num_platforms == NULL) && platforms == NULL) ||\n      (num_entries == 0 && platforms != NULL)) {\n    return CL_INVALID_VALUE;\n  }\n\n  static bool shouldLoad = true;\n\n  static std::once_flag initOnce;\n  std::call_once(initOnce, [](){ shouldLoad = ShouldLoadPlatform(); });\n\n  if (!shouldLoad) {\n    *not_null(num_platforms) = 0;\n    return CL_SUCCESS;\n  }\n\n  if (!amd::Runtime::initialized()) {\n    amd::Runtime::init();\n  }\n\n  if (num_platforms != NULL && platforms == NULL) {\n    *num_platforms = 1;\n    return CL_SUCCESS;\n  }\n\n  assert(platforms != NULL && \"check the code above\");\n  *platforms = reinterpret_cast<cl_platform_id>(&amd::PlatformID::Platform);\n\n  *not_null(num_platforms) = 1;\n  return CL_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.7.0-6twwcw3rjraboiuw75ysfcdddj55uxkg/spack-src/opencl-on-vdi/tests/ocltst/env/ocltst.cpp": "/* Copyright (c) 2010-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n/////////////////////////////////////////////////////////////////////////////\n\n#include <CL/cl.h>\n\n#ifdef ATI_OS_WIN\n#include <windows.h>\n\n#include \"Window.h\"\ntypedef HMODULE ModuleHandle;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n\n#ifdef ATI_OS_LINUX\n#include <dlfcn.h>\ntypedef void* ModuleHandle;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n\n#include \"BaseTestImp.h\"\n#include \"Module.h\"\n#include \"OCLLog.h\"\n#include \"OCLTest.h\"\n#include \"OCLTestImp.h\"\n#include \"OCLTestList.h\"\n#include \"OCLWrapper.h\"\n#include \"Timer.h\"\n#include \"Worker.h\"\n#include \"getopt.h\"\n#include \"oclsysinfo.h\"\n#include \"pfm.h\"\n\n//! Including OCLutilities Thread utility\n#include \"OCL/Thread.h\"\n\n//! Lock that needs to be obtained to access the global\n//! module variable\nstatic OCLutil::Lock moduleLock;\n\n#include <assert.h>\n#include <stdio.h>\n\n#include <algorithm>\n#include <memory>\n#include <string>\n#include <vector>\n\n/////////////////////////////////////////////////////////////////////////////\n\n#ifdef ATI_OS_WIN\nstatic LONG WINAPI xFilter(LPEXCEPTION_POINTERS xEP);\nvoid serviceStubCall();\n#endif\n\n#define MAX_DEVICES 16\n#undef CHECK_RESULT\n#define CHECK_RESULT(test, msg) \\\n  if ((test)) {                 \\\n    printf(\"\\n%s\\n\", msg);      \\\n    exit(1);                    \\\n  }\n\n//! Declaration of a function that find devices of a specific type for the\n//! chosen platform\nint findAdapters(unsigned int platformIdx, bool useCPU, cl_platform_id*);\n\n//! class App that is used to run the tests on the system\nclass App {\n public:\n  static bool m_reRunFailed;\n  static bool m_svcMsg;\n  //! Constructor for App\n  App(unsigned int platform)\n      : m_list(false),\n        m_console(true),\n        m_useCPU(false),\n        m_dump(false),\n        m_perflab(false),\n        m_noSysInfoPrint(false),\n        m_numItr(1),\n        mp_testOrder(NULL),\n        m_rndOrder(false),\n        m_spawned(0),\n        m_threads(1),\n        m_runthread(0),\n        m_width(512),\n        m_height(512),\n        m_window(0),\n        m_platform(platform) {\n    // initialize OCLWrapper reference\n    m_wrapper = new OCLWrapper();\n\n    // m_workers = Set of worker objects that are used to run a subtest from a\n    // module\n    for (unsigned int i = 0; i < 256; i++) m_workers[i] = 0;\n\n    // Setting the number of devices\n    /*\n     * Force caltst to use 1 thread at a time in Windows\n     * only contextual calls are thread safe currently\n     */\n    m_numDevices = findAdapters(m_platform, m_useCPU, NULL);\n    // m_numDevices = 1;\n\n    // Report structure used to store the results of the tests\n#if 0\n            testReport = (Report **)malloc(sizeof(Report *) * m_numDevices);\n            for(unsigned int i = 0; i < m_numDevices; i++)\n            {\n                testReport[i] = new Report;\n            }\n#else\n    testReport = (Report**)malloc(sizeof(Report*));\n    testReport[0] = new Report;\n#endif\n  }\n\n  //! Destructor for App\n  ~App() {\n    // Deleting the Worker objects\n    for (unsigned int i = 0; i < 256; i++) {\n      if (m_workers[i]) {\n        delete m_workers[i];\n        m_workers[i] = 0;\n      }\n    }\n\n    // Deleting the report structures\n    // for(unsigned int i = 0; i < m_numDevices; i++)\n    for (unsigned int i = 0; i < 1; i++) {\n      delete testReport[i];\n    }\n    free(testReport);\n    m_wrapper->clUnloadPlatformAMD(mpform_id);\n\n    delete m_wrapper;\n  }\n\n  //! Function used to create a worker object corresponding to a subtest in a\n  //! module\n  void SetWorker(unsigned int index, OCLWrapper* wrapper, Module* module,\n                 TestMethod run, unsigned int id, unsigned int subtest,\n                 unsigned int test, bool dump, bool view, bool useCPU,\n                 void* window, unsigned int x, unsigned int y, bool perflab,\n                 unsigned int deviceId, unsigned int platform) {\n    if (index >= 256) return;\n\n    if (m_workers[index]) delete m_workers[index];\n\n    m_workers[index] =\n        new Worker(wrapper, module, run, id, subtest, test, dump, view, useCPU,\n                   window, x, y, perflab, deviceId, platform);\n\n    assert(m_workers[index] != 0);\n    // oclTestLog(OCLTEST_LOG_ALWAYS, \"Worker Device Id = %d\\n\",\n    // m_workers[index]->getDeviceId());\n  }\n\n  //! Function to return the 'index'th m_workers\n  Worker* GetWorker(unsigned int index) {\n    if (index >= 256) return 0;\n\n    return m_workers[index];\n  }\n\n  //! Create a thread to run the subtest\n  void AddThread(unsigned int workerindex, unsigned int usage) {\n    Worker* worker = GetWorker(workerindex);\n    if (worker == 0) {\n      return;\n    }\n\n    // usage = Whether to use threads or not\n    if (usage != 0) {\n      // Creating a thread\n      // getTestMethod = runSubTest here\n      // which takes a Worker object as an argument\n      m_pool[workerindex].create(worker->getTestMethod(), (void*)(worker));\n      m_spawned++;\n    } else {\n      // Same as above without using threads\n      TestMethod run = worker->getTestMethod();\n      if (run) {\n        run(worker);\n        UpdateTestReport(workerindex, worker->getResult());\n      }\n    }\n    return;\n  }\n\n  //! Function which waits for all threads to execute and also updates the\n  //! report\n  void WaitAllThreads() {\n    for (unsigned int w = 0; w < m_spawned; w++) {\n      m_pool[w].join();\n      UpdateTestReport(w, m_workers[w]->getResult());\n    }\n    m_spawned = 0;\n  }\n\n  //! Function to add a worker thread so as to run a subtest of a module\n  //! @param run = runSubtest function\n  //! @param index = index of the module in m_modules\n  //! @param subtest = the subtest number to run\n  //! @param usage = whether to use threads or not\n  //! @param test = The test in the module to be executed\n  void AddWorkerThread(unsigned int index, unsigned int subtest,\n                       unsigned int test, unsigned int usage, TestMethod run) {\n    if (m_spawned > m_threads) {\n      WaitAllThreads();\n    }\n\n    // Creating a worker thread for each device\n#if 0\n            for(unsigned int i = 0; i < m_numDevices; i++)\n            {\n                SetWorker(i,\n                          m_wrapper,\n                          &m_modules[index],\n                          run,\n                          m_spawned,\n                          subtest,\n                          test,\n                          m_dump,\n                          !m_console,\n                          m_useCPU,\n                          m_window,\n                          m_width,\n                          m_height,\n                          m_perflab,\n                          i,\n                          m_platform);            \n            }\n#else\n    for (unsigned int i = 0; i < 1; i++) {\n      SetWorker(i, m_wrapper, &m_modules[index], run, m_spawned, subtest, test,\n                m_dump, !m_console, m_useCPU, m_window, m_width, m_height,\n                m_perflab, m_deviceId, m_platform);\n    }\n#endif\n\n    // Creating and executing a thread for each device\n    // for(unsigned int i = 0; i < m_numDevices; i++)\n    for (unsigned int i = 0; i < 1; i++) {\n      AddThread(i, usage);\n    }\n  }\n\n  void printOCLinfo(void);\n\n  //! Function to process the commandline arguments\n  void CommandLine(unsigned int argc, char** argv);\n\n  //! Function to scan for the different tests in the module\n  void ScanForTests();\n\n  //! Function to run all the specified tests\n  void RunAllTests();\n\n  //! Free memory\n  void CleanUp();\n\n  //! Function to set the order in which test are executed.\n  void SetTestRunOrder(int);\n\n  //! Function to print the test order\n  void PrintTestOrder(int);\n\n  //! Function to get the number of iterations.\n  int GetNumItr(void) { return m_numItr; }\n\n private:\n  typedef std::vector<unsigned int> TestIndexList;\n  typedef std::vector<std::string> StringList;\n\n  void AddToList(StringList& strlist, const char* str);\n  void LoadList(StringList& strlist, const char* filename);\n\n  bool TestInList(StringList& strlist, const char* testname);\n\n  //! Array storing the report for each device\n  Report** testReport;\n\n  //! Function to update the result of each device\n  void UpdateTestReport(int index, TestResult* result) {\n    if (result != NULL) {\n      if (result->passed) {\n        if (testReport[index]->max->value < result->value) {\n          testReport[index]->max->value = result->value;\n          testReport[index]->max->resultString = result->resultString;\n        }\n        if (testReport[index]->min->value > result->value) {\n          testReport[index]->min->value = result->value;\n          testReport[index]->min->resultString = result->resultString;\n        }\n      } else {\n        testReport[index]->numFailedTests++;\n        testReport[index]->success = false;\n      }\n    } else {\n      testReport[index]->numFailedTests++;\n      testReport[index]->success = false;\n    }\n  }\n\n  //! Functions used to find the range of the tests to be run\n  void GetTestIndexList(TestIndexList& testIndices, StringList& testList,\n                        const char* szModuleTestname, int maxIndex);\n  void PruneTestIndexList(TestIndexList& testIndices,\n                          TestIndexList& avoidIndices,\n                          TestIndexList& erasedIndices);\n\n  StringList m_paths;\n  StringList m_tests;\n  StringList m_avoid;\n  std::vector<Module> m_modules;\n  bool m_list;\n  bool m_console;\n  bool m_useCPU;\n  bool m_dump;\n  bool m_perflab;\n  bool m_noSysInfoPrint;\n  int m_numItr;\n  int* mp_testOrder;\n  bool m_rndOrder;\n\n  //! m_pool = Various threads created to execute tests on multiple devices\n  OCLutil::Thread m_pool[256];\n\n  Worker* m_workers[256];\n\n  //! Number of threads spawned\n  unsigned int m_spawned;\n\n  //! Upper limit on the number of threads that can be spawned\n  unsigned int m_threads;\n  unsigned int m_runthread;\n  unsigned int m_width;\n  unsigned int m_height;\n  void* m_window;\n\n  //! which index/platform id from the platforms vector returned by\n  //! cl::Platform::get we should run on\n  unsigned int m_platform;\n  cl_platform_id mpform_id;\n\n  //! Number of devices on the system\n  unsigned int m_numDevices;\n  //\n  //! Device ID to use on the system\n  unsigned int m_deviceId;\n\n  // OCLWrapper reference\n  OCLWrapper* m_wrapper;\n};\n\nvoid App::printOCLinfo(void) {\n  std::string calinfo;\n  if (!m_noSysInfoPrint) {\n    oclSysInfo(calinfo, m_useCPU, m_deviceId, m_platform);\n    oclTestLog(OCLTEST_LOG_ALWAYS, calinfo.c_str());\n  }\n}\n\n/*-----------------------------------------------------\nFunction to randomize the order in which tests are executed\n-------------------------------------------------------*/\n#ifdef ATI_OS_WIN\n#include <time.h>\n#endif\n// void App::SetTestRunOrder(int test_count)\nvoid App::SetTestRunOrder(int mod_index) {\n  assert(mp_testOrder != NULL);\n  unsigned int test_count = m_modules[mod_index].get_count();\n\n  StringList uniqueTests;\n  for (unsigned int i = 0; i < m_tests.size(); ++i) {\n    // see if the tests are being run using indices\n    size_t nFirstBracket = m_tests[i].find(\"[\");\n    // set the test name\n    std::string szTestName = m_tests[i];\n\n    // order of execution is set based on base name so get the base name\n    if (nFirstBracket != std::string::npos)\n      szTestName = szTestName.substr(0, nFirstBracket);\n\n    bool bTestExists = false;\n    for (unsigned int j = 0; j < uniqueTests.size(); ++j) {\n      if (strcmp(szTestName.c_str(), uniqueTests[j].c_str()) == 0) {\n        bTestExists = true;\n        break;\n      }\n    }\n\n    if (!bTestExists) {\n      AddToList(uniqueTests, szTestName.c_str());\n    }\n  }\n\n  for (unsigned int i = 0; i < test_count && i < uniqueTests.size(); i++) {\n    for (unsigned int j = 0; j < test_count; j++) {\n      unsigned int index = i;\n      // add all the prev test indices\n      for (int k = 0; k < mod_index; k++) index += m_modules[k].get_count();\n\n      std::string szTestName = uniqueTests[index];\n\n      if (strcmp(szTestName.c_str(), m_modules[mod_index].get_name(j)) == 0) {\n        mp_testOrder[i] = j;\n        break;\n      }\n    }\n  }\n\n  if (m_rndOrder) {\n    srand((unsigned int)time(NULL));\n    for (unsigned int i = 0; i < test_count; i++) {\n      // find two random indices\n      int index1 = (int)((float)test_count * (rand() / (RAND_MAX + 1.0)));\n      int index2 = (int)((float)test_count * (rand() / (RAND_MAX + 1.0)));\n      // swap the data\n      int tmp = mp_testOrder[index1];\n      mp_testOrder[index1] = mp_testOrder[index2];\n      mp_testOrder[index2] = tmp;\n    }\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\n// Process device string. Returns true if there is a primary ATI Radeon device\n// adapter, false otherwise\nstatic bool procDevString(const char* devString) {\n  // Search for the string \"Radeon\" inside the device string\n  if (strstr(devString, \"Radeon\") || strstr(devString, \"R600\") ||\n      strstr(devString, \"RV630\") || strstr(devString, \"RV670\") ||\n      (strstr(devString, \"Stream\") && strstr(devString, \"Processor\"))) {\n    // Ignore if the device is a secondary device, i.e., not an adapter\n    if (strstr(devString, \"Secondary\")) {\n      return false;\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n}\n\n//!\n//! Function to find the total number of adapters on the system\n//!\nint findAdapters(unsigned int platformIdx, bool useCPU,\n                 cl_platform_id* mpform) {\n  unsigned int numOfAdapters = 0;\n  cl_int error = 0;\n  cl_uint numPlatforms = 0;\n\n  error = clGetPlatformIDs(0, NULL, &numPlatforms);\n  CHECK_RESULT((error != CL_SUCCESS), \"clGetPlatformIDs failed\");\n\n  CHECK_RESULT((platformIdx >= numPlatforms), \"Invalid platform\");\n\n  cl_platform_id* platforms = new cl_platform_id[numPlatforms];\n  error = clGetPlatformIDs(numPlatforms, platforms, NULL);\n  CHECK_RESULT(error != CL_SUCCESS, \"clGetPlatformIDs failed\");\n\n  cl_platform_id platform = 0;\n\n  platform = platforms[platformIdx];\n\n  delete[] platforms;\n\n  cl_device_type devType = CL_DEVICE_TYPE_GPU;\n  if (useCPU) devType = CL_DEVICE_TYPE_CPU;\n  error = clGetDeviceIDs(platform, devType, 0, 0, &numOfAdapters);\n  CHECK_RESULT((error != CL_SUCCESS), \"clGetDeviceIDs failed\");\n  if (mpform) {\n    (*mpform) = platform;\n  }\n\n  return (int)numOfAdapters;\n}\n\nint calibrate(OCLTest* test) {\n  int n = 1;\n\n#if 0\n    while (1)\n    {\n        double timer = run(test, n);\n        if (timer > 2.)\n        {\n            break;\n        }\n        n *= 2;\n    }\n#endif\n\n  return n;\n}\n\nvoid* dummyThread(void* argv) {\n  unsigned int counter = 0;\n  while (counter < 1000000) counter++;\n\n  return argv;\n}\n\n//! Function used to run the test specified\n//! It would look something like OCLPerfInputspeed[0]\ndouble run(OCLTest* test, int passes) {\n  CPerfCounter counter;\n\n  counter.Reset();\n  counter.Start();\n  int i;\n  for (i = 0; i < passes; i++) {\n    test->run();\n  }\n  counter.Stop();\n  double timer = counter.GetElapsedTime();\n  counter.Reset();\n\n  return timer;\n}\n\n//! Function to display the result after a test is finished\n//! It also stores the result in a TestResult object\nvoid report(Worker* w, const char* testname, int testnum, unsigned int crc,\n            const char* errorMsg, float timer, TestResult* tr,\n            const char* testDesc) {\n  unsigned int thread = w->getId();\n  bool perflab = w->getPerflab();\n  unsigned int deviceId = w->getDeviceId();\n\n  char tmpUnits[256];\n  if (perflab) {\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"%10.3f\\n\", timer);\n  } else {\n    const char* passedOrFailed[] = {\"FAILED\", \"PASSED\"};\n\n    // char teststring[256];\n    // sprintf(teststring, \"%s[%d]\", testname, testnum);\n    // sprintf(tmpUnits, \"Device[%d]:\\t%-32s:\\t%s\\n\", deviceId, teststring,\n    // ((tr->passed) ? passedOrFailed[1] : passedOrFailed[0]));\n    // If crc is not 0 or errorMsg is not empty, print the full stats\n    if ((crc != 0) || (errorMsg && (errorMsg[0] != '\\0'))) {\n      sprintf(tmpUnits,\n              \"%s %s: %s[%d] T[%1d] [%3d], %10.3f %-20s (chksum 0x%08x)\\n\",\n              testDesc, ((tr->passed) ? passedOrFailed[1] : passedOrFailed[0]),\n              w->isCPUEnabled() ? \"CPU\" : \"GPU\", deviceId, thread, testnum,\n              timer, errorMsg, crc);\n    } else {\n      sprintf(tmpUnits, \"%s %s: %s[%d] T[%1d] [%3d], %10.3f\\n\", testDesc,\n              ((tr->passed) ? passedOrFailed[1] : passedOrFailed[0]),\n              w->isCPUEnabled() ? \"CPU\" : \"GPU\", deviceId, thread, testnum,\n              timer);\n    }\n\n    oclTestLog(OCLTEST_LOG_ALWAYS, tmpUnits);\n\n    tr->value = timer;\n    tr->resultString.assign(tmpUnits);\n\n    if (App::m_svcMsg && !tr->passed) {\n      char escaped[2 * sizeof(tmpUnits)];\n\n      char* ptr = escaped;\n      for (int i = 0; tmpUnits[i] != '\\0'; ++i) {\n        switch (tmpUnits[i]) {\n          case '\\n':\n            *ptr++ = '|';\n            *ptr++ = 'n';\n            break;\n          case '\\r':\n            *ptr++ = '|';\n            *ptr++ = 'r';\n            break;\n          case '\\'':\n          case '|':\n          case ']':\n          case '[':\n            *ptr++ = '|';\n          default:\n            *ptr++ = tmpUnits[i];\n        }\n      }\n      *ptr = '\\0';\n\n      oclTestLog(OCLTEST_LOG_ALWAYS,\n                 \"##teamcity[testFailed name='%s.%s.%d' message='FAILED' \"\n                 \"details='%s']\\n\",\n                 w->getModule()->get_libname(), testname, testnum, escaped);\n    }\n  }\n}\n\n//! Thread Entry point\nvoid* runSubtest(void* worker) {\n  char units[256];\n  double conversion;\n  unsigned int crc = 0;\n  bool second_run = false;\n\n  // Getting the worker object that is running in this thread\n  Worker* w = (Worker*)worker;\n\n  if (w == 0) return NULL;\n\n  unsigned int test = w->getTestIndex();\n  unsigned int subtest = w->getSubTest();\n  unsigned int deviceId = w->getDeviceId();\n  unsigned int platformIndex = w->getPlatformID();\n  TestResult* result = w->getResult();\n\nRERUN_TEST:\n  // Acquiring lock on the 'module' object common to all threads\n  moduleLock.lock();\n  Module* m = w->getModule();\n  if (m == 0 || m->create_test == 0) return NULL;\n  // If we can, used the cached version,\n  // otherwise create the test.\n  OCLTest* pt = (m->cached_test ? m->cached_test[subtest] : NULL);\n  if (!pt) {\n    pt = m->create_test(subtest);\n    if (pt->cache_test() && m->cached_test) {\n      m->cached_test[subtest] = pt;\n    }\n  }\n  pt->clearError();\n  OCLTestImp* tmp = pt->toOCLTestImp();\n  if (tmp) {\n    tmp->setOCLWrapper(w->getOCLWrapper());\n  }\n  std::string subtestName = m->get_name(subtest);\n  moduleLock.unlock();\n\n  if (pt == 0) return NULL;\n\n  pt->resetDescString();\n  if (App::m_svcMsg) {\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"##teamcity[testStarted name='%s.%s.%d' \"\n               \"captureStandardOutput='true']\\n\",\n               m->get_libname(), subtestName.c_str(), test);\n  }\n  // setting the type to CPU.\n  if (w->isCPUEnabled()) {\n    pt->useCPU();\n  }\n  // Setting the device according to the worker thread\n  pt->setDeviceId(w->getDeviceId());\n  pt->setPlatformIndex(w->getPlatformID());\n  // Opening the 'test'th subtest of 'pt'\n  pt->open(test, units, conversion, deviceId);\n  pt->clearPerfInfo();\n\n  char buffer[256];\n  sprintf(buffer, \"%s[%3d]\", subtestName.c_str(), test);\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"%-32s\", buffer);\n\n  if (pt->hasErrorOccured()) {\n    result->passed = false;\n    report(w, subtestName.c_str(), test, crc, pt->getErrorMsg(),\n           pt->getPerfInfo(), result, pt->testDescString.c_str());\n  } else {\n    unsigned int n = calibrate(pt);\n    double timer = run(pt, n);\n    crc = pt->close();\n\n    if (pt->hasErrorOccured()) {\n      // run second time if the test fails the first time.\n      if (!second_run && App::m_reRunFailed && !App::m_svcMsg) {\n        second_run = true;\n\n        // Destroying a test object\n        moduleLock.lock();\n        if (!pt->cache_test()) {\n          m->destroy_test(pt);\n        }\n        moduleLock.unlock();\n\n        pt->clearError();\n        goto RERUN_TEST;\n      }\n    }\n    result->passed = !pt->hasErrorOccured();\n    /// print conditional pass if it is passes the second time.\n    if (second_run && result->passed) {\n      report(w, subtestName.c_str(), test, crc, \"Conditional PASS\",\n             pt->getPerfInfo(), result, pt->testDescString.c_str());\n    } else {\n      report(w, subtestName.c_str(), test, crc, pt->getErrorMsg(),\n             pt->getPerfInfo(), result, pt->testDescString.c_str());\n    }\n  }\n  if (App::m_svcMsg) {\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"##teamcity[testFinished name='%s.%s.%d']\\n\",\n               m->get_libname(), subtestName.c_str(), test);\n  }\n\n  // Make sure we clear the error after we report that there was an error.\n  pt->clearError();\n\n  // Destroying a test object\n  moduleLock.lock();\n  if (!pt->cache_test()) {\n    m->destroy_test(pt);\n  }\n  moduleLock.unlock();\n  return NULL;\n}\n\nvoid App::PrintTestOrder(int mod_index) {\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"Module: %s (%d tests)\\n\",\n             m_modules[mod_index].name.c_str(),\n             m_modules[mod_index].get_count());\n\n  for (unsigned int j = 0; j < m_modules[mod_index].get_count(); j++) {\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"%s\\n\",\n               m_modules[mod_index].get_name(mp_testOrder[j]));\n  }\n}\n\n//! Function that runs all the tests specified in the command-line\nvoid App::RunAllTests() {\n#ifdef ATI_OS_WIN\n\n  if (!m_console) m_window = new Window(\"Test\", 100, 100, m_width, m_height, 0);\n#endif\n\n  //\n  //  Add all tests to run list if none specified\n  //\n  if (m_tests.size() < 1) {\n    for (unsigned int i = 0; i < m_modules.size(); i++) {\n      for (unsigned int j = 0; j < m_modules[i].get_count(); j++) {\n        AddToList(m_tests, m_modules[i].get_name(j));\n      }\n    }\n  }\n\n  unsigned int num_passes = 0;\n  unsigned int num_failures = 0;\n\n  if (App::m_svcMsg) {\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"##teamcity[testSuiteStarted name='ocltst']\\n\");\n  }\n\n  //\n  //  Run each test\n  //\n  for (unsigned int i = 0; i < m_modules.size(); i++) {\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"\\n-------------------------------------------------\\n\");\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"The OpenCL Testing Module %s Version = %d \\n\",\n               m_modules[i].get_libname(), m_modules[i].get_version());\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"------------------------------\\n\");\n\n    // array to keep track of order of test execution.\n    int test_count = m_modules[i].get_count();\n    mp_testOrder = new int[test_count];\n    memset((void*)mp_testOrder, 0, sizeof(*mp_testOrder) * test_count);\n    SetTestRunOrder(i);\n\n    //\n    //  List all tests first if the option was turned on\n    //\n    if (m_list) {\n      PrintTestOrder(i);\n      delete[] mp_testOrder;\n      continue;\n      // return;\n    }\n\n    for (unsigned int itr_var = 0; itr_var < m_modules[i].get_count();\n         itr_var++) {\n      // done for random order generation\n      unsigned int subtest = mp_testOrder[itr_var];\n\n      const char* name = m_modules[i].get_name(subtest);\n      if (itr_var < m_tests.size() && TestInList(m_tests, name)) {\n        OCLTest* pt = NULL;\n        if (m_modules[i].cached_test) {\n          pt = m_modules[i].cached_test[subtest];\n        }\n        // Try to use the cached version first!\n        if (!pt) {\n          pt = m_modules[i].create_test(subtest);\n          if (pt->cache_test() && m_modules[i].cached_test) {\n            m_modules[i].cached_test[subtest] = pt;\n          }\n        }\n\n        int numSubTests = pt->getNumSubTests();\n        assert(numSubTests > 0);\n\n        TestIndexList testIndices;\n        GetTestIndexList(testIndices, m_tests, name, numSubTests - 1);\n\n        TestIndexList avoidIndices;\n        GetTestIndexList(avoidIndices, m_avoid, name, numSubTests - 1);\n\n        TestIndexList erasedIndices;\n        PruneTestIndexList(testIndices, avoidIndices, erasedIndices);\n\n        int numTestsRun = 0;\n        for (unsigned int j = 0; j < testIndices.size(); j++) {\n          unsigned int test = testIndices[j];\n\n          WaitAllThreads();\n          AddWorkerThread(i, subtest, test, pt->getThreadUsage(), runSubtest);\n\n          for (unsigned int thread = 1;\n               (thread < m_threads) && (thread < m_modules.size()); thread++) {\n            AddWorkerThread(thread, subtest, test, pt->getThreadUsage(),\n                            dummyThread);\n          }\n\n          numTestsRun++;\n        }\n\n        WaitAllThreads();\n        // Printing the test report\n        // First checking whether the number of subtests is greater than 1.\n        // No point printing report for a one subtest test\n\n        if (numTestsRun > 0) {\n          if (testReport[0]->success) {\n            num_passes++;\n          } else {\n            num_failures++;\n          }\n        }\n        if (App::m_svcMsg) {\n          for (unsigned int j = 0; j < erasedIndices.size(); j++) {\n            oclTestLog(OCLTEST_LOG_ALWAYS,\n                       \"##teamcity[testIgnored name='%s.%s.%d']\\n\",\n                       m_modules[i].get_libname(), name, erasedIndices[j]);\n          }\n        }\n\n        // Resetting the values of the test reports\n        // for(unsigned int j = 0; j < m_numDevices; j++)\n        for (unsigned int j = 0; j < 1; j++) {\n          testReport[j]->reset();\n        }\n        m_modules[i].destroy_test(pt);\n        if (m_modules[i].cached_test) {\n          m_modules[i].cached_test[subtest] = NULL;\n        }\n      }\n    }\n\n    // print the order in which the test are executed if they are\n    // randomized.\n    if (m_rndOrder) {\n      PrintTestOrder(i);\n    }\n    // deleting the test order\n    delete[] mp_testOrder;\n  }\n\n  if (App::m_svcMsg) {\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"##teamcity[testSuiteFinished name='ocltst']\\n\");\n  }\n\n#ifdef ATI_OS_WIN\n  if (!m_console && m_window) {\n    ((Window*)m_window)->ConsumeEvents();\n  }\n#endif\n  float total_tests = (float)(num_passes + num_failures);\n\n  float percent_passed = 0.0f;\n  float percent_failed = 0.0f;\n  float percent_total = 0.0f;\n  if (total_tests > 0) {\n    percent_passed = 100.0f * ((float)num_passes / total_tests);\n    percent_failed = 100.0f * ((float)num_failures / total_tests);\n    percent_total = 100.0f * ((float)total_tests / total_tests);\n  }\n\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"\\n\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"----------------------------------------\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"Total Passed Tests:  %8d (%6.2f%s)\\n\",\n             num_passes, percent_passed, \"%\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"Total Failed Tests:  %8d (%6.2f%s)\\n\",\n             num_failures, percent_failed, \"%\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"----------------------------------------\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"Total Run Tests:     %8d (%6.2f%s)\\n\",\n             (int)total_tests, percent_total, \"%\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"\\n\\n\");\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\nvoid App::AddToList(StringList& strlist, const char* str) {\n  std::string s(str);\n\n  strlist.push_back(s);\n}\n\nvoid App::LoadList(StringList& strlist, const char* filename) {\n  char buffer[1024];\n\n  FILE* fp = fopen(filename, \"r\");\n\n  if (fp == NULL) return;\n\n  while (fgets(buffer, 1000, fp) != NULL) {\n    size_t length = strlen(buffer);\n    if (length > 0) {\n      if (buffer[length - 1] != '\\n') {\n        length++;\n      }\n      buffer[length - 1] = 0;\n      AddToList(strlist, buffer);\n    }\n  }\n\n  fclose(fp);\n}\n\nstatic void Help(const char* name) {\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"%s (-w | -v | -m | -M | -l | -t | -T | -p | -d | -x | -y | -g| \"\n             \"-o | -n )\\n\",\n             name);\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"   -w            : enable window mode\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -v            : enable TeamCity service messages\\n\");\n  oclTestLog(\n      OCLTEST_LOG_ALWAYS,\n      \"   -d            : dump test output to portable float map (pfm)\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -m <module>   : specify a DLL module with tests\\n\");\n  oclTestLog(\n      OCLTEST_LOG_ALWAYS,\n      \"   -M <filename> : specify a text file with one DLL module per line\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -l            : list test names in DLL modules and exit\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -s <count>    : number of threads to spawn\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"   -t <testname> : run test\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -T <filename> : specify a text file with one test per line\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -a <testname> : specify a test to avoid\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -A <filename> : specify a text file of tests to avoid with \"\n             \"one test per line\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -p <platform> : specify a platform to run on, 'amd','nvidia' \"\n             \"or 'intel'\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"   -h            : this help text\\n\");\n  oclTestLog(\n      OCLTEST_LOG_ALWAYS,\n      \"   -x            : x dimension for debug output image (and window)\\n\");\n  oclTestLog(\n      OCLTEST_LOG_ALWAYS,\n      \"   -y            : y dimension for debug output image (and window)\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -P            : Perflab mode (just print the result without \"\n             \"any supplementary information)\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -n #number    : run the tests specified with -m, -M, -t or -T \"\n             \"options multiple times\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -r            : Option to Randomize the order in which the \"\n             \"tests are executed.\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -R            : Option to ReRun failed tests for conditional \"\n             \"pass.\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -i            : Don't print system information\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -g <GPUid>    : GPUid to run the tests on\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -o <filename> : dump the output to a specified file\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"   -c            : Run the test on the CPU device.\\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"                 : \\n\");\n  oclTestLog(OCLTEST_LOG_ALWAYS,\n             \"                 : To run only one subtest of a test, append the \"\n             \"subtest to\\n\");\n  oclTestLog(\n      OCLTEST_LOG_ALWAYS,\n      \"                 : the end of the test name in brackets. i.e. test[1]\");\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"\\n\");\n\n  exit(0);\n}\n\nunsigned int getPlatformID(const char* str) {\n  std::string strOfCLVendor(str);\n  std::string strOfCLPlatformName;\n  unsigned int platform = 0;\n\n  // currently, the only input values amd,nvidia and intel are supported\n  if (strOfCLVendor == \"amd\") {\n    strOfCLPlatformName = \"Advanced Micro Devices, Inc.\";\n  } else if (strOfCLVendor == \"intel\") {\n    strOfCLPlatformName = \"Intel(R) Corporation\";\n  } else if (strOfCLVendor == \"nvidia\") {\n    strOfCLPlatformName = \"NVIDIA Corporation\";\n  } else {\n    // fall-back on platform index 0\n    return platform;\n  }\n\n  cl_int status;\n  cl_uint numPlatforms = 0;\n\n  status = clGetPlatformIDs(0, NULL, &numPlatforms);\n  if (status != CL_SUCCESS) {\n    return platform;\n  }\n\n  cl_platform_id* platforms = new cl_platform_id[numPlatforms];\n  status = clGetPlatformIDs(numPlatforms, platforms, NULL);\n\n  if (status == CL_SUCCESS) {\n    unsigned int i;\n    for (i = 0; i < numPlatforms; ++i) {\n      char buff[200];\n      status = clGetPlatformInfo(platforms[i], CL_PLATFORM_VENDOR, sizeof(buff),\n                                 buff, NULL);\n      if (status != CL_SUCCESS) {\n        break;\n      }\n      if (strcmp(buff, strOfCLPlatformName.c_str()) == 0) {\n        platform = i;\n        break;\n      }\n    }\n  }\n\n  delete[] platforms;\n  return platform;\n}\n\nunsigned int parseCommandLineForPlatform(unsigned int argc, char** argv) {\n  int c;\n  unsigned int platform = 0;\n\n  while ((c = getopt(argc, argv, \"dg:lm:M:o:Ps:t:T:a:A:p:v:wxy:in:rcRV\")) !=\n         -1) {\n    switch (c) {\n      case 'p':\n        platform = getPlatformID(optarg);\n        break;\n      default:\n        break;\n    }\n  }\n  return platform;\n}\n\nvoid App::CommandLine(unsigned int argc, char** argv) {\n  unsigned int i = 1;\n  int c;\n  bool hasOption = false;\n  unsigned int tmpNumDevices = 0;\n  unsigned int tmpDeviceId = 0;\n  m_deviceId = 0;\n  int tmp;\n\n  while ((c = getopt(argc, argv, \"dg:lm:M:o:Ps:t:T:a:A:p:v:wxy:in:rcRV\")) !=\n         -1) {\n    switch (c) {\n      case 'c':\n        m_useCPU = true;\n        break;\n\n      case 'p':\n        break;\n\n      case 'w':\n        m_console = false;\n        hasOption = true;\n        break;\n\n      case 'V':\n        m_svcMsg = true;\n        break;\n\n      case 'd':\n        m_dump = true;\n        hasOption = true;\n        break;\n\n      case 'm':\n        AddToList(m_paths, optarg);\n        hasOption = true;\n        break;\n\n      case 'M':\n        LoadList(m_paths, optarg);\n        hasOption = true;\n        break;\n\n      case 'a':\n        AddToList(m_avoid, optarg);\n        hasOption = true;\n        break;\n\n      case 'A':\n        LoadList(m_avoid, optarg);\n        hasOption = true;\n        break;\n\n      case 'l':\n        m_list = true;\n        hasOption = true;\n        break;\n\n      // command line switch to loop execution of any specified test or tests n\n      // number of times\n      case 'n':\n        m_numItr = atoi(optarg);\n        break;\n\n      // command line switch to randomize the order of test execution in OCLTest\n      case 'r':\n        m_rndOrder = true;\n        break;\n\n      // command line switch to rerun the failed tests to see if they pass on\n      // second run\n      case 'R': {\n        m_reRunFailed = true;\n        break;\n      }\n      case 't':\n        AddToList(m_tests, optarg);\n        hasOption = true;\n        break;\n\n      case 'T':\n        LoadList(m_tests, optarg);\n        hasOption = true;\n        break;\n\n      case 's':\n        m_threads = atoi(optarg);\n        hasOption = true;\n        break;\n\n      case 'h':\n        Help(argv[0]);\n        break;\n\n      case 'x':\n        m_width = atoi(optarg);\n        hasOption = true;\n        break;\n\n      case 'y':\n        m_height = atoi(optarg);\n        hasOption = true;\n        break;\n\n      case 'P':\n        m_perflab = true;\n        hasOption = true;\n        break;\n      case 'g':\n#if 0\n            tmpNumDevices = (unsigned int)atoi(optarg);\n            if(m_numDevices < tmpNumDevices)\n            {\n                oclTestLog(OCLTEST_LOG_ALWAYS, \"Number of Devices(%d) less than specified by the user(%d).  Using %d devices.\\n\", m_numDevices, tmpNumDevices, m_numDevices);\n            }\n            else\n            {\n                m_numDevices = tmpNumDevices;\n            }\n#else\n        tmpDeviceId = (unsigned int)atoi(optarg);\n#endif\n        break;\n      case 'v':\n        tmp = atoi(optarg);\n        if (tmp >= 0 && tmp < 100) {\n          oclTestSetLogLevel(atoi(optarg));\n        } else {\n          oclTestLog(OCLTEST_LOG_ALWAYS, \"Invalid verbose level\\n\");\n        }\n        break;\n      case 'o': {\n        hasOption = true;\n        oclTestEnableLogToFile(optarg);\n      } break;\n      case 'i':\n        m_noSysInfoPrint = true;\n        break;\n      default:\n        Help(argv[0]);\n        break;\n    }\n  }\n\n  // Reset devices in case user overrode defaults\n  m_numDevices = findAdapters(m_platform, m_useCPU, &mpform_id);\n  if (m_numDevices < (tmpDeviceId + 1)) {\n    m_deviceId = 0;\n    oclTestLog(OCLTEST_LOG_ALWAYS,\n               \"User specified deviceId(%d) exceedes the number of \"\n               \"Devices(%d).  Using device %d.\\n\",\n               tmpDeviceId, m_numDevices, m_deviceId);\n  } else {\n    m_deviceId = tmpDeviceId;\n  }\n\n  if (!hasOption) {\n    Help(argv[0]);\n  }\n}\n\nbool App::TestInList(StringList& strlist, const char* szModuleTestname) {\n  if (szModuleTestname == NULL) {\n    return false;\n  }\n  for (unsigned int i = 0; i < strlist.size(); i++) {\n    // check to see if an index is specified for this test name\n    int nIndex = -1;\n    std::string szTestName = strlist[i];\n    if (szTestName.find(\"[\") != std::string::npos) {\n      size_t nFirstBracket = szTestName.find(\"[\");\n      size_t nLastBracket = szTestName.find(\"]\");\n      if ((nFirstBracket != std::string::npos) &&\n          (nLastBracket != std::string::npos) &&\n          (nLastBracket > nFirstBracket)) {\n        szTestName = szTestName.substr(0, nFirstBracket);\n      }\n    }\n    if (strcmp(szModuleTestname, szTestName.c_str()) == 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvoid App::GetTestIndexList(TestIndexList& testIndices, StringList& testList,\n                           const char* szModuleTestname, int maxIndex) {\n  for (unsigned int i = 0; i < testList.size(); i++) {\n    IndicesRange nIndex = {0, maxIndex};\n\n    // If the test name string ends with [...] parse the text\n    // between the brackets to determine the index range.\n    std::string szTestName = testList[i];\n    if (szTestName.find(\"[\") != std::string::npos) {\n      size_t nFirstBracket = szTestName.find(\"[\");\n      size_t nLastBracket = szTestName.find(\"]\");\n      if ((nFirstBracket != std::string::npos) &&\n          (nLastBracket != std::string::npos) &&\n          (nLastBracket > nFirstBracket)) {\n        // Getting the string between the brackets '[' and ']'\n        // The values can be one of the following:-\n        // [a-b] - Run tests from a to b\n        // [a-] - Run tests from subtest a to subtest total_tests\n        // [-b] - Run tests from subtest 0 to subtest b\n        // a and b are indices of the tests to run\n\n        std::string nIndexString = szTestName.substr(\n            nFirstBracket + 1, nLastBracket - nFirstBracket - 1);\n        size_t nIntermediateHyphen = szTestName.find(\"-\");\n        if ((nIntermediateHyphen != std::string::npos) &&\n            (nIntermediateHyphen < nLastBracket) &&\n            (nIntermediateHyphen > nFirstBracket)) {\n          // Getting the start index\n          if ((nIntermediateHyphen - 1) == nFirstBracket) {\n            nIndex.startIndex = 0;\n          } else {\n            nIndex.startIndex =\n                atoi(szTestName\n                         .substr(nFirstBracket + 1,\n                                 nIntermediateHyphen - nFirstBracket - 1)\n                         .c_str());\n          }\n\n          // Getting the end index\n          if ((nIntermediateHyphen + 1) == nLastBracket) {\n            nIndex.endIndex = maxIndex;\n          } else {\n            nIndex.endIndex =\n                atoi(szTestName\n                         .substr(nIntermediateHyphen + 1,\n                                 nLastBracket - nIntermediateHyphen - 1)\n                         .c_str());\n          }\n        } else {\n          nIndex.startIndex = atoi(\n              szTestName\n                  .substr(nFirstBracket + 1, nLastBracket - nFirstBracket - 1)\n                  .c_str());\n          nIndex.endIndex = nIndex.startIndex;\n        }\n      }\n\n      szTestName = szTestName.substr(0, nFirstBracket);\n    }\n\n    if (strcmp(szModuleTestname, szTestName.c_str()) == 0) {\n      // If the values are out of order, swap them.\n      if (nIndex.startIndex > nIndex.endIndex) {\n        int tmp = nIndex.startIndex;\n        nIndex.startIndex = nIndex.endIndex;\n        nIndex.endIndex = tmp;\n      }\n\n      // Add the indices in the specified range to the list.\n      for (int i = nIndex.startIndex; i <= nIndex.endIndex; ++i) {\n        if (i <= maxIndex) {\n          testIndices.push_back(i);\n        } else {\n          oclTestLog(OCLTEST_LOG_ALWAYS,\n                     \"Error: Invalid test index for subtest: %s!\\n\",\n                     szModuleTestname);\n        }\n      }\n\n      // Now sort and prune duplicates.\n      std::sort(testIndices.begin(), testIndices.end());\n      std::unique(testIndices.begin(), testIndices.end());\n    }\n  }\n}\n\nvoid App::PruneTestIndexList(TestIndexList& testIndices,\n                             TestIndexList& avoidIndices,\n                             TestIndexList& erasedIndices) {\n  for (TestIndexList::iterator it = testIndices.begin();\n       it != testIndices.end();) {\n    unsigned int index = *it;\n    TestIndexList::iterator result =\n        std::find(avoidIndices.begin(), avoidIndices.end(), index);\n    if (result != avoidIndices.end()) {\n      it = testIndices.erase(it);\n      erasedIndices.push_back(index);\n    } else {\n      ++it;\n    }\n  }\n}\n\nvoid App::ScanForTests() {\n  for (unsigned int i = 0; i < m_paths.size(); i++) {\n    Module mod;\n\n#ifdef ATI_OS_WIN\n    std::string::iterator myIter;\n    myIter = m_paths[i].end();\n    myIter--;\n    if (*myIter == 0x0a) m_paths[i].erase(myIter);\n\n    mod.hmodule = LoadLibrary(m_paths[i].c_str());\n#endif\n#ifdef ATI_OS_LINUX\n    mod.hmodule = dlopen(m_paths[i].c_str(), RTLD_NOW);\n#endif\n\n    if (mod.hmodule == NULL) {\n      fprintf(stderr, \"Could not load module: %s\\n\", m_paths[i].c_str());\n#ifdef ATI_OS_LINUX\n      fprintf(stderr, \"Error : %s\\n\", dlerror());\n#else\n#endif\n    } else {\n      mod.name = m_paths[i];\n\n#ifdef ATI_OS_WIN\n      mod.get_count = (TestCountFuncPtr)GetProcAddress(mod.hmodule,\n                                                       \"OCLTestList_TestCount\");\n      mod.get_name =\n          (TestNameFuncPtr)GetProcAddress(mod.hmodule, \"OCLTestList_TestName\");\n      mod.create_test = (CreateTestFuncPtr)GetProcAddress(\n          mod.hmodule, \"OCLTestList_CreateTest\");\n      mod.destroy_test = (DestroyTestFuncPtr)GetProcAddress(\n          mod.hmodule, \"OCLTestList_DestroyTest\");\n      mod.get_version = (TestVersionFuncPtr)GetProcAddress(\n          mod.hmodule, \"OCLTestList_TestLibVersion\");\n      mod.get_libname = (TestLibNameFuncPtr)GetProcAddress(\n          mod.hmodule, \"OCLTestList_TestLibName\");\n#endif\n#ifdef ATI_OS_LINUX\n      mod.get_count =\n          (TestCountFuncPtr)dlsym(mod.hmodule, \"OCLTestList_TestCount\");\n      mod.get_name =\n          (TestNameFuncPtr)dlsym(mod.hmodule, \"OCLTestList_TestName\");\n      mod.create_test =\n          (CreateTestFuncPtr)dlsym(mod.hmodule, \"OCLTestList_CreateTest\");\n      mod.destroy_test =\n          (DestroyTestFuncPtr)dlsym(mod.hmodule, \"OCLTestList_DestroyTest\");\n      mod.get_version =\n          (TestVersionFuncPtr)dlsym(mod.hmodule, \"OCLTestList_TestLibVersion\");\n      mod.get_libname =\n          (TestLibNameFuncPtr)dlsym(mod.hmodule, \"OCLTestList_TestLibName\");\n#endif\n      mod.cached_test = new OCLTest*[mod.get_count()];\n      for (int x = 0, y = mod.get_count(); x < y; ++x) {\n        mod.cached_test[x] = NULL;\n      }\n      m_modules.push_back(mod);\n    }\n  }\n}\n\nvoid App::CleanUp() {\n  for (unsigned int i = 0; i < m_modules.size(); i++) {\n    if (m_modules[i].cached_test) {\n      delete[] m_modules[i].cached_test;\n    }\n#ifdef ATI_OS_WIN\n    FreeLibrary(m_modules[i].hmodule);\n#endif\n#ifdef ATI_OS_LINUX\n    dlclose(m_modules[i].hmodule);\n#endif\n  }\n\n#ifdef ATI_OS_WIN\n  if (m_window) delete m_window;\n  m_window = 0;\n#endif\n}\n\nextern int optind;\n/////////////////////////////////////////////////////////////////////////////\nbool App::m_reRunFailed = false;\nbool App::m_svcMsg = false;\nint main(int argc, char** argv) {\n  unsigned int platform = 0;\n  platform = parseCommandLineForPlatform(argc, argv);\n  // reset optind as we really didn't parse the full command line\n  optind = 0;\n  App app(platform);\n#ifdef ATI_OS_WIN\n  // this function is registers windows service routine when ocltst is launched\n  // by the OS on service initialization. On other scenarios, this function does\n  // nothing.\n  serviceStubCall();\n  // SetErrorMode(SEM_NOGPFAULTERRORBOX);\n  // const LPTOP_LEVEL_EXCEPTION_FILTER oldFilter =\n  // SetUnhandledExceptionFilter(xFilter);\n#endif  // ATI_OS_WIN\n#ifdef AUTO_REGRESS\n  try {\n#endif /* AUTO_REGRESS */\n    app.CommandLine(argc, argv);\n    app.printOCLinfo();\n    app.ScanForTests();\n    for (int i = 0; i < app.GetNumItr(); i++) {\n      app.RunAllTests();\n    }\n    app.CleanUp();\n#ifdef AUTO_REGRESS\n  } catch (...) {\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"Exiting due to unhandled exception!\\n\");\n    return (-1);\n  }\n#endif /* AUTO_REGRESS */\n\n  return 0;\n}\n\n#ifdef ATI_OS_WIN\n\n#include <dbghelp.h>\n\ntypedef unsigned int uint32;\ntypedef size_t uintp;\n\nstruct StackEntry {\n  uintp addr;\n  uint32 line;\n  uint32 disp;\n  char symbol[128];\n  char file[128];\n};\n\nstatic const unsigned int MAX_DEPTH_PER_NODE = 24;\nstruct Info {\n  bool operator==(const Info& b) const { return key == b.key; }\n\n  uintp key;  // pointer, handle, whatever\n  StackEntry stack[MAX_DEPTH_PER_NODE];\n};\n\nstatic void dumpTraceBack(CONTEXT& context) {\n  Info info;\n\n  oclTestLog(OCLTEST_LOG_ALWAYS, \"Exception: exiting!\\n\");\n  HANDLE process = GetCurrentProcess();\n\n  STACKFRAME64 stackframe;\n  memset(&stackframe, 0, sizeof(STACKFRAME64));\n\n#if defined(_WIN64)\n  stackframe.AddrPC.Offset = context.Rip;\n  stackframe.AddrPC.Mode = AddrModeFlat;\n  stackframe.AddrStack.Offset = context.Rsp;\n  stackframe.AddrStack.Mode = AddrModeFlat;\n  stackframe.AddrFrame.Offset = context.Rbp;\n  stackframe.AddrFrame.Mode = AddrModeFlat;\n#else\n  stackframe.AddrPC.Offset = context.Eip;\n  stackframe.AddrPC.Mode = AddrModeFlat;\n  stackframe.AddrStack.Offset = context.Esp;\n  stackframe.AddrStack.Mode = AddrModeFlat;\n  stackframe.AddrFrame.Offset = context.Ebp;\n  stackframe.AddrFrame.Mode = AddrModeFlat;\n#endif\n  unsigned int depth = 0;\n\n  if (SymInitialize(process, NULL, true)) {\n    while ((depth < MAX_DEPTH_PER_NODE) &&\n           StackWalk64(IMAGE_FILE_MACHINE_I386, process, GetCurrentThread(),\n                       &stackframe, &context, NULL, SymFunctionTableAccess64,\n                       SymGetModuleBase64, NULL)) {\n      if (stackframe.AddrPC.Offset != 0) {\n        //\n        //  we don't want to evaluate the names/lines yet\n        //  so just record the address\n        //\n        info.stack[depth].addr = (uintp)stackframe.AddrPC.Offset;\n\n        DWORD64 disp64;\n        DWORD disp;\n        IMAGEHLP_SYMBOL64* symInfo;\n        IMAGEHLP_LINE64 lineInfo;\n        uintp addr = (uintp)stackframe.AddrPC.Offset;\n        char buffer[128];\n\n        symInfo = (IMAGEHLP_SYMBOL64*)&buffer[0];\n        symInfo->SizeOfStruct = sizeof(symInfo);\n        symInfo->MaxNameLength = (sizeof(buffer) - sizeof(IMAGEHLP_SYMBOL64));\n\n        lineInfo.SizeOfStruct = sizeof(lineInfo);\n\n        if (SymGetSymFromAddr64(process, addr, &disp64, symInfo)) {\n          sprintf(info.stack[depth].symbol, \"%s\", symInfo->Name);\n          info.stack[depth].disp = (uint32)disp64;\n        } else {\n          sprintf(info.stack[depth].symbol, \"\");\n        }\n\n        if (SymGetLineFromAddr64(process, addr, &disp, &lineInfo)) {\n          sprintf(info.stack[depth].file, \"%s\", lineInfo.FileName);\n          info.stack[depth].line = lineInfo.LineNumber;\n        } else {\n          info.stack[depth].file[0] = '\\0';\n        }\n        depth++;\n      }\n    }\n  }\n\n  SymCleanup(process);\n\n  int j = 0;\n  while (j < MAX_DEPTH_PER_NODE && info.stack[j].addr != 0) {\n    oclTestLog(OCLTEST_LOG_ALWAYS, \"        %s()+%d (0x%.8x)  %s:%d\\n\",\n               info.stack[j].symbol, info.stack[j].disp, info.stack[j].addr,\n               info.stack[j].file, info.stack[j].line);\n\n    j++;\n  }\n}\n\nstatic LONG WINAPI xFilter(LPEXCEPTION_POINTERS xEP) {\n  CONTEXT context;\n  CONTEXT* xCtx = &context;\n  memset(xCtx, 0, sizeof(CONTEXT));\n  context.ContextFlags = CONTEXT_FULL;\n  memcpy(xCtx, xEP->ContextRecord, sizeof(CONTEXT));\n\n  dumpTraceBack(context);\n\n  return (EXCEPTION_EXECUTE_HANDLER);\n}\n#undef CHECK_RESULT\n#endif  // WIN_OS\n\n/////////////////////////////////////////////////////////////////////////////\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.7.0-6twwcw3rjraboiuw75ysfcdddj55uxkg/spack-src/opencl-on-vdi/khronos/icd/loader/linux/icd_linux.c": "/*\n * Copyright (c) 2016-2019 The Khronos Group Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * OpenCL is a trademark of Apple Inc. used under license by Khronos.\n */\n\n#include \"icd.h\"\n#include \"icd_envvars.h\"\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <pthread.h>\n\nstatic pthread_once_t initialized = PTHREAD_ONCE_INIT;\n\n/*\n * \n * Vendor enumeration functions\n *\n */\n\n// go through the list of vendors in the two configuration files\nvoid khrIcdOsVendorsEnumerate(void)\n{\n    DIR *dir = NULL;\n    struct dirent *dirEntry = NULL;\n    char* vendorPath = ICD_VENDOR_PATH;\n    char* envPath = NULL;\n\n    khrIcdVendorsEnumerateEnv();\n\n    envPath = khrIcd_secure_getenv(\"OCL_ICD_VENDORS\");\n    if (NULL != envPath)\n    {\n        vendorPath = envPath;\n    }\n\n    dir = opendir(vendorPath);\n    if (NULL == dir) \n    {\n        KHR_ICD_TRACE(\"Failed to open path %s, continuing\\n\", vendorPath);\n    }\n    else\n    {\n        // attempt to load all files in the directory\n        for (dirEntry = readdir(dir); dirEntry; dirEntry = readdir(dir) )\n        {\n            switch(dirEntry->d_type)\n            {\n            case DT_UNKNOWN:\n            case DT_REG:\n            case DT_LNK:\n                {\n                    const char* extension = \".icd\";\n                    FILE *fin = NULL;\n                    char* fileName = NULL;\n                    char* buffer = NULL;\n                    long bufferSize = 0;\n\n                    // make sure the file name ends in .icd\n                    if (strlen(extension) > strlen(dirEntry->d_name) )\n                    {\n                        break;\n                    }\n                    if (strcmp(dirEntry->d_name + strlen(dirEntry->d_name) - strlen(extension), extension) )\n                    {\n                        break;\n                    }\n\n                    // allocate space for the full path of the vendor library name\n                    fileName = malloc(strlen(dirEntry->d_name) + strlen(vendorPath) + 1);\n                    if (!fileName)\n                    {\n                        KHR_ICD_TRACE(\"Failed allocate space for ICD file path\\n\");\n                        break;\n                    }\n                    sprintf(fileName, \"%s%s\", vendorPath, dirEntry->d_name);\n\n                    // open the file and read its contents\n                    fin = fopen(fileName, \"r\");\n                    if (!fin)\n                    {\n                        free(fileName);\n                        break;\n                    }\n                    fseek(fin, 0, SEEK_END);\n                    bufferSize = ftell(fin);\n\n                    buffer = malloc(bufferSize+1);\n                    if (!buffer)\n                    {\n                        free(fileName);\n                        fclose(fin);\n                        break;\n                    }\n                    memset(buffer, 0, bufferSize+1);\n                    fseek(fin, 0, SEEK_SET);\n                    if (bufferSize != (long)fread(buffer, 1, bufferSize, fin) )\n                    {\n                        free(fileName);\n                        free(buffer);\n                        fclose(fin);\n                        break;\n                    }\n                    // ignore a newline at the end of the file\n                    if (buffer[bufferSize-1] == '\\n') buffer[bufferSize-1] = '\\0';\n\n                    // load the string read from the file\n                    khrIcdVendorAdd(buffer);\n\n                    free(fileName);\n                    free(buffer);\n                    fclose(fin);\n                }\n                break;\n            default:\n                break;\n            }\n        }\n\n        closedir(dir);\n    }\n\n    if (NULL != envPath)\n    {\n        khrIcd_free_getenv(envPath);\n    }\n}\n\n// go through the list of vendors only once\nvoid khrIcdOsVendorsEnumerateOnce(void)\n{\n    pthread_once(&initialized, khrIcdOsVendorsEnumerate);\n}\n\n/*\n * \n * Dynamic library loading functions\n *\n */\n\n// dynamically load a library.  returns NULL on failure\nvoid *khrIcdOsLibraryLoad(const char *libraryName)\n{\n    void *retVal = dlopen (libraryName, RTLD_NOW);\n\n    if (NULL == retVal) {\n        printf(\"dlerror: %s\\n\", dlerror());\n    }\n\n    return retVal;\n}\n\n// get a function pointer from a loaded library.  returns NULL on failure.\nvoid *khrIcdOsLibraryGetFunctionAddress(void *library, const char *functionName)\n{\n    return dlsym(library, functionName);\n}\n\n// unload a library\nvoid khrIcdOsLibraryUnload(void *library)\n{\n    dlclose(library);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.7.0-6twwcw3rjraboiuw75ysfcdddj55uxkg/spack-src/device/pal/palsched.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-hip-rocclr-3.7.0-6twwcw3rjraboiuw75ysfcdddj55uxkg/spack-src/device/gpu/gpusched.hpp"
    ],
    "total_files": 806
}