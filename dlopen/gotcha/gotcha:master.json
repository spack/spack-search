{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-master-mteuum2hrp62uwy6o3knzku2vbnnowhs/spack-src/src/gotcha_dl.h": "#ifndef GOTCHA_DL_H\n#define GOTCHA_DL_H\n\n#include \"hash.h\"\n#include \"tool.h\"\n\nvoid handle_libdl();\nextern void update_all_library_gots(hash_table_t *bindings);\nextern int prepare_symbol(struct internal_binding_t *binding);\n\nextern gotcha_wrappee_handle_t orig_dlopen_handle;\nextern gotcha_wrappee_handle_t orig_dlsym_handle;\n\nextern struct gotcha_binding_t dl_binds[];\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-master-mteuum2hrp62uwy6o3knzku2vbnnowhs/spack-src/src/gotcha_dl.c": "#define _GNU_SOURCE\n#include \"gotcha_dl.h\"\n#include \"tool.h\"\n#include \"libc_wrappers.h\"\n#include \"elf_ops.h\"\n#include <dlfcn.h>\n\nvoid* _dl_sym(void* handle, const char* name, void* where);\n\ngotcha_wrappee_handle_t orig_dlopen_handle;\ngotcha_wrappee_handle_t orig_dlsym_handle;\n\nstatic int per_binding(hash_key_t key, hash_data_t data, void *opaque KNOWN_UNUSED)\n{\n   int result;\n   struct internal_binding_t *binding = (struct internal_binding_t *) data;\n\n   debug_printf(3, \"Trying to re-bind %s from tool %s after dlopen\\n\",\n                binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   \n   while (binding->next_binding) {\n      binding = binding->next_binding;\n      debug_printf(3, \"Selecting new innermost version of binding %s from tool %s.\\n\",\n                   binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   }\n   \n   result = prepare_symbol(binding);\n   if (result == -1) {\n      debug_printf(3, \"Still could not prepare binding %s after dlopen\\n\", binding->user_binding->name);\n      return 0;\n   }\n\n   removefrom_hashtable(&notfound_binding_table, key);\n   return 0;\n}\n\nstatic void* dlopen_wrapper(const char* filename, int flags) {\n   typeof(&dlopen_wrapper) orig_dlopen = gotcha_get_wrappee(orig_dlopen_handle);\n   void *handle;\n   debug_printf(1, \"User called dlopen(%s, 0x%x)\\n\", filename, (unsigned int) flags);\n   handle = orig_dlopen(filename,flags);\n\n   debug_printf(2, \"Searching new dlopened libraries for previously-not-found exports\\n\");\n   foreach_hash_entry(&notfound_binding_table, NULL, per_binding);\n\n   debug_printf(2, \"Updating GOT entries for new dlopened libraries\\n\");\n   update_all_library_gots(&function_hash_table);\n  \n   return handle;\n}\n\nstatic void* dlsym_wrapper(void* handle, const char* symbol_name){\n  typeof(&dlsym_wrapper) orig_dlsym = gotcha_get_wrappee(orig_dlsym_handle);\n  struct internal_binding_t *binding;\n  int result;\n  \n  if(handle == RTLD_NEXT){\n    return _dl_sym(RTLD_NEXT, symbol_name ,__builtin_return_address(0));\n  }\n  \n  result = lookup_hashtable(&function_hash_table, (hash_key_t) symbol_name, (hash_data_t *) &binding);\n  if (result == -1)\n     return orig_dlsym(handle, symbol_name);\n  else\n     return binding->user_binding->wrapper_pointer;\n}\n\nstruct gotcha_binding_t dl_binds[] = {\n  {\"dlopen\", dlopen_wrapper, &orig_dlopen_handle},\n  {\"dlsym\", dlsym_wrapper, &orig_dlsym_handle}\n};     \nvoid handle_libdl(){\n  gotcha_wrap(dl_binds, 2, \"gotcha\");\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-master-mteuum2hrp62uwy6o3knzku2vbnnowhs/spack-src/src/hash.c": "/*\nThis file is part of GOTCHA.  For copyright information see the COPYRIGHT\nfile in the top level directory, or at\nhttps://github.com/LLNL/gotcha/blob/master/COPYRIGHT\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License (as published by the Free\nSoftware Foundation) version 2.1 dated February 1999.  This program is\ndistributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS FOR A PARTICULAR\nPURPOSE. See the terms and conditions of the GNU Lesser General Public License\nfor more details.  You should have received a copy of the GNU Lesser General\nPublic License along with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include \"libc_wrappers.h\"\n#include \"hash.h\"\n\n#define EMPTY 0\n#define TOMBSTONE 1\n#define INUSE 2\n\nstruct hash_entry_t {\n   hash_key_t key;\n   hash_data_t data;\n   hash_hashvalue_t hash_value;\n   struct hash_entry_t *next;\n   struct hash_entry_t *prev;\n   uint32_t status;\n};\n\ntypedef struct hash_entry_t hash_entry_t;\n\nint create_hashtable(hash_table_t *table, size_t initial_size, hash_func_t hashfunc, \n                     hash_cmp_t keycmp)\n{\n   hash_entry_t *newtable;\n   int entries_per_page;\n\n   entries_per_page = gotcha_getpagesize() / sizeof(hash_entry_t);\n   if (initial_size % entries_per_page)\n      initial_size += entries_per_page - (initial_size % entries_per_page);\n\n   newtable = (hash_entry_t *) gotcha_malloc(initial_size * sizeof(hash_entry_t));\n   if (!newtable)\n      return -1;\n   gotcha_memset(newtable, 0, initial_size * sizeof(hash_entry_t));\n\n   table->table_size = initial_size;\n   table->entry_count = 0;\n   table->hashfunc = hashfunc;\n   table->keycmp = keycmp;\n   table->table = newtable;\n   table->head = NULL;\n   \n   return 0;\n}\n\nstatic hash_entry_t *insert(hash_table_t *table, hash_key_t key, hash_data_t data, hash_hashvalue_t value)\n{\n   unsigned long index = (unsigned long)value % table->table_size;\n   unsigned long startindex = index;\n\n   hash_entry_t *entry = NULL;\n   do {\n      entry = table->table + index;\n      if (entry->status == EMPTY || entry->status == TOMBSTONE) {\n         entry->key = key;\n         entry->data = data;\n         entry->hash_value = value;\n         entry->status = INUSE;\n         break;\n      }\n      index++;\n      if (index == table->table_size)\n         index = 0;\n   } while (index != startindex);\n\n   if (!entry)\n      return NULL;\n\n   entry->next = table->head;\n   entry->prev = NULL;\n   if (table->head)\n      table->head->prev = entry;\n   table->head = entry;\n   table->entry_count++;         \n\n   return entry;\n}\n\nint grow_hashtable(hash_table_t *table, size_t new_size)\n{\n   hash_table_t newtable;\n   hash_entry_t *result;\n   size_t i;\n\n   newtable.table_size = new_size;\n   newtable.entry_count = 0;\n   newtable.hashfunc = table->hashfunc;\n   newtable.keycmp = table->keycmp;\n   newtable.table = (hash_entry_t *) gotcha_malloc(new_size * sizeof(hash_entry_t));\n   newtable.head = NULL;\n   gotcha_memset(newtable.table, 0, new_size * sizeof(hash_entry_t));\n\n   for (i = 0; i < table->table_size; i++) {\n      if (table->table[i].status == EMPTY || table->table[i].status == TOMBSTONE)\n         continue;\n      result = insert(&newtable, table->table[i].key, table->table[i].data,\n                      table->table[i].hash_value);\n      if (!result) {\n         return -1;\n      }\n   }\n\n   destroy_hashtable(table);\n   *table = newtable;\n   return 0;\n}\n\nint destroy_hashtable(hash_table_t *table)\n{\n   gotcha_free(table->table);\n   table->table_size = 0;\n   table->entry_count = 0;\n   table->hashfunc = NULL;\n   table->keycmp = NULL;\n   table->table = NULL;\n   table->head = NULL;\n   return 0;\n}\n\nstatic int lookup(hash_table_t *table, hash_key_t key, hash_entry_t **entry)\n{\n   size_t index, startindex;\n   hash_hashvalue_t hashval;\n\n   hashval = table->hashfunc(key);\n   index = hashval % table->table_size;\n   startindex = index;\n   \n   for (;;) {\n      hash_entry_t *cur = table->table + index;\n      if ((cur->status == INUSE) && \n          (cur->hash_value == hashval) && \n          (table->keycmp(cur->key, key) == 0)) {\n         *entry = cur;\n         return 0;\n      }\n\n      if (cur->status == EMPTY)\n         return -1;\n      index++;\n      if (index == table->table_size)\n         index = 0;\n      if (index == startindex)\n         return -1;\n   }\n}\n\nint lookup_hashtable(hash_table_t *table, hash_key_t key, hash_data_t *data)\n{\n   hash_entry_t *entry;\n   int result;\n\n   result = lookup(table, key, &entry);\n   if (result == -1)\n      return -1;\n   *data = entry->data;\n   return 0;\n}\n\nint addto_hashtable(hash_table_t *table, hash_key_t key, hash_data_t data)\n{\n   size_t newsize;\n   int result;\n   hash_hashvalue_t val;\n   hash_entry_t *entry;\n\n   newsize = table->table_size;\n   while (table->entry_count > newsize/2)\n      newsize *= 2;\n   if (newsize != table->table_size) {\n      result = grow_hashtable(table, newsize);\n      if (result == -1)\n         return -1;\n   }\n\n   val = table->hashfunc(key);\n   entry = insert(table, key, data, val);\n   if (!entry)\n      return -1;\n\n   return 0;\n}\n\nint removefrom_hashtable(hash_table_t *table, hash_key_t key)\n{\n   hash_entry_t *entry;\n   int result;\n\n   result = lookup(table, key, &entry);\n   if (result == -1)\n      return -1;\n\n   entry->key = NULL;\n   entry->data = NULL;\n   entry->hash_value = 0;\n   entry->status = TOMBSTONE;\n   if (entry->next)\n      entry->next->prev = entry->prev;\n   if (entry->prev)\n      entry->prev->next = entry->next;\n   if (table->head == entry)\n      table->head = entry->next;\n   //Do not set entry->next to NULL, which would break the iterate & delete\n   //idiom used under dlopen_wrapper.\n   \n   table->entry_count--;\n   return 0;\n}\n\nint foreach_hash_entry(hash_table_t *table, void *opaque, int (*cb)(hash_key_t key, hash_data_t data, void *opaque))\n{\n   int result;\n   struct hash_entry_t *i;\n   for (i = table->head; i != NULL; i = i->next) {\n      result = cb(i->key, i->data, opaque);\n      if (result != 0)\n         return result;\n   }\n   return 0;\n}\n\nhash_hashvalue_t strhash(const char *str)\n{\n   unsigned long hash = 5381;\n   int c;\n\n   while ((c = *str++))\n      hash = hash * 33 + c;\n\n   return (hash_hashvalue_t) hash;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-master-mteuum2hrp62uwy6o3knzku2vbnnowhs/spack-src/src/gotcha.c": "/*\nThis file is part of GOTCHA.  For copyright information see the COPYRIGHT\nfile in the top level directory, or at\nhttps://github.com/LLNL/gotcha/blob/master/COPYRIGHT\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License (as published by the Free\nSoftware Foundation) version 2.1 dated February 1999.  This program is\ndistributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS FOR A PARTICULAR\nPURPOSE. See the terms and conditions of the GNU Lesser General Public License\nfor more details.  You should have received a copy of the GNU Lesser General\nPublic License along with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include \"translations.h\"\n#include \"libc_wrappers.h\"\n#include \"gotcha/gotcha.h\"\n#include \"gotcha/gotcha_types.h\"\n#include \"gotcha_utils.h\"\n#include \"gotcha_auxv.h\"\n#include \"gotcha_dl.h\"\n#include \"elf_ops.h\"\n#include \"tool.h\"\n\nstatic void writeAddress(void* write, void* value){\n  *(void**)write = value;\n}\n\nstatic void** getBindingAddressPointer(struct gotcha_binding_t* in){\n  return (void**)in->function_handle;\n}\n\nstatic void setBindingAddressPointer(struct gotcha_binding_t* in, void* value){\n   void **target = getBindingAddressPointer(in);\n   debug_printf(3, \"Updating binding address pointer at %p to %p\\n\", target, value);\n   writeAddress(target, value);\n}\n\nstatic void** getInternalBindingAddressPointer(struct internal_binding_t** in){\n  return (void**)&((*in)->wrappee_pointer);\n}\n\nstatic void setInternalBindingAddressPointer(void** in, void* value){\n  void** target = getInternalBindingAddressPointer((struct internal_binding_t**)in);\n  debug_printf(3, \"Updating binding address pointer at %p to %p\\n\", target, value);\n  writeAddress(target, value);\n}\n\nint prepare_symbol(struct internal_binding_t *binding)\n{\n   int result;\n   struct link_map *lib;\n   struct gotcha_binding_t *user_binding = binding->user_binding;\n\n   debug_printf(2, \"Looking up exported symbols for %s\\n\", user_binding->name);\n   for (lib = _r_debug.r_map; lib != 0; lib = lib->l_next) {\n      struct library_t *int_library = get_library(lib);\n      if (!int_library) {\n         debug_printf(3, \"Creating new library object for %s\\n\", LIB_NAME(lib));\n         int_library = add_library(lib);\n      }\n      \n      if (is_vdso(lib)) {\n         debug_printf(2, \"Skipping VDSO library at 0x%lx with name %s\\n\",\n                      lib->l_addr, LIB_NAME(lib));\n         continue;\n      }\n      debug_printf(2, \"Searching for exported symbols in %s\\n\", LIB_NAME(lib));\n      INIT_DYNAMIC(lib);\n\n      if (!gnu_hash && !elf_hash) {\n         debug_printf(3, \"Library %s does not export or import symbols\\n\", LIB_NAME(lib));\n         continue;\n      }\n      result = -1;\n      if (gnu_hash) {\n         debug_printf(3, \"Checking GNU hash for %s in %s\\n\",\n                      user_binding->name, LIB_NAME(lib));\n         result = lookup_gnu_hash_symbol(user_binding->name, symtab, strtab,\n                                         (struct gnu_hash_header *) gnu_hash);\n      }\n      if (elf_hash && result == -1) {\n         debug_printf(3, \"Checking ELF hash for %s in %s\\n\",\n                      user_binding->name, LIB_NAME(lib));\n         result = lookup_elf_hash_symbol(user_binding->name, symtab, strtab,\n                                         (ElfW(Word) *)elf_hash);\n      }\n      if (result == -1) {\n         debug_printf(3, \"%s not found in %s\\n\",\n                      user_binding->name, LIB_NAME(lib));\n         continue;\n      }\n      if (! GOTCHA_CHECK_VISIBILITY(symtab[result])) {\n         debug_printf(3, \"Symbol %s found but not exported in %s\\n\", \n                      user_binding->name, LIB_NAME(lib));\n         continue;\n      }\n\n      debug_printf(2, \"Symbol %s found in %s at 0x%lx\\n\", \n                   user_binding->name, LIB_NAME(lib),\n                   symtab[result].st_value + lib->l_addr);\n      setInternalBindingAddressPointer(user_binding->function_handle,(void *)(symtab[result].st_value + lib->l_addr));\n      return 0;\n   }\n   debug_printf(1, \"Symbol %s was found in program\\n\", user_binding->name);\n   return -1;\n}\n\nstatic void insert_at_head(struct internal_binding_t *binding, struct internal_binding_t *head)\n{\n   binding->next_binding = head;\n   setInternalBindingAddressPointer(binding->user_binding->function_handle, head->user_binding->wrapper_pointer);\n   removefrom_hashtable(&function_hash_table, (void*) binding->user_binding->name);\n   addto_hashtable(&function_hash_table, (void*)binding->user_binding->name, (void*)binding);\n}\n\nstatic void insert_after_pos(struct internal_binding_t *binding, struct internal_binding_t *pos)\n{\n   setInternalBindingAddressPointer(binding->user_binding->function_handle, pos->wrappee_pointer);\n   setInternalBindingAddressPointer(pos->user_binding->function_handle, binding->user_binding->wrapper_pointer);\n   binding->next_binding = pos->next_binding;\n   pos->next_binding = binding;\n}\n\n#define RWO_NOCHANGE 0\n#define RWO_NEED_LOOKUP (1 << 0)\n#define RWO_NEED_BINDING (1 << 1)\nstatic int rewrite_wrapper_orders(struct internal_binding_t* binding)\n{\n  const char* name = binding->user_binding->name;\n  int insert_priority = get_priority(binding->associated_binding_table->tool);\n  \n  if(gotcha_strcmp(name,\"main\")==0){\n    if(!main_wrapped){\n      debug_printf(2, \"Wrapping main with Gotcha's internal wrappers\");\n      main_wrapped = 1;\n      gotcha_wrap(libc_main_wrappers,1,\"gotcha\");\n      gotcha_wrap(main_wrappers,1,\"gotcha\");\n    }\n  }\n\n  debug_printf(2, \"gotcha_rewrite_wrapper_orders for binding %s in tool %s of priority %d\\n\",\n               name, binding->associated_binding_table->tool->tool_name, insert_priority);\n\n  struct internal_binding_t* head;\n  int hash_result;\n  hash_result = lookup_hashtable(&function_hash_table, (void*)name, (void**)&head);\n  if(hash_result != 0) {\n    debug_printf(2, \"Adding new entry for %s to hash table\\n\", name);\n    addto_hashtable(&function_hash_table, (void *) name, (void *) binding);\n    return (RWO_NEED_LOOKUP | RWO_NEED_BINDING);\n  }\n\n  int head_priority = get_priority(head->associated_binding_table->tool);\n    if (head_priority < insert_priority) {\n     debug_printf(2, \"New binding priority %d is greater than head priority %d, adding to head\\n\",\n                   insert_priority, head_priority);\n     insert_at_head(binding, head);\n     return RWO_NEED_BINDING;\n  }\n\n  struct internal_binding_t* cur;\n  for (cur = head; cur->next_binding; cur = cur->next_binding) {\n     int next_priority = get_priority(cur->next_binding->associated_binding_table->tool);\n     debug_printf(3, \"Comparing binding for new insertion %d to binding for tool %s at %d\\n\",\n                   insert_priority, cur->next_binding->associated_binding_table->tool->tool_name,\n                   next_priority);\n     if (next_priority < insert_priority) {\n        break;\n     }\n     if (cur->user_binding->wrapper_pointer == binding->user_binding->wrapper_pointer) {\n        debug_printf(3, \"Tool is already inserted.  Skipping binding rewrite\\n\");\n        return RWO_NOCHANGE;\n     }\n  }\n  debug_printf(2, \"Inserting binding after tool %s\\n\", cur->associated_binding_table->tool->tool_name);\n  insert_after_pos(binding, cur);\n  return RWO_NOCHANGE;\n}\n\nstatic int update_lib_bindings(ElfW(Sym) * symbol KNOWN_UNUSED, char *name, ElfW(Addr) offset,\n                               struct link_map *lmap, hash_table_t *lookuptable)\n{\n  int result;\n  struct internal_binding_t *internal_binding;\n  void **got_address;\n\n  result = lookup_hashtable(lookuptable, name, (void **) &internal_binding);\n  if (result != 0)\n     return 0;\n  got_address = (void**) (lmap->l_addr + offset);\n  writeAddress(got_address, internal_binding->user_binding->wrapper_pointer);\n  debug_printf(3, \"Remapped call to %s at 0x%lx in %s to wrapper at 0x%p\\n\",\n             name, (lmap->l_addr + offset), LIB_NAME(lmap),\n             internal_binding->user_binding->wrapper_pointer);\n  return 0;\n}\n\n#ifndef MAX\n#define MAX(a,b) (a>b?a:b)\n#endif\n\nstatic int mark_got_writable(struct link_map *lib)\n{\n   static unsigned int page_size = 0;\n   INIT_DYNAMIC(lib);\n   if (!got)\n      return 0;\n\n   if (!page_size)\n      page_size = gotcha_getpagesize();\n\n   size_t protect_size = MAX(rel_size, page_size);\n   if(protect_size % page_size){\n      protect_size += page_size -  ((protect_size) %page_size);\n   }\n   ElfW(Addr) prot_address = BOUNDARY_BEFORE(got,(ElfW(Addr))page_size);\n   debug_printf(3, \"Setting library %s GOT table from %p to +%lu to writeable\\n\",\n                LIB_NAME(lib), (void *) prot_address, protect_size);\n   int res = gotcha_mprotect((void*)prot_address,protect_size,PROT_READ | PROT_WRITE | PROT_EXEC );\n   if(res == -1){ // mprotect returns -1 on an error\n      error_printf(\"GOTCHA attempted to mark the GOT table as writable and was unable to do so, \"\n                   \"calls to wrapped functions may likely fail.\\n\");\n   }\n\n   return 0;\n}\n\nstatic int update_library_got(struct link_map *map, hash_table_t *bindingtable)\n{\n   struct library_t *lib = get_library(map);\n   if (!lib) {\n      debug_printf(3, \"Creating new library object for %s\\n\", LIB_NAME(map));\n      lib = add_library(map);\n   }\n\n   if (!libraryFilterFunc(map)) {\n      debug_printf(3, \"Skipping library %s due to libraryFilterFunc\\n\", LIB_NAME(map));\n      return 0;\n   }\n\n   if (lib->generation == current_generation) {\n      debug_printf(2, \"Library %s is already up-to-date.  Skipping GOT rewriting\\n\", LIB_NAME(map));\n      return 0;\n   }\n   \n   if (!(lib->flags & LIB_GOT_MARKED_WRITEABLE)) {\n      mark_got_writable(map);\n      lib->flags |= LIB_GOT_MARKED_WRITEABLE;\n   }\n\n   FOR_EACH_PLTREL(map, update_lib_bindings, map, bindingtable);\n\n   lib->generation = current_generation;\n   return 0;\n}\n\nvoid update_all_library_gots(hash_table_t *bindings)\n{\n   struct link_map *lib_iter;\n   debug_printf(2, \"Searching all callsites for %lu bindings\\n\", (unsigned long) bindings->entry_count);\n   for (lib_iter = _r_debug.r_map; lib_iter != 0; lib_iter = lib_iter->l_next) {\n      update_library_got(lib_iter, bindings);\n   }   \n}\n\nGOTCHA_EXPORT enum gotcha_error_t gotcha_wrap(struct gotcha_binding_t* user_bindings, int num_actions, const char* tool_name)\n{\n  int i, not_found = 0, new_bindings_count = 0;\n  tool_t *tool;\n  hash_table_t new_bindings;\n\n  gotcha_init();\n\n  debug_printf(1, \"User called gotcha_wrap for tool %s with %d bindings\\n\",\n               tool_name, num_actions);\n  if (debug_level >= 3) {\n    for (i = 0; i < num_actions; i++) {\n       debug_bare_printf(3, \"\\t%d: %s will map to %p\\n\", i, user_bindings[i].name,\n                         user_bindings[i].wrapper_pointer);\n    }\n  }\n  debug_printf(3, \"Initializing %d user binding entries to NULL\\n\", num_actions);\n  for (i = 0; i < num_actions; i++) {\n    setBindingAddressPointer(&user_bindings[i], NULL);\n  }\n\n  if (!tool_name)\n     tool_name = \"[UNSPECIFIED]\";\n  tool = get_tool(tool_name);\n  if (!tool)\n     tool = create_tool(tool_name);\n  if (!tool) {\n     error_printf(\"Failed to create tool %s\\n\", tool_name);\n     return GOTCHA_INTERNAL;\n  }\n\n  current_generation++;\n  debug_printf(2, \"Moved current_generation to %u in gotcha_wrap\\n\", current_generation);\n\n  debug_printf(2, \"Creating internal binding data structures and adding binding to tool\\n\");\n  binding_t *bindings = add_binding_to_tool(tool, user_bindings, num_actions);\n  if (!bindings) {\n     error_printf(\"Failed to create bindings for tool %s\\n\", tool_name);\n     return GOTCHA_INTERNAL;\n  }\n\n  debug_printf(2, \"Processing %d bindings\\n\", num_actions);\n  for (i = 0; i < num_actions; i++) {\n     struct internal_binding_t *binding = bindings->internal_bindings + i;\n\n     int result = rewrite_wrapper_orders(binding);\n     if (result & RWO_NEED_LOOKUP) {\n        debug_printf(2, \"Symbol %s needs lookup operation\\n\", binding->user_binding->name);\n        int presult = prepare_symbol(binding);\n        if (presult == -1) {\n           debug_printf(2, \"Stashing %s in notfound_binding table to re-lookup on dlopens\\n\",\n                        binding->user_binding->name);\n           addto_hashtable(&notfound_binding_table, (hash_key_t) binding->user_binding->name, (hash_data_t) binding);\n           not_found++;\n        }\n     }\n     if (result & RWO_NEED_BINDING) {\n        debug_printf(2, \"Symbol %s needs binding from application\\n\", binding->user_binding->name);\n        if (!new_bindings_count) {\n           create_hashtable(&new_bindings, num_actions*2, (hash_func_t) strhash, (hash_cmp_t) gotcha_strcmp);\n        }\n        addto_hashtable(&new_bindings, (void *) binding->user_binding->name, (void *) binding);\n        new_bindings_count++;\n     }\n  }\n  \n  if (new_bindings_count) {\n     update_all_library_gots(&new_bindings);\n     destroy_hashtable(&new_bindings);\n  }\n\n  if (not_found) {\n     debug_printf(1, \"Could not find bindings for %d / %d functions\\n\", not_found, num_actions);\n     return GOTCHA_FUNCTION_NOT_FOUND;\n  }\n  debug_printf(1, \"Gotcha wrap completed successfully\\n\");\n  return GOTCHA_SUCCESS;\n}\n\nstatic enum gotcha_error_t gotcha_configure_int(const char* tool_name, enum gotcha_config_key_t configuration_key , int value){\n  tool_t * tool = get_tool(tool_name);\n  if(tool==NULL){\n    tool = create_tool(tool_name);\n  }\n  if( configuration_key == GOTCHA_PRIORITY){\n    tool->config.priority = value;\n  }\n  else{\n    error_printf(\"Invalid property being configured on tool %s\\n\", tool_name);\n    return GOTCHA_INTERNAL;\n  }\n  return GOTCHA_SUCCESS;\n}\n\nGOTCHA_EXPORT enum gotcha_error_t gotcha_set_priority(const char* tool_name, int value){\n  gotcha_init();\n  debug_printf(1, \"User called gotcha_set_priority(%s, %d)\\n\", tool_name, value);\n  enum gotcha_error_t error_on_set = gotcha_configure_int(tool_name, GOTCHA_PRIORITY, value);\n  if(error_on_set != GOTCHA_SUCCESS) {\n    return error_on_set;\n  }\n  tool_t* tool_to_place = get_tool(tool_name);\n  if(!tool_to_place){\n     tool_to_place = create_tool(tool_name);\n  }\n  remove_tool_from_list(tool_to_place);\n  reorder_tool(tool_to_place);\n  return GOTCHA_SUCCESS;\n}\n\nGOTCHA_EXPORT enum gotcha_error_t gotcha_get_priority(const char* tool_name, int *priority){\n  gotcha_init();\n  return get_configuration_value(tool_name, GOTCHA_PRIORITY, priority);\n}\n\nGOTCHA_EXPORT void* gotcha_get_wrappee(gotcha_wrappee_handle_t handle){\n  return ((struct internal_binding_t*)handle)->wrappee_pointer;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-master-mteuum2hrp62uwy6o3knzku2vbnnowhs/spack-src/test/CMakeLists.txt": "add_subdirectory(rogot)\nadd_subdirectory(unit)\nadd_subdirectory(dlopen)\nadd_subdirectory(stack)\nadd_subdirectory(priority)\nadd_subdirectory(multi_agent_dlopen)\nadd_subdirectory(ppc_stress_multi_module)\nadd_subdirectory(wrap_main)\nif(COMPILER_SUPPORTS_CXX11)\nadd_subdirectory(hammer)\nendif()\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-master-mteuum2hrp62uwy6o3knzku2vbnnowhs/spack-src/test/dlopen/test_dlopen.c": "/*\nThis file is part of GOTCHA.  For copyright information see the COPYRIGHT\nfile in the top level directory, or at\nhttps://github.com/LLNL/gotcha/blob/master/COPYRIGHT\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License (as published by the Free\nSoftware Foundation) version 2.1 dated February 1999.  This program is\ndistributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS FOR A PARTICULAR\nPURPOSE. See the terms and conditions of the GNU Lesser General Public License\nfor more details.  You should have received a copy of the GNU Lesser General\nPublic License along with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include \"gotcha/gotcha.h\"\n\n#define Q(x) #x\n#define QUOTE(x) Q(x)\n\n#ifndef LIB_NAME_RAW\n#define LIB_NAME_RAW libnum.so\n#endif\n\n#define LIB_NAME QUOTE(LIB_NAME_RAW)\nint correct_return_four()\n{\n   return 4;\n}\n\nint return_five() \n{\n   /* Intentional bug, gotcha will correct this to return 5*/\n   return 3;\n}\n\nint correct_return_five()\n{\n   return 5;\n}\n\n\nstatic gotcha_wrappee_handle_t buggy_return_four;\nstatic gotcha_wrappee_handle_t buggy_return_five;\nstruct gotcha_binding_t funcs[] = {\n   { \"return_four\", correct_return_four, &buggy_return_four },\n   { \"return_five\", correct_return_five, &buggy_return_five }\n};\n\nint main()\n{\n   void *libnum;\n   int (*retfour)(void);\n   int (*test_retfive)(void);\n   int had_error = 0;\n   int result;\n\n   result = gotcha_wrap(funcs, 2, \"dlopen_test\");\n   if(result != GOTCHA_FUNCTION_NOT_FOUND){\n     fprintf(stderr, \"GOTCHA should have failed to find a function, but found it\\n\");\n     return -1;\n   }\n\n   libnum = dlopen(LIB_NAME, RTLD_NOW);\n   if (!libnum) {\n      fprintf(stderr, \"ERROR: Test failed to dlopen libnum.so\\n\");\n      return -1;\n   }\n\n   /* Test 1: Check if a dlsym generated indirect call gets re-routed by gotcha */\n   retfour = (int (*)(void)) dlsym(libnum, \"return_four\");\n   if (retfour() != 4) {\n      fprintf(stderr, \"ERROR: dlsym returned original function, not wrapped\\n\");\n      had_error = -1;\n   }\n\n   /* Test 2: Does a call in a dlopen'd library get rerouted by gotcha */\n   test_retfive = (int (*)(void)) dlsym(libnum, \"test_return_five\");\n   if (test_retfive() != 5) {\n      fprintf(stderr, \"ERROR: call to return_five in libnum.so was not wrapped by correct_return_five\\n\");\n      had_error = -1;\n   }\n\n   return had_error;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-master-mteuum2hrp62uwy6o3knzku2vbnnowhs/spack-src/test/dlopen/CMakeLists.txt": "add_library(num SHARED num.c)\nadd_executable(test_dlopen test_dlopen.c)\nset_target_properties(test_dlopen\n  PROPERTIES COMPILE_FLAGS \"-DLIB_NAME_RAW=\\\"\\\"${CMAKE_CURRENT_BINARY_DIR}/libnum.so\\\"\\\"\"\n  )\ntarget_link_libraries(test_dlopen gotcha dl)\ngotcha_add_test(dlopen_test test_dlopen)\nenvironment_add(dlopen_test TEST \"GOTCHA_DEBUG=3 LIBNUM_DIR=${CMAKE_CURRENT_BINARY_DIR}\")\nset_tests_properties(dlopen_test PROPERTIES\n  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}\n)\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-master-mteuum2hrp62uwy6o3knzku2vbnnowhs/spack-src/test/multi_agent_dlopen/dlsym.c": "/*\n *  dlsym.c  -->  libsym.so\n *\n *  Override dlsym() and replace with __libc_dlsym().\n */\n\n#define _GNU_SOURCE  1\n\n#include <dlfcn.h>\n#include <err.h>\n#include <errno.h>\n#include <stdio.h>\n\n#define MYNAME  \"libsym.so\"\n\ntypedef void * dlsym_fcn_t(void *, const char *);\ntypedef void * dlopen_mode_fcn_t(const char *, int);\n\ndlsym_fcn_t __libc_dlsym;\ndlopen_mode_fcn_t __libc_dlopen_mode;\n\nvoid *\ndlsym(void *handle, const char *symbol)\n{\n    fprintf(stderr, \"%s:  enter dlsym:  sym = %s\\n\", MYNAME, symbol);\n\n    void * dl_handle = __libc_dlopen_mode(\"libdl.so\", RTLD_LAZY);\n\n    if (dl_handle == NULL) {\n\terr(1, \"__libc_dlopen_mode failed\");\n    }\n\n    dlsym_fcn_t * the_dlsym = __libc_dlsym(dl_handle, \"dlsym\");\n\n    if (the_dlsym == NULL) {\n\terr(1, \"__libc_dlsym failed\");\n    }\n\n    fprintf(stderr, \"%s:  mid   dlsym:  dlsym = %p\\n\", MYNAME, the_dlsym);\n\n#if 0\n    if (handle == RTLD_NEXT) { handle = RTLD_DEFAULT; }\n#endif\n\n    void *ans = the_dlsym(handle, symbol);\n\n    if (ans == NULL) {\n\terr(1, \"the_dlsym failed\");\n    }\n\n    fprintf(stderr, \"%s:  exit  dlsym:  ans = %p\\n\", MYNAME, ans);\n\n    return ans;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-master-mteuum2hrp62uwy6o3knzku2vbnnowhs/spack-src/test/multi_agent_dlopen/monitor.c": "/*\n *  monitor.c  -->  libmon.so\n *\n *  Override dlopen() use dlsym(RTLD_NEXT).\n */\n\n#define _GNU_SOURCE  1\n\n#include <dlfcn.h>\n#include <err.h>\n#include <errno.h>\n#include <stdio.h>\n#include <gotcha/gotcha.h>\n\n#define MYNAME  \"libmon.so\"\n\ntypedef void *dlopen_fcn_t(const char *, int);\n\ngotcha_wrappee_handle_t reel_dlopen_handle;\n\nvoid *\nwrap_dlopen(const char *file, int flag)\n{\n    typeof(&wrap_dlopen) reel_dlopen = gotcha_get_wrappee(reel_dlopen_handle);\n    fprintf(stderr, \"ENTER WRAP: %p\\n\", reel_dlopen);\n    fprintf(stderr, \"%s:  enter dlopen:  file = %s\\n\", MYNAME, file);\n\n    void *ans = reel_dlopen ? (reel_dlopen)(file, flag) : NULL;\n    if(!ans){\n      fprintf(stderr, \"Real dlopen not found\\n\");\n    }\n    fprintf(stderr, \"%s:  exit  dlopen:  handle = %p\\n\", MYNAME, ans);\n\n    return ans;\n}\nvoid* opaque;\nstruct gotcha_binding_t binds[] = {\n  { \"dlopen\", wrap_dlopen, &reel_dlopen_handle}\n};\nvoid fix_things(){\n  reel_dlopen_handle = NULL;\n  gotcha_wrap(binds, 1, \"silly\");\n  typeof(&wrap_dlopen) reel_dlopen = gotcha_get_wrappee(reel_dlopen_handle);\n  fprintf(stderr, \"IMMEDIATE WRITE: %p\\n\", reel_dlopen);\n}\n__attribute__((constructor)) void startup_fix_things(){\n  fix_things(); \n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-master-mteuum2hrp62uwy6o3knzku2vbnnowhs/spack-src/test/multi_agent_dlopen/main.c": "/*\n *  Try dlopen(libm.so, ...) and call sin().\n */\n\n#include <dlfcn.h>\n#include <err.h>\n#include <errno.h>\n#include <math.h>\n#include <stdio.h>\n\n#define MYNAME  \"main\"\n\ntypedef double sin_fcn_t(double);\n\nint\nmain(int argc, char **argv)\n{\n    sin_fcn_t *sin_fcn = NULL;\n    double val = 4.0;\n    double ans = 0.0;\n\n    fprintf(stderr, \"%s:  val = %.6f\\n\", MYNAME, val);\n\n    void *handle = dlopen(\"libm.so\", RTLD_NOW);\n    if (handle == NULL) {\n\terr(1, \"dlopen failed\");\n    }\n\n    fprintf(stderr, \"%s:\\n\", MYNAME);\n\n    sin_fcn = dlsym(handle, \"sin\");\n    if (sin_fcn == NULL) {\n\terr(1, \"dlsym failed\");\n    }\n\n    fprintf(stderr, \"%s:\\n\", MYNAME);\n\n    ans = (*sin_fcn)(val);\n\n    fprintf(stderr, \"%s:  ans = %.6f\\n\", MYNAME, ans);\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-master-mteuum2hrp62uwy6o3knzku2vbnnowhs/spack-src/test/multi_agent_dlopen/CMakeLists.txt": "set(CMAKE_C_FLAGS \"-g -O -fPIC\")\nadd_library(multi_agent_sym SHARED dlsym.c)\nadd_library(multi_agent_mon SHARED monitor.c)\nadd_executable(multi_agent_main main.c)\ntarget_link_libraries(multi_agent_main dl)\ntarget_link_libraries(multi_agent_mon dl gotcha)\ngotcha_add_test(multi_agent_dlopen multi_agent_main)\nenvironment_add(multi_agent_dlopen TEST \"LD_PRELOAD=${CMAKE_CURRENT_BINARY_DIR}/libmulti_agent_sym.so:${CMAKE_CURRENT_BINARY_DIR}/libmulti_agent_mon.so GOTCHA_DEBUG=3 LIBNUM_DIR=${CMAKE_CURRENT_BINARY_DIR}\")\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-master-mteuum2hrp62uwy6o3knzku2vbnnowhs/spack-src/.git/objects/pack/pack-84c37b69469a1825e1d704b66b0cbda4e5987916.idx",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-master-mteuum2hrp62uwy6o3knzku2vbnnowhs/spack-src/.git/objects/pack/pack-84c37b69469a1825e1d704b66b0cbda4e5987916.pack"
    ],
    "total_files": 108
}