{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/AttachDetach/secondary_attach_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n   Test the scenario when Pin attaches to an application, using PIN_AttachProbed API,\n   which one of its secondary thread is a zombie thread .\n   Pin wouldn't attach to the zombie thread and wouldn't give a thread detach callbacks on detach\n   to the zombie thread.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <pthread.h>\n#include <sstream>\n#include <fstream>\n#include <sys/wait.h>\n#include \"zombie_utils.h\"\n\nEXPORT_SYM bool AfterAttach1();\n\nconst char * fileName;\n\nconst char *imageToLoad;\n\npid_t zombieThreadPid;\n\npid_t parentPid;\n\nbool AfterAttach1()\n{\n    // Pin sets an analysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\n// This function is invoked when the secondary thread starts to execute.\nvoid* SecondaryThreadMain(void* v) \n{\n    void *handle = dlopen(imageToLoad, RTLD_LAZY); \n\n    if(!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", imageToLoad, dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    pthread_exit(0);  \n}\n\n// Expected argv arguments:\n// [1] pin executable\n// [2] -slow_assert\n// [3] tool\n// [4] imageName \n// [5] output file\t\n\nint main(int argc, char** argv)\n{\n    if(argc!=6)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n\n    imageToLoad= argv[4];\n    fileName = argv[5];\n    parentPid = getpid();\n    pid_t child = fork();\n    \n    if (child < 0)\n    {\n        perror(\"Fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    {\n        // Pin sets an analysis function here to notify the application\n        // when Pin attaches to it in the first attach session.\n        while(!AfterAttach1())\n        {\n            sleep(1);\n        }\n\n        NotifyTestType(TEST_TYPE_SECONDARY_THREAD_ZOMBIE_IN_REATTACH);\n\n        pthread_t tid;\n        pthread_create(&tid, NULL, SecondaryThreadMain, NULL);\n        fprintf(stderr, \"APP: tid of zombie: %d\\n\", (int)tid);\n        \n        while(1);\n    }\n    \n    if (child == 0)\n    {\n        // Inside child \n        pid_t second_child_pid = fork ();\n        \n        if (second_child_pid < 0)\n        {\n            perror(\"Fork failed while creating application process\");\n            exit(RES_FORK_FAILED);\n        }\n\n        if (second_child_pid > 0)\n        {\n            // Inside parent 2\n            waitpid(second_child_pid, 0, 0); // wait until Pin is injected to the application process.\n            exit(RES_SUCCESS);\n        }\n        else\n        { \n            // Inside child 2\n            char attachPid[MAX_SIZE];\n            snprintf(attachPid, MAX_SIZE , \"%d\", parentPid);\n\n            // Pin attaches to the application.\n            execl(argv[1], argv[1], argv[2], \"-probe\",\"-pid\", attachPid,  \"-t\",  argv[3], \"-o\", argv[5], NULL); // never return\n            perror(\"execl failed while trying to attach Pin to the application\\n\");\n            exit(RES_EXEC_FAILED);\n        }\n    }\n\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/AttachDetach/reattach_probed_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n// @ORIGINAL_AUTHOR: Elena Demikhovsky\n\n/*! @file\n *  Test detaching - reattach Pin on Linux\n *  The application creates threads in a loop. Each thread does some work and exits.\n *  The process in endless, expected to be stopped by tool.\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <linux/unistd.h>\n#include <math.h>\n#ifdef TARGET_ANDROID\n#include <sys/syscall.h>\n#endif\n\n#define NTHREADS 20\n\n/*\n * Get thread Id\n */\npid_t GetTid()\n{\n     return syscall(__NR_gettid);\n}\n\n# define TLS_GET_GS_REG() \\\n  ({ int __seg; __asm (\"movw %%gs, %w0\" : \"=q\" (__seg)); __seg & 0xffff; })\n\n\nvolatile bool loop1, loop2 ;\nvoid * thread_func (void *arg)\n{    \n    while (loop2)\n    {\n        void *space = malloc(300);\n        //sleep(1);\n        free(space);\n    }\n    return 0;\n\n}\n\ntypedef  double (*DLL_FUNC)(double x);\ntypedef  int (*DLL_INT_FUNC)(int x);\n\n\nvoid * thread_dlopen_func (void *arg)\n{    \n    double number = 0.2;\n    double calculatedValue = 0;\n    while (loop1)\n    {\n        void *handle = dlopen(\"libmy_dll.so\", RTLD_LAZY);\n        if (handle)\n        {\n            DLL_FUNC fptr = (DLL_FUNC)dlsym(handle, \"my_dll_sin\");\n            calculatedValue += (*fptr)(number);\n            \n            //sleep(1);\n            dlclose(handle);\n        }\n        else \n        {\n            fprintf(stderr, \"error opening my_dll.so, thread %d\\n\", GetTid());\n            exit(-1);\n        } \n        number += 0.01;\n    }\n        \n    return 0;\n}\n\nint main (int argc, char *argv[])\n{\n    unsigned long gs_val = TLS_GET_GS_REG();\n    while (1)\n    {\n        loop1 = true;\n        loop2 = true;\n        pthread_t h[NTHREADS];\n        \n        pthread_create (&h[0], 0, thread_dlopen_func, 0);\n        for (unsigned long i = 1; i < NTHREADS; i++)\n        {\n            pthread_create (&h[i], 0, thread_func, 0);\n        }\n        sleep(1);\n\n        loop1 = false;\n        loop2 = false;\n\n        for (unsigned long i = 0; i < NTHREADS; i++)\n        {\n            pthread_join (h[i], 0);\n        }\n    }    \n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/AttachDetach/attachReattachThreadDetachCallbacks_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <pthread.h>\n\n#define EXPORT_SYM extern \"C\"\n\n#define NTHREADS 20\n\nvolatile bool loop;\n\nEXPORT_SYM bool AfterAttach1();\n\nEXPORT_SYM bool AfterAttach2();\n\nstatic int MAX_SIZE = 128; /*maximum line size*/\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_FORK_FAILED,      // 1\n    RES_EXEC_FAILED,      // 2\n    RES_LOAD_FAILED,      // 3\n    RES_INVALID_ARGS      // 4\n};\n\nbool AfterAttach1()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nvoid * thread_func (void *arg)\n{    \n    while (loop)\n    {\n         sched_yield();\n    }\n    return 0;\n}\n\n/*\n    Expected argv arguments:\n    [1] pin executable\n    [2] \"slow asserts\"\n    [3] tool\n    [4] output file\n    [5] First imageName\n\t[6] Second imageName\n*/\nint main(int argc, char** argv)\n{\n    fprintf(stderr, \"Start main\\n\");\n\t\n    if(argc!=7)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n\n    loop  = true;\n\n    int ret_val;\n    pthread_t h[NTHREADS];\n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        ret_val= pthread_create (&h[i], 0, thread_func, 0);\n        if(ret_val) \n        {\n            perror(\"ERROR, pthread_create failed\");\n            exit(1);\n        }\n    }\n\t\n    pid_t parentPid = getpid();\n    pid_t child = fork();\n    if (child < 0)\n    {\n        perror(\"Fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    { \n\t\twhile(!AfterAttach1())\n        {\n            sleep(1);\n        }\n        \n\t\tvoid *handle = dlopen(argv[5], RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n        \n\t\twhile(!AfterAttach2())\n        {\n            sleep(1);\n        }\n\n        handle = dlopen(argv[6], RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[2], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n        \n        while(1)\n        {\n            // expected to be stopped by tool.\n            sleep(1);\n        }\n    }\n\t\n    if ( child == 0 )\n    {\n        // Inside child\n        char attachPid[MAX_SIZE];\n        snprintf(attachPid ,MAX_SIZE , \"%d\", parentPid);\n        execl(argv[1],argv[2],\"-pid\", attachPid, \"-probe\", \"-t\",  argv[3], \"-o\", argv[4], NULL);\n        perror(\"execl failed while trying to attach Pin to the application\\n\");\n        exit(RES_EXEC_FAILED);\n    }\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/AttachDetach/detach_probed_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n// @ORIGINAL_AUTHOR: Elena Demikhovsky\n\n/*! @file\n *  Test detaching Pin from running process on Linux\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <linux/unistd.h>\n#ifdef TARGET_ANDROID\n#include <sys/syscall.h>\n#endif\n\n#define NTHREADS 20\n\n/*\n * Get thread Id\n */\npid_t GetTid()\n{\n     return syscall(__NR_gettid);\n}\n\nextern \"C\" void TellPinToDetach(unsigned long *updateWhenReady)\n{\n    return;\n}\n\nvolatile bool loop2 = true;\nvoid * thread_func (void *arg)\n{    \n    while (loop2)\n    {\n        void *space = malloc(300);\n        sleep(1);\n        free(space);\n    }\n    return 0;\n\n}\n\nvolatile bool loop1 = true;\ntypedef  double (*SIN_FUNC)(double x);\n\nvoid * thread_dlopen_func (void *arg)\n{    \n\tdouble number = 0.2;\n    while (loop1)\n    {\n        void *handle = dlopen(\"libm.so\", RTLD_LAZY);\n        if (handle)\n        {\n            SIN_FUNC sin_fptr = (SIN_FUNC)dlsym(handle, \"sin\");\n            if (sin_fptr)\n            {\n                double val = (*sin_fptr)(number);\n                printf(\"val = %.4f\\n\", val);\n            }\n            sleep(2);\n            dlclose(handle);\n        }\n\t\tnumber += 0.01;\n    }\n        \n    return 0;\n\n}\n\nint main (int argc, char *argv[])\n{\n    pthread_t h[NTHREADS];\n    \n    pthread_create (&h[0], 0, thread_dlopen_func, 0);\n    for (unsigned long i = 1; i < NTHREADS; i++)\n    {\n        pthread_create (&h[i], 0, thread_func, 0);\n    }\n    \n\tunsigned long pinDetached = false;\n    TellPinToDetach(&pinDetached);\n    \n\twhile (!pinDetached)\n\t{\n    \tsleep(2);\n\t}\n    \n    loop1 = false;\n    loop2 = false;\n    \n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        pthread_join (h[i], 0);\n    }\n    printf(\"All threads exited. The test PASSED\\n\");    \n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/AttachDetach/main_attach_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n   Test the scenario where Pin tries to reattach to an application, using PIN_AttachProbed API,\n   when the main thread of the application is a zombie thread.\n   Pin wouldn't attach to the application in this scenario. \n   Instead, Pin will give a message to the user notifying why Pin didn't attach to the application and the\n   application will continue to run natively\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <fstream>\n#include <sstream>\n#include \"zombie_utils.h\"\n\n\nEXPORT_SYM bool AfterAttach1();\n\npid_t zombieThreadPid;\n\nconst char * fileName;\n\nconst char *imageToLoad;\n\nbool AfterAttach1()\n{\n    // Pin sets an analysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\n// This function is invoked when the secondary thread starts execution.\nvoid* SecondaryThreadMain(void* v) \n{\n    // Wait until Pin notifies the application that it can't reattach to it since\n    // the main thread of the application is a zombie thread.\n    while(!NotifyUserPinUnableToAttach(fileName)) sleep(1);\n    pthread_exit(0);  \n}\n\n// Expected argv arguments:\n// [1] pin executable\n// [2] -slow_assert\n// [3] tool\n// [4] imageName \n// [5] output file\t\nint main(int argc, char** argv)\n{\n    if(argc!=6)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n\n    imageToLoad= argv[4];\n    fileName = argv[5];\n    zombieThreadPid = getpid();\n    pid_t child = fork();\n    \n    if (child < 0)\n    {\n        perror(\"Fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    { \n        // Pin sets an analysis function here to notify the application\n        // when Pin attaches to it in the first attach session.\n        while(!AfterAttach1())\n        {\n            sleep(1);\n        }\n\n        NotifyTestType(TEST_TYPE_MAIN_THREAD_ZOMBIE_IN_REATTACH);\n\n        NotifyZombiePid(zombieThreadPid);\n\n        pthread_t tid;\n        pthread_create(&tid, NULL, SecondaryThreadMain, NULL);\n\n        // When the image is loaded into the memory,\n        // the tool instructs Pin to detach from the application.\n        void *handle = dlopen(imageToLoad, RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", imageToLoad, dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }  \n\n        // After calling to thread_exit(0) function, the main thread is going to become a zombie thread.\n        // Pin should not attach to the application.\n        // Instead, Pin should give a message to the user notifying why Pin didn't attach to the application.\n        pthread_exit(0);\n    }\n\n    if (child == 0)\n    {\n        // Inside child 1\n        pid_t second_child_pid = fork ();\n        \n        if (second_child_pid < 0)\n        {\n            perror(\"Fork failed while creating application process\");\n            exit(RES_FORK_FAILED);\n        }\n\n        if (second_child_pid > 0)\n        {\n            // Inside parent 2\n            waitpid(second_child_pid, 0, 0); // wait until Pin is injected to the application process.\n            exit(RES_SUCCESS);\n        }\n        else\n        { \n            //Inside child 2\n            char attachPid[MAX_SIZE];\n            snprintf(attachPid, MAX_SIZE , \"%d\", zombieThreadPid);\n\n            // Pin  attaches to the application.\n            // never return\n            execl(argv[1], argv[1], argv[2], \"-probe\", \"-pid\", attachPid, \"-t\",  argv[3],\"-o\", argv[5], NULL);\n            perror(\"execl failed while trying to attach Pin to the application\\n\");\n            exit(RES_EXEC_FAILED);\n        }\n    } \n\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/AttachDetach/launchReattachThreadDetachCallbacks_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <pthread.h>\n\n#define EXPORT_SYM extern \"C\"\n\n#define NTHREADS 20\n\n\nvolatile bool loop;\n\nEXPORT_SYM bool AfterAttach2();\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_LOAD_FAILED,      // 1\n    RES_INVALID_ARGS      // 2    \n};\n\n\n\nvoid * thread_func (void *arg)\n{    \n    while (loop)\n    {\n         sched_yield();\n    }\n    return 0;\n}\n\n/*\n    Expected argv arguments:\n    [1]\tFirst image to load\t\n    [2]\tSecond image to load\n*/\nint main (int argc, char *argv[])\n{\n    if(argc!=3)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n\n    loop = true;\n\t\n    pthread_t h[NTHREADS];\n    int ret_val;\n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        ret_val= pthread_create (&h[i], 0, thread_func, 0);\n        if(ret_val) \n        {\n            perror(\"ERROR, pthread_create failed\");\n            exit(1);\n        }\n    }\n\n\tvoid *handle = dlopen(argv[1], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n    \n\twhile(!AfterAttach2())\n    {\n        sleep(1);\n    }\n    \n    handle = dlopen(argv[2], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[2], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        pthread_join (h[i], 0);\n    }\n\n    return RES_SUCCESS;\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Replay/ia32_cross_os_replay.reference": "[ 0]+ /disk/PinTools/Utils/obj-ia32/cp-pin    \nFunction 'main' loaded at 8048d90\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n[ 1]+ /lib/ld-linux.so.2                      \nFunction 'rtld_lock_default_unlock_recursive' loaded at 555558c0\nFunction 'relocate_doit' loaded at 55556770\nFunction 'fillin_rpath' loaded at 5555a3c0\nFunction 'decompose_rpath' loaded at 5555c9f0\nFunction 'do_lookup_x' loaded at 5555e380\nFunction '_dl_map_object_deps' loaded at 55560e40\nFunction '_dl_sort_fini' loaded at 55562ba0\nFunction 'match_symbol' loaded at 55563930\nFunction '_dl_next_tls_modid' loaded at 55564e10\nFunction '_dl_tls_setup' loaded at 55565940\nFunction '_dl_runtime_resolve' loaded at 55567930\nFunction '__assert_fail' loaded at 55568870\nFunction 'calloc' loaded at 55568f60\nFunction 'profil_counter' loaded at 55569560\nFunction '__lseek' loaded at 555698d0\nFunction '__madvise' loaded at 55569e50\nFunction 'strlen' loaded at 5556a270\nFunction '__i686.get_pc_thunk.cx' loaded at 5556ae47\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n[ 2]+ /usr/lib/libstdc++.so.6                 \nFunction '_ZN9__gnu_cxx17__pool_alloc_base12_M_get_mutexEv' loaded at 56d760f0\nFunction '_ZN9__gnu_cxx6__poolILb1EE13_M_initializeEPFvPvE' loaded at 56d774d0\nFunction '_ZNKSt7codecvtIwc11__mbstate_tE16do_always_noconvEv' loaded at 56d78800\nFunction '_ZNSt7codecvtIcc11__mbstate_tEC1Ej' loaded at 56d78c10\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE7_M_copyEPwPKwj' loaded at 56d78f70\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE15_M_check_lengthEjjPKc' loaded at 56d791c0\nFunction '_ZNKSt14basic_ofstreamIwSt11char_traitsIwEE7is_openEv' loaded at 56d79900\nFunction '_ZStlsIdcSt11char_traitsIcEERSt13basic_ostreamIT0_T1_ES6_RKSt7complexIT_E' loaded at 56d7a7f0\nFunction '_ZNKSt5ctypeIcE9do_narrowEPKcS2_cPc' loaded at 56d7bdf0\nFunction '_ZNSt5ctypeIcED2Ev' loaded at 56d7c340\nFunction '_ZNSt12ctype_bynameIwEC2EPKcj' loaded at 56d7c880\nFunction '_ZN11__gnu_debug19_Safe_sequence_base7_M_swapERS0_' loaded at 56d7da10\nFunction '_ZSt18__throw_bad_typeidv' loaded at 56d7de60\nFunction '_ZNSt12out_of_rangeD0Ev' loaded at 56d7e0f0\nFunction '_ZSt23__throw_underflow_errorPKc' loaded at 56d7e480\nFunction '_ZNSt8ios_base6xallocEv' loaded at 56d7edd0\nFunction '_ZNSt8ios_base7failureC1ERKSs' loaded at 56d7f3c0\nFunction '_ZNSt8ios_base7_M_initEv' loaded at 56d808d0\nFunction '_ZNSt6localeC2ERKS_' loaded at 56d80b10\nFunction '_ZNSt6locale5_ImplD2Ev' loaded at 56d81310\nFunction '_ZNSt6locale5_ImplC2Ej' loaded at 56d81e00\nFunction '_ZNSt6localeC2ERKS_S1_i' loaded at 56d84170\nFunction '_ZNSt11logic_errorC2ERKSs' loaded at 56d86830\nFunction '_ZNSt13runtime_errorC2ERKSs' loaded at 56d86af0\nFunction '_ZNSt13runtime_errorD0Ev' loaded at 56d86e20\nFunction '_ZNSt12strstreambuf7_M_freeEPc' loaded at 56d870e0\nFunction '_ZNSt12strstreambuf9underflowEv' loaded at 56d87330\nFunction '_ZNSt12strstreambufC2EPaiS0_' loaded at 56d87c80\nFunction '_ZNSt12strstreambufC1EPKhi' loaded at 56d88450\nFunction '_ZNSt10ostrstreamD2Ev' loaded at 56d88cb0\nFunction '_ZNSt10istrstreamD1Ev' loaded at 56d89480\nFunction '_ZNSt9strstreamD0Ev' loaded at 56d89bf0\nFunction '_ZSt18_Rb_tree_decrementPKSt18_Rb_tree_node_base' loaded at 56d8a2d0\nFunction '_ZNSaIwED1Ev' loaded at 56d8a8c0\nFunction '_ZNSt13basic_filebufIcSt11char_traitsIcEE13_M_set_bufferEi' loaded at 56d8b6c0\nFunction '_ZNSt13basic_filebufIwSt11char_traitsIwEE27_M_allocate_internal_bufferEv' loaded at 56d8b8b0\nFunction '_ZNSt13basic_filebufIwSt11char_traitsIwEE9pbackfailEj' loaded at 56d8be20\nFunction '_ZNSt13basic_filebufIcSt11char_traitsIcEE6xsgetnEPci' loaded at 56d8d060\nFunction '_ZNSt14basic_ifstreamIwSt11char_traitsIwEE7is_openEv' loaded at 56d8e080\nFunction '_ZNSt13basic_filebufIwSt11char_traitsIwEED0Ev' loaded at 56d8e980\nFunction '_ZNSt13basic_filebufIcSt11char_traitsIcEE9showmanycEv' loaded at 56d8f250\nFunction '_ZNSt14basic_ofstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode' loaded at 56d8f860\nFunction '_ZNSt14basic_ofstreamIwSt11char_traitsIwEEC2Ev' loaded at 56d8fe60\nFunction '_ZNSt14basic_ofstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode' loaded at 56d904d0\nFunction '_ZNSt14basic_ifstreamIcSt11char_traitsIcEEC1Ev' loaded at 56d90d40\nFunction '_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev' loaded at 56d91430\nFunction '_ZTv0_n12_NSt13basic_fstreamIcSt11char_traitsIcEED0Ev' loaded at 56d91dc0\nFunction '_ZNSt13basic_fstreamIwSt11char_traitsIwEED2Ev' loaded at 56d92260\nFunction '_ZNKSt9basic_iosIwSt11char_traitsIwEE7rdstateEv' loaded at 56d93680\nFunction '_ZNSt9basic_iosIcSt11char_traitsIcEEC1Ev' loaded at 56d938f0\nFunction '_ZNSt9basic_iosIcSt11char_traitsIcEED2Ev' loaded at 56d93c00\nFunction '_ZNKSt9basic_iosIwSt11char_traitsIwEE3badEv' loaded at 56d93fe0\nFunction '_ZNSt9basic_iosIwSt11char_traitsIwEE10exceptionsESt12_Ios_Iostate' loaded at 56d941d0\nFunction '_ZNSt9basic_iosIwSt11char_traitsIwEE5imbueERKSt6locale' loaded at 56d944a0\nFunction '_ZNSt14basic_iostreamIwSt11char_traitsIwEEC1Ev' loaded at 56d94f60\nFunction '_ZNSdC1Ev' loaded at 56d95280\nFunction '_ZNSirsEPFRSt8ios_baseS0_E' loaded at 56d954d0\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEErsEPFRSt8ios_baseS4_E' loaded at 56d95600\nFunction '_ZStrsISt11char_traitsIcEERSt13basic_istreamIcT_ES5_Pa' loaded at 56d958a0\nFunction '_ZStrsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_St12_Setiosflags' loaded at 56d95b40\nFunction '_ZTv0_n12_NSt13basic_istreamIwSt11char_traitsIwEED1Ev' loaded at 56d95e20\nFunction '_ZStrsIcSt11char_traitsIcEERSt13basic_istreamIT_T0_ES6_RS3_' loaded at 56d96650\nFunction '_ZNSi3getERSt15basic_streambufIcSt11char_traitsIcEE' loaded at 56d96fa0\nFunction '_ZNSirsERy' loaded at 56d97a40\nFunction '_ZSt2wsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_' loaded at 56d987a0\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEE3getERSt15basic_streambufIwS1_Ew' loaded at 56d99390\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEErsERf' loaded at 56d99e80\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEE6sentryC2ERS2_b' loaded at 56d9abf0\nFunction '_ZNKSt10moneypunctIcLb0EE13thousands_sepEv' loaded at 56d9c540\nFunction '_ZNKSt10moneypunctIcLb0EE14do_frac_digitsEv' loaded at 56d9c6c0\nFunction '_ZNKSt10moneypunctIcLb1EE10pos_formatEv' loaded at 56d9c890\nFunction '_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' loaded at 56d9cb50\nFunction '_ZNSt16__numpunct_cacheIcEC1Ej' loaded at 56d9cda0\nFunction '_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRe' loaded at 56d9d200\nFunction '_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPKv' loaded at 56d9d5f0\nFunction '_ZNSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEEC2Ej' loaded at 56d9d850\nFunction '_ZNKSt8messagesIcE4openERKSsRKSt6locale' loaded at 56d9db80\nFunction '_ZNSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED0Ev' loaded at 56d9dfc0\nFunction '_ZNSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEED1Ev' loaded at 56d9e1e0\nFunction '_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED2Ev' loaded at 56d9e3f0\nFunction '_ZSt9has_facetISt8numpunctIcEEbRKSt6locale' loaded at 56d9e810\nFunction '_ZSt9use_facetISt10moneypunctIcLb0EEERKT_RKSt6locale' loaded at 56d9ebb0\nFunction '_ZNSt7collateIcEC2Ej' loaded at 56d9ef10\nFunction '_ZNSt8messagesIcED1Ev' loaded at 56d9f290\nFunction '_ZNSt16__numpunct_cacheIcED2Ev' loaded at 56d9f6d0\nFunction '_ZNSt15numpunct_bynameIcED2Ev' loaded at 56d9fb30\nFunction '_ZNSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' loaded at 56d9ffb0\nFunction '_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' loaded at 56da0310\nFunction '_ZNSt15messages_bynameIcEC2EPKcj' loaded at 56da07c0\nFunction '_ZNSt11__timepunctIcEC2Ej' loaded at 56da0fc0\nFunction '_ZNKSt8numpunctIcE12do_falsenameEv' loaded at 56da12f0\nFunction '_ZNSt10moneypunctIcLb1EEC2EP15__locale_structPKcj' loaded at 56da17f0\nFunction '_ZNKSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPK2tmPKcSB_' loaded at 56da1c80\nFunction '_ZNSt15numpunct_bynameIcEC1EPKcj' loaded at 56da2180\nFunction '_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE14do_get_weekdayES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm' loaded at 56da3b00\nFunction '_ZNKSt7collateIcE12do_transformEPKcS2_' loaded at 56da68d0\nFunction '_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' loaded at 56dac390\nFunction '_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE15_M_insert_floatIeEES3_S3_RSt8ios_baseccT_' loaded at 56daeb10\nFunction '_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE6do_putES3_RSt8ios_basecm' loaded at 56db0310\nFunction '_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRm' loaded at 56db2f10\nFunction '_ZStlsIcSt11char_traitsIcESaIcEERSt13basic_ostreamIT_T0_ES7_RKSbIS4_S5_T1_E' loaded at 56db5520\nFunction '_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEPFRS2_S3_E' loaded at 56db5a10\nFunction '_ZNSoC2EPSt15basic_streambufIcSt11char_traitsIcEE' loaded at 56db5ba0\nFunction '_ZNSoC1Ev' loaded at 56db5e20\nFunction '_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_' loaded at 56db6470\nFunction '_ZNSoD2Ev' loaded at 56db6a40\nFunction '_ZNSolsEs' loaded at 56db6d50\nFunction '_ZNSo5writeEPKci' loaded at 56db7af0\nFunction '_ZNSolsEx' loaded at 56db8a50\nFunction '_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEi' loaded at 56db9e90\nFunction '_ZSt4endsIwSt11char_traitsIwEERSt13basic_ostreamIT_T0_ES6_' loaded at 56dbb170\nFunction '_ZNKSt19basic_ostringstreamIcSt11char_traitsIcESaIcEE5rdbufEv' loaded at 56dbba10\nFunction '_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE6setbufEPwi' loaded at 56dbbd40\nFunction '_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE3strERKSbIwS1_S2_E' loaded at 56dbc7f0\nFunction '_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode' loaded at 56dbcc90\nFunction '_ZNKSt18basic_stringstreamIcSt11char_traitsIcESaIcEE3strEv' loaded at 56dbd7f0\nFunction '_ZNKSt19basic_istringstreamIwSt11char_traitsIwESaIwEE3strEv' loaded at 56dbdfc0\nFunction '_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEED2Ev' loaded at 56dbe670\nFunction '_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode' loaded at 56dbee50\nFunction '_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode' loaded at 56dbf9a0\nFunction '_ZTv0_n12_NSt19basic_istringstreamIwSt11char_traitsIwESaIwEED0Ev' loaded at 56dc0180\nFunction '_ZTv0_n12_NSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev' loaded at 56dc0a90\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEE10pubseekposESt4fposI11__mbstate_tESt13_Ios_Openmode' loaded at 56dc12e0\nFunction '_ZNKSt15basic_streambufIcSt11char_traitsIcEE4pptrEv' loaded at 56dc1420\nFunction '_ZNSt15basic_streambufIwSt11char_traitsIwEE10pubseekoffExSt12_Ios_SeekdirSt13_Ios_Openmode' loaded at 56dc14f0\nFunction '_ZNKSt15basic_streambufIwSt11char_traitsIwEE5pbaseEv' loaded at 56dc1680\nFunction '_ZNSt15basic_streambufIwSt11char_traitsIwEEaSERKS2_' loaded at 56dc1740\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEEC1Ev' loaded at 56dc1a40\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEED1Ev' loaded at 56dc1ce0\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEE7seekposESt4fposI11__mbstate_tESt13_Ios_Openmode' loaded at 56dc1e40\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEE5sputcEc' loaded at 56dc2150\nFunction '_ZNKSs7_M_dataEv' loaded at 56dc26e0\nFunction '_ZNKSs4sizeEv' loaded at 56dc2820\nFunction '_ZNSs4_Rep15_M_set_sharableEv' loaded at 56dc28e0\nFunction '_ZNKSs5emptyEv' loaded at 56dc2d70\nFunction '_ZNKSs16find_last_not_ofEcj' loaded at 56dc3010\nFunction '_ZNKSs13find_first_ofEcj' loaded at 56dc33e0\nFunction '_ZNKSs4rendEv' loaded at 56dc3740\nFunction '_ZNKSs7compareEjjRKSs' loaded at 56dc3b60\nFunction '_ZNSsC2EPKcjRKSaIcE' loaded at 56dc4040\nFunction '_ZNSsC1IPcEET_S1_RKSaIcE' loaded at 56dc4470\nFunction '_ZNSs6appendEPKcj' loaded at 56dc4a00\nFunction '_ZNSs6assignEPKc' loaded at 56dc5100\nFunction '_ZNSs6insertEN9__gnu_cxx17__normal_iteratorIPcSsEEjc' loaded at 56dc54e0\nFunction '_ZNSs7_M_leakEv' loaded at 56dc59b0\nFunction '_ZNSsD2Ev' loaded at 56dc5d10\nFunction '_ZNSs7replaceEjjPKc' loaded at 56dc63b0\nFunction '_ZNSt8valarrayIjED2Ev' loaded at 56dc6700\nFunction '_ZNKSt10moneypunctIwLb0EE13positive_signEv' loaded at 56dc6dc0\nFunction '_ZNKSt10moneypunctIwLb1EE13decimal_pointEv' loaded at 56dc6f70\nFunction '_ZNKSt10moneypunctIwLb1EE16do_thousands_sepEv' loaded at 56dc7100\nFunction '_ZNKSt8numpunctIwE13decimal_pointEv' loaded at 56dc74b0\nFunction '_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRt' loaded at 56dc76f0\nFunction '_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE3putES3_RSt8ios_basewb' loaded at 56dc7b10\nFunction '_ZNKSt11__timepunctIwE20_M_date_time_formatsEPPKw' loaded at 56dc7ea0\nFunction '_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10date_orderEv' loaded at 56dc8130\nFunction '_ZNKSt8messagesIwE8do_closeEi' loaded at 56dc8430\nFunction '_ZNSt8time_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED0Ev' loaded at 56dc87b0\nFunction '_ZNSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEED1Ev' loaded at 56dc89d0\nFunction '_ZSt9has_facetISt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEEbRKSt6locale' loaded at 56dc8cb0\nFunction '_ZSt9has_facetISt7codecvtIwc11__mbstate_tEEbRKSt6locale' loaded at 56dc9110\nFunction '_ZSt9use_facetISt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEERKT_RKSt6locale' loaded at 56dc9470\nFunction '_ZNSt14codecvt_bynameIwc11__mbstate_tED1Ev' loaded at 56dc97d0\nFunction '_ZNSt15messages_bynameIwED0Ev' loaded at 56dc9bb0\nFunction '_ZNSt18__moneypunct_cacheIwLb1EED1Ev' loaded at 56dca010\nFunction '_ZNSt17moneypunct_bynameIwLb1EED1Ev' loaded at 56dca3f0\nFunction '_ZNSt8numpunctIwEC1EP15__locale_structj' loaded at 56dca870\nFunction '_ZNSt18__moneypunct_cacheIwLb0EEC2Ej' loaded at 56dcabf0\nFunction '_ZNSt17__timepunct_cacheIwEC1Ej' loaded at 56dcb110\nFunction '_ZNKSt10moneypunctIwLb0EE16do_negative_signEv' loaded at 56dcb8b0\nFunction '_ZNSt10moneypunctIwLb1EEC1EPSt18__moneypunct_cacheIwLb1EEj' loaded at 56dcbe10\nFunction '_ZNSt8messagesIwEC1EP15__locale_structPKcj' loaded at 56dcc1f0\nFunction '_ZNSt15time_get_bynameIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEC2EPKcj' loaded at 56dcc8d0\nFunction '_ZNSt17moneypunct_bynameIwLb0EEC2EPKcj' loaded at 56dccd40\nFunction '_ZNSt14collate_bynameIwEC2EPKcj' loaded at 56dcf9b0\nFunction '_ZNKSt9money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb1EEES3_S3_RSt8ios_basewRKSbIwS2_SaIwEE' loaded at 56dd1030\nFunction '_ZNKSt9money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10_M_extractILb0EEES3_S3_S3_RSt8ios_baseRSt12_Ios_IostateRSs' loaded at 56dd4110\nFunction '_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE13_M_insert_intIxEES3_S3_RSt8ios_basewT_' loaded at 56dd7b60\nFunction '_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRx' loaded at 56dda050\nFunction '_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_putES3_RSt8ios_basewb' loaded at 56ddcfc0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE5beginEv' loaded at 56ddd810\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE4_Rep12_M_is_sharedEv' loaded at 56ddd8e0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE4findEPKwjj' loaded at 56dddca0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE17find_first_not_ofEwj' loaded at 56dddf40\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE13find_first_ofEPKwjj' loaded at 56dde330\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE12find_last_ofEPKwj' loaded at 56dde6a0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE7compareEjjRKS2_jj' loaded at 56dde9c0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_jjRKS1_' loaded at 56ddefa0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEEC1EPKwRKS1_' loaded at 56ddf3b0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE9push_backEw' loaded at 56ddf8d0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEED2Ev' loaded at 56ddfe30\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPwS2_EEw' loaded at 56de0420\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE6insertEjRKS2_jj' loaded at 56de0910\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE6rbeginEv' loaded at 56de0c30\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE7replaceEjjPKw' loaded at 56de1210\nFunction '_ZNKSt7codecvtIwc11__mbstate_tE9do_lengthERS0_PKcS4_j' loaded at 56de15e0\nFunction '_ZNKSt5ctypeIwE11do_scan_notEtPKwS2_' loaded at 56de1dc0\nFunction '_ZNKSt5ctypeIwE10do_toupperEw' loaded at 56de21e0\nFunction '_ZNSt10moneypunctIwLb0EED2Ev' loaded at 56de2ab0\nFunction '_ZNSt10moneypunctIcLb0EE24_M_initialize_moneypunctEP15__locale_structPKc' loaded at 56de3090\nFunction '_ZNSt8numpunctIwE22_M_initialize_numpunctEP15__locale_struct' loaded at 56de4390\nFunction '_ZNSt12__basic_fileIcE4syncEv' loaded at 56de5a80\nFunction '_ZNSt12__basic_fileIcE6xsgetnEPci' loaded at 56de5f30\nFunction '_ZdlPvRKSt9nothrow_t' loaded at 56de62c0\nFunction '__cxa_begin_catch' loaded at 56de66c0\nFunction '__cxa_call_unexpected' loaded at 56de6d30\nFunction '__cxa_guard_release' loaded at 56de7630\nFunction '__cxa_pure_virtual' loaded at 56de7970\nFunction '_ZN10__cxxabiv117__class_type_infoD0Ev' loaded at 56de7b30\nFunction '_ZNSt10bad_typeidD1Ev' loaded at 56de7d50\nFunction '_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_' loaded at 56de8060\nFunction '_ZN10__cxxabiv117__pbase_type_infoD2Ev' loaded at 56de8a60\nFunction '_ZN10__cxxabiv120__function_type_infoD0Ev' loaded at 56de8c70\nFunction '_ZNK10__cxxabiv119__pointer_type_info15__pointer_catchEPKNS_17__pbase_type_infoEPPvj' loaded at 56de8ef0\nFunction '__cxa_vec_new' loaded at 56de95e0\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n[ 3]+ /lib/libm.so.6                          \nFunction '__i686.get_pc_thunk.bx' loaded at 56e2e4c7\nFunction 'fegetenv' loaded at 56e30a90\nFunction '__ieee754_asin' loaded at 56e30db0\nFunction '__ieee754_y0' loaded at 56e314e0\nFunction '__ieee754_log10' loaded at 56e32c10\nFunction 'cbrt' loaded at 56e335f0\nFunction 'logb' loaded at 56e340d0\nFunction 'asin' loaded at 56e34840\nFunction 'hypot' loaded at 56e34e30\nFunction 'log10' loaded at 56e35560\nFunction 'nan' loaded at 56e35b00\nFunction 'creal' loaded at 56e35f10\nFunction 'csin' loaded at 56e36b80\nFunction 'clog10' loaded at 56e37d60\nFunction '__finite' loaded at 56e382b0\nFunction '__ieee754_atan2f' loaded at 56e386d0\nFunction 'ponef' loaded at 56e38ee0\nFunction '__ieee754_remainderf' loaded at 56e3a280\nFunction 'cbrtf' loaded at 56e3ab60\nFunction 'logbf' loaded at 56e3b4d0\nFunction 'asinf' loaded at 56e3b9e0\nFunction 'hypotf' loaded at 56e3bff0\nFunction 'log10f' loaded at 56e3c6c0\nFunction 'nanf' loaded at 56e3cc50\nFunction 'crealf' loaded at 56e3cf60\nFunction 'csinf' loaded at 56e3dab0\nFunction 'clog10f' loaded at 56e3e9d0\nFunction 'finitef' loaded at 56e3ee00\nFunction '__ieee754_atan2l' loaded at 56e3f320\nFunction 'pone' loaded at 56e3fff0\nFunction '__ieee754_remainderl' loaded at 56e41730\nFunction 'cbrtl' loaded at 56e41ca0\nFunction 'logbl' loaded at 56e42800\nFunction 'atan2l' loaded at 56e42db0\nFunction 'y0l' loaded at 56e43420\nFunction 'powl' loaded at 56e43b90\nFunction 'truncl' loaded at 56e44180\nFunction 'cabsl' loaded at 56e444c0\nFunction 'ctanl' loaded at 56e45540\nFunction 'fmal' loaded at 56e466c0\nFunction 'copysignl' loaded at 56e46ae0\nFunction '__divdc3' loaded at 56e48190\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n[ 4]+ /lib/libgcc_s.so.1                      \nFunction '__ashldi3' loaded at 56e5a8e0\nFunction '__subvsi3' loaded at 56e5abe0\nFunction '__ctzdi2' loaded at 56e5b030\nFunction '__mulxc3' loaded at 56e5bd70\nFunction '__fixdfdi' loaded at 56e5d020\nFunction '__udivmoddi4' loaded at 56e5d8e0\nFunction '_Unwind_GetGR' loaded at 56e5dcd0\nFunction '__register_frame_info' loaded at 56e60260\nFunction '.fini' loaded at 56e62104\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n[ 5]+ /lib/libc.so.6                          \nFunction 'gnu_get_libc_version' loaded at 56e79980\nFunction '__divdi3' loaded at 56e79ee0\nFunction '__gconv_close' loaded at 56e7adc0\nFunction '__gconv_find_transform' loaded at 56e7bab0\nFunction 'add_alias' loaded at 56e7c180\nFunction '__gconv_transform_ascii_internal' loaded at 56e7e080\nFunction '__gconv_translit_find' loaded at 56e81e20\nFunction '__gconv_lookup_cache' loaded at 56e82780\nFunction '_L_unlock_996' loaded at 56e838fc\nFunction 'rangecmp' loaded at 56e84640\nFunction '__duplocale' loaded at 56e85ad0\nFunction '__collseq_table_lookup' loaded at 56e85f30\nFunction 'isdigit' loaded at 56e86400\nFunction '__isascii_l' loaded at 56e866a0\nFunction 'ispunct_l' loaded at 56e86810\nFunction 'set_binding_values' loaded at 56e869d0\nFunction '__dcigettext' loaded at 56e87a10\nFunction 'dcngettext' loaded at 56e88220\nFunction '_nl_expand_alias' loaded at 56e89d40\nFunction 'new_exp_2' loaded at 56e8a920\nFunction 'finite' loaded at 56e8bd40\nFunction 'copysignf' loaded at 56e8c0f0\nFunction 'modfl' loaded at 56e8c3b0\nFunction '__libc_longjmp' loaded at 56e8c810\nFunction 'sigpending' loaded at 56e8cd90\nFunction 'sigpause' loaded at 56e8d1f0\nFunction 'sigaddset' loaded at 56e8d5a0\nFunction '__libc_current_sigrtmax_private' loaded at 56e8d8f0\nFunction 'sigset' loaded at 56e8de10\nFunction '_quicksort' loaded at 56e8e360\nFunction '_L_lock_22' loaded at 56e8f45a\nFunction 'exit' loaded at 56e8f530\nFunction 'div' loaded at 56e8f9d0\nFunction 'initstate' loaded at 56e8fef0\nFunction 'setstate_r' loaded at 56e90070\nFunction 'mrand48' loaded at 56e90610\nFunction 'jrand48_r' loaded at 56e908d0\nFunction 'strtoll' loaded at 56e90ca0\nFunction 'strtoull_l' loaded at 56e92390\nFunction '__strtof_l' loaded at 56e948e0\nFunction 'do_system' loaded at 56e99720\nFunction 'realpath' loaded at 56e99cf0\nFunction '__xpg_basename' loaded at 56e9b780\nFunction 'wcstoimax' loaded at 56e9c020\nFunction '__mpn_add_n' loaded at 56e9c4a0\nFunction '__mpn_impn_sqr_n_basecase' loaded at 56e9cfa0\nFunction '__mpn_construct_double' loaded at 56e9ddf0\nFunction '_itowa' loaded at 56e9e690\nFunction '_L_unlock_11056' loaded at 56ea35aa\nFunction 'printf_size_info' loaded at 56ea77b0\nFunction 'group_number' loaded at 56ea8220\nFunction 'vfscanf' loaded at 56eb2050\nFunction 'perror_internal' loaded at 56eb6cd0\nFunction '__path_search' loaded at 56eb7770\nFunction 'ftrylockfile' loaded at 56eb7ea0\nFunction '_IO_file_doallocate' loaded at 56eb8b50\nFunction '_L_unlock_161' loaded at 56eb9245\nFunction '__fopen_internal' loaded at 56eb9690\nFunction '_L_lock_41' loaded at 56eb9bdc\nFunction '_L_unlock_185' loaded at 56eb9ecf\nFunction '_L_lock_47' loaded at 56eba57b\nFunction '_IO_proc_close' loaded at 56ebaa70\nFunction '_L_unlock_110' loaded at 56ebb13e\nFunction '_IO_setbuffer' loaded at 56ebb4a0\nFunction '_L_unlock_95' loaded at 56ebb894\nFunction '_L_unlock_105' loaded at 56ebbda2\nFunction 'getwchar' loaded at 56ebc020\nFunction '_L_lock_43' loaded at 56ebc4e9\nFunction 'putwc' loaded at 56ebc940\nFunction '_L_unlock_81' loaded at 56ebcc61\nFunction 'vswprintf' loaded at 56ebcf20\nFunction '_IO_sungetwc' loaded at 56ebd360\nFunction 'save_for_wbackup' loaded at 56ebd7c0\nFunction '_IO_wstr_finish' loaded at 56ebe140\nFunction '_IO_wdo_write' loaded at 56ebf2a0\nFunction 'do_out' loaded at 56ebfb00\nFunction '_L_lock_29' loaded at 56ec0220\nFunction '_L_lock_30' loaded at 56ec04ae\nFunction '_L_lock_29' loaded at 56ec08df\nFunction '_L_lock_30' loaded at 56ec0c7e\nFunction '_IO_strn_overflow' loaded at 56ec1080\nFunction 'ftello' loaded at 56ec1670\nFunction 'ftello64' loaded at 56ec1b60\nFunction '__fpending' loaded at 56ec1e00\nFunction '_L_unlock_17' loaded at 56ec25f2\nFunction '_L_lock_29' loaded at 56ec2814\nFunction '_IO_file_sync_mmap' loaded at 56ec2d30\nFunction '_IO_do_write' loaded at 56ec3a10\nFunction '_IO_file_setbuf_mmap' loaded at 56ec44a0\nFunction 'flush_cleanup' loaded at 56ec4fa0\nFunction '_IO_sgetn' loaded at 56ec55a0\nFunction '_IO_adjust_column' loaded at 56ec5960\nFunction '_IO_default_seek' loaded at 56ec5fc0\nFunction '_IO_list_lock' loaded at 56ec6070\nFunction '_IO_default_doallocate' loaded at 56ec67e0\nFunction '_L_unlock_280' loaded at 56ec6c3e\nFunction '_L_lock_1784' loaded at 56ec6cca\nFunction '_IO_str_pbackfail' loaded at 56ec6f60\nFunction '__failing_morecore' loaded at 56ec75a0\nFunction 'ptmalloc_init' loaded at 56ec7ef0\nFunction 'cfree' loaded at 56ec91a0\nFunction 'realloc_check' loaded at 56ecaaa0\nFunction 'realloc_hook_ini' loaded at 56ecbad0\nFunction '_L_unlock_2466' loaded at 56ecc04a\nFunction '_L_unlock_4424' loaded at 56ecc0e2\nFunction '_L_unlock_8320' loaded at 56ecc17a\nFunction '_L_lock_9316' loaded at 56ecc20f\nFunction '_L_unlock_9886' loaded at 56ecc29b\nFunction '_L_unlock_10772' loaded at 56ecc327\nFunction 'mprobe' loaded at 56ecc510\nFunction 'mtrace' loaded at 56eccc10\nFunction '_L_lock_751' loaded at 56ecd4f3\nFunction '_obstack_memory_used' loaded at 56ecd8f0\nFunction '__strdup' loaded at 56ecdfd0\nFunction 'strpbrk' loaded at 56ece820\nFunction 'bcmp' loaded at 56ecf180\nFunction 'ffsll' loaded at 56ecfd90\nFunction '_wordcopy_fwd_aligned' loaded at 56ed0310\nFunction 'rawmemchr' loaded at 56ed0b90\nFunction 'argz_insert' loaded at 56ed1180\nFunction 'envz_add' loaded at 56ed1970\nFunction '__memset_gcn_by4' loaded at 56ed3700\nFunction '__strncat_g' loaded at 56ed3950\nFunction '__strcspn_g' loaded at 56ed3b40\nFunction '__strcspn_c1' loaded at 56ed3f70\nFunction '__strsep_3c' loaded at 56ed4270\nFunction '__xpg_strerror_r' loaded at 56ed4680\nFunction 'wcsncpy' loaded at 56ed4aa0\nFunction 'wmemset' loaded at 56ed4f80\nFunction 'mbsrtowcs' loaded at 56ed58e0\nFunction 'wcstoll' loaded at 56ed6550\nFunction '____wcstol_l_internal' loaded at 56ed6870\nFunction '____wcstod_l_internal' loaded at 56ed8040\nFunction 'wcscoll' loaded at 56ede440\nFunction '_nl_cleanup_ctype' loaded at 56ee0000\nFunction 'asctime' loaded at 56ee0c60\nFunction 'guess_time_tm' loaded at 56ee0eb0\nFunction '__tzstring' loaded at 56ee1be0\nFunction '_L_unlock_2123' loaded at 56ee287f\nFunction 'ftime' loaded at 56ee39c0\nFunction 'memcpy_uppcase' loaded at 56ee68e0\nFunction '_nl_init_alt_digit' loaded at 56eeab60\nFunction '_nl_cleanup_time' loaded at 56eeafe0\nFunction '_L_unlock_119' loaded at 56eeb4ac\nFunction 'alphasort' loaded at 56eeb840\nFunction '_L_lock_246' loaded at 56eebee0\nFunction '_L_lock_27' loaded at 56eec50a\nFunction 'getgrgid' loaded at 56eecca0\nFunction '_L_unlock_290' loaded at 56eed201\nFunction 'getgrgid_r' loaded at 56eed4e0\nFunction '_L_unlock_116' loaded at 56eee03e\nFunction '_L_lock_25' loaded at 56eee5d6\nFunction '_L_unlock_233' loaded at 56eee8bd\nFunction 'times' loaded at 56eef2d0\nFunction 'pause' loaded at 56eefb10\nFunction 'execle' loaded at 56ef0120\nFunction 'getegid' loaded at 56ef09a0\nFunction 'getsid' loaded at 56ef0c60\nFunction 'setlogin' loaded at 56ef1140\nFunction 'handle_intel' loaded at 56ef1a00\nFunction 'collated_compare' loaded at 56ef3be0\nFunction 'end_pattern' loaded at 56ef5f50\nFunction 're_node_set_contains' loaded at 56efa780\nFunction 'find_subexp_node' loaded at 56efad00\nFunction 'lower_subexps' loaded at 56efb590\nFunction 'free_dfa_content' loaded at 56efb9d0\nFunction 'check_arrival_expand_ecl' loaded at 56efc4b0\nFunction 're_node_set_init_copy' loaded at 56efd1f0\nFunction 'build_upper_buffer' loaded at 56efe6f0\nFunction 'check_arrival' loaded at 56efffa0\nFunction 'parse_bracket_exp' loaded at 56f02cf0\nFunction 'set_regs' loaded at 56f05f40\nFunction 're_exec' loaded at 56f08f60\nFunction '_getopt_long_only_r' loaded at 56f0a650\nFunction '__sched_get_priority_min' loaded at 56f0a940\nFunction 'in6aicmp' loaded at 56f0ad30\nFunction '_L_lock_9088' loaded at 56f0e70d\nFunction 'eval_expr' loaded at 56f0ed40\nFunction 'pread' loaded at 56f12850\nFunction 'posix_spawn_file_actions_addclose' loaded at 56f12cb0\nFunction 'posix_spawnattr_setpgroup' loaded at 56f12fa0\nFunction 'posix_spawnattr_setschedparam' loaded at 56f13760\nFunction '__xstat64' loaded at 56f13b70\nFunction 'fstatfs64' loaded at 56f143f0\nFunction 'mkdir' loaded at 56f14a00\nFunction '__close' loaded at 56f15160\nFunction '__fcntl_nocancel' loaded at 56f15750\nFunction 'creat64' loaded at 56f15cc0\nFunction 'getttyname' loaded at 56f162f0\nFunction 'readlinkat' loaded at 56f17050\nFunction 'object_compare' loaded at 56f184b0\nFunction 'fts_palloc' loaded at 56f19850\nFunction 'posix_fadvise' loaded at 56f1afc0\nFunction '__internal_statvfs' loaded at 56f1bea0\nFunction 'tcsetpgrp' loaded at 56f1c4c0\nFunction 'setrlimit64' loaded at 56f1c8f0\nFunction '__sbrk' loaded at 56f1cdb0\nFunction 'setregid' loaded at 56f1d440\nFunction '___newselect_nocancel' loaded at 56f1d84a\nFunction 'sethostid' loaded at 56f1de50\nFunction 'usleep' loaded at 56f1e150\nFunction 'getfsspec' loaded at 56f1e570\nFunction '_L_lock_1062' loaded at 56f1f144\nFunction 'ftruncate64' loaded at 56f1f5c0\nFunction 'endusershell' loaded at 56f1fcc0\nFunction 'openlog_internal' loaded at 56f20390\nFunction '_L_lock_1085' loaded at 56f20c4c\nFunction 'madvise' loaded at 56f21070\nFunction 'fcvt_r' loaded at 56f21420\nFunction 'hsearch_r' loaded at 56f22060\nFunction 'tsearch' loaded at 56f22a40\nFunction 'errx' loaded at 56f23040\nFunction 'dirname' loaded at 56f238b0\nFunction 'listxattr' loaded at 56f23d30\nFunction 'vm86' loaded at 56f24080\nFunction 'gnu_dev_major' loaded at 56f24450\nFunction 'capget' loaded at 56f24730\nFunction 'inotify_add_watch' loaded at 56f24a30\nFunction 'prctl' loaded at 56f24d60\nFunction 'getpeername' loaded at 56f250c0\nFunction 'setsockopt' loaded at 56f25500\nFunction '__libc_msgsnd' loaded at 56f259a0\nFunction 'shmget' loaded at 56f25f10\nFunction 'pc_to_index' loaded at 56f26b80\nFunction 'iswxdigit' loaded at 56f27410\nFunction 'iswpunct' loaded at 56f27c50\nFunction 'iswalpha_l' loaded at 56f28270\nFunction '__towlower_l' loaded at 56f28880\nFunction '_L_unlock_111' loaded at 56f28cd6\nFunction 'getspent_r' loaded at 56f29440\nFunction '_nss_files_parse_spent' loaded at 56f298b0\nFunction '_L_lock_34' loaded at 56f2a3eb\nFunction '__argp_fmtstream_update' loaded at 56f2a500\nFunction '__argp_fmtstream_puts' loaded at 56f2af00\nFunction 'until_short' loaded at 56f2b2d0\nFunction 'usage_argful_short_opt' loaded at 56f2c270\nFunction 'argp_help' loaded at 56f2e4a0\nFunction 'argp_usage' loaded at 56f2f580\nFunction 'pthread_attr_setschedparam' loaded at 56f2f7d0\nFunction 'pthread_cond_signal' loaded at 56f2fa10\nFunction 'pthread_self' loaded at 56f2fc50\nFunction '_L_lock_116' loaded at 56f2ff5a\nFunction 'inet_ntop4' loaded at 56f30490\nFunction 'net_mask' loaded at 56f30ec0\nFunction 'skip_ws' loaded at 56f324c0\nFunction '_L_unlock_68' loaded at 56f3306e\nFunction '__nss_configure_lookup' loaded at 56f33a70\nFunction '__nss_getent' loaded at 56f34000\nFunction '__nss_group_lookup' loaded at 56f34eb0\nFunction '__backtrace' loaded at 56f35490\nFunction '__sprintf_chk' loaded at 56f35e60\nFunction '_L_unlock_99' loaded at 56f362af\nFunction '_L_unlock_302' loaded at 56f36680\nFunction '__pread64_chk' loaded at 56f36be0\nFunction '__wmemcpy_chk' loaded at 56f36ee0\nFunction '__vswprintf_chk' loaded at 56f37220\nFunction '_L_lock_35' loaded at 56f376ca\nFunction '_L_unlock_247' loaded at 56f379a7\nFunction '__wcsnrtombs_chk' loaded at 56f37c70\nFunction '_L_unlock_63' loaded at 56f38084\nFunction '__h_errno_location' loaded at 56f38530\nFunction '_L_unlock_149' loaded at 56f38ddb\nFunction '_L_unlock_73' loaded at 56f396ee\nFunction '_L_lock_28' loaded at 56f39c55\nFunction '_L_lock_148' loaded at 56f39fee\nFunction '_L_lock_24' loaded at 56f3a5ed\nFunction '_L_unlock_237' loaded at 56f3a8ce\nFunction '_L_lock_27' loaded at 56f3b036\nFunction '_L_unlock_72' loaded at 56f3b54e\nFunction '_L_unlock_111' loaded at 56f3b7b6\nFunction '_L_unlock_167' loaded at 56f3bbce\nFunction 'ether_ntoa_r' loaded at 56f3c510\nFunction 'rresvport_af' loaded at 56f3d200\nFunction '__internal_setnetgrent_reuse' loaded at 56f3ed70\nFunction '_L_unlock_711' loaded at 56f3f622\nFunction '_L_lock_28' loaded at 56f3f9ad\nFunction '_L_lock_25' loaded at 56f3fc16\nFunction 'if_nameindex' loaded at 56f40ba0\nFunction 'inet6_option_init' loaded at 56f41ee0\nFunction 'setsourcefilter' loaded at 56f42720\nFunction 'authnone_create_once' loaded at 56f43340\nFunction 'xdr_authunix_parms' loaded at 56f43b70\nFunction 'clntraw_geterr' loaded at 56f448e0\nFunction 'clnttcp_freeres' loaded at 56f44fc0\nFunction 'clntudp_freeres' loaded at 56f45930\nFunction 'pmap_unset' loaded at 56f46810\nFunction 'pmap_rmtcall' loaded at 56f47720\nFunction '__rpc_thread_variables' loaded at 56f480a0\nFunction 'svcerr_weakauth' loaded at 56f483b0\nFunction 'xprt_unregister' loaded at 56f48920\nFunction 'svcraw_getargs' loaded at 56f48e30\nFunction 'svctcp_freeargs' loaded at 56f495e0\nFunction 'svctcp_rendezvous_abort' loaded at 56f49c40\nFunction 'svcudp_recv' loaded at 56f4a4f0\nFunction 'xdr_u_longlong_t' loaded at 56f4ab90\nFunction 'xdr_wrapstring' loaded at 56f4afb0\nFunction 'xdrmem_setpos' loaded at 56f4b520\nFunction 'skip_input_bytes' loaded at 56f4b7c0\nFunction 'xdrrec_getbytes' loaded at 56f4bb50\nFunction 'xdrstdio_create' loaded at 56f4c150\nFunction 'xdrstdio_getpos' loaded at 56f4c400\nFunction 'x_destroy' loaded at 56f4c790\nFunction 'xdr_authdes_cred' loaded at 56f4d030\nFunction 'key_get_conv' loaded at 56f4e400\nFunction '_L_unlock_445' loaded at 56f4e8df\nFunction 'xdr_keystatus' loaded at 56f4ec90\nFunction '_svcauth_des' loaded at 56f4f730\nFunction 'clntunix_create' loaded at 56f50340\nFunction 'svcunixfd_create' loaded at 56f50ed0\nFunction '_create_xid' loaded at 56f516a0\nFunction 'xdr_uint8_t' loaded at 56f51ac0\nFunction '__nscd_gethostbyname2_r' loaded at 56f52fd0\nFunction 'get_mapping' loaded at 56f53dc0\nFunction 'getutent' loaded at 56f546c0\nFunction 'endutent' loaded at 56f549f0\nFunction 'getutline' loaded at 56f54b40\nFunction '__utmp_equal' loaded at 56f55040\nFunction 'updwtmp' loaded at 56f55fb0\nFunction 'setutxent' loaded at 56f56cb0\nFunction 'dl_iterate_phdr' loaded at 56f56e70\nFunction '__libc_dlopen_mode' loaded at 56f57510\nFunction 'fde_unencoded_compare' loaded at 56f57b40\nFunction '__register_frame' loaded at 56f58350\nFunction '_L_lock_136' loaded at 56f59129\nFunction '_Unwind_GetIP' loaded at 56f591e0\nFunction 'read_uleb128' loaded at 56f59b50\nFunction '_IO_old_cookie_seek' loaded at 56f59eb0\nFunction '_L_lock_68' loaded at 56f5a7ea\nFunction '_L_lock_36' loaded at 56f5ab9c\nFunction '_IO_file_xsputn' loaded at 56f5af40\nFunction '_IO_old_file_finish' loaded at 56f5bae0\nFunction 'versionsort64' loaded at 56f5c090\nFunction 'sched_setaffinity' loaded at 56f5d210\nFunction 'getspent_r' loaded at 56f5d550\nFunction 'gethostbyname2_r' loaded at 56f5d7f0\nFunction 'getservbyport_r' loaded at 56f5dbe0\nFunction 'free_mem' loaded at 56f5dff0\nFunction 'free_mem' loaded at 56f5e5c0\nFunction '_L_unlock_44' loaded at 56f5e905\nFunction '__rpc_thread_destroy' loaded at 56f5ec70\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 6]- /disk/PinTools/Utils/obj-ia32/cp-pin    \n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 5]- /lib/ld-linux.so.2                      \n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 4]- /usr/lib/libstdc++.so.6                 \n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 3]- /lib/libm.so.6                          \n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 2]- /lib/libgcc_s.so.1                      \n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 1]- /lib/libc.so.6                          \n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Replay/ia32_cross_os_replay.record": "L '/disk/PinTools/Utils/obj-ia32/cp-pin' 8048ad8 780 0 1 \n\t'main' 8048d90\nEND_RTN_LIST\nL '/lib/ld-linux.so.2' 555557c0 157aa 55555000 0 \n\t'rtld_lock_default_unlock_recursive' 555558c0\n\t'relocate_doit' 55556770\n\t'fillin_rpath' 5555a3c0\n\t'decompose_rpath' 5555c9f0\n\t'do_lookup_x' 5555e380\n\t'_dl_map_object_deps' 55560e40\n\t'_dl_sort_fini' 55562ba0\n\t'match_symbol' 55563930\n\t'_dl_next_tls_modid' 55564e10\n\t'_dl_tls_setup' 55565940\n\t'_dl_runtime_resolve' 55567930\n\t'__assert_fail' 55568870\n\t'calloc' 55568f60\n\t'profil_counter' 55569560\n\t'__lseek' 555698d0\n\t'__madvise' 55569e50\n\t'strlen' 5556a270\n\t'__i686.get_pc_thunk.cx' 5556ae47\nEND_RTN_LIST\nL '/usr/lib/libstdc++.so.6' 56d7182c 7c6b4 56d37000 0 \n\t'_ZN9__gnu_cxx17__pool_alloc_base12_M_get_mutexEv' 56d760f0\n\t'_ZN9__gnu_cxx6__poolILb1EE13_M_initializeEPFvPvE' 56d774d0\n\t'_ZNKSt7codecvtIwc11__mbstate_tE16do_always_noconvEv' 56d78800\n\t'_ZNSt7codecvtIcc11__mbstate_tEC1Ej' 56d78c10\n\t'_ZNSbIwSt11char_traitsIwESaIwEE7_M_copyEPwPKwj' 56d78f70\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE15_M_check_lengthEjjPKc' 56d791c0\n\t'_ZNKSt14basic_ofstreamIwSt11char_traitsIwEE7is_openEv' 56d79900\n\t'_ZStlsIdcSt11char_traitsIcEERSt13basic_ostreamIT0_T1_ES6_RKSt7complexIT_E' 56d7a7f0\n\t'_ZNKSt5ctypeIcE9do_narrowEPKcS2_cPc' 56d7bdf0\n\t'_ZNSt5ctypeIcED2Ev' 56d7c340\n\t'_ZNSt12ctype_bynameIwEC2EPKcj' 56d7c880\n\t'_ZN11__gnu_debug19_Safe_sequence_base7_M_swapERS0_' 56d7da10\n\t'_ZSt18__throw_bad_typeidv' 56d7de60\n\t'_ZNSt12out_of_rangeD0Ev' 56d7e0f0\n\t'_ZSt23__throw_underflow_errorPKc' 56d7e480\n\t'_ZNSt8ios_base6xallocEv' 56d7edd0\n\t'_ZNSt8ios_base7failureC1ERKSs' 56d7f3c0\n\t'_ZNSt8ios_base7_M_initEv' 56d808d0\n\t'_ZNSt6localeC2ERKS_' 56d80b10\n\t'_ZNSt6locale5_ImplD2Ev' 56d81310\n\t'_ZNSt6locale5_ImplC2Ej' 56d81e00\n\t'_ZNSt6localeC2ERKS_S1_i' 56d84170\n\t'_ZNSt11logic_errorC2ERKSs' 56d86830\n\t'_ZNSt13runtime_errorC2ERKSs' 56d86af0\n\t'_ZNSt13runtime_errorD0Ev' 56d86e20\n\t'_ZNSt12strstreambuf7_M_freeEPc' 56d870e0\n\t'_ZNSt12strstreambuf9underflowEv' 56d87330\n\t'_ZNSt12strstreambufC2EPaiS0_' 56d87c80\n\t'_ZNSt12strstreambufC1EPKhi' 56d88450\n\t'_ZNSt10ostrstreamD2Ev' 56d88cb0\n\t'_ZNSt10istrstreamD1Ev' 56d89480\n\t'_ZNSt9strstreamD0Ev' 56d89bf0\n\t'_ZSt18_Rb_tree_decrementPKSt18_Rb_tree_node_base' 56d8a2d0\n\t'_ZNSaIwED1Ev' 56d8a8c0\n\t'_ZNSt13basic_filebufIcSt11char_traitsIcEE13_M_set_bufferEi' 56d8b6c0\n\t'_ZNSt13basic_filebufIwSt11char_traitsIwEE27_M_allocate_internal_bufferEv' 56d8b8b0\n\t'_ZNSt13basic_filebufIwSt11char_traitsIwEE9pbackfailEj' 56d8be20\n\t'_ZNSt13basic_filebufIcSt11char_traitsIcEE6xsgetnEPci' 56d8d060\n\t'_ZNSt14basic_ifstreamIwSt11char_traitsIwEE7is_openEv' 56d8e080\n\t'_ZNSt13basic_filebufIwSt11char_traitsIwEED0Ev' 56d8e980\n\t'_ZNSt13basic_filebufIcSt11char_traitsIcEE9showmanycEv' 56d8f250\n\t'_ZNSt14basic_ofstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode' 56d8f860\n\t'_ZNSt14basic_ofstreamIwSt11char_traitsIwEEC2Ev' 56d8fe60\n\t'_ZNSt14basic_ofstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode' 56d904d0\n\t'_ZNSt14basic_ifstreamIcSt11char_traitsIcEEC1Ev' 56d90d40\n\t'_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev' 56d91430\n\t'_ZTv0_n12_NSt13basic_fstreamIcSt11char_traitsIcEED0Ev' 56d91dc0\n\t'_ZNSt13basic_fstreamIwSt11char_traitsIwEED2Ev' 56d92260\n\t'_ZNKSt9basic_iosIwSt11char_traitsIwEE7rdstateEv' 56d93680\n\t'_ZNSt9basic_iosIcSt11char_traitsIcEEC1Ev' 56d938f0\n\t'_ZNSt9basic_iosIcSt11char_traitsIcEED2Ev' 56d93c00\n\t'_ZNKSt9basic_iosIwSt11char_traitsIwEE3badEv' 56d93fe0\n\t'_ZNSt9basic_iosIwSt11char_traitsIwEE10exceptionsESt12_Ios_Iostate' 56d941d0\n\t'_ZNSt9basic_iosIwSt11char_traitsIwEE5imbueERKSt6locale' 56d944a0\n\t'_ZNSt14basic_iostreamIwSt11char_traitsIwEEC1Ev' 56d94f60\n\t'_ZNSdC1Ev' 56d95280\n\t'_ZNSirsEPFRSt8ios_baseS0_E' 56d954d0\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEErsEPFRSt8ios_baseS4_E' 56d95600\n\t'_ZStrsISt11char_traitsIcEERSt13basic_istreamIcT_ES5_Pa' 56d958a0\n\t'_ZStrsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_St12_Setiosflags' 56d95b40\n\t'_ZTv0_n12_NSt13basic_istreamIwSt11char_traitsIwEED1Ev' 56d95e20\n\t'_ZStrsIcSt11char_traitsIcEERSt13basic_istreamIT_T0_ES6_RS3_' 56d96650\n\t'_ZNSi3getERSt15basic_streambufIcSt11char_traitsIcEE' 56d96fa0\n\t'_ZNSirsERy' 56d97a40\n\t'_ZSt2wsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_' 56d987a0\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEE3getERSt15basic_streambufIwS1_Ew' 56d99390\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEErsERf' 56d99e80\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEE6sentryC2ERS2_b' 56d9abf0\n\t'_ZNKSt10moneypunctIcLb0EE13thousands_sepEv' 56d9c540\n\t'_ZNKSt10moneypunctIcLb0EE14do_frac_digitsEv' 56d9c6c0\n\t'_ZNKSt10moneypunctIcLb1EE10pos_formatEv' 56d9c890\n\t'_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' 56d9cb50\n\t'_ZNSt16__numpunct_cacheIcEC1Ej' 56d9cda0\n\t'_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRe' 56d9d200\n\t'_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPKv' 56d9d5f0\n\t'_ZNSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEEC2Ej' 56d9d850\n\t'_ZNKSt8messagesIcE4openERKSsRKSt6locale' 56d9db80\n\t'_ZNSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED0Ev' 56d9dfc0\n\t'_ZNSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEED1Ev' 56d9e1e0\n\t'_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED2Ev' 56d9e3f0\n\t'_ZSt9has_facetISt8numpunctIcEEbRKSt6locale' 56d9e810\n\t'_ZSt9use_facetISt10moneypunctIcLb0EEERKT_RKSt6locale' 56d9ebb0\n\t'_ZNSt7collateIcEC2Ej' 56d9ef10\n\t'_ZNSt8messagesIcED1Ev' 56d9f290\n\t'_ZNSt16__numpunct_cacheIcED2Ev' 56d9f6d0\n\t'_ZNSt15numpunct_bynameIcED2Ev' 56d9fb30\n\t'_ZNSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' 56d9ffb0\n\t'_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' 56da0310\n\t'_ZNSt15messages_bynameIcEC2EPKcj' 56da07c0\n\t'_ZNSt11__timepunctIcEC2Ej' 56da0fc0\n\t'_ZNKSt8numpunctIcE12do_falsenameEv' 56da12f0\n\t'_ZNSt10moneypunctIcLb1EEC2EP15__locale_structPKcj' 56da17f0\n\t'_ZNKSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPK2tmPKcSB_' 56da1c80\n\t'_ZNSt15numpunct_bynameIcEC1EPKcj' 56da2180\n\t'_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE14do_get_weekdayES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm' 56da3b00\n\t'_ZNKSt7collateIcE12do_transformEPKcS2_' 56da68d0\n\t'_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' 56dac390\n\t'_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE15_M_insert_floatIeEES3_S3_RSt8ios_baseccT_' 56daeb10\n\t'_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE6do_putES3_RSt8ios_basecm' 56db0310\n\t'_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRm' 56db2f10\n\t'_ZStlsIcSt11char_traitsIcESaIcEERSt13basic_ostreamIT_T0_ES7_RKSbIS4_S5_T1_E' 56db5520\n\t'_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEPFRS2_S3_E' 56db5a10\n\t'_ZNSoC2EPSt15basic_streambufIcSt11char_traitsIcEE' 56db5ba0\n\t'_ZNSoC1Ev' 56db5e20\n\t'_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_' 56db6470\n\t'_ZNSoD2Ev' 56db6a40\n\t'_ZNSolsEs' 56db6d50\n\t'_ZNSo5writeEPKci' 56db7af0\n\t'_ZNSolsEx' 56db8a50\n\t'_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEi' 56db9e90\n\t'_ZSt4endsIwSt11char_traitsIwEERSt13basic_ostreamIT_T0_ES6_' 56dbb170\n\t'_ZNKSt19basic_ostringstreamIcSt11char_traitsIcESaIcEE5rdbufEv' 56dbba10\n\t'_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE6setbufEPwi' 56dbbd40\n\t'_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE3strERKSbIwS1_S2_E' 56dbc7f0\n\t'_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode' 56dbcc90\n\t'_ZNKSt18basic_stringstreamIcSt11char_traitsIcESaIcEE3strEv' 56dbd7f0\n\t'_ZNKSt19basic_istringstreamIwSt11char_traitsIwESaIwEE3strEv' 56dbdfc0\n\t'_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEED2Ev' 56dbe670\n\t'_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode' 56dbee50\n\t'_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode' 56dbf9a0\n\t'_ZTv0_n12_NSt19basic_istringstreamIwSt11char_traitsIwESaIwEED0Ev' 56dc0180\n\t'_ZTv0_n12_NSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev' 56dc0a90\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEE10pubseekposESt4fposI11__mbstate_tESt13_Ios_Openmode' 56dc12e0\n\t'_ZNKSt15basic_streambufIcSt11char_traitsIcEE4pptrEv' 56dc1420\n\t'_ZNSt15basic_streambufIwSt11char_traitsIwEE10pubseekoffExSt12_Ios_SeekdirSt13_Ios_Openmode' 56dc14f0\n\t'_ZNKSt15basic_streambufIwSt11char_traitsIwEE5pbaseEv' 56dc1680\n\t'_ZNSt15basic_streambufIwSt11char_traitsIwEEaSERKS2_' 56dc1740\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEEC1Ev' 56dc1a40\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEED1Ev' 56dc1ce0\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEE7seekposESt4fposI11__mbstate_tESt13_Ios_Openmode' 56dc1e40\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEE5sputcEc' 56dc2150\n\t'_ZNKSs7_M_dataEv' 56dc26e0\n\t'_ZNKSs4sizeEv' 56dc2820\n\t'_ZNSs4_Rep15_M_set_sharableEv' 56dc28e0\n\t'_ZNKSs5emptyEv' 56dc2d70\n\t'_ZNKSs16find_last_not_ofEcj' 56dc3010\n\t'_ZNKSs13find_first_ofEcj' 56dc33e0\n\t'_ZNKSs4rendEv' 56dc3740\n\t'_ZNKSs7compareEjjRKSs' 56dc3b60\n\t'_ZNSsC2EPKcjRKSaIcE' 56dc4040\n\t'_ZNSsC1IPcEET_S1_RKSaIcE' 56dc4470\n\t'_ZNSs6appendEPKcj' 56dc4a00\n\t'_ZNSs6assignEPKc' 56dc5100\n\t'_ZNSs6insertEN9__gnu_cxx17__normal_iteratorIPcSsEEjc' 56dc54e0\n\t'_ZNSs7_M_leakEv' 56dc59b0\n\t'_ZNSsD2Ev' 56dc5d10\n\t'_ZNSs7replaceEjjPKc' 56dc63b0\n\t'_ZNSt8valarrayIjED2Ev' 56dc6700\n\t'_ZNKSt10moneypunctIwLb0EE13positive_signEv' 56dc6dc0\n\t'_ZNKSt10moneypunctIwLb1EE13decimal_pointEv' 56dc6f70\n\t'_ZNKSt10moneypunctIwLb1EE16do_thousands_sepEv' 56dc7100\n\t'_ZNKSt8numpunctIwE13decimal_pointEv' 56dc74b0\n\t'_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRt' 56dc76f0\n\t'_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE3putES3_RSt8ios_basewb' 56dc7b10\n\t'_ZNKSt11__timepunctIwE20_M_date_time_formatsEPPKw' 56dc7ea0\n\t'_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10date_orderEv' 56dc8130\n\t'_ZNKSt8messagesIwE8do_closeEi' 56dc8430\n\t'_ZNSt8time_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED0Ev' 56dc87b0\n\t'_ZNSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEED1Ev' 56dc89d0\n\t'_ZSt9has_facetISt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEEbRKSt6locale' 56dc8cb0\n\t'_ZSt9has_facetISt7codecvtIwc11__mbstate_tEEbRKSt6locale' 56dc9110\n\t'_ZSt9use_facetISt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEERKT_RKSt6locale' 56dc9470\n\t'_ZNSt14codecvt_bynameIwc11__mbstate_tED1Ev' 56dc97d0\n\t'_ZNSt15messages_bynameIwED0Ev' 56dc9bb0\n\t'_ZNSt18__moneypunct_cacheIwLb1EED1Ev' 56dca010\n\t'_ZNSt17moneypunct_bynameIwLb1EED1Ev' 56dca3f0\n\t'_ZNSt8numpunctIwEC1EP15__locale_structj' 56dca870\n\t'_ZNSt18__moneypunct_cacheIwLb0EEC2Ej' 56dcabf0\n\t'_ZNSt17__timepunct_cacheIwEC1Ej' 56dcb110\n\t'_ZNKSt10moneypunctIwLb0EE16do_negative_signEv' 56dcb8b0\n\t'_ZNSt10moneypunctIwLb1EEC1EPSt18__moneypunct_cacheIwLb1EEj' 56dcbe10\n\t'_ZNSt8messagesIwEC1EP15__locale_structPKcj' 56dcc1f0\n\t'_ZNSt15time_get_bynameIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEC2EPKcj' 56dcc8d0\n\t'_ZNSt17moneypunct_bynameIwLb0EEC2EPKcj' 56dccd40\n\t'_ZNSt14collate_bynameIwEC2EPKcj' 56dcf9b0\n\t'_ZNKSt9money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb1EEES3_S3_RSt8ios_basewRKSbIwS2_SaIwEE' 56dd1030\n\t'_ZNKSt9money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10_M_extractILb0EEES3_S3_S3_RSt8ios_baseRSt12_Ios_IostateRSs' 56dd4110\n\t'_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE13_M_insert_intIxEES3_S3_RSt8ios_basewT_' 56dd7b60\n\t'_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRx' 56dda050\n\t'_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_putES3_RSt8ios_basewb' 56ddcfc0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE5beginEv' 56ddd810\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE4_Rep12_M_is_sharedEv' 56ddd8e0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE4findEPKwjj' 56dddca0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE17find_first_not_ofEwj' 56dddf40\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE13find_first_ofEPKwjj' 56dde330\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE12find_last_ofEPKwj' 56dde6a0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE7compareEjjRKS2_jj' 56dde9c0\n\t'_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_jjRKS1_' 56ddefa0\n\t'_ZNSbIwSt11char_traitsIwESaIwEEC1EPKwRKS1_' 56ddf3b0\n\t'_ZNSbIwSt11char_traitsIwESaIwEE9push_backEw' 56ddf8d0\n\t'_ZNSbIwSt11char_traitsIwESaIwEED2Ev' 56ddfe30\n\t'_ZNSbIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPwS2_EEw' 56de0420\n\t'_ZNSbIwSt11char_traitsIwESaIwEE6insertEjRKS2_jj' 56de0910\n\t'_ZNSbIwSt11char_traitsIwESaIwEE6rbeginEv' 56de0c30\n\t'_ZNSbIwSt11char_traitsIwESaIwEE7replaceEjjPKw' 56de1210\n\t'_ZNKSt7codecvtIwc11__mbstate_tE9do_lengthERS0_PKcS4_j' 56de15e0\n\t'_ZNKSt5ctypeIwE11do_scan_notEtPKwS2_' 56de1dc0\n\t'_ZNKSt5ctypeIwE10do_toupperEw' 56de21e0\n\t'_ZNSt10moneypunctIwLb0EED2Ev' 56de2ab0\n\t'_ZNSt10moneypunctIcLb0EE24_M_initialize_moneypunctEP15__locale_structPKc' 56de3090\n\t'_ZNSt8numpunctIwE22_M_initialize_numpunctEP15__locale_struct' 56de4390\n\t'_ZNSt12__basic_fileIcE4syncEv' 56de5a80\n\t'_ZNSt12__basic_fileIcE6xsgetnEPci' 56de5f30\n\t'_ZdlPvRKSt9nothrow_t' 56de62c0\n\t'__cxa_begin_catch' 56de66c0\n\t'__cxa_call_unexpected' 56de6d30\n\t'__cxa_guard_release' 56de7630\n\t'__cxa_pure_virtual' 56de7970\n\t'_ZN10__cxxabiv117__class_type_infoD0Ev' 56de7b30\n\t'_ZNSt10bad_typeidD1Ev' 56de7d50\n\t'_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_' 56de8060\n\t'_ZN10__cxxabiv117__pbase_type_infoD2Ev' 56de8a60\n\t'_ZN10__cxxabiv120__function_type_infoD0Ev' 56de8c70\n\t'_ZNK10__cxxabiv119__pointer_type_info15__pointer_catchEPKNS_17__pbase_type_infoEPPvj' 56de8ef0\n\t'__cxa_vec_new' 56de95e0\nEND_RTN_LIST\nL '/lib/libm.so.6' 56e2e314 1a5dc 56e2b000 0 \n\t'__i686.get_pc_thunk.bx' 56e2e4c7\n\t'fegetenv' 56e30a90\n\t'__ieee754_asin' 56e30db0\n\t'__ieee754_y0' 56e314e0\n\t'__ieee754_log10' 56e32c10\n\t'cbrt' 56e335f0\n\t'logb' 56e340d0\n\t'asin' 56e34840\n\t'hypot' 56e34e30\n\t'log10' 56e35560\n\t'nan' 56e35b00\n\t'creal' 56e35f10\n\t'csin' 56e36b80\n\t'clog10' 56e37d60\n\t'__finite' 56e382b0\n\t'__ieee754_atan2f' 56e386d0\n\t'ponef' 56e38ee0\n\t'__ieee754_remainderf' 56e3a280\n\t'cbrtf' 56e3ab60\n\t'logbf' 56e3b4d0\n\t'asinf' 56e3b9e0\n\t'hypotf' 56e3bff0\n\t'log10f' 56e3c6c0\n\t'nanf' 56e3cc50\n\t'crealf' 56e3cf60\n\t'csinf' 56e3dab0\n\t'clog10f' 56e3e9d0\n\t'finitef' 56e3ee00\n\t'__ieee754_atan2l' 56e3f320\n\t'pone' 56e3fff0\n\t'__ieee754_remainderl' 56e41730\n\t'cbrtl' 56e41ca0\n\t'logbl' 56e42800\n\t'atan2l' 56e42db0\n\t'y0l' 56e43420\n\t'powl' 56e43b90\n\t'truncl' 56e44180\n\t'cabsl' 56e444c0\n\t'ctanl' 56e45540\n\t'fmal' 56e466c0\n\t'copysignl' 56e46ae0\n\t'__divdc3' 56e48190\nEND_RTN_LIST\nL '/lib/libgcc_s.so.1' 56e5a4fc 7c24 56e59000 0 \n\t'__ashldi3' 56e5a8e0\n\t'__subvsi3' 56e5abe0\n\t'__ctzdi2' 56e5b030\n\t'__mulxc3' 56e5bd70\n\t'__fixdfdi' 56e5d020\n\t'__udivmoddi4' 56e5d8e0\n\t'_Unwind_GetGR' 56e5dcd0\n\t'__register_frame_info' 56e60260\n\t'.fini' 56e62104\nEND_RTN_LIST\nL '/lib/libc.so.6' 56e795d8 e5746 56e64000 0 \n\t'gnu_get_libc_version' 56e79980\n\t'__divdi3' 56e79ee0\n\t'__gconv_close' 56e7adc0\n\t'__gconv_find_transform' 56e7bab0\n\t'add_alias' 56e7c180\n\t'__gconv_transform_ascii_internal' 56e7e080\n\t'__gconv_translit_find' 56e81e20\n\t'__gconv_lookup_cache' 56e82780\n\t'_L_unlock_996' 56e838fc\n\t'rangecmp' 56e84640\n\t'__duplocale' 56e85ad0\n\t'__collseq_table_lookup' 56e85f30\n\t'isdigit' 56e86400\n\t'__isascii_l' 56e866a0\n\t'ispunct_l' 56e86810\n\t'set_binding_values' 56e869d0\n\t'__dcigettext' 56e87a10\n\t'dcngettext' 56e88220\n\t'_nl_expand_alias' 56e89d40\n\t'new_exp_2' 56e8a920\n\t'finite' 56e8bd40\n\t'copysignf' 56e8c0f0\n\t'modfl' 56e8c3b0\n\t'__libc_longjmp' 56e8c810\n\t'sigpending' 56e8cd90\n\t'sigpause' 56e8d1f0\n\t'sigaddset' 56e8d5a0\n\t'__libc_current_sigrtmax_private' 56e8d8f0\n\t'sigset' 56e8de10\n\t'_quicksort' 56e8e360\n\t'_L_lock_22' 56e8f45a\n\t'exit' 56e8f530\n\t'div' 56e8f9d0\n\t'initstate' 56e8fef0\n\t'setstate_r' 56e90070\n\t'mrand48' 56e90610\n\t'jrand48_r' 56e908d0\n\t'strtoll' 56e90ca0\n\t'strtoull_l' 56e92390\n\t'__strtof_l' 56e948e0\n\t'do_system' 56e99720\n\t'realpath' 56e99cf0\n\t'__xpg_basename' 56e9b780\n\t'wcstoimax' 56e9c020\n\t'__mpn_add_n' 56e9c4a0\n\t'__mpn_impn_sqr_n_basecase' 56e9cfa0\n\t'__mpn_construct_double' 56e9ddf0\n\t'_itowa' 56e9e690\n\t'_L_unlock_11056' 56ea35aa\n\t'printf_size_info' 56ea77b0\n\t'group_number' 56ea8220\n\t'vfscanf' 56eb2050\n\t'perror_internal' 56eb6cd0\n\t'__path_search' 56eb7770\n\t'ftrylockfile' 56eb7ea0\n\t'_IO_file_doallocate' 56eb8b50\n\t'_L_unlock_161' 56eb9245\n\t'__fopen_internal' 56eb9690\n\t'_L_lock_41' 56eb9bdc\n\t'_L_unlock_185' 56eb9ecf\n\t'_L_lock_47' 56eba57b\n\t'_IO_proc_close' 56ebaa70\n\t'_L_unlock_110' 56ebb13e\n\t'_IO_setbuffer' 56ebb4a0\n\t'_L_unlock_95' 56ebb894\n\t'_L_unlock_105' 56ebbda2\n\t'getwchar' 56ebc020\n\t'_L_lock_43' 56ebc4e9\n\t'putwc' 56ebc940\n\t'_L_unlock_81' 56ebcc61\n\t'vswprintf' 56ebcf20\n\t'_IO_sungetwc' 56ebd360\n\t'save_for_wbackup' 56ebd7c0\n\t'_IO_wstr_finish' 56ebe140\n\t'_IO_wdo_write' 56ebf2a0\n\t'do_out' 56ebfb00\n\t'_L_lock_29' 56ec0220\n\t'_L_lock_30' 56ec04ae\n\t'_L_lock_29' 56ec08df\n\t'_L_lock_30' 56ec0c7e\n\t'_IO_strn_overflow' 56ec1080\n\t'ftello' 56ec1670\n\t'ftello64' 56ec1b60\n\t'__fpending' 56ec1e00\n\t'_L_unlock_17' 56ec25f2\n\t'_L_lock_29' 56ec2814\n\t'_IO_file_sync_mmap' 56ec2d30\n\t'_IO_do_write' 56ec3a10\n\t'_IO_file_setbuf_mmap' 56ec44a0\n\t'flush_cleanup' 56ec4fa0\n\t'_IO_sgetn' 56ec55a0\n\t'_IO_adjust_column' 56ec5960\n\t'_IO_default_seek' 56ec5fc0\n\t'_IO_list_lock' 56ec6070\n\t'_IO_default_doallocate' 56ec67e0\n\t'_L_unlock_280' 56ec6c3e\n\t'_L_lock_1784' 56ec6cca\n\t'_IO_str_pbackfail' 56ec6f60\n\t'__failing_morecore' 56ec75a0\n\t'ptmalloc_init' 56ec7ef0\n\t'cfree' 56ec91a0\n\t'realloc_check' 56ecaaa0\n\t'realloc_hook_ini' 56ecbad0\n\t'_L_unlock_2466' 56ecc04a\n\t'_L_unlock_4424' 56ecc0e2\n\t'_L_unlock_8320' 56ecc17a\n\t'_L_lock_9316' 56ecc20f\n\t'_L_unlock_9886' 56ecc29b\n\t'_L_unlock_10772' 56ecc327\n\t'mprobe' 56ecc510\n\t'mtrace' 56eccc10\n\t'_L_lock_751' 56ecd4f3\n\t'_obstack_memory_used' 56ecd8f0\n\t'__strdup' 56ecdfd0\n\t'strpbrk' 56ece820\n\t'bcmp' 56ecf180\n\t'ffsll' 56ecfd90\n\t'_wordcopy_fwd_aligned' 56ed0310\n\t'rawmemchr' 56ed0b90\n\t'argz_insert' 56ed1180\n\t'envz_add' 56ed1970\n\t'__memset_gcn_by4' 56ed3700\n\t'__strncat_g' 56ed3950\n\t'__strcspn_g' 56ed3b40\n\t'__strcspn_c1' 56ed3f70\n\t'__strsep_3c' 56ed4270\n\t'__xpg_strerror_r' 56ed4680\n\t'wcsncpy' 56ed4aa0\n\t'wmemset' 56ed4f80\n\t'mbsrtowcs' 56ed58e0\n\t'wcstoll' 56ed6550\n\t'____wcstol_l_internal' 56ed6870\n\t'____wcstod_l_internal' 56ed8040\n\t'wcscoll' 56ede440\n\t'_nl_cleanup_ctype' 56ee0000\n\t'asctime' 56ee0c60\n\t'guess_time_tm' 56ee0eb0\n\t'__tzstring' 56ee1be0\n\t'_L_unlock_2123' 56ee287f\n\t'ftime' 56ee39c0\n\t'memcpy_uppcase' 56ee68e0\n\t'_nl_init_alt_digit' 56eeab60\n\t'_nl_cleanup_time' 56eeafe0\n\t'_L_unlock_119' 56eeb4ac\n\t'alphasort' 56eeb840\n\t'_L_lock_246' 56eebee0\n\t'_L_lock_27' 56eec50a\n\t'getgrgid' 56eecca0\n\t'_L_unlock_290' 56eed201\n\t'getgrgid_r' 56eed4e0\n\t'_L_unlock_116' 56eee03e\n\t'_L_lock_25' 56eee5d6\n\t'_L_unlock_233' 56eee8bd\n\t'times' 56eef2d0\n\t'pause' 56eefb10\n\t'execle' 56ef0120\n\t'getegid' 56ef09a0\n\t'getsid' 56ef0c60\n\t'setlogin' 56ef1140\n\t'handle_intel' 56ef1a00\n\t'collated_compare' 56ef3be0\n\t'end_pattern' 56ef5f50\n\t're_node_set_contains' 56efa780\n\t'find_subexp_node' 56efad00\n\t'lower_subexps' 56efb590\n\t'free_dfa_content' 56efb9d0\n\t'check_arrival_expand_ecl' 56efc4b0\n\t're_node_set_init_copy' 56efd1f0\n\t'build_upper_buffer' 56efe6f0\n\t'check_arrival' 56efffa0\n\t'parse_bracket_exp' 56f02cf0\n\t'set_regs' 56f05f40\n\t're_exec' 56f08f60\n\t'_getopt_long_only_r' 56f0a650\n\t'__sched_get_priority_min' 56f0a940\n\t'in6aicmp' 56f0ad30\n\t'_L_lock_9088' 56f0e70d\n\t'eval_expr' 56f0ed40\n\t'pread' 56f12850\n\t'posix_spawn_file_actions_addclose' 56f12cb0\n\t'posix_spawnattr_setpgroup' 56f12fa0\n\t'posix_spawnattr_setschedparam' 56f13760\n\t'__xstat64' 56f13b70\n\t'fstatfs64' 56f143f0\n\t'mkdir' 56f14a00\n\t'__close' 56f15160\n\t'__fcntl_nocancel' 56f15750\n\t'creat64' 56f15cc0\n\t'getttyname' 56f162f0\n\t'readlinkat' 56f17050\n\t'object_compare' 56f184b0\n\t'fts_palloc' 56f19850\n\t'posix_fadvise' 56f1afc0\n\t'__internal_statvfs' 56f1bea0\n\t'tcsetpgrp' 56f1c4c0\n\t'setrlimit64' 56f1c8f0\n\t'__sbrk' 56f1cdb0\n\t'setregid' 56f1d440\n\t'___newselect_nocancel' 56f1d84a\n\t'sethostid' 56f1de50\n\t'usleep' 56f1e150\n\t'getfsspec' 56f1e570\n\t'_L_lock_1062' 56f1f144\n\t'ftruncate64' 56f1f5c0\n\t'endusershell' 56f1fcc0\n\t'openlog_internal' 56f20390\n\t'_L_lock_1085' 56f20c4c\n\t'madvise' 56f21070\n\t'fcvt_r' 56f21420\n\t'hsearch_r' 56f22060\n\t'tsearch' 56f22a40\n\t'errx' 56f23040\n\t'dirname' 56f238b0\n\t'listxattr' 56f23d30\n\t'vm86' 56f24080\n\t'gnu_dev_major' 56f24450\n\t'capget' 56f24730\n\t'inotify_add_watch' 56f24a30\n\t'prctl' 56f24d60\n\t'getpeername' 56f250c0\n\t'setsockopt' 56f25500\n\t'__libc_msgsnd' 56f259a0\n\t'shmget' 56f25f10\n\t'pc_to_index' 56f26b80\n\t'iswxdigit' 56f27410\n\t'iswpunct' 56f27c50\n\t'iswalpha_l' 56f28270\n\t'__towlower_l' 56f28880\n\t'_L_unlock_111' 56f28cd6\n\t'getspent_r' 56f29440\n\t'_nss_files_parse_spent' 56f298b0\n\t'_L_lock_34' 56f2a3eb\n\t'__argp_fmtstream_update' 56f2a500\n\t'__argp_fmtstream_puts' 56f2af00\n\t'until_short' 56f2b2d0\n\t'usage_argful_short_opt' 56f2c270\n\t'argp_help' 56f2e4a0\n\t'argp_usage' 56f2f580\n\t'pthread_attr_setschedparam' 56f2f7d0\n\t'pthread_cond_signal' 56f2fa10\n\t'pthread_self' 56f2fc50\n\t'_L_lock_116' 56f2ff5a\n\t'inet_ntop4' 56f30490\n\t'net_mask' 56f30ec0\n\t'skip_ws' 56f324c0\n\t'_L_unlock_68' 56f3306e\n\t'__nss_configure_lookup' 56f33a70\n\t'__nss_getent' 56f34000\n\t'__nss_group_lookup' 56f34eb0\n\t'__backtrace' 56f35490\n\t'__sprintf_chk' 56f35e60\n\t'_L_unlock_99' 56f362af\n\t'_L_unlock_302' 56f36680\n\t'__pread64_chk' 56f36be0\n\t'__wmemcpy_chk' 56f36ee0\n\t'__vswprintf_chk' 56f37220\n\t'_L_lock_35' 56f376ca\n\t'_L_unlock_247' 56f379a7\n\t'__wcsnrtombs_chk' 56f37c70\n\t'_L_unlock_63' 56f38084\n\t'__h_errno_location' 56f38530\n\t'_L_unlock_149' 56f38ddb\n\t'_L_unlock_73' 56f396ee\n\t'_L_lock_28' 56f39c55\n\t'_L_lock_148' 56f39fee\n\t'_L_lock_24' 56f3a5ed\n\t'_L_unlock_237' 56f3a8ce\n\t'_L_lock_27' 56f3b036\n\t'_L_unlock_72' 56f3b54e\n\t'_L_unlock_111' 56f3b7b6\n\t'_L_unlock_167' 56f3bbce\n\t'ether_ntoa_r' 56f3c510\n\t'rresvport_af' 56f3d200\n\t'__internal_setnetgrent_reuse' 56f3ed70\n\t'_L_unlock_711' 56f3f622\n\t'_L_lock_28' 56f3f9ad\n\t'_L_lock_25' 56f3fc16\n\t'if_nameindex' 56f40ba0\n\t'inet6_option_init' 56f41ee0\n\t'setsourcefilter' 56f42720\n\t'authnone_create_once' 56f43340\n\t'xdr_authunix_parms' 56f43b70\n\t'clntraw_geterr' 56f448e0\n\t'clnttcp_freeres' 56f44fc0\n\t'clntudp_freeres' 56f45930\n\t'pmap_unset' 56f46810\n\t'pmap_rmtcall' 56f47720\n\t'__rpc_thread_variables' 56f480a0\n\t'svcerr_weakauth' 56f483b0\n\t'xprt_unregister' 56f48920\n\t'svcraw_getargs' 56f48e30\n\t'svctcp_freeargs' 56f495e0\n\t'svctcp_rendezvous_abort' 56f49c40\n\t'svcudp_recv' 56f4a4f0\n\t'xdr_u_longlong_t' 56f4ab90\n\t'xdr_wrapstring' 56f4afb0\n\t'xdrmem_setpos' 56f4b520\n\t'skip_input_bytes' 56f4b7c0\n\t'xdrrec_getbytes' 56f4bb50\n\t'xdrstdio_create' 56f4c150\n\t'xdrstdio_getpos' 56f4c400\n\t'x_destroy' 56f4c790\n\t'xdr_authdes_cred' 56f4d030\n\t'key_get_conv' 56f4e400\n\t'_L_unlock_445' 56f4e8df\n\t'xdr_keystatus' 56f4ec90\n\t'_svcauth_des' 56f4f730\n\t'clntunix_create' 56f50340\n\t'svcunixfd_create' 56f50ed0\n\t'_create_xid' 56f516a0\n\t'xdr_uint8_t' 56f51ac0\n\t'__nscd_gethostbyname2_r' 56f52fd0\n\t'get_mapping' 56f53dc0\n\t'getutent' 56f546c0\n\t'endutent' 56f549f0\n\t'getutline' 56f54b40\n\t'__utmp_equal' 56f55040\n\t'updwtmp' 56f55fb0\n\t'setutxent' 56f56cb0\n\t'dl_iterate_phdr' 56f56e70\n\t'__libc_dlopen_mode' 56f57510\n\t'fde_unencoded_compare' 56f57b40\n\t'__register_frame' 56f58350\n\t'_L_lock_136' 56f59129\n\t'_Unwind_GetIP' 56f591e0\n\t'read_uleb128' 56f59b50\n\t'_IO_old_cookie_seek' 56f59eb0\n\t'_L_lock_68' 56f5a7ea\n\t'_L_lock_36' 56f5ab9c\n\t'_IO_file_xsputn' 56f5af40\n\t'_IO_old_file_finish' 56f5bae0\n\t'versionsort64' 56f5c090\n\t'sched_setaffinity' 56f5d210\n\t'getspent_r' 56f5d550\n\t'gethostbyname2_r' 56f5d7f0\n\t'getservbyport_r' 56f5dbe0\n\t'free_mem' 56f5dff0\n\t'free_mem' 56f5e5c0\n\t'_L_unlock_44' 56f5e905\n\t'__rpc_thread_destroy' 56f5ec70\nEND_RTN_LIST\nU '/disk/PinTools/Utils/obj-ia32/cp-pin'\nU '/lib/ld-linux.so.2'\nU '/usr/lib/libstdc++.so.6'\nU '/lib/libm.so.6'\nU '/lib/libgcc_s.so.1'\nU '/lib/libc.so.6'\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Debugger/makefile.rules": "##############################################################\n#\n# This file includes all the test targets as well as all the\n# non-default build rules and test recipes.\n#\n##############################################################\n\n# WRL does not have a native debugger, we don't test this directory on that OS.\n# See the exceptions section to see how that's done.\n\n###### Additional includes that are specific to this directory ######\n\ninclude $(TOOLS_ROOT)/Config/makefile.debug.rules\n\n\n##############################################################\n#\n# Test targets\n#\n##############################################################\n\n###### Place all generic definitions here ######\n\n# This defines tests which run tools of the same name.  This is simply for convenience to avoid\n# defining the test name twice (once in TOOL_ROOTS and again in TEST_ROOTS).\n# Tests defined here should not be defined in TOOL_ROOTS and TEST_ROOTS.\nTEST_TOOL_ROOTS :=\n\n# This defines the tests to be run that were not already defined in TEST_TOOL_ROOTS.\nTEST_ROOTS :=\n\n# This defines a list of tests that should run in the \"short\" sanity. Tests in this list must also\n# appear either in the TEST_TOOL_ROOTS or the TEST_ROOTS list.\n# If the entire directory should be tested in sanity, assign TEST_TOOL_ROOTS and TEST_ROOTS to the\n# SANITY_SUBSET variable in the tests section below (see example in makefile.rules.tmpl).\nSANITY_SUBSET :=\n\n# This defines the tools which will be run during the the tests, and were not already defined in\n# TEST_TOOL_ROOTS.\nTOOL_ROOTS :=\n\n# This defines the static analysis tools which will be run during the the tests. They should not\n# be defined in TEST_TOOL_ROOTS. If a test with the same name exists, it should be defined in\n# TEST_ROOTS.\n# Note: Static analysis tools are in fact executables linked with the Pin Static Analysis Library.\n# This library provides a subset of the Pin APIs which allows the tool to perform static analysis\n# of an application or dll. Pin itself is not used when this tool runs.\nSA_TOOL_ROOTS :=\n\n# This defines all the applications that will be run during the tests.\nAPP_ROOTS :=\n\n# This defines any additional object files that need to be compiled.\nOBJECT_ROOTS :=\n\n# This defines any additional dlls (shared objects), other than the pintools, that need to be compiled.\nDLL_ROOTS :=\n\n# This defines any static libraries (archives), that need to be built.\nLIB_ROOTS :=\n\n###### Place OS-specific definitions here ######\n\n# Linux\nifeq ($(TARGET_OS),linux)\n    TEST_TOOL_ROOTS += stop-resume-when-suspended check-if-thread-stopped\n    TEST_ROOTS += simple-pindb-launch pindb-start-fini pindb-noprompt-kill pindb-detach pindb-abrupt-disconnect \\\n                  pindb-kill-like-gdb pindb-simple-command pindb-step-custom-break pindb-simultaneous-toolbreak \\\n                  pindb-simultaneous-toolbreak-serialize pindb-simultaneous-toolbreak-squash pindb-invalidate-regs \\\n                  pindb-simultaneous-toolbreak-change pindb-simultaneous-toolbreak-step pindb-simple-simultaneous-multi \\\n                  pindb-simple-simultaneous-multi-serialize simple execfail fork breaktool breaktool_const_context \\\n                  breaktool-wait breaktool-nodebugger bp-icount action-pending thread launch-gdb stack-debugger \\\n                  debugger-shell-breakpoints debugger-shell-tracepoints start-fini intercept-breakpoint emu-simple ymm \\\n                  pc-change-bp pc-change-async interpreter-remove mt-exit debugger-type signal-step siginfo xmm-$(TARGET) \\\n                  pindb-attach-after-custom-stop allow-remote set-mode gdb-detach-reattach invalid-write bptest-$(TARGET) \\\n                  pindb-pthread-step-exit gdb-pthread-step-exit pindb-pthread-cont-exitgroup simultaneous-toolbreak \\\n                  simultaneous-toolbreak-squash simultaneous-toolbreak-change simultaneous-toolbreak-attach \\\n                  pindb-simultaneous-multi pindb-simultaneous-multi-serialize pindb-simultaneous-toolbreak-attach \\\n                  launch-gdb_const_context ymm_with_set_xmm_scratch_regs_tool watchpoint_const_context \\\n                  simultaneous-toolbreak_const_context xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool \\\n                  xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_const_context \\\n                  xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_and_set_xmm_reg \\\n                  app-pause-in-app-thread app-pause-in-int-thread bphandler gdb-svr4-libraries-extension\n    TOOL_ROOTS += stack-debugger start-fini-callback simple-command-tool use-debugger-shell simultaneous-toolbreak \\\n                  breaktool int3-count action-pending-tool checkpoint watchpoint launch-gdb-tool intercept-tool \\\n                  pc-change-async-tool interpreter-remove mt-exit-tool debugger-type set-mode-tool invalidate-regs \\\n                  set_xmm_scratches set_xmm_scratches_before_breakpoint set_xmm_scratches_before_breakpoint_and_set_xmm_reg \\\n                  set_xmm_scratches_for_ymmtest null-emulator-$(TARGET) \\\n                  app-pause-in-app-thread-tool app-pause-in-int-thread-tool library-load-tool\n    APP_ROOTS += simple-pindb simple simple-static exec fork action-pending-app thread checkpoint-app bptest-$(TARGET) \\\n                 watchpoint-app callerapp fibonacci sleep-unix intercept-app pc-change-bp pc-change-async xmm-$(TARGET) \\\n                 mt-exit signal-catch reattach-loop pthread-bare-exit pthread-bare-exitgroup thread-$(OS_TYPE) \\\n                 ymm-$(TARGET) debugger-shell-app-$(TARGET) app-pause-app pick-random-port bphandler_app dlopen-dlclose\n    OBJECT_ROOTS += simple-pindb-asm-$(TARGET_OS)-$(TARGET)\n    ifeq ($(TARGET),ia32)\n        TEST_ROOTS += access-64-on-32\n    endif \nendif\n\n# Windows\nifeq ($(TARGET_OS),windows)\n    TEST_TOOL_ROOTS += stop-resume-when-suspended check-if-thread-stopped\n    TEST_ROOTS += simple-pindb-launch pindb-start-fini pindb-noprompt-kill pindb-detach pindb-abrupt-disconnect \\\n                  pindb-kill-like-gdb pindb-simple-command pindb-step-custom-break pindb-simultaneous-toolbreak \\\n                  pindb-simultaneous-toolbreak-serialize pindb-simultaneous-toolbreak-squash pindb-invalidate-regs \\\n                  pindb-simultaneous-toolbreak-change pindb-simultaneous-toolbreak-step pindb-simple-simultaneous-multi \\\n                  pindb-simple-simultaneous-multi-serialize pindb-win-unhandled-exception pindb-win-handled-exception \\\n                  pindb-win-continued-exception1 pindb-win-continued-exception2 pindb-win-software-exception \\\n                  pindb-win-cpp-exception pindb-win-squash-exception pindb-win-step-exception \\\n                  pindb-win-library-notifications pindb-win-step-library pindb-win-thread-stress \\\n                  app-pause-in-app-thread app-pause-in-int-thread\n    TOOL_ROOTS += stack-debugger start-fini-callback simple-command-tool use-debugger-shell simultaneous-toolbreak \\\n                  invalidate-regs app-pause-in-app-thread-tool app-pause-in-int-thread-tool\n    APP_ROOTS += simple-pindb simple win-unhandled-exception win-handled-exception win-continued-exception1 \\\n                 win-continued-exception2 win-software-exception win-cpp-exception win-load-library \\\n                 win-thread-stress thread-$(OS_TYPE) app-pause-app\n    OBJECT_ROOTS += simple-pindb-asm-$(TARGET_OS)-$(TARGET)\n    DLL_ROOTS += win-foo-library\n    ifeq ($(TARGET),ia32)\n        TEST_ROOTS += access-64-on-32\n    endif\nendif\n\n###### Handle exceptions here ######\n\n# These two tests trigger a compiler bug when building on 32-bit Windows with ICC versions 11.x.  It's difficult\n# to disable the tests only for those compiler versions, so we disable them whenever we build with ICC.  These\n# lines should be removed when we migrate to ICC 12.x.  See Mantis #2444.\n#\nifeq ($(TARGET)-$(TARGET_OS),ia32-windows)\n    ifneq ($(ICC),)\n        TEST_ROOTS := $(filter-out pindb-win-continued-exception1 pindb-win-continued-exception2, $(TEST_ROOTS))        \n    endif\nendif\n\n#pindb-win-step-exception fails on pinw32-12. Mantis: 3072. \nifeq ($(TARGET_OS),windows)\n    TEST_ROOTS := $(filter-out pindb-win-step-exception, $(TEST_ROOTS)) \nendif\n\n# There is a bug with PinADX when using early-injection (the default) on 32-bit applications when running\n# on a 64-bit host and when using versions of Windows earlier than Vista.  That bug causes this test to\n# fail, so we disable it in this case.  We can re-enable this test when Mantis #2385 is fixed.\n#\nosname := $(shell uname -s)\nifeq ($(findstring CYGWIN_NT-5,$(osname))-$(HOST_ARCH)-$(TARGET),CYGWIN_NT-5-intel64-ia32)\n    TEST_ROOTS := $(filter-out pindb-start-fini, $(TEST_ROOTS))\nendif\n\nifeq ($(TARGET_OS),linux)\n    GDB_VERSION_IF_BEFORE_66 :=  $(strip $(shell $(GDB) --version | head -1 | $(GREP) -E -o \" [6]\\.[2-5]+\"))\n    GDB_VERSION_IF_AFTER_74 := $(strip $(shell $(GDB) --version | head -1 | $(GREP) -E -o \" [7-9]\\.[4-9]+\"))\n    ifneq ($(GDB_VERSION_IF_BEFORE_66),\"\")\n#   Versions of gdb older than 6.6 do not understand the XMM registers, so disable the xmm tests.\n#\n        TEST_ROOTS := $(filter-out xmm-$(TARGET) xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool \\\n                                   xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_const_context \\\n                                   xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_and_set_xmm_reg, \\\n                                   $(TEST_ROOTS))\n        TOOL_ROOTS := $(filter-out set_xmm_scratches_before_breakpoint \\\n                                   set_xmm_scratches_before_breakpoint_and_set_xmm_reg set_xmm_scratches, $(TOOL_ROOTS))\n        APP_ROOTS := $(filter-out xmm-$(TARGET), $(APP_ROOTS))\n    endif\n    ifeq ($(strip $(GDB_VERSION_IF_AFTER_74)),)\n#   Versions of gdb older than 7.4 do not understand svr4 libraries query\n#\n        TEST_ROOTS := $(filter-out gdb-svr4-libraries-extension, $(TEST_ROOTS))\n        TOOL_ROOTS := $(filter-out library-load-tool, $(TOOL_ROOTS))\n        APP_ROOTS := $(filter-out dlopen-dlclose, $(APP_ROOTS))\n    endif\nendif\n\n# WRL does not have a native debugger, therefore don't test this directory on that OS.\nosrel := $(shell uname -r)\nifeq ($(findstring WR,$(osrel)),WR)\n    TEST_TOOL_ROOTS :=\n    TEST_ROOTS :=\n    SANITY_SUBSET :=\n    TOOL_ROOTS :=\n    SA_TOOL_ROOTS :=\n    APP_ROOTS :=\n    OBJECT_ROOTS :=\n    DLL_ROOTS :=\n    LIB_ROOTS :=\nendif\n\n# TODO: Debugger integration is not yet supported on MIC\n# See Mantis 2925\nifeq ($(TARGET),mic)\n    TEST_TOOL_ROOTS :=\n    TEST_ROOTS :=\n    SANITY_SUBSET :=\n    TOOL_ROOTS :=\n    SA_TOOL_ROOTS :=\n    APP_ROOTS :=\n    OBJECT_ROOTS :=\n    DLL_ROOTS :=\n    LIB_ROOTS :=\nendif\n\n\n##############################################################\n#\n# Test recipes\n#\n##############################################################\n\n###### Finalize sanity here ######\n\nSANITY_SUBSET := $(TEST_TOOL_ROOTS) $(TEST_ROOTS)\n\n# This section contains recipes for tests other than the default.\n# See makefile.default.rules for the default test rules.\n# All tests in this section should adhere to the naming convention: <testname>.test\n\n# This is a time limit (in seconds) we use for some of the tests below.  It's intentionally high\n# to avoid timeouts when the system load is very high, which can happen in our nightly tests.\n#\nTLIMIT := 300\n\n# This is the example tool from the manual run such that you can attach the debugger after it triggers a stack\n# breakpoint.\n#\nstack-debugger-late.test: $(OBJDIR)fibonacci$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_silent -t $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX) \\\n\t  -stackbreak 4000 -o $(OBJDIR)$(@:.test=.toolout) -timeout $(TLIMIT) \\\n\t    -- $(OBJDIR)fibonacci$(EXE_SUFFIX) 1000 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.toolout) > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.toolout) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)fibonacci$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Basic test of debugger features.\n#\nsimple.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Basic test for breakpoint handling features.\n#\nbphandler.test: $(OBJDIR)bphandler$(PINTOOL_SUFFIX) $(OBJDIR)bphandler_app$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)bphandler$(PINTOOL_SUFFIX) -- $(OBJDIR)bphandler_app$(EXE_SUFFIX) > \\\n      $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)bphandler_app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Verify we can debug across a failed exec() call.\n#\nexecfail.test: $(OBJDIR)exec$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -follow_execv -- $(OBJDIR)exec$(EXE_SUFFIX) ./does-not-exist > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)exec$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Verify we can debug across a parent call to fork().\n#\nfork.test: $(OBJDIR)fork$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)fork$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)fork$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Basic test of PIN_ApplicationBreakpoint()\n#\nbreaktool.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 0 \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\nbreaktool_const_context.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 0 -const_context 1 \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Verify that PIN_ApplicationBreakpoint(.., TRUE, ..) will wait if there's no debugger.\n#\nbreaktool-wait.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) \\\n\t  -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 1 -port $(OBJDIR)$(@:.test=.out) \\\n\t    -- $(OBJDIR)simple$(EXE_SUFFIX) &\n\tcount=0; \\\n\tuntil $(BASHTEST) -s $(OBJDIR)$(@:.test=.out) -o $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tsleep 5\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\tport=`cat $(OBJDIR)$(@:.test=.out)`; echo \"target remote :$$port\" >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Verify that PIN_ApplicationBreakpoint(.., FALSE, ..) does not wait if there's no debugger.\n#\nbreaktool-nodebugger.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 0 \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX)\n\n# Test breakpoints in various circumstances.\n#\nbptest-$(TARGET).test: $(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.)$(COMPARE_EXT) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that breakpoints do not cause the tool to see any extra instructions (e.g. INT3).\n#\nbp-icount.test: $(OBJDIR)simple-static$(EXE_SUFFIX) $(OBJDIR)int3-count$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) -t $(OBJDIR)int3-count$(PINTOOL_SUFFIX) -func main -o $(OBJDIR)bp-icount.reference \\\n\t  -- $(OBJDIR)simple-static$(EXE_SUFFIX)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)int3-count$(PINTOOL_SUFFIX) -func main -o $(OBJDIR)bp-icount.count \\\n\t  -- $(OBJDIR)simple-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(CMP) $(OBJDIR)bp-icount.reference $(OBJDIR)bp-icount.count\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test the PIN_IsActionPending() API.\n#\naction-pending.test: $(OBJDIR)action-pending-app$(EXE_SUFFIX) $(OBJDIR)action-pending-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)action-pending-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)action-pending-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)action-pending-app$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that we can print out XMM registers.  Older GDB's don't know how to print XMM registers well,\n# so use a modern GDB for this test.\n#\n# We first test that GDB itself will run.  If not, we just skip the body of this test.  The modern\n# GDB won't run on some old test systems.\n#\nxmm-$(TARGET).test: $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool.test: $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(QGREP) \"$1 = 0x0000000000000000000000003f800000\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"$2 = 0x00000000000000000000000040000000\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"$3 = 0xff00ff000a550a55123456789abcdef0\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"exited normally.\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"instrumented the movdqa\" $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\t$(QGREP) \"did setApplicationBreakpoint\" $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\t$(QGREP) \"regular_context\" $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_const_context.test: $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN)  $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out -const_context 1 \\\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(QGREP) \"$1 = 0x0000000000000000000000003f800000\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"$2 = 0x00000000000000000000000040000000\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"$3 = 0xff00ff000a550a55123456789abcdef0\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"exited normally.\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"instrumented the movdqa\" $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\t$(QGREP) \"did setApplicationBreakpoint\" $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\t$(QGREP) \"const_context\" $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_and_set_xmm_reg.test: $(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN)  $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out \\\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(QGREP) \"$1 = 0x0000000000000000000000003f800000\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"$2 = 0x00000000000000000000000040000000\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"$3 = 0xff00ff000a550a55123456789abcdef0\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"$4 = 0x5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"exited normally.\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"instrumented the movdqa\" $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\t$(QGREP) \"tool got the expected gdb command\" $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\t$(QGREP) \"tool properly set xmm3\" $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_tool.test: $(OBJDIR)set_xmm_scratches$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN)  $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratches.out \\\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) instrumented $(OBJDIR)set_xmm_scratches.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)set_xmm_scratches.out\n\n# Simple test of a threaded program.\n#\nthread.test: $(OBJDIR)thread$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)thread$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat thread.gdb >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)thread$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p thread.compare -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Simple test of a threaded program built statically (uses non-nptl thread package on Linux).\n# NOTE: This test is disabled, so it does not run automatically.  Modern versions of GDB do not\n#   support non-nptl threads well.\n#\nthread-static.test: $(OBJDIR)thread-static$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)thread-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat thread.gdb >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)thread-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p thread.compare -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Simple test of the 'pindb' debugger.  We launch Pin separatly and pindb attaches.\n# TODO: This is disabled until Mantis #1839 is fixed.\n#\nsimple-pindb-attach.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) basic $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.compare)\n\t$(PYTHON) launch-pin-attach-debugger.py --pin=$(PIN_NOFLAGS) --pin-exe=$(BARE_PIN) \\\n\t    --pindb=$(PINDB) --pindb-libpath=$(PINDB_LIBPATH) \\\n\t    --tool=$(OBJDIR)stack-debugger$(PINTOOL_SUFFIX) --app=$(OBJDIR)simple-pindb$(EXE_SUFFIX) \\\n\t    --cpu=$(TARGET) --timeout=$(TLIMIT) \\\n\t    --pin-out=$(OBJDIR)$(@:.test=.out) --pindb-in=$(OBJDIR)$(@:.test=.pindbin) \\\n\t    --pindb-out=$(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.compare) $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.pindbout)\n\n# Simple test of the 'pindb' debugger.  We use the pindb \"run\" command to launch and attach to pin.\n#\nsimple-pindb-launch.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) basic $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple-pindb$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(OBJDIR)$(@:.test=.pindbin.0) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare) $(OBJDIR)$(@:.test=.pindbout) \\\n\t      $(OBJDIR)$(@:.test=.pindbin)\n\n# Test the checkpoint tool.\n#\ncheckpoint.test: $(OBJDIR)checkpoint-app$(EXE_SUFFIX) $(OBJDIR)checkpoint$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)checkpoint$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)checkpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)checkpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p checkpoint-gdb.compare -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p checkpoint-app.compare -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test the watchpoint tool.\n#\nwatchpoint.test: $(OBJDIR)watchpoint-app$(EXE_SUFFIX) $(OBJDIR)watchpoint$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)watchpoint-app 1 > $(OBJDIR)$(@:.test=.gdb)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)watchpoint$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(OBJDIR)$(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout) $(OBJDIR)$(@:.test=.gdb)\n\nwatchpoint_const_context.test: $(OBJDIR)watchpoint-app$(EXE_SUFFIX) $(OBJDIR)watchpoint$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)watchpoint-app$(EXE_SUFFIX) 1 > $(OBJDIR)$(@:.test=.gdb)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)watchpoint$(PINTOOL_SUFFIX) -const_context 1 \\\n\t  -- $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(OBJDIR)$(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout) $(OBJDIR)$(@:.test=.gdb)\n\n# This test starts Pin with debugger support enabled, but Pin does not stop at\n# the first instruction waiting for a debugger to attach.  Instead, the\n# application runs under Pin immediately.  Later, if the tool finds something\n# interesting, it can ask the user (or a GUI shell) to start the debugger and\n# attach at the interesting point.\n#\nlaunch-gdb.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.gdbin)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) -timeout $(TLIMIT) \\\n\t  -o $(OBJDIR)$(@:.test=.gdbin) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.gdbin) > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# This tests the -appdebug_server_port <PORT> option of PIN.\n# We pick an available TCP port randomly, then we run PIN with -appdebug_server_port specifying the random port\n# We expect to connect with GDB to the port we specified\n#\ngdb-fixed-port.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.gdbin)\n\t$(OBJDIR)pick-random-port$(EXE_SUFFIX) unused > $(OBJDIR)$(@:.test=.random)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_server_port `cat $(OBJDIR)$(@:.test=.random)` -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) -timeout $(TLIMIT) \\\n\t  -o $(OBJDIR)$(@:.test=.gdbin) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote :'`cat $(OBJDIR)$(@:.test=.random)` $(OBJDIR)$(@:.test=.gdbin) > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# This tests the -appdebug_server_port <PORT> option of PIN when we.\n# provide a port which is already taken by another application\n# We expect PIN to fail because it won't acquire the port\n#\ngdb-fixed-port-used.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.gdbin)\n\t$(OBJDIR)pick-random-port$(EXE_SUFFIX) used > $(OBJDIR)$(@:.test=.random)\n\t! ( $(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_server_port `cat $(OBJDIR)$(@:.test=.random)` -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) \\\n\t    -timeout $(TLIMIT) -o $(OBJDIR)$(@:.test=.gdbin) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) )\n\t$(QGREP) \"E:Unable to create debugger connection\" $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.random)\n\n# This tests the -appdebug_server_port <PORT> option of PIN when we\n# provide an invalid TCP port number.\n# We expect PIN to fail because the TCP port number is invalid\n#\ngdb-fixed-bad-port.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.gdbin)\n\t! ( $(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_server_port 100000 -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) \\\n\t    -timeout $(TLIMIT) -o $(OBJDIR)$(@:.test=.gdbin) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) )\n\t$(QGREP) \"E:Invalid TCP server port: 100000\" $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin)\n\nlaunch-gdb_const_context.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.gdbin)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) -const_context 1 -timeout $(TLIMIT) \\\n\t  -o $(OBJDIR)$(@:.test=.gdbin) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.gdbin) > /dev/null 2>&1 || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# This is the example tool we describe in the manual, which demonstrates the major features\n# of the application-level debugging API.  The tool tracks the application's stack usage\n# and allows breakpoints to be set when the stack usage crosses a threshold.\n#\nstack-debugger.test: $(OBJDIR)fibonacci$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)fibonacci$(EXE_SUFFIX) 1000 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)fibonacci$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that we can asynchronously stop the target in PinDB by sending CTRL-C (SIGINT).\n# TODO: This is disabled until Mantis #2055 is fixed.\n#\npindb-async-stop.test: $(OBJDIR)sleep-unix$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)sleep-unix$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout) & \\\n\t    pid=$$!; \\\n\t    sleep 2; \\\n\t    while kill -INT $$pid > /dev/null 2>&1; \\\n\t    do \\\n\t        sleep 2; \\\n\t    done; \\\n\t    wait\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test of breakpoint commands in the \"debugger-shell\" instrumentation library.\n#\ndebugger-shell-breakpoints.test: $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) breakpoints $(OBJDIR)$(@:.test=.gdbin.0) $(OBJDIR)$(@:.test=.compare)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(OBJDIR)$(@:.test=.gdbin.0) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin.0) $(OBJDIR)$(@:.test=.compare) \\\n\t      $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test of tracepoint commands in the \"debugger-shell\" instrumentation library.\n#\ndebugger-shell-tracepoints.test: $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) tracepoints $(OBJDIR)$(@:.test=.gdbin.0) $(OBJDIR)$(@:.test=.compare)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(OBJDIR)$(@:.test=.gdbin.0) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin.0) $(OBJDIR)$(@:.test=.compare) \\\n\t      $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that the thread-start, thread-fini, and fini call-backs are correctly called even when GDB\n# immediately terminates the application .\n#\nstart-fini.test: $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) -o $(OBJDIR)$(@:.test=.toolout) \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) & \\\n\t    count=0; \\\n\t    until $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t        do sleep 1; count=`expr $$count + 1`; done; \\\n\t    echo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin); \\\n\t    $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin); \\\n\t    cat quit.gdb >> $(OBJDIR)$(@:.test=.gdbin); \\\n\t    $(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1; \\\n\twait\n\t$(CMP) start-fini.reference $(OBJDIR)$(@:.test=.toolout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that the thread-start, thread-fini, and fini call-backs are correctly called when PinDB\n# immediately terminates the application (tested on both Linux and Windows).\n#\npindb-start-fini.test: $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) \\\n\t    -o $(OBJDIR)$(@:.test=.toolout)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(DIFF) start-fini.reference $(OBJDIR)$(@:.test=.toolout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\nstop-resume-when-suspended.test: $(OBJDIR)stop-resume-when-suspended$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)stop-resume-when-suspended$(PINTOOL_SUFFIX) \\\n\t    -o $(OBJDIR)$(@:.test=.toolout)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(DIFF) stop-resume-when-suspended.reference $(OBJDIR)$(@:.test=.toolout)\n\t$(QGREP) \"Sum is 55\" $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Verify that PIN_InterceptDebuggingEvent() can intercept and squash breakpoints.\n#\nintercept-breakpoint.test: $(OBJDIR)intercept-app$(EXE_SUFFIX) $(OBJDIR)intercept-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)intercept-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)intercept-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)intercept-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=-gdb.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=-app.compare) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test the PIN_AddDebuggerRegisterEmulator() API.  This test is legal to run with any version of GDB,\n# but it only tests the API well when run with a GDB that supports register extensions in the XML\n# \"feature document\".  This includes GDB 7.2 and later, and a few special earlier distributions.\n#\nemu-simple.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)null-emulator-$(TARGET)$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)null-emulator-$(TARGET)$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat simple.gdb >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p simple.compare -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Verify that the debugger can print the value of a YMM register when running on native AVX hardware.\n# This test will pass even when run on non-AVX hardware.  However, it's only effective when run on\n# AVX hardware and when run with a GDB that supports AVX.\n#\nymm.test: $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\nymm_with_set_xmm_scratch_regs_tool.test: $(OBJDIR)set_xmm_scratches_for_ymmtest$(PINTOOL_SUFFIX) $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_for_ymmtest$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\tcat set_xmm_scratches_for_ymmtest.out\n\t$(QGREP) instrumented set_xmm_scratches_for_ymmtest.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f instrumented set_xmm_scratches_for_ymmtest.out\n\n# Verify that the debugger change the the PC when stopped after an indirect JMP instruction.\n#\npc-change-bp.test: $(OBJDIR)pc-change-bp$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)pc-change-bp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)pc-change-bp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Verify that the tool can change the PC from an ASYNC_BREAK intercept function when the thread\n# is stopped after an indirect JMP instruction.\n#\npc-change-async.test: $(OBJDIR)pc-change-async$(EXE_SUFFIX) $(OBJDIR)pc-change-async-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)pc-change-async-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)pc-change-async$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)pc-change-async$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test the PIN_RemoveDebugInterpreter() API.\n#\ninterpreter-remove.test: $(OBJDIR)interpreter-remove$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) -appdebug -t $(OBJDIR)interpreter-remove$(PINTOOL_SUFFIX) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t  do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\techo 'monitor bdio' >> $(OBJDIR)$(@:.test=.gdbin)\n\techo 'c' >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > /dev/null 2>&1\n\t! $(GREP) 'PIN_RemoveDebugInterpreter failed' $(OBJDIR)$(@:.test=.out) > /dev/null\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin)\n\n# Verify that GDB can terminate an application where one thread is blocked in\n# a system call.  Previously, the Pin process would sometimes hang when this\n# happened, so the test checks that the process exits.  (Note, \"kill -s 0 <pid>\"\n# just checks if a process exists, it doesn't send a signal.)\n#\nmt-exit.test: $(OBJDIR)mt-exit$(EXE_SUFFIX) $(OBJDIR)mt-exit-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.toolout)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)mt-exit-tool$(PINTOOL_SUFFIX) -o $(OBJDIR)$(@:.test=.toolout) \\\n\t  -- $(OBJDIR)mt-exit$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)mt-exit$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\tpid=`cat $(OBJDIR)$(@:.test=.toolout)`; \\\n\tcount=0; \\\n\tuntil ! kill -s 0 $$pid > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done; \\\n\t$(BASHTEST) $$count -le $(TLIMIT)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout) $(OBJDIR)$(@:.test=.toolout)\n\n# Simple test of the PIN_GetDebuggerType() API.\n#\ndebugger-type.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)debugger-type$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)debugger-type$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(GREP) 'Debugger Type is GDB' $(OBJDIR)$(@:.test=.out) > /dev/null\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that we can single-step into a signal handler.\n#\nsignal-step.test: $(OBJDIR)signal-catch$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that GDB can print $_siginfo and get the signal information structure from Pin.\n#\nsiginfo.test: $(OBJDIR)signal-catch$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that PinDB can attach after the Pin tool has stopped at a custom breakpoint and that PinDB\n# can still get the tool's custom stop message (see Mantis #2357).\n#\n# This is disabled on Windows, but it could probably be enabled there when Mantis #1839 is fixed.\n#\npindb-attach-after-custom-stop.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) \\\n\t  -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -where main -wait_for_debugger 1 -port $(OBJDIR)$(@:.test=.port) \\\n\t    -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'Tool stopping at breakpoint' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    --gdb-protocol=:`cat $(OBJDIR)$(@:.test=.port)` $(PINDB_USERFLAGS) < $(@:.test=.pindbin) > \\\n\t    $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows unhandled exception with PinDB.\n#\npindb-win-unhandled-exception.test: $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows handled exception with PinDB.\n#\npindb-win-handled-exception.test: $(OBJDIR)win-handled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-handled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows continued exception with PinDB.  The exception filter continues the search.  Note,\n# this test is known to fail (due to a compiler bug) when compiled for IA32 with ICC version 11.x.\n# (It passes with ICC versions 10.x and 12.x.)\n#\npindb-win-continued-exception1.test: $(OBJDIR)win-continued-exception1$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-continued-exception1$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows continued exception with PinDB.  The exception filter executes the handler.  Note,\n# this test is known to fail (due to a compiler bug) when compiled for IA32 with ICC version 11.x.\n# (It passes with ICC versions 10.x and 12.x.)\n#\npindb-win-continued-exception2.test: $(OBJDIR)win-continued-exception2$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-continued-exception2$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows software exception with PinDB.  The exception is raised via RaiseException() and is unhandled.\n#\npindb-win-software-exception.test: $(OBJDIR)win-software-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-software-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows C++ exception with PinDB.\n#\npindb-win-cpp-exception.test: $(OBJDIR)win-cpp-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-cpp-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test ability to squash a Windows exception.  Squashing a first-chance exception re-executes\n# the excepting instruction, which raises a new first-chance exception.  Squashing a last-chance\n# exception also re-executes the excepting instruction, which raises a new first-chance exception.\n#\npindb-win-squash-exception.test: $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test ability to single-step after receiving a Windows exception.  Stepping from a first-chance\n# exception should go to the first instruction in the handler.  Stepping from a last-chance\n# exception should cause the application to terminate.\n#\npindb-win-step-exception.test: $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test DLL load / unload notifications with PinDB.\n#\npindb-win-library-notifications.test: $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test ability to single-step after receiving a Windows library load / unload notification.\n#\npindb-win-step-library.test: $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Make sure PinDB does not wait for confirmation when killing the target process when --noprompt is specified.\n#\npindb-noprompt-kill.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test the -appdebug_allow_remote knob, which allows GDB to run on a different machine than Pin.\n# However, it's difficult to actually run GDB on a different machine as part of this test, so\n# we still run them both on the same machine.\n#\nallow-remote.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -appdebug_allow_remote -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat simple.gdb >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p simple.compare -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Verify that Pin doesn't crash if the debugger attempts to access a 64-bit address for a 32-bit Pin process.\n#\naccess-64-on-32.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Make sure we can ebable debugging via PIN_SetDebugMode() from the tool.  This test should\n# be run without -appdebug.\n#\nset-mode.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)set-mode-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) -t $(OBJDIR)set-mode-tool$(PINTOOL_SUFFIX) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat simple.gdb >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p simple.compare -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that PinDB can detach from Pin.\n#\npindb-detach.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) detach $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple-pindb$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(OBJDIR)$(@:.test=.pindbin.0) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.pindbin.0) \\\n\t      $(OBJDIR)$(@:.test=.compare)\n\n# Abruptly disconnect PinDB from Pin.  This simulates the behavior when the debugger unexpectedly dies.\n# We expect an error from Pin, but Pin shouldn't hang.\n#\npindb-abrupt-disconnect.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs -logfile $(OBJDIR)$(@:.test=.pin.log) $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(SYNC)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pin.log) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbin) \\\n\t      $(OBJDIR)$(@:.test=.pindbout)\n\n# Test the \"kill-like-gdb\" command in PinDB.  This sends the same legacy \"kill\" command to PinADX that\n# GDB uses.\n#\npindb-kill-like-gdb.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that GDB can detach from Pin and then re-attach later.\n#\ngdb-detach-reattach.test: $(OBJDIR)reattach-loop$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > $(OBJDIR)$(@:.test=.port)\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=-1.gdbin)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-1.gdbin)\n\tcat $(@:.test=-1.gdb) >> $(OBJDIR)$(@:.test=-1.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=-1.gdbin) -n $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-1.gdbout)\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=-2.gdbin)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-2.gdbin)\n\tcat $(@:.test=-2.gdb) >> $(OBJDIR)$(@:.test=-2.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=-2.gdbin) -n $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-2.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-1.compare) -c $(OBJDIR)$(@:.test=-1.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-2.compare) -c $(OBJDIR)$(@:.test=-2.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=-app.compare) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port) $(OBJDIR)$(@:.test=-1.gdbin) \\\n\t      $(OBJDIR)$(@:.test=-1.gdbout) $(OBJDIR)$(@:.test=-2.gdbin) $(OBJDIR)$(@:.test=-2.gdbout)\n\n# Test that GDB can detach from Pin and then re-attach later.\n#\ngdb-detach-reattach-fixed-port.test: $(OBJDIR)reattach-loop$(EXE_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)pick-random-port$(EXE_SUFFIX) unused > $(OBJDIR)$(@:.test=.random)\n\t$(PIN) $(PINFLAGS_DEBUG) -appdebug_server_port `cat $(OBJDIR)$(@:.test=.random)` -- \\\n\t    $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote :'`cat $(OBJDIR)$(@:.test=.random)` \\\n\t    $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(GREP) 'target remote :'`cat $(OBJDIR)$(@:.test=.random)` $(OBJDIR)$(@:.test=.out) > $(OBJDIR)$(@:.test=.port)\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=-1.gdbin)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-1.gdbin)\n\tcat $(@:.test=-1.gdb) >> $(OBJDIR)$(@:.test=-1.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=-1.gdbin) -n $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-1.gdbout)\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=-2.gdbin)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-2.gdbin)\n\tcat $(@:.test=-2.gdb) >> $(OBJDIR)$(@:.test=-2.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=-2.gdbin) -n $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-2.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-1.compare) -c $(OBJDIR)$(@:.test=-1.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-2.compare) -c $(OBJDIR)$(@:.test=-2.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=-app.compare) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port) $(OBJDIR)$(@:.test=-1.gdbin) \\\n\t    $(OBJDIR)$(@:.test=-1.gdbout) $(OBJDIR)$(@:.test=-2.gdbin) $(OBJDIR)$(@:.test=-2.gdbout) \\\n\t    $(OBJDIR)$(@:.test=.random)\n\n# Test that extended commands work using PinDB.  This also checks that the tool does _not_ receive\n# commands that start with the \"pin \" prefix.\n#\npindb-simple-command.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)simple-command-tool$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simple-command-tool$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that the debugger can write to an invalid address in the application.\n#\ninvalid-write.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Try debugging an application with lots of threads that exit at the same time.\n#\npindb-win-thread-stress.test: $(OBJDIR)win-thread-stress$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-thread-stress$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that we can single-step over an instruction that exits the calling thread while another thread\n# still exists.  We expect the debugger to stop after the thread exits, leaving the focus on\n# the one remaining thread.\n#\npindb-pthread-step-exit.test: $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Same test as above, but use GDB instead of PinDB.\n#\ngdb-pthread-step-exit.test: $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that we can debug an application where one thread exits the entire process\n# while another thread still exists.\n#\npindb-pthread-cont-exitgroup.test: $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that we can single-step over an instruction that exits the entire process while\n# another thread still exists.  We expect the debugger to stop after the exit call\n# and indicate that the process is terminated.\n#\npindb-pthread-step-exitgroup.test: $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that we can single-step over an instruction that triggers a custom breakpoint.\n# This should stop due to the custom breakpoint, without stepping over the instruction.\n# A subsequent step should skip the custom breakpoint and step over the instruction.\n#\npindb-step-custom-break.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX) $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) step-custom-break $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple-pindb$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(OBJDIR)$(@:.test=.pindbin.0) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare) $(OBJDIR)$(@:.test=.pindbin) \\\n\t      $(OBJDIR)$(@:.test=.pindbout)\n\n# Test the behavior when several threads stop at simultaneous tool breakpoints.\n# After one breakpoint is delivered, the others are pending.  This test makes\n# sure that the pending events are delivered one-at-a-time to GDB.  It also\n# tests that the tool can list the pending breakpoints.\n#\nsimultaneous-toolbreak.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\nsimultaneous-toolbreak_const_context.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 -const_context 1 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# After one breakpoint is delivered, the others are pending.  This test\n# squashes the pending breakpoints and then makes sure they are not\n# delivered to GDB.\n#\nsimultaneous-toolbreak-squash.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# After one breakpoint is delivered, the others are pending.  This test\n# changes the message of the pending breakpoints and then makes sure they\n# are delivered with the new message.\n#\nsimultaneous-toolbreak-change.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that we can attach GDB to the application after it has stopped\n# at several simultaneous tool breakpoints.  We expect GDB to attach\n# at the context of one of those breakpoints, and we expect the others\n# to be pending.\n#\nsimultaneous-toolbreak-attach.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) \\\n\t  -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 -wait_for_debugger \\\n\t    -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'Waiting for debugger to attach' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test runs with PinDB, which expects all breakpoints to be delivered\n# simultaneously.  Make sure that all 4 breakpoints are delivered at once,\n# and that none are pending.\n#\npindb-simultaneous-toolbreak.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test runs PinDB in a mode where each breakpoint is delivered one-\n# at-a-time (similar to GDB).  We make sure that there are pending breakpoints\n# after the first is delivered, and we make sure that all breakpoints are\n# delivered one-at-a-time.\n#\npindb-simultaneous-toolbreak-serialize.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test also runs PinDB in a mode where each breakpoint is delivered\n# one-at-a-time.  In this test, we squash the remaining breakpoints after\n# the first is delivered and then make sure that the squashed breakpoints\n# are not delivered.\n#\npindb-simultaneous-toolbreak-squash.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test also runs PinDB in a mode where each breakpoint is delivered\n# one-at-a-time.  In this test, we change the message of the remaining\n# breakpoints after the first is delivered and then make sure that the\n# breakpoints are delivered with the changed message.\n#\npindb-simultaneous-toolbreak-change.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# When breakpoints are delivered one-at-a-time, try single-stepping one\n# thread while there are pending breakpoints on the others.  The pending\n# breakpoints should not be delivered because the single-step doesn't\n# advance the execution of those threads.\n#\npindb-simultaneous-toolbreak-step.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# This is a stress test for simultaneous debugger events.  Each thread stops when\n# the thread is created, at a normal breakpoint, at a tool breakpoint, and stops\n# when the thread exits.  There is no serialization in this variant of the test,\n# so we expect that many events will be reported to the debugger simultaneously.\n# The test verifies that we get all the events.\n#\npindb-simultaneous-multi.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n        $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare3) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare4) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This test is identical to the one above except that we don't stop when new\n# threads are created or when they exit.  We use this test on Windows to avoid\n# a problem with the virus scanner.  If a virus scan happens when this test runs,\n# the scanner injects a new thread into the test application.  If the debugger\n# stops when new threads are created, the scanner thread causes an extra stop in\n# the debugger which causes the test to fail.  This variant of the test avoids\n# the problem by not stopping in the debugger when new threads start or exit.\n# We also run this test on Unix because it tests different code paths in Pin.\n#\npindb-simple-simultaneous-multi.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n        $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This is another stress test for simultaneous debugger events, similar to the\n# one above.  In this variant, Pin delivers the events one-at-a-time to the\n# debugger.  Again, we verifiy that the debugger gets them all.\n#\npindb-simultaneous-multi-serialize.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare3) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare4) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This test is identical to the one above except that we don't stop when new\n# threads are created or when they exit.  We use this test on Windows to avoid\n# a problem with the virus scanner.  See \"pindb-simple-simultaneous-multi.test\"\n# for more information.  We also run it on Unix because it tests different code\n# paths in Pin.\n#\npindb-simple-simultaneous-multi-serialize.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This is similar to \"simultaneous-toolbreak-attach\", but we use PinDB\n# instead of GDB.  The application stops at several simultaneous breakpoints\n# before PinDB attaches.  Since PinDB allows multiple simultaneous breakpoints,\n# we expect all of them to be visible when PinDB attaches, and there will be\n# no pending breakpoints.\n#\n# This is disabled on Windows, but it could probably be enabled there when Mantis #1839 is fixed.\n#\npindb-simultaneous-toolbreak-attach.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -wait_for_debugger -port $(OBJDIR)$(@:.test=.port) -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 \\\n\t    > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'Waiting for debugger to attach' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    --gdb-protocol=:`cat $(OBJDIR)$(@:.test=.port)` $(PINDB_USERFLAGS) < $(@:.test=.pindbin) > \\\n\t    $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address) \\\n\t  $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port)\n\n# Test that we can use a custom command to change the register state of the target application,\n# and then use the \"invalidate registers\" API to invalidate any stale register data in the\n# debugger protocol library.\n#\npindb-invalidate-regs.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)invalidate-regs$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)invalidate-regs$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --noprompt $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# This test validates stopping threads API called in application thread.\napp-pause-in-app-thread.test: $(OBJDIR)app-pause-in-app-thread-tool$(PINTOOL_SUFFIX) $(OBJDIR)app-pause-app$(EXE_SUFFIX)\n\t$(PIN) -t $(OBJDIR)app-pause-in-app-thread-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)app-pause-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out)\n\t$(CGREP) 'Threads stopped by application thread' $(OBJDIR)$(@:.test=.out) | $(QGREP) \"3\"\n\t$(RM) $(OBJDIR)$(@:.test=.out)\n\n# This test validates stopping threads API called in internal thread.\napp-pause-in-int-thread.test: $(OBJDIR)app-pause-in-int-thread-tool$(PINTOOL_SUFFIX) $(OBJDIR)app-pause-app$(EXE_SUFFIX)\n\t$(PIN) -t $(OBJDIR)app-pause-in-int-thread-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)app-pause-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out)\n\t$(CGREP) 'Threads stopped by internal thread' $(OBJDIR)$(@:.test=.out) | $(QGREP) \"3\"\n\t$(RM) $(OBJDIR)$(@:.test=.out)\n\ncheck-if-thread-stopped.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)check-if-thread-stopped$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)check-if-thread-stopped$(PINTOOL_SUFFIX) -threads 4\" \\\n\t  -o $(OBJDIR)$(@:.test=.toolout) > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(QGREP) \"Finished\" $(OBJDIR)$(@:.test=.toolout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.toolout)\n\n# Tests GDB extension of retrieving loaded shared libraries\n# Also, this test changes the base address of libc.so as seen\n# by GDB to 0xd00dead and checks that GDB reports the expected\n# base address.\n#\ngdb-svr4-libraries-extension.test: $(OBJDIR)dlopen-dlclose$(EXE_SUFFIX) $(OBJDIR)library-load-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)library-load-tool$(PINTOOL_SUFFIX) -- \\\n\t    $(OBJDIR)dlopen-dlclose$(EXE_SUFFIX) `$(CXX) $(COMP_OBJ) /dev/null -print-file-name=libgcc_s.so` > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)dlopen-dlclose$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n\n##############################################################\n#\n# Build rules\n#\n##############################################################\n\n# This section contains the build rules for all binaries that have special build rules.\n# See makefile.default.rules for the default build rules.\n\n###### Special tools' build rules ######\n\n$(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX): $(OBJDIR)use-debugger-shell$(OBJ_SUFFIX) $(OBJDIR)debugger-shell$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches_before_breakpoint$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches_for_ymmtest$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches_for_ymmtest$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n###### Special applications' build rules ######\n\n$(OBJDIR)simple$(EXE_SUFFIX): simple.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)bphandler_app$(EXE_SUFFIX): bphandler_app.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)simple-static$(EXE_SUFFIX): simple.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(STATIC) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)exec$(EXE_SUFFIX): exec.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)fork$(EXE_SUFFIX): fork.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX): bptest.cpp bptest-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)action-pending-app$(EXE_SUFFIX): action-pending-app.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX): xmm.c xmm-asm-$(TARGET).s\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)thread$(EXE_SUFFIX): thread.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)thread-static$(EXE_SUFFIX): thread.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(STATIC) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)simple-pindb$(EXE_SUFFIX): simple-pindb.cpp $(OBJDIR)simple-pindb-asm-$(TARGET_OS)-$(TARGET)$(OBJ_SUFFIX)\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(NO_RANDOM) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)checkpoint-app$(EXE_SUFFIX): checkpoint-app.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)watchpoint-app$(EXE_SUFFIX): watchpoint-app.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)callerapp$(EXE_SUFFIX): callerapp.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)fibonacci$(EXE_SUFFIX): $(TOOLS_ROOT)/ManualExamples/fibonacci.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)sleep-unix$(EXE_SUFFIX): sleep-unix.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX): debugger-shell-app.cpp debugger-shell-app-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)intercept-app$(EXE_SUFFIX): intercept-app.cpp intercept-app-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX): ymm.cpp ymm-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pc-change-bp$(EXE_SUFFIX): pc-change-bp.cpp pc-change-bp-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pc-change-async$(EXE_SUFFIX): pc-change-async.cpp pc-change-async-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)mt-exit$(EXE_SUFFIX): mt-exit.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)signal-catch$(EXE_SUFFIX): signal-catch.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-unhandled-exception$(EXE_SUFFIX): win-unhandled-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n \n$(OBJDIR)win-handled-exception$(EXE_SUFFIX): win-handled-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-continued-exception1$(EXE_SUFFIX): win-continued-exception1.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-continued-exception2$(EXE_SUFFIX): win-continued-exception2.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-software-exception$(EXE_SUFFIX): win-software-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-cpp-exception$(EXE_SUFFIX): win-cpp-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-load-library$(EXE_SUFFIX): win-load-library.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)reattach-loop$(EXE_SUFFIX): reattach-loop.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-thread-stress$(EXE_SUFFIX): win-thread-stress.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pthread-bare-exit$(EXE_SUFFIX): pthread-bare-exit.cpp pthread-bare-exit-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX): pthread-bare-exitgroup.cpp pthread-bare-exitgroup-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n# A simple threaded application that we use for several tests.  Both Windows and Posix (Unix)\n# versions export the function \"GlobalFunction()\", which the tests rely on.\n#\n$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX): thread-$(OS_TYPE).cpp\n\t$(APP_CXX) $(COMPONENT_INCLUDES) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)app-pause-app$(EXE_SUFFIX): app-pause-app.cpp $(THREADLIB)\n\t$(APP_CXX) $(COMPONENT_INCLUDES) $(APP_CXXFLAGS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS) $(APP_LPATHS) $(APP_LIBS) $(APP_LIB_ATOMIC)\n\n###### Special objects' build rules ######\n\n$(OBJDIR)stack-debugger$(OBJ_SUFFIX): $(TOOLS_ROOT)/ManualExamples/stack-debugger.cpp\n\t$(CXX) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)debugger-shell$(OBJ_SUFFIX): $(TOOLS_ROOT)/InstLib/debugger-shell.cpp\n\t$(CXX) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)start-fini-callback$(OBJ_SUFFIX): start-fini-callback.cpp\n\t$(CXX) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)simple-pindb-asm-$(TARGET_OS)-$(TARGET)$(OBJ_SUFFIX): simple-pindb-asm-$(TARGET_OS)-$(TARGET)$(ASM_SUFFIX)\n\t$(ASMBLR) $(ASM_FLAGS) $(DBG_INFO_CXX_ALWAYS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)win-foo-library$(OBJ_SUFFIX): win-foo-library.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DLL_CXXFLAGS) $(DBG_INFO_CXX_ALWAYS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX): set_xmm_scratches_$(TARGET)$(ASM_SUFFIX)\n\t$(ASMBLR) $(ASM_FLAGS) $(DBG_INFO_CXX_ALWAYS) $(COMP_OBJ)$@ $<\n\n###### Special dlls' build rules ######\n\n$(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX): $(OBJDIR)win-foo-library$(OBJ_SUFFIX)\n\t$(LINKER) $(APP_LDFLAGS_NOOPT) $(DLL_LDFLAGS) $(LINK_EXE)$@ $< $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Debugger/dlopen-dlclose.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#define _GNU_SOURCE\n#include <dlfcn.h>\n#include <link.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// Macro to create empty function which won't be opt-out by\n// the compiler\n#define EMPTY_FUNCTION(name) \\\n    void name();        \\\n    __asm__(              \\\n    \".global \" #name \"\\n\" \\\n    #name \":\\n\"          \\\n    \"ret\\n\"               \\\n    )\n\nEMPTY_FUNCTION(AfterLoadLibrary);\nEMPTY_FUNCTION(AfterUnloadLibrary);\n\nint main(int argc, char* argv[])\n{\n    if (argc != 2)\n    {\n        fprintf(stderr, \"Usage: %s <path to dynamic library>\\n\", argv[0]);\n        exit(1);\n    }\n    const char* file = argv[1];\n    printf(\"Loading shared object %s\\n\", file);\n    fflush(stdout);\n    void *handle = dlopen(file, RTLD_NOW | RTLD_LOCAL);\n    if (NULL == handle)\n    {\n        fprintf(stderr,\"Failed to load %s - %s\\n\", file, dlerror());\n        exit(1);\n    }\n    AfterLoadLibrary();\n    printf(\"Unloading shared object %s\\n\", file);\n    fflush(stdout);\n    dlclose(handle);\n    AfterUnloadLibrary();\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/ToolUnitTests/dltest.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define ONE \"libone.dylib\"\n#define TWO \"libtwo.dylib\"\n#else\n#define ONE \"libone.so\"\n#define TWO \"libtwo.so\"\n#endif\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n#if defined(TARGET_MAC) || defined(TARGET_BSD)\n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);\n#else    \n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);\n#endif    \n    fprintf(stderr, \"Allocated %p\\n\",mem);\n    // This unmap should not trigger a flush\n    munmap(mem, 0x2000);\n    \n    Load(ONE, 1);\n    Load(TWO, 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/ToolUnitTests/dltest2.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define ONE \"libone.dylib\"\n#define TWO \"libtwo.dylib\"\n#else\n#define ONE \"libone.so\"\n#define TWO \"libtwo.so\"\n#endif\n\nvoid Load(char *name, int expect)\n{\n    int val;\n    double dval;\n    \n    void *handle;\n    int (*sym)();\n    double (*fsin)(double);\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n        \n    val = sym();\n    if (val != expect)\n        exit(1);\n\n    dlclose(handle);\n}\n\nint main()\n{\n    int i;\n    for(i = 0; i < 100; i++)\n    {\n        switch(1 + rand() % 2) {\n        case 1:\n            Load(ONE, 1);\n            break;\n        case 2:\n            Load(TWO, 2);\n            break;\n        }\n    }\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/ToolUnitTests/dlclose_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define LIBCLOSE \"libclose1.dylib\"\n#else\n#define LIBCLOSE \"libclose1.so\"\n#endif\n\nvoid Load(const char * name)\n{\n    void * handle;\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    dlclose(handle);\n}\n\nint main()\n{\n    Load(LIBCLOSE);\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/MacTests/bundle_app.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <dlfcn.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n    void *bundle = 0;\n    const char* (*fptr)();\n    bundle = dlopen(argv[1], RTLD_LAZY);\n    if (bundle)\n    {\n        fprintf(stdout, \"Loaded bundle successfully\\n\");\n    }\n    else\n    {\n        fprintf(stderr, \"Failed to load bundle: %s\\n\", dlerror());\n        return 1;\n    }\n\n    fptr = (const char* (*)())dlsym(bundle, \"my_function\");\n\n    if (fptr)\n    {\n        fprintf(stdout, \"Located symbol successfully\\n\");\n    }\n    else\n    {\n        fprintf(stderr, \"Failed to locate symbol in bundle: %s\\n\", dlerror());\n        return 1;\n    }\n\n    fprintf(stdout, \"Calling bundle function...\\n\");\n    fprintf(stdout, \"Bundle function call result: %s\\n\", (*fptr)());\n    fprintf(stdout, \"Called bundle function.\\n\");\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/MacTests/section_app.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <dlfcn.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n    void *bundle = 0;\n    bundle = dlopen(argv[1], RTLD_LAZY);\n    if (bundle)\n    {\n        fprintf(stdout, \"Loaded library successfully\\n\");\n    }\n    else\n    {\n        fprintf(stderr, \"Failed to load library: %s\\n\", dlerror());\n        return 1;\n    }\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/dltest_unix.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n#if defined(TARGET_MAC) || defined(TARGET_BSD)\n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);\n#else    \n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);\n#endif    \n    fprintf(stderr, \"Allocated %p\\n\",mem);\n    // This unmap should not trigger a flush\n    munmap(mem, 0x2000);\n    \n    Load(\"libone.so\", 1);\n    Load(\"libtwo.so\", 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/malloctrace2.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n\n/* ===================================================================== */\n/*\n  @ORIGINAL_AUTHOR: Robert Cohn, Elena Demikhovsky\n*/\n\n/* ===================================================================== */\n/*! @file\n The test shows how wrappers may be implemented in DLL loaded in runtime.\n The dopen() is being called from application space. But it can't be called \n before libc is initialized.\n In this example I call dlopen before main().\n */\n\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n\nusing namespace std;\n\n\n/* ===================================================================== */\n/* Commandline Switches */\n/* ===================================================================== */\n\nKNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\",\n    \"o\", \"malloctrace2.outfile\", \"specify trace file name\");\n\n/* ===================================================================== */\n\nINT32 Usage()\n{\n    cerr <<\n        \"This pin tool inserts a user-written version of malloc() and free() into the application.\\n\"\n        \"\\n\";\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return -1;\n}\n\n\n/* ===================================================================== */\n/* Definitions for Probe mode */\n/* ===================================================================== */\n\ntypedef typeof(malloc) * MallocType;\ntypedef typeof(free) * FreeType;\ntypedef typeof(dlopen) * DlopenType;\ntypedef typeof(dlsym) * DlsymType;\n\nMallocType MallocWrapper = 0;\nMallocType origMalloc = 0;\n\nFreeType FreeWrapper = 0;\nFreeType origFree = 0;\n\nvoid * MallocTraceHandle = 0;\n\nDlopenType AppDlopen = 0;\nDlsymType AppDlsym = 0;\n\ntypedef VOID (*SET_ORIG_FPTR)(MallocType mallocPtr, FreeType freePtr);\n\n/* ===================================================================== */\n/* Probe mode tool */\n/* ===================================================================== */\n\nVOID *MallocWrapperInTool(size_t size)\n{\n    if (MallocWrapper)\n    {\n        return (*MallocWrapper)(size);\n    }\n    else\n    {\n        ASSERTX(origMalloc != 0);\n        return (*origMalloc)(size);\n    }\n}\n\nVOID FreeWrapperInTool(void *p)\n{\n    if (FreeWrapper)\n    {\n        (*FreeWrapper)(p);\n    }\n    else\n    {\n        ASSERTX(origFree != 0);\n        (*origFree)(p);\n    }\n}\n\n/* I'm calling dlopen before main.\n * Some malloc-free may be lost, of course.\n * But the earliest point you can call dlopen is after init of libc\n */\nVOID MainRtnCallback()\n{\n    cout << \"In main callback\" << endl;\n    // inject libmallocwrappers.so into application by executing application dlopen\n\n    MallocTraceHandle = AppDlopen(\"libmallocwrappers.so\", RTLD_LAZY);\n    ASSERTX(MallocTraceHandle);\n\n    // Get function pointers for the wrappers\n    MallocWrapper = MallocType(AppDlsym(MallocTraceHandle, \"mallocWrapper\"));\n    FreeWrapper = FreeType(AppDlsym(MallocTraceHandle, \"freeWrapper\"));\n    ASSERTX(MallocWrapper && FreeWrapper);\n\n    // Send original function pointers to libmallocwrappers.so\n    SET_ORIG_FPTR setOriginalFptr = (SET_ORIG_FPTR) AppDlsym(MallocTraceHandle, \"SetOriginalFptr\");\n    ASSERTX(setOriginalFptr != 0);\n    (*setOriginalFptr)(origMalloc, origFree);\n}\n\nVOID ImageLoad(IMG img, VOID *v)\n{\n    if (strstr(IMG_Name(img).c_str(), \"libdl.so\"))\n    {\n        // Get the function pointer for the application dlopen:\n        // dlopen@@GLIBC_2.1 is the official, versioned name.\n        // \n        // The exact suffix must match the ABI of the libdl header files\n        // this source code gets compiled against. Makefile/configure\n        // trickery would be needed to figure this suffix out, so it\n        // is simply hard-coded here.\n        //\n        // To keep the resulting binaries compatible with future libdl.so\n        // versions, this code also checks for backwards compatibility\n        // versions of the calls as they would be provided in such a\n        // future version.\n        \n#if defined(TARGET_IA32E)\n# define DLOPEN_VERSION \"GLIBC_2.2.5\"\n# define DLSYM_VERSION \"GLIBC_2.2.5\"\n#elif defined(TARGET_IA32)\n# define DLOPEN_VERSION \"GLIBC_2.1\"\n# define DLSYM_VERSION \"GLIBC_2.0\"\n#else\n# error symbol versions unknown for this target\n#endif\n            \n        RTN dlopenRtn = RTN_FindByName(img, \"dlopen@@\" DLOPEN_VERSION);\n        if (!RTN_Valid(dlopenRtn)) \n        {\n            dlopenRtn = RTN_FindByName(img, \"dlopen@\" DLOPEN_VERSION);\n        }\n\n        if (!RTN_Valid(dlopenRtn)) \n        {\n            // fallback for the cases in which symbols do not have a version\n            dlopenRtn = RTN_FindByName(img, \"dlopen\");\n        }\n        \n        ASSERTX(RTN_Valid(dlopenRtn));\n        AppDlopen = DlopenType(RTN_Funptr(dlopenRtn));\n        \n        // Get the function pointer for the application dlsym\n        RTN dlsymRtn = RTN_FindByName(img, \"dlsym@@\" DLSYM_VERSION);\n        if (!RTN_Valid(dlsymRtn)) {\n            dlsymRtn = RTN_FindByName(img, \"dlsym@\" DLSYM_VERSION);\n        }\n        if (!RTN_Valid(dlsymRtn)) {\n            // fallback for the cases in which symbols do not have a version\n            dlsymRtn = RTN_FindByName(img, \"dlsym\");\n        }\n        \n        ASSERTX(RTN_Valid(dlsymRtn));\n        AppDlsym = DlsymType(RTN_Funptr(dlsymRtn));\n\n        \n    }\n\n    if (strstr(IMG_Name(img).c_str(), \"libc.so\"))\n    {\n        // Replace malloc and free in application libc with wrappers in libmallocwrappers.so\n        RTN mallocRtn = RTN_FindByName(img, \"malloc\");\n        ASSERTX(RTN_Valid(mallocRtn));\n\n        if ( ! RTN_IsSafeForProbedReplacement( mallocRtn ) )\n        {\n            cout << \"Cannot replace malloc in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n        RTN freeRtn = RTN_FindByName(img, \"free\");\n        ASSERTX(RTN_Valid(freeRtn));\n\n        if ( ! RTN_IsSafeForProbedReplacement( freeRtn ) )\n        {\n            cout << \"Cannot replace free in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n        \n        origMalloc = (MallocType)RTN_ReplaceProbed(mallocRtn, AFUNPTR(MallocWrapperInTool));\n        \n        origFree = (FreeType)RTN_ReplaceProbed(freeRtn, AFUNPTR(FreeWrapperInTool));\n\n    }\n    \n    /* I call dopen before main. If this point is too late for you,\n    catch init() of libc and call dlopen after init() is done\n    */\n    if (IMG_IsMainExecutable(img))\n    {\n        RTN mainRtn = RTN_FindByName(img, \"_main\");\n        if (!RTN_Valid(mainRtn))\n            mainRtn = RTN_FindByName(img, \"main\");\n\n        if (!RTN_Valid(mainRtn))\n        {\n            cout << \"Can't find the main routine in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n        RTN_InsertCallProbed(mainRtn, IPOINT_BEFORE, AFUNPTR(MainRtnCallback), IARG_END);\n    }\n}\n\n                    \n\n/* ===================================================================== */\n/* main */\n/* ===================================================================== */\n\nint main(int argc, CHAR *argv[])\n{\n    PIN_InitSymbols();\n    \n    if( PIN_Init(argc,argv) )\n    {\n        return Usage();\n    }\n    \n    IMG_AddInstrumentFunction(ImageLoad, 0);\n        \n    PIN_StartProgramProbed();\n    \n    return 0;\n}\n\n/* ===================================================================== */\n/* eof */\n/* ===================================================================== */\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/tpss_lin_libdl.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n * This tool mimics the behavior of TPSS on Linux by adding probes to various libdl functions.\n * However, in this tool these probes are merely empty wrappers that call the original functions.\n * The objective of the test is to verify that probe generation and insertion don't cause Pin\n * to crash.\n */\n\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <dlfcn.h>\n\ntypedef char * CHAR_PTR;\n\ntypedef void * VOID_PTR;\n\nofstream OutFile;\n\n/* ===================================================================== */\n/* Commandline Switches                                                  */\n/* ===================================================================== */\n\nKNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\",\n    \"o\", \"tpss_lin_libdl.txt\", \"specify tool log file name\");\n\n/* ===================================================================== */\n/* Utility functions                                                     */\n/* ===================================================================== */\n\n// Print help information\nINT32 Usage()\n{\n    cerr << \"This tool mimics the behavior of TPSS on Linux by adding probes to various libdl functions.\" << endl;\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return 1;\n}\n\n// Utility function to return the time\nstring CurrentTime()\n{\n    char tmpbuf[128];\n    time_t thetime = time(NULL);\n    ctime_r(&thetime, tmpbuf);\n    return tmpbuf;\n}\n\n\n/* ===================================================================== */\n/* Function signatures - these functions will be probed                  */\n/* ===================================================================== */\n\nVOID_PTR (*fptrdlopen)(__const CHAR_PTR __file, int  __mode);\n\nint (*fptrdlclose)(VOID_PTR __handle);\n\nVOID_PTR (*fptrdlsym)(VOID_PTR __handle , __const CHAR_PTR __name );\n\nVOID_PTR (*fptrdlvsym)( VOID_PTR __handle, __const CHAR_PTR __name,__const CHAR_PTR __version);\n\nint (*fptrdladdr)(__const void *__address , Dl_info * __info);\n\nint (*fptrdladdr1)(__const void * __address , Dl_info * __info, void ** __extra_info, int __flags);\n\nCHAR_PTR (*fptrdlerror)(void);\n\n/* ===================================================================== */\n/* Probes - implementation of the wrapper functions                      */\n/* ===================================================================== */\n\nVOID_PTR mydlopen(__const CHAR_PTR __file, int __mode)\n{\n   OutFile << CurrentTime() << \"mydlopen called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlopen(__file, __mode);\n\n   return res;\n}\n\nint mydlclose(VOID_PTR __handle)\n{\n   OutFile << CurrentTime() << \"mydlclose called \" << endl;\n   OutFile.flush();\n   int res = fptrdlclose(__handle);\n\n   return res;\n}\n\nVOID_PTR mydlsym(VOID_PTR  __handle, __const CHAR_PTR  __name)\n{\n   OutFile << CurrentTime() << \"mydlsym called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlsym(__handle, __name);\n\n   return res;\n}\n\nVOID_PTR mydlvsym(VOID_PTR  __handle, __const CHAR_PTR  __name, __const CHAR_PTR __version)\n{\n   OutFile << CurrentTime() << \"mydlvsym called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlvsym(__handle, __name, __version);\n\n   return res;\n}\n\nint mydladdr(__const void * __address, Dl_info * __info)\n{\n   OutFile << CurrentTime() << \"mydladdr called \" << endl;\n   OutFile.flush();\n   int res = fptrdladdr(__address, __info);\n\n   return res;\n}\n\nint mydladdr1(__const void * __address, Dl_info * __info, void ** __extra_info, int __flags)\n{\n   OutFile << CurrentTime() << \"mydladdr1 called \" << endl;\n   OutFile.flush();\n   int res = fptrdladdr1(__address, __info, __extra_info, __flags);\n\n   return res;\n}\n\nCHAR_PTR mydlerror(void)\n{\n   OutFile << CurrentTime() << \"CHAR_PTR called \" << endl;\n   OutFile.flush();\n   CHAR_PTR res = fptrdlerror();\n\n   return res;\n}\n\n/* ===================================================================== */\n/* Instrumnetation functions                                             */\n/* ===================================================================== */\n\n// Image load callback - inserts the probes.\nvoid ImgLoad(IMG img, void *v)\n{\n    // Called every time a new image is loaded\n\n    if ( (IMG_Name(img).find(\"libdl.so\") != string::npos) ||\n         (IMG_Name(img).find(\"LIBDL.SO\") != string::npos) ||\n         (IMG_Name(img).find(\"LIBDL.so\") != string::npos) )\n    {\n        RTN rtndlclose = RTN_FindByName(img, \"dlclose\");\n        if (RTN_Valid(rtndlclose) && RTN_IsSafeForProbedReplacement(rtndlclose))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlclose at \" << RTN_Address(rtndlclose) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlclose, AFUNPTR(mydlclose)));\n            fptrdlclose = (int (*)(VOID_PTR ))fptr;\n        }\n\n        RTN rtndlopen = RTN_FindByName(img, \"dlopen\");\n        if (RTN_Valid(rtndlopen) && RTN_IsSafeForProbedReplacement(rtndlopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlopen at \" << RTN_Address(rtndlopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlopen, AFUNPTR(mydlopen)));\n            fptrdlopen = (VOID_PTR (*)(__const CHAR_PTR , int ))fptr;\n        }\n\n        RTN rtndlsym = RTN_FindByName(img, \"dlsym\");\n        if (RTN_Valid(rtndlsym) && RTN_IsSafeForProbedReplacement(rtndlsym))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlsym at \" << RTN_Address(rtndlsym) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlsym, AFUNPTR(mydlsym)));\n            fptrdlsym = (VOID_PTR (*)(VOID_PTR, __const CHAR_PTR ))fptr;\n        }\n\n        RTN rtndlvsym = RTN_FindByName(img, \"dlvsym\");\n        if (RTN_Valid(rtndlvsym) && RTN_IsSafeForProbedReplacement(rtndlvsym))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlvsym at \" << RTN_Address(rtndlvsym) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlvsym, AFUNPTR(mydlvsym)));\n            fptrdlvsym = (VOID_PTR (*)(VOID_PTR, __const CHAR_PTR, __const CHAR_PTR))fptr;\n        }\n\n        RTN rtndladdr = RTN_FindByName(img, \"dladdr\");\n        if (RTN_Valid(rtndladdr) && RTN_IsSafeForProbedReplacement(rtndladdr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dladdr at \" << RTN_Address(rtndladdr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndladdr, AFUNPTR(mydladdr)));\n            fptrdladdr = (int (*)(__const void * , Dl_info * ))fptr;\n        }\n\n        RTN rtndladdr1 = RTN_FindByName(img, \"dladdr1\");\n        if (RTN_Valid(rtndladdr) && RTN_IsSafeForProbedReplacement(rtndladdr1))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dladdr1 at \" << RTN_Address(rtndladdr1) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndladdr, AFUNPTR(mydladdr1)));\n            fptrdladdr1 = (int (*)(__const void * , Dl_info *, void **, int ))fptr;\n        }\n\n        RTN rtndlerror = RTN_FindByName(img, \"dlerror\");\n        if (RTN_Valid(rtndlerror) && RTN_IsSafeForProbedReplacement(rtndlerror))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlerror at \" << RTN_Address(rtndlerror) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlerror, AFUNPTR(mydlerror)));\n            fptrdlerror = (CHAR_PTR (*)(void ))fptr;\n        }\n    }\n    // finished instrumentation\n}\n\n/* ===================================================================== */\n/* Main function                                                         */\n/* ===================================================================== */\n\nint main(int argc, char *argv[])\n{\n    // Initialize Pin\n    PIN_InitSymbols();\n    if (PIN_Init(argc,argv))\n    {\n        return Usage();\n    }\n\n    OutFile.open(KnobOutputFile.Value().c_str());\n    OutFile << hex;\n    OutFile.setf(ios::showbase);\n    OutFile << CurrentTime() << \"started!\" << endl;\n    OutFile.flush();\n\n    // Register the instrumentation callback\n    IMG_AddInstrumentFunction(ImgLoad, 0);\n\n\n    // Start the application\n    PIN_StartProgramProbed(); // never returns\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/unloadtest_unix.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n    Load(\"libone.so\", 1);\n    Load(\"libtwo.so\", 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/tpss_lin_libc.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n * This tool mimics the behavior of TPSS on Linux by adding probes to various libc functions.\n * However, in this tool these probes are merely empty wrappers that call the original functions.\n * The objective of the test is to verify that probe generation and insertion don't cause Pin\n * to crash.\n */\n\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <ctime>\n#include <sys/types.h>\n#include <sys/timeb.h>\n#include <rpc/rpc.h>\n#include <rpc/pmap_clnt.h>\n#include <semaphore.h>\n#include <dlfcn.h>\n#include <signal.h>\n#include <poll.h>\n#include <time.h>\n#include <link.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <sys/ipc.h>\n#include <sys/sem.h>\n#include <signal.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <stdio.h>\n#include <string.h>\n#include <wchar.h>\n#include <sys/socket.h>\n#include <sys/utsname.h>\n#include <sched.h>\n#include <time.h>\n\n/* ===================================================================== */\n/* Commandline Switches                                                  */\n/* ===================================================================== */\n\ntypedef int * INT_PTR;\n\ntypedef void * VOID_PTR;\n\ntypedef char * CHAR_PTR;\n\nofstream OutFile;\n\nKNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\", \"o\", \"tpss_lin_libc.txt\",\n        \"specify tool log file name\");\n\n/* ===================================================================== */\n/* Utility functions                                                     */\n/* ===================================================================== */\n\n// Print help information\nINT32 Usage() {\n    cerr\n            << \"This tool mimics the behavior of TPSS on Linux by adding probes to various libc functions.\"\n            << endl;\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return 1;\n}\n\n// Utility function to return the time\nstring CurrentTime() {\n    char tmpbuf[128];\n    time_t thetime = time(NULL);\n    ctime_r(&thetime, tmpbuf);\n    return tmpbuf;\n}\n\n/* ===================================================================== */\n/* Function signatures - these functions will be probed                  */\n/* ===================================================================== */\n\nint (*fptrnanosleep)(const struct timespec *__rqtp, struct timespec *__rmtp);\n\nint (*fptrdl_iterate_phdr)(int (*__callback)(struct dl_phdr_info *__info, size_t __size,\n    VOID_PTR __data), VOID_PTR __data);\n\nint (*fptrsystem)(const CHAR_PTR __command);\n\nunsigned int (*fptralarm)(unsigned int __seconds);\n\nssize_t (*fptrrecvmsg)(int __socket, struct msghdr *__message, int __flags);\n\nssize_t (*fptrsendmsg)(int __sockfd, const struct msghdr *__msg, int __flags);\n\nint (*fptrpause)(void);\n\nint (*fptrsigtimedwait)(const sigset_t *__set, siginfo_t *__info, const struct timespec *__timeout);\n\nint (*fptrsigwaitinfo)(const sigset_t *__set, siginfo_t *__info);\n\nint (*fptrepoll_wait)(int __epfd, struct epoll_event *__events, int __maxevents,\n    int __timeout);\n\nint (*fptrepoll_pwait)(int __epfd, struct epoll_event *__events,\n    int __maxevents, int __timeout, const sigset_t *__sigmask);\n\nint (*fptrppoll)(struct pollfd *__fds, nfds_t __nfds,\n    const struct timespec *__timeout_ts, const sigset_t *__sigmask);\n\nint (*fptrmsgsnd)(int __msqid, const VOID_PTR __msgp, size_t __msgsz, int __msgflg);\n\nssize_t (*fptrmsgrcv)(int __msqid, VOID_PTR __msgp, size_t __msgsz, long __msgtyp, int __msgflg);\n\nint (*fptrsemop)(int __semid, struct sembuf *__sops, unsigned __nsops);\n\nint (*fptrsemtimedop)(int __semid, struct sembuf *__sops);\n\nint (*fptrusleep)(useconds_t __usec);\n\nuseconds_t (*fptrualarm)(useconds_t __usecs, useconds_t __interval);\n\nint (*fptrgetitimer)(int __which, struct itimerval *__curr_value);\n\nint (*fptrsigwait)(const sigset_t *__set, INT_PTR __sig);\n\nint (*fptrmsgget)(key_t __key, int __msgflg);\n\nint (*fptrsemget)(key_t __key, int __nsems, int __semflg);\n\npid_t (*fptrwait)(INT_PTR __status);\n\npid_t (*fptrwaitpid)(pid_t __pid, INT_PTR __atus, int __options);\n\nint (*fptrwaitid)(idtype_t __idtype, id_t __id, siginfo_t *__infop,int __options);\n\npid_t (*fptrwait3)(INT_PTR __status, int __options, struct rusage *__rusage);\n\npid_t (*fptrwait4)(pid_t __pid, INT_PTR status, int __options, struct rusage *__rusage);\n\nssize_t (*fptrreadv)(int __fd, const struct iovec *__iov, int __iovcnt);\n\nssize_t (*fptrwritev)(int __fd, const struct iovec *__iov, int __iovcnt);\n\nint (*fptrflock)(int __fd, int __operation);\n\nvoid (*fptrflockfile)(FILE *__filehandle);\n\nvoid (*fptrfunlockfile)(FILE *__filehandle);\n\nint (*fptrlockf)(int __fd, int __cmd, off_t __len);\n\nint (*fptrsetenv)(const CHAR_PTR __name, const CHAR_PTR __value, int __overwrite);\n\nint (*fptrunsetenv)(const CHAR_PTR __name);\n\nCHAR_PTR (*fptrgetenv)(const CHAR_PTR __name);\n\nvoid (*fptrperror)(const CHAR_PTR __s);\n\nVOID_PTR (*fptrmmap)(VOID_PTR __addr, size_t __len, int __prot, int __flags,\n        int __fildes, off_t __off);\n\nint (*fptrmunmap)(VOID_PTR __addr, size_t __len);\n\nint (*fptrfileno)(FILE *__stream);\n\npid_t (*fptrgetpid)(void);\n\npid_t (*fptrgetppid)(void);\n\nVOID_PTR (*fptrmemset)(VOID_PTR __s, int __c, size_t __n);\n\nVOID_PTR (*fptrmemcpy)(VOID_PTR __dest, const VOID_PTR __src, size_t __n);\n\nint (*fptraccess)(const CHAR_PTR __pathname, int __mode);\n\noff_t (*fptrlseek)(int __fd, off_t __offset, int __whence);\n\noff64_t (*fptrlseek64)(int __fd, off64_t __offset, int __whence);\n\nint (*fptrfdatasync)(int __fd);\n\nint (*fptrunlink)(const CHAR_PTR __pathname);\n\nsize_t (*fptrstrlen)(const CHAR_PTR __s);\n\nsize_t (*fptrwcslen)(const wchar_t *__s);\n\nCHAR_PTR (*fptrstrcpy)(CHAR_PTR __dest, const CHAR_PTR __src);\n\nCHAR_PTR (*fptrstrncpy)(CHAR_PTR __dest, const CHAR_PTR __src, size_t __n);\n\nCHAR_PTR (*fptrstrcat)(CHAR_PTR __dest, const CHAR_PTR __src);\n\nCHAR_PTR (*fptrstrstr)(const CHAR_PTR __haystack, const CHAR_PTR __needle);\n\nCHAR_PTR (*fptrstrchr0)(const CHAR_PTR __s, int __c);\n\nCHAR_PTR (*fptrstrrchr)(const CHAR_PTR __s, int __c);\n\nint (*fptrstrcmp)(const CHAR_PTR __s1, const CHAR_PTR __s2);\n\nint (*fptrstrncmp)(const CHAR_PTR __s1, const CHAR_PTR __s2, size_t __n);\n\nint (*fptrsigaddset)(sigset_t *__set, int __signum);\n\nint (*fptrsigdelset)(sigset_t *__set, int __signum);\n\nint (*fptrsigismember)(const sigset_t *__set, int __signum);\n\nCHAR_PTR (*fptrstrerror)(int __errnum);\n\nint (*fptrbind)(int __sockfd, const struct sockaddr *__addr, socklen_t __addrlen);\n\nint (*fptrlisten)(int __sockfd, int __backlog);\n\nint (*fptruname)(struct utsname *__name);\n\nint (*fptrgethostname)(CHAR_PTR __name, size_t __len);\n\nint (*fptrkill)(pid_t __pid, int __sig);\n\nint (*fptrsched_yield)(void);\n\nint (*fptrtimer_settime)(timer_t __timerid, int __flags, const struct itimerspec * __value, struct itimerspec * __ovalue);\n\nint (*fptrsigaltstack)(const stack_t *__ss, stack_t *__oss);\n\nint (*fptrshutdown)(int, int);\n\nint (*fptrsleep)(unsigned int);\n\nint (*fptrsocket)(int, int, int);\n\nint (*fptrselect)(int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict, struct timeval *__restrict);\n\nint (*fptrpoll)(struct pollfd *, nfds_t, int);\n\nint (*fptraccept)(int, __SOCKADDR_ARG, socklen_t *__restrict);\n\nint (*fptrconnect)(int, __CONST_SOCKADDR_ARG, socklen_t);\n\nssize_t (*fptrrecv)(int, VOID_PTR , size_t, int);\n\nssize_t (*fptrrecvfrom)(int, VOID_PTR __restrict, size_t, int, __SOCKADDR_ARG, socklen_t *__restrict);\n\nssize_t (*fptrsend)(int, __const VOID_PTR , size_t, int);\n\nwint_t (*fptrgetwc)(__FILE *);\n\nint (*fptrsetitimer)(__itimer_which_t, __const struct itimerval *__restrict, struct itimerval *__restrict);\n\nint (*fptrsigpending)(sigset_t *);\n\nint (*fptrsigaction)(int, __const struct sigaction *__restrict, struct sigaction *__restrict);\n\n__sighandler_t (*fptrsignal)(int, __sighandler_t);\n\nvoid (*fptrabort)();\n\nssize_t (*fptrsendto)(int, __const VOID_PTR , size_t, int, __CONST_SOCKADDR_ARG, socklen_t);\n\nint (*fptr_IO_getc)(FILE *);\n\nint (*fptrgetchar)();\n\nwint_t (*fptrgetwchar)();\n\nCHAR_PTR  (*fptrgets)(CHAR_PTR );\n\nCHAR_PTR  (*fptrfgets)(CHAR_PTR __restrict, int, FILE *__restrict);\n\nwint_t (*fptrfgetwc)(__FILE *);\n\nsize_t (*fptrfread)(VOID_PTR __restrict, size_t, size_t, FILE *__restrict);\n\nsize_t (*fptrfwrite)(__const VOID_PTR __restrict, size_t, size_t, FILE *__restrict);\n\nint (*fptropen)(__const CHAR_PTR , int, mode_t);\n\nint (*fptrgetw)(FILE *);\n\nvoid (*fptrfgetc)(__FILE *);\n\nwchar_t * (*fptrfgetws)(wchar_t *__restrict, int, __FILE *__restrict);\n\nint (*fptrpipe)(int[2]);\n\nssize_t (*fptrread)(int, VOID_PTR , size_t);\n\nssize_t (*fptrwrite)(int, __const VOID_PTR , size_t);\n\nFILE * (*fptrfopen)(__const CHAR_PTR __restrict, __const CHAR_PTR __restrict);\n\nFILE * (*fptrfdopen)(int, __const CHAR_PTR );\n\nint (*fptrclose)(int);\n\nint (*fptrfclose)(FILE *);\n\nint (*fptrcallrpc)(__const CHAR_PTR , u_long, u_long, u_long, xdrproc_t, __const CHAR_PTR , xdrproc_t, CHAR_PTR );\n\nenum clnt_stat (*fptrclnt_broadcast)(u_long, u_long, u_long, xdrproc_t, caddr_t,\n        xdrproc_t, caddr_t, resultproc_t);\n\nCLIENT * (*fptrclntudp_create)(struct sockaddr_in *, u_long, u_long, struct timeval, INT_PTR );\n\nCLIENT * (*fptrclntudp_bufcreate)(struct sockaddr_in *, u_long, u_long, struct timeval, INT_PTR , u_int, u_int);\n\nstruct pmaplist * (*fptrpmap_getmaps)(struct sockaddr_in *);\n\nu_short (*fptrpmap_getport)(struct sockaddr_in *, u_long, u_long, u_int);\n\nenum clnt_stat (*fptrpmap_rmtcall)(struct sockaddr_in *, u_long, u_long, u_long, xdrproc_t, caddr_t, xdrproc_t, caddr_t, struct timeval, u_long *);\n\nbool_t (*fptrpmap_set)(u_long, u_long, int, u_short);\n\nCLIENT * (*fptrclntraw_create)(u_long, u_long);\n\nvoid (*fptrsvc_run)();\n\nbool_t (*fptrsvc_sendreply)(SVCXPRT *, xdrproc_t, caddr_t);\n\nSVCXPRT * (*fptrsvcraw_create)();\n\nSVCXPRT * (*fptrsvctcp_create)(int, u_int, u_int);\n\nSVCXPRT * (*fptrsvcudp_bufcreate)(int, u_int, u_int);\n\nSVCXPRT * (*fptrsvcudp_create)(int);\n\nvoid (*fptr_exit)(int);\n\nint (*fptrsigprocmask)(int, __const sigset_t *__restrict, sigset_t *__restrict);\n\nvoid (*fptrexit)(int);\n\nint (*fptrpselect)(int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict, \n    const struct timespec *__restrict, const __sigset_t *__restrict);\n\nint (*fptrioctl)(int __d, int __request, CHAR_PTR  __argp);\n\nint (*fptrfcntl)(int __fd, int __cmd, VOID_PTR  __argp);\n\nVOID_PTR (*fptr__libc_dlopen_mode)(const CHAR_PTR __name, int __mode);\n\nINT_PTR  (*fptr__errno_location)(void);\n\nint (*fptrsyscall)(int __number, long int __arg1, long int __arg2, long int __arg3,\n     long int __arg4, long int __arg5, long int __arg6, long int __arg7);\n\n/* ===================================================================== */\n/* Probes - implementation of the wrapper functions                      */\n/* ===================================================================== */\n\nint mynanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) \n{\n    OutFile << CurrentTime() << \"mynanosleep called \" << endl;\n    OutFile.flush();\n    int res = fptrnanosleep(__rqtp, __rmtp);\n\n    return res;\n}\nint mydl_iterate_phdr(\n        int (*__callback)(struct dl_phdr_info *__info, size_t __size,\n                VOID_PTR __data), VOID_PTR __sec_data) \n{\n    OutFile << CurrentTime() << \"mydl_iterate_phdr called \" << endl;\n    OutFile.flush();\n    int res = fptrdl_iterate_phdr((__callback), __sec_data);\n    return res;\n}\n\nint mysystem(const CHAR_PTR __command) \n{\n    OutFile << CurrentTime() << \"mysystem called \" << endl;\n    OutFile.flush();\n    int res = fptrsystem(__command);\n\n    return res;\n}\n\nunsigned int myalarm(unsigned int __seconds)\n{\n    OutFile << CurrentTime() << \"myalarm called \" << endl;\n    OutFile.flush();\n    unsigned int res = fptralarm(__seconds);\n\n    return res;\n}\n\nssize_t myrecvmsg(int __socket, struct msghdr *__message, int __flags)\n{\n    OutFile << CurrentTime() << \"myrecvmsg called \" << endl;\n    OutFile.flush();\n    ssize_t res = fptrrecvmsg(__socket, __message, __flags);\n\n    return res;\n}\n\nssize_t mysendmsg(int __sockfd, const struct msghdr *__msg, int __flags) \n{\n    OutFile << CurrentTime() << \"mysendmsg called \" << endl;\n    OutFile.flush();\n    ssize_t res = fptrsendmsg(__sockfd, __msg, __flags);\n\n    return res;\n}\n\nint mypause(void) \n{\n    OutFile << CurrentTime() << \"mypause called \" << endl;\n    OutFile.flush();\n    int res = fptrpause();\n\n    return res;\n}\n\nint mysigtimedwait(const sigset_t *__set, siginfo_t *__info,\n        const struct timespec *__timeout) \n{\n    OutFile << CurrentTime() << \"mysigtimedwait called \" << endl;\n    OutFile.flush();\n    int res = fptrsigtimedwait(__set, __info, __timeout);\n\n    return res;\n}\n\nint mysigwaitinfo(const sigset_t *__set, siginfo_t *__info) \n{\n    OutFile << CurrentTime() << \"mysigwaitinfo called \" << endl;\n    OutFile.flush();\n    int res = fptrsigwaitinfo(__set, __info);\n\n    return res;\n}\n\nint myepoll_wait(int __epfd, struct epoll_event *__events, int __maxevents,\n        int __timeout) \n{\n    OutFile << CurrentTime() << \"myepoll_wait called \" << endl;\n    OutFile.flush();\n    int res = fptrepoll_wait(__epfd, __events, __maxevents, __timeout);\n\n    return res;\n}\n\nint myepoll_pwait(int __epfd, struct epoll_event *__events, int __maxevents,\n        int __timeout) \n{\n    OutFile << CurrentTime() << \"myepoll_pwait called \" << endl;\n    OutFile.flush();\n    int res = fptrepoll_wait(__epfd, __events, __maxevents, __timeout);\n\n    return res;\n}\n\nint myppoll(struct pollfd *__fds, nfds_t __nfds,\n        const struct timespec *__timeout_ts, const sigset_t *__sigmask) \n{\n    OutFile << CurrentTime() << \"myppoll called \" << endl;\n    OutFile.flush();\n    int res = fptrppoll(__fds, __nfds, __timeout_ts, __sigmask);\n\n    return res;\n}\n\nint mymsgsnd(int __msqid, const VOID_PTR __msgp, size_t __msgsz, int __msgflg) \n{\n    OutFile << CurrentTime() << \"mymsgsnd called \" << endl;\n    OutFile.flush();\n    int res = fptrmsgsnd(__msqid, __msgp, __msgsz, __msgflg);\n\n    return res;\n}\n\nssize_t mymsgrcv(int __msqid, VOID_PTR __msgp, size_t __msgsz, long __msgtyp,\n        int __msgflg) \n{\n    OutFile << CurrentTime() << \"mymsgrcv called \" << endl;\n    OutFile.flush();\n    ssize_t res = fptrmsgrcv(__msqid, __msgp, __msgsz, __msgtyp, __msgflg);\n\n    return res;\n}\n\nint mysemtimedop(int __semid, struct sembuf *__sops) \n{\n    OutFile << CurrentTime() << \"mysemtimedop called \" << endl;\n    OutFile.flush();\n    int res = fptrsemtimedop(__semid, __sops);\n\n    return res;\n}\n\nint myusleep(useconds_t __usecs) \n{\n    OutFile << CurrentTime() << \"myusleep called \" << endl;\n    OutFile.flush();\n    int res = fptrusleep(__usecs);\n\n    return res;\n}\n\nuseconds_t myualarm(useconds_t __usecs, useconds_t __interval) \n{\n    OutFile << CurrentTime() << \"myualarm called \" << endl;\n    OutFile.flush();\n    useconds_t res = fptrualarm(__usecs, __interval);\n\n    return res;\n}\n\nint mygetitimer(int __which, struct itimerval *__curr_value) \n{\n    OutFile << CurrentTime() << \"mygetitimer called \" << endl;\n    OutFile.flush();\n    int res = fptrgetitimer(__which, __curr_value);\n\n    return res;\n}\n\nint mysigwait(const sigset_t *__set, INT_PTR __sig) \n{\n    OutFile << CurrentTime() << \"mysigwait called \" << endl;\n    OutFile.flush();\n    int res = fptrsigwait(__set, __sig);\n\n    return res;\n}\n\nint mymsgget(key_t __key, int __msgflg) \n{\n    OutFile << CurrentTime() << \"mymsgget called \" << endl;\n    OutFile.flush();\n    int res = fptrmsgget(__key, __msgflg);\n\n    return res;\n}\n\nint mysemget(key_t __key, int __nsems, int __semflg) \n{\n    OutFile << CurrentTime() << \"mysemget called \" << endl;\n    OutFile.flush();\n    int res = fptrsemget(__key, __nsems, __semflg);\n\n    return res;\n}\n\npid_t mywaitpid(pid_t __pid, INT_PTR __status, int __options) \n{\n    OutFile << CurrentTime() << \"mywaitpid called \" << endl;\n    OutFile.flush();\n    pid_t res = fptrwaitpid(__pid, __status, __options);\n\n    return res;\n}\n\nint mywaitid(idtype_t __idtype, id_t __id, siginfo_t *__infop, int __options)\n{\n    OutFile << CurrentTime() << \"mywaittid called \" << endl;\n    OutFile.flush();\n    int res = fptrwaitid(__idtype, __id, __infop, __options);\n\n    return res;\n}\n\npid_t mywait3(INT_PTR __status, int __options, struct rusage *__rusage) \n{\n    OutFile << CurrentTime() << \"mywait3 called \" << endl;\n    OutFile.flush();\n    pid_t res = fptrwait3(__status, __options, __rusage);\n\n    return res;\n}\n\npid_t mywait4(pid_t __pid, INT_PTR __status, int __options,\n        struct rusage *__rusage) \n{\n    OutFile << CurrentTime() << \"mywait4 called \" << endl;\n    OutFile.flush();\n    pid_t res = fptrwait4(__pid, __status, __options, __rusage);\n\n    return res;\n}\n\nssize_t myreadv(int __fd, const struct iovec *__iov, int __iovcnt) \n{\n    OutFile << CurrentTime() << \"myreadv called \" << endl;\n    OutFile.flush();\n    ssize_t res = fptrreadv(__fd, __iov, __iovcnt);\n\n    return res;\n}\n\nssize_t mywritev(int __fd, const struct iovec *__iov, int __iovcnt) \n{\n    OutFile << CurrentTime() << \"mywritev called \" << endl;\n    OutFile.flush();\n    ssize_t res = fptrwritev(__fd, __iov, __iovcnt);\n\n    return res;\n}\n\nint myflock(int __fd, int __operation) \n{\n    OutFile << CurrentTime() << \"myflock called \" << endl;\n    OutFile.flush();\n    int res = fptrflock(__fd, __operation);\n\n    return res;\n}\n\nvoid myflockfile(FILE *__filehandle) \n{\n    OutFile << CurrentTime() << \"myflockfile called \" << endl;\n    OutFile.flush();\n    fptrflockfile(__filehandle);\n}\n\nvoid myfunlockfile(FILE *__filehandle) \n{\n    OutFile << CurrentTime() << \"myfunlockfile called \" << endl;\n    OutFile.flush();\n    fptrfunlockfile(__filehandle);\n}\n\nint mylockf(int __fd, int __cmd, off_t __len) \n{\n    OutFile << CurrentTime() << \"mylockf called \" << endl;\n    OutFile.flush();\n    int res = fptrlockf(__fd, __cmd, __len);\n\n    return res;\n}\n\nint mysetenv(const CHAR_PTR __name, const CHAR_PTR __value, int __overwrite) \n{\n    OutFile << CurrentTime() << \"mysetenv called \" << endl;\n    OutFile.flush();\n    int res = fptrsetenv(__name, __value, __overwrite);\n\n    return res;\n}\n\nint myunsetenv(const CHAR_PTR __name) \n{\n    OutFile << CurrentTime() << \"myunsetenv called \" << endl;\n    OutFile.flush();\n    int res = fptrunsetenv(__name);\n\n    return res;\n}\n\nCHAR_PTR  mygetenv(const CHAR_PTR __name) \n{\n    OutFile << CurrentTime() << \"mygetenv called \" << endl;\n    OutFile.flush();\n    CHAR_PTR  res = fptrgetenv(__name);\n\n    return res;\n}\n\nvoid myperror(const CHAR_PTR __s) \n{\n    OutFile << CurrentTime() << \"myperrorcalled \" << endl;\n    OutFile.flush();\n    fptrperror(__s);\n\n}\n\nVOID_PTR  mymmap(VOID_PTR __addr, size_t __len, int __prot, int __flags, int __fildes,\n        off_t __off) \n{\n    OutFile << CurrentTime() << \"mymmap called \" << endl;\n    OutFile.flush();\n    VOID_PTR  res = fptrmmap(__addr, __len, __prot, __flags, __fildes, __off);\n\n    return res;\n}\n\nint mymunmap(VOID_PTR __addr, size_t __len) \n{\n    OutFile << CurrentTime() << \"mymunmap called \" << endl;\n    OutFile.flush();\n    int res = fptrmunmap(__addr, __len);\n\n    return res;\n}\n\nint myfileno(FILE *__stream)\n{   \n    OutFile << CurrentTime() << \"myfileno called \" << endl;\n    OutFile.flush();\n    int res = fptrfileno(__stream);\n\n    return res;\n}\n\npid_t mygetpid(void) \n{\n    OutFile << CurrentTime() << \"mygetpid called \" << endl;\n    OutFile.flush();\n    pid_t res = fptrgetpid();\n\n    return res;\n}\n\npid_t mygetppid(void) \n{\n    OutFile << CurrentTime() << \"mygetppid called \" << endl;\n    OutFile.flush();\n    pid_t res = fptrgetppid();\n\n    return res;\n}\n\nVOID_PTR  mymemset(VOID_PTR __s, int __c, size_t __n) {\n    OutFile << CurrentTime() << \"mymemset called \" << endl;\n    OutFile.flush();\n    VOID_PTR  res = fptrmemset(__s, __c, __n);\n\n    return res;\n}\n\nVOID_PTR  mymemcpy(VOID_PTR __dest, const VOID_PTR __src, size_t __n) \n{\n    OutFile << CurrentTime() << \"mymemcpy called \" << endl;\n    OutFile.flush();\n    VOID_PTR  res = fptrmemcpy(__dest, __src, __n);\n\n    return res;\n}\n\nint myaccess(const CHAR_PTR __pathname, int __mode) \n{\n    OutFile << CurrentTime() << \"myaccess called \" << endl;\n    OutFile.flush();\n    int res = fptraccess(__pathname, __mode);\n\n    return res;\n}\n\noff_t mylseek(int __fd, off_t __offset, int __whence) \n{\n    OutFile << CurrentTime() << \"mylseek called \" << endl;\n    OutFile.flush();\n    off_t res = fptrlseek(__fd, __offset, __whence);\n\n    return res;\n}\n\noff64_t mylseek64(int __fd, off64_t __offset, int __whence) \n{\n    OutFile << CurrentTime() << \"mylseek64 called \" << endl;\n    OutFile.flush();\n    off64_t res = fptrlseek64(__fd, __offset, __whence);\n\n    return res;\n}\n\nint myfdatasync(int __fd) {\n    OutFile << CurrentTime() << \"myfdatasync called \" << endl;\n    OutFile.flush();\n    int res = fptrfdatasync(__fd);\n\n    return res;\n}\n\nint myunlink(const CHAR_PTR __pathname) \n{\n    OutFile << CurrentTime() << \"myunlink called \" << endl;\n    OutFile.flush();\n    int res = fptrunlink(__pathname);\n\n    return res;\n}\n\nsize_t mystrlen(const CHAR_PTR __s) \n{\n    OutFile << CurrentTime() << \"mystrlen called \" << endl;\n    OutFile.flush();\n    size_t res = fptrstrlen(__s);\n\n    return res;\n}\n\nsize_t mywcslen(const wchar_t *__s)\n{\n    OutFile << CurrentTime() << \"mywcslen called \" << endl;\n    OutFile.flush();\n    size_t res = fptrwcslen(__s);\n\n    return res;\n}\n\nCHAR_PTR  mystrcpy(CHAR_PTR __dest, const CHAR_PTR __src) \n{\n    OutFile << CurrentTime() << \"mystrcpy called \" << endl;\n    OutFile.flush();\n    CHAR_PTR  res = fptrstrcpy(__dest, __src);\n\n    return res;\n}\n\nCHAR_PTR  mystrncpy(CHAR_PTR __dest, const CHAR_PTR __src, size_t __n) \n{\n    OutFile << CurrentTime() << \"mystrncpy called \" << endl;\n    OutFile.flush();\n    CHAR_PTR  res = fptrstrncpy(__dest, __src, __n);\n\n    return res;\n}\n\nCHAR_PTR  mystrcat(CHAR_PTR __dest, const CHAR_PTR __src) \n{\n    OutFile << CurrentTime() << \"mystrcat called \" << endl;\n    OutFile.flush();\n    CHAR_PTR  res = fptrstrcat(__dest, __src);\n\n    return res;\n}\n\nCHAR_PTR  mystrstr(const CHAR_PTR __haystack, const CHAR_PTR __needle) \n{\n    OutFile << CurrentTime() << \"mystrstr called \" << endl;\n    OutFile.flush();\n    CHAR_PTR  res = fptrstrstr(__haystack, __needle);\n\n    return res;\n}\n\nCHAR_PTR  mystrchr0(const CHAR_PTR __s, int __c) \n{\n    OutFile << CurrentTime() << \"mystrchr0 called \" << endl;\n    OutFile.flush();\n    CHAR_PTR  res = fptrstrchr0(__s, __c);\n\n    return res;\n}\n\nCHAR_PTR  mystrrchr(const CHAR_PTR __s, int __c) \n{\n    OutFile << CurrentTime() << \"mystrrchr called \" << endl;\n    OutFile.flush();\n    CHAR_PTR  res = fptrstrrchr(__s, __c);\n\n    return res;\n}\n\nint mystrcmp(const CHAR_PTR __s1, const CHAR_PTR __s2) \n{\n    OutFile << CurrentTime() << \"mystrcmp called \" << endl;\n    OutFile.flush();\n    int res = fptrstrcmp(__s1, __s2);\n\n    return res;\n}\n\nint mystrncmp(const CHAR_PTR __s1, const CHAR_PTR __s2, size_t __n) \n{\n    OutFile << CurrentTime() << \"mystrncmp called \" << endl;\n    OutFile.flush();\n    int res = fptrstrncmp(__s1, __s2, __n);\n\n    return res;\n}\n\nint mysigaddset(sigset_t *__set, int __signum) \n{\n    OutFile << CurrentTime() << \"mysigaddset called \" << endl;\n    OutFile.flush();\n    int res = fptrsigaddset(__set, __signum);\n\n    return res;\n}\n\nint mysigdelset(sigset_t *__set, int __signum) {\n    OutFile << CurrentTime() << \"mysigdelset called \" << endl;\n    OutFile.flush();\n    int res = fptrsigdelset(__set, __signum);\n\n    return res;\n}\n\nint mysigismember(sigset_t *__set, int __signum)\n{\n    OutFile << CurrentTime() << \"mysigismember called \" << endl;\n    OutFile.flush();\n    int res = fptrsigismember(__set, __signum);\n\n    return res;\n}\n\nCHAR_PTR  mystrerror(int __errnum) \n{\n    OutFile << CurrentTime() << \"mystrerror called \" << endl;\n    OutFile.flush();\n    CHAR_PTR  res = fptrstrerror(__errnum);\n\n    return res;\n}\n\nint mybind(int __sockfd, const struct sockaddr *__addr, socklen_t __addrlen) \n{\n    OutFile << CurrentTime() << \"mybind called \" << endl;\n    OutFile.flush();\n    int res = fptrbind(__sockfd, __addr, __addrlen);\n\n    return res;\n}\n\nint mylisten(int __sockfd, int __backlog) \n{\n    OutFile << CurrentTime() << \"mylisten called \" << endl;\n    OutFile.flush();\n    int res = fptrlisten(__sockfd, __backlog);\n\n    return res;\n}\n\nint myuname(struct utsname *__name) \n{\n    OutFile << CurrentTime() << \"myuname called \" << endl;\n    OutFile.flush();\n    int res = fptruname(__name);\n\n    return res;\n}\n\nint mygethostname(CHAR_PTR __name, size_t __len) \n{\n    OutFile << CurrentTime() << \"mygethostname called \" << endl;\n    OutFile.flush();\n    int res = fptrgethostname(__name, __len);\n\n    return res;\n}\n\nint mykill(pid_t __pid, int __sig) \n{\n    OutFile << CurrentTime() << \"mykill called \" << endl;\n    OutFile.flush();\n    int res = fptrkill(__pid, __sig);\n\n    return res;\n}\n\nint mysched_yield(void) \n{\n    OutFile << CurrentTime() << \"mysched_yield called \" << endl;\n    OutFile.flush();\n    int res = fptrsched_yield();\n\n    return res;\n}\n\nint mytimer_settime(timer_t __timerid, int __flags,\n        const struct itimerspec * __value, struct itimerspec * __ovalue) \n{\n    OutFile << CurrentTime() << \"mytimer_settime called \" << endl;\n    OutFile.flush();\n    int res = fptrtimer_settime(__timerid, __flags, __value, __ovalue);\n\n    return res;\n}\n\nint mysigaltstack(const stack_t *__ss, stack_t *__oss) \n{\n    OutFile << CurrentTime() << \"mysigaltstacke called \" << endl;\n    OutFile.flush();\n    int res = fptrsigaltstack(__ss, __oss);\n\n    return res;\n}\n\nint mysleep(unsigned int __seconds) \n{\n    OutFile << CurrentTime() << \"mysleep called \" << endl;\n    OutFile.flush();\n    int res = fptrsleep(__seconds);\n\n    return res;\n}\n\nint mysocket(int __domain, int __type, int __protocol) \n{\n    OutFile << CurrentTime() << \"mysocket called \" << endl;\n    OutFile.flush();\n    int res = fptrsocket(__domain, __type, __protocol);\n\n    return res;\n}\n\nint myshutdown(int __fd, int __how) \n{\n    OutFile << CurrentTime() << \"myshutdown called \" << endl;\n    OutFile.flush();\n    int res = fptrshutdown(__fd, __how);\n\n    return res;\n}\n\nint myselect(int __nfds, fd_set *__restrict __readfds,\n        fd_set *__restrict __writefds, fd_set *__restrict __exceptfds,\n        struct timeval *__restrict __timeout) \n{\n    OutFile << CurrentTime() << \"myselect called \" << endl;\n    OutFile.flush();\n    int res = fptrselect(__nfds, __readfds, __writefds, __exceptfds, __timeout);\n\n    return res;\n}\n\nint mypoll(struct pollfd * __fds, nfds_t __nfds, int __timeout) \n{\n    OutFile << CurrentTime() << \"mypoll called \" << endl;\n    OutFile.flush();\n    int res = fptrpoll(__fds, __nfds, __timeout);\n\n    return res;\n}\n\nint myaccept(int __fd, __SOCKADDR_ARG __addr,\n        socklen_t *__restrict __addr_len) \n{\n    OutFile << CurrentTime() << \"myaccept called \" << endl;\n    OutFile.flush();\n    int res = fptraccept(__fd, __addr, __addr_len);\n\n    return res;\n}\n\nint myconnect(int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len) \n{\n    OutFile << CurrentTime() << \"myconnect called \" << endl;\n    OutFile.flush();\n    int res = fptrconnect(__fd, __addr, __len);\n\n    return res;\n}\n\nssize_t myrecv(int __fd, VOID_PTR  __buf, size_t __n, int __flags) \n{\n    OutFile << CurrentTime() << \"myrecv called \" << endl;\n    OutFile.flush();\n    ssize_t res = fptrrecv(__fd, __buf, __n, __flags);\n\n    return res;\n}\n\nssize_t myrecvfrom(int __fd, VOID_PTR __restrict __buf, size_t __n, int __flags,\n        __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len) \n{\n    OutFile << CurrentTime() << \"myrecvfrom called \" << endl;\n    OutFile.flush();\n    ssize_t res = fptrrecvfrom(__fd, __buf, __n, __flags, __addr, __addr_len);\n\n    return res;\n}\n\nssize_t mysend(int __fd, __const VOID_PTR  __buf, size_t __n, int __flags) \n{\n    OutFile << CurrentTime() << \"mysend called \" << endl;\n    OutFile.flush();\n    ssize_t res = fptrsend(__fd, __buf, __n, __flags);\n\n    return res;\n}\n\nwint_t mygetwc(__FILE * __stream) \n{\n    OutFile << CurrentTime() << \"mygetwc called \" << endl;\n    OutFile.flush();\n    wint_t res = fptrgetwc(__stream);\n\n    return res;\n}\n\nvoid myexit(int __status) \n{\n    OutFile << CurrentTime() << \"myexit called \" << endl;\n    OutFile.flush();\n    fptrexit(__status);\n\n}\n\nint mysetitimer(__itimer_which_t  __which, __const\n        struct itimerval *__restrict __new,\n        struct itimerval *__restrict __old) \n{\n    OutFile << CurrentTime() << \"mysetitimer called \" << endl;\n    OutFile.flush();\n    int res = fptrsetitimer(__which, __new, __old);\n\n    return res;\n}\n\nint mysigpending(sigset_t * __set) \n{\n    OutFile << CurrentTime() << \"mysigpending called \" << endl;\n    OutFile.flush();\n    int res = fptrsigpending(__set);\n\n    return res;\n}\n\n__sighandler_t mysignal(int __sig, __sighandler_t  __handler) \n\n{\n    OutFile << CurrentTime() << \"mysignal called \" << endl;\n    OutFile.flush();\n    __sighandler_t res = fptrsignal(__sig, __handler);\n\n    return res;\n}\n\nvoid myabort() \n{\n    OutFile << CurrentTime() << \"myabort called \" << endl;\n    OutFile.flush();\n    fptrabort();\n}\n\nint myclose(int __fd) \n{\n    OutFile << CurrentTime() << \"myclose called \" << endl;\n    OutFile.flush();\n    int res = fptrclose(__fd);\n\n    return res;\n}\n\nssize_t mysendto(int __fd, __const VOID_PTR  __buf, size_t __n, int __flags,\n        __CONST_SOCKADDR_ARG __addr, socklen_t __addr_len) \n{\n    OutFile << CurrentTime() << \"mysendto called \" << endl;\n    OutFile.flush();\n    ssize_t res = fptrsendto(__fd, __buf, __n, __flags, __addr, __addr_len);\n\n    return res;\n}\n\nint my_IO_getc(FILE * __stream) \n{\n    OutFile << CurrentTime() << \"my_IO_getc called \" << endl;\n    OutFile.flush();\n    int res = fptr_IO_getc(__stream);\n\n    return res;\n}\n\nint mygetchar()\n{\n    OutFile << CurrentTime() << \"mygetchar called \" << endl;\n    OutFile.flush();\n    int res = fptrgetchar();\n\n    return res;\n}\n\nwint_t mygetwchar() \n{\n    OutFile << CurrentTime() << \"mygetwchar called \" << endl;\n    OutFile.flush();\n    wint_t res = fptrgetwchar();\n\n    return res;\n}\n\nCHAR_PTR  mygets(CHAR_PTR  __s) \n{\n    OutFile << CurrentTime() << \"mygets called \" << endl;\n    OutFile.flush();\n    CHAR_PTR  res = fptrgets(__s);\n\n    return res;\n}\n\nCHAR_PTR  myfgets(CHAR_PTR __restrict __s, int __n, FILE *__restrict __stream) \n{\n    OutFile << CurrentTime() << \"myfgets called \" << endl;\n    OutFile.flush();\n    CHAR_PTR  res = fptrfgets(__s, __n, __stream);\n\n    return res;\n}\n\nwint_t myfgetwc(__FILE * __stream) \n{\n    OutFile << CurrentTime() << \"myfgetwc called \" << endl;\n    OutFile.flush();\n    wint_t res = fptrfgetwc(__stream);\n\n    return res;\n}\n\nsize_t myfread(VOID_PTR __restrict __ptr, size_t __size, size_t __n,\n        FILE *__restrict __stream)\n{\n    OutFile << CurrentTime() << \"myfread called \" << endl;\n    OutFile.flush();\n    size_t res = fptrfread(__ptr, __size, __n, __stream);\n\n    return res;\n}\n\nsize_t myfwrite(__const VOID_PTR __restrict __ptr, size_t __size, size_t __n,\n        FILE *__restrict __s) \n{\n    OutFile << CurrentTime() << \"myfwrite called \" << endl;\n    OutFile.flush();\n    size_t res = fptrfwrite(__ptr, __size, __n, __s);\n\n    return res;\n}\n\nint myopen(__const CHAR_PTR  __file, int __flags, mode_t __mode) \n{\n    OutFile << CurrentTime() << \"myopen called \" << endl;\n    OutFile.flush();\n    int res = fptropen(__file, __flags, __mode);\n\n    return res;\n}\n\nint mygetw(FILE * __stream) \n{\n    OutFile << CurrentTime() << \"mygetw called \" << endl;\n    OutFile.flush();\n    int res = fptrgetw(__stream);\n\n    return res;\n}\n\nvoid myfgetc(__FILE * __stream) \n{\n    OutFile << CurrentTime() << \"myfgetc called \" << endl;\n    OutFile.flush();\n    fptrfgetc(__stream);\n\n}\n\nwchar_t * myfgetws(wchar_t *__restrict __ws, int __n,\n        __FILE *__restrict __stream) \n        {\n    OutFile << CurrentTime() << \"myfgetws called \" << endl;\n    OutFile.flush();\n    wchar_t * res = fptrfgetws(__ws, __n, __stream);\n\n    return res;\n}\n\nint mypipe(int* __pipedes) \n{\n    OutFile << CurrentTime() << \"mypipe called \" << endl;\n    OutFile.flush();\n    int res = fptrpipe(__pipedes);\n\n    return res;\n}\n\nssize_t myread(int __fd, VOID_PTR  __buf, size_t __nbytes) \n{\n    OutFile << CurrentTime() << \"myread called \" << endl;\n    OutFile.flush();\n    ssize_t res = fptrread(__fd, __buf, __nbytes);\n\n    return res;\n}\n\nssize_t mywrite(int __fd, __const VOID_PTR  __buf, size_t __n) \n{\n    OutFile << CurrentTime() << \"mywrite called \" << endl;\n    OutFile.flush();\n    ssize_t res = fptrwrite(__fd, __buf, __n);\n\n    return res;\n}\n\nFILE * myfopen(__const CHAR_PTR __restrict __filename,\n        __const CHAR_PTR __restrict __modes) \n{\n    OutFile << CurrentTime() << \"myfopen called \" << endl;\n    OutFile.flush();\n    FILE * res = fptrfopen(__filename, __modes);\n\n    return res;\n}\n\nFILE * myfdopen(int __fd, __const CHAR_PTR  __modes) \n{\n    OutFile << CurrentTime() << \"myfdopen called \" << endl;\n    OutFile.flush();\n    FILE * res = fptrfdopen(__fd, __modes);\n\n    return res;\n}\n\nint mycallrpc(__const CHAR_PTR  __host, u_long __prognum, u_long __versnum,\n        u_long __procnum, xdrproc_t __inproc, __const CHAR_PTR  __in,\n        xdrproc_t __outproc, CHAR_PTR  __out) \n{\n    OutFile << CurrentTime() << \"mycallrpc called \" << endl;\n    OutFile.flush();\n    int res = fptrcallrpc(__host, __prognum, __versnum, __procnum, __inproc,\n            __in, __outproc, __out);\n\n    return res;\n}\n\nenum clnt_stat myclnt_broadcast(u_long __prog, u_long __vers, u_long __proc,\n        xdrproc_t __xargs, caddr_t __argsp, xdrproc_t __xresults,\n        caddr_t __resultsp, resultproc_t __eachresult) \n{\n    OutFile << CurrentTime() << \"myclnt_broadcast called \" << endl;\n    OutFile.flush();\n    enum clnt_stat res = fptrclnt_broadcast(__prog, __vers, __proc, __xargs,\n            __argsp, __xresults, __resultsp, __eachresult);\n\n    return res;\n}\n\nCLIENT * myclntudp_create(struct sockaddr_in * __raddr, u_long __program,\n        u_long __version, struct timeval __wait_resend, INT_PTR  __sockp) \n{\n    OutFile << CurrentTime() << \"myclntudp_create called \" << endl;\n    OutFile.flush();\n    CLIENT * res = fptrclntudp_create(__raddr, __program, __version,\n            __wait_resend, __sockp);\n\n    return res;\n}\n\nCLIENT * myclntudp_bufcreate(struct sockaddr_in * __raddr, u_long __program,\n        u_long __version, struct timeval __wait_resend, INT_PTR  __sockp,\n        u_int __sendsz, u_int __recvsz) \n{\n    OutFile << CurrentTime() << \"myclntudp_bufcreate called \" << endl;\n    OutFile.flush();\n    CLIENT * res = fptrclntudp_bufcreate(__raddr, __program, __version,\n            __wait_resend, __sockp, __sendsz, __recvsz);\n\n    return res;\n}\n\nstruct pmaplist * mypmap_getmaps(struct sockaddr_in * __address) \n{\n    OutFile << CurrentTime() << \"mypmap_getmaps called \" << endl;\n    OutFile.flush();\n    struct pmaplist * res = fptrpmap_getmaps(__address);\n\n    return res;\n}\n\nu_short mypmap_getport(struct sockaddr_in * __address, u_long __program,\n        u_long __version, u_int __protocol) \n{\n    OutFile << CurrentTime() << \"mypmap_getport called \" << endl;\n    OutFile.flush();\n    u_short res = fptrpmap_getport(__address, __program, __version, __protocol);\n\n    return res;\n}\n\nenum clnt_stat mypmap_rmtcall(struct sockaddr_in * __addr, u_long __prog,\n        u_long __vers, u_long __proc, xdrproc_t __xdrargs, caddr_t __argsp,\n        xdrproc_t __xdrres, caddr_t __resp, struct timeval __tout,\n        u_long * __port_ptr) \n{\n    OutFile << CurrentTime() << \"mypmap_rmtcall called \" << endl;\n    OutFile.flush();\n    enum clnt_stat res = fptrpmap_rmtcall(__addr, __prog, __vers, __proc,\n            __xdrargs, __argsp, __xdrres, __resp, __tout, __port_ptr);\n\n    return res;\n}\n\nbool_t mypmap_set(u_long __program, u_long __vers, int __protocol, u_short __port) \n{\n    OutFile << CurrentTime() << \"mypmap_set called \" << endl;\n    OutFile.flush();\n    bool_t res = fptrpmap_set(__program, __vers, __protocol, __port);\n\n    return res;\n}\n\nCLIENT * myclntraw_create(u_long __prog, u_long __vers) \n{\n    OutFile << CurrentTime() << \"myclntraw_create called \" << endl;\n    OutFile.flush();\n    CLIENT * res = fptrclntraw_create(__prog, __vers);\n\n    return res;\n}\n\nvoid mysvc_run()\n{\n    OutFile << CurrentTime() << \"mysvc_run called \" << endl;\n    OutFile.flush();\n    fptrsvc_run();\n}\n\nbool_t mysvc_sendreply(SVCXPRT * xprt, xdrproc_t __xdr_results,\n        caddr_t __xdr_location) \n{\n    OutFile << CurrentTime() << \"mysvc_sendreply called \" << endl;\n    OutFile.flush();\n    bool_t res = fptrsvc_sendreply(xprt, __xdr_results, __xdr_location);\n\n    return res;\n}\n\nSVCXPRT * mysvcraw_create() \n{\n    OutFile << CurrentTime() << \"mysvcraw_create called \" << endl;\n    OutFile.flush();\n    SVCXPRT * res = fptrsvcraw_create();\n\n    return res;\n}\n\nSVCXPRT * mysvctcp_create(int __sock, u_int __sendsize, u_int __recvsize) \n{\n    OutFile << CurrentTime() << \"mypmap_rmtcall called \" << endl;\n    OutFile.flush();\n    SVCXPRT * res = fptrsvctcp_create(__sock, __sendsize, __recvsize);\n\n    return res;\n}\n\nSVCXPRT * mysvcudp_bufcreate(int __sock, u_int __sendsz, u_int __recvsz)\n{\n    OutFile << CurrentTime() << \"mysvcudp_bufcreate called \" << endl;\n    OutFile.flush();\n    SVCXPRT * res = fptrsvcudp_bufcreate(__sock, __sendsz, __recvsz);\n\n    return res;\n}\n\nSVCXPRT * mysvcudp_create(int __sock)\n{\n    OutFile << CurrentTime() << \"mysvcudp_create called \" << endl;\n    OutFile.flush();\n    SVCXPRT * res = fptrsvcudp_create(__sock);\n\n    return res;\n}\n\nvoid my_exit(int __status)\n{\n    OutFile << CurrentTime() << \"my_exit called \" << endl;\n    OutFile.flush();\n    fptr_exit(__status);\n\n}\n\nint my_nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) \n{\n    OutFile << CurrentTime() << \"my_nanosleep called \" << endl;\n    OutFile.flush();\n    int res = fptrnanosleep(__rqtp, __rmtp);\n\n    return res;\n}\n\nint mysigprocmask(int __how, __const sigset_t *__restrict __set,\n        sigset_t *__restrict __oset) \n{\n    OutFile << CurrentTime() << \"mysigprocmask called \" << endl;\n    OutFile.flush();\n    int res = fptrsigprocmask(__how, __set, __oset);\n\n    return res;\n}\n\nint mypselect(int __nfds, fd_set *__restrict __readfds,\n        fd_set *__restrict __writefds, fd_set *__restrict __exceptfds,\n        const struct timespec *__restrict __timeout,\n        const __sigset_t *__restrict __sigmask) \n{\n    OutFile << CurrentTime() << \"mypselect called \" << endl;\n    OutFile.flush();\n    int res = fptrpselect(__nfds, __readfds, __writefds, __exceptfds, __timeout,\n            __sigmask);\n\n    return res;\n}\n\npid_t mywait(INT_PTR __status) \n{\n    OutFile << CurrentTime() << \"mywait called \" << endl;\n    OutFile.flush();\n    int res = fptrwait(__status);\n\n    return res;\n}\n\nint myfclose(FILE * __stream) \n{\n    OutFile << CurrentTime() << \"myfclose called \" << endl;\n    OutFile.flush();\n    int res = fptrfclose(__stream);\n\n    return res;\n}\n\nint myioctl(int __d, int __request, CHAR_PTR  __argp) \n{\n    OutFile << CurrentTime() << \"myioctl called \" << endl;\n    OutFile.flush();\n    int res = fptrioctl(__d, __request, __argp);\n\n    return res;\n}\n\nint myfcntl(int __fd, int __cmd, VOID_PTR  __argp) \n{\n    OutFile << CurrentTime() << \"myfcntl called \" << endl;\n    OutFile.flush();\n    int res = fptrfcntl(__fd, __cmd, __argp);\n\n    return res;\n}\n\nVOID_PTR  my__libc_dlopen_mode(const CHAR_PTR __name, int __mode) \n{\n    OutFile << CurrentTime() << \"my__libc_dlopen_mode called \" << endl;\n    OutFile.flush();\n    VOID_PTR  res = fptr__libc_dlopen_mode(__name, __mode);\n\n    return res;\n}\n\nINT_PTR  my__errno_location(void) \n{\n    OutFile << CurrentTime() << \"my__errno_location called \" << endl;\n    OutFile.flush();\n    INT_PTR  res = fptr__errno_location();\n\n    return res;\n}\n\nint mysyscall(int __number, long int __arg1, long int __arg2, long int __arg3,\n        long int __arg4, long int __arg5, long int __arg6, long int __arg7) \n{\n    OutFile << CurrentTime() << \"mysyscall called \" << endl;\n    OutFile.flush();\n    int res = fptrsyscall(__number, __arg1, __arg2, __arg3, __arg4, __arg5,\n            __arg6, __arg7);\n\n    return res;\n}\n\nint mysigaction(int __sig, __const struct sigaction *__restrict __act,\n        struct sigaction *__restrict __oact) \n{\n    OutFile << CurrentTime() << \"mysigaction called \" << endl;\n    OutFile.flush();\n    int res = fptrsigaction(__sig, __act, __oact);\n\n    return res;\n}\n\n/* ===================================================================== */\n/* Instrumnetation functions                                             */\n/* ===================================================================== */\n\n// Image load callback - inserts the probes.\nvoid ImgLoad(IMG img, VOID_PTR v) {\n    // Called every time a new image is loaded\n    if ((IMG_Name(img).find(\"libc.so\") != string::npos)\n            || (IMG_Name(img).find(\"LIBC.SO\") != string::npos)\n            || (IMG_Name(img).find(\"LIBC.so\") != string::npos)) \n    {\n            \n        RTN rtnsleep = RTN_FindByName(img, \"sleep\");\n        if (RTN_Valid(rtnsleep) && RTN_IsSafeForProbedReplacement(rtnsleep)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for sleep at \"\n                    << RTN_Address(rtnsleep) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsleep, AFUNPTR(mysleep)));\n            fptrsleep = (int (*)(unsigned int))fptr;\n        }\n\n        RTN rtnsocket = RTN_FindByName(img, \"socket\");\n        if (RTN_Valid(rtnsocket) && RTN_IsSafeForProbedReplacement(rtnsocket))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for socket at \"\n                    << RTN_Address(rtnsocket) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsocket, AFUNPTR(mysocket)));\n            fptrsocket = (int (*)(int, int, int))fptr;\n        }\n\n        RTN rtnshutdown = RTN_FindByName(img, \"shutdown\");\n        if (RTN_Valid(rtnshutdown)\n                && RTN_IsSafeForProbedReplacement(rtnshutdown)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for shutdown at \" << RTN_Address(rtnshutdown) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnshutdown, AFUNPTR(myshutdown)));\n            fptrshutdown = (int (*)(int, int))fptr;\n        }\n\n        RTN rtnselect = RTN_FindByName(img, \"select\");\n        if (RTN_Valid(rtnselect) && RTN_IsSafeForProbedReplacement(rtnselect)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for select at \" << RTN_Address(rtnselect) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnselect, AFUNPTR(myselect)));\n            fptrselect = (int (*)(int, fd_set *, fd_set *, fd_set *, struct timeval *))fptr;\n        }\n\n        RTN rtnpoll = RTN_FindByName(img, \"poll\");\n        if (RTN_Valid(rtnpoll) && RTN_IsSafeForProbedReplacement(rtnpoll)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for poll at \" << RTN_Address(rtnpoll) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpoll, AFUNPTR(mypoll)));\n            fptrpoll = (int (*)(struct pollfd *, nfds_t, int))fptr;\n        }\n\n        RTN rtnpselect = RTN_FindByName(img, \"pselect\");\n        if (RTN_Valid(rtnpselect)\n                && RTN_IsSafeForProbedReplacement(rtnpselect))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pselect at \"\n                    << RTN_Address(rtnpselect) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpselect, AFUNPTR(mypselect)));\n            fptrpselect = (int (*)(int, fd_set *, fd_set *, fd_set *,\n                    const struct timespec *, const __sigset_t *))fptr;\n        }\n\n        RTN rtnaccept = RTN_FindByName(img, \"accept\");\n        if (RTN_Valid(rtnaccept) && RTN_IsSafeForProbedReplacement(rtnaccept)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for accept at \" << RTN_Address(rtnaccept) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnaccept, AFUNPTR(myaccept)));\n            fptraccept = (int (*)(int, __SOCKADDR_ARG, socklen_t *__restrict))fptr;\n            }\n\n        RTN rtnconnect = RTN_FindByName(img, \"connect\");\n        if (RTN_Valid(rtnconnect) && RTN_IsSafeForProbedReplacement(rtnconnect))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for connect at \" << RTN_Address(rtnconnect) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnconnect, AFUNPTR(myconnect)));\n            fptrconnect = (int (*)(int, __CONST_SOCKADDR_ARG, socklen_t))fptr;\n        }\n\n        RTN rtnrecv = RTN_FindByName(img, \"recv\");\n        if (RTN_Valid(rtnrecv) && RTN_IsSafeForProbedReplacement(rtnrecv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for recv at \" << RTN_Address(rtnrecv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnrecv, AFUNPTR(myrecv)));\n            fptrrecv = (ssize_t (*)(int, VOID_PTR , size_t, int))fptr;\n        }\n\n        RTN rtnrecvfrom = RTN_FindByName(img, \"recvfrom\");\n        if (RTN_Valid(rtnrecvfrom) && RTN_IsSafeForProbedReplacement(rtnrecvfrom))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for recvfrom at \" << RTN_Address(rtnrecvfrom) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnrecvfrom, AFUNPTR(myrecvfrom)));\n            fptrrecvfrom = (ssize_t (*)(int, VOID_PTR , size_t, int, __SOCKADDR_ARG, socklen_t *))fptr;\n        }\n\n        RTN rtnsend = RTN_FindByName(img, \"send\");\n        if (RTN_Valid(rtnsend) && RTN_IsSafeForProbedReplacement(rtnsend)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for send at \" << RTN_Address(rtnsend) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsend, AFUNPTR(mysend)));\n\t\t\tfptrsend = (ssize_t (*)(int, __const VOID_PTR, size_t, int))fptr;\n        }\n\n        RTN rtnsendto = RTN_FindByName(img, \"sendto\");\n        if (RTN_Valid(rtnsendto) && RTN_IsSafeForProbedReplacement(rtnsendto)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for sendto at \" << RTN_Address(rtnsendto) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsendto, AFUNPTR(mysendto)));\n            fptrsendto = (ssize_t (*)(int, __const VOID_PTR , size_t, int, __CONST_SOCKADDR_ARG, socklen_t))fptr;\n        }\n\n        RTN rtngetwc = RTN_FindByName(img, \"getwc\");\n        if (RTN_Valid(rtngetwc) && RTN_IsSafeForProbedReplacement(rtngetwc)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for getwc at \" << RTN_Address(rtngetwc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetwc, AFUNPTR(mygetwc)));\n            fptrgetwc = (wint_t (*)(__FILE *))fptr;\n        }\n\n        RTN rtngetw = RTN_FindByName(img, \"getw\");\n        if (RTN_Valid(rtngetw) && RTN_IsSafeForProbedReplacement(rtngetw))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getw at \" << RTN_Address(rtngetw) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetw, AFUNPTR(mygetw)));\n            fptrgetw = (int (*)(FILE *))fptr;\n        }\n\n        RTN rtn_IO_getc = RTN_FindByName(img, \"_IO_getc\");\n        if (RTN_Valid(rtn_IO_getc)\n                && RTN_IsSafeForProbedReplacement(rtn_IO_getc)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for _IO_getc at \" << RTN_Address(rtn_IO_getc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn_IO_getc, AFUNPTR(my_IO_getc)));\n            fptr_IO_getc = (int (*)(FILE *))fptr;\n        }\n\n        RTN rtngetchar = RTN_FindByName(img, \"getchar\");\n        if (RTN_Valid(rtngetchar) && RTN_IsSafeForProbedReplacement(rtngetchar)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for getchar at \" << RTN_Address(rtngetchar) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetchar, AFUNPTR(mygetchar)));\n            fptrgetchar = (int (*)())fptr;\n        }\n\n        RTN rtngetwchar = RTN_FindByName(img, \"getwchar\");\n        if (RTN_Valid(rtngetwchar) && RTN_IsSafeForProbedReplacement(rtngetwchar))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getwchar at \"\n                    << RTN_Address(rtngetwchar) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetwchar, AFUNPTR(mygetwchar)));\n            fptrgetwchar = (wint_t (*)())fptr;\n        }\n\n        RTN rtngets = RTN_FindByName(img, \"gets\");\n        if (RTN_Valid(rtngets) && RTN_IsSafeForProbedReplacement(rtngets))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for gets at \" << RTN_Address(rtngets) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngets, AFUNPTR(mygets)));\n            fptrgets = (CHAR_PTR  (*)(CHAR_PTR ))fptr;\n        }\n\n        RTN rtnfgetc = RTN_FindByName(img, \"fgetc\");\n        if (RTN_Valid(rtnfgetc) && RTN_IsSafeForProbedReplacement(rtnfgetc)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgetc at \" << RTN_Address(rtnfgetc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgetc, AFUNPTR(myfgetc)));\n            fptrfgetc = (void (*)(__FILE *))fptr;\n        }\n\n        RTN rtnfgetwc = RTN_FindByName(img, \"fgetwc\");\n        if (RTN_Valid(rtnfgetwc) && RTN_IsSafeForProbedReplacement(rtnfgetwc)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgetwc at \" << RTN_Address(rtnfgetwc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgetwc, AFUNPTR(myfgetwc)));\n            fptrfgetwc = (wint_t (*)(__FILE *))fptr;\n        }\n\n        RTN rtnfgets = RTN_FindByName(img, \"fgets\");\n        if (RTN_Valid(rtnfgets) && RTN_IsSafeForProbedReplacement(rtnfgets)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgets at \" << RTN_Address(rtnfgets) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgets, AFUNPTR(myfgets)));\n            fptrfgets = (CHAR_PTR  (*)(CHAR_PTR __restrict, int,\n                    FILE *__restrict))fptr;\n        }\n\n        RTN rtnfgetws = RTN_FindByName(img, \"fgetws\");\n        if (RTN_Valid(rtnfgetws) && RTN_IsSafeForProbedReplacement(rtnfgetws))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgetws at \" << RTN_Address(rtnfgetws) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgetws, AFUNPTR(myfgetws)));\n            fptrfgetws = (wchar_t * (*)(wchar_t *, int, __FILE *))fptr;\n        }\n\n        RTN rtnfread = RTN_FindByName(img, \"fread\");\n        if (RTN_Valid(rtnfread) && RTN_IsSafeForProbedReplacement(rtnfread))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fread at \" << RTN_Address(rtnfread) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfread, AFUNPTR(myfread)));\n            fptrfread = (size_t (*)(VOID_PTR , size_t, size_t, FILE *))fptr;\n        }\n\n        RTN rtnfwrite = RTN_FindByName(img, \"fwrite\");\n        if (RTN_Valid(rtnfwrite) && RTN_IsSafeForProbedReplacement(rtnfwrite))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fwrite at \" << RTN_Address(rtnfwrite) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfwrite, AFUNPTR(myfwrite)));\n            fptrfwrite = (size_t (*)(__const VOID_PTR __restrict, size_t, size_t,\n                    FILE *__restrict))fptr;\n        }\n\n        RTN rtnpipe = RTN_FindByName(img, \"pipe\");\n        if (RTN_Valid(rtnpipe) && RTN_IsSafeForProbedReplacement(rtnpipe))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pipe at \" << RTN_Address(rtnpipe) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpipe, AFUNPTR(mypipe)));\n            fptrpipe = (int (*)(int[2]))fptr;\n        }\n\n        RTN rtnread = RTN_FindByName(img, \"read\");\n        if (RTN_Valid(rtnread) && RTN_IsSafeForProbedReplacement(rtnread))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for read at \" << RTN_Address(rtnread) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnread, AFUNPTR(myread)));\n            fptrread = (ssize_t (*)(int, VOID_PTR , size_t))fptr;\n        }\n\n        RTN rtnwrite = RTN_FindByName(img, \"write\");\n        if (RTN_Valid(rtnwrite) && RTN_IsSafeForProbedReplacement(rtnwrite))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for write at \" << RTN_Address(rtnwrite) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwrite, AFUNPTR(mywrite)));\n            fptrwrite = (ssize_t (*)(int, __const VOID_PTR , size_t))fptr;\n        }\n\n        RTN rtnopen = RTN_FindByName(img, \"open\");\n        if (RTN_Valid(rtnopen) && RTN_IsSafeForProbedReplacement(rtnopen)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for open at \" << RTN_Address(rtnopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnopen, AFUNPTR(myopen)));\n            fptropen = (int (*)(__const CHAR_PTR , int, mode_t))fptr;\n        }\n\n        RTN rtnfopen = RTN_FindByName(img, \"fopen\");\n        if (RTN_Valid(rtnfopen) && RTN_IsSafeForProbedReplacement(rtnfopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fopen at \" << RTN_Address(rtnfopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfopen, AFUNPTR(myfopen)));\n            fptrfopen = (FILE * (*)(__const CHAR_PTR __restrict, __const CHAR_PTR __restrict))fptr;\n        }\n\n        RTN rtnfdopen = RTN_FindByName(img, \"fdopen\");\n        if (RTN_Valid(rtnfdopen) && RTN_IsSafeForProbedReplacement(rtnfdopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fdopen at \" << RTN_Address(rtnfdopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfdopen, AFUNPTR(myfdopen)));\n            fptrfdopen = (FILE * (*)(int, __const CHAR_PTR ))fptr;\n        }\n\n        RTN rtnclose = RTN_FindByName(img, \"close\");\n        if (RTN_Valid(rtnclose) && RTN_IsSafeForProbedReplacement(rtnclose))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for close at \" << RTN_Address(rtnclose) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclose, AFUNPTR(myclose)));\n            fptrclose = (int (*)(int))fptr;\n        }\n\n        RTN rtnfclose = RTN_FindByName(img, \"fclose\");\n        if (RTN_Valid(rtnfclose) && RTN_IsSafeForProbedReplacement(rtnfclose))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fclose at \" << RTN_Address(rtnfclose) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfclose, AFUNPTR(myfclose)));\n            fptrfclose = (int (*)(FILE *))fptr;\n        }\n\n        RTN rtncallrpc = RTN_FindByName(img, \"callrpc\");\n        if (RTN_Valid(rtncallrpc)&& RTN_IsSafeForProbedReplacement(rtncallrpc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for callrpc at \" << RTN_Address(rtncallrpc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtncallrpc, AFUNPTR(mycallrpc)));\n            fptrcallrpc = (int (*)(__const CHAR_PTR , u_long, u_long, u_long,\n                    xdrproc_t, __const CHAR_PTR , xdrproc_t, CHAR_PTR ))fptr;\n        }\n\n        RTN rtnclnt_broadcast = RTN_FindByName(img, \"clnt_broadcast\");\n        if (RTN_Valid(rtnclnt_broadcast)\n                && RTN_IsSafeForProbedReplacement(rtnclnt_broadcast))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for clnt_broadcast at \" << RTN_Address(rtnclnt_broadcast) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclnt_broadcast, AFUNPTR(myclnt_broadcast)));\n            fptrclnt_broadcast = (enum clnt_stat (*)(u_long, u_long, u_long,\n                    xdrproc_t, caddr_t, xdrproc_t, caddr_t, resultproc_t))fptr;\n        }\n\n        RTN rtnclntudp_create = RTN_FindByName(img, \"clntudp_create\");\n        if (RTN_Valid(rtnclntudp_create)\n                && RTN_IsSafeForProbedReplacement(rtnclntudp_create)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for clntudp_create at \" << RTN_Address(rtnclntudp_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclntudp_create, AFUNPTR(myclntudp_create)));\n            fptrclntudp_create = (CLIENT * (*)(struct sockaddr_in *, u_long,\n                    u_long, struct timeval, INT_PTR ))fptr;\n        }\n\n        RTN rtnclntudp_bufcreate = RTN_FindByName(img, \"clntudp_bufcreate\");\n        if (RTN_Valid(rtnclntudp_bufcreate) && RTN_IsSafeForProbedReplacement(rtnclntudp_bufcreate))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for clntudp_bufcreate at \" << RTN_Address(rtnclntudp_bufcreate) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclntudp_bufcreate, AFUNPTR(myclntudp_bufcreate)));\n            fptrclntudp_bufcreate = (CLIENT * (*)(struct sockaddr_in *, u_long, u_long, struct timeval, INT_PTR , u_int, u_int))fptr;\n        }\n\n        RTN rtnpmap_getmaps = RTN_FindByName(img, \"pmap_getmaps\");\n        if (RTN_Valid(rtnpmap_getmaps) && RTN_IsSafeForProbedReplacement(rtnpmap_getmaps)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_getmaps at \" << RTN_Address(rtnpmap_getmaps) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_getmaps, AFUNPTR(mypmap_getmaps)));\n            fptrpmap_getmaps = (struct pmaplist * (*)( struct sockaddr_in *))fptr;\n        }\n\n        RTN rtnpmap_getport = RTN_FindByName(img, \"pmap_getport\");\n        if (RTN_Valid(rtnpmap_getport) && RTN_IsSafeForProbedReplacement(rtnpmap_getport))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_getport at \" << RTN_Address(rtnpmap_getport) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_getport, AFUNPTR(mypmap_getport)));\n            fptrpmap_getport = (u_short (*)(struct sockaddr_in *, u_long, u_long, u_int))fptr;\n        }\n\n        RTN rtnpmap_rmtcall = RTN_FindByName(img, \"pmap_rmtcall\");\n        if (RTN_Valid(rtnpmap_rmtcall) && RTN_IsSafeForProbedReplacement(rtnpmap_rmtcall)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_rmtcall at \" << RTN_Address(rtnpmap_rmtcall) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_rmtcall, AFUNPTR(mypmap_rmtcall)));\n            fptrpmap_rmtcall = (enum clnt_stat (*)(struct sockaddr_in *, u_long,\n                    u_long, u_long, xdrproc_t, caddr_t, xdrproc_t, caddr_t,\n                    struct timeval, u_long *))fptr;\n        }\n\n        RTN rtnpmap_set = RTN_FindByName(img, \"pmap_set\");\n        if (RTN_Valid(rtnpmap_set) && RTN_IsSafeForProbedReplacement(rtnpmap_set)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_set at \" << RTN_Address(rtnpmap_set) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_set, AFUNPTR(mypmap_set)));\n            fptrpmap_set = (bool_t (*)(u_long, u_long, int, u_short))fptr;\n        }\n\n        RTN rtnclntraw_create = RTN_FindByName(img, \"clntraw_create\");\n        if (RTN_Valid(rtnclntraw_create)\n                && RTN_IsSafeForProbedReplacement(rtnclntraw_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for clntraw_create at \" << RTN_Address(rtnclntraw_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclntraw_create, AFUNPTR(myclntraw_create)));\n            fptrclntraw_create = (CLIENT * (*)(u_long, u_long))fptr;\n        }\n\n        RTN rtnsvc_run = RTN_FindByName(img, \"svc_run\");\n        if (RTN_Valid(rtnsvc_run) && RTN_IsSafeForProbedReplacement(rtnsvc_run)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for svc_run at \"\n                    << RTN_Address(rtnsvc_run) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvc_run, AFUNPTR(mysvc_run)));\n            fptrsvc_run = (void (*)())fptr;\n        }\n        \n        RTN rtnsvc_sendreply = RTN_FindByName(img, \"svc_sendreply\");\n        if (RTN_Valid(rtnsvc_sendreply) && RTN_IsSafeForProbedReplacement(rtnsvc_sendreply))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svc_sendreply at \" << RTN_Address(rtnsvc_sendreply) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvc_sendreply, AFUNPTR(mysvc_sendreply)));\n            fptrsvc_sendreply = (bool_t (*)(SVCXPRT *, xdrproc_t, caddr_t))fptr;\n        }\n\n        RTN rtnsvcraw_create = RTN_FindByName(img, \"svcraw_create\");\n        if (RTN_Valid(rtnsvcraw_create) && RTN_IsSafeForProbedReplacement(rtnsvcraw_create)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for svcraw_create at \" << RTN_Address(rtnsvcraw_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvcraw_create, AFUNPTR(mysvcraw_create)));\n            fptrsvcraw_create = (SVCXPRT * (*)())fptr;\n        }\n\n        RTN rtnsvctcp_create = RTN_FindByName(img, \"svctcp_create\");\n        if (RTN_Valid(rtnsvctcp_create) && RTN_IsSafeForProbedReplacement(rtnsvctcp_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svctcp_create at \" << RTN_Address(rtnsvctcp_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvctcp_create, AFUNPTR(mysvctcp_create)));\n            fptrsvctcp_create = (SVCXPRT * (*)(int, u_int, u_int))fptr;\n        }\n\n        RTN rtnsvcudp_bufcreate = RTN_FindByName(img, \"svcudp_bufcreate\");\n        if (RTN_Valid(rtnsvcudp_bufcreate) && RTN_IsSafeForProbedReplacement(rtnsvcudp_bufcreate))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svcudp_bufcreate at \" << RTN_Address(rtnsvcudp_bufcreate) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvcudp_bufcreate, AFUNPTR(mysvcudp_bufcreate)));\n            fptrsvcudp_bufcreate = (SVCXPRT * (*)(int, u_int, u_int))fptr;\n        }\n\n        RTN rtnsvcudp_create = RTN_FindByName(img, \"svcudp_create\");\n        if (RTN_Valid(rtnsvcudp_create) && RTN_IsSafeForProbedReplacement(rtnsvcudp_create)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for svcudp_create at \" << RTN_Address(rtnsvcudp_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvcudp_create, AFUNPTR(mysvcudp_create)));\n            fptrsvcudp_create = (SVCXPRT * (*)(int))fptr;\n        }\n\n        RTN rtnabort = RTN_FindByName(img, \"abort\");\n        if (RTN_Valid(rtnabort) && RTN_IsSafeForProbedReplacement(rtnabort)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for abort at \" << RTN_Address(rtnabort) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnabort, AFUNPTR(myabort)));\n            fptrabort = (void (*)())fptr;\n        }\n\n        RTN rtn_exit = RTN_FindByName(img, \"_exit\");\n        if (RTN_Valid(rtn_exit) && RTN_IsSafeForProbedReplacement(rtn_exit)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for _exit at \" << RTN_Address(rtn_exit) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn_exit, AFUNPTR(my_exit)));\n            fptr_exit = (void (*)(int))fptr;\n        }\n\n        RTN rtnnanosleep = RTN_FindByName(img, \"nanosleep\");\n        if (RTN_Valid(rtnnanosleep) && RTN_IsSafeForProbedReplacement(rtnnanosleep))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for nanosleep at \" << RTN_Address(rtnnanosleep) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnnanosleep, AFUNPTR(my_nanosleep)));\n            fptrnanosleep = (int (*)(const struct timespec *, struct timespec *))fptr;\n        }\n\n        RTN rtnsignal = RTN_FindByName(img, \"signal\");\n        if (RTN_Valid(rtnsignal) && RTN_IsSafeForProbedReplacement(rtnsignal)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for signal at \" << RTN_Address(rtnsignal) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsignal, AFUNPTR(mysignal)));\n            fptrsignal = (__sighandler_t (*)(int, __sighandler_t))fptr;\n        }\n\n        RTN rtnsigprocmask = RTN_FindByName(img, \"sigprocmask\");\n        if (RTN_Valid(rtnsigprocmask) && RTN_IsSafeForProbedReplacement(rtnsigprocmask)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigprocmask at \" << RTN_Address(rtnsigprocmask) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigprocmask, AFUNPTR(mysigprocmask)));\n            fptrsigprocmask = (int (*)(int, __const sigset_t *__restrict, sigset_t *__restrict))fptr;\n        }\n\n        RTN rtnsigpending = RTN_FindByName(img, \"sigpending\");\n        if (RTN_Valid(rtnsigpending) && RTN_IsSafeForProbedReplacement(rtnsigpending)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigpending at \" << RTN_Address(rtnsigpending) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigpending, AFUNPTR(mysigpending)));\n            fptrsigpending = (int (*)(sigset_t *))fptr;\n        }\n\n        RTN rtnsigaction = RTN_FindByName(img, \"sigaction\");\n        if (RTN_Valid(rtnsigaction) && RTN_IsSafeForProbedReplacement(rtnsigaction)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigaction at \" << RTN_Address(rtnsigaction) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigaction, AFUNPTR(mysigaction)));\n            fptrsigaction = (int (*)(int __sig, __const struct sigaction *__restrict __act, struct sigaction *__restrict __oact))fptr;\n        }\n\n        RTN rtnsetitimer = RTN_FindByName(img, \"setitimer\");\n        if (RTN_Valid(rtnsetitimer) && RTN_IsSafeForProbedReplacement(rtnsetitimer)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for setitimer at \" << RTN_Address(rtnsetitimer) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsetitimer, AFUNPTR(mysetitimer)));\n            fptrsetitimer = (int (*)(__itimer_which_t,  __const struct itimerval *__restrict, struct itimerval *__restrict))fptr;\n        }\n\n        RTN rtnexit = RTN_FindByName(img, \"exit\");\n        if (RTN_Valid(rtnexit) && RTN_IsSafeForProbedReplacement(rtnexit)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for exit at \" << RTN_Address(rtnexit) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnexit, AFUNPTR(myexit)));\n            fptrexit = (void (*)(int))fptr;\n        }\n\n        RTN rtndl_iterate_phdr = RTN_FindByName(img, \"dl_iterate_phdr\");\n        if (RTN_Valid(rtnexit) && RTN_IsSafeForProbedReplacement(rtndl_iterate_phdr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dl_iterate_phdr at \" << RTN_Address(rtndl_iterate_phdr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndl_iterate_phdr, AFUNPTR(mydl_iterate_phdr)));\n            fptrdl_iterate_phdr = (int (*)( int (*callback)(struct dl_phdr_info *info, size_t size, VOID_PTR data), VOID_PTR data))fptr;\n        }\n\n        RTN rtnsystem = RTN_FindByName(img, \"system\");\n        if (RTN_Valid(rtnsystem) && RTN_IsSafeForProbedReplacement(rtnsystem)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for system at \"\n                    << RTN_Address(rtnsystem) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsystem, AFUNPTR(mysystem)));\n            fptrsystem = (int (*)(const CHAR_PTR ))fptr;\n        }\n\n        RTN rtnalarm = RTN_FindByName(img, \"alarm\");\n        if (RTN_Valid(rtnalarm) && RTN_IsSafeForProbedReplacement(rtnalarm)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for alarm at \"\n                    << RTN_Address(rtnalarm) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnalarm, AFUNPTR(myalarm)));\n            fptralarm = (unsigned int (*)(unsigned int))fptr;\n        }\n\n        RTN rtnrecvmsg = RTN_FindByName(img, \"recvmsg\");\n        if (RTN_Valid(rtnrecvmsg) && RTN_IsSafeForProbedReplacement(rtnrecvmsg)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for recvmsg at \" << RTN_Address(rtnrecvmsg) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnrecvmsg, AFUNPTR(myrecvmsg)));\n            fptrrecvmsg = (ssize_t (*)(int, struct msghdr *, int))fptr;\n        }\n\n        RTN rtnsendmsg = RTN_FindByName(img, \"sendmsg\");\n        if (RTN_Valid(rtnsendmsg) && RTN_IsSafeForProbedReplacement(rtnsendmsg))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sendmsg at \"\n                    << RTN_Address(rtnsendmsg) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsendmsg, AFUNPTR(mysendmsg)));\n            fptrsendmsg = (ssize_t (*)(int, const struct msghdr *, int))fptr;\n        }\n\n        RTN rtnpause = RTN_FindByName(img, \"pause\");\n        if (RTN_Valid(rtnpause) && RTN_IsSafeForProbedReplacement(rtnpause)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for pause at \"\n                    << RTN_Address(rtnpause) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpause, AFUNPTR(mypause)));\n            fptrpause = (int (*)(void))fptr;\n        }\n\n        RTN rtnsigtimedwait = RTN_FindByName(img, \"sigtimedwait\");\n        if (RTN_Valid(rtnsigtimedwait) && RTN_IsSafeForProbedReplacement(rtnsigtimedwait)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigtimedwait at \" << RTN_Address(rtnsigtimedwait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigtimedwait, AFUNPTR(mysigtimedwait)));\n            fptrsigtimedwait = (int (*)(const sigset_t *, siginfo_t *, const struct timespec *))fptr;\n        }\n\n        RTN rtnsigwaitinfo = RTN_FindByName(img, \"sigwaitinfo\");\n        if (RTN_Valid(rtnsigwaitinfo) && RTN_IsSafeForProbedReplacement(rtnsigwaitinfo))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigwaitinfo at \" << RTN_Address(rtnsigwaitinfo) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigwaitinfo, AFUNPTR(mysigwaitinfo)));\n            fptrsigwaitinfo = (int (*)(const sigset_t *, siginfo_t *))fptr;\n        }\n\n        RTN rtnepoll_wait = RTN_FindByName(img, \"epoll_wait\");\n        if (RTN_Valid(rtnepoll_wait) && RTN_IsSafeForProbedReplacement(rtnepoll_wait)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for epoll_wait at \" << RTN_Address(rtnepoll_wait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnepoll_wait, AFUNPTR(myepoll_wait)));\n            fptrepoll_wait = (int (*)(int, struct epoll_event *, int, int))fptr;\n        }\n\n        RTN rtnppoll = RTN_FindByName(img, \"ppoll\");\n        if (RTN_Valid(rtnppoll) && RTN_IsSafeForProbedReplacement(rtnppoll)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for ppoll at \" << RTN_Address(rtnppoll) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnppoll, AFUNPTR(myppoll)));\n            fptrppoll = (int (*)(struct pollfd *, nfds_t, const struct timespec *, const sigset_t *))fptr;\n        }\n\n        RTN rtnmsgsnd = RTN_FindByName(img, \"msgsnd\");\n        if (RTN_Valid(rtnmsgsnd) && RTN_IsSafeForProbedReplacement(rtnmsgsnd)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for msgsnd at \" << RTN_Address(rtnmsgsnd) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmsgsnd, AFUNPTR(mymsgsnd)));\n            fptrmsgsnd = (int (*)(int, const VOID_PTR , size_t, int))fptr;\n        }\n\n        RTN rtnmsgrcv = RTN_FindByName(img, \"msgrcv\");\n        if (RTN_Valid(rtnmsgrcv) && RTN_IsSafeForProbedReplacement(rtnmsgrcv)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for msgrcv at \" << RTN_Address(rtnmsgrcv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmsgrcv, AFUNPTR(mymsgrcv)));\n            fptrmsgrcv = (ssize_t (*)(int, VOID_PTR , size_t, long, int))fptr;\n        }\n\n        RTN rtnsemop = RTN_FindByName(img, \"semop\");\n        if (RTN_Valid(rtnsemop) && RTN_IsSafeForProbedReplacement(rtnsemop)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for semop at \" << RTN_Address(rtnsemop) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsemop, AFUNPTR(mymsgrcv)));\n            fptrsemop = (int (*)(int, struct sembuf *, unsigned))fptr;\n        }\n        \n        RTN rtnsemtimedop = RTN_FindByName(img, \"semtimedop\");\n        if (RTN_Valid(rtnsemtimedop)\n                && RTN_IsSafeForProbedReplacement(rtnsemtimedop)) {\n            OutFile << CurrentTime() << \"Inserting probe for semtimedop at \"\n                    << RTN_Address(rtnsemtimedop) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsemtimedop,\n                    AFUNPTR(mysemtimedop)));\n            fptrsemtimedop = (int (*)(int, struct sembuf *))fptr;}\n\n        RTN rtnusleep = RTN_FindByName(img, \"usleep\");\n        if (RTN_Valid(rtnusleep) && RTN_IsSafeForProbedReplacement(rtnusleep)) {\n            OutFile << CurrentTime() << \"Inserting probe for usleep at \"\n                    << RTN_Address(rtnusleep) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnusleep, AFUNPTR(myusleep)));\n            fptrusleep = (int (*)(useconds_t))fptr;}\n\n        RTN rtnualarm = RTN_FindByName(img, \"ualarm\");\n        if (RTN_Valid(rtnualarm) && RTN_IsSafeForProbedReplacement(rtnualarm)) {\n            OutFile << CurrentTime() << \"Inserting probe for ualarm at \"\n                    << RTN_Address(rtnualarm) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnualarm, AFUNPTR(myualarm)));\n            fptrualarm = (useconds_t (*)(useconds_t, useconds_t))fptr;}\n\n        RTN rtngetitimer = RTN_FindByName(img, \"getitimer\");\n        if (RTN_Valid(rtngetitimer) && RTN_IsSafeForProbedReplacement(rtngetitimer))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getitimer at \" << RTN_Address(rtngetitimer) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetitimer, AFUNPTR(mygetitimer)));\n            fptrgetitimer = (int (*)(int, struct itimerval *))fptr;}\n\n        RTN rtnsigwait = RTN_FindByName(img, \"sigwait\");\n        if (RTN_Valid(rtnsigwait) && RTN_IsSafeForProbedReplacement(rtnsigwait))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigwait at \" << RTN_Address(rtnsigwait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigwait, AFUNPTR(mysigwait)));\n            fptrsigwait = (int (*)(const sigset_t *, INT_PTR ))fptr;\n        }\n\n        RTN rtnmsgget = RTN_FindByName(img, \"msgget\");\n        if (RTN_Valid(rtnmsgget) && RTN_IsSafeForProbedReplacement(rtnmsgget)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for msgget at \" << RTN_Address(rtnmsgget) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmsgget, AFUNPTR(mymsgget)));\n            fptrmsgget = (int (*)(key_t, int))fptr;\n        }\n\n        RTN rtnsemget = RTN_FindByName(img, \"semget\");\n        if (RTN_Valid(rtnsemget) && RTN_IsSafeForProbedReplacement(rtnsemget))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for semget at \" << RTN_Address(rtnsemget) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsemget, AFUNPTR(mysemget)));\n            fptrsemget = (int (*)(key_t, int, int))fptr;\n        }\n\n        RTN rtnwait = RTN_FindByName(img, \"wait\");\n        if (RTN_Valid(rtnwait) && RTN_IsSafeForProbedReplacement(rtnwait)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for wait at \" << RTN_Address(rtnwait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwait, AFUNPTR(mywait)));\n            fptrwait = (pid_t (*)(INT_PTR ))fptr;\n        }\n\n        RTN rtnwaitpid = RTN_FindByName(img, \"waitpid\");\n        if (RTN_Valid(rtnwaitpid) && RTN_IsSafeForProbedReplacement(rtnwaitpid)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for waitpid at \" << RTN_Address(rtnwaitpid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwaitpid, AFUNPTR(mywaitpid)));\n            fptrwaitpid = (pid_t (*)(pid_t, INT_PTR , int))fptr;\n        }\n\n        RTN rtnwaitid = RTN_FindByName(img, \"waitid\");\n        if (RTN_Valid(rtnwaitid) && RTN_IsSafeForProbedReplacement(rtnwaitid)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for waitid at \" << RTN_Address(rtnwaitid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwaitid, AFUNPTR(mywaitid)));\n            fptrwaitid = (int (*)(idtype_t, id_t, siginfo_t *, int))fptr;\n        }\n\n        RTN rtnwait3 = RTN_FindByName(img, \"wait3\");\n        if (RTN_Valid(rtnwait3) && RTN_IsSafeForProbedReplacement(rtnwait3)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for wait3 at \" << RTN_Address(rtnwait3) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwait3, AFUNPTR(mywait3)));\n            fptrwait3 = (pid_t (*)(INT_PTR , int, struct rusage *))fptr;\n        }\n\n        RTN rtnwait4 = RTN_FindByName(img, \"wait4\");\n        if (RTN_Valid(rtnwait3) && RTN_IsSafeForProbedReplacement(rtnwait4)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for wait4 at \" << RTN_Address(rtnwait4) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwait3, AFUNPTR(mywait4)));\n            fptrwait4 = (pid_t (*)(pid_t, INT_PTR , int, struct rusage *))fptr;\n        }\n\n        RTN rtnreadv = RTN_FindByName(img, \"readv\");\n        if (RTN_Valid(rtnreadv) && RTN_IsSafeForProbedReplacement(rtnreadv)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for readv at \" << RTN_Address(rtnreadv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnreadv, AFUNPTR(myreadv)));\n            fptrreadv = (ssize_t (*)(int, const struct iovec *, int))fptr;\n        }\n\n        RTN rtnwritev = RTN_FindByName(img, \"writev\");\n        if (RTN_Valid(rtnwritev) && RTN_IsSafeForProbedReplacement(rtnwritev)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for writev at \" << RTN_Address(rtnwritev) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwritev, AFUNPTR(mywritev)));\n            fptrwritev = (ssize_t (*)(int, const struct iovec *, int))fptr;\n        }\n\n        RTN rtnflockfile = RTN_FindByName(img, \"flockfile\");\n        if (RTN_Valid(rtnflockfile) && RTN_IsSafeForProbedReplacement(rtnflockfile)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for flockfile at \" << RTN_Address(rtnflockfile) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnflockfile, AFUNPTR(myflockfile)));\n            fptrflockfile = (void (*)(FILE *))fptr;\n        }\n        RTN rtnfunlockfile = RTN_FindByName(img, \"funlockfile\");\n        if (RTN_Valid(rtnfunlockfile)\n                && RTN_IsSafeForProbedReplacement(rtnfunlockfile)) {\n            OutFile << CurrentTime() << \"Inserting probe for funlockfile at \"\n                    << RTN_Address(rtnfunlockfile) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfunlockfile,\n                    AFUNPTR(myfunlockfile)));\n            fptrfunlockfile = (void (*)(FILE *))fptr;}\n\n        RTN rtnlockf = RTN_FindByName(img, \"lockf\");\n        if (RTN_Valid(rtnlockf) && RTN_IsSafeForProbedReplacement(rtnlockf))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for lockf at \" << RTN_Address(rtnlockf) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlockf, AFUNPTR(mylockf)));\n            fptrlockf = (int (*)(int, int, off_t))fptr;\n        }\n\n        RTN rtnsetenv = RTN_FindByName(img, \"setenv\");\n        if (RTN_Valid(rtnsetenv) && RTN_IsSafeForProbedReplacement(rtnsetenv)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for setenv at \" << RTN_Address(rtnsetenv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsetenv, AFUNPTR(mysetenv)));\n            fptrsetenv = (int (*)(const CHAR_PTR , const CHAR_PTR , int))fptr;\n        }\n            \n        RTN rtnunsetenv = RTN_FindByName(img, \"unsetenv\");\n        if (RTN_Valid(rtnunsetenv) && RTN_IsSafeForProbedReplacement(rtnunsetenv)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for unsetenv at \" << RTN_Address(rtnunsetenv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnunsetenv, AFUNPTR(myunsetenv)));\n            fptrunsetenv = (int (*)(const CHAR_PTR ))fptr;\n        }\n\n        RTN rtngetenv = RTN_FindByName(img, \"getenv\");\n        if (RTN_Valid(rtngetenv) && RTN_IsSafeForProbedReplacement(rtngetenv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getenv at \"\n                    << RTN_Address(rtngetenv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetenv, AFUNPTR(mygetenv)));\n            fptrgetenv = (CHAR_PTR  (*)(const CHAR_PTR ))fptr;\n        }\n\n        RTN rtnperror = RTN_FindByName(img, \"perror\");\n        if (RTN_Valid(rtnperror) && RTN_IsSafeForProbedReplacement(rtnperror)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for perror at \"\n                    << RTN_Address(rtnperror) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnperror, AFUNPTR(myperror)));\n            fptrperror = (void (*)(const CHAR_PTR ))fptr;\n        }\n\n        RTN rtnmmap = RTN_FindByName(img, \"mmap\");\n        if (RTN_Valid(rtnmmap) && RTN_IsSafeForProbedReplacement(rtnmmap)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for mmap at \"\n                    << RTN_Address(rtnmmap) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmmap, AFUNPTR(mymmap)));\n            fptrmmap = (VOID_PTR (*)(VOID_PTR , size_t, int, int, int, off_t))fptr;\n        }\n\n        RTN rtnmunmap = RTN_FindByName(img, \"munmap\");\n        if (RTN_Valid(rtnmunmap) && RTN_IsSafeForProbedReplacement(rtnmunmap))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for munmap at \"\n                    << RTN_Address(rtnmunmap) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmunmap, AFUNPTR(mymunmap)));\n            fptrmunmap = (int (*)(VOID_PTR , size_t))fptr;\n        }\n\n        RTN rtnfileno = RTN_FindByName(img, \"fileno\");\n        if (RTN_Valid(rtnfileno) && RTN_IsSafeForProbedReplacement(rtnfileno)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for fileno at \"\n                    << RTN_Address(rtnfileno) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfileno, AFUNPTR(myfileno)));\n            fptrfileno = (int (*)(FILE *))fptr;\n        }\n\n        RTN rtngetpid = RTN_FindByName(img, \"getpid\");\n        if (RTN_Valid(rtngetpid) && RTN_IsSafeForProbedReplacement(rtngetpid)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for getpid at \"\n                    << RTN_Address(rtngetpid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetpid, AFUNPTR(mygetpid)));\n            fptrgetpid = (pid_t (*)(void))fptr;\n        }\n\n        RTN rtngetppid = RTN_FindByName(img, \"getppid\");\n        if (RTN_Valid(rtngetppid) && RTN_IsSafeForProbedReplacement(rtngetppid))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getppid at \" << RTN_Address(rtngetppid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetppid, AFUNPTR(mygetppid)));\n            fptrgetppid = (pid_t (*)(void))fptr;\n        }\n\n        RTN rtnmemset = RTN_FindByName(img, \"memset\");\n        if (RTN_Valid(rtnmemset) && RTN_IsSafeForProbedReplacement(rtnmemset)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for memset at \" << RTN_Address(rtnmemset) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmemset, AFUNPTR(mymemset)));\n            fptrmemset = (VOID_PTR  (*)(VOID_PTR , int, size_t))fptr;\n        }\n\n        RTN rtnmemcpy = RTN_FindByName(img, \"memcpy\");\n        if (RTN_Valid(rtnmemcpy) && RTN_IsSafeForProbedReplacement(rtnmemcpy)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for memcpy at \" << RTN_Address(rtnmemcpy) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmemcpy, AFUNPTR(mymemcpy)));\n            fptrmemcpy = (VOID_PTR  (*)(VOID_PTR , const VOID_PTR , size_t))fptr;\n        }\n\n        RTN rtnaccess = RTN_FindByName(img, \"access\");\n        if (RTN_Valid(rtnaccess) && RTN_IsSafeForProbedReplacement(rtnaccess)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for access at \" << RTN_Address(rtnaccess) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnaccess, AFUNPTR(myaccess)));\n            fptraccess = (int (*)(const CHAR_PTR , int))fptr;\n        }\n\n        RTN rtnlseek = RTN_FindByName(img, \"lseek\");\n        if (RTN_Valid(rtnlseek) && RTN_IsSafeForProbedReplacement(rtnlseek))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for lseek at \" << RTN_Address(rtnlseek) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlseek, AFUNPTR(mylseek)));\n            fptrlseek = (off_t (*)(int, off_t, int))fptr;\n        }\n\n        RTN rtnlseek64 = RTN_FindByName(img, \"lseek64\");\n        if (RTN_Valid(rtnlseek64) && RTN_IsSafeForProbedReplacement(rtnlseek64)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for lseek64 at \" << RTN_Address(rtnlseek64) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlseek64, AFUNPTR(mylseek64)));\n            fptrlseek64 = (off64_t (*)(int, off64_t, int))fptr;\n        }\n\n        RTN rtnfdatasync = RTN_FindByName(img, \"fdatasync\");\n        if (RTN_Valid(rtnfdatasync) && RTN_IsSafeForProbedReplacement(rtnfdatasync))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fdatasync at \" << RTN_Address(rtnfdatasync) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfdatasync, AFUNPTR(myfdatasync)));\n            fptrfdatasync = (int (*)(int))fptr;\n        }\n\n        RTN rtnunlink = RTN_FindByName(img, \"unlink\");\n        if (RTN_Valid(rtnunlink) && RTN_IsSafeForProbedReplacement(rtnunlink)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for unlink at \" << RTN_Address(rtnunlink) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnunlink, AFUNPTR(myunlink)));\n            fptrunlink = (int (*)(const CHAR_PTR ))fptr;\n        }\n\n        RTN rtnstrlen = RTN_FindByName(img, \"strlen\");\n        if (RTN_Valid(rtnstrlen) && RTN_IsSafeForProbedReplacement(rtnstrlen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strlen at \" << RTN_Address(rtnstrlen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrlen, AFUNPTR(mystrlen)));\n            fptrstrlen = (size_t (*)(const CHAR_PTR ))fptr;\n        }\n\n        RTN rtnwcslen = RTN_FindByName(img, \"wcslen\");\n        if (RTN_Valid(rtnwcslen) && RTN_IsSafeForProbedReplacement(rtnwcslen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for wcslen at \"<< RTN_Address(rtnwcslen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwcslen, AFUNPTR(mywcslen)));\n            fptrwcslen = (size_t (*)(const wchar_t *))fptr;\n        }\n\n        RTN rtnstrcpy = RTN_FindByName(img, \"strcpy\");\n        if (RTN_Valid(rtnstrcpy) && RTN_IsSafeForProbedReplacement(rtnstrcpy))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strcpy at \" << RTN_Address(rtnstrcpy) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrcpy, AFUNPTR(mystrcpy)));\n            fptrstrcpy = (CHAR_PTR  (*)(CHAR_PTR , const CHAR_PTR ))fptr;\n        }\n\n        RTN rtnstrncpy = RTN_FindByName(img, \"strncpy\");\n        if (RTN_Valid(rtnstrncpy) && RTN_IsSafeForProbedReplacement(rtnstrncpy)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for strncpy at \" << RTN_Address(rtnstrncpy) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrncpy, AFUNPTR(mystrcpy)));\n            fptrstrncpy = (CHAR_PTR  (*)(CHAR_PTR , const CHAR_PTR , size_t))fptr;\n        }\n\n        RTN rtnstrcat = RTN_FindByName(img, \"strcat\");\n        if (RTN_Valid(rtnstrcat) && RTN_IsSafeForProbedReplacement(rtnstrcat)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for strcat at \" << RTN_Address(rtnstrcat) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrcat, AFUNPTR(mystrcat)));\n            fptrstrcat = (CHAR_PTR  (*)(CHAR_PTR , const CHAR_PTR ))fptr;\n        }\n\n        RTN rtnstrstr = RTN_FindByName(img, \"strstr\");\n        if (RTN_Valid(rtnstrstr) && RTN_IsSafeForProbedReplacement(rtnstrstr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strstr at \" << RTN_Address(rtnstrstr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrstr, AFUNPTR(mystrstr)));\n            fptrstrstr = (CHAR_PTR  (*)(const CHAR_PTR , const CHAR_PTR ))fptr;\n        }\n\n        RTN rtnstrchr0 = RTN_FindByName(img, \"strchr0\");\n        if (RTN_Valid(rtnstrchr0) && RTN_IsSafeForProbedReplacement(rtnstrchr0))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strchr0 at \" << RTN_Address(rtnstrchr0) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrchr0, AFUNPTR(mystrchr0)));\n            fptrstrrchr = (CHAR_PTR  (*)(const CHAR_PTR , int))fptr;\n        }\n\n        RTN rtnstrrchr = RTN_FindByName(img, \"strrchr\");\n        if (RTN_Valid(rtnstrrchr) && RTN_IsSafeForProbedReplacement(rtnstrrchr)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for strrchr at \"\n                    << RTN_Address(rtnstrrchr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrrchr, AFUNPTR(mystrrchr)));\n            fptrstrrchr = (CHAR_PTR  (*)(const CHAR_PTR , int))fptr;\n        }\n\n        RTN rtnstrcmp = RTN_FindByName(img, \"strcmp\");\n        if (RTN_Valid(rtnstrcmp) && RTN_IsSafeForProbedReplacement(rtnstrcmp))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strcmp at \" << RTN_Address(rtnstrcmp) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrcmp, AFUNPTR(mystrcmp)));\n            fptrstrcmp = (int (*)(const CHAR_PTR , const CHAR_PTR ))fptr;\n        }\n\n        RTN rtnstrncmp = RTN_FindByName(img, \"strncmp\");\n        if (RTN_Valid(rtnstrncmp) && RTN_IsSafeForProbedReplacement(rtnstrncmp))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strncmp at \" << RTN_Address(rtnstrncmp) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrncmp, AFUNPTR(mystrncmp)));\n            fptrstrncmp = (int (*)(const CHAR_PTR , const CHAR_PTR , size_t))fptr;\n        }\n\n        RTN rtnsigaddset = RTN_FindByName(img, \"sigaddset\");\n        if (RTN_Valid(rtnsigaddset) && RTN_IsSafeForProbedReplacement(rtnsigaddset))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigaddset at \" << RTN_Address(rtnsigaddset) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigaddset, AFUNPTR(mysigaddset)));\n            fptrsigaddset = (int (*)(sigset_t *, int))fptr;\n        }\n\n        RTN rtnsigdelset = RTN_FindByName(img, \"sigdelset\");\n        if (RTN_Valid(rtnsigdelset) && RTN_IsSafeForProbedReplacement(rtnsigdelset)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigdelset at \"<< RTN_Address(rtnsigdelset) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigdelset, AFUNPTR(mysigdelset)));\n            fptrsigdelset = (int (*)(sigset_t *, int))fptr;\n        }\n\n        RTN rtnsigismember = RTN_FindByName(img, \"sigismember\");\n        if (RTN_Valid(rtnsigismember) && RTN_IsSafeForProbedReplacement(rtnsigismember)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigismember at \" << RTN_Address(rtnsigismember) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigismember, AFUNPTR(mysigismember)));\n            fptrsigdelset = (int (*)(sigset_t *, int))fptr;\n        }\n\n        RTN rtnstrerror = RTN_FindByName(img, \"strerror\");\n        if (RTN_Valid(rtnstrerror) && RTN_IsSafeForProbedReplacement(rtnstrerror)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for strerror at \" << RTN_Address(rtnstrerror) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrerror, AFUNPTR(mystrerror)));\n            fptrstrerror = (CHAR_PTR  (*)(int))fptr;\n        }\n\n        RTN rtnbind = RTN_FindByName(img, \"bind\");\n        if (RTN_Valid(rtnbind) && RTN_IsSafeForProbedReplacement(rtnbind)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for bind at \" << RTN_Address(rtnbind) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnbind, AFUNPTR(mybind)));\n            fptrbind = (int (*)(int, const struct sockaddr *, socklen_t))fptr;\n        }\n\n        RTN rtnlisten = RTN_FindByName(img, \"listen\");\n        if (RTN_Valid(rtnlisten) && RTN_IsSafeForProbedReplacement(rtnlisten))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for listen at \" << RTN_Address(rtnlisten) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlisten, AFUNPTR(mylisten)));\n            fptrlisten = (int (*)(int, int))fptr;\n        }\n\n        RTN rtnuname = RTN_FindByName(img, \"uname\");\n        if (RTN_Valid(rtnuname) && RTN_IsSafeForProbedReplacement(rtnuname)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for uname at \"    << RTN_Address(rtnuname) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnuname, AFUNPTR(myuname)));\n            fptruname = (int (*)(struct utsname *))fptr;\n        }\n\n        RTN rtngethostname = RTN_FindByName(img, \"gethostname\");\n        if (RTN_Valid(rtngethostname) && RTN_IsSafeForProbedReplacement(rtngethostname))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for gethostname at \" << RTN_Address(rtngethostname) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngethostname, AFUNPTR(mygethostname)));\n            fptrgethostname = (int (*)(CHAR_PTR , size_t))fptr;\n        }\n\n        RTN rtnkill = RTN_FindByName(img, \"kill\");\n        if (RTN_Valid(rtnkill) && RTN_IsSafeForProbedReplacement(rtnkill)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for kill at \" << RTN_Address(rtnkill) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnkill, AFUNPTR(mykill)));\n            fptrkill = (int (*)(pid_t, int))fptr;\n        }\n\n        RTN rtnsched_yield = RTN_FindByName(img, \"sched_yield\");\n        if (RTN_Valid(rtnsched_yield) && RTN_IsSafeForProbedReplacement(rtnsched_yield)) {\n            OutFile << CurrentTime() << \"Inserting probe for sched_yield at \" << RTN_Address(rtnsched_yield) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsched_yield, AFUNPTR(mysched_yield)));\n            fptrsched_yield = (int (*)())fptr;\n        }\n\n        RTN rtntimer_settime = RTN_FindByName(img, \"timer_settime\");\n        if (RTN_Valid(rtntimer_settime) && RTN_IsSafeForProbedReplacement(rtntimer_settime)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for timer_settime at \" << RTN_Address(rtntimer_settime) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtntimer_settime, AFUNPTR(mytimer_settime)));\n            fptrtimer_settime = (int (*)(timer_t, int, const struct itimerspec *, struct itimerspec *))fptr;\n        }\n\n        RTN rtnsigaltstack = RTN_FindByName(img, \"sigaltstack\");\n        if (RTN_Valid(rtnsigaltstack) && RTN_IsSafeForProbedReplacement(rtnsigaltstack))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigaltstack at \" << RTN_Address(rtnsigaltstack) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigaltstack, AFUNPTR(mysigaltstack)));\n            fptrsigaltstack = (int (*)(const stack_t *, stack_t *))fptr;\n        }\n\n        RTN rtnioctl = RTN_FindByName(img, \"ioctl\");\n        if (RTN_Valid(rtnioctl) && RTN_IsSafeForProbedReplacement(rtnioctl))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for ioctl at \" << RTN_Address(rtnioctl) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnioctl, AFUNPTR(myioctl)));\n            fptrioctl = (int (*)(int, int, CHAR_PTR ))fptr;\n        }\n\n        RTN rtnflock = RTN_FindByName(img, \"flock\");\n        if (RTN_Valid(rtnflock) && RTN_IsSafeForProbedReplacement(rtnflock)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for flock at \" << RTN_Address(rtnflock) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnflock, AFUNPTR(myflock)));\n            fptrflock = (int (*)(int, int))fptr;\n        }\n\n        RTN rtn__libc_dlopen_mode = RTN_FindByName(img, \"__libc_dlopen_mode\");\n        if (RTN_Valid(rtn__libc_dlopen_mode) && RTN_IsSafeForProbedReplacement(rtn__libc_dlopen_mode)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for __libc_dlopen_mode at \" << RTN_Address(rtn__libc_dlopen_mode) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn__libc_dlopen_mode, AFUNPTR(my__libc_dlopen_mode)));\n            fptr__libc_dlopen_mode = (VOID_PTR  (*)(const CHAR_PTR , int))fptr;\n        }\n\n        RTN rtn__errno_location = RTN_FindByName(img, \"__errno_location\");\n        if (RTN_Valid(rtn__errno_location) && RTN_IsSafeForProbedReplacement(rtn__errno_location))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for __errno_location at \" << RTN_Address(rtn__errno_location) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn__errno_location, AFUNPTR(my__errno_location)));\n            fptr__errno_location = (INT_PTR  (*)())fptr;\n        }\n\n        RTN rtnsyscall = RTN_FindByName(img, \"syscall\");\n        if (RTN_Valid(rtnsyscall) && RTN_IsSafeForProbedReplacement(rtnsyscall)) \n        {\n            OutFile << CurrentTime() << \"Inserting probe for syscall at \" << RTN_Address(rtnsyscall) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsyscall, AFUNPTR(mysyscall)));\n            fptrsyscall = (int (*)(int, long int, long int, long int, long int, long int, long int, long int))fptr;}\n        }\n        // finished instrumentation\n    }\n\n/* ===================================================================== */\n/* Main function                                                         */\n/* ===================================================================== */\n\nint main(int argc, char *argv[]) {\n    // Initialize Pin\n    PIN_InitSymbols();\n    if (PIN_Init(argc, argv)) {\n        return Usage();\n    }\n\n    OutFile.open(KnobOutputFile.Value().c_str());\n    OutFile << hex;\n    OutFile.setf(ios::showbase);\n    OutFile << CurrentTime() << \"started!\" << endl;\n    OutFile.flush();\n\n    // Register the instrumentation callback\n    IMG_AddInstrumentFunction(ImgLoad, 0);\n\n    // Start the application\n    PIN_StartProgramProbed(); // never returns\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Tests/sourceLocation_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n * This app checks a bug in the debug_elf cache mechanism. The cache contains images\n * that have previously been searched for debug information. When a pintool calls the\n * PIN_GetSourceLocation API, this cache is searched first (for the nearest address\n * which is greater or equal to the one being searched for). However, unloaded images\n * were never removed from the cache. When the API was used during an image unload\n * callback, if the images at high addresses were removed first, the search could be\n * conducted on images in the cache that had already been removed from Pin's internal\n * data structures, thus causing an assertion. The solution was to remove these images\n * from the cache as well as from the other data structres.\n * This app loads two images and then unloads the higher addressed one first in order\n * to recreate the conditions mentioned above.\n */\n\n#include <dlfcn.h>\n#include <iostream>\n#include <cstdlib>\n\nusing std::cerr;\nusing std::endl;\n\nvoid* DLopen(const char* filename) {\n    void* handle = dlopen(filename, RTLD_LAZY);\n    if (handle == NULL) {\n        cerr << \"APP ERROR: failed to open \" << filename << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n    return handle;\n}\n\nvoid* DLsym(void* handle, const char* symname) {\n    dlerror(); // clear errors\n    void* sym = dlsym(handle, symname);\n    char* error = dlerror();\n    if (error != NULL) {\n        cerr << \"APP ERROR: failed to get address for symbol \" << symname << \" - \" << error << endl;\n        exit(-1);\n    }\n    return sym;\n}\n\nvoid DLcloseBoth(void* first, void* second) {\n    if (dlclose(first) != 0) {\n        cerr << \"APP ERROR: failed to close image at \" << first << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n    if (dlclose(second) != 0) {\n        cerr << \"APP ERROR: failed to close image at \" << second << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n}\n\n/*\n * Expected argv arguments:\n * [1] image1\n * [2] image2\n */\nint main(int argc, char* argv[]) {\n    \n    void* handle1 = DLopen(argv[1]);            // open image1\n    void* handle2 = DLopen(argv[2]);            // open image2\n    void* dummy1 = DLsym(handle1, \"dummy1\");    // get address from image1\n    void* dummy2 = DLsym(handle2, \"dummy2\");    // get address from image2\n\n    // unload images - higher addressed image first\n    if (dummy1 > dummy2) {\n        DLcloseBoth(handle1, handle2);\n    }\n    else {\n        DLcloseBoth(handle2, handle1);\n    }\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/ImageTests/l_imageLoad_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <dlfcn.h>\n\n#define EXPORT_SYM extern \"C\"\n\nEXPORT_SYM int AfterAttach();\n\nstatic int MAX_SIZE = 128; /*maximum line size*/\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_FORK_FAILED,      // 1\n    RES_EXEC_FAILED,      // 2\n    RES_LOAD_FAILED,      // 3\n    RES_RES_INVALID_ARGS  // 4\n};\n\nvoid UnixOpen(char* filename)\n{\n    void* dlh = dlopen(filename, RTLD_LAZY);\n    if( !dlh )\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", filename, dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n    dlclose(dlh);\n}\n\nint AfterAttach()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return 0;\n}\n\n/*\n    Expected argv arguments:\n    [1] first image to load\n    [2] second image to load\n    [3] pin executable\n    [4] \"-slow_asserts\"\n    [5] \"-probe\"\n    [6] tool\n    [7] \"-o\"\n    [8] tool's output file\n*/\n\nint main(int argc, char** argv)\n{\n    if(argc < 9)\n    {\n        fprintf(stderr, \"l_imageLoad_app received too few arguments. If you are running this test outside a kit test, you may need to add -slow-asserts right after the pin argument.\\n\" );\n        exit(RES_RES_INVALID_ARGS);\n    }\n    if(argc > 9)\n    {\n        fprintf(stderr, \"l_imageLoad_app received too many arguments\\n\" );\n        exit(RES_RES_INVALID_ARGS);\n    }\n\n    UnixOpen(argv[1]);\n\n    pid_t parentPid = getpid();\n    pid_t child = fork();\n    if (child < 0) {\n        perror(\"fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n    if (child)\n    {\n        // inside parent\n        while(!AfterAttach())\n        {\n            sleep(1);\n        }\n\n        UnixOpen(argv[2]);\n    }\n    if ( child == 0 )\n    {\n        // inside child\n        char attachPid[MAX_SIZE];\n        sprintf(attachPid, \"%d\", parentPid);\n        execl(argv[3], argv[3], argv[4],argv[5],\"-pid\", attachPid, \"-t\", argv[6], argv[7], argv[8],  NULL);\n        perror(\"execl failed while trying to attach Pin to the application\\n\");\n        exit(RES_EXEC_FAILED);\n    }\n    return RES_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/ImageTests/imageUnload_app.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <dlfcn.h>\n\nvoid Open(char* filename)\n{\n    void* dlh = dlopen(filename, RTLD_LAZY);\n    if( !dlh )\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\", filename, dlerror());\n        exit(2);\n    }\n    dlclose(dlh);\n}\n\nint main(int argc, char** argv)\n{\n    if(argc<1)\n    {\n        fprintf(stderr, \"No image name to load has been supplied\" );\n        fflush(stderr);\n        return 1;\n    }\n\n    Open(argv[1]);\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/ImageTests/full_path_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdio.h>\n#include <dlfcn.h>\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_LOAD_FAILED,      // 1\n    RES_RES_INVALID_ARGS  // 2\n};\n\n/*\n    Expected argv arguments:\n    [1] image to load\n*/\nint main(int argc, char** argv)\n{\n    if(argc!=2)\n    {\n        fprintf(stderr, \"No enough arguments\\n\" );\n        fflush(stderr);\n        return RES_RES_INVALID_ARGS;\n    }\n\n    void* handle;\n\n    handle = dlopen(argv[1], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        return RES_LOAD_FAILED;\n    }\n\n    return RES_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/ImageTests/launchReattachImageLoadCallbacks_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n\n#define EXPORT_SYM extern \"C\"\n\nEXPORT_SYM bool AfterAttach2();\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_LOAD_FAILED,      // 1\n};\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nint main (int argc, char *argv[])\n{\n    void *handle = dlopen(argv[1], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    while(!AfterAttach2())\n    {\n        sleep(1);\n    }\n\n    handle = dlopen(argv[2], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    while(1)\n    {\n        // expected to be stopped by tool.\n        sleep(1);\n    }\n\n    return RES_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/ImageTests/attachReattachImageLoadCallbacks_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string.h>\n\n#define EXPORT_SYM extern \"C\"\n\nEXPORT_SYM bool AfterAttach1();\n\nEXPORT_SYM bool AfterAttach2();\n\nstatic int MAX_SIZE = 128; /*maximum line size*/\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_FORK_FAILED,      // 1\n    RES_EXEC_FAILED,      // 2\n    RES_LOAD_FAILED,      // 3\n    RES_RES_INVALID_ARGS  // 4\n};\n\n\nbool AfterAttach1()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\n/*\n * block only the signals in the list: \"signalsListToBlock\"\n */\nvoid BlockSignals(int signalsListToBlock[] , int len, sigset_t * sigmask)\n{\n    sigemptyset(sigmask);\n    int i;\n    for(i=0; i< len; ++i) \n        sigaddset(sigmask, signalsListToBlock[i]);\n    pthread_sigmask(SIG_SETMASK, sigmask, NULL);\n}\n\n\n/*\n    Expected argv arguments:\n    [1] first image to load\n    [2] second image to load\n    [3] pin executable\n    [4] \"-slow_asserts\"\n    [5] \"-probe\"\n    [6] tool\n    [7] output file\n    [8] represent if SIGTRAP should be blocked by the application\n    argv[8]=0 - SIGTRAP shouldn't be blocked\n    argv[8]=1 - SIGTRAP should be blocked\n*/\n\nint main(int argc, char** argv)\n{\n    if(argc!=9)\n    {\n        fprintf(stderr, \"No enough arguments\\n\" );\n        fflush(stderr);\n        exit(RES_RES_INVALID_ARGS);\n    }\n\n    if (strcmp(argv[1], \"1\") == 0) // Need to block the SIGTRAP signal\n    {\n        int sigList[1] = {SIGTRAP};\n        sigset_t sigmask;\n        BlockSignals(sigList, 1, &sigmask);\n    }\n   \n    pid_t parentPid = getpid();\n    pid_t child = fork();\n    if (child < 0)\n    {\n        perror(\"fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    {\n        // inside parent\n        while(!AfterAttach1())\n        {\n            sleep(1);\n        }\n\n        void *handle = dlopen(argv[1], RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n\n        while(!AfterAttach2())\n        {\n            sleep(1);\n        }\n\n        handle = dlopen(argv[2], RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[2], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n\n        while(1)\n        {\n            // expected to be stopped by tool.\n            sleep(1);\n        }\n    }\n\n    if ( child == 0 )\n    {\n        // inside child\n        char attachPid[MAX_SIZE];\n        snprintf(attachPid ,MAX_SIZE , \"%d\", parentPid);\n        execl(argv[3], argv[4], argv[5],\"-pid\", attachPid, \"-t\",  argv[6], \"-o\", argv[7], NULL);\n        perror(\"execl failed while trying to attach Pin to the application\\n\");\n        exit(RES_EXEC_FAILED);\n    }\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/ImageTests/images_on_attach_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n *  This application should be used with the images_on_attach_tool tool.\n *  See documentation in the tool for the test details.\n */\n\n#include <iostream>\n#include <cstdlib>\n#include <dlfcn.h>\n#include <unistd.h>\n\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\n\nextern \"C\"\n{\nvoid DoRelease(volatile bool* doRelease)\n{\n    // Do nothing\n}\n} // extern \"C\"\n\n\nstatic void WaitForAttach()\n{\n    const unsigned int timeout = 300;\n    unsigned int releaseCounter = 0;\n    volatile bool released = false;\n    while (!released)\n    {\n        if (timeout == releaseCounter)\n        {\n            cerr << \"APP ERROR: Timeout reached and the tool did not release the application.\" << endl;\n            exit(1);\n        }\n        ++releaseCounter;\n        DoRelease(&released);\n        sleep(1);\n    }\n}\n\n\nstatic void LoadAdditionalLibraries(const char* usrlib)\n{\n    const void *libutil = dlopen(\"libutil.so.1\", RTLD_LAZY);\n    if(NULL == libutil)\n    {\n        cerr << \"APP ERROR: Failed to load libutil.so.1\" << endl;\n        exit(1);\n    }\n    const void *usrlibptr = dlopen(usrlib, RTLD_LAZY);\n    if(NULL == usrlibptr)\n    {\n        cerr << \"APP ERROR: Failed to load \" << usrlib << endl;\n        exit(1);\n    }\n}\n\n\n/*\n * Expected arguments:\n *\n * [1] - Shared object to load dynamically\n */\nint main( int argc, char *argv[] )\n{\n    // Check the number of parameters.\n    if (2 != argc)\n    {\n        cerr << \"Usage: \" << argv[0] << \" <shared object to load>\" << endl;\n        return 1;\n    }\n\n    // Wait for the tool to attach to the application.\n    WaitForAttach();\n\n    // Pin is attached, now load two more shared objects.\n    LoadAdditionalLibraries(argv[1]);\n\n    // Done.\n    cout << \"APP: Application completed successfully.\" << endl;\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/namespaceLEVEL__PINCLIENT.html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html><head><meta http-equiv=\"Content-Type\" content=\"text/html;charset=iso-8859-1\">\n<title>Pin: LEVEL_PINCLIENT Namespace Reference</title>\n<link href=\"doxygen.css\" rel=\"stylesheet\" type=\"text/css\">\n<link href=\"tabs.css\" rel=\"stylesheet\" type=\"text/css\">\n</head><body>\n<!-- Generated by Doxygen 1.4.6 -->\n<div class=\"tabs\">\n  <ul>\n    <li><a href=\"index.html\"><span>Main&nbsp;Page</span></a></li>\n    <li><a href=\"modules.html\"><span>Modules</span></a></li>\n    <li id=\"current\"><a href=\"namespaces.html\"><span>Namespaces</span></a></li>\n    <li><a href=\"classes.html\"><span>Classes</span></a></li>\n    <li>\n      <form action=\"search.php\" method=\"get\">\n        <table cellspacing=\"0\" cellpadding=\"0\" border=\"0\">\n          <tr>\n            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>\n            <td><input type=\"text\" name=\"query\" value=\"\" size=\"20\" accesskey=\"s\"/></td>\n          </tr>\n        </table>\n      </form>\n    </li>\n  </ul></div>\n<div class=\"tabs\">\n  <ul>\n    <li><a href=\"namespaces.html\"><span>Namespace List</span></a></li>\n    <li><a href=\"namespacemembers.html\"><span>Namespace&nbsp;Members</span></a></li>\n  </ul></div>\n<h1>LEVEL_PINCLIENT Namespace Reference</h1>\n<p>\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tr><td></td></tr>\n<tr><td colspan=\"2\"><br><h2>Typedefs</h2></td></tr>\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gbe792b6e32e9bbb19d51a1f352743a82\">FORK_PROBE_MODE_CALLBACK</a> )(UINT32 childPid, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef map&lt; SYM, ADDRINT &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#064f1cffbe0833f653a0220e012e31c1\">SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP</a></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g0650fbca62cb2b9cbab67e03a167476f\">CODECACHE_NOARG_CALLBACK</a> )()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g82af67ae80f0e32df5a9e3ea770cf59c\">CODECACHE_CACHEBLOCK_CALLBACK</a> )(USIZE new_block_size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#gf4feed5d90f646051a5d91b8debf4b9a\">CODECACHE_FULL_CALLBACK</a> )(USIZE trace_size, USIZE stub_size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#ge018fe6a6eb8565b1db1ab6ffa10f9f7\">CODECACHE_ENTEREXIT_CALLBACK</a> )(ADDRINT cache_pc)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#gce17d419e491ef60197773de4e1960ba\">CODECACHE_LINKED_CALLBACK</a> )(ADDRINT branch_pc, ADDRINT target_pc)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g02318d763590176a9a61b9b49f2fe93c\">CODECACHE_UNLINKED_CALLBACK</a> )(ADDRINT branch_pc, ADDRINT stub_pc)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g57a902525ea351b9a31440aea9570a13\">CODECACHE_TRACEINVALIDATED_CALLBACK</a> )(ADDRINT orig_pc, ADDRINT cache_pc, BOOL success)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef LEVEL_BASE::CHILD_PROCESS_CLASS *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CHILD__PROCESS__API.html#g104e2b5e1bfd80e62cb3cd8f50ddfdf2\">CHILD_PROCESS</a></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef BOOL(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CHILD__PROCESS__API.html#gcb01db8476fb5a6b4d86f09a336fe15f\">FOLLOW_CHILD_PROCESS_CALLBACK</a> )(<a class=\"el\" href=\"group__CHILD__PROCESS__API.html#g104e2b5e1bfd80e62cb3cd8f50ddfdf2\">CHILD_PROCESS</a> childProcess, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef BOOL(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#g6dc634ecc9b3b225a7adc1894358dfb3\">DEBUG_INTERPRETER_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, const std::string &amp;cmd, std::string *reply, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef BOOL(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#g4f422159aa53c6ac15e3c4988470ef4c\">DEBUG_BREAKPOINT_CALLBACK</a> )(ADDRINT addr, UINT size, BOOL insert, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef BOOL(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#97777ec594ce08c91a2f730a75474d0b\">INTERCEPT_DEBUGGING_EVENT_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, DEBUGGING_EVENT eventType, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, VOID *arg)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad713b5294a122b1b1a6e1ce1612af7d\">GET_EMULATED_REGISTER_CALLBACK</a> )(unsigned toolRegId, <a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, VOID *data, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#7ef92513d710ad89aa3900aa62a17b60\">SET_EMULATED_REGISTER_CALLBACK</a> )(unsigned toolRegId, <a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, const VOID *data, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef USIZE(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#54e02565dbdab62ea4dc1829c8e7bc34\">GET_TARGET_DESCRIPTION_CALLBACK</a> )(const std::string &amp;name, USIZE size, VOID *buf, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#gc79b6ff735d7c369f1954561ee8a5d15\">SIGNAL_BEFORE_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, INT32 sig, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxtFrom, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxtTo, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ge95acc4f2b08a2491822c1884428968c\">SIGNAL_AFTER_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxtFrom, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxtTo, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g3fdc760fe71cfaf87705e80ebd882e28\">THREAD_BEGIN_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, VOID *sp, int flags, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g0db566a4d0296476e0cc949894a3ad12\">THREAD_END_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, INT32 code, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef BOOL(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g5ae022cf68f790ab7df956253d3536a7\">SIGNAL_INTERCEPT_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, INT32 sig, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, BOOL hasHndlr, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g8861283eeb90cff2839c84ef8bba5802\">IMAGECALLBACK</a> )(IMG, VOID *)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef map&lt; ADDRINT, USIZE &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0eefbda43523c1adaff6dd670372cdff\">CODE_RANGES</a></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef <a class=\"el\" href=\"group__PIN__CONTROL.html#g884814f02a548395107079cf3a4ff552\">EXCEPT_HANDLING_RESULT</a>(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gb3550c0044899834614bc73245f90743\">INTERNAL_EXCEPTION_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, <a class=\"el\" href=\"group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f\">EXCEPTION_INFO</a> *pExceptInfo, <a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#g5041f3f7591f9ee249b986d2bc2f7d6e\">PHYSICAL_CONTEXT</a> *pPhysCtxt, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#fd62761063369139ae3c774377bf2c09\">TRACEGENCODE_CALLBACK</a> )(<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef TRACE_CLASS *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef COMPLEX_CALLBACKVAL_BASE *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g53cea46aaf83cb4d14f5e485eac688df\">REMOVE_INSTRUMENTATION_CALLBACK</a> )(VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gbf9966c96960a9de9bccd39a6b6d6fd7\">DETACH_CALLBACK</a> )(VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gc0db898ddefe4b25ed1737176ce7c1ef\">DETACH_PROBED_CALLBACK</a> )(VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g7d76d5f60f83d8564bb7d75198055059\">ATTACH_PROBED_CALLBACK</a> )(VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g0f271c9545b0d1b159827e718d1b7f74\">APPLICATION_START_CALLBACK</a> )(VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gcc77dcacc144b3894f5f0fc13360cdec\">FINI_CALLBACK</a> )(INT32 code, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef size_t(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gf26c93895c15754aa02c56d41f81f5f4\">FETCH_CALLBACK</a> )(void *buf, ADDRINT addr, size_t size, <a class=\"el\" href=\"group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f\">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gde47352f7f71df0632aa847aae16a274\">OUT_OF_MEMORY_CALLBACK</a> )(size_t size, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f3e4861ef8256dcc4048a1e3f9a3ab22\">PREPARE_FOR_ATEXIT_CALLBACK</a> )(VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef ADDRINT(PIN_FAST_ANALYSIS_CALL *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g0411d789e6ec1dbfa0cdf936e91544ab\">MEMORY_ADDR_TRANS_CALLBACK</a> )(PIN_MEM_TRANS_INFO *memTransInfo, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g81f4a1b953b4806f7db51c881f71e80f\">FORK_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadid, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g299a24d8e05412410b32b75b51564081\">THREAD_START_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, INT32 flags, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g73e6d9480c1690536f9a5ed8b14b426c\">THREAD_ATTACH_PROBED_CALLBACK</a> )(VOID *sigmask, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gadb876e9e1ba64a65f73bd87fc9e3c50\">THREAD_DETACH_PROBED_CALLBACK</a> )(VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gaf37c586368c5230ff7fba6c2bfebd01\">THREAD_FINI_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, INT32 code, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g78a7c9eeb76f7c94dbfc382ba6a213d1\">CONTEXT_CHANGE_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__PIN__CONTROL.html#gfa1b03e06c6ab0f86fc2abc1693ce688\">CONTEXT_CHANGE_REASON</a> reason, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *from, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *to, INT32 info, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#g15a0626027cd595bd1bd2a516118240e\">SYSCALL_ENTRY_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a> std, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#g3a481ce6651f7d491e78912bc628d5aa\">SYSCALL_EXIT_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a> std, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef BOOL(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g2f00e98cd79f80c871f8ac193f9c1ba8\">INTERCEPT_SIGNAL_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, INT32 sig, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, BOOL hasHandler, const <a class=\"el\" href=\"group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f\">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g8d5ecf0344c6faa23c1ee38437538f6c\">PROBES_INSERTED_CALLBACK</a> )(IMG img, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID *(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BUFFER__API.html#g2f6bf0657fdea122fa71bd8ff95d9e9b\">TRACE_BUFFER_CALLBACK</a> )(BUFFER_ID id, <a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, VOID *buf, UINT64 numElements, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#gd83539eedf8c29f0603bcb61e8d1df33\">INS_INSTRUMENT_CALLBACK</a> )(INS ins, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g927e6010210856a2b60b757460e53f15\">TRACE_INSTRUMENT_CALLBACK</a> )(<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">typedef VOID(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g36aaf349284bbf9d5dede36061572e1b\">RTN_INSTRUMENT_CALLBACK</a> )(RTN rtn, VOID *v)</td></tr>\n\n<tr><td colspan=\"2\"><br><h2>Enumerations</h2></td></tr>\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">enum &nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#g8aa0db3277ed9b401a204bf2d1bdc6aa\">UNDECORATION</a> { <br>\n&nbsp;&nbsp;<a class=\"el\" href=\"group__SYM__BASIC__API.html#gg8aa0db3277ed9b401a204bf2d1bdc6aad0dc787dc307af558576ba62f0e40ef3\">UNDECORATION_COMPLETE</a>, \n<br>\n&nbsp;&nbsp;<a class=\"el\" href=\"group__SYM__BASIC__API.html#gg8aa0db3277ed9b401a204bf2d1bdc6aa7ac5b7ca1c9423fbe3d44bfbda828c43\">UNDECORATION_NAME_ONLY</a>\n<br>\n }</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">enum &nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga8378cf542c080182b597101ee265983\">SYMBOL_INFO_MODE</a> { <br>\n&nbsp;&nbsp;<a class=\"el\" href=\"group__PIN__CONTROL.html#gga8378cf542c080182b597101ee265983f2d53b280bf156a6e95c5f7448f52831\">NO_SYMBOLS</a> =  0, \n<br>\n&nbsp;&nbsp;<a class=\"el\" href=\"group__PIN__CONTROL.html#gga8378cf542c080182b597101ee265983e0d6a139760597f64a0800449d5f8dbc\">EXPORT_SYMBOLS</a> =  (1&lt;&lt;0), \n<br>\n&nbsp;&nbsp;<a class=\"el\" href=\"group__PIN__CONTROL.html#gga8378cf542c080182b597101ee2659834b60203d748803ef3af28de8d2900666\">DEBUG_SYMBOLS</a> =  (1&lt;&lt;1), \n<br>\n&nbsp;&nbsp;<a class=\"el\" href=\"group__PIN__CONTROL.html#gga8378cf542c080182b597101ee265983aafa00aec7da2bcaa4bcc0c5b5a9d83d\">IFUNC_SYMBOLS</a> =  (1&lt;&lt;2), \n<br>\n&nbsp;&nbsp;<a class=\"el\" href=\"group__PIN__CONTROL.html#gga8378cf542c080182b597101ee2659835ac095606383aa2df08020d95b4f8009\">DEBUG_OR_EXPORT_SYMBOLS</a> =  (DEBUG_SYMBOLS | EXPORT_SYMBOLS)\n<br>\n }</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">enum &nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#d3a7912bbf9ba48adc6493e196774ead\">IMAGE_LOAD_FLAGS</a> { <br>\n&nbsp;&nbsp;<b>IMAGE_LOAD_NONE</b> =  0x00, \n<br>\n&nbsp;&nbsp;<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#d3a7912bbf9ba48adc6493e196774ead2cf518944068a3b505a8a3720bb44bea\">IMAGE_LOAD_MAINEXECUTABLE</a> =  0x01, \n<br>\n&nbsp;&nbsp;<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#d3a7912bbf9ba48adc6493e196774ead14f0362884823626e98f723c97050325\">IMAGE_LOAD_FOUNDINMEMORY</a> =  0x02, \n<br>\n&nbsp;&nbsp;<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#d3a7912bbf9ba48adc6493e196774eadecda4dd661a0561b92863205eff7343d\">IMAGE_LOAD_RUNTIME</a> =  0x04, \n<br>\n&nbsp;&nbsp;<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#d3a7912bbf9ba48adc6493e196774eadd4f1673728d121f373736e02c3bde78d\">IMAGE_LOAD_TEXTFROMIMAGE</a> =  0x08\n<br>\n }</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">enum &nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PROBE_TAG</b> { <br>\n&nbsp;&nbsp;<b>PROBE_TAG_OK</b>, \n<br>\n&nbsp;&nbsp;<b>PROBE_TAG_BRANCH_TARGET</b>, \n<br>\n&nbsp;&nbsp;<b>PROBE_TAG_POSSIBLE_UNIDENTIFIED_BRANCH_TARGET</b>, \n<br>\n&nbsp;&nbsp;<b>PROBE_TAG_BRANCH_PAST_END</b>, \n<br>\n&nbsp;&nbsp;<b>PROBE_TAG_TOO_SMALL</b>, \n<br>\n&nbsp;&nbsp;<b>PROBE_TAG_PREV_PROBE</b>, \n<br>\n&nbsp;&nbsp;<b>PROBE_TAG_RUNTIME_FIXUP</b>, \n<br>\n&nbsp;&nbsp;<b>PROBE_TAG_RELOCATE</b>, \n<br>\n&nbsp;&nbsp;<b>PROBE_TAG_NOT_RELOCATABLE</b>, \n<br>\n&nbsp;&nbsp;<b>PROBE_TAG_UNKNOWN</b>\n<br>\n }</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">enum &nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f171c445e32ac6109fe8b63ef99fef45\">REPLAY_MODE</a> { <br>\n&nbsp;&nbsp;<b>REPLAY_MODE_NONE</b> =  0x00, \n<br>\n&nbsp;&nbsp;<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f171c445e32ac6109fe8b63ef99fef455a7da031e019cd68d30f0a968d818412\">REPLAY_MODE_IMAGEOPS</a> =  0x01, \n<br>\n&nbsp;&nbsp;<b>REPLAY_MODE_ALL</b> =  REPLAY_MODE_IMAGEOPS\n<br>\n }</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">enum &nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gf191d518e93cfce6bf6e43d0b2bf3d81\">PROBE_MODE</a> { <br>\n&nbsp;&nbsp;<b>PROBE_MODE_DEFAULT</b> =  0, \n<br>\n&nbsp;&nbsp;<b>PROBE_MODE_ALLOW_RELOCATION</b> =  (1&lt;&lt;0)\n<br>\n }</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">enum &nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gb6974c15e664605870435c05a1bf33bd\">FPOINT</a> { <br>\n&nbsp;&nbsp;<a class=\"el\" href=\"group__PIN__CONTROL.html#ggb6974c15e664605870435c05a1bf33bd1bf77c6f3a5ac150cf7fb1c10f0429cf\">FPOINT_BEFORE</a>, \n<br>\n&nbsp;&nbsp;<a class=\"el\" href=\"group__PIN__CONTROL.html#ggb6974c15e664605870435c05a1bf33bdcba5c8d0ce036ae68ab51e180e5f7d35\">FPOINT_AFTER_IN_PARENT</a>, \n<br>\n&nbsp;&nbsp;<a class=\"el\" href=\"group__PIN__CONTROL.html#ggb6974c15e664605870435c05a1bf33bd35c7c8f0fae3a1a1cbe29d6d79045c88\">FPOINT_AFTER_IN_CHILD</a>\n<br>\n }</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">enum &nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CONDINSTSTATE</b> { <br>\n&nbsp;&nbsp;<b>CONDINST_NORMAL</b>, \n<br>\n&nbsp;&nbsp;<b>CONDINST_IF</b>, \n<br>\n&nbsp;&nbsp;<b>CONDINST_THEN</b>\n<br>\n }</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">enum &nbsp;</td><td class=\"memItemRight\" valign=\"bottom\">{ <br>\n&nbsp;&nbsp;<b>TLS_KEY_RESERVED_LAST</b> =  140, \n<br>\n&nbsp;&nbsp;<b>TLS_KEY_INTERNAL_EXCEPTION</b>, \n<br>\n&nbsp;&nbsp;<b>TLS_KEY_CLIENT_FIRST</b>, \n<br>\n&nbsp;&nbsp;<b>TLS_KEY_CLIENT_LAST</b> =  TLS_KEY_CLIENT_FIRST + 63\n<br>\n }</td></tr>\n\n<tr><td colspan=\"2\"><br><h2>Functions</h2></td></tr>\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"d85b95f029976c12def88afd62d19d2f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::calc32CRC\" ref=\"d85b95f029976c12def88afd62d19d2f\" args=\"(const CHAR *start, UINT32 size)\" -->\nLOCALFUN UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>calc32CRC</b> (const CHAR *start, UINT32 size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">string&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#20cd15d62787677dcb26da903ce17dfd\">FindGnuDebugLinkFile</a> (IMG img, CHAR **imageStart, size_t *imageSize)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"0dbe83f2b5cc10f68123f986e4ec6304\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImageInitSession\" ref=\"0dbe83f2b5cc10f68123f986e4ec6304\" args=\"()\" -->\nLOCALINLINE IMAGE_INIT_SESSION *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ImageInitSession</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#9d8bb4715f6a6124c599657695f384ba\">IMG_IsStandardLoaderLibrary</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#61e605e545c9bfa6576f4140f8eff378\">IMG_IsStandardSystemLibrary</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#c0a38d6752148494df0b1f0fa9e369bb\">IMG_IsStandardThreadLibrary</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#d39750018c98a35ca1fd1b3ec5823bb6\">IMG_IsStandardGccLibrary</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f37649faa2f58621a6ad13fa4b7ef797\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FindAuxBase\" ref=\"f37649faa2f58621a6ad13fa4b7ef797\" args=\"(CHAR **argv)\" -->\nLOCALFUN AUXTYPE *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FindAuxBase</b> (CHAR **argv)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"67973408d26c10cb014a9f38ff14dfa8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AppAuxValue\" ref=\"67973408d26c10cb014a9f38ff14dfa8\" args=\"(INT64 type)\" -->\nLOCALFUN ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>AppAuxValue</b> (INT64 type)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"2e302e090c6ed65bfb7271cac706554d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::LoaderAddress\" ref=\"2e302e090c6ed65bfb7271cac706554d\" args=\"()\" -->\nLOCALFUN ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>LoaderAddress</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"c2cb62cc67bd1cce6a8bd5f93539aa11\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetImageOffset\" ref=\"c2cb62cc67bd1cce6a8bd5f93539aa11\" args=\"(const CHAR *filename, ADDRINT loadAddr, void *arg)\" -->\nLOCALFUN ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>GetImageOffset</b> (const CHAR *filename, ADDRINT loadAddr, void *arg)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#17237d9e31f04fa0a4fe4754d4861326\">NotifyDebuggerOnImageLoad</a> (BOOL isMain, VOID *loaderInfo)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0ee03bf03511053a995f8173b90d1bfc\">NotifyDebuggerOnImageUnload</a> (VOID *loaderInfo)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"770b3cdc1fcdf95957aa1e05d4fe299b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MakeLoaderInfoFromLinkMap\" ref=\"770b3cdc1fcdf95957aa1e05d4fe299b\" args=\"(const string &amp;name, struct link_map *lm)\" -->\nLOCALFUN LINUX_LOADER_IMAGE_INFO *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>MakeLoaderInfoFromLinkMap</b> (const string &amp;name, struct link_map *lm)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"01d57355b22be3c4b6d80495ff384e32\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImageByName\" ref=\"01d57355b22be3c4b6d80495ff384e32\" args=\"(const string &amp;name)\" -->\nLOCALFUN IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ImageByName</b> (const string &amp;name)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"48fc31483fdc77a780c8bc0b972aa1a9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyDebuggerOnElfImageLoad\" ref=\"48fc31483fdc77a780c8bc0b972aa1a9\" args=\"(BOOL isMain, BOOL isInterp, const string &amp;name, struct link_map *lm)\" -->\nLOCALFUN LINUX_LOADER_IMAGE_INFO *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>NotifyDebuggerOnElfImageLoad</b> (BOOL isMain, BOOL isInterp, const string &amp;name, struct link_map *lm)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"32965f21eb4e97509c7a2f1ccefbb6ab\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ProcessLoadedImage\" ref=\"32965f21eb4e97509c7a2f1ccefbb6ab\" args=\"(IMG img, LINUX_LOADER_IMAGE_INFO *li)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ProcessLoadedImage</b> (IMG img, LINUX_LOADER_IMAGE_INFO *li)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#4c038211455f2a905645c8488eae4063\">ScanLibrariesUnlocked</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#2d2b2a981a9427e437e4bacdb257cc50\">ScanLibrariesLocked</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"0e5680669832343e6e6c49672f006cef\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::OnLoaderBreak\" ref=\"0e5680669832343e6e6c49672f006cef\" args=\"()\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>OnLoaderBreak</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"028605ca7761d70ac2bc207afdbe5990\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::OnLoaderBreakProbe\" ref=\"028605ca7761d70ac2bc207afdbe5990\" args=\"()\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>OnLoaderBreakProbe</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ccf08634d9f9eed0859a6bc40821a8c8\">ReadElfHeader</a> (CHAR const *file, EHDR *ehdr)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"860adfafff691548ba02cb126ddc5340\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MainImageLoadOffset\" ref=\"860adfafff691548ba02cb126ddc5340\" args=\"(CHAR const *file)\" -->\nLOCALFUN ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>MainImageLoadOffset</b> (CHAR const *file)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#162c02d22e09d1f32a5e7b71aac44b0f\">ImageInitialize</a> (BOOL forReplay)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#9e943322cba0d0ff2967eabbff059594\">ImageUnInitialize</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#2e0ad7b8e1be9c2b7857827ae2b40c18\">RTN_CheckFixups</a> (RTN rtn, UINT32 probe_size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a8ba7316f32f79cc20e0248ca006001a\">ImageInstrument</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a07b9dfb5804cebe66994e1ff51dfddb\">IMG_UnmapImage</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#8aa50f020f753dfc777e849da3b397a2\">IMG_FreeDebugInfo</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#5eb472b944d448e714e3d09fd4a38c3b\">NotifyDataRanges</a> (IMG img, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0eefbda43523c1adaff6dd670372cdff\">CODE_RANGES</a> *rangeMap)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#8db2b14300e5795dc6a946c945955302\">PIN_RemoveForkProbedCallbacks</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g1e0ca5fc45108b0610ad773bc56117f5\">PIN_AddForkFunctionProbed</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gb6974c15e664605870435c05a1bf33bd\">FPOINT</a> point, <a class=\"el\" href=\"group__PIN__CONTROL.html#gbe792b6e32e9bbb19d51a1f352743a82\">FORK_PROBE_MODE_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f2284c0855542b30f70fbe34adb6fd1e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ForkInProbeMode\" ref=\"f2284c0855542b30f70fbe34adb6fd1e\" args=\"()\" -->\nLOCALFUN pid_t&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ForkInProbeMode</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#bc4673eeff9e97dc24b7136693274b84\">RTN_ReplaceSyscallProbed</a> (RTN rtn, INT32 syscallNum, RTN errnoLocationRtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"6ce34e304771ca5cb158e7c922978c41\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ProbeMunmap\" ref=\"6ce34e304771ca5cb158e7c922978c41\" args=\"(void *start)\" -->\nLOCALFUN void&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ProbeMunmap</b> (void *start)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0ffa8a7cf24cb2d8fa0a15f084f796fb\">RecordFptrAppGetppid</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN FORKFUNCPTR&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#58178a737e6c77940df6420698b51da5\">InstrumentSystemLibraryForkFunction</a> (IMG img, const char *fname)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"0e02474be0a5567c68fa865181ea622f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InstrumentSystemLibraries\" ref=\"0e02474be0a5567c68fa865181ea622f\" args=\"(IMG img)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>InstrumentSystemLibraries</b> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#60292471a0c8012931cf81f21ad5eac6\">ImageLoadProbesOsSpecific</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"83d689c9bed925ee9480aa6f2e2edd6d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ReplaceOneInstruction\" ref=\"83d689c9bed925ee9480aa6f2e2edd6d\" args=\"(INS ins, INT32 syscallNo, RTN errnoLocationRtn)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ReplaceOneInstruction</b> (INS ins, INT32 syscallNo, RTN errnoLocationRtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">INT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f1296a8c20facdb8e54640748fedc0ed\">EmulateExecvProbed</a> (ADDRINT arg0, ADDRINT arg1, ADDRINT arg2, ADDRINT errnoLocationFptr)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"67b5a1dd532a80696c28ae6aba99e28e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::operator&lt;\" ref=\"67b5a1dd532a80696c28ae6aba99e28e\" args=\"(const SYM_BASIC_INFO &amp;lhs, const SYM_BASIC_INFO &amp;rhs)\" -->\nLOCALNSFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>operator&lt;</b> (const SYM_BASIC_INFO &amp;lhs, const SYM_BASIC_INFO &amp;rhs)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9\">PIN_InitSymbols</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"0f390426152c6b03a565d8d45e5a8d8e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_SymbolsInit\" ref=\"0f390426152c6b03a565d8d45e5a8d8e\" args=\"()\" -->\nBOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PIN_SymbolsInit</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g6a86d823a691298dbe8b9ca73f328761\">PIN_InitSymbolsAlt</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#ga8378cf542c080182b597101ee265983\">SYMBOL_INFO_MODE</a> mode)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"dbc73ad47fdca05b64c719af1cde36a0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AddSym\" ref=\"dbc73ad47fdca05b64c719af1cde36a0\" args=\"(SYM sym, IMG img, BOOL dynamic, const CHAR *sym_name, const SYMREC *rawsym, UINT32 imgsize, IADDR iaddr, SYM_IFUNC_TYPE Ifunc_type)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>AddSym</b> (SYM sym, IMG img, BOOL dynamic, const CHAR *sym_name, const SYMREC *rawsym, UINT32 imgsize, IADDR iaddr, SYM_IFUNC_TYPE Ifunc_type)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"ccec3311197661f75be0e936f78d5b9f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CookSymIfuncSec\" ref=\"ccec3311197661f75be0e936f78d5b9f\" args=\"(IMG img, SYM ifunc_resolver, const SYMREC *array_dynamic_symbol_table, int i, SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP *sym_resolver_vs_actual_address_ifunc_map)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CookSymIfuncSec</b> (IMG img, SYM ifunc_resolver, const SYMREC *array_dynamic_symbol_table, int i, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#064f1cffbe0833f653a0220e012e31c1\">SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP</a> *sym_resolver_vs_actual_address_ifunc_map)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"941b79deecf1007b32cd47796cdf5460\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CookSymSec\" ref=\"941b79deecf1007b32cd47796cdf5460\" args=\"(set&lt; SYM_BASIC_INFO &gt; &amp;symbolSet, SEC sec_symtab, SEC sec_strtab, BOOL dynamic, SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP *sym_resolver_vs_actual_address_ifunc_map)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CookSymSec</b> (set&lt; SYM_BASIC_INFO &gt; &amp;symbolSet, SEC sec_symtab, SEC sec_strtab, BOOL dynamic, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#064f1cffbe0833f653a0220e012e31c1\">SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP</a> *sym_resolver_vs_actual_address_ifunc_map)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"0416fde992ba8ee65f83a0caf08fa86e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CompareSyms\" ref=\"0416fde992ba8ee65f83a0caf08fa86e\" args=\"(const SYM &amp;s1, const SYM &amp;s2)\" -->\nLOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CompareSyms</b> (const SYM &amp;s1, const SYM &amp;s2)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"4a145287789f1e7ed109b0838c17932b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_SortRegsymsByIaddr\" ref=\"4a145287789f1e7ed109b0838c17932b\" args=\"(IMG img)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>IMG_SortRegsymsByIaddr</b> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#9e7ad6d2c910db2984d9784843991425\">CookRegsym</a> (IMG img, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#064f1cffbe0833f653a0220e012e31c1\">SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP</a> *sym_resolver_vs_actual_address_ifunc_map)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#617ef8b03bd319a2c4b53c776d2d0dff\">IMG_FindDataSymbolAddress</a> (IMG origImg, const CHAR *symname)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#7c50ee332ef31bb550510378c1f94c31\">SYM_IsDataMarker</a> (SYM sym)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"240fc2bf39c2023f18fa172f24aca0cf\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYM_NameNoVersion\" ref=\"240fc2bf39c2023f18fa172f24aca0cf\" args=\"(const string &amp;symbolName)\" -->\nLOCALFUN string&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SYM_NameNoVersion</b> (const string &amp;symbolName)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"704c48f26acb1c61c8f34d9e5a723db9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::skipBackwardsMatchedPair\" ref=\"704c48f26acb1c61c8f34d9e5a723db9\" args=\"(const string &amp;undecoratedName, size_t pos, char openBra, char closeBra)\" -->\nLOCALFUN size_t&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>skipBackwardsMatchedPair</b> (const string &amp;undecoratedName, size_t pos, char openBra, char closeBra)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"dd0ea7c645974694567522ebb66a7fdb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::skipBackwardsTemplatedName\" ref=\"dd0ea7c645974694567522ebb66a7fdb\" args=\"(const string &amp;undecoratedName, size_t pos)\" -->\nLOCALFUN size_t&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>skipBackwardsTemplatedName</b> (const string &amp;undecoratedName, size_t pos)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"87f54c0a646dcdb14e881db4c338bcad\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::sanitize\" ref=\"87f54c0a646dcdb14e881db4c338bcad\" args=\"(const string &amp;original)\" -->\nLOCALFUN string&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>sanitize</b> (const string &amp;original)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"21420c3568828a456c9723532e58bf5b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::cplus_demangle\" ref=\"21420c3568828a456c9723532e58bf5b\" args=\"(const string &amp;name, UNDECORATION style)\" -->\nLOCALFUN string&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>cplus_demangle</b> (const string &amp;name, <a class=\"el\" href=\"group__SYM__BASIC__API.html#g8aa0db3277ed9b401a204bf2d1bdc6aa\">UNDECORATION</a> style)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">string&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#38ef4d708109f017f7474e6d8d0785fe\">SYM_UndecorateName</a> (const string &amp;symbolName, <a class=\"el\" href=\"group__SYM__BASIC__API.html#g8aa0db3277ed9b401a204bf2d1bdc6aa\">UNDECORATION</a> style)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0dbf3e856092db68f58e8b5dca1727fa\">AotiRecordCall</a> (<a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, INS ins, ACALL const *acall)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#fcdfcaf9b73d23639eb2831182b70919\">AotiRecordMutation</a> (INS ins, EXT ext)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#87a72d53166313658044d1966b7eca76\">AotiPlaybackCall</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#783309f729f772c5b75875881515fc68\">AotiInstrumentationExists</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#e364d214bd4f5d2698f6608fa5f19568\">AotiRemoveImageInstrumentation</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g928ea574ccdb4938e194e3e59e5e4e18\">CODECACHE_AddCacheInitFunction</a> (<a class=\"el\" href=\"group__CODECACHE__API.html#g0650fbca62cb2b9cbab67e03a167476f\">CODECACHE_NOARG_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g7dc0a6914461a25a859e17b6091a78ff\">CODECACHE_AddCacheBlockFunction</a> (<a class=\"el\" href=\"group__CODECACHE__API.html#g82af67ae80f0e32df5a9e3ea770cf59c\">CODECACHE_CACHEBLOCK_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g0de20d84496651fec529ceea45308b36\">CODECACHE_AddFullCacheFunction</a> (<a class=\"el\" href=\"group__CODECACHE__API.html#gf4feed5d90f646051a5d91b8debf4b9a\">CODECACHE_FULL_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#b115c9a18cef7092f2d83c80e6ca1a5f\">CODECACHE_AddFullBlockFunction</a> (<a class=\"el\" href=\"group__CODECACHE__API.html#gf4feed5d90f646051a5d91b8debf4b9a\">CODECACHE_FULL_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g4ddcb3104eacce51d0224acf7eaf4d82\">CODECACHE_AddCacheFlushedFunction</a> (<a class=\"el\" href=\"group__CODECACHE__API.html#g0650fbca62cb2b9cbab67e03a167476f\">CODECACHE_NOARG_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g60ebb929e128ab5cda520f9ce9ac8177\">CODECACHE_AddCodeCacheEnteredFunction</a> (<a class=\"el\" href=\"group__CODECACHE__API.html#ge018fe6a6eb8565b1db1ab6ffa10f9f7\">CODECACHE_ENTEREXIT_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g4e9b85fef7632417b9520eb8ee3e747c\">CODECACHE_AddCodeCacheExitedFunction</a> (<a class=\"el\" href=\"group__CODECACHE__API.html#ge018fe6a6eb8565b1db1ab6ffa10f9f7\">CODECACHE_ENTEREXIT_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#gdbbd691bc637e089f43606047663fe32\">CODECACHE_AddTraceLinkedFunction</a> (<a class=\"el\" href=\"group__CODECACHE__API.html#gce17d419e491ef60197773de4e1960ba\">CODECACHE_LINKED_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g5a5767e61862d57e76711b3848b442d1\">CODECACHE_AddTraceUnlinkedFunction</a> (<a class=\"el\" href=\"group__CODECACHE__API.html#g02318d763590176a9a61b9b49f2fe93c\">CODECACHE_UNLINKED_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g0f492ca9ac4bee7d6b455203ac5162ec\">CODECACHE_AddTraceInvalidatedFunction</a> (<a class=\"el\" href=\"group__CODECACHE__API.html#g57a902525ea351b9a31440aea9570a13\">CODECACHE_TRACEINVALIDATED_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g5560890aca1e8607ddad1707026bc527\">CODECACHE_InvalidateTraceAtProgramAddress</a> (ADDRINT app_pc)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#4e15e2ab7462fc49c315279f7a04ced3\">CODECACHE_InvalidateTraceAtCacheAddress</a> (ADDRINT cache_pc)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#gefd9d0fe567d1d9f79c74d71552d310f\">CODECACHE_CodeMemReserved</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g2449877197423a8f000f5c8d91d32910\">CODECACHE_DirectoryMemUsed</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g1925463f6422bc560463400ac23c3bdc\">CODECACHE_CodeMemUsed</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g1ce5ce32ae7aaef91aa5f9ab893e0298\">CODECACHE_ExitStubBytes</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g980754d2a9e859467f839d77b95b5510\">CODECACHE_LinkBytes</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g6d78b2244b1972ae1cf4fad8c3a7fa66\">CODECACHE_CacheSizeLimit</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g9cbf214155f1a42c704ac0909a6d7989\">CODECACHE_BlockSize</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g8168c74ab03baf600588869bab38d12e\">CODECACHE_NumTracesInCache</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g5299e58b3b7737bc4ec34a0871d7c5d1\">CODECACHE_NumExitStubsInCache</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#gc13290c14cd71b4add6d8b1e175f75fa\">CODECACHE_CreateNewCacheBlock</a> (USIZE block_size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#gfd9f8d21e8d9ca4ba748e40204e21083\">CODECACHE_ChangeCacheLimit</a> (USIZE cache_size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g483f87cde62ba854c125e90389f930b5\">CODECACHE_ChangeBlockSize</a> (USIZE block_size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g68943e1ad4c5938e02fd926f6e042b7b\">CODECACHE_ChangeMaxInsPerTrace</a> (UINT32 max_ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#gd1ec79d8de4aa25dca2abb885407a558\">CODECACHE_ChangeMaxBblsPerTrace</a> (UINT32 max_basic_blocks)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#e25f772eb23640ed41aa6d8032ccf7c0\">CODECACHE_NumTracesInBlock</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f5a8107215aae47136ebb16b74441ca8\">CODECACHE_NumHits</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#7f2c708ab4eece407bf8049ff64f9382\">CODECACHE_NumMisses</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#gafb0363b47365792d19edeaf0479eb5f\">CODECACHE_FlushCache</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#gef086e43aaa039bd0c0e936b32e19869\">CODECACHE_InvalidateRange</a> (ADDRINT start, ADDRINT end)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g0bc79e1b84af23dcaee4709502944822\">INS_CodeCacheAddress</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g3cf669dcabe251ebc5071b7c4ef67c4c\">BBL_CodeCacheAddress</a> (BBL bbl)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#gc1fb515ac93650e6ae50ed366dd8fcb7\">TRACE_CodeCacheAddress</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">USIZE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#gf2b7f0e90b276d177695f844b2e4943f\">INS_CodeCacheSize</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">USIZE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g749be87c563fdd21f2a6e75b5e5b64e0\">BBL_CodeCacheSize</a> (BBL bbl)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">USIZE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g453920c22d5c1b4f87b03bc8df75b6c3\">TRACE_CodeCacheSize</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#g83946eff31ccb3275439be0975382a22\">CODECACHE_OriginalAddress</a> (ADDRINT cache_pc)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#e561a040d0010efa4dbf5c4076e9f95b\">CODECACHE_FlushBlock</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">USIZE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#ga36853e09296bf40b9056c8bd8168438\">PIN_MemoryAllocatedForPin</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"099ece3f9c83d716427c2ce8e6ad02b0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoPostCacheInit\" ref=\"099ece3f9c83d716427c2ce8e6ad02b0\" args=\"()\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoPostCacheInit</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f5f1d829728676421ca574cf4178ab48\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoCacheBlockCreated\" ref=\"f5f1d829728676421ca574cf4178ab48\" args=\"(USIZE block_size)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoCacheBlockCreated</b> (USIZE block_size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"1d649cec5ecc0b4ea80d6905f3a128b0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoCacheBlockIsFull\" ref=\"1d649cec5ecc0b4ea80d6905f3a128b0\" args=\"(USIZE trace_size, USIZE stub_size)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoCacheBlockIsFull</b> (USIZE trace_size, USIZE stub_size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"23ca4cabc89b3b4d27f62939c72d030d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoCacheIsFull\" ref=\"23ca4cabc89b3b4d27f62939c72d030d\" args=\"(USIZE trace_size, USIZE stub_size)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoCacheIsFull</b> (USIZE trace_size, USIZE stub_size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"abfa17d85beec229fcef216128ff2bee\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoPostCacheFlush\" ref=\"abfa17d85beec229fcef216128ff2bee\" args=\"()\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoPostCacheFlush</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"faaf63fd747c6317d36df8e29110475c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoCodeCacheEntered\" ref=\"faaf63fd747c6317d36df8e29110475c\" args=\"(ADDRINT cache_pc)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoCodeCacheEntered</b> (ADDRINT cache_pc)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"d0f59783c1cc61539b54ef6f5b10809c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoCodeCacheExited\" ref=\"d0f59783c1cc61539b54ef6f5b10809c\" args=\"(ADDRINT cache_pc)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoCodeCacheExited</b> (ADDRINT cache_pc)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"690e8b98285c899783218e4d7a196c2b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoTraceLinked\" ref=\"690e8b98285c899783218e4d7a196c2b\" args=\"(ADDRINT branch_pc, ADDRINT target_pc)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoTraceLinked</b> (ADDRINT branch_pc, ADDRINT target_pc)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"45d11533ce0655bd6c61f231eb2a7d51\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoTraceUnlinked\" ref=\"45d11533ce0655bd6c61f231eb2a7d51\" args=\"(ADDRINT branch_pc, ADDRINT stub_pc)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoTraceUnlinked</b> (ADDRINT branch_pc, ADDRINT stub_pc)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"0f46a89a541f4f216b5867674ac8701f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoTraceInvalidated\" ref=\"0f46a89a541f4f216b5867674ac8701f\" args=\"(ADDRINT orig_pc, ADDRINT cache_pc, BOOL success)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoTraceInvalidated</b> (ADDRINT orig_pc, ADDRINT cache_pc, BOOL success)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#9980c5b2f7fbb3200b0e1c01897786d7\">InitializeCacheClient</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#bfd6c9c3b418cd0af8daacece35396a3\">CheckNoCodeCacheCallbacks</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g4f667d78b5533ec07b15ef4df0d7a78e\">PIN_AddFollowChildProcessFunction</a> (<a class=\"el\" href=\"group__CHILD__PROCESS__API.html#gcb01db8476fb5a6b4d86f09a336fe15f\">FOLLOW_CHILD_PROCESS_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#923f50d40c1060c7f9edf139a7582832\">PIN_RemoveFollowChildProcessFunctions</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#9ced1d383167e4d5e2f6123254766a99\">CallFollowChildProcess</a> (<a class=\"el\" href=\"group__CHILD__PROCESS__API.html#g104e2b5e1bfd80e62cb3cd8f50ddfdf2\">CHILD_PROCESS</a> childProcess, const char **toolAppend)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f1edcf9d406767a2b633e694791b3a2c\">InitializeFollowChildClient</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g92a87e8230190529b537433214d14beb\">OS_PROCESS_ID</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CHILD__PROCESS__API.html#g053fe4f7163288c31b3d96dc3efa16e5\">CHILD_PROCESS_GetId</a> (<a class=\"el\" href=\"group__CHILD__PROCESS__API.html#g104e2b5e1bfd80e62cb3cd8f50ddfdf2\">CHILD_PROCESS</a> childProcess)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CHILD__PROCESS__API.html#gdf9d4adb14fedc8df2e59a788467fd26\">CHILD_PROCESS_GetCommandLine</a> (<a class=\"el\" href=\"group__CHILD__PROCESS__API.html#g104e2b5e1bfd80e62cb3cd8f50ddfdf2\">CHILD_PROCESS</a> childProcess, INT *pArgc, const CHAR *const **pArgv)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CHILD__PROCESS__API.html#g66756fe9d243612d1752464dd6b24efe\">CHILD_PROCESS_SetPinCommandLine</a> (<a class=\"el\" href=\"group__CHILD__PROCESS__API.html#g104e2b5e1bfd80e62cb3cd8f50ddfdf2\">CHILD_PROCESS</a> childProcess, INT argc, const CHAR *const *argv)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">void&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEBUG__API.html#gcdb6e153e9699ed9011aba7ac629c5d8\">PIN_GetSourceLocation</a> (ADDRINT address, INT32 *column, INT32 *line, string *fileName)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#5a46741b62b9f4c816db8e18a8a0d150\">CallDebugInterpreters</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *, const char *, const char **)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#22048f762db39a31919bd90986959395\">CallBreakpointHandlers</a> (ADDRINT, UINT, BOOL)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#08a9eabff055b1d30459070adb2e4b9a\">CallInterceptedDebuggingEvent</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>, DEBUGGING_EVENT, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#e3bd73e60d122d915bf5850aec4d9082\">GetEmulatedRegister</a> (unsigned, <a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *, VOID *)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#6802c61d2660ada4b5fbad73bf109a0c\">SetEmulatedRegister</a> (unsigned, <a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *, const VOID *)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN USIZE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#2334c57be6663b3484124d78b22c9712\">GetTargetDescription</a> (const std::string &amp;, USIZE, VOID *)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#87a1d90748ddeabcb8be3ead165f8c07\">DebuggerClientInitialize</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#g5c3c5c6220acfad8860218b41410b07a\">PIN_AddDebugInterpreter</a> (<a class=\"el\" href=\"group__APPDEBUG__API.html#g6dc634ecc9b3b225a7adc1894358dfb3\">DEBUG_INTERPRETER_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#g1798c34b9a1384ba4b55fb8af0042512\">PIN_RemoveDebugInterpreter</a> (<a class=\"el\" href=\"group__APPDEBUG__API.html#g6dc634ecc9b3b225a7adc1894358dfb3\">DEBUG_INTERPRETER_CALLBACK</a> fun)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#g3f3296542ad9dbd72967e36de005fd5a\">PIN_AddBreakpointHandler</a> (<a class=\"el\" href=\"group__APPDEBUG__API.html#g4f422159aa53c6ac15e3c4988470ef4c\">DEBUG_BREAKPOINT_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#gd7f2971e58ab2cc4f232bed0e1b0a37d\">PIN_RemoveBreakpointHandler</a> (<a class=\"el\" href=\"group__APPDEBUG__API.html#g4f422159aa53c6ac15e3c4988470ef4c\">DEBUG_BREAKPOINT_CALLBACK</a> fun)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#g776b0533f78b5abeabf6463183ba6027\">PIN_ResetBreakpointAt</a> (ADDRINT addr)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#g0cc79428309a39c0cbae4e6131b51f3a\">PIN_ApplicationBreakpoint</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, BOOL waitIfNoDebugger, const std::string &amp;msg)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#g918080ac9119c54376a30b41bc1c1352\">PIN_SetDebugMode</a> (const <a class=\"el\" href=\"structDEBUG__MODE.html\">DEBUG_MODE</a> *mode)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__APPDEBUG__API.html#g2873b12faab265843028e2f388009e98\">DEBUG_STATUS</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#gf5d23fef76d1846b74cc1c4b61813e93\">PIN_GetDebugStatus</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#g88a899a52d6a26fb8d43f239fe0b7518\">PIN_GetDebugConnectionInfo</a> (<a class=\"el\" href=\"structDEBUG__CONNECTION__INFO.html\">DEBUG_CONNECTION_INFO</a> *info)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__APPDEBUG__API.html#g8cee9ac7175a55371abac6e09f5f8768\">DEBUGGER_TYPE</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#gde1f6df906e38d64c1e19a1a4eb76c7c\">PIN_GetDebuggerType</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#g10470a2efb23fe149125a72fcf6ac337\">PIN_WaitForDebuggerToConnect</a> (unsigned timeout)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#g2cbad4bee57ff3ae86f8f6eb1c9ec094\">PIN_GetStoppedThreadPendingToolBreakpoint</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, std::string *msg)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#g8cae74fa93b294c52079efb6f8195b1e\">PIN_ChangePendingToolBreakpointOnStoppedThread</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, BOOL squash, const std::string &amp;msg)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#afb41af0a98f375df6bc3aa244f03f45\">PIN_InterceptDebuggingEvent</a> (DEBUGGING_EVENT eventType, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#97777ec594ce08c91a2f730a75474d0b\">INTERCEPT_DEBUGGING_EVENT_CALLBACK</a> fun, VOID *arg)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#68a4173dc9649381353502748f429c9d\">PIN_AddDebuggerRegisterEmulator</a> (unsigned numRegisters, const <a class=\"el\" href=\"structDEBUGGER__REG__DESCRIPTION.html\">DEBUGGER_REG_DESCRIPTION</a> *registerDescriptions, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad713b5294a122b1b1a6e1ce1612af7d\">GET_EMULATED_REGISTER_CALLBACK</a> getFun, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#7ef92513d710ad89aa3900aa62a17b60\">SET_EMULATED_REGISTER_CALLBACK</a> setFun, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#54e02565dbdab62ea4dc1829c8e7bc34\">GET_TARGET_DESCRIPTION_CALLBACK</a> getDescriptionFun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#2058c68dbd07ef6f628abd0c313ea269\">DeprecatedCallSignalBefores</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, INT32 sig, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *from, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *to)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#420b29c16e7549c18b9ed34dec3ce1df\">DeprecatedCallSignalAfters</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *from, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *to)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#9271d8c3ee45a76adfdcf97856ebac63\">DeprecatedCallThreadBegins</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, VOID *sp, int flags)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0f54f522b4e20fbaea714ca2d4726a4b\">DeprecatedCallThreadEnds</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, INT32 code)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"98df1145c2b749aa4c0235c6af9f1d23\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallSignalIntercept\" ref=\"98df1145c2b749aa4c0235c6af9f1d23\" args=\"(THREADID tid, INT32 sig, CONTEXT *ctxt, BOOL hasHandler, const EXCEPTION_INFO *pExceptInfo, VOID *v)\" -->\nLOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CallSignalIntercept</b> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, INT32 sig, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, BOOL hasHandler, const <a class=\"el\" href=\"group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f\">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#gb731fcb56a2b7cd1f29c90810234db5c\">PIN_AddSignalBeforeFunction</a> (<a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#gc79b6ff735d7c369f1954561ee8a5d15\">SIGNAL_BEFORE_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#gfad3e0d26e3dc68ac8be59250a25fd3f\">PIN_AddSignalAfterFunction</a> (<a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ge95acc4f2b08a2491822c1884428968c\">SIGNAL_AFTER_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g25746713a7e0267a9c55bd78d95ade81\">PIN_AddSignalInterceptFunction</a> (INT32 sig, <a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g5ae022cf68f790ab7df956253d3536a7\">SIGNAL_INTERCEPT_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g670373654bdf570fe250aeb5c6bdafc9\">PIN_AddThreadBeginFunction</a> (<a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g3fdc760fe71cfaf87705e80ebd882e28\">THREAD_BEGIN_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g618ab3ddc99206fd78abcb829baf8ccd\">PIN_AddThreadEndFunction</a> (<a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g0db566a4d0296476e0cc949894a3ad12\">THREAD_END_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g52f3a67636a87f80580bd9ae37ab01c7\">PIN_StartProbedProgram</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g53520920dce2c0b519bc10f7bbec9886\">RTN_IsSafeForProbe</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g7a996be7fec85f2a67e171ef767172c7\">RTN_ReplaceWithUninstrumentedRoutine</a> (RTN replacedRtn, AFUNPTR replacementFun)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"2b138d5d15ed3fbc38f3e24a8d8765f6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobSymFamily\" ref=\"2b138d5d15ed3fbc38f3e24a8d8765f6\" args=\"(&quot;pintool:sym&quot;,&quot;Symbols controls&quot;)\" -->\nLOCALVAR KNOB_COMMENT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobSymFamily</b> (&quot;pintool:sym&quot;,&quot;Symbols controls&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"cff6fc34134c5638290b8d96ee0eb66e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobUnrestrictedRtnSize\" ref=\"cff6fc34134c5638290b8d96ee0eb66e\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;unrestricted_rtn_size&quot;,&quot;0&quot;,&quot;Use the unrestricted RTN size. &quot;&quot;When set the RTN size defined by the distance between RTN start to the beginning of next RTN.&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobUnrestrictedRtnSize</b> (KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;unrestricted_rtn_size&quot;,&quot;0&quot;,&quot;Use the unrestricted RTN size. &quot;&quot;When set the RTN size defined by the distance between RTN start to the beginning of next RTN.&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"5c3d49682faee9cd7b7b99cc84a15d1d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobShortName\" ref=\"5c3d49682faee9cd7b7b99cc84a15d1d\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;short_name&quot;,&quot;0&quot;,&quot;Use the shortest name for the RTN. &quot;&quot;Names with version substrings are preferred over the same name without the substring.&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobShortName</b> (KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;short_name&quot;,&quot;0&quot;,&quot;Use the shortest name for the RTN. &quot;&quot;Names with version substrings are preferred over the same name without the substring.&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">KNOB&lt; BOOL &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#598a612bc7e5ea1f418dd2ab671ca97c\">KnobJitApi</a> (KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;support_jit_api&quot;,&quot;0&quot;,&quot;Enables the Jitted Functions Support&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"2602a9d5ba6607b5138ede1f50e987d8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_is_shadow_img\" ref=\"2602a9d5ba6607b5138ede1f50e987d8\" args=\"(IMG img)\" -->\nLOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>IMG_is_shadow_img</b> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g6893a5b1fec6b80a95d704c2e773904e\">IMG_Next</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gd0d95a60ed46be5aa1c5ade8ecbd4709\">IMG_Prev</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gb6cb72ab86f5b0cd8eb4b9ca62ab3246\">IMG_Invalid</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g270890995751804b99748df891264ab2\">IMG_Valid</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">SEC&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g33f7761534eeb9e0d8caffa9dd9c7b29\">IMG_SecHead</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">SEC&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ge0642428178daa38cc8d32f8fc86fd6f\">IMG_SecTail</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">SYM&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g348cdf7a038afa17459b49efac8ce4f1\">IMG_RegsymHead</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gb8e9c84a2f94aebe6c57226ab604a6e6\">IMG_Entry</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">const string &amp;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g491b26d161526b35498839f5cdf30a76\">IMG_Name</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gff3327c1539acd77feb096d20442104a\">IMG_Gp</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g0b1ec819cfdc6ab668335c8ef923e595\">IMG_LoadOffset</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g08c181dc4776ed954ebda9c5c28ce6c4\">IMG_LowAddress</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g6eff113bda0343f46397fe9cc866d5df\">IMG_HighAddress</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gfaff9055ed84254aa9ae9fbcb4e43ba9\">IMG_StartAddress</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">USIZE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g16f41c028b4908e2218c61b873c87c78\">IMG_SizeMapped</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gc800e23070e2f1ee535bf7c06e2f6f58\">IMG_TYPE</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g3fb22bb78eec9f551149a4ff7ba2d827\">IMG_Type</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g22ee33d2f99ac461146541ed8094d205\">IMG_IsMainExecutable</a> (IMG x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g9049891c13cbc87c8427cf7ccc2f501a\">IMG_IsStaticExecutable</a> (IMG x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#geac301624abebcbc103447306bf0037b\">IMG_NumRegions</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g61dbd928707746c08ad1e60aab39b944\">IMG_RegionHighAddress</a> (IMG img, UINT32 n)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gc90f1d878b0169a1f5d6b98f251d582b\">IMG_RegionLowAddress</a> (IMG img, UINT32 n)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#79fa304a836f1cc5c3c32abc7f9fd9c6\">IMG_FindRtnByName</a> (IMG img, const string &amp;name)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"468c8a49c9e179b69765eebb0e7b36f6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FinalizeRtn\" ref=\"468c8a49c9e179b69765eebb0e7b36f6\" args=\"(RTN rtn, USIZE size)\" -->\nLOCALFUN RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FinalizeRtn</b> (RTN rtn, USIZE size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"78e83bad98d10428c6a88d6417f38cfc\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AddRtnsToMap\" ref=\"78e83bad98d10428c6a88d6417f38cfc\" args=\"(IMG img)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>AddRtnsToMap</b> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#c226e8c7cca942b48a9fd396df246e37\">IMG_CreateAt</a> (const char *filename, ADDRINT start, USIZE size, ADDRINT loadOffset, BOOL mainExecutable)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#g3002fffef1eff03eb1d55ff6dc9c5977\">SEC_Img</a> (SEC sec)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">SEC&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#g75fc1b62fe6f1d67d36e3215e464f000\">SEC_Next</a> (SEC sec)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">SEC&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#g30f3aed51c11cb6715938399e6891b75\">SEC_Prev</a> (SEC sec)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">SEC&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#gfdbef9156a2ae6f526b4683f8f6fe6be\">SEC_Invalid</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#g1b12fe810ea34835d192449f8d41e226\">SEC_Valid</a> (SEC x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#g1a81afab78e506eb52b3c4d5fa81584d\">SEC_RtnHead</a> (SEC sec)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#gdc3ffead016cff9464a1f83de95d8356\">SEC_RtnTail</a> (SEC sec)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">const string &amp;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#g6182f198c8dbd354630b1531b5fdc534\">SEC_Name</a> (SEC sec)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#g9d3e14174cd3222b425135d9c74df159\">SEC_TYPE</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#g7058d53e989a3857440028c69089b7c1\">SEC_Type</a> (SEC sec)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#g65927c8d87fbe84104e9e1eb52bc59e4\">SEC_Mapped</a> (SEC sec)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">const VOID *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#g3ef92a1978b1d42bd44e4418702804a9\">SEC_Data</a> (SEC sec)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">SEC&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g9046edfd85722ef2f701282ba7a5c7a2\">RTN_Sec</a> (RTN x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gf21d0d3fd6851e83e42827f09c03a4e7\">RTN_Next</a> (RTN x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g9c78a0482f0f81a0ddfa844954a84dc9\">RTN_Prev</a> (RTN x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g4946397af2bfbe1825aeca264e4bc4de\">RTN_Invalid</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6\">RTN_Valid</a> (RTN x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f0ae7fbd43a8319f1b64e582d48f2116\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RtnOutsideRangesManager\" ref=\"f0ae7fbd43a8319f1b64e582d48f2116\" args=\"()\" -->\nLOCALINLINE RTN_OUTSIDE_RANGES &amp;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RtnOutsideRangesManager</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#7752482ea13c862c244fb7cb51e8df4b\">DisassembleRegion</a> (RTN rtn, BBL bbl, const VOID *current, const VOID *end, ADDRINT rtnStart, ADDRINT rtnEnd, ADDRINT virtual_offset)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"21c938c939e4e901b0927fcb5e0b49ea\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DisassembleFirstIns\" ref=\"21c938c939e4e901b0927fcb5e0b49ea\" args=\"(const VOID *current, const VOID *end, ADDRINT virtual_offset)\" -->\nLOCALFUN INS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DisassembleFirstIns</b> (const VOID *current, const VOID *end, ADDRINT virtual_offset)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"e5ff074bf3afb987390c19f95c4f4941\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FetchRtnIns\" ref=\"e5ff074bf3afb987390c19f95c4f4941\" args=\"(RTN rtn)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FetchRtnIns</b> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"314caa13cfdc01ace9cee8ed6ad89267\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FetchRtnInsFirstOnly\" ref=\"314caa13cfdc01ace9cee8ed6ad89267\" args=\"(RTN rtn)\" -->\nLOCALFUN INS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FetchRtnInsFirstOnly</b> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API BBL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga793e2a308c99a05c7b2efbe027e8330\">RTN_BblHead</a> (RTN x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API BBL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g273a2bba1ca70f5e02f70f78da5733a1\">RTN_BblTail</a> (RTN x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">const string &amp;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gb274bf5dadf6f1ae3259715ae161ebd1\">RTN_Name</a> (RTN x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g696ccffb0bff15b1565216aa0e7813f3\">RTN_IsArtificial</a> (RTN x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">SYM&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gb3c8e4196812c16e0072311ccf31b198\">RTN_Sym</a> (RTN x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">AFUNPTR&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g5b6998f250d54f5b1dcc4f65837add7a\">RTN_Funptr</a> (RTN x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#cfa58d6beb1e2285d781c296ae891578\">RTN_Destroy</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g2021004b76379a3e40db22743b50dbeb\">RTN_Id</a> (RTN x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API INT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g9253774cbe2df6653a5d0350fc4fb54d\">RTN_No</a> (RTN x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">INS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#gc87b625878d4ba42dfbeac2c81ac48bc\">BBL_InsHead</a> (BBL x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">INS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#g8a843c465bd2ab4ff8c7adfc81b468ca\">BBL_InsTail</a> (BBL x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BBL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#g60805b0620b58e2c9ca2add6e16d26ef\">BBL_Next</a> (BBL x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BBL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#g36c84e09b8eb7670b71a6829d9e63932\">BBL_Prev</a> (BBL x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#g5aaace888f68ec067f60e3b74c0b9131\">BBL_Valid</a> (BBL x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BBL_TYPE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#01bb22507bfb96558a4b8f3f35e23abf\">BBL_Type</a> (BBL x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">EDG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#3a7e85c10450b8477f8bf83069a771aa\">EDG_NextSucc</a> (EDG x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">EDG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#17e7e55f60e8f37076ef126c4988c2e5\">EDG_INVALID</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#3a11abd329135a8864c2d84114a7561c\">EDG_Valid</a> (EDG x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">EDG_TYPE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#98af1008c26ca6c3afe99daec2df5d48\">EDG_Type</a> (EDG x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#ge180d58ae453f61a939b1c4c5a66c129\">INS_Rtn</a> (INS x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">INS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g2711640bba1359feb3385a0c7b42ff4b\">INS_Next</a> (INS x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">INS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#gea9aa925c0d0c3a898843e32d40756ae\">INS_Prev</a> (INS x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">INS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#gee7afe69950c06eceea88705d6639101\">INS_Invalid</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g98b61a0ca7456dce466a5f773656e310\">INS_Valid</a> (INS x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#gd3b5f975c84b126531b38930b94b5544\">INS_Address</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">USIZE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#gf031508bacfcaf4d566f9df8245f3df2\">INS_Size</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#ga52df2852835cd0938a5f2c0e81aaecd\">INS_DirectBranchOrCallTargetAddress</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#gc9e4a7b2326fb29d949de0b4195fde55\">INS_NextAddress</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">SYM&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#ge180d8ef29e941662eae416f92adbd72\">SYM_Next</a> (SYM x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">SYM&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#ge99cdd587ca1bc240496b9397345c6fd\">SYM_Prev</a> (SYM x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">const string &amp;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#g2322cb4a1c052fa27420f66b1f3eb8e3\">SYM_Name</a> (SYM x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">SYM&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#g7954a25db2764ecb7f1b52964981f7b1\">SYM_Invalid</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#ge83aad6ccb150a96e6bde242326a8ad4\">SYM_Valid</a> (SYM x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#g16af244db33ce22b1a1ae4d435bf1bd5\">SYM_Dynamic</a> (SYM x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#g60d44c7c2104b7f6413334aa85fc370a\">SYM_GeneratedByPin</a> (SYM x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#g1bc3b15e0e088980f89de34a3a3068e7\">SYM_IFuncImplementation</a> (SYM x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#gcb6c2c75ed8c06148832315f54025177\">SYM_IFuncResolver</a> (SYM x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#g00de931c3077bdbfa72bb16c49fc007d\">SYM_Value</a> (SYM x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#g7ed74b45b09985458bf987af1d0828e8\">SYM_Index</a> (SYM x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#gfcacf68cea21989a37542886f5ddbf01\">SYM_Address</a> (SYM x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#bcb216ec4df150015d0370d30bd7e904\">GetOpenImg</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#64f7462d92129da25864a39dd4183442\">ResetOpenRtn</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#4f04e50e427cfd24aaa274ee8ba5c0a6\">ResetOpenImg</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab6a79b971b43b6f40df77682f6a4061\">InitializeApp</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#75098a371b4b052b8f2b7d64d2f808dc\">UnInitializeApp</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g9440e63ee69888e8889a90912f605316\">IMG_Id</a> (IMG x)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gf873a62e2b6d0d4e67ea5a0a3d4667ca\">IMG_FindImgById</a> (UINT32 id)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#e514b390226e49f828de74a3e93e40ad\">IMG_FindByUnloadAddress</a> (ADDRINT startAddress)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ge45546e72983c134da872b7ff8430949\">IMG_FindByAddress</a> (ADDRINT address)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#c83d3d834774eb26105d9220fc240ccb\">IMG_FindBySectionsAddress</a> (ADDRINT address)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g50b3794c06a99774ed62abec8ad3b173\">RTN_AddInstrumentFunction</a> (<a class=\"el\" href=\"group__RTN__BASIC__API.html#g36aaf349284bbf9d5dede36061572e1b\">RTN_INSTRUMENT_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"bf64c59e4fd16184fea4f76707e4a820\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::operator&lt;\" ref=\"bf64c59e4fd16184fea4f76707e4a820\" args=\"(const RTN_KEY &amp;p1, const RTN_KEY &amp;p2)\" -->\nLOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>operator&lt;</b> (const RTN_KEY &amp;p1, const RTN_KEY &amp;p2)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g4867c865fcf260951b7d750aaaaa0007\">IMG_AddInstrumentFunction</a> (<a class=\"el\" href=\"group__IMG__BASIC__API.html#g8861283eeb90cff2839c84ef8bba5802\">IMAGECALLBACK</a> fun, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#958abd58434e88c4c4790bea50ba69bb\">IMG_RemoveToolCallbacks</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g8f27bbc6bbc60d15df64ca5e81b19c30\">IMG_AddUnloadFunction</a> (<a class=\"el\" href=\"group__IMG__BASIC__API.html#g8861283eeb90cff2839c84ef8bba5802\">IMAGECALLBACK</a> fun, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"db22c8f3dd0e2023664a836d924964fb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_Destroy\" ref=\"db22c8f3dd0e2023664a836d924964fb\" args=\"(IMG img)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>IMG_Destroy</b> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#8e929d0af8332af1b934e4c7a686ec5a\">ProcessImageUnload</a> (IMG img, BOOL copyBits)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#4d3105395edc6c295957afc8fd08e02f\">PIN_UnloadAllImages</a> (BOOL copyBits)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#c62cdf7c3212f4177e4d884db0fa43ff\">ProcessModuleUnload</a> (ADDRINT base)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">USIZE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gaac677a394e97b62b31ff222ffe4c32a\">RTN_Range</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">USIZE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g80ec28fada91863f90c590ea8b6d0b9e\">RTN_Size</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g8a6de80acafcce3573ec8f572989cc6e\">RTN_IFuncResolver</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga50fd585a35c89fbb920b4c643cc9e4e\">RTN_IFuncImplementation</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"977183140b6a0390e984db2de4846515\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InitRtnToSym\" ref=\"977183140b6a0390e984db2de4846515\" args=\"(RTN rtn, SYM sym)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>InitRtnToSym</b> (RTN rtn, SYM sym)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"7c06e6e5670d68f3b8eb6e403ddd87ca\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::UseShortName\" ref=\"7c06e6e5670d68f3b8eb6e403ddd87ca\" args=\"(RTN rtn, SYM sym)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>UseShortName</b> (RTN rtn, SYM sym)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"7abbd210cb7cf22d0111fc72305716a7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::BestFit\" ref=\"7abbd210cb7cf22d0111fc72305716a7\" args=\"(RTN rtn, SYM sym)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>BestFit</b> (RTN rtn, SYM sym)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"97e0d5a03d36a0100f23b6fd51f782de\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SymPosition\" ref=\"97e0d5a03d36a0100f23b6fd51f782de\" args=\"(SYM sym, const MemRange &amp;range)\" -->\nLOCALFUN INT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SymPosition</b> (SYM sym, const MemRange &amp;range)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#1da8803f4e53cf500efbcc2b68d265e8\">FindCodeRanges</a> (IMG img, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0eefbda43523c1adaff6dd670372cdff\">CODE_RANGES</a> *rangeMap)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#20bb0768cd2b9b95341f9b56810d9bf7\">NotifyDataRange</a> (<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0eefbda43523c1adaff6dd670372cdff\">CODE_RANGES</a> *rangeMap, ADDRINT base, USIZE size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"20e0f5a49bb674d59d521739362c1867\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MakeRtns\" ref=\"20e0f5a49bb674d59d521739362c1867\" args=\"(IMG img)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>MakeRtns</b> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#066e24528cd7ad167763af54d18bc758\">CallRtnCallbacks</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a512e61d187cc6c8c5dd80be88a284ce\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallRtnCallbacks\" ref=\"a512e61d187cc6c8c5dd80be88a284ce\" args=\"(IMG img)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CallRtnCallbacks</b> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"d1c0ce4c922df10c7e2559e88a002335\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DsUpdatesDueRtnfuncCreation\" ref=\"d1c0ce4c922df10c7e2559e88a002335\" args=\"(RTN rtnToSplit, RTN originatedFromIfunc, ADDRINT rtnToSplitAddr, ADDRINT rtnToSplitSize, ADDRINT newRtnAddr)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DsUpdatesDueRtnfuncCreation</b> (RTN rtnToSplit, RTN originatedFromIfunc, ADDRINT rtnToSplitAddr, ADDRINT rtnToSplitSize, ADDRINT newRtnAddr)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f2c4fdca9beecabf6adc46ac8bd96831\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::handleIfuncSymbol\" ref=\"f2c4fdca9beecabf6adc46ac8bd96831\" args=\"(ADDRINT actualFuncAddr, SYM resolver, IMG img)\" -->\nLOCALFUN RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>handleIfuncSymbol</b> (ADDRINT actualFuncAddr, SYM resolver, IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"dd47b89249742e41a22a4f73392eb841\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImgLoad\" ref=\"dd47b89249742e41a22a4f73392eb841\" args=\"(const string &amp;filename, const CHAR *trueFilename, ADDRINT load_offset, UINT32 flags, BOOL *unmapAfterProcessing, void *arg)\" -->\nLOCALFUN IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ImgLoad</b> (const string &amp;filename, const CHAR *trueFilename, ADDRINT load_offset, UINT32 flags, BOOL *unmapAfterProcessing, void *arg)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#d5ed06cb7e8c4088f98fe38e2dd61f31\">IMG_RecordLoadOp</a> (const string &amp;imageName, const char *fileName, ADDRINT lo, UINT32 fl)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#2c27dcf002aba8bd73c1b3e8f843c86e\">IMG_RecordLoadOp</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#6b02551e35f166adb7fb96967c7c7911\">IMG_ExecuteRecordedLoadOps</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gbe4609c85b9795a1d57e9d6bfc3f5f23\">IMG_Open</a> (const string &amp;filename)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gb260d0d2298aefe76f041595fe918fd0\">IMG_Close</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"7f226845fe155af6ebf19212186bab33\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NewThread\" ref=\"7f226845fe155af6ebf19212186bab33\" args=\"()\" -->\nLOCALFUN THREAD_CONTEXT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>NewThread</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"0b893dbfeb06e574334240f82230a130\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImageLoadProbes\" ref=\"0b893dbfeb06e574334240f82230a130\" args=\"(IMG img)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ImageLoadProbes</b> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#7767a09795b8a85cbdaa32877e13ffce\">ProcessImageLoad</a> (const string &amp;filename, const CHAR *trueFilename, ADDRINT load_offset, UINT32 flags, void *loaderInfo, void *arg)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#5a1ab30ed65b0535cd1ec7e1aac7f172\">ProcessImageLoad</a> (const string &amp;filename, const CHAR *trueFilename, ADDRINT load_offset, UINT32 flags, void *arg)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#2c3cf54dba70e1e4fbbe250a476a3688\">IMG_ReplayImageLoad</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#3f1355bdf1c34c5e19cb947b9c399043\">IMG_GetLoaderInfo</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#b9668f8fa8b8539657861c38f02fbab2\">IMG_SetLoaderInfo</a> (IMG img, VOID *loaderInfo)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#e743e5fcb67304db3aa325a5df3c2325\">CompleteImageLoad</a> (IMG img, void *arg)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a2a730180eafa2a413b937098fd2bd95\">InitDynamicCodeImage</a> (IMG newImg)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#12c24fff0262f4fe68e1000aa1d679d7\">IsPinLoaded</a> (const string &amp;name)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">string&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g2d23a45cffdac00f7efa403b05c85bc4\">RTN_FindNameByAddress</a> (ADDRINT address)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gc9d3d0a9e51f251da80910c74d4118c9\">RTN_FindByAddress</a> (ADDRINT address)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g926d67b40afab106e86ccbb33565c889\">RTN_FindByName</a> (IMG img, const CHAR *name)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0\">RTN_Open</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#e32f659b8fd09884dedac7a45c95cf7d\">RTN_OpenAndFetch</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3\">RTN_Close</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">INS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gb49dd96d5d0d0fdcf38c922585c6ba06\">RTN_InsHead</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">INS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g601bc008886a5cc3bd2df4936d8e76e8\">RTN_InsHeadOnly</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">INS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ge667ff98539eb3d39c3a40e9ca96c3e0\">RTN_InsTail</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g50c2e1ac2a2bab9baff6e04c27e905cd\">RTN_NumIns</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a\">RTN_InsertCall</a> (RTN rtn, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gb74b01b5b6feb47a1f52d9f8ea7ea154\">RTN_Address</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g394372fdee2823655d7e5eb1742e5ffa\">RTN_CreateAt</a> (ADDRINT address, string name)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#afa81f8f08250d7bbb6ccc4ff03d4fe4\">RTN_CreateJitFunction</a> (IMG img, ADDRINT address, const string &amp;name, USIZE size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#cd548b0bb345eaee3624bde3cdf13c67\">RTN_DestroyJitFunction</a> (ADDRINT address)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gb36b828dc06d754e79780245d938dc7b\">RTN_IsDynamic</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#gaf9c0a83b7c4fc5530d36102eba7f7c6\">SEC_Address</a> (SEC sec)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#gd75fca5ed60762d2a8bad9c26e0887ba\">SEC_IsReadable</a> (SEC sec)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#g8c1de2f387fc852a15a6d0a478a9d123\">SEC_IsWriteable</a> (SEC sec)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#g9952762fd6886cd3b97531456988b97f\">SEC_IsExecutable</a> (SEC sec)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">USIZE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#gdbc92d99eef0a9e5a157e9901bf87208\">SEC_Size</a> (SEC sec)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#gfd9d165d01ab3d9cf964574ca11be303\">BBL_Original</a> (BBL bbl)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#g2ef8e1f0100a56cc0a67237877dbceb8\">BBL_Address</a> (BBL bbl)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">USIZE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#gd294a98d13337e378b219a4671c351d6\">BBL_Size</a> (BBL bbl)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#g8db4044229abb48140e32b391a5bf050\">APP_ImgHead</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga7e4fd6c7b35b21e381af2077cd51ef0\">APP_ImgTail</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0525801ca47a4e43620d4c39835344c1\">ToolUseImageAPI</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">string&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#gd02e31773f5a8aef5e5a70be7f09dd17\">PIN_UndecorateSymbolName</a> (const string &amp;symbolName, <a class=\"el\" href=\"group__SYM__BASIC__API.html#g8aa0db3277ed9b401a204bf2d1bdc6aa\">UNDECORATION</a> style)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g183ea6e8b331b719338c56d39760e273\">PIN_AddInternalExceptionHandler</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gb3550c0044899834614bc73245f90743\">INTERNAL_EXCEPTION_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g22e1f539c7159c1bc9a2aac8f8803e81\">PIN_TryStart</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, <a class=\"el\" href=\"group__PIN__CONTROL.html#gb3550c0044899834614bc73245f90743\">INTERNAL_EXCEPTION_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g865588e1c8ec27149ab627aecabfd4c1\">PIN_TryEnd</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"29082f70b240a06317e3c636a4eca520\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ProbeTag_String\" ref=\"29082f70b240a06317e3c636a4eca520\" args=\"(PROBE_TAG tag)\" -->\nLOCALFUN string&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ProbeTag_String</b> (PROBE_TAG tag)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BBL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#c8cc4050cbb42f925c1cb58f08ae85d7\">TRACE_AddInlineReturnEdg</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BBL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#65ef8545c3c4558e591a6ce11bbb52e9\">TRACE_AddInlineCallEdg</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BBL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ce2384973d5e1029706c0dda314a9aaa\">TRACE_AddBranchEdg</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BBL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a66913eb9503806b8899ae4415c07a87\">TRACE_AddFallthroughEdg</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#c2e56309fafae7058494ecd59a96744d\">TRACE_StraightenControlFlow</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a7255411e603da634dd7e96f78f5cfa9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_InsertProbeImp\" ref=\"a7255411e603da634dd7e96f78f5cfa9\" args=\"(ADDRINT src_addr, ADDRINT dst_addr, USIZE probeSize)\" -->\nLOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PIN_InsertProbeImp</b> (ADDRINT src_addr, ADDRINT dst_addr, USIZE probeSize)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#034cda838606c61faa059859f76da7fb\">PIN_InsertProbe</a> (ADDRINT src_addr, ADDRINT dst_addr)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#271f5af1f2fa7eda8fe07c8d7284c215\">PIN_RemoveProbe</a> (ADDRINT address)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f45374ef152ae9e634751f380fde39e6\">TRACE_GenerateCode</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#e34d7eb04c99b26b1558320fecc799d7\">INS_IsPinXfer</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#2e5e0d58f0b03f6d3097435d9faabde5\">INS_IsNativeXfer</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#8479246e853712ea3fb9d942bbc36612\">INS_SetNativeXfer</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#063127f4332d26e854e041c73903ce10\">INS_skip_xlate_set</a> (INS ins, BOOL b)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#79d2fe6706153c0ceff1e3470fefa426\">TRACE_ExitsXferToNative</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#36c838d1995c451f596161fcf1de70d7\">INS_SetPinXfer</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#7191bcfd463c348aa4b78a3b69b2d96b\">INS_IsNativeCall</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f2a8eda4c80ea2b762140b6f41a13739\">INS_IsXlateCall</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#868138e8ffb4bc0f08879959f711cbdd\">INS_SetXlateCall</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0b19d6710b2f62db97b79d8624103f52\">INS_SetNativeCall</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#68b8a7d4fcf85183f5a4d66246d45063\">CatchEndInstrumentation</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#d4a791e2d1da0a57f243770d37b336f9\">BeginInstrumentedExecution</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g4eaf8017949dc10cb62476e6d0bceda5\">PIN_IsProbeMode</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gf9553939b8b4f4aa966dedd6ce64f661\">PIN_IsAttaching</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"1e4c03a25203118f8e5af3619ae09d04\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckInsSequenceForProbe\" ref=\"1e4c03a25203118f8e5af3619ae09d04\" args=\"(INS ins, UINT32 probe_size)\" -->\nLOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CheckInsSequenceForProbe</b> (INS ins, UINT32 probe_size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f65d5d63926fc7cf54a842e11f6b037b\">BBL_InvalidForProbe</a> (BBL bbl)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#d2a0bb30b870acbeb102f30ff69569a3\">RTN_CheckRtnSizeForProbe</a> (RTN rtn, BOOL checkForPadding, BOOL *didcheckForPadding, UINT32 probe_size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#45309e6bd43fc38b5cb3b12115178a25\">RTN_ProbeMayOverwriteBranchTarget</a> (RTN rtn, UINT32 probe_size, BOOL *mayOverwriteUnidentifiedBranchTarget)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#7e79b848b975ff17bd601f06494d6888\">RTN_CheckForPreviousProbe</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a3d3f1ee27f714efd6ee27f2c947b884\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckProbeSafety\" ref=\"a3d3f1ee27f714efd6ee27f2c947b884\" args=\"(RTN rtn, BOOL checkForPadding, BOOL *didcheckForPadding, UINT32 probe_size)\" -->\nLOCALFUN PROBE_TAG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CheckProbeSafety</b> (RTN rtn, BOOL checkForPadding, BOOL *didcheckForPadding, UINT32 probe_size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"40c00bdf35c865e0e9c3a78a62655604\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_IsRelocatable\" ref=\"40c00bdf35c865e0e9c3a78a62655604\" args=\"(RTN rtn)\" -->\nLOCALFUN PROBE_TAG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_IsRelocatable</b> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a698f1be08bcc9a9625e4cbcd945254e\">DeleteRtnCheckHistory</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"d44413ec77d530c986fb3a8cdb780723\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_CheckForSafeProbe\" ref=\"d44413ec77d530c986fb3a8cdb780723\" args=\"(RTN rtn, BOOL allowPOP, PROBE_TAG *tagptr, UINT32 *probe_size, PROBE_MODE mode, BOOL checkForPadding)\" -->\nLOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_CheckForSafeProbe</b> (RTN rtn, BOOL allowPOP, PROBE_TAG *tagptr, UINT32 *probe_size, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gf191d518e93cfce6bf6e43d0b2bf3d81\">PROBE_MODE</a> mode, BOOL checkForPadding)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g59b4507c13286cfad2195de5659a1783\">RTN_IsSafeForProbedInsertion</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g04857c442387f4c2a004775a47429f47\">RTN_IsSafeForProbedInsertionEx</a> (RTN rtn, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gf191d518e93cfce6bf6e43d0b2bf3d81\">PROBE_MODE</a> mode)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g7ea1c8fd47cf2ef8f97f30b9d228c9a3\">RTN_IsSafeForProbedReplacement</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gc7988500a690993150dd71349fa6fefc\">RTN_IsSafeForProbedReplacementEx</a> (RTN rtn, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gf191d518e93cfce6bf6e43d0b2bf3d81\">PROBE_MODE</a> mode)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"fcf07fde0817c20d17c6ef8a75168c43\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CookArguments\" ref=\"fcf07fde0817c20d17c6ef8a75168c43\" args=\"(va_list argList, ADDRINT instAddress)\" -->\nLOCALFUN <a class=\"el\" href=\"group__INST__ARGS.html#g71f6833136d66657723c6630ed144fb8\">IARGLIST</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CookArguments</b> (va_list argList, ADDRINT instAddress)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"ae82620774a26e65ccefd03b83b11937\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_ReplaceSignatureProbedImpl\" ref=\"ae82620774a26e65ccefd03b83b11937\" args=\"(RTN orgRtn, AFUNPTR replacement, PROBE_MODE mode, va_list argList)\" -->\nLOCALFUN AFUNPTR&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_ReplaceSignatureProbedImpl</b> (RTN orgRtn, AFUNPTR replacement, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gf191d518e93cfce6bf6e43d0b2bf3d81\">PROBE_MODE</a> mode, va_list argList)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">AFUNPTR&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g5cc8019660f41cae2449c826a878afe0\">RTN_ReplaceSignatureProbed</a> (RTN replacedRtn, AFUNPTR replacementFun,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">AFUNPTR&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g23398b03719fea855a64e43e767cad6a\">RTN_ReplaceSignatureProbedEx</a> (RTN replacedRtn, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gf191d518e93cfce6bf6e43d0b2bf3d81\">PROBE_MODE</a> mode, AFUNPTR replacementFun,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#498cd509d5928c5ee1a5a09b461f4129\">INS_ReplaceSignatureProbed</a> (INS orgIns, AFUNPTR replacementFunptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">AFUNPTR&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#081ab58c8dcd42ab607207e8d17f8d4b\">RTN_InsertProbe</a> (RTN rtn, AFUNPTR replacement, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gf191d518e93cfce6bf6e43d0b2bf3d81\">PROBE_MODE</a> mode)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"8aec7fe98a178af00aaaa2be75a346bf\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_InsertCallProbedImpl\" ref=\"8aec7fe98a178af00aaaa2be75a346bf\" args=\"(RTN rtn, IPOINT action, AFUNPTR funptr, PROBE_MODE mode, va_list argList)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_InsertCallProbedImpl</b> (RTN rtn, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, AFUNPTR funptr, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gf191d518e93cfce6bf6e43d0b2bf3d81\">PROBE_MODE</a> mode, va_list argList)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g14e777b8f3dca1049dd035df0f900a5f\">RTN_InsertCallProbed</a> (RTN orgRtn, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g6aba02ce7c30c66f0a7124c1ea10a613\">RTN_InsertCallProbedEx</a> (RTN orgRtn, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gf191d518e93cfce6bf6e43d0b2bf3d81\">PROBE_MODE</a> mode, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"ec5a280cdab56fb6d0aa847fc5510530\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_CheckForProbeInsertion\" ref=\"ec5a280cdab56fb6d0aa847fc5510530\" args=\"(INS ins)\" -->\nLOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>INS_CheckForProbeInsertion</b> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g761d2835019d91668430baa4323e5234\">PIN_IsSafeForProbedInsertion</a> (ADDRINT addr)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g51f4fcede5894981b70f3d73cbdb39f4\">PIN_InsertCallProbed</a> (ADDRINT addr, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">INT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g48573de2158f0e8b212e9f1a0c03930e\">RTN_CodeRangesProbed</a> (RTN rtn, INT32 num, <a class=\"el\" href=\"structPIN__CODE__RANGE.html\">PIN_CODE_RANGE</a> *buffer)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#fde19488ce7dbdda6777aa19412c7c01\">CompleteProbesInstrumentationForCurrentModule</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#23a4e64ed9045f9667e25e4bb57befce\">Open_Rtn</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#1b9ed6947b61e58a030bde3c4bbc22fd\">Close_Rtn</a> (RTN rtn)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PROTO__API.html#gaa40d7e36e9ad7a07ee68adb5b312377\">PROTO</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PROTO__API.html#g49300accd53f8e574af0b706ee553625\">PROTO_Allocate</a> (PARG_T returnArg, <a class=\"el\" href=\"group__PROTO__API.html#g54651b96181be964a6a914420a4e021c\">CALLINGSTD_TYPE</a> cstype, const char *name,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PROTO__API.html#g0affd7dbe19f86b3b3ffb260540d37e4\">PROTO_Free</a> (<a class=\"el\" href=\"group__PROTO__API.html#gaa40d7e36e9ad7a07ee68adb5b312377\">PROTO</a> proto)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">GLOBALCONST <a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g7ae5606fe8ade20e30274a5a53b827af\">PIN_CALLBACK_INVALID</a> (0)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#e85f66d0e50f6222e2dd97d64fbb70ea\">VmFunctionNotInitialized</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"0f6a1d8fe6ada39e97a9d6e0c179e6f1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_RemoveToolCallbacks\" ref=\"0f6a1d8fe6ada39e97a9d6e0c179e6f1\" args=\"()\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PIN_RemoveToolCallbacks</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"4886f2a8503517a39a1578dbea23baab\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobProfile\" ref=\"4886f2a8503517a39a1578dbea23baab\" args=\"(KNOB_MODE_WRITEONCE,&quot;supported:stat&quot;,&quot;profile&quot;,&quot;0&quot;,&quot;print amount of memory dynamically allocated but not yet freed by the tool&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobProfile</b> (KNOB_MODE_WRITEONCE,&quot;supported:stat&quot;,&quot;profile&quot;,&quot;0&quot;,&quot;print amount of memory dynamically allocated but not yet freed by the tool&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#803aaca717b5d93e5dac74037fb170c0\">IsThreadInFiniCallback</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#gab34d1953888d943b66400fd065e7af6\">OS_THREAD_ID</a> sysId)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"57cabaffe84629fc81f7b0b302f26604\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SetProcessExiting\" ref=\"57cabaffe84629fc81f7b0b302f26604\" args=\"()\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SetProcessExiting</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#7b1e55fbe21558d48e13522ed648f74b\">Shutdown</a> (INT32 exitCode, BOOL waitToolThreads)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"6f45342fe9932c0dc9c3d692df741d16\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoInstructions\" ref=\"6f45342fe9932c0dc9c3d692df741d16\" args=\"(TRACE trace)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoInstructions</b> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"8a5097681f41728e7274b49d882b74ff\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckNoJITCallbacks\" ref=\"8a5097681f41728e7274b49d882b74ff\" args=\"()\" -->\nLOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CheckNoJITCallbacks</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"1e9098e4a2efb319f15657c60e36094c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckNoProbeCallbacks\" ref=\"1e9098e4a2efb319f15657c60e36094c\" args=\"()\" -->\nLOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CheckNoProbeCallbacks</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALINLINE <a class=\"el\" href=\"group__PIN__THREAD__API.html#gab34d1953888d943b66400fd065e7af6\">OS_THREAD_ID</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#685681f02994155a16dd1f8b4cd3a808\">GetCurrentSysId</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gab34d1953888d943b66400fd065e7af6\">OS_THREAD_ID</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#3acf9b2974d069552c48a9a2934906cb\">GetCurrentSysIdById</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"3f256375fbae1af663b7fcca2ceaab70\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobCheckLocks\" ref=\"3f256375fbae1af663b7fcca2ceaab70\" args=\"(KNOB_MODE_WRITEONCE,&quot;supported:message&quot;,&quot;checklocks&quot;,&quot;1&quot;,&quot;Check locks are used correctly&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobCheckLocks</b> (KNOB_MODE_WRITEONCE,&quot;supported:message&quot;,&quot;checklocks&quot;,&quot;1&quot;,&quot;Check locks are used correctly&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"54700313d396bbd2dfdc901d8cf869b2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InitClientLock\" ref=\"54700313d396bbd2dfdc901d8cf869b2\" args=\"()\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>InitClientLock</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#949153c3d46f3d7077acae3a6b56881e\">CheckPinClientLock</a> (const CHAR *funname)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gc5d4cd777e5c34bb760ea6768e054f20\">PIN_LockClient</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga4d21b5ab38ba60932969d0d37e4f5de\">PIN_UnlockClient</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#380eabb845a436f5359fcba351816d48\">PIN_TryClientLock</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#1ff6b5f93566358d0fb11e216823b926\">PIN_CallerOwnsClientMutex</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#gab34d1953888d943b66400fd065e7af6\">OS_THREAD_ID</a> osid)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#e452842da6146745fbc83214f0783c53\">EnterPinClientMasterMode</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#3987af32238008426ac922ae09682692\">ExitPinClientMasterMode</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">GLOBALDLLFUN PINCLIENTINT *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#dd8e5edcd2496eeca4d27e2ba85009bf\">ClientInt</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">GLOBALDLLCFUN PINCLIENTINT *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#e2c225e7228027d1257a3704c15ec985\">ClientIntC</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"236f05229aae7116f66c02d434d85470\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TraceWithFunctionReplacement\" ref=\"236f05229aae7116f66c02d434d85470\" args=\"(TRACE trace)\" -->\nLOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>TraceWithFunctionReplacement</b> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN size_t&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a18dbb09c1604bdeb2c61b0ed79928c0\">InstFetcher</a> (void *copyBuf, const VOID *address, size_t maxSizeToCopy, <a class=\"el\" href=\"group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f\">EXCEPTION_INFO</a> *pExceptInfo)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"c154827e9269d3be00e20d812e118ed2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SetInTraceCallbacks\" ref=\"c154827e9269d3be00e20d812e118ed2\" args=\"()\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SetInTraceCallbacks</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"3b6c6ff6876275389d5b2f6321dd0746\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ReSetInTraceCallbacks\" ref=\"3b6c6ff6876275389d5b2f6321dd0746\" args=\"()\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ReSetInTraceCallbacks</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#147ecfb74ef886cb2d4ce0b894856859\">GetInTraceCallbacks</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#7e85b1d8759aa15306d7a6c865ba2a40\">CallTraceCallbacks</a> (REGION *region)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">INS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#7fbc97767465a78117608323b5a07e52\">TraceFirstIns</a> (ADDRINT currTraceAddr)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"45344999ebbf7e8057ad929ca99ba724\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoTraceInserted\" ref=\"45344999ebbf7e8057ad929ca99ba724\" args=\"(REGION *region)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoTraceInserted</b> (REGION *region)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#56fc6a403835656fae9147a1cda535d3\">CallFinis</a> (INT32 code)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad298e1b3ca1dbdc9df7e4dd73b04dc2\">NotifyOutOfMemory</a> (size_t size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ffbb2aeca388542bbadc0175d8c9de74\">NotifyPrepareForAtExit</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN ADDRINT PIN_FAST_ANALYSIS_CALL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#5965a0281ced35efbe4b244d44adcef5\">CallMemoryAddrTrans</a> (PIN_MEM_TRANS_INFO *memTransInfo, void *)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#27adc4c4cc6e22c387c375df93a9a1ad\">CallForksBefore</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadId, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#3de9a7cbd6c702df4ba562a32cd6165c\">CallForksAfterInParent</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadId, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#2a13d5cf30fbcb2f8194ec75836cb9f2\">CallForksAfterInChild</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadId, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#d3c2482a4d8c345aad3d7531044c35aa\">DoDetachs</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#c69967c684c53f18360b0cd589e5c7dc\">NotifyDetachCompletedJitMode</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#e8417db6d6d9daa0687429f39bab419e\">ImageInitializeFirst</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#1ee401916e8d1cb8ef4a38e1b4ba61e1\">CallApplicationStart</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#94e4fe3219a4c9a7965d20e19eb59bdb\">DoDetachsProbed</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#6060fbdaa7a8efcfa5a709995cb52199\">CallDetachCompletionCallback</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#b79119368e922f4a3fe34c36cf5ce45e\">DoAttachsProbed</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#7cca4a9e9f08dda102d3df55c1dd6922\">InitializeClientTls</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#55b7d6706f050de3e48d6cecdbd1cefc\">DestroyClientTls</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f487fb472b83c554466bf3a6c270a036\">CallThreadStarts</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, INT32 flags)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#6cd3583ef487f57d31c0423f279af440\">CallThreadFinis</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, INT32 code)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#17ab278ab99de9ead236d4c6e0008bcd\">CallContextChanges</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__PIN__CONTROL.html#gfa1b03e06c6ab0f86fc2abc1693ce688\">CONTEXT_CHANGE_REASON</a> reason, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *from, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *to, INT32 info)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#64ed417090d21ba01ed3a2d07c72c6c8\">CallSyscallEntry</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a> std)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#d17e30fa7d197523bbef1342295bc70f\">CallSyscallExit</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a> std)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#469d71cab4d59deef1b4d7beaf3cd556\">CallInterceptSignal</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, INT32 sig, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, BOOL hasHandler, const <a class=\"el\" href=\"group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f\">EXCEPTION_INFO</a> *pExceptInfo)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#55e1adf45f6c5bb11518f7611383753b\">CallThreadAttachInProbeMode</a> (VOID *sigmask)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#3d292327538fdf8e828df2b964458ec7\">CallThreadDetachInProbeMode</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#e6e689fcac512324250b55cd596aa09d\">CallProbesInserted</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__ERROR__FILE__BASIC.html#g7c4c001c9d041bea6bb972fad4ff748e\">PIN_WriteErrorMessage</a> (const char *msg, INT32 type, <a class=\"el\" href=\"group__ERROR__FILE__BASIC.html#g9999820041ad7ef6114c83aa49c72b22\">PIN_ERR_SEVERITY_TYPE</a> severity, INT32 num,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"560de3102b10af796356c4884e6b2d29\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoReplaceFunByNativeCall\" ref=\"560de3102b10af796356c4884e6b2d29\" args=\"(INS ins, VOID *v)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoReplaceFunByNativeCall</b> (INS ins, VOID *v)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f6fa2f5c68cbfaabf93cd66da4f5943f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoInstrumentForFunReplacement\" ref=\"f6fa2f5c68cbfaabf93cd66da4f5943f\" args=\"(REGION *region, BOOL firstInstIsReplaceable)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoInstrumentForFunReplacement</b> (REGION *region, BOOL firstInstIsReplaceable)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">AFUNPTR&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ged5e4ef123236add61c3f4f5cb5a4f09\">RTN_Replace</a> (RTN replacedRtn, AFUNPTR replacementFun)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">AFUNPTR&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gdba66dc89d3e71ce4413aa55eb3d450f\">RTN_ReplaceSignature</a> (RTN replacedRtn, AFUNPTR replacementFun,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">AFUNPTR&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#g3ab4d3386c8c56259772d9cffc607186\">RTN_ReplaceProbed</a> (RTN replacedRtn, AFUNPTR replacementFun)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">AFUNPTR&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gb1ae7d76a4c39de5559d7a1567489f43\">RTN_ReplaceProbedEx</a> (RTN replacedRtn, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gf191d518e93cfce6bf6e43d0b2bf3d81\">PROBE_MODE</a> mode, AFUNPTR replacementFun)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#95adcb0e41b514c219a7f3c15c549c12\">CheckNotInCallback</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, const char *function)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g5280354edd95efc19a837617ff63ba51\">PIN_CallApplicationFunction</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, <a class=\"el\" href=\"group__PROTO__API.html#g54651b96181be964a6a914420a4e021c\">CALLINGSTD_TYPE</a> cstype, AFUNPTR origFunPtr, <a class=\"el\" href=\"structCALL__APPLICATION__FUNCTION__PARAM.html\">CALL_APPLICATION_FUNCTION_PARAM</a> *param,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API.html#g5d0c99ac6722a36c4fbc85fbb585d901\">INS_IsAddedForFunctionReplacement</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g863491a71eb40d0c6a8c7813813b433e\">PIN_RegisterItcAuxCallBackPushFun</a> (AFUNPTR callBackPushFun)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g16e4f67c10f95873a82586f08054ddfd\">RTN_ComplexReplaceWithUninstrumentedRoutine</a> (RTN replacedRtn, AFUNPTR replacementFun)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g2d32e98b83c1d8e31a836fd49c50711a\">PIN_FindAlternateAppStack</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"0135d1d6c7c428e9012569dfd9151877\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InitializeCallBacks\" ref=\"0135d1d6c7c428e9012569dfd9151877\" args=\"()\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>InitializeCallBacks</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g2bcaa089e557326db9b1a9274bd3451c\">CALLBACK_SetExecutionPriority</a> (<a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a> callback, INT32 priority)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">INT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g658864225c8670585c13bc2641a334f8\">CALLBACK_GetExecutionPriority</a> (<a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a> callback)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g0261da0abe384db4e2f97cd31cf986f7\">TRACE_AddInstrumentFunction</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g927e6010210856a2b60b757460e53f15\">TRACE_INSTRUMENT_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CODECACHE__API.html#ge514aeab57d383efa6a1586bf41fc13c\">CODECACHE_AddTraceInsertedFunction</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g927e6010210856a2b60b757460e53f15\">TRACE_INSTRUMENT_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#gad5fd5cdd6c1cd37e57a1264e93b0435\">INS_AddInstrumentFunction</a> (<a class=\"el\" href=\"group__INS__INST__API.html#gd83539eedf8c29f0603bcb61e8d1df33\">INS_INSTRUMENT_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb\">PIN_AddFiniFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gcc77dcacc144b3894f5f0fc13360cdec\">FINI_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g69016c0c2ddfd1e8bec50e6ab4ab46b1\">PIN_AddFiniUnlockedFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gcc77dcacc144b3894f5f0fc13360cdec\">FINI_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g5ae6f03e5b5cd137cceee6d735aa7b04\">PIN_AddFetchFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gf26c93895c15754aa02c56d41f81f5f4\">FETCH_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">size_t&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g1d14c23857e14e0a0dca38a3621e035f\">PIN_FetchCode</a> (void *copyBuf, const VOID *address, size_t maxSize, <a class=\"el\" href=\"group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f\">EXCEPTION_INFO</a> *pExceptInfo)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gcae8a563efbe6d5f2eff743d718e5ce0\">PIN_AddOutOfMemoryFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gde47352f7f71df0632aa847aae16a274\">OUT_OF_MEMORY_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#959335effb5aa746d6e3bf35af66b6de\">PIN_AddPrepareForAtExitFunction</a> (<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f3e4861ef8256dcc4048a1e3f9a3ab22\">PREPARE_FOR_ATEXIT_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g63b1d94d623119a6e9045508e74c37f4\">PIN_AddMemoryAddressTransFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#g0411d789e6ec1dbfa0cdf936e91544ab\">MEMORY_ADDR_TRANS_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g0411d789e6ec1dbfa0cdf936e91544ab\">MEMORY_ADDR_TRANS_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g7bd534f9a12e20477ed018b8c3aad531\">PIN_GetMemoryAddressTransFunction</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g4c85e2907788d57d10241d4f8b86a170\">PIN_AddDetachFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gbf9966c96960a9de9bccd39a6b6d6fd7\">DETACH_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gda020c86d21d2c795662ce573c5ca798\">PIN_AddDetachFunctionProbed</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gc0db898ddefe4b25ed1737176ce7c1ef\">DETACH_PROBED_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g0549831d0b423aea93768b1bc491938b\">PIN_AddThreadStartFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#g299a24d8e05412410b32b75b51564081\">THREAD_START_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g9530fbf65d6222a8bc8862abcea26d44\">PIN_AddThreadAttachProbedFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#g73e6d9480c1690536f9a5ed8b14b426c\">THREAD_ATTACH_PROBED_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g348443e6950c5791902323f98dfb9b82\">PIN_AddThreadDetachProbedFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gadb876e9e1ba64a65f73bd87fc9e3c50\">THREAD_DETACH_PROBED_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g4e2be141dc01c0af5120c9394b33f121\">PIN_AddApplicationStartFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#g0f271c9545b0d1b159827e718d1b7f74\">APPLICATION_START_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gc3f2c06e525bd0f23e8aa55f801989df\">PIN_AddThreadFiniFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gaf37c586368c5230ff7fba6c2bfebd01\">THREAD_FINI_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gfe475fc12b9060e8e45cbfccd7d592c8\">PIN_AddContextChangeFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#g78a7c9eeb76f7c94dbfc382ba6a213d1\">CONTEXT_CHANGE_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#gb62f4c93284ca4219f53aa9c4ab4d545\">PIN_AddSyscallEntryFunction</a> (<a class=\"el\" href=\"group__PIN__SYSCALL__API.html#g15a0626027cd595bd1bd2a516118240e\">SYSCALL_ENTRY_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#g8bf568a9177431df0939d478de94bb51\">PIN_AddSyscallExitFunction</a> (<a class=\"el\" href=\"group__PIN__SYSCALL__API.html#g3a481ce6651f7d491e78912bc628d5aa\">SYSCALL_EXIT_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g6a0c20f386b88de45925e3434c52e4ff\">PIN_InterceptSignal</a> (INT32 sig, <a class=\"el\" href=\"group__PIN__CONTROL.html#g2f00e98cd79f80c871f8ac193f9c1ba8\">INTERCEPT_SIGNAL_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g048709607373930698fb578b7150815d\">PIN_UnblockSignal</a> (INT32 sig, BOOL enable)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g05e7e1b3ff0d9b1656dc71a3e861269e\">PIN_AddProbesInsertedFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#g8d5ecf0344c6faa23c1ee38437538f6c\">PROBES_INSERTED_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga141366d36aec81e19f4576de1c3f2e4\">PIN_AddForkFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gb6974c15e664605870435c05a1bf33bd\">FPOINT</a> point, <a class=\"el\" href=\"group__PIN__CONTROL.html#g81f4a1b953b4806f7db51c881f71e80f\">FORK_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gaee2fe5932a3cc759d9968820be6e15d\">PIN_RemoveInstrumentation</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g80c35ab4c9835fa66947ecd50f09fd59\">PIN_RemoveFiniFunctions</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g0f3537980bb5ab3b0411a83426a32370\">PIN_Detach</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g12d2f1c80491b151ce004ba459c5695e\">PIN_DetachProbed</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gcfca774907868814fc1b1fbe3f16e265\">PIN_AttachProbed</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#g7d76d5f60f83d8564bb7d75198055059\">ATTACH_PROBED_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"090ec9903dc8d279786f2869a5277ce3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckAndUpdateCondInstState\" ref=\"090ec9903dc8d279786f2869a5277ce3\" args=\"(char const *typeName, CONDINSTSTATE &amp;lastState, CONDINSTSTATE currState)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CheckAndUpdateCondInstState</b> (char const *typeName, CONDINSTSTATE &amp;lastState, CONDINSTSTATE currState)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#g446df8cbefd4950b78cba7c9e7346053\">INS_InsertPredicatedCall</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> ipoint, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190\">INS_InsertCall</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349\">INS_InsertIfCall</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee\">INS_InsertThenCall</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#ge5fe0d754fe92ae152aa55cc291417fb\">INS_InsertIfPredicatedCall</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#gdc00d6ecae0b6f4e4d48208236e26d20\">INS_InsertThenPredicatedCall</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#e1962eef4545136bbf75ae9d2b81cca7\">AInsertCall</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> ipoint, <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g86f7fb67313713de42a734956e27cf0e\">PREDICATE</a> pred, COND_CALL_TYPE condCallType, AFUNPTR funptr, va_list ap)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#d82bf598bd3fa1a0c810e3befb6b53cb\">AInsertVersionCase</a> (INS ins, <a class=\"el\" href=\"group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641\">REG</a> reg, INT32 case_value, ADDRINT version, va_list ap)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"68a4f1e73c17fcb23778c6dcf8404384\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::StartProgram\" ref=\"68a4f1e73c17fcb23778c6dcf8404384\" args=\"()\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>StartProgram</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9\">PIN_StartProgram</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g7de96e728655962e8ecb4cfe49bd6c2c\">PIN_StartProgramProbed</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a9343dd049e8f62aee5e5a0413a1e7f4\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DumpCharmVersion\" ref=\"a9343dd049e8f62aee5e5a0413a1e7f4\" args=\"()\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DumpCharmVersion</b> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f931b4a6091bde108d175e3e7498f6cd\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobPintoolFamily\" ref=\"f931b4a6091bde108d175e3e7498f6cd\" args=\"(&quot;pintool&quot;,&quot;Pin tools switches&quot;)\" -->\nLOCALVAR KNOB_COMMENT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobPintoolFamily</b> (&quot;pintool&quot;,&quot;Pin tools switches&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"8167faf2951633d0acfeb0c22d7d6d93\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobGeneralFamily\" ref=\"8167faf2951633d0acfeb0c22d7d6d93\" args=\"(&quot;supported&quot;,&quot;General developer switches&quot;)\" -->\nLOCALVAR KNOB_COMMENT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobGeneralFamily</b> (&quot;supported&quot;,&quot;General developer switches&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"05d0576cc65e9286d5b0944bd7b9312b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobBasicFamily\" ref=\"05d0576cc65e9286d5b0944bd7b9312b\" args=\"(&quot;supported:basic&quot;,&quot;Basic switches&quot;)\" -->\nLOCALVAR KNOB_COMMENT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobBasicFamily</b> (&quot;supported:basic&quot;,&quot;Basic switches&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"26600171d8519e3d223b3498a3ebbb42\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobDebugFamily\" ref=\"26600171d8519e3d223b3498a3ebbb42\" args=\"(&quot;supported:debug&quot;,&quot;General switches&quot;)\" -->\nLOCALVAR KNOB_COMMENT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobDebugFamily</b> (&quot;supported:debug&quot;,&quot;General switches&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"fd45c93c66c1f44a95120674b6ddb173\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobMessageFamily\" ref=\"fd45c93c66c1f44a95120674b6ddb173\" args=\"(&quot;supported:message&quot;,&quot;Message switches&quot;)\" -->\nLOCALVAR KNOB_COMMENT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobMessageFamily</b> (&quot;supported:message&quot;,&quot;Message switches&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"953fc6c61c84808e012205e26eac2304\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobRegionFamily\" ref=\"953fc6c61c84808e012205e26eac2304\" args=\"(&quot;supported:region&quot;,&quot;Region generation switches&quot;)\" -->\nLOCALVAR KNOB_COMMENT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobRegionFamily</b> (&quot;supported:region&quot;,&quot;Region generation switches&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"941db7ce1509c31868f8ff429ac3c416\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobRegAllocFamily\" ref=\"941db7ce1509c31868f8ff429ac3c416\" args=\"(&quot;supported:regalloc&quot;,&quot;Register allocation switches&quot;)\" -->\nLOCALVAR KNOB_COMMENT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobRegAllocFamily</b> (&quot;supported:regalloc&quot;,&quot;Register allocation switches&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"949f58e4c23c4489e4deb14d2a496ae0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobLogFile\" ref=\"949f58e4c23c4489e4deb14d2a496ae0\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;logfile&quot;,&quot;pintool.log&quot;,&quot;The log file path and file name&quot;)\" -->\nLOCALVAR KNOB&lt; string &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobLogFile</b> (KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;logfile&quot;,&quot;pintool.log&quot;,&quot;The log file path and file name&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"ce1d103d6cd1f1dc8ecf4345d46ee367\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobUniqueLogFiles\" ref=\"ce1d103d6cd1f1dc8ecf4345d46ee367\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;unique_logfile&quot;,&quot;0&quot;,&quot;The log file names will contain the pid&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobUniqueLogFiles</b> (KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;unique_logfile&quot;,&quot;0&quot;,&quot;The log file names will contain the pid&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"03335b965b6b400c5ec9fd449664bca2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobHelp1\" ref=\"03335b965b6b400c5ec9fd449664bca2\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;help&quot;,&quot;0&quot;,&quot;Print help message (Return failure of PIN_Init() in order to allow the tool\\\n                             to print help message)&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobHelp1</b> (KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;help&quot;,&quot;0&quot;,&quot;Print help message (Return failure of PIN_Init() in order to allow the tool\\\n                             to print help message)&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"d2c8ddd52db56438873925e8de0a42b6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobHelp2\" ref=\"d2c8ddd52db56438873925e8de0a42b6\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;h&quot;,&quot;0&quot;,&quot;Print help message (Return failure of PIN_Init() in order to allow the tool\\\n                             to print help message)&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobHelp2</b> (KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;h&quot;,&quot;0&quot;,&quot;Print help message (Return failure of PIN_Init() in order to allow the tool\\\n                             to print help message)&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">KNOB&lt; BOOL &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#d1783541b0c70d52db9fd54d55d16769\">KnobAppendLogFile</a> (KNOB_MODE_WRITEONCE,&quot;supported&quot;,&quot;append_logfile&quot;,&quot;0&quot;,&quot;Append to the end of the log file if it already exists&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">MESSAGE_TYPE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#6e274b207b131f9e6157c6023beed454\">MessageTypeLogImage</a> (&quot;log_image&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: image API&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">MESSAGE_TYPE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#cf8b2cb915ed32cf036e3a17b8d1dfa2\">MessageTypeLogSym</a> (&quot;log_sym&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: symbol API&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">MESSAGE_TYPE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#b59bf319cf44ea196ca24b52478f7a15\">MessageTypeLogProbe</a> (&quot;log_probe&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: probe information&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">MESSAGE_TYPE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#13d630de596b4fc3308041174feef1b0\">MessageTypeLogBuffer</a> (&quot;log_buffer&quot;,&quot;&quot;, false, false, false, true, LOGTYPE_LOGFILE,&quot;pin log: buffering&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">MESSAGE_TYPE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#5c464fca7e2b11fdcd4d9dfb3bc29908\">MessageTypeLogUnwind</a> (&quot;log_unwind&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: unwind&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">MESSAGE_TYPE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#83ca6b869d18c3e453b18c002a1e7e3e\">MessageTypeLogFetchRtnIns</a> (&quot;log_fetch_rtn_ins&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: fetch rtn ins information&quot;)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g4007a44687f5ac0eb247dd80b8cad5a9\">ParseCommandLine</a> (int xargc, CHAR **xargv)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"52f23913782b408f0c174acfd48c1693\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_ParseCommandLine\" ref=\"52f23913782b408f0c174acfd48c1693\" args=\"(int xargc, CHAR **xargv, BOOL standAlone)\" -->\nLOCALFUN BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PIN_ParseCommandLine</b> (int xargc, CHAR **xargv, BOOL standAlone)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a\">PIN_Init</a> (INT32 argc, CHAR **argv)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#708cf91fa398ebda7d6e0327691cd573\">PIN_SetReplayMode</a> (UINT32 flags)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#9d460e6bc52e1db10ecfee7f106e0852\">TRACE_Allocate</a> (ADDRINT addr)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#bafca7871ec69820b3f557bafd2528f6\">TRACE_AllocateForProbe</a> (PROBE_TYPE probeType, ADDRINT addr, RTN rtn, USIZE probeSize, BOOL mustReadAtLeastProbesizeBytes)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#04c81e8750b01807a367b9d2b4750991\">TRACE_RelocateOriginalInsAddr</a> (ADDRINT addr)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#01f77e8f558750e1868c6fcbb15e2bec\">TRACE_Deallocate</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#4b7e3c774ff39f497b49d6b80d616892\">TRACE_CodeRtn</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g3c4f1f8d29623597e900c140e37d05ac\">TRACE_InsertCall</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#gfb053ca508eae34e6f5133c1586807ad\">TRACE_InsertIfCall</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g77101ac4fea2311c484ff906546f79bf\">TRACE_InsertThenCall</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BBL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g1804f26fc605c9344d57be21b392796b\">TRACE_BblHead</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BBL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g840294a6e7ab1e4400783817516485a6\">TRACE_BblTail</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72eec4cf390f5ef28ba66538ccd4505d\">TRACE_Original</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g16d75a72655e20adb7529796f9b4ac1b\">TRACE_Address</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">USIZE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g3b6c8e9549dc99d2a7b2768906e97101\">TRACE_Size</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#gd7b13b1a5e0fa0942c6eef456b066742\">TRACE_Rtn</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g98cd5e6870b66bf6aab128e3869eb0fb\">TRACE_HasFallThrough</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g8da44516942db541f0ae0aa1d4d92881\">TRACE_NumBbl</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g011b24d5319f8c19f0151755a1378fe5\">TRACE_NumIns</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">USIZE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#gb102072213b6734135b7c63296ac5ee2\">TRACE_StubSize</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#g5fba2db08badc1f77616c8f41ce31884\">BBL_InsertCall</a> (BBL bbl, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#g3e3b3de2bab1f650f39feb7a5d6985ba\">BBL_InsertIfCall</a> (BBL bbl, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#g467686f401830e8b4ea82a4667772bd7\">BBL_InsertThenCall</a> (BBL bbl, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#g1ccfd0a3ac85bbf6d176ca5db7dd9b60\">BBL_HasFallThrough</a> (BBL bbl)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#gad28b770423dddb16678418740c07214\">PIN_SupportsProcessorState</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#g8c2bf0dcc650f916f07bfacf67d1d281\">PROCESSOR_STATE</a> state)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#g17de91853734e5b9ebc49677d5ef34ad\">PIN_ContextContainsState</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__CONTEXT__API.html#g8c2bf0dcc650f916f07bfacf67d1d281\">PROCESSOR_STATE</a> state)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#g4e6408c641479c22918a888d95ca1930\">PIN_SetContextRegval</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641\">REG</a> reg, const UINT8 *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#gd74a7cdb671067c21d184374c453e760\">PIN_GetContextRegval</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641\">REG</a> reg, UINT8 *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga3f8746ccdac1c1fbcb2e2f3f3cd7bcb\">PIN_SetContextReg</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641\">REG</a> reg, ADDRINT val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898\">PIN_GetContextReg</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641\">REG</a> reg)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#g1ecb72b47dc52ed2f5f440d134ce5c33\">PIN_SetContextFPState</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, const FPSTATE *fpstate)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#g614266cd822667f28d9365a40de601be\">PIN_GetContextFPState</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, FPSTATE *fpstate)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#g5eaae6fe4719308c1024a27d37b81be6\">PIN_SaveContext</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxtFrom, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxtTo)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#gc12dbb3ebd227f71a9644733f6faa116\">PIN_ExecuteAt</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#g0130f5b454974d69c69275680ded4a37\">PIN_SetSyscallArgument</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a> std, UINT32 argNum, ADDRINT val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#gd38043f1ae2f1198b7f3b233218593d4\">PIN_GetSyscallArgument</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a> std, UINT32 argNum)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#g441fc7c57ea2f00024e35c8360af6b0d\">PIN_SetSyscallNumber</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a> std, ADDRINT val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#g82342da8cd54d9346482a34303b8317c\">PIN_GetSyscallNumber</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a> std)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#g2b7ff20cfdcb54df003635e693944da1\">PIN_GetSyscallReturn</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a> std)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#g60bdf3d96e07fb6a23628ed731b14e54\">PIN_GetSyscallErrno</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a> std)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#g441ca5bf0e0ef6d63f26a80ef2533508\">PIN_SetPhysicalContextReg</a> (<a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#g5041f3f7591f9ee249b986d2bc2f7d6e\">PHYSICAL_CONTEXT</a> *pPhysCtxt, <a class=\"el\" href=\"group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641\">REG</a> reg, ADDRINT val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#g31b92f00285f47be17e31d2d039e95be\">PIN_GetPhysicalContextReg</a> (const <a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#g5041f3f7591f9ee249b986d2bc2f7d6e\">PHYSICAL_CONTEXT</a> *pPhysCtxt, <a class=\"el\" href=\"group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641\">REG</a> reg)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#ga7093d68c77f656df32e096e198d17e8\">PIN_SetPhysicalContextFPState</a> (<a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#g5041f3f7591f9ee249b986d2bc2f7d6e\">PHYSICAL_CONTEXT</a> *pPhysCtxt, const VOID *fpstate)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#g51be65015e61346fceac3079840f3f5f\">PIN_GetPhysicalContextFPState</a> (const <a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#g5041f3f7591f9ee249b986d2bc2f7d6e\">PHYSICAL_CONTEXT</a> *pPhysCtxt, VOID *fpstate)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__EXCEPTION__API.html#g40302a79ed756094abf1af155b6d3a0b\">PIN_RaiseException</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, const <a class=\"el\" href=\"group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f\">EXCEPTION_INFO</a> *pExceptInfo)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gab34d1953888d943b66400fd065e7af6\">OS_THREAD_ID</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#d96929757b22bc06974749c1c24ea9cd\">PIN_ClientFork</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a2b64629c1958915cc355913419328c6\">PIN_SpawnApplicationThread</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"c663f73d842c625b01cb84f962c04892\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RecordInstructionMutation\" ref=\"c663f73d842c625b01cb84f962c04892\" args=\"(INS ins, EXT ext, BOOL noDuplicates)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RecordInstructionMutation</b> (INS ins, EXT ext, BOOL noDuplicates)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g96e067b52ed9903bb801a45cffb44015\">INS_ChangeMemOpToBaseRegisterAddressMode</a> (INS ins, <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g85141a6f16d6f95209af26fe902fc605\">MEMORY_TYPE</a> mtype, <a class=\"el\" href=\"group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641\">REG</a> newBase)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga0594245179c51098dba5e43bab3256e\">INS_RewriteMemoryAddressingToBaseRegisterOnly</a> (INS ins, <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g85141a6f16d6f95209af26fe902fc605\">MEMORY_TYPE</a> mtype, <a class=\"el\" href=\"group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641\">REG</a> newBase)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__MOD__API__GEN__IA32.html#g9309f9f665d0d01b9c880eeaf2955d33\">INS_RewriteMemoryOperand</a> (INS ins, UINT32 memindex, <a class=\"el\" href=\"group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641\">REG</a> reg)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__MOD__API__GEN__IA32.html#g001c169ec3e061fc6436b63af220d81d\">INS_InsertIndirectJump</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> ipoint, <a class=\"el\" href=\"group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641\">REG</a> reg)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__MOD__API__GEN__IA32.html#g85b5d845590e666a8424e3793a2cdf33\">INS_InsertDirectJump</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> ipoint, ADDRINT tgt)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__MISC.html#gd978a635c336009b30c0ff63d1968c5c\">GetVmLock</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__MISC.html#gbadaea85fb5c97db162fb1dd77dac82a\">ReleaseVmLock</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641\">REG</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__REG__CPU__GENERIC.html#g8ae822ec8bc5d3579bfb6808fa1dd86a\">PIN_ClaimToolRegister</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">CHAR *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gf54dbae6665a47abdc2f7054f2cd6b6e\">PIN_VmFullPath</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">const CHAR *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gb788a5b83d7412f1310dc64b40af6e13\">PIN_ToolFullPath</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__PROCESS__API.html#ga63df44a0d4ff7dcfe501cbc436afd39\">PIN_IsProcessExiting</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">NORETURN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__PROCESS__API.html#ga2093202206f08d8faa12baa4392962e\">PIN_ExitProcess</a> (INT32 exitCode)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">INT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__PROCESS__API.html#ga49549dfe3363154368aa80038463078\">PIN_GetPid</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__MOD__API__GEN__IA32.html#g408da5197af3462940d9d0de25bb886a\">INS_Delete</a> (INS ins)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INST__ARGS.html#g5564adb7924f9239e356b1a4d700e241\">IARGLIST_AddArguments</a> (<a class=\"el\" href=\"group__INST__ARGS.html#g71f6833136d66657723c6630ed144fb8\">IARGLIST</a> args,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__INST__ARGS.html#g71f6833136d66657723c6630ed144fb8\">IARGLIST</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INST__ARGS.html#gc0167c9284b812860e33cb819ebca425\">IARGLIST_Alloc</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INST__ARGS.html#g66e2ac9c1c58e6538ac2342579c2c9bf\">IARGLIST_Free</a> (<a class=\"el\" href=\"group__INST__ARGS.html#g71f6833136d66657723c6630ed144fb8\">IARGLIST</a> args)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">size_t&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g1e6d08632dccfcd10aec3fbdd2562899\">PIN_SafeCopy</a> (VOID *dst, const VOID *src, size_t size)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">size_t&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g5f752650fe59150f3ba7afd2af936c2a\">PIN_SafeCopyEx</a> (VOID *dst, const VOID *src, size_t size, <a class=\"el\" href=\"group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f\">EXCEPTION_INFO</a> *pExceptInfo)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#abf475704acc93da772440427ce1c957\">CheckPinInitialized</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#g4b68e6136fdec6a50269edfa4ff4c977\">INS_InsertFillBuffer</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, BUFFER_ID id,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#g31224df338c699eeb7cb93c27047db5f\">INS_InsertFillBufferPredicated</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, BUFFER_ID id,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#gf1a1306f6844b8ae3b67b2b54c0cf8a5\">INS_InsertFillBufferThen</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, BUFFER_ID id,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#118efddba68a76896a7efe028de9e9e4\">BBL_InsertFillBuffer</a> (BBL bbl, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, BUFFER_ID id,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#29956b8f47051278d5babbab1252fc33\">RTN_InsertFillBuffer</a> (RTN rtn, <a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a> action, BUFFER_ID id,...)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#426859bbbddcd08be80a97aa38022674\">CallBufferFullCallback</a> (BUFFER_ID id, <a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, VOID *buf, UINT64 numElts)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f224a237e6e8dcad6311613fdad47ee0\">CallAllBufferFullCallbacks</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BUFFER_ID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BUFFER__API.html#g16f88ae475a2539bfec3c7ce8b9eb16e\">PIN_DefineTraceBuffer</a> (size_t recordSize, UINT32 numPages, <a class=\"el\" href=\"group__BUFFER__API.html#g2f6bf0657fdea122fa71bd8ff95d9e9b\">TRACE_BUFFER_CALLBACK</a> fun, VOID *val)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BUFFER__API.html#g13114277f4e96e1975a3a93898c12238\">PIN_AllocateBuffer</a> (BUFFER_ID id)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BUFFER__API.html#ga15b74f066828e4a53cf4e985f247c8c\">PIN_DeallocateBuffer</a> (BUFFER_ID id, VOID *buf)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gc738674dfc1a59b17f6af2da7ae083f4\">PIN_IsActionPending</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gc033d720b9d6ccbfc0d5b87d3b083ebb\">PIN_GetInitialThreadCount</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BUFFER__API.html#g1f4f970d91ae257131d0fccabf3e009b\">PIN_GetBufferPointer</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *const ctxt, BUFFER_ID id)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gc15ee36f1352f316aedb01f3c875ff8b\">PIN_CheckReadAccess</a> (VOID *addr)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#g0c6eafad5ef60643bab9426ff4355245\">PIN_CheckWriteAccess</a> (VOID *addr)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab75caaf01908ef2220a2f63918a99f3\">PIN_ReplaySyscallEntry</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a> std)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#8ac057feb5dd33a7669874d438976c4e\">PIN_ReplaySyscallExit</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a> std)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">NORETURN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__PROCESS__API.html#gffd57de20b0bc20da0a0d4c6fdc261bf\">PIN_ExitApplication</a> (INT32 status)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"bd28ec232f6ad3224b264adc4826f16b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ContextChangeReasonName\" ref=\"bd28ec232f6ad3224b264adc4826f16b\" args=\"(CONTEXT_CHANGE_REASON r)\" -->\nLOCALFUN const char *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ContextChangeReasonName</b> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gfa1b03e06c6ab0f86fc2abc1693ce688\">CONTEXT_CHANGE_REASON</a> r)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0b2d6250936b3d9591c2cfda724f4a72\">PIN_ReplayContextChange</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *from, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *to, <a class=\"el\" href=\"group__PIN__CONTROL.html#gfa1b03e06c6ab0f86fc2abc1693ce688\">CONTEXT_CHANGE_REASON</a> reason, INT32 info)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f13f4dc480f3bfa8891c2310fadf578a\">PIN_ReplayImageLoad</a> (const char *imageName, const char *fileName, ADDRINT loadOffset, BOOL mainImage)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0955efae5ae55dc5a33930a85b29b827\">PIN_ReplayImageUnload</a> (IMG img)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#1d8ff737256a9487034f5f3b3ea8e327\">PIN_WasMemoryReservedInLoadTime</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">PIN_CLIENT_STATE &amp;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#3e6f06b5b38aaa73232fe31374844ded\">PinClientState</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"70b79230f0e456be583f02827c4ec32f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PinJitApiNotifyEvent\" ref=\"70b79230f0e456be583f02827c4ec32f\" args=\"(iJIT_JVM_EVENT event_type, void *eventSpecificData)\" -->\nLOCALFUN VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PinJitApiNotifyEvent</b> (iJIT_JVM_EVENT event_type, void *eventSpecificData)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__STOPPED__THREAD__API.html#gbf775f8c2d71daf3ca7449fa7c75f779\">PIN_StopApplicationThreads</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__STOPPED__THREAD__API.html#g365a2410182eb8e292c19a6435f20235\">PIN_IsThreadStoppedInDebugger</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__STOPPED__THREAD__API.html#g2c0269160a38df5ef97930c6082ec9b2\">PIN_ResumeApplicationThreads</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__STOPPED__THREAD__API.html#gd847c6ad6c110ca0c174e0af7d5ceb43\">PIN_GetStoppedThreadCount</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__STOPPED__THREAD__API.html#gcd4cb59ac57b50f57b50f9b25e7a2265\">PIN_GetStoppedThreadId</a> (UINT32 i)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__STOPPED__THREAD__API.html#g634b4ab44bd65932edc6ae415ef7a952\">PIN_GetStoppedThreadContext</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__STOPPED__THREAD__API.html#gd72b1d245293ae95ea177688ae180650\">PIN_GetStoppedThreadWriteableContext</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gab34d1953888d943b66400fd065e7af6\">OS_THREAD_ID</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g59c4b41428ad9d7af82e9f235af116bd\">PIN_GetTid</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g2d4f56d399e36e3cbe5687658d793fec\">PIN_ThreadId</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g4241be5be9711468c54c1a19ee391a01\">PIN_THREAD_UID</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g5d3d91803513a24104400d94943d7124\">PIN_ThreadUid</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gab34d1953888d943b66400fd065e7af6\">OS_THREAD_ID</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g9d69c31157c904d96305a6b2b2c1cda5\">PIN_GetParentTid</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g9b72c188dec1cc5a3866d59e8609b817\">PIN_Sleep</a> (UINT32 milliseconds)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g2fd7cff1385ea64b072ca2d8e1d03b50\">PIN_Yield</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g60cc19335450af20d87bac6378e9ccab\">PIN_SpawnInternalThread</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#gaccb7f72d2ba2b8ed63340421b983b53\">ROOT_THREAD_FUNC</a> *pThreadFunc, VOID *arg, size_t stackSize, <a class=\"el\" href=\"group__PIN__THREAD__API.html#g4241be5be9711468c54c1a19ee391a01\">PIN_THREAD_UID</a> *pThreadUid)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gce25675b629bd147170b228dbe05e2c2\">PIN_ExitThread</a> (INT32 exitCode)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gfd5cff0307f8c70eaa3bff5f8b758969\">PIN_IsApplicationThread</a> ()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gbbbfe111d0087c0e21b8b7bffbc341c5\">PIN_WaitForThreadTermination</a> (const <a class=\"el\" href=\"group__PIN__THREAD__API.html#g4241be5be9711468c54c1a19ee391a01\">PIN_THREAD_UID</a> &amp;threadUid, UINT32 milliseconds, INT32 *pExitCode)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#28e71d973c42f6ca44a77276e600eb27\">PIN_RegisterNewThread</a> (THREAD_CONTEXT *pContext)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g48422bbc491485657227fe94386b964c\">TLS_KEY</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g36b79c1845d1874b1d6fbe7c8e7f3e91\">PIN_CreateThreadDataKey</a> (DESTRUCTFUN destruct_func)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g947459b197106638a20232298b51acf1\">PIN_DeleteThreadDataKey</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g48422bbc491485657227fe94386b964c\">TLS_KEY</a> key)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g1aa594f2e2588a78829ad0c608a55048\">PIN_SetThreadData</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g48422bbc491485657227fe94386b964c\">TLS_KEY</a> key, const VOID *data)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga9c9fc37a23b5088470b95bfaf4819af\">PIN_SetThreadData</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g48422bbc491485657227fe94386b964c\">TLS_KEY</a> key, const VOID *data, <a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadId)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g428ab4182b5fec58ee34b21362774d5f\">PIN_GetThreadData</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g48422bbc491485657227fe94386b964c\">TLS_KEY</a> key)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gb27333aea5e3cbcae826e7fca7768bfc\">PIN_GetThreadData</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#g48422bbc491485657227fe94386b964c\">TLS_KEY</a> key, <a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> threadId)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__VERSION__API.html#g2fced180c997736f54ceaa9a2bf9a673\">BBL_SetTargetVersion</a> (BBL bbl, ADDRINT version)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">ADDRINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__VERSION__API.html#g5a2ccf99020f175d76402e1e571058ab\">TRACE_Version</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">VOID&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__VERSION__API.html#g62f005fa4da982ad464d827b6f1e7a5e\">INS_InsertVersionCase</a> (INS ins, <a class=\"el\" href=\"group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641\">REG</a> reg, INT32 case_value, ADDRINT version,...)</td></tr>\n\n<tr><td colspan=\"2\"><br><h2>Variables</h2></td></tr>\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f6bdd2a9909110852cb8677d0cd1597f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::crc32table\" ref=\"f6bdd2a9909110852cb8677d0cd1597f\" args=\"[]\" -->\nLOCALCONST UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>crc32table</b> []</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"3a0bedec01eec4d86900c88e2ef1d32a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::LOADER_NAME\" ref=\"3a0bedec01eec4d86900c88e2ef1d32a\" args=\"\" -->\nLOCALVAR const CHAR *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>LOADER_NAME</b> = &quot;ld-linux&quot;</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"69e23840989188c08da9baac52ffcae6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::debug_state_func\" ref=\"69e23840989188c08da9baac52ffcae6\" args=\"\" -->\nLOCALVAR const CHAR *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>debug_state_func</b> = &quot;_dl_debug_state&quot;</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"4f2840fcc14c9566b56d9bd6414f5524\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::debug_state_var\" ref=\"4f2840fcc14c9566b56d9bd6414f5524\" args=\"\" -->\nLOCALVAR const CHAR *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>debug_state_var</b> = &quot;_r_debug&quot;</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"c3d3ee277f595a3424c58067b5de882c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::rbrk_ft\" ref=\"c3d3ee277f595a3424c58067b5de882c\" args=\")(void)\" -->\nLOCALTYPE typedef void *(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>rbrk_ft</b> )(void)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"ad1dc525ec500dffc1c0312bdec4adab\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadInScan\" ref=\"ad1dc525ec500dffc1c0312bdec4adab\" args=\"\" -->\nLOCALVAR BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadInScan</b> = FALSE</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"c3fd735db95a819e60ad3da352d598ac\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FORK_PROBE_MODE_CALLBACKVAL\" ref=\"c3fd735db95a819e60ad3da352d598ac\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__PIN__CONTROL.html#gbe792b6e32e9bbb19d51a1f352743a82\">FORK_PROBE_MODE_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FORK_PROBE_MODE_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"049e495d500c8b0bc255644131347641\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FORK_PROBE_MODE_CALLBACKFUNS\" ref=\"049e495d500c8b0bc255644131347641\" args=\"\" -->\nLOCALTYPE typedef FORK_PROBE_MODE_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FORK_PROBE_MODE_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"1eeb0cc4c134ddc7b64f0b8bee81a344\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::forkProbedListBefore\" ref=\"1eeb0cc4c134ddc7b64f0b8bee81a344\" args=\"\" -->\nLOCALVAR FORK_PROBE_MODE_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>forkProbedListBefore</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"41f0756bc6adc8a6103008b8f3df947d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::forkProbedListAfterInParent\" ref=\"41f0756bc6adc8a6103008b8f3df947d\" args=\"\" -->\nLOCALVAR FORK_PROBE_MODE_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>forkProbedListAfterInParent</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"3c1e77d8f9cf357351e871463be4f467\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::forkProbedListAfterInChild\" ref=\"3c1e77d8f9cf357351e871463be4f467\" args=\"\" -->\nLOCALVAR FORK_PROBE_MODE_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>forkProbedListAfterInChild</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"61b95c1219185f10cc2fe7c2acf67348\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FORKFUNCPTR\" ref=\"61b95c1219185f10cc2fe7c2acf67348\" args=\")()\" -->\nLOCALTYPE typedef pid_t(*&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FORKFUNCPTR</b> )()</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"dba881253d5e24761c390c11e9b88494\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::origFork\" ref=\"dba881253d5e24761c390c11e9b88494\" args=\"\" -->\nLOCALVAR FORKFUNCPTR&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>origFork</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"e9f6f3887c167d78ad5c1d59f96ba620\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::getPpidFuncName\" ref=\"e9f6f3887c167d78ad5c1d59f96ba620\" args=\"\" -->\nLOCALVAR const char *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>getPpidFuncName</b> = &quot;getppid&quot;</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"6c3057dd52a0c635134a62270613d65f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::munmapFuncName\" ref=\"6c3057dd52a0c635134a62270613d65f\" args=\"\" -->\nLOCALVAR const char *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>munmapFuncName</b> = &quot;munmap&quot;</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f6578026203f605c7ee955a296784dc2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::forkFuncName\" ref=\"f6578026203f605c7ee955a296784dc2\" args=\"\" -->\nLOCALVAR const char *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>forkFuncName</b> = &quot;__libc_fork&quot;</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"4e0433516c47b4d6cb4459d055020668\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::vforkFuncName\" ref=\"4e0433516c47b4d6cb4459d055020668\" args=\"\" -->\nLOCALVAR const char *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>vforkFuncName</b> = &quot;__vfork&quot;</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"86d93109c026f7a364ad04e5d39d8217\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::errnoLocFuncName\" ref=\"86d93109c026f7a364ad04e5d39d8217\" args=\"\" -->\nLOCALVAR const char *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>errnoLocFuncName</b> = &quot;__errno_location&quot;</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"1b9713233d35f575519a2d329f45f8a9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SymInit\" ref=\"1b9713233d35f575519a2d329f45f8a9\" args=\"\" -->\nLOCALVAR BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SymInit</b> = false</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"916f2dabc257e863280fa821a93201bb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SymMode\" ref=\"916f2dabc257e863280fa821a93201bb\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"group__PIN__CONTROL.html#ga8378cf542c080182b597101ee265983\">SYMBOL_INFO_MODE</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SymMode</b> = NO_SYMBOLS</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"62f698a3e9500c22d635bb3dce6dcb05\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYM_BASIC_INFO\" ref=\"62f698a3e9500c22d635bb3dce6dcb05\" args=\"\" -->\nLOCALTYPE typedef pair&lt; string,<br>\n ADDRINT &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SYM_BASIC_INFO</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"ba3df4a6d3a83d8d95f646446a8855fc\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYMSET_CONST_ITERATOR\" ref=\"ba3df4a6d3a83d8d95f646446a8855fc\" args=\"\" -->\nLOCALTYPE typedef set&lt; SYM_BASIC_INFO <br>\n&gt;::const_iterator&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SYMSET_CONST_ITERATOR</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap><a class=\"anchor\" name=\"7ca61e498048f364864ab34e8a826151\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::sanitizations\" ref=\"7ca61e498048f364864ab34e8a826151\" args=\"[]\" -->\nstruct {</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap>&nbsp;&nbsp;&nbsp;const string&nbsp;&nbsp;&nbsp;<b>name</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap>&nbsp;&nbsp;&nbsp;const string&nbsp;&nbsp;&nbsp;<b>replacement</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap>&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;&nbsp;<b>length</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap valign=\"top\">}&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>sanitizations</b> []</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"cec2ce7ed2940b7e727120800cf0788c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ILIST\" ref=\"cec2ce7ed2940b7e727120800cf0788c\" args=\"\" -->\nLOCALTYPE typedef list&lt; INSTR &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ILIST</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"ea918c9258e57e1a7b59f0cbe40d3330\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMAP\" ref=\"ea918c9258e57e1a7b59f0cbe40d3330\" args=\"\" -->\nLOCALTYPE typedef map&lt; ADDRINT,<br>\n INSTR_INFO &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>IMAP</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"7255a73ddd00572b638ffbd48d3ed3dc\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::imap\" ref=\"7255a73ddd00572b638ffbd48d3ed3dc\" args=\"\" -->\nLOCALVAR IMAP&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>imap</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"3d78d66c482867710387e4328ec8ac6b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_NOARG_CALLBACKVAL\" ref=\"3d78d66c482867710387e4328ec8ac6b\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__CODECACHE__API.html#g0650fbca62cb2b9cbab67e03a167476f\">CODECACHE_NOARG_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CODECACHE_NOARG_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"56d3a4f53212e5bcd5d57f9dfb3c6cac\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_NOARG_CALLBACKFUNS\" ref=\"56d3a4f53212e5bcd5d57f9dfb3c6cac\" args=\"\" -->\nLOCALTYPE typedef CODECACHE_NOARG_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CODECACHE_NOARG_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"dbfb155d1e7193be7742c768f22402e1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::postCacheInitList\" ref=\"dbfb155d1e7193be7742c768f22402e1\" args=\"\" -->\nLOCALVAR CODECACHE_NOARG_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>postCacheInitList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"11e9537f4f0b5df2543b030a3a0860a2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::postCacheFlushList\" ref=\"11e9537f4f0b5df2543b030a3a0860a2\" args=\"\" -->\nLOCALVAR CODECACHE_NOARG_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>postCacheFlushList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a0b149986efc1962a8338857bcdd0b6d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_CACHEBLOCK_CALLBACKVAL\" ref=\"a0b149986efc1962a8338857bcdd0b6d\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__CODECACHE__API.html#g82af67ae80f0e32df5a9e3ea770cf59c\">CODECACHE_CACHEBLOCK_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CODECACHE_CACHEBLOCK_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a6b172b82d50bbe5805ebe0b64095071\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_CACHEBLOCK_CALLBACKFUNS\" ref=\"a6b172b82d50bbe5805ebe0b64095071\" args=\"\" -->\nLOCALTYPE typedef CODECACHE_CACHEBLOCK_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CODECACHE_CACHEBLOCK_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"435e028f02ddb1b43bdeef2ea907aeb5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::cacheBlockCreatedList\" ref=\"435e028f02ddb1b43bdeef2ea907aeb5\" args=\"\" -->\nLOCALVAR CODECACHE_CACHEBLOCK_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>cacheBlockCreatedList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"995397964ac8cd746789201e66aa1f59\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_FULL_CALLBACKVAL\" ref=\"995397964ac8cd746789201e66aa1f59\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__CODECACHE__API.html#gf4feed5d90f646051a5d91b8debf4b9a\">CODECACHE_FULL_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CODECACHE_FULL_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"479d5b7f7350a1a8d1b57ee5e3247250\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_FULL_CALLBACKFUNS\" ref=\"479d5b7f7350a1a8d1b57ee5e3247250\" args=\"\" -->\nLOCALTYPE typedef CODECACHE_FULL_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CODECACHE_FULL_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"19078fa0ca26529db9d9b781e8b3ed2d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::cacheFullList\" ref=\"19078fa0ca26529db9d9b781e8b3ed2d\" args=\"\" -->\nLOCALVAR CODECACHE_FULL_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>cacheFullList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"616ee6badde9f4236bd6781e991bb3a0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::cacheBlockFullList\" ref=\"616ee6badde9f4236bd6781e991bb3a0\" args=\"\" -->\nLOCALVAR CODECACHE_FULL_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>cacheBlockFullList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"2d7d32eb7541f4bead8bde2a61bee65e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_ENTEREXIT_CALLBACKVAL\" ref=\"2d7d32eb7541f4bead8bde2a61bee65e\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__CODECACHE__API.html#ge018fe6a6eb8565b1db1ab6ffa10f9f7\">CODECACHE_ENTEREXIT_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CODECACHE_ENTEREXIT_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a146456ab4844fdc0fcbe6c110782710\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_ENTEREXIT_CALLBACKFUNS\" ref=\"a146456ab4844fdc0fcbe6c110782710\" args=\"\" -->\nLOCALTYPE typedef CODECACHE_ENTEREXIT_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CODECACHE_ENTEREXIT_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"fdc72966d6b181c3cafb2e31b059df9f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::cacheEnterList\" ref=\"fdc72966d6b181c3cafb2e31b059df9f\" args=\"\" -->\nLOCALVAR CODECACHE_ENTEREXIT_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>cacheEnterList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"bcb41efc1796ec8f98adca1ad4dd5887\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::cacheExitList\" ref=\"bcb41efc1796ec8f98adca1ad4dd5887\" args=\"\" -->\nLOCALVAR CODECACHE_ENTEREXIT_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>cacheExitList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"11ecb2c36ea33d83a2825f5cfabc2cb1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_LINKED_CALLBACKVAL\" ref=\"11ecb2c36ea33d83a2825f5cfabc2cb1\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__CODECACHE__API.html#gce17d419e491ef60197773de4e1960ba\">CODECACHE_LINKED_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CODECACHE_LINKED_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"569ab88223bdc444fed8a2e8144108ab\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_LINKED_CALLBACKFUNS\" ref=\"569ab88223bdc444fed8a2e8144108ab\" args=\"\" -->\nLOCALTYPE typedef CODECACHE_LINKED_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CODECACHE_LINKED_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"7455998ca288c7d161440aab8e3e2e91\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::traceLinkedList\" ref=\"7455998ca288c7d161440aab8e3e2e91\" args=\"\" -->\nLOCALVAR CODECACHE_LINKED_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>traceLinkedList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"18d4bced4409183b6a0acd293acb5efe\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_UNLINKED_CALLBACKVAL\" ref=\"18d4bced4409183b6a0acd293acb5efe\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__CODECACHE__API.html#g02318d763590176a9a61b9b49f2fe93c\">CODECACHE_UNLINKED_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CODECACHE_UNLINKED_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a34965234bb0e001121a461859f83f1d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_UNLINKED_CALLBACKFUNS\" ref=\"a34965234bb0e001121a461859f83f1d\" args=\"\" -->\nLOCALTYPE typedef CODECACHE_UNLINKED_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CODECACHE_UNLINKED_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"71c0e4dd88fa650e7dcb07e933a0af81\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::traceUnlinkedList\" ref=\"71c0e4dd88fa650e7dcb07e933a0af81\" args=\"\" -->\nLOCALVAR CODECACHE_UNLINKED_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>traceUnlinkedList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"8cc015c2017e954a8032f1dbab9fae5b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_TRACEINVALIDATED_CALLBACKVAL\" ref=\"8cc015c2017e954a8032f1dbab9fae5b\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__CODECACHE__API.html#g57a902525ea351b9a31440aea9570a13\">CODECACHE_TRACEINVALIDATED_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CODECACHE_TRACEINVALIDATED_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a7d6c7fa0e3b86571441c93544d6aa07\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_TRACEINVALIDATED_CALLBACKFUNS\" ref=\"a7d6c7fa0e3b86571441c93544d6aa07\" args=\"\" -->\nLOCALTYPE typedef CODECACHE_TRACEINVALIDATED_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CODECACHE_TRACEINVALIDATED_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"d46bef4aa39b1b87ec034de85016ce1f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::traceInvalidatedList\" ref=\"d46bef4aa39b1b87ec034de85016ce1f\" args=\"\" -->\nLOCALVAR CODECACHE_TRACEINVALIDATED_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>traceInvalidatedList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"566cb65642ea0ec61f5d6aaf15d36318\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FOLLOW_CHILD_PROCESS_CALLBACKVAL\" ref=\"566cb65642ea0ec61f5d6aaf15d36318\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__CHILD__PROCESS__API.html#gcb01db8476fb5a6b4d86f09a336fe15f\">FOLLOW_CHILD_PROCESS_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FOLLOW_CHILD_PROCESS_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"097f0094ba43ecbf6e24d40c76b80238\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FOLLOW_CHILD_PROCESS_CALLBACKVALFUNS\" ref=\"097f0094ba43ecbf6e24d40c76b80238\" args=\"\" -->\nLOCALTYPE typedef FOLLOW_CHILD_PROCESS_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FOLLOW_CHILD_PROCESS_CALLBACKVALFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"de945beed691057e34172ed15ca1c68c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::followChildProcessList\" ref=\"de945beed691057e34172ed15ca1c68c\" args=\"\" -->\nLOCALVAR FOLLOW_CHILD_PROCESS_CALLBACKVALFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>followChildProcessList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f5fe2ba97b0e90a145ba634e1e56ce9a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DEBUG_INTERPRETER_CALLBACKVAL\" ref=\"f5fe2ba97b0e90a145ba634e1e56ce9a\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__APPDEBUG__API.html#g6dc634ecc9b3b225a7adc1894358dfb3\">DEBUG_INTERPRETER_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DEBUG_INTERPRETER_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"edccccc85902a4e254ed21ec99c3ce72\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DEBUG_INTERPRETER_CALLBACKFUNS\" ref=\"edccccc85902a4e254ed21ec99c3ce72\" args=\"\" -->\nLOCALTYPE typedef DEBUG_INTERPRETER_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DEBUG_INTERPRETER_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"0e69f56cecd56340dc65871097098e95\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::debugInterpreterList\" ref=\"0e69f56cecd56340dc65871097098e95\" args=\"\" -->\nLOCALVAR DEBUG_INTERPRETER_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>debugInterpreterList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"9f80a180144783ef8e09b8c49c74af46\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DEBUG_BREAKPOINT_CALLBACKVAL\" ref=\"9f80a180144783ef8e09b8c49c74af46\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__APPDEBUG__API.html#g4f422159aa53c6ac15e3c4988470ef4c\">DEBUG_BREAKPOINT_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DEBUG_BREAKPOINT_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"2d2ace1fa59ecd9302218e81589d1325\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DEBUG_BREAKPOINT_CALLBACKFUNS\" ref=\"2d2ace1fa59ecd9302218e81589d1325\" args=\"\" -->\nLOCALTYPE typedef DEBUG_BREAKPOINT_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DEBUG_BREAKPOINT_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"c32d46eaff844ae664b895f30d6f2c18\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::debugBreakpointList\" ref=\"c32d46eaff844ae664b895f30d6f2c18\" args=\"\" -->\nLOCALVAR DEBUG_BREAKPOINT_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>debugBreakpointList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"2e52cace42a558dd1291fc3fbead6d72\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INTERCEPT_DEBUGGING_EVENT_CALLBACKVAL\" ref=\"2e52cace42a558dd1291fc3fbead6d72\" args=\"\" -->\nLOCALTYPE typedef SIMPLE_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#97777ec594ce08c91a2f730a75474d0b\">INTERCEPT_DEBUGGING_EVENT_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>INTERCEPT_DEBUGGING_EVENT_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"9bd71df6ed7def5adf2bdf5815dc5c57\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InterceptDebuggingEventBreakpoint\" ref=\"9bd71df6ed7def5adf2bdf5815dc5c57\" args=\"\" -->\nLOCALVAR INTERCEPT_DEBUGGING_EVENT_CALLBACKVAL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>InterceptDebuggingEventBreakpoint</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f8c31c7e2e8c66e088beb46cee71affd\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InterceptDebuggingEventSingleStep\" ref=\"f8c31c7e2e8c66e088beb46cee71affd\" args=\"\" -->\nLOCALVAR INTERCEPT_DEBUGGING_EVENT_CALLBACKVAL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>InterceptDebuggingEventSingleStep</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"7a92cfd69c63142a2dc5281a9286d3e5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InterceptDebuggingEventAsyncBreak\" ref=\"7a92cfd69c63142a2dc5281a9286d3e5\" args=\"\" -->\nLOCALVAR INTERCEPT_DEBUGGING_EVENT_CALLBACKVAL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>InterceptDebuggingEventAsyncBreak</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"5378a51ef269423513afba66a0ca0213\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetEmulatedRegisterCallback\" ref=\"5378a51ef269423513afba66a0ca0213\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad713b5294a122b1b1a6e1ce1612af7d\">GET_EMULATED_REGISTER_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>GetEmulatedRegisterCallback</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"23c7b0cf24afd45e777feda71bdfc16e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SetEmulatedRegisterCallback\" ref=\"23c7b0cf24afd45e777feda71bdfc16e\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#7ef92513d710ad89aa3900aa62a17b60\">SET_EMULATED_REGISTER_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SetEmulatedRegisterCallback</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"3779e8a2bc28adf64f6579c79466d40a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetTargetDescriptionCallback\" ref=\"3779e8a2bc28adf64f6579c79466d40a\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#54e02565dbdab62ea4dc1829c8e7bc34\">GET_TARGET_DESCRIPTION_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>GetTargetDescriptionCallback</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"bfab2e2f9e97d0cc4e0796aa34ba1bae\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::EmulatedRegisterCallbackVal\" ref=\"bfab2e2f9e97d0cc4e0796aa34ba1bae\" args=\"\" -->\nLOCALVAR VOID *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>EmulatedRegisterCallbackVal</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"382e6729b15ead17fb255e9bfc066541\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SIGNAL_BEFORE_CALLBACKVAL\" ref=\"382e6729b15ead17fb255e9bfc066541\" args=\"\" -->\nLOCALTYPE typedef SIMPLE_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#gc79b6ff735d7c369f1954561ee8a5d15\">SIGNAL_BEFORE_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SIGNAL_BEFORE_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"9ea95f56c5ae650ff9fed14465d6e9d2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SIGNAL_BEFORE_CALLBACKFUNS\" ref=\"9ea95f56c5ae650ff9fed14465d6e9d2\" args=\"\" -->\nLOCALTYPE typedef SIGNAL_BEFORE_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SIGNAL_BEFORE_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"dbaf2d468b1c64646d4d38d18a752c5a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::signalBeforeList\" ref=\"dbaf2d468b1c64646d4d38d18a752c5a\" args=\"\" -->\nLOCALVAR SIGNAL_BEFORE_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>signalBeforeList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"0056dfc306a701608ed7d33d1cf07faf\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SIGNAL_AFTER_CALLBACKVAL\" ref=\"0056dfc306a701608ed7d33d1cf07faf\" args=\"\" -->\nLOCALTYPE typedef SIMPLE_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ge95acc4f2b08a2491822c1884428968c\">SIGNAL_AFTER_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SIGNAL_AFTER_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f9f8bb6f173b7098900e16fad018e702\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SIGNAL_AFTER_CALLBACKFUNS\" ref=\"f9f8bb6f173b7098900e16fad018e702\" args=\"\" -->\nLOCALTYPE typedef SIGNAL_AFTER_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SIGNAL_AFTER_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"ad0b78f889a9d47cf2d4337816e93379\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::signalAfterList\" ref=\"ad0b78f889a9d47cf2d4337816e93379\" args=\"\" -->\nLOCALVAR SIGNAL_AFTER_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>signalAfterList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"ce1558d6c2093464d29fef9241efba2c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_BEGIN_CALLBACKVAL\" ref=\"ce1558d6c2093464d29fef9241efba2c\" args=\"\" -->\nLOCALTYPE typedef SIMPLE_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g3fdc760fe71cfaf87705e80ebd882e28\">THREAD_BEGIN_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_BEGIN_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"bfedb11cfc6ee35b368c81c94edc821f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_BEGIN_CALLBACKFUNS\" ref=\"bfedb11cfc6ee35b368c81c94edc821f\" args=\"\" -->\nLOCALTYPE typedef THREAD_BEGIN_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_BEGIN_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"33cc0baff62b330a4ae22034a4fbeb7f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadBeginList\" ref=\"33cc0baff62b330a4ae22034a4fbeb7f\" args=\"\" -->\nLOCALVAR THREAD_BEGIN_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadBeginList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"18a3602adee42e6afabb4a890e3ea3aa\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_END_CALLBACKVAL\" ref=\"18a3602adee42e6afabb4a890e3ea3aa\" args=\"\" -->\nLOCALTYPE typedef SIMPLE_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g0db566a4d0296476e0cc949894a3ad12\">THREAD_END_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_END_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"eff05c2cb4f0916fc840caae4fb3a52a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_END_CALLBACKFUNS\" ref=\"eff05c2cb4f0916fc840caae4fb3a52a\" args=\"\" -->\nLOCALTYPE typedef THREAD_END_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_END_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f08e18a586dee07a33083266b661e24d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadEndList\" ref=\"f08e18a586dee07a33083266b661e24d\" args=\"\" -->\nLOCALVAR THREAD_END_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadEndList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"bccab6008ace3b986d6227c8244ba968\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SIGNAL_INTERCEPT_MAP\" ref=\"bccab6008ace3b986d6227c8244ba968\" args=\"\" -->\nLOCALTYPE typedef std::map&lt;<br>\n int, <a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#g5ae022cf68f790ab7df956253d3536a7\">SIGNAL_INTERCEPT_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SIGNAL_INTERCEPT_MAP</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"d475addc932b26d80f342bc9fad768a3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::signalInterceptMap\" ref=\"d475addc932b26d80f342bc9fad768a3\" args=\"\" -->\nLOCALVAR SIGNAL_INTERCEPT_MAP&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>signalInterceptMap</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"ef8dbc5f42d754e75ccc38e321f85cae\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_PAIR\" ref=\"ef8dbc5f42d754e75ccc38e321f85cae\" args=\"\" -->\nLOCALTYPE typedef pair&lt; RTN_KEY,<br>\n RTN &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_PAIR</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"ac752d1263ecf262923a032da00ad7b5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_MAP\" ref=\"ac752d1263ecf262923a032da00ad7b5\" args=\"\" -->\nLOCALTYPE typedef map&lt; RTN_KEY,<br>\n RTN &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_MAP</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"9b0ccaae799cb1044045baeda3da7297\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::rtn_map\" ref=\"9b0ccaae799cb1044045baeda3da7297\" args=\"\" -->\nLOCALVAR RTN_MAP&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>rtn_map</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"b85861e46ee0da63ebee5b3066950569\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_OUTSIDE_RANGES_LIST\" ref=\"b85861e46ee0da63ebee5b3066950569\" args=\"\" -->\nLOCALTYPE typedef list&lt; MemRange &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_OUTSIDE_RANGES_LIST</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"826121dcd21d3e491896e302b730b4bf\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_OUTSIDE_RANGES_MAP\" ref=\"826121dcd21d3e491896e302b730b4bf\" args=\"\" -->\nLOCALTYPE typedef map&lt; ADDRINT,<br>\n OUTSIDE_TARGET_MEM_RANGE,<br>\n std::less&lt; ADDRINT &gt; &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_OUTSIDE_RANGES_MAP</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"93632b0872c4744e8112f40abc800e92\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_OUTSIDE_TARGETS_MAP\" ref=\"93632b0872c4744e8112f40abc800e92\" args=\"\" -->\nLOCALTYPE typedef map&lt; ADDRINT,<br>\n OUTSIDE_TARGET, std::less&lt;<br>\n ADDRINT &gt; &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_OUTSIDE_TARGETS_MAP</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"08f2151aa6f5d0b90b88eef71847ca98\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_OUTSIDE_PREV_BBLS_MAP\" ref=\"08f2151aa6f5d0b90b88eef71847ca98\" args=\"\" -->\nLOCALTYPE typedef map&lt; ADDRINT,<br>\n BBL, std::less&lt; ADDRINT &gt; &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_OUTSIDE_PREV_BBLS_MAP</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"bc97e7ad17cd039b6bb4fead297b79de\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_UJMP_VECTOR\" ref=\"bc97e7ad17cd039b6bb4fead297b79de\" args=\"\" -->\nLOCALTYPE typedef vector&lt;<br>\n INS &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_UJMP_VECTOR</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"7caa9a4ea64ba35550bc3612cb91cf19\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::WHOLE_TEXT_SECTION\" ref=\"7caa9a4ea64ba35550bc3612cb91cf19\" args=\"\" -->\nLOCALVAR const char *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>WHOLE_TEXT_SECTION</b> = &quot;.text&quot;</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"61731af755be73f1fa03f81af7170194\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::UNNAMED_IMAGE_ENTRY_POINT\" ref=\"61731af755be73f1fa03f81af7170194\" args=\"\" -->\nLOCALVAR const char *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>UNNAMED_IMAGE_ENTRY_POINT</b> = &quot;unnamedImageEntryPoint&quot;</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"ee51791315edcd9bea4b34dbcbeb75b9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMAGECALLBACKVAL\" ref=\"ee51791315edcd9bea4b34dbcbeb75b9\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__IMG__BASIC__API.html#g8861283eeb90cff2839c84ef8bba5802\">IMAGECALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>IMAGECALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"91f8e802ae1c3cb7f00956d73b0f4b51\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMAGECALLBACKFUNS\" ref=\"91f8e802ae1c3cb7f00956d73b0f4b51\" args=\"\" -->\nLOCALTYPE typedef IMAGECALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>IMAGECALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"cdc3973b391c05eaa4c941fa00ad8736\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::imageLoadList\" ref=\"cdc3973b391c05eaa4c941fa00ad8736\" args=\"\" -->\nLOCALVAR IMAGECALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>imageLoadList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"b5d482a30f89fe3de83d4ecde4aee633\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::imageUnloadList\" ref=\"b5d482a30f89fe3de83d4ecde4aee633\" args=\"\" -->\nLOCALVAR IMAGECALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>imageUnloadList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"5de4abe3376c7a2ba5ce8f666ac28b0a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::app\" ref=\"5de4abe3376c7a2ba5ce8f666ac28b0a\" args=\"\" -->\nLOCALVAR APP&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>app</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a2c68ca43719167d5c6a4028b0b439c7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::OpenRtn\" ref=\"a2c68ca43719167d5c6a4028b0b439c7\" args=\"\" -->\nLOCALVAR RTN&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>OpenRtn</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"b25193498eb7942d306a40685e39f821\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::OpenImg\" ref=\"b25193498eb7942d306a40685e39f821\" args=\"\" -->\nLOCALVAR IMG&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>OpenImg</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a7ed07ee139b1869c653621ef1cf46d7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_INSTRUMENT_CALLBACKVAL\" ref=\"a7ed07ee139b1869c653621ef1cf46d7\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__RTN__BASIC__API.html#g36aaf349284bbf9d5dede36061572e1b\">RTN_INSTRUMENT_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_INSTRUMENT_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"b19b52385b74efa7cdf60b189eeaeb02\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_INSTRUMENT_CALLBACKFUNS\" ref=\"b19b52385b74efa7cdf60b189eeaeb02\" args=\"\" -->\nLOCALTYPE typedef RTN_INSTRUMENT_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_INSTRUMENT_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"2eb283852777f144cdf6180757d980cb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::rtnList\" ref=\"2eb283852777f144cdf6180757d980cb\" args=\"\" -->\nLOCALVAR RTN_INSTRUMENT_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>rtnList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"6a2278471d44da678a4d1727121223eb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::savedImageLoadOps\" ref=\"6a2278471d44da678a4d1727121223eb\" args=\"\" -->\nLOCALVAR std::list&lt; IMAGE_LOAD_OP &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>savedImageLoadOps</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f638f949ffe356850cb88af68fb69209\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::savedImageLoadOps2\" ref=\"f638f949ffe356850cb88af68fb69209\" args=\"\" -->\nLOCALVAR std::list&lt; IMAGE_LOAD_OP2 &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>savedImageLoadOps2</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">GLOBALCONST UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#3253ea7060c2ea491bfaf92eede1bd40\">MAX_IEH_CALLBACKS</a> = 32</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"be1d2421a1545c6e24e3332d9ab9b8a9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::rtnHistory\" ref=\"be1d2421a1545c6e24e3332d9ab9b8a9\" args=\"\" -->\nLOCALVAR RTN_CHECK_HISTORY&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>rtnHistory</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALVAR PINCLIENTINT&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ClientIntData</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"5d2dd560e4c5f071de65dd7d0146d37b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_INSTRUMENT_CALLBACKVAL\" ref=\"5d2dd560e4c5f071de65dd7d0146d37b\" args=\"\" -->\nSECTION_END LOCALTYPE typedef <br>\nCOMPLEX_CALLBACKVAL&lt; <a class=\"el\" href=\"group__INS__INST__API.html#gd83539eedf8c29f0603bcb61e8d1df33\">INS_INSTRUMENT_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>INS_INSTRUMENT_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"968a7dae18bee43935a64a87c704631f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_INSTRUMENT_CALLBACKFUNS\" ref=\"968a7dae18bee43935a64a87c704631f\" args=\"\" -->\nLOCALTYPE typedef INS_INSTRUMENT_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>INS_INSTRUMENT_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"726803ef18c394d43fd0dd62f9b05d6c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::insList\" ref=\"726803ef18c394d43fd0dd62f9b05d6c\" args=\"\" -->\nLOCALVAR INS_INSTRUMENT_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>insList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"cfb293c84342373fcf2535bdd9bcbf60\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_INSTRUMENT_CALLBACKVAL\" ref=\"cfb293c84342373fcf2535bdd9bcbf60\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__TRACE__BASIC__API.html#g927e6010210856a2b60b757460e53f15\">TRACE_INSTRUMENT_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>TRACE_INSTRUMENT_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"09b8728f4b19aa1ef24646daad0b4b08\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_INSTRUMENT_CALLBACKFUNS\" ref=\"09b8728f4b19aa1ef24646daad0b4b08\" args=\"\" -->\nLOCALTYPE typedef TRACE_INSTRUMENT_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>TRACE_INSTRUMENT_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"6e3b00d128845813afa839402062c46e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::traceList\" ref=\"6e3b00d128845813afa839402062c46e\" args=\"\" -->\nLOCALVAR TRACE_INSTRUMENT_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>traceList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f316194d0822216be6c1cbd438079e7d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::traceInsertList\" ref=\"f316194d0822216be6c1cbd438079e7d\" args=\"\" -->\nLOCALVAR TRACE_INSTRUMENT_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>traceInsertList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"c5d46918ba57d3d8076d1f171704a494\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::outOfMemoryFun\" ref=\"c5d46918ba57d3d8076d1f171704a494\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"group__PIN__CONTROL.html#gde47352f7f71df0632aa847aae16a274\">OUT_OF_MEMORY_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>outOfMemoryFun</b> = 0</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"0fc9a3e8db943fa3ec358e5a16696063\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::outOfMemoryVal\" ref=\"0fc9a3e8db943fa3ec358e5a16696063\" args=\"\" -->\nLOCALVAR VOID *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>outOfMemoryVal</b> = 0</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a0f73981328004ded28b1f5c0d02e579\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::prepareForAtExitFun\" ref=\"a0f73981328004ded28b1f5c0d02e579\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f3e4861ef8256dcc4048a1e3f9a3ab22\">PREPARE_FOR_ATEXIT_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>prepareForAtExitFun</b> = 0</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"00c4149381e58da5749b49786e961575\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::prepareForAtExitVal\" ref=\"00c4149381e58da5749b49786e961575\" args=\"\" -->\nLOCALVAR VOID *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>prepareForAtExitVal</b> = 0</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"79bc697dd097f4318224a35e80e72204\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::memoryAddrTransFun\" ref=\"79bc697dd097f4318224a35e80e72204\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"group__PIN__CONTROL.html#g0411d789e6ec1dbfa0cdf936e91544ab\">MEMORY_ADDR_TRANS_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>memoryAddrTransFun</b> = 0</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"13215473835605b94a20fa0b3920f00d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::memoryAddrTransVal\" ref=\"13215473835605b94a20fa0b3920f00d\" args=\"\" -->\nLOCALVAR VOID *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>memoryAddrTransVal</b> = 0</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"e390dfa05382317e7d05896b1752cbc9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FINI_CALLBACKVAL\" ref=\"e390dfa05382317e7d05896b1752cbc9\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__PIN__CONTROL.html#gcc77dcacc144b3894f5f0fc13360cdec\">FINI_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FINI_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"c99516a8eefeb3ee451cd04d104e1e18\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FINI_CALLBACKFUNS\" ref=\"c99516a8eefeb3ee451cd04d104e1e18\" args=\"\" -->\nLOCALTYPE typedef FINI_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FINI_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"b07a165324a7d55d2a94e6dd6c3d7ae9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::finiList\" ref=\"b07a165324a7d55d2a94e6dd6c3d7ae9\" args=\"\" -->\nLOCALVAR FINI_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>finiList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"86a96238d6646e619e0e7510f4c92714\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::finiUnlockedList\" ref=\"86a96238d6646e619e0e7510f4c92714\" args=\"\" -->\nLOCALVAR FINI_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>finiUnlockedList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f09343b17aab0aee99446b97359a2a59\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::fetchCallbackFun\" ref=\"f09343b17aab0aee99446b97359a2a59\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"group__PIN__CONTROL.html#gf26c93895c15754aa02c56d41f81f5f4\">FETCH_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>fetchCallbackFun</b> = 0</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"4e0feaa79300eaf652587abe382d8736\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::fetchCallbackVal\" ref=\"4e0feaa79300eaf652587abe382d8736\" args=\"\" -->\nLOCALVAR VOID *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>fetchCallbackVal</b> = 0</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"1df3c7394d7b22cee6b31d5742f931d7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FORK_CALLBACKVAL\" ref=\"1df3c7394d7b22cee6b31d5742f931d7\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__PIN__CONTROL.html#g81f4a1b953b4806f7db51c881f71e80f\">FORK_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FORK_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"ccce735dca5288bcc09c6decf4a9a97c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FORK_CALLBACKFUNS\" ref=\"ccce735dca5288bcc09c6decf4a9a97c\" args=\"\" -->\nLOCALTYPE typedef FORK_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FORK_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"2f5d4d947671b04ddb80bf215fe321c3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::forkListBefore\" ref=\"2f5d4d947671b04ddb80bf215fe321c3\" args=\"\" -->\nLOCALVAR FORK_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>forkListBefore</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a4cf10527638421dfe9c5f10e1f3fbb6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::forkListAfterInParent\" ref=\"a4cf10527638421dfe9c5f10e1f3fbb6\" args=\"\" -->\nLOCALVAR FORK_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>forkListAfterInParent</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"4d7a4155076f9d86169b9d0647a876f4\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::forkListAfterInChild\" ref=\"4d7a4155076f9d86169b9d0647a876f4\" args=\"\" -->\nLOCALVAR FORK_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>forkListAfterInChild</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"8492507146e24ee584304c0e529fcda6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DETACH_CALLBACKVAL\" ref=\"8492507146e24ee584304c0e529fcda6\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__PIN__CONTROL.html#gbf9966c96960a9de9bccd39a6b6d6fd7\">DETACH_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DETACH_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"c39eee4d5ad3a754aa2bb2507e0c512e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DETACH_CALLBACKFUNS\" ref=\"c39eee4d5ad3a754aa2bb2507e0c512e\" args=\"\" -->\nLOCALTYPE typedef DETACH_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DETACH_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"4e0d050da051769913e9721c7c4329c5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::detachList\" ref=\"4e0d050da051769913e9721c7c4329c5\" args=\"\" -->\nLOCALVAR DETACH_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>detachList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"1159cf0423f1732fbab321bf05aa0c00\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DETACH_PROBED_CALLBACKVAL\" ref=\"1159cf0423f1732fbab321bf05aa0c00\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__PIN__CONTROL.html#gc0db898ddefe4b25ed1737176ce7c1ef\">DETACH_PROBED_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DETACH_PROBED_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a71fb31615a4628cc45003efe3fd9b8e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DETACH_PROBED_CALLBACKFUNS\" ref=\"a71fb31615a4628cc45003efe3fd9b8e\" args=\"\" -->\nLOCALTYPE typedef DETACH_PROBED_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DETACH_PROBED_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"6a5dc57b3ec0ccf3754420a6b745ce2a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::detachProbedList\" ref=\"6a5dc57b3ec0ccf3754420a6b745ce2a\" args=\"\" -->\nLOCALVAR DETACH_PROBED_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>detachProbedList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"b259aaa89dbd983221e64c14e0fefab1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::attachProbedFun\" ref=\"b259aaa89dbd983221e64c14e0fefab1\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"group__PIN__CONTROL.html#g7d76d5f60f83d8564bb7d75198055059\">ATTACH_PROBED_CALLBACK</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>attachProbedFun</b> = 0</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"cba023cdfb9f3c1865ec9e55d54ff34c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::attachProbedVal\" ref=\"cba023cdfb9f3c1865ec9e55d54ff34c\" args=\"\" -->\nLOCALVAR VOID *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>attachProbedVal</b> = 0</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"48b7fbaf9a35d391c41a051450171eaa\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::APPLICATION_START_CALLBACKVAL\" ref=\"48b7fbaf9a35d391c41a051450171eaa\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__PIN__CONTROL.html#g0f271c9545b0d1b159827e718d1b7f74\">APPLICATION_START_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>APPLICATION_START_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"d5ce56d5e4bd9317fef9df273a46e7d0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::APPLICATION_START_CALLBACKFUNS\" ref=\"d5ce56d5e4bd9317fef9df273a46e7d0\" args=\"\" -->\nLOCALTYPE typedef APPLICATION_START_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>APPLICATION_START_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"8821051dfdbd1a7f7f79394d16c8f1f9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::appStartList\" ref=\"8821051dfdbd1a7f7f79394d16c8f1f9\" args=\"\" -->\nLOCALVAR APPLICATION_START_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>appStartList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"fcec3fe44116987074d797c80a825941\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_START_CALLBACKVAL\" ref=\"fcec3fe44116987074d797c80a825941\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__PIN__CONTROL.html#g299a24d8e05412410b32b75b51564081\">THREAD_START_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_START_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"b403883da791e67c13381339912443e5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_START_CALLBACKFUNS\" ref=\"b403883da791e67c13381339912443e5\" args=\"\" -->\nLOCALTYPE typedef THREAD_START_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_START_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"c6ca07951325f2cb99dc6ffd04ba1085\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadStartList\" ref=\"c6ca07951325f2cb99dc6ffd04ba1085\" args=\"\" -->\nLOCALVAR THREAD_START_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadStartList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"1b706ed080fc3012db2c11b205c7fa84\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_ATTACH_PROBED_CALLBACKVAL\" ref=\"1b706ed080fc3012db2c11b205c7fa84\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__PIN__CONTROL.html#g73e6d9480c1690536f9a5ed8b14b426c\">THREAD_ATTACH_PROBED_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_ATTACH_PROBED_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"fcc596eb8d248e30b515995c3743bcde\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_ATTACH_PROBED_CALLBACKFUNS\" ref=\"fcc596eb8d248e30b515995c3743bcde\" args=\"\" -->\nLOCALTYPE typedef THREAD_ATTACH_PROBED_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_ATTACH_PROBED_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"17fd9369a8570065e90d891909f24a9e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadAttachProbedList\" ref=\"17fd9369a8570065e90d891909f24a9e\" args=\"\" -->\nLOCALVAR THREAD_ATTACH_PROBED_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadAttachProbedList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a037bd7548d4fb7fcbf09f6f5e49045e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_DETACH_PROBED_CALLBACKVAL\" ref=\"a037bd7548d4fb7fcbf09f6f5e49045e\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__PIN__CONTROL.html#gadb876e9e1ba64a65f73bd87fc9e3c50\">THREAD_DETACH_PROBED_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_DETACH_PROBED_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"fbd46b6ff657f4370063f0455ef3020d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_DETACH_PROBED_CALLBACKFUNS\" ref=\"fbd46b6ff657f4370063f0455ef3020d\" args=\"\" -->\nLOCALTYPE typedef THREAD_DETACH_PROBED_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_DETACH_PROBED_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"95cd2085b3d07ebe69f87d7b58963f9c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadDetachProbedList\" ref=\"95cd2085b3d07ebe69f87d7b58963f9c\" args=\"\" -->\nLOCALVAR THREAD_DETACH_PROBED_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadDetachProbedList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"c0f15d4c93389c9e263d1b0b65ab2b66\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_FINI_CALLBACKVAL\" ref=\"c0f15d4c93389c9e263d1b0b65ab2b66\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__PIN__CONTROL.html#gaf37c586368c5230ff7fba6c2bfebd01\">THREAD_FINI_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_FINI_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"8c68a4e907c41eaf869af85921059756\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_FINI_CALLBACKFUNS\" ref=\"8c68a4e907c41eaf869af85921059756\" args=\"\" -->\nLOCALTYPE typedef THREAD_FINI_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_FINI_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"d30911064fb04e7f5627ccae075b5576\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadFiniList\" ref=\"d30911064fb04e7f5627ccae075b5576\" args=\"\" -->\nLOCALVAR THREAD_FINI_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadFiniList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"69cfb45ff925a36e0a005032ef2641c2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CONTEXT_CHANGE_CALLBACKVAL\" ref=\"69cfb45ff925a36e0a005032ef2641c2\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__PIN__CONTROL.html#g78a7c9eeb76f7c94dbfc382ba6a213d1\">CONTEXT_CHANGE_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CONTEXT_CHANGE_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"5c38bfbeed4d0966863e1a4978d3cdd9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CONTEXT_CHANGE_CALLBACKFUNS\" ref=\"5c38bfbeed4d0966863e1a4978d3cdd9\" args=\"\" -->\nLOCALTYPE typedef CONTEXT_CHANGE_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CONTEXT_CHANGE_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"751380cb0ee2ef84a3a310f726fcc493\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::contextChangeList\" ref=\"751380cb0ee2ef84a3a310f726fcc493\" args=\"\" -->\nLOCALVAR CONTEXT_CHANGE_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>contextChangeList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"8c8669a4b8b7cd1c0ea7344b56ecf128\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYSCALL_ENTRY_CALLBACKVAL\" ref=\"8c8669a4b8b7cd1c0ea7344b56ecf128\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__PIN__SYSCALL__API.html#g15a0626027cd595bd1bd2a516118240e\">SYSCALL_ENTRY_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SYSCALL_ENTRY_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"bb89d6327b54ad4a5ac59cbe8a1e9a2a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYSCALL_ENTRY_CALLBACKFUNS\" ref=\"bb89d6327b54ad4a5ac59cbe8a1e9a2a\" args=\"\" -->\nLOCALTYPE typedef SYSCALL_ENTRY_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SYSCALL_ENTRY_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"d96f479138976379b7b9a7cefec2af53\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::syscallEntryList\" ref=\"d96f479138976379b7b9a7cefec2af53\" args=\"\" -->\nLOCALVAR SYSCALL_ENTRY_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>syscallEntryList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"1a600061addadffaff5bf18c71852199\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYSCALL_EXIT_CALLBACKVAL\" ref=\"1a600061addadffaff5bf18c71852199\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__PIN__SYSCALL__API.html#g3a481ce6651f7d491e78912bc628d5aa\">SYSCALL_EXIT_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SYSCALL_EXIT_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"911de0680a278336382b17f8feef32fd\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYSCALL_EXIT_CALLBACKFUNS\" ref=\"911de0680a278336382b17f8feef32fd\" args=\"\" -->\nLOCALTYPE typedef SYSCALL_EXIT_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SYSCALL_EXIT_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"bd9f1cffc7198d3294aa245c70d9a066\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::syscallExitList\" ref=\"bd9f1cffc7198d3294aa245c70d9a066\" args=\"\" -->\nLOCALVAR SYSCALL_EXIT_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>syscallExitList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"b2cb24fc556ef79e656223a027f93644\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INTERCEPT_SIGNAL_CALLBACKVAL\" ref=\"b2cb24fc556ef79e656223a027f93644\" args=\"\" -->\nLOCALTYPE typedef SIMPLE_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__PIN__CONTROL.html#g2f00e98cd79f80c871f8ac193f9c1ba8\">INTERCEPT_SIGNAL_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>INTERCEPT_SIGNAL_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"290e1ec9c24417a9bff2599ea2ba0a5e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INTERCEPT_SIGNAL_MAP\" ref=\"290e1ec9c24417a9bff2599ea2ba0a5e\" args=\"\" -->\nLOCALTYPE typedef std::map&lt;<br>\n int, INTERCEPT_SIGNAL_CALLBACKVAL &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>INTERCEPT_SIGNAL_MAP</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a712a3aaf61143b06be7ada418e08f08\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::interceptSignalMap\" ref=\"a712a3aaf61143b06be7ada418e08f08\" args=\"\" -->\nLOCALVAR INTERCEPT_SIGNAL_MAP&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>interceptSignalMap</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"74a383ee391de591af7d4209a3193d85\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PROBES_INSERTED_CALLBACKVAL\" ref=\"74a383ee391de591af7d4209a3193d85\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__PIN__CONTROL.html#g8d5ecf0344c6faa23c1ee38437538f6c\">PROBES_INSERTED_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PROBES_INSERTED_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"ae1faf1fb999770785e72b48cabeadb0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PROBES_INSERTED_CALLBACKFUNS\" ref=\"ae1faf1fb999770785e72b48cabeadb0\" args=\"\" -->\nLOCALTYPE typedef PROBES_INSERTED_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PROBES_INSERTED_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"6a83971fd787ad77f73c22f35f252b38\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::probesInsertedList\" ref=\"6a83971fd787ad77f73c22f35f252b38\" args=\"\" -->\nLOCALVAR PROBES_INSERTED_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>probesInsertedList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"ff714c180ffc5f9570e2edb2d35fae0c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_BUFFER_CALLBACKVAL\" ref=\"ff714c180ffc5f9570e2edb2d35fae0c\" args=\"\" -->\nLOCALTYPE typedef SIMPLE_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__BUFFER__API.html#g2f6bf0657fdea122fa71bd8ff95d9e9b\">TRACE_BUFFER_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>TRACE_BUFFER_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"e6c9ef380265b4f5e4ea9b23cdfec789\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_BUFFER_CALLBACK_MAP\" ref=\"e6c9ef380265b4f5e4ea9b23cdfec789\" args=\"\" -->\nLOCALTYPE typedef std::map&lt;<br>\n BUFFER_ID, TRACE_BUFFER_CALLBACKVAL &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>TRACE_BUFFER_CALLBACK_MAP</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"488c3fdcbee6b8f3320d2a0bd3f90dd5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::traceBufferCallbackMap\" ref=\"488c3fdcbee6b8f3320d2a0bd3f90dd5\" args=\"\" -->\nLOCALVAR TRACE_BUFFER_CALLBACK_MAP&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>traceBufferCallbackMap</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"f5fe2ba97b0e90a145ba634e1e56ce9a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DEBUG_INTERPRETER_CALLBACKVAL\" ref=\"f5fe2ba97b0e90a145ba634e1e56ce9a\" args=\"\" -->\nLOCALTYPE typedef COMPLEX_CALLBACKVAL&lt;<br>\n <a class=\"el\" href=\"group__APPDEBUG__API.html#g6dc634ecc9b3b225a7adc1894358dfb3\">DEBUG_INTERPRETER_CALLBACK</a> &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DEBUG_INTERPRETER_CALLBACKVAL</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"edccccc85902a4e254ed21ec99c3ce72\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DEBUG_INTERPRETER_CALLBACKFUNS\" ref=\"edccccc85902a4e254ed21ec99c3ce72\" args=\"\" -->\nLOCALTYPE typedef DEBUG_INTERPRETER_CALLBACKVAL::FUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DEBUG_INTERPRETER_CALLBACKFUNS</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"0e69f56cecd56340dc65871097098e95\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::debugInterpreterList\" ref=\"0e69f56cecd56340dc65871097098e95\" args=\"\" -->\nLOCALVAR DEBUG_INTERPRETER_CALLBACKFUNS&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>debugInterpreterList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"098be2b6fcaed9bddfea275925aea5d5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::addrReferences\" ref=\"098be2b6fcaed9bddfea275925aea5d5\" args=\"\" -->\nLOCALVAR set&lt; ADDRINT, less&lt;<br>\n ADDRINT &gt; &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>addrReferences</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"0784ce6711760eb11da7c31e3de2164c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::replayModeFlags\" ref=\"0784ce6711760eb11da7c31e3de2164c\" args=\"\" -->\nLOCALVAR UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>replayModeFlags</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"99d4710d84e1a83dd95e9ef6ad045fae\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ToolArgc\" ref=\"99d4710d84e1a83dd95e9ef6ad045fae\" args=\"\" -->\nLOCALVAR INT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ToolArgc</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"cef9f6d597e2f547806e3805e627b27e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ToolArgv\" ref=\"cef9f6d597e2f547806e3805e627b27e\" args=\"\" -->\nLOCALVAR CHAR **&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ToolArgv</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"e4be1c94403842572e87dda27dac7844\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IsProcessExiting\" ref=\"e4be1c94403842572e87dda27dac7844\" args=\"\" -->\nLOCALVAR volatile BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>IsProcessExiting</b> = FALSE</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"998a8eae8a7fd009878529bda9363645\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IdOfThreadInFiniCallback\" ref=\"998a8eae8a7fd009878529bda9363645\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"group__PIN__THREAD__API.html#gab34d1953888d943b66400fd065e7af6\">OS_THREAD_ID</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>IdOfThreadInFiniCallback</b> = 0</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"a5f43d2d702629297b4b61067d2e49aa\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PinClientMutex\" ref=\"a5f43d2d702629297b4b61067d2e49aa\" args=\"\" -->\nLOCALVAR PIN_CLIENT_MUTEX&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PinClientMutex</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"3943f6cbc5b80869e8e9a92047d3d6c4\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::inTraceCallbacks\" ref=\"3943f6cbc5b80869e8e9a92047d3d6c4\" args=\"\" -->\nLOCALVAR BOOL&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>inTraceCallbacks</b> = FALSE</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"3cf04a3586e6862fa8308b315d912fce\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::replacedFunList\" ref=\"3cf04a3586e6862fa8308b315d912fce\" args=\"\" -->\nLOCALVAR REPLACEDFUN::LIST&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>replacedFunList</b></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"8133e036f0b05c7206085cc3af9f18dc\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::condInstStateForIns\" ref=\"8133e036f0b05c7206085cc3af9f18dc\" args=\"\" -->\nLOCALVAR CONDINSTSTATE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>condInstStateForIns</b> = CONDINST_NORMAL</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"0c13229ad5c0c281afbadc6d2b480a66\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::insLastIfPredicate\" ref=\"0c13229ad5c0c281afbadc6d2b480a66\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g86f7fb67313713de42a734956e27cf0e\">PREDICATE</a>&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>insLastIfPredicate</b> = PREDICATE_ALWAYS_TRUE</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"bf87bd979f3573f64eebbbb27fc7b82e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::condInstStateForTrace\" ref=\"bf87bd979f3573f64eebbbb27fc7b82e\" args=\"\" -->\nLOCALVAR CONDINSTSTATE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>condInstStateForTrace</b> = CONDINST_NORMAL</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\"><a class=\"anchor\" name=\"5d676d9c7406c01791ff4721dd940ee3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::condInstStateForBbl\" ref=\"5d676d9c7406c01791ff4721dd940ee3\" args=\"\" -->\nLOCALVAR CONDINSTSTATE&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><b>condInstStateForBbl</b> = CONDINST_NORMAL</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">GLOBALCONST UINT32&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g96c05dc507e6d0f7e5c2a235ccac442b\">MAX_CLIENT_TLS_KEYS</a> = (TLS_KEY_CLIENT_LAST - TLS_KEY_CLIENT_FIRST + 1)</td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALTYPE typedef TLS_KEY_ALLOCATOR&lt;<br>\n TLS_KEY_CLIENT_FIRST, TLS_KEY_CLIENT_LAST &gt;&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#78e750d35a09d252068994a9fd401172\">CLIENT_TLS_KEY_ALLOCATOR</a></td></tr>\n\n<tr><td class=\"memItemLeft\" nowrap align=\"right\" valign=\"top\">LOCALVAR <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#78e750d35a09d252068994a9fd401172\">CLIENT_TLS_KEY_ALLOCATOR</a> *&nbsp;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#66ef7fa2888f0aed01b601057cccbc95\">pClientTlsKeyAllocator</a></td></tr>\n\n</table>\n<hr><a name=\"_details\"></a><h2>Detailed Description</h2>\nPIN DWARF debugging information using libpindwarf (LLVM based) library \n<p>\n<hr><h2>Typedef Documentation</h2>\n<a class=\"anchor\" name=\"0eefbda43523c1adaff6dd670372cdff\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODE_RANGES\" ref=\"0eefbda43523c1adaff6dd670372cdff\" args=\"\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">typedef map&lt;ADDRINT, USIZE&gt; <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0eefbda43523c1adaff6dd670372cdff\">LEVEL_PINCLIENT::CODE_RANGES</a>          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nMap of code ranges in image. Key is base address of code range, Value is size of the range.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"ad713b5294a122b1b1a6e1ce1612af7d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GET_EMULATED_REGISTER_CALLBACK\" ref=\"ad713b5294a122b1b1a6e1ce1612af7d\" args=\")(unsigned toolRegId, THREADID tid, CONTEXT *ctxt, VOID *data, VOID *v)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">typedef VOID(* <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad713b5294a122b1b1a6e1ce1612af7d\">LEVEL_PINCLIENT::GET_EMULATED_REGISTER_CALLBACK</a>)(unsigned toolRegId, <a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, VOID *data, VOID *v)          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall-back function that Pin calls to get the value of a register emulated by the tool.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>toolRegId</em>&nbsp;</td><td>Identifies the emulated register (from the <em>registerDescriptions</em> parameter to <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#68a4173dc9649381353502748f429c9d\">PIN_AddDebuggerRegisterEmulator()</a>). </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>tid</em>&nbsp;</td><td>Identifies the thread whose register is read. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>ctxt</em>&nbsp;</td><td>Architected register state for the thread. </td></tr>\n    <tr><td valign=\"top\"><tt>[out]</tt>&nbsp;</td><td valign=\"top\"><em>data</em>&nbsp;</td><td>Points to a buffer that receives the value of the register. The value must be stored in little-endian format (least significant bytes first). If the register size is not an even multiple of bytes, the upper bits of the last byte (most significant byte) are unused. If the register size is 2, 4, or 8 bytes, <em>data</em> is naturally aligned, so it may be cast to a pointer of the appropriate type. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"54e02565dbdab62ea4dc1829c8e7bc34\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GET_TARGET_DESCRIPTION_CALLBACK\" ref=\"54e02565dbdab62ea4dc1829c8e7bc34\" args=\")(const std::string &amp;name, USIZE size, VOID *buf, VOID *v)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">typedef USIZE(* <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#54e02565dbdab62ea4dc1829c8e7bc34\">LEVEL_PINCLIENT::GET_TARGET_DESCRIPTION_CALLBACK</a>)(const std::string &amp;name, USIZE size, VOID *buf, VOID *v)          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall-back function that Pin calls to get the content of a document that describes an emulated target processor to an application-level debugger. This is useful, for example, when a Pin tool emulates additional registers beyond those defined by the native CPU. A debugger can use this document to understand the emulated registers and how to display them.<p>\nThe format of the returned document varies depending on the debugger that is connected to Pin. Tools can use <a class=\"el\" href=\"group__APPDEBUG__API.html#gde1f6df906e38d64c1e19a1a4eb76c7c\">PIN_GetDebuggerType()</a> to tell which debugger is connected.<p>\nWhen used with GDB, the description should be an XML \"target feature\" document, as described in the GDB user manual, \"Debugging With GDB\". See the appendix titled \"Target Descriptions\" for details of the XML document format. GDB starts by asking for a document titled \"target.xml\". However, this document may reference other documents via \"include\" statements. If so, GDB will ask for those additional documents by their names.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>name</em>&nbsp;</td><td>The name of the requested document. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>size</em>&nbsp;</td><td>Size (bytes) of the <em>buf</em> buffer. </td></tr>\n    <tr><td valign=\"top\"><tt>[out]</tt>&nbsp;</td><td valign=\"top\"><em>buf</em>&nbsp;</td><td>Points to a buffer that receives the content of the document. If the document requires more than <em>size</em> bytes, the tool need not write anything into <em>buf</em>. Instead, the tool should return the required size. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>v</em>&nbsp;</td><td>The tool's call-back value.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>If the tool knows how to provide the document named <em>name</em>, it returns the size (bytes) of that document. If that size is less than or equal to <em>size</em>, the tool should also write the content of the document to <em>buf</em>. If the tool does not know how to provide this document, it should return zero. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"97777ec594ce08c91a2f730a75474d0b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INTERCEPT_DEBUGGING_EVENT_CALLBACK\" ref=\"97777ec594ce08c91a2f730a75474d0b\" args=\")(THREADID tid, DEBUGGING_EVENT eventType, CONTEXT *ctxt, VOID *arg)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">typedef BOOL(* <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#97777ec594ce08c91a2f730a75474d0b\">LEVEL_PINCLIENT::INTERCEPT_DEBUGGING_EVENT_CALLBACK</a>)(<a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, DEBUGGING_EVENT eventType, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, VOID *arg)          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall-back function when the tool intercepts a debugging event with <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#afb41af0a98f375df6bc3aa244f03f45\">PIN_InterceptDebuggingEvent()</a>.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>tid</em>&nbsp;</td><td>The Pin thread ID of the thread that received the debugging event. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>eventType</em>&nbsp;</td><td>Tells the debugging event. </td></tr>\n    <tr><td valign=\"top\"><tt>[in,out]</tt>&nbsp;</td><td valign=\"top\"><em>ctxt</em>&nbsp;</td><td>On input, gives the register state at the point the thread received the event. The tool may change <em>ctxt</em>. If the event is passed on to the debugger, the debugger sees the modified register state. If the event is not passed on to the debugger, the thread resumes execution at the new register state. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>arg</em>&nbsp;</td><td>The tool's call-back value.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>Returning TRUE tells Pin to pass the debugging event on to the debugger. Returning FALSE tells Pin to squash the event and the thread resumes without stopping in the debugger.</dd></dl>\nThe following scenarios are not allowed:<p>\n<ul>\n<li>The call-back may not return FALSE for DEBUGGING_EVENT_ASYNC_BREAK.</li><li>If the call-back returns TRUE for DEBUGGING_EVENT_BREAKPOINT or DEBUGGING_EVENT_SINGLE_STEP, it may not change the value of REG_INST_PC in <em>ctxt</em>. This restriction exists because debuggers typically make assumptions on the PC value when these events trigger. </li></ul>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"f3e4861ef8256dcc4048a1e3f9a3ab22\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PREPARE_FOR_ATEXIT_CALLBACK\" ref=\"f3e4861ef8256dcc4048a1e3f9a3ab22\" args=\")(VOID *v)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">typedef VOID(* <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f3e4861ef8256dcc4048a1e3f9a3ab22\">LEVEL_PINCLIENT::PREPARE_FOR_ATEXIT_CALLBACK</a>)(VOID *v)          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall back function when pin is about to call NtTerminateProcess. The function that is registered by this callback should do the following:<ul>\n<li>Kill all the internal threads of the tool without using the Pin API (i.e. - return from the main function of the thread is fine, but calling Pin_ExitThread is not.) Pin will wait until all the internal threads were killed before it will continue to run. This function can be registered via <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#959335effb5aa746d6e3bf35af66b6de\">PIN_AddPrepareForAtExitFunction()</a>.</li></ul>\n<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>size</em>&nbsp;</td><td>Size of the failed allocation </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>v</em>&nbsp;</td><td>The tool's call-back value </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"7ef92513d710ad89aa3900aa62a17b60\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SET_EMULATED_REGISTER_CALLBACK\" ref=\"7ef92513d710ad89aa3900aa62a17b60\" args=\")(unsigned toolRegId, THREADID tid, CONTEXT *ctxt, const VOID *data, VOID *v)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">typedef VOID(* <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#7ef92513d710ad89aa3900aa62a17b60\">LEVEL_PINCLIENT::SET_EMULATED_REGISTER_CALLBACK</a>)(unsigned toolRegId, <a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *ctxt, const VOID *data, VOID *v)          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall-back function that Pin calls to set the value of a register emulated by the tool.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>toolRegId</em>&nbsp;</td><td>Identifies the emulated register (from the <em>registerDescriptions</em> parameter to <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#68a4173dc9649381353502748f429c9d\">PIN_AddDebuggerRegisterEmulator()</a>). </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>tid</em>&nbsp;</td><td>Identifies the thread whose register is written. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>ctxt</em>&nbsp;</td><td>Architected register state for the thread. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>data</em>&nbsp;</td><td>Points to the new value for the register. The value is stored in the same format as described in GET_EMULATED_REGISTER_CALLBACK. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"064f1cffbe0833f653a0220e012e31c1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP\" ref=\"064f1cffbe0833f653a0220e012e31c1\" args=\"\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">typedef map&lt;SYM, ADDRINT&gt; <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#064f1cffbe0833f653a0220e012e31c1\">LEVEL_PINCLIENT::SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP</a>          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis map is used during the ifunc symbol processing. It maps between ifunc symbol names and the actual function addresses which doesn't have a symbol associated with them.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"fd62761063369139ae3c774377bf2c09\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACEGENCODE_CALLBACK\" ref=\"fd62761063369139ae3c774377bf2c09\" args=\")(TRACE trace, VOID *v)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">typedef VOID(* <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#fd62761063369139ae3c774377bf2c09\">LEVEL_PINCLIENT::TRACEGENCODE_CALLBACK</a>)(<a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> trace, VOID *v)          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall back function when Pin has to generate a rogue trace for an exit     </td>\n  </tr>\n</table>\n<hr><h2>Enumeration Type Documentation</h2>\n<a class=\"anchor\" name=\"df75eedebfc8cc39ead3d00ada244a07\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::@0\" ref=\"df75eedebfc8cc39ead3d00ada244a07\" args=\"\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">anonymous enum          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nKeys to access client data in the thread local storage     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"d3a7912bbf9ba48adc6493e196774ead\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMAGE_LOAD_FLAGS\" ref=\"d3a7912bbf9ba48adc6493e196774ead\" args=\"\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">enum <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#d3a7912bbf9ba48adc6493e196774ead\">LEVEL_PINCLIENT::IMAGE_LOAD_FLAGS</a>          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nNames for flags to construct the arguments to ProcessImageLoad and ImgLoad Without these you get a list of cryptic BOOL arguments; by using these you see what the arguments being passed mean. <dl compact><dt><b>Enumerator: </b></dt><dd>\n<table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n<tr><td valign=\"top\"><em><a class=\"anchor\" name=\"d3a7912bbf9ba48adc6493e196774ead2cf518944068a3b505a8a3720bb44bea\"></a><!-- doxytag: member=\"IMAGE_LOAD_MAINEXECUTABLE\" ref=\"d3a7912bbf9ba48adc6493e196774ead2cf518944068a3b505a8a3720bb44bea\" args=\"\" -->IMAGE_LOAD_MAINEXECUTABLE</em>&nbsp;</td><td>\nSet for the main executable. </td></tr>\n<tr><td valign=\"top\"><em><a class=\"anchor\" name=\"d3a7912bbf9ba48adc6493e196774ead14f0362884823626e98f723c97050325\"></a><!-- doxytag: member=\"IMAGE_LOAD_FOUNDINMEMORY\" ref=\"d3a7912bbf9ba48adc6493e196774ead14f0362884823626e98f723c97050325\" args=\"\" -->IMAGE_LOAD_FOUNDINMEMORY</em>&nbsp;</td><td>\nSet if the image was found in memory during Pin initalization (only Windows at present) </td></tr>\n<tr><td valign=\"top\"><em><a class=\"anchor\" name=\"d3a7912bbf9ba48adc6493e196774eadecda4dd661a0561b92863205eff7343d\"></a><!-- doxytag: member=\"IMAGE_LOAD_RUNTIME\" ref=\"d3a7912bbf9ba48adc6493e196774eadecda4dd661a0561b92863205eff7343d\" args=\"\" -->IMAGE_LOAD_RUNTIME</em>&nbsp;</td><td>\nSet if the image was loaded at runtime. </td></tr>\n<tr><td valign=\"top\"><em><a class=\"anchor\" name=\"d3a7912bbf9ba48adc6493e196774eadd4f1673728d121f373736e02c3bde78d\"></a><!-- doxytag: member=\"IMAGE_LOAD_TEXTFROMIMAGE\" ref=\"d3a7912bbf9ba48adc6493e196774eadd4f1673728d121f373736e02c3bde78d\" args=\"\" -->IMAGE_LOAD_TEXTFROMIMAGE</em>&nbsp;</td><td>\nSet if RTNs should get their code from Pin's copy of the image, rather than the one mapped by the OS. (For replay where the OS' one may not exist yet). </td></tr>\n</table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"f171c445e32ac6109fe8b63ef99fef45\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::REPLAY_MODE\" ref=\"f171c445e32ac6109fe8b63ef99fef45\" args=\"\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">enum <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f171c445e32ac6109fe8b63ef99fef45\">LEVEL_PINCLIENT::REPLAY_MODE</a>          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nFlags passed to PIN_SetReplayMode. <dl compact><dt><b>Enumerator: </b></dt><dd>\n<table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n<tr><td valign=\"top\"><em><a class=\"anchor\" name=\"f171c445e32ac6109fe8b63ef99fef455a7da031e019cd68d30f0a968d818412\"></a><!-- doxytag: member=\"REPLAY_MODE_IMAGEOPS\" ref=\"f171c445e32ac6109fe8b63ef99fef455a7da031e019cd68d30f0a968d818412\" args=\"\" -->REPLAY_MODE_IMAGEOPS</em>&nbsp;</td><td>\nReplayer will handle image ops. </td></tr>\n</table>\n</dl>\n    </td>\n  </tr>\n</table>\n<hr><h2>Function Documentation</h2>\n<a class=\"anchor\" name=\"e1962eef4545136bbf75ae9d2b81cca7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AInsertCall\" ref=\"e1962eef4545136bbf75ae9d2b81cca7\" args=\"(INS ins, IPOINT ipoint, PREDICATE pred, COND_CALL_TYPE condCallType, AFUNPTR funptr, va_list ap)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::AInsertCall           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INS&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ipoint</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g86f7fb67313713de42a734956e27cf0e\">PREDICATE</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>pred</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>COND_CALL_TYPE&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>condCallType</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>AFUNPTR&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>funptr</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>va_list&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ap</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nIf \"condFun\" is non-zero, then this analysis call will be invoked only if condFun (which is an analysis function called immediately before \"funptr\") returns a non-zero value.<p>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux, Windows &amp; MacOS<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"d82bf598bd3fa1a0c810e3befb6b53cb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AInsertVersionCase\" ref=\"d82bf598bd3fa1a0c810e3befb6b53cb\" args=\"(INS ins, REG reg, INT32 case_value, ADDRINT version, va_list ap)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::AInsertVersionCase           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INS&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641\">REG</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>reg</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>INT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>case_value</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>version</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>va_list&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ap</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux, Windows &amp; MacOS<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"783309f729f772c5b75875881515fc68\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AotiInstrumentationExists\" ref=\"783309f729f772c5b75875881515fc68\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::AotiInstrumentationExists           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nTRUE if there are any AOTI requests. Only used for an assertion to check that all AOTI has been cleared when all images are unloaded.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"87a72d53166313658044d1966b7eca76\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AotiPlaybackCall\" ref=\"87a72d53166313658044d1966b7eca76\" args=\"(INS ins)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::AotiPlaybackCall           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INS&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>ins</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nx internal     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"0dbf3e856092db68f58e8b5dca1727fa\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AotiRecordCall\" ref=\"0dbf3e856092db68f58e8b5dca1727fa\" args=\"(IPOINT action, INS ins, ACALL const *acall)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::AotiRecordCall           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>action</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>INS&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ACALL const *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>acall</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nx internal     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"fcdfcaf9b73d23639eb2831182b70919\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AotiRecordMutation\" ref=\"fcdfcaf9b73d23639eb2831182b70919\" args=\"(INS ins, EXT ext)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::AotiRecordMutation           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INS&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>EXT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ext</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nx internal     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"e364d214bd4f5d2698f6608fa5f19568\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AotiRemoveImageInstrumentation\" ref=\"e364d214bd4f5d2698f6608fa5f19568\" args=\"(IMG img)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::AotiRemoveImageInstrumentation           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>img</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nRemove any AOTI that has been applied to instructions in the given image.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"118efddba68a76896a7efe028de9e9e4\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::BBL_InsertFillBuffer\" ref=\"118efddba68a76896a7efe028de9e9e4\" args=\"(BBL bbl, IPOINT action, BUFFER_ID id,...)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::BBL_InsertFillBuffer           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">BBL&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>bbl</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>action</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>BUFFER_ID&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>id</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>...</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nInsert analysis code to fill one record in a trace buffer, relative to a BBL.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>bbl</em>&nbsp;</td><td>The application BBL </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>action</em>&nbsp;</td><td>Whether the record is filled before or after the BBL </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>id</em>&nbsp;</td><td>The ID of the buffer whose record is filled </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>...</em>&nbsp;</td><td><a class=\"el\" href=\"group__INST__ARGS.html#g7e2c955c99fa84246bb2bce1525b5681\">IARG_TYPE</a>. Additional arguments to specify the fields of the trace buffer.</td></tr>\n  </table>\n</dl>\nCertain IARG_TYPEs cannot be used with the *_InsertFillBuffer APIs. The unsupported IARG_TYPEs are: IARG_CONTEXT, IARG_REG_REFERENCE, and IARG_REG_CONST_REFERENCE.<p>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux &amp; Windows<br>\n <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"f65d5d63926fc7cf54a842e11f6b037b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::BBL_InvalidForProbe\" ref=\"f65d5d63926fc7cf54a842e11f6b037b\" args=\"(BBL bbl)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::BBL_InvalidForProbe           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">BBL&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>bbl</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis routine tests whether the basic block can be replaced with probe The function return TRUE when the basic block has a problem<ul>\n<li>bb size &lt; probe size</li><li>a call instruction is inside bbl and its return address is inside the probe </li></ul>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"01bb22507bfb96558a4b8f3f35e23abf\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::BBL_Type\" ref=\"01bb22507bfb96558a4b8f3f35e23abf\" args=\"(BBL x)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BBL_TYPE LEVEL_PINCLIENT::BBL_Type           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">BBL&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>x</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<dl compact><dt><b>Returns:</b></dt><dd>The type of the basic block </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"d4a791e2d1da0a57f243770d37b336f9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::BeginInstrumentedExecution\" ref=\"d4a791e2d1da0a57f243770d37b336f9\" args=\"(RTN rtn)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::BeginInstrumentedExecution           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">RTN&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>rtn</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nInsert a probe into the PIN_ExecuteInstrumented routine in the application to transition from original code execution to jitted code execution     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"f224a237e6e8dcad6311613fdad47ee0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallAllBufferFullCallbacks\" ref=\"f224a237e6e8dcad6311613fdad47ee0\" args=\"(THREADID tid, CONTEXT *ctxt)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::CallAllBufferFullCallbacks           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCalls all of the buffer full functions in turn. Generally, this is useful when a thread terminates, since that's the only time we definitely will call all of the buffer full callbacks.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"1ee401916e8d1cb8ef4a38e1b4ba61e1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallApplicationStart\" ref=\"1ee401916e8d1cb8ef4a38e1b4ba61e1\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::CallApplicationStart           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<ul>\n<li>Notify VM about application start</li><li>Call application start callback functions </li></ul>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"22048f762db39a31919bd90986959395\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallBreakpointHandlers\" ref=\"22048f762db39a31919bd90986959395\" args=\"(ADDRINT, UINT, BOOL)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN BOOL LEVEL_PINCLIENT::CallBreakpointHandlers           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>addr</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>UINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>size</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>BOOL&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>insert</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall any breakpoint handlers to handle a breakpoint set/delete command.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>addr</em>&nbsp;</td><td>The address of the requested breakpoint. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>size</em>&nbsp;</td><td>The size of the breakpoint (HW/SW) </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>insert</em>&nbsp;</td><td>Whether if this is a breakpoint insertion or deletion.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>TRUE if any handler takes control over the breakpoint. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"426859bbbddcd08be80a97aa38022674\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallBufferFullCallback\" ref=\"426859bbbddcd08be80a97aa38022674\" args=\"(BUFFER_ID id, THREADID tid, CONTEXT *ctxt, VOID *buf, UINT64 numElts)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID* LEVEL_PINCLIENT::CallBufferFullCallback           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">BUFFER_ID&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>id</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>VOID *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>buf</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>UINT64&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>numElts</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCalls the buffer full function (as specified by PIN_DefineTraceBuffer) when either the buffer is full or the thread terminates.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>id</em>&nbsp;</td><td>The ID of the trace buffer. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>tid</em>&nbsp;</td><td>The ID of the thread whose buffer filled </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>buf</em>&nbsp;</td><td>Pointer to the base of the filled buffer </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>numElts</em>&nbsp;</td><td>Number of elements in buffer </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"17ab278ab99de9ead236d4c6e0008bcd\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallContextChanges\" ref=\"17ab278ab99de9ead236d4c6e0008bcd\" args=\"(THREADID threadIndex, CONTEXT_CHANGE_REASON reason, const CONTEXT *from, CONTEXT *to, INT32 info)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::CallContextChanges           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__PIN__CONTROL.html#gfa1b03e06c6ab0f86fc2abc1693ce688\">CONTEXT_CHANGE_REASON</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>reason</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>from</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>to</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>INT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>info</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall context change callbacks.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"5a46741b62b9f4c816db8e18a8a0d150\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallDebugInterpreters\" ref=\"5a46741b62b9f4c816db8e18a8a0d150\" args=\"(THREADID, CONTEXT *, const char *, const char **)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN BOOL LEVEL_PINCLIENT::CallDebugInterpreters           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const char *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>cmd</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const char **&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>reply</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall any debug interpreters to handle a debugger command.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>threadIndex</em>&nbsp;</td><td>Pin thread ID of debugger focus thread. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>ctxt</em>&nbsp;</td><td>Application register state of focus thread, which could be changed. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>cmd</em>&nbsp;</td><td>Debugger command. </td></tr>\n    <tr><td valign=\"top\"><tt>[out]</tt>&nbsp;</td><td valign=\"top\"><em>reply</em>&nbsp;</td><td>Receives a pointer to the command's response, if it is handled.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>TRUE if any interpreter handles <em>cmd</em>. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"6060fbdaa7a8efcfa5a709995cb52199\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallDetachCompletionCallback\" ref=\"6060fbdaa7a8efcfa5a709995cb52199\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::CallDetachCompletionCallback           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall detach probed completion callbacks. When this callback function is called, it is guaranteed that Pin removed all probes from the application code and that no other callback function will be called afterwards (except from additional Detach callback functions).     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"56fc6a403835656fae9147a1cda535d3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallFinis\" ref=\"56fc6a403835656fae9147a1cda535d3\" args=\"(INT32 code)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::CallFinis           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INT32&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>code</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nx     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"9ced1d383167e4d5e2f6123254766a99\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallFollowChildProcess\" ref=\"9ced1d383167e4d5e2f6123254766a99\" args=\"(CHILD_PROCESS childProcess, const char **toolAppend)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN BOOL LEVEL_PINCLIENT::CallFollowChildProcess           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__CHILD__PROCESS__API.html#g104e2b5e1bfd80e62cb3cd8f50ddfdf2\">CHILD_PROCESS</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>childProcess</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const char **&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>toolAppend</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall Follow child process callback<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>childProcess</em>&nbsp;</td><td>Child process handle </td></tr>\n    <tr><td valign=\"top\"><tt>[out]</tt>&nbsp;</td><td valign=\"top\"><em>toolAppend</em>&nbsp;</td><td>If Pin should automatically add the \"KnobAppendLogFile\" switch to the tool's command line, <em>toolAppend</em> is set to the name of that switch. If the switch should not be automatically added, it is set to NULL.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>TRUE If user is interested to inject Pin (and tool) into child/exec-ed process<br>\n FALSE If user is not interested to inject Pin (and tool) into child/exec-ed process<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"2a13d5cf30fbcb2f8194ec75836cb9f2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallForksAfterInChild\" ref=\"2a13d5cf30fbcb2f8194ec75836cb9f2\" args=\"(THREADID threadId, const CONTEXT *ctxt)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::CallForksAfterInChild           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>threadId</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nnotify child after fork     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"3de9a7cbd6c702df4ba562a32cd6165c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallForksAfterInParent\" ref=\"3de9a7cbd6c702df4ba562a32cd6165c\" args=\"(THREADID threadId, const CONTEXT *ctxt)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::CallForksAfterInParent           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>threadId</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nnotify parent after fork     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"27adc4c4cc6e22c387c375df93a9a1ad\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallForksBefore\" ref=\"27adc4c4cc6e22c387c375df93a9a1ad\" args=\"(THREADID threadId, const CONTEXT *ctxt)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::CallForksBefore           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>threadId</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nnotify before fork     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"08a9eabff055b1d30459070adb2e4b9a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallInterceptedDebuggingEvent\" ref=\"08a9eabff055b1d30459070adb2e4b9a\" args=\"(THREADID, DEBUGGING_EVENT, CONTEXT *)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN BOOL LEVEL_PINCLIENT::CallInterceptedDebuggingEvent           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>DEBUGGING_EVENT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>eventType</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall a client debugging event interceptor function.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>tid</em>&nbsp;</td><td>Thread that received the debugging event. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>eventType</em>&nbsp;</td><td>Tells the debugging event. </td></tr>\n    <tr><td valign=\"top\"><tt>[in,out]</tt>&nbsp;</td><td valign=\"top\"><em>ctxt</em>&nbsp;</td><td>Register state when the event was received, which the tool can modify.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>TRUE tells Pin to pass the even on to the debugger, FALSE tells Pin to squash the event.</dd></dl>\n<dl compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"469d71cab4d59deef1b4d7beaf3cd556\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallInterceptSignal\" ref=\"469d71cab4d59deef1b4d7beaf3cd556\" args=\"(THREADID tid, INT32 sig, CONTEXT *ctxt, BOOL hasHandler, const EXCEPTION_INFO *pExceptInfo)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN BOOL LEVEL_PINCLIENT::CallInterceptSignal           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>INT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>sig</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>BOOL&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>hasHandler</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const <a class=\"el\" href=\"group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f\">EXCEPTION_INFO</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>pExceptInfo</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall signal \"intercept\" callbacks. Returns TRUE if signal should be passed on to the application.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"5965a0281ced35efbe4b244d44adcef5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallMemoryAddrTrans\" ref=\"5965a0281ced35efbe4b244d44adcef5\" args=\"(PIN_MEM_TRANS_INFO *memTransInfo, void *)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN ADDRINT PIN_FAST_ANALYSIS_CALL LEVEL_PINCLIENT::CallMemoryAddrTrans           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">PIN_MEM_TRANS_INFO *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>memTransInfo</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>void *&nbsp;</td>\n          <td class=\"mdname\" nowrap></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nTools callback function to tell PIN to use a different memory address.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"e6e689fcac512324250b55cd596aa09d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallProbesInserted\" ref=\"e6e689fcac512324250b55cd596aa09d\" args=\"(IMG img)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::CallProbesInserted           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>img</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall callbacks when Pin is done inserting probes.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"066e24528cd7ad167763af54d18bc758\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallRtnCallbacks\" ref=\"066e24528cd7ad167763af54d18bc758\" args=\"(RTN rtn)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::CallRtnCallbacks           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">RTN&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>rtn</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCalls all rtn callbacks for given routine     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"64ed417090d21ba01ed3a2d07c72c6c8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallSyscallEntry\" ref=\"64ed417090d21ba01ed3a2d07c72c6c8\" args=\"(THREADID threadIndex, CONTEXT *ctxt, SYSCALL_STANDARD std)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::CallSyscallEntry           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>std</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall syscall entry callbacks.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"d17e30fa7d197523bbef1342295bc70f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallSyscallExit\" ref=\"d17e30fa7d197523bbef1342295bc70f\" args=\"(THREADID threadIndex, CONTEXT *ctxt, SYSCALL_STANDARD std)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::CallSyscallExit           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>std</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall syscall exit callbacks.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"55e1adf45f6c5bb11518f7611383753b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallThreadAttachInProbeMode\" ref=\"55e1adf45f6c5bb11518f7611383753b\" args=\"(VOID *sigmask)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::CallThreadAttachInProbeMode           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">VOID *&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>sigmask</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall attached thread callback in probe mode     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"3d292327538fdf8e828df2b964458ec7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallThreadDetachInProbeMode\" ref=\"3d292327538fdf8e828df2b964458ec7\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::CallThreadDetachInProbeMode           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall detach thread callback in probe mode <dl compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"6cd3583ef487f57d31c0423f279af440\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallThreadFinis\" ref=\"6cd3583ef487f57d31c0423f279af440\" args=\"(THREADID threadIndex, const CONTEXT *ctxt, INT32 code)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::CallThreadFinis           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>INT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>code</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall Thread Fini callbacks     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"f487fb472b83c554466bf3a6c270a036\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallThreadStarts\" ref=\"f487fb472b83c554466bf3a6c270a036\" args=\"(THREADID threadIndex, CONTEXT *ctxt, INT32 flags)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::CallThreadStarts           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>INT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>flags</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall Thread Start callbacks     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"7e85b1d8759aa15306d7a6c865ba2a40\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallTraceCallbacks\" ref=\"7e85b1d8759aa15306d7a6c865ba2a40\" args=\"(REGION *region)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::CallTraceCallbacks           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">REGION *&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>region</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nWalk the list of trace instrumentors and call them     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"68b8a7d4fcf85183f5a4d66246d45063\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CatchEndInstrumentation\" ref=\"68b8a7d4fcf85183f5a4d66246d45063\" args=\"(TRACE trace)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::CatchEndInstrumentation           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>trace</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nIf this is a call to PIN_ExecuteUninstrumented, then transfer control to original code     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"bfd6c9c3b418cd0af8daacece35396a3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckNoCodeCacheCallbacks\" ref=\"bfd6c9c3b418cd0af8daacece35396a3\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::CheckNoCodeCacheCallbacks           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCheck that no code-cache callback was registered     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"95adcb0e41b514c219a7f3c15c549c12\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckNotInCallback\" ref=\"95adcb0e41b514c219a7f3c15c549c12\" args=\"(THREADID tid, const char *function)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::CheckNotInCallback           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const char *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>function</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCheck that a Pin client user interface call has been made from an analysis function, not a callback. <dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>tid</em>&nbsp;</td><td>Thread ID of the thread making the call </td></tr>\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>function</em>&nbsp;</td><td>Name of the interface function being called</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux, Windows, BSD<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"949153c3d46f3d7077acae3a6b56881e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckPinClientLock\" ref=\"949153c3d46f3d7077acae3a6b56881e\" args=\"(const CHAR *funname)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::CheckPinClientLock           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">const CHAR *&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>funname</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCheck that we have the client lock.<p>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>\n <b>O/S</b>: Linux, Windows &amp; MacOS<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"abf475704acc93da772440427ce1c957\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckPinInitialized\" ref=\"abf475704acc93da772440427ce1c957\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::CheckPinInitialized           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nRaise an error if pin has not been initialized. Call this from pin api functions to ensure that <a class=\"el\" href=\"group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a\">PIN_Init()</a> has been called first.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"dd8e5edcd2496eeca4d27e2ba85009bf\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ClientInt\" ref=\"dd8e5edcd2496eeca4d27e2ba85009bf\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">GLOBALDLLFUN PINCLIENTINT* LEVEL_PINCLIENT::ClientInt           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nx     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"e2c225e7228027d1257a3704c15ec985\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ClientIntC\" ref=\"e2c225e7228027d1257a3704c15ec985\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">GLOBALDLLCFUN PINCLIENTINT* LEVEL_PINCLIENT::ClientIntC           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nx     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"1b9ed6947b61e58a030bde3c4bbc22fd\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::Close_Rtn\" ref=\"1b9ed6947b61e58a030bde3c4bbc22fd\" args=\"(RTN rtn)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::Close_Rtn           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">RTN&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>rtn</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nClose the given RTN.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"b115c9a18cef7092f2d83c80e6ca1a5f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_AddFullBlockFunction\" ref=\"b115c9a18cef7092f2d83c80e6ca1a5f\" args=\"(CODECACHE_FULL_CALLBACK fun, VOID *val)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074\">PIN_CALLBACK</a> LEVEL_PINCLIENT::CODECACHE_AddFullBlockFunction           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__CODECACHE__API.html#gf4feed5d90f646051a5d91b8debf4b9a\">CODECACHE_FULL_CALLBACK</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>fun</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>VOID *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>val</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nAdds a function that gets called whenever a cache block fills up.<p>\n<dl compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>\n<dl compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux, Windows &amp; MacOS<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"e561a040d0010efa4dbf5c4076e9f95b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_FlushBlock\" ref=\"e561a040d0010efa4dbf5c4076e9f95b\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::CODECACHE_FlushBlock           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis routine flushes a given cache block, and removes the relevant inter-block links <dl compact><dt><b>Returns:</b></dt><dd>Boolean success if the given block was successfully flushed </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"4e15e2ab7462fc49c315279f7a04ced3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_InvalidateTraceAtCacheAddress\" ref=\"4e15e2ab7462fc49c315279f7a04ced3\" args=\"(ADDRINT cache_pc)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::CODECACHE_InvalidateTraceAtCacheAddress           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">ADDRINT&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>cache_pc</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nInvalidates the trace starting at the given code cache address <dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>cache_pc</em>&nbsp;</td><td>The code cache address (must be the start of a trace) </td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>Success if trace exists at location indicated and is invalidated</dd></dl>\n<dl compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux, Windows &amp; MacOS<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"f5a8107215aae47136ebb16b74441ca8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_NumHits\" ref=\"f5a8107215aae47136ebb16b74441ca8\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">UINT32 LEVEL_PINCLIENT::CODECACHE_NumHits           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<dl compact><dt><b>Returns:</b></dt><dd>Number of code cache hits </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"7f2c708ab4eece407bf8049ff64f9382\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_NumMisses\" ref=\"7f2c708ab4eece407bf8049ff64f9382\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">UINT32 LEVEL_PINCLIENT::CODECACHE_NumMisses           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<dl compact><dt><b>Returns:</b></dt><dd>Number of code cache misses </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"e25f772eb23640ed41aa6d8032ccf7c0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODECACHE_NumTracesInBlock\" ref=\"e25f772eb23640ed41aa6d8032ccf7c0\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">UINT32 LEVEL_PINCLIENT::CODECACHE_NumTracesInBlock           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<dl compact><dt><b>Returns:</b></dt><dd>Number of traces in the given code cache block</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux, Windows &amp; MacOS<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"e743e5fcb67304db3aa325a5df3c2325\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CompleteImageLoad\" ref=\"e743e5fcb67304db3aa325a5df3c2325\" args=\"(IMG img, void *arg)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::CompleteImageLoad           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>void *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>arg</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nWhen the application loads a new image, do some bookeeping.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"fde19488ce7dbdda6777aa19412c7c01\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CompleteProbesInstrumentationForCurrentModule\" ref=\"fde19488ce7dbdda6777aa19412c7c01\" args=\"(IMG img)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::CompleteProbesInstrumentationForCurrentModule           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>img</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nIn probes mode, if the user inserted any calls, generate the code now. This was not done during ImageLoad() because users can insert several calls on one RTN. This method restricts users to inserting probes in ImageLoad(). This is OK, because it is the only thread- safe place to do it.<p>\nRegister all unwind frames     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"9e7ad6d2c910db2984d9784843991425\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CookRegsym\" ref=\"9e7ad6d2c910db2984d9784843991425\" args=\"(IMG img, SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP *sym_resolver_vs_actual_address_ifunc_map)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::CookRegsym           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>sym_resolver_vs_actual_address_ifunc_map</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\ncook .symtab, like IMG_CookRegsym, but less error checking so it won't assert on valid images name_vs_actual_address_ifunc_map is a temporary data structure which is used during the processing of ifunc symbols. Contains only ifunc symbols that their corresponding actual function addresses don't have a symbol which is associated with them. This map will be processed afterwards by the function: \"CreateRtnOriginatedFromIfunc\", where an rtn object will be created for each instance in the map.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"87a1d90748ddeabcb8be3ead165f8c07\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DebuggerClientInitialize\" ref=\"87a1d90748ddeabcb8be3ead165f8c07\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::DebuggerClientInitialize           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nInitialize the client library call-backs for the application-level debugger API's.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"a698f1be08bcc9a9625e4cbcd945254e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DeleteRtnCheckHistory\" ref=\"a698f1be08bcc9a9625e4cbcd945254e\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::DeleteRtnCheckHistory           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nClear history of routine check     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"420b29c16e7549c18b9ed34dec3ce1df\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DeprecatedCallSignalAfters\" ref=\"420b29c16e7549c18b9ed34dec3ce1df\" args=\"(THREADID threadIndex, const CONTEXT *from, const CONTEXT *to)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::DeprecatedCallSignalAfters           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>from</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>to</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall signal \"after\" callbacks.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"2058c68dbd07ef6f628abd0c313ea269\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DeprecatedCallSignalBefores\" ref=\"2058c68dbd07ef6f628abd0c313ea269\" args=\"(THREADID threadIndex, INT32 sig, const CONTEXT *from, const CONTEXT *to)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::DeprecatedCallSignalBefores           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>INT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>sig</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>from</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>to</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall signal \"before\" callbacks.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"9271d8c3ee45a76adfdcf97856ebac63\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DeprecatedCallThreadBegins\" ref=\"9271d8c3ee45a76adfdcf97856ebac63\" args=\"(THREADID threadIndex, VOID *sp, int flags)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::DeprecatedCallThreadBegins           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>VOID *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>sp</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>int&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>flags</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall thread \"begin\" callbacks.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"0f54f522b4e20fbaea714ca2d4726a4b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DeprecatedCallThreadEnds\" ref=\"0f54f522b4e20fbaea714ca2d4726a4b\" args=\"(THREADID threadIndex, INT32 code)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::DeprecatedCallThreadEnds           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>INT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>code</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall thread \"end\" callbacks.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"55b7d6706f050de3e48d6cecdbd1cefc\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DestroyClientTls\" ref=\"55b7d6706f050de3e48d6cecdbd1cefc\" args=\"(THREADID threadIndex)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::DestroyClientTls           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>threadIndex</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nDestroy client TLS in the given thread. <dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>threadIndex</em>&nbsp;</td><td>ID of the target thread </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"7752482ea13c862c244fb7cb51e8df4b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DisassembleRegion\" ref=\"7752482ea13c862c244fb7cb51e8df4b\" args=\"(RTN rtn, BBL bbl, const VOID *current, const VOID *end, ADDRINT rtnStart, ADDRINT rtnEnd, ADDRINT virtual_offset)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::DisassembleRegion           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">RTN&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>BBL&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>bbl</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const VOID *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>current</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const VOID *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>end</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>rtnStart</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>rtnEnd</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>virtual_offset</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nRtnOutsideRangesManager().HaveRet()     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"b79119368e922f4a3fe34c36cf5ce45e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoAttachsProbed\" ref=\"b79119368e922f4a3fe34c36cf5ce45e\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::DoAttachsProbed           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nPerfrom probed attach operations     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"d3c2482a4d8c345aad3d7531044c35aa\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoDetachs\" ref=\"d3c2482a4d8c345aad3d7531044c35aa\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::DoDetachs           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nWalk the list of detach functions     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"94e4fe3219a4c9a7965d20e19eb59bdb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoDetachsProbed\" ref=\"94e4fe3219a4c9a7965d20e19eb59bdb\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::DoDetachsProbed           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nOn Linux distributions, this function is called by the dedicated thread. It is called when all of the thread detach callbacks from all the application threads have been given. On non Linux distributions, this function is called by the dedicated detach thread while all of the application threads are stopped. The function performs:<ul>\n<li>Remove callbacks and probes.</li><li>Unload all images (and ask to remove probes),</li><li>Set pin state to be detached.,</li><li>Call the detach completion callbacks(Only on non linux).</li><li>Notify about detach completion (Only on non linux). </li></ul>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"17e7e55f60e8f37076ef126c4988c2e5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::EDG_INVALID\" ref=\"17e7e55f60e8f37076ef126c4988c2e5\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">EDG LEVEL_PINCLIENT::EDG_INVALID           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<dl compact><dt><b>Returns:</b></dt><dd>An invalid edge </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"3a7e85c10450b8477f8bf83069a771aa\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::EDG_NextSucc\" ref=\"3a7e85c10450b8477f8bf83069a771aa\" args=\"(EDG x)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">EDG LEVEL_PINCLIENT::EDG_NextSucc           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">EDG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>x</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<dl compact><dt><b>Returns:</b></dt><dd>The next successor edge </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"98af1008c26ca6c3afe99daec2df5d48\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::EDG_Type\" ref=\"98af1008c26ca6c3afe99daec2df5d48\" args=\"(EDG x)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">EDG_TYPE LEVEL_PINCLIENT::EDG_Type           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">EDG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>x</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<dl compact><dt><b>Returns:</b></dt><dd>The type of the edge </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"3a11abd329135a8864c2d84114a7561c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::EDG_Valid\" ref=\"3a11abd329135a8864c2d84114a7561c\" args=\"(EDG x)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::EDG_Valid           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">EDG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>x</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<dl compact><dt><b>Returns:</b></dt><dd>True if x is not <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#17e7e55f60e8f37076ef126c4988c2e5\">EDG_INVALID()</a> </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"f1296a8c20facdb8e54640748fedc0ed\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::EmulateExecvProbed\" ref=\"f1296a8c20facdb8e54640748fedc0ed\" args=\"(ADDRINT arg0, ADDRINT arg1, ADDRINT arg2, ADDRINT errnoLocationFptr)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">INT LEVEL_PINCLIENT::EmulateExecvProbed           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>arg0</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>arg1</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>arg2</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>errnoLocationFptr</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nEmulation of execve system call in Probe mode The function does not return if execve succeeds<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>arg0</em>&nbsp;</td><td>first parameter to exec </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>arg1</em>&nbsp;</td><td>second parameter to exec </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>arg2</em>&nbsp;</td><td>third parameter to exec </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>errnoLocationFptr</em>&nbsp;</td><td>a pointer to errno. This field should be filled if execve fails</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>one of the following: (1) - no return - execve succeeded (2) - ret is 0 - no emulation for execve, execute it natively (3) - ret is not 0 execve was emulated and failed, continue the current process </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"e452842da6146745fbc83214f0783c53\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::EnterPinClientMasterMode\" ref=\"e452842da6146745fbc83214f0783c53\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::EnterPinClientMasterMode           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThe VM has called into the pin client     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"3987af32238008426ac922ae09682692\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ExitPinClientMasterMode\" ref=\"3987af32238008426ac922ae09682692\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::ExitPinClientMasterMode           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nReturning from pin client to VM     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"1da8803f4e53cf500efbcc2b68d265e8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FindCodeRanges\" ref=\"1da8803f4e53cf500efbcc2b68d265e8\" args=\"(IMG img, CODE_RANGES *rangeMap)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::FindCodeRanges           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>CODE_RANGES *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>rangeMap</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nFind all code ranges in binary image according to information from image headers.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"20cd15d62787677dcb26da903ce17dfd\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FindGnuDebugLinkFile\" ref=\"20cd15d62787677dcb26da903ce17dfd\" args=\"(IMG img, CHAR **imageStart, size_t *imageSize)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">string LEVEL_PINCLIENT::FindGnuDebugLinkFile           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>CHAR **&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>imageStart</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>size_t *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>imageSize</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nFind the filename of a .gnu_debug_link section. Return the filename of the debug link and an open file descriptor for it.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"685681f02994155a16dd1f8b4cd3a808\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetCurrentSysId\" ref=\"685681f02994155a16dd1f8b4cd3a808\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALINLINE <a class=\"el\" href=\"group__PIN__THREAD__API.html#gab34d1953888d943b66400fd065e7af6\">OS_THREAD_ID</a> LEVEL_PINCLIENT::GetCurrentSysId           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<dl compact><dt><b>Returns:</b></dt><dd>The OS thread ID for the calling thread. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"3acf9b2974d069552c48a9a2934906cb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetCurrentSysIdById\" ref=\"3acf9b2974d069552c48a9a2934906cb\" args=\"(THREADID tid)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gab34d1953888d943b66400fd065e7af6\">OS_THREAD_ID</a> LEVEL_PINCLIENT::GetCurrentSysIdById           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>tid</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nGet the OS thread ID for the calling thread.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>tid</em>&nbsp;</td><td>Pin ID for the calling thread.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>OS ID for the calling thread. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"e3bd73e60d122d915bf5850aec4d9082\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetEmulatedRegister\" ref=\"e3bd73e60d122d915bf5850aec4d9082\" args=\"(unsigned, THREADID, CONTEXT *, VOID *)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::GetEmulatedRegister           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">unsigned&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>toolRegId</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>VOID *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>data</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall a client function to get the value of an emulated register.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>toolRegId</em>&nbsp;</td><td>Tool's ID which identifies the emulated register. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>tid</em>&nbsp;</td><td>The thread whose register is requested. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>ctxt</em>&nbsp;</td><td>Architected register state for the thread. </td></tr>\n    <tr><td valign=\"top\"><tt>[out]</tt>&nbsp;</td><td valign=\"top\"><em>data</em>&nbsp;</td><td>Receives the value of the register. </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"147ecfb74ef886cb2d4ce0b894856859\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetInTraceCallbacks\" ref=\"147ecfb74ef886cb2d4ce0b894856859\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::GetInTraceCallbacks           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nGet the value of inTraceCallbacks     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"bcb216ec4df150015d0370d30bd7e904\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetOpenImg\" ref=\"bcb216ec4df150015d0370d30bd7e904\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">IMG LEVEL_PINCLIENT::GetOpenImg           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis function provides the IMG structure of the image opened by IMG_Open     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"2334c57be6663b3484124d78b22c9712\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetTargetDescription\" ref=\"2334c57be6663b3484124d78b22c9712\" args=\"(const std::string &amp;, USIZE, VOID *)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN USIZE LEVEL_PINCLIENT::GetTargetDescription           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">const std::string &amp;&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>name</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>USIZE&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>size</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>VOID *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>buf</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall a client function to get a document that describes the target machine's registers.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>name</em>&nbsp;</td><td>The name of the requested document. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>size</em>&nbsp;</td><td>Size (bytes) of the <em>buf</em> buffer. </td></tr>\n    <tr><td valign=\"top\"><tt>[out]</tt>&nbsp;</td><td valign=\"top\"><em>buf</em>&nbsp;</td><td>Points to a buffer that receives the content of the document.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>The size of the requested document or zero if the tool doesn't know this document. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"162c02d22e09d1f32a5e7b71aac44b0f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImageInitialize\" ref=\"162c02d22e09d1f32a5e7b71aac44b0f\" args=\"(BOOL forReplay)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::ImageInitialize           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">BOOL&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>forReplay</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nInitialize the image tracking code.<ul>\n<li>Load the main image</li><li>If we are attaching and the loader has initialized, scan the shared libraries</li><li>If we are not attaching, find the loader and explicitly scan it </li></ul>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"e8417db6d6d9daa0687429f39bab419e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImageInitializeFirst\" ref=\"e8417db6d6d9daa0687429f39bab419e\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::ImageInitializeFirst           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nInitialize images before Pin client started.<ul>\n<li>Clear Pin client list of registered images.</li><li>Enumerate and register all already loaded images.</li><li>Call image load callback function for every registered image. Called by VM in _startProgram() </li></ul>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"a8ba7316f32f79cc20e0248ca006001a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImageInstrument\" ref=\"a8ba7316f32f79cc20e0248ca006001a\" args=\"(TRACE trace)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::ImageInstrument           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>trace</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCalled when each trace is instrumented to support code for tracking images.<ul>\n<li>Instruments the shared library loader entry that is called every time an image is loaded The instrumentation will scan for shared libraries</li><li>Captures the pointer to the LoaderInfo when ld-linux has initialized DT_DEBUG </li></ul>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"60292471a0c8012931cf81f21ad5eac6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImageLoadProbesOsSpecific\" ref=\"60292471a0c8012931cf81f21ad5eac6\" args=\"(IMG img)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::ImageLoadProbesOsSpecific           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>img</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nProbe the relevant functions (in probe mode)     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"9e943322cba0d0ff2967eabbff059594\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImageUnInitialize\" ref=\"9e943322cba0d0ff2967eabbff059594\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::ImageUnInitialize           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nUninitialize the image tracking code.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"c226e8c7cca942b48a9fd396df246e37\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_CreateAt\" ref=\"c226e8c7cca942b48a9fd396df246e37\" args=\"(const char *filename, ADDRINT start, USIZE size, ADDRINT loadOffset, BOOL mainExecutable)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">IMG LEVEL_PINCLIENT::IMG_CreateAt           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">const char *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>filename</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>start</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>USIZE&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>size</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>loadOffset</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>BOOL&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>mainExecutable</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nReturns a IMG object for image loaded outside of PIN's loader. Tool should use this IMG object to mark the routines inside it, using <a class=\"el\" href=\"group__RTN__BASIC__API.html#g394372fdee2823655d7e5eb1742e5ffa\">RTN_CreateAt()</a>. After all the routines are marked, tool should call <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#2c3cf54dba70e1e4fbbe250a476a3688\">IMG_ReplayImageLoad()</a> to finalize the image load procedure.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>filename</em>&nbsp;</td><td>name of the image visible to Pin tools </td></tr>\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>start</em>&nbsp;</td><td>memory address where first byte of the image is loaded to </td></tr>\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>size</em>&nbsp;</td><td>the size of the image in memory. This means that the image region in memory will be at [start .. start+size) </td></tr>\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>loadOffset</em>&nbsp;</td><td>the offset between the memory addresses specified in the executable/library files and the memory addresses where this image was actaully loaded </td></tr>\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>mainImage</em>&nbsp;</td><td>TRUE if this is the main image</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>IMG object that represents the image. Please make sure to call <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#2c3cf54dba70e1e4fbbe250a476a3688\">IMG_ReplayImageLoad()</a> on the IMG object after you're done creating all the routines in the IMG object.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: All<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"6b02551e35f166adb7fb96967c7c7911\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_ExecuteRecordedLoadOps\" ref=\"6b02551e35f166adb7fb96967c7c7911\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::IMG_ExecuteRecordedLoadOps           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nExecute the list of recorded image load operations and clean the list as we go.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"c83d3d834774eb26105d9220fc240ccb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_FindBySectionsAddress\" ref=\"c83d3d834774eb26105d9220fc240ccb\" args=\"(ADDRINT address)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">IMG LEVEL_PINCLIENT::IMG_FindBySectionsAddress           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">ADDRINT&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>address</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nFind image by address. Given an address, it is considered belonging to an image only if the address equals to one of the following: the start address of the text segment, the start address of the data segment or the lowest address loaded by the image. <dl compact><dt><b>Returns:</b></dt><dd>IMG object, valid or invalid</dd></dl>\n<dl compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>\n <b>O/S</b>: Linux, Windows &amp; MacOS<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"e514b390226e49f828de74a3e93e40ad\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_FindByUnloadAddress\" ref=\"e514b390226e49f828de74a3e93e40ad\" args=\"(ADDRINT startAddress)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">IMG LEVEL_PINCLIENT::IMG_FindByUnloadAddress           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">ADDRINT&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>startAddress</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nFind image by the address which the loader uses when it frees the memory of an image. For Linux, OS X* and Android, for each image, check if the address equals to the start address of the text segment. For Windows, for each image, check if the address equals to the start of the Image. This function should be used to determined if ProcessImageUnload should be called when unmapping an address.<p>\n<dl compact><dt><b>Returns:</b></dt><dd>IMG object, valid or invalid</dd></dl>\n<dl compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>\n <b>O/S</b>: Linux, Windows &amp; MacOS &amp; Android<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"617ef8b03bd319a2c4b53c776d2d0dff\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_FindDataSymbolAddress\" ref=\"617ef8b03bd319a2c4b53c776d2d0dff\" args=\"(IMG origImg, const CHAR *symname)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">ADDRINT LEVEL_PINCLIENT::IMG_FindDataSymbolAddress           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>origImg</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const CHAR *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>symname</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nFind the address of a data symbol in an image. Since that image doesn't have the symbol table in memory anymore (it was unmapped), we need to read the image into a temporary image. This is quite expensive so it is not recommended to expose it to the API or use it frequently.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"79fa304a836f1cc5c3c32abc7f9fd9c6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_FindRtnByName\" ref=\"79fa304a836f1cc5c3c32abc7f9fd9c6\" args=\"(IMG img, const string &amp;name)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">RTN LEVEL_PINCLIENT::IMG_FindRtnByName           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const string &amp;&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>name</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nFind a particular routine by name in the given image     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"8aa50f020f753dfc777e849da3b397a2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_FreeDebugInfo\" ref=\"8aa50f020f753dfc777e849da3b397a2\" args=\"(IMG img)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::IMG_FreeDebugInfo           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>img</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nFree debug info     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"3f1355bdf1c34c5e19cb947b9c399043\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_GetLoaderInfo\" ref=\"3f1355bdf1c34c5e19cb947b9c399043\" args=\"(IMG img)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID* LEVEL_PINCLIENT::IMG_GetLoaderInfo           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>img</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nGets a read-only copy of loader information for the image which is used in PIN ADX debugger.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>img</em>&nbsp;</td><td>The image object to act on</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>Pointer to OS specific structure that holds data about loader information. On Linux, this is a pointer to struct LINUX_LOADER_IMAGE_INFO.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"d39750018c98a35ca1fd1b3ec5823bb6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_IsStandardGccLibrary\" ref=\"d39750018c98a35ca1fd1b3ec5823bb6\" args=\"(IMG img)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::IMG_IsStandardGccLibrary           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>img</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nReturn TRUE if the specified image is libgcc library     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"9d8bb4715f6a6124c599657695f384ba\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_IsStandardLoaderLibrary\" ref=\"9d8bb4715f6a6124c599657695f384ba\" args=\"(IMG img)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::IMG_IsStandardLoaderLibrary           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>img</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nReturn TRUE if the specified image is ld library     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"61e605e545c9bfa6576f4140f8eff378\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_IsStandardSystemLibrary\" ref=\"61e605e545c9bfa6576f4140f8eff378\" args=\"(IMG img)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::IMG_IsStandardSystemLibrary           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>img</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nReturn TRUE if the specified image is libc library     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"c0a38d6752148494df0b1f0fa9e369bb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_IsStandardThreadLibrary\" ref=\"c0a38d6752148494df0b1f0fa9e369bb\" args=\"(IMG img)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::IMG_IsStandardThreadLibrary           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>img</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nReturn TRUE if the specified image is libpthread library     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"2c27dcf002aba8bd73c1b3e8f843c86e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_RecordLoadOp\" ref=\"2c27dcf002aba8bd73c1b3e8f843c86e\" args=\"(IMG img)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::IMG_RecordLoadOp           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>img</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nRemember an imge load operation so that we can execute it when PIN_StartProgram is called.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"d5ed06cb7e8c4088f98fe38e2dd61f31\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_RecordLoadOp\" ref=\"d5ed06cb7e8c4088f98fe38e2dd61f31\" args=\"(const string &amp;imageName, const char *fileName, ADDRINT lo, UINT32 fl)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::IMG_RecordLoadOp           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">const string &amp;&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>imageName</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const char *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>fileName</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>lo</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>UINT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>fl</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nRemember an imge load operation so that we can execute it when PIN_StartProgram is called.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"958abd58434e88c4c4790bea50ba69bb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_RemoveToolCallbacks\" ref=\"958abd58434e88c4c4790bea50ba69bb\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::IMG_RemoveToolCallbacks           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nRemove all image notification functions     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"2c3cf54dba70e1e4fbbe250a476a3688\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_ReplayImageLoad\" ref=\"2c3cf54dba70e1e4fbbe250a476a3688\" args=\"(IMG img)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::IMG_ReplayImageLoad           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>img</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nReplays the image load of an IMG object (created by <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#c226e8c7cca942b48a9fd396df246e37\">IMG_CreateAt()</a>). This means that all the image load callbacks will be called for the specified IMG object. If <a class=\"el\" href=\"group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9\">PIN_StartProgram()</a> wasn't called yet, PIN will enqueue this request and will process this request after <a class=\"el\" href=\"group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9\">PIN_StartProgram()</a> was called<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>img</em>&nbsp;</td><td>The image object to replay its load</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: All<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"b9668f8fa8b8539657861c38f02fbab2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_SetLoaderInfo\" ref=\"b9668f8fa8b8539657861c38f02fbab2\" args=\"(IMG img, VOID *loaderInfo)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::IMG_SetLoaderInfo           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>VOID *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>loaderInfo</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nSets the loader information for the image which are used in PIN ADX debugger.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>img</em>&nbsp;</td><td>The image object to act on </td></tr>\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>loaderInfo</em>&nbsp;</td><td>Points to OS specific structure that holds data about loader information. On Linux, this is a pointer to struct LINUX_LOADER_IMAGE_INFO.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"a07b9dfb5804cebe66994e1ff51dfddb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_UnmapImage\" ref=\"a07b9dfb5804cebe66994e1ff51dfddb\" args=\"(IMG img)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::IMG_UnmapImage           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>img</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nUnmap file     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"a2a730180eafa2a413b937098fd2bd95\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InitDynamicCodeImage\" ref=\"a2a730180eafa2a413b937098fd2bd95\" args=\"(IMG newImg)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::InitDynamicCodeImage           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>newImg</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nInitialize an dynamic code image after it has been allocated. An dynamic code image contains dynamically created code, e.g. Jitted functions.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"ab6a79b971b43b6f40df77682f6a4061\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InitializeApp\" ref=\"ab6a79b971b43b6f40df77682f6a4061\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::InitializeApp           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nInitialize app for usage     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"9980c5b2f7fbb3200b0e1c01897786d7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InitializeCacheClient\" ref=\"9980c5b2f7fbb3200b0e1c01897786d7\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::InitializeCacheClient           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall back function that passes no arguments     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"7cca4a9e9f08dda102d3df55c1dd6922\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InitializeClientTls\" ref=\"7cca4a9e9f08dda102d3df55c1dd6922\" args=\"(THREADID threadIndex)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::InitializeClientTls           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>threadIndex</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nInitialize client TLS in the current thread. <dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>threadIndex</em>&nbsp;</td><td>ID of the current thread </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"f1edcf9d406767a2b633e694791b3a2c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InitializeFollowChildClient\" ref=\"f1edcf9d406767a2b633e694791b3a2c\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::InitializeFollowChildClient           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nInitialize follow-child callbacks     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"7191bcfd463c348aa4b78a3b69b2d96b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_IsNativeCall\" ref=\"7191bcfd463c348aa4b78a3b69b2d96b\" args=\"(INS ins)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::INS_IsNativeCall           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INS&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>ins</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<dl compact><dt><b>Returns:</b></dt><dd>TRUE if a call instruction is marked to be executed natively. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"2e5e0d58f0b03f6d3097435d9faabde5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_IsNativeXfer\" ref=\"2e5e0d58f0b03f6d3097435d9faabde5\" args=\"(INS ins)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::INS_IsNativeXfer           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INS&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>ins</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<dl compact><dt><b>Returns:</b></dt><dd>TRUE if a control flow instruction has been setup to transfer control back to the native code on the taken path. This is the default mechanism. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"e34d7eb04c99b26b1558320fecc799d7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_IsPinXfer\" ref=\"e34d7eb04c99b26b1558320fecc799d7\" args=\"(INS ins)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::INS_IsPinXfer           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INS&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>ins</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<dl compact><dt><b>Returns:</b></dt><dd>TRUE if a control flow instruction has been setup to transfer control to trace generator upon the taken path. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"f2a8eda4c80ea2b762140b6f41a13739\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_IsXlateCall\" ref=\"f2a8eda4c80ea2b762140b6f41a13739\" args=\"(INS ins)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::INS_IsXlateCall           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INS&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>ins</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<dl compact><dt><b>Returns:</b></dt><dd>TRUE if a call instruction is marked to be traslated to a push and a jump to the target to ensure transparency to the application as to where the call originated from. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"498cd509d5928c5ee1a5a09b461f4129\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_ReplaceSignatureProbed\" ref=\"498cd509d5928c5ee1a5a09b461f4129\" args=\"(INS orgIns, AFUNPTR replacementFunptr,...)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::INS_ReplaceSignatureProbed           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INS&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>orgIns</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>AFUNPTR&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>replacementFunptr</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>...</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis routine replaces one instruction The caller checks whether the routine CFG allows this replacement.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"0b19d6710b2f62db97b79d8624103f52\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_SetNativeCall\" ref=\"0b19d6710b2f62db97b79d8624103f52\" args=\"(INS ins)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::INS_SetNativeCall           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INS&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>ins</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nA call instruction is not translated into a PUSH and a JUMP. This implies that the application might realize that the call is being made from the trace in the code cache and thus any code that depends on the return address at the target site is no longer valid and thus results in program corruption. Doing this implies any instruction following the call in the trace is executed.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"8479246e853712ea3fb9d942bbc36612\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_SetNativeXfer\" ref=\"8479246e853712ea3fb9d942bbc36612\" args=\"(INS ins)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::INS_SetNativeXfer           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INS&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>ins</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nSet a control flow instruction to transfer control back to the native code on the taken path. This is the default mechanism.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"36c838d1995c451f596161fcf1de70d7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_SetPinXfer\" ref=\"36c838d1995c451f596161fcf1de70d7\" args=\"(INS ins)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::INS_SetPinXfer           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INS&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>ins</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nSet a control flow instruction to transfer control back to the trace generator upon the taken path.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"868138e8ffb4bc0f08879959f711cbdd\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_SetXlateCall\" ref=\"868138e8ffb4bc0f08879959f711cbdd\" args=\"(INS ins)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::INS_SetXlateCall           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INS&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>ins</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nA call instruction is translated into a return address PUSH and a JMP to ensure that the application does not realize that the call occured in the code cache if it looked at the return address on the stack since we put the original application return address on the stack. This implies that when a return is executed at the call target the control returns to the original application. Any fallthrough instructions in the trace are not executed. Also see <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0b19d6710b2f62db97b79d8624103f52\">INS_SetNativeCall</a> for otherwise.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"063127f4332d26e854e041c73903ce10\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_skip_xlate_set\" ref=\"063127f4332d26e854e041c73903ce10\" args=\"(INS ins, BOOL b)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::INS_skip_xlate_set           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INS&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>BOOL&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>b</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nmark this instruction so it will not be translated by the VM.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"a18dbb09c1604bdeb2c61b0ed79928c0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InstFetcher\" ref=\"a18dbb09c1604bdeb2c61b0ed79928c0\" args=\"(void *copyBuf, const VOID *address, size_t maxSizeToCopy, EXCEPTION_INFO *pExceptInfo)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN size_t LEVEL_PINCLIENT::InstFetcher           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">void *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>copyBuf</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const VOID *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>address</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>size_t&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>maxSizeToCopy</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f\">EXCEPTION_INFO</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>pExceptInfo</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis is the function that is called to fetch instruction bytes from the tool's registered callback fetch function (if any).<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[out]</tt>&nbsp;</td><td valign=\"top\"><em>copyBuf</em>&nbsp;</td><td>A buffer which receives the fetched instruction bytes. This buffer is at least size bytes long. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>address</em>&nbsp;</td><td>Starting address from which instruction bytes should be fetched. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>maxSizeToCopy</em>&nbsp;</td><td>The number of bytes that should be fetched. </td></tr>\n    <tr><td valign=\"top\"><tt>[out]</tt>&nbsp;</td><td valign=\"top\"><em>pExceptInfo</em>&nbsp;</td><td>If less than <em>maxSizeToCopy</em> bytes are fetched, <em>pExceptInfo</em> receives an exception that describes why more bytes could not be fetched. If Pin needs more bytes to decode the next instruction, this exception will be delivered to the application.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes successfully fetched into <em>copyBuf</em>. This may be less than <em>maxSizeToCopy</em> (or even zero) if Pin attempts to fetch instructions from an invalid address. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"58178a737e6c77940df6420698b51da5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InstrumentSystemLibraryForkFunction\" ref=\"58178a737e6c77940df6420698b51da5\" args=\"(IMG img, const char *fname)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN FORKFUNCPTR LEVEL_PINCLIENT::InstrumentSystemLibraryForkFunction           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const char *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>fname</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nInstrument fork-like functions (fork, vfork).<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>img</em>&nbsp;</td><td>Image object of the libc library. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>fname</em>&nbsp;</td><td>Name of the function to replace. If the variable is NULL, the function does nothing.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the original function if it was replaced, NULL otherwise. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"12c24fff0262f4fe68e1000aa1d679d7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IsPinLoaded\" ref=\"12c24fff0262f4fe68e1000aa1d679d7\" args=\"(const string &amp;name)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::IsPinLoaded           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">const string &amp;&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>name</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nx     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"803aaca717b5d93e5dac74037fb170c0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IsThreadInFiniCallback\" ref=\"803aaca717b5d93e5dac74037fb170c0\" args=\"(OS_THREAD_ID sysId)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::IsThreadInFiniCallback           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gab34d1953888d943b66400fd065e7af6\">OS_THREAD_ID</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>sysId</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nTells whether the given thread is currently executing a thread-fini callback.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>sysId</em>&nbsp;</td><td>O/S ID for a thread.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>TRUE if the thread <em>sysId</em> is currently executing a thread-fini callback. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"d1783541b0c70d52db9fd54d55d16769\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobAppendLogFile\" ref=\"d1783541b0c70d52db9fd54d55d16769\" args=\"(KNOB_MODE_WRITEONCE,&quot;supported&quot;,&quot;append_logfile&quot;,&quot;0&quot;,&quot;Append to the end of the log file if it already exists&quot;)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">KNOB&lt;BOOL&gt; LEVEL_PINCLIENT::KnobAppendLogFile           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">KNOB_MODE_WRITEONCE&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;supported&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;append_logfile&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;0&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;Append to the end of the log file if it already exists&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nNew log messages should be appended to the end of the log file if it already exists.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"598a612bc7e5ea1f418dd2ab671ca97c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobJitApi\" ref=\"598a612bc7e5ea1f418dd2ab671ca97c\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;support_jit_api&quot;,&quot;0&quot;,&quot;Enables the Jitted Functions Support&quot;)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">KNOB&lt;BOOL&gt; LEVEL_PINCLIENT::KnobJitApi           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">KNOB_MODE_WRITEONCE&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;pintool:sym&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;support_jit_api&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;0&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;Enables the Jitted Functions Support&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis knob enables the Jitted Functions Support.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"13d630de596b4fc3308041174feef1b0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MessageTypeLogBuffer\" ref=\"13d630de596b4fc3308041174feef1b0\" args=\"(&quot;log_buffer&quot;,&quot;&quot;, false, false, false, true, LOGTYPE_LOGFILE,&quot;pin log: buffering&quot;)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">MESSAGE_TYPE LEVEL_PINCLIENT::MessageTypeLogBuffer           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">&quot;log_buffer&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>true&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>LOGTYPE_LOGFILE&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;pin log: buffering&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nmessages associated with fast buffering API     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"83ca6b869d18c3e453b18c002a1e7e3e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MessageTypeLogFetchRtnIns\" ref=\"83ca6b869d18c3e453b18c002a1e7e3e\" args=\"(&quot;log_fetch_rtn_ins&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: fetch rtn ins information&quot;)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">MESSAGE_TYPE LEVEL_PINCLIENT::MessageTypeLogFetchRtnIns           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">&quot;log_fetch_rtn_ins&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>LOGTYPE_LOGFILE&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;pin log: fetch rtn ins information&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nFetch RTN INS log message     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"6e274b207b131f9e6157c6023beed454\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MessageTypeLogImage\" ref=\"6e274b207b131f9e6157c6023beed454\" args=\"(&quot;log_image&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: image API&quot;)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">MESSAGE_TYPE LEVEL_PINCLIENT::MessageTypeLogImage           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">&quot;log_image&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>LOGTYPE_LOGFILE&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;pin log: image API&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nLogging for image api     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"b59bf319cf44ea196ca24b52478f7a15\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MessageTypeLogProbe\" ref=\"b59bf319cf44ea196ca24b52478f7a15\" args=\"(&quot;log_probe&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: probe information&quot;)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">MESSAGE_TYPE LEVEL_PINCLIENT::MessageTypeLogProbe           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">&quot;log_probe&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>LOGTYPE_LOGFILE&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;pin log: probe information&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nProbe log message     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"cf8b2cb915ed32cf036e3a17b8d1dfa2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MessageTypeLogSym\" ref=\"cf8b2cb915ed32cf036e3a17b8d1dfa2\" args=\"(&quot;log_sym&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: symbol API&quot;)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">MESSAGE_TYPE LEVEL_PINCLIENT::MessageTypeLogSym           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">&quot;log_sym&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>LOGTYPE_LOGFILE&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;pin log: symbol API&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nLogging for symbols in image api     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"5c464fca7e2b11fdcd4d9dfb3bc29908\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MessageTypeLogUnwind\" ref=\"5c464fca7e2b11fdcd4d9dfb3bc29908\" args=\"(&quot;log_unwind&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: unwind&quot;)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">MESSAGE_TYPE LEVEL_PINCLIENT::MessageTypeLogUnwind           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">&quot;log_unwind&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>false&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>LOGTYPE_LOGFILE&nbsp;</td>\n          <td class=\"mdname\" nowrap>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&quot;pin log: unwind&quot;&nbsp;</td>\n          <td class=\"mdname\" nowrap></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nmessages associated with PinProbes     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"20bb0768cd2b9b95341f9b56810d9bf7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyDataRange\" ref=\"20bb0768cd2b9b95341f9b56810d9bf7\" args=\"(CODE_RANGES *rangeMap, ADDRINT base, USIZE size)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::NotifyDataRange           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">CODE_RANGES *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>rangeMap</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>base</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>USIZE&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>size</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nUpdate code range database to take into account the specified data range.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"5eb472b944d448e714e3d09fd4a38c3b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyDataRanges\" ref=\"5eb472b944d448e714e3d09fd4a38c3b\" args=\"(IMG img, CODE_RANGES *rangeMap)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::NotifyDataRanges           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>CODE_RANGES *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>rangeMap</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nUpdate original map of code ranges in binary image taking into account known data ranges that may overlap with the original code ranges.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"17237d9e31f04fa0a4fe4754d4861326\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyDebuggerOnImageLoad\" ref=\"17237d9e31f04fa0a4fe4754d4861326\" args=\"(BOOL isMain, VOID *loaderInfo)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::NotifyDebuggerOnImageLoad           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">BOOL&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>isMain</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>VOID *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>loaderInfo</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nNotifies the debugger that new image had been loaded <dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>isMain</em>&nbsp;</td><td>True is the image is the main executable </td></tr>\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>loaderInfo</em>&nbsp;</td><td>Points to a LINUX_LOADER_IMAGE_INFO that holds image information for PINADX </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"0ee03bf03511053a995f8173b90d1bfc\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyDebuggerOnImageUnload\" ref=\"0ee03bf03511053a995f8173b90d1bfc\" args=\"(VOID *loaderInfo)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::NotifyDebuggerOnImageUnload           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">VOID *&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>loaderInfo</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nNotifies the debugger that an image was unloaded <dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>loaderInfo</em>&nbsp;</td><td>Points to a LINUX_LOADER_IMAGE_INFO that holds image information for PINADX </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"c69967c684c53f18360b0cd589e5c7dc\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyDetachCompletedJitMode\" ref=\"c69967c684c53f18360b0cd589e5c7dc\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::NotifyDetachCompletedJitMode           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nRemove all client callbacks after detach     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"ad298e1b3ca1dbdc9df7e4dd73b04dc2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyOutOfMemory\" ref=\"ad298e1b3ca1dbdc9df7e4dd73b04dc2\" args=\"(size_t size)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::NotifyOutOfMemory           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">size_t&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>size</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nNotify pin / pin tool is out of memory. Do minimal actions in here due to the subtle location (i.e. no memory)<ul>\n<li>Don't serialize the callback</li><li>Don't use any STL in here </li></ul>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"ffbb2aeca388542bbadc0175d8c9de74\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyPrepareForAtExit\" ref=\"ffbb2aeca388542bbadc0175d8c9de74\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::NotifyPrepareForAtExit           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nNotify that pin is about to call NtTerminateProcess when the at_exit feature is enabled. The function that is registered by this callback should do the following:<ul>\n<li>Kill all the internal threads of the tool without using the Pin API (i.e. - return from the main function of the thread is fine, but calling Pin_ExitThread is not.) Pin will wait until all the internal threads were killed before it will continue to run. </li></ul>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"23a4e64ed9045f9667e25e4bb57befce\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::Open_Rtn\" ref=\"23a4e64ed9045f9667e25e4bb57befce\" args=\"(RTN rtn)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::Open_Rtn           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">RTN&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>rtn</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nOpen the given RTN.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"68a4173dc9649381353502748f429c9d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_AddDebuggerRegisterEmulator\" ref=\"68a4173dc9649381353502748f429c9d\" args=\"(unsigned numRegisters, const DEBUGGER_REG_DESCRIPTION *registerDescriptions, GET_EMULATED_REGISTER_CALLBACK getFun, SET_EMULATED_REGISTER_CALLBACK setFun, GET_TARGET_DESCRIPTION_CALLBACK getDescriptionFun, VOID *val)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::PIN_AddDebuggerRegisterEmulator           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">unsigned&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>numRegisters</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const <a class=\"el\" href=\"structDEBUGGER__REG__DESCRIPTION.html\">DEBUGGER_REG_DESCRIPTION</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>registerDescriptions</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>GET_EMULATED_REGISTER_CALLBACK&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>getFun</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>SET_EMULATED_REGISTER_CALLBACK&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>setFun</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>GET_TARGET_DESCRIPTION_CALLBACK&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>getDescriptionFun</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>VOID *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>val</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis API is useful for Pin tools that emulate registers that do not exist in the host machine's ISA. If an application debugger is attached to Pin, this API informs the debugger about the extended registers, allowing users to display and manipulate the emulated registers as though they were native registers. Of course, not all debuggers have this capability. Calling this API for such a non-conforming debugger is legal, but ineffective. A non-conforming debugger will ignore the emulated registers and just display the native ones.<p>\nWhen using this API, the set of registers presented to the debugger is specified in two redundant ways, and it is the tool's responsibility to ensure that they are consistent. One specification is a text document that the debugger reads. This document can have any format that the tool and the debugger agree upon, and could convey information about the registers, how they should be displayed in the debugger, etc. The tool provides this document via the <em>getDescriptionFun</em> call-back. The second register specification is through the <em>registerDescriptions</em> parameter, which Pin uses when communicating the register values to the debugger.<p>\nIf this API is called, it must be called before calling <a class=\"el\" href=\"group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9\">PIN_StartProgram()</a>. Also, a tool can install only one debugger register emulator, so a call to <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#68a4173dc9649381353502748f429c9d\">PIN_AddDebuggerRegisterEmulator()</a> will overwrite any previous call.<p>\nWhen used with GDB, this API is effective only for versions of GDB that support register extensions in the XML \"feature document\". This includes GDB versions 7.2 and later, as well as some distributions of earlier GDB versions.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>numRegisters</em>&nbsp;</td><td>The number of entries in <em>registerDescriptions</em>. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>registerDescriptions</em>&nbsp;</td><td>An array describing each register that the debugger will know about. This includes both native registers and emulated registers. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>getFun</em>&nbsp;</td><td>Call-back function that Pin calls to get the value of an emulated register. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>setFun</em>&nbsp;</td><td>Call-back function that Pin calls to set the value of an emulated register. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>getDescriptionFun</em>&nbsp;</td><td>Call-back function that Pin calls to get the content of a text document that tells the debugger about the registers defined in <em>registerDescriptions</em>. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>val</em>&nbsp;</td><td>Value passed to the call-back functions.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux, Windows<br>\n <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"959335effb5aa746d6e3bf35af66b6de\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_AddPrepareForAtExitFunction\" ref=\"959335effb5aa746d6e3bf35af66b6de\" args=\"(PREPARE_FOR_ATEXIT_CALLBACK fun, VOID *val)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::PIN_AddPrepareForAtExitFunction           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">PREPARE_FOR_ATEXIT_CALLBACK&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>fun</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>VOID *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>val</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThe function that is registered by this callback should do the following:<ul>\n<li>Kill all the internal threads of the tool without using the Pin API (i.e. - return from the main function of the thread is fine, but calling Pin_ExitThread is not.) Pin will wait until all the internal threads were killed before it will continue to run.</li></ul>\n<p>\nA tool can register only one notification function.<br>\n A new notification function registration overwrites any previous registration.<br>\n To disable the notification function, pass a NULL function pointer.<br>\n<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Note:</b></dt><dd>The pin client lock and the Pin Vm lock is obtained during the call of this API.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; PROBE<br>\n <b>O/S</b>: Windows <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"1ff6b5f93566358d0fb11e216823b926\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_CallerOwnsClientMutex\" ref=\"1ff6b5f93566358d0fb11e216823b926\" args=\"(OS_THREAD_ID osid)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::PIN_CallerOwnsClientMutex           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gab34d1953888d943b66400fd065e7af6\">OS_THREAD_ID</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>osid</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nReturn TRUE if calling thread is the owner of the lock.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>osid</em>&nbsp;</td><td>OS ID of calling thread.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>\n <b>O/S</b>: Linux, Windows &amp; MacOS<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"d96929757b22bc06974749c1c24ea9cd\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_ClientFork\" ref=\"d96929757b22bc06974749c1c24ea9cd\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gab34d1953888d943b66400fd065e7af6\">OS_THREAD_ID</a> LEVEL_PINCLIENT::PIN_ClientFork           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nAllow a Pintool to safely fork. Call the fork system call and notify the VM appropriately. <dl compact><dt><b>Returns:</b></dt><dd>Parent: ID of the child, child: 0, INVALID_THREADID if fork failed</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux &amp; MacOS<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"034cda838606c61faa059859f76da7fb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_InsertProbe\" ref=\"034cda838606c61faa059859f76da7fb\" args=\"(ADDRINT src_addr, ADDRINT dst_addr)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::PIN_InsertProbe           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>src_addr</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>dst_addr</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis is an internal Pin API. It is not supported for use in general tools. We reserve the right to change or remove this API at any time without advanced notice.<p>\nThis API must be used in conjunction with other internal APIs. Do not use this API.<p>\nInserts a probe at an address.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>src_addr</em>&nbsp;</td><td>Address to insert the probe at </td></tr>\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>dst_addr</em>&nbsp;</td><td>Target to where the probe should point to </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"afb41af0a98f375df6bc3aa244f03f45\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_InterceptDebuggingEvent\" ref=\"afb41af0a98f375df6bc3aa244f03f45\" args=\"(DEBUGGING_EVENT eventType, INTERCEPT_DEBUGGING_EVENT_CALLBACK fun, VOID *arg)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::PIN_InterceptDebuggingEvent           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">DEBUGGING_EVENT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>eventType</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>INTERCEPT_DEBUGGING_EVENT_CALLBACK&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>fun</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>VOID *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>arg</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nEstablish an interceptor function for debugging events that Pin sends to an external debugger. This API allows a tool to filter these events before they are visible to the debugger.<p>\nA tool can set only one \"intercept\" function for a particular event, so a new function overwrites any previous one for the same event. To disable an interceptor, pass a NULL function pointer.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>eventType</em>&nbsp;</td><td>Tells the type of events to intercept. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>fun</em>&nbsp;</td><td>The tool's interceptor function, or NULL. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>val</em>&nbsp;</td><td>Value to pass to the interceptor function.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux, Windows<br>\n <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"28e71d973c42f6ca44a77276e600eb27\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_RegisterNewThread\" ref=\"28e71d973c42f6ca44a77276e600eb27\" args=\"(THREAD_CONTEXT *pContext)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a> LEVEL_PINCLIENT::PIN_RegisterNewThread           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">THREAD_CONTEXT *&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>pContext</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nRegister the current application thread in the Pin thread database.<p>\nThis function is called when an application, which runs under Pin in probe mode, requests Pin to create a thread context suitable for JITing and instrumentation. The application calls the PIN_NewThread() function (in the pinapp library) which is intercepted by a probe and redirected to <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#28e71d973c42f6ca44a77276e600eb27\">PIN_RegisterNewThread()</a>. The context created by this function is then passed to the PIN_ExecuteInstrumented function that starts JIT-instrumented execution of the thread.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[out]</tt>&nbsp;</td><td valign=\"top\"><em>pointer</em>&nbsp;</td><td>to the variable that receives context of the new thread on return from this function. If this parameter is NULL, the context is not returned </td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>ID of the current thread or INVALID_THREADID upon failure</dd></dl>\n<dl compact><dt><b>Note:</b></dt><dd>This function is intended for advanced users only. Public Pin API does not support switching between JIT and probe mode. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"923f50d40c1060c7f9edf139a7582832\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_RemoveFollowChildProcessFunctions\" ref=\"923f50d40c1060c7f9edf139a7582832\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::PIN_RemoveFollowChildProcessFunctions           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nRemove all follow child notification functions     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"8db2b14300e5795dc6a946c945955302\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_RemoveForkProbedCallbacks\" ref=\"8db2b14300e5795dc6a946c945955302\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::PIN_RemoveForkProbedCallbacks           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nRemove all notification functions     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"271f5af1f2fa7eda8fe07c8d7284c215\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_RemoveProbe\" ref=\"271f5af1f2fa7eda8fe07c8d7284c215\" args=\"(ADDRINT address)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::PIN_RemoveProbe           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">ADDRINT&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>address</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis is an internal Pin API. It is not supported for use in general tools. We reserve the right to change or remove this API at any time without advanced notice.<p>\nRemove a probe that was previously inserted at address<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>src_addr</em>&nbsp;</td><td>Address at which a probe was previously inserted </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"0b2d6250936b3d9591c2cfda724f4a72\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_ReplayContextChange\" ref=\"0b2d6250936b3d9591c2cfda724f4a72\" args=\"(THREADID tid, const CONTEXT *from, CONTEXT *to, CONTEXT_CHANGE_REASON reason, INT32 info)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::PIN_ReplayContextChange           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>from</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>to</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__PIN__CONTROL.html#gfa1b03e06c6ab0f86fc2abc1693ce688\">CONTEXT_CHANGE_REASON</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>reason</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>INT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>info</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis API is intended for use by tools that replay the execution of an application and need to replay an asynchronous context change that was received by the application at record time. This API is not intended as a general way to send a forced context change (signal, exception, APC) to the application. To do that, see <a class=\"el\" href=\"group__EXCEPTION__API.html#g40302a79ed756094abf1af155b6d3a0b\">PIN_RaiseException()</a>.<p>\nCalling this API causes Pin to call back on the tool's context-changed notification function if one was set up with <a class=\"el\" href=\"group__PIN__CONTROL.html#gfe475fc12b9060e8e45cbfccd7d592c8\">PIN_AddContextChangeFunction()</a>. Thus, the tool is notified about the context change as though the application really received it. Calling this API may also notify an external debugger if one is attached to Pin via the -appdebug switch, which gives the debugger a chance to stop execution of the application when it receives the replayed context change. (Whether this happens depends on the CONTEXT_CHANGE_REASON, and the expected behavior of the debugger on different platforms).<p>\n<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0b2d6250936b3d9591c2cfda724f4a72\">PIN_ReplayContextChange()</a> does not return to its caller. If the <em>to</em> parameter is not NULL, execution resumes at that context after it has been potentially modified by the tool's context-changed call-back. If <em>reason</em> is CONTEXT_CHANGE_REASON_FATALSIGNAL, Pin emulates a fatal signal and execution terminates gracefully after calling the tool's Fini functions.<p>\nThis API can be called from an analysis routine or a replacement routine, but not from a callback.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>tid</em>&nbsp;</td><td>The ID of the calling thread. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>from</em>&nbsp;</td><td>The register state prior to the context change (e.g. the register state at the point when the signal is received for CONTEXT_CHANGE_REASON_SIGNAL). </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>to</em>&nbsp;</td><td>The register state immediately after the context change. This should be NULL for CONTEXT_CHANGE_REASON_FATALSIGNAL. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>reason</em>&nbsp;</td><td>The type of the context change. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>info</em>&nbsp;</td><td>Additional information, depending on <em>reason</em>. (Ignored for <em>reason</em> codes not listed below.) <ul>\n<li>CONTEXT_CHANGE_REASON_FATALSIGNAL: The Unix signal number. </li>\n<li>CONTEXT_CHANGE_REASON_SIGNAL: The Unix signal number. </li>\n<li>CONTEXT_CHANGE_REASON_EXCEPTION: The Windows exception code. </li>\n</ul>\n</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>This function does not return.</dd></dl>\n<dl compact><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux &amp; Windows<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"f13f4dc480f3bfa8891c2310fadf578a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_ReplayImageLoad\" ref=\"f13f4dc480f3bfa8891c2310fadf578a\" args=\"(const char *imageName, const char *fileName, ADDRINT loadOffset, BOOL mainImage)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">IMG LEVEL_PINCLIENT::PIN_ReplayImageLoad           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">const char *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>imageName</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const char *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>fileName</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>loadOffset</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>BOOL&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>mainImage</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nAsk Pin to perform all the functions it would normally do when it detects that a new shared library has been loaded. This is intended for use in a replay system, where the replay tool has recorded library load operations, and now wants to replay them.<p>\nThe code calling this routine need <b>not</b> ensure that the loaded sections of the image have already been restored. Using this interface causes Pin to use its private copy of the image information to satisfy the IMG, SEC and RTN functions.<p>\nThis routine can be called <b>before</b> PIN_StartProgram to set up image load operations for images which were loaded before Pin took control of the program at record time (on Unix systems these are normally the main executable and the dynamic linker; on Windows more system libraries may be present). When called at this point the image load callbacks are remembered internally, and replayed when PIN_StartProgram is called. (This is the same time they would have been made at record time, and ensures that all relevant callbacks have been registered).<p>\nPIN_ReplayImageLoad can also be called from analysis or callback routines, in which case the relevant callbacks are made immediately. If called from an analysis routine, the Pin client lock must be claimed before calling PIN_ReplayImageLoad (the Pin client lock is already held when in a callback routine, so there is no need to claim it again).<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>imageName</em>&nbsp;</td><td>name of the image visible to Pin tools </td></tr>\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>fileName</em>&nbsp;</td><td>name of the file from which the image is read </td></tr>\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>loadOffset</em>&nbsp;</td><td>offset from the address at which the image is naturally loaded to the address at which it has been loaded </td></tr>\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>mainImage</em>&nbsp;</td><td>TRUE if this is the main image</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>the image id of the loaded img, or IMG_INVALID() when called before PIN_StartProgram</dd></dl>\n<dl compact><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux (others to follow)<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"0955efae5ae55dc5a33930a85b29b827\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_ReplayImageUnload\" ref=\"0955efae5ae55dc5a33930a85b29b827\" args=\"(IMG img)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::PIN_ReplayImageUnload           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>img</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nAsk Pin to perform all the functions it would normally do when it detects that a shared library has been unloaded. This is intended for use in a replay system, where the replay tool has recorded library unload operations, and now wants to replay them.<p>\nNote that a replay system need not explicitly call this function to cause image unload callbacks at the end of process execution. Pin will generate those callbacks itself provided that images were created using the <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f13f4dc480f3bfa8891c2310fadf578a\">PIN_ReplayImageLoad</a> call. However, this function is required to handle explicit image unloads (for instance those caused by <code>dlclose()</code> )<p>\nPIN_ReplayImageUnload can be called from analysis or callback routines. If called from an analysis routine, the Pin client lock must be claimed before calling PIN_ReplayImageUnload (the Pin client lock is already held when in a callback routine, so there is no need to claim it again).<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>img</em>&nbsp;</td><td>the IMG to be unloaded</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux (others to follow)<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"ab75caaf01908ef2220a2f63918a99f3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_ReplaySyscallEntry\" ref=\"ab75caaf01908ef2220a2f63918a99f3\" args=\"(THREADID tid, CONTEXT *ctxt, SYSCALL_STANDARD std)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::PIN_ReplaySyscallEntry           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>std</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis API is intended for use by tools that replay the execution of an application and need to behave as if a system call has been made, calling all callbacks registered with PIN_AddSysCallEntry function. However, no system call is actually performed.<p>\nThis API can be called from an analysis routine or a replacement routine, but not from a call-back.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>tid</em>&nbsp;</td><td>The ID of the thread in which the system call appears to execute. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>from</em>&nbsp;</td><td>The register state at the point when the system call appears to execute. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>std</em>&nbsp;</td><td>The calling standard of the system call.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux,Windows,BSD<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"8ac057feb5dd33a7669874d438976c4e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_ReplaySyscallExit\" ref=\"8ac057feb5dd33a7669874d438976c4e\" args=\"(THREADID tid, CONTEXT *ctxt, SYSCALL_STANDARD std)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::PIN_ReplaySyscallExit           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#g3b24ec17730bcf65f7ff170f7ff49fba\">SYSCALL_STANDARD</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>std</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis API is intended for use by tools that replay the execution of an application and need to behave as if a system call has been made, calling all callbacks registered with PIN_AddSysCallExit function. However, no system call is actually performed.<p>\nThis API can be called from an analysis routine or a replacement routine, but not from a call-back.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>tid</em>&nbsp;</td><td>The ID of the thread in which the system call appears to execute. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>from</em>&nbsp;</td><td>The register state at the point after the system call has executed. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>std</em>&nbsp;</td><td>The calling standard of the system call.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux,Windows,BSD<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"708cf91fa398ebda7d6e0327691cd573\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_SetReplayMode\" ref=\"708cf91fa398ebda7d6e0327691cd573\" args=\"(UINT32 flags)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::PIN_SetReplayMode           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">UINT32&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>flags</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nTell Pin to execute different sets of operations in replay mode.<p>\nThe only flag currently supported is REPLAY_MODE_IMAGEOPS which disables Pin's normal detection of image load and unload events, which are expected to be replayed through the <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#f13f4dc480f3bfa8891c2310fadf578a\">PIN_ReplayImageLoad</a> and <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#0955efae5ae55dc5a33930a85b29b827\">PIN_ReplayImageUnload</a> calls. It also avoids Pin loading information about the initial image given on the command line.<p>\nOther flags may be added as required in the future.<p>\nMust be called before <a class=\"el\" href=\"group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9\">PIN_StartProgram</a><p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>flags</em>&nbsp;</td><td>A mask created from the PIN_REPLAY_MODE_FLAGS enum describing the operations the replayer will take control of.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux (others later)<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"a2b64629c1958915cc355913419328c6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_SpawnApplicationThread\" ref=\"a2b64629c1958915cc355913419328c6\" args=\"(const CONTEXT *ctxt)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::PIN_SpawnApplicationThread           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">const <a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>ctxt</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nStart a new thread which will begin to execute with the register state from the context. At least the flags register in the context must be sensible (even if all of the thread's registers will be set in the thread start callback).<p>\nThis function requires the VM lock to operate, so will acquire and release it if it is not already held.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>ctxt</em>&nbsp;</td><td>context for the new thread. </td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>TRUE if a new thread was sucessfully spawned, FALSE if not.</dd></dl>\n<dl compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API. <p>\nThis function must be used on applications that are running with the (newer) NPTL version of pthread library. Running this function on an application that is running with the (older) LinuxThreads version of pthread can prevent PIN from shuting down the VM when the application exits.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux<br>\n <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"380eabb845a436f5359fcba351816d48\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_TryClientLock\" ref=\"380eabb845a436f5359fcba351816d48\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::PIN_TryClientLock           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nAtempts to acquire the client lock, but does not block the caller. <dl compact><dt><b>Returns:</b></dt><dd>Returns TRUE if the lock is acquired, FALSE if not. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"4d3105395edc6c295957afc8fd08e02f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_UnloadAllImages\" ref=\"4d3105395edc6c295957afc8fd08e02f\" args=\"(BOOL copyBits)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::PIN_UnloadAllImages           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">BOOL&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>copyBits</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nDestroy all image objects. Remove probes.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"1d8ff737256a9487034f5f3b3ea8e327\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_WasMemoryReservedInLoadTime\" ref=\"1d8ff737256a9487034f5f3b3ea8e327\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::PIN_WasMemoryReservedInLoadTime           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nReturn TRUE if PIN was successfully reserved the neccessary memory at application load time (specified on the -reserve_memory knob), and was successfully restricted the memory from the loader (specified on the -restrict_memory knob). It is guaranteed this is the return value is FALSE then none the memory specified in the mentioned knobs was reserved/restricted<p>\n<dl compact><dt><b>Returns:</b></dt><dd>TRUE if all the memory was reserved/restricted</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"3e6f06b5b38aaa73232fe31374844ded\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PinClientState\" ref=\"3e6f06b5b38aaa73232fe31374844ded\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">PIN_CLIENT_STATE&amp; LEVEL_PINCLIENT::PinClientState           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nReturn reference to the instance of the PIN_CLIENT_STATE singleton     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"5a1ab30ed65b0535cd1ec7e1aac7f172\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ProcessImageLoad\" ref=\"5a1ab30ed65b0535cd1ec7e1aac7f172\" args=\"(const string &amp;filename, const CHAR *trueFilename, ADDRINT load_offset, UINT32 flags, void *arg)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">IMG LEVEL_PINCLIENT::ProcessImageLoad           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">const string &amp;&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>filename</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const CHAR *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>trueFilename</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>load_offset</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>UINT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>flags</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>void *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>arg</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nWhen the application loads a new image, do some bookeeping.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>filename</em>&nbsp;</td><td>The filename seen by the user </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>trueFilename</em>&nbsp;</td><td>The file actually read (or NULL if filename should be used)</td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>load_offset</em>&nbsp;</td><td>The offset from the images linked address to its load address </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>flags</em>&nbsp;</td><td>Flags for the new image (an | of values from IMAGE_LOAD_FLAGS enumeration)</td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>arg</em>&nbsp;</td><td>Argument specific to the image type</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>New IMG object corresponding to the loaded image. IMG_INVALID() if load was unsuccessful. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"7767a09795b8a85cbdaa32877e13ffce\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ProcessImageLoad\" ref=\"7767a09795b8a85cbdaa32877e13ffce\" args=\"(const string &amp;filename, const CHAR *trueFilename, ADDRINT load_offset, UINT32 flags, void *loaderInfo, void *arg)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">IMG LEVEL_PINCLIENT::ProcessImageLoad           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">const string &amp;&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>filename</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const CHAR *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>trueFilename</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>load_offset</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>UINT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>flags</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>void *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>loaderInfo</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>void *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>arg</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nWhen the application loads a new image, do some bookeeping.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>filename</em>&nbsp;</td><td>The filename seen by the user </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>trueFilename</em>&nbsp;</td><td>The file actually read (or NULL if filename should be used)</td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>load_offset</em>&nbsp;</td><td>The offset from the images linked address to its load address </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>flags</em>&nbsp;</td><td>Flags for the new image (an | of values from IMAGE_LOAD_FLAGS enumeration)</td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>loaderInfo</em>&nbsp;</td><td>Points to OS specific struct containing loader information about the image to be used for PINADX debugger.</td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>arg</em>&nbsp;</td><td>Argument specific to the image type</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>New IMG object corresponding to the loaded image. IMG_INVALID() if load was unsuccessful. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"8e929d0af8332af1b934e4c7a686ec5a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ProcessImageUnload\" ref=\"8e929d0af8332af1b934e4c7a686ec5a\" args=\"(IMG img, BOOL copyBits)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::ProcessImageUnload           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>BOOL&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>copyBits</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nProcess image unload notification. <dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>img</em>&nbsp;</td><td>unloaded image </td></tr>\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>copyBits</em>&nbsp;</td><td>should pin restore original probed bits back to the image code </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"c62cdf7c3212f4177e4d884db0fa43ff\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ProcessModuleUnload\" ref=\"c62cdf7c3212f4177e4d884db0fa43ff\" args=\"(ADDRINT base)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::ProcessModuleUnload           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">ADDRINT&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>base</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nProcess module unload.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>base</em>&nbsp;</td><td>base address of the module </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"ccf08634d9f9eed0859a6bc40821a8c8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ReadElfHeader\" ref=\"ccf08634d9f9eed0859a6bc40821a8c8\" args=\"(CHAR const *file, EHDR *ehdr)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::ReadElfHeader           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">CHAR const *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>file</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>EHDR *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ehdr</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nRead the elf header of a binary     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"0ffa8a7cf24cb2d8fa0a15f084f796fb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RecordFptrAppGetppid\" ref=\"0ffa8a7cf24cb2d8fa0a15f084f796fb\" args=\"(IMG img)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::RecordFptrAppGetppid           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>img</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nRecord the getppid function pointer which is used by the application.<p>\nThe getppid function pointer is needed for the lock acquisition algorithm which is used in probe mode.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>img</em>&nbsp;</td><td>Image object of libc library.</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>AFUNPTR getppid function pointer. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"4f04e50e427cfd24aaa274ee8ba5c0a6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ResetOpenImg\" ref=\"4f04e50e427cfd24aaa274ee8ba5c0a6\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::ResetOpenImg           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nx     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"64f7462d92129da25864a39dd4183442\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ResetOpenRtn\" ref=\"64f7462d92129da25864a39dd4183442\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::ResetOpenRtn           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nx     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"2e0ad7b8e1be9c2b7857827ae2b40c18\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_CheckFixups\" ref=\"2e0ad7b8e1be9c2b7857827ae2b40c18\" args=\"(RTN rtn, UINT32 probe_size)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::RTN_CheckFixups           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">RTN&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>UINT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>probe_size</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nReturn TRUE if fixup bytes intercept replaced bytes of the rtn entry point probe.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>rtn</em>&nbsp;</td><td>Handle of RTN object </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"7e79b848b975ff17bd601f06494d6888\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_CheckForPreviousProbe\" ref=\"7e79b848b975ff17bd601f06494d6888\" args=\"(RTN rtn)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::RTN_CheckForPreviousProbe           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">RTN&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>rtn</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis routine checks if there was a probe previously placed at this address by Pin or the pin tool. Two probes cannot be placed at the same address at the same time. When a library is unloaded, the probes for that library are removed.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"d2a0bb30b870acbeb102f30ff69569a3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_CheckRtnSizeForProbe\" ref=\"d2a0bb30b870acbeb102f30ff69569a3\" args=\"(RTN rtn, BOOL checkForPadding, BOOL *didcheckForPadding, UINT32 probe_size)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN BOOL LEVEL_PINCLIENT::RTN_CheckRtnSizeForProbe           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">RTN&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>BOOL&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>checkForPadding</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>BOOL *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>didcheckForPadding</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>UINT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>probe_size</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis routine tests the size of a function to ensure that a probe will not overflow its bounds. The function returns TRUE in case rtn size is not fit for probe.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"afa81f8f08250d7bbb6ccc4ff03d4fe4\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_CreateJitFunction\" ref=\"afa81f8f08250d7bbb6ccc4ff03d4fe4\" args=\"(IMG img, ADDRINT address, const string &amp;name, USIZE size)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">RTN LEVEL_PINCLIENT::RTN_CreateJitFunction           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">IMG&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>address</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const string &amp;&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>name</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>USIZE&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>size</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCreate a Jitted function at the given address.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>address</em>&nbsp;</td><td>The start address of the new routine </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>name</em>&nbsp;</td><td>The assigned name of the new routine</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>RTN object The new created routine object.</dd></dl>\n<dl compact><dt><b>Note:</b></dt><dd>Close any open routine before calling this interface with <a class=\"el\" href=\"group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3\">RTN_Close()</a>.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: All<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"cfa58d6beb1e2285d781c296ae891578\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_Destroy\" ref=\"cfa58d6beb1e2285d781c296ae891578\" args=\"(RTN rtn)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::RTN_Destroy           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">RTN&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>rtn</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nan rtn No RTN can be open when destroying an RTN     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"cd548b0bb345eaee3624bde3cdf13c67\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_DestroyJitFunction\" ref=\"cd548b0bb345eaee3624bde3cdf13c67\" args=\"(ADDRINT address)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::RTN_DestroyJitFunction           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">ADDRINT&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>address</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nDestroy a Jitted function object at the given address.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>address</em>&nbsp;</td><td>The start address of the routine to destroy</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Note:</b></dt><dd>Close any open routine before calling this interface with <a class=\"el\" href=\"group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3\">RTN_Close()</a>.</dd></dl>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>\n <b>O/S</b>: Linux, Windows &amp; MacOS<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"29956b8f47051278d5babbab1252fc33\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_InsertFillBuffer\" ref=\"29956b8f47051278d5babbab1252fc33\" args=\"(RTN rtn, IPOINT action, BUFFER_ID id,...)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::RTN_InsertFillBuffer           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">RTN&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21\">IPOINT</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>action</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>BUFFER_ID&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>id</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>...</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nInsert analysis code to fill one record in a trace buffer, relative to a RTN.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>rtn</em>&nbsp;</td><td>The application RTN </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>action</em>&nbsp;</td><td>Whether the record is filled before or after the RTN </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>id</em>&nbsp;</td><td>The ID of the bufer whose record is filled </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>...</em>&nbsp;</td><td><a class=\"el\" href=\"group__INST__ARGS.html#g7e2c955c99fa84246bb2bce1525b5681\">IARG_TYPE</a>. Additional arguments to specify the fields of the trace buffer.</td></tr>\n  </table>\n</dl>\nCertain IARG_TYPEs cannot be used with the *_InsertFillBuffer APIs. The unsupported IARG_TYPEs are: IARG_CONTEXT, IARG_REG_REFERENCE, and IARG_REG_CONST_REFERENCE.<p>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>\n <b>O/S</b>: Linux &amp; Windows<br>\n <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"081ab58c8dcd42ab607207e8d17f8d4b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_InsertProbe\" ref=\"081ab58c8dcd42ab607207e8d17f8d4b\" args=\"(RTN rtn, AFUNPTR replacement, PROBE_MODE mode)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">AFUNPTR LEVEL_PINCLIENT::RTN_InsertProbe           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">RTN&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>AFUNPTR&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>replacement</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__RTN__BASIC__API.html#gf191d518e93cfce6bf6e43d0b2bf3d81\">PROBE_MODE</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>mode</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis is an internal Pin API. It is not supported for use in general tools. We reserve the right to change or remove this API at any time without advanced notice.<p>\nThis API must be used in conjunction with other internal APIs. Do not use this API.<p>\nInstall a probe at the entry point of a routine<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>rtn</em>&nbsp;</td><td>routine to be probed </td></tr>\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>probe</em>&nbsp;</td><td>routine to call at the probe point </td></tr>\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>mode</em>&nbsp;</td><td>- specifies whether the routine can be relocated if probe insertion is impossible due to small first bb </td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>function pointer that to be called to execute the original unprobed routine</dd></dl>\n<dl compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"e32f659b8fd09884dedac7a45c95cf7d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_OpenAndFetch\" ref=\"e32f659b8fd09884dedac7a45c95cf7d\" args=\"(RTN rtn)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::RTN_OpenAndFetch           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">RTN&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>rtn</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nOpen the given rtn and fetch all the instructions<p>\n<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>\n <b>O/S</b>: Linux, Windows &amp; MacOS<br>\n <b>CPU:</b> All<br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"45309e6bd43fc38b5cb3b12115178a25\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_ProbeMayOverwriteBranchTarget\" ref=\"45309e6bd43fc38b5cb3b12115178a25\" args=\"(RTN rtn, UINT32 probe_size, BOOL *mayOverwriteUnidentifiedBranchTarget)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN BOOL LEVEL_PINCLIENT::RTN_ProbeMayOverwriteBranchTarget           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">RTN&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>UINT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>probe_size</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>BOOL *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>mayOverwriteUnidentifiedBranchTarget</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nThis routine tests to see if the probe may overwrite the target of a branch/call     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"bc4673eeff9e97dc24b7136693274b84\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_ReplaceSyscallProbed\" ref=\"bc4673eeff9e97dc24b7136693274b84\" args=\"(RTN rtn, INT32 syscallNum, RTN errnoLocationRtn)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN BOOL LEVEL_PINCLIENT::RTN_ReplaceSyscallProbed           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">RTN&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>INT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>syscallNum</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>RTN&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>errnoLocationRtn</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nInstrument one system call instruction inside routine     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"2d2b2a981a9427e437e4bacdb257cc50\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ScanLibrariesLocked\" ref=\"2d2b2a981a9427e437e4bacdb257cc50\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::ScanLibrariesLocked           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nTake VM lock and client lock before scan.<p>\nIn the probe mode we also take VmLock because in attach mode one thread may be still in Vm and another thread may be in dlopen process.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"4c038211455f2a905645c8488eae4063\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ScanLibrariesUnlocked\" ref=\"4c038211455f2a905645c8488eae4063\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::ScanLibrariesUnlocked           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nAll necessary locks are already taken (the function's name is misleading). Search for DLLs that Pin hasn't yet seen.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"6802c61d2660ada4b5fbad73bf109a0c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SetEmulatedRegister\" ref=\"6802c61d2660ada4b5fbad73bf109a0c\" args=\"(unsigned, THREADID, CONTEXT *, const VOID *)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::SetEmulatedRegister           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">unsigned&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>toolRegId</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c\">THREADID</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb\">CONTEXT</a> *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>const VOID *&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>data</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCall a client function to set the value of an emulated register.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>toolRegId</em>&nbsp;</td><td>Tool's ID which identifies the emulated register. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>tid</em>&nbsp;</td><td>The thread whose register is requested. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>ctxt</em>&nbsp;</td><td>Architected register state for the thread. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>data</em>&nbsp;</td><td>Buffer with the value of the register. </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"7b1e55fbe21558d48e13522ed648f74b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::Shutdown\" ref=\"7b1e55fbe21558d48e13522ed648f74b\" args=\"(INT32 exitCode, BOOL waitToolThreads)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALFUN VOID LEVEL_PINCLIENT::Shutdown           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">INT32&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>exitCode</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>BOOL&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>waitToolThreads</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nShutdown the client when the application is about to terminate. <dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>exitCode</em>&nbsp;</td><td>OS specific termination code for the application. </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>waitToolThreads</em>&nbsp;</td><td>TRUE, if the tool has private threads that need to be waited for exit. </td></tr>\n  </table>\n</dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"7c50ee332ef31bb550510378c1f94c31\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYM_IsDataMarker\" ref=\"7c50ee332ef31bb550510378c1f94c31\" args=\"(SYM sym)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::SYM_IsDataMarker           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">SYM&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>sym</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nxxx     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"38ef4d708109f017f7474e6d8d0785fe\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYM_UndecorateName\" ref=\"38ef4d708109f017f7474e6d8d0785fe\" args=\"(const string &amp;symbolName, UNDECORATION style)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">string LEVEL_PINCLIENT::SYM_UndecorateName           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">const string &amp;&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>symbolName</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap><a class=\"el\" href=\"group__SYM__BASIC__API.html#g8aa0db3277ed9b401a204bf2d1bdc6aa\">UNDECORATION</a>&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>style</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nUndecorate symbol name. <br>\n Provides undecoration of C++ names and decorated C names. The behavior of this function <br>\n is compiler and OS specific. <br>\n<p>\nC++ decorated name is undecorated either to full signature (UNDECORATION_COMPLETE style) <br>\n or to [scope::]name form (UNDECORATION_NAME_ONLY style). <br>\n<p>\nExample of undecoration of symbol generated by GCC compiler on Linux:<br>\n<p>\n<div class=\"fragment\"><pre class=\"fragment\">  Style                   Original name                      Undecorated name\n  =====================   ==================                 ======================================\n  <a class=\"code\" href=\"group__SYM__BASIC__API.html#gg8aa0db3277ed9b401a204bf2d1bdc6aad0dc787dc307af558576ba62f0e40ef3\">UNDECORATION_COMPLETE</a>   _ZN1A7method1ERKSt6vectorIiSaIiEE  A::method1(std::vector&lt;<span class=\"keywordtype\">int</span>, std::allocator&lt;int&gt; &gt; <span class=\"keyword\">const</span>&amp;)\n  <a class=\"code\" href=\"group__SYM__BASIC__API.html#gg8aa0db3277ed9b401a204bf2d1bdc6aa7ac5b7ca1c9423fbe3d44bfbda828c43\">UNDECORATION_NAME_ONLY</a>                                     A::method1\n</pre></div><p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>symbolName</em>&nbsp;</td><td>Decorated name <br>\n </td></tr>\n    <tr><td valign=\"top\"><tt>[in]</tt>&nbsp;</td><td valign=\"top\"><em>style</em>&nbsp;</td><td>Undecoration style, relevant only to C++ undecoration <br>\n Values: <br>\n UNDECORATION_COMPLETE undecorate to full signature <br>\n UNDECORATION_NAME_ONLY undecorate to [scope::]name <br>\n</td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>string containing undecorated symbol name. <br>\n If undecoration fails or is not supported, the function returns the unmodified original name. <br>\n </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"0525801ca47a4e43620d4c39835344c1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ToolUseImageAPI\" ref=\"0525801ca47a4e43620d4c39835344c1\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BOOL LEVEL_PINCLIENT::ToolUseImageAPI           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nReturn TRUE if the Pintool uses any image API support.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"ce2384973d5e1029706c0dda314a9aaa\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_AddBranchEdg\" ref=\"ce2384973d5e1029706c0dda314a9aaa\" args=\"(TRACE trace)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BBL LEVEL_PINCLIENT::TRACE_AddBranchEdg           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>trace</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nIf the last instruction of the trace is a direct branch then add the target path bbl as the fallthrough path into the trace. <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#c2e56309fafae7058494ecd59a96744d\">TRACE_StraightenControlFlow</a> must be invoked prior to compiling the trace to ensure that the branches are invereted.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>trace</em>&nbsp;</td><td>Trace to add the new basic block to </td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>bbl A handle to the newly added basic block </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"a66913eb9503806b8899ae4415c07a87\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_AddFallthroughEdg\" ref=\"a66913eb9503806b8899ae4415c07a87\" args=\"(TRACE trace)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BBL LEVEL_PINCLIENT::TRACE_AddFallthroughEdg           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>trace</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nAdd the fallthrough path bbl of the current last instruction in the trace to the end of the trace.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>trace</em>&nbsp;</td><td>Trace to add the new basic block to </td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>bbl A handle to the newly added basic block </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"65ef8545c3c4558e591a6ce11bbb52e9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_AddInlineCallEdg\" ref=\"65ef8545c3c4558e591a6ce11bbb52e9\" args=\"(TRACE trace)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BBL LEVEL_PINCLIENT::TRACE_AddInlineCallEdg           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>trace</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nIf the last instruction of the trace is a direct call then inline the call target into the trace.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>trace</em>&nbsp;</td><td>Trace to add the new basic block to </td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>bbl A handle to the newly added basic block </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"c8cc4050cbb42f925c1cb58f08ae85d7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_AddInlineReturnEdg\" ref=\"c8cc4050cbb42f925c1cb58f08ae85d7\" args=\"(TRACE trace)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">BBL LEVEL_PINCLIENT::TRACE_AddInlineReturnEdg           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>trace</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nInline the return path of a call that has been previously inlined in this trace using <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#65ef8545c3c4558e591a6ce11bbb52e9\">TRACE_AddInlineCallEdg</a>. This requires that the tail instruction of the trace is a return instruction.<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>trace</em>&nbsp;</td><td>Trace to add the new basic block to </td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>bbl A handle to the newly added basic block </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"9d460e6bc52e1db10ecfee7f106e0852\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_Allocate\" ref=\"9d460e6bc52e1db10ecfee7f106e0852\" args=\"(ADDRINT addr)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> LEVEL_PINCLIENT::TRACE_Allocate           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">ADDRINT&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>addr</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCreate a new trace. The trace is initialized with a bbl starting at the requested address<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>addr</em>&nbsp;</td><td>The address from where to fetch the initialization bbl </td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>TRACE A handle to a trace initialized with a bbl begining at address</dd></dl>\n<dl compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"bafca7871ec69820b3f557bafd2528f6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_AllocateForProbe\" ref=\"bafca7871ec69820b3f557bafd2528f6\" args=\"(PROBE_TYPE probeType, ADDRINT addr, RTN rtn, USIZE probeSize, BOOL mustReadAtLeastProbesizeBytes)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a> LEVEL_PINCLIENT::TRACE_AllocateForProbe           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">PROBE_TYPE&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>probeType</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>ADDRINT&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>addr</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>RTN&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>USIZE&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>probeSize</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"md\" nowrap align=\"right\"></td>\n          <td class=\"md\"></td>\n          <td class=\"md\" nowrap>BOOL&nbsp;</td>\n          <td class=\"mdname\" nowrap> <em>mustReadAtLeastProbesizeBytes</em></td>\n        </tr>\n        <tr>\n          <td class=\"md\"></td>\n          <td class=\"md\">)&nbsp;</td>\n          <td class=\"md\" colspan=\"2\"></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nLike TRACE_Allocate, but only fetch enough instructions to cover a probe<p>\n<dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>probeType</em>&nbsp;</td><td>See PROBE_TYPE </td></tr>\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>addr</em>&nbsp;</td><td>The address from where to fetch the initialization bbl </td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>TRACE A handle to a trace initialized with a bbl begining at address</dd></dl>\n<dl compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"4b7e3c774ff39f497b49d6b80d616892\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_CodeRtn\" ref=\"4b7e3c774ff39f497b49d6b80d616892\" args=\"(TRACE trace)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">RTN LEVEL_PINCLIENT::TRACE_CodeRtn           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>trace</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nx     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"01f77e8f558750e1868c6fcbb15e2bec\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_Deallocate\" ref=\"01f77e8f558750e1868c6fcbb15e2bec\" args=\"(TRACE trace)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::TRACE_Deallocate           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>trace</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nDeallocate a prev. allocated trace.<p>\n<dl compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"79d2fe6706153c0ceff1e3470fefa426\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_ExitsXferToNative\" ref=\"79d2fe6706153c0ceff1e3470fefa426\" args=\"(TRACE trace)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::TRACE_ExitsXferToNative           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>trace</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nAll exits from this trace go back to original code     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"f45374ef152ae9e634751f380fde39e6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_GenerateCode\" ref=\"f45374ef152ae9e634751f380fde39e6\" args=\"(TRACE trace)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">ADDRINT LEVEL_PINCLIENT::TRACE_GenerateCode           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>trace</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCompile and put trace in the code cache.<p>\n<dl compact><dt><b>Returns:</b></dt><dd>Address where the trace has been placed </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"04c81e8750b01807a367b9d2b4750991\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_RelocateOriginalInsAddr\" ref=\"04c81e8750b01807a367b9d2b4750991\" args=\"(ADDRINT addr)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">ADDRINT LEVEL_PINCLIENT::TRACE_RelocateOriginalInsAddr           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">ADDRINT&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>addr</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nCreate a trace from a specified address, Transfer all exits to native generated a code, put in in code cache and return an address <dl compact><dt><b>Parameters:</b></dt><dd>\n  <table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n    <tr><td valign=\"top\"></td><td valign=\"top\"><em>addr</em>&nbsp;</td><td>- trace entry address </td></tr>\n  </table>\n</dl>\n<dl compact><dt><b>Returns:</b></dt><dd>address of the generated code in code cache</dd></dl>\n<dl compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"c2e56309fafae7058494ecd59a96744d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_StraightenControlFlow\" ref=\"c2e56309fafae7058494ecd59a96744d\" args=\"(TRACE trace)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::TRACE_StraightenControlFlow           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc\">TRACE</a>&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>trace</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nBuild the control flow for the trace just generated; allows the traversing of the instructions inserted into the trace. This must be called prior to looking at a trace that has applied <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#65ef8545c3c4558e591a6ce11bbb52e9\">TRACE_AddInlineCallEdg</a> or <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#c8cc4050cbb42f925c1cb58f08ae85d7\">TRACE_AddInlineReturnEdg</a> functions for the adding of basic blocks to the trace. Upon invoking this function, the trace's control flow is fixed up to look as it would in the memory afer compilation.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"7fbc97767465a78117608323b5a07e52\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TraceFirstIns\" ref=\"7fbc97767465a78117608323b5a07e52\" args=\"(ADDRINT currTraceAddr)\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">INS LEVEL_PINCLIENT::TraceFirstIns           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"md\" nowrap valign=\"top\">ADDRINT&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap> <em>currTraceAddr</em>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nReturns the first instruction in the given trace.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"75098a371b4b052b8f2b7d64d2f808dc\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::UnInitializeApp\" ref=\"75098a371b4b052b8f2b7d64d2f808dc\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::UnInitializeApp           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nUninitialize app     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"e85f66d0e50f6222e2dd97d64fbb70ea\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::VmFunctionNotInitialized\" ref=\"e85f66d0e50f6222e2dd97d64fbb70ea\" args=\"()\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">VOID LEVEL_PINCLIENT::VmFunctionNotInitialized           </td>\n          <td class=\"md\" valign=\"top\">(&nbsp;</td>\n          <td class=\"mdname1\" valign=\"top\" nowrap>          </td>\n          <td class=\"md\" valign=\"top\">&nbsp;)&nbsp;</td>\n          <td class=\"md\" nowrap></td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nIf the pintool is executed without a vm, then some of the function pointers in ClientIntData will not be defined. Rather than jump to 0 and segv, we print a message.     </td>\n  </tr>\n</table>\n<hr><h2>Variable Documentation</h2>\n<a class=\"anchor\" name=\"78e750d35a09d252068994a9fd401172\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CLIENT_TLS_KEY_ALLOCATOR\" ref=\"78e750d35a09d252068994a9fd401172\" args=\"\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALTYPE typedef TLS_KEY_ALLOCATOR&lt;TLS_KEY_CLIENT_FIRST, TLS_KEY_CLIENT_LAST&gt; <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#78e750d35a09d252068994a9fd401172\">LEVEL_PINCLIENT::CLIENT_TLS_KEY_ALLOCATOR</a>          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nAllocator of TLS keys in client TLS.     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"b6c70477fc4b5e5ecb84f178bf60a15d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ClientIntData\" ref=\"b6c70477fc4b5e5ecb84f178bf60a15d\" args=\"\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALVAR PINCLIENTINT LEVEL_PINCLIENT::ClientIntData          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\n<b>Initial value:</b><div class=\"fragment\"><pre class=\"fragment\">\n{\n    \n    \n    PINCLIENTINT::MAGIC\n}\n</pre></div>    </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"3253ea7060c2ea491bfaf92eede1bd40\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MAX_IEH_CALLBACKS\" ref=\"3253ea7060c2ea491bfaf92eede1bd40\" args=\"\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">GLOBALCONST UINT32 <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#3253ea7060c2ea491bfaf92eede1bd40\">LEVEL_PINCLIENT::MAX_IEH_CALLBACKS</a> = 32          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nMaximum number of internal exception handling callbacks     </td>\n  </tr>\n</table>\n<a class=\"anchor\" name=\"66ef7fa2888f0aed01b601057cccbc95\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::pClientTlsKeyAllocator\" ref=\"66ef7fa2888f0aed01b601057cccbc95\" args=\"\" --><p>\n<table class=\"mdTable\" cellpadding=\"2\" cellspacing=\"0\">\n  <tr>\n    <td class=\"mdRow\">\n      <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n        <tr>\n          <td class=\"md\" nowrap valign=\"top\">LOCALVAR <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#78e750d35a09d252068994a9fd401172\">CLIENT_TLS_KEY_ALLOCATOR</a>* <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#66ef7fa2888f0aed01b601057cccbc95\">LEVEL_PINCLIENT::pClientTlsKeyAllocator</a>          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n<table cellspacing=\"5\" cellpadding=\"0\" border=\"0\">\n  <tr>\n    <td>\n      &nbsp;\n    </td>\n    <td>\n\n<p>\nSingle instance of the allocator of TLS keys in client TLS.     </td>\n  </tr>\n</table>\n<hr size=\"1\"><address style=\"align: right;\"><small>Generated on Wed Jan 21 02:16:19 2015 for Pin by&nbsp;\n<a href=\"http://www.doxygen.org/index.html\">\n<img src=\"doxygen.png\" alt=\"doxygen\" align=\"middle\" border=\"0\"></a> 1.4.6 </small></address>\n</body>\n</html>\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/group__KNOBS.html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html><head><meta http-equiv=\"Content-Type\" content=\"text/html;charset=iso-8859-1\">\n<title>Pin: Command Line Switches</title>\n<link href=\"doxygen.css\" rel=\"stylesheet\" type=\"text/css\">\n<link href=\"tabs.css\" rel=\"stylesheet\" type=\"text/css\">\n</head><body>\n<!-- Generated by Doxygen 1.4.6 -->\n<div class=\"tabs\">\n  <ul>\n    <li><a href=\"index.html\"><span>Main&nbsp;Page</span></a></li>\n    <li><a href=\"modules.html\"><span>Modules</span></a></li>\n    <li><a href=\"namespaces.html\"><span>Namespaces</span></a></li>\n    <li><a href=\"classes.html\"><span>Classes</span></a></li>\n    <li>\n      <form action=\"search.php\" method=\"get\">\n        <table cellspacing=\"0\" cellpadding=\"0\" border=\"0\">\n          <tr>\n            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>\n            <td><input type=\"text\" name=\"query\" value=\"\" size=\"20\" accesskey=\"s\"/></td>\n          </tr>\n        </table>\n      </form>\n    </li>\n  </ul></div>\n<h1>Command Line Switches</h1><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tr><td></td></tr>\n</table>\nThis section describes the command line switches that are currently supported by Pin.<p>\nPin switches should appear after the pin command, but before the -t &lt;tool&gt; option. The following Pin switches are supported:<p>\n<table frame=\"void\" rules=\"none\" cellspacing=\"10\" border=\"1\" cellpadding=\"3\">\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-follow_execv </td><td>Execute all processes spawned by the execv class system calls with Pin.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-help </td><td>Print the help message.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pause_tool &lt;n&gt; </td><td>Pause and print the PID so the debugger can be attached after the tool is loaded. Processing will resume after \"n\" seconds.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-logfile </td><td>Indicates the path and name of the log file. The default path is the current working directory. The default name is pin.log.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-unique_logfile </td><td>Appends the pid to the log file name.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-error_file </td><td>Indicates the path and name of the error file. The default path is the current working directory. If an error file is specified, all errors will be written to the error file, and will not be displayed on the console. If an error file is not specified, no error file will be created. The error file is designed to be parsed by tools that layer on top of Pin. See <a class=\"el\" href=\"group__ERROR__FILE__BASIC.html\">Pin Error Reporting Support</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-unique_error_file </td><td>Appends the pid to the error file name.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-injection &lt;mode&gt; </td><td>Where &lt;mode&gt; is one of dynamic, self, child, parent. UNIX-only. See <a class=\"el\" href=\"index.html#INJECTION\">Injection</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-inline </td><td>Inline simple analysis routines.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-log_inline </td><td>Report which analysis routines have been inlined in the pin.log file.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-cc_memory_size &lt;n&gt; </td><td>Max (in bytes) code cache size (0==unlimited, default). Must be a multiple of the code cache block size   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pid &lt;pid #&gt; </td><td>Attach Pin and the Pintool to an already running executable with the given process id.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pin_memory_range </td><td>Restrict pin to a memory range, 0x80000000:0x90000000 or size: 0:0x10000000.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-restrict_memory </td><td>Prevent PIN's dymamic loader from using these memory regions, 0x10000000:0x20000000   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pin_memory_size </td><td>Limit the number of bytes that can be dynamically allocated by PIN and PIN tool Note that the number of bytes allocated by PIN is defined by the total number of memory pages allocated by PIN multiplied by the page size   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-tool_load_option </td><td>Load the tool with additional flags. Currently supported flags are:<br>\n <b>deepbind:</b> (Linux only) Load the tool with the RTLD_DEEPBIND flag to make it a self-contained library. For more information see the dlopen man pages.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-t &lt;toolname&gt; </td><td>Specify the Pintool to use. If you are running a 32-bit application in an IA-32 architecture, or a 64-bit application on an Intel(R) 64 architecture, only -t &lt;toolname&gt; is needed. If you are running an application on an Intel(R) 64 architecture, where all of the components in the chain are either 32-bit or 64-bit, but not both, only -t &lt;toolname&gt; is needed. If you are running an application on an Intel(R) 64 architecture, where components in the chain are both 32-bit and 64-bit, use -t64 &lt;64-bit toolname&gt; to specify the 64-bit tool binary followed by -t &lt;32-bit toolname&gt; to specify the 32-bit tool binary and the tool options. For more information, see <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-t64 &lt;64-bit toolname&gt; </td><td>Specify 64-bit tool binary for Intel(R) 64 architecture. If you are running an application on an Intel(R) 64 architecture, where components in the chain are both 32-bit and 64-bit, use -t64 together with -t as described above. See <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>. <br>\n <b>Important</b>: Using -t64 without -t is not recommended, since in this case when given a 32-bit application, Pin will run the application without applying any tool.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-p32 &lt;toolname&gt; </td><td>Specify Pin binary for IA-32 architecture. See <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-p64 &lt;toolname&gt; </td><td>Specify Pin binary for Intel(R) 64 architecture. See <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-smc_support [1][0] </td><td>Enable (1) or disable (0) support for self-modifying code (SMC) in the application. This option is enabled by default.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-smc_strict [0][1] </td><td>Enable (1) or disable (0) support for SMC inside basic blocks. By default (0), pin assumes that basic blocks do not modify their own code.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" name=\"SWITCH_APPDEBUG\"></a> -appdebug  </td><td>Debug the application, stopping in the debugger as soon as the application is launched.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" name=\"SWITCH_APPDEBUG_ENABLE\"></a> -appdebug_enable  </td><td>Enable application level debugger support, but do not stop when the application is launched. Instead, you can connect a debugger after launch.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" name=\"SWITCH_APPDEBUG_SILENT\"></a> -appdebug_silent  </td><td>When application debugging is enabled, Pin normally prints a message telling how to connect an external debugger. This knob disables the message. Pin never prints this message when -appdebug_connection is specified.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" name=\"SWITCH_APPDEBUG_EXCLUDE\"></a> -appdebug_exclude  </td><td>When application debugging and -follow_execv are both specified, the default behavior is to enable debugging on all child processes. This knob, which is repeatable, specifies an application name for which debugging is disabled. Debugging is disabled for a process if it's argv[0] value matches one of the -appdebug_exclude names.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" name=\"SWITCH_APPDEBUG_ALLOW_REMOTE\"></a> -appdebug_allow_remote  </td><td>When application debugging is enabled, the default behavior requires the debugger to run on the same system as Pin. This knob allows Pin to connect to an external debugger that runs on a remote system. This knob is ignored when -appdebug_connection is specified because -appdebug_connection explicitly specifies the machine on which the debugger runs.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" name=\"SWITCH_APPDEBUG_CONNECTION\"></a> -appdebug_connection  </td><td>When application debugging is enabled, Pin's default behavior is to open a TCP port and wait for a debugger to connect. This knob reverses the roles; the debugger opens a TCP port and waits for Pin to connect to the port specified in this knob. The format of the knob value should be \"[ip]:port\". If the \"ip\" address is specified, it should be in dot-decimal notation. If \"ip\" is omitted, Pin connects to the specified port on the local machine. The port number should be specified in decimal. Note that this knob is never used when debugging with GDB.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-detach_reattach </td><td>Allow detach and reattach in probe mode. Windows* only.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-debug_instrumented_processes </td><td>Print message to allow debugger attach to instrumented processes. Windows* only.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-slow_asserts </td><td>Perform expensive sanity checks   </td></tr>\n</table>\n<p>\nPin also supports the following tool switches. Tool switches should be placed after the tool name, but before the double dash (\"--\").<p>\n<table frame=\"void\" rules=\"none\" cellspacing=\"10\" border=\"1\" cellpadding=\"3\">\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-logfile </td><td>Indicates the path and name of the log file. The default path is the current working directory. The default name is pintool.log.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-unique_logfile </td><td>Appends the pid to the log file name.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-discard_line_info &lt;module_name&gt; </td><td>Discard line information for specific module. Module name should be a short name without path, and not a symbolic link   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-discard_line_info_all </td><td>Discard line information for all modules.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-help </td><td>Print the help message.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-support_jit_api </td><td>Enables managed platforms support.  </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-short_name </td><td>Use the shortest name for the RTN. Names with version substrings are preferred over the same name without the substring.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-symbol_path &lt;list of paths&gt; </td><td>Specifies list of paths separated with semicolons that are searched to find symbol and line information. The list is searched when necessary after default search algorithm is applied. Default list is empty. Windows* only.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-slow_asserts </td><td>Perform expensive sanity checks. Recommended to be used in development and testing phase.   </td></tr>\n</table>\n<p>\nIf you want to add your own command line options to your tool, please see <a class=\"el\" href=\"group__KNOB__API.html\">KNOBS</a>. <hr size=\"1\"><address style=\"align: right;\"><small>Generated on Wed Jan 21 02:16:16 2015 for Pin by&nbsp;\n<a href=\"http://www.doxygen.org/index.html\">\n<img src=\"doxygen.png\" alt=\"doxygen\" align=\"middle\" border=\"0\"></a> 1.4.6 </small></address>\n</body>\n</html>\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/lib/libpin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/lib/libpinapp.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/lib/libpinjitprofiling.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/lib/libsapin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/lib/libpinvm.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/lib-ext/libpindwarf.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/runtime/GPLv3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/runtime/cpplibs/libgcc_s.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/runtime/cpplibs/libstdc++.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/runtime/cpplibs/libstdc++.so.6.0.13",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/runtime/cpplibs/libstdc++.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/runtime/cpplibs/libgcc_s.so.1",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Utils/hello_win.pdb-ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Utils/hello_win.pdb-intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Utils/hello_win.exe-ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Utils/hello_win.exe-intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/I18N/win_unicode_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/I18N/win_unicode_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/I18N/win_unicode_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/I18N/win_unicode_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_stdcall_app.pdb.zi.intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_stdcall_app.exe.zi.intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/probestdcall_app.pdb.zi",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_stdcall_app.pdb.zi.ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_defaultcall_app.exe.zi.intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_fastcall_app.pdb.zi.intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_defaultcall_app.pdb.zi.intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_fastcall_app.exe.zi.intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_stdcall_app.exe.zi.ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_fastcall_app.exe.zi.ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_fastcall_app.pdb.zi.ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_stdcall_app.exe.zi",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_defaultcall_app.exe.zi.ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/probestdcall_app.exe.zi",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/probefastcall_app.pdb.zi",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_defaultcall_app.pdb.zi.ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/probefastcall_app.exe.zi",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_stdcall_app.pdb.zi",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Tests/winapp_runs_pin_intel64.xex",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Tests/winapp_runs_pin.suo",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Tests/winapp_runs_pin.ico",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Tests/winapp_runs_pin.rc",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Tests/winapp_runs_pin_ia32.xex",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/lib/libpin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/lib/libpinapp.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/lib/libpinjitprofiling.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/lib/libsapin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/lib/libpinvm.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/lib-ext/libpindwarf.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/runtime/GPLv3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/runtime/cpplibs/libgcc_s.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/runtime/cpplibs/libstdc++.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/runtime/cpplibs/libstdc++.so.6.0.13",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/runtime/cpplibs/libstdc++.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/runtime/cpplibs/libgcc_s.so.1",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/extlib/libstdc++.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/extlib/libgcc_s.so.1",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/extlib/libm.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/extlib/libc.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/lib/libxed.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/lib/libxed-ild.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/search.idx",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2pnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/tab_l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2mlastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2folderopen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2plastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2vertline.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2lastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2blank.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2link.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2folderclosed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/tab_b.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/tab_r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2mnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2node.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/components/lib/intel64/libatomic.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/components/lib/intel64/libdebugger-protocol.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/components/lib/intel64/libdebugger-protocol.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/components/lib/ia32/libatomic.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/components/lib/ia32/libdebugger-protocol.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/components/lib/ia32/libdebugger-protocol.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/extlib/libstdc++.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/extlib/libgcc_s.so.1",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/extlib/libm.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/extlib/libc.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/lib/libxed.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/lib/libxed-ild.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/search.idx",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2pnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/tab_l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2mlastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2folderopen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2plastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2vertline.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2lastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2blank.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2link.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2folderclosed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/tab_b.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/tab_r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2mnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2node.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/search.idx",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/tab_l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/pin-debugger-project-properties1.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/pin-debugger-option-pages-properties.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/pin-debugger-attach.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/tab_b.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/stack-debugger-commands.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/pin-debugger-project-properties2.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/stack-debugger-custom-break.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/tab_r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/doxygen.png"
    ],
    "total_files": 3245
}