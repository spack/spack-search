{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/AttachDetach/secondary_attach_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n   Test the scenario when Pin attaches to an application, using PIN_AttachProbed API,\n   which one of its secondary thread is a zombie thread .\n   Pin wouldn't attach to the zombie thread and wouldn't give a thread detach callbacks on detach\n   to the zombie thread.\n*/\n\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <pthread.h>\n#include <sstream>\n#include <fstream>\n#include <sys/wait.h>\n#include \"zombie_utils.h\"\n\nEXPORT_SYM bool AfterAttach1();\n\nconst char * fileName;\n\nconst char *imageToLoad;\n\npid_t zombieThreadPid;\n\npid_t parentPid;\n\nbool AfterAttach1()\n{\n    // Pin sets an analysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\n// This function is invoked when the secondary thread starts to execute.\nvoid* SecondaryThreadMain(void* v) \n{\n    void *handle = dlopen(imageToLoad, RTLD_LAZY); \n\n    if(!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", imageToLoad, dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    pthread_exit(0);  \n}\n\n// Expected argv arguments:\n// [1] pin executable\n// [2] -slow_assert\n// [3] tool\n// [4] imageName \n// [5] output file\t\n\nint main(int argc, char** argv)\n{\n    if(argc!=6)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n\n    imageToLoad= argv[4];\n    fileName = argv[5];\n    parentPid = getpid();\n    pid_t child = fork();\n    \n    if (child < 0)\n    {\n        perror(\"Fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    {\n        // Pin sets an analysis function here to notify the application\n        // when Pin attaches to it in the first attach session.\n        while(!AfterAttach1())\n        {\n            sleep(1);\n        }\n\n        NotifyTestType(TEST_TYPE_SECONDARY_THREAD_ZOMBIE_IN_REATTACH);\n\n        pthread_t tid;\n        pthread_create(&tid, NULL, SecondaryThreadMain, NULL);\n        fprintf(stderr, \"APP: tid of zombie: %d\\n\", (int)tid);\n        \n        while(1);\n    }\n    \n    if (child == 0)\n    {\n        // Inside child \n        pid_t second_child_pid = fork ();\n        \n        if (second_child_pid < 0)\n        {\n            perror(\"Fork failed while creating application process\");\n            exit(RES_FORK_FAILED);\n        }\n\n        if (second_child_pid > 0)\n        {\n            // Inside parent 2\n            waitpid(second_child_pid, 0, 0); // wait until Pin is injected to the application process.\n            exit(RES_SUCCESS);\n        }\n        else\n        { \n            // Inside child 2\n            char attachPid[MAX_SIZE];\n            snprintf(attachPid, MAX_SIZE , \"%d\", parentPid);\n\n            // Pin attaches to the application.\n            execl(argv[1], argv[1], argv[2], \"-probe\",\"-pid\", attachPid,  \"-t\",  argv[3], \"-o\", argv[5], NULL); // never return\n            perror(\"execl failed while trying to attach Pin to the application\\n\");\n            exit(RES_EXEC_FAILED);\n        }\n    }\n\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/AttachDetach/reattach_probed_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*! @file\n *  Test detaching - reattach Pin on Linux\n *  The application creates threads in a loop. Each thread does some work and exits.\n *  The process in endless, expected to be stopped by tool.\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <math.h>\n#include \"../Utils/threadlib.h\"\n\n#define NTHREADS 20\n\n#ifdef TARGET_LINUX\n\n#define DLL_SUFFIX \".so\"\n\n#elif defined(TARGET_MAC)\n\n#define DLL_SUFFIX \".dylib\"\n\n#endif\n\n# define TLS_GET_GS_REG() \\\n  ({ int __seg; __asm (\"movw %%gs, %w0\" : \"=q\" (__seg)); __seg & 0xffff; })\n\n\nvolatile bool loop1, loop2 ;\nvoid * thread_func (void *arg)\n{    \n    while (loop2)\n    {\n        void *space = malloc(300);\n        //sleep(1);\n        free(space);\n    }\n    return 0;\n\n}\n\ntypedef  double (*DLL_FUNC)(double x);\ntypedef  int (*DLL_INT_FUNC)(int x);\n\n\nvoid * thread_dlopen_func (void *arg)\n{    \n    double number = 0.2;\n    double calculatedValue = 0;\n    while (loop1)\n    {\n        void *handle = dlopen(\"libmy_dll\" DLL_SUFFIX, RTLD_LAZY);\n        if (handle)\n        {\n            DLL_FUNC fptr = (DLL_FUNC)dlsym(handle, \"my_dll_sin\");\n            calculatedValue += (*fptr)(number);\n            \n            //sleep(1);\n            dlclose(handle);\n        }\n        else \n        {\n            fprintf(stderr, \"error opening my_dll\" DLL_SUFFIX \", thread %ld\\n\", GetTid());\n            exit(-1);\n        } \n        number += 0.01;\n    }\n        \n    return 0;\n}\n\nint main (int argc, char *argv[])\n{\n    unsigned long gs_val = TLS_GET_GS_REG();\n    while (1)\n    {\n        loop1 = true;\n        loop2 = true;\n        pthread_t h[NTHREADS];\n        \n        pthread_create (&h[0], 0, thread_dlopen_func, 0);\n        for (unsigned long i = 1; i < NTHREADS; i++)\n        {\n            pthread_create (&h[i], 0, thread_func, 0);\n        }\n        sleep(1);\n\n        loop1 = false;\n        loop2 = false;\n\n        for (unsigned long i = 0; i < NTHREADS; i++)\n        {\n            pthread_join (h[i], 0);\n        }\n    }    \n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/AttachDetach/attachReattachThreadDetachCallbacks_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <pthread.h>\n\n#define EXPORT_SYM extern \"C\"\n\n#define NTHREADS 20\n\nvolatile bool loop;\n\nEXPORT_SYM bool AfterAttach1();\n\nEXPORT_SYM bool AfterAttach2();\n\nstatic int MAX_SIZE = 128; /*maximum line size*/\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_FORK_FAILED,      // 1\n    RES_EXEC_FAILED,      // 2\n    RES_LOAD_FAILED,      // 3\n    RES_INVALID_ARGS      // 4\n};\n\nbool AfterAttach1()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nvoid * thread_func (void *arg)\n{    \n    while (loop)\n    {\n         sched_yield();\n    }\n    return 0;\n}\n\n/*\n    Expected argv arguments:\n    [1] pin executable\n    [2] \"slow asserts\"\n    [3] tool\n    [4] output file\n    [5] First imageName\n\t[6] Second imageName\n*/\nint main(int argc, char** argv)\n{\n    fprintf(stderr, \"Start main\\n\");\n\t\n    if(argc!=7)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n\n    loop  = true;\n\n    int ret_val;\n    pthread_t h[NTHREADS];\n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        ret_val= pthread_create (&h[i], 0, thread_func, 0);\n        if(ret_val) \n        {\n            perror(\"ERROR, pthread_create failed\");\n            exit(1);\n        }\n    }\n\t\n    pid_t parentPid = getpid();\n    pid_t child = fork();\n    if (child < 0)\n    {\n        perror(\"Fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    { \n\t\twhile(!AfterAttach1())\n        {\n            sleep(1);\n        }\n        \n\t\tvoid *handle = dlopen(argv[5], RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n        \n\t\twhile(!AfterAttach2())\n        {\n            sleep(1);\n        }\n\n        handle = dlopen(argv[6], RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[2], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n        \n        while(1)\n        {\n            // expected to be stopped by tool.\n            sleep(1);\n        }\n    }\n\t\n    if ( child == 0 )\n    {\n        // Inside child\n        char attachPid[MAX_SIZE];\n        snprintf(attachPid ,MAX_SIZE , \"%d\", parentPid);\n        execl(argv[1],argv[2],\"-pid\", attachPid, \"-t\",  argv[3], \"-o\", argv[4], NULL);\n        perror(\"execl failed while trying to attach Pin to the application\\n\");\n        exit(RES_EXEC_FAILED);\n    }\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/AttachDetach/detach_probed_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*! @file\n *  Test detaching Pin from running process on a Unix compatible system\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n\n#define NTHREADS 20\n\n#ifdef TARGET_MAC\n# define DLL_SUFFIX \".dylib\"\n#else\n# define DLL_SUFFIX \".so\"\n#endif\n\nextern \"C\" void TellPinToDetach(unsigned long *updateWhenReady)\n{\n    return;\n}\n\nvolatile bool loop2 = true;\nvoid * thread_func (void *arg)\n{    \n    while (loop2)\n    {\n        void *space = malloc(300);\n        sleep(1);\n        free(space);\n    }\n    return 0;\n\n}\n\nvolatile bool loop1 = true;\ntypedef  double (*SIN_FUNC)(double x);\n\nvoid * thread_dlopen_func (void *arg)\n{    \n\tdouble number = 0.2;\n    while (loop1)\n    {\n        void *handle = dlopen(\"libm\" DLL_SUFFIX, RTLD_LAZY);\n        if (handle)\n        {\n            SIN_FUNC sin_fptr = (SIN_FUNC)dlsym(handle, \"sin\");\n            if (sin_fptr)\n            {\n                double val = (*sin_fptr)(number);\n                printf(\"val = %.4f\\n\", val);\n            }\n            sleep(2);\n            dlclose(handle);\n        }\n\t\tnumber += 0.01;\n    }\n        \n    return 0;\n\n}\n\nint main (int argc, char *argv[])\n{\n    pthread_t h[NTHREADS];\n    \n    pthread_create (&h[0], 0, thread_dlopen_func, 0);\n    for (unsigned long i = 1; i < NTHREADS; i++)\n    {\n        pthread_create (&h[i], 0, thread_func, 0);\n    }\n    \n\tunsigned long pinDetached = false;\n    TellPinToDetach(&pinDetached);\n    \n\twhile (!pinDetached)\n\t{\n    \tsleep(2);\n\t}\n    \n    loop1 = false;\n    loop2 = false;\n    \n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        pthread_join (h[i], 0);\n    }\n    printf(\"All threads exited. The test PASSED\\n\");    \n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/AttachDetach/main_attach_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n   Test the scenario where Pin tries to reattach to an application, using PIN_AttachProbed API,\n   when the main thread of the application is a zombie thread.\n   Pin wouldn't attach to the application in this scenario. \n   Instead, Pin will give a message to the user notifying why Pin didn't attach to the application and the\n   application will continue to run natively\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <fstream>\n#include <sstream>\n#include \"zombie_utils.h\"\n\n\nEXPORT_SYM bool AfterAttach1();\n\npid_t zombieThreadPid;\n\nconst char * fileName;\n\nconst char *imageToLoad;\n\nbool AfterAttach1()\n{\n    // Pin sets an analysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\n// This function is invoked when the secondary thread starts execution.\nvoid* SecondaryThreadMain(void* v) \n{\n    // Wait until Pin notifies the application that it can't reattach to it since\n    // the main thread of the application is a zombie thread.\n    while(!NotifyUserPinUnableToAttach(fileName)) sleep(1);\n    pthread_exit(0);  \n}\n\n// Expected argv arguments:\n// [1] pin executable\n// [2] -slow_assert\n// [3] tool\n// [4] imageName \n// [5] output file\t\nint main(int argc, char** argv)\n{\n    if(argc!=6)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n\n    imageToLoad= argv[4];\n    fileName = argv[5];\n    zombieThreadPid = getpid();\n    pid_t child = fork();\n    \n    if (child < 0)\n    {\n        perror(\"Fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    { \n        // Pin sets an analysis function here to notify the application\n        // when Pin attaches to it in the first attach session.\n        while(!AfterAttach1())\n        {\n            sleep(1);\n        }\n\n        NotifyTestType(TEST_TYPE_MAIN_THREAD_ZOMBIE_IN_REATTACH);\n\n        NotifyZombiePid(zombieThreadPid);\n\n        pthread_t tid;\n        pthread_create(&tid, NULL, SecondaryThreadMain, NULL);\n\n        // When the image is loaded into the memory,\n        // the tool instructs Pin to detach from the application.\n        void *handle = dlopen(imageToLoad, RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", imageToLoad, dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }  \n\n        // After calling to thread_exit(0) function, the main thread is going to become a zombie thread.\n        // Pin should not attach to the application.\n        // Instead, Pin should give a message to the user notifying why Pin didn't attach to the application.\n        pthread_exit(0);\n    }\n\n    if (child == 0)\n    {\n        // Inside child 1\n        pid_t second_child_pid = fork ();\n        \n        if (second_child_pid < 0)\n        {\n            perror(\"Fork failed while creating application process\");\n            exit(RES_FORK_FAILED);\n        }\n\n        if (second_child_pid > 0)\n        {\n            // Inside parent 2\n            waitpid(second_child_pid, 0, 0); // wait until Pin is injected to the application process.\n            exit(RES_SUCCESS);\n        }\n        else\n        { \n            //Inside child 2\n            char attachPid[MAX_SIZE];\n            snprintf(attachPid, MAX_SIZE , \"%d\", zombieThreadPid);\n\n            // Pin  attaches to the application.\n            // never return\n            execl(argv[1], argv[1], argv[2], \"-probe\", \"-pid\", attachPid, \"-t\",  argv[3],\"-o\", argv[5], NULL);\n            perror(\"execl failed while trying to attach Pin to the application\\n\");\n            exit(RES_EXEC_FAILED);\n        }\n    } \n\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/AttachDetach/reattach_jit_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*! @file\n *  Test detaching - reattach Pin on Linux\n *  The application creates threads in a loop. Each thread does some work and exits.\n *  The process in signaled by the pintool (by replacing AppShouldExit()) that it should exit.\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <math.h>\n#include \"../Utils/threadlib.h\"\n\n#define NTHREADS 20\n\nvolatile bool loop1, loop2 ;\nvoid * thread_func (void *arg)\n{\n    while (loop2)\n    {\n        void *space = malloc(300);\n        //sleep(1);\n        free(space);\n    }\n    return 0;\n\n}\n\nextern \"C\" int AppShouldExit()\n{\n    return 0;\n}\n\ntypedef  double (*DLL_FUNC)(double x);\ntypedef  int (*DLL_INT_FUNC)(int x);\n\n\nvoid * thread_dlopen_func (void *arg)\n{\n    double number = 0.2;\n    double calculatedValue = 0;\n    while (loop1)\n    {\n        void *handle = dlopen(\"libmy_dll.so\", RTLD_LAZY);\n        if (handle)\n        {\n            DLL_FUNC fptr = (DLL_FUNC)dlsym(handle, \"my_dll_sin\");\n            calculatedValue += (*fptr)(number);\n\n            //sleep(1);\n            dlclose(handle);\n        }\n        else\n        {\n            fprintf(stderr, \"error opening my_dll.so, thread %d\\n\", GetTid());\n            exit(-1);\n        }\n        number += 0.01;\n    }\n\n    return 0;\n}\n\nint main (int argc, char *argv[])\n{\n    const unsigned int numOfSeconds = 5 * 60; // allow 5 minutes\n    unsigned int secondsRemaining = numOfSeconds;\n    for (; secondsRemaining && (!AppShouldExit()) ; --secondsRemaining)\n    {\n        loop1 = true;\n        loop2 = true;\n        pthread_t h[NTHREADS];\n\n        pthread_create (&h[0], 0, thread_dlopen_func, 0);\n        for (unsigned long i = 1; i < NTHREADS; i++)\n        {\n            pthread_create (&h[i], 0, thread_func, 0);\n        }\n        sleep(1);\n\n        loop1 = false;\n        loop2 = false;\n\n        for (unsigned long i = 0; i < NTHREADS; i++)\n        {\n            pthread_join (h[i], 0);\n        }\n    }\n    if (secondsRemaining == 0)\n    {\n        fprintf(stderr, \"ERROR: The application ran for %u seconds without completion\\n\", numOfSeconds);\n        return 1;\n    }\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/AttachDetach/launchReattachThreadDetachCallbacks_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <pthread.h>\n\n#define EXPORT_SYM extern \"C\"\n\n#define NTHREADS 20\n\n\nvolatile bool loop;\n\nEXPORT_SYM bool AfterAttach2();\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_LOAD_FAILED,      // 1\n    RES_INVALID_ARGS      // 2    \n};\n\n\n\nvoid * thread_func (void *arg)\n{    \n    while (loop)\n    {\n         sched_yield();\n    }\n    return 0;\n}\n\n/*\n    Expected argv arguments:\n    [1]\tFirst image to load\t\n    [2]\tSecond image to load\n*/\nint main (int argc, char *argv[])\n{\n    if(argc!=3)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n\n    loop = true;\n\t\n    pthread_t h[NTHREADS];\n    int ret_val;\n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        ret_val= pthread_create (&h[i], 0, thread_func, 0);\n        if(ret_val) \n        {\n            perror(\"ERROR, pthread_create failed\");\n            exit(1);\n        }\n    }\n\n\tvoid *handle = dlopen(argv[1], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n    \n\twhile(!AfterAttach2())\n    {\n        sleep(1);\n    }\n    \n    handle = dlopen(argv[2], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[2], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        pthread_join (h[i], 0);\n    }\n\n    return RES_SUCCESS;\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/MemTranslate/malloc_translation_app.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#define _GNU_SOURCE\n#include <dlfcn.h>\n#include <link.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// The highest bit value in a pointer\n#define HIGHEST_BIT ((uintptr_t)1 << (8 * sizeof(void*) - 1))\n// Turn on the highest bit in a pointer\n#define MK_PTR(ptr) ((void*)(((uintptr_t)ptr) | HIGHEST_BIT))\n// Turn off the highest bit in a pointer\n#define STRIP_PTR(ptr) ((void*)((uintptr_t)ptr & ~HIGHEST_BIT))\n\n// Initial allocator buffer (see below for explnaition).\nstatic char initial_buf[1024*1024];\nstatic size_t initial_buf_idx = 0;\n\nstatic void* (*libc_malloc)(size_t) = NULL;\nstatic void* (*libc_calloc)(size_t, size_t) = NULL;\nstatic void* (*libc_realloc)(void *ptr, size_t) = NULL;\nstatic void (*libc_free)(void*) = NULL;\n\n/*\n * Initialize all malloc related symbols from libc\n */\nvoid __attribute__((constructor)) init()\n{\n    libc_malloc = dlsym(RTLD_NEXT, \"malloc\");\n    libc_calloc = dlsym(RTLD_NEXT, \"calloc\");\n    libc_realloc = dlsym(RTLD_NEXT, \"realloc\");\n    libc_free = dlsym(RTLD_NEXT, \"free\");\n}\n\n/*********************************************************\n * Below we implement an initial allocator.\n * The first allocated bytes cannot be allocate with libc's\n * memory allocation function.\n * This is merely because calling dlsym() in the loader, to\n * get the address of libc's memory allocation function,\n * causes the loader to call calloc() (the overriden version\n * of calloc()) and if we call dlsym() in calloc() it will\n * eventually cause an infinite recursion.\n * To overcome this, we implement a simple allocator here\n * that allocates the first bytes of the program from\n * the static buffer initial_buf[].\n *********************************************************/\nvoid *initial_malloc(size_t size)\n{\n    void* ret;\n    if (sizeof(initial_buf) < initial_buf_idx + size + sizeof(size_t))\n    {\n        return NULL;\n    }\n    *((size_t*)&initial_buf[initial_buf_idx]) = size;\n    ret = (void*)&initial_buf[initial_buf_idx + sizeof(size_t)];\n    initial_buf_idx += ((size + 2 * sizeof(size_t) - 1) / sizeof(size_t)) * sizeof(size_t);\n    return ret;\n}\n\nsize_t initial_free(void* ptr)\n{\n    if ((ptr >= (void*)initial_buf) && (ptr < (void*)&initial_buf[initial_buf_idx]))\n    {\n        return *((size_t*)ptr - 1);\n    }\n    return 0;\n}\n\n/*********************************************************\n * Wrapper functions for libc memory allocation functions.\n * Here we translate the memory addresses in and out of\n * memory allocation function so the highest bit in the\n * memory address will be turn on.\n *********************************************************/\nvoid *malloc(size_t size)\n{\n    void* ret;\n    if (NULL != (ret = initial_malloc(size)))\n    {\n        return MK_PTR(ret);\n    }\n    return MK_PTR(libc_malloc(size));\n}\n\nvoid *calloc(size_t nmemb, size_t size)\n{\n    void* ret;\n    if (NULL != (ret = initial_malloc(nmemb*size)))\n    {\n        return MK_PTR(ret);\n    }\n    return MK_PTR(libc_calloc(nmemb, size));\n}\n\nvoid *realloc(void *ptr, size_t size)\n{\n    size_t old_size;\n    if (0 != (old_size = initial_free(STRIP_PTR(ptr))))\n    {\n        void* new_ptr = malloc(size);\n        memcpy(STRIP_PTR(new_ptr), STRIP_PTR(ptr), size<old_size?size:old_size);\n        return new_ptr;\n    }\n    return MK_PTR(libc_realloc(STRIP_PTR(ptr), size));\n}\n\nvoid free(void *ptr)\n{\n    if (0 < initial_free(STRIP_PTR(ptr)))\n    {\n        return;\n    }\n    return libc_free(STRIP_PTR(ptr));\n}\n\n/*\n * This simple program just loads the library which its filename was\n * provided ain the command line arguments\n */\nint main(int argc, char* argv[])\n{\n    if (argc != 2)\n    {\n        fprintf(stderr, \"Usage: %s <path to dynamic library>\\n\", argv[0]);\n        exit(1);\n    }\n    const char* file = argv[1];\n    printf(\"Loading shared object %s\\n\", file);\n    fflush(stdout);\n    void *handle = dlopen(file, RTLD_NOW | RTLD_LOCAL);\n    if (NULL == handle)\n    {\n        fprintf(stderr,\"Failed to load %s - %s\\n\", file, dlerror());\n        exit(1);\n    }\n    printf(\"Unloading shared object %s\\n\", file);\n    fflush(stdout);\n    dlclose(handle);\n\n    printf(\"Application finished successfully!\\n\");\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Replay/ia32_cross_os_replay.reference": "[ 0]+ /disk/PinTools/Utils/obj-ia32/cp-pin    \nFunction 'main' loaded at 8048d90\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n[ 1]+ /lib/ld-linux.so.2                      \nFunction 'rtld_lock_default_unlock_recursive' loaded at 555558c0\nFunction 'relocate_doit' loaded at 55556770\nFunction 'fillin_rpath' loaded at 5555a3c0\nFunction 'decompose_rpath' loaded at 5555c9f0\nFunction 'do_lookup_x' loaded at 5555e380\nFunction '_dl_map_object_deps' loaded at 55560e40\nFunction '_dl_sort_fini' loaded at 55562ba0\nFunction 'match_symbol' loaded at 55563930\nFunction '_dl_next_tls_modid' loaded at 55564e10\nFunction '_dl_tls_setup' loaded at 55565940\nFunction '_dl_runtime_resolve' loaded at 55567930\nFunction '__assert_fail' loaded at 55568870\nFunction 'calloc' loaded at 55568f60\nFunction 'profil_counter' loaded at 55569560\nFunction '__lseek' loaded at 555698d0\nFunction '__madvise' loaded at 55569e50\nFunction 'strlen' loaded at 5556a270\nFunction '__i686.get_pc_thunk.cx' loaded at 5556ae47\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n[ 2]+ /usr/lib/libstdc++.so.6                 \nFunction '_ZN9__gnu_cxx17__pool_alloc_base12_M_get_mutexEv' loaded at 56d760f0\nFunction '_ZN9__gnu_cxx6__poolILb1EE13_M_initializeEPFvPvE' loaded at 56d774d0\nFunction '_ZNKSt7codecvtIwc11__mbstate_tE16do_always_noconvEv' loaded at 56d78800\nFunction '_ZNSt7codecvtIcc11__mbstate_tEC1Ej' loaded at 56d78c10\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE7_M_copyEPwPKwj' loaded at 56d78f70\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE15_M_check_lengthEjjPKc' loaded at 56d791c0\nFunction '_ZNKSt14basic_ofstreamIwSt11char_traitsIwEE7is_openEv' loaded at 56d79900\nFunction '_ZStlsIdcSt11char_traitsIcEERSt13basic_ostreamIT0_T1_ES6_RKSt7complexIT_E' loaded at 56d7a7f0\nFunction '_ZNKSt5ctypeIcE9do_narrowEPKcS2_cPc' loaded at 56d7bdf0\nFunction '_ZNSt5ctypeIcED2Ev' loaded at 56d7c340\nFunction '_ZNSt12ctype_bynameIwEC2EPKcj' loaded at 56d7c880\nFunction '_ZN11__gnu_debug19_Safe_sequence_base7_M_swapERS0_' loaded at 56d7da10\nFunction '_ZSt18__throw_bad_typeidv' loaded at 56d7de60\nFunction '_ZNSt12out_of_rangeD0Ev' loaded at 56d7e0f0\nFunction '_ZSt23__throw_underflow_errorPKc' loaded at 56d7e480\nFunction '_ZNSt8ios_base6xallocEv' loaded at 56d7edd0\nFunction '_ZNSt8ios_base7failureC1ERKSs' loaded at 56d7f3c0\nFunction '_ZNSt8ios_base7_M_initEv' loaded at 56d808d0\nFunction '_ZNSt6localeC2ERKS_' loaded at 56d80b10\nFunction '_ZNSt6locale5_ImplD2Ev' loaded at 56d81310\nFunction '_ZNSt6locale5_ImplC2Ej' loaded at 56d81e00\nFunction '_ZNSt6localeC2ERKS_S1_i' loaded at 56d84170\nFunction '_ZNSt11logic_errorC2ERKSs' loaded at 56d86830\nFunction '_ZNSt13runtime_errorC2ERKSs' loaded at 56d86af0\nFunction '_ZNSt13runtime_errorD0Ev' loaded at 56d86e20\nFunction '_ZNSt12strstreambuf7_M_freeEPc' loaded at 56d870e0\nFunction '_ZNSt12strstreambuf9underflowEv' loaded at 56d87330\nFunction '_ZNSt12strstreambufC2EPaiS0_' loaded at 56d87c80\nFunction '_ZNSt12strstreambufC1EPKhi' loaded at 56d88450\nFunction '_ZNSt10ostrstreamD2Ev' loaded at 56d88cb0\nFunction '_ZNSt10istrstreamD1Ev' loaded at 56d89480\nFunction '_ZNSt9strstreamD0Ev' loaded at 56d89bf0\nFunction '_ZSt18_Rb_tree_decrementPKSt18_Rb_tree_node_base' loaded at 56d8a2d0\nFunction '_ZNSaIwED1Ev' loaded at 56d8a8c0\nFunction '_ZNSt13basic_filebufIcSt11char_traitsIcEE13_M_set_bufferEi' loaded at 56d8b6c0\nFunction '_ZNSt13basic_filebufIwSt11char_traitsIwEE27_M_allocate_internal_bufferEv' loaded at 56d8b8b0\nFunction '_ZNSt13basic_filebufIwSt11char_traitsIwEE9pbackfailEj' loaded at 56d8be20\nFunction '_ZNSt13basic_filebufIcSt11char_traitsIcEE6xsgetnEPci' loaded at 56d8d060\nFunction '_ZNSt14basic_ifstreamIwSt11char_traitsIwEE7is_openEv' loaded at 56d8e080\nFunction '_ZNSt13basic_filebufIwSt11char_traitsIwEED0Ev' loaded at 56d8e980\nFunction '_ZNSt13basic_filebufIcSt11char_traitsIcEE9showmanycEv' loaded at 56d8f250\nFunction '_ZNSt14basic_ofstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode' loaded at 56d8f860\nFunction '_ZNSt14basic_ofstreamIwSt11char_traitsIwEEC2Ev' loaded at 56d8fe60\nFunction '_ZNSt14basic_ofstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode' loaded at 56d904d0\nFunction '_ZNSt14basic_ifstreamIcSt11char_traitsIcEEC1Ev' loaded at 56d90d40\nFunction '_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev' loaded at 56d91430\nFunction '_ZTv0_n12_NSt13basic_fstreamIcSt11char_traitsIcEED0Ev' loaded at 56d91dc0\nFunction '_ZNSt13basic_fstreamIwSt11char_traitsIwEED2Ev' loaded at 56d92260\nFunction '_ZNKSt9basic_iosIwSt11char_traitsIwEE7rdstateEv' loaded at 56d93680\nFunction '_ZNSt9basic_iosIcSt11char_traitsIcEEC1Ev' loaded at 56d938f0\nFunction '_ZNSt9basic_iosIcSt11char_traitsIcEED2Ev' loaded at 56d93c00\nFunction '_ZNKSt9basic_iosIwSt11char_traitsIwEE3badEv' loaded at 56d93fe0\nFunction '_ZNSt9basic_iosIwSt11char_traitsIwEE10exceptionsESt12_Ios_Iostate' loaded at 56d941d0\nFunction '_ZNSt9basic_iosIwSt11char_traitsIwEE5imbueERKSt6locale' loaded at 56d944a0\nFunction '_ZNSt14basic_iostreamIwSt11char_traitsIwEEC1Ev' loaded at 56d94f60\nFunction '_ZNSdC1Ev' loaded at 56d95280\nFunction '_ZNSirsEPFRSt8ios_baseS0_E' loaded at 56d954d0\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEErsEPFRSt8ios_baseS4_E' loaded at 56d95600\nFunction '_ZStrsISt11char_traitsIcEERSt13basic_istreamIcT_ES5_Pa' loaded at 56d958a0\nFunction '_ZStrsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_St12_Setiosflags' loaded at 56d95b40\nFunction '_ZTv0_n12_NSt13basic_istreamIwSt11char_traitsIwEED1Ev' loaded at 56d95e20\nFunction '_ZStrsIcSt11char_traitsIcEERSt13basic_istreamIT_T0_ES6_RS3_' loaded at 56d96650\nFunction '_ZNSi3getERSt15basic_streambufIcSt11char_traitsIcEE' loaded at 56d96fa0\nFunction '_ZNSirsERy' loaded at 56d97a40\nFunction '_ZSt2wsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_' loaded at 56d987a0\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEE3getERSt15basic_streambufIwS1_Ew' loaded at 56d99390\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEErsERf' loaded at 56d99e80\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEE6sentryC2ERS2_b' loaded at 56d9abf0\nFunction '_ZNKSt10moneypunctIcLb0EE13thousands_sepEv' loaded at 56d9c540\nFunction '_ZNKSt10moneypunctIcLb0EE14do_frac_digitsEv' loaded at 56d9c6c0\nFunction '_ZNKSt10moneypunctIcLb1EE10pos_formatEv' loaded at 56d9c890\nFunction '_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' loaded at 56d9cb50\nFunction '_ZNSt16__numpunct_cacheIcEC1Ej' loaded at 56d9cda0\nFunction '_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRe' loaded at 56d9d200\nFunction '_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPKv' loaded at 56d9d5f0\nFunction '_ZNSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEEC2Ej' loaded at 56d9d850\nFunction '_ZNKSt8messagesIcE4openERKSsRKSt6locale' loaded at 56d9db80\nFunction '_ZNSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED0Ev' loaded at 56d9dfc0\nFunction '_ZNSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEED1Ev' loaded at 56d9e1e0\nFunction '_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED2Ev' loaded at 56d9e3f0\nFunction '_ZSt9has_facetISt8numpunctIcEEbRKSt6locale' loaded at 56d9e810\nFunction '_ZSt9use_facetISt10moneypunctIcLb0EEERKT_RKSt6locale' loaded at 56d9ebb0\nFunction '_ZNSt7collateIcEC2Ej' loaded at 56d9ef10\nFunction '_ZNSt8messagesIcED1Ev' loaded at 56d9f290\nFunction '_ZNSt16__numpunct_cacheIcED2Ev' loaded at 56d9f6d0\nFunction '_ZNSt15numpunct_bynameIcED2Ev' loaded at 56d9fb30\nFunction '_ZNSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' loaded at 56d9ffb0\nFunction '_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' loaded at 56da0310\nFunction '_ZNSt15messages_bynameIcEC2EPKcj' loaded at 56da07c0\nFunction '_ZNSt11__timepunctIcEC2Ej' loaded at 56da0fc0\nFunction '_ZNKSt8numpunctIcE12do_falsenameEv' loaded at 56da12f0\nFunction '_ZNSt10moneypunctIcLb1EEC2EP15__locale_structPKcj' loaded at 56da17f0\nFunction '_ZNKSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPK2tmPKcSB_' loaded at 56da1c80\nFunction '_ZNSt15numpunct_bynameIcEC1EPKcj' loaded at 56da2180\nFunction '_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE14do_get_weekdayES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm' loaded at 56da3b00\nFunction '_ZNKSt7collateIcE12do_transformEPKcS2_' loaded at 56da68d0\nFunction '_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' loaded at 56dac390\nFunction '_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE15_M_insert_floatIeEES3_S3_RSt8ios_baseccT_' loaded at 56daeb10\nFunction '_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE6do_putES3_RSt8ios_basecm' loaded at 56db0310\nFunction '_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRm' loaded at 56db2f10\nFunction '_ZStlsIcSt11char_traitsIcESaIcEERSt13basic_ostreamIT_T0_ES7_RKSbIS4_S5_T1_E' loaded at 56db5520\nFunction '_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEPFRS2_S3_E' loaded at 56db5a10\nFunction '_ZNSoC2EPSt15basic_streambufIcSt11char_traitsIcEE' loaded at 56db5ba0\nFunction '_ZNSoC1Ev' loaded at 56db5e20\nFunction '_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_' loaded at 56db6470\nFunction '_ZNSoD2Ev' loaded at 56db6a40\nFunction '_ZNSolsEs' loaded at 56db6d50\nFunction '_ZNSo5writeEPKci' loaded at 56db7af0\nFunction '_ZNSolsEx' loaded at 56db8a50\nFunction '_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEi' loaded at 56db9e90\nFunction '_ZSt4endsIwSt11char_traitsIwEERSt13basic_ostreamIT_T0_ES6_' loaded at 56dbb170\nFunction '_ZNKSt19basic_ostringstreamIcSt11char_traitsIcESaIcEE5rdbufEv' loaded at 56dbba10\nFunction '_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE6setbufEPwi' loaded at 56dbbd40\nFunction '_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE3strERKSbIwS1_S2_E' loaded at 56dbc7f0\nFunction '_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode' loaded at 56dbcc90\nFunction '_ZNKSt18basic_stringstreamIcSt11char_traitsIcESaIcEE3strEv' loaded at 56dbd7f0\nFunction '_ZNKSt19basic_istringstreamIwSt11char_traitsIwESaIwEE3strEv' loaded at 56dbdfc0\nFunction '_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEED2Ev' loaded at 56dbe670\nFunction '_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode' loaded at 56dbee50\nFunction '_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode' loaded at 56dbf9a0\nFunction '_ZTv0_n12_NSt19basic_istringstreamIwSt11char_traitsIwESaIwEED0Ev' loaded at 56dc0180\nFunction '_ZTv0_n12_NSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev' loaded at 56dc0a90\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEE10pubseekposESt4fposI11__mbstate_tESt13_Ios_Openmode' loaded at 56dc12e0\nFunction '_ZNKSt15basic_streambufIcSt11char_traitsIcEE4pptrEv' loaded at 56dc1420\nFunction '_ZNSt15basic_streambufIwSt11char_traitsIwEE10pubseekoffExSt12_Ios_SeekdirSt13_Ios_Openmode' loaded at 56dc14f0\nFunction '_ZNKSt15basic_streambufIwSt11char_traitsIwEE5pbaseEv' loaded at 56dc1680\nFunction '_ZNSt15basic_streambufIwSt11char_traitsIwEEaSERKS2_' loaded at 56dc1740\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEEC1Ev' loaded at 56dc1a40\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEED1Ev' loaded at 56dc1ce0\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEE7seekposESt4fposI11__mbstate_tESt13_Ios_Openmode' loaded at 56dc1e40\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEE5sputcEc' loaded at 56dc2150\nFunction '_ZNKSs7_M_dataEv' loaded at 56dc26e0\nFunction '_ZNKSs4sizeEv' loaded at 56dc2820\nFunction '_ZNSs4_Rep15_M_set_sharableEv' loaded at 56dc28e0\nFunction '_ZNKSs5emptyEv' loaded at 56dc2d70\nFunction '_ZNKSs16find_last_not_ofEcj' loaded at 56dc3010\nFunction '_ZNKSs13find_first_ofEcj' loaded at 56dc33e0\nFunction '_ZNKSs4rendEv' loaded at 56dc3740\nFunction '_ZNKSs7compareEjjRKSs' loaded at 56dc3b60\nFunction '_ZNSsC2EPKcjRKSaIcE' loaded at 56dc4040\nFunction '_ZNSsC1IPcEET_S1_RKSaIcE' loaded at 56dc4470\nFunction '_ZNSs6appendEPKcj' loaded at 56dc4a00\nFunction '_ZNSs6assignEPKc' loaded at 56dc5100\nFunction '_ZNSs6insertEN9__gnu_cxx17__normal_iteratorIPcSsEEjc' loaded at 56dc54e0\nFunction '_ZNSs7_M_leakEv' loaded at 56dc59b0\nFunction '_ZNSsD2Ev' loaded at 56dc5d10\nFunction '_ZNSs7replaceEjjPKc' loaded at 56dc63b0\nFunction '_ZNSt8valarrayIjED2Ev' loaded at 56dc6700\nFunction '_ZNKSt10moneypunctIwLb0EE13positive_signEv' loaded at 56dc6dc0\nFunction '_ZNKSt10moneypunctIwLb1EE13decimal_pointEv' loaded at 56dc6f70\nFunction '_ZNKSt10moneypunctIwLb1EE16do_thousands_sepEv' loaded at 56dc7100\nFunction '_ZNKSt8numpunctIwE13decimal_pointEv' loaded at 56dc74b0\nFunction '_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRt' loaded at 56dc76f0\nFunction '_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE3putES3_RSt8ios_basewb' loaded at 56dc7b10\nFunction '_ZNKSt11__timepunctIwE20_M_date_time_formatsEPPKw' loaded at 56dc7ea0\nFunction '_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10date_orderEv' loaded at 56dc8130\nFunction '_ZNKSt8messagesIwE8do_closeEi' loaded at 56dc8430\nFunction '_ZNSt8time_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED0Ev' loaded at 56dc87b0\nFunction '_ZNSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEED1Ev' loaded at 56dc89d0\nFunction '_ZSt9has_facetISt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEEbRKSt6locale' loaded at 56dc8cb0\nFunction '_ZSt9has_facetISt7codecvtIwc11__mbstate_tEEbRKSt6locale' loaded at 56dc9110\nFunction '_ZSt9use_facetISt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEERKT_RKSt6locale' loaded at 56dc9470\nFunction '_ZNSt14codecvt_bynameIwc11__mbstate_tED1Ev' loaded at 56dc97d0\nFunction '_ZNSt15messages_bynameIwED0Ev' loaded at 56dc9bb0\nFunction '_ZNSt18__moneypunct_cacheIwLb1EED1Ev' loaded at 56dca010\nFunction '_ZNSt17moneypunct_bynameIwLb1EED1Ev' loaded at 56dca3f0\nFunction '_ZNSt8numpunctIwEC1EP15__locale_structj' loaded at 56dca870\nFunction '_ZNSt18__moneypunct_cacheIwLb0EEC2Ej' loaded at 56dcabf0\nFunction '_ZNSt17__timepunct_cacheIwEC1Ej' loaded at 56dcb110\nFunction '_ZNKSt10moneypunctIwLb0EE16do_negative_signEv' loaded at 56dcb8b0\nFunction '_ZNSt10moneypunctIwLb1EEC1EPSt18__moneypunct_cacheIwLb1EEj' loaded at 56dcbe10\nFunction '_ZNSt8messagesIwEC1EP15__locale_structPKcj' loaded at 56dcc1f0\nFunction '_ZNSt15time_get_bynameIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEC2EPKcj' loaded at 56dcc8d0\nFunction '_ZNSt17moneypunct_bynameIwLb0EEC2EPKcj' loaded at 56dccd40\nFunction '_ZNSt14collate_bynameIwEC2EPKcj' loaded at 56dcf9b0\nFunction '_ZNKSt9money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb1EEES3_S3_RSt8ios_basewRKSbIwS2_SaIwEE' loaded at 56dd1030\nFunction '_ZNKSt9money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10_M_extractILb0EEES3_S3_S3_RSt8ios_baseRSt12_Ios_IostateRSs' loaded at 56dd4110\nFunction '_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE13_M_insert_intIxEES3_S3_RSt8ios_basewT_' loaded at 56dd7b60\nFunction '_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRx' loaded at 56dda050\nFunction '_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_putES3_RSt8ios_basewb' loaded at 56ddcfc0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE5beginEv' loaded at 56ddd810\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE4_Rep12_M_is_sharedEv' loaded at 56ddd8e0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE4findEPKwjj' loaded at 56dddca0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE17find_first_not_ofEwj' loaded at 56dddf40\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE13find_first_ofEPKwjj' loaded at 56dde330\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE12find_last_ofEPKwj' loaded at 56dde6a0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE7compareEjjRKS2_jj' loaded at 56dde9c0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_jjRKS1_' loaded at 56ddefa0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEEC1EPKwRKS1_' loaded at 56ddf3b0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE9push_backEw' loaded at 56ddf8d0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEED2Ev' loaded at 56ddfe30\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPwS2_EEw' loaded at 56de0420\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE6insertEjRKS2_jj' loaded at 56de0910\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE6rbeginEv' loaded at 56de0c30\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE7replaceEjjPKw' loaded at 56de1210\nFunction '_ZNKSt7codecvtIwc11__mbstate_tE9do_lengthERS0_PKcS4_j' loaded at 56de15e0\nFunction '_ZNKSt5ctypeIwE11do_scan_notEtPKwS2_' loaded at 56de1dc0\nFunction '_ZNKSt5ctypeIwE10do_toupperEw' loaded at 56de21e0\nFunction '_ZNSt10moneypunctIwLb0EED2Ev' loaded at 56de2ab0\nFunction '_ZNSt10moneypunctIcLb0EE24_M_initialize_moneypunctEP15__locale_structPKc' loaded at 56de3090\nFunction '_ZNSt8numpunctIwE22_M_initialize_numpunctEP15__locale_struct' loaded at 56de4390\nFunction '_ZNSt12__basic_fileIcE4syncEv' loaded at 56de5a80\nFunction '_ZNSt12__basic_fileIcE6xsgetnEPci' loaded at 56de5f30\nFunction '_ZdlPvRKSt9nothrow_t' loaded at 56de62c0\nFunction '__cxa_begin_catch' loaded at 56de66c0\nFunction '__cxa_call_unexpected' loaded at 56de6d30\nFunction '__cxa_guard_release' loaded at 56de7630\nFunction '__cxa_pure_virtual' loaded at 56de7970\nFunction '_ZN10__cxxabiv117__class_type_infoD0Ev' loaded at 56de7b30\nFunction '_ZNSt10bad_typeidD1Ev' loaded at 56de7d50\nFunction '_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_' loaded at 56de8060\nFunction '_ZN10__cxxabiv117__pbase_type_infoD2Ev' loaded at 56de8a60\nFunction '_ZN10__cxxabiv120__function_type_infoD0Ev' loaded at 56de8c70\nFunction '_ZNK10__cxxabiv119__pointer_type_info15__pointer_catchEPKNS_17__pbase_type_infoEPPvj' loaded at 56de8ef0\nFunction '__cxa_vec_new' loaded at 56de95e0\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n[ 3]+ /lib/libm.so.6                          \nFunction '__i686.get_pc_thunk.bx' loaded at 56e2e4c7\nFunction 'fegetenv' loaded at 56e30a90\nFunction '__ieee754_asin' loaded at 56e30db0\nFunction '__ieee754_y0' loaded at 56e314e0\nFunction '__ieee754_log10' loaded at 56e32c10\nFunction 'cbrt' loaded at 56e335f0\nFunction 'logb' loaded at 56e340d0\nFunction 'asin' loaded at 56e34840\nFunction 'hypot' loaded at 56e34e30\nFunction 'log10' loaded at 56e35560\nFunction 'nan' loaded at 56e35b00\nFunction 'creal' loaded at 56e35f10\nFunction 'csin' loaded at 56e36b80\nFunction 'clog10' loaded at 56e37d60\nFunction '__finite' loaded at 56e382b0\nFunction '__ieee754_atan2f' loaded at 56e386d0\nFunction 'ponef' loaded at 56e38ee0\nFunction '__ieee754_remainderf' loaded at 56e3a280\nFunction 'cbrtf' loaded at 56e3ab60\nFunction 'logbf' loaded at 56e3b4d0\nFunction 'asinf' loaded at 56e3b9e0\nFunction 'hypotf' loaded at 56e3bff0\nFunction 'log10f' loaded at 56e3c6c0\nFunction 'nanf' loaded at 56e3cc50\nFunction 'crealf' loaded at 56e3cf60\nFunction 'csinf' loaded at 56e3dab0\nFunction 'clog10f' loaded at 56e3e9d0\nFunction 'finitef' loaded at 56e3ee00\nFunction '__ieee754_atan2l' loaded at 56e3f320\nFunction 'pone' loaded at 56e3fff0\nFunction '__ieee754_remainderl' loaded at 56e41730\nFunction 'cbrtl' loaded at 56e41ca0\nFunction 'logbl' loaded at 56e42800\nFunction 'atan2l' loaded at 56e42db0\nFunction 'y0l' loaded at 56e43420\nFunction 'powl' loaded at 56e43b90\nFunction 'truncl' loaded at 56e44180\nFunction 'cabsl' loaded at 56e444c0\nFunction 'ctanl' loaded at 56e45540\nFunction 'fmal' loaded at 56e466c0\nFunction 'copysignl' loaded at 56e46ae0\nFunction '__divdc3' loaded at 56e48190\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n[ 4]+ /lib/libgcc_s.so.1                      \nFunction '__ashldi3' loaded at 56e5a8e0\nFunction '__subvsi3' loaded at 56e5abe0\nFunction '__ctzdi2' loaded at 56e5b030\nFunction '__mulxc3' loaded at 56e5bd70\nFunction '__fixdfdi' loaded at 56e5d020\nFunction '__udivmoddi4' loaded at 56e5d8e0\nFunction '_Unwind_GetGR' loaded at 56e5dcd0\nFunction '__register_frame_info' loaded at 56e60260\nFunction '.fini' loaded at 56e62104\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n[ 5]+ /lib/libc.so.6                          \nFunction 'gnu_get_libc_version' loaded at 56e79980\nFunction '__divdi3' loaded at 56e79ee0\nFunction '__gconv_close' loaded at 56e7adc0\nFunction '__gconv_find_transform' loaded at 56e7bab0\nFunction 'add_alias' loaded at 56e7c180\nFunction '__gconv_transform_ascii_internal' loaded at 56e7e080\nFunction '__gconv_translit_find' loaded at 56e81e20\nFunction '__gconv_lookup_cache' loaded at 56e82780\nFunction '_L_unlock_996' loaded at 56e838fc\nFunction 'rangecmp' loaded at 56e84640\nFunction '__duplocale' loaded at 56e85ad0\nFunction '__collseq_table_lookup' loaded at 56e85f30\nFunction 'isdigit' loaded at 56e86400\nFunction '__isascii_l' loaded at 56e866a0\nFunction 'ispunct_l' loaded at 56e86810\nFunction 'set_binding_values' loaded at 56e869d0\nFunction '__dcigettext' loaded at 56e87a10\nFunction 'dcngettext' loaded at 56e88220\nFunction '_nl_expand_alias' loaded at 56e89d40\nFunction 'new_exp_2' loaded at 56e8a920\nFunction 'finite' loaded at 56e8bd40\nFunction 'copysignf' loaded at 56e8c0f0\nFunction 'modfl' loaded at 56e8c3b0\nFunction '__libc_longjmp' loaded at 56e8c810\nFunction 'sigpending' loaded at 56e8cd90\nFunction 'sigpause' loaded at 56e8d1f0\nFunction 'sigaddset' loaded at 56e8d5a0\nFunction '__libc_current_sigrtmax_private' loaded at 56e8d8f0\nFunction 'sigset' loaded at 56e8de10\nFunction '_quicksort' loaded at 56e8e360\nFunction '_L_lock_22' loaded at 56e8f45a\nFunction 'exit' loaded at 56e8f530\nFunction 'div' loaded at 56e8f9d0\nFunction 'initstate' loaded at 56e8fef0\nFunction 'setstate_r' loaded at 56e90070\nFunction 'mrand48' loaded at 56e90610\nFunction 'jrand48_r' loaded at 56e908d0\nFunction 'strtoll' loaded at 56e90ca0\nFunction 'strtoull_l' loaded at 56e92390\nFunction '__strtof_l' loaded at 56e948e0\nFunction 'do_system' loaded at 56e99720\nFunction 'realpath' loaded at 56e99cf0\nFunction '__xpg_basename' loaded at 56e9b780\nFunction 'wcstoimax' loaded at 56e9c020\nFunction '__mpn_add_n' loaded at 56e9c4a0\nFunction '__mpn_impn_sqr_n_basecase' loaded at 56e9cfa0\nFunction '__mpn_construct_double' loaded at 56e9ddf0\nFunction '_itowa' loaded at 56e9e690\nFunction '_L_unlock_11056' loaded at 56ea35aa\nFunction 'printf_size_info' loaded at 56ea77b0\nFunction 'group_number' loaded at 56ea8220\nFunction 'vfscanf' loaded at 56eb2050\nFunction 'perror_internal' loaded at 56eb6cd0\nFunction '__path_search' loaded at 56eb7770\nFunction 'ftrylockfile' loaded at 56eb7ea0\nFunction '_IO_file_doallocate' loaded at 56eb8b50\nFunction '_L_unlock_161' loaded at 56eb9245\nFunction '__fopen_internal' loaded at 56eb9690\nFunction '_L_lock_41' loaded at 56eb9bdc\nFunction '_L_unlock_185' loaded at 56eb9ecf\nFunction '_L_lock_47' loaded at 56eba57b\nFunction '_IO_proc_close' loaded at 56ebaa70\nFunction '_L_unlock_110' loaded at 56ebb13e\nFunction '_IO_setbuffer' loaded at 56ebb4a0\nFunction '_L_unlock_95' loaded at 56ebb894\nFunction '_L_unlock_105' loaded at 56ebbda2\nFunction 'getwchar' loaded at 56ebc020\nFunction '_L_lock_43' loaded at 56ebc4e9\nFunction 'putwc' loaded at 56ebc940\nFunction '_L_unlock_81' loaded at 56ebcc61\nFunction 'vswprintf' loaded at 56ebcf20\nFunction '_IO_sungetwc' loaded at 56ebd360\nFunction 'save_for_wbackup' loaded at 56ebd7c0\nFunction '_IO_wstr_finish' loaded at 56ebe140\nFunction '_IO_wdo_write' loaded at 56ebf2a0\nFunction 'do_out' loaded at 56ebfb00\nFunction '_L_lock_29' loaded at 56ec0220\nFunction '_L_lock_30' loaded at 56ec04ae\nFunction '_L_lock_29' loaded at 56ec08df\nFunction '_L_lock_30' loaded at 56ec0c7e\nFunction '_IO_strn_overflow' loaded at 56ec1080\nFunction 'ftello' loaded at 56ec1670\nFunction 'ftello64' loaded at 56ec1b60\nFunction '__fpending' loaded at 56ec1e00\nFunction '_L_unlock_17' loaded at 56ec25f2\nFunction '_L_lock_29' loaded at 56ec2814\nFunction '_IO_file_sync_mmap' loaded at 56ec2d30\nFunction '_IO_do_write' loaded at 56ec3a10\nFunction '_IO_file_setbuf_mmap' loaded at 56ec44a0\nFunction 'flush_cleanup' loaded at 56ec4fa0\nFunction '_IO_sgetn' loaded at 56ec55a0\nFunction '_IO_adjust_column' loaded at 56ec5960\nFunction '_IO_default_seek' loaded at 56ec5fc0\nFunction '_IO_list_lock' loaded at 56ec6070\nFunction '_IO_default_doallocate' loaded at 56ec67e0\nFunction '_L_unlock_280' loaded at 56ec6c3e\nFunction '_L_lock_1784' loaded at 56ec6cca\nFunction '_IO_str_pbackfail' loaded at 56ec6f60\nFunction '__failing_morecore' loaded at 56ec75a0\nFunction 'ptmalloc_init' loaded at 56ec7ef0\nFunction 'cfree' loaded at 56ec91a0\nFunction 'realloc_check' loaded at 56ecaaa0\nFunction 'realloc_hook_ini' loaded at 56ecbad0\nFunction '_L_unlock_2466' loaded at 56ecc04a\nFunction '_L_unlock_4424' loaded at 56ecc0e2\nFunction '_L_unlock_8320' loaded at 56ecc17a\nFunction '_L_lock_9316' loaded at 56ecc20f\nFunction '_L_unlock_9886' loaded at 56ecc29b\nFunction '_L_unlock_10772' loaded at 56ecc327\nFunction 'mprobe' loaded at 56ecc510\nFunction 'mtrace' loaded at 56eccc10\nFunction '_L_lock_751' loaded at 56ecd4f3\nFunction '_obstack_memory_used' loaded at 56ecd8f0\nFunction '__strdup' loaded at 56ecdfd0\nFunction 'strpbrk' loaded at 56ece820\nFunction 'bcmp' loaded at 56ecf180\nFunction 'ffsll' loaded at 56ecfd90\nFunction '_wordcopy_fwd_aligned' loaded at 56ed0310\nFunction 'rawmemchr' loaded at 56ed0b90\nFunction 'argz_insert' loaded at 56ed1180\nFunction 'envz_add' loaded at 56ed1970\nFunction '__memset_gcn_by4' loaded at 56ed3700\nFunction '__strncat_g' loaded at 56ed3950\nFunction '__strcspn_g' loaded at 56ed3b40\nFunction '__strcspn_c1' loaded at 56ed3f70\nFunction '__strsep_3c' loaded at 56ed4270\nFunction '__xpg_strerror_r' loaded at 56ed4680\nFunction 'wcsncpy' loaded at 56ed4aa0\nFunction 'wmemset' loaded at 56ed4f80\nFunction 'mbsrtowcs' loaded at 56ed58e0\nFunction 'wcstoll' loaded at 56ed6550\nFunction '____wcstol_l_internal' loaded at 56ed6870\nFunction '____wcstod_l_internal' loaded at 56ed8040\nFunction 'wcscoll' loaded at 56ede440\nFunction '_nl_cleanup_ctype' loaded at 56ee0000\nFunction 'asctime' loaded at 56ee0c60\nFunction 'guess_time_tm' loaded at 56ee0eb0\nFunction '__tzstring' loaded at 56ee1be0\nFunction '_L_unlock_2123' loaded at 56ee287f\nFunction 'ftime' loaded at 56ee39c0\nFunction 'memcpy_uppcase' loaded at 56ee68e0\nFunction '_nl_init_alt_digit' loaded at 56eeab60\nFunction '_nl_cleanup_time' loaded at 56eeafe0\nFunction '_L_unlock_119' loaded at 56eeb4ac\nFunction 'alphasort' loaded at 56eeb840\nFunction '_L_lock_246' loaded at 56eebee0\nFunction '_L_lock_27' loaded at 56eec50a\nFunction 'getgrgid' loaded at 56eecca0\nFunction '_L_unlock_290' loaded at 56eed201\nFunction 'getgrgid_r' loaded at 56eed4e0\nFunction '_L_unlock_116' loaded at 56eee03e\nFunction '_L_lock_25' loaded at 56eee5d6\nFunction '_L_unlock_233' loaded at 56eee8bd\nFunction 'times' loaded at 56eef2d0\nFunction 'pause' loaded at 56eefb10\nFunction 'execle' loaded at 56ef0120\nFunction 'getegid' loaded at 56ef09a0\nFunction 'getsid' loaded at 56ef0c60\nFunction 'setlogin' loaded at 56ef1140\nFunction 'handle_intel' loaded at 56ef1a00\nFunction 'collated_compare' loaded at 56ef3be0\nFunction 'end_pattern' loaded at 56ef5f50\nFunction 're_node_set_contains' loaded at 56efa780\nFunction 'find_subexp_node' loaded at 56efad00\nFunction 'lower_subexps' loaded at 56efb590\nFunction 'free_dfa_content' loaded at 56efb9d0\nFunction 'check_arrival_expand_ecl' loaded at 56efc4b0\nFunction 're_node_set_init_copy' loaded at 56efd1f0\nFunction 'build_upper_buffer' loaded at 56efe6f0\nFunction 'check_arrival' loaded at 56efffa0\nFunction 'parse_bracket_exp' loaded at 56f02cf0\nFunction 'set_regs' loaded at 56f05f40\nFunction 're_exec' loaded at 56f08f60\nFunction '_getopt_long_only_r' loaded at 56f0a650\nFunction '__sched_get_priority_min' loaded at 56f0a940\nFunction 'in6aicmp' loaded at 56f0ad30\nFunction '_L_lock_9088' loaded at 56f0e70d\nFunction 'eval_expr' loaded at 56f0ed40\nFunction 'pread' loaded at 56f12850\nFunction 'posix_spawn_file_actions_addclose' loaded at 56f12cb0\nFunction 'posix_spawnattr_setpgroup' loaded at 56f12fa0\nFunction 'posix_spawnattr_setschedparam' loaded at 56f13760\nFunction '__xstat64' loaded at 56f13b70\nFunction 'fstatfs64' loaded at 56f143f0\nFunction 'mkdir' loaded at 56f14a00\nFunction '__close' loaded at 56f15160\nFunction '__fcntl_nocancel' loaded at 56f15750\nFunction 'creat64' loaded at 56f15cc0\nFunction 'getttyname' loaded at 56f162f0\nFunction 'readlinkat' loaded at 56f17050\nFunction 'object_compare' loaded at 56f184b0\nFunction 'fts_palloc' loaded at 56f19850\nFunction 'posix_fadvise' loaded at 56f1afc0\nFunction '__internal_statvfs' loaded at 56f1bea0\nFunction 'tcsetpgrp' loaded at 56f1c4c0\nFunction 'setrlimit64' loaded at 56f1c8f0\nFunction '__sbrk' loaded at 56f1cdb0\nFunction 'setregid' loaded at 56f1d440\nFunction '___newselect_nocancel' loaded at 56f1d84a\nFunction 'sethostid' loaded at 56f1de50\nFunction 'usleep' loaded at 56f1e150\nFunction 'getfsspec' loaded at 56f1e570\nFunction '_L_lock_1062' loaded at 56f1f144\nFunction 'ftruncate64' loaded at 56f1f5c0\nFunction 'endusershell' loaded at 56f1fcc0\nFunction 'openlog_internal' loaded at 56f20390\nFunction '_L_lock_1085' loaded at 56f20c4c\nFunction 'madvise' loaded at 56f21070\nFunction 'fcvt_r' loaded at 56f21420\nFunction 'hsearch_r' loaded at 56f22060\nFunction 'tsearch' loaded at 56f22a40\nFunction 'errx' loaded at 56f23040\nFunction 'dirname' loaded at 56f238b0\nFunction 'listxattr' loaded at 56f23d30\nFunction 'vm86' loaded at 56f24080\nFunction 'gnu_dev_major' loaded at 56f24450\nFunction 'capget' loaded at 56f24730\nFunction 'inotify_add_watch' loaded at 56f24a30\nFunction 'prctl' loaded at 56f24d60\nFunction 'getpeername' loaded at 56f250c0\nFunction 'setsockopt' loaded at 56f25500\nFunction '__libc_msgsnd' loaded at 56f259a0\nFunction 'shmget' loaded at 56f25f10\nFunction 'pc_to_index' loaded at 56f26b80\nFunction 'iswxdigit' loaded at 56f27410\nFunction 'iswpunct' loaded at 56f27c50\nFunction 'iswalpha_l' loaded at 56f28270\nFunction '__towlower_l' loaded at 56f28880\nFunction '_L_unlock_111' loaded at 56f28cd6\nFunction 'getspent_r' loaded at 56f29440\nFunction '_nss_files_parse_spent' loaded at 56f298b0\nFunction '_L_lock_34' loaded at 56f2a3eb\nFunction '__argp_fmtstream_update' loaded at 56f2a500\nFunction '__argp_fmtstream_puts' loaded at 56f2af00\nFunction 'until_short' loaded at 56f2b2d0\nFunction 'usage_argful_short_opt' loaded at 56f2c270\nFunction 'argp_help' loaded at 56f2e4a0\nFunction 'argp_usage' loaded at 56f2f580\nFunction 'pthread_attr_setschedparam' loaded at 56f2f7d0\nFunction 'pthread_cond_signal' loaded at 56f2fa10\nFunction 'pthread_self' loaded at 56f2fc50\nFunction '_L_lock_116' loaded at 56f2ff5a\nFunction 'inet_ntop4' loaded at 56f30490\nFunction 'net_mask' loaded at 56f30ec0\nFunction 'skip_ws' loaded at 56f324c0\nFunction '_L_unlock_68' loaded at 56f3306e\nFunction '__nss_configure_lookup' loaded at 56f33a70\nFunction '__nss_getent' loaded at 56f34000\nFunction '__nss_group_lookup' loaded at 56f34eb0\nFunction '__backtrace' loaded at 56f35490\nFunction '__sprintf_chk' loaded at 56f35e60\nFunction '_L_unlock_99' loaded at 56f362af\nFunction '_L_unlock_302' loaded at 56f36680\nFunction '__pread64_chk' loaded at 56f36be0\nFunction '__wmemcpy_chk' loaded at 56f36ee0\nFunction '__vswprintf_chk' loaded at 56f37220\nFunction '_L_lock_35' loaded at 56f376ca\nFunction '_L_unlock_247' loaded at 56f379a7\nFunction '__wcsnrtombs_chk' loaded at 56f37c70\nFunction '_L_unlock_63' loaded at 56f38084\nFunction '__h_errno_location' loaded at 56f38530\nFunction '_L_unlock_149' loaded at 56f38ddb\nFunction '_L_unlock_73' loaded at 56f396ee\nFunction '_L_lock_28' loaded at 56f39c55\nFunction '_L_lock_148' loaded at 56f39fee\nFunction '_L_lock_24' loaded at 56f3a5ed\nFunction '_L_unlock_237' loaded at 56f3a8ce\nFunction '_L_lock_27' loaded at 56f3b036\nFunction '_L_unlock_72' loaded at 56f3b54e\nFunction '_L_unlock_111' loaded at 56f3b7b6\nFunction '_L_unlock_167' loaded at 56f3bbce\nFunction 'ether_ntoa_r' loaded at 56f3c510\nFunction 'rresvport_af' loaded at 56f3d200\nFunction '__internal_setnetgrent_reuse' loaded at 56f3ed70\nFunction '_L_unlock_711' loaded at 56f3f622\nFunction '_L_lock_28' loaded at 56f3f9ad\nFunction '_L_lock_25' loaded at 56f3fc16\nFunction 'if_nameindex' loaded at 56f40ba0\nFunction 'inet6_option_init' loaded at 56f41ee0\nFunction 'setsourcefilter' loaded at 56f42720\nFunction 'authnone_create_once' loaded at 56f43340\nFunction 'xdr_authunix_parms' loaded at 56f43b70\nFunction 'clntraw_geterr' loaded at 56f448e0\nFunction 'clnttcp_freeres' loaded at 56f44fc0\nFunction 'clntudp_freeres' loaded at 56f45930\nFunction 'pmap_unset' loaded at 56f46810\nFunction 'pmap_rmtcall' loaded at 56f47720\nFunction '__rpc_thread_variables' loaded at 56f480a0\nFunction 'svcerr_weakauth' loaded at 56f483b0\nFunction 'xprt_unregister' loaded at 56f48920\nFunction 'svcraw_getargs' loaded at 56f48e30\nFunction 'svctcp_freeargs' loaded at 56f495e0\nFunction 'svctcp_rendezvous_abort' loaded at 56f49c40\nFunction 'svcudp_recv' loaded at 56f4a4f0\nFunction 'xdr_u_longlong_t' loaded at 56f4ab90\nFunction 'xdr_wrapstring' loaded at 56f4afb0\nFunction 'xdrmem_setpos' loaded at 56f4b520\nFunction 'skip_input_bytes' loaded at 56f4b7c0\nFunction 'xdrrec_getbytes' loaded at 56f4bb50\nFunction 'xdrstdio_create' loaded at 56f4c150\nFunction 'xdrstdio_getpos' loaded at 56f4c400\nFunction 'x_destroy' loaded at 56f4c790\nFunction 'xdr_authdes_cred' loaded at 56f4d030\nFunction 'key_get_conv' loaded at 56f4e400\nFunction '_L_unlock_445' loaded at 56f4e8df\nFunction 'xdr_keystatus' loaded at 56f4ec90\nFunction '_svcauth_des' loaded at 56f4f730\nFunction 'clntunix_create' loaded at 56f50340\nFunction 'svcunixfd_create' loaded at 56f50ed0\nFunction '_create_xid' loaded at 56f516a0\nFunction 'xdr_uint8_t' loaded at 56f51ac0\nFunction '__nscd_gethostbyname2_r' loaded at 56f52fd0\nFunction 'get_mapping' loaded at 56f53dc0\nFunction 'getutent' loaded at 56f546c0\nFunction 'endutent' loaded at 56f549f0\nFunction 'getutline' loaded at 56f54b40\nFunction '__utmp_equal' loaded at 56f55040\nFunction 'updwtmp' loaded at 56f55fb0\nFunction 'setutxent' loaded at 56f56cb0\nFunction 'dl_iterate_phdr' loaded at 56f56e70\nFunction '__libc_dlopen_mode' loaded at 56f57510\nFunction 'fde_unencoded_compare' loaded at 56f57b40\nFunction '__register_frame' loaded at 56f58350\nFunction '_L_lock_136' loaded at 56f59129\nFunction '_Unwind_GetIP' loaded at 56f591e0\nFunction 'read_uleb128' loaded at 56f59b50\nFunction '_IO_old_cookie_seek' loaded at 56f59eb0\nFunction '_L_lock_68' loaded at 56f5a7ea\nFunction '_L_lock_36' loaded at 56f5ab9c\nFunction '_IO_file_xsputn' loaded at 56f5af40\nFunction '_IO_old_file_finish' loaded at 56f5bae0\nFunction 'versionsort64' loaded at 56f5c090\nFunction 'sched_setaffinity' loaded at 56f5d210\nFunction 'getspent_r' loaded at 56f5d550\nFunction 'gethostbyname2_r' loaded at 56f5d7f0\nFunction 'getservbyport_r' loaded at 56f5dbe0\nFunction 'free_mem' loaded at 56f5dff0\nFunction 'free_mem' loaded at 56f5e5c0\nFunction '_L_unlock_44' loaded at 56f5e905\nFunction '__rpc_thread_destroy' loaded at 56f5ec70\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 6]- /disk/PinTools/Utils/obj-ia32/cp-pin    \n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 5]- /lib/ld-linux.so.2                      \n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 4]- /usr/lib/libstdc++.so.6                 \n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 3]- /lib/libm.so.6                          \n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 2]- /lib/libgcc_s.so.1                      \n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 1]- /lib/libc.so.6                          \n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Replay/ia32_cross_os_replay.record": "L '/disk/PinTools/Utils/obj-ia32/cp-pin' 8048ad8 781 0 1 \n\t'main' 8048d90\nEND_RTN_LIST\nL '/lib/ld-linux.so.2' 555557c0 157ab 55555000 0 \n\t'rtld_lock_default_unlock_recursive' 555558c0\n\t'relocate_doit' 55556770\n\t'fillin_rpath' 5555a3c0\n\t'decompose_rpath' 5555c9f0\n\t'do_lookup_x' 5555e380\n\t'_dl_map_object_deps' 55560e40\n\t'_dl_sort_fini' 55562ba0\n\t'match_symbol' 55563930\n\t'_dl_next_tls_modid' 55564e10\n\t'_dl_tls_setup' 55565940\n\t'_dl_runtime_resolve' 55567930\n\t'__assert_fail' 55568870\n\t'calloc' 55568f60\n\t'profil_counter' 55569560\n\t'__lseek' 555698d0\n\t'__madvise' 55569e50\n\t'strlen' 5556a270\n\t'__i686.get_pc_thunk.cx' 5556ae47\nEND_RTN_LIST\nL '/usr/lib/libstdc++.so.6' 56d7182c 7c6b5 56d37000 0 \n\t'_ZN9__gnu_cxx17__pool_alloc_base12_M_get_mutexEv' 56d760f0\n\t'_ZN9__gnu_cxx6__poolILb1EE13_M_initializeEPFvPvE' 56d774d0\n\t'_ZNKSt7codecvtIwc11__mbstate_tE16do_always_noconvEv' 56d78800\n\t'_ZNSt7codecvtIcc11__mbstate_tEC1Ej' 56d78c10\n\t'_ZNSbIwSt11char_traitsIwESaIwEE7_M_copyEPwPKwj' 56d78f70\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE15_M_check_lengthEjjPKc' 56d791c0\n\t'_ZNKSt14basic_ofstreamIwSt11char_traitsIwEE7is_openEv' 56d79900\n\t'_ZStlsIdcSt11char_traitsIcEERSt13basic_ostreamIT0_T1_ES6_RKSt7complexIT_E' 56d7a7f0\n\t'_ZNKSt5ctypeIcE9do_narrowEPKcS2_cPc' 56d7bdf0\n\t'_ZNSt5ctypeIcED2Ev' 56d7c340\n\t'_ZNSt12ctype_bynameIwEC2EPKcj' 56d7c880\n\t'_ZN11__gnu_debug19_Safe_sequence_base7_M_swapERS0_' 56d7da10\n\t'_ZSt18__throw_bad_typeidv' 56d7de60\n\t'_ZNSt12out_of_rangeD0Ev' 56d7e0f0\n\t'_ZSt23__throw_underflow_errorPKc' 56d7e480\n\t'_ZNSt8ios_base6xallocEv' 56d7edd0\n\t'_ZNSt8ios_base7failureC1ERKSs' 56d7f3c0\n\t'_ZNSt8ios_base7_M_initEv' 56d808d0\n\t'_ZNSt6localeC2ERKS_' 56d80b10\n\t'_ZNSt6locale5_ImplD2Ev' 56d81310\n\t'_ZNSt6locale5_ImplC2Ej' 56d81e00\n\t'_ZNSt6localeC2ERKS_S1_i' 56d84170\n\t'_ZNSt11logic_errorC2ERKSs' 56d86830\n\t'_ZNSt13runtime_errorC2ERKSs' 56d86af0\n\t'_ZNSt13runtime_errorD0Ev' 56d86e20\n\t'_ZNSt12strstreambuf7_M_freeEPc' 56d870e0\n\t'_ZNSt12strstreambuf9underflowEv' 56d87330\n\t'_ZNSt12strstreambufC2EPaiS0_' 56d87c80\n\t'_ZNSt12strstreambufC1EPKhi' 56d88450\n\t'_ZNSt10ostrstreamD2Ev' 56d88cb0\n\t'_ZNSt10istrstreamD1Ev' 56d89480\n\t'_ZNSt9strstreamD0Ev' 56d89bf0\n\t'_ZSt18_Rb_tree_decrementPKSt18_Rb_tree_node_base' 56d8a2d0\n\t'_ZNSaIwED1Ev' 56d8a8c0\n\t'_ZNSt13basic_filebufIcSt11char_traitsIcEE13_M_set_bufferEi' 56d8b6c0\n\t'_ZNSt13basic_filebufIwSt11char_traitsIwEE27_M_allocate_internal_bufferEv' 56d8b8b0\n\t'_ZNSt13basic_filebufIwSt11char_traitsIwEE9pbackfailEj' 56d8be20\n\t'_ZNSt13basic_filebufIcSt11char_traitsIcEE6xsgetnEPci' 56d8d060\n\t'_ZNSt14basic_ifstreamIwSt11char_traitsIwEE7is_openEv' 56d8e080\n\t'_ZNSt13basic_filebufIwSt11char_traitsIwEED0Ev' 56d8e980\n\t'_ZNSt13basic_filebufIcSt11char_traitsIcEE9showmanycEv' 56d8f250\n\t'_ZNSt14basic_ofstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode' 56d8f860\n\t'_ZNSt14basic_ofstreamIwSt11char_traitsIwEEC2Ev' 56d8fe60\n\t'_ZNSt14basic_ofstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode' 56d904d0\n\t'_ZNSt14basic_ifstreamIcSt11char_traitsIcEEC1Ev' 56d90d40\n\t'_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev' 56d91430\n\t'_ZTv0_n12_NSt13basic_fstreamIcSt11char_traitsIcEED0Ev' 56d91dc0\n\t'_ZNSt13basic_fstreamIwSt11char_traitsIwEED2Ev' 56d92260\n\t'_ZNKSt9basic_iosIwSt11char_traitsIwEE7rdstateEv' 56d93680\n\t'_ZNSt9basic_iosIcSt11char_traitsIcEEC1Ev' 56d938f0\n\t'_ZNSt9basic_iosIcSt11char_traitsIcEED2Ev' 56d93c00\n\t'_ZNKSt9basic_iosIwSt11char_traitsIwEE3badEv' 56d93fe0\n\t'_ZNSt9basic_iosIwSt11char_traitsIwEE10exceptionsESt12_Ios_Iostate' 56d941d0\n\t'_ZNSt9basic_iosIwSt11char_traitsIwEE5imbueERKSt6locale' 56d944a0\n\t'_ZNSt14basic_iostreamIwSt11char_traitsIwEEC1Ev' 56d94f60\n\t'_ZNSdC1Ev' 56d95280\n\t'_ZNSirsEPFRSt8ios_baseS0_E' 56d954d0\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEErsEPFRSt8ios_baseS4_E' 56d95600\n\t'_ZStrsISt11char_traitsIcEERSt13basic_istreamIcT_ES5_Pa' 56d958a0\n\t'_ZStrsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_St12_Setiosflags' 56d95b40\n\t'_ZTv0_n12_NSt13basic_istreamIwSt11char_traitsIwEED1Ev' 56d95e20\n\t'_ZStrsIcSt11char_traitsIcEERSt13basic_istreamIT_T0_ES6_RS3_' 56d96650\n\t'_ZNSi3getERSt15basic_streambufIcSt11char_traitsIcEE' 56d96fa0\n\t'_ZNSirsERy' 56d97a40\n\t'_ZSt2wsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_' 56d987a0\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEE3getERSt15basic_streambufIwS1_Ew' 56d99390\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEErsERf' 56d99e80\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEE6sentryC2ERS2_b' 56d9abf0\n\t'_ZNKSt10moneypunctIcLb0EE13thousands_sepEv' 56d9c540\n\t'_ZNKSt10moneypunctIcLb0EE14do_frac_digitsEv' 56d9c6c0\n\t'_ZNKSt10moneypunctIcLb1EE10pos_formatEv' 56d9c890\n\t'_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' 56d9cb50\n\t'_ZNSt16__numpunct_cacheIcEC1Ej' 56d9cda0\n\t'_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRe' 56d9d200\n\t'_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPKv' 56d9d5f0\n\t'_ZNSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEEC2Ej' 56d9d850\n\t'_ZNKSt8messagesIcE4openERKSsRKSt6locale' 56d9db80\n\t'_ZNSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED0Ev' 56d9dfc0\n\t'_ZNSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEED1Ev' 56d9e1e0\n\t'_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED2Ev' 56d9e3f0\n\t'_ZSt9has_facetISt8numpunctIcEEbRKSt6locale' 56d9e810\n\t'_ZSt9use_facetISt10moneypunctIcLb0EEERKT_RKSt6locale' 56d9ebb0\n\t'_ZNSt7collateIcEC2Ej' 56d9ef10\n\t'_ZNSt8messagesIcED1Ev' 56d9f290\n\t'_ZNSt16__numpunct_cacheIcED2Ev' 56d9f6d0\n\t'_ZNSt15numpunct_bynameIcED2Ev' 56d9fb30\n\t'_ZNSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' 56d9ffb0\n\t'_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' 56da0310\n\t'_ZNSt15messages_bynameIcEC2EPKcj' 56da07c0\n\t'_ZNSt11__timepunctIcEC2Ej' 56da0fc0\n\t'_ZNKSt8numpunctIcE12do_falsenameEv' 56da12f0\n\t'_ZNSt10moneypunctIcLb1EEC2EP15__locale_structPKcj' 56da17f0\n\t'_ZNKSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPK2tmPKcSB_' 56da1c80\n\t'_ZNSt15numpunct_bynameIcEC1EPKcj' 56da2180\n\t'_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE14do_get_weekdayES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm' 56da3b00\n\t'_ZNKSt7collateIcE12do_transformEPKcS2_' 56da68d0\n\t'_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' 56dac390\n\t'_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE15_M_insert_floatIeEES3_S3_RSt8ios_baseccT_' 56daeb10\n\t'_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE6do_putES3_RSt8ios_basecm' 56db0310\n\t'_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRm' 56db2f10\n\t'_ZStlsIcSt11char_traitsIcESaIcEERSt13basic_ostreamIT_T0_ES7_RKSbIS4_S5_T1_E' 56db5520\n\t'_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEPFRS2_S3_E' 56db5a10\n\t'_ZNSoC2EPSt15basic_streambufIcSt11char_traitsIcEE' 56db5ba0\n\t'_ZNSoC1Ev' 56db5e20\n\t'_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_' 56db6470\n\t'_ZNSoD2Ev' 56db6a40\n\t'_ZNSolsEs' 56db6d50\n\t'_ZNSo5writeEPKci' 56db7af0\n\t'_ZNSolsEx' 56db8a50\n\t'_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEi' 56db9e90\n\t'_ZSt4endsIwSt11char_traitsIwEERSt13basic_ostreamIT_T0_ES6_' 56dbb170\n\t'_ZNKSt19basic_ostringstreamIcSt11char_traitsIcESaIcEE5rdbufEv' 56dbba10\n\t'_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE6setbufEPwi' 56dbbd40\n\t'_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE3strERKSbIwS1_S2_E' 56dbc7f0\n\t'_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode' 56dbcc90\n\t'_ZNKSt18basic_stringstreamIcSt11char_traitsIcESaIcEE3strEv' 56dbd7f0\n\t'_ZNKSt19basic_istringstreamIwSt11char_traitsIwESaIwEE3strEv' 56dbdfc0\n\t'_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEED2Ev' 56dbe670\n\t'_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode' 56dbee50\n\t'_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode' 56dbf9a0\n\t'_ZTv0_n12_NSt19basic_istringstreamIwSt11char_traitsIwESaIwEED0Ev' 56dc0180\n\t'_ZTv0_n12_NSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev' 56dc0a90\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEE10pubseekposESt4fposI11__mbstate_tESt13_Ios_Openmode' 56dc12e0\n\t'_ZNKSt15basic_streambufIcSt11char_traitsIcEE4pptrEv' 56dc1420\n\t'_ZNSt15basic_streambufIwSt11char_traitsIwEE10pubseekoffExSt12_Ios_SeekdirSt13_Ios_Openmode' 56dc14f0\n\t'_ZNKSt15basic_streambufIwSt11char_traitsIwEE5pbaseEv' 56dc1680\n\t'_ZNSt15basic_streambufIwSt11char_traitsIwEEaSERKS2_' 56dc1740\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEEC1Ev' 56dc1a40\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEED1Ev' 56dc1ce0\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEE7seekposESt4fposI11__mbstate_tESt13_Ios_Openmode' 56dc1e40\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEE5sputcEc' 56dc2150\n\t'_ZNKSs7_M_dataEv' 56dc26e0\n\t'_ZNKSs4sizeEv' 56dc2820\n\t'_ZNSs4_Rep15_M_set_sharableEv' 56dc28e0\n\t'_ZNKSs5emptyEv' 56dc2d70\n\t'_ZNKSs16find_last_not_ofEcj' 56dc3010\n\t'_ZNKSs13find_first_ofEcj' 56dc33e0\n\t'_ZNKSs4rendEv' 56dc3740\n\t'_ZNKSs7compareEjjRKSs' 56dc3b60\n\t'_ZNSsC2EPKcjRKSaIcE' 56dc4040\n\t'_ZNSsC1IPcEET_S1_RKSaIcE' 56dc4470\n\t'_ZNSs6appendEPKcj' 56dc4a00\n\t'_ZNSs6assignEPKc' 56dc5100\n\t'_ZNSs6insertEN9__gnu_cxx17__normal_iteratorIPcSsEEjc' 56dc54e0\n\t'_ZNSs7_M_leakEv' 56dc59b0\n\t'_ZNSsD2Ev' 56dc5d10\n\t'_ZNSs7replaceEjjPKc' 56dc63b0\n\t'_ZNSt8valarrayIjED2Ev' 56dc6700\n\t'_ZNKSt10moneypunctIwLb0EE13positive_signEv' 56dc6dc0\n\t'_ZNKSt10moneypunctIwLb1EE13decimal_pointEv' 56dc6f70\n\t'_ZNKSt10moneypunctIwLb1EE16do_thousands_sepEv' 56dc7100\n\t'_ZNKSt8numpunctIwE13decimal_pointEv' 56dc74b0\n\t'_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRt' 56dc76f0\n\t'_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE3putES3_RSt8ios_basewb' 56dc7b10\n\t'_ZNKSt11__timepunctIwE20_M_date_time_formatsEPPKw' 56dc7ea0\n\t'_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10date_orderEv' 56dc8130\n\t'_ZNKSt8messagesIwE8do_closeEi' 56dc8430\n\t'_ZNSt8time_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED0Ev' 56dc87b0\n\t'_ZNSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEED1Ev' 56dc89d0\n\t'_ZSt9has_facetISt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEEbRKSt6locale' 56dc8cb0\n\t'_ZSt9has_facetISt7codecvtIwc11__mbstate_tEEbRKSt6locale' 56dc9110\n\t'_ZSt9use_facetISt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEERKT_RKSt6locale' 56dc9470\n\t'_ZNSt14codecvt_bynameIwc11__mbstate_tED1Ev' 56dc97d0\n\t'_ZNSt15messages_bynameIwED0Ev' 56dc9bb0\n\t'_ZNSt18__moneypunct_cacheIwLb1EED1Ev' 56dca010\n\t'_ZNSt17moneypunct_bynameIwLb1EED1Ev' 56dca3f0\n\t'_ZNSt8numpunctIwEC1EP15__locale_structj' 56dca870\n\t'_ZNSt18__moneypunct_cacheIwLb0EEC2Ej' 56dcabf0\n\t'_ZNSt17__timepunct_cacheIwEC1Ej' 56dcb110\n\t'_ZNKSt10moneypunctIwLb0EE16do_negative_signEv' 56dcb8b0\n\t'_ZNSt10moneypunctIwLb1EEC1EPSt18__moneypunct_cacheIwLb1EEj' 56dcbe10\n\t'_ZNSt8messagesIwEC1EP15__locale_structPKcj' 56dcc1f0\n\t'_ZNSt15time_get_bynameIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEC2EPKcj' 56dcc8d0\n\t'_ZNSt17moneypunct_bynameIwLb0EEC2EPKcj' 56dccd40\n\t'_ZNSt14collate_bynameIwEC2EPKcj' 56dcf9b0\n\t'_ZNKSt9money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb1EEES3_S3_RSt8ios_basewRKSbIwS2_SaIwEE' 56dd1030\n\t'_ZNKSt9money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10_M_extractILb0EEES3_S3_S3_RSt8ios_baseRSt12_Ios_IostateRSs' 56dd4110\n\t'_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE13_M_insert_intIxEES3_S3_RSt8ios_basewT_' 56dd7b60\n\t'_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRx' 56dda050\n\t'_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_putES3_RSt8ios_basewb' 56ddcfc0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE5beginEv' 56ddd810\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE4_Rep12_M_is_sharedEv' 56ddd8e0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE4findEPKwjj' 56dddca0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE17find_first_not_ofEwj' 56dddf40\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE13find_first_ofEPKwjj' 56dde330\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE12find_last_ofEPKwj' 56dde6a0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE7compareEjjRKS2_jj' 56dde9c0\n\t'_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_jjRKS1_' 56ddefa0\n\t'_ZNSbIwSt11char_traitsIwESaIwEEC1EPKwRKS1_' 56ddf3b0\n\t'_ZNSbIwSt11char_traitsIwESaIwEE9push_backEw' 56ddf8d0\n\t'_ZNSbIwSt11char_traitsIwESaIwEED2Ev' 56ddfe30\n\t'_ZNSbIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPwS2_EEw' 56de0420\n\t'_ZNSbIwSt11char_traitsIwESaIwEE6insertEjRKS2_jj' 56de0910\n\t'_ZNSbIwSt11char_traitsIwESaIwEE6rbeginEv' 56de0c30\n\t'_ZNSbIwSt11char_traitsIwESaIwEE7replaceEjjPKw' 56de1210\n\t'_ZNKSt7codecvtIwc11__mbstate_tE9do_lengthERS0_PKcS4_j' 56de15e0\n\t'_ZNKSt5ctypeIwE11do_scan_notEtPKwS2_' 56de1dc0\n\t'_ZNKSt5ctypeIwE10do_toupperEw' 56de21e0\n\t'_ZNSt10moneypunctIwLb0EED2Ev' 56de2ab0\n\t'_ZNSt10moneypunctIcLb0EE24_M_initialize_moneypunctEP15__locale_structPKc' 56de3090\n\t'_ZNSt8numpunctIwE22_M_initialize_numpunctEP15__locale_struct' 56de4390\n\t'_ZNSt12__basic_fileIcE4syncEv' 56de5a80\n\t'_ZNSt12__basic_fileIcE6xsgetnEPci' 56de5f30\n\t'_ZdlPvRKSt9nothrow_t' 56de62c0\n\t'__cxa_begin_catch' 56de66c0\n\t'__cxa_call_unexpected' 56de6d30\n\t'__cxa_guard_release' 56de7630\n\t'__cxa_pure_virtual' 56de7970\n\t'_ZN10__cxxabiv117__class_type_infoD0Ev' 56de7b30\n\t'_ZNSt10bad_typeidD1Ev' 56de7d50\n\t'_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_' 56de8060\n\t'_ZN10__cxxabiv117__pbase_type_infoD2Ev' 56de8a60\n\t'_ZN10__cxxabiv120__function_type_infoD0Ev' 56de8c70\n\t'_ZNK10__cxxabiv119__pointer_type_info15__pointer_catchEPKNS_17__pbase_type_infoEPPvj' 56de8ef0\n\t'__cxa_vec_new' 56de95e0\nEND_RTN_LIST\nL '/lib/libm.so.6' 56e2e314 1a5dd 56e2b000 0 \n\t'__i686.get_pc_thunk.bx' 56e2e4c7\n\t'fegetenv' 56e30a90\n\t'__ieee754_asin' 56e30db0\n\t'__ieee754_y0' 56e314e0\n\t'__ieee754_log10' 56e32c10\n\t'cbrt' 56e335f0\n\t'logb' 56e340d0\n\t'asin' 56e34840\n\t'hypot' 56e34e30\n\t'log10' 56e35560\n\t'nan' 56e35b00\n\t'creal' 56e35f10\n\t'csin' 56e36b80\n\t'clog10' 56e37d60\n\t'__finite' 56e382b0\n\t'__ieee754_atan2f' 56e386d0\n\t'ponef' 56e38ee0\n\t'__ieee754_remainderf' 56e3a280\n\t'cbrtf' 56e3ab60\n\t'logbf' 56e3b4d0\n\t'asinf' 56e3b9e0\n\t'hypotf' 56e3bff0\n\t'log10f' 56e3c6c0\n\t'nanf' 56e3cc50\n\t'crealf' 56e3cf60\n\t'csinf' 56e3dab0\n\t'clog10f' 56e3e9d0\n\t'finitef' 56e3ee00\n\t'__ieee754_atan2l' 56e3f320\n\t'pone' 56e3fff0\n\t'__ieee754_remainderl' 56e41730\n\t'cbrtl' 56e41ca0\n\t'logbl' 56e42800\n\t'atan2l' 56e42db0\n\t'y0l' 56e43420\n\t'powl' 56e43b90\n\t'truncl' 56e44180\n\t'cabsl' 56e444c0\n\t'ctanl' 56e45540\n\t'fmal' 56e466c0\n\t'copysignl' 56e46ae0\n\t'__divdc3' 56e48190\nEND_RTN_LIST\nL '/lib/libgcc_s.so.1' 56e5a4fc 7c25 56e59000 0 \n\t'__ashldi3' 56e5a8e0\n\t'__subvsi3' 56e5abe0\n\t'__ctzdi2' 56e5b030\n\t'__mulxc3' 56e5bd70\n\t'__fixdfdi' 56e5d020\n\t'__udivmoddi4' 56e5d8e0\n\t'_Unwind_GetGR' 56e5dcd0\n\t'__register_frame_info' 56e60260\n\t'.fini' 56e62104\nEND_RTN_LIST\nL '/lib/libc.so.6' 56e795d8 e5747 56e64000 0 \n\t'gnu_get_libc_version' 56e79980\n\t'__divdi3' 56e79ee0\n\t'__gconv_close' 56e7adc0\n\t'__gconv_find_transform' 56e7bab0\n\t'add_alias' 56e7c180\n\t'__gconv_transform_ascii_internal' 56e7e080\n\t'__gconv_translit_find' 56e81e20\n\t'__gconv_lookup_cache' 56e82780\n\t'_L_unlock_996' 56e838fc\n\t'rangecmp' 56e84640\n\t'__duplocale' 56e85ad0\n\t'__collseq_table_lookup' 56e85f30\n\t'isdigit' 56e86400\n\t'__isascii_l' 56e866a0\n\t'ispunct_l' 56e86810\n\t'set_binding_values' 56e869d0\n\t'__dcigettext' 56e87a10\n\t'dcngettext' 56e88220\n\t'_nl_expand_alias' 56e89d40\n\t'new_exp_2' 56e8a920\n\t'finite' 56e8bd40\n\t'copysignf' 56e8c0f0\n\t'modfl' 56e8c3b0\n\t'__libc_longjmp' 56e8c810\n\t'sigpending' 56e8cd90\n\t'sigpause' 56e8d1f0\n\t'sigaddset' 56e8d5a0\n\t'__libc_current_sigrtmax_private' 56e8d8f0\n\t'sigset' 56e8de10\n\t'_quicksort' 56e8e360\n\t'_L_lock_22' 56e8f45a\n\t'exit' 56e8f530\n\t'div' 56e8f9d0\n\t'initstate' 56e8fef0\n\t'setstate_r' 56e90070\n\t'mrand48' 56e90610\n\t'jrand48_r' 56e908d0\n\t'strtoll' 56e90ca0\n\t'strtoull_l' 56e92390\n\t'__strtof_l' 56e948e0\n\t'do_system' 56e99720\n\t'realpath' 56e99cf0\n\t'__xpg_basename' 56e9b780\n\t'wcstoimax' 56e9c020\n\t'__mpn_add_n' 56e9c4a0\n\t'__mpn_impn_sqr_n_basecase' 56e9cfa0\n\t'__mpn_construct_double' 56e9ddf0\n\t'_itowa' 56e9e690\n\t'_L_unlock_11056' 56ea35aa\n\t'printf_size_info' 56ea77b0\n\t'group_number' 56ea8220\n\t'vfscanf' 56eb2050\n\t'perror_internal' 56eb6cd0\n\t'__path_search' 56eb7770\n\t'ftrylockfile' 56eb7ea0\n\t'_IO_file_doallocate' 56eb8b50\n\t'_L_unlock_161' 56eb9245\n\t'__fopen_internal' 56eb9690\n\t'_L_lock_41' 56eb9bdc\n\t'_L_unlock_185' 56eb9ecf\n\t'_L_lock_47' 56eba57b\n\t'_IO_proc_close' 56ebaa70\n\t'_L_unlock_110' 56ebb13e\n\t'_IO_setbuffer' 56ebb4a0\n\t'_L_unlock_95' 56ebb894\n\t'_L_unlock_105' 56ebbda2\n\t'getwchar' 56ebc020\n\t'_L_lock_43' 56ebc4e9\n\t'putwc' 56ebc940\n\t'_L_unlock_81' 56ebcc61\n\t'vswprintf' 56ebcf20\n\t'_IO_sungetwc' 56ebd360\n\t'save_for_wbackup' 56ebd7c0\n\t'_IO_wstr_finish' 56ebe140\n\t'_IO_wdo_write' 56ebf2a0\n\t'do_out' 56ebfb00\n\t'_L_lock_29' 56ec0220\n\t'_L_lock_30' 56ec04ae\n\t'_L_lock_29' 56ec08df\n\t'_L_lock_30' 56ec0c7e\n\t'_IO_strn_overflow' 56ec1080\n\t'ftello' 56ec1670\n\t'ftello64' 56ec1b60\n\t'__fpending' 56ec1e00\n\t'_L_unlock_17' 56ec25f2\n\t'_L_lock_29' 56ec2814\n\t'_IO_file_sync_mmap' 56ec2d30\n\t'_IO_do_write' 56ec3a10\n\t'_IO_file_setbuf_mmap' 56ec44a0\n\t'flush_cleanup' 56ec4fa0\n\t'_IO_sgetn' 56ec55a0\n\t'_IO_adjust_column' 56ec5960\n\t'_IO_default_seek' 56ec5fc0\n\t'_IO_list_lock' 56ec6070\n\t'_IO_default_doallocate' 56ec67e0\n\t'_L_unlock_280' 56ec6c3e\n\t'_L_lock_1784' 56ec6cca\n\t'_IO_str_pbackfail' 56ec6f60\n\t'__failing_morecore' 56ec75a0\n\t'ptmalloc_init' 56ec7ef0\n\t'cfree' 56ec91a0\n\t'realloc_check' 56ecaaa0\n\t'realloc_hook_ini' 56ecbad0\n\t'_L_unlock_2466' 56ecc04a\n\t'_L_unlock_4424' 56ecc0e2\n\t'_L_unlock_8320' 56ecc17a\n\t'_L_lock_9316' 56ecc20f\n\t'_L_unlock_9886' 56ecc29b\n\t'_L_unlock_10772' 56ecc327\n\t'mprobe' 56ecc510\n\t'mtrace' 56eccc10\n\t'_L_lock_751' 56ecd4f3\n\t'_obstack_memory_used' 56ecd8f0\n\t'__strdup' 56ecdfd0\n\t'strpbrk' 56ece820\n\t'bcmp' 56ecf180\n\t'ffsll' 56ecfd90\n\t'_wordcopy_fwd_aligned' 56ed0310\n\t'rawmemchr' 56ed0b90\n\t'argz_insert' 56ed1180\n\t'envz_add' 56ed1970\n\t'__memset_gcn_by4' 56ed3700\n\t'__strncat_g' 56ed3950\n\t'__strcspn_g' 56ed3b40\n\t'__strcspn_c1' 56ed3f70\n\t'__strsep_3c' 56ed4270\n\t'__xpg_strerror_r' 56ed4680\n\t'wcsncpy' 56ed4aa0\n\t'wmemset' 56ed4f80\n\t'mbsrtowcs' 56ed58e0\n\t'wcstoll' 56ed6550\n\t'____wcstol_l_internal' 56ed6870\n\t'____wcstod_l_internal' 56ed8040\n\t'wcscoll' 56ede440\n\t'_nl_cleanup_ctype' 56ee0000\n\t'asctime' 56ee0c60\n\t'guess_time_tm' 56ee0eb0\n\t'__tzstring' 56ee1be0\n\t'_L_unlock_2123' 56ee287f\n\t'ftime' 56ee39c0\n\t'memcpy_uppcase' 56ee68e0\n\t'_nl_init_alt_digit' 56eeab60\n\t'_nl_cleanup_time' 56eeafe0\n\t'_L_unlock_119' 56eeb4ac\n\t'alphasort' 56eeb840\n\t'_L_lock_246' 56eebee0\n\t'_L_lock_27' 56eec50a\n\t'getgrgid' 56eecca0\n\t'_L_unlock_290' 56eed201\n\t'getgrgid_r' 56eed4e0\n\t'_L_unlock_116' 56eee03e\n\t'_L_lock_25' 56eee5d6\n\t'_L_unlock_233' 56eee8bd\n\t'times' 56eef2d0\n\t'pause' 56eefb10\n\t'execle' 56ef0120\n\t'getegid' 56ef09a0\n\t'getsid' 56ef0c60\n\t'setlogin' 56ef1140\n\t'handle_intel' 56ef1a00\n\t'collated_compare' 56ef3be0\n\t'end_pattern' 56ef5f50\n\t're_node_set_contains' 56efa780\n\t'find_subexp_node' 56efad00\n\t'lower_subexps' 56efb590\n\t'free_dfa_content' 56efb9d0\n\t'check_arrival_expand_ecl' 56efc4b0\n\t're_node_set_init_copy' 56efd1f0\n\t'build_upper_buffer' 56efe6f0\n\t'check_arrival' 56efffa0\n\t'parse_bracket_exp' 56f02cf0\n\t'set_regs' 56f05f40\n\t're_exec' 56f08f60\n\t'_getopt_long_only_r' 56f0a650\n\t'__sched_get_priority_min' 56f0a940\n\t'in6aicmp' 56f0ad30\n\t'_L_lock_9088' 56f0e70d\n\t'eval_expr' 56f0ed40\n\t'pread' 56f12850\n\t'posix_spawn_file_actions_addclose' 56f12cb0\n\t'posix_spawnattr_setpgroup' 56f12fa0\n\t'posix_spawnattr_setschedparam' 56f13760\n\t'__xstat64' 56f13b70\n\t'fstatfs64' 56f143f0\n\t'mkdir' 56f14a00\n\t'__close' 56f15160\n\t'__fcntl_nocancel' 56f15750\n\t'creat64' 56f15cc0\n\t'getttyname' 56f162f0\n\t'readlinkat' 56f17050\n\t'object_compare' 56f184b0\n\t'fts_palloc' 56f19850\n\t'posix_fadvise' 56f1afc0\n\t'__internal_statvfs' 56f1bea0\n\t'tcsetpgrp' 56f1c4c0\n\t'setrlimit64' 56f1c8f0\n\t'__sbrk' 56f1cdb0\n\t'setregid' 56f1d440\n\t'___newselect_nocancel' 56f1d84a\n\t'sethostid' 56f1de50\n\t'usleep' 56f1e150\n\t'getfsspec' 56f1e570\n\t'_L_lock_1062' 56f1f144\n\t'ftruncate64' 56f1f5c0\n\t'endusershell' 56f1fcc0\n\t'openlog_internal' 56f20390\n\t'_L_lock_1085' 56f20c4c\n\t'madvise' 56f21070\n\t'fcvt_r' 56f21420\n\t'hsearch_r' 56f22060\n\t'tsearch' 56f22a40\n\t'errx' 56f23040\n\t'dirname' 56f238b0\n\t'listxattr' 56f23d30\n\t'vm86' 56f24080\n\t'gnu_dev_major' 56f24450\n\t'capget' 56f24730\n\t'inotify_add_watch' 56f24a30\n\t'prctl' 56f24d60\n\t'getpeername' 56f250c0\n\t'setsockopt' 56f25500\n\t'__libc_msgsnd' 56f259a0\n\t'shmget' 56f25f10\n\t'pc_to_index' 56f26b80\n\t'iswxdigit' 56f27410\n\t'iswpunct' 56f27c50\n\t'iswalpha_l' 56f28270\n\t'__towlower_l' 56f28880\n\t'_L_unlock_111' 56f28cd6\n\t'getspent_r' 56f29440\n\t'_nss_files_parse_spent' 56f298b0\n\t'_L_lock_34' 56f2a3eb\n\t'__argp_fmtstream_update' 56f2a500\n\t'__argp_fmtstream_puts' 56f2af00\n\t'until_short' 56f2b2d0\n\t'usage_argful_short_opt' 56f2c270\n\t'argp_help' 56f2e4a0\n\t'argp_usage' 56f2f580\n\t'pthread_attr_setschedparam' 56f2f7d0\n\t'pthread_cond_signal' 56f2fa10\n\t'pthread_self' 56f2fc50\n\t'_L_lock_116' 56f2ff5a\n\t'inet_ntop4' 56f30490\n\t'net_mask' 56f30ec0\n\t'skip_ws' 56f324c0\n\t'_L_unlock_68' 56f3306e\n\t'__nss_configure_lookup' 56f33a70\n\t'__nss_getent' 56f34000\n\t'__nss_group_lookup' 56f34eb0\n\t'__backtrace' 56f35490\n\t'__sprintf_chk' 56f35e60\n\t'_L_unlock_99' 56f362af\n\t'_L_unlock_302' 56f36680\n\t'__pread64_chk' 56f36be0\n\t'__wmemcpy_chk' 56f36ee0\n\t'__vswprintf_chk' 56f37220\n\t'_L_lock_35' 56f376ca\n\t'_L_unlock_247' 56f379a7\n\t'__wcsnrtombs_chk' 56f37c70\n\t'_L_unlock_63' 56f38084\n\t'__h_errno_location' 56f38530\n\t'_L_unlock_149' 56f38ddb\n\t'_L_unlock_73' 56f396ee\n\t'_L_lock_28' 56f39c55\n\t'_L_lock_148' 56f39fee\n\t'_L_lock_24' 56f3a5ed\n\t'_L_unlock_237' 56f3a8ce\n\t'_L_lock_27' 56f3b036\n\t'_L_unlock_72' 56f3b54e\n\t'_L_unlock_111' 56f3b7b6\n\t'_L_unlock_167' 56f3bbce\n\t'ether_ntoa_r' 56f3c510\n\t'rresvport_af' 56f3d200\n\t'__internal_setnetgrent_reuse' 56f3ed70\n\t'_L_unlock_711' 56f3f622\n\t'_L_lock_28' 56f3f9ad\n\t'_L_lock_25' 56f3fc16\n\t'if_nameindex' 56f40ba0\n\t'inet6_option_init' 56f41ee0\n\t'setsourcefilter' 56f42720\n\t'authnone_create_once' 56f43340\n\t'xdr_authunix_parms' 56f43b70\n\t'clntraw_geterr' 56f448e0\n\t'clnttcp_freeres' 56f44fc0\n\t'clntudp_freeres' 56f45930\n\t'pmap_unset' 56f46810\n\t'pmap_rmtcall' 56f47720\n\t'__rpc_thread_variables' 56f480a0\n\t'svcerr_weakauth' 56f483b0\n\t'xprt_unregister' 56f48920\n\t'svcraw_getargs' 56f48e30\n\t'svctcp_freeargs' 56f495e0\n\t'svctcp_rendezvous_abort' 56f49c40\n\t'svcudp_recv' 56f4a4f0\n\t'xdr_u_longlong_t' 56f4ab90\n\t'xdr_wrapstring' 56f4afb0\n\t'xdrmem_setpos' 56f4b520\n\t'skip_input_bytes' 56f4b7c0\n\t'xdrrec_getbytes' 56f4bb50\n\t'xdrstdio_create' 56f4c150\n\t'xdrstdio_getpos' 56f4c400\n\t'x_destroy' 56f4c790\n\t'xdr_authdes_cred' 56f4d030\n\t'key_get_conv' 56f4e400\n\t'_L_unlock_445' 56f4e8df\n\t'xdr_keystatus' 56f4ec90\n\t'_svcauth_des' 56f4f730\n\t'clntunix_create' 56f50340\n\t'svcunixfd_create' 56f50ed0\n\t'_create_xid' 56f516a0\n\t'xdr_uint8_t' 56f51ac0\n\t'__nscd_gethostbyname2_r' 56f52fd0\n\t'get_mapping' 56f53dc0\n\t'getutent' 56f546c0\n\t'endutent' 56f549f0\n\t'getutline' 56f54b40\n\t'__utmp_equal' 56f55040\n\t'updwtmp' 56f55fb0\n\t'setutxent' 56f56cb0\n\t'dl_iterate_phdr' 56f56e70\n\t'__libc_dlopen_mode' 56f57510\n\t'fde_unencoded_compare' 56f57b40\n\t'__register_frame' 56f58350\n\t'_L_lock_136' 56f59129\n\t'_Unwind_GetIP' 56f591e0\n\t'read_uleb128' 56f59b50\n\t'_IO_old_cookie_seek' 56f59eb0\n\t'_L_lock_68' 56f5a7ea\n\t'_L_lock_36' 56f5ab9c\n\t'_IO_file_xsputn' 56f5af40\n\t'_IO_old_file_finish' 56f5bae0\n\t'versionsort64' 56f5c090\n\t'sched_setaffinity' 56f5d210\n\t'getspent_r' 56f5d550\n\t'gethostbyname2_r' 56f5d7f0\n\t'getservbyport_r' 56f5dbe0\n\t'free_mem' 56f5dff0\n\t'free_mem' 56f5e5c0\n\t'_L_unlock_44' 56f5e905\n\t'__rpc_thread_destroy' 56f5ec70\nEND_RTN_LIST\nU '/disk/PinTools/Utils/obj-ia32/cp-pin'\nU '/lib/ld-linux.so.2'\nU '/usr/lib/libstdc++.so.6'\nU '/lib/libm.so.6'\nU '/lib/libgcc_s.so.1'\nU '/lib/libc.so.6'\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Debugger/makefile.rules": "##############################################################\n#\n# This file includes all the test targets as well as all the\n# non-default build rules and test recipes.\n#\n##############################################################\n\n###### Additional includes that are specific to this directory ######\n\ninclude $(TOOLS_ROOT)/Config/makefile.debug.rules\n\n\n##############################################################\n#\n# Test targets\n#\n##############################################################\n\n###### Place all generic definitions here ######\n\n# This defines tests which run tools of the same name.  This is simply for convenience to avoid\n# defining the test name twice (once in TOOL_ROOTS and again in TEST_ROOTS).\n# Tests defined here should not be defined in TOOL_ROOTS and TEST_ROOTS.\nTEST_TOOL_ROOTS :=\n\n# This defines the tests to be run that were not already defined in TEST_TOOL_ROOTS.\nTEST_ROOTS :=\n\n# This defines the tools which will be run during the the tests, and were not already defined in\n# TEST_TOOL_ROOTS.\nTOOL_ROOTS :=\n\n# This defines the static analysis tools which will be run during the the tests. They should not\n# be defined in TEST_TOOL_ROOTS. If a test with the same name exists, it should be defined in\n# TEST_ROOTS.\n# Note: Static analysis tools are in fact executables linked with the Pin Static Analysis Library.\n# This library provides a subset of the Pin APIs which allows the tool to perform static analysis\n# of an application or dll. Pin itself is not used when this tool runs.\nSA_TOOL_ROOTS :=\n\n# This defines all the applications that will be run during the tests.\nAPP_ROOTS :=\n\n# This defines any additional object files that need to be compiled.\nOBJECT_ROOTS :=\n\n# This defines any additional dlls (shared objects), other than the pintools, that need to be compiled.\nDLL_ROOTS :=\n\n# This defines any static libraries (archives), that need to be built.\nLIB_ROOTS :=\n\n###### Place OS-specific definitions here ######\n\n# Linux\nifeq ($(TARGET_OS),linux)\n    TEST_TOOL_ROOTS += stop-resume-when-suspended check-if-thread-stopped\n    TEST_ROOTS += simple-pindb-launch pindb-start-fini pindb-noprompt-kill pindb-detach pindb-abrupt-disconnect \\\n                  pindb-kill-like-gdb pindb-simple-command pindb-step-custom-break pindb-simultaneous-toolbreak \\\n                  pindb-simultaneous-toolbreak-serialize pindb-simultaneous-toolbreak-squash pindb-invalidate-regs \\\n                  pindb-simultaneous-toolbreak-change pindb-simultaneous-toolbreak-step pindb-simple-simultaneous-multi \\\n                  pindb-simple-simultaneous-multi-serialize simple execfail fork breaktool breaktool_const_context \\\n                  breaktool-wait breaktool-nodebugger bp-icount action-pending thread launch-gdb stack-debugger pindb-zmm \\\n                  debugger-shell-breakpoints debugger-shell-tracepoints start-fini intercept-breakpoint emu-simple ymm zmm \\\n                  pc-change-bp pc-change-async interpreter-remove mt-exit debugger-type signal-step siginfo xmm-$(TARGET) \\\n                  pindb-attach-after-custom-stop allow-remote set-mode gdb-detach-reattach invalid-write bptest-$(TARGET) \\\n                  pindb-pthread-step-exit gdb-pthread-step-exit pindb-pthread-cont-exitgroup simultaneous-toolbreak \\\n                  simultaneous-toolbreak-squash simultaneous-toolbreak-change simultaneous-toolbreak-attach \\\n                  pindb-simultaneous-multi pindb-simultaneous-multi-serialize pindb-simultaneous-toolbreak-attach \\\n                  launch-gdb_const_context ymm_with_set_xmm_scratch_regs_tool watchpoint_const_context \\\n                  simultaneous-toolbreak_const_context xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool \\\n                  xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_const_context \\\n                  xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_and_set_xmm_reg \\\n                  app-pause-in-app-thread app-pause-in-int-thread bphandler gdb-svr4-libraries-extension simple-pindb-attach\n    TOOL_ROOTS += stack-debugger start-fini-callback simple-command-tool use-debugger-shell simultaneous-toolbreak \\\n                  breaktool int3-count action-pending-tool checkpoint watchpoint launch-gdb-tool intercept-tool \\\n                  pc-change-async-tool interpreter-remove mt-exit-tool debugger-type set-mode-tool invalidate-regs \\\n                  set_xmm_scratches set_xmm_scratches_before_breakpoint set_xmm_scratches_before_breakpoint_and_set_xmm_reg \\\n                  set_xmm_scratches_for_ymmtest null-emulator-$(TARGET) \\\n                  app-pause-in-app-thread-tool app-pause-in-int-thread-tool library-load-tool\n    APP_ROOTS += simple-pindb simple simple-static exec fork action-pending-app thread checkpoint-app bptest-$(TARGET) \\\n                 watchpoint-app callerapp fibonacci sleep-unix intercept-app pc-change-bp pc-change-async xmm-$(TARGET) \\\n                 mt-exit signal-catch reattach-loop pthread-bare-exit pthread-bare-exitgroup thread-$(OS_TYPE) \\\n                 ymm-$(TARGET) zmm-$(TARGET) debugger-shell-app-$(TARGET) app-pause-app pick-random-port bphandler_app \\\n                 dlopen-dlclose\n    OBJECT_ROOTS += simple-pindb-asm-$(TARGET_OS)-$(TARGET) zmm-asm-$(TARGET)\n    ifeq ($(TARGET),ia32)\n        TEST_ROOTS += access-64-on-32\n    endif\n\n    ifeq ($(shell $(TOOLS_ROOT)/Utils/testStaticLibs), 1)\n        TEST_ROOTS := $(filter-out bp-icount, $(TEST_ROOTS))\n        TOOL_ROOTS := $(filter-out int3-count, $(TOOL_ROOTS))\n        APP_ROOTS := $(filter-out simple-static, $(APP_ROOTS))\n    endif\nendif\n\n# OS X*\nifeq ($(TARGET_OS),mac)\n    TEST_ROOTS += app-pause-in-app-thread app-pause-in-int-thread\n    TOOL_ROOTS += app-pause-in-app-thread-tool app-pause-in-int-thread-tool\n    APP_ROOTS += app-pause-app\nendif\n\n# Windows\nifeq ($(TARGET_OS),windows)\n    TEST_TOOL_ROOTS += stop-resume-when-suspended check-if-thread-stopped\n    TEST_ROOTS += simple-pindb-launch pindb-start-fini pindb-noprompt-kill pindb-detach pindb-abrupt-disconnect \\\n                  pindb-kill-like-gdb pindb-simple-command pindb-step-custom-break pindb-simultaneous-toolbreak \\\n                  pindb-simultaneous-toolbreak-serialize pindb-simultaneous-toolbreak-squash pindb-invalidate-regs \\\n                  pindb-simultaneous-toolbreak-change pindb-simultaneous-toolbreak-step pindb-simple-simultaneous-multi \\\n                  pindb-simple-simultaneous-multi-serialize pindb-win-unhandled-exception pindb-win-handled-exception \\\n                  pindb-win-continued-exception1 pindb-win-continued-exception2 pindb-win-software-exception \\\n                  pindb-win-cpp-exception pindb-win-squash-exception pindb-win-step-exception pindb-zmm \\\n                  pindb-win-library-notifications pindb-win-step-library pindb-win-thread-stress \\\n                  pindb-win-exception-after-exit app-pause-in-app-thread app-pause-in-int-thread simple-pindb-attach\n    TOOL_ROOTS += stack-debugger start-fini-callback simple-command-tool use-debugger-shell simultaneous-toolbreak \\\n                  invalidate-regs app-pause-in-app-thread-tool app-pause-in-int-thread-tool\n    APP_ROOTS += simple-pindb simple win-unhandled-exception win-handled-exception win-continued-exception1 \\\n                 win-continued-exception2 win-software-exception win-cpp-exception win-load-library \\\n                 win-thread-stress thread-$(OS_TYPE) app-pause-app win-exception-after-exit zmm-$(TARGET)\n    OBJECT_ROOTS += simple-pindb-asm-$(TARGET_OS)-$(TARGET) win-foo-library zmm-asm-$(TARGET)\n    DLL_ROOTS += win-foo-library win-exception-after-exit-dll\n    ifeq ($(TARGET),ia32)\n        TEST_ROOTS += access-64-on-32\n    endif\nendif\n\n###### Handle exceptions here ######\n\n# This test is disabled until Mantis 1839 is fixed.\nTEST_ROOTS := $(filter-out simple-pindb-attach, $(TEST_ROOTS))\n\n#pindb-win-step-exception fails on pinw32-12. Mantis: 3072. \nifeq ($(TARGET_OS),windows)\n    TEST_ROOTS := $(filter-out pindb-win-step-exception, $(TEST_ROOTS))\nendif\n\n# There is a bug with PinADX when using early-injection (the default) on 32-bit applications when running\n# on a 64-bit host and when using versions of Windows earlier than Vista.  That bug causes this test to\n# fail, so we disable it in this case.  We can re-enable this test when Mantis #2385 is fixed.\n#\nosname := $(shell uname -s)\nifeq ($(findstring CYGWIN_NT-5,$(osname))-$(HOST_ARCH)-$(TARGET),CYGWIN_NT-5-intel64-ia32)\n    TEST_ROOTS := $(filter-out pindb-start-fini, $(TEST_ROOTS))\nendif\n\nifeq ($(TARGET_OS),linux)\n    GDB_VERSION_IF_BEFORE_66 := $(strip $(shell $(GDB) --version | head -1 | $(GREP) -E -o \" [6]\\.[2-5]+\"))\n    GDB_VERSION_IF_AFTER_74 := $(strip $(shell $(GDB) --version | head -1 | $(GREP) -E -o \" [7-9]\\.[4-9]+\"))\n    ifneq ($(GDB_VERSION_IF_BEFORE_66),\"\")\n#   Versions of gdb older than 6.6 do not understand the XMM registers, so disable the xmm tests.\n#\n        TEST_ROOTS := $(filter-out xmm-$(TARGET) xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool \\\n                                   xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_const_context \\\n                                   xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_and_set_xmm_reg, \\\n                                   $(TEST_ROOTS))\n        TOOL_ROOTS := $(filter-out set_xmm_scratches_before_breakpoint \\\n                                   set_xmm_scratches_before_breakpoint_and_set_xmm_reg set_xmm_scratches, $(TOOL_ROOTS))\n        APP_ROOTS := $(filter-out xmm-$(TARGET), $(APP_ROOTS))\n    endif\n    ifeq ($(strip $(GDB_VERSION_IF_AFTER_74)),)\n#   Versions of gdb older than 7.4 do not understand svr4 libraries query\n#\n        TEST_ROOTS := $(filter-out gdb-svr4-libraries-extension, $(TEST_ROOTS))\n        TOOL_ROOTS := $(filter-out library-load-tool, $(TOOL_ROOTS))\n        APP_ROOTS := $(filter-out dlopen-dlclose, $(APP_ROOTS))\n    endif\nendif\n\n###### Define the sanity subset ######\n\n# This defines the list of tests that should run in sanity. It should include all the tests listed in\n# TEST_TOOL_ROOTS and TEST_ROOTS excluding only unstable tests.\nSANITY_SUBSET := $(TEST_TOOL_ROOTS) $(TEST_ROOTS)\n\n\n##############################################################\n#\n# Test recipes\n#\n##############################################################\n\n# This section contains recipes for tests other than the default.\n# See makefile.default.rules for the default test rules.\n# All tests in this section should adhere to the naming convention: <testname>.test\n\n# This is a time limit (in seconds) we use for some of the tests below.  It's intentionally high\n# to avoid timeouts when the system load is very high, which can happen in our nightly tests.\n#\nTLIMIT := 300\n\n# This is the example tool from the manual run such that you can attach the debugger after it triggers a stack\n# breakpoint.\n#\nstack-debugger-late.test: $(OBJDIR)fibonacci$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_silent -t $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX) \\\n\t  -stackbreak 4000 -o $(OBJDIR)$(@:.test=.toolout) -timeout $(TLIMIT) \\\n\t    -- $(OBJDIR)fibonacci$(EXE_SUFFIX) 1000 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.toolout) > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.toolout) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)fibonacci$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Basic test of debugger features.\n#\nsimple.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Basic test for breakpoint handling features.\n#\nbphandler.test: $(OBJDIR)bphandler$(PINTOOL_SUFFIX) $(OBJDIR)bphandler_app$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)bphandler$(PINTOOL_SUFFIX) -- $(OBJDIR)bphandler_app$(EXE_SUFFIX) > \\\n      $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)bphandler_app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Verify we can debug across a failed exec() call.\n#\nexecfail.test: $(OBJDIR)exec$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -follow_execv -- $(OBJDIR)exec$(EXE_SUFFIX) ./does-not-exist > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)exec$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Verify we can debug across a parent call to fork().\n#\nfork.test: $(OBJDIR)fork$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)fork$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)fork$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Basic test of PIN_ApplicationBreakpoint()\n#\nbreaktool.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 0 \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\nbreaktool_const_context.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 0 -const_context 1 \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Verify that PIN_ApplicationBreakpoint(.., TRUE, ..) will wait if there's no debugger.\n#\nbreaktool-wait.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) \\\n\t  -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 1 -port $(OBJDIR)$(@:.test=.out) \\\n\t    -- $(OBJDIR)simple$(EXE_SUFFIX) &\n\tcount=0; \\\n\tuntil $(BASHTEST) -s $(OBJDIR)$(@:.test=.out) -o $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tsleep 5\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\tport=`cat $(OBJDIR)$(@:.test=.out)`; echo \"target remote :$$port\" >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Verify that PIN_ApplicationBreakpoint(.., FALSE, ..) does not wait if there's no debugger.\n#\nbreaktool-nodebugger.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 0 \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX)\n\n# Test breakpoints in various circumstances.\n#\nbptest-$(TARGET).test: $(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.)$(COMPARE_EXT) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that breakpoints do not cause the tool to see any extra instructions (e.g. INT3).\n#\nbp-icount.test: $(OBJDIR)simple-static$(EXE_SUFFIX) $(OBJDIR)int3-count$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) -t $(OBJDIR)int3-count$(PINTOOL_SUFFIX) -func main -o $(OBJDIR)bp-icount.reference \\\n\t  -- $(OBJDIR)simple-static$(EXE_SUFFIX)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)int3-count$(PINTOOL_SUFFIX) -func main -o $(OBJDIR)bp-icount.count \\\n\t  -- $(OBJDIR)simple-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(CMP) $(OBJDIR)bp-icount.reference $(OBJDIR)bp-icount.count\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test the PIN_IsActionPending() API.\n#\naction-pending.test: $(OBJDIR)action-pending-app$(EXE_SUFFIX) $(OBJDIR)action-pending-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)action-pending-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)action-pending-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)action-pending-app$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that we can print out XMM registers.  Older GDB's don't know how to print XMM registers well,\n# so use a modern GDB for this test.\n#\n# We first test that GDB itself will run.  If not, we just skip the body of this test.  The modern\n# GDB won't run on some old test systems.\n#\nxmm-$(TARGET).test: $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool.test: $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(QGREP) \"$1 = 0x0000000000000000000000003f800000\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"$2 = 0x00000000000000000000000040000000\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"$3 = 0xff00ff000a550a55123456789abcdef0\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"exited normally.\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"instrumented the movdqa\" $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\t$(QGREP) \"did setApplicationBreakpoint\" $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\t$(QGREP) \"regular_context\" $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_const_context.test: $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN)  $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out -const_context 1 \\\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(QGREP) \"$1 = 0x0000000000000000000000003f800000\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"$2 = 0x00000000000000000000000040000000\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"$3 = 0xff00ff000a550a55123456789abcdef0\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"exited normally.\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"instrumented the movdqa\" $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\t$(QGREP) \"did setApplicationBreakpoint\" $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\t$(QGREP) \"const_context\" $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_and_set_xmm_reg.test: $(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN)  $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out \\\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(QGREP) \"$1 = 0x0000000000000000000000003f800000\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"$2 = 0x00000000000000000000000040000000\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"$3 = 0xff00ff000a550a55123456789abcdef0\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"$4 = 0x5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"exited normally.\" $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) \"instrumented the movdqa\" $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\t$(QGREP) \"tool got the expected gdb command\" $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\t$(QGREP) \"tool properly set xmm3\" $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_tool.test: $(OBJDIR)set_xmm_scratches$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN)  $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratches.out \\\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(QGREP) instrumented $(OBJDIR)set_xmm_scratches.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)set_xmm_scratches.out\n\n# Simple test of a threaded program.\n#\nthread.test: $(OBJDIR)thread$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)thread$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat thread.gdb >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)thread$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p thread.compare -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Simple test of a threaded program built statically (uses non-nptl thread package on Linux).\n# NOTE: This test is disabled, so it does not run automatically.  Modern versions of GDB do not\n#   support non-nptl threads well.\n#\nthread-static.test: $(OBJDIR)thread-static$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)thread-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat thread.gdb >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)thread-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p thread.compare -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Simple test of the 'pindb' debugger.  We launch Pin separatly and pindb attaches.\n#\nsimple-pindb-attach.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) basic $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.compare)\n\t$(PYTHON) launch-pin-attach-debugger.py --pin=$(BARE_PIN) --pin-exe=$(BARE_PIN) \\\n\t    --pindb=$(PINDB) --pindb-libpath=$(PINDB_LIBPATH) \\\n\t    --tool=$(OBJDIR)stack-debugger$(PINTOOL_SUFFIX) --app=$(OBJDIR)simple-pindb$(EXE_SUFFIX) \\\n\t    --cpu=$(TARGET) --timeout=$(TLIMIT) \\\n\t    --pin-out=$(OBJDIR)$(@:.test=.out) --pindb-in=$(OBJDIR)$(@:.test=.pindbin) \\\n\t    --pindb-out=$(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.compare) $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.pindbout)\n\n# Simple test of the 'pindb' debugger.  We use the pindb \"run\" command to launch and attach to pin.\n#\nsimple-pindb-launch.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) basic $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple-pindb$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(OBJDIR)$(@:.test=.pindbin.0) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare) $(OBJDIR)$(@:.test=.pindbout) \\\n\t      $(OBJDIR)$(@:.test=.pindbin)\n\n# Test the checkpoint tool.\n#\ncheckpoint.test: $(OBJDIR)checkpoint-app$(EXE_SUFFIX) $(OBJDIR)checkpoint$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)checkpoint$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)checkpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)checkpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p checkpoint-gdb.compare -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p checkpoint-app.compare -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test the watchpoint tool.\n#\nwatchpoint.test: $(OBJDIR)watchpoint-app$(EXE_SUFFIX) $(OBJDIR)watchpoint$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)watchpoint-app 1 > $(OBJDIR)$(@:.test=.gdb)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)watchpoint$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(OBJDIR)$(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout) $(OBJDIR)$(@:.test=.gdb)\n\nwatchpoint_const_context.test: $(OBJDIR)watchpoint-app$(EXE_SUFFIX) $(OBJDIR)watchpoint$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)watchpoint-app$(EXE_SUFFIX) 1 > $(OBJDIR)$(@:.test=.gdb)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)watchpoint$(PINTOOL_SUFFIX) -const_context 1 \\\n\t  -- $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(OBJDIR)$(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout) $(OBJDIR)$(@:.test=.gdb)\n\n# This test starts Pin with debugger support enabled, but Pin does not stop at\n# the first instruction waiting for a debugger to attach.  Instead, the\n# application runs under Pin immediately.  Later, if the tool finds something\n# interesting, it can ask the user (or a GUI shell) to start the debugger and\n# attach at the interesting point.\n#\nlaunch-gdb.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.gdbin)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) -timeout $(TLIMIT) \\\n\t  -o $(OBJDIR)$(@:.test=.gdbin) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.gdbin) > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# This tests the -appdebug_server_port <PORT> option of PIN.\n# We pick an available TCP port randomly, then we run PIN with -appdebug_server_port specifying the random port\n# We expect to connect with GDB to the port we specified\n#\ngdb-fixed-port.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.gdbin)\n\t$(OBJDIR)pick-random-port$(EXE_SUFFIX) unused > $(OBJDIR)$(@:.test=.random)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_server_port `cat $(OBJDIR)$(@:.test=.random)` -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) -timeout $(TLIMIT) \\\n\t  -o $(OBJDIR)$(@:.test=.gdbin) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote :'`cat $(OBJDIR)$(@:.test=.random)` $(OBJDIR)$(@:.test=.gdbin) > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# This tests the -appdebug_server_port <PORT> option of PIN when we.\n# provide a port which is already taken by another application\n# We expect PIN to fail because it won't acquire the port\n#\ngdb-fixed-port-used.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.gdbin)\n\t$(OBJDIR)pick-random-port$(EXE_SUFFIX) used > $(OBJDIR)$(@:.test=.random)\n\t! ( $(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_server_port `cat $(OBJDIR)$(@:.test=.random)` -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) \\\n\t    -timeout $(TLIMIT) -o $(OBJDIR)$(@:.test=.gdbin) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) )\n\t$(QGREP) \"E:Unable to create debugger connection\" $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.random)\n\n# This tests the -appdebug_server_port <PORT> option of PIN when we\n# provide an invalid TCP port number.\n# We expect PIN to fail because the TCP port number is invalid\n#\ngdb-fixed-bad-port.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.gdbin)\n\t! ( $(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_server_port 100000 -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) \\\n\t    -timeout $(TLIMIT) -o $(OBJDIR)$(@:.test=.gdbin) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) )\n\t$(QGREP) \"E:Invalid TCP server port: 100000\" $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin)\n\nlaunch-gdb_const_context.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.gdbin)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) -const_context 1 -timeout $(TLIMIT) \\\n\t  -o $(OBJDIR)$(@:.test=.gdbin) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.gdbin) > /dev/null 2>&1 || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# This is the example tool we describe in the manual, which demonstrates the major features\n# of the application-level debugging API.  The tool tracks the application's stack usage\n# and allows breakpoints to be set when the stack usage crosses a threshold.\n#\nstack-debugger.test: $(OBJDIR)fibonacci$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)fibonacci$(EXE_SUFFIX) 1000 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)fibonacci$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that we can asynchronously stop the target in PinDB by sending CTRL-C (SIGINT).\n# TODO: This is disabled until Mantis #2055 is fixed.\n#\npindb-async-stop.test: $(OBJDIR)sleep-unix$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)sleep-unix$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout) & \\\n\t    pid=$$!; \\\n\t    sleep 2; \\\n\t    while kill -INT $$pid > /dev/null 2>&1; \\\n\t    do \\\n\t        sleep 2; \\\n\t    done; \\\n\t    wait\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test of breakpoint commands in the \"debugger-shell\" instrumentation library.\n#\ndebugger-shell-breakpoints.test: $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) breakpoints $(OBJDIR)$(@:.test=.gdbin.0) $(OBJDIR)$(@:.test=.compare)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(OBJDIR)$(@:.test=.gdbin.0) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin.0) $(OBJDIR)$(@:.test=.compare) \\\n\t      $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test of tracepoint commands in the \"debugger-shell\" instrumentation library.\n#\ndebugger-shell-tracepoints.test: $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) tracepoints $(OBJDIR)$(@:.test=.gdbin.0) $(OBJDIR)$(@:.test=.compare)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(OBJDIR)$(@:.test=.gdbin.0) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin.0) $(OBJDIR)$(@:.test=.compare) \\\n\t      $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that the thread-start, thread-fini, and fini call-backs are correctly called even when GDB\n# immediately terminates the application .\n#\nstart-fini.test: $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) -o $(OBJDIR)$(@:.test=.toolout) \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) & \\\n\t    count=0; \\\n\t    until $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t        do sleep 1; count=`expr $$count + 1`; done; \\\n\t    echo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin); \\\n\t    $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin); \\\n\t    cat quit.gdb >> $(OBJDIR)$(@:.test=.gdbin); \\\n\t    $(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1; \\\n\twait\n\t$(CMP) start-fini.reference $(OBJDIR)$(@:.test=.toolout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that the thread-start, thread-fini, and fini call-backs are correctly called when PinDB\n# immediately terminates the application (tested on both Linux and Windows).\n#\npindb-start-fini.test: $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) \\\n\t    -o $(OBJDIR)$(@:.test=.toolout)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(DIFF) start-fini.reference $(OBJDIR)$(@:.test=.toolout)\n\t$(SYNC)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\nstop-resume-when-suspended.test: $(OBJDIR)stop-resume-when-suspended$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)stop-resume-when-suspended$(PINTOOL_SUFFIX) \\\n\t    -o $(OBJDIR)$(@:.test=.toolout)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\tsleep 5\n\t$(DIFF) stop-resume-when-suspended.reference $(OBJDIR)$(@:.test=.toolout)\n\t$(QGREP) \"Sum is 55\" $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Verify that PIN_InterceptDebuggingEvent() can intercept and squash breakpoints.\n#\nintercept-breakpoint.test: $(OBJDIR)intercept-app$(EXE_SUFFIX) $(OBJDIR)intercept-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)intercept-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)intercept-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)intercept-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=-gdb.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=-app.compare) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test the PIN_AddDebuggerRegisterEmulator() API.  This test is legal to run with any version of GDB,\n# but it only tests the API well when run with a GDB that supports register extensions in the XML\n# \"feature document\".  This includes GDB 7.2 and later, and a few special earlier distributions.\n#\nemu-simple.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)null-emulator-$(TARGET)$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)null-emulator-$(TARGET)$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat simple.gdb >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p simple.compare -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Verify that the debugger can print the value of a YMM register when running on native AVX hardware.\n# This test will pass even when run on non-AVX hardware.  However, it's only effective when run on\n# AVX hardware and when run with a GDB that supports AVX.\n#\nymm.test: $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\nymm_with_set_xmm_scratch_regs_tool.test: $(OBJDIR)set_xmm_scratches_for_ymmtest$(PINTOOL_SUFFIX) $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_for_ymmtest$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\tcat set_xmm_scratches_for_ymmtest.out\n\t$(QGREP) instrumented set_xmm_scratches_for_ymmtest.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f instrumented set_xmm_scratches_for_ymmtest.out\n\n# Verify that the debugger can print the value of a ZMM register when running on native AVX512 hardware.\n# This test will pass even when run on non-AVX512 hardware.  However, it's only effective when run on\n# AVX512 hardware and when run with a GDB that supports AVX512.\n#\nzmm.test: $(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\tif ! $(QGREP) \"HandleSigill\" $(OBJDIR)$(@:.test=.gdbout) ; then \\\n\t  $(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout); \\\n\tfi\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\npindb-zmm.test: $(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX)\n\techo \"set pinargs \" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\tif ! $(QGREP) \"Processor does not support AVX512\" $(OBJDIR)$(@:.test=.pindbout) ; then \\\n\t  $(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout); \\\n\tfi\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Verify that the debugger change the the PC when stopped after an indirect JMP instruction.\n#\npc-change-bp.test: $(OBJDIR)pc-change-bp$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)pc-change-bp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)pc-change-bp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Verify that the tool can change the PC from an ASYNC_BREAK intercept function when the thread\n# is stopped after an indirect JMP instruction.\n#\npc-change-async.test: $(OBJDIR)pc-change-async$(EXE_SUFFIX) $(OBJDIR)pc-change-async-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)pc-change-async-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)pc-change-async$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)pc-change-async$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test the PIN_RemoveDebugInterpreter() API.\n#\ninterpreter-remove.test: $(OBJDIR)interpreter-remove$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) -appdebug -t $(OBJDIR)interpreter-remove$(PINTOOL_SUFFIX) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t  do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\techo 'monitor bdio' >> $(OBJDIR)$(@:.test=.gdbin)\n\techo 'c' >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > /dev/null 2>&1\n\t! $(GREP) 'PIN_RemoveDebugInterpreter failed' $(OBJDIR)$(@:.test=.out) > /dev/null\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin)\n\n# Verify that GDB can terminate an application where one thread is blocked in\n# a system call.  Previously, the Pin process would sometimes hang when this\n# happened, so the test checks that the process exits.  (Note, \"kill -s 0 <pid>\"\n# just checks if a process exists, it doesn't send a signal.)\n#\nmt-exit.test: $(OBJDIR)mt-exit$(EXE_SUFFIX) $(OBJDIR)mt-exit-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.toolout)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)mt-exit-tool$(PINTOOL_SUFFIX) -o $(OBJDIR)$(@:.test=.toolout) \\\n\t  -- $(OBJDIR)mt-exit$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)mt-exit$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\tpid=`cat $(OBJDIR)$(@:.test=.toolout)`; \\\n\tcount=0; \\\n\tuntil ! kill -s 0 $$pid > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done; \\\n\t$(BASHTEST) $$count -le $(TLIMIT)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout) $(OBJDIR)$(@:.test=.toolout)\n\n# Simple test of the PIN_GetDebuggerType() API.\n#\ndebugger-type.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)debugger-type$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)debugger-type$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(GREP) 'Debugger Type is GDB' $(OBJDIR)$(@:.test=.out) > /dev/null\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that we can single-step into a signal handler.\n#\nsignal-step.test: $(OBJDIR)signal-catch$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that GDB can print $_siginfo and get the signal information structure from Pin.\n#\nsiginfo.test: $(OBJDIR)signal-catch$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that PinDB can attach after the Pin tool has stopped at a custom breakpoint and that PinDB\n# can still get the tool's custom stop message (see Mantis #2357).\n#\n# This is disabled on Windows, but it could probably be enabled there when Mantis #1839 is fixed.\n#\npindb-attach-after-custom-stop.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) \\\n\t  -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -where main -wait_for_debugger 1 -port $(OBJDIR)$(@:.test=.port) \\\n\t    -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'Tool stopping at breakpoint' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    --gdb-protocol=:`cat $(OBJDIR)$(@:.test=.port)` $(PINDB_USERFLAGS) < $(@:.test=.pindbin) > \\\n\t    $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows unhandled exception with PinDB.\n#\npindb-win-unhandled-exception.test: $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows handled exception with PinDB.\n#\npindb-win-handled-exception.test: $(OBJDIR)win-handled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-handled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows continued exception with PinDB.  The exception filter continues the search.\npindb-win-continued-exception1.test: $(OBJDIR)win-continued-exception1$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-continued-exception1$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows continued exception with PinDB.  The exception filter executes the handler.\npindb-win-continued-exception2.test: $(OBJDIR)win-continued-exception2$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-continued-exception2$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows software exception with PinDB.  The exception is raised via RaiseException() and is unhandled.\n#\npindb-win-software-exception.test: $(OBJDIR)win-software-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-software-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows C++ exception with PinDB.\n#\npindb-win-cpp-exception.test: $(OBJDIR)win-cpp-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-cpp-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test ability to squash a Windows exception.  Squashing a first-chance exception re-executes\n# the excepting instruction, which raises a new first-chance exception.  Squashing a last-chance\n# exception also re-executes the excepting instruction, which raises a new first-chance exception.\n#\npindb-win-squash-exception.test: $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test ability to single-step after receiving a Windows exception.  Stepping from a first-chance\n# exception should go to the first instruction in the handler.  Stepping from a last-chance\n# exception should cause the application to terminate.\n#\npindb-win-step-exception.test: $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that Pin properly handles exception which happens after beginning of process exit flow\n# when PinADX is disabled.\n#\npindb-win-exception-after-exit.test: $(OBJDIR)win-exception-after-exit$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-exception-after-exit$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --noprompt $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\tsleep 2\n\t$(QGREP) \"Caught exception C0000005\" $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test DLL load / unload notifications with PinDB.\n#\npindb-win-library-notifications.test: $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test ability to single-step after receiving a Windows library load / unload notification.\n#\npindb-win-step-library.test: $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Make sure PinDB does not wait for confirmation when killing the target process when --noprompt is specified.\n#\npindb-noprompt-kill.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test the -appdebug_allow_remote knob, which allows GDB to run on a different machine than Pin.\n# However, it's difficult to actually run GDB on a different machine as part of this test, so\n# we still run them both on the same machine.\n#\nallow-remote.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -appdebug_allow_remote -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat simple.gdb >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p simple.compare -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Verify that Pin doesn't crash if the debugger attempts to access a 64-bit address for a 32-bit Pin process.\n#\naccess-64-on-32.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Make sure we can ebable debugging via PIN_SetDebugMode() from the tool.  This test should\n# be run without -appdebug.\n#\nset-mode.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)set-mode-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) -t $(OBJDIR)set-mode-tool$(PINTOOL_SUFFIX) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat simple.gdb >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout)\n\t$(PYCOMPARE) -p simple.compare -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that PinDB can detach from Pin.\n#\npindb-detach.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) detach $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple-pindb$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(OBJDIR)$(@:.test=.pindbin.0) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.pindbin.0) \\\n\t      $(OBJDIR)$(@:.test=.compare)\n\n# Abruptly disconnect PinDB from Pin.  This simulates the behavior when the debugger unexpectedly dies.\n# We expect an error from Pin, but Pin shouldn't hang.\n#\npindb-abrupt-disconnect.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs -logfile $(OBJDIR)$(@:.test=.pin.log) $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(SYNC)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pin.log) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbin) \\\n\t      $(OBJDIR)$(@:.test=.pindbout)\n\n# Test the \"kill-like-gdb\" command in PinDB.  This sends the same legacy \"kill\" command to PinADX that\n# GDB uses.\n#\npindb-kill-like-gdb.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that GDB can detach from Pin and then re-attach later.\n#\ngdb-detach-reattach.test: $(OBJDIR)reattach-loop$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > $(OBJDIR)$(@:.test=.port)\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=-1.gdbin)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-1.gdbin)\n\tcat $(@:.test=-1.gdb) >> $(OBJDIR)$(@:.test=-1.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=-1.gdbin) -n $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-1.gdbout)\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=-2.gdbin)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-2.gdbin)\n\tcat $(@:.test=-2.gdb) >> $(OBJDIR)$(@:.test=-2.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=-2.gdbin) -n $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-2.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-1.compare) -c $(OBJDIR)$(@:.test=-1.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-2.compare) -c $(OBJDIR)$(@:.test=-2.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=-app.compare) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port) $(OBJDIR)$(@:.test=-1.gdbin) \\\n\t      $(OBJDIR)$(@:.test=-1.gdbout) $(OBJDIR)$(@:.test=-2.gdbin) $(OBJDIR)$(@:.test=-2.gdbout)\n\n# Test that GDB can detach from Pin and then re-attach later.\n#\ngdb-detach-reattach-fixed-port.test: $(OBJDIR)reattach-loop$(EXE_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)pick-random-port$(EXE_SUFFIX) unused > $(OBJDIR)$(@:.test=.random)\n\t$(PIN) $(PINFLAGS_DEBUG) -appdebug_server_port `cat $(OBJDIR)$(@:.test=.random)` -- \\\n\t    $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote :'`cat $(OBJDIR)$(@:.test=.random)` \\\n\t    $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(GREP) 'target remote :'`cat $(OBJDIR)$(@:.test=.random)` $(OBJDIR)$(@:.test=.out) > $(OBJDIR)$(@:.test=.port)\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=-1.gdbin)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-1.gdbin)\n\tcat $(@:.test=-1.gdb) >> $(OBJDIR)$(@:.test=-1.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=-1.gdbin) -n $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-1.gdbout)\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=-2.gdbin)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-2.gdbin)\n\tcat $(@:.test=-2.gdb) >> $(OBJDIR)$(@:.test=-2.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=-2.gdbin) -n $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-2.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-1.compare) -c $(OBJDIR)$(@:.test=-1.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-2.compare) -c $(OBJDIR)$(@:.test=-2.gdbout)\n\t$(PYCOMPARE) -p $(@:.test=-app.compare) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port) $(OBJDIR)$(@:.test=-1.gdbin) \\\n\t    $(OBJDIR)$(@:.test=-1.gdbout) $(OBJDIR)$(@:.test=-2.gdbin) $(OBJDIR)$(@:.test=-2.gdbout) \\\n\t    $(OBJDIR)$(@:.test=.random)\n\n# Test that extended commands work using PinDB.  This also checks that the tool does _not_ receive\n# commands that start with the \"pin \" prefix.\n#\npindb-simple-command.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)simple-command-tool$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simple-command-tool$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that the debugger can write to an invalid address in the application.\n#\ninvalid-write.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Try debugging an application with lots of threads that exit at the same time.\n#\npindb-win-thread-stress.test: $(OBJDIR)win-thread-stress$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-thread-stress$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that we can single-step over an instruction that exits the calling thread while another thread\n# still exists.  We expect the debugger to stop after the thread exits, leaving the focus on\n# the one remaining thread.\n#\npindb-pthread-step-exit.test: $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Same test as above, but use GDB instead of PinDB.\n#\ngdb-pthread-step-exit.test: $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that we can debug an application where one thread exits the entire process\n# while another thread still exists.\n#\npindb-pthread-cont-exitgroup.test: $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that we can single-step over an instruction that exits the entire process while\n# another thread still exists.  We expect the debugger to stop after the exit call\n# and indicate that the process is terminated.\n#\npindb-pthread-step-exitgroup.test: $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that we can single-step over an instruction that triggers a custom breakpoint.\n# This should stop due to the custom breakpoint, without stepping over the instruction.\n# A subsequent step should skip the custom breakpoint and step over the instruction.\n#\npindb-step-custom-break.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX) $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) step-custom-break $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple-pindb$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(OBJDIR)$(@:.test=.pindbin.0) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare) $(OBJDIR)$(@:.test=.pindbin) \\\n\t      $(OBJDIR)$(@:.test=.pindbout)\n\n# Test the behavior when several threads stop at simultaneous tool breakpoints.\n# After one breakpoint is delivered, the others are pending.  This test makes\n# sure that the pending events are delivered one-at-a-time to GDB.  It also\n# tests that the tool can list the pending breakpoints.\n#\nsimultaneous-toolbreak.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\nsimultaneous-toolbreak_const_context.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 -const_context 1 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# After one breakpoint is delivered, the others are pending.  This test\n# squashes the pending breakpoints and then makes sure they are not\n# delivered to GDB.\n#\nsimultaneous-toolbreak-squash.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# After one breakpoint is delivered, the others are pending.  This test\n# changes the message of the pending breakpoints and then makes sure they\n# are delivered with the new message.\n#\nsimultaneous-toolbreak-change.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Test that we can attach GDB to the application after it has stopped\n# at several simultaneous tool breakpoints.  We expect GDB to attach\n# at the context of one of those breakpoints, and we expect the others\n# to be pending.\n#\nsimultaneous-toolbreak-attach.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) \\\n\t  -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 -wait_for_debugger \\\n\t    -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'Waiting for debugger to attach' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test runs with PinDB, which expects all breakpoints to be delivered\n# simultaneously.  Make sure that all 4 breakpoints are delivered at once,\n# and that none are pending.\n#\npindb-simultaneous-toolbreak.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test runs PinDB in a mode where each breakpoint is delivered one-\n# at-a-time (similar to GDB).  We make sure that there are pending breakpoints\n# after the first is delivered, and we make sure that all breakpoints are\n# delivered one-at-a-time.\n#\npindb-simultaneous-toolbreak-serialize.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test also runs PinDB in a mode where each breakpoint is delivered\n# one-at-a-time.  In this test, we squash the remaining breakpoints after\n# the first is delivered and then make sure that the squashed breakpoints\n# are not delivered.\n#\npindb-simultaneous-toolbreak-squash.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test also runs PinDB in a mode where each breakpoint is delivered\n# one-at-a-time.  In this test, we change the message of the remaining\n# breakpoints after the first is delivered and then make sure that the\n# breakpoints are delivered with the changed message.\n#\npindb-simultaneous-toolbreak-change.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# When breakpoints are delivered one-at-a-time, try single-stepping one\n# thread while there are pending breakpoints on the others.  The pending\n# breakpoints should not be delivered because the single-step doesn't\n# advance the execution of those threads.\n#\npindb-simultaneous-toolbreak-step.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# This is a stress test for simultaneous debugger events.  Each thread stops when\n# the thread is created, at a normal breakpoint, at a tool breakpoint, and stops\n# when the thread exits.  There is no serialization in this variant of the test,\n# so we expect that many events will be reported to the debugger simultaneously.\n# The test verifies that we get all the events.\n#\npindb-simultaneous-multi.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n        $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare3) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare4) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This test is identical to the one above except that we don't stop when new\n# threads are created or when they exit.  We use this test on Windows to avoid\n# a problem with the virus scanner.  If a virus scan happens when this test runs,\n# the scanner injects a new thread into the test application.  If the debugger\n# stops when new threads are created, the scanner thread causes an extra stop in\n# the debugger which causes the test to fail.  This variant of the test avoids\n# the problem by not stopping in the debugger when new threads start or exit.\n# We also run this test on Unix because it tests different code paths in Pin.\n#\npindb-simple-simultaneous-multi.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n        $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This is another stress test for simultaneous debugger events, similar to the\n# one above.  In this variant, Pin delivers the events one-at-a-time to the\n# debugger.  Again, we verifiy that the debugger gets them all.\n#\npindb-simultaneous-multi-serialize.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare3) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare4) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This test is identical to the one above except that we don't stop when new\n# threads are created or when they exit.  We use this test on Windows to avoid\n# a problem with the virus scanner.  See \"pindb-simple-simultaneous-multi.test\"\n# for more information.  We also run it on Unix because it tests different code\n# paths in Pin.\n#\npindb-simple-simultaneous-multi-serialize.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This is similar to \"simultaneous-toolbreak-attach\", but we use PinDB\n# instead of GDB.  The application stops at several simultaneous breakpoints\n# before PinDB attaches.  Since PinDB allows multiple simultaneous breakpoints,\n# we expect all of them to be visible when PinDB attaches, and there will be\n# no pending breakpoints.\n#\n# This is disabled on Windows, but it could probably be enabled there when Mantis #1839 is fixed.\n#\npindb-simultaneous-toolbreak-attach.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -wait_for_debugger -port $(OBJDIR)$(@:.test=.port) -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 \\\n\t    > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'Waiting for debugger to attach' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    --gdb-protocol=:`cat $(OBJDIR)$(@:.test=.port)` $(PINDB_USERFLAGS) < $(@:.test=.pindbin) > \\\n\t    $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address) \\\n\t  $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port)\n\n# Test that we can use a custom command to change the register state of the target application,\n# and then use the \"invalidate registers\" API to invalidate any stale register data in the\n# debugger protocol library.\n#\npindb-invalidate-regs.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)invalidate-regs$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)invalidate-regs$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --noprompt $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# This test validates stopping threads API called in application thread.\napp-pause-in-app-thread.test: $(OBJDIR)app-pause-in-app-thread-tool$(PINTOOL_SUFFIX) $(OBJDIR)app-pause-app$(EXE_SUFFIX)\n\t$(PIN) -t $(OBJDIR)app-pause-in-app-thread-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)app-pause-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out)\n\t$(CGREP) 'Threads stopped by application thread' $(OBJDIR)$(@:.test=.out) | $(QGREP) \"3\"\n\t$(RM) $(OBJDIR)$(@:.test=.out)\n\n# This test validates stopping threads API called in internal thread.\napp-pause-in-int-thread.test: $(OBJDIR)app-pause-in-int-thread-tool$(PINTOOL_SUFFIX) $(OBJDIR)app-pause-app$(EXE_SUFFIX)\n\t$(PIN) -t $(OBJDIR)app-pause-in-int-thread-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)app-pause-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out)\n\t$(CGREP) 'Threads stopped by internal thread' $(OBJDIR)$(@:.test=.out) | $(QGREP) \"3\"\n\t$(RM) $(OBJDIR)$(@:.test=.out)\n\ncheck-if-thread-stopped.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)check-if-thread-stopped$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)check-if-thread-stopped$(PINTOOL_SUFFIX) -threads 4\" \\\n\t  -o $(OBJDIR)$(@:.test=.toolout) > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\tsleep 5\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(QGREP) \"Finished\" $(OBJDIR)$(@:.test=.toolout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.toolout)\n\n# Tests GDB extension of retrieving loaded shared libraries\n# Also, this test changes the base address of libc.so as seen\n# by GDB to 0xd00dead and checks that GDB reports the expected\n# base address.\n#\ngdb-svr4-libraries-extension.test: $(OBJDIR)dlopen-dlclose$(EXE_SUFFIX) $(OBJDIR)library-load-tool$(PINTOOL_SUFFIX)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)library-load-tool$(PINTOOL_SUFFIX) -- \\\n\t    $(OBJDIR)dlopen-dlclose$(EXE_SUFFIX) `$(CXX) $(COMP_OBJ) /dev/null -print-file-name=libm.so` > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo 'set remotetimeout $(TLIMIT)' > $(OBJDIR)$(@:.test=.gdbin)\n\t$(GREP) 'target remote' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.gdbin)\n\tcat $(@:.test=.gdb) >> $(OBJDIR)$(@:.test=.gdbin)\n\t$(GDB) -batch -x $(OBJDIR)$(@:.test=.gdbin) -n $(OBJDIR)dlopen-dlclose$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.gdbout) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.gdbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.gdbin) $(OBJDIR)$(@:.test=.gdbout)\n\n\n##############################################################\n#\n# Build rules\n#\n##############################################################\n\n# This section contains the build rules for all binaries that have special build rules.\n# See makefile.default.rules for the default build rules.\n\n###### Special tools' build rules ######\n\n$(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX): $(OBJDIR)use-debugger-shell$(OBJ_SUFFIX) $(OBJDIR)debugger-shell$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches_before_breakpoint$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches_for_ymmtest$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches_for_ymmtest$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n###### Special applications' build rules ######\n\n$(OBJDIR)simple$(EXE_SUFFIX): simple.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)bphandler_app$(EXE_SUFFIX): bphandler_app.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)simple-static$(EXE_SUFFIX): simple.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(STATIC) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)exec$(EXE_SUFFIX): exec.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)fork$(EXE_SUFFIX): fork.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX): bptest.cpp bptest-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)action-pending-app$(EXE_SUFFIX): action-pending-app.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX): xmm.c xmm-asm-$(TARGET).s\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)thread$(EXE_SUFFIX): thread.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)thread-static$(EXE_SUFFIX): thread.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(STATIC) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)simple-pindb$(EXE_SUFFIX): simple-pindb.cpp $(OBJDIR)simple-pindb-asm-$(TARGET_OS)-$(TARGET)$(OBJ_SUFFIX)\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(NO_RANDOM) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)checkpoint-app$(EXE_SUFFIX): checkpoint-app.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)watchpoint-app$(EXE_SUFFIX): watchpoint-app.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)callerapp$(EXE_SUFFIX): callerapp.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)fibonacci$(EXE_SUFFIX): $(TOOLS_ROOT)/ManualExamples/fibonacci.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)sleep-unix$(EXE_SUFFIX): sleep-unix.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX): debugger-shell-app.cpp debugger-shell-app-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)intercept-app$(EXE_SUFFIX): intercept-app.cpp intercept-app-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX): ymm.cpp ymm-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX): zmm.cpp $(OBJDIR)zmm-asm-$(TARGET)$(OBJ_SUFFIX)\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pc-change-bp$(EXE_SUFFIX): pc-change-bp.cpp pc-change-bp-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pc-change-async$(EXE_SUFFIX): pc-change-async.cpp pc-change-async-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)mt-exit$(EXE_SUFFIX): mt-exit.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)signal-catch$(EXE_SUFFIX): signal-catch.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-unhandled-exception$(EXE_SUFFIX): win-unhandled-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n \n$(OBJDIR)win-handled-exception$(EXE_SUFFIX): win-handled-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-continued-exception1$(EXE_SUFFIX): win-continued-exception1.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-continued-exception2$(EXE_SUFFIX): win-continued-exception2.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-software-exception$(EXE_SUFFIX): win-software-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-cpp-exception$(EXE_SUFFIX): win-cpp-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-exception-after-exit$(EXE_SUFFIX): win-exception-after-exit.cpp $(OBJDIR)$(DLL_PREFIX)win-exception-after-exit-dll$(DLL_SUFFIX)\n\t$(APP_CXX) $(APP_CXXFLAGS) $(COMP_EXE)$@ $< $(APP_LDFLAGS) $(APP_LIBS) $(OBJDIR)win-exception-after-exit-dll$(LIB_SUFFIX)\n\n$(OBJDIR)win-load-library$(EXE_SUFFIX): win-load-library.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)reattach-loop$(EXE_SUFFIX): reattach-loop.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(NO_PIC) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-thread-stress$(EXE_SUFFIX): win-thread-stress.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pthread-bare-exit$(EXE_SUFFIX): pthread-bare-exit.cpp pthread-bare-exit-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX): pthread-bare-exitgroup.cpp pthread-bare-exitgroup-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n# A simple threaded application that we use for several tests.  Both Windows and Posix (Unix)\n# versions export the function \"GlobalFunction()\", which the tests rely on.\n#\n$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX): thread-$(OS_TYPE).cpp\n\t$(APP_CXX) $(COMPONENT_INCLUDES) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)app-pause-app$(EXE_SUFFIX): app-pause-app.cpp $(THREADLIB)\n\t$(APP_CXX) $(COMPONENT_INCLUDES) $(APP_CXXFLAGS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS) $(APP_LPATHS) $(APP_LIBS) $(APP_LIB_ATOMIC)\n\n###### Special objects' build rules ######\n\n$(OBJDIR)stack-debugger$(OBJ_SUFFIX): $(TOOLS_ROOT)/ManualExamples/stack-debugger.cpp\n\t$(CXX) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)debugger-shell$(OBJ_SUFFIX): $(TOOLS_ROOT)/InstLib/debugger-shell.cpp\n\t$(CXX) $(TOOL_CXXFLAGS) $(SUPPRESS_WARNING_ALIGNED_NEW) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)start-fini-callback$(OBJ_SUFFIX): start-fini-callback.cpp\n\t$(CXX) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)simple-pindb-asm-$(TARGET_OS)-$(TARGET)$(OBJ_SUFFIX): simple-pindb-asm-$(TARGET_OS)-$(TARGET)$(ASM_SUFFIX)\n\t$(ASMBLR) $(ASM_FLAGS) $(DBG_INFO_CXX_ALWAYS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)win-foo-library$(OBJ_SUFFIX): win-foo-library.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DLL_CXXFLAGS) $(DBG_INFO_CXX_ALWAYS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX): set_xmm_scratches_$(TARGET)$(ASM_SUFFIX)\n\t$(ASMBLR) $(ASM_FLAGS) $(DBG_INFO_CXX_ALWAYS) $(COMP_OBJ)$@ $<\n\n###### Special dlls' build rules ######\n\n$(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX): $(OBJDIR)win-foo-library$(OBJ_SUFFIX)\n\t$(LINKER) $(APP_LDFLAGS_NOOPT) $(DLL_LDFLAGS) $(LINK_EXE)$@ $< $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)$(DLL_PREFIX)win-exception-after-exit-dll$(DLL_SUFFIX): win-exception-after-exit-dll.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS) $(DLL_CXXFLAGS) $(COMP_EXE)$@ $< $(APP_LDFLAGS) $(DLL_LDFLAGS) $(APP_LIBS)\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Debugger/dlopen-dlclose.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#define _GNU_SOURCE\n#include <dlfcn.h>\n#include <link.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// Macro to create empty function which won't be opt-out by\n// the compiler\n#define EMPTY_FUNCTION(name) \\\n    void name();        \\\n    __asm__(              \\\n    \".global \" #name \"\\n\" \\\n    #name \":\\n\"          \\\n    \"ret\\n\"               \\\n    )\n\nEMPTY_FUNCTION(AfterLoadLibrary);\nEMPTY_FUNCTION(AfterUnloadLibrary);\n\nint main(int argc, char* argv[])\n{\n    if (argc != 2)\n    {\n        fprintf(stderr, \"Usage: %s <path to dynamic library>\\n\", argv[0]);\n        exit(1);\n    }\n    const char* file = argv[1];\n    printf(\"Loading shared object %s\\n\", file);\n    fflush(stdout);\n    void *handle = dlopen(file, RTLD_NOW | RTLD_LOCAL);\n    if (NULL == handle)\n    {\n        fprintf(stderr,\"Failed to load %s - %s\\n\", file, dlerror());\n        exit(1);\n    }\n    AfterLoadLibrary();\n    printf(\"Unloading shared object %s\\n\", file);\n    fflush(stdout);\n    dlclose(handle);\n    AfterUnloadLibrary();\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/ToolUnitTests/dltest.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define ONE \"libone.dylib\"\n#define TWO \"libtwo.dylib\"\n#else\n#define ONE \"libone.so\"\n#define TWO \"libtwo.so\"\n#endif\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n#if defined(TARGET_MAC) || defined(TARGET_BSD)\n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);\n#else    \n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n#endif    \n    fprintf(stderr, \"Allocated %p\\n\",mem);\n    // This unmap should not trigger a flush\n    munmap(mem, 0x2000);\n    \n    Load(ONE, 1);\n    Load(TWO, 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/ToolUnitTests/dltest2.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define ONE \"libone.dylib\"\n#define TWO \"libtwo.dylib\"\n#else\n#define ONE \"libone.so\"\n#define TWO \"libtwo.so\"\n#endif\n\nvoid Load(char *name, int expect)\n{\n    int val;\n    double dval;\n    \n    void *handle;\n    int (*sym)();\n    double (*fsin)(double);\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n        \n    val = sym();\n    if (val != expect)\n        exit(1);\n\n    dlclose(handle);\n}\n\nint main()\n{\n    int i;\n    for(i = 0; i < 100; i++)\n    {\n        switch(1 + rand() % 2) {\n        case 1:\n            Load(ONE, 1);\n            break;\n        case 2:\n            Load(TWO, 2);\n            break;\n        }\n    }\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/ToolUnitTests/main_dll.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*! @file\n *  pin tool combined from multi-DLLs (main_dll, dynamic_secondary_dll, static_secondary_dll). \n *  This is the \"main DLL\", use PIN API only in this DLL\n *  usage of PIN API in dynamic_secondary_dll and static_secondary_dll is not allowed\n *  (see README for more inforamtion)\n *\n *  NOTE: New Pin image loader does not (yet) support dynamic loading of Pin DLLs.\n *        Code related to dynamic_secondary_dll was suppressed.\n *        Look at Mantis 3280 for updates.\n *        #define DYN_LOAD will enable validation of dynamic loading feature in the test.\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"pin.H\"\n\nusing namespace std;\n\nKNOB<BOOL> KnobEnumerate(KNOB_MODE_WRITEONCE, \"pintool\",\n    \"enumerate\", \"0\", \"Enumerate modules loaded by Pin\");\n\n/* ===================================================================== */\n/* Global Variables and Declerations */\n/* ===================================================================== */\n\nPIN_LOCK pinLock;\n\ntypedef VOID (* BEFORE_BBL)(ADDRINT ip);\ntypedef int (* INIT_F)(bool enumerate);\ntypedef VOID (* FINI_F)();\n\n#if defined(DYN_LOAD)\n// Functions pointers for dynamic_secondary_dll\nBEFORE_BBL pBeforeBBL2;\nINIT_F pInit2;\nFINI_F pFini2;\n#endif\n\n// Dll imports for static_secondary_dll\nextern \"C\" __declspec( dllimport ) VOID BeforeBBL1(ADDRINT ip);\nextern \"C\" __declspec( dllimport ) VOID Init1();\nextern \"C\" __declspec( dllimport ) VOID Fini1();\n\n/* ===================================================================== */\n\n// This function is called before every basic block\nVOID PIN_FAST_ANALYSIS_CALL BeforeBBL(ADDRINT ip) \n{\n    PIN_GetLock(&pinLock, PIN_GetTid());\n    BeforeBBL1(ip);\n#if defined(DYN_LOAD)\n    pBeforeBBL2(ip);\n#endif\n    PIN_ReleaseLock(&pinLock);\n}\n\n/* ===================================================================== */\n\n// Pin calls this function every time a new trace is encountered\nVOID Trace(TRACE trace, VOID *v)\n{\n    // Visit every basic block  in the trace\n    for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl))\n    {\n        // Insert a call to BeforeBBL before every bbl, passing the ip address.\n        BBL_InsertCall(bbl, IPOINT_BEFORE, (AFUNPTR)BeforeBBL, IARG_FAST_ANALYSIS_CALL, \n                       IARG_INST_PTR, IARG_END);\n    }\n}\n\nVOID ThreadStart(THREADID threadid, CONTEXT *ctxt, INT32 flags, VOID *v)\n{\n    PIN_GetLock(&pinLock, PIN_GetTid());\n    BeforeBBL1(0);\n#if defined(DYN_LOAD)\n    pBeforeBBL2(0);\n#endif\n    PIN_ReleaseLock(&pinLock);\n}\n\nVOID ThreadFini(THREADID threadid, const CONTEXT *ctxt, INT32 code, VOID *v)\n{\n    PIN_GetLock(&pinLock, PIN_GetTid());\n    BeforeBBL1(0);\n#if defined(DYN_LOAD)\n    pBeforeBBL2(0);\n#endif\n    PIN_ReleaseLock(&pinLock);\n}\n\n/* ===================================================================== */\n\n// This function is called when the application exits\nVOID Fini(INT32 code, VOID *v)\n{\n    Fini1();\n#if defined(DYN_LOAD)\n    pFini2();\n#endif\n}\n\n// This function gets info of an image loaded by Pin loader.\n// Invoked by dl_iterate_phdr()\nint dl_iterate_callback(struct dl_phdr_info * info, size_t size, VOID * data)\n{\n    cerr << info->dlpi_name << \" \" << hex << info->dlpi_addr << \" \" << info->dlpi_phdr->p_memsz << endl;\n    // Increment module counter.\n    ++(*reinterpret_cast<int *>(data));\n    return 0;\n}\n\n/* ===================================================================== */\n\nint main(int argc, char * argv[])\n{\n    // Initialize pin\n    PIN_Init(argc, argv);\n\n    PIN_InitLock(&pinLock);\n\n    // Register Trace() to be called to instrument traces\n    TRACE_AddInstrumentFunction(Trace, 0);\n\n    // Register Fini() to be called when the application exits\n    PIN_AddFiniFunction(Fini, 0);\n\n    // Call Static secondary dll Init1()\n    Init1();\n\n    int nModules;\n\n#if defined(DYN_LOAD)\n    // Dynamic secondary dll - load library, initialize function pointers\n    // and call Init2()\n    VOID * module = dlopen(\"dynamic_secondary_dll.dll\", RTLD_NOW);\n    if (module == NULL)\n    {\n        cerr << \"Failed to load dynamic_secondary_dll.dll\" << endl;\n        exit(1);\n    }\n    pInit2 = reinterpret_cast<INIT_F>(dlsym(module, \"Init2\"));\n    pBeforeBBL2 = reinterpret_cast<BEFORE_BBL>(dlsym(module, \"BeforeBBL2\"));\n    pFini2 = reinterpret_cast<FINI_F>(dlsym(module, \"Fini2\"));\n    if (pInit2 == NULL || pBeforeBBL2 == NULL || pFini2 == NULL)\n    {\n        cerr << \"Failed to find proc addresses in dynamic_secondary_dll.dll\" << endl;\n        exit(1);\n    }\n\n    nModules = pInit2(KnobEnumerate);\n#endif\n\n    int nModulesMain = 0;\n    // Enumerate DLLs currently loaded by Pin loader.\n    dl_iterate_phdr(dl_iterate_callback, &nModulesMain);\n\n    if (KnobEnumerate && ((nModulesMain <= 0) || (nModulesMain != nModules)))\n    {\n        // Failure. Module enumeration results in main and dynamic Dlls don't match.\n        PIN_ExitApplication(1);\n    }\n\n    // Start the program, never returns\n    PIN_StartProgram();\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/ToolUnitTests/dlclose_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define LIBCLOSE \"libclose1.dylib\"\n#else\n#define LIBCLOSE \"libclose1.so\"\n#endif\n\nvoid Load(const char * name)\n{\n    void * handle;\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    dlclose(handle);\n}\n\nint main()\n{\n    Load(LIBCLOSE);\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/tpss_lin_libc_tool.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n * This tool mimics the behavior of TPSS on Linux by adding probes to various libc functions.\n * However, in this tool these probes are merely empty wrappers that call the original functions.\n * The objective of the test is to verify that probe generation and insertion don't cause Pin\n * to crash.\n *\n * This file is part of the tpss_lin_libc tool and compiles against the tool's libc (e.g. PIN CRT).\n * This file implements all the intrumenting logic thus requires PIN headers.\n */\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <ctime>\n#include <unistd.h>\n\n/* ===================================================================== */\n/* Commandline Switches                                                  */\n/* ===================================================================== */\n\ntypedef int * INT_PTR;\n\ntypedef void * VOID_PTR;\n\ntypedef char * CHAR_PTR;\n\nofstream OutFile;\n\nKNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\", \"o\", \"tpss_lin_libc.txt\",\n        \"specify tool log file name\");\n\n/* ===================================================================== */\n/* Pointers to the original functions that we probe                      */\n/* ===================================================================== */\nextern AFUNPTR fptrnanosleep;\nextern AFUNPTR fptrdl_iterate_phdr;\nextern AFUNPTR fptrsystem;\nextern AFUNPTR fptralarm;\nextern AFUNPTR fptrrecvmsg;\nextern AFUNPTR fptrsendmsg;\nextern AFUNPTR fptrpause;\nextern AFUNPTR fptrsigtimedwait;\nextern AFUNPTR fptrsigwaitinfo;\nextern AFUNPTR fptrepoll_wait;\nextern AFUNPTR fptrppoll;\nextern AFUNPTR fptrmsgsnd;\nextern AFUNPTR fptrmsgrcv;\nextern AFUNPTR fptrsemop;\nextern AFUNPTR fptrsemtimedop;\nextern AFUNPTR fptrusleep;\nextern AFUNPTR fptrualarm;\nextern AFUNPTR fptrgetitimer;\nextern AFUNPTR fptrsigwait;\nextern AFUNPTR fptrmsgget;\nextern AFUNPTR fptrsemget;\nextern AFUNPTR fptrwait;\nextern AFUNPTR fptrwaitpid;\nextern AFUNPTR fptrwaitid;\nextern AFUNPTR fptrwait3;\nextern AFUNPTR fptrwait4;\nextern AFUNPTR fptrreadv;\nextern AFUNPTR fptrwritev;\nextern AFUNPTR fptrflock;\nextern AFUNPTR fptrflockfile;\nextern AFUNPTR fptrfunlockfile;\nextern AFUNPTR fptrlockf;\nextern AFUNPTR fptrsetenv;\nextern AFUNPTR fptrunsetenv;\nextern AFUNPTR fptrgetenv;\nextern AFUNPTR fptrperror;\nextern AFUNPTR fptrmmap;\nextern AFUNPTR fptrmunmap;\nextern AFUNPTR fptrfileno;\nextern AFUNPTR fptrgetpid;\nextern AFUNPTR fptrgetppid;\nextern AFUNPTR fptrmemset;\nextern AFUNPTR fptrmemcpy;\nextern AFUNPTR fptraccess;\nextern AFUNPTR fptrlseek;\nextern AFUNPTR fptrlseek64;\nextern AFUNPTR fptrfdatasync;\nextern AFUNPTR fptrunlink;\nextern AFUNPTR fptrstrlen;\nextern AFUNPTR fptrwcslen;\nextern AFUNPTR fptrstrcpy;\nextern AFUNPTR fptrstrncpy;\nextern AFUNPTR fptrstrcat;\nextern AFUNPTR fptrstrstr;\nextern AFUNPTR fptrstrrchr;\nextern AFUNPTR fptrstrcmp;\nextern AFUNPTR fptrstrncmp;\nextern AFUNPTR fptrsigaddset;\nextern AFUNPTR fptrsigdelset;\nextern AFUNPTR fptrstrerror;\nextern AFUNPTR fptrbind;\nextern AFUNPTR fptrlisten;\nextern AFUNPTR fptruname;\nextern AFUNPTR fptrgethostname;\nextern AFUNPTR fptrkill;\nextern AFUNPTR fptrsched_yield;\nextern AFUNPTR fptrtimer_settime;\nextern AFUNPTR fptrsigaltstack;\nextern AFUNPTR fptrshutdown;\nextern AFUNPTR fptrsleep;\nextern AFUNPTR fptrsocket;\nextern AFUNPTR fptrselect;\nextern AFUNPTR fptrpoll;\nextern AFUNPTR fptraccept;\nextern AFUNPTR fptrconnect;\nextern AFUNPTR fptrrecv;\nextern AFUNPTR fptrrecvfrom;\nextern AFUNPTR fptrsend;\nextern AFUNPTR fptrgetwc;\nextern AFUNPTR fptrsetitimer;\nextern AFUNPTR fptrsigpending;\nextern AFUNPTR fptrsigaction;\nextern AFUNPTR fptrsignal;\nextern AFUNPTR fptrabort;\nextern AFUNPTR fptrsendto;\nextern AFUNPTR fptr_IO_getc;\nextern AFUNPTR fptrgetchar;\nextern AFUNPTR fptrgetwchar;\nextern AFUNPTR fptrgets;\nextern AFUNPTR fptrfgets;\nextern AFUNPTR fptrfgetwc;\nextern AFUNPTR fptrfread;\nextern AFUNPTR fptrfwrite;\nextern AFUNPTR fptropen;\nextern AFUNPTR fptrgetw;\nextern AFUNPTR fptrfgetc;\nextern AFUNPTR fptrfgetws;\nextern AFUNPTR fptrpipe;\nextern AFUNPTR fptrread;\nextern AFUNPTR fptrwrite;\nextern AFUNPTR fptrfopen;\nextern AFUNPTR fptrfdopen;\nextern AFUNPTR fptrclose;\nextern AFUNPTR fptrfclose;\nextern AFUNPTR fptrcallrpc;\nextern AFUNPTR fptrclnt_broadcast;\nextern AFUNPTR fptrclntudp_create;\nextern AFUNPTR fptrclntudp_bufcreate;\nextern AFUNPTR fptrpmap_getmaps;\nextern AFUNPTR fptrpmap_getport;\nextern AFUNPTR fptrpmap_rmtcall;\nextern AFUNPTR fptrpmap_set;\nextern AFUNPTR fptrclntraw_create;\nextern AFUNPTR fptrsvc_run;\nextern AFUNPTR fptrsvc_sendreply;\nextern AFUNPTR fptrsvcraw_create;\nextern AFUNPTR fptrsvctcp_create;\nextern AFUNPTR fptrsvcudp_bufcreate;\nextern AFUNPTR fptrsvcudp_create;\nextern AFUNPTR fptr_exit;\nextern AFUNPTR fptrsigprocmask;\nextern AFUNPTR fptrexit;\nextern AFUNPTR fptrpselect;\nextern AFUNPTR fptrioctl;\nextern AFUNPTR fptr__libc_dlopen_mode;\nextern AFUNPTR fptr__errno_location;\nextern AFUNPTR fptrsyscall;\n\n/* ===================================================================== */\n/* Replacement functions implemented in the other part of the tool       */\n/* ===================================================================== */\nextern \"C\"\n{\nvoid mysleep();\nvoid mysocket();\nvoid myshutdown();\nvoid myselect();\nvoid mypoll();\nvoid mypselect();\nvoid myaccept();\nvoid myconnect();\nvoid myrecv();\nvoid myrecvfrom();\nvoid mysend();\nvoid mysendto();\nvoid mygetwc();\nvoid mygetw();\nvoid my_IO_getc();\nvoid mygetchar();\nvoid mygetwchar();\nvoid mygets();\nvoid myfgetc();\nvoid myfgetwc();\nvoid myfgets();\nvoid myfgetws();\nvoid myfread();\nvoid myfwrite();\nvoid mypipe();\nvoid myread();\nvoid mywrite();\nvoid myopen();\nvoid myfopen();\nvoid myfdopen();\nvoid myclose();\nvoid myfclose();\nvoid mycallrpc();\nvoid myclnt_broadcast();\nvoid myclntudp_create();\nvoid myclntudp_bufcreate();\nvoid mypmap_getmaps();\nvoid mypmap_getport();\nvoid mypmap_rmtcall();\nvoid mypmap_set();\nvoid myclntraw_create();\nvoid mysvc_run();\nvoid mysvc_sendreply();\nvoid mysvcraw_create();\nvoid mysvctcp_create();\nvoid mysvcudp_bufcreate();\nvoid mysvcudp_create();\nvoid myabort();\nvoid my_exit();\nvoid my_nanosleep();\nvoid mysignal();\nvoid mysigprocmask();\nvoid mysigpending();\nvoid mysigaction();\nvoid mysetitimer();\nvoid myexit();\nvoid mydl_iterate_phdr();\nvoid mysystem();\nvoid myalarm();\nvoid myrecvmsg();\nvoid mysendmsg();\nvoid mypause();\nvoid mysigtimedwait();\nvoid mysigwaitinfo();\nvoid myepoll_wait();\nvoid myppoll();\nvoid mymsgsnd();\nvoid mymsgrcv();\nvoid mymsgrcv();\nvoid mysemtimedop();\nvoid myusleep();\nvoid myualarm();\nvoid mygetitimer();\nvoid mysigwait();\nvoid mymsgget();\nvoid mysemget();\nvoid mywait();\nvoid mywaitpid();\nvoid mywaitid();\nvoid mywait3();\nvoid mywait4();\nvoid myreadv();\nvoid mywritev();\nvoid myflockfile();\nvoid mylockf();\nvoid mysetenv();\nvoid myunsetenv();\nvoid mygetenv();\nvoid myperror();\nvoid mymmap();\nvoid mymunmap();\nvoid myfileno();\nvoid mygetpid();\nvoid mygetppid();\nvoid mymemset();\nvoid mymemcpy();\nvoid myaccess();\nvoid mylseek();\nvoid mylseek64();\nvoid myfdatasync();\nvoid myunlink();\nvoid mystrlen();\nvoid mywcslen();\nvoid mystrcpy();\nvoid mystrcpy();\nvoid mystrcat();\nvoid mystrstr();\nvoid mystrchr0();\nvoid mystrrchr();\nvoid mystrcmp();\nvoid mystrncmp();\nvoid mysigaddset();\nvoid mysigdelset();\nvoid mysigismember();\nvoid mystrerror();\nvoid mybind();\nvoid mylisten();\nvoid myuname();\nvoid mygethostname();\nvoid mykill();\nvoid mysched_yield();\nvoid mytimer_settime();\nvoid mysigaltstack();\nvoid myioctl();\nvoid myflock();\nvoid my__libc_dlopen_mode();\nvoid my__errno_location();\nvoid mysyscall();\nvoid myfunlockfile();\n}\n\n/* ===================================================================== */\n/* Utility functions                                                     */\n/* ===================================================================== */\n\n// Print help information\nINT32 Usage() {\n    cerr\n            << \"This tool mimics the behavior of TPSS on Linux by adding probes to various libc functions.\"\n            << endl;\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return 1;\n}\n\n// Utility function to return the time\nstring CurrentTime() {\n    char tmpbuf[128];\n    time_t thetime = time(NULL);\n    ctime_r(&thetime, tmpbuf);\n    return tmpbuf;\n}\n\nextern \"C\" void printFunctionCalled(const char* funcName)\n{\n    OutFile << CurrentTime() << funcName << \" called \" << endl;\n    OutFile.flush();\n}\n\nbool is_GLIBC2_24_or_newer(IMG img)\n{\n    char path[PATH_MAX] = {0};\n    if (0 <= readlink(IMG_Name(img).c_str(), path, sizeof(path)-1))\n    {\n        return (string(\"libc-2.24.so\") == basename(path));\n    }\n    return false;\n}\n\n/* ===================================================================== */\n/* Instrumnetation functions                                             */\n/* ===================================================================== */\n\n// Image load callback - inserts the probes.\nvoid ImgLoad(IMG img, VOID_PTR v) {\n    // Called every time a new image is loaded\n    if ((IMG_Name(img).find(\"libc.so\") != string::npos)\n            || (IMG_Name(img).find(\"LIBC.SO\") != string::npos)\n            || (IMG_Name(img).find(\"LIBC.so\") != string::npos))\n    {\n\n        RTN rtnsleep = RTN_FindByName(img, \"sleep\");\n        if (RTN_Valid(rtnsleep) && RTN_IsSafeForProbedReplacement(rtnsleep))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sleep at \"\n                    << RTN_Address(rtnsleep) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsleep, AFUNPTR(mysleep)));\n            fptrsleep = fptr;\n        }\n\n        RTN rtnsocket = RTN_FindByName(img, \"socket\");\n        if (RTN_Valid(rtnsocket) && RTN_IsSafeForProbedReplacement(rtnsocket))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for socket at \"\n                    << RTN_Address(rtnsocket) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsocket, AFUNPTR(mysocket)));\n            fptrsocket = fptr;\n        }\n\n        RTN rtnshutdown = RTN_FindByName(img, \"shutdown\");\n        if (RTN_Valid(rtnshutdown)\n                && RTN_IsSafeForProbedReplacement(rtnshutdown))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for shutdown at \" << RTN_Address(rtnshutdown) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnshutdown, AFUNPTR(myshutdown)));\n            fptrshutdown = fptr;\n        }\n\n        RTN rtnselect = RTN_FindByName(img, \"select\");\n        if (RTN_Valid(rtnselect) && RTN_IsSafeForProbedReplacement(rtnselect))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for select at \" << RTN_Address(rtnselect) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnselect, AFUNPTR(myselect)));\n            fptrselect = fptr;\n        }\n\n        RTN rtnpoll = RTN_FindByName(img, \"poll\");\n        if (RTN_Valid(rtnpoll) && RTN_IsSafeForProbedReplacement(rtnpoll))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for poll at \" << RTN_Address(rtnpoll) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpoll, AFUNPTR(mypoll)));\n            fptrpoll = fptr;\n        }\n\n        RTN rtnpselect = RTN_FindByName(img, \"pselect\");\n        if (RTN_Valid(rtnpselect)\n                && RTN_IsSafeForProbedReplacement(rtnpselect))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pselect at \"\n                    << RTN_Address(rtnpselect) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpselect, AFUNPTR(mypselect)));\n            fptrpselect = fptr;\n        }\n\n        RTN rtnaccept = RTN_FindByName(img, \"accept\");\n        if (RTN_Valid(rtnaccept) && RTN_IsSafeForProbedReplacement(rtnaccept))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for accept at \" << RTN_Address(rtnaccept) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnaccept, AFUNPTR(myaccept)));\n            fptraccept = fptr;\n        }\n\n        RTN rtnconnect = RTN_FindByName(img, \"connect\");\n        if (RTN_Valid(rtnconnect) && RTN_IsSafeForProbedReplacement(rtnconnect))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for connect at \" << RTN_Address(rtnconnect) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnconnect, AFUNPTR(myconnect)));\n            fptrconnect = fptr;\n        }\n\n        RTN rtnrecv = RTN_FindByName(img, \"recv\");\n        if (RTN_Valid(rtnrecv) && RTN_IsSafeForProbedReplacement(rtnrecv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for recv at \" << RTN_Address(rtnrecv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnrecv, AFUNPTR(myrecv)));\n            fptrrecv = fptr;\n        }\n\n        RTN rtnrecvfrom = RTN_FindByName(img, \"recvfrom\");\n        if (RTN_Valid(rtnrecvfrom) && RTN_IsSafeForProbedReplacement(rtnrecvfrom))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for recvfrom at \" << RTN_Address(rtnrecvfrom) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnrecvfrom, AFUNPTR(myrecvfrom)));\n            fptrrecvfrom = fptr;\n        }\n\n        RTN rtnsend = RTN_FindByName(img, \"send\");\n        if (RTN_Valid(rtnsend) && RTN_IsSafeForProbedReplacement(rtnsend))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for send at \" << RTN_Address(rtnsend) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsend, AFUNPTR(mysend)));\n            fptrsend = fptr;\n        }\n\n        RTN rtnsendto = RTN_FindByName(img, \"sendto\");\n        if (RTN_Valid(rtnsendto) && RTN_IsSafeForProbedReplacement(rtnsendto))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sendto at \" << RTN_Address(rtnsendto) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsendto, AFUNPTR(mysendto)));\n            fptrsendto = fptr;\n        }\n\n        RTN rtngetwc = RTN_FindByName(img, \"getwc\");\n        if (RTN_Valid(rtngetwc) && RTN_IsSafeForProbedReplacement(rtngetwc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getwc at \" << RTN_Address(rtngetwc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetwc, AFUNPTR(mygetwc)));\n            fptrgetwc = fptr;\n        }\n\n        RTN rtngetw = RTN_FindByName(img, \"getw\");\n        if (RTN_Valid(rtngetw) && RTN_IsSafeForProbedReplacement(rtngetw))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getw at \" << RTN_Address(rtngetw) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetw, AFUNPTR(mygetw)));\n            fptrgetw = fptr;\n        }\n\n        RTN rtn_IO_getc = RTN_FindByName(img, \"_IO_getc\");\n        if (RTN_Valid(rtn_IO_getc)\n                && RTN_IsSafeForProbedReplacement(rtn_IO_getc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for _IO_getc at \" << RTN_Address(rtn_IO_getc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn_IO_getc, AFUNPTR(my_IO_getc)));\n            fptr_IO_getc = fptr;\n        }\n\n        RTN rtngetchar = RTN_FindByName(img, \"getchar\");\n        if (RTN_Valid(rtngetchar) && RTN_IsSafeForProbedReplacement(rtngetchar))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getchar at \" << RTN_Address(rtngetchar) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetchar, AFUNPTR(mygetchar)));\n            fptrgetchar = fptr;\n        }\n\n        RTN rtngetwchar = RTN_FindByName(img, \"getwchar\");\n        if (RTN_Valid(rtngetwchar) && RTN_IsSafeForProbedReplacement(rtngetwchar))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getwchar at \"\n                    << RTN_Address(rtngetwchar) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetwchar, AFUNPTR(mygetwchar)));\n            fptrgetwchar = fptr;\n        }\n\n        RTN rtngets = RTN_FindByName(img, \"gets\");\n        if (RTN_Valid(rtngets) && RTN_IsSafeForProbedReplacement(rtngets))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for gets at \" << RTN_Address(rtngets) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngets, AFUNPTR(mygets)));\n            fptrgets = fptr;\n        }\n\n        RTN rtnfgetc = RTN_FindByName(img, \"fgetc\");\n        if (RTN_Valid(rtnfgetc) && RTN_IsSafeForProbedReplacement(rtnfgetc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgetc at \" << RTN_Address(rtnfgetc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgetc, AFUNPTR(myfgetc)));\n            fptrfgetc = fptr;\n        }\n\n        RTN rtnfgetwc = RTN_FindByName(img, \"fgetwc\");\n        if (RTN_Valid(rtnfgetwc) && RTN_IsSafeForProbedReplacement(rtnfgetwc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgetwc at \" << RTN_Address(rtnfgetwc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgetwc, AFUNPTR(myfgetwc)));\n            fptrfgetwc = fptr;\n        }\n\n        RTN rtnfgets = RTN_FindByName(img, \"fgets\");\n        if (RTN_Valid(rtnfgets) && RTN_IsSafeForProbedReplacement(rtnfgets))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgets at \" << RTN_Address(rtnfgets) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgets, AFUNPTR(myfgets)));\n            fptrfgets = fptr;\n        }\n\n        RTN rtnfgetws = RTN_FindByName(img, \"fgetws\");\n        if (RTN_Valid(rtnfgetws) && RTN_IsSafeForProbedReplacement(rtnfgetws))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgetws at \" << RTN_Address(rtnfgetws) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgetws, AFUNPTR(myfgetws)));\n            fptrfgetws = fptr;\n        }\n\n        RTN rtnfread = RTN_FindByName(img, \"fread\");\n        if (RTN_Valid(rtnfread) && RTN_IsSafeForProbedReplacement(rtnfread))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fread at \" << RTN_Address(rtnfread) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfread, AFUNPTR(myfread)));\n            fptrfread = fptr;\n        }\n\n        RTN rtnfwrite = RTN_FindByName(img, \"fwrite\");\n        if (RTN_Valid(rtnfwrite) && RTN_IsSafeForProbedReplacement(rtnfwrite))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fwrite at \" << RTN_Address(rtnfwrite) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfwrite, AFUNPTR(myfwrite)));\n            fptrfwrite = fptr;\n        }\n\n        RTN rtnpipe = RTN_FindByName(img, \"pipe\");\n        if (RTN_Valid(rtnpipe) && RTN_IsSafeForProbedReplacement(rtnpipe))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pipe at \" << RTN_Address(rtnpipe) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpipe, AFUNPTR(mypipe)));\n            fptrpipe = fptr;\n        }\n\n        RTN rtnread = RTN_FindByName(img, \"read\");\n        if (RTN_Valid(rtnread) && RTN_IsSafeForProbedReplacement(rtnread))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for read at \" << RTN_Address(rtnread) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnread, AFUNPTR(myread)));\n            fptrread = fptr;\n        }\n\n        RTN rtnwrite = RTN_FindByName(img, \"write\");\n        if (RTN_Valid(rtnwrite) && RTN_IsSafeForProbedReplacement(rtnwrite))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for write at \" << RTN_Address(rtnwrite) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwrite, AFUNPTR(mywrite)));\n            fptrwrite = fptr;\n        }\n\n        RTN rtnopen = RTN_FindByName(img, \"open\");\n        if (RTN_Valid(rtnopen) && RTN_IsSafeForProbedReplacement(rtnopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for open at \" << RTN_Address(rtnopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnopen, AFUNPTR(myopen)));\n            fptropen = fptr;\n        }\n\n        RTN rtnfopen = RTN_FindByName(img, \"fopen\");\n        if (RTN_Valid(rtnfopen) && RTN_IsSafeForProbedReplacement(rtnfopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fopen at \" << RTN_Address(rtnfopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfopen, AFUNPTR(myfopen)));\n            fptrfopen = fptr;\n        }\n\n        RTN rtnfdopen = RTN_FindByName(img, \"fdopen\");\n        if (RTN_Valid(rtnfdopen) && RTN_IsSafeForProbedReplacement(rtnfdopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fdopen at \" << RTN_Address(rtnfdopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfdopen, AFUNPTR(myfdopen)));\n            fptrfdopen = fptr;\n        }\n\n        RTN rtnclose = RTN_FindByName(img, \"close\");\n        if (RTN_Valid(rtnclose) && RTN_IsSafeForProbedReplacement(rtnclose))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for close at \" << RTN_Address(rtnclose) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclose, AFUNPTR(myclose)));\n            fptrclose = fptr;\n        }\n\n        RTN rtnfclose = RTN_FindByName(img, \"fclose\");\n        if (RTN_Valid(rtnfclose) && RTN_IsSafeForProbedReplacement(rtnfclose))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fclose at \" << RTN_Address(rtnfclose) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfclose, AFUNPTR(myfclose)));\n            fptrfclose = fptr;\n        }\n\n        RTN rtncallrpc = RTN_FindByName(img, \"callrpc\");\n        if (RTN_Valid(rtncallrpc)&& RTN_IsSafeForProbedReplacement(rtncallrpc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for callrpc at \" << RTN_Address(rtncallrpc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtncallrpc, AFUNPTR(mycallrpc)));\n            fptrcallrpc = fptr;\n        }\n\n        RTN rtnclnt_broadcast = RTN_FindByName(img, \"clnt_broadcast\");\n        if (RTN_Valid(rtnclnt_broadcast)\n                && RTN_IsSafeForProbedReplacement(rtnclnt_broadcast))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for clnt_broadcast at \" << RTN_Address(rtnclnt_broadcast) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclnt_broadcast, AFUNPTR(myclnt_broadcast)));\n            fptrclnt_broadcast = fptr;\n        }\n\n        RTN rtnclntudp_create = RTN_FindByName(img, \"clntudp_create\");\n        if (RTN_Valid(rtnclntudp_create)\n                && RTN_IsSafeForProbedReplacement(rtnclntudp_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for clntudp_create at \" << RTN_Address(rtnclntudp_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclntudp_create, AFUNPTR(myclntudp_create)));\n            fptrclntudp_create = fptr;\n        }\n\n        RTN rtnclntudp_bufcreate = RTN_FindByName(img, \"clntudp_bufcreate\");\n        if (RTN_Valid(rtnclntudp_bufcreate) && RTN_IsSafeForProbedReplacement(rtnclntudp_bufcreate))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for clntudp_bufcreate at \" << RTN_Address(rtnclntudp_bufcreate) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclntudp_bufcreate, AFUNPTR(myclntudp_bufcreate)));\n            fptrclntudp_bufcreate = fptr;\n        }\n\n        RTN rtnpmap_getmaps = RTN_FindByName(img, \"pmap_getmaps\");\n        if (RTN_Valid(rtnpmap_getmaps) && RTN_IsSafeForProbedReplacement(rtnpmap_getmaps))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_getmaps at \" << RTN_Address(rtnpmap_getmaps) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_getmaps, AFUNPTR(mypmap_getmaps)));\n            fptrpmap_getmaps = fptr;\n        }\n\n        RTN rtnpmap_getport = RTN_FindByName(img, \"pmap_getport\");\n        if (RTN_Valid(rtnpmap_getport) && RTN_IsSafeForProbedReplacement(rtnpmap_getport))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_getport at \" << RTN_Address(rtnpmap_getport) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_getport, AFUNPTR(mypmap_getport)));\n            fptrpmap_getport = fptr;\n        }\n\n        RTN rtnpmap_rmtcall = RTN_FindByName(img, \"pmap_rmtcall\");\n        if (RTN_Valid(rtnpmap_rmtcall) && RTN_IsSafeForProbedReplacement(rtnpmap_rmtcall))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_rmtcall at \" << RTN_Address(rtnpmap_rmtcall) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_rmtcall, AFUNPTR(mypmap_rmtcall)));\n            fptrpmap_rmtcall = fptr;\n        }\n\n        RTN rtnpmap_set = RTN_FindByName(img, \"pmap_set\");\n        if (RTN_Valid(rtnpmap_set) && RTN_IsSafeForProbedReplacement(rtnpmap_set))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_set at \" << RTN_Address(rtnpmap_set) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_set, AFUNPTR(mypmap_set)));\n            fptrpmap_set = fptr;\n        }\n\n        RTN rtnclntraw_create = RTN_FindByName(img, \"clntraw_create\");\n        if (RTN_Valid(rtnclntraw_create)\n                && RTN_IsSafeForProbedReplacement(rtnclntraw_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for clntraw_create at \" << RTN_Address(rtnclntraw_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclntraw_create, AFUNPTR(myclntraw_create)));\n            fptrclntraw_create = fptr;\n        }\n\n        RTN rtnsvc_run = RTN_FindByName(img, \"svc_run\");\n        if (RTN_Valid(rtnsvc_run) && RTN_IsSafeForProbedReplacement(rtnsvc_run))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svc_run at \"\n                    << RTN_Address(rtnsvc_run) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvc_run, AFUNPTR(mysvc_run)));\n            fptrsvc_run = fptr;\n        }\n\n        RTN rtnsvc_sendreply = RTN_FindByName(img, \"svc_sendreply\");\n        if (RTN_Valid(rtnsvc_sendreply) && RTN_IsSafeForProbedReplacement(rtnsvc_sendreply))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svc_sendreply at \" << RTN_Address(rtnsvc_sendreply) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvc_sendreply, AFUNPTR(mysvc_sendreply)));\n            fptrsvc_sendreply = fptr;\n        }\n\n        RTN rtnsvcraw_create = RTN_FindByName(img, \"svcraw_create\");\n        if (RTN_Valid(rtnsvcraw_create) && RTN_IsSafeForProbedReplacement(rtnsvcraw_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svcraw_create at \" << RTN_Address(rtnsvcraw_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvcraw_create, AFUNPTR(mysvcraw_create)));\n            fptrsvcraw_create = fptr;\n        }\n\n        RTN rtnsvctcp_create = RTN_FindByName(img, \"svctcp_create\");\n        if (RTN_Valid(rtnsvctcp_create) && RTN_IsSafeForProbedReplacement(rtnsvctcp_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svctcp_create at \" << RTN_Address(rtnsvctcp_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvctcp_create, AFUNPTR(mysvctcp_create)));\n            fptrsvctcp_create = fptr;\n        }\n\n        RTN rtnsvcudp_bufcreate = RTN_FindByName(img, \"svcudp_bufcreate\");\n        if (RTN_Valid(rtnsvcudp_bufcreate) && RTN_IsSafeForProbedReplacement(rtnsvcudp_bufcreate))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svcudp_bufcreate at \" << RTN_Address(rtnsvcudp_bufcreate) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvcudp_bufcreate, AFUNPTR(mysvcudp_bufcreate)));\n            fptrsvcudp_bufcreate = fptr;\n        }\n\n        RTN rtnsvcudp_create = RTN_FindByName(img, \"svcudp_create\");\n        if (RTN_Valid(rtnsvcudp_create) && RTN_IsSafeForProbedReplacement(rtnsvcudp_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svcudp_create at \" << RTN_Address(rtnsvcudp_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvcudp_create, AFUNPTR(mysvcudp_create)));\n            fptrsvcudp_create = fptr;\n        }\n\n        RTN rtnabort = RTN_FindByName(img, \"abort\");\n        if (RTN_Valid(rtnabort) && RTN_IsSafeForProbedReplacement(rtnabort))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for abort at \" << RTN_Address(rtnabort) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnabort, AFUNPTR(myabort)));\n            fptrabort = fptr;\n        }\n\n        RTN rtn_exit = RTN_FindByName(img, \"_exit\");\n        if (RTN_Valid(rtn_exit) && RTN_IsSafeForProbedReplacement(rtn_exit))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for _exit at \" << RTN_Address(rtn_exit) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn_exit, AFUNPTR(my_exit)));\n            fptr_exit = fptr;\n        }\n\n        RTN rtnnanosleep = RTN_FindByName(img, \"nanosleep\");\n        if (RTN_Valid(rtnnanosleep) && RTN_IsSafeForProbedReplacement(rtnnanosleep))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for nanosleep at \" << RTN_Address(rtnnanosleep) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnnanosleep, AFUNPTR(my_nanosleep)));\n            fptrnanosleep = fptr;\n        }\n\n        RTN rtnsignal = RTN_FindByName(img, \"signal\");\n        if (RTN_Valid(rtnsignal) && RTN_IsSafeForProbedReplacement(rtnsignal))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for signal at \" << RTN_Address(rtnsignal) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsignal, AFUNPTR(mysignal)));\n            fptrsignal = fptr;\n        }\n\n        RTN rtnsigprocmask = RTN_FindByName(img, \"sigprocmask\");\n        if (RTN_Valid(rtnsigprocmask) && RTN_IsSafeForProbedReplacement(rtnsigprocmask))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigprocmask at \" << RTN_Address(rtnsigprocmask) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigprocmask, AFUNPTR(mysigprocmask)));\n            fptrsigprocmask = fptr;\n        }\n\n        RTN rtnsigpending = RTN_FindByName(img, \"sigpending\");\n        if (RTN_Valid(rtnsigpending) && RTN_IsSafeForProbedReplacement(rtnsigpending))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigpending at \" << RTN_Address(rtnsigpending) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigpending, AFUNPTR(mysigpending)));\n            fptrsigpending = fptr;\n        }\n\n        RTN rtnsigaction = RTN_FindByName(img, \"sigaction\");\n        if (RTN_Valid(rtnsigaction) && RTN_IsSafeForProbedReplacement(rtnsigaction))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigaction at \" << RTN_Address(rtnsigaction) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigaction, AFUNPTR(mysigaction)));\n            fptrsigaction = fptr;\n        }\n\n        RTN rtnsetitimer = RTN_FindByName(img, \"setitimer\");\n        if (RTN_Valid(rtnsetitimer) && RTN_IsSafeForProbedReplacement(rtnsetitimer))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for setitimer at \" << RTN_Address(rtnsetitimer) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsetitimer, AFUNPTR(mysetitimer)));\n            fptrsetitimer = fptr;\n        }\n\n        RTN rtnexit = RTN_FindByName(img, \"exit\");\n        if (RTN_Valid(rtnexit) && RTN_IsSafeForProbedReplacement(rtnexit))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for exit at \" << RTN_Address(rtnexit) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnexit, AFUNPTR(myexit)));\n            fptrexit = fptr;\n        }\n\n        RTN rtndl_iterate_phdr = RTN_FindByName(img, \"dl_iterate_phdr\");\n        if (RTN_Valid(rtnexit) && RTN_IsSafeForProbedReplacement(rtndl_iterate_phdr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dl_iterate_phdr at \" << RTN_Address(rtndl_iterate_phdr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndl_iterate_phdr, AFUNPTR(mydl_iterate_phdr)));\n            fptrdl_iterate_phdr = fptr;\n        }\n\n        RTN rtnsystem = RTN_FindByName(img, \"system\");\n        if (RTN_Valid(rtnsystem) && RTN_IsSafeForProbedReplacement(rtnsystem))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for system at \"\n                    << RTN_Address(rtnsystem) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsystem, AFUNPTR(mysystem)));\n            fptrsystem = fptr;\n        }\n\n        RTN rtnalarm = RTN_FindByName(img, \"alarm\");\n        if (RTN_Valid(rtnalarm) && RTN_IsSafeForProbedReplacement(rtnalarm))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for alarm at \"\n                    << RTN_Address(rtnalarm) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnalarm, AFUNPTR(myalarm)));\n            fptralarm = fptr;\n        }\n\n        RTN rtnrecvmsg = RTN_FindByName(img, \"recvmsg\");\n        if (RTN_Valid(rtnrecvmsg) && RTN_IsSafeForProbedReplacement(rtnrecvmsg))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for recvmsg at \" << RTN_Address(rtnrecvmsg) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnrecvmsg, AFUNPTR(myrecvmsg)));\n            fptrrecvmsg = fptr;\n        }\n\n        RTN rtnsendmsg = RTN_FindByName(img, \"sendmsg\");\n        if (RTN_Valid(rtnsendmsg) && RTN_IsSafeForProbedReplacement(rtnsendmsg))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sendmsg at \"\n                    << RTN_Address(rtnsendmsg) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsendmsg, AFUNPTR(mysendmsg)));\n            fptrsendmsg = fptr;\n        }\n\n        RTN rtnpause = RTN_FindByName(img, \"pause\");\n        if (RTN_Valid(rtnpause) && RTN_IsSafeForProbedReplacement(rtnpause))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pause at \"\n                    << RTN_Address(rtnpause) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpause, AFUNPTR(mypause)));\n            fptrpause = fptr;\n        }\n\n        RTN rtnsigtimedwait = RTN_FindByName(img, \"sigtimedwait\");\n        if (RTN_Valid(rtnsigtimedwait) && RTN_IsSafeForProbedReplacement(rtnsigtimedwait))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigtimedwait at \" << RTN_Address(rtnsigtimedwait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigtimedwait, AFUNPTR(mysigtimedwait)));\n            fptrsigtimedwait = fptr;\n        }\n\n        RTN rtnsigwaitinfo = RTN_FindByName(img, \"sigwaitinfo\");\n        if (RTN_Valid(rtnsigwaitinfo) && RTN_IsSafeForProbedReplacement(rtnsigwaitinfo))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigwaitinfo at \" << RTN_Address(rtnsigwaitinfo) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigwaitinfo, AFUNPTR(mysigwaitinfo)));\n            fptrsigwaitinfo = fptr;\n        }\n\n        RTN rtnepoll_wait = RTN_FindByName(img, \"epoll_wait\");\n        if (RTN_Valid(rtnepoll_wait) && RTN_IsSafeForProbedReplacement(rtnepoll_wait))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for epoll_wait at \" << RTN_Address(rtnepoll_wait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnepoll_wait, AFUNPTR(myepoll_wait)));\n            fptrepoll_wait = fptr;\n        }\n\n        RTN rtnppoll = RTN_FindByName(img, \"ppoll\");\n        if (RTN_Valid(rtnppoll) && RTN_IsSafeForProbedReplacement(rtnppoll))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for ppoll at \" << RTN_Address(rtnppoll) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnppoll, AFUNPTR(myppoll)));\n            fptrppoll = fptr;\n        }\n\n        RTN rtnmsgsnd = RTN_FindByName(img, \"msgsnd\");\n        if (RTN_Valid(rtnmsgsnd) && RTN_IsSafeForProbedReplacement(rtnmsgsnd))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for msgsnd at \" << RTN_Address(rtnmsgsnd) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmsgsnd, AFUNPTR(mymsgsnd)));\n            fptrmsgsnd = fptr;\n        }\n\n        RTN rtnmsgrcv = RTN_FindByName(img, \"msgrcv\");\n        if (RTN_Valid(rtnmsgrcv) && RTN_IsSafeForProbedReplacement(rtnmsgrcv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for msgrcv at \" << RTN_Address(rtnmsgrcv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmsgrcv, AFUNPTR(mymsgrcv)));\n            fptrmsgrcv = fptr;\n        }\n\n        RTN rtnsemop = RTN_FindByName(img, \"semop\");\n        if (RTN_Valid(rtnsemop) && RTN_IsSafeForProbedReplacement(rtnsemop))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for semop at \" << RTN_Address(rtnsemop) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsemop, AFUNPTR(mymsgrcv)));\n            fptrsemop = fptr;\n        }\n\n        RTN rtnsemtimedop = RTN_FindByName(img, \"semtimedop\");\n        if (RTN_Valid(rtnsemtimedop)\n                && RTN_IsSafeForProbedReplacement(rtnsemtimedop)) {\n            OutFile << CurrentTime() << \"Inserting probe for semtimedop at \"\n                    << RTN_Address(rtnsemtimedop) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = RTN_ReplaceProbed(rtnsemtimedop, AFUNPTR(mysemtimedop));\n            fptrsemtimedop = fptr;\n        }\n\n        RTN rtnusleep = RTN_FindByName(img, \"usleep\");\n        if (RTN_Valid(rtnusleep) && RTN_IsSafeForProbedReplacement(rtnusleep)) {\n            OutFile << CurrentTime() << \"Inserting probe for usleep at \"\n                    << RTN_Address(rtnusleep) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnusleep, AFUNPTR(myusleep)));\n            fptrusleep = fptr;}\n\n        RTN rtnualarm = RTN_FindByName(img, \"ualarm\");\n        if (RTN_Valid(rtnualarm) && RTN_IsSafeForProbedReplacement(rtnualarm)) {\n            OutFile << CurrentTime() << \"Inserting probe for ualarm at \"\n                    << RTN_Address(rtnualarm) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnualarm, AFUNPTR(myualarm)));\n            fptrualarm = fptr;}\n\n        RTN rtngetitimer = RTN_FindByName(img, \"getitimer\");\n        if (RTN_Valid(rtngetitimer) && RTN_IsSafeForProbedReplacement(rtngetitimer))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getitimer at \" << RTN_Address(rtngetitimer) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetitimer, AFUNPTR(mygetitimer)));\n            fptrgetitimer = fptr;}\n\n        RTN rtnsigwait = RTN_FindByName(img, \"sigwait\");\n        if (RTN_Valid(rtnsigwait) && RTN_IsSafeForProbedReplacement(rtnsigwait))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigwait at \" << RTN_Address(rtnsigwait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigwait, AFUNPTR(mysigwait)));\n            fptrsigwait = fptr;\n        }\n\n        RTN rtnmsgget = RTN_FindByName(img, \"msgget\");\n        if (RTN_Valid(rtnmsgget) && RTN_IsSafeForProbedReplacement(rtnmsgget))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for msgget at \" << RTN_Address(rtnmsgget) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmsgget, AFUNPTR(mymsgget)));\n            fptrmsgget = fptr;\n        }\n\n        RTN rtnsemget = RTN_FindByName(img, \"semget\");\n        if (RTN_Valid(rtnsemget) && RTN_IsSafeForProbedReplacement(rtnsemget))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for semget at \" << RTN_Address(rtnsemget) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsemget, AFUNPTR(mysemget)));\n            fptrsemget = fptr;\n        }\n\n        RTN rtnwait = RTN_FindByName(img, \"wait\");\n        if (RTN_Valid(rtnwait) && RTN_IsSafeForProbedReplacement(rtnwait))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for wait at \" << RTN_Address(rtnwait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwait, AFUNPTR(mywait)));\n            fptrwait = fptr;\n        }\n\n        RTN rtnwaitpid = RTN_FindByName(img, \"waitpid\");\n        if (RTN_Valid(rtnwaitpid) && RTN_IsSafeForProbedReplacement(rtnwaitpid))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for waitpid at \" << RTN_Address(rtnwaitpid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwaitpid, AFUNPTR(mywaitpid)));\n            fptrwaitpid = fptr;\n        }\n\n        RTN rtnwaitid = RTN_FindByName(img, \"waitid\");\n        if (RTN_Valid(rtnwaitid) && RTN_IsSafeForProbedReplacement(rtnwaitid))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for waitid at \" << RTN_Address(rtnwaitid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwaitid, AFUNPTR(mywaitid)));\n            fptrwaitid = fptr;\n        }\n\n        RTN rtnwait3 = RTN_FindByName(img, \"wait3\");\n        if (RTN_Valid(rtnwait3) && RTN_IsSafeForProbedReplacement(rtnwait3))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for wait3 at \" << RTN_Address(rtnwait3) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwait3, AFUNPTR(mywait3)));\n            fptrwait3 = fptr;\n        }\n\n        RTN rtnwait4 = RTN_FindByName(img, \"wait4\");\n        if (RTN_Valid(rtnwait3) && RTN_IsSafeForProbedReplacement(rtnwait4))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for wait4 at \" << RTN_Address(rtnwait4) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwait3, AFUNPTR(mywait4)));\n            fptrwait4 = fptr;\n        }\n\n        RTN rtnreadv = RTN_FindByName(img, \"readv\");\n        if (RTN_Valid(rtnreadv) && RTN_IsSafeForProbedReplacement(rtnreadv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for readv at \" << RTN_Address(rtnreadv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnreadv, AFUNPTR(myreadv)));\n            fptrreadv = fptr;\n        }\n\n        RTN rtnwritev = RTN_FindByName(img, \"writev\");\n        if (RTN_Valid(rtnwritev) && RTN_IsSafeForProbedReplacement(rtnwritev))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for writev at \" << RTN_Address(rtnwritev) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwritev, AFUNPTR(mywritev)));\n            fptrwritev = fptr;\n        }\n\n        RTN rtnflockfile = RTN_FindByName(img, \"flockfile\");\n        if (RTN_Valid(rtnflockfile) && RTN_IsSafeForProbedReplacement(rtnflockfile))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for flockfile at \" << RTN_Address(rtnflockfile) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnflockfile, AFUNPTR(myflockfile)));\n            fptrflockfile = fptr;\n        }\n        RTN rtnfunlockfile = RTN_FindByName(img, \"funlockfile\");\n        if (RTN_Valid(rtnfunlockfile)\n                && RTN_IsSafeForProbedReplacement(rtnfunlockfile)) {\n            OutFile << CurrentTime() << \"Inserting probe for funlockfile at \"\n                    << RTN_Address(rtnfunlockfile) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfunlockfile,\n                    AFUNPTR(myfunlockfile)));\n            fptrfunlockfile = fptr;}\n\n        RTN rtnlockf = RTN_FindByName(img, \"lockf\");\n        if (RTN_Valid(rtnlockf) && RTN_IsSafeForProbedReplacement(rtnlockf))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for lockf at \" << RTN_Address(rtnlockf) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlockf, AFUNPTR(mylockf)));\n            fptrlockf = fptr;\n        }\n\n        RTN rtnsetenv = RTN_FindByName(img, \"setenv\");\n        if (RTN_Valid(rtnsetenv) && RTN_IsSafeForProbedReplacement(rtnsetenv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for setenv at \" << RTN_Address(rtnsetenv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsetenv, AFUNPTR(mysetenv)));\n            fptrsetenv = fptr;\n        }\n\n        RTN rtnunsetenv = RTN_FindByName(img, \"unsetenv\");\n        if (RTN_Valid(rtnunsetenv) && RTN_IsSafeForProbedReplacement(rtnunsetenv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for unsetenv at \" << RTN_Address(rtnunsetenv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnunsetenv, AFUNPTR(myunsetenv)));\n            fptrunsetenv = fptr;\n        }\n\n        RTN rtngetenv = RTN_FindByName(img, \"getenv\");\n        if (RTN_Valid(rtngetenv) && RTN_IsSafeForProbedReplacement(rtngetenv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getenv at \"\n                    << RTN_Address(rtngetenv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetenv, AFUNPTR(mygetenv)));\n            fptrgetenv = fptr;\n        }\n\n        RTN rtnperror = RTN_FindByName(img, \"perror\");\n        if (RTN_Valid(rtnperror) && RTN_IsSafeForProbedReplacement(rtnperror))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for perror at \"\n                    << RTN_Address(rtnperror) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnperror, AFUNPTR(myperror)));\n            fptrperror = fptr;\n        }\n\n        RTN rtnmmap = RTN_FindByName(img, \"mmap\");\n        if (RTN_Valid(rtnmmap) && RTN_IsSafeForProbedReplacement(rtnmmap))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for mmap at \"\n                    << RTN_Address(rtnmmap) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmmap, AFUNPTR(mymmap)));\n            fptrmmap = fptr;\n        }\n\n        RTN rtnmunmap = RTN_FindByName(img, \"munmap\");\n        if (RTN_Valid(rtnmunmap) && RTN_IsSafeForProbedReplacement(rtnmunmap))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for munmap at \"\n                    << RTN_Address(rtnmunmap) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmunmap, AFUNPTR(mymunmap)));\n            fptrmunmap = fptr;\n        }\n\n        RTN rtnfileno = RTN_FindByName(img, \"fileno\");\n        if (RTN_Valid(rtnfileno) && RTN_IsSafeForProbedReplacement(rtnfileno))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fileno at \"\n                    << RTN_Address(rtnfileno) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfileno, AFUNPTR(myfileno)));\n            fptrfileno = fptr;\n        }\n\n        RTN rtngetpid = RTN_FindByName(img, \"getpid\");\n        if (RTN_Valid(rtngetpid) && RTN_IsSafeForProbedReplacement(rtngetpid))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getpid at \"\n                    << RTN_Address(rtngetpid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetpid, AFUNPTR(mygetpid)));\n            fptrgetpid = fptr;\n        }\n\n        RTN rtngetppid = RTN_FindByName(img, \"getppid\");\n        if (RTN_Valid(rtngetppid) && RTN_IsSafeForProbedReplacement(rtngetppid))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getppid at \" << RTN_Address(rtngetppid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetppid, AFUNPTR(mygetppid)));\n            fptrgetppid = fptr;\n        }\n\n        RTN rtnmemset = RTN_FindByName(img, \"memset\");\n        if (RTN_Valid(rtnmemset) && RTN_IsSafeForProbedReplacement(rtnmemset))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for memset at \" << RTN_Address(rtnmemset) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmemset, AFUNPTR(mymemset)));\n            fptrmemset = fptr;\n        }\n\n        RTN rtnmemcpy = RTN_FindByName(img, \"memcpy\");\n        if (RTN_Valid(rtnmemcpy) && RTN_IsSafeForProbedReplacement(rtnmemcpy))\n        {\n            if (!is_GLIBC2_24_or_newer(img))\n            {\n                OutFile << CurrentTime() << \"Inserting probe for memcpy at \" << RTN_Address(rtnmemcpy) << endl;\n                OutFile.flush();\n                AFUNPTR fptr = (RTN_ReplaceProbed(rtnmemcpy, AFUNPTR(mymemcpy)));\n                fptrmemcpy = fptr;\n            }\n        }\n\n        RTN rtnaccess = RTN_FindByName(img, \"access\");\n        if (RTN_Valid(rtnaccess) && RTN_IsSafeForProbedReplacement(rtnaccess))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for access at \" << RTN_Address(rtnaccess) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnaccess, AFUNPTR(myaccess)));\n            fptraccess = fptr;\n        }\n\n        RTN rtnlseek = RTN_FindByName(img, \"lseek\");\n        if (RTN_Valid(rtnlseek) && RTN_IsSafeForProbedReplacement(rtnlseek))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for lseek at \" << RTN_Address(rtnlseek) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlseek, AFUNPTR(mylseek)));\n            fptrlseek = fptr;\n        }\n\n        RTN rtnlseek64 = RTN_FindByName(img, \"lseek64\");\n        if (RTN_Valid(rtnlseek64) && RTN_IsSafeForProbedReplacement(rtnlseek64))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for lseek64 at \" << RTN_Address(rtnlseek64) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlseek64, AFUNPTR(mylseek64)));\n            fptrlseek64 = fptr;\n        }\n\n        RTN rtnfdatasync = RTN_FindByName(img, \"fdatasync\");\n        if (RTN_Valid(rtnfdatasync) && RTN_IsSafeForProbedReplacement(rtnfdatasync))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fdatasync at \" << RTN_Address(rtnfdatasync) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfdatasync, AFUNPTR(myfdatasync)));\n            fptrfdatasync = fptr;\n        }\n\n        RTN rtnunlink = RTN_FindByName(img, \"unlink\");\n        if (RTN_Valid(rtnunlink) && RTN_IsSafeForProbedReplacement(rtnunlink))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for unlink at \" << RTN_Address(rtnunlink) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnunlink, AFUNPTR(myunlink)));\n            fptrunlink = fptr;\n        }\n\n        RTN rtnstrlen = RTN_FindByName(img, \"strlen\");\n        if (RTN_Valid(rtnstrlen) && RTN_IsSafeForProbedReplacement(rtnstrlen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strlen at \" << RTN_Address(rtnstrlen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrlen, AFUNPTR(mystrlen)));\n            fptrstrlen = fptr;\n        }\n\n        RTN rtnwcslen = RTN_FindByName(img, \"wcslen\");\n        if (RTN_Valid(rtnwcslen) && RTN_IsSafeForProbedReplacement(rtnwcslen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for wcslen at \"<< RTN_Address(rtnwcslen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwcslen, AFUNPTR(mywcslen)));\n            fptrwcslen = fptr;\n        }\n\n        RTN rtnstrcpy = RTN_FindByName(img, \"strcpy\");\n        if (RTN_Valid(rtnstrcpy) && RTN_IsSafeForProbedReplacement(rtnstrcpy))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strcpy at \" << RTN_Address(rtnstrcpy) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrcpy, AFUNPTR(mystrcpy)));\n            fptrstrcpy = fptr;\n        }\n\n        RTN rtnstrncpy = RTN_FindByName(img, \"strncpy\");\n        if (RTN_Valid(rtnstrncpy) && RTN_IsSafeForProbedReplacement(rtnstrncpy))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strncpy at \" << RTN_Address(rtnstrncpy) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrncpy, AFUNPTR(mystrcpy)));\n            fptrstrncpy = fptr;\n        }\n\n        RTN rtnstrcat = RTN_FindByName(img, \"strcat\");\n        if (RTN_Valid(rtnstrcat) && RTN_IsSafeForProbedReplacement(rtnstrcat))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strcat at \" << RTN_Address(rtnstrcat) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrcat, AFUNPTR(mystrcat)));\n            fptrstrcat = fptr;\n        }\n\n        RTN rtnstrstr = RTN_FindByName(img, \"strstr\");\n        if (RTN_Valid(rtnstrstr) && RTN_IsSafeForProbedReplacement(rtnstrstr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strstr at \" << RTN_Address(rtnstrstr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrstr, AFUNPTR(mystrstr)));\n            fptrstrstr = fptr;\n        }\n\n        RTN rtnstrchr0 = RTN_FindByName(img, \"strchr0\");\n        if (RTN_Valid(rtnstrchr0) && RTN_IsSafeForProbedReplacement(rtnstrchr0))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strchr0 at \" << RTN_Address(rtnstrchr0) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrchr0, AFUNPTR(mystrchr0)));\n            fptrstrrchr = fptr;\n        }\n\n        RTN rtnstrrchr = RTN_FindByName(img, \"strrchr\");\n        if (RTN_Valid(rtnstrrchr) && RTN_IsSafeForProbedReplacement(rtnstrrchr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strrchr at \"\n                    << RTN_Address(rtnstrrchr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrrchr, AFUNPTR(mystrrchr)));\n            fptrstrrchr = fptr;\n        }\n\n        RTN rtnstrcmp = RTN_FindByName(img, \"strcmp\");\n        if (RTN_Valid(rtnstrcmp) && RTN_IsSafeForProbedReplacement(rtnstrcmp))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strcmp at \" << RTN_Address(rtnstrcmp) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrcmp, AFUNPTR(mystrcmp)));\n            fptrstrcmp = fptr;\n        }\n\n        RTN rtnstrncmp = RTN_FindByName(img, \"strncmp\");\n        if (RTN_Valid(rtnstrncmp) && RTN_IsSafeForProbedReplacement(rtnstrncmp))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strncmp at \" << RTN_Address(rtnstrncmp) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrncmp, AFUNPTR(mystrncmp)));\n            fptrstrncmp = fptr;\n        }\n\n        RTN rtnsigaddset = RTN_FindByName(img, \"sigaddset\");\n        if (RTN_Valid(rtnsigaddset) && RTN_IsSafeForProbedReplacement(rtnsigaddset))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigaddset at \" << RTN_Address(rtnsigaddset) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigaddset, AFUNPTR(mysigaddset)));\n            fptrsigaddset = fptr;\n        }\n\n        RTN rtnsigdelset = RTN_FindByName(img, \"sigdelset\");\n        if (RTN_Valid(rtnsigdelset) && RTN_IsSafeForProbedReplacement(rtnsigdelset))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigdelset at \"<< RTN_Address(rtnsigdelset) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigdelset, AFUNPTR(mysigdelset)));\n            fptrsigdelset = fptr;\n        }\n\n        RTN rtnsigismember = RTN_FindByName(img, \"sigismember\");\n        if (RTN_Valid(rtnsigismember) && RTN_IsSafeForProbedReplacement(rtnsigismember))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigismember at \" << RTN_Address(rtnsigismember) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigismember, AFUNPTR(mysigismember)));\n            fptrsigdelset = fptr;\n        }\n\n        RTN rtnstrerror = RTN_FindByName(img, \"strerror\");\n        if (RTN_Valid(rtnstrerror) && RTN_IsSafeForProbedReplacement(rtnstrerror))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strerror at \" << RTN_Address(rtnstrerror) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrerror, AFUNPTR(mystrerror)));\n            fptrstrerror = fptr;\n        }\n\n        RTN rtnbind = RTN_FindByName(img, \"bind\");\n        if (RTN_Valid(rtnbind) && RTN_IsSafeForProbedReplacement(rtnbind))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for bind at \" << RTN_Address(rtnbind) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnbind, AFUNPTR(mybind)));\n            fptrbind = fptr;\n        }\n\n        RTN rtnlisten = RTN_FindByName(img, \"listen\");\n        if (RTN_Valid(rtnlisten) && RTN_IsSafeForProbedReplacement(rtnlisten))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for listen at \" << RTN_Address(rtnlisten) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlisten, AFUNPTR(mylisten)));\n            fptrlisten = fptr;\n        }\n\n        RTN rtnuname = RTN_FindByName(img, \"uname\");\n        if (RTN_Valid(rtnuname) && RTN_IsSafeForProbedReplacement(rtnuname))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for uname at \"    << RTN_Address(rtnuname) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnuname, AFUNPTR(myuname)));\n            fptruname = fptr;\n        }\n\n        RTN rtngethostname = RTN_FindByName(img, \"gethostname\");\n        if (RTN_Valid(rtngethostname) && RTN_IsSafeForProbedReplacement(rtngethostname))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for gethostname at \" << RTN_Address(rtngethostname) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngethostname, AFUNPTR(mygethostname)));\n            fptrgethostname = fptr;\n        }\n\n        RTN rtnkill = RTN_FindByName(img, \"kill\");\n        if (RTN_Valid(rtnkill) && RTN_IsSafeForProbedReplacement(rtnkill))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for kill at \" << RTN_Address(rtnkill) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnkill, AFUNPTR(mykill)));\n            fptrkill = fptr;\n        }\n\n        RTN rtnsched_yield = RTN_FindByName(img, \"sched_yield\");\n        if (RTN_Valid(rtnsched_yield) && RTN_IsSafeForProbedReplacement(rtnsched_yield)) {\n            OutFile << CurrentTime() << \"Inserting probe for sched_yield at \" << RTN_Address(rtnsched_yield) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsched_yield, AFUNPTR(mysched_yield)));\n            fptrsched_yield = fptr;\n        }\n\n        RTN rtntimer_settime = RTN_FindByName(img, \"timer_settime\");\n        if (RTN_Valid(rtntimer_settime) && RTN_IsSafeForProbedReplacement(rtntimer_settime))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for timer_settime at \" << RTN_Address(rtntimer_settime) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtntimer_settime, AFUNPTR(mytimer_settime)));\n            fptrtimer_settime = fptr;\n        }\n\n        RTN rtnsigaltstack = RTN_FindByName(img, \"sigaltstack\");\n        if (RTN_Valid(rtnsigaltstack) && RTN_IsSafeForProbedReplacement(rtnsigaltstack))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigaltstack at \" << RTN_Address(rtnsigaltstack) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigaltstack, AFUNPTR(mysigaltstack)));\n            fptrsigaltstack = fptr;\n        }\n\n        RTN rtnioctl = RTN_FindByName(img, \"ioctl\");\n        if (RTN_Valid(rtnioctl) && RTN_IsSafeForProbedReplacement(rtnioctl))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for ioctl at \" << RTN_Address(rtnioctl) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnioctl, AFUNPTR(myioctl)));\n            fptrioctl = fptr;\n        }\n\n        RTN rtnflock = RTN_FindByName(img, \"flock\");\n        if (RTN_Valid(rtnflock) && RTN_IsSafeForProbedReplacement(rtnflock))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for flock at \" << RTN_Address(rtnflock) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnflock, AFUNPTR(myflock)));\n            fptrflock = fptr;\n        }\n\n        RTN rtn__libc_dlopen_mode = RTN_FindByName(img, \"__libc_dlopen_mode\");\n        if (RTN_Valid(rtn__libc_dlopen_mode) && RTN_IsSafeForProbedReplacement(rtn__libc_dlopen_mode))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for __libc_dlopen_mode at \" << RTN_Address(rtn__libc_dlopen_mode) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn__libc_dlopen_mode, AFUNPTR(my__libc_dlopen_mode)));\n            fptr__libc_dlopen_mode = fptr;\n        }\n\n        RTN rtn__errno_location = RTN_FindByName(img, \"__errno_location\");\n        if (RTN_Valid(rtn__errno_location) && RTN_IsSafeForProbedReplacement(rtn__errno_location))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for __errno_location at \" << RTN_Address(rtn__errno_location) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn__errno_location, AFUNPTR(my__errno_location)));\n            fptr__errno_location = fptr;\n        }\n\n        RTN rtnsyscall = RTN_FindByName(img, \"syscall\");\n        if (RTN_Valid(rtnsyscall) && RTN_IsSafeForProbedReplacement(rtnsyscall))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for syscall at \" << RTN_Address(rtnsyscall) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsyscall, AFUNPTR(mysyscall)));\n            fptrsyscall = fptr;}\n        }\n        // finished instrumentation\n    }\n\n/* ===================================================================== */\n/* Main function                                                         */\n/* ===================================================================== */\n\nint main(int argc, char *argv[]) {\n    // Initialize Pin\n    PIN_InitSymbols();\n    if (PIN_Init(argc, argv)) {\n        return Usage();\n    }\n\n    OutFile.open(KnobOutputFile.Value().c_str());\n    OutFile << hex;\n    OutFile.setf(ios::showbase);\n    OutFile << CurrentTime() << \"started!\" << endl;\n    OutFile.flush();\n\n    // Register the instrumentation callback\n    IMG_AddInstrumentFunction(ImgLoad, 0);\n\n    // Start the application\n    PIN_StartProgramProbed(); // never returns\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/dltest_unix.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include \"../InstLib/tool_macros.h\"\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n#if defined(TARGET_MAC) || defined(TARGET_BSD)\n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);\n#else    \n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n#endif    \n    fprintf(stderr, \"Allocated %p\\n\",mem);\n    // This unmap should not trigger a flush\n    munmap(mem, 0x2000);\n\n    Load(SHARED_LIB(\"libone\"), 1);\n    Load(SHARED_LIB(\"libtwo\"), 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/malloctrace2.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*! @file\n The test shows how wrappers may be implemented in DLL loaded in runtime.\n The dopen() is being called from application space. But it can't be called\n before libc is initialized.\n In this example I call dlopen before main().\n */\n\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"tool_macros.h\"\n\n#ifdef TARGET_MAC\n# define MALLOC_LIB \"libsystem_malloc.dylib\"\n#else\n# define MALLOC_LIB \"libc.so\"\n#endif\n\nusing namespace std;\n\n\n/* ===================================================================== */\n\nINT32 Usage()\n{\n    cerr <<\n        \"This pin tool inserts a user-written version of malloc() and free() into the application.\\n\"\n        \"\\n\";\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return -1;\n}\n\n\n/* ===================================================================== */\n/* Definitions for Probe mode */\n/* ===================================================================== */\n\ntypedef typeof(malloc) * MallocType;\ntypedef typeof(free) * FreeType;\ntypedef typeof(dlopen) * DlopenType;\ntypedef typeof(dlsym) * DlsymType;\n\nMallocType MallocWrapper = 0;\nMallocType origMalloc = 0;\n\nFreeType FreeWrapper = 0;\nFreeType origFree = 0;\n\nvoid * MallocTraceHandle = 0;\n\nDlopenType AppDlopen = 0;\nDlsymType AppDlsym = 0;\n\ntypedef VOID (*SET_ORIG_FPTR)(MallocType mallocPtr, FreeType freePtr);\n\n/* ===================================================================== */\n/* Probe mode tool */\n/* ===================================================================== */\n\nVOID *MallocWrapperInTool(size_t size)\n{\n    if (MallocWrapper)\n    {\n        return (*MallocWrapper)(size);\n    }\n    else\n    {\n        ASSERTX(origMalloc != 0);\n        return (*origMalloc)(size);\n    }\n}\n\nVOID FreeWrapperInTool(void *p)\n{\n    if (FreeWrapper)\n    {\n        (*FreeWrapper)(p);\n    }\n    else\n    {\n        ASSERTX(origFree != 0);\n        (*origFree)(p);\n    }\n}\n\n/* I'm calling dlopen before main.\n * Some malloc-free may be lost, of course.\n * But the earliest point you can call dlopen is after init of libc\n */\nVOID MainRtnCallback()\n{\n    cout << \"In main callback\" << endl;\n    // inject libmallocwrappers.so into application by executing application dlopen\n\n    MallocTraceHandle = AppDlopen(SHARED_LIB(\"libmallocwrappers\"), RTLD_LAZY);\n    ASSERTX(MallocTraceHandle);\n\n    // Get function pointers for the wrappers\n    MallocWrapper = MallocType(AppDlsym(MallocTraceHandle, \"mallocWrapper\"));\n    FreeWrapper = FreeType(AppDlsym(MallocTraceHandle, \"freeWrapper\"));\n    ASSERTX(MallocWrapper && FreeWrapper);\n\n    // Send original function pointers to libmallocwrappers.so\n    SET_ORIG_FPTR setOriginalFptr = (SET_ORIG_FPTR) AppDlsym(MallocTraceHandle, \"SetOriginalFptr\");\n    ASSERTX(setOriginalFptr != 0);\n    (*setOriginalFptr)(origMalloc, origFree);\n}\n\nVOID ImageLoad(IMG img, VOID *v)\n{\n    if (strstr(IMG_Name(img).c_str(), \"libdl.so\"))\n    {\n        // Get the function pointer for the application dlopen:\n        // dlopen@@GLIBC_2.1 is the official, versioned name.\n        //\n        // The exact suffix must match the ABI of the libdl header files\n        // this source code gets compiled against. Makefile/configure\n        // trickery would be needed to figure this suffix out, so it\n        // is simply hard-coded here.\n        //\n        // To keep the resulting binaries compatible with future libdl.so\n        // versions, this code also checks for backwards compatibility\n        // versions of the calls as they would be provided in such a\n        // future version.\n\n#if defined(TARGET_IA32E)\n# define DLOPEN_VERSION \"GLIBC_2.2.5\"\n# define DLSYM_VERSION \"GLIBC_2.2.5\"\n#elif defined(TARGET_IA32)\n# define DLOPEN_VERSION \"GLIBC_2.1\"\n# define DLSYM_VERSION \"GLIBC_2.0\"\n#else\n# error symbol versions unknown for this target\n#endif\n\n        RTN dlopenRtn = RTN_FindByName(img, \"dlopen@@\" DLOPEN_VERSION);\n        if (!RTN_Valid(dlopenRtn))\n        {\n            dlopenRtn = RTN_FindByName(img, \"dlopen@\" DLOPEN_VERSION);\n        }\n\n        if (!RTN_Valid(dlopenRtn))\n        {\n            // fallback for the cases in which symbols do not have a version\n            dlopenRtn = RTN_FindByName(img, \"dlopen\");\n        }\n\n        ASSERTX(RTN_Valid(dlopenRtn));\n        AppDlopen = DlopenType(RTN_Funptr(dlopenRtn));\n\n        // Get the function pointer for the application dlsym\n        RTN dlsymRtn = RTN_FindByName(img, \"dlsym@@\" DLSYM_VERSION);\n        if (!RTN_Valid(dlsymRtn)) {\n            dlsymRtn = RTN_FindByName(img, \"dlsym@\" DLSYM_VERSION);\n        }\n        if (!RTN_Valid(dlsymRtn)) {\n            // fallback for the cases in which symbols do not have a version\n            dlsymRtn = RTN_FindByName(img, \"dlsym\");\n        }\n\n        ASSERTX(RTN_Valid(dlsymRtn));\n        AppDlsym = DlsymType(RTN_Funptr(dlsymRtn));\n\n\n    }\n    if (strstr(IMG_Name(img).c_str(), \"libdyld.dylib\"))\n    {\n        RTN dlopenRtn = RTN_FindByName(img, C_MANGLE(\"dlopen\") );\n\n        // Get the function pointer for the application dlsym\n        RTN dlsymRtn = RTN_FindByName(img, C_MANGLE(\"dlsym\") );\n\n        // In some systems, dlsym and dlopen symbols don't exist.\n        // In this case, exit with special return code.\n        if (!RTN_Valid(dlsymRtn) && !RTN_Valid(dlopenRtn))\n        {\n            cerr << \"Error: dlsym and dlopen not found\" << endl;\n            PIN_ExitApplication(13);\n        }\n\n        AppDlopen = DlopenType(RTN_Funptr(dlopenRtn));\n        AppDlsym = DlsymType(RTN_Funptr(dlsymRtn));\n\n    }\n\n    if (strstr(IMG_Name(img).c_str(), MALLOC_LIB))\n    {\n        // Replace malloc and free in application libc with wrappers in libmallocwrappers.so\n        RTN mallocRtn = RTN_FindByName(img, C_MANGLE(\"malloc\"));\n        ASSERTX(RTN_Valid(mallocRtn));\n\n        if ( ! RTN_IsSafeForProbedReplacement( mallocRtn ) )\n        {\n            cout << \"Cannot replace malloc in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n        RTN freeRtn = RTN_FindByName(img, C_MANGLE(\"free\"));\n        ASSERTX(RTN_Valid(freeRtn));\n\n        if ( ! RTN_IsSafeForProbedReplacement( freeRtn ) )\n        {\n            cout << \"Cannot replace free in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n\n        origMalloc = (MallocType)RTN_ReplaceProbed(mallocRtn, AFUNPTR(MallocWrapperInTool));\n\n        origFree = (FreeType)RTN_ReplaceProbed(freeRtn, AFUNPTR(FreeWrapperInTool));\n\n    }\n\n    /* I call dopen before main. If this point is too late for you,\n    catch init() of libc and call dlopen after init() is done\n    */\n    if (IMG_IsMainExecutable(img))\n    {\n        RTN mainRtn = RTN_FindByName(img, \"_main\");\n        if (!RTN_Valid(mainRtn))\n            mainRtn = RTN_FindByName(img, \"main\");\n\n        if (!RTN_Valid(mainRtn))\n        {\n            cout << \"Can't find the main routine in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n        RTN_InsertCallProbed(mainRtn, IPOINT_BEFORE, AFUNPTR(MainRtnCallback), IARG_END);\n    }\n}\n\n\n\n/* ===================================================================== */\n/* main */\n/* ===================================================================== */\n\nint main(int argc, CHAR *argv[])\n{\n    PIN_InitSymbols();\n\n    if( PIN_Init(argc,argv) )\n    {\n        return Usage();\n    }\n\n    IMG_AddInstrumentFunction(ImageLoad, 0);\n\n    PIN_StartProgramProbed();\n\n    return 0;\n}\n\n/* ===================================================================== */\n/* eof */\n/* ===================================================================== */\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/tpss_lin_libc.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n * This tool mimics the behavior of TPSS on Linux by adding probes to various libc functions.\n * However, in this tool these probes are merely empty wrappers that call the original functions.\n * The objective of the test is to verify that probe generation and insertion don't cause Pin\n * to crash.\n *\n * This file is part of the tpss_lin_libc tool and compiles against the native\n * libc of the machine/compiler in order to extact data types definition from it's headers.\n */\n\n#define _GNU_SOURCE\n#include <link.h>\n#include <sys/types.h>\n#include <sys/timeb.h>\n#include <rpc/rpc.h>\n#include <rpc/pmap_clnt.h>\n#include <semaphore.h>\n#include <dlfcn.h>\n#include <signal.h>\n#include <poll.h>\n#include <time.h>\n#include <link.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <sys/ipc.h>\n#include <sys/sem.h>\n#include <signal.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <stdio.h>\n#include <string.h>\n#include <wchar.h>\n#include <sys/socket.h>\n#include <sys/utsname.h>\n#include <sched.h>\n#include <time.h>\n\ntypedef int * INT_PTR;\n\ntypedef void * VOID_PTR;\n\ntypedef char * CHAR_PTR;\n\nvoid printFunctionCalled(const char* funcName);\n\n/* ===================================================================== */\n/* Function signatures - these functions will be probed                  */\n/* ===================================================================== */\n\nint (*fptrnanosleep)(const struct timespec *__rqtp, struct timespec *__rmtp);\n\nint (*fptrdl_iterate_phdr)(int (*__callback)(struct dl_phdr_info *__info, size_t __size,\n    VOID_PTR __data), VOID_PTR __data);\n\nint (*fptrsystem)(const CHAR_PTR __command);\n\nunsigned int (*fptralarm)(unsigned int __seconds);\n\nssize_t (*fptrrecvmsg)(int __socket, struct msghdr *__message, int __flags);\n\nssize_t (*fptrsendmsg)(int __sockfd, const struct msghdr *__msg, int __flags);\n\nint (*fptrpause)(void);\n\nint (*fptrsigtimedwait)(const sigset_t *__set, siginfo_t *__info, const struct timespec *__timeout);\n\nint (*fptrsigwaitinfo)(const sigset_t *__set, siginfo_t *__info);\n\nint (*fptrepoll_wait)(int __epfd, struct epoll_event *__events, int __maxevents,\n    int __timeout);\n\nint (*fptrepoll_pwait)(int __epfd, struct epoll_event *__events,\n    int __maxevents, int __timeout, const sigset_t *__sigmask);\n\nint (*fptrppoll)(struct pollfd *__fds, nfds_t __nfds,\n    const struct timespec *__timeout_ts, const sigset_t *__sigmask);\n\nint (*fptrmsgsnd)(int __msqid, const VOID_PTR __msgp, size_t __msgsz, int __msgflg);\n\nssize_t (*fptrmsgrcv)(int __msqid, VOID_PTR __msgp, size_t __msgsz, long __msgtyp, int __msgflg);\n\nint (*fptrsemop)(int __semid, struct sembuf *__sops, unsigned __nsops);\n\nint (*fptrsemtimedop)(int __semid, struct sembuf *__sops);\n\nint (*fptrusleep)(useconds_t __usec);\n\nuseconds_t (*fptrualarm)(useconds_t __usecs, useconds_t __interval);\n\nint (*fptrgetitimer)(int __which, struct itimerval *__curr_value);\n\nint (*fptrsigwait)(const sigset_t *__set, INT_PTR __sig);\n\nint (*fptrmsgget)(key_t __key, int __msgflg);\n\nint (*fptrsemget)(key_t __key, int __nsems, int __semflg);\n\npid_t (*fptrwait)(INT_PTR __status);\n\npid_t (*fptrwaitpid)(pid_t __pid, INT_PTR __atus, int __options);\n\nint (*fptrwaitid)(idtype_t __idtype, id_t __id, siginfo_t *__infop,int __options);\n\npid_t (*fptrwait3)(INT_PTR __status, int __options, struct rusage *__rusage);\n\npid_t (*fptrwait4)(pid_t __pid, INT_PTR status, int __options, struct rusage *__rusage);\n\nssize_t (*fptrreadv)(int __fd, const struct iovec *__iov, int __iovcnt);\n\nssize_t (*fptrwritev)(int __fd, const struct iovec *__iov, int __iovcnt);\n\nint (*fptrflock)(int __fd, int __operation);\n\nvoid (*fptrflockfile)(FILE *__filehandle);\n\nvoid (*fptrfunlockfile)(FILE *__filehandle);\n\nint (*fptrlockf)(int __fd, int __cmd, off_t __len);\n\nint (*fptrsetenv)(const CHAR_PTR __name, const CHAR_PTR __value, int __overwrite);\n\nint (*fptrunsetenv)(const CHAR_PTR __name);\n\nCHAR_PTR (*fptrgetenv)(const CHAR_PTR __name);\n\nvoid (*fptrperror)(const CHAR_PTR __s);\n\nVOID_PTR (*fptrmmap)(VOID_PTR __addr, size_t __len, int __prot, int __flags,\n        int __fildes, off_t __off);\n\nint (*fptrmunmap)(VOID_PTR __addr, size_t __len);\n\nint (*fptrfileno)(FILE *__stream);\n\npid_t (*fptrgetpid)(void);\n\npid_t (*fptrgetppid)(void);\n\nVOID_PTR (*fptrmemset)(VOID_PTR __s, int __c, size_t __n);\n\nVOID_PTR (*fptrmemcpy)(VOID_PTR __dest, const VOID_PTR __src, size_t __n);\n\nint (*fptraccess)(const CHAR_PTR __pathname, int __mode);\n\noff_t (*fptrlseek)(int __fd, off_t __offset, int __whence);\n\noff64_t (*fptrlseek64)(int __fd, off64_t __offset, int __whence);\n\nint (*fptrfdatasync)(int __fd);\n\nint (*fptrunlink)(const CHAR_PTR __pathname);\n\nsize_t (*fptrstrlen)(const CHAR_PTR __s);\n\nsize_t (*fptrwcslen)(const wchar_t *__s);\n\nCHAR_PTR (*fptrstrcpy)(CHAR_PTR __dest, const CHAR_PTR __src);\n\nCHAR_PTR (*fptrstrncpy)(CHAR_PTR __dest, const CHAR_PTR __src, size_t __n);\n\nCHAR_PTR (*fptrstrcat)(CHAR_PTR __dest, const CHAR_PTR __src);\n\nCHAR_PTR (*fptrstrstr)(const CHAR_PTR __haystack, const CHAR_PTR __needle);\n\nCHAR_PTR (*fptrstrchr0)(const CHAR_PTR __s, int __c);\n\nCHAR_PTR (*fptrstrrchr)(const CHAR_PTR __s, int __c);\n\nint (*fptrstrcmp)(const CHAR_PTR __s1, const CHAR_PTR __s2);\n\nint (*fptrstrncmp)(const CHAR_PTR __s1, const CHAR_PTR __s2, size_t __n);\n\nint (*fptrsigaddset)(sigset_t *__set, int __signum);\n\nint (*fptrsigdelset)(sigset_t *__set, int __signum);\n\nint (*fptrsigismember)(const sigset_t *__set, int __signum);\n\nCHAR_PTR (*fptrstrerror)(int __errnum);\n\nint (*fptrbind)(int __sockfd, const struct sockaddr *__addr, socklen_t __addrlen);\n\nint (*fptrlisten)(int __sockfd, int __backlog);\n\nint (*fptruname)(struct utsname *__name);\n\nint (*fptrgethostname)(CHAR_PTR __name, size_t __len);\n\nint (*fptrkill)(pid_t __pid, int __sig);\n\nint (*fptrsched_yield)(void);\n\nint (*fptrtimer_settime)(timer_t __timerid, int __flags, const struct itimerspec * __value, struct itimerspec * __ovalue);\n\nint (*fptrsigaltstack)(const stack_t *__ss, stack_t *__oss);\n\nint (*fptrshutdown)(int, int);\n\nint (*fptrsleep)(unsigned int);\n\nint (*fptrsocket)(int, int, int);\n\nint (*fptrselect)(int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict, struct timeval *__restrict);\n\nint (*fptrpoll)(struct pollfd *, nfds_t, int);\n\nint (*fptraccept)(int, __SOCKADDR_ARG, socklen_t *__restrict);\n\nint (*fptrconnect)(int, __CONST_SOCKADDR_ARG, socklen_t);\n\nssize_t (*fptrrecv)(int, VOID_PTR , size_t, int);\n\nssize_t (*fptrrecvfrom)(int, VOID_PTR __restrict, size_t, int, __SOCKADDR_ARG, socklen_t *__restrict);\n\nssize_t (*fptrsend)(int, __const VOID_PTR , size_t, int);\n\nwint_t (*fptrgetwc)(__FILE *);\n\nint (*fptrsetitimer)(__itimer_which_t, __const struct itimerval *__restrict, struct itimerval *__restrict);\n\nint (*fptrsigpending)(sigset_t *);\n\nint (*fptrsigaction)(int, __const struct sigaction *__restrict, struct sigaction *__restrict);\n\n__sighandler_t (*fptrsignal)(int, __sighandler_t);\n\nvoid (*fptrabort)();\n\nssize_t (*fptrsendto)(int, __const VOID_PTR , size_t, int, __CONST_SOCKADDR_ARG, socklen_t);\n\nint (*fptr_IO_getc)(FILE *);\n\nint (*fptrgetchar)();\n\nwint_t (*fptrgetwchar)();\n\nCHAR_PTR  (*fptrgets)(CHAR_PTR );\n\nCHAR_PTR  (*fptrfgets)(CHAR_PTR __restrict, int, FILE *__restrict);\n\nwint_t (*fptrfgetwc)(__FILE *);\n\nsize_t (*fptrfread)(VOID_PTR __restrict, size_t, size_t, FILE *__restrict);\n\nsize_t (*fptrfwrite)(__const VOID_PTR __restrict, size_t, size_t, FILE *__restrict);\n\nint (*fptropen)(__const CHAR_PTR , int, mode_t);\n\nint (*fptrgetw)(FILE *);\n\nvoid (*fptrfgetc)(__FILE *);\n\nwchar_t * (*fptrfgetws)(wchar_t *__restrict, int, __FILE *__restrict);\n\nint (*fptrpipe)(int[2]);\n\nssize_t (*fptrread)(int, VOID_PTR , size_t);\n\nssize_t (*fptrwrite)(int, __const VOID_PTR , size_t);\n\nFILE * (*fptrfopen)(__const CHAR_PTR __restrict, __const CHAR_PTR __restrict);\n\nFILE * (*fptrfdopen)(int, __const CHAR_PTR );\n\nint (*fptrclose)(int);\n\nint (*fptrfclose)(FILE *);\n\nint (*fptrcallrpc)(__const CHAR_PTR , u_long, u_long, u_long, xdrproc_t, __const CHAR_PTR , xdrproc_t, CHAR_PTR );\n\nenum clnt_stat (*fptrclnt_broadcast)(u_long, u_long, u_long, xdrproc_t, caddr_t,\n        xdrproc_t, caddr_t, resultproc_t);\n\nCLIENT * (*fptrclntudp_create)(struct sockaddr_in *, u_long, u_long, struct timeval, INT_PTR );\n\nCLIENT * (*fptrclntudp_bufcreate)(struct sockaddr_in *, u_long, u_long, struct timeval, INT_PTR , u_int, u_int);\n\nstruct pmaplist * (*fptrpmap_getmaps)(struct sockaddr_in *);\n\nu_short (*fptrpmap_getport)(struct sockaddr_in *, u_long, u_long, u_int);\n\nenum clnt_stat (*fptrpmap_rmtcall)(struct sockaddr_in *, u_long, u_long, u_long, xdrproc_t, caddr_t, xdrproc_t, caddr_t, struct timeval, u_long *);\n\nbool_t (*fptrpmap_set)(u_long, u_long, int, u_short);\n\nCLIENT * (*fptrclntraw_create)(u_long, u_long);\n\nvoid (*fptrsvc_run)();\n\nbool_t (*fptrsvc_sendreply)(SVCXPRT *, xdrproc_t, caddr_t);\n\nSVCXPRT * (*fptrsvcraw_create)();\n\nSVCXPRT * (*fptrsvctcp_create)(int, u_int, u_int);\n\nSVCXPRT * (*fptrsvcudp_bufcreate)(int, u_int, u_int);\n\nSVCXPRT * (*fptrsvcudp_create)(int);\n\nvoid (*fptr_exit)(int);\n\nint (*fptrsigprocmask)(int, __const sigset_t *__restrict, sigset_t *__restrict);\n\nvoid (*fptrexit)(int);\n\nint (*fptrpselect)(int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict, \n    const struct timespec *__restrict, const __sigset_t *__restrict);\n\nint (*fptrioctl)(int __d, int __request, CHAR_PTR  __argp);\n\nint (*fptrfcntl)(int __fd, int __cmd, VOID_PTR  __argp);\n\nVOID_PTR (*fptr__libc_dlopen_mode)(const CHAR_PTR __name, int __mode);\n\nINT_PTR  (*fptr__errno_location)(void);\n\nint (*fptrsyscall)(int __number, long int __arg1, long int __arg2, long int __arg3,\n     long int __arg4, long int __arg5, long int __arg6, long int __arg7);\n\n/* ===================================================================== */\n/* Probes - implementation of the wrapper functions                      */\n/* ===================================================================== */\n\nint mynanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) \n{\n    printFunctionCalled(\"mynanosleep\");\n    int res = fptrnanosleep(__rqtp, __rmtp);\n\n    return res;\n}\nint mydl_iterate_phdr(\n        int (*__callback)(struct dl_phdr_info *__info, size_t __size,\n                VOID_PTR __data), VOID_PTR __sec_data) \n{\n    printFunctionCalled(\"mydl_iterate_phdr\");\n    int res = fptrdl_iterate_phdr((__callback), __sec_data);\n    return res;\n}\n\nint mysystem(const CHAR_PTR __command) \n{\n    printFunctionCalled(\"mysystem\");\n    int res = fptrsystem(__command);\n\n    return res;\n}\n\nunsigned int myalarm(unsigned int __seconds)\n{\n    printFunctionCalled(\"myalarm\");\n    unsigned int res = fptralarm(__seconds);\n\n    return res;\n}\n\nssize_t myrecvmsg(int __socket, struct msghdr *__message, int __flags)\n{\n    printFunctionCalled(\"myrecvmsg\");\n    ssize_t res = fptrrecvmsg(__socket, __message, __flags);\n\n    return res;\n}\n\nssize_t mysendmsg(int __sockfd, const struct msghdr *__msg, int __flags) \n{\n    printFunctionCalled(\"mysendmsg\");\n    ssize_t res = fptrsendmsg(__sockfd, __msg, __flags);\n\n    return res;\n}\n\nint mypause(void) \n{\n    printFunctionCalled(\"mypause\");\n    int res = fptrpause();\n\n    return res;\n}\n\nint mysigtimedwait(const sigset_t *__set, siginfo_t *__info,\n        const struct timespec *__timeout) \n{\n    printFunctionCalled(\"mysigtimedwait\");\n    int res = fptrsigtimedwait(__set, __info, __timeout);\n\n    return res;\n}\n\nint mysigwaitinfo(const sigset_t *__set, siginfo_t *__info) \n{\n    printFunctionCalled(\"mysigwaitinfo\");\n    int res = fptrsigwaitinfo(__set, __info);\n\n    return res;\n}\n\nint myepoll_wait(int __epfd, struct epoll_event *__events, int __maxevents,\n        int __timeout) \n{\n    printFunctionCalled(\"myepoll_wait\");\n    int res = fptrepoll_wait(__epfd, __events, __maxevents, __timeout);\n\n    return res;\n}\n\nint myepoll_pwait(int __epfd, struct epoll_event *__events, int __maxevents,\n        int __timeout) \n{\n    printFunctionCalled(\"myepoll_pwait\");\n    int res = fptrepoll_wait(__epfd, __events, __maxevents, __timeout);\n\n    return res;\n}\n\nint myppoll(struct pollfd *__fds, nfds_t __nfds,\n        const struct timespec *__timeout_ts, const sigset_t *__sigmask) \n{\n    printFunctionCalled(\"myppoll\");\n    int res = fptrppoll(__fds, __nfds, __timeout_ts, __sigmask);\n\n    return res;\n}\n\nint mymsgsnd(int __msqid, const VOID_PTR __msgp, size_t __msgsz, int __msgflg) \n{\n    printFunctionCalled(\"mymsgsnd\");\n    int res = fptrmsgsnd(__msqid, __msgp, __msgsz, __msgflg);\n\n    return res;\n}\n\nssize_t mymsgrcv(int __msqid, VOID_PTR __msgp, size_t __msgsz, long __msgtyp,\n        int __msgflg) \n{\n    printFunctionCalled(\"mymsgrcv\");\n    ssize_t res = fptrmsgrcv(__msqid, __msgp, __msgsz, __msgtyp, __msgflg);\n\n    return res;\n}\n\nint mysemtimedop(int __semid, struct sembuf *__sops) \n{\n    printFunctionCalled(\"mysemtimedop\");\n    int res = fptrsemtimedop(__semid, __sops);\n\n    return res;\n}\n\nint myusleep(useconds_t __usecs) \n{\n    printFunctionCalled(\"myusleep\");\n    int res = fptrusleep(__usecs);\n\n    return res;\n}\n\nuseconds_t myualarm(useconds_t __usecs, useconds_t __interval) \n{\n    printFunctionCalled(\"myualarm\");\n    useconds_t res = fptrualarm(__usecs, __interval);\n\n    return res;\n}\n\nint mygetitimer(int __which, struct itimerval *__curr_value) \n{\n    printFunctionCalled(\"mygetitimer\");\n    int res = fptrgetitimer(__which, __curr_value);\n\n    return res;\n}\n\nint mysigwait(const sigset_t *__set, INT_PTR __sig) \n{\n    printFunctionCalled(\"mysigwait\");\n    int res = fptrsigwait(__set, __sig);\n\n    return res;\n}\n\nint mymsgget(key_t __key, int __msgflg) \n{\n    printFunctionCalled(\"mymsgget\");\n    int res = fptrmsgget(__key, __msgflg);\n\n    return res;\n}\n\nint mysemget(key_t __key, int __nsems, int __semflg) \n{\n    printFunctionCalled(\"mysemget\");\n    int res = fptrsemget(__key, __nsems, __semflg);\n\n    return res;\n}\n\npid_t mywaitpid(pid_t __pid, INT_PTR __status, int __options) \n{\n    printFunctionCalled(\"mywaitpid\");\n    pid_t res = fptrwaitpid(__pid, __status, __options);\n\n    return res;\n}\n\nint mywaitid(idtype_t __idtype, id_t __id, siginfo_t *__infop, int __options)\n{\n    printFunctionCalled(\"mywaittid\");\n    int res = fptrwaitid(__idtype, __id, __infop, __options);\n\n    return res;\n}\n\npid_t mywait3(INT_PTR __status, int __options, struct rusage *__rusage) \n{\n    printFunctionCalled(\"mywait3\");\n    pid_t res = fptrwait3(__status, __options, __rusage);\n\n    return res;\n}\n\npid_t mywait4(pid_t __pid, INT_PTR __status, int __options,\n        struct rusage *__rusage) \n{\n    printFunctionCalled(\"mywait4\");\n    pid_t res = fptrwait4(__pid, __status, __options, __rusage);\n\n    return res;\n}\n\nssize_t myreadv(int __fd, const struct iovec *__iov, int __iovcnt) \n{\n    printFunctionCalled(\"myreadv\");\n    ssize_t res = fptrreadv(__fd, __iov, __iovcnt);\n\n    return res;\n}\n\nssize_t mywritev(int __fd, const struct iovec *__iov, int __iovcnt) \n{\n    printFunctionCalled(\"mywritev\");\n    ssize_t res = fptrwritev(__fd, __iov, __iovcnt);\n\n    return res;\n}\n\nint myflock(int __fd, int __operation) \n{\n    printFunctionCalled(\"myflock\");\n    int res = fptrflock(__fd, __operation);\n\n    return res;\n}\n\nvoid myflockfile(FILE *__filehandle) \n{\n    printFunctionCalled(\"myflockfile\");\n    fptrflockfile(__filehandle);\n}\n\nvoid myfunlockfile(FILE *__filehandle) \n{\n    printFunctionCalled(\"myfunlockfile\");\n    fptrfunlockfile(__filehandle);\n}\n\nint mylockf(int __fd, int __cmd, off_t __len) \n{\n    printFunctionCalled(\"mylockf\");\n    int res = fptrlockf(__fd, __cmd, __len);\n\n    return res;\n}\n\nint mysetenv(const CHAR_PTR __name, const CHAR_PTR __value, int __overwrite) \n{\n    printFunctionCalled(\"mysetenv\");\n    int res = fptrsetenv(__name, __value, __overwrite);\n\n    return res;\n}\n\nint myunsetenv(const CHAR_PTR __name) \n{\n    printFunctionCalled(\"myunsetenv\");\n    int res = fptrunsetenv(__name);\n\n    return res;\n}\n\nCHAR_PTR  mygetenv(const CHAR_PTR __name) \n{\n    printFunctionCalled(\"mygetenv\");\n    CHAR_PTR  res = fptrgetenv(__name);\n\n    return res;\n}\n\nvoid myperror(const CHAR_PTR __s) \n{\n    printFunctionCalled(\"myperror\");\n    fptrperror(__s);\n\n}\n\nVOID_PTR  mymmap(VOID_PTR __addr, size_t __len, int __prot, int __flags, int __fildes,\n        off_t __off) \n{\n    printFunctionCalled(\"mymmap\");\n    VOID_PTR  res = fptrmmap(__addr, __len, __prot, __flags, __fildes, __off);\n\n    return res;\n}\n\nint mymunmap(VOID_PTR __addr, size_t __len) \n{\n    printFunctionCalled(\"mymunmap\");\n    int res = fptrmunmap(__addr, __len);\n\n    return res;\n}\n\nint myfileno(FILE *__stream)\n{   \n    printFunctionCalled(\"myfileno\");\n    int res = fptrfileno(__stream);\n\n    return res;\n}\n\npid_t mygetpid(void) \n{\n    printFunctionCalled(\"mygetpid\");\n    pid_t res = fptrgetpid();\n\n    return res;\n}\n\npid_t mygetppid(void) \n{\n    printFunctionCalled(\"mygetppid\");\n    pid_t res = fptrgetppid();\n\n    return res;\n}\n\nVOID_PTR  mymemset(VOID_PTR __s, int __c, size_t __n) {\n    printFunctionCalled(\"mymemset\");\n    VOID_PTR  res = fptrmemset(__s, __c, __n);\n\n    return res;\n}\n\nVOID_PTR  mymemcpy(VOID_PTR __dest, const VOID_PTR __src, size_t __n) \n{\n    printFunctionCalled(\"mymemcpy\");\n    VOID_PTR  res = fptrmemcpy(__dest, __src, __n);\n\n    return res;\n}\n\nint myaccess(const CHAR_PTR __pathname, int __mode) \n{\n    printFunctionCalled(\"myaccess\");\n    int res = fptraccess(__pathname, __mode);\n\n    return res;\n}\n\noff_t mylseek(int __fd, off_t __offset, int __whence) \n{\n    printFunctionCalled(\"mylseek\");\n    off_t res = fptrlseek(__fd, __offset, __whence);\n\n    return res;\n}\n\noff64_t mylseek64(int __fd, off64_t __offset, int __whence) \n{\n    printFunctionCalled(\"mylseek64\");\n    off64_t res = fptrlseek64(__fd, __offset, __whence);\n\n    return res;\n}\n\nint myfdatasync(int __fd) {\n    printFunctionCalled(\"myfdatasync\");\n    int res = fptrfdatasync(__fd);\n\n    return res;\n}\n\nint myunlink(const CHAR_PTR __pathname) \n{\n    printFunctionCalled(\"myunlink\");\n    int res = fptrunlink(__pathname);\n\n    return res;\n}\n\nsize_t mystrlen(const CHAR_PTR __s) \n{\n    printFunctionCalled(\"mystrlen\");\n    size_t res = fptrstrlen(__s);\n\n    return res;\n}\n\nsize_t mywcslen(const wchar_t *__s)\n{\n    printFunctionCalled(\"mywcslen\");\n    size_t res = fptrwcslen(__s);\n\n    return res;\n}\n\nCHAR_PTR  mystrcpy(CHAR_PTR __dest, const CHAR_PTR __src) \n{\n    printFunctionCalled(\"mystrcpy\");\n    CHAR_PTR  res = fptrstrcpy(__dest, __src);\n\n    return res;\n}\n\nCHAR_PTR  mystrncpy(CHAR_PTR __dest, const CHAR_PTR __src, size_t __n) \n{\n    printFunctionCalled(\"mystrncpy\");\n    CHAR_PTR  res = fptrstrncpy(__dest, __src, __n);\n\n    return res;\n}\n\nCHAR_PTR  mystrcat(CHAR_PTR __dest, const CHAR_PTR __src) \n{\n    printFunctionCalled(\"mystrcat\");\n    CHAR_PTR  res = fptrstrcat(__dest, __src);\n\n    return res;\n}\n\nCHAR_PTR  mystrstr(const CHAR_PTR __haystack, const CHAR_PTR __needle) \n{\n    printFunctionCalled(\"mystrstr\");\n    CHAR_PTR  res = fptrstrstr(__haystack, __needle);\n\n    return res;\n}\n\nCHAR_PTR  mystrchr0(const CHAR_PTR __s, int __c) \n{\n    printFunctionCalled(\"mystrchr0\");\n    CHAR_PTR  res = fptrstrchr0(__s, __c);\n\n    return res;\n}\n\nCHAR_PTR  mystrrchr(const CHAR_PTR __s, int __c) \n{\n    printFunctionCalled(\"mystrrchr\");\n    CHAR_PTR  res = fptrstrrchr(__s, __c);\n\n    return res;\n}\n\nint mystrcmp(const CHAR_PTR __s1, const CHAR_PTR __s2) \n{\n    printFunctionCalled(\"mystrcmp\");\n    int res = fptrstrcmp(__s1, __s2);\n\n    return res;\n}\n\nint mystrncmp(const CHAR_PTR __s1, const CHAR_PTR __s2, size_t __n) \n{\n    printFunctionCalled(\"mystrncmp\");\n    int res = fptrstrncmp(__s1, __s2, __n);\n\n    return res;\n}\n\nint mysigaddset(sigset_t *__set, int __signum) \n{\n    printFunctionCalled(\"mysigaddset\");\n    int res = fptrsigaddset(__set, __signum);\n\n    return res;\n}\n\nint mysigdelset(sigset_t *__set, int __signum) {\n    printFunctionCalled(\"mysigdelset\");\n    int res = fptrsigdelset(__set, __signum);\n\n    return res;\n}\n\nint mysigismember(sigset_t *__set, int __signum)\n{\n    printFunctionCalled(\"mysigismember\");\n    int res = fptrsigismember(__set, __signum);\n\n    return res;\n}\n\nCHAR_PTR  mystrerror(int __errnum) \n{\n    printFunctionCalled(\"mystrerror\");\n    CHAR_PTR  res = fptrstrerror(__errnum);\n\n    return res;\n}\n\nint mybind(int __sockfd, const struct sockaddr *__addr, socklen_t __addrlen) \n{\n    printFunctionCalled(\"mybind\");\n    int res = fptrbind(__sockfd, __addr, __addrlen);\n\n    return res;\n}\n\nint mylisten(int __sockfd, int __backlog) \n{\n    printFunctionCalled(\"mylisten\");\n    int res = fptrlisten(__sockfd, __backlog);\n\n    return res;\n}\n\nint myuname(struct utsname *__name) \n{\n    printFunctionCalled(\"myuname\");\n    int res = fptruname(__name);\n\n    return res;\n}\n\nint mygethostname(CHAR_PTR __name, size_t __len) \n{\n    printFunctionCalled(\"mygethostname\");\n    int res = fptrgethostname(__name, __len);\n\n    return res;\n}\n\nint mykill(pid_t __pid, int __sig) \n{\n    printFunctionCalled(\"mykill\");\n    int res = fptrkill(__pid, __sig);\n\n    return res;\n}\n\nint mysched_yield(void) \n{\n    printFunctionCalled(\"mysched_yield\");\n    int res = fptrsched_yield();\n\n    return res;\n}\n\nint mytimer_settime(timer_t __timerid, int __flags,\n        const struct itimerspec * __value, struct itimerspec * __ovalue) \n{\n    printFunctionCalled(\"mytimer_settime\");\n    int res = fptrtimer_settime(__timerid, __flags, __value, __ovalue);\n\n    return res;\n}\n\nint mysigaltstack(const stack_t *__ss, stack_t *__oss) \n{\n    printFunctionCalled(\"mysigaltstacke\");\n    int res = fptrsigaltstack(__ss, __oss);\n\n    return res;\n}\n\nint mysleep(unsigned int __seconds) \n{\n    printFunctionCalled(\"mysleep\");\n    int res = fptrsleep(__seconds);\n\n    return res;\n}\n\nint mysocket(int __domain, int __type, int __protocol) \n{\n    printFunctionCalled(\"mysocket\");\n    int res = fptrsocket(__domain, __type, __protocol);\n\n    return res;\n}\n\nint myshutdown(int __fd, int __how) \n{\n    printFunctionCalled(\"myshutdown\");\n    int res = fptrshutdown(__fd, __how);\n\n    return res;\n}\n\nint myselect(int __nfds, fd_set *__restrict __readfds,\n        fd_set *__restrict __writefds, fd_set *__restrict __exceptfds,\n        struct timeval *__restrict __timeout) \n{\n    printFunctionCalled(\"myselect\");\n    int res = fptrselect(__nfds, __readfds, __writefds, __exceptfds, __timeout);\n\n    return res;\n}\n\nint mypoll(struct pollfd * __fds, nfds_t __nfds, int __timeout) \n{\n    printFunctionCalled(\"mypoll\");\n    int res = fptrpoll(__fds, __nfds, __timeout);\n\n    return res;\n}\n\nint myaccept(int __fd, __SOCKADDR_ARG __addr,\n        socklen_t *__restrict __addr_len) \n{\n    printFunctionCalled(\"myaccept\");\n    int res = fptraccept(__fd, __addr, __addr_len);\n\n    return res;\n}\n\nint myconnect(int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len) \n{\n    printFunctionCalled(\"myconnect\");\n    int res = fptrconnect(__fd, __addr, __len);\n\n    return res;\n}\n\nssize_t myrecv(int __fd, VOID_PTR  __buf, size_t __n, int __flags) \n{\n    printFunctionCalled(\"myrecv\");\n    ssize_t res = fptrrecv(__fd, __buf, __n, __flags);\n\n    return res;\n}\n\nssize_t myrecvfrom(int __fd, VOID_PTR __restrict __buf, size_t __n, int __flags,\n        __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len) \n{\n    printFunctionCalled(\"myrecvfrom\");\n    ssize_t res = fptrrecvfrom(__fd, __buf, __n, __flags, __addr, __addr_len);\n\n    return res;\n}\n\nssize_t mysend(int __fd, __const VOID_PTR  __buf, size_t __n, int __flags) \n{\n    printFunctionCalled(\"mysend\");\n    ssize_t res = fptrsend(__fd, __buf, __n, __flags);\n\n    return res;\n}\n\nwint_t mygetwc(__FILE * __stream) \n{\n    printFunctionCalled(\"mygetwc\");\n    wint_t res = fptrgetwc(__stream);\n\n    return res;\n}\n\nvoid myexit(int __status) \n{\n    printFunctionCalled(\"myexit\");\n    fptrexit(__status);\n\n}\n\nint mysetitimer(__itimer_which_t  __which, __const\n        struct itimerval *__restrict __new,\n        struct itimerval *__restrict __old) \n{\n    printFunctionCalled(\"mysetitimer\");\n    int res = fptrsetitimer(__which, __new, __old);\n\n    return res;\n}\n\nint mysigpending(sigset_t * __set) \n{\n    printFunctionCalled(\"mysigpending\");\n    int res = fptrsigpending(__set);\n\n    return res;\n}\n\n__sighandler_t mysignal(int __sig, __sighandler_t  __handler) \n\n{\n    printFunctionCalled(\"mysignal\");\n    __sighandler_t res = fptrsignal(__sig, __handler);\n\n    return res;\n}\n\nvoid myabort() \n{\n    printFunctionCalled(\"myabort\");\n    fptrabort();\n}\n\nint myclose(int __fd) \n{\n    printFunctionCalled(\"myclose\");\n    int res = fptrclose(__fd);\n\n    return res;\n}\n\nssize_t mysendto(int __fd, __const VOID_PTR  __buf, size_t __n, int __flags,\n        __CONST_SOCKADDR_ARG __addr, socklen_t __addr_len) \n{\n    printFunctionCalled(\"mysendto\");\n    ssize_t res = fptrsendto(__fd, __buf, __n, __flags, __addr, __addr_len);\n\n    return res;\n}\n\nint my_IO_getc(FILE * __stream) \n{\n    printFunctionCalled(\"my_IO_getc\");\n    int res = fptr_IO_getc(__stream);\n\n    return res;\n}\n\nint mygetchar()\n{\n    printFunctionCalled(\"mygetchar\");\n    int res = fptrgetchar();\n\n    return res;\n}\n\nwint_t mygetwchar() \n{\n    printFunctionCalled(\"mygetwchar\");\n    wint_t res = fptrgetwchar();\n\n    return res;\n}\n\nCHAR_PTR  mygets(CHAR_PTR  __s) \n{\n    printFunctionCalled(\"mygets\");\n    CHAR_PTR  res = fptrgets(__s);\n\n    return res;\n}\n\nCHAR_PTR  myfgets(CHAR_PTR __restrict __s, int __n, FILE *__restrict __stream) \n{\n    printFunctionCalled(\"myfgets\");\n    CHAR_PTR  res = fptrfgets(__s, __n, __stream);\n\n    return res;\n}\n\nwint_t myfgetwc(__FILE * __stream) \n{\n    printFunctionCalled(\"myfgetwc\");\n    wint_t res = fptrfgetwc(__stream);\n\n    return res;\n}\n\nsize_t myfread(VOID_PTR __restrict __ptr, size_t __size, size_t __n,\n        FILE *__restrict __stream)\n{\n    printFunctionCalled(\"myfread\");\n    size_t res = fptrfread(__ptr, __size, __n, __stream);\n\n    return res;\n}\n\nsize_t myfwrite(__const VOID_PTR __restrict __ptr, size_t __size, size_t __n,\n        FILE *__restrict __s) \n{\n    printFunctionCalled(\"myfwrite\");\n    size_t res = fptrfwrite(__ptr, __size, __n, __s);\n\n    return res;\n}\n\nint myopen(__const CHAR_PTR  __file, int __flags, mode_t __mode) \n{\n    printFunctionCalled(\"myopen\");\n    int res = fptropen(__file, __flags, __mode);\n\n    return res;\n}\n\nint mygetw(FILE * __stream) \n{\n    printFunctionCalled(\"mygetw\");\n    int res = fptrgetw(__stream);\n\n    return res;\n}\n\nvoid myfgetc(__FILE * __stream) \n{\n    printFunctionCalled(\"myfgetc\");\n    fptrfgetc(__stream);\n\n}\n\nwchar_t * myfgetws(wchar_t *__restrict __ws, int __n,\n        __FILE *__restrict __stream) \n        {\n    printFunctionCalled(\"myfgetws\");\n    wchar_t * res = fptrfgetws(__ws, __n, __stream);\n\n    return res;\n}\n\nint mypipe(int* __pipedes) \n{\n    printFunctionCalled(\"mypipe\");\n    int res = fptrpipe(__pipedes);\n\n    return res;\n}\n\nssize_t myread(int __fd, VOID_PTR  __buf, size_t __nbytes) \n{\n    printFunctionCalled(\"myread\");\n    ssize_t res = fptrread(__fd, __buf, __nbytes);\n\n    return res;\n}\n\nssize_t mywrite(int __fd, __const VOID_PTR  __buf, size_t __n) \n{\n    printFunctionCalled(\"mywrite\");\n    ssize_t res = fptrwrite(__fd, __buf, __n);\n\n    return res;\n}\n\nFILE * myfopen(__const CHAR_PTR __restrict __filename,\n        __const CHAR_PTR __restrict __modes) \n{\n    printFunctionCalled(\"myfopen\");\n    FILE * res = fptrfopen(__filename, __modes);\n\n    return res;\n}\n\nFILE * myfdopen(int __fd, __const CHAR_PTR  __modes) \n{\n    printFunctionCalled(\"myfdopen\");\n    FILE * res = fptrfdopen(__fd, __modes);\n\n    return res;\n}\n\nint mycallrpc(__const CHAR_PTR  __host, u_long __prognum, u_long __versnum,\n        u_long __procnum, xdrproc_t __inproc, __const CHAR_PTR  __in,\n        xdrproc_t __outproc, CHAR_PTR  __out) \n{\n    printFunctionCalled(\"mycallrpc\");\n    int res = fptrcallrpc(__host, __prognum, __versnum, __procnum, __inproc,\n            __in, __outproc, __out);\n\n    return res;\n}\n\nenum clnt_stat myclnt_broadcast(u_long __prog, u_long __vers, u_long __proc,\n        xdrproc_t __xargs, caddr_t __argsp, xdrproc_t __xresults,\n        caddr_t __resultsp, resultproc_t __eachresult) \n{\n    printFunctionCalled(\"myclnt_broadcast\");\n    enum clnt_stat res = fptrclnt_broadcast(__prog, __vers, __proc, __xargs,\n            __argsp, __xresults, __resultsp, __eachresult);\n\n    return res;\n}\n\nCLIENT * myclntudp_create(struct sockaddr_in * __raddr, u_long __program,\n        u_long __version, struct timeval __wait_resend, INT_PTR  __sockp) \n{\n    printFunctionCalled(\"myclntudp_create\");\n    CLIENT * res = fptrclntudp_create(__raddr, __program, __version,\n            __wait_resend, __sockp);\n\n    return res;\n}\n\nCLIENT * myclntudp_bufcreate(struct sockaddr_in * __raddr, u_long __program,\n        u_long __version, struct timeval __wait_resend, INT_PTR  __sockp,\n        u_int __sendsz, u_int __recvsz) \n{\n    printFunctionCalled(\"myclntudp_bufcreate\");\n    CLIENT * res = fptrclntudp_bufcreate(__raddr, __program, __version,\n            __wait_resend, __sockp, __sendsz, __recvsz);\n\n    return res;\n}\n\nstruct pmaplist * mypmap_getmaps(struct sockaddr_in * __address) \n{\n    printFunctionCalled(\"mypmap_getmaps\");\n    struct pmaplist * res = fptrpmap_getmaps(__address);\n\n    return res;\n}\n\nu_short mypmap_getport(struct sockaddr_in * __address, u_long __program,\n        u_long __version, u_int __protocol) \n{\n    printFunctionCalled(\"mypmap_getport\");\n    u_short res = fptrpmap_getport(__address, __program, __version, __protocol);\n\n    return res;\n}\n\nenum clnt_stat mypmap_rmtcall(struct sockaddr_in * __addr, u_long __prog,\n        u_long __vers, u_long __proc, xdrproc_t __xdrargs, caddr_t __argsp,\n        xdrproc_t __xdrres, caddr_t __resp, struct timeval __tout,\n        u_long * __port_ptr) \n{\n    printFunctionCalled(\"mypmap_rmtcall\");\n    enum clnt_stat res = fptrpmap_rmtcall(__addr, __prog, __vers, __proc,\n            __xdrargs, __argsp, __xdrres, __resp, __tout, __port_ptr);\n\n    return res;\n}\n\nbool_t mypmap_set(u_long __program, u_long __vers, int __protocol, u_short __port) \n{\n    printFunctionCalled(\"mypmap_set\");\n    bool_t res = fptrpmap_set(__program, __vers, __protocol, __port);\n\n    return res;\n}\n\nCLIENT * myclntraw_create(u_long __prog, u_long __vers) \n{\n    printFunctionCalled(\"myclntraw_create\");\n    CLIENT * res = fptrclntraw_create(__prog, __vers);\n\n    return res;\n}\n\nvoid mysvc_run()\n{\n    printFunctionCalled(\"mysvc_run\");\n    fptrsvc_run();\n}\n\nbool_t mysvc_sendreply(SVCXPRT * xprt, xdrproc_t __xdr_results,\n        caddr_t __xdr_location) \n{\n    printFunctionCalled(\"mysvc_sendreply\");\n    bool_t res = fptrsvc_sendreply(xprt, __xdr_results, __xdr_location);\n\n    return res;\n}\n\nSVCXPRT * mysvcraw_create() \n{\n    printFunctionCalled(\"mysvcraw_create\");\n    SVCXPRT * res = fptrsvcraw_create();\n\n    return res;\n}\n\nSVCXPRT * mysvctcp_create(int __sock, u_int __sendsize, u_int __recvsize) \n{\n    printFunctionCalled(\"mypmap_rmtcall\");\n    SVCXPRT * res = fptrsvctcp_create(__sock, __sendsize, __recvsize);\n\n    return res;\n}\n\nSVCXPRT * mysvcudp_bufcreate(int __sock, u_int __sendsz, u_int __recvsz)\n{\n    printFunctionCalled(\"mysvcudp_bufcreate\");\n    SVCXPRT * res = fptrsvcudp_bufcreate(__sock, __sendsz, __recvsz);\n\n    return res;\n}\n\nSVCXPRT * mysvcudp_create(int __sock)\n{\n    printFunctionCalled(\"mysvcudp_create\");\n    SVCXPRT * res = fptrsvcudp_create(__sock);\n\n    return res;\n}\n\nvoid my_exit(int __status)\n{\n    printFunctionCalled(\"my_exit\");\n    fptr_exit(__status);\n\n}\n\nint my_nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) \n{\n    printFunctionCalled(\"my_nanosleep\");\n    int res = fptrnanosleep(__rqtp, __rmtp);\n\n    return res;\n}\n\nint mysigprocmask(int __how, __const sigset_t *__restrict __set,\n        sigset_t *__restrict __oset) \n{\n    printFunctionCalled(\"mysigprocmask\");\n    int res = fptrsigprocmask(__how, __set, __oset);\n\n    return res;\n}\n\nint mypselect(int __nfds, fd_set *__restrict __readfds,\n        fd_set *__restrict __writefds, fd_set *__restrict __exceptfds,\n        const struct timespec *__restrict __timeout,\n        const __sigset_t *__restrict __sigmask) \n{\n    printFunctionCalled(\"mypselect\");\n    int res = fptrpselect(__nfds, __readfds, __writefds, __exceptfds, __timeout,\n            __sigmask);\n\n    return res;\n}\n\npid_t mywait(INT_PTR __status) \n{\n    printFunctionCalled(\"mywait\");\n    int res = fptrwait(__status);\n\n    return res;\n}\n\nint myfclose(FILE * __stream) \n{\n    printFunctionCalled(\"myfclose\");\n    int res = fptrfclose(__stream);\n\n    return res;\n}\n\nint myioctl(int __d, int __request, CHAR_PTR  __argp) \n{\n    printFunctionCalled(\"myioctl\");\n    int res = fptrioctl(__d, __request, __argp);\n\n    return res;\n}\n\nint myfcntl(int __fd, int __cmd, VOID_PTR  __argp) \n{\n    printFunctionCalled(\"myfcntl\");\n    int res = fptrfcntl(__fd, __cmd, __argp);\n\n    return res;\n}\n\nVOID_PTR  my__libc_dlopen_mode(const CHAR_PTR __name, int __mode) \n{\n    printFunctionCalled(\"my__libc_dlopen_mode\");\n    VOID_PTR  res = fptr__libc_dlopen_mode(__name, __mode);\n\n    return res;\n}\n\nINT_PTR  my__errno_location(void) \n{\n    printFunctionCalled(\"my__errno_location\");\n    INT_PTR  res = fptr__errno_location();\n\n    return res;\n}\n\nint mysyscall(int __number, long int __arg1, long int __arg2, long int __arg3,\n        long int __arg4, long int __arg5, long int __arg6, long int __arg7) \n{\n    printFunctionCalled(\"mysyscall\");\n    int res = fptrsyscall(__number, __arg1, __arg2, __arg3, __arg4, __arg5,\n            __arg6, __arg7);\n\n    return res;\n}\n\nint mysigaction(int __sig, __const struct sigaction *__restrict __act,\n        struct sigaction *__restrict __oact) \n{\n    printFunctionCalled(\"mysigaction\");\n    int res = fptrsigaction(__sig, __act, __oact);\n\n    return res;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/tpss_lin_libdl.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n * This tool mimics the behavior of TPSS on Linux by adding probes to various libdl functions.\n * However, in this tool these probes are merely empty wrappers that call the original functions.\n * The objective of the test is to verify that probe generation and insertion don't cause Pin\n * to crash.\n */\n\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <dlfcn.h>\n\ntypedef char * CHAR_PTR;\n\ntypedef void * VOID_PTR;\n\nofstream OutFile;\n\n/* ===================================================================== */\n/* Commandline Switches                                                  */\n/* ===================================================================== */\n\nKNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\",\n    \"o\", \"tpss_lin_libdl.txt\", \"specify tool log file name\");\n\n/* ===================================================================== */\n/* Utility functions                                                     */\n/* ===================================================================== */\n\n// Print help information\nINT32 Usage()\n{\n    cerr << \"This tool mimics the behavior of TPSS on Linux by adding probes to various libdl functions.\" << endl;\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return 1;\n}\n\n// Utility function to return the time\nstring CurrentTime()\n{\n    char tmpbuf[128];\n    time_t thetime = time(NULL);\n    ctime_r(&thetime, tmpbuf);\n    return tmpbuf;\n}\n\n\n/* ===================================================================== */\n/* Function signatures - these functions will be probed                  */\n/* ===================================================================== */\n\nVOID_PTR (*fptrdlopen)(__const CHAR_PTR __file, int  __mode);\n\nint (*fptrdlclose)(VOID_PTR __handle);\n\nVOID_PTR (*fptrdlsym)(VOID_PTR __handle , __const CHAR_PTR __name );\n\nVOID_PTR (*fptrdlvsym)( VOID_PTR __handle, __const CHAR_PTR __name,__const CHAR_PTR __version);\n\nint (*fptrdladdr)(__const void *__address , Dl_info * __info);\n\nint (*fptrdladdr1)(__const void * __address , Dl_info * __info, void ** __extra_info, int __flags);\n\nCHAR_PTR (*fptrdlerror)(void);\n\n/* ===================================================================== */\n/* Probes - implementation of the wrapper functions                      */\n/* ===================================================================== */\n\nVOID_PTR mydlopen(__const CHAR_PTR __file, int __mode)\n{\n   OutFile << CurrentTime() << \"mydlopen called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlopen(__file, __mode);\n\n   return res;\n}\n\nint mydlclose(VOID_PTR __handle)\n{\n   OutFile << CurrentTime() << \"mydlclose called \" << endl;\n   OutFile.flush();\n   int res = fptrdlclose(__handle);\n\n   return res;\n}\n\nVOID_PTR mydlsym(VOID_PTR  __handle, __const CHAR_PTR  __name)\n{\n   OutFile << CurrentTime() << \"mydlsym called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlsym(__handle, __name);\n\n   return res;\n}\n\nVOID_PTR mydlvsym(VOID_PTR  __handle, __const CHAR_PTR  __name, __const CHAR_PTR __version)\n{\n   OutFile << CurrentTime() << \"mydlvsym called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlvsym(__handle, __name, __version);\n\n   return res;\n}\n\nint mydladdr(__const void * __address, Dl_info * __info)\n{\n   OutFile << CurrentTime() << \"mydladdr called \" << endl;\n   OutFile.flush();\n   int res = fptrdladdr(__address, __info);\n\n   return res;\n}\n\nint mydladdr1(__const void * __address, Dl_info * __info, void ** __extra_info, int __flags)\n{\n   OutFile << CurrentTime() << \"mydladdr1 called \" << endl;\n   OutFile.flush();\n   int res = fptrdladdr1(__address, __info, __extra_info, __flags);\n\n   return res;\n}\n\nCHAR_PTR mydlerror(void)\n{\n   OutFile << CurrentTime() << \"CHAR_PTR called \" << endl;\n   OutFile.flush();\n   CHAR_PTR res = fptrdlerror();\n\n   return res;\n}\n\n/* ===================================================================== */\n/* Instrumnetation functions                                             */\n/* ===================================================================== */\n\n// Image load callback - inserts the probes.\nvoid ImgLoad(IMG img, void *v)\n{\n    // Called every time a new image is loaded\n\n    if ( (IMG_Name(img).find(\"libdl.so\") != string::npos) ||\n         (IMG_Name(img).find(\"LIBDL.SO\") != string::npos) ||\n         (IMG_Name(img).find(\"LIBDL.so\") != string::npos) )\n    {\n        RTN rtndlclose = RTN_FindByName(img, \"dlclose\");\n        if (RTN_Valid(rtndlclose) && RTN_IsSafeForProbedReplacement(rtndlclose))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlclose at \" << RTN_Address(rtndlclose) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlclose, AFUNPTR(mydlclose)));\n            fptrdlclose = (int (*)(VOID_PTR ))fptr;\n        }\n\n        RTN rtndlopen = RTN_FindByName(img, \"dlopen\");\n        if (RTN_Valid(rtndlopen) && RTN_IsSafeForProbedReplacement(rtndlopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlopen at \" << RTN_Address(rtndlopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlopen, AFUNPTR(mydlopen)));\n            fptrdlopen = (VOID_PTR (*)(__const CHAR_PTR , int ))fptr;\n        }\n\n        RTN rtndlsym = RTN_FindByName(img, \"dlsym\");\n        if (RTN_Valid(rtndlsym) && RTN_IsSafeForProbedReplacement(rtndlsym))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlsym at \" << RTN_Address(rtndlsym) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlsym, AFUNPTR(mydlsym)));\n            fptrdlsym = (VOID_PTR (*)(VOID_PTR, __const CHAR_PTR ))fptr;\n        }\n\n        RTN rtndlvsym = RTN_FindByName(img, \"dlvsym\");\n        if (RTN_Valid(rtndlvsym) && RTN_IsSafeForProbedReplacement(rtndlvsym))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlvsym at \" << RTN_Address(rtndlvsym) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlvsym, AFUNPTR(mydlvsym)));\n            fptrdlvsym = (VOID_PTR (*)(VOID_PTR, __const CHAR_PTR, __const CHAR_PTR))fptr;\n        }\n\n        RTN rtndladdr = RTN_FindByName(img, \"dladdr\");\n        if (RTN_Valid(rtndladdr) && RTN_IsSafeForProbedReplacement(rtndladdr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dladdr at \" << RTN_Address(rtndladdr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndladdr, AFUNPTR(mydladdr)));\n            fptrdladdr = (int (*)(__const void * , Dl_info * ))fptr;\n        }\n\n        RTN rtndladdr1 = RTN_FindByName(img, \"dladdr1\");\n        if (RTN_Valid(rtndladdr) && RTN_IsSafeForProbedReplacement(rtndladdr1))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dladdr1 at \" << RTN_Address(rtndladdr1) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndladdr, AFUNPTR(mydladdr1)));\n            fptrdladdr1 = (int (*)(__const void * , Dl_info *, void **, int ))fptr;\n        }\n\n        RTN rtndlerror = RTN_FindByName(img, \"dlerror\");\n        if (RTN_Valid(rtndlerror) && RTN_IsSafeForProbedReplacement(rtndlerror))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlerror at \" << RTN_Address(rtndlerror) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlerror, AFUNPTR(mydlerror)));\n            fptrdlerror = (CHAR_PTR (*)(void ))fptr;\n        }\n    }\n    // finished instrumentation\n}\n\n/* ===================================================================== */\n/* Main function                                                         */\n/* ===================================================================== */\n\nint main(int argc, char *argv[])\n{\n    // Initialize Pin\n    PIN_InitSymbols();\n    if (PIN_Init(argc,argv))\n    {\n        return Usage();\n    }\n\n    OutFile.open(KnobOutputFile.Value().c_str());\n    OutFile << hex;\n    OutFile.setf(ios::showbase);\n    OutFile << CurrentTime() << \"started!\" << endl;\n    OutFile.flush();\n\n    // Register the instrumentation callback\n    IMG_AddInstrumentFunction(ImgLoad, 0);\n\n\n    // Start the application\n    PIN_StartProgramProbed(); // never returns\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/unloadtest_unix.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include \"../InstLib/tool_macros.h\"\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n    Load(SHARED_LIB(\"libone\"), 1);\n    Load(SHARED_LIB(\"libtwo\"), 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Tests/sourceLocation_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n * This app checks a bug in the debug_elf cache mechanism. The cache contains images\n * that have previously been searched for debug information. When a pintool calls the\n * PIN_GetSourceLocation API, this cache is searched first (for the nearest address\n * which is greater or equal to the one being searched for). However, unloaded images\n * were never removed from the cache. When the API was used during an image unload\n * callback, if the images at high addresses were removed first, the search could be\n * conducted on images in the cache that had already been removed from Pin's internal\n * data structures, thus causing an assertion. The solution was to remove these images\n * from the cache as well as from the other data structres.\n * This app loads two images and then unloads the higher addressed one first in order\n * to recreate the conditions mentioned above.\n */\n\n#include <dlfcn.h>\n#include <iostream>\n#include <cstdlib>\n\nusing std::cerr;\nusing std::endl;\n\nvoid* DLopen(const char* filename) {\n    void* handle = dlopen(filename, RTLD_LAZY);\n    if (handle == NULL) {\n        cerr << \"APP ERROR: failed to open \" << filename << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n    return handle;\n}\n\nvoid* DLsym(void* handle, const char* symname) {\n    dlerror(); // clear errors\n    void* sym = dlsym(handle, symname);\n    char* error = dlerror();\n    if (error != NULL) {\n        cerr << \"APP ERROR: failed to get address for symbol \" << symname << \" - \" << error << endl;\n        exit(-1);\n    }\n    return sym;\n}\n\nvoid DLcloseBoth(void* first, void* second) {\n    if (dlclose(first) != 0) {\n        cerr << \"APP ERROR: failed to close image at \" << first << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n    if (dlclose(second) != 0) {\n        cerr << \"APP ERROR: failed to close image at \" << second << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n}\n\n/*\n * Expected argv arguments:\n * [1] image1\n * [2] image2\n */\nint main(int argc, char* argv[]) {\n    \n    void* handle1 = DLopen(argv[1]);            // open image1\n    void* handle2 = DLopen(argv[2]);            // open image2\n    void* dummy1 = DLsym(handle1, \"dummy1\");    // get address from image1\n    void* dummy2 = DLsym(handle2, \"dummy2\");    // get address from image2\n\n    // unload images - higher addressed image first\n    if (dummy1 > dummy2) {\n        DLcloseBoth(handle1, handle2);\n    }\n    else {\n        DLcloseBoth(handle2, handle1);\n    }\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/ImageTests/l_imageLoad_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <dlfcn.h>\n\n#define EXPORT_SYM extern \"C\"\n\nEXPORT_SYM int AfterAttach();\n\nstatic int MAX_SIZE = 128; /*maximum line size*/\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_FORK_FAILED,      // 1\n    RES_EXEC_FAILED,      // 2\n    RES_LOAD_FAILED,      // 3\n    RES_RES_INVALID_ARGS  // 4\n};\n\nvoid UnixOpen(char* filename)\n{\n    void* dlh = dlopen(filename, RTLD_LAZY);\n    if( !dlh )\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", filename, dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n    dlclose(dlh);\n}\n\nint AfterAttach()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return 0;\n}\n\n/*\n    Expected argv arguments:\n    [1] first image to load\n    [2] second image to load\n    [3] pin executable\n    [4] \"-slow_asserts\"\n    [5] \"-probe\"\n    [6] tool\n    [7] \"-o\"\n    [8] tool's output file\n*/\n\nint main(int argc, char** argv)\n{\n    if(argc < 9)\n    {\n        fprintf(stderr, \"l_imageLoad_app received too few arguments. If you are running this test outside a kit test, you may need to add -slow-asserts right after the pin argument.\\n\" );\n        exit(RES_RES_INVALID_ARGS);\n    }\n    if(argc > 9)\n    {\n        fprintf(stderr, \"l_imageLoad_app received too many arguments\\n\" );\n        exit(RES_RES_INVALID_ARGS);\n    }\n\n    UnixOpen(argv[1]);\n\n    pid_t parentPid = getpid();\n    pid_t child = fork();\n    if (child < 0) {\n        perror(\"fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n    if (child)\n    {\n        // inside parent\n        while(!AfterAttach())\n        {\n            sleep(1);\n        }\n\n        UnixOpen(argv[2]);\n    }\n    if ( child == 0 )\n    {\n        // inside child\n        char attachPid[MAX_SIZE];\n        sprintf(attachPid, \"%d\", parentPid);\n        execl(argv[3], argv[3], argv[4],argv[5],\"-pid\", attachPid, \"-t\", argv[6], argv[7], argv[8],  NULL);\n        perror(\"execl failed while trying to attach Pin to the application\\n\");\n        exit(RES_EXEC_FAILED);\n    }\n    return RES_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/ImageTests/imageUnload_app.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <dlfcn.h>\n\nvoid Open(char* filename)\n{\n    void* dlh = dlopen(filename, RTLD_LAZY);\n    if( !dlh )\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\", filename, dlerror());\n        exit(2);\n    }\n    dlclose(dlh);\n}\n\nint main(int argc, char** argv)\n{\n    if(argc<1)\n    {\n        fprintf(stderr, \"No image name to load has been supplied\" );\n        fflush(stderr);\n        return 1;\n    }\n\n    Open(argv[1]);\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/ImageTests/full_path_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdio.h>\n#include <dlfcn.h>\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_LOAD_FAILED,      // 1\n    RES_RES_INVALID_ARGS  // 2\n};\n\n/*\n    Expected argv arguments:\n    [1] image to load\n*/\nint main(int argc, char** argv)\n{\n    if(argc!=2)\n    {\n        fprintf(stderr, \"No enough arguments\\n\" );\n        fflush(stderr);\n        return RES_RES_INVALID_ARGS;\n    }\n\n    void* handle;\n\n    handle = dlopen(argv[1], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        return RES_LOAD_FAILED;\n    }\n\n    return RES_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/ImageTests/split_image_linux_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <vector>\n#include <dlfcn.h>\n#include <limits.h>\n#include <link.h>\n\n// The executable filename of this program\nchar progname[4096];\n\nusing namespace std;\n\n/*\n * Iterate over all images known to the loader and print their memory regions\n */\nint dl_iterate(struct dl_phdr_info *info, size_t size, void *data)\n{\n    const char* realname = info->dlpi_name;\n    vector<pair<void*, void*> > vecSegments;\n    if (strstr(realname, \"linux-gate.so\") == realname || strstr(realname, \"linux-vdso.so\") == realname)\n    {\n        // Don't count VDSO, PIN doesn't repont it intentionally\n        return 0;\n    }\n    for (int j = 0; j < info->dlpi_phnum; j++)\n    {\n        if (info->dlpi_phdr[j].p_type == PT_LOAD)\n        {\n            void* start = (void *) (info->dlpi_addr + info->dlpi_phdr[j].p_vaddr);\n            void* end = (void*)((char*)start + info->dlpi_phdr[j].p_memsz - 1);\n            vecSegments.push_back(pair<void*, void*>(start, end));\n            if (*realname == 0 && (void*)dl_iterate >= start && (void*)dl_iterate < end)\n            {\n                realname = progname;\n            }\n        }\n    }\n    if (*realname != 0)\n    {\n        for (vector<pair<void*, void*> >::iterator it = vecSegments.begin(); it != vecSegments.end(); it++)\n        {\n            printf(\"%s, %p-%p\\n\", realname, it->first, it->second);\n        }\n    }\n    return 0;\n}\n\nint main(int argc, const char* argv[], char** envp)\n{\n    if (argc != 2)\n    {\n        printf(\"Usage: %s <path to lib>\\n\", argv[0]);\n        return 1;\n    }\n    realpath(argv[0], progname);\n    void* hDll = dlopen(argv[1], RTLD_LAZY | RTLD_GLOBAL);\n    if (NULL == hDll)\n    {\n        printf(\"Failed to open %s - %s\\n\", argv[1], dlerror());\n        return 1;\n    }\n    int (*return2)() = (int (*)())dlsym(hDll, \"return2\");\n    if (NULL == return2)\n    {\n        printf(\"Failed to locate 'return2' - %s\\n\", dlerror());\n        return 1;\n    }\n\n    if (return2() != 2)\n    {\n        printf(\"Bad value returned from 'return2'\\n\");\n        return 1;\n    }\n    dl_iterate_phdr(dl_iterate, NULL);\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/ImageTests/launchReattachImageLoadCallbacks_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n\n#define EXPORT_SYM extern \"C\"\n\nEXPORT_SYM bool AfterAttach2();\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_LOAD_FAILED,      // 1\n};\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nint main (int argc, char *argv[])\n{\n    void *handle = dlopen(argv[1], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    while(!AfterAttach2())\n    {\n        sleep(1);\n    }\n\n    handle = dlopen(argv[2], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    while(1)\n    {\n        // expected to be stopped by tool.\n        sleep(1);\n    }\n\n    return RES_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/ImageTests/attachReattachImageLoadCallbacks_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string.h>\n\n#define EXPORT_SYM extern \"C\"\n\nEXPORT_SYM bool AfterAttach1();\n\nEXPORT_SYM bool AfterAttach2();\n\nstatic int MAX_SIZE = 128; /*maximum line size*/\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_FORK_FAILED,      // 1\n    RES_EXEC_FAILED,      // 2\n    RES_LOAD_FAILED,      // 3\n    RES_RES_INVALID_ARGS  // 4\n};\n\n\nbool AfterAttach1()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\n/*\n * block only the signals in the list: \"signalsListToBlock\"\n */\nvoid BlockSignals(int signalsListToBlock[] , int len, sigset_t * sigmask)\n{\n    sigemptyset(sigmask);\n    int i;\n    for(i=0; i< len; ++i) \n        sigaddset(sigmask, signalsListToBlock[i]);\n    pthread_sigmask(SIG_SETMASK, sigmask, NULL);\n}\n\n\n/*\n    Expected argv arguments:\n    [1] first image to load\n    [2] second image to load\n    [3] pin executable\n    [4] \"-slow_asserts\"\n    [5] \"-probe\"\n    [6] tool\n    [7] output file\n    [8] represent if SIGTRAP should be blocked by the application\n    argv[8]=0 - SIGTRAP shouldn't be blocked\n    argv[8]=1 - SIGTRAP should be blocked\n*/\n\nint main(int argc, char** argv)\n{\n    if(argc!=9)\n    {\n        fprintf(stderr, \"No enough arguments\\n\" );\n        fflush(stderr);\n        exit(RES_RES_INVALID_ARGS);\n    }\n\n    if (strcmp(argv[1], \"1\") == 0) // Need to block the SIGTRAP signal\n    {\n        int sigList[1] = {SIGTRAP};\n        sigset_t sigmask;\n        BlockSignals(sigList, 1, &sigmask);\n    }\n   \n    pid_t parentPid = getpid();\n    pid_t child = fork();\n    if (child < 0)\n    {\n        perror(\"fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    {\n        // inside parent\n        while(!AfterAttach1())\n        {\n            sleep(1);\n        }\n\n        void *handle = dlopen(argv[1], RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n\n        while(!AfterAttach2())\n        {\n            sleep(1);\n        }\n\n        handle = dlopen(argv[2], RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[2], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n\n        while(1)\n        {\n            // expected to be stopped by tool.\n            sleep(1);\n        }\n    }\n\n    if ( child == 0 )\n    {\n        // inside child\n        char attachPid[MAX_SIZE];\n        snprintf(attachPid ,MAX_SIZE , \"%d\", parentPid);\n        execl(argv[3], argv[4], argv[5],\"-pid\", attachPid, \"-t\",  argv[6], \"-o\", argv[7], NULL);\n        perror(\"execl failed while trying to attach Pin to the application\\n\");\n        exit(RES_EXEC_FAILED);\n    }\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/ImageTests/images_on_attach_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n *  This application should be used with the images_on_attach_tool tool.\n *  See documentation in the tool for the test details.\n */\n\n#include <iostream>\n#include <cstdlib>\n#include <dlfcn.h>\n#include <unistd.h>\n\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\n\nextern \"C\"\n{\nvoid DoRelease(volatile bool* doRelease)\n{\n    // Do nothing\n}\n} // extern \"C\"\n\n\nstatic void WaitForAttach()\n{\n    const unsigned int timeout = 300;\n    unsigned int releaseCounter = 0;\n    volatile bool released = false;\n    while (!released)\n    {\n        if (timeout == releaseCounter)\n        {\n            cerr << \"APP ERROR: Timeout reached and the tool did not release the application.\" << endl;\n            exit(1);\n        }\n        ++releaseCounter;\n        DoRelease(&released);\n        sleep(1);\n    }\n}\n\n\nstatic void LoadAdditionalLibraries(const char* usrlib)\n{\n    const void *libutil = dlopen(\"libutil.so.1\", RTLD_LAZY);\n    if(NULL == libutil)\n    {\n        cerr << \"APP ERROR: Failed to load libutil.so.1\" << endl;\n        exit(1);\n    }\n    const void *usrlibptr = dlopen(usrlib, RTLD_LAZY);\n    if(NULL == usrlibptr)\n    {\n        cerr << \"APP ERROR: Failed to load \" << usrlib << endl;\n        exit(1);\n    }\n}\n\n\n/*\n * Expected arguments:\n *\n * [1] - Shared object to load dynamically\n */\nint main( int argc, char *argv[] )\n{\n    // Check the number of parameters.\n    if (2 != argc)\n    {\n        cerr << \"Usage: \" << argv[0] << \" <shared object to load>\" << endl;\n        return 1;\n    }\n\n    // Wait for the tool to attach to the application.\n    WaitForAttach();\n\n    // Pin is attached, now load two more shared objects.\n    LoadAdditionalLibraries(argv[1]);\n\n    // Done.\n    cout << \"APP: Application completed successfully.\" << endl;\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/include/dlfcn.h": "/*\n * Copyright (C) 2008 The Android Open Source Project\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#ifndef __DLFCN_H__\n#define __DLFCN_H__\n\n#include <sys/cdefs.h>\n\n__BEGIN_DECLS\n\ntypedef struct {\n    const char *dli_fname;  /* Pathname of shared object that\n                               contains address */\n    void       *dli_fbase;  /* Address at which shared object\n                               is loaded */\n    const char *dli_sname;  /* Name of nearest symbol with address\n                               lower than addr */\n    void       *dli_saddr;  /* Exact address of symbol named\n                               in dli_sname */\n} Dl_info;\n\nextern void*        dlopen(const char*  filename, int flag);\nextern int          dlclose(void*  handle);\nextern const char*  dlerror(void);\nextern void*        dlsym(void*  handle, const char*  symbol);\nextern int          dladdr(const void* addr, Dl_info *info);\n\nenum {\n#if defined(__APPLE__)\n  RTLD_LAZY   = 1,\n  RTLD_NOW    = 2,\n  RTLD_LOCAL  = 4,\n  RTLD_GLOBAL = 8,\n  RTLD_NOLOAD = 0x10,\n  RTLD_NODELETE = 0x80,\n  RTLD_FIRST = 0x100,   /* Mac OS X 10.5 and later */\n#else\n# if defined(__LP64__)\n  RTLD_NOW  = 2,\n# else\n  RTLD_NOW  = 0,\n# endif\n  RTLD_LAZY = 1,\n\n  RTLD_LOCAL  = 0,\n# if defined(__LP64__)\n  RTLD_GLOBAL = 0x00100,\n# else\n  RTLD_GLOBAL = 2,\n# endif\n  RTLD_NOLOAD = 4,\n#endif\n};\n\n#if defined(__APPLE__)\n# define RTLD_NEXT       ((void *) -1)   /* Search subsequent objects. */\n# define RTLD_DEFAULT    ((void *) -2)   /* Use default search algorithm. */\n# define RTLD_SELF       ((void *) -3)   /* Search this and subsequent objects (Mac OS X 10.5 and later) */\n# define RTLD_MAIN_ONLY  ((void *) -5)   /* Search main executable only (Mac OS X 10.5 and later) */\n#else\n# if defined (__LP64__)\n#  define RTLD_DEFAULT  ((void*) 0)\n#  define RTLD_NEXT     ((void*) -1L)\n# else\n#  define RTLD_DEFAULT  ((void*) 0xffffffff)\n#  define RTLD_NEXT     ((void*) 0xfffffffe)\n# endif\n#endif\n\n#if defined(__APPLE__) && defined(__NEED_DYLD_PRIVATE)\n#include <mach-o/dyld.h>\n#include <mach-o/dyld_images.h>\n\nstruct dyld_unwind_sections\n{\n\tconst struct mach_header*\t\tmh;\n\tconst void*\t\t\t\t\t\tdwarf_section;\n\tuintptr_t\t\t\t\t\t\tdwarf_section_length;\n\tconst void*\t\t\t\t\t\tcompact_unwind_section;\n\tuintptr_t\t\t\t\t\t\tcompact_unwind_section_length;\n};\n\nextern bool _dyld_find_unwind_sections(void* addr, struct dyld_unwind_sections* info);\nextern void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide));\nextern void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide));\n\n#endif\n\n__END_DECLS\n\n#endif /* __DLFCN_H */\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/include/nsswitch.h": "/*\t$NetBSD: nsswitch.h,v 1.21 2011/07/17 20:54:34 joerg Exp $\t*/\n\n/*-\n * Copyright (c) 1997, 1998, 1999, 2004 The NetBSD Foundation, Inc.\n * All rights reserved.\n *\n * This code is derived from software contributed to The NetBSD Foundation\n * by Luke Mewburn.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef _NSSWITCH_H\n#define _NSSWITCH_H\t1\n\n#include <sys/types.h>\n#include <stdarg.h>\n\n#define\tNSS_MODULE_INTERFACE_VERSION\t0\n\n#ifndef _PATH_NS_CONF\n#define _PATH_NS_CONF\t\"/etc/nsswitch.conf\"\n#endif\n\n#define\tNS_CONTINUE\t0\n#define\tNS_RETURN\t1\n\n/*\n * Layout of:\n *\tuint32_t ns_src.flags\n */\n\t/* nsswitch.conf status codes and nsdispatch(3) return values */\n#define\tNS_SUCCESS\t(1<<0)\t\t/* entry was found */\n#define\tNS_UNAVAIL\t(1<<1)\t\t/* source not responding, or corrupt */\n#define\tNS_NOTFOUND\t(1<<2)\t\t/* source responded 'no such entry' */\n#define\tNS_TRYAGAIN\t(1<<3)\t\t/* source busy, may respond to retrys */\n#define\tNS_STATUSMASK\t0x000000ff\t/* bitmask to get the status flags */\n\n\t/* internal nsdispatch(3) flags; not settable in nsswitch.conf(5)  */\n#define\tNS_FORCEALL\t(1<<8)\t\t/* force all methods to be invoked; */\n\n/*\n * Currently implemented sources.\n */\n#define NSSRC_FILES\t\"files\"\t\t/* local files */\n#define\tNSSRC_DNS\t\"dns\"\t\t/* DNS; IN for hosts, HS for others */\n#define\tNSSRC_NIS\t\"nis\"\t\t/* YP/NIS */\n#define\tNSSRC_COMPAT\t\"compat\"\t/* passwd,group in YP compat mode */\n\n/*\n * Currently implemented databases.\n */\n#define NSDB_HOSTS\t\t\"hosts\"\n#define NSDB_GROUP\t\t\"group\"\n#define NSDB_GROUP_COMPAT\t\"group_compat\"\n#define NSDB_NETGROUP\t\t\"netgroup\"\n#define NSDB_NETWORKS\t\t\"networks\"\n#define NSDB_PASSWD\t\t\"passwd\"\n#define NSDB_PASSWD_COMPAT\t\"passwd_compat\"\n#define NSDB_SHELLS\t\t\"shells\"\n\n/*\n * Suggested databases to implement.\n */\n#define NSDB_ALIASES\t\t\"aliases\"\n#define NSDB_AUTH\t\t\"auth\"\n#define NSDB_AUTOMOUNT\t\t\"automount\"\n#define NSDB_BOOTPARAMS\t\t\"bootparams\"\n#define NSDB_ETHERS\t\t\"ethers\"\n#define NSDB_EXPORTS\t\t\"exports\"\n#define NSDB_NETMASKS\t\t\"netmasks\"\n#define NSDB_PHONES\t\t\"phones\"\n#define NSDB_PRINTCAP\t\t\"printcap\"\n#define NSDB_PROTOCOLS\t\t\"protocols\"\n#define NSDB_REMOTE\t\t\"remote\"\n#define NSDB_RPC\t\t\"rpc\"\n#define NSDB_SENDMAILVARS\t\"sendmailvars\"\n#define NSDB_SERVICES\t\t\"services\"\n#define NSDB_TERMCAP\t\t\"termcap\"\n#define NSDB_TTYS\t\t\"ttys\"\n\n/*\n * ns_dtab `callback' function signature.\n */\ntypedef\tint (*nss_method)(void *, void *, va_list);\n\n/*\n * ns_dtab - `nsswitch dispatch table'\n * Contains an entry for each source and the appropriate function to call.\n */\ntypedef struct {\n\tconst char\t *src;\n\tnss_method\t callback;\n\tvoid\t\t *cb_data;\n} ns_dtab;\n\n/*\n * Macros to help build an ns_dtab[]\n */\n#define NS_FILES_CB(F,C)\t{ NSSRC_FILES,\tF,\t__UNCONST(C) },\n#define NS_COMPAT_CB(F,C)\t{ NSSRC_COMPAT,\tF,\t__UNCONST(C) },\n\n#ifdef HESIOD\n#   define NS_DNS_CB(F,C)\t{ NSSRC_DNS,\tF,\t__UNCONST(C) },\n#else\n#   define NS_DNS_CB(F,C)\n#endif\n\n#ifdef YP\n#   define NS_NIS_CB(F,C)\t{ NSSRC_NIS,\tF,\t__UNCONST(C) },\n#else\n#   define NS_NIS_CB(F,C)\n#endif\n#define\tNS_NULL_CB\t\t{ .src = NULL },\n\n/*\n * ns_src - `nsswitch source'\n * Used by the nsparser routines to store a mapping between a source\n * and its dispatch control flags for a given database.\n */\ntypedef struct {\n\tconst char\t*name;\n\tuint32_t\t flags;\n} ns_src;\n\n\n/*\n * Default sourcelists (if nsswitch.conf is missing, corrupt,\n * or the requested database doesn't have an entry)\n */\nextern const ns_src __nsdefaultsrc[];\nextern const ns_src __nsdefaultcompat[];\nextern const ns_src __nsdefaultcompat_forceall[];\nextern const ns_src __nsdefaultfiles[];\nextern const ns_src __nsdefaultfiles_forceall[];\nextern const ns_src __nsdefaultnis[];\nextern const ns_src __nsdefaultnis_forceall[];\n\n\n/*\n * ns_mtab - `nsswitch method table'\n * An nsswitch module provides a mapping from (database name, method name)\n * tuples to the nss_method and associated callback data.  Effectively,\n * ns_dtab, but used for dynamically loaded modules.\n */\ntypedef struct {\n\tconst char\t*database;\n\tconst char\t*name;\n\tnss_method\t method;\n\tvoid\t\t*mdata;\n} ns_mtab;\n\n/*\n * nss_module_register_fn - module registration function\n *\tcalled at module load\n * nss_module_unregister_fn - module un-registration function\n *\tcalled at module unload\n */\ntypedef\tvoid (*nss_module_unregister_fn)(ns_mtab *, u_int);\ntypedef\tns_mtab *(*nss_module_register_fn)(const char *, u_int *,\n\t\t\t\t\t   nss_module_unregister_fn *);\n\n#ifdef _NS_PRIVATE\n\n/*\n * Private data structures for back-end nsswitch implementation.\n */\n\n/*\n * ns_dbt - `nsswitch database thang'\n * For each database in /etc/nsswitch.conf there is a ns_dbt, with its\n * name and a list of ns_src's containing the source information.\n */\ntypedef struct {\n\tconst char\t*name;\t\t/* name of database */\n\tns_src\t\t*srclist;\t/* list of sources */\n\tu_int\t\t srclistsize;\t/* size of srclist */\n} ns_dbt;\n\n/*\n * ns_mod - `nsswitch module'\n */\ntypedef struct {\n\tconst char\t*name;\t\t/* module name */\n\tvoid\t\t*handle;\t/* handle from dlopen() */\n\tns_mtab\t\t*mtab;\t\t/* method table */\n\tu_int\t\t mtabsize;\t/* size of mtab */\n\t\t\t\t\t/* called to unload module */\n\tnss_module_unregister_fn unregister;\n} ns_mod;\n\n#endif /* _NS_PRIVATE */\n\n\n#include <sys/cdefs.h>\n\n__BEGIN_DECLS\nint\tnsdispatch(void *, const ns_dtab [], const char *,\n\t\t\tconst char *, const ns_src [], ...) __LIBC_ABI_PUBLIC__;\n\n#ifdef _NS_PRIVATE\nint\t\t _nsdbtaddsrc(ns_dbt *, const ns_src *);\nvoid\t\t _nsdbtdump(const ns_dbt *);\nint\t\t _nsdbtput(const ns_dbt *);\nvoid\t\t _nsyyerror(const char *);\nint\t\t _nsyylex(void);\n#endif /* _NS_PRIVATE */\n\n__END_DECLS\n\n#endif /* !_NSSWITCH_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/include/android/dlext.h": "/*\n * Copyright (C) 2014 The Android Open Source Project\n\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef __ANDROID_DLEXT_H__\n#define __ANDROID_DLEXT_H__\n\n#include <stddef.h>\n#include <sys/cdefs.h>\n\n__BEGIN_DECLS\n\n/* bitfield definitions for android_dlextinfo.flags */\nenum {\n  /* When set, the reserved_addr and reserved_size fields must point to an\n   * already-reserved region of address space which will be used to load the\n   * library if it fits. If the reserved region is not large enough, the load\n   * will fail.\n   */\n  ANDROID_DLEXT_RESERVED_ADDRESS      = 0x1,\n\n  /* As DLEXT_RESERVED_ADDRESS, but if the reserved region is not large enough,\n   * the linker will choose an available address instead.\n   */\n  ANDROID_DLEXT_RESERVED_ADDRESS_HINT = 0x2,\n\n  /* When set, write the GNU RELRO section of the mapped library to relro_fd\n   * after relocation has been performed, to allow it to be reused by another\n   * process loading the same library at the same address. This implies\n   * ANDROID_DLEXT_USE_RELRO.\n   */\n  ANDROID_DLEXT_WRITE_RELRO           = 0x4,\n\n  /* When set, compare the GNU RELRO section of the mapped library to relro_fd\n   * after relocation has been performed, and replace any relocated pages that\n   * are identical with a version mapped from the file.\n   */\n  ANDROID_DLEXT_USE_RELRO             = 0x8,\n\n  /* Instruct dlopen to use library_fd instead of opening file by name.\n   * The filename parameter is still used to identify the library.\n   */\n  ANDROID_DLEXT_USE_LIBRARY_FD        = 0x10,\n\n  /* Mask of valid bits */\n  ANDROID_DLEXT_VALID_FLAG_BITS       = ANDROID_DLEXT_RESERVED_ADDRESS |\n                                        ANDROID_DLEXT_RESERVED_ADDRESS_HINT |\n                                        ANDROID_DLEXT_WRITE_RELRO |\n                                        ANDROID_DLEXT_USE_RELRO |\n                                        ANDROID_DLEXT_USE_LIBRARY_FD,\n};\n\ntypedef struct {\n  uint64_t flags;\n  void*   reserved_addr;\n  size_t  reserved_size;\n  int     relro_fd;\n  int     library_fd;\n} android_dlextinfo;\n\nextern void* android_dlopen_ext(const char* filename, int flag, const android_dlextinfo* extinfo);\n\n__END_DECLS\n\n#endif /* __ANDROID_DLEXT_H__ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/include/freebsd/sys/sys/elf_common.h": "/*-\n * Copyright (c) 2017 Dell EMC\n * Copyright (c) 2000, 2001, 2008, 2011, David E. O'Brien\n * Copyright (c) 1998 John D. Polstra.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * $FreeBSD$\n */\n\n#ifndef _SYS_ELF_COMMON_H_\n#define _SYS_ELF_COMMON_H_ 1\n\n/*\n * ELF definitions that are independent of architecture or word size.\n */\n\n/*\n * Note header.  The \".note\" section contains an array of notes.  Each\n * begins with this header, aligned to a word boundary.  Immediately\n * following the note header is n_namesz bytes of name, padded to the\n * next word boundary.  Then comes n_descsz bytes of descriptor, again\n * padded to a word boundary.  The values of n_namesz and n_descsz do\n * not include the padding.\n */\n\ntypedef struct {\n  u_int32_t n_namesz; /* Length of name. */\n  u_int32_t n_descsz; /* Length of descriptor. */\n  u_int32_t n_type;   /* Type of this note. */\n} Elf_Note;\n\n/*\n * Option kinds.\n */\n#define ODK_NULL  0 /* undefined */\n#define ODK_REGINFO 1 /* register usage info */\n#define ODK_EXCEPTIONS  2 /* exception processing info */\n#define ODK_PAD   3 /* section padding */\n#define ODK_HWPATCH 4 /* hardware patch applied */\n#define ODK_FILL  5 /* fill value used by the linker */\n#define ODK_TAGS  6 /* reserved space for tools */\n#define ODK_HWAND 7 /* hardware AND patch applied */\n#define ODK_HWOR  8 /* hardware OR patch applied */\n#define ODK_GP_GROUP  9 /* GP group for text/data sections */\n#define ODK_IDENT 10  /* ID information */\n#define ODK_PAGESIZE  11  /* page size information */\n\n/*\n * ODK_EXCEPTIONS info field masks.\n */\n#define OEX_FPU_MIN 0x0000001f  /* min FPU exception required */\n#define OEX_FPU_MAX 0x00001f00  /* max FPU exception allowed */\n#define OEX_PAGE0 0x00010000  /* page zero must be mapped */\n#define OEX_SMM   0x00020000  /* run in sequential memory mode */\n#define OEX_PRECISEFP 0x00040000  /* run in precise FP exception mode */\n#define OEX_DISMISS 0x00080000  /* dismiss invalid address traps */\n\n/*\n * ODK_PAD info field masks.\n */\n#define OPAD_PREFIX 0x0001\n#define OPAD_POSTFIX  0x0002\n#define OPAD_SYMBOL 0x0004\n\n/*\n * ODK_HWPATCH info field masks.\n */\n#define OHW_R4KEOP  0x00000001  /* patch for R4000 branch at end-of-page bug */\n#define OHW_R8KPFETCH 0x00000002  /* R8000 prefetch bug may occur */\n#define OHW_R5KEOP  0x00000004  /* patch for R5000 branch at end-of-page bug */\n#define OHW_R5KCVTL 0x00000008  /* R5000 cvt.[ds].l bug: clean == 1 */\n#define OHW_R10KLDL 0x00000010UL  /* need patch for R10000 misaligned load */\n\n/*\n * ODK_HWAND/ODK_HWOR info field and hwp_flags[12] masks.\n */\n#define OHWA0_R4KEOP_CHECKED  0x00000001  /* object checked for R4000 end-of-page bug */\n#define OHWA0_R4KEOP_CLEAN  0x00000002  /* object verified clean for R4000 end-of-page bug */\n#define OHWO0_FIXADE    0x00000001  /* object requires call to fixade */\n\n/*\n * ODK_IDENT/ODK_GP_GROUP info field masks.\n */\n#define OGP_GROUP 0x0000ffff  /* GP group number */\n#define OGP_SELF  0x00010000  /* GP group is self-contained */\n\n/*\n * The header for GNU-style hash sections.\n */\n\ntypedef struct {\n  u_int32_t gh_nbuckets;  /* Number of hash buckets. */\n  u_int32_t gh_symndx;  /* First visible symbol in .dynsym. */\n  u_int32_t gh_maskwords; /* #maskwords used in bloom filter. */\n  u_int32_t gh_shift2;  /* Bloom filter shift count. */\n} Elf_GNU_Hash_Header;\n\n/* Indexes into the e_ident array.  Keep synced with\n   http://www.sco.com/developers/gabi/latest/ch4.eheader.html */\n#define EI_MAG0   0 /* Magic number, byte 0. */\n#define EI_MAG1   1 /* Magic number, byte 1. */\n#define EI_MAG2   2 /* Magic number, byte 2. */\n#define EI_MAG3   3 /* Magic number, byte 3. */\n#define EI_CLASS  4 /* Class of machine. */\n#define EI_DATA   5 /* Data format. */\n#define EI_VERSION  6 /* ELF format version. */\n#define EI_OSABI  7 /* Operating system / ABI identification */\n#define EI_ABIVERSION 8 /* ABI version */\n#define OLD_EI_BRAND  8 /* Start of architecture identification. */\n#define EI_PAD    9 /* Start of padding (per SVR4 ABI). */\n#define EI_NIDENT 16  /* Size of e_ident array. */\n\n/* Values for the magic number bytes. */\n#define ELFMAG0   0x7f\n#define ELFMAG1   'E'\n#define ELFMAG2   'L'\n#define ELFMAG3   'F'\n#define ELFMAG    \"\\177ELF\" /* magic string */\n#define SELFMAG   4   /* magic string size */\n\n/* Values for e_ident[EI_VERSION] and e_version. */\n#define EV_NONE   0\n#define EV_CURRENT  1\n\n/* Values for e_ident[EI_CLASS]. */\n#define ELFCLASSNONE  0 /* Unknown class. */\n#define ELFCLASS32  1 /* 32-bit architecture. */\n#define ELFCLASS64  2 /* 64-bit architecture. */\n\n/* Values for e_ident[EI_DATA]. */\n#define ELFDATANONE 0 /* Unknown data format. */\n#define ELFDATA2LSB 1 /* 2's complement little-endian. */\n#define ELFDATA2MSB 2 /* 2's complement big-endian. */\n\n/* Values for e_ident[EI_OSABI]. */\n#define ELFOSABI_NONE   0 /* UNIX System V ABI */\n#define ELFOSABI_HPUX   1 /* HP-UX operating system */\n#define ELFOSABI_NETBSD   2 /* NetBSD */\n#define ELFOSABI_LINUX    3 /* GNU/Linux */\n#define ELFOSABI_HURD   4 /* GNU/Hurd */\n#define ELFOSABI_86OPEN   5 /* 86Open common IA32 ABI */\n#define ELFOSABI_SOLARIS  6 /* Solaris */\n#define ELFOSABI_AIX    7 /* AIX */\n#define ELFOSABI_IRIX   8 /* IRIX */\n#define ELFOSABI_FREEBSD  9 /* FreeBSD */\n#define ELFOSABI_TRU64    10  /* TRU64 UNIX */\n#define ELFOSABI_MODESTO  11  /* Novell Modesto */\n#define ELFOSABI_OPENBSD  12  /* OpenBSD */\n#define ELFOSABI_OPENVMS  13  /* Open VMS */\n#define ELFOSABI_NSK    14  /* HP Non-Stop Kernel */\n#define ELFOSABI_AROS   15  /* Amiga Research OS */\n#define ELFOSABI_FENIXOS  16  /* FenixOS */\n#define ELFOSABI_CLOUDABI 17  /* Nuxi CloudABI */\n#define ELFOSABI_ARM_AEABI  64  /* ARM EABI */\n#define ELFOSABI_ARM    97  /* ARM */\n#define ELFOSABI_STANDALONE 255 /* Standalone (embedded) application */\n\n#define ELFOSABI_SYSV   ELFOSABI_NONE /* symbol used in old spec */\n#define ELFOSABI_MONTEREY ELFOSABI_AIX  /* Monterey */\n#define ELFOSABI_GNU    ELFOSABI_LINUX\n\n/* e_ident */\n#define IS_ELF(ehdr)  ((ehdr).e_ident[EI_MAG0] == ELFMAG0 && \\\n       (ehdr).e_ident[EI_MAG1] == ELFMAG1 && \\\n       (ehdr).e_ident[EI_MAG2] == ELFMAG2 && \\\n       (ehdr).e_ident[EI_MAG3] == ELFMAG3)\n\n/* Values for e_type. */\n#define ET_NONE   0 /* Unknown type. */\n#define ET_REL    1 /* Relocatable. */\n#define ET_EXEC   2 /* Executable. */\n#define ET_DYN    3 /* Shared object. */\n#define ET_CORE   4 /* Core file. */\n#define ET_LOOS   0xfe00  /* First operating system specific. */\n#define ET_HIOS   0xfeff  /* Last operating system-specific. */\n#define ET_LOPROC 0xff00  /* First processor-specific. */\n#define ET_HIPROC 0xffff  /* Last processor-specific. */\n\n/* Values for e_machine. */\n#define EM_NONE   0 /* Unknown machine. */\n#define EM_M32    1 /* AT&T WE32100. */\n#define EM_SPARC  2 /* Sun SPARC. */\n#define EM_386    3 /* Intel i386. */\n#define EM_68K    4 /* Motorola 68000. */\n#define EM_88K    5 /* Motorola 88000. */\n#define EM_IAMCU  6 /* Intel MCU. */\n#define EM_860    7 /* Intel i860. */\n#define EM_MIPS   8 /* MIPS R3000 Big-Endian only. */\n#define EM_S370   9 /* IBM System/370. */\n#define EM_MIPS_RS3_LE  10  /* MIPS R3000 Little-Endian. */\n#define EM_PARISC 15  /* HP PA-RISC. */\n#define EM_VPP500 17  /* Fujitsu VPP500. */\n#define EM_SPARC32PLUS  18  /* SPARC v8plus. */\n#define EM_960    19  /* Intel 80960. */\n#define EM_PPC    20  /* PowerPC 32-bit. */\n#define EM_PPC64  21  /* PowerPC 64-bit. */\n#define EM_S390   22  /* IBM System/390. */\n#define EM_V800   36  /* NEC V800. */\n#define EM_FR20   37  /* Fujitsu FR20. */\n#define EM_RH32   38  /* TRW RH-32. */\n#define EM_RCE    39  /* Motorola RCE. */\n#define EM_ARM    40  /* ARM. */\n#define EM_SH   42  /* Hitachi SH. */\n#define EM_SPARCV9  43  /* SPARC v9 64-bit. */\n#define EM_TRICORE  44  /* Siemens TriCore embedded processor. */\n#define EM_ARC    45  /* Argonaut RISC Core. */\n#define EM_H8_300 46  /* Hitachi H8/300. */\n#define EM_H8_300H  47  /* Hitachi H8/300H. */\n#define EM_H8S    48  /* Hitachi H8S. */\n#define EM_H8_500 49  /* Hitachi H8/500. */\n#define EM_IA_64  50  /* Intel IA-64 Processor. */\n#define EM_MIPS_X 51  /* Stanford MIPS-X. */\n#define EM_COLDFIRE 52  /* Motorola ColdFire. */\n#define EM_68HC12 53  /* Motorola M68HC12. */\n#define EM_MMA    54  /* Fujitsu MMA. */\n#define EM_PCP    55  /* Siemens PCP. */\n#define EM_NCPU   56  /* Sony nCPU. */\n#define EM_NDR1   57  /* Denso NDR1 microprocessor. */\n#define EM_STARCORE 58  /* Motorola Star*Core processor. */\n#define EM_ME16   59  /* Toyota ME16 processor. */\n#define EM_ST100  60  /* STMicroelectronics ST100 processor. */\n#define EM_TINYJ  61  /* Advanced Logic Corp. TinyJ processor. */\n#define EM_X86_64 62  /* Advanced Micro Devices x86-64 */\n#define EM_AMD64  EM_X86_64 /* Advanced Micro Devices x86-64 (compat) */\n#define EM_PDSP   63  /* Sony DSP Processor. */\n#define EM_FX66   66  /* Siemens FX66 microcontroller. */\n#define EM_ST9PLUS  67  /* STMicroelectronics ST9+ 8/16\n           microcontroller. */\n#define EM_ST7    68  /* STmicroelectronics ST7 8-bit\n           microcontroller. */\n#define EM_68HC16 69  /* Motorola MC68HC16 microcontroller. */\n#define EM_68HC11 70  /* Motorola MC68HC11 microcontroller. */\n#define EM_68HC08 71  /* Motorola MC68HC08 microcontroller. */\n#define EM_68HC05 72  /* Motorola MC68HC05 microcontroller. */\n#define EM_SVX    73  /* Silicon Graphics SVx. */\n#define EM_ST19   74  /* STMicroelectronics ST19 8-bit mc. */\n#define EM_VAX    75  /* Digital VAX. */\n#define EM_CRIS   76  /* Axis Communications 32-bit embedded\n           processor. */\n#define EM_JAVELIN  77  /* Infineon Technologies 32-bit embedded\n           processor. */\n#define EM_FIREPATH 78  /* Element 14 64-bit DSP Processor. */\n#define EM_ZSP    79  /* LSI Logic 16-bit DSP Processor. */\n#define EM_MMIX   80  /* Donald Knuth's educational 64-bit proc. */\n#define EM_HUANY  81  /* Harvard University machine-independent\n           object files. */\n#define EM_PRISM  82  /* SiTera Prism. */\n#define EM_AVR    83  /* Atmel AVR 8-bit microcontroller. */\n#define EM_FR30   84  /* Fujitsu FR30. */\n#define EM_D10V   85  /* Mitsubishi D10V. */\n#define EM_D30V   86  /* Mitsubishi D30V. */\n#define EM_V850   87  /* NEC v850. */\n#define EM_M32R   88  /* Mitsubishi M32R. */\n#define EM_MN10300  89  /* Matsushita MN10300. */\n#define EM_MN10200  90  /* Matsushita MN10200. */\n#define EM_PJ   91  /* picoJava. */\n#define EM_OPENRISC 92  /* OpenRISC 32-bit embedded processor. */\n#define EM_ARC_A5 93  /* ARC Cores Tangent-A5. */\n#define EM_XTENSA 94  /* Tensilica Xtensa Architecture. */\n#define EM_VIDEOCORE  95  /* Alphamosaic VideoCore processor. */\n#define EM_TMM_GPP  96  /* Thompson Multimedia General Purpose\n           Processor. */\n#define EM_NS32K  97  /* National Semiconductor 32000 series. */\n#define EM_TPC    98  /* Tenor Network TPC processor. */\n#define EM_SNP1K  99  /* Trebia SNP 1000 processor. */\n#define EM_ST200  100 /* STMicroelectronics ST200 microcontroller. */\n#define EM_IP2K   101 /* Ubicom IP2xxx microcontroller family. */\n#define EM_MAX    102 /* MAX Processor. */\n#define EM_CR   103 /* National Semiconductor CompactRISC\n           microprocessor. */\n#define EM_F2MC16 104 /* Fujitsu F2MC16. */\n#define EM_MSP430 105 /* Texas Instruments embedded microcontroller\n           msp430. */\n#define EM_BLACKFIN 106 /* Analog Devices Blackfin (DSP) processor. */\n#define EM_SE_C33 107 /* S1C33 Family of Seiko Epson processors. */\n#define EM_SEP    108 /* Sharp embedded microprocessor. */\n#define EM_ARCA   109 /* Arca RISC Microprocessor. */\n#define EM_UNICORE  110 /* Microprocessor series from PKU-Unity Ltd.\n           and MPRC of Peking University */\n#define EM_AARCH64  183 /* AArch64 (64-bit ARM) */\n#define EM_RISCV  243 /* RISC-V */\n\n/* Non-standard or deprecated. */\n#define EM_486    6 /* Intel i486. */\n#define EM_MIPS_RS4_BE  10  /* MIPS R4000 Big-Endian */\n#define EM_ALPHA_STD  41  /* Digital Alpha (standard value). */\n#define EM_ALPHA  0x9026  /* Alpha (written in the absence of an ABI) */\n\n/**\n * e_flags\n */\n#define EF_ARM_RELEXEC  0x1\n#define EF_ARM_HASENTRY 0x2\n#define EF_ARM_SYMSARESORTED  0x4\n#define EF_ARM_DYNSYMSUSESEGIDX 0x8\n#define EF_ARM_MAPSYMSFIRST 0x10\n#define EF_ARM_LE8    0x00400000\n#define EF_ARM_BE8    0x00800000\n#define EF_ARM_EABIMASK   0xFF000000\n#define EF_ARM_EABI_UNKNOWN 0x00000000\n#define EF_ARM_EABI_VER1  0x01000000\n#define EF_ARM_EABI_VER2  0x02000000\n#define EF_ARM_EABI_VER3  0x03000000\n#define EF_ARM_EABI_VER4  0x04000000\n#define EF_ARM_EABI_VER5  0x05000000\n#define EF_ARM_INTERWORK  0x00000004\n#define EF_ARM_APCS_26    0x00000008\n#define EF_ARM_APCS_FLOAT 0x00000010\n#define EF_ARM_PIC    0x00000020\n#define EF_ARM_ALIGN8   0x00000040\n#define EF_ARM_NEW_ABI    0x00000080\n#define EF_ARM_OLD_ABI    0x00000100\n#define EF_ARM_SOFT_FLOAT 0x00000200\n#define EF_ARM_VFP_FLOAT  0x00000400\n#define EF_ARM_MAVERICK_FLOAT 0x00000800\n\n#define EF_MIPS_NOREORDER 0x00000001\n#define EF_MIPS_PIC   0x00000002  /* Contains PIC code */\n#define EF_MIPS_CPIC    0x00000004  /* STD PIC calling sequence */\n#define EF_MIPS_UCODE   0x00000010\n#define EF_MIPS_ABI2    0x00000020  /* N32 */\n#define EF_MIPS_OPTIONS_FIRST 0x00000080\n#define EF_MIPS_ARCH_ASE  0x0F000000  /* Architectural extensions */\n#define EF_MIPS_ARCH_ASE_MDMX 0x08000000  /* MDMX multimedia extension */\n#define EF_MIPS_ARCH_ASE_M16  0x04000000  /* MIPS-16 ISA extensions */\n#define EF_MIPS_ARCH    0xF0000000  /* Architecture field */\n\n#define EF_PPC_EMB    0x80000000\n#define EF_PPC_RELOCATABLE  0x00010000\n#define EF_PPC_RELOCATABLE_LIB  0x00008000\n\n#define EF_SPARC_EXT_MASK 0x00ffff00\n#define EF_SPARC_32PLUS   0x00000100\n#define EF_SPARC_SUN_US1  0x00000200\n#define EF_SPARC_HAL_R1   0x00000200\n#define EF_SPARC_SUN_US3  0x00000800\n\n#define EF_SPARCV9_MM   0x00000003\n#define EF_SPARCV9_TSO    0x00000000\n#define EF_SPARCV9_PSO    0x00000001\n#define EF_SPARCV9_RMO    0x00000002\n\n/* Special section indexes. */\n#define SHN_UNDEF      0    /* Undefined, missing, irrelevant. */\n#define SHN_LORESERVE 0xff00    /* First of reserved range. */\n#define SHN_LOPROC  0xff00    /* First processor-specific. */\n#define SHN_HIPROC  0xff1f    /* Last processor-specific. */\n#define SHN_LOOS  0xff20    /* First operating system-specific. */\n#define SHN_FBSD_CACHED SHN_LOOS  /* Transient, for sys/kern/link_elf_obj\n             linker only: Cached global in local\n             symtab. */\n#define SHN_HIOS  0xff3f    /* Last operating system-specific. */\n#define SHN_ABS   0xfff1    /* Absolute values. */\n#define SHN_COMMON  0xfff2    /* Common data. */\n#define SHN_XINDEX  0xffff    /* Escape -- index stored elsewhere. */\n#define SHN_HIRESERVE 0xffff    /* Last of reserved range. */\n\n/* sh_type */\n#define SHT_NULL    0 /* inactive */\n#define SHT_PROGBITS    1 /* program defined information */\n#define SHT_SYMTAB    2 /* symbol table section */\n#define SHT_STRTAB    3 /* string table section */\n#define SHT_RELA    4 /* relocation section with addends */\n#define SHT_HASH    5 /* symbol hash table section */\n#define SHT_DYNAMIC   6 /* dynamic section */\n#define SHT_NOTE    7 /* note section */\n#define SHT_NOBITS    8 /* no space section */\n#define SHT_REL     9 /* relocation section - no addends */\n#define SHT_SHLIB   10  /* reserved - purpose unknown */\n#define SHT_DYNSYM    11  /* dynamic symbol table section */\n#define SHT_INIT_ARRAY    14  /* Initialization function pointers. */\n#define SHT_FINI_ARRAY    15  /* Termination function pointers. */\n#define SHT_PREINIT_ARRAY 16  /* Pre-initialization function ptrs. */\n#define SHT_GROUP   17  /* Section group. */\n#define SHT_SYMTAB_SHNDX  18  /* Section indexes (see SHN_XINDEX). */\n#define SHT_LOOS    0x60000000  /* First of OS specific semantics */\n#define SHT_LOSUNW    0x6ffffff4\n#define SHT_SUNW_dof    0x6ffffff4\n#define SHT_SUNW_cap    0x6ffffff5\n#define SHT_GNU_ATTRIBUTES  0x6ffffff5\n#define SHT_SUNW_SIGNATURE  0x6ffffff6\n#define SHT_GNU_HASH    0x6ffffff6\n#define SHT_GNU_LIBLIST   0x6ffffff7\n#define SHT_SUNW_ANNOTATE 0x6ffffff7\n#define SHT_SUNW_DEBUGSTR 0x6ffffff8\n#define SHT_SUNW_DEBUG    0x6ffffff9\n#define SHT_SUNW_move   0x6ffffffa\n#define SHT_SUNW_COMDAT   0x6ffffffb\n#define SHT_SUNW_syminfo  0x6ffffffc\n#define SHT_SUNW_verdef   0x6ffffffd\n#define SHT_GNU_verdef    0x6ffffffd  /* Symbol versions provided */\n#define SHT_SUNW_verneed  0x6ffffffe\n#define SHT_GNU_verneed   0x6ffffffe  /* Symbol versions required */\n#define SHT_SUNW_versym   0x6fffffff\n#define SHT_GNU_versym    0x6fffffff  /* Symbol version table */\n#define SHT_HISUNW    0x6fffffff\n#define SHT_HIOS    0x6fffffff  /* Last of OS specific semantics */\n#define SHT_LOPROC    0x70000000  /* reserved range for processor */\n#define SHT_X86_64_UNWIND 0x70000001  /* unwind information */\n#define SHT_AMD64_UNWIND  SHT_X86_64_UNWIND \n\n#define SHT_ARM_EXIDX   0x70000001  /* Exception index table. */\n#define SHT_ARM_PREEMPTMAP  0x70000002  /* BPABI DLL dynamic linking \n               pre-emption map. */\n#define SHT_ARM_ATTRIBUTES  0x70000003  /* Object file compatibility \n               attributes. */\n#define SHT_ARM_DEBUGOVERLAY  0x70000004  /* See DBGOVL for details. */\n#define SHT_ARM_OVERLAYSECTION  0x70000005  /* See DBGOVL for details. */\n#define SHT_MIPS_LIBLIST  0x70000000\n#define SHT_MIPS_MSYM   0x70000001\n#define SHT_MIPS_CONFLICT 0x70000002\n#define SHT_MIPS_GPTAB    0x70000003\n#define SHT_MIPS_UCODE    0x70000004\n#define SHT_MIPS_DEBUG    0x70000005\n#define SHT_MIPS_REGINFO  0x70000006\n#define SHT_MIPS_PACKAGE  0x70000007\n#define SHT_MIPS_PACKSYM  0x70000008\n#define SHT_MIPS_RELD   0x70000009\n#define SHT_MIPS_IFACE    0x7000000b\n#define SHT_MIPS_CONTENT  0x7000000c\n#define SHT_MIPS_OPTIONS  0x7000000d\n#define SHT_MIPS_DELTASYM 0x7000001b\n#define SHT_MIPS_DELTAINST  0x7000001c\n#define SHT_MIPS_DELTACLASS 0x7000001d\n#define SHT_MIPS_DWARF    0x7000001e  /* MIPS gcc uses MIPS_DWARF */\n#define SHT_MIPS_DELTADECL  0x7000001f\n#define SHT_MIPS_SYMBOL_LIB 0x70000020\n#define SHT_MIPS_EVENTS   0x70000021\n#define SHT_MIPS_TRANSLATE  0x70000022\n#define SHT_MIPS_PIXIE    0x70000023\n#define SHT_MIPS_XLATE    0x70000024\n#define SHT_MIPS_XLATE_DEBUG  0x70000025\n#define SHT_MIPS_WHIRL    0x70000026\n#define SHT_MIPS_EH_REGION  0x70000027\n#define SHT_MIPS_XLATE_OLD  0x70000028\n#define SHT_MIPS_PDR_EXCEPTION  0x70000029\n#define SHT_MIPS_ABIFLAGS 0x7000002a\n\n#define SHT_SPARC_GOTDATA 0x70000000\n\n#define SHTORDERED\n#define SHT_HIPROC    0x7fffffff  /* specific section header types */\n#define SHT_LOUSER    0x80000000  /* reserved range for application */\n#define SHT_HIUSER    0xffffffff  /* specific indexes */\n\n/* Flags for sh_flags. */\n#define SHF_WRITE   0x1 /* Section contains writable data. */\n#define SHF_ALLOC   0x2 /* Section occupies memory. */\n#define SHF_EXECINSTR   0x4 /* Section contains instructions. */\n#define SHF_MERGE   0x10  /* Section may be merged. */\n#define SHF_STRINGS   0x20  /* Section contains strings. */\n#define SHF_INFO_LINK   0x40  /* sh_info holds section index. */\n#define SHF_LINK_ORDER    0x80  /* Special ordering requirements. */\n#define SHF_OS_NONCONFORMING  0x100 /* OS-specific processing required. */\n#define SHF_GROUP   0x200 /* Member of section group. */\n#define SHF_TLS     0x400 /* Section contains TLS data. */\n#define SHF_COMPRESSED    0x800 /* Section contains compressed data. */\n#define SHF_MASKOS  0x0ff00000  /* OS-specific semantics. */\n#define SHF_MASKPROC  0xf0000000  /* Processor-specific semantics. */\n\n/* Flags for section groups. */\n#define GRP_COMDAT  0x1 /* COMDAT semantics. */\n\n/*\n * Flags / mask for .gnu.versym sections.\n */\n#define VERSYM_VERSION  0x7fff\n#define VERSYM_HIDDEN 0x8000\n\n/* Values for p_type. */\n#define PT_NULL   0 /* Unused entry. */\n#define PT_LOAD   1 /* Loadable segment. */\n#define PT_DYNAMIC  2 /* Dynamic linking information segment. */\n#define PT_INTERP 3 /* Pathname of interpreter. */\n#define PT_NOTE   4 /* Auxiliary information. */\n#define PT_SHLIB  5 /* Reserved (not used). */\n#define PT_PHDR   6 /* Location of program header itself. */\n#define PT_TLS    7 /* Thread local storage segment */\n#define PT_LOOS   0x60000000  /* First OS-specific. */\n#define PT_SUNW_UNWIND  0x6464e550  /* amd64 UNWIND program header */\n#define PT_GNU_EH_FRAME 0x6474e550\n#define PT_GNU_STACK  0x6474e551\n#define PT_GNU_RELRO  0x6474e552\n#define PT_DUMP_DELTA 0x6fb5d000  /* va->pa map for kernel dumps\n             (currently arm). */\n#define PT_LOSUNW 0x6ffffffa\n#define PT_SUNWBSS  0x6ffffffa  /* Sun Specific segment */\n#define PT_SUNWSTACK  0x6ffffffb  /* describes the stack segment */\n#define PT_SUNWDTRACE 0x6ffffffc  /* private */\n#define PT_SUNWCAP  0x6ffffffd  /* hard/soft capabilities segment */\n#define PT_HISUNW 0x6fffffff\n#define PT_HIOS   0x6fffffff  /* Last OS-specific. */\n#define PT_LOPROC 0x70000000  /* First processor-specific type. */\n#define PT_ARM_ARCHEXT  0x70000000  /* ARM arch compat information. */\n#define PT_ARM_EXIDX  0x70000001  /* ARM exception unwind tables. */\n#define PT_HIPROC 0x7fffffff  /* Last processor-specific type. */\n\n/* Values for p_flags. */\n#define PF_X    0x1   /* Executable. */\n#define PF_W    0x2   /* Writable. */\n#define PF_R    0x4   /* Readable. */\n#define PF_MASKOS 0x0ff00000  /* Operating system-specific. */\n#define PF_MASKPROC 0xf0000000  /* Processor-specific. */\n\n/* Extended program header index. */\n#define PN_XNUM   0xffff\n\n/* Values for d_tag. */\n#define DT_NULL   0 /* Terminating entry. */\n#define DT_NEEDED 1 /* String table offset of a needed shared\n           library. */\n#define DT_PLTRELSZ 2 /* Total size in bytes of PLT relocations. */\n#define DT_PLTGOT 3 /* Processor-dependent address. */\n#define DT_HASH   4 /* Address of symbol hash table. */\n#define DT_STRTAB 5 /* Address of string table. */\n#define DT_SYMTAB 6 /* Address of symbol table. */\n#define DT_RELA   7 /* Address of ElfNN_Rela relocations. */\n#define DT_RELASZ 8 /* Total size of ElfNN_Rela relocations. */\n#define DT_RELAENT  9 /* Size of each ElfNN_Rela relocation entry. */\n#define DT_STRSZ  10  /* Size of string table. */\n#define DT_SYMENT 11  /* Size of each symbol table entry. */\n#define DT_INIT   12  /* Address of initialization function. */\n#define DT_FINI   13  /* Address of finalization function. */\n#define DT_SONAME 14  /* String table offset of shared object\n           name. */\n#define DT_RPATH  15  /* String table offset of library path. [sup] */\n#define DT_SYMBOLIC 16  /* Indicates \"symbolic\" linking. [sup] */\n#define DT_REL    17  /* Address of ElfNN_Rel relocations. */\n#define DT_RELSZ  18  /* Total size of ElfNN_Rel relocations. */\n#define DT_RELENT 19  /* Size of each ElfNN_Rel relocation. */\n#define DT_PLTREL 20  /* Type of relocation used for PLT. */\n#define DT_DEBUG  21  /* Reserved (not used). */\n#define DT_TEXTREL  22  /* Indicates there may be relocations in\n           non-writable segments. [sup] */\n#define DT_JMPREL 23  /* Address of PLT relocations. */\n#define DT_BIND_NOW 24  /* [sup] */\n#define DT_INIT_ARRAY 25  /* Address of the array of pointers to\n           initialization functions */\n#define DT_FINI_ARRAY 26  /* Address of the array of pointers to\n           termination functions */\n#define DT_INIT_ARRAYSZ 27  /* Size in bytes of the array of\n           initialization functions. */\n#define DT_FINI_ARRAYSZ 28  /* Size in bytes of the array of\n           termination functions. */\n#define DT_RUNPATH  29  /* String table offset of a null-terminated\n           library search path string. */\n#define DT_FLAGS  30  /* Object specific flag values. */\n#define DT_ENCODING 32  /* Values greater than or equal to DT_ENCODING\n           and less than DT_LOOS follow the rules for\n           the interpretation of the d_un union\n           as follows: even == 'd_ptr', odd == 'd_val'\n           or none */\n#define DT_PREINIT_ARRAY 32 /* Address of the array of pointers to\n           pre-initialization functions. */\n#define DT_PREINIT_ARRAYSZ 33 /* Size in bytes of the array of\n           pre-initialization functions. */\n#define DT_MAXPOSTAGS 34  /* number of positive tags */\n#define DT_LOOS   0x6000000d  /* First OS-specific */\n#define DT_SUNW_AUXILIARY 0x6000000d  /* symbol auxiliary name */\n#define DT_SUNW_RTLDINF   0x6000000e  /* ld.so.1 info (private) */\n#define DT_SUNW_FILTER    0x6000000f  /* symbol filter name */\n#define DT_SUNW_CAP   0x60000010  /* hardware/software */\n#define DT_HIOS   0x6ffff000  /* Last OS-specific */\n\n/*\n * DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the\n * Dyn.d_un.d_val field of the Elf*_Dyn structure.\n */\n#define DT_VALRNGLO 0x6ffffd00\n#define DT_GNU_PRELINKED  0x6ffffdf5 /* prelinking timestamp */\n#define DT_GNU_CONFLICTSZ 0x6ffffdf6 /* size of conflict section */\n#define DT_GNU_LIBLISTSZ  0x6ffffdf7 /* size of library list */\n#define DT_CHECKSUM 0x6ffffdf8  /* elf checksum */\n#define DT_PLTPADSZ 0x6ffffdf9  /* pltpadding size */\n#define DT_MOVEENT  0x6ffffdfa  /* move table entry size */\n#define DT_MOVESZ 0x6ffffdfb  /* move table size */\n#define DT_FEATURE  0x6ffffdfc  /* feature holder */\n#define DT_FEATURE_1  DT_FEATURE\n#define DT_POSFLAG_1  0x6ffffdfd  /* flags for DT_* entries, effecting */\n          /*  the following DT_* entry. */\n          /*  See DF_P1_* definitions */\n#define DT_SYMINSZ  0x6ffffdfe  /* syminfo table size (in bytes) */\n#define DT_SYMINENT 0x6ffffdff  /* syminfo entry size (in bytes) */\n#define DT_VALRNGHI 0x6ffffdff\n\n/*\n * DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the\n * Dyn.d_un.d_ptr field of the Elf*_Dyn structure.\n *\n * If any adjustment is made to the ELF object after it has been\n * built, these entries will need to be adjusted.\n */\n#define DT_ADDRRNGLO  0x6ffffe00\n#define DT_GNU_HASH 0x6ffffef5  /* GNU-style hash table */\n#define DT_TLSDESC_PLT  0x6ffffef6  /* loc. of PLT for tlsdesc resolver */\n#define DT_TLSDESC_GOT  0x6ffffef7  /* loc. of GOT for tlsdesc resolver */\n#define DT_GNU_CONFLICT 0x6ffffef8  /* address of conflict section */\n#define DT_GNU_LIBLIST  0x6ffffef9  /* address of library list */\n#define DT_CONFIG 0x6ffffefa  /* configuration information */\n#define DT_DEPAUDIT 0x6ffffefb  /* dependency auditing */\n#define DT_AUDIT  0x6ffffefc  /* object auditing */\n#define DT_PLTPAD 0x6ffffefd  /* pltpadding (sparcv9) */\n#define DT_MOVETAB  0x6ffffefe  /* move table */\n#define DT_SYMINFO  0x6ffffeff  /* syminfo table */\n#define DT_ADDRRNGHI  0x6ffffeff\n\n#define DT_VERSYM 0x6ffffff0  /* Address of versym section. */\n#define DT_RELACOUNT  0x6ffffff9  /* number of RELATIVE relocations */\n#define DT_RELCOUNT 0x6ffffffa  /* number of RELATIVE relocations */\n#define DT_FLAGS_1  0x6ffffffb  /* state flags - see DF_1_* defs */\n#define DT_VERDEF 0x6ffffffc  /* Address of verdef section. */\n#define DT_VERDEFNUM  0x6ffffffd  /* Number of elems in verdef section */\n#define DT_VERNEED  0x6ffffffe  /* Address of verneed section. */\n#define DT_VERNEEDNUM 0x6fffffff  /* Number of elems in verneed section */\n\n#define DT_LOPROC 0x70000000  /* First processor-specific type. */\n\n#define DT_ARM_SYMTABSZ     0x70000001\n#define DT_ARM_PREEMPTMAP   0x70000002\n\n#define DT_SPARC_REGISTER   0x70000001\n#define DT_DEPRECATED_SPARC_REGISTER  0x7000001\n\n#define DT_MIPS_RLD_VERSION   0x70000001\n#define DT_MIPS_TIME_STAMP    0x70000002\n#define DT_MIPS_ICHECKSUM   0x70000003\n#define DT_MIPS_IVERSION    0x70000004\n#define DT_MIPS_FLAGS     0x70000005\n#define DT_MIPS_BASE_ADDRESS    0x70000006\n#define DT_MIPS_CONFLICT    0x70000008\n#define DT_MIPS_LIBLIST     0x70000009\n#define DT_MIPS_LOCAL_GOTNO   0x7000000a\n#define DT_MIPS_CONFLICTNO    0x7000000b\n#define DT_MIPS_LIBLISTNO   0x70000010\n#define DT_MIPS_SYMTABNO    0x70000011\n#define DT_MIPS_UNREFEXTNO    0x70000012\n#define DT_MIPS_GOTSYM      0x70000013\n#define DT_MIPS_HIPAGENO    0x70000014\n#define DT_MIPS_RLD_MAP     0x70000016\n#define DT_MIPS_DELTA_CLASS   0x70000017\n#define DT_MIPS_DELTA_CLASS_NO    0x70000018\n#define DT_MIPS_DELTA_INSTANCE    0x70000019\n#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001A\n#define DT_MIPS_DELTA_RELOC   0x7000001B\n#define DT_MIPS_DELTA_RELOC_NO    0x7000001C\n#define DT_MIPS_DELTA_SYM   0x7000001D\n#define DT_MIPS_DELTA_SYM_NO    0x7000001E\n#define DT_MIPS_DELTA_CLASSSYM    0x70000020\n#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021\n#define DT_MIPS_CXX_FLAGS   0x70000022\n#define DT_MIPS_PIXIE_INIT    0x70000023\n#define DT_MIPS_SYMBOL_LIB    0x70000024\n#define DT_MIPS_LOCALPAGE_GOTIDX  0x70000025\n#define DT_MIPS_LOCAL_GOTIDX    0x70000026\n#define DT_MIPS_HIDDEN_GOTIDX   0x70000027\n#define DT_MIPS_PROTECTED_GOTIDX  0x70000028\n#define DT_MIPS_OPTIONS     0x70000029\n#define DT_MIPS_INTERFACE   0x7000002A\n#define DT_MIPS_DYNSTR_ALIGN    0x7000002B\n#define DT_MIPS_INTERFACE_SIZE    0x7000002C\n#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002D\n#define DT_MIPS_PERF_SUFFIX   0x7000002E\n#define DT_MIPS_COMPACT_SIZE    0x7000002F\n#define DT_MIPS_GP_VALUE    0x70000030\n#define DT_MIPS_AUX_DYNAMIC   0x70000031\n#define DT_MIPS_PLTGOT      0x70000032\n#define DT_MIPS_RLD_OBJ_UPDATE    0x70000033\n#define DT_MIPS_RWPLT     0x70000034\n\n#define DT_PPC_GOT      0x70000000\n#define DT_PPC_TLSOPT     0x70000001\n\n#define DT_PPC64_GLINK      0x70000000\n#define DT_PPC64_OPD      0x70000001\n#define DT_PPC64_OPDSZ      0x70000002\n#define DT_PPC64_TLSOPT     0x70000003\n\n#define DT_AUXILIARY  0x7ffffffd  /* shared library auxiliary name */\n#define DT_USED   0x7ffffffe  /* ignored - same as needed */\n#define DT_FILTER 0x7fffffff  /* shared library filter name */\n#define DT_HIPROC 0x7fffffff  /* Last processor-specific type. */\n\n/* Values for DT_FLAGS */\n#define DF_ORIGIN 0x0001  /* Indicates that the object being loaded may\n           make reference to the $ORIGIN substitution\n           string */\n#define DF_SYMBOLIC 0x0002  /* Indicates \"symbolic\" linking. */\n#define DF_TEXTREL  0x0004  /* Indicates there may be relocations in\n           non-writable segments. */\n#define DF_BIND_NOW 0x0008  /* Indicates that the dynamic linker should\n           process all relocations for the object\n           containing this entry before transferring\n           control to the program. */\n#define DF_STATIC_TLS 0x0010  /* Indicates that the shared object or\n           executable contains code using a static\n           thread-local storage scheme. */\n\n/* Values for DT_FLAGS_1 */\n#define DF_1_BIND_NOW 0x00000001  /* Same as DF_BIND_NOW */\n#define DF_1_GLOBAL 0x00000002  /* Set the RTLD_GLOBAL for object */\n#define DF_1_NODELETE 0x00000008  /* Set the RTLD_NODELETE for object */\n#define DF_1_LOADFLTR 0x00000010  /* Immediate loading of filtees */\n#define DF_1_NOOPEN     0x00000040  /* Do not allow loading on dlopen() */\n#define DF_1_ORIGIN 0x00000080  /* Process $ORIGIN */\n#define DF_1_INTERPOSE  0x00000400  /* Interpose all objects but main */\n#define DF_1_NODEFLIB 0x00000800  /* Do not search default paths */\n\n/* Values for l_flags. */\n#define LL_NONE     0x0 /* no flags */\n#define LL_EXACT_MATCH    0x1 /* require an exact match */\n#define LL_IGNORE_INT_VER 0x2 /* ignore version incompatibilities */\n#define LL_REQUIRE_MINOR  0x4\n#define LL_EXPORTS    0x8\n#define LL_DELAY_LOAD   0x10\n#define LL_DELTA    0x20\n\n/* Values for n_type used in executables. */\n#define NT_FREEBSD_ABI_TAG  1\n#define NT_FREEBSD_NOINIT_TAG 2\n#define NT_FREEBSD_ARCH_TAG 3\n\n/* Values for n_type.  Used in core files. */\n#define NT_PRSTATUS 1 /* Process status. */\n#define NT_FPREGSET 2 /* Floating point registers. */\n#define NT_PRPSINFO 3 /* Process state info. */\n#define NT_THRMISC  7 /* Thread miscellaneous info. */\n#define NT_PROCSTAT_PROC  8 /* Procstat proc data. */\n#define NT_PROCSTAT_FILES 9 /* Procstat files data. */\n#define NT_PROCSTAT_VMMAP 10  /* Procstat vmmap data. */\n#define NT_PROCSTAT_GROUPS  11  /* Procstat groups data. */\n#define NT_PROCSTAT_UMASK 12  /* Procstat umask data. */\n#define NT_PROCSTAT_RLIMIT  13  /* Procstat rlimit data. */\n#define NT_PROCSTAT_OSREL 14  /* Procstat osreldate data. */\n#define NT_PROCSTAT_PSSTRINGS 15  /* Procstat ps_strings data. */\n#define NT_PROCSTAT_AUXV  16  /* Procstat auxv data. */\n#define NT_PTLWPINFO    17  /* Thread ptrace miscellaneous info. */\n#define NT_PPC_VMX  0x100 /* PowerPC Altivec/VMX registers */\n#define NT_X86_XSTATE 0x202 /* x86 XSAVE extended state. */\n#define NT_ARM_VFP  0x400 /* ARM VFP registers */\n\n/* Symbol Binding - ELFNN_ST_BIND - st_info */\n#define STB_LOCAL 0 /* Local symbol */\n#define STB_GLOBAL  1 /* Global symbol */\n#define STB_WEAK  2 /* like global - lower precedence */\n#define STB_LOOS  10  /* Start of operating system reserved range. */\n#define STB_GNU_UNIQUE  10  /* Unique symbol (GNU) */\n#define STB_HIOS  12  /* End of operating system reserved range. */\n#define STB_LOPROC  13  /* reserved range for processor */\n#define STB_HIPROC  15  /*   specific semantics. */\n\n/* Symbol type - ELFNN_ST_TYPE - st_info */\n#define STT_NOTYPE  0 /* Unspecified type. */\n#define STT_OBJECT  1 /* Data object. */\n#define STT_FUNC  2 /* Function. */\n#define STT_SECTION 3 /* Section. */\n#define STT_FILE  4 /* Source file. */\n#define STT_COMMON  5 /* Uninitialized common block. */\n#define STT_TLS   6 /* TLS object. */\n#define STT_NUM   7\n#define STT_LOOS  10  /* Reserved range for operating system */\n#define STT_GNU_IFUNC 10\n#define STT_HIOS  12  /*   specific semantics. */\n#define STT_LOPROC  13  /* Start of processor reserved range. */\n#define STT_SPARC_REGISTER 13 /* SPARC register information. */\n#define STT_HIPROC  15  /* End of processor reserved range. */\n\n/* Symbol visibility - ELFNN_ST_VISIBILITY - st_other */\n#define STV_DEFAULT 0x0 /* Default visibility (see binding). */\n#define STV_INTERNAL  0x1 /* Special meaning in relocatable objects. */\n#define STV_HIDDEN  0x2 /* Not visible. */\n#define STV_PROTECTED 0x3 /* Visible but not preemptible. */\n#define STV_EXPORTED  0x4\n#define STV_SINGLETON 0x5\n#define STV_ELIMINATE 0x6\n\n/* Special symbol table indexes. */\n#define STN_UNDEF 0 /* Undefined symbol index. */\n\n/* Symbol versioning flags. */\n#define VER_DEF_CURRENT 1\n#define VER_DEF_IDX(x)  VER_NDX(x)\n\n#define VER_FLG_BASE  0x01\n#define VER_FLG_WEAK  0x02\n\n#define VER_NEED_CURRENT  1\n#define VER_NEED_WEAK (1u << 15)\n#define VER_NEED_HIDDEN VER_NDX_HIDDEN\n#define VER_NEED_IDX(x) VER_NDX(x)\n\n#define VER_NDX_LOCAL 0\n#define VER_NDX_GLOBAL  1\n#define VER_NDX_GIVEN 2\n\n#define VER_NDX_HIDDEN  (1u << 15)\n#define VER_NDX(x)  ((x) & ~(1u << 15))\n\n#define CA_SUNW_NULL  0\n#define CA_SUNW_HW_1  1   /* first hardware capabilities entry */\n#define CA_SUNW_SF_1  2   /* first software capabilities entry */\n\n/*\n * Syminfo flag values\n */\n#define SYMINFO_FLG_DIRECT  0x0001  /* symbol ref has direct association */\n          /*  to object containing defn. */\n#define SYMINFO_FLG_PASSTHRU  0x0002  /* ignored - see SYMINFO_FLG_FILTER */\n#define SYMINFO_FLG_COPY  0x0004  /* symbol is a copy-reloc */\n#define SYMINFO_FLG_LAZYLOAD  0x0008  /* object containing defn should be */\n          /*  lazily-loaded */\n#define SYMINFO_FLG_DIRECTBIND  0x0010  /* ref should be bound directly to */\n          /*  object containing defn. */\n#define SYMINFO_FLG_NOEXTDIRECT 0x0020  /* don't let an external reference */\n          /*  directly bind to this symbol */\n#define SYMINFO_FLG_FILTER  0x0002  /* symbol ref is associated to a */\n#define SYMINFO_FLG_AUXILIARY 0x0040  /*  standard or auxiliary filter */\n\n/*\n * Syminfo.si_boundto values.\n */\n#define SYMINFO_BT_SELF   0xffff  /* symbol bound to self */\n#define SYMINFO_BT_PARENT 0xfffe  /* symbol bound to parent */\n#define SYMINFO_BT_NONE   0xfffd  /* no special symbol binding */\n#define SYMINFO_BT_EXTERN 0xfffc  /* symbol defined as external */\n#define SYMINFO_BT_LOWRESERVE 0xff00  /* beginning of reserved entries */\n\n/*\n * Syminfo version values.\n */\n#define SYMINFO_NONE    0 /* Syminfo version */\n#define SYMINFO_CURRENT   1\n#define SYMINFO_NUM   2\n\n/* Values for ch_type (compressed section headers). */\n#define ELFCOMPRESS_ZLIB  1 /* ZLIB/DEFLATE */\n#define ELFCOMPRESS_LOOS  0x60000000  /* OS-specific */\n#define ELFCOMPRESS_HIOS  0x6fffffff\n#define ELFCOMPRESS_LOPROC  0x70000000  /* Processor-specific */\n#define ELFCOMPRESS_HIPROC  0x7fffffff\n\n/*\n * Relocation types.\n *\n * All machine architectures are defined here to allow tools on one to\n * handle others.\n */\n\n#define R_386_NONE    0 /* No relocation. */\n#define R_386_32    1 /* Add symbol value. */\n#define R_386_PC32    2 /* Add PC-relative symbol value. */\n#define R_386_GOT32   3 /* Add PC-relative GOT offset. */\n#define R_386_PLT32   4 /* Add PC-relative PLT offset. */\n#define R_386_COPY    5 /* Copy data from shared object. */\n#define R_386_GLOB_DAT    6 /* Set GOT entry to data address. */\n#define R_386_JMP_SLOT    7 /* Set GOT entry to code address. */\n#define R_386_RELATIVE    8 /* Add load address of shared object. */\n#define R_386_GOTOFF    9 /* Add GOT-relative symbol address. */\n#define R_386_GOTPC   10  /* Add PC-relative GOT table address. */\n#define R_386_TLS_TPOFF   14  /* Negative offset in static TLS block */\n#define R_386_TLS_IE    15  /* Absolute address of GOT for -ve static TLS */\n#define R_386_TLS_GOTIE   16  /* GOT entry for negative static TLS block */\n#define R_386_TLS_LE    17  /* Negative offset relative to static TLS */\n#define R_386_TLS_GD    18  /* 32 bit offset to GOT (index,off) pair */\n#define R_386_TLS_LDM   19  /* 32 bit offset to GOT (index,zero) pair */\n#define R_386_TLS_GD_32   24  /* 32 bit offset to GOT (index,off) pair */\n#define R_386_TLS_GD_PUSH 25  /* pushl instruction for Sun ABI GD sequence */\n#define R_386_TLS_GD_CALL 26  /* call instruction for Sun ABI GD sequence */\n#define R_386_TLS_GD_POP  27  /* popl instruction for Sun ABI GD sequence */\n#define R_386_TLS_LDM_32  28  /* 32 bit offset to GOT (index,zero) pair */\n#define R_386_TLS_LDM_PUSH  29  /* pushl instruction for Sun ABI LD sequence */\n#define R_386_TLS_LDM_CALL  30  /* call instruction for Sun ABI LD sequence */\n#define R_386_TLS_LDM_POP 31  /* popl instruction for Sun ABI LD sequence */\n#define R_386_TLS_LDO_32  32  /* 32 bit offset from start of TLS block */\n#define R_386_TLS_IE_32   33  /* 32 bit offset to GOT static TLS offset entry */\n#define R_386_TLS_LE_32   34  /* 32 bit offset within static TLS block */\n#define R_386_TLS_DTPMOD32  35  /* GOT entry containing TLS index */\n#define R_386_TLS_DTPOFF32  36  /* GOT entry containing TLS offset */\n#define R_386_TLS_TPOFF32 37  /* GOT entry of -ve static TLS offset */\n#define R_386_IRELATIVE   42  /* PLT entry resolved indirectly at runtime */\n\n#define R_AARCH64_NONE    0 /* No relocation */\n#define R_AARCH64_ABS64   257 /* Absolute offset */\n#define R_AARCH64_ABS32   258 /* Absolute, 32-bit overflow check */\n#define R_AARCH64_ABS16   259 /* Absolute, 16-bit overflow check */\n#define R_AARCH64_PREL64  260 /* PC relative */\n#define R_AARCH64_PREL32  261 /* PC relative, 32-bit overflow check */\n#define R_AARCH64_PREL16  262 /* PC relative, 16-bit overflow check */\n#define R_AARCH64_COPY    1024  /* Copy data from shared object */\n#define R_AARCH64_GLOB_DAT  1025  /* Set GOT entry to data address */\n#define R_AARCH64_JUMP_SLOT 1026  /* Set GOT entry to code address */\n#define R_AARCH64_RELATIVE  1027  /* Add load address of shared object */\n#define R_AARCH64_TLS_DTPREL64  1028\n#define R_AARCH64_TLS_DTPMOD64  1029\n#define R_AARCH64_TLS_TPREL64   1030\n#define R_AARCH64_TLSDESC   1031  /* Identify the TLS descriptor */\n#define R_AARCH64_IRELATIVE 1032\n\n#define R_ARM_NONE    0 /* No relocation. */\n#define R_ARM_PC24    1\n#define R_ARM_ABS32   2\n#define R_ARM_REL32   3\n#define R_ARM_PC13    4\n#define R_ARM_ABS16   5\n#define R_ARM_ABS12   6\n#define R_ARM_THM_ABS5    7\n#define R_ARM_ABS8    8\n#define R_ARM_SBREL32   9\n#define R_ARM_THM_PC22    10\n#define R_ARM_THM_PC8   11\n#define R_ARM_AMP_VCALL9  12\n#define R_ARM_SWI24   13\n#define R_ARM_THM_SWI8    14\n#define R_ARM_XPC25   15\n#define R_ARM_THM_XPC22   16\n/* TLS relocations */\n#define R_ARM_TLS_DTPMOD32  17  /* ID of module containing symbol */\n#define R_ARM_TLS_DTPOFF32  18  /* Offset in TLS block */\n#define R_ARM_TLS_TPOFF32 19  /* Offset in static TLS block */\n#define R_ARM_COPY    20  /* Copy data from shared object. */\n#define R_ARM_GLOB_DAT    21  /* Set GOT entry to data address. */\n#define R_ARM_JUMP_SLOT   22  /* Set GOT entry to code address. */\n#define R_ARM_RELATIVE    23  /* Add load address of shared object. */\n#define R_ARM_GOTOFF    24  /* Add GOT-relative symbol address. */\n#define R_ARM_GOTPC   25  /* Add PC-relative GOT table address. */\n#define R_ARM_GOT32   26  /* Add PC-relative GOT offset. */\n#define R_ARM_PLT32   27  /* Add PC-relative PLT offset. */\n#define R_ARM_GNU_VTENTRY 100\n#define R_ARM_GNU_VTINHERIT 101\n#define R_ARM_RSBREL32    250\n#define R_ARM_THM_RPC22   251\n#define R_ARM_RREL32    252\n#define R_ARM_RABS32    253\n#define R_ARM_RPC24   254\n#define R_ARM_RBASE   255\n\n/*  Name      Value    Field  Calculation */\n#define R_IA_64_NONE    0 /* None */\n#define R_IA_64_IMM14   0x21  /* immediate14  S + A */\n#define R_IA_64_IMM22   0x22  /* immediate22  S + A */\n#define R_IA_64_IMM64   0x23  /* immediate64  S + A */\n#define R_IA_64_DIR32MSB  0x24  /* word32 MSB S + A */\n#define R_IA_64_DIR32LSB  0x25  /* word32 LSB S + A */\n#define R_IA_64_DIR64MSB  0x26  /* word64 MSB S + A */\n#define R_IA_64_DIR64LSB  0x27  /* word64 LSB S + A */\n#define R_IA_64_GPREL22   0x2a  /* immediate22  @gprel(S + A) */\n#define R_IA_64_GPREL64I  0x2b  /* immediate64  @gprel(S + A) */\n#define R_IA_64_GPREL32MSB  0x2c  /* word32 MSB @gprel(S + A) */\n#define R_IA_64_GPREL32LSB  0x2d  /* word32 LSB @gprel(S + A) */\n#define R_IA_64_GPREL64MSB  0x2e  /* word64 MSB @gprel(S + A) */\n#define R_IA_64_GPREL64LSB  0x2f  /* word64 LSB @gprel(S + A) */\n#define R_IA_64_LTOFF22   0x32  /* immediate22  @ltoff(S + A) */\n#define R_IA_64_LTOFF64I  0x33  /* immediate64  @ltoff(S + A) */\n#define R_IA_64_PLTOFF22  0x3a  /* immediate22  @pltoff(S + A) */\n#define R_IA_64_PLTOFF64I 0x3b  /* immediate64  @pltoff(S + A) */\n#define R_IA_64_PLTOFF64MSB 0x3e  /* word64 MSB @pltoff(S + A) */\n#define R_IA_64_PLTOFF64LSB 0x3f  /* word64 LSB @pltoff(S + A) */\n#define R_IA_64_FPTR64I   0x43  /* immediate64  @fptr(S + A) */\n#define R_IA_64_FPTR32MSB 0x44  /* word32 MSB @fptr(S + A) */\n#define R_IA_64_FPTR32LSB 0x45  /* word32 LSB @fptr(S + A) */\n#define R_IA_64_FPTR64MSB 0x46  /* word64 MSB @fptr(S + A) */\n#define R_IA_64_FPTR64LSB 0x47  /* word64 LSB @fptr(S + A) */\n#define R_IA_64_PCREL60B  0x48  /* immediate60 form1 S + A - P */\n#define R_IA_64_PCREL21B  0x49  /* immediate21 form1 S + A - P */\n#define R_IA_64_PCREL21M  0x4a  /* immediate21 form2 S + A - P */\n#define R_IA_64_PCREL21F  0x4b  /* immediate21 form3 S + A - P */\n#define R_IA_64_PCREL32MSB  0x4c  /* word32 MSB S + A - P */\n#define R_IA_64_PCREL32LSB  0x4d  /* word32 LSB S + A - P */\n#define R_IA_64_PCREL64MSB  0x4e  /* word64 MSB S + A - P */\n#define R_IA_64_PCREL64LSB  0x4f  /* word64 LSB S + A - P */\n#define R_IA_64_LTOFF_FPTR22  0x52  /* immediate22  @ltoff(@fptr(S + A)) */\n#define R_IA_64_LTOFF_FPTR64I 0x53  /* immediate64  @ltoff(@fptr(S + A)) */\n#define R_IA_64_LTOFF_FPTR32MSB 0x54  /* word32 MSB @ltoff(@fptr(S + A)) */\n#define R_IA_64_LTOFF_FPTR32LSB 0x55  /* word32 LSB @ltoff(@fptr(S + A)) */\n#define R_IA_64_LTOFF_FPTR64MSB 0x56  /* word64 MSB @ltoff(@fptr(S + A)) */\n#define R_IA_64_LTOFF_FPTR64LSB 0x57  /* word64 LSB @ltoff(@fptr(S + A)) */\n#define R_IA_64_SEGREL32MSB 0x5c  /* word32 MSB @segrel(S + A) */\n#define R_IA_64_SEGREL32LSB 0x5d  /* word32 LSB @segrel(S + A) */\n#define R_IA_64_SEGREL64MSB 0x5e  /* word64 MSB @segrel(S + A) */\n#define R_IA_64_SEGREL64LSB 0x5f  /* word64 LSB @segrel(S + A) */\n#define R_IA_64_SECREL32MSB 0x64  /* word32 MSB @secrel(S + A) */\n#define R_IA_64_SECREL32LSB 0x65  /* word32 LSB @secrel(S + A) */\n#define R_IA_64_SECREL64MSB 0x66  /* word64 MSB @secrel(S + A) */\n#define R_IA_64_SECREL64LSB 0x67  /* word64 LSB @secrel(S + A) */\n#define R_IA_64_REL32MSB  0x6c  /* word32 MSB BD + A */\n#define R_IA_64_REL32LSB  0x6d  /* word32 LSB BD + A */\n#define R_IA_64_REL64MSB  0x6e  /* word64 MSB BD + A */\n#define R_IA_64_REL64LSB  0x6f  /* word64 LSB BD + A */\n#define R_IA_64_LTV32MSB  0x74  /* word32 MSB S + A */\n#define R_IA_64_LTV32LSB  0x75  /* word32 LSB S + A */\n#define R_IA_64_LTV64MSB  0x76  /* word64 MSB S + A */\n#define R_IA_64_LTV64LSB  0x77  /* word64 LSB S + A */\n#define R_IA_64_PCREL21BI 0x79  /* immediate21 form1 S + A - P */\n#define R_IA_64_PCREL22   0x7a  /* immediate22  S + A - P */\n#define R_IA_64_PCREL64I  0x7b  /* immediate64  S + A - P */\n#define R_IA_64_IPLTMSB   0x80  /* function descriptor MSB special */\n#define R_IA_64_IPLTLSB   0x81  /* function descriptor LSB speciaal */\n#define R_IA_64_SUB   0x85  /* immediate64  A - S */\n#define R_IA_64_LTOFF22X  0x86  /* immediate22  special */\n#define R_IA_64_LDXMOV    0x87  /* immediate22  special */\n#define R_IA_64_TPREL14   0x91  /* imm14  @tprel(S + A) */\n#define R_IA_64_TPREL22   0x92  /* imm22  @tprel(S + A) */\n#define R_IA_64_TPREL64I  0x93  /* imm64  @tprel(S + A) */\n#define R_IA_64_TPREL64MSB  0x96  /* word64 MSB @tprel(S + A) */\n#define R_IA_64_TPREL64LSB  0x97  /* word64 LSB @tprel(S + A) */\n#define R_IA_64_LTOFF_TPREL22 0x9a  /* imm22  @ltoff(@tprel(S+A)) */\n#define R_IA_64_DTPMOD64MSB 0xa6  /* word64 MSB @dtpmod(S + A) */\n#define R_IA_64_DTPMOD64LSB 0xa7  /* word64 LSB @dtpmod(S + A) */\n#define R_IA_64_LTOFF_DTPMOD22  0xaa  /* imm22  @ltoff(@dtpmod(S+A)) */\n#define R_IA_64_DTPREL14  0xb1  /* imm14  @dtprel(S + A) */\n#define R_IA_64_DTPREL22  0xb2  /* imm22  @dtprel(S + A) */\n#define R_IA_64_DTPREL64I 0xb3  /* imm64  @dtprel(S + A) */\n#define R_IA_64_DTPREL32MSB 0xb4  /* word32 MSB @dtprel(S + A) */\n#define R_IA_64_DTPREL32LSB 0xb5  /* word32 LSB @dtprel(S + A) */\n#define R_IA_64_DTPREL64MSB 0xb6  /* word64 MSB @dtprel(S + A) */\n#define R_IA_64_DTPREL64LSB 0xb7  /* word64 LSB @dtprel(S + A) */\n#define R_IA_64_LTOFF_DTPREL22  0xba  /* imm22  @ltoff(@dtprel(S+A)) */\n\n#define R_MIPS_NONE 0 /* No reloc */\n#define R_MIPS_16 1 /* Direct 16 bit */\n#define R_MIPS_32 2 /* Direct 32 bit */\n#define R_MIPS_REL32  3 /* PC relative 32 bit */\n#define R_MIPS_26 4 /* Direct 26 bit shifted */\n#define R_MIPS_HI16 5 /* High 16 bit */\n#define R_MIPS_LO16 6 /* Low 16 bit */\n#define R_MIPS_GPREL16  7 /* GP relative 16 bit */\n#define R_MIPS_LITERAL  8 /* 16 bit literal entry */\n#define R_MIPS_GOT16  9 /* 16 bit GOT entry */\n#define R_MIPS_PC16 10  /* PC relative 16 bit */\n#define R_MIPS_CALL16 11  /* 16 bit GOT entry for function */\n#define R_MIPS_GPREL32  12  /* GP relative 32 bit */\n#define R_MIPS_64 18  /* Direct 64 bit */\n#define R_MIPS_GOT_DISP 19\n#define R_MIPS_GOT_PAGE 20\n#define R_MIPS_GOT_OFST 21\n#define R_MIPS_GOT_HI16 22  /* GOT HI 16 bit */\n#define R_MIPS_GOT_LO16 23  /* GOT LO 16 bit */\n#define R_MIPS_SUB  24\n#define R_MIPS_CALLHI16 30  /* upper 16 bit GOT entry for function */\n#define R_MIPS_CALLLO16 31  /* lower 16 bit GOT entry for function */\n#define R_MIPS_JALR 37\n#define R_MIPS_TLS_GD 42\n#define R_MIPS_COPY 126\n#define R_MIPS_JUMP_SLOT  127\n\n#define R_PPC_NONE    0 /* No relocation. */\n#define R_PPC_ADDR32    1\n#define R_PPC_ADDR24    2\n#define R_PPC_ADDR16    3\n#define R_PPC_ADDR16_LO   4\n#define R_PPC_ADDR16_HI   5\n#define R_PPC_ADDR16_HA   6\n#define R_PPC_ADDR14    7\n#define R_PPC_ADDR14_BRTAKEN  8\n#define R_PPC_ADDR14_BRNTAKEN 9\n#define R_PPC_REL24   10\n#define R_PPC_REL14   11\n#define R_PPC_REL14_BRTAKEN 12\n#define R_PPC_REL14_BRNTAKEN  13\n#define R_PPC_GOT16   14\n#define R_PPC_GOT16_LO    15\n#define R_PPC_GOT16_HI    16\n#define R_PPC_GOT16_HA    17\n#define R_PPC_PLTREL24    18\n#define R_PPC_COPY    19\n#define R_PPC_GLOB_DAT    20\n#define R_PPC_JMP_SLOT    21\n#define R_PPC_RELATIVE    22\n#define R_PPC_LOCAL24PC   23\n#define R_PPC_UADDR32   24\n#define R_PPC_UADDR16   25\n#define R_PPC_REL32   26\n#define R_PPC_PLT32   27\n#define R_PPC_PLTREL32    28\n#define R_PPC_PLT16_LO    29\n#define R_PPC_PLT16_HI    30\n#define R_PPC_PLT16_HA    31\n#define R_PPC_SDAREL16    32\n#define R_PPC_SECTOFF   33\n#define R_PPC_SECTOFF_LO  34\n#define R_PPC_SECTOFF_HI  35\n#define R_PPC_SECTOFF_HA  36\n\n/*\n * 64-bit relocations\n */\n#define R_PPC64_ADDR64    38\n#define R_PPC64_ADDR16_HIGHER 39\n#define R_PPC64_ADDR16_HIGHERA  40\n#define R_PPC64_ADDR16_HIGHEST  41\n#define R_PPC64_ADDR16_HIGHESTA 42\n#define R_PPC64_UADDR64   43\n#define R_PPC64_REL64   44\n#define R_PPC64_PLT64   45\n#define R_PPC64_PLTREL64  46\n#define R_PPC64_TOC16   47\n#define R_PPC64_TOC16_LO  48\n#define R_PPC64_TOC16_HI  49\n#define R_PPC64_TOC16_HA  50\n#define R_PPC64_TOC   51\n#define R_PPC64_DTPMOD64  68\n#define R_PPC64_TPREL64   73\n#define R_PPC64_DTPREL64  78\n\n/*\n * TLS relocations\n */\n#define R_PPC_TLS   67\n#define R_PPC_DTPMOD32    68\n#define R_PPC_TPREL16   69\n#define R_PPC_TPREL16_LO  70\n#define R_PPC_TPREL16_HI  71\n#define R_PPC_TPREL16_HA  72\n#define R_PPC_TPREL32   73\n#define R_PPC_DTPREL16    74\n#define R_PPC_DTPREL16_LO 75\n#define R_PPC_DTPREL16_HI 76\n#define R_PPC_DTPREL16_HA 77\n#define R_PPC_DTPREL32    78\n#define R_PPC_GOT_TLSGD16 79\n#define R_PPC_GOT_TLSGD16_LO  80\n#define R_PPC_GOT_TLSGD16_HI  81\n#define R_PPC_GOT_TLSGD16_HA  82\n#define R_PPC_GOT_TLSLD16 83\n#define R_PPC_GOT_TLSLD16_LO  84\n#define R_PPC_GOT_TLSLD16_HI  85\n#define R_PPC_GOT_TLSLD16_HA  86\n#define R_PPC_GOT_TPREL16 87\n#define R_PPC_GOT_TPREL16_LO  88\n#define R_PPC_GOT_TPREL16_HI  89\n#define R_PPC_GOT_TPREL16_HA  90\n\n/*\n * The remaining relocs are from the Embedded ELF ABI, and are not in the\n *  SVR4 ELF ABI.\n */\n\n#define R_PPC_EMB_NADDR32 101\n#define R_PPC_EMB_NADDR16 102\n#define R_PPC_EMB_NADDR16_LO  103\n#define R_PPC_EMB_NADDR16_HI  104\n#define R_PPC_EMB_NADDR16_HA  105\n#define R_PPC_EMB_SDAI16  106\n#define R_PPC_EMB_SDA2I16 107\n#define R_PPC_EMB_SDA2REL 108\n#define R_PPC_EMB_SDA21   109\n#define R_PPC_EMB_MRKREF  110\n#define R_PPC_EMB_RELSEC16  111\n#define R_PPC_EMB_RELST_LO  112\n#define R_PPC_EMB_RELST_HI  113\n#define R_PPC_EMB_RELST_HA  114\n#define R_PPC_EMB_BIT_FLD 115\n#define R_PPC_EMB_RELSDA  116\n\n/*\n * RISC-V relocation types.\n */\n\n/* Relocation types used by the dynamic linker. */\n#define R_RISCV_NONE    0\n#define R_RISCV_32    1\n#define R_RISCV_64    2\n#define R_RISCV_RELATIVE  3\n#define R_RISCV_COPY    4\n#define R_RISCV_JUMP_SLOT 5\n#define R_RISCV_TLS_DTPMOD32  6\n#define R_RISCV_TLS_DTPMOD64  7\n#define R_RISCV_TLS_DTPREL32  8\n#define R_RISCV_TLS_DTPREL64  9\n#define R_RISCV_TLS_TPREL32 10\n#define R_RISCV_TLS_TPREL64 11\n\n/* Relocation types not used by the dynamic linker. */\n#define R_RISCV_BRANCH    16\n#define R_RISCV_JAL   17\n#define R_RISCV_CALL    18\n#define R_RISCV_CALL_PLT  19\n#define R_RISCV_GOT_HI20  20\n#define R_RISCV_TLS_GOT_HI20  21\n#define R_RISCV_TLS_GD_HI20 22\n#define R_RISCV_PCREL_HI20  23\n#define R_RISCV_PCREL_LO12_I  24\n#define R_RISCV_PCREL_LO12_S  25\n#define R_RISCV_HI20    26\n#define R_RISCV_LO12_I    27\n#define R_RISCV_LO12_S    28\n#define R_RISCV_TPREL_HI20  29\n#define R_RISCV_TPREL_LO12_I  30\n#define R_RISCV_TPREL_LO12_S  31\n#define R_RISCV_TPREL_ADD 32\n#define R_RISCV_ADD8    33\n#define R_RISCV_ADD16   34\n#define R_RISCV_ADD32   35\n#define R_RISCV_ADD64   36\n#define R_RISCV_SUB8    37\n#define R_RISCV_SUB16   38\n#define R_RISCV_SUB32   39\n#define R_RISCV_SUB64   40\n#define R_RISCV_GNU_VTINHERIT 41\n#define R_RISCV_GNU_VTENTRY 42\n#define R_RISCV_ALIGN   43\n#define R_RISCV_RVC_BRANCH  44\n#define R_RISCV_RVC_JUMP  45\n\n#define R_SPARC_NONE    0\n#define R_SPARC_8   1\n#define R_SPARC_16    2\n#define R_SPARC_32    3\n#define R_SPARC_DISP8   4\n#define R_SPARC_DISP16    5\n#define R_SPARC_DISP32    6\n#define R_SPARC_WDISP30   7\n#define R_SPARC_WDISP22   8\n#define R_SPARC_HI22    9\n#define R_SPARC_22    10\n#define R_SPARC_13    11\n#define R_SPARC_LO10    12\n#define R_SPARC_GOT10   13\n#define R_SPARC_GOT13   14\n#define R_SPARC_GOT22   15\n#define R_SPARC_PC10    16\n#define R_SPARC_PC22    17\n#define R_SPARC_WPLT30    18\n#define R_SPARC_COPY    19\n#define R_SPARC_GLOB_DAT  20\n#define R_SPARC_JMP_SLOT  21\n#define R_SPARC_RELATIVE  22\n#define R_SPARC_UA32    23\n#define R_SPARC_PLT32   24\n#define R_SPARC_HIPLT22   25\n#define R_SPARC_LOPLT10   26\n#define R_SPARC_PCPLT32   27\n#define R_SPARC_PCPLT22   28\n#define R_SPARC_PCPLT10   29\n#define R_SPARC_10    30\n#define R_SPARC_11    31\n#define R_SPARC_64    32\n#define R_SPARC_OLO10   33\n#define R_SPARC_HH22    34\n#define R_SPARC_HM10    35\n#define R_SPARC_LM22    36\n#define R_SPARC_PC_HH22   37\n#define R_SPARC_PC_HM10   38\n#define R_SPARC_PC_LM22   39\n#define R_SPARC_WDISP16   40\n#define R_SPARC_WDISP19   41\n#define R_SPARC_GLOB_JMP  42\n#define R_SPARC_7   43\n#define R_SPARC_5   44\n#define R_SPARC_6   45\n#define R_SPARC_DISP64    46\n#define R_SPARC_PLT64   47\n#define R_SPARC_HIX22   48\n#define R_SPARC_LOX10   49\n#define R_SPARC_H44   50\n#define R_SPARC_M44   51\n#define R_SPARC_L44   52\n#define R_SPARC_REGISTER  53\n#define R_SPARC_UA64    54\n#define R_SPARC_UA16    55\n#define R_SPARC_TLS_GD_HI22 56\n#define R_SPARC_TLS_GD_LO10 57\n#define R_SPARC_TLS_GD_ADD  58\n#define R_SPARC_TLS_GD_CALL 59\n#define R_SPARC_TLS_LDM_HI22  60\n#define R_SPARC_TLS_LDM_LO10  61\n#define R_SPARC_TLS_LDM_ADD 62\n#define R_SPARC_TLS_LDM_CALL  63\n#define R_SPARC_TLS_LDO_HIX22 64\n#define R_SPARC_TLS_LDO_LOX10 65\n#define R_SPARC_TLS_LDO_ADD 66\n#define R_SPARC_TLS_IE_HI22 67\n#define R_SPARC_TLS_IE_LO10 68\n#define R_SPARC_TLS_IE_LD 69\n#define R_SPARC_TLS_IE_LDX  70\n#define R_SPARC_TLS_IE_ADD  71\n#define R_SPARC_TLS_LE_HIX22  72\n#define R_SPARC_TLS_LE_LOX10  73\n#define R_SPARC_TLS_DTPMOD32  74\n#define R_SPARC_TLS_DTPMOD64  75\n#define R_SPARC_TLS_DTPOFF32  76\n#define R_SPARC_TLS_DTPOFF64  77\n#define R_SPARC_TLS_TPOFF32 78\n#define R_SPARC_TLS_TPOFF64 79\n\n#define R_X86_64_NONE   0 /* No relocation. */\n#define R_X86_64_64   1 /* Add 64 bit symbol value. */\n#define R_X86_64_PC32   2 /* PC-relative 32 bit signed sym value. */\n#define R_X86_64_GOT32    3 /* PC-relative 32 bit GOT offset. */\n#define R_X86_64_PLT32    4 /* PC-relative 32 bit PLT offset. */\n#define R_X86_64_COPY   5 /* Copy data from shared object. */\n#define R_X86_64_GLOB_DAT 6 /* Set GOT entry to data address. */\n#define R_X86_64_JMP_SLOT 7 /* Set GOT entry to code address. */\n#define R_X86_64_RELATIVE 8 /* Add load address of shared object. */\n#define R_X86_64_GOTPCREL 9 /* Add 32 bit signed pcrel offset to GOT. */\n#define R_X86_64_32   10  /* Add 32 bit zero extended symbol value */\n#define R_X86_64_32S    11  /* Add 32 bit sign extended symbol value */\n#define R_X86_64_16   12  /* Add 16 bit zero extended symbol value */\n#define R_X86_64_PC16   13  /* Add 16 bit signed extended pc relative symbol value */\n#define R_X86_64_8    14  /* Add 8 bit zero extended symbol value */\n#define R_X86_64_PC8    15  /* Add 8 bit signed extended pc relative symbol value */\n#define R_X86_64_DTPMOD64 16  /* ID of module containing symbol */\n#define R_X86_64_DTPOFF64 17  /* Offset in TLS block */\n#define R_X86_64_TPOFF64  18  /* Offset in static TLS block */\n#define R_X86_64_TLSGD    19  /* PC relative offset to GD GOT entry */\n#define R_X86_64_TLSLD    20  /* PC relative offset to LD GOT entry */\n#define R_X86_64_DTPOFF32 21  /* Offset in TLS block */\n#define R_X86_64_GOTTPOFF 22  /* PC relative offset to IE GOT entry */\n#define R_X86_64_TPOFF32  23  /* Offset in static TLS block */\n#define R_X86_64_PC64   24  /* PC-relative 64 bit signed sym value. */\n#define R_X86_64_GOTOFF64 25\n#define R_X86_64_GOTPC32  26\n#define R_X86_64_GOT64    27\n#define R_X86_64_GOTPCREL64 28\n#define R_X86_64_GOTPC64  29\n#define R_X86_64_GOTPLT64 30\n#define R_X86_64_PLTOFF64 31\n#define R_X86_64_SIZE32   32\n#define R_X86_64_SIZE64   33\n#define R_X86_64_GOTPC32_TLSDESC 34\n#define R_X86_64_TLSDESC_CALL 35\n#define R_X86_64_TLSDESC  36\n#define R_X86_64_IRELATIVE  37\n\n\n#endif /* !_SYS_ELF_COMMON_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/namespaceLEVEL__PINCLIENT.html": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/xhtml;charset=UTF-8\"/>\n<title>Pin: LEVEL_PINCLIENT Namespace Reference</title>\n<link href=\"tabs.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<link href=\"search/search.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<script type=\"text/javascript\" src=\"search/search.js\"></script>\n<link href=\"doxygen.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>\n<body onload='searchBox.OnSelectItem(0);'>\n<!-- Generated by Doxygen 1.7.4 -->\n<script type=\"text/javascript\"><!--\nvar searchBox = new SearchBox(\"searchBox\", \"search\",false,'Search');\n--></script>\n<div id=\"top\">\n<div id=\"titlearea\">\n<table cellspacing=\"0\" cellpadding=\"0\">\n <tbody>\n <tr style=\"height: 56px;\">\n  <td style=\"padding-left: 0.5em;\">\n   <div id=\"projectname\">Pin</div>\n  </td>\n </tr>\n </tbody>\n</table>\n</div>\n  <div id=\"navrow1\" class=\"tabs\">\n    <ul class=\"tablist\">\n      <li><a href=\"index.html\"><span>Main&#160;Page</span></a></li>\n      <li><a href=\"modules.html\"><span>Modules</span></a></li>\n      <li class=\"current\"><a href=\"namespaces.html\"><span>Namespaces</span></a></li>\n      <li><a href=\"annotated.html\"><span>Classes</span></a></li>\n      <li id=\"searchli\">\n        <div id=\"MSearchBox\" class=\"MSearchBoxInactive\">\n        <span class=\"left\">\n          <img id=\"MSearchSelect\" src=\"search/mag_sel.png\"\n               onmouseover=\"return searchBox.OnSearchSelectShow()\"\n               onmouseout=\"return searchBox.OnSearchSelectHide()\"\n               alt=\"\"/>\n          <input type=\"text\" id=\"MSearchField\" value=\"Search\" accesskey=\"S\"\n               onfocus=\"searchBox.OnSearchFieldFocus(true)\" \n               onblur=\"searchBox.OnSearchFieldFocus(false)\" \n               onkeyup=\"searchBox.OnSearchFieldChange(event)\"/>\n          </span><span class=\"right\">\n            <a id=\"MSearchClose\" href=\"javascript:searchBox.CloseResultsWindow()\"><img id=\"MSearchCloseImg\" border=\"0\" src=\"search/close.png\" alt=\"\"/></a>\n          </span>\n        </div>\n      </li>\n    </ul>\n  </div>\n  <div id=\"navrow2\" class=\"tabs2\">\n    <ul class=\"tablist\">\n      <li><a href=\"namespaces.html\"><span>Namespace&#160;List</span></a></li>\n      <li><a href=\"namespacemembers.html\"><span>Namespace&#160;Members</span></a></li>\n    </ul>\n  </div>\n</div>\n<div class=\"header\">\n  <div class=\"summary\">\n<a href=\"#typedef-members\">Typedefs</a> &#124;\n<a href=\"#enum-members\">Enumerations</a> &#124;\n<a href=\"#func-members\">Functions</a> &#124;\n<a href=\"#var-members\">Variables</a>  </div>\n  <div class=\"headertitle\">\n<div class=\"title\">LEVEL_PINCLIENT Namespace Reference</div>  </div>\n</div>\n<div class=\"contents\">\n<table class=\"memberdecls\">\n<tr><td colspan=\"2\"><h2><a name=\"typedef-members\"></a>\nTypedefs</h2></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef map&lt; SYM, ADDRINT &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad2ae6fe95412a7e60c6e2687215e7d96\">SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP</a></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef <br class=\"typebreak\"/>\nLEVEL_BASE::CHILD_PROCESS_CLASS *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CHILD__PROCESS__API.html#ga17aa0357dbaaec79a971207a6d4ec281\">CHILD_PROCESS</a></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef BOOL(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CHILD__PROCESS__API.html#gab109395d5b4fa72f83efaf0a449c340b\">FOLLOW_CHILD_PROCESS_CALLBACK</a> )(<a class=\"el\" href=\"group__CHILD__PROCESS__API.html#ga17aa0357dbaaec79a971207a6d4ec281\">CHILD_PROCESS</a> childProcess, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef BOOL(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#ga10a867bb048e6ec4e52306a548604c2b\">DEBUG_INTERPRETER_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, const std::string &amp;cmd, std::string *reply, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef BOOL(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#gabe5afceda93e234bfb67111f319bef23\">DEBUG_BREAKPOINT_CALLBACK</a> )(ADDRINT addr, UINT size, BOOL insert, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef BOOL(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a371d93560a7f7ae5ec4b97c228197fce\">INTERCEPT_DEBUGGING_EVENT_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, DEBUGGING_EVENT eventType, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, VOID *arg)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a03b643cf8ed4f53d9578ae1c0ea80ff1\">GET_EMULATED_REGISTER_CALLBACK</a> )(unsigned toolRegId, <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, VOID *data, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aa9709409d9f414af22b6c3f0a12c95a3\">SET_EMULATED_REGISTER_CALLBACK</a> )(unsigned toolRegId, <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, const VOID *data, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef USIZE(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a9c0055d850f5c7299b4e3b9e3b26e53c\">GET_TARGET_DESCRIPTION_CALLBACK</a> )(const std::string &amp;name, USIZE size, VOID *buf, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga0e02ac705fda839f4942303a0dbd92a9\">SIGNAL_BEFORE_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, INT32 sig, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxtFrom, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxtTo, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga139244febc8272114b851ac93a8cd36d\">SIGNAL_AFTER_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxtFrom, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxtTo, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#gae72726a7bc47716300b14a903f63c492\">THREAD_BEGIN_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, VOID *sp, int flags, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga1da3746b42e9e84eef562509c680ea7b\">THREAD_END_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, INT32 code, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef BOOL(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga2116b73be99579bae5c752aae9eb3ab4\">SIGNAL_INTERCEPT_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, INT32 sig, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, BOOL hasHndlr, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga3c454c8efe9960033aabdcc1c43b8fa7\">IMAGECALLBACK</a> )(IMG, VOID *)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef map&lt; ADDRINT, USIZE &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a5e0a0b00100c49bf205b4959f008e2f0\">CODE_RANGES</a></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef <a class=\"el\" href=\"group__PIN__CONTROL.html#ga8c5c16fb133375efa3a27d3a3900c603\">EXCEPT_HANDLING_RESULT</a>(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga64b49da7310c130bcebb21c1fcaaf318\">INTERNAL_EXCEPTION_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, <a class=\"el\" href=\"group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5\">EXCEPTION_INFO</a> *pExceptInfo, <a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#ga3c6833a027db42b5d528a0c65cefbc07\">PHYSICAL_CONTEXT</a> *pPhysCtxt, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a64ca0820c096be9a8425fc0d9a70f7a8\">TRACEGENCODE_CALLBACK</a> )(<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef TRACE_CLASS *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gadfef9e89968c6491114d7ceae51ab61b\">PIN_CONFIGURATION_INFO</a></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef COMPLEX_CALLBACKVAL_BASE *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga03cd6bf5e72db42913aee13f08d7591a\">REMOVE_INSTRUMENTATION_CALLBACK</a> )(VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gad1e358c0ce1a5aef73f263b2800deb36\">DETACH_CALLBACK</a> )(VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga1edd9181ea2f698c21c743be7f93267e\">DETACH_PROBED_CALLBACK</a> )(VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga250c31d0d85cd9ec799f30752c476841\">ATTACH_PROBED_CALLBACK</a> )(VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga50ed540b287876494d489a0fb863f0f4\">ATTACH_CALLBACK</a> )(VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gae1c672af1a7b69eed84982ed7e3efcdb\">APPLICATION_START_CALLBACK</a> )(VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga680e195155c9e4141d994512b31a319b\">PREPARE_FOR_FINI_CALLBACK</a> )(VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gaacb361fd2832e34cc92e7f03bd1f1621\">FINI_CALLBACK</a> )(INT32 code, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef size_t(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga308874ca87663350daa5608de534a0ce\">FETCH_CALLBACK</a> )(void *buf, ADDRINT addr, size_t size, <a class=\"el\" href=\"group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5\">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gabbf7a42619fda89affa3df8bddebc32e\">OUT_OF_MEMORY_CALLBACK</a> )(size_t size, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef ADDRINT(PIN_FAST_ANALYSIS_CALL *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga1a1c5b833df7e988522aa312890d1ca4\">MEMORY_ADDR_TRANS_CALLBACK</a> )(<a class=\"el\" href=\"structPIN__MEM__TRANS__INFO.html\">PIN_MEM_TRANS_INFO</a> *memTransInfo, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#gafa7e66beec272534d120b9ab3ea4ca84\">SMC_CALLBACK</a> )(ADDRINT traceStartAddress, ADDRINT traceEndAddress, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gadc08958640205e2e9ff994fdac917a25\">FORK_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadid, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga4b987e362ca821776c61f27af5d54574\">THREAD_START_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, INT32 flags, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gab3501b75015ec6c930b97b2f190195d1\">THREAD_ATTACH_PROBED_CALLBACK</a> )(VOID *sigmask, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gae2f1f3018393574f4949f8ce61ce6c32\">THREAD_DETACH_PROBED_CALLBACK</a> )(VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gaf61282484a7afd5e278ae6a7023862b0\">THREAD_ATTACH_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga57f8ed1dca340de4282fe3327b44ca81\">THREAD_DETACH_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga670ae83f83ef39ac19d793e16b23c5ca\">THREAD_FINI_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, INT32 code, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gaf57e5726e099445f81e9b529336ba073\">CONTEXT_CHANGE_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__PIN__CONTROL.html#ga8e4e6511a0e09fdc5ec7d6dbf395b3a8\">CONTEXT_CHANGE_REASON</a> reason, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *from, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *to, INT32 info, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#gabee4934fa6434c13c0c2f4ce2a6468dd\">SYSCALL_ENTRY_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, SYSCALL_STANDARD std, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#ga6579efc9b9f38ac589db8559fc503ea8\">SYSCALL_EXIT_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, SYSCALL_STANDARD std, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef BOOL(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga93cea72a6023405d0e90c65c81a62d6f\">INTERCEPT_SIGNAL_CALLBACK</a> )(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, INT32 sig, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, BOOL hasHandler, const <a class=\"el\" href=\"group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5\">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga880c51b16479dde27cb248f038b4ab76\">PROBES_INSERTED_CALLBACK</a> )(IMG img, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID *(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BUFFER__API.html#ga2f5cb32e7787a78f3d82777ccc6bcc74\">TRACE_BUFFER_CALLBACK</a> )(BUFFER_ID id, <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, VOID *buf, UINT64 numElements, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#gaf8c8e7d6c9872e80d4571ba461dff870\">INS_INSTRUMENT_CALLBACK</a> )(INS ins, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaaec88a4f6dc5f49e092754540a5ed7b0\">TRACE_INSTRUMENT_CALLBACK</a> )(<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">typedef VOID(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gad0b5091252621bacc4645cb920fdc403\">RTN_INSTRUMENT_CALLBACK</a> )(RTN rtn, VOID *v)</td></tr>\n<tr><td colspan=\"2\"><h2><a name=\"enum-members\"></a>\nEnumerations</h2></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">enum &#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#ga2b7e9b0b1d3e5d38135695bdb1b380fe\">UNDECORATION</a> { <br/>\n&#160;&#160;<a class=\"el\" href=\"group__SYM__BASIC__API.html#gga2b7e9b0b1d3e5d38135695bdb1b380fea97005f7701a8e2ce6a060b31f7fb3287\">UNDECORATION_COMPLETE</a>, \n<br/>\n&#160;&#160;<a class=\"el\" href=\"group__SYM__BASIC__API.html#gga2b7e9b0b1d3e5d38135695bdb1b380fea22890064021b2aa1f9f2754d181b7073\">UNDECORATION_NAME_ONLY</a>\n<br/>\n }</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">enum &#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga139152abe353fdff0216a5519d261c73\">SYMBOL_INFO_MODE</a> { <br/>\n&#160;&#160;<a class=\"el\" href=\"group__PIN__CONTROL.html#gga139152abe353fdff0216a5519d261c73af44e4b240fa01ca6ed3a64acf6022ce4\">NO_SYMBOLS</a> =  0, \n<br/>\n&#160;&#160;<a class=\"el\" href=\"group__PIN__CONTROL.html#gga139152abe353fdff0216a5519d261c73a3486158cb738b76b7385310ec8f5b671\">EXPORT_SYMBOLS</a> =  (1&lt;&lt;0), \n<br/>\n&#160;&#160;<a class=\"el\" href=\"group__PIN__CONTROL.html#gga139152abe353fdff0216a5519d261c73a25bfc332ecb53ef24ee4ff743d09bde1\">DEBUG_SYMBOLS</a> =  (1&lt;&lt;1), \n<br/>\n&#160;&#160;<a class=\"el\" href=\"group__PIN__CONTROL.html#gga139152abe353fdff0216a5519d261c73aa07edbcaef24a5dbbe880f20916bd74e\">IFUNC_SYMBOLS</a> =  (1&lt;&lt;2), \n<br/>\n&#160;&#160;<a class=\"el\" href=\"group__PIN__CONTROL.html#gga139152abe353fdff0216a5519d261c73a172580d6ba02ac51ce4d3140bdafec07\">DEBUG_OR_EXPORT_SYMBOLS</a> =  (DEBUG_SYMBOLS | EXPORT_SYMBOLS)\n<br/>\n }</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">enum &#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aee3bb3cf999bb595aee75ad4d0745a9e\">IMAGE_LOAD_FLAGS</a> { <br/>\n&#160;&#160;<b>IMAGE_LOAD_NONE</b> =  0x00, \n<br/>\n&#160;&#160;<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aee3bb3cf999bb595aee75ad4d0745a9ea6f623c8327e2d18e98947584512a9be4\">IMAGE_LOAD_MAINEXECUTABLE</a> =  0x01, \n<br/>\n&#160;&#160;<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aee3bb3cf999bb595aee75ad4d0745a9ea57e940bb73df0b6928809abc9e78c2ae\">IMAGE_LOAD_FOUNDINMEMORY</a> =  0x02, \n<br/>\n&#160;&#160;<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aee3bb3cf999bb595aee75ad4d0745a9ead1484fb8b885e9f54b79efac5c2066e0\">IMAGE_LOAD_RUNTIME</a> =  0x04, \n<br/>\n&#160;&#160;<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aee3bb3cf999bb595aee75ad4d0745a9ea6296486ba50d398ec22b841e97e1b11c\">IMAGE_LOAD_TEXTFROMIMAGE</a> =  0x08, \n<br/>\n&#160;&#160;<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aee3bb3cf999bb595aee75ad4d0745a9ea8ece880802674715efdfa82b17ceea3e\">IMAGE_LOAD_INTERPRETER</a> =  0x10\n<br/>\n }</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">enum &#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PROBE_TAG</b> { <br/>\n&#160;&#160;<b>PROBE_TAG_OK</b>, \n<br/>\n&#160;&#160;<b>PROBE_TAG_BRANCH_TARGET</b>, \n<br/>\n&#160;&#160;<b>PROBE_TAG_POSSIBLE_UNIDENTIFIED_BRANCH_TARGET</b>, \n<br/>\n&#160;&#160;<b>PROBE_TAG_BRANCH_PAST_END</b>, \n<br/>\n&#160;&#160;<b>PROBE_TAG_TOO_SMALL</b>, \n<br/>\n&#160;&#160;<b>PROBE_TAG_PREV_PROBE</b>, \n<br/>\n&#160;&#160;<b>PROBE_TAG_RUNTIME_FIXUP</b>, \n<br/>\n&#160;&#160;<b>PROBE_TAG_RELOCATE</b>, \n<br/>\n&#160;&#160;<b>PROBE_TAG_NOT_RELOCATABLE</b>, \n<br/>\n&#160;&#160;<b>PROBE_TAG_UNKNOWN</b>\n<br/>\n }</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">enum &#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ae69d9a1cd56064e0397c268953ac7de7\">REPLAY_MODE</a> { <br/>\n&#160;&#160;<b>REPLAY_MODE_NONE</b> =  0x00, \n<br/>\n&#160;&#160;<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ae69d9a1cd56064e0397c268953ac7de7a670480aefd15f6ef98e64835e176f6d6\">REPLAY_MODE_IMAGEOPS</a> =  0x01, \n<br/>\n&#160;&#160;<b>REPLAY_MODE_ALL</b> =  REPLAY_MODE_IMAGEOPS\n<br/>\n }</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">enum &#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf\">PROBE_MODE</a> { <br/>\n&#160;&#160;<b>PROBE_MODE_DEFAULT</b> =  0, \n<br/>\n&#160;&#160;<b>PROBE_MODE_ALLOW_RELOCATION</b> =  (1&lt;&lt;0)\n<br/>\n }</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">enum &#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga0244f9b4e34e4eed7d483fa6ec7b70f0\">SMC_ENABLE_DISABLE_TYPE</a> { <br/>\n&#160;&#160;<b>SMC_ENABLE</b>, \n<br/>\n&#160;&#160;<b>SMC_DISABLE</b>\n<br/>\n }</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">enum &#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gab459bf0034704bf1aa7fa7e192b7dc08\">FPOINT</a> { <br/>\n&#160;&#160;<a class=\"el\" href=\"group__PIN__CONTROL.html#ggab459bf0034704bf1aa7fa7e192b7dc08ad25e85d29c19e7e0c5a9a768191bbcd7\">FPOINT_BEFORE</a>, \n<br/>\n&#160;&#160;<a class=\"el\" href=\"group__PIN__CONTROL.html#ggab459bf0034704bf1aa7fa7e192b7dc08ae95eedd3db4447dda41b3fe76c7013c6\">FPOINT_AFTER_IN_PARENT</a>, \n<br/>\n&#160;&#160;<a class=\"el\" href=\"group__PIN__CONTROL.html#ggab459bf0034704bf1aa7fa7e192b7dc08ab97d0822ccc4bd553feab25fc85412fc\">FPOINT_AFTER_IN_CHILD</a>\n<br/>\n }</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">enum &#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gaf9a18d894714ae57264a2302638fc4b3\">ATTACH_STATUS</a> { <br/>\n&#160;&#160;<a class=\"el\" href=\"group__PIN__CONTROL.html#ggaf9a18d894714ae57264a2302638fc4b3ab479d68822d4264f3ad10880a5b21a3d\">ATTACH_INITIATED</a>, \n<br/>\n&#160;&#160;<a class=\"el\" href=\"group__PIN__CONTROL.html#ggaf9a18d894714ae57264a2302638fc4b3a14afa31e2dadab79279e93630e18f671\">ATTACH_FAILED_DETACH</a>\n<br/>\n }</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">enum &#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CONDINSTSTATE</b> { <br/>\n&#160;&#160;<b>CONDINST_NORMAL</b>, \n<br/>\n&#160;&#160;<b>CONDINST_IF</b>, \n<br/>\n&#160;&#160;<b>CONDINST_THEN</b>\n<br/>\n }</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">enum &#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab17933d09ef2378f9a385e00e041911e\">REPLAY_IMAGE_TYPE</a> { <br/>\n&#160;&#160;<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab17933d09ef2378f9a385e00e041911ea736a565b689088f245e364274dc94e52\">REPLAY_IMAGE_TYPE_REGULAR</a> =  0, \n<br/>\n&#160;&#160;<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab17933d09ef2378f9a385e00e041911ea876a84ec97b14930a5890e80a39c7eab\">REPLAY_IMAGE_TYPE_MAIN_EXE</a> =  1, \n<br/>\n&#160;&#160;<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab17933d09ef2378f9a385e00e041911ea387edc1bb726b8dc3d6f8d99f5afb219\">REPLAY_IMAGE_TYPE_INTERPRETER</a> =  2\n<br/>\n }</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">enum &#160;</td><td class=\"memItemRight\" valign=\"bottom\">{ <br/>\n&#160;&#160;<b>TLS_KEY_INTERNAL_EXCEPTION</b>, \n<br/>\n&#160;&#160;<b>TLS_KEY_CLIENT_FIRST</b>, \n<br/>\n&#160;&#160;<b>TLS_KEY_CLIENT_LAST</b> =  TLS_KEY_CLIENT_FIRST + 63\n<br/>\n }</td></tr>\n<tr><td colspan=\"2\"><h2><a name=\"func-members\"></a>\nFunctions</h2></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a557870a34485bc96e7713820173c6192\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::calc32CRC\" ref=\"a557870a34485bc96e7713820173c6192\" args=\"(const CHAR *start, UINT32 size)\" -->\nLOCALFUN UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>calc32CRC</b> (const CHAR *start, UINT32 size)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">string&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a9f66eabbfb8a323c113902c49b0d918a\">FindGnuDebugLinkFile</a> (IMG img, CHAR **imageStart, size_t *imageSize)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a3f3b15285499932f44312c1d1149626d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImageInitSession\" ref=\"a3f3b15285499932f44312c1d1149626d\" args=\"()\" -->\nLOCALINLINE IMAGE_INIT_SESSION *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ImageInitSession</b> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ae79710cbf7a04731f43365063bf807f4\">IMG_IsStandardLoaderLibrary</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a43a58c48d2d39493be740bbe37f60f93\">updateHasLinesData</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a68bc9abe10e95a074674f1b1bdafe672\">IMG_IsStandardSystemLibrary</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ac37eba6a29c7d594c11984f744052353\">IMG_IsStandardThreadLibrary</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab8582ba61e6db66849f527b44559d836\">IMG_IsStandardGccLibrary</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a75856982ea675ab44c5853701db3a5d5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FindAuxBase\" ref=\"a75856982ea675ab44c5853701db3a5d5\" args=\"(CHAR **argv)\" -->\nLOCALFUN AUXTYPE *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FindAuxBase</b> (CHAR **argv)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a3f94fe7c1f75b336d5f922c6bdd6a6ea\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AppAuxValue\" ref=\"a3f94fe7c1f75b336d5f922c6bdd6a6ea\" args=\"(UINT64 type)\" -->\nLOCALFUN ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>AppAuxValue</b> (UINT64 type)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a96f50970e0ae8261b7a719ebb52e052f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::LoaderAddress\" ref=\"a96f50970e0ae8261b7a719ebb52e052f\" args=\"()\" -->\nLOCALFUN ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>LoaderAddress</b> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a03224476813833bcf3d474649ef31bf5\">VdsoAddress</a> ()</td></tr>\n<tr><td class=\"memTemplParams\" colspan=\"2\"><a class=\"anchor\" id=\"a75acdd8f5c06bd4ddd6c27f6c71531d5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ValidateLoaderInfo\" ref=\"a75acdd8f5c06bd4ddd6c27f6c71531d5\" args=\"(LOADERINFO loaderInfo)\" -->\ntemplate&lt;typename LOADERINFO &gt; </td></tr>\n<tr><td class=\"memTemplItemLeft\" align=\"right\" valign=\"top\">LOCALTEMPLATEFUN BOOL&#160;</td><td class=\"memTemplItemRight\" valign=\"bottom\"><b>ValidateLoaderInfo</b> (LOADERINFO loaderInfo)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a397ff749e5f8ae8ba184138e9ca9c9bf\">NotifyDebuggerOnImageLoad</a> (BOOL isMain, VOID *loaderInfo)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aca76650323000be4b8c6f7c9466f8d5e\">NotifyDebuggerOnImageUnload</a> (VOID *loaderInfo)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a58b8dff24bc1f45368e19dbc746eef87\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MakeLoaderInfoFromLinkMap\" ref=\"a58b8dff24bc1f45368e19dbc746eef87\" args=\"(const string &amp;name, struct link_map *lm)\" -->\nLOCALFUN LINUX_LOADER_IMAGE_INFO *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>MakeLoaderInfoFromLinkMap</b> (const string &amp;name, struct link_map *lm)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a53fccc1c75cdcfb5c4d1f20fbc2f082e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImageByName\" ref=\"a53fccc1c75cdcfb5c4d1f20fbc2f082e\" args=\"(const string &amp;name)\" -->\nLOCALFUN IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ImageByName</b> (const string &amp;name)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a0db4fe7cf5276f3b116d1b4ebedb699e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyDebuggerOnElfImageLoad\" ref=\"a0db4fe7cf5276f3b116d1b4ebedb699e\" args=\"(BOOL isMain, BOOL isInterp, const string &amp;name, struct link_map *lm)\" -->\nLOCALFUN LINUX_LOADER_IMAGE_INFO *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>NotifyDebuggerOnElfImageLoad</b> (BOOL isMain, BOOL isInterp, const string &amp;name, struct link_map *lm)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a38bca4b1187d489fcf402f9f2f0beee8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ProcessLoadedImage\" ref=\"a38bca4b1187d489fcf402f9f2f0beee8\" args=\"(IMG img, LINUX_LOADER_IMAGE_INFO *li)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ProcessLoadedImage</b> (IMG img, LINUX_LOADER_IMAGE_INFO *li)</td></tr>\n<tr><td class=\"memTemplParams\" colspan=\"2\"><a class=\"anchor\" id=\"a2a671b51051681103dbb28373a6e5407\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TranslateMemoryPointer\" ref=\"a2a671b51051681103dbb28373a6e5407\" args=\"(PTR ptr)\" -->\ntemplate&lt;typename PTR &gt; </td></tr>\n<tr><td class=\"memTemplItemLeft\" align=\"right\" valign=\"top\">LOCALTEMPLATEFUN PTR&#160;</td><td class=\"memTemplItemRight\" valign=\"bottom\"><b>TranslateMemoryPointer</b> (PTR ptr)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a75e177e0b75ff6e0745f0cdec0e5651a\">ScanLibrariesUnlocked</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a09a3f51b12ef413c052ae8711d6f1149\">ScanLibrariesLocked</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a999fb2dff2f5404d5942722f909ea53a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::OnLoaderBreak\" ref=\"a999fb2dff2f5404d5942722f909ea53a\" args=\"(THREADID threadid, const CONTEXT *ctxt)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>OnLoaderBreak</b> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadid, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a4c9a3bd423c80fbca9d581a47b943b29\">ResolveIFunc</a> (ADDRINT resolver)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ac3286648074b56e39e787c3abd1043b9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::OnLoaderBreakProbe\" ref=\"ac3286648074b56e39e787c3abd1043b9\" args=\"()\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>OnLoaderBreakProbe</b> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a05f11ab955128ccc7dd936280c211da1\">ReadElfHeader</a> (CHAR const *file, EHDR *ehdr)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aaf072b6842669edb16e43d49443b8023\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MainImageLoadOffset\" ref=\"aaf072b6842669edb16e43d49443b8023\" args=\"(CHAR const *file)\" -->\nLOCALFUN ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>MainImageLoadOffset</b> (CHAR const *file)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a0e36dab2a480daa8b416f76b6df377ff\">ScanLibraries</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a6796500f41701a58428c24ba32b2fa3d\">ImageInitialize</a> (BOOL forReplay)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a6d3018f88c9d1070213adee2748711d8\">ImageUnInitialize</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#afede320485ede702f65075f0428cadc4\">RTN_CheckFixups</a> (RTN rtn, INS target_ins, UINT32 probe_size)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a0599c5d25723d9156ba2c3b40ce916a8\">ImageInstrument</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a70582d67b216e4d32c5eb57a96940f54\">IMG_UnmapImage</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a54299136511761dd2d608374b8f12df0\">IMG_FreeDebugInfo</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a6b14fbaff11247c8c8008d72e83997fd\">NotifyDataRanges</a> (IMG img, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a5e0a0b00100c49bf205b4959f008e2f0\">CODE_RANGES</a> *rangeMap)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a0c5031ea2a7abe33d2687421ad35137b\">IMG_GetSubprogramsInfo</a> (IMG img, map&lt; ADDRINT, SymbolDebugInfo &gt; &amp;routines)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ac81803573d6e06ed7175617076f8a39b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobDisablePLTSyms\" ref=\"ac81803573d6e06ed7175617076f8a39b\" args=\"(KNOB_MODE_WRITEONCE,&quot;supported&quot;,&quot;disable_plt_syms&quot;,&quot;0&quot;,&quot;Disable synthesizing symbols for PLT entries&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobDisablePLTSyms</b> (KNOB_MODE_WRITEONCE,&quot;supported&quot;,&quot;disable_plt_syms&quot;,&quot;0&quot;,&quot;Disable synthesizing symbols for PLT entries&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aaea159000da6c5103330635232719df0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::operator&lt;\" ref=\"aaea159000da6c5103330635232719df0\" args=\"(const SYM_BASIC_INFO &amp;lhs, const SYM_BASIC_INFO &amp;rhs)\" -->\nLOCALNSFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>operator&lt;</b> (const SYM_BASIC_INFO &amp;lhs, const SYM_BASIC_INFO &amp;rhs)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga8cf4aca0b0bdbc7fc0ae965883d8e3c2\">PIN_InitSymbols</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af2a3d378dfd8aca7d241c3a079eab24e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_SymbolsInit\" ref=\"af2a3d378dfd8aca7d241c3a079eab24e\" args=\"()\" -->\nBOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PIN_SymbolsInit</b> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gac133406ab660e13f67dd64f27cdf67c6\">PIN_InitSymbolsAlt</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#ga139152abe353fdff0216a5519d261c73\">SYMBOL_INFO_MODE</a> mode)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ae8a1f617c162f08f07ca0f3bddd16292\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AddSym\" ref=\"ae8a1f617c162f08f07ca0f3bddd16292\" args=\"(SYM sym, IMG img, BOOL dynamic, const CHAR *sym_name, const SYMREC *rawsym, UINT32 imgsize, IADDR iaddr, SYM_IFUNC_TYPE Ifunc_type)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>AddSym</b> (SYM sym, IMG img, BOOL dynamic, const CHAR *sym_name, const SYMREC *rawsym, UINT32 imgsize, IADDR iaddr, SYM_IFUNC_TYPE Ifunc_type)</td></tr>\n<tr><td class=\"memTemplParams\" colspan=\"2\"><a class=\"anchor\" id=\"aa01c59aded2b966cb003b00340971153\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ConvertSym\" ref=\"aa01c59aded2b966cb003b00340971153\" args=\"(SYMREC *sym_dst, const SYMBOL_TYPE *sym_src)\" -->\ntemplate&lt;typename SYMBOL_TYPE &gt; </td></tr>\n<tr><td class=\"memTemplItemLeft\" align=\"right\" valign=\"top\">LOCALTEMPLATEFUN VOID&#160;</td><td class=\"memTemplItemRight\" valign=\"bottom\"><b>ConvertSym</b> (SYMREC *sym_dst, const SYMBOL_TYPE *sym_src)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ad95ab66c3555ab00a2b5c0ba976a4650\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CookSymIfuncSec\" ref=\"ad95ab66c3555ab00a2b5c0ba976a4650\" args=\"(IMG img, SYM ifunc_resolver, const SYMREC *symrec, SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP *sym_resolver_vs_actual_address_ifunc_map)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CookSymIfuncSec</b> (IMG img, SYM ifunc_resolver, const SYMREC *symrec, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad2ae6fe95412a7e60c6e2687215e7d96\">SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP</a> *sym_resolver_vs_actual_address_ifunc_map)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a72e3d3f338e8d24c40b34b2579b9b760\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetPltSec\" ref=\"a72e3d3f338e8d24c40b34b2579b9b760\" args=\"(IMG img, SEC *plt_sec, SEC *relocation_Sec)\" -->\nLOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>GetPltSec</b> (IMG img, SEC *plt_sec, SEC *relocation_Sec)</td></tr>\n<tr><td class=\"memTemplParams\" colspan=\"2\"><a class=\"anchor\" id=\"aa0d7b7aa02c68b20172772926a280858\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CookSymPltSec\" ref=\"aa0d7b7aa02c68b20172772926a280858\" args=\"(IMG img, const SYMBOL_TYPE *array, const CHAR *string_table)\" -->\ntemplate&lt;typename SYMBOL_TYPE &gt; </td></tr>\n<tr><td class=\"memTemplItemLeft\" align=\"right\" valign=\"top\">LOCALTEMPLATEFUN VOID&#160;</td><td class=\"memTemplItemRight\" valign=\"bottom\"><b>CookSymPltSec</b> (IMG img, const SYMBOL_TYPE *array, const CHAR *string_table)</td></tr>\n<tr><td class=\"memTemplParams\" colspan=\"2\"><a class=\"anchor\" id=\"a4a52bb1da30641471f52ade0b78e2e93\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CookSymSec\" ref=\"a4a52bb1da30641471f52ade0b78e2e93\" args=\"(set&lt; SYM_BASIC_INFO &gt; &amp;symbolSet, SEC sec_symtab, SEC sec_strtab, BOOL dynamic, SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP *sym_resolver_vs_actual_address_ifunc_map)\" -->\ntemplate&lt;typename SYMBOL_TYPE &gt; </td></tr>\n<tr><td class=\"memTemplItemLeft\" align=\"right\" valign=\"top\">LOCALTEMPLATEFUN VOID&#160;</td><td class=\"memTemplItemRight\" valign=\"bottom\"><b>CookSymSec</b> (set&lt; SYM_BASIC_INFO &gt; &amp;symbolSet, SEC sec_symtab, SEC sec_strtab, BOOL dynamic, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad2ae6fe95412a7e60c6e2687215e7d96\">SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP</a> *sym_resolver_vs_actual_address_ifunc_map)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a243c9fcfa976ce63de5d7119941cf47b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CompareSyms\" ref=\"a243c9fcfa976ce63de5d7119941cf47b\" args=\"(const SYM &amp;s1, const SYM &amp;s2)\" -->\nLOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CompareSyms</b> (const SYM &amp;s1, const SYM &amp;s2)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a5d07cc04a53e4b1aa407f43919c999e2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_SortRegsymsByIaddr\" ref=\"a5d07cc04a53e4b1aa407f43919c999e2\" args=\"(IMG img)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>IMG_SortRegsymsByIaddr</b> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a9d11d9715b1647d8454699309168b389\">CookRegsym</a> (IMG img, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad2ae6fe95412a7e60c6e2687215e7d96\">SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP</a> *sym_resolver_vs_actual_address_ifunc_map)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a6051e14b16661669c01ae646f7a96b75\">IMG_FindDataSymbolAddress</a> (IMG origImg, const CHAR *symname)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad5a0a2ae6adab89ea1f155d4136588ef\">SYM_IsDataMarker</a> (SYM sym)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a5d5512035e32f3b4d58b7175bb200836\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYM_NameNoVersion\" ref=\"a5d5512035e32f3b4d58b7175bb200836\" args=\"(const string &amp;symbolName)\" -->\nLOCALFUN string&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SYM_NameNoVersion</b> (const string &amp;symbolName)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af4a1dcfe0213de34daf6ca0259beb203\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::skipBackwardsMatchedPair\" ref=\"af4a1dcfe0213de34daf6ca0259beb203\" args=\"(const string &amp;undecoratedName, size_t pos, char openBra, char closeBra)\" -->\nLOCALFUN size_t&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>skipBackwardsMatchedPair</b> (const string &amp;undecoratedName, size_t pos, char openBra, char closeBra)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a72ec34c7e246924d6a35a8e0b6a6020d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::skipBackwardsTemplatedName\" ref=\"a72ec34c7e246924d6a35a8e0b6a6020d\" args=\"(const string &amp;undecoratedName, size_t pos)\" -->\nLOCALFUN size_t&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>skipBackwardsTemplatedName</b> (const string &amp;undecoratedName, size_t pos)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a4da40119364d4ad1b9783229cd8111b3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::sanitize\" ref=\"a4da40119364d4ad1b9783229cd8111b3\" args=\"(const string &amp;original)\" -->\nLOCALFUN string&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>sanitize</b> (const string &amp;original)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a0a3177506246aa6b62e500352de04969\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::cplus_demangle\" ref=\"a0a3177506246aa6b62e500352de04969\" args=\"(const string &amp;name, UNDECORATION style)\" -->\nLOCALFUN string&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>cplus_demangle</b> (const string &amp;name, <a class=\"el\" href=\"group__SYM__BASIC__API.html#ga2b7e9b0b1d3e5d38135695bdb1b380fe\">UNDECORATION</a> style)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">string&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a264d769aeff8fcaad10dec15db64a079\">SYM_UndecorateName</a> (const string &amp;symbolName, <a class=\"el\" href=\"group__SYM__BASIC__API.html#ga2b7e9b0b1d3e5d38135695bdb1b380fe\">UNDECORATION</a> style)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a3de79db7ac47bc101333fc8d2e0310ae\">AotiRecordCall</a> (<a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, INS ins, ACALL const *acall)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a99baa03aa92b6b342069040d11c49d76\">AotiRecordMutation</a> (INS ins, EXT ext)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab118b0b829996ea668ed5b3c43ff8e44\">AotiPlaybackCall</a> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aa33fad786d51ff6db7a51ad37f374c06\">AotiInstrumentationExists</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aa40d88269593cc522e42dd9069689434\">AotiRemoveImageInstrumentation</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga5f4e19c43f3de21d382c3c4e2442d961\">PIN_AddFollowChildProcessFunction</a> (<a class=\"el\" href=\"group__CHILD__PROCESS__API.html#gab109395d5b4fa72f83efaf0a449c340b\">FOLLOW_CHILD_PROCESS_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ac44f566bcb26066051a1f7c775670a0a\">PIN_RemoveFollowChildProcessFunctions</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a6ac9f850dbebce7bbe95f7e96eacace8\">CallFollowChildProcess</a> (<a class=\"el\" href=\"group__CHILD__PROCESS__API.html#ga17aa0357dbaaec79a971207a6d4ec281\">CHILD_PROCESS</a> childProcess, const char **toolAppend)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a9bb9b372e5702a51fb9bf390b1b08e7c\">InitializeFollowChildClient</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga2bf6029042d57fb825536c795c94d1ed\">OS_PROCESS_ID</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CHILD__PROCESS__API.html#ga0b2e319de5e952095201a6d15f257c39\">CHILD_PROCESS_GetId</a> (<a class=\"el\" href=\"group__CHILD__PROCESS__API.html#ga17aa0357dbaaec79a971207a6d4ec281\">CHILD_PROCESS</a> childProcess)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CHILD__PROCESS__API.html#ga49de6a716351cd4cc809a76685ebf74b\">CHILD_PROCESS_GetCommandLine</a> (<a class=\"el\" href=\"group__CHILD__PROCESS__API.html#ga17aa0357dbaaec79a971207a6d4ec281\">CHILD_PROCESS</a> childProcess, INT *pArgc, const CHAR *const **pArgv)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CHILD__PROCESS__API.html#ga40356c5b1a2fdaf98b6b7c9cedc9a860\">CHILD_PROCESS_SetPinCommandLine</a> (<a class=\"el\" href=\"group__CHILD__PROCESS__API.html#ga17aa0357dbaaec79a971207a6d4ec281\">CHILD_PROCESS</a> childProcess, INT argc, const CHAR *const *argv)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">void&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEBUG__API.html#ga1639763325d420bcaa5d873324f65bdd\">PIN_GetSourceLocation</a> (ADDRINT address, INT32 *column, INT32 *line, string *fileName)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#af562a0c721c14988965a5e367b2f7797\">CallDebugInterpreters</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *, const char *, const char **)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#add06479e9277d6495e56ed43a6244393\">CallBreakpointHandlers</a> (ADDRINT, USIZE, BOOL)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aac62d19ea850c5202aca9c662a9170e7\">CallInterceptedDebuggingEvent</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>, DEBUGGING_EVENT, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a7e114cbfb7f867187ad29a618a6fd0ec\">GetEmulatedRegister</a> (unsigned, <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *, VOID *)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a11140bb045d91fe035c4929dcc25ea5a\">SetEmulatedRegister</a> (unsigned, <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *, const VOID *)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN USIZE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a584437695086199ec608222e1c98125c\">GetTargetDescription</a> (const std::string &amp;, USIZE, VOID *)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a6ca1e80a9b07359325653e26b2bd460f\">DebuggerClientInitialize</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#ga57d86fbcd855d998c28e27a8dfa56643\">PIN_AddDebugInterpreter</a> (<a class=\"el\" href=\"group__APPDEBUG__API.html#ga10a867bb048e6ec4e52306a548604c2b\">DEBUG_INTERPRETER_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#ga43b1ad6ff739bc4f8e25a7dea7003149\">PIN_RemoveDebugInterpreter</a> (<a class=\"el\" href=\"group__APPDEBUG__API.html#ga10a867bb048e6ec4e52306a548604c2b\">DEBUG_INTERPRETER_CALLBACK</a> fun)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#ga83121e1cfc3de0791af5103d280d0582\">PIN_AddBreakpointHandler</a> (<a class=\"el\" href=\"group__APPDEBUG__API.html#gabe5afceda93e234bfb67111f319bef23\">DEBUG_BREAKPOINT_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#ga0b5f0fdc444755fff6835b10eb8ef458\">PIN_RemoveBreakpointHandler</a> (<a class=\"el\" href=\"group__APPDEBUG__API.html#gabe5afceda93e234bfb67111f319bef23\">DEBUG_BREAKPOINT_CALLBACK</a> fun)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#ga743648f0bd936eb557b18f5895719fa6\">PIN_ResetBreakpointAt</a> (ADDRINT addr)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#gad46f50d48ebcf2414e766c2978111c4b\">PIN_ApplicationBreakpoint</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, BOOL waitIfNoDebugger, const std::string &amp;msg)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#ga18ca2c9bdb2862120d0484fcbbc3b68c\">PIN_SetDebugMode</a> (const <a class=\"el\" href=\"structDEBUG__MODE.html\">DEBUG_MODE</a> *mode)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__APPDEBUG__API.html#ga41e814fff526e0232f2f8c3055d6e88b\">DEBUG_STATUS</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#gab15de5ddf44f7deef79a42e7b041ac12\">PIN_GetDebugStatus</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#gadf62887d32f6c37118fe5503d008a976\">PIN_GetDebugConnectionInfo</a> (<a class=\"el\" href=\"structDEBUG__CONNECTION__INFO.html\">DEBUG_CONNECTION_INFO</a> *info)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__APPDEBUG__API.html#ga87ad53f06ecf9cbcd3b94a155e1c11b5\">DEBUGGER_TYPE</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#ga00b8b40b94841bd54585a68f790417a7\">PIN_GetDebuggerType</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#gab76db0d06ebabd4a42540a92016b9d13\">PIN_WaitForDebuggerToConnect</a> (unsigned timeout)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#ga91b9a1cd6f3e3f8cd938d3135628ea3c\">PIN_GetStoppedThreadPendingToolBreakpoint</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, std::string *msg)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__APPDEBUG__API.html#gacfb688d9a56f440120ccce595b96edc2\">PIN_ChangePendingToolBreakpointOnStoppedThread</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, BOOL squash, const std::string &amp;msg)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#adfb0406b9445f953a6caff6cd8570a19\">PIN_InterceptDebuggingEvent</a> (DEBUGGING_EVENT eventType, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a371d93560a7f7ae5ec4b97c228197fce\">INTERCEPT_DEBUGGING_EVENT_CALLBACK</a> fun, VOID *arg)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#afefe009e0072dbf80e266586a2ab9987\">PIN_AddDebuggerRegisterEmulator</a> (unsigned numRegisters, const <a class=\"el\" href=\"structDEBUGGER__REG__DESCRIPTION.html\">DEBUGGER_REG_DESCRIPTION</a> *registerDescriptions, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a03b643cf8ed4f53d9578ae1c0ea80ff1\">GET_EMULATED_REGISTER_CALLBACK</a> getFun, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aa9709409d9f414af22b6c3f0a12c95a3\">SET_EMULATED_REGISTER_CALLBACK</a> setFun, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a9c0055d850f5c7299b4e3b9e3b26e53c\">GET_TARGET_DESCRIPTION_CALLBACK</a> getDescriptionFun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a32ba8de38eaf8c944cd602a756c2adff\">DeprecatedCallSignalBefores</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, INT32 sig, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *from, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *to)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a508ed445511af017a35bafb36134f856\">DeprecatedCallSignalAfters</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *from, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *to)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#acec3a8376aede04a6af2aed6706ceb2c\">DeprecatedCallThreadBegins</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, VOID *sp, int flags)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a81fa093db0b8a9bbff132e64b68691bc\">DeprecatedCallThreadEnds</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, INT32 code)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af3e1287a136c3877012ee0cb76038969\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallSignalIntercept\" ref=\"af3e1287a136c3877012ee0cb76038969\" args=\"(THREADID tid, INT32 sig, CONTEXT *ctxt, BOOL hasHandler, const EXCEPTION_INFO *pExceptInfo, VOID *v)\" -->\nLOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CallSignalIntercept</b> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, INT32 sig, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, BOOL hasHandler, const <a class=\"el\" href=\"group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5\">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga3d4d01746c8a1cc2da7a25dd6ec815c7\">PIN_AddSignalBeforeFunction</a> (<a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga0e02ac705fda839f4942303a0dbd92a9\">SIGNAL_BEFORE_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga93cf14f5d64433de5959455e6e1f8de0\">PIN_AddSignalAfterFunction</a> (<a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga139244febc8272114b851ac93a8cd36d\">SIGNAL_AFTER_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#gaf99a4acc59e0f245616d8cd9c0185dff\">PIN_AddSignalInterceptFunction</a> (INT32 sig, <a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga2116b73be99579bae5c752aae9eb3ab4\">SIGNAL_INTERCEPT_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#gaa24902575aa63431437aae0584684d04\">PIN_AddThreadBeginFunction</a> (<a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#gae72726a7bc47716300b14a903f63c492\">THREAD_BEGIN_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga51ce6b5ee948e9d8690a5b48d09e5810\">PIN_AddThreadEndFunction</a> (<a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga1da3746b42e9e84eef562509c680ea7b\">THREAD_END_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga88572848d7557febc865048a567c3f27\">PIN_StartProbedProgram</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#gace98ae592b27550a32c0fbaad49c38c6\">RTN_IsSafeForProbe</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga6ab3dd02d81a017184fdb7b732cf2978\">RTN_ReplaceWithUninstrumentedRoutine</a> (RTN replacedRtn, AFUNPTR replacementFun)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga62d795230ca66a1a9cf6e16726a120dd\">CODECACHE_FlushCache</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#gab4c2363befe741703c215542105bdbd4\">CODECACHE_InvalidateTraceAtProgramAddress</a> (ADDRINT app_pc)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga0a660ced8895b07128693f68ac1110ba\">CODECACHE_InvalidateRange</a> (ADDRINT start, ADDRINT end)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga766616b0f13d433fc3fcd3b73fec9618\">TRACE_Original</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga90254ac41e24350fa450360f1a3a3f0a\">CALLBACK_SetExecutionPriority</a> (<a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a> callback, INT32 priority)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API INT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga4bd1ae07cf0209a2bf59cd1b63cd3c49\">CALLBACK_GetExecutionPriority</a> (<a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a> callback)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a8ff1d63a65e7e1a6fbeb7ad47a014d71\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobSymFamily\" ref=\"a8ff1d63a65e7e1a6fbeb7ad47a014d71\" args=\"(&quot;pintool:sym&quot;,&quot;Symbols controls&quot;)\" -->\nLOCALVAR KNOB_COMMENT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobSymFamily</b> (&quot;pintool:sym&quot;,&quot;Symbols controls&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ab4de70a1eebac85a02f1894706be4bec\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobUnrestrictedRtnSize\" ref=\"ab4de70a1eebac85a02f1894706be4bec\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;unrestricted_rtn_size&quot;,&quot;0&quot;,&quot;Use the unrestricted RTN size. &quot;&quot;When set the RTN size defined by the distance between RTN start to the beginning of next RTN.&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobUnrestrictedRtnSize</b> (KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;unrestricted_rtn_size&quot;,&quot;0&quot;,&quot;Use the unrestricted RTN size. &quot;&quot;When set the RTN size defined by the distance between RTN start to the beginning of next RTN.&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ad088d5c3b73d7b3b1d80f96caefccb88\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobShortName\" ref=\"ad088d5c3b73d7b3b1d80f96caefccb88\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;short_name&quot;,&quot;0&quot;,&quot;Use the shortest name for the RTN. &quot;&quot;Names with version substrings are preferred over the same name without the substring.&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobShortName</b> (KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;short_name&quot;,&quot;0&quot;,&quot;Use the shortest name for the RTN. &quot;&quot;Names with version substrings are preferred over the same name without the substring.&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a8a0935532cc0cb15293a1909b9e64ee3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobIgnoreDebugInfo\" ref=\"a8a0935532cc0cb15293a1909b9e64ee3\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;ignore_debug_info&quot;,&quot;0&quot;,&quot;Ignore debug info for the image. Symbols are taken from the symbol tables.&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobIgnoreDebugInfo</b> (KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;ignore_debug_info&quot;,&quot;0&quot;,&quot;Ignore debug info for the image. Symbols are taken from the symbol tables.&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a1fcb06188b26b0e5cdd510c9ae451dfb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobReduceRtnSizeMode\" ref=\"a1fcb06188b26b0e5cdd510c9ae451dfb\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;reduce_rtn_size_mode&quot;,&quot;auto&quot;,&quot;Mode for RTN size reduction: delete trailing instructions after RET if there is no &quot;&quot;jump to the rtn part after the RET. &quot;&quot;Possible modes are: auto/never/always&quot;)\" -->\nLOCALVAR KNOB&lt; string &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobReduceRtnSizeMode</b> (KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;reduce_rtn_size_mode&quot;,&quot;auto&quot;,&quot;Mode for RTN size reduction: delete trailing instructions after RET if there is no &quot;&quot;jump to the rtn part after the RET. &quot;&quot;Possible modes are: auto/never/always&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">KNOB&lt; BOOL &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a965db2da01b01a6f3f1b2b714cb9e68d\">KnobJitApi</a> (KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;support_jit_api&quot;,&quot;0&quot;,&quot;Enables the Jitted Functions Support&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a8f748c25dbd531810b17e33193c8b134\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_is_shadow_img\" ref=\"a8f748c25dbd531810b17e33193c8b134\" args=\"(IMG img)\" -->\nLOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>IMG_is_shadow_img</b> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gad253413a215b0730931e785fdea285e2\">IMG_Next</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga523b30e6483010ae4f257554740c9849\">IMG_Prev</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga3fad5a2c5057d27742af9bd2d6f78098\">IMG_Invalid</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga2a31e066181719e79810b0cf784e726e\">IMG_Valid</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">SEC&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gaa9597e002a76d7a5e5e1b530bb263aad\">IMG_SecHead</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">SEC&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gaf1dd3caa46530d580d28259df2cf6f60\">IMG_SecTail</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">SYM&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga5394fba999264f58cb4838b8061dd79f\">IMG_RegsymHead</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga315b455812c1b5bb5d49862479fcf5ef\">IMG_Entry</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">const string &amp;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga50e1d947e0949aa33f0d35804968d560\">IMG_Name</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gadb638cffcab6c6ce15595e34a2188f64\">IMG_Gp</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga28653b8b716d88949c50cac0252d38a1\">IMG_LoadOffset</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga287976c95e15d6f5655ce9a665723711\">IMG_LowAddress</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga9057f7b0d638da4e104683f492d2f300\">IMG_HighAddress</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gad194d40eeeff2afd8a3ae0c6ade3359c\">IMG_StartAddress</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">USIZE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gafb2f9299a425268ad06747da54d40418\">IMG_SizeMapped</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG_TYPE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gac39ef3534ad9ade281df0c2938abe695\">IMG_Type</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gac8f52592ec23aa3eee464d3400f0ab51\">IMG_IsMainExecutable</a> (IMG x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga9554196d5213d2d8e8bf6d4f2ce08a82\">IMG_hasLinesData</a> (IMG x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga8da4468dd8be5a65b31bc1c558bc8b6a\">IMG_IsInterpreter</a> (IMG x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga3d8e588e75d2dd3f2b3959b9e8d21402\">IMG_IsStaticExecutable</a> (IMG x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga7f6693257db1e0c70cea152a86df4653\">IMG_IsVDSO</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gadb1f082009379b8efe0567239d256a2b\">IMG_NumRegions</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga048915d5f7bcb371ed460e679e5f143a\">IMG_RegionHighAddress</a> (IMG img, UINT32 n)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga86a6cc871c017abe758742b82380353c\">IMG_RegionLowAddress</a> (IMG img, UINT32 n)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ade7195737db5709d9d52e4820ded936e\">IMG_FindRtnByName</a> (IMG img, const string &amp;name)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a9275e667363750faddd564ea4c2f5942\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FinalizeRtn\" ref=\"a9275e667363750faddd564ea4c2f5942\" args=\"(RTN rtn, USIZE size)\" -->\nLOCALFUN RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FinalizeRtn</b> (RTN rtn, USIZE size)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a4d892caa22bf4980175e68f26ee16296\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AddRtnsToMap\" ref=\"a4d892caa22bf4980175e68f26ee16296\" args=\"(IMG img)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>AddRtnsToMap</b> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aadd937a10996937e8601c196bbb22bde\">IMG_CreateAt</a> (const char *filename, ADDRINT start, USIZE size, ADDRINT loadOffset, BOOL mainExecutable)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#gac57c906aeabfa47c07300e6a70d70c05\">SEC_Img</a> (SEC sec)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">SEC&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#ga0f20232da7164c5a2bd7a484218cfa36\">SEC_Next</a> (SEC sec)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">SEC&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#gaf1b1ecd1d013d0c960929881a2c81d72\">SEC_Prev</a> (SEC sec)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">SEC&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#gaaf0fea51106fcabe3752c03052159d0b\">SEC_Invalid</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#ga584ce38ee42410cf65bb5c7201760663\">SEC_Valid</a> (SEC x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#ga2b837186aae0819ca2389253438d22b9\">SEC_RtnHead</a> (SEC sec)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#gaafd10f481120aea485de5af8436c8158\">SEC_RtnTail</a> (SEC sec)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">const string &amp;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#ga3d9f8a437007612c3a45c9caf3d5f269\">SEC_Name</a> (SEC sec)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">SEC_TYPE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#gaca496c584d38d1f27f3e6144eca81d3c\">SEC_Type</a> (SEC sec)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#ga823cc57ab85dd3f1313e452236ccceec\">SEC_Mapped</a> (SEC sec)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">const VOID *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#gabb32012ee0f7b436ee1fc9b7beec102f\">SEC_Data</a> (SEC sec)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">SEC&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga4883c839d424578a9f6983d05e6a9a12\">RTN_Sec</a> (RTN x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga491bf55c9718f8751054ebe37b460d65\">RTN_Next</a> (RTN x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gad8d3497e9c27305ba5e9e77e169996ac\">RTN_Prev</a> (RTN x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga8499bc83ee010e62a121237ee277224d\">RTN_Invalid</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga6ac855c9a19a3aab44347188e6695875\">RTN_Valid</a> (RTN x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a2e828345e38e794f601bd5dcf306a364\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RtnOutsideRangesManager\" ref=\"a2e828345e38e794f601bd5dcf306a364\" args=\"()\" -->\nLOCALINLINE RTN_OUTSIDE_RANGES &amp;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RtnOutsideRangesManager</b> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad2dc3f523c9139e9b34fd992f8cf4def\">DisassembleRegion</a> (RTN rtn, BBL bbl, const VOID *current, const VOID *end, ADDRINT rtnStart, ADDRINT rtnEnd, ADDRINT rtnLimit, ADDRINT virtual_offset)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a915bbeefd6a459df55415c4d4e9aa895\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DisassembleFirstIns\" ref=\"a915bbeefd6a459df55415c4d4e9aa895\" args=\"(const VOID *current, const VOID *end, ADDRINT limit, ADDRINT virtual_offset)\" -->\nLOCALFUN INS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DisassembleFirstIns</b> (const VOID *current, const VOID *end, ADDRINT limit, ADDRINT virtual_offset)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a9f8e728637840cb26d5016cc41a2b00a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FetchRtnIns\" ref=\"a9f8e728637840cb26d5016cc41a2b00a\" args=\"(RTN rtn)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FetchRtnIns</b> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a2e7440fb2f8676d5c895198706028359\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FetchRtnInsFirstOnly\" ref=\"a2e7440fb2f8676d5c895198706028359\" args=\"(RTN rtn)\" -->\nLOCALFUN INS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FetchRtnInsFirstOnly</b> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API BBL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga8045abedf21160f94f418df6a986e46e\">RTN_BblHead</a> (RTN x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API BBL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga5e2e2ef9a5187dea1991904a326b0160\">RTN_BblTail</a> (RTN x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">const string &amp;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gaf9d9689a59240ecc29c80d584f268c72\">RTN_Name</a> (RTN x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga2df028d74e179059f26b4b45cd6d260a\">RTN_IsArtificial</a> (RTN x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">SYM&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gaf0bc95e4eccdcd11cf9b3033a0d5ba78\">RTN_Sym</a> (RTN x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">AFUNPTR&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga039af36fbf3aa4014f30ff8c31b41f9a\">RTN_Funptr</a> (RTN x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a22a3dc3f37c8807e398207ae3c9ae18f\">RTN_Destroy</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga10e6c8d7293bdeae08b2940e3c57c0f0\">RTN_Id</a> (RTN x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API INT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#gafc1187b3faca66b3613aa2a056391f06\">RTN_No</a> (RTN x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">INS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#ga7618bc7c80a25024227d3a24d59b936b\">BBL_InsHead</a> (BBL x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">INS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#ga732ec73ec6ef1bd2dfcd26f80d7de9da\">BBL_InsTail</a> (BBL x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BBL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#gadd7141abb47139b52922e04e0c4a10f3\">BBL_Next</a> (BBL x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BBL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#gaf02bad35306c92f23db35bf956cf03d0\">BBL_Prev</a> (BBL x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#ga58a8d019cd09ce46cfe431ec8f14a075\">BBL_Valid</a> (BBL x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BBL_TYPE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ac1e81d9d0d09a669a18bff1ca6c56247\">BBL_Type</a> (BBL x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">EDG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a3fac8ea1c46bf047849cdf42c369f2df\">EDG_NextSucc</a> (EDG x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">EDG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a53f3fcf0151e3349d95416e25ee4d9c6\">EDG_INVALID</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a0ab2a735ea8ee72c359d758b526be822\">EDG_Valid</a> (EDG x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">EDG_TYPE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a1b2f4b1757a053c6670262210511ffd8\">EDG_Type</a> (EDG x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#ga45207e8a66dd24f7e1718679edbd2cd4\">INS_Rtn</a> (INS x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">INS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#ga227ce58a739b1573125c11071ecb48de\">INS_Next</a> (INS x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">INS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#ga8af1c76af4b35e637b2d27602f5a7287\">INS_Prev</a> (INS x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">INS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#gac811aea087098408689897c77156a74b\">INS_Invalid</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#ga3a8b61fffa9ae4ad9f899b21ce37397c\">INS_Valid</a> (INS x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#ga6b685dec56c6a045f8cc3c03f52d054a\">INS_Address</a> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">USIZE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#ga9d23f5a7bc5b619a933fda60d832cec9\">INS_Size</a> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#ga4f6e9ddc2fbc4721b9447009a29b487f\">INS_DirectBranchOrCallTargetAddress</a> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API__GEN__IA32.html#ga75b390df45e1f00b03f6a5e832cc8dd0\">INS_NextAddress</a> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">SYM&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#ga41641c7ae44bbd4985dbe53de9cadbcd\">SYM_Next</a> (SYM x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">SYM&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#gaaa7da67a974321461f71cdabaa570332\">SYM_Prev</a> (SYM x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">const string &amp;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#gab8745ce55b3edeccdd9dce81e29cb71d\">SYM_Name</a> (SYM x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">SYM&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#ga7f5f9c4a276ee72cab7b3146bb00bdbd\">SYM_Invalid</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#ga222198e876ee9b2a72deeea3ed5c4008\">SYM_Valid</a> (SYM x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#gaeabc9c888e1a602c9fb3f4ac76e268ad\">SYM_Dynamic</a> (SYM x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#gad8dee48248ed711909920868ccd5a5c8\">SYM_GeneratedByPin</a> (SYM x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#gabd5966d9cd59cc55a0ecc2960a8bf13a\">SYM_IFuncImplementation</a> (SYM x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#ga597c47ff86b5ca2dd7a109f0f0cfd90b\">SYM_IFuncResolver</a> (SYM x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#ga8b72567bd2c6639c367519927913c6bd\">SYM_Value</a> (SYM x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#gac3bbe7a24b51a24e82ccccf8bdbe1b93\">SYM_Index</a> (SYM x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#gad90d4926d803a56df07434aa225fec1c\">SYM_Address</a> (SYM x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a27719fdb1dc48dc421e36c15fa2c2e53\">GetOpenImg</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a2a2baa8394fbab603d57712dd827f14d\">ResetOpenRtn</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ac011223a420ad84e67025c76652d2234\">ResetOpenImg</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a594102de771efeea2fe096fb4a863841\">InitializeApp</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a1bcddc1b9f7d528b4fa332bb663de28d\">UnInitializeApp</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gae9802263d9ceb357e46f215d86294548\">IMG_Id</a> (IMG x)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga2a14587e0c206aac7cbd0e6c14e9ca44\">IMG_FindImgById</a> (UINT32 id)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab55faf03bbd86c746ddd7bd04733c4e2\">IMG_FindByUnloadAddress</a> (ADDRINT startAddress)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga30b412953fdb2924c9db4f49398cfc7b\">IMG_FindByAddress</a> (ADDRINT address)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a636f5a30b095a80e421afd7b01a871c8\">IMG_FindBySectionsAddress</a> (ADDRINT address)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gad10b9862dbe2f9bef8f7978492c35d01\">RTN_AddInstrumentFunction</a> (<a class=\"el\" href=\"group__RTN__BASIC__API.html#gad0b5091252621bacc4645cb920fdc403\">RTN_INSTRUMENT_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a41956b23df33a4edf1abc2cd1a2e81e5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::operator&lt;\" ref=\"a41956b23df33a4edf1abc2cd1a2e81e5\" args=\"(const RTN_KEY &amp;p1, const RTN_KEY &amp;p2)\" -->\nLOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>operator&lt;</b> (const RTN_KEY &amp;p1, const RTN_KEY &amp;p2)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#ga494869187b5d94d7dd346bc9ff49642f\">IMG_AddInstrumentFunction</a> (<a class=\"el\" href=\"group__IMG__BASIC__API.html#ga3c454c8efe9960033aabdcc1c43b8fa7\">IMAGECALLBACK</a> fun, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a83b7d0a3393009112f8aa269daf76bde\">IMG_RemoveToolCallbacks</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gadd37dea66b2c1c46ef45d77023926a95\">IMG_AddUnloadFunction</a> (<a class=\"el\" href=\"group__IMG__BASIC__API.html#ga3c454c8efe9960033aabdcc1c43b8fa7\">IMAGECALLBACK</a> fun, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a51bad3bb0ae3ff57d9c24bc2ca296f5c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_Destroy\" ref=\"a51bad3bb0ae3ff57d9c24bc2ca296f5c\" args=\"(IMG img)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>IMG_Destroy</b> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a99b914317dfaaaf652b87dc8dc5496eb\">ProcessImageUnload</a> (IMG img, BOOL copyBits)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a378032ed84e6a188b5ac8553ddd42f56\">PIN_UnloadAllImages</a> (BOOL copyBits)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a97b3b556deafad660b25d2cfa5961d09\">ProcessModuleUnload</a> (ADDRINT base)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">USIZE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga3a60bd22473cbf464bca49b3390c79bb\">RTN_Range</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">USIZE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga5a80e8ef7b6d02902b07ca889f4b5b35\">RTN_Size</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gaa1a4dc39a9f5124f74b2e65df3ccf32e\">RTN_IFuncResolver</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gaf56269b96a74a3ccf6c6466f07887c39\">RTN_IFuncImplementation</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a77f732e4c5ac55a7637888a8180c6e0f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InitRtnToSym\" ref=\"a77f732e4c5ac55a7637888a8180c6e0f\" args=\"(RTN rtn, SYM sym)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>InitRtnToSym</b> (RTN rtn, SYM sym)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a0caca792f9c4bba25b61e9860830afe0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::UseShortName\" ref=\"a0caca792f9c4bba25b61e9860830afe0\" args=\"(RTN rtn, SYM sym)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>UseShortName</b> (RTN rtn, SYM sym)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a4b2ee1f00601aadd8abf22723688bbed\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::BestFit\" ref=\"a4b2ee1f00601aadd8abf22723688bbed\" args=\"(RTN rtn, SYM sym)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>BestFit</b> (RTN rtn, SYM sym)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a3a5cc7a7fe9a618c8605749edc17b9f2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SymPosition\" ref=\"a3a5cc7a7fe9a618c8605749edc17b9f2\" args=\"(SYM sym, const MemRange &amp;range)\" -->\nLOCALFUN INT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SymPosition</b> (SYM sym, const MemRange &amp;range)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a3bfb3f37ebea5ae134fc1a35f0c10a34\">FindCodeRanges</a> (IMG img, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a5e0a0b00100c49bf205b4959f008e2f0\">CODE_RANGES</a> *rangeMap)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a231d65c3bf9fe87bc7aa830f8548ea45\">NotifyDataRange</a> (<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a5e0a0b00100c49bf205b4959f008e2f0\">CODE_RANGES</a> *rangeMap, ADDRINT base, USIZE size)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a143873432f63ca179546919b83c78183\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MakeRtns\" ref=\"a143873432f63ca179546919b83c78183\" args=\"(IMG img)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>MakeRtns</b> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#abfd805493ad262757ea268fbe1e60dc1\">CallRtnCallbacks</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a1d448a967d61bd03d8859c4f2d142068\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallRtnCallbacks\" ref=\"a1d448a967d61bd03d8859c4f2d142068\" args=\"(IMG img)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CallRtnCallbacks</b> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ae4cd8f264c1b7c1a956e9791de83f993\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DsUpdatesDueRtnfuncCreation\" ref=\"ae4cd8f264c1b7c1a956e9791de83f993\" args=\"(RTN rtnToSplit, RTN originatedFromIfunc, ADDRINT rtnToSplitAddr, ADDRINT rtnToSplitSize, ADDRINT newRtnAddr)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DsUpdatesDueRtnfuncCreation</b> (RTN rtnToSplit, RTN originatedFromIfunc, ADDRINT rtnToSplitAddr, ADDRINT rtnToSplitSize, ADDRINT newRtnAddr)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a502dad94477f5b3020177c63c54944b2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::handleIfuncSymbol\" ref=\"a502dad94477f5b3020177c63c54944b2\" args=\"(ADDRINT actualFuncAddr, SYM resolver, IMG img)\" -->\nLOCALFUN RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>handleIfuncSymbol</b> (ADDRINT actualFuncAddr, SYM resolver, IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a807583ac0f175b7d4a772fe98a24a05a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FixSymbolsFromDebugInfo\" ref=\"a807583ac0f175b7d4a772fe98a24a05a\" args=\"(IMG img)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FixSymbolsFromDebugInfo</b> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a1649d9c970131f057da27ada51b87947\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImgLoad\" ref=\"a1649d9c970131f057da27ada51b87947\" args=\"(const string &amp;filename, const CHAR *trueFilename, ADDRINT load_offset, UINT32 flags, BOOL *unmapAfterProcessing, void *arg)\" -->\nLOCALFUN IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ImgLoad</b> (const string &amp;filename, const CHAR *trueFilename, ADDRINT load_offset, UINT32 flags, BOOL *unmapAfterProcessing, void *arg)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a6f8fe5b67c1f6c020af0197c224b27c8\">IMG_RecordLoadOp</a> (const string &amp;imageName, const char *fileName, ADDRINT lo, UINT32 fl)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad8e7dc716b74328e4678af5254dd61bc\">IMG_RecordLoadOp</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#abae8411a46a9d56cd275314f8c37d2c8\">IMG_ExecuteRecordedLoadOps</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gaee6aa7a71640eddc7fc99c24c73798fd\">IMG_Open</a> (const string &amp;filename)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gabc73d2aa6dcfec0e2fe57b602905c0b8\">IMG_Close</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a6feda1aafac2fe621a0961fb5f53cc3b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImageLoadProbes\" ref=\"a6feda1aafac2fe621a0961fb5f53cc3b\" args=\"(IMG img)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ImageLoadProbes</b> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a9dca1c25a1b23e9d43b7e27b7c56bf6a\">ProcessImageLoad</a> (const string &amp;filename, const CHAR *trueFilename, ADDRINT load_offset, UINT32 flags, void *loaderInfo, void *arg)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a73a27a7179751469a966b7794a875a5b\">ProcessImageLoad</a> (const string &amp;filename, const CHAR *trueFilename, ADDRINT load_offset, UINT32 flags, void *arg)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a12b4fb22826ca2519efbaae1b473f065\">IMG_ReplayImageLoad</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad6b4454f38290f1668a10f0b1a8b45e9\">IMG_GetLoaderInfo</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a2e19c3407381daae95c0b8c302e2eb7c\">IMG_SetLoaderInfo</a> (IMG img, VOID *loaderInfo)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ac8e782e5b73d7578df307fbf803518f8\">CompleteImageLoad</a> (IMG img, void *arg)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a6e89485f4d64a274f849636054a79e03\">InitDynamicCodeImage</a> (IMG newImg)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a5f6603e4222111db606b2cbf67dea7fe\">IsPinLoaded</a> (const string &amp;name)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">string&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga46d422d71d917e2cd7cd374c10804341\">RTN_FindNameByAddress</a> (ADDRINT address)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga6f86e6509f4bddb238576cda772c15de\">RTN_FindByAddress</a> (ADDRINT address)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga77a2ad03e0431b881d6c3019b45261eb\">RTN_FindByName</a> (IMG img, const CHAR *name)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gaf8714086f8aebc9feacccc8cd02dc561\">RTN_Open</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ac5f5e2c7eb0d86fb1147d299bbaf1cda\">RTN_OpenAndFetch</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga37272253377eb65c9eb5ff47ec4f1e6b\">RTN_Close</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">INS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gab1bd91206939b88057664c46ef8eac86\">RTN_InsHead</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">INS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga2ff7a2210bc42f9367635f0bf30b24cb\">RTN_InsHeadOnly</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">INS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gaab13f04ab2dcb762c79aea42c5aef69d\">RTN_InsTail</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga540e1cb6a6c696d3da538abd5e369fc5\">RTN_NumIns</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga76bde295a78d1232fd6ff98a5ff011cf\">RTN_InsertCall</a> (RTN rtn, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga83a81fae96c9faabe0f1c90a0d7e865f\">RTN_Address</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gaa6c9c5c444bffe61f7a37cb478517eff\">RTN_CreateAt</a> (ADDRINT address, string name)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a34300d01ab3b416b0f310038785d55fc\">RTN_CreateJitFunction</a> (IMG img, ADDRINT address, const string &amp;name, USIZE size)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ae4d47dafafa0234f556207c029cec943\">RTN_DestroyJitFunction</a> (ADDRINT address)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga260a065245b69511e0071b2b469f854b\">RTN_IsDynamic</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#gaeaf8824c1817dbd47764dc61703b409b\">SEC_Address</a> (SEC sec)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#gaa22bf6cb0666d1c1861d7742ad9ac4db\">SEC_IsReadable</a> (SEC sec)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#ga65221462de831ab90631f2712e617810\">SEC_IsWriteable</a> (SEC sec)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#ga25886aa281f8ba375da93621c6c26315\">SEC_IsExecutable</a> (SEC sec)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">USIZE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SEC__BASIC__API.html#ga757392dabac8e8f072edd00259702c58\">SEC_Size</a> (SEC sec)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#ga87270a66b97b60a42443922cdeac47a1\">BBL_Original</a> (BBL bbl)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#gaa11bc3cbdfb07b039491b17501b58e63\">BBL_Address</a> (BBL bbl)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">USIZE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#ga5bd7460c8ffab83343046308a5ae646f\">BBL_Size</a> (BBL bbl)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gaf7f7aef4682f740253cbbc139562826a\">APP_ImgHead</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__IMG__BASIC__API.html#gad7bd2faff9cbc8a30e73cc6e7d845d0f\">APP_ImgTail</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#affb5a0ee4b3aaff697b0cfffbcd36c82\">ToolUseImageAPI</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">string&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__SYM__BASIC__API.html#gaac3a758d968bd9cf375ba740c2beb46e\">PIN_UndecorateSymbolName</a> (const string &amp;symbolName, <a class=\"el\" href=\"group__SYM__BASIC__API.html#ga2b7e9b0b1d3e5d38135695bdb1b380fe\">UNDECORATION</a> style)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga60adbdd03078851f0e2611ab06e17c19\">PIN_AddInternalExceptionHandler</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#ga64b49da7310c130bcebb21c1fcaaf318\">INTERNAL_EXCEPTION_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga75d9372356e0cda2acb7f5851d328575\">PIN_TryStart</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, <a class=\"el\" href=\"group__PIN__CONTROL.html#ga64b49da7310c130bcebb21c1fcaaf318\">INTERNAL_EXCEPTION_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga4b5c7f34928a2594509ba69baf404129\">PIN_TryEnd</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a28129e84544f4ed5c37d92cb6b5d65f9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ProbeTag_String\" ref=\"a28129e84544f4ed5c37d92cb6b5d65f9\" args=\"(PROBE_TAG tag)\" -->\nLOCALFUN string&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ProbeTag_String</b> (PROBE_TAG tag)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BBL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a60639d7058702b7bc9b83388e2ed2cce\">TRACE_AddInlineReturnEdg</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BBL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a8af18c7c1f7c32d14d9a38d60556c2f5\">TRACE_AddInlineCallEdg</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BBL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a45df0793879feb51088aac93a00ab445\">TRACE_AddBranchEdg</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BBL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad2a16414294c509cc41912bc341f8317\">TRACE_AddFallthroughEdg</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a05c7f6a42280e66aa8d7e52637268d3b\">TRACE_StraightenControlFlow</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a7c9aa0bae875df798c7e2d3fd7b44706\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_InsertProbeImp\" ref=\"a7c9aa0bae875df798c7e2d3fd7b44706\" args=\"(ADDRINT src_addr, ADDRINT dst_addr, USIZE probeSize)\" -->\nLOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PIN_InsertProbeImp</b> (ADDRINT src_addr, ADDRINT dst_addr, USIZE probeSize)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a10ae4e3b3638ebaedff562b6a68be3ad\">PIN_InsertProbe</a> (ADDRINT src_addr, ADDRINT dst_addr)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a0616c43a557393a0f1b5120fc1025262\">PIN_RemoveProbe</a> (ADDRINT address)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a18ec62f2e936ef49a1700c8b17e6ce81\">TRACE_GenerateCode</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aaf7404039cd1f80f9b11877cb9fe7514\">INS_IsPinXfer</a> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a8a9254d5fb8ca4f675bf394b6b95b688\">INS_IsNativeXfer</a> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ae3a6085d1927a8f339a250ce48aa7e61\">INS_SetNativeXfer</a> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a9dfb00c2773416c3f18b271ca4762c83\">INS_skip_xlate_set</a> (INS ins, BOOL b)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a29b1cc638bb5ccc9fa63185386b74f5b\">TRACE_ExitsXferToNative</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a0e46cb329ac1fda6ccc52e8c6be97760\">INS_SetPinXfer</a> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a113cc21664dc0b7431b23e7c0c072d56\">INS_IsNativeCall</a> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ade23e9e0cbe9ef7a0eb0af6e92aab648\">INS_IsXlateCall</a> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab1605a8c9ecb9af1028a30a82ecba468\">INS_SetXlateCall</a> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ac59d3b948aae49f7e0ef78ab5fc1a0cb\">INS_SetNativeCall</a> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga294137f03b1d950d0f1f95968979b490\">PIN_IsProbeMode</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gabb4b02d78ee780c3b70e86a86ff798cd\">PIN_IsAttaching</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a4a20b1b6367663d4c3da83439ea4cd89\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckInsSequenceForProbe\" ref=\"a4a20b1b6367663d4c3da83439ea4cd89\" args=\"(INS ins, UINT32 probe_size)\" -->\nLOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CheckInsSequenceForProbe</b> (INS ins, UINT32 probe_size)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a0af73397284764d03efb7033eca6ee3a\">BBL_InvalidForProbe</a> (BBL bbl)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a00e3461bafde757b3234ef4a60cfd3e9\">RTN_CheckRtnSizeForProbe</a> (RTN rtn, INS target_ins, BOOL checkForPadding, UINT32 probe_size)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#abb6b7ba49de88820d087a2a43ab8bc53\">ProbeMayOverwriteBranchTarget</a> (INS target_ins, UINT32 probe_size, BOOL *mayOverwriteUnidentifiedBranchTarget)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN PROBE_TAG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a45c8eb634b2c3fb728a520b1503a8455\">CheckProbeSafetyStatically</a> (INS ins, RTN rtn, BOOL checkForPadding, UINT32 probe_size)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ab9b59fe0a26934b9893a842eac925799\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_IsRelocatable\" ref=\"ab9b59fe0a26934b9893a842eac925799\" args=\"(RTN rtn)\" -->\nLOCALFUN PROBE_TAG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_IsRelocatable</b> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN PROBE_TAG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#acd925b36779e20f1a4aac18ecc736957\">CheckForProbeOverlap</a> (INS ins, USIZE probe_size, BOOL allowPOP)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN PROBE_TAG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a71ee07774932285f8bdb639f0b8897f9\">CheckForSafeProbe</a> (INS ins, BOOL allowPOP, USIZE *probe_size, USIZE suggested_probe_size, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf\">PROBE_MODE</a> mode, BOOL checkForPadding)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"abbef8cfd91734756a0f995d1e708b8f8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_CheckForSafeProbe\" ref=\"abbef8cfd91734756a0f995d1e708b8f8\" args=\"(RTN rtn, BOOL allowPOP, PROBE_TAG *tagptr, USIZE *probe_size, USIZE suggested_probe_size, PROBE_MODE mode, BOOL checkForPadding)\" -->\nLOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_CheckForSafeProbe</b> (RTN rtn, BOOL allowPOP, PROBE_TAG *tagptr, USIZE *probe_size, USIZE suggested_probe_size, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf\">PROBE_MODE</a> mode, BOOL checkForPadding)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga5133c810a48e94f566fecc2c11eb1f50\">RTN_IsSafeForProbedInsertion</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gaac635416e3b16a25d8bb9d157979bde4\">RTN_IsSafeForProbedInsertionEx</a> (RTN rtn, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf\">PROBE_MODE</a> mode)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga7e153406e2ff0031186ea67d9da1e2d7\">RTN_IsSafeForProbedReplacement</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gaaccf66a3919efb9807dbd86bcb4ec36a\">RTN_IsSafeForProbedReplacementEx</a> (RTN rtn, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf\">PROBE_MODE</a> mode)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a6d40a197e4b6d1c77ada83ce9a0a2827\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CookArguments\" ref=\"a6d40a197e4b6d1c77ada83ce9a0a2827\" args=\"(va_list argList, ADDRINT instAddress, BOOL addReturnReg)\" -->\nLOCALFUN <a class=\"el\" href=\"group__INST__ARGS.html#gafbeb707dc23c7c09e1e8c932649107d5\">IARGLIST</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CookArguments</b> (va_list argList, ADDRINT instAddress, BOOL addReturnReg)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a1b7291ccba5e224f3799aea8f4230997\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CookArgumentsRTN\" ref=\"a1b7291ccba5e224f3799aea8f4230997\" args=\"(va_list argList, RTN rtn)\" -->\nLOCALFUN <a class=\"el\" href=\"group__INST__ARGS.html#gafbeb707dc23c7c09e1e8c932649107d5\">IARGLIST</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CookArgumentsRTN</b> (va_list argList, RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ab71fac8b25e30ad6d71964340400de35\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CookArgumentsINS\" ref=\"ab71fac8b25e30ad6d71964340400de35\" args=\"(va_list argList, INS ins)\" -->\nLOCALFUN <a class=\"el\" href=\"group__INST__ARGS.html#gafbeb707dc23c7c09e1e8c932649107d5\">IARGLIST</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CookArgumentsINS</b> (va_list argList, INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a0352306027e09b54c3100f5669aee10c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_ReplaceSignatureProbedImpl\" ref=\"a0352306027e09b54c3100f5669aee10c\" args=\"(RTN orgRtn, AFUNPTR replacement, PROBE_MODE mode, va_list argList)\" -->\nLOCALFUN AFUNPTR&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_ReplaceSignatureProbedImpl</b> (RTN orgRtn, AFUNPTR replacement, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf\">PROBE_MODE</a> mode, va_list argList)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">AFUNPTR&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gaec56561cab520a5493a599800319447b\">RTN_ReplaceSignatureProbed</a> (RTN replacedRtn, AFUNPTR replacementFun,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">AFUNPTR&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#gaae095733d136989fd0ebf49546758c65\">RTN_ReplaceSignatureProbedEx</a> (RTN replacedRtn, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf\">PROBE_MODE</a> mode, AFUNPTR replacementFun,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a7fc556909765b5c53d83a4e43dce53b4\">INS_ReplaceSignatureProbed</a> (INS orgIns, AFUNPTR replacementFunptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ae3e15336d0231e3c06f7622b54466685\">TRACE_Oaddr</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">AFUNPTR&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a95268c597d6a7374f0fb025b5ea1f6cd\">RTN_InsertProbe</a> (RTN rtn, AFUNPTR replacement, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf\">PROBE_MODE</a> mode)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab443407913cc8da0d33f50b2e83a8cb2\">RTN_InsertCallProbedImpl</a> (RTN rtn, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, AFUNPTR funptr, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf\">PROBE_MODE</a> mode, va_list argList)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga8654a9e07644e5f6a73db1abea0899a7\">RTN_InsertCallProbed</a> (RTN orgRtn, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga77f0894505803bbae6da71ee1f3a3781\">RTN_InsertCallProbedEx</a> (RTN orgRtn, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf\">PROBE_MODE</a> mode, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aad6fc85e416ff68c910ef0bc35e75eee\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_CheckForProbeInsertion\" ref=\"aad6fc85e416ff68c910ef0bc35e75eee\" args=\"(INS ins)\" -->\nLOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>INS_CheckForProbeInsertion</b> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga389d27155d820029712f396a2a824370\">PIN_IsSafeForProbedInsertion</a> (ADDRINT addr)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a7869d6cf8708e35c81aec2ba8697e34d\">INS_InsertCallProbed</a> (INS orgIns, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, AFUNPTR funPtr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga163322863f36bbbeef986c94d319eef0\">PIN_InsertCallProbed</a> (ADDRINT addr, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">INT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga8903109ba2b31277e60c7225e74120b3\">RTN_CodeRangesProbed</a> (RTN rtn, INT32 num, <a class=\"el\" href=\"structPIN__CODE__RANGE.html\">PIN_CODE_RANGE</a> *buffer)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a4827df1144e026140854053f6260e004\">CompleteProbesInstrumentationForCurrentModule</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad4cd44dc0a1ca88938976161c979d026\">Open_Rtn</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ac10e5a998df02e25ba25f567e424d08d\">Close_Rtn</a> (RTN rtn)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PROTO__API.html#ga554ff954c3ea33bb537f30e3b500ef1c\">PROTO</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PROTO__API.html#ga83166e4f44766add35b740312e346054\">PROTO_Allocate</a> (<a class=\"el\" href=\"structPARG__T.html\">PARG_T</a> returnArg, <a class=\"el\" href=\"group__PROTO__API.html#gacfd9f3c8dc22310ce9b9152e8c61b17c\">CALLINGSTD_TYPE</a> cstype, const char *name,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PROTO__API.html#ga164ba9eb7fbd418343184b0e2c8a3ae6\">PROTO_Free</a> (<a class=\"el\" href=\"group__PROTO__API.html#ga554ff954c3ea33bb537f30e3b500ef1c\">PROTO</a> proto)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">GLOBALCONST <a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#gae29dca6df4a80d9086c1574c6f430a1c\">PIN_CALLBACK_INVALID</a> (0)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a7aa1ce4877e9a29e504fdf1afd092a14\">VmFunctionNotInitialized</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a9936729c76df7c3e79bbf5f609091081\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_RemoveToolCallbacks\" ref=\"a9936729c76df7c3e79bbf5f609091081\" args=\"()\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PIN_RemoveToolCallbacks</b> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af7060ca06ca3d2f85d308a1611db2c9e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobProfile\" ref=\"af7060ca06ca3d2f85d308a1611db2c9e\" args=\"(KNOB_MODE_WRITEONCE,&quot;supported:stat&quot;,&quot;profile&quot;,&quot;0&quot;,&quot;print amount of memory dynamically allocated but not yet freed by the tool&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobProfile</b> (KNOB_MODE_WRITEONCE,&quot;supported:stat&quot;,&quot;profile&quot;,&quot;0&quot;,&quot;print amount of memory dynamically allocated but not yet freed by the tool&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ae1a0ec37fc6b360cb87f21ebf086f6a4\">IsThreadInFiniCallback</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e\">OS_THREAD_ID</a> sysId)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a2237ed51b22e4d29cdcd02d7c6b05ea8\">Shutdown</a> (INT32 exitCode)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a0f99adf62cd8712fb64b6f5f04864604\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoInstructions\" ref=\"a0f99adf62cd8712fb64b6f5f04864604\" args=\"(TRACE trace)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoInstructions</b> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af9e5f6f7cea24221726874ac44a20259\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckNoJITCallbacks\" ref=\"af9e5f6f7cea24221726874ac44a20259\" args=\"()\" -->\nLOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CheckNoJITCallbacks</b> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aa3d5e8e46a1f58d25b6f4f5fe2d6aa85\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckNoProbeCallbacks\" ref=\"aa3d5e8e46a1f58d25b6f4f5fe2d6aa85\" args=\"()\" -->\nLOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CheckNoProbeCallbacks</b> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALINLINE <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e\">OS_THREAD_ID</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a3550baa3be6c6f98a4cd4b43c7a69e13\">GetCurrentSysId</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e\">OS_THREAD_ID</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a5e21abe87547bf0b628e611f239f11e6\">GetCurrentSysIdById</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"adda1c978810da31589197a41d1a4f0b6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobCheckLocks\" ref=\"adda1c978810da31589197a41d1a4f0b6\" args=\"(KNOB_MODE_WRITEONCE,&quot;supported:message&quot;,&quot;checklocks&quot;,&quot;1&quot;,&quot;Check locks are used correctly&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobCheckLocks</b> (KNOB_MODE_WRITEONCE,&quot;supported:message&quot;,&quot;checklocks&quot;,&quot;1&quot;,&quot;Check locks are used correctly&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ad09d111e59ded6f50d1590b8352400b3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InitClientLock\" ref=\"ad09d111e59ded6f50d1590b8352400b3\" args=\"()\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>InitClientLock</b> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aa6376f0f3895bc1ecfbc0b4d0959293a\">CheckPinClientLock</a> (const CHAR *funname)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gadf5abd51ee9b1d599c539a9e2784e9ef\">PIN_LockClient</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gaa6239dd852b5236f75413209aceb7a79\">PIN_UnlockClient</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a5adbfb1ca2cd769ad1a2a93693f06eb8\">PIN_TryClientLock</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a242a7c455a425daf7f88b593eda19e95\">PIN_CallerOwnsClientMutex</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e\">OS_THREAD_ID</a> osid)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a2853e9235fb6484c4048916f51c1f4dd\">PIN_CallerOwnsClientMutex</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a34ff185bcb1194021bc0c00dc5394b6e\">EnterPinClientMasterMode</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a97b8e7b9232fe94a75d5a8860d542daa\">ExitPinClientMasterMode</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a1dfb99281484eff25cd26a613cbee884\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TraceWithFunctionReplacement\" ref=\"a1dfb99281484eff25cd26a613cbee884\" args=\"(TRACE trace)\" -->\nLOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>TraceWithFunctionReplacement</b> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN size_t&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aaff64400633bd73fd02b76cb7970155f\">InstFetcher</a> (void *copyBuf, const VOID *address, size_t maxSizeToCopy, <a class=\"el\" href=\"group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5\">EXCEPTION_INFO</a> *pExceptInfo)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a3561aa931697b6dfd7b9e59bb565023b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SetInTraceCallbacks\" ref=\"a3561aa931697b6dfd7b9e59bb565023b\" args=\"()\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SetInTraceCallbacks</b> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af60ed2764da9963865d9be5f7b68ca21\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ReSetInTraceCallbacks\" ref=\"af60ed2764da9963865d9be5f7b68ca21\" args=\"()\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ReSetInTraceCallbacks</b> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad64eb00b9187bdd65bf2f1ff694c4647\">GetInTraceCallbacks</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a2b7c73780476c5c06a3c9553841c0661\">CallTraceCallbacks</a> (REGION *region)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">INS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a1b2ed34f406f5224a3cc97d79bad3fd8\">TraceFirstIns</a> (ADDRINT currTraceAddr)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aa2681511ab60e48e3bd1db8c815ab2d5\">CallFinis</a> (INT32 code)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a401b23264662f635d37ef4b093dabc23\">NotifyOutOfMemory</a> (size_t size)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a4b81d1361174167557d948ea6eb1a7dc\">NotifyPrepareForFini</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN ADDRINT <br class=\"typebreak\"/>\nPIN_FAST_ANALYSIS_CALL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a1c2a79b9049f8a9ab48dd784b53be8ff\">CallMemoryAddrTrans</a> (<a class=\"el\" href=\"structPIN__MEM__TRANS__INFO.html\">PIN_MEM_TRANS_INFO</a> *memTransInfo, void *)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aeffae3f5bdc9b9e05ccd2957ec93cabf\">CallForksBefore</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadId, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a79e4460dea1b39fb174638a48f72952e\">CallForksAfterInParent</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadId, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ac870ed7f318d38ecc29792c1405a886e\">CallForksAfterInChild</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadId, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a9ae6545b0de8e11ceeb2a156fbddb308\">DoDetachs</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#afa31ee9aebf2996a8bff0ad0ddabdc7c\">NotifyDetachCompletedJitMode</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a173100747aaaf9a7a5ea268ea03d689e\">ImageInitializeFirst</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab6cad33f4573660889e02d65241cd6f8\">CallApplicationStart</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a37517ef9880857f380a896b503385f53\">DoDetachsProbed</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a622417b787f3af47c1bf78ef6c7a1b26\">CallDetachCompletionCallback</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a91b20661756eb216ce79a1a00cf28c7c\">DoAttachsProbed</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aba984baec4378aafe754751c02c7fa5f\">InitializeClientTls</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ae29376630884d0b2b76de2c5ca3ec305\">DestroyClientTls</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad0af5a85f4b90c58305ceb49b56e190b\">CallThreadStarts</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, INT32 flags)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aa37067a024fe890ef1f75990d847d704\">CallThreadFinis</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, INT32 code)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aa5de4339e0e000dbdb81471cad2382b7\">CallContextChanges</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__PIN__CONTROL.html#ga8e4e6511a0e09fdc5ec7d6dbf395b3a8\">CONTEXT_CHANGE_REASON</a> reason, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *from, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *to, INT32 info)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aa52208efeab7bd250e87838239b897d9\">CallSyscallEntry</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, SYSCALL_STANDARD std)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a841e66c6ef638d7c61edd9dcf5ab38a9\">CallSyscallExit</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, SYSCALL_STANDARD std)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab29eb4fae54c8a104e811af43ac4d916\">CallSmcCallbacks</a> (ADDRINT traceStartAddress, ADDRINT traceEndAddress)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ac5af6e1448c76411194b5d77bd361b8f\">CallInterceptSignal</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, INT32 sig, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, BOOL hasHandler, const <a class=\"el\" href=\"group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5\">EXCEPTION_INFO</a> *pExceptInfo)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a559f28d92aef38a62230ad30a5a5b692\">CallThreadAttachInProbeMode</a> (VOID *sigmask)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a33979b57dc3a084f7eaa5b2ee99d6a03\">CallThreadDetachInProbeMode</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#af97df78b685115c02e1f43ffd119c9c0\">CallThreadAttachInJitMode</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a6db5bfe9dd4fd5813f6ea524942894e0\">CallThreadDetachInJitMode</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadIndex, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a900f475870cb230ee9b8a98233feffad\">CallProbesInserted</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__ERROR__FILE__BASIC.html#ga84c94bd764e6504ea991d147476376eb\">PIN_WriteErrorMessage</a> (const char *msg, INT32 type, <a class=\"el\" href=\"group__ERROR__FILE__BASIC.html#gaa5229e893bc3646b53b8547328305441\">PIN_ERR_SEVERITY_TYPE</a> severity, INT32 num,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a9d57189aaaa0ce87cb1e42ae8f55c23b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoReplaceFunByNativeCall\" ref=\"a9d57189aaaa0ce87cb1e42ae8f55c23b\" args=\"(INS ins, VOID *v)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoReplaceFunByNativeCall</b> (INS ins, VOID *v)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a994b5deb430ebc469b6036e076f20609\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoInstrumentForFunReplacement\" ref=\"a994b5deb430ebc469b6036e076f20609\" args=\"(REGION *region, BOOL firstInstIsReplaceable)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DoInstrumentForFunReplacement</b> (REGION *region, BOOL firstInstIsReplaceable)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">AFUNPTR&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga64940153e16fee5bd143a95bdf67c5af\">RTN_Replace</a> (RTN replacedRtn, AFUNPTR replacementFun)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">AFUNPTR&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga2dcaf2242c7a62151d89c01e2f04f8c0\">RTN_ReplaceSignature</a> (RTN replacedRtn, AFUNPTR replacementFun,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">AFUNPTR&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga63500925719539624424cd62a8d027f9\">RTN_ReplaceProbed</a> (RTN replacedRtn, AFUNPTR replacementFun)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">AFUNPTR&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__RTN__BASIC__API.html#ga935f735a52675d54fdb5a40b99de2026\">RTN_ReplaceProbedEx</a> (RTN replacedRtn, <a class=\"el\" href=\"group__RTN__BASIC__API.html#gaabed1675b61b2375c45d3b9e157a15bf\">PROBE_MODE</a> mode, AFUNPTR replacementFun)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#af1d748476519707c91124bacb9eda9a7\">CheckNotInCallback</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, const char *function)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga5ae5853e6600a23f9c552cba784870cc\">PIN_CallApplicationFunction</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, <a class=\"el\" href=\"group__PROTO__API.html#gacfd9f3c8dc22310ce9b9152e8c61b17c\">CALLINGSTD_TYPE</a> cstype, AFUNPTR origFunPtr, <a class=\"el\" href=\"structCALL__APPLICATION__FUNCTION__PARAM.html\">CALL_APPLICATION_FUNCTION_PARAM</a> *param,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aae0f15e77f8bd505e412a86f5d6ae7c8\">CallApplicationFunctionUnchecked</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, <a class=\"el\" href=\"group__PROTO__API.html#gacfd9f3c8dc22310ce9b9152e8c61b17c\">CALLINGSTD_TYPE</a> cstype, AFUNPTR origFunPtr, <a class=\"el\" href=\"structCALL__APPLICATION__FUNCTION__PARAM.html\">CALL_APPLICATION_FUNCTION_PARAM</a> *param,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__BASIC__API.html#ga32b488980f5ec67eb7b4e58eb4e5c527\">INS_IsAddedForFunctionReplacement</a> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#gaf1c86d763dffeb6535d82f12e0e9ac7c\">PIN_RegisterItcAuxCallBackPushFun</a> (AFUNPTR callBackPushFun)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga7a6e36a22de42687453baf685b435c9e\">RTN_ComplexReplaceWithUninstrumentedRoutine</a> (RTN replacedRtn, AFUNPTR replacementFun)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga1b8018033f600345427e3d6108a60ddf\">PIN_FindAlternateAppStack</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3a7c84e73f2b260812b67bca49d37ed3\">CALLBACK_SetExecutionOrder</a> (<a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a> callback, <a class=\"el\" href=\"group__INST__ARGS.html#ga3d1d5f6805cb16d00bce441290ca2212\">CALL_ORDER</a> order)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__INST__ARGS.html#ga3d1d5f6805cb16d00bce441290ca2212\">CALL_ORDER</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#gaca5b99a09f97738c08fc0b7f8ef3988e\">CALLBACK_GetExecutionOrder</a> (<a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a> callback)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#ga41381de13d25c4bbd968cb64cb719d56\">TRACE_AddInstrumentFunction</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaaec88a4f6dc5f49e092754540a5ed7b0\">TRACE_INSTRUMENT_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#gaaff4a98e0ece27fc46c0050b4ae05c6d\">INS_AddInstrumentFunction</a> (<a class=\"el\" href=\"group__INS__INST__API.html#gaf8c8e7d6c9872e80d4571ba461dff870\">INS_INSTRUMENT_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gac167b8d28d255e53a0ac1f6e9edcd3ec\">PIN_AddFiniFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gaacb361fd2832e34cc92e7f03bd1f1621\">FINI_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga3ca849f6b9c098afb7769e0845cc52c1\">PIN_AddPrepareForFiniFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#ga680e195155c9e4141d994512b31a319b\">PREPARE_FOR_FINI_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga50e51f92c7ea2b6d8b271ecf71a7db65\">PIN_AddFetchFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#ga308874ca87663350daa5608de534a0ce\">FETCH_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">size_t&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga29ad6213c90cfee4a67640798c0c2501\">PIN_FetchCode</a> (void *copyBuf, const VOID *address, size_t maxSize, <a class=\"el\" href=\"group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5\">EXCEPTION_INFO</a> *pExceptInfo)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga897b98855a1853146f9d291687f41946\">PIN_AddOutOfMemoryFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gabbf7a42619fda89affa3df8bddebc32e\">OUT_OF_MEMORY_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga6d9a4cd860d8168ce1dab07da404752e\">PIN_AddMemoryAddressTransFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#ga1a1c5b833df7e988522aa312890d1ca4\">MEMORY_ADDR_TRANS_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#gac54c633b19be7ead9057abb84d2155e6\">TRACE_AddSmcDetectedFunction</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gafa7e66beec272534d120b9ab3ea4ca84\">SMC_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga1a1c5b833df7e988522aa312890d1ca4\">MEMORY_ADDR_TRANS_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga8852a4e2eb765b1356069037bdf05f83\">PIN_GetMemoryAddressTransFunction</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gafc04e55a26e3b74cdebb8c6a1bf5503b\">PIN_AddDetachFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gad1e358c0ce1a5aef73f263b2800deb36\">DETACH_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gafd8d7788f12ec84f1c81074851ff716d\">PIN_AddDetachFunctionProbed</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#ga1edd9181ea2f698c21c743be7f93267e\">DETACH_PROBED_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga93431bb0680a22395327ac7d8bb0c14c\">PIN_AddThreadStartFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#ga4b987e362ca821776c61f27af5d54574\">THREAD_START_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga6bdae30ea6adc711a3ae04aed47bc222\">PIN_AddThreadAttachProbedFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gab3501b75015ec6c930b97b2f190195d1\">THREAD_ATTACH_PROBED_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga697a1abfcdcc139915c008190aba9dcb\">PIN_AddThreadAttachFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gaf61282484a7afd5e278ae6a7023862b0\">THREAD_ATTACH_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gae579102abbf9c663827c82b867db63ad\">PIN_AddThreadDetachProbedFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gae2f1f3018393574f4949f8ce61ce6c32\">THREAD_DETACH_PROBED_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga7f157496433d50573d2f025beca83e5a\">PIN_AddThreadDetachFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#ga57f8ed1dca340de4282fe3327b44ca81\">THREAD_DETACH_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga4516c650e020cd12a5425b08588d2ae2\">PIN_AddApplicationStartFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gae1c672af1a7b69eed84982ed7e3efcdb\">APPLICATION_START_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gae79d468cc5e19b450603f07f3397203d\">PIN_AddThreadFiniFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#ga670ae83f83ef39ac19d793e16b23c5ca\">THREAD_FINI_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga786fd61c9be3c42a1a6deefc71dffadf\">PIN_AddContextChangeFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gaf57e5726e099445f81e9b529336ba073\">CONTEXT_CHANGE_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#ga85b302054acdd2a2d1314d5c311855d9\">PIN_AddSyscallEntryFunction</a> (<a class=\"el\" href=\"group__PIN__SYSCALL__API.html#gabee4934fa6434c13c0c2f4ce2a6468dd\">SYSCALL_ENTRY_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#ga435e2ea4e20a9042f471759211972ac8\">PIN_AddSyscallExitFunction</a> (<a class=\"el\" href=\"group__PIN__SYSCALL__API.html#ga6579efc9b9f38ac589db8559fc503ea8\">SYSCALL_EXIT_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga240de32335a0aca3ceee37ad96b1dd12\">PIN_InterceptSignal</a> (INT32 sig, <a class=\"el\" href=\"group__PIN__CONTROL.html#ga93cea72a6023405d0e90c65c81a62d6f\">INTERCEPT_SIGNAL_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gac7795f34b4a267644e4d10b288c38d96\">PIN_UnblockSignal</a> (INT32 sig, BOOL enable)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gaec69b96ad1f34e000f56a06abfd1311b\">PIN_SetSmcSupport</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#ga0244f9b4e34e4eed7d483fa6ec7b70f0\">SMC_ENABLE_DISABLE_TYPE</a> enable_disable)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga234255869a62bce07edda25d34ffd5b7\">PIN_AddProbesInsertedFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#ga880c51b16479dde27cb248f038b4ab76\">PROBES_INSERTED_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CALLBACKS.html#ga3ba1895c602cd5b2863b7b75840187a4\">PIN_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga7282900fb6160031936d8b63fecc4e21\">PIN_AddForkFunction</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gab459bf0034704bf1aa7fa7e192b7dc08\">FPOINT</a> point, <a class=\"el\" href=\"group__PIN__CONTROL.html#gadc08958640205e2e9ff994fdac917a25\">FORK_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga7f5784c3b9431086f3b5b750912ca0c2\">PIN_RemoveInstrumentation</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gaf896499ed7402ef4e34baaa64626e0bd\">PIN_RemoveInstrumentationInRange</a> (ADDRINT start, ADDRINT end)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gafc1635c2b2550236a66dcba25f9cc8a7\">PIN_RemoveFiniFunctions</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga6277d16bf33ede39685a26a92fc3cbef\">PIN_Detach</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gaf9a18d894714ae57264a2302638fc4b3\">ATTACH_STATUS</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga4940c04f3fe39a87090c6872b9ba7e5a\">PIN_Attach</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#ga50ed540b287876494d489a0fb863f0f4\">ATTACH_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga634584cd69b124a7edd58655010e295f\">PIN_DetachProbed</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gaf9a18d894714ae57264a2302638fc4b3\">ATTACH_STATUS</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga5630fbebba55f0b78adb96adccc8daf8\">PIN_AttachProbed</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#ga250c31d0d85cd9ec799f30752c476841\">ATTACH_PROBED_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a3b22db0e4d8dd250862e029535f40b78\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckAndUpdateCondInstState\" ref=\"a3b22db0e4d8dd250862e029535f40b78\" args=\"(char const *typeName, CONDINSTSTATE &amp;lastState, CONDINSTSTATE currState)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CheckAndUpdateCondInstState</b> (char const *typeName, CONDINSTSTATE &amp;lastState, CONDINSTSTATE currState)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#ga26d02bff719bf8600421895956804252\">INS_InsertPredicatedCall</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> ipoint, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#ga74a956a0acde197043d04f4adcde4626\">INS_InsertCall</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#ga7907ad8ebd991b9e24df3b3b9cec4cac\">INS_InsertIfCall</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#ga952b2b061d3fa8f1cc4d5d59fef53a69\">INS_InsertThenCall</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#ga5009833ffeecd9fecd8f842a605bf2a1\">INS_InsertIfPredicatedCall</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#ga88f930cbed33fa370c9611cc0183d97b\">INS_InsertThenPredicatedCall</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a8af54e336d13d0a50e3a1c45c426559b\">AInsertCall</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> ipoint, PREDICATE pred, COND_CALL_TYPE condCallType, AFUNPTR funptr, va_list ap)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a7bc27a1f2ee76485897d0b3d46b6ebf3\">AInsertVersionCase</a> (INS ins, REG reg, INT32 case_value, ADDRINT version, va_list ap)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aa93dc8c79dbf90ccf3deef77a20a1fc9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::StartProgram\" ref=\"aa93dc8c79dbf90ccf3deef77a20a1fc9\" args=\"()\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>StartProgram</b> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gadfef9e89968c6491114d7ceae51ab61b\">PIN_CONFIGURATION_INFO</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gabf3035f1cd239935bb4b9d45b39be266\">PIN_CreateDefaultConfigurationInfo</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga48dd43d356a2b768c7c0d3cbc4e1fee6\">PIN_SetAllowedConcurrentCallbacks</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gadfef9e89968c6491114d7ceae51ab61b\">PIN_CONFIGURATION_INFO</a> options, <a class=\"el\" href=\"group__PIN__CONTROL.html#ga4e114852e46d5d839d6e71e242709777\">PIN_CALLBACK_TYPE</a> callbackType)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gaded401aeb030a76ee3396137b06ad808\">PIN_StartProgram</a> (<a class=\"el\" href=\"group__PIN__CONTROL.html#gadfef9e89968c6491114d7ceae51ab61b\">PIN_CONFIGURATION_INFO</a> options=PIN_CreateDefaultConfigurationInfo())</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga01a31bf221500b0ca0b97fb64cc62247\">PIN_StartProgramProbed</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af94fc9b878408fef2c29c9e9f1da8591\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DumpPinVersion\" ref=\"af94fc9b878408fef2c29c9e9f1da8591\" args=\"()\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DumpPinVersion</b> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a7be3a8b27a027fc432e6d33c27236afb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobPintoolFamily\" ref=\"a7be3a8b27a027fc432e6d33c27236afb\" args=\"(&quot;pintool&quot;,&quot;Pin tools switches&quot;)\" -->\nLOCALVAR KNOB_COMMENT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobPintoolFamily</b> (&quot;pintool&quot;,&quot;Pin tools switches&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ac1c95594011b1ec3d5b89d0da5ae6e52\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobGeneralFamily\" ref=\"ac1c95594011b1ec3d5b89d0da5ae6e52\" args=\"(&quot;supported&quot;,&quot;General developer switches&quot;)\" -->\nLOCALVAR KNOB_COMMENT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobGeneralFamily</b> (&quot;supported&quot;,&quot;General developer switches&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a0515d8455d1aaef16ce0c9f1354f8ec0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobBasicFamily\" ref=\"a0515d8455d1aaef16ce0c9f1354f8ec0\" args=\"(&quot;supported:basic&quot;,&quot;Basic switches&quot;)\" -->\nLOCALVAR KNOB_COMMENT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobBasicFamily</b> (&quot;supported:basic&quot;,&quot;Basic switches&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aa2afebd4506e0ee3361a3df434791b60\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobDebugFamily\" ref=\"aa2afebd4506e0ee3361a3df434791b60\" args=\"(&quot;supported:debug&quot;,&quot;General switches&quot;)\" -->\nLOCALVAR KNOB_COMMENT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobDebugFamily</b> (&quot;supported:debug&quot;,&quot;General switches&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a9a693e1c60d8d29731c99c67598d3083\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobMessageFamily\" ref=\"a9a693e1c60d8d29731c99c67598d3083\" args=\"(&quot;supported:message&quot;,&quot;Message switches&quot;)\" -->\nLOCALVAR KNOB_COMMENT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobMessageFamily</b> (&quot;supported:message&quot;,&quot;Message switches&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aa12766a9e9e89bc96e35a6e906f1c387\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobRegionFamily\" ref=\"aa12766a9e9e89bc96e35a6e906f1c387\" args=\"(&quot;supported:region&quot;,&quot;Region generation switches&quot;)\" -->\nLOCALVAR KNOB_COMMENT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobRegionFamily</b> (&quot;supported:region&quot;,&quot;Region generation switches&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ab2e260c571cc0f269e556f53c1768101\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobRegAllocFamily\" ref=\"ab2e260c571cc0f269e556f53c1768101\" args=\"(&quot;supported:regalloc&quot;,&quot;Register allocation switches&quot;)\" -->\nLOCALVAR KNOB_COMMENT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobRegAllocFamily</b> (&quot;supported:regalloc&quot;,&quot;Register allocation switches&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a5355849bb055e8d819ef2f2e4d77ea7f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobLogFile\" ref=\"a5355849bb055e8d819ef2f2e4d77ea7f\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;logfile&quot;,&quot;pintool.log&quot;,&quot;The log file path and file name&quot;)\" -->\nLOCALVAR KNOB&lt; string &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobLogFile</b> (KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;logfile&quot;,&quot;pintool.log&quot;,&quot;The log file path and file name&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aaf30635b3b92cc8364221dd1711cd06e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobUniqueLogFiles\" ref=\"aaf30635b3b92cc8364221dd1711cd06e\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;unique_logfile&quot;,&quot;0&quot;,&quot;The log file names will contain the pid&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobUniqueLogFiles</b> (KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;unique_logfile&quot;,&quot;0&quot;,&quot;The log file names will contain the pid&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"affa19f08d264629bfa0fb3d2ac7df6bc\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobHelp1\" ref=\"affa19f08d264629bfa0fb3d2ac7df6bc\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;help&quot;,&quot;0&quot;,&quot;Print help message (Return failure of PIN_Init() in order to allow the tool\\\n                             to print help message)&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobHelp1</b> (KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;help&quot;,&quot;0&quot;,&quot;Print help message (Return failure of PIN_Init() in order to allow the tool\\\n                             to print help message)&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"addf8e398c072b67403c371bd2862a1c6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobHelp2\" ref=\"addf8e398c072b67403c371bd2862a1c6\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;h&quot;,&quot;0&quot;,&quot;Print help message (Return failure of PIN_Init() in order to allow the tool\\\n                             to print help message)&quot;)\" -->\nLOCALVAR KNOB&lt; BOOL &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>KnobHelp2</b> (KNOB_MODE_WRITEONCE,&quot;pintool&quot;,&quot;h&quot;,&quot;0&quot;,&quot;Print help message (Return failure of PIN_Init() in order to allow the tool\\\n                             to print help message)&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">KNOB&lt; BOOL &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a597f1a848e384f3ea3682a72ff009bfa\">KnobAppendLogFile</a> (KNOB_MODE_WRITEONCE,&quot;supported&quot;,&quot;append_logfile&quot;,&quot;0&quot;,&quot;Append to the end of the log file if it already exists&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">MESSAGE_TYPE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ae3cf23142dd361a5388d198c8971e14e\">MessageTypeLogImage</a> (&quot;log_image&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: image API&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">MESSAGE_TYPE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#af82bb0cef427898c7e7596a5351967d4\">MessageTypeLogSym</a> (&quot;log_sym&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: symbol API&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">MESSAGE_TYPE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a5f739dea50f93f289f36b605e465a22a\">MessageTypeLogProbe</a> (&quot;log_probe&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: probe information&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">MESSAGE_TYPE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a330863d93ba1490c1e6095145abb0f22\">MessageTypeLogBuffer</a> (&quot;log_buffer&quot;,&quot;&quot;, false, false, false, true, LOGTYPE_LOGFILE,&quot;pin log: buffering&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">MESSAGE_TYPE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad8d0947f828dbfa7e225ceb85d12ed8a\">MessageTypeLogUnwind</a> (&quot;log_unwind&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: unwind&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">MESSAGE_TYPE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a6ff7cf915b4d32c6e4518de0c8ff1767\">MessageTypeLogFetchRtnIns</a> (&quot;log_fetch_rtn_ins&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: fetch rtn ins information&quot;)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga76e7349023b7f2616e5a203662048da0\">ParseCommandLine</a> (int xargc, CHAR **xargv)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a144d787b42fcc13ce9f5f4a1c68dd7d6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_ParseCommandLine\" ref=\"a144d787b42fcc13ce9f5f4a1c68dd7d6\" args=\"(int xargc, CHAR **xargv, BOOL standAlone)\" -->\nLOCALFUN BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PIN_ParseCommandLine</b> (int xargc, CHAR **xargv, BOOL standAlone)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a76b12d093b37bceeb49d28a2b57c153f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InitializeCallBacks\" ref=\"a76b12d093b37bceeb49d28a2b57c153f\" args=\"()\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>InitializeCallBacks</b> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">SECTION_END GLOBALDLLFUN <br class=\"typebreak\"/>\nPINCLIENTINT *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#af377b565131f78619a601361d21f72b5\">ClientInt</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">GLOBALDLLCFUN PINCLIENTINT *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a1ba7380410fb3c87de838eae9e87d913\">ClientIntC</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga783d3bd40c3fb2ca51b1f9af31a70c9c\">PIN_Init</a> (INT32 argc, CHAR **argv)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a0b084c12668f64a8f5631ffe014bcfaf\">PIN_SetReplayMode</a> (UINT32 flags)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab066724c31a244041d5850216840fc52\">TRACE_Allocate</a> (ADDRINT addr)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#adccb4c741e7b559636ed11944109c278\">TRACE_AllocateForProbe</a> (PROBE_TYPE probeType, ADDRINT addr, RTN rtn, USIZE probeSize, BOOL mustReadAtLeastProbesizeBytes)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a9c3568e4ff3275f8869bf6f1c31fab92\">TRACE_RelocateOriginalInsAddr</a> (ADDRINT addr)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ac729f22ec7341faf38d82a9e0ba73db6\">TRACE_Deallocate</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a13e6a00c19122a0c2369540fb6d84ba6\">TRACE_CodeRtn</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#ga39917f34980f1c764e855232ddcc64e4\">TRACE_InsertCall</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#ga670d4fbb52d4c3acb83420b7168d5299\">TRACE_InsertIfCall</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaa1d6600c78738b465bc948333a1c47c9\">TRACE_InsertThenCall</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BBL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#ga008abc5ba1af8d9e9cd073ffe0aefa18\">TRACE_BblHead</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BBL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaa4aa2f32db009042fce6003cf3865772\">TRACE_BblTail</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#ga4279cae8e263cf4f65e17444b1697386\">TRACE_Address</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">USIZE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#ga00ad4fc2b7e9560f33adf5e9cfb11e94\">TRACE_Size</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#gab59d17665260b3f35f743f3669b87488\">TRACE_Rtn</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf5115f280788d0dd1252109c3b63fb75\">TRACE_HasFallThrough</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#ga099b3edb27c5d8ba22af27300394e4bf\">TRACE_NumBbl</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#ga47a689f7fca5d78c1e546af88b856daa\">TRACE_NumIns</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#gaeee9d7a6253d49d226bbed3f35768169\">BBL_InsertCall</a> (BBL bbl, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#ga2cb232c4ec093d6212130d2212b7753f\">BBL_InsertIfCall</a> (BBL bbl, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#gafc21707fffe4859507872641a5e8e245\">BBL_InsertThenCall</a> (BBL bbl, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BBL__BASIC__API.html#ga8a127ecac76dc52fc032e1e852b50a1d\">BBL_HasFallThrough</a> (BBL bbl)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga1d1892c1af9c4bd004e1968628ebf2ad\">PIN_SupportsProcessorState</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#ga479f2b92361e3794145bb90a1ea7e027\">PROCESSOR_STATE</a> state)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#gac0761d2f5d40984f5af337fa51ca300e\">PIN_ContextContainsState</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__CONTEXT__API.html#ga479f2b92361e3794145bb90a1ea7e027\">PROCESSOR_STATE</a> state)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#gabda2431b3ed648ef10484cb1b7d82fb6\">PIN_SetContextRegval</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, REG reg, const UINT8 *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#gab3ce54ce359ab95b0e5242543b802d67\">PIN_GetContextRegval</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, REG reg, UINT8 *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga2369ec2d95122f62cb3673a5a3507023\">PIN_SetContextReg</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, REG reg, ADDRINT val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#gac1358a6179f0a63300fdf34ecf8b741d\">PIN_GetContextReg</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, REG reg)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga3ee37c6cde359eb80adc79213097c6a8\">PIN_SetContextFPState</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, const FPSTATE *fpstate)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga8d7048d8a840bc18b549a8ab5889bbda\">PIN_GetContextFPState</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, FPSTATE *fpstate)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">REGSET&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga280fa4acc15b804855808e97fcf4fc91\">PIN_GetFullContextRegsSet</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga9ee4fe2f1f73c27883097e035286c831\">PIN_SaveContext</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxtFrom, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxtTo)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__CONTEXT__API.html#gaa836395fa2c09ed62f85d74b46970659\">PIN_ExecuteAt</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#gaa532751f97b471692e5a4f6e47fd5e6d\">PIN_SetSyscallArgument</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, SYSCALL_STANDARD std, UINT32 argNum, ADDRINT val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#ga09ec258651518b635b19e996f3685592\">PIN_GetSyscallArgument</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, SYSCALL_STANDARD std, UINT32 argNum)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#gad487e2291fab27c857f499ef620df557\">PIN_SetSyscallNumber</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, SYSCALL_STANDARD std, ADDRINT val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#ga7978c0470ca54f50f13c5015fce82b67\">PIN_GetSyscallNumber</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, SYSCALL_STANDARD std)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#gaa05b2658e8eed741ff10408f93453494\">PIN_GetSyscallReturn</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, SYSCALL_STANDARD std)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__SYSCALL__API.html#gae2a6966760a8f1d7a15fcbb0fe0a50fa\">PIN_GetSyscallErrno</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, SYSCALL_STANDARD std)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#ga52607b77f25b946b70529722638f70ad\">PIN_SetPhysicalContextReg</a> (<a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#ga3c6833a027db42b5d528a0c65cefbc07\">PHYSICAL_CONTEXT</a> *pPhysCtxt, REG reg, ADDRINT val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#gaade34c7ca1e5a29b89f82f49afafa31f\">PIN_GetPhysicalContextReg</a> (const <a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#ga3c6833a027db42b5d528a0c65cefbc07\">PHYSICAL_CONTEXT</a> *pPhysCtxt, REG reg)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#gad141c940f419a3e0fd5badf4a7ae21f1\">PIN_SetPhysicalContextFPState</a> (<a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#ga3c6833a027db42b5d528a0c65cefbc07\">PHYSICAL_CONTEXT</a> *pPhysCtxt, const VOID *fpstate)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#ga269d9f9c92c7fbc355380f6777c8f4ea\">PIN_GetPhysicalContextFPState</a> (const <a class=\"el\" href=\"group__PHYSICAL__CONTEXT__API.html#ga3c6833a027db42b5d528a0c65cefbc07\">PHYSICAL_CONTEXT</a> *pPhysCtxt, VOID *fpstate)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__EXCEPTION__API.html#ga656279818bb8972fbdac576b57854561\">PIN_RaiseException</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, const <a class=\"el\" href=\"group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5\">EXCEPTION_INFO</a> *pExceptInfo)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e\">OS_THREAD_ID</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a22dc9c2b2d797118827d2680bdcc239a\">PIN_ClientFork</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a878b8da6dfffd13a7cae68c3d6428792\">PIN_SpawnApplicationThread</a> (const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af6705ad5c646311a347a3099c1d377f4\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RecordInstructionMutation\" ref=\"af6705ad5c646311a347a3099c1d377f4\" args=\"(INS ins, EXT ext, BOOL noDuplicates)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RecordInstructionMutation</b> (INS ins, EXT ext, BOOL noDuplicates)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga16092fd92737ed4e127c60afc368bfed\">INS_ChangeMemOpToBaseRegisterAddressMode</a> (INS ins, MEMORY_TYPE mtype, REG newBase)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_DEPRECATED_API BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga8a29badbe8a33e66dd9b36fd660eb5bf\">INS_RewriteMemoryAddressingToBaseRegisterOnly</a> (INS ins, MEMORY_TYPE mtype, REG newBase)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__MOD__API__GEN__IA32.html#ga5d92097342958a5e005f05e9bb9d7164\">INS_RewriteMemoryOperand</a> (INS ins, UINT32 memindex, REG reg)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__MOD__API__GEN__IA32.html#gaf1877a898320c826b33e0d001a921378\">INS_InsertIndirectJump</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> ipoint, REG reg)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__MOD__API__GEN__IA32.html#gaed3106e003f2eae3e332e1a526defd7b\">INS_InsertDirectJump</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> ipoint, ADDRINT tgt)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a56c2d268d45b26ac3513437d45ae19ef\">GetVmLock</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a7bd7512514651e76d2cab0e86f897e03\">ReleaseVmLock</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">REG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__REG__CPU__GENERIC.html#gac83862ca36497c4ef0d334f4fe8e1661\">PIN_ClaimToolRegister</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">CHAR *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gab047eba18942e83814934eda278de607\">PIN_VmFullPath</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">const CHAR *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gac266390e4b69a624a88adcda64ac86c8\">PIN_ToolFullPath</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#adb79f43519a66afb7026cfea36c7cf82\">IsProcessExiting</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">NORETURN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__PROCESS__API.html#gacca02e5ee771570c8d255506692a63ae\">PIN_ExitProcess</a> (INT32 exitCode)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">INT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__PROCESS__API.html#ga4bf5a4a357a5829228abf26faa03604b\">PIN_GetPid</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__MOD__API__GEN__IA32.html#gad37791f157338a12e22f8d9c54f09fe4\">INS_Delete</a> (INS ins)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INST__ARGS.html#gae3eb88acf12be3a154102006b4de7e4d\">IARGLIST_AddArguments</a> (<a class=\"el\" href=\"group__INST__ARGS.html#gafbeb707dc23c7c09e1e8c932649107d5\">IARGLIST</a> args,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__INST__ARGS.html#gafbeb707dc23c7c09e1e8c932649107d5\">IARGLIST</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INST__ARGS.html#ga5cbcceec6b0a3ebe21b78c85c4a8c8c9\">IARGLIST_Alloc</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INST__ARGS.html#ga392b26a0d0881f24d3abf7d4d1d8e176\">IARGLIST_Free</a> (<a class=\"el\" href=\"group__INST__ARGS.html#gafbeb707dc23c7c09e1e8c932649107d5\">IARGLIST</a> args)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">size_t&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga98669d2f5629027689d60bd852ffa0eb\">PIN_SafeCopy</a> (VOID *dst, const VOID *src, size_t size)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">size_t&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga271a2d60a060ddd0c13d6599afe8c0e2\">PIN_SafeCopyEx</a> (VOID *dst, const VOID *src, size_t size, <a class=\"el\" href=\"group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5\">EXCEPTION_INFO</a> *pExceptInfo)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a35f082729a54d94c0404f1d60f10dca6\">CheckPinInitialized</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#gacf731514b88f79344068df5d8e60eacc\">INS_InsertFillBuffer</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, BUFFER_ID id,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#ga74a3e0d9a1e35568c28abd9b2ba29e4d\">INS_InsertFillBufferPredicated</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, BUFFER_ID id,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__INS__INST__API.html#gaa4e98a83483b18bf47d20cb99b4c24ec\">INS_InsertFillBufferThen</a> (INS ins, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, BUFFER_ID id,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a8a51b784d4c613aa0689e96e7a267cc1\">BBL_InsertFillBuffer</a> (BBL bbl, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, BUFFER_ID id,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a7e992d7d2ee72a2c9f0d718c74f7f76a\">RTN_InsertFillBuffer</a> (RTN rtn, <a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a> action, BUFFER_ID id,...)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#afdc368dbbaf5fa963fac258622a7a63f\">CallBufferFullCallback</a> (BUFFER_ID id, <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, VOID *buf, UINT64 numElts)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ae9d9e8c8e1773ac38fece9849fa5f628\">CallAllBufferFullCallbacks</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BUFFER_ID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BUFFER__API.html#ga008bd698d07658fc4f60fd9b61fb81bc\">PIN_DefineTraceBuffer</a> (size_t recordSize, UINT32 numPages, <a class=\"el\" href=\"group__BUFFER__API.html#ga2f5cb32e7787a78f3d82777ccc6bcc74\">TRACE_BUFFER_CALLBACK</a> fun, VOID *val)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BUFFER__API.html#ga2c9c14f8b8dc4a6cb6c137f533d8d14a\">PIN_AllocateBuffer</a> (BUFFER_ID id)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BUFFER__API.html#gad6f219bd78622a73d42d37e3f9d6801e\">PIN_DeallocateBuffer</a> (BUFFER_ID id, VOID *buf)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gac671358905f7d4dac7d544b6048e3ee3\">PIN_IsActionPending</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga4494aa98db78e24a10caec922404200e\">PIN_GetInitialThreadCount</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__BUFFER__API.html#ga2c67a48c18fcdc9c88ed826e28f40434\">PIN_GetBufferPointer</a> (<a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *const ctxt, BUFFER_ID id)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga97c4af33bb0a330a0967c80c61fcd1c4\">PIN_CheckReadAccess</a> (VOID *addr)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#gab1c7bfe02dcbcc4415ef03a7267a1b11\">PIN_CheckWriteAccess</a> (VOID *addr)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga0df38f14792706f4377486473c0bb382\">PIN_GetAuxVectorValue</a> (ADDRINT type, bool *found)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#af2d0628d04cad7be70e60df70079bc94\">PIN_ReplaySyscallEntry</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, SYSCALL_STANDARD std)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a45dda023dabf1443df8fd629a2557a8d\">PIN_ReplaySyscallExit</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, SYSCALL_STANDARD std)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">NORETURN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__PROCESS__API.html#gaca18852e033c5cefb830bb74b24bbb41\">PIN_ExitApplication</a> (INT32 status)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a49e650a8a9a2bd8fce8e3319d268c421\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ContextChangeReasonName\" ref=\"a49e650a8a9a2bd8fce8e3319d268c421\" args=\"(CONTEXT_CHANGE_REASON r)\" -->\nLOCALFUN const char *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ContextChangeReasonName</b> (<a class=\"el\" href=\"group__PIN__CONTROL.html#ga8e4e6511a0e09fdc5ec7d6dbf395b3a8\">CONTEXT_CHANGE_REASON</a> r)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a98ae9555107bb81ab2499e3519e74525\">PIN_ReplayContextChange</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *from, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *to, <a class=\"el\" href=\"group__PIN__CONTROL.html#ga8e4e6511a0e09fdc5ec7d6dbf395b3a8\">CONTEXT_CHANGE_REASON</a> reason, INT32 info)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ae6d4291b91c0f4cdf30e9f789ac9f6ab\">PIN_ReplayImageLoad</a> (const char *imageName, const char *fileName, ADDRINT loadOffset, <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab17933d09ef2378f9a385e00e041911e\">REPLAY_IMAGE_TYPE</a> imageType)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a52379b3dd9e24ddeda2a8d828f89050a\">PIN_ReplayImageUnload</a> (IMG img)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a8d243673a6238afe734e70be901c7af1\">PIN_WasMemoryReservedInLoadTime</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">PIN_CLIENT_STATE &amp;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#af387339f038e94df9fa404c7f0d97b35\">PinClientState</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a332e01f13e21a598ee2a2a65e80b1d62\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PinJitApiNotifyEvent\" ref=\"a332e01f13e21a598ee2a2a65e80b1d62\" args=\"(iJIT_JVM_EVENT event_type, void *eventSpecificData)\" -->\nLOCALFUN VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PinJitApiNotifyEvent</b> (iJIT_JVM_EVENT event_type, void *eventSpecificData)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__STOPPED__THREAD__API.html#ga548ed1631804b58caa91ab40970bea87\">PIN_StopApplicationThreads</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__STOPPED__THREAD__API.html#gab83ac31abfc4074429c4b5cde43dbca1\">PIN_IsThreadStoppedInDebugger</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__STOPPED__THREAD__API.html#ga3b14a74ff766a0ddf12f591d53e08d2b\">PIN_ResumeApplicationThreads</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__STOPPED__THREAD__API.html#ga728fc728138b1049d1785f46cd8cd310\">PIN_GetStoppedThreadCount</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__STOPPED__THREAD__API.html#ga117be31fa21b8be7e73d0ef8376e2d11\">PIN_GetStoppedThreadId</a> (UINT32 i)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__STOPPED__THREAD__API.html#ga50dac280d3e41bea9b48974231f43dab\">PIN_GetStoppedThreadContext</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__STOPPED__THREAD__API.html#ga7154fed50af7d888d5bfd04bd70b7396\">PIN_GetStoppedThreadWriteableContext</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e\">OS_THREAD_ID</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga9f3c61bba77bd6fb9ad9b1d35db211e8\">PIN_GetTid</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gaf7a3364bd3d459fefa1cccf45571e4bd\">PIN_ThreadId</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9\">PIN_THREAD_UID</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga1e43d54c4e15ad1d9474fbf764e42a05\">PIN_ThreadUid</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e\">OS_THREAD_ID</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga0d57a3a8d9a6b4c107ad92e7990fb323\">PIN_GetParentTid</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga28935318ee1add7ae5f62b7afcb5ed97\">PIN_Sleep</a> (UINT32 milliseconds)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga86b438c55e13bcd11ea3814818048d14\">PIN_Yield</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gae5a4c5a6aa259ee6d89e856d5060b1f8\">PIN_SpawnInternalThread</a> (<a class=\"el\" href=\"group__PIN__THREAD__API.html#gaf7d4b7206749ac3075b941a513d876c5\">ROOT_THREAD_FUNC</a> *pThreadFunc, VOID *arg, size_t stackSize, <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9\">PIN_THREAD_UID</a> *pThreadUid)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga4f8579b9498909ffcd7afcc7520016b9\">PIN_ExitThread</a> (INT32 exitCode)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga0602cd47412009126005c37fa1ee6205\">PIN_IsApplicationThread</a> ()</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gabcf36c5795141e682ca2dff3f097681a\">PIN_WaitForThreadTermination</a> (const <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga057233f26b54f23b1ddb0c0c5e31dba9\">PIN_THREAD_UID</a> &amp;threadUid, UINT32 milliseconds, INT32 *pExitCode)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">TLS_KEY&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga681b583239becd0b181f5b31e865931c\">PIN_CreateThreadDataKey</a> (DESTRUCTFUN destruct_func)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gad70a860606c7a8c28808b353e428813d\">PIN_DeleteThreadDataKey</a> (TLS_KEY key)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga07e007644db1d47bb89f97aa5273bc36\">PIN_SetThreadData</a> (TLS_KEY key, const VOID *data)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga268c8c79f3ea0b273240d2fb466a92f8\">PIN_SetThreadData</a> (TLS_KEY key, const VOID *data, <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadId)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#gab82e344077340051545bcb16478fb4a2\">PIN_GetThreadData</a> (TLS_KEY key)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga54b958f9981cd2b6de9eb442d8de85c4\">PIN_GetThreadData</a> (TLS_KEY key, <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> threadId)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__VERSION__API.html#ga92b15fcd9cc969a2139e900ced67d9c6\">BBL_SetTargetVersion</a> (BBL bbl, ADDRINT version)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">ADDRINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__VERSION__API.html#ga64f041866d7afab9c0760362859d060b\">TRACE_Version</a> (<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">VOID&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__TRACE__VERSION__API.html#gad981e85ff0ffbdfea7f64a9506791126\">INS_InsertVersionCase</a> (INS ins, REG reg, INT32 case_value, ADDRINT version,...)</td></tr>\n<tr><td colspan=\"2\"><h2><a name=\"var-members\"></a>\nVariables</h2></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"abb556b68f747417cefa72c6e1107f8b4\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::rbrk_ft\" ref=\"abb556b68f747417cefa72c6e1107f8b4\" args=\")(void)\" -->\nLOCALTYPE typedef void *(*&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>rbrk_ft</b> )(void)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a735feaa5876d9a1de28b2be14b872be9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYM_BASIC_INFO\" ref=\"a735feaa5876d9a1de28b2be14b872be9\" args=\"\" -->\nLOCALTYPE typedef pair&lt; string, <br class=\"typebreak\"/>\nADDRINT &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SYM_BASIC_INFO</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ac3a48f0053a293b874736539a60c9fb0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYMSET_CONST_ITERATOR\" ref=\"ac3a48f0053a293b874736539a60c9fb0\" args=\"\" -->\nLOCALTYPE typedef set<br class=\"typebreak\"/>\n&lt; SYM_BASIC_INFO &gt;<br class=\"typebreak\"/>\n::const_iterator&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SYMSET_CONST_ITERATOR</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aab9db6196384a33c172f84e484f95ae7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ILIST\" ref=\"aab9db6196384a33c172f84e484f95ae7\" args=\"\" -->\nLOCALTYPE typedef list&lt; INSTR &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ILIST</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a632b09375b4fe06eca56b49496849a42\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMAP\" ref=\"a632b09375b4fe06eca56b49496849a42\" args=\"\" -->\nLOCALTYPE typedef map&lt; ADDRINT, <br class=\"typebreak\"/>\nINSTR_INFO &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>IMAP</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ae75e7a6d1fa6869a3ae8bc17e8453233\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FOLLOW_CHILD_PROCESS_CALLBACKVAL\" ref=\"ae75e7a6d1fa6869a3ae8bc17e8453233\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__CHILD__PROCESS__API.html#gab109395d5b4fa72f83efaf0a449c340b\">FOLLOW_CHILD_PROCESS_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FOLLOW_CHILD_PROCESS_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a9d20f0bd5ca45f9d4bfe65cbbe7b17fb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FOLLOW_CHILD_PROCESS_CALLBACKVALFUNS\" ref=\"a9d20f0bd5ca45f9d4bfe65cbbe7b17fb\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nFOLLOW_CHILD_PROCESS_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FOLLOW_CHILD_PROCESS_CALLBACKVALFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a9ba14e5e56e6e2f32d5fcd8893baba5e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DEBUG_INTERPRETER_CALLBACKVAL\" ref=\"a9ba14e5e56e6e2f32d5fcd8893baba5e\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__APPDEBUG__API.html#ga10a867bb048e6ec4e52306a548604c2b\">DEBUG_INTERPRETER_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DEBUG_INTERPRETER_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aeaaecbd9a2454cf9182b7c3500be7b7e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DEBUG_INTERPRETER_CALLBACKFUNS\" ref=\"aeaaecbd9a2454cf9182b7c3500be7b7e\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nDEBUG_INTERPRETER_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DEBUG_INTERPRETER_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a4e19062d62f8918353e0dc6a5ceae072\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DEBUG_BREAKPOINT_CALLBACKVAL\" ref=\"a4e19062d62f8918353e0dc6a5ceae072\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__APPDEBUG__API.html#gabe5afceda93e234bfb67111f319bef23\">DEBUG_BREAKPOINT_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DEBUG_BREAKPOINT_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aa80be8cc8d997eba4a346e0dbf20094b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DEBUG_BREAKPOINT_CALLBACKFUNS\" ref=\"aa80be8cc8d997eba4a346e0dbf20094b\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nDEBUG_BREAKPOINT_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DEBUG_BREAKPOINT_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a0b6b260a2bc6b6178dfc12a15a67c776\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INTERCEPT_DEBUGGING_EVENT_CALLBACKVAL\" ref=\"a0b6b260a2bc6b6178dfc12a15a67c776\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nSIMPLE_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a371d93560a7f7ae5ec4b97c228197fce\">INTERCEPT_DEBUGGING_EVENT_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>INTERCEPT_DEBUGGING_EVENT_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af597ed0907e5122904962622c832d6e6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SIGNAL_BEFORE_CALLBACKVAL\" ref=\"af597ed0907e5122904962622c832d6e6\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nSIMPLE_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga0e02ac705fda839f4942303a0dbd92a9\">SIGNAL_BEFORE_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SIGNAL_BEFORE_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a48a6335556d55a09f7750600f83c5230\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SIGNAL_BEFORE_CALLBACKFUNS\" ref=\"a48a6335556d55a09f7750600f83c5230\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nSIGNAL_BEFORE_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SIGNAL_BEFORE_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aab6b6e33a90ad2ae0135be56664b2a89\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SIGNAL_AFTER_CALLBACKVAL\" ref=\"aab6b6e33a90ad2ae0135be56664b2a89\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nSIMPLE_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga139244febc8272114b851ac93a8cd36d\">SIGNAL_AFTER_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SIGNAL_AFTER_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a426fdc7e8ef8e83023293184be47947a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SIGNAL_AFTER_CALLBACKFUNS\" ref=\"a426fdc7e8ef8e83023293184be47947a\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nSIGNAL_AFTER_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SIGNAL_AFTER_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"abd23001a65fce8945c8e3fd872d39726\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_BEGIN_CALLBACKVAL\" ref=\"abd23001a65fce8945c8e3fd872d39726\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nSIMPLE_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#gae72726a7bc47716300b14a903f63c492\">THREAD_BEGIN_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_BEGIN_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aa287a0a13154f716403d8a72f9b48975\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_BEGIN_CALLBACKFUNS\" ref=\"aa287a0a13154f716403d8a72f9b48975\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nTHREAD_BEGIN_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_BEGIN_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aad1619e124d554abcf02538a2fbb39b0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_END_CALLBACKVAL\" ref=\"aad1619e124d554abcf02538a2fbb39b0\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nSIMPLE_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga1da3746b42e9e84eef562509c680ea7b\">THREAD_END_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_END_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a2139e4604b813c17aebece5a6c885ed2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_END_CALLBACKFUNS\" ref=\"a2139e4604b813c17aebece5a6c885ed2\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nTHREAD_END_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_END_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a9fc35c2dc1b1af5ef6fb3ae71d820fed\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SIGNAL_INTERCEPT_MAP\" ref=\"a9fc35c2dc1b1af5ef6fb3ae71d820fed\" args=\"\" -->\nLOCALTYPE typedef std::map<br class=\"typebreak\"/>\n&lt; int, <br class=\"typebreak\"/>\n<a class=\"el\" href=\"group__DEPRECATED__PIN__API.html#ga2116b73be99579bae5c752aae9eb3ab4\">SIGNAL_INTERCEPT_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SIGNAL_INTERCEPT_MAP</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a592229d4991faf175706c2b116628d0d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_PAIR\" ref=\"a592229d4991faf175706c2b116628d0d\" args=\"\" -->\nLOCALTYPE typedef pair<br class=\"typebreak\"/>\n&lt; RTN_KEY, RTN &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_PAIR</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a21d21c6660024cc3f8594facd12df74d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_MAP\" ref=\"a21d21c6660024cc3f8594facd12df74d\" args=\"\" -->\nLOCALTYPE typedef map&lt; RTN_KEY, <br class=\"typebreak\"/>\nRTN &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_MAP</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a26f282e41ee2799b4ab1f571a2d73d22\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_OUTSIDE_RANGES_LIST\" ref=\"a26f282e41ee2799b4ab1f571a2d73d22\" args=\"\" -->\nLOCALTYPE typedef list&lt; MemRange &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_OUTSIDE_RANGES_LIST</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aea33a2151666ef0bcf0678de9be6fea9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_OUTSIDE_RANGES_MAP\" ref=\"aea33a2151666ef0bcf0678de9be6fea9\" args=\"\" -->\nLOCALTYPE typedef map&lt; ADDRINT, <br class=\"typebreak\"/>\nOUTSIDE_TARGET_MEM_RANGE, <br class=\"typebreak\"/>\nstd::less&lt; ADDRINT &gt; &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_OUTSIDE_RANGES_MAP</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a5884c88fe6161050fbf0639b3866bb87\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_OUTSIDE_TARGETS_MAP\" ref=\"a5884c88fe6161050fbf0639b3866bb87\" args=\"\" -->\nLOCALTYPE typedef map&lt; ADDRINT, <br class=\"typebreak\"/>\nOUTSIDE_TARGET, std::less<br class=\"typebreak\"/>\n&lt; ADDRINT &gt; &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_OUTSIDE_TARGETS_MAP</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a26b173f4d4db4a89b41f3f3d0524ab8a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_OUTSIDE_PREV_BBLS_MAP\" ref=\"a26b173f4d4db4a89b41f3f3d0524ab8a\" args=\"\" -->\nLOCALTYPE typedef map&lt; ADDRINT, <br class=\"typebreak\"/>\nBBL, std::less&lt; ADDRINT &gt; &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_OUTSIDE_PREV_BBLS_MAP</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a44ccb60ac4fa0cddfee69e6e22f6ef5c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_UJMP_VECTOR\" ref=\"a44ccb60ac4fa0cddfee69e6e22f6ef5c\" args=\"\" -->\nLOCALTYPE typedef vector&lt; INS &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_UJMP_VECTOR</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ac02a7f17bd6270a8a3a8896a9303c994\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMAGECALLBACKVAL\" ref=\"ac02a7f17bd6270a8a3a8896a9303c994\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__IMG__BASIC__API.html#ga3c454c8efe9960033aabdcc1c43b8fa7\">IMAGECALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>IMAGECALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a557b398b0b349692f6fef743fa295061\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMAGECALLBACKFUNS\" ref=\"a557b398b0b349692f6fef743fa295061\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nIMAGECALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>IMAGECALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"abc7316e6ce7f969b4738c523d9aab452\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_INSTRUMENT_CALLBACKVAL\" ref=\"abc7316e6ce7f969b4738c523d9aab452\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__RTN__BASIC__API.html#gad0b5091252621bacc4645cb920fdc403\">RTN_INSTRUMENT_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_INSTRUMENT_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"accd9e5ae5c544e3fca67337a31637fc1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_INSTRUMENT_CALLBACKFUNS\" ref=\"accd9e5ae5c544e3fca67337a31637fc1\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nRTN_INSTRUMENT_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RTN_INSTRUMENT_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a1d811d4749c596c72265ca7d11b7ba89\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_INSTRUMENT_CALLBACKVAL\" ref=\"a1d811d4749c596c72265ca7d11b7ba89\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__INS__INST__API.html#gaf8c8e7d6c9872e80d4571ba461dff870\">INS_INSTRUMENT_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>INS_INSTRUMENT_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a069940329805c6cea50f5199d35ad9bb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_INSTRUMENT_CALLBACKFUNS\" ref=\"a069940329805c6cea50f5199d35ad9bb\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nINS_INSTRUMENT_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>INS_INSTRUMENT_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a71063e7031a43952c409e8a4ec6dfd3e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_INSTRUMENT_CALLBACKVAL\" ref=\"a71063e7031a43952c409e8a4ec6dfd3e\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaaec88a4f6dc5f49e092754540a5ed7b0\">TRACE_INSTRUMENT_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>TRACE_INSTRUMENT_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a6f4f89aa6cd6775e058b1c458a013644\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_INSTRUMENT_CALLBACKFUNS\" ref=\"a6f4f89aa6cd6775e058b1c458a013644\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nTRACE_INSTRUMENT_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>TRACE_INSTRUMENT_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aa466c937cec6d56a9d5d5f45df4b7388\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SMC_CALLBACKVAL\" ref=\"aa466c937cec6d56a9d5d5f45df4b7388\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__TRACE__BASIC__API.html#gafa7e66beec272534d120b9ab3ea4ca84\">SMC_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SMC_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a93dedb13c30d15cdb95f74a25a9b4b29\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SMC_CALLBACKFUNS\" ref=\"a93dedb13c30d15cdb95f74a25a9b4b29\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nSMC_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SMC_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ab6d8bbb9eea35a634032a77fa0531b84\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PREPARE_FOR_FINI_CALLBACKVAL\" ref=\"ab6d8bbb9eea35a634032a77fa0531b84\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__CONTROL.html#ga680e195155c9e4141d994512b31a319b\">PREPARE_FOR_FINI_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PREPARE_FOR_FINI_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ac2f5480bb4a02b1e213a35f626869ba4\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PREPARE_FOR_FINI_CALLBACKFUNS\" ref=\"ac2f5480bb4a02b1e213a35f626869ba4\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nPREPARE_FOR_FINI_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PREPARE_FOR_FINI_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a347d823239c3f7c121479e9550e57b78\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FINI_CALLBACKVAL\" ref=\"a347d823239c3f7c121479e9550e57b78\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__CONTROL.html#gaacb361fd2832e34cc92e7f03bd1f1621\">FINI_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FINI_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ac0e997d37da51b9f21b8f63ea6cf106e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FINI_CALLBACKFUNS\" ref=\"ac0e997d37da51b9f21b8f63ea6cf106e\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nFINI_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FINI_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a0779ca1a95ff6a26c67c83fd192f2c95\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FORK_CALLBACKVAL\" ref=\"a0779ca1a95ff6a26c67c83fd192f2c95\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__CONTROL.html#gadc08958640205e2e9ff994fdac917a25\">FORK_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FORK_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a2b012041afe52c55faedf13dc7b5f51a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FORK_CALLBACKFUNS\" ref=\"a2b012041afe52c55faedf13dc7b5f51a\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nFORK_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>FORK_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a26c4171c6bca7cae5f14625c4bc1b16a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DETACH_CALLBACKVAL\" ref=\"a26c4171c6bca7cae5f14625c4bc1b16a\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__CONTROL.html#gad1e358c0ce1a5aef73f263b2800deb36\">DETACH_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DETACH_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a117e4ed9cdb3c8df0a1ded71b3a6f00d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DETACH_CALLBACKFUNS\" ref=\"a117e4ed9cdb3c8df0a1ded71b3a6f00d\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nDETACH_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DETACH_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a41dfc73d544b106bb7ce1d3f625ca4ee\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DETACH_PROBED_CALLBACKVAL\" ref=\"a41dfc73d544b106bb7ce1d3f625ca4ee\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__CONTROL.html#ga1edd9181ea2f698c21c743be7f93267e\">DETACH_PROBED_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DETACH_PROBED_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a984839b935c4ba611ac49912c7d8f1fc\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DETACH_PROBED_CALLBACKFUNS\" ref=\"a984839b935c4ba611ac49912c7d8f1fc\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nDETACH_PROBED_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>DETACH_PROBED_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a201c3703d27d49f88679c79858eebed6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::APPLICATION_START_CALLBACKVAL\" ref=\"a201c3703d27d49f88679c79858eebed6\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__CONTROL.html#gae1c672af1a7b69eed84982ed7e3efcdb\">APPLICATION_START_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>APPLICATION_START_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a45dc87d9dba5ca81c7c44acc13882b34\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::APPLICATION_START_CALLBACKFUNS\" ref=\"a45dc87d9dba5ca81c7c44acc13882b34\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nAPPLICATION_START_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>APPLICATION_START_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aef2271554350df526e46c01a73deca18\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_START_CALLBACKVAL\" ref=\"aef2271554350df526e46c01a73deca18\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__CONTROL.html#ga4b987e362ca821776c61f27af5d54574\">THREAD_START_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_START_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a8e83761e96848dfc4c0c5a8dbf81ed46\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_START_CALLBACKFUNS\" ref=\"a8e83761e96848dfc4c0c5a8dbf81ed46\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nTHREAD_START_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_START_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a3a768e74b2a3dacd5a97641d0b380d99\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_ATTACH_PROBED_CALLBACKVAL\" ref=\"a3a768e74b2a3dacd5a97641d0b380d99\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__CONTROL.html#gab3501b75015ec6c930b97b2f190195d1\">THREAD_ATTACH_PROBED_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_ATTACH_PROBED_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"afef04a9cf81c42ab42d648aef22471fa\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_ATTACH_PROBED_CALLBACKFUNS\" ref=\"afef04a9cf81c42ab42d648aef22471fa\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nTHREAD_ATTACH_PROBED_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_ATTACH_PROBED_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ada459ab555c5c0b8c9bb522af4d9370f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_DETACH_PROBED_CALLBACKVAL\" ref=\"ada459ab555c5c0b8c9bb522af4d9370f\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__CONTROL.html#gae2f1f3018393574f4949f8ce61ce6c32\">THREAD_DETACH_PROBED_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_DETACH_PROBED_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a4da50e59755ae93710a91db880016646\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_DETACH_PROBED_CALLBACKFUNS\" ref=\"a4da50e59755ae93710a91db880016646\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nTHREAD_DETACH_PROBED_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_DETACH_PROBED_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ade7d26db2dc0cafd2974e1393492353d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_ATTACH_CALLBACKVAL\" ref=\"ade7d26db2dc0cafd2974e1393492353d\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__CONTROL.html#gaf61282484a7afd5e278ae6a7023862b0\">THREAD_ATTACH_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_ATTACH_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a610852cb7a56da40b60f5e7de4eb627e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_ATTACH_CALLBACKFUNS\" ref=\"a610852cb7a56da40b60f5e7de4eb627e\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nTHREAD_ATTACH_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_ATTACH_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a5073e39dd6dbe479a148088fa61e192c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_DETACH_CALLBACKVAL\" ref=\"a5073e39dd6dbe479a148088fa61e192c\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__CONTROL.html#ga57f8ed1dca340de4282fe3327b44ca81\">THREAD_DETACH_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_DETACH_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ade69c84b6a2f3f126dfe211d9a082ec8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_DETACH_CALLBACKFUNS\" ref=\"ade69c84b6a2f3f126dfe211d9a082ec8\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nTHREAD_DETACH_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_DETACH_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ac0771d8dd8abee6e77f127e26d1631de\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_FINI_CALLBACKVAL\" ref=\"ac0771d8dd8abee6e77f127e26d1631de\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__CONTROL.html#ga670ae83f83ef39ac19d793e16b23c5ca\">THREAD_FINI_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_FINI_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a3118962d0add2fa99c90f557c50f87c1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::THREAD_FINI_CALLBACKFUNS\" ref=\"a3118962d0add2fa99c90f557c50f87c1\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nTHREAD_FINI_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>THREAD_FINI_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ac574fb4058be459642adc216501adce6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CONTEXT_CHANGE_CALLBACKVAL\" ref=\"ac574fb4058be459642adc216501adce6\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__CONTROL.html#gaf57e5726e099445f81e9b529336ba073\">CONTEXT_CHANGE_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CONTEXT_CHANGE_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af88e0ee0b1ead1f973d54a95a0b3f3a9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CONTEXT_CHANGE_CALLBACKFUNS\" ref=\"af88e0ee0b1ead1f973d54a95a0b3f3a9\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCONTEXT_CHANGE_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>CONTEXT_CHANGE_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a86819f3aff84f6ad45a557c53f84e3ab\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYSCALL_ENTRY_CALLBACKVAL\" ref=\"a86819f3aff84f6ad45a557c53f84e3ab\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__SYSCALL__API.html#gabee4934fa6434c13c0c2f4ce2a6468dd\">SYSCALL_ENTRY_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SYSCALL_ENTRY_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a51867e03834e17f1ec2c05d692e9f75b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYSCALL_ENTRY_CALLBACKFUNS\" ref=\"a51867e03834e17f1ec2c05d692e9f75b\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nSYSCALL_ENTRY_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SYSCALL_ENTRY_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a8fba4d7bc358f331a9700d2c66b442c3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYSCALL_EXIT_CALLBACKVAL\" ref=\"a8fba4d7bc358f331a9700d2c66b442c3\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__SYSCALL__API.html#ga6579efc9b9f38ac589db8559fc503ea8\">SYSCALL_EXIT_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SYSCALL_EXIT_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af15c9c5be17f65e68065c777b3575595\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYSCALL_EXIT_CALLBACKFUNS\" ref=\"af15c9c5be17f65e68065c777b3575595\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nSYSCALL_EXIT_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SYSCALL_EXIT_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a0dfc24b954dc495c63fd621567493d95\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INTERCEPT_SIGNAL_CALLBACKVAL\" ref=\"a0dfc24b954dc495c63fd621567493d95\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nSIMPLE_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__CONTROL.html#ga93cea72a6023405d0e90c65c81a62d6f\">INTERCEPT_SIGNAL_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>INTERCEPT_SIGNAL_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a3720fe35c58219200c7bc8893b68098d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INTERCEPT_SIGNAL_MAP\" ref=\"a3720fe35c58219200c7bc8893b68098d\" args=\"\" -->\nLOCALTYPE typedef std::map<br class=\"typebreak\"/>\n&lt; int, <br class=\"typebreak\"/>\nINTERCEPT_SIGNAL_CALLBACKVAL &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>INTERCEPT_SIGNAL_MAP</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a1bf85f6801cdb925f2196b04ee7bf842\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PROBES_INSERTED_CALLBACKVAL\" ref=\"a1bf85f6801cdb925f2196b04ee7bf842\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nCOMPLEX_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__PIN__CONTROL.html#ga880c51b16479dde27cb248f038b4ab76\">PROBES_INSERTED_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PROBES_INSERTED_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aedc8f48df995d017bb1f139d51fd7b83\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PROBES_INSERTED_CALLBACKFUNS\" ref=\"aedc8f48df995d017bb1f139d51fd7b83\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nPROBES_INSERTED_CALLBACKVAL::FUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PROBES_INSERTED_CALLBACKFUNS</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a09583720da13f97dadf467fa45b4ec46\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_BUFFER_CALLBACKVAL\" ref=\"a09583720da13f97dadf467fa45b4ec46\" args=\"\" -->\nLOCALTYPE typedef <br class=\"typebreak\"/>\nSIMPLE_CALLBACKVAL<br class=\"typebreak\"/>\n&lt; <a class=\"el\" href=\"group__BUFFER__API.html#ga2f5cb32e7787a78f3d82777ccc6bcc74\">TRACE_BUFFER_CALLBACK</a> &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>TRACE_BUFFER_CALLBACKVAL</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ac99d6caca307d6e69b7c84c4a2ea101b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_BUFFER_CALLBACK_MAP\" ref=\"ac99d6caca307d6e69b7c84c4a2ea101b\" args=\"\" -->\nLOCALTYPE typedef std::map<br class=\"typebreak\"/>\n&lt; BUFFER_ID, <br class=\"typebreak\"/>\nTRACE_BUFFER_CALLBACKVAL &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>TRACE_BUFFER_CALLBACK_MAP</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALTYPE typedef <br class=\"typebreak\"/>\nTLS_KEY_ALLOCATOR<br class=\"typebreak\"/>\n&lt; TLS_KEY_CLIENT_FIRST, <br class=\"typebreak\"/>\nTLS_KEY_CLIENT_LAST &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a54e0dc2e438a1924e754695ecf0140e4\">CLIENT_TLS_KEY_ALLOCATOR</a></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a4a1d6feabfdeab052c3ef38df63a9a78\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::crc32table\" ref=\"a4a1d6feabfdeab052c3ef38df63a9a78\" args=\"[]\" -->\nLOCALCONST UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>crc32table</b> []</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af095bce213cedb727c84bdefbc7f7f11\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::debug_state_func\" ref=\"af095bce213cedb727c84bdefbc7f7f11\" args=\"\" -->\nLOCALVAR const CHAR *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>debug_state_func</b> = &quot;_dl_debug_state&quot;</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ab7cc00ea7d8e670f6f3cc3bd467691f5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::debug_state_var\" ref=\"ab7cc00ea7d8e670f6f3cc3bd467691f5\" args=\"\" -->\nLOCALVAR const CHAR *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>debug_state_var</b> = &quot;_r_debug&quot;</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a9e06d502d3e60509b575c9ac3a2c7de5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadInScan\" ref=\"a9e06d502d3e60509b575c9ac3a2c7de5\" args=\"\" -->\nLOCALVAR BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadInScan</b> = FALSE</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a0dde6968ca3c9a7ac0ac215568abd0ce\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SymInit\" ref=\"a0dde6968ca3c9a7ac0ac215568abd0ce\" args=\"\" -->\nLOCALVAR BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SymInit</b> = false</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a0a0d823d1882cc7127c8ae081cb55dbd\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SymMode\" ref=\"a0a0d823d1882cc7127c8ae081cb55dbd\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"group__PIN__CONTROL.html#ga139152abe353fdff0216a5519d261c73\">SYMBOL_INFO_MODE</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SymMode</b> = NO_SYMBOLS</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a97b1ff57753936d9ec184a1eeed94350\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PLT0_ENTRY_SIZE\" ref=\"a97b1ff57753936d9ec184a1eeed94350\" args=\"\" -->\nLOCALVAR const INT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PLT0_ENTRY_SIZE</b> = 16</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a5087a1f118b42a4039129e38c1b21208\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PLT_ENTRY_SIZE\" ref=\"a5087a1f118b42a4039129e38c1b21208\" args=\"\" -->\nLOCALVAR const INT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PLT_ENTRY_SIZE</b> = 16</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af0b5c47efc81c136169242d676d59aaf\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RELC_INDEX_OFFSET\" ref=\"af0b5c47efc81c136169242d676d59aaf\" args=\"\" -->\nLOCALVAR const INT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>RELC_INDEX_OFFSET</b> = 7</td></tr>\n<tr><td class=\"memItemLeft\" ><a class=\"anchor\" id=\"a80d1aa46cab5ebfe902cc73fe31e243c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::sanitizations\" ref=\"a80d1aa46cab5ebfe902cc73fe31e243c\" args=\"[]\" -->\nstruct {</td></tr>\n<tr><td class=\"memItemLeft\" >&#160;&#160;&#160;const string&#160;&#160;&#160;<b>name</b></td></tr>\n<tr><td class=\"memItemLeft\" >&#160;&#160;&#160;const string&#160;&#160;&#160;<b>replacement</b></td></tr>\n<tr><td class=\"memItemLeft\" >&#160;&#160;&#160;size_t&#160;&#160;&#160;<b>length</b></td></tr>\n<tr><td class=\"memItemLeft\" valign=\"top\">}&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>sanitizations</b> []</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"abceedf7787a128059e7d62e18b069944\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::imap\" ref=\"abceedf7787a128059e7d62e18b069944\" args=\"\" -->\nLOCALVAR IMAP&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>imap</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a8786b036a7e551520b4b84ad821373e7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::followChildProcessList\" ref=\"a8786b036a7e551520b4b84ad821373e7\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\nFOLLOW_CHILD_PROCESS_CALLBACKVALFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>followChildProcessList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ac99180101b69be974ad0fb0a383fdb34\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::debugInterpreterList\" ref=\"ac99180101b69be974ad0fb0a383fdb34\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\nDEBUG_INTERPRETER_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>debugInterpreterList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ac03e30cda37305ac181aeff52b907dc0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::debugBreakpointList\" ref=\"ac03e30cda37305ac181aeff52b907dc0\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\nDEBUG_BREAKPOINT_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>debugBreakpointList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a9c3278b92db2d7ff4c3e929d6b52c030\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InterceptDebuggingEventBreakpoint\" ref=\"a9c3278b92db2d7ff4c3e929d6b52c030\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\nINTERCEPT_DEBUGGING_EVENT_CALLBACKVAL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>InterceptDebuggingEventBreakpoint</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a3104e56e4efd102e5495f7fc31e262b1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InterceptDebuggingEventSingleStep\" ref=\"a3104e56e4efd102e5495f7fc31e262b1\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\nINTERCEPT_DEBUGGING_EVENT_CALLBACKVAL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>InterceptDebuggingEventSingleStep</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ad53591338c57f71b3063d2c12176327d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InterceptDebuggingEventAsyncBreak\" ref=\"ad53591338c57f71b3063d2c12176327d\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\nINTERCEPT_DEBUGGING_EVENT_CALLBACKVAL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>InterceptDebuggingEventAsyncBreak</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a3bd93888f7e4fa6de1527b05e46022d1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetEmulatedRegisterCallback\" ref=\"a3bd93888f7e4fa6de1527b05e46022d1\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\n<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a03b643cf8ed4f53d9578ae1c0ea80ff1\">GET_EMULATED_REGISTER_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>GetEmulatedRegisterCallback</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a37b228b6b6ae77ef4f7a0d01a729b766\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SetEmulatedRegisterCallback\" ref=\"a37b228b6b6ae77ef4f7a0d01a729b766\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\n<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aa9709409d9f414af22b6c3f0a12c95a3\">SET_EMULATED_REGISTER_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>SetEmulatedRegisterCallback</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aaa5ec6368babc5289681abb0bb3dac95\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetTargetDescriptionCallback\" ref=\"aaa5ec6368babc5289681abb0bb3dac95\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\n<a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a9c0055d850f5c7299b4e3b9e3b26e53c\">GET_TARGET_DESCRIPTION_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>GetTargetDescriptionCallback</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ac890b723c2eff1690c8b56ddff08fa35\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::EmulatedRegisterCallbackVal\" ref=\"ac890b723c2eff1690c8b56ddff08fa35\" args=\"\" -->\nLOCALVAR VOID *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>EmulatedRegisterCallbackVal</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aa603cc7e44d9c917d9339e07ead3ecc0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::signalBeforeList\" ref=\"aa603cc7e44d9c917d9339e07ead3ecc0\" args=\"\" -->\nLOCALVAR SIGNAL_BEFORE_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>signalBeforeList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a62cc4d4df767193ba6620588615f5039\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::signalAfterList\" ref=\"a62cc4d4df767193ba6620588615f5039\" args=\"\" -->\nLOCALVAR SIGNAL_AFTER_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>signalAfterList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a201ab5b019567653f7a1a65a313358da\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadBeginList\" ref=\"a201ab5b019567653f7a1a65a313358da\" args=\"\" -->\nLOCALVAR THREAD_BEGIN_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadBeginList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a22e778fdc3813222a82234eafdb8b65d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadEndList\" ref=\"a22e778fdc3813222a82234eafdb8b65d\" args=\"\" -->\nLOCALVAR THREAD_END_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadEndList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a2d5b76371723768ca408ee67b8ec1950\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::signalInterceptMap\" ref=\"a2d5b76371723768ca408ee67b8ec1950\" args=\"\" -->\nLOCALVAR SIGNAL_INTERCEPT_MAP&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>signalInterceptMap</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a88455744fb9220a5849ec043ef58e565\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::rtn_map\" ref=\"a88455744fb9220a5849ec043ef58e565\" args=\"\" -->\nLOCALVAR RTN_MAP&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>rtn_map</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a1c30fbb71f0e7c12a165c4bc890563ae\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::WHOLE_TEXT_SECTION\" ref=\"a1c30fbb71f0e7c12a165c4bc890563ae\" args=\"\" -->\nLOCALVAR const char *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>WHOLE_TEXT_SECTION</b> = &quot;.text&quot;</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aec0eac46125ae9b393f2a6791659c9d2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::UNNAMED_IMAGE_ENTRY_POINT\" ref=\"aec0eac46125ae9b393f2a6791659c9d2\" args=\"\" -->\nLOCALVAR const char *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>UNNAMED_IMAGE_ENTRY_POINT</b> = &quot;unnamedImageEntryPoint&quot;</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"adfbfa8fc2b49dd35cc7a186e3d601148\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::imageLoadList\" ref=\"adfbfa8fc2b49dd35cc7a186e3d601148\" args=\"\" -->\nLOCALVAR IMAGECALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>imageLoadList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a5b36ae6674b663a991f44c930508f9f7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::imageUnloadList\" ref=\"a5b36ae6674b663a991f44c930508f9f7\" args=\"\" -->\nLOCALVAR IMAGECALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>imageUnloadList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ad6d7acbc587e9a7ef434c5e887737d7d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::app\" ref=\"ad6d7acbc587e9a7ef434c5e887737d7d\" args=\"\" -->\nLOCALVAR APP&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>app</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ad231a661c32cbc93253ce18542c7b5ba\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::OpenRtn\" ref=\"ad231a661c32cbc93253ce18542c7b5ba\" args=\"\" -->\nLOCALVAR RTN&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>OpenRtn</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a27342ae8c4a1333444ccbb46df2a71ca\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::OpenImg\" ref=\"a27342ae8c4a1333444ccbb46df2a71ca\" args=\"\" -->\nLOCALVAR IMG&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>OpenImg</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a9f7769b375fcea4b75ac985cac407f2d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::rtnList\" ref=\"a9f7769b375fcea4b75ac985cac407f2d\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\nRTN_INSTRUMENT_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>rtnList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a964fa9c4a3fda9d90159128808d22e3b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::savedImageLoadOps\" ref=\"a964fa9c4a3fda9d90159128808d22e3b\" args=\"\" -->\nLOCALVAR std::list&lt; IMAGE_LOAD_OP &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>savedImageLoadOps</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a6f25094d427491d45e72edf3d2057b8f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::savedImageLoadOps2\" ref=\"a6f25094d427491d45e72edf3d2057b8f\" args=\"\" -->\nLOCALVAR std::list<br class=\"typebreak\"/>\n&lt; IMAGE_LOAD_OP2 &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>savedImageLoadOps2</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">GLOBALCONST UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a28715588ef8741d97df6b914ea713e0b\">MAX_IEH_CALLBACKS</a> = 32</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a5c74a25f356d9c100f47c2688bad7519\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::syscallCallbacksRWLock\" ref=\"a5c74a25f356d9c100f47c2688bad7519\" args=\"\" -->\nLOCALVAR PINVM::PINSYNC_RWLOCK&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>syscallCallbacksRWLock</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a40d94ed72256aca9096ec748627d138e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::insList\" ref=\"a40d94ed72256aca9096ec748627d138e\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\nINS_INSTRUMENT_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>insList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ab7808e6e524654107f1a013b0f17d11b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::traceList\" ref=\"ab7808e6e524654107f1a013b0f17d11b\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\nTRACE_INSTRUMENT_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>traceList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aa9d64608fbd7bcd90771e1aa998e2a2c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::outOfMemoryFun\" ref=\"aa9d64608fbd7bcd90771e1aa998e2a2c\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"group__PIN__CONTROL.html#gabbf7a42619fda89affa3df8bddebc32e\">OUT_OF_MEMORY_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>outOfMemoryFun</b> = 0</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ae59622303e19b035fc05b95c6892ac75\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::outOfMemoryVal\" ref=\"ae59622303e19b035fc05b95c6892ac75\" args=\"\" -->\nLOCALVAR VOID *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>outOfMemoryVal</b> = 0</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af8cb651c0f4ff12d40ba3a2904a11f71\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::memoryAddrTransFun\" ref=\"af8cb651c0f4ff12d40ba3a2904a11f71\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"group__PIN__CONTROL.html#ga1a1c5b833df7e988522aa312890d1ca4\">MEMORY_ADDR_TRANS_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>memoryAddrTransFun</b> = 0</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aece1cd1afa93e708bcd20a0aae993853\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::memoryAddrTransVal\" ref=\"aece1cd1afa93e708bcd20a0aae993853\" args=\"\" -->\nLOCALVAR VOID *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>memoryAddrTransVal</b> = 0</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ae37a9f0efe5746f1ddd41ea562d83135\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::smcCallbackList\" ref=\"ae37a9f0efe5746f1ddd41ea562d83135\" args=\"\" -->\nLOCALVAR SMC_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>smcCallbackList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a44ac61191b919ae4f2bd3cb53e752f8d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::prepareForFiniList\" ref=\"a44ac61191b919ae4f2bd3cb53e752f8d\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\nPREPARE_FOR_FINI_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>prepareForFiniList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a7ae55ab26eb6e032ad160517f2afb1c4\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::finiList\" ref=\"a7ae55ab26eb6e032ad160517f2afb1c4\" args=\"\" -->\nLOCALVAR FINI_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>finiList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a180f09ff2124783e205b9897f90bfaca\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::fetchCallbackFun\" ref=\"a180f09ff2124783e205b9897f90bfaca\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"group__PIN__CONTROL.html#ga308874ca87663350daa5608de534a0ce\">FETCH_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>fetchCallbackFun</b> = 0</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a3c892dad69e4c8510532e21e064bf0fb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::fetchCallbackVal\" ref=\"a3c892dad69e4c8510532e21e064bf0fb\" args=\"\" -->\nLOCALVAR VOID *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>fetchCallbackVal</b> = 0</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aed681709b09738d8fd5c8d4fd4b7f1c7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::forkListBefore\" ref=\"aed681709b09738d8fd5c8d4fd4b7f1c7\" args=\"\" -->\nLOCALVAR FORK_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>forkListBefore</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af42853d022d60d4f01152182ea98ac2a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::forkListAfterInParent\" ref=\"af42853d022d60d4f01152182ea98ac2a\" args=\"\" -->\nLOCALVAR FORK_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>forkListAfterInParent</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a2ce3e8578997e2b424ac2b74c3289a28\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::forkListAfterInChild\" ref=\"a2ce3e8578997e2b424ac2b74c3289a28\" args=\"\" -->\nLOCALVAR FORK_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>forkListAfterInChild</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a84954a85f4bb5ec103f97f9ac4b70958\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::detachList\" ref=\"a84954a85f4bb5ec103f97f9ac4b70958\" args=\"\" -->\nLOCALVAR DETACH_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>detachList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a084aadcf47c59503ac0c7e91f9b5ae4d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::detachProbedList\" ref=\"a084aadcf47c59503ac0c7e91f9b5ae4d\" args=\"\" -->\nLOCALVAR DETACH_PROBED_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>detachProbedList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a5840d83c43404c64b9ceeb55284339ce\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::attachProbedFun\" ref=\"a5840d83c43404c64b9ceeb55284339ce\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"group__PIN__CONTROL.html#ga250c31d0d85cd9ec799f30752c476841\">ATTACH_PROBED_CALLBACK</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>attachProbedFun</b> = 0</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aef8487ffe273054075cc21f0e295e9c2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::attachProbedVal\" ref=\"aef8487ffe273054075cc21f0e295e9c2\" args=\"\" -->\nLOCALVAR VOID *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>attachProbedVal</b> = 0</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a86ec61f50d188cb7461f8042d4746b46\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::appStartList\" ref=\"a86ec61f50d188cb7461f8042d4746b46\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\nAPPLICATION_START_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>appStartList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a9ddaee537ceb23efca3d8055a526c908\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadStartList\" ref=\"a9ddaee537ceb23efca3d8055a526c908\" args=\"\" -->\nLOCALVAR THREAD_START_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadStartList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aec5359277fc424038613c104adc1e0fa\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadAttachProbedList\" ref=\"aec5359277fc424038613c104adc1e0fa\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\nTHREAD_ATTACH_PROBED_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadAttachProbedList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a407d7c263d323d76474a90440acf7997\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadDetachProbedList\" ref=\"a407d7c263d323d76474a90440acf7997\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\nTHREAD_DETACH_PROBED_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadDetachProbedList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a836b20377eb159744510cac7b84032a9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadAttachJitList\" ref=\"a836b20377eb159744510cac7b84032a9\" args=\"\" -->\nLOCALVAR THREAD_ATTACH_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadAttachJitList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ac998c80aaa0bc194992fa93261b49ebf\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadDetachJitList\" ref=\"ac998c80aaa0bc194992fa93261b49ebf\" args=\"\" -->\nLOCALVAR THREAD_DETACH_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadDetachJitList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aba85570dd913efc07e3d0ba5a2bd218d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::threadFiniList\" ref=\"aba85570dd913efc07e3d0ba5a2bd218d\" args=\"\" -->\nLOCALVAR THREAD_FINI_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>threadFiniList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aad336723cf2cddead68b7d5391d380d7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::contextChangeList\" ref=\"aad336723cf2cddead68b7d5391d380d7\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\nCONTEXT_CHANGE_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>contextChangeList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aeda16173f524c3da3f2092b448c60a5e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::syscallEntryList\" ref=\"aeda16173f524c3da3f2092b448c60a5e\" args=\"\" -->\nLOCALVAR SYSCALL_ENTRY_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>syscallEntryList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a00107e8256b2e66485a928c4a73d426b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::syscallExitList\" ref=\"a00107e8256b2e66485a928c4a73d426b\" args=\"\" -->\nLOCALVAR SYSCALL_EXIT_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>syscallExitList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a6a0c3f727bcbe2d1198f4d794bc74caf\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::interceptSignalMap\" ref=\"a6a0c3f727bcbe2d1198f4d794bc74caf\" args=\"\" -->\nLOCALVAR INTERCEPT_SIGNAL_MAP&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>interceptSignalMap</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"add2c792664426fc4d1a698e0c716eb6c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::probesInsertedList\" ref=\"add2c792664426fc4d1a698e0c716eb6c\" args=\"\" -->\nLOCALVAR <br class=\"typebreak\"/>\nPROBES_INSERTED_CALLBACKFUNS&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>probesInsertedList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a027bfaa83fc5a57a1339ec8700c17231\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::traceBufferCallbackMap\" ref=\"a027bfaa83fc5a57a1339ec8700c17231\" args=\"\" -->\nLOCALVAR TRACE_BUFFER_CALLBACK_MAP&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>traceBufferCallbackMap</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ab4ed00ed33ca9d8e6988ed8b27386cb3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::addrReferences\" ref=\"ab4ed00ed33ca9d8e6988ed8b27386cb3\" args=\"\" -->\nLOCALVAR set&lt; ADDRINT, less<br class=\"typebreak\"/>\n&lt; ADDRINT &gt; &gt;&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>addrReferences</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"addc345bf822f662ea090a3b17f0f9bde\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::replayModeFlags\" ref=\"addc345bf822f662ea090a3b17f0f9bde\" args=\"\" -->\nLOCALVAR UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>replayModeFlags</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"ae88cde66a4a43535e98b243e3199c0f0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ToolArgc\" ref=\"ae88cde66a4a43535e98b243e3199c0f0\" args=\"\" -->\nLOCALVAR INT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ToolArgc</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a3632aff9bbca715da16c514c2e19ff1b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ToolArgv\" ref=\"a3632aff9bbca715da16c514c2e19ff1b\" args=\"\" -->\nLOCALVAR CHAR **&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ToolArgv</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a6a6e19b7fa80bfb50eed06c1fa00a5e2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::pinStartOptions\" ref=\"a6a6e19b7fa80bfb50eed06c1fa00a5e2\" args=\"\" -->\nLOCALVAR PIN_CONFIGURATION&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>pinStartOptions</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a975ef8b88e0de6e7406daf24776dcc3c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::processExiting\" ref=\"a975ef8b88e0de6e7406daf24776dcc3c\" args=\"\" -->\nLOCALVAR volatile BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>processExiting</b> = FALSE</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a5794a9c1d136fd7bbf13a8c618c013c2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IdOfThreadInFiniCallback\" ref=\"a5794a9c1d136fd7bbf13a8c618c013c2\" args=\"\" -->\nLOCALVAR <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e\">OS_THREAD_ID</a>&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>IdOfThreadInFiniCallback</b> = 0</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a8cc32fe392ef49f28fb08d1196a1f280\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PinClientMutex\" ref=\"a8cc32fe392ef49f28fb08d1196a1f280\" args=\"\" -->\nLOCALVAR PIN_CLIENT_MUTEX&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>PinClientMutex</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"af498c519fed5914541c1c406697a6862\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::inTraceCallbacks\" ref=\"af498c519fed5914541c1c406697a6862\" args=\"\" -->\nLOCALVAR BOOL&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>inTraceCallbacks</b> = FALSE</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a1d44a6df4a36d7962cbfe7a9d72117df\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::replacedFunList\" ref=\"a1d44a6df4a36d7962cbfe7a9d72117df\" args=\"\" -->\nLOCALVAR REPLACEDFUN::LIST&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>replacedFunList</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a1b9467dbf6e3ace046de02382e88c376\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::condInstStateForIns\" ref=\"a1b9467dbf6e3ace046de02382e88c376\" args=\"\" -->\nLOCALVAR CONDINSTSTATE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>condInstStateForIns</b> = CONDINST_NORMAL</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"a1ad7f1262d8e1d99d5001831fb4e816e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::insLastIfPredicate\" ref=\"a1ad7f1262d8e1d99d5001831fb4e816e\" args=\"\" -->\nLOCALVAR PREDICATE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>insLastIfPredicate</b> = PREDICATE_ALWAYS_TRUE</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALVAR PINCLIENTINT&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>ClientIntData</b></td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"aedcd4ad23de590685aad1d5875ef5b81\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::condInstStateForTrace\" ref=\"aedcd4ad23de590685aad1d5875ef5b81\" args=\"\" -->\nLOCALVAR CONDINSTSTATE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>condInstStateForTrace</b> = CONDINST_NORMAL</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\"><a class=\"anchor\" id=\"adfa9f55f4af0e065282b96ffb2f3f184\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::condInstStateForBbl\" ref=\"adfa9f55f4af0e065282b96ffb2f3f184\" args=\"\" -->\nLOCALVAR CONDINSTSTATE&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><b>condInstStateForBbl</b> = CONDINST_NORMAL</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">GLOBALCONST UINT32&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#gad783207300b6d463f018da9b9bebba7d\">MAX_CLIENT_TLS_KEYS</a> = (TLS_KEY_CLIENT_LAST - TLS_KEY_CLIENT_FIRST + 1)</td></tr>\n<tr><td class=\"memItemLeft\" align=\"right\" valign=\"top\">LOCALVAR <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a54e0dc2e438a1924e754695ecf0140e4\">CLIENT_TLS_KEY_ALLOCATOR</a> *&#160;</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a6cd19d87592e2fa8b69b59c8c12e54a1\">pClientTlsKeyAllocator</a></td></tr>\n</table>\n<hr/><a name=\"details\" id=\"details\"></a><h2>Detailed Description</h2>\n<div class=\"textblock\"><p>PIN DWARF debugging information using libpindwarf (LLVM based) library</p>\n<p>Static model for instrumenting IMG's once they are loaded into memory. This file contains the ELF specific part for Linux.</p>\n<p>Ahead of Time Instrumentation</p>\n<p>Pin client functions for the follow child process mechanism</p>\n<p>PIN support for debugging information</p>\n<p>Pin client functions for the application-level debugger.</p>\n<p>Deprecated Pin client functions.</p>\n<p>Static model for instrumenting IMG's once they are loaded into memory.</p>\n<p>Pin client interface and implementation for internal exception handling</p>\n<p>Client side interface to pin vm.</p>\n<p>Additional client side interface to pin vm containing the interfaces useful for a replay tool. These mainly allow a PinTool to request that Pin execute callbacks associated with specific events.</p>\n<p>pin client state</p>\n<p>Pin Jitted Functions Support</p>\n<p>Pin client functions to temporarily stop all application threads, examine their state and resume.</p>\n<p>Threading API for clients</p>\n<p>Pin client interfaces for trace versioning </p>\n</div><hr/><h2>Typedef Documentation</h2>\n<a class=\"anchor\" id=\"a5e0a0b00100c49bf205b4959f008e2f0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CODE_RANGES\" ref=\"a5e0a0b00100c49bf205b4959f008e2f0\" args=\"\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">typedef map&lt;ADDRINT, USIZE&gt; <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a5e0a0b00100c49bf205b4959f008e2f0\">LEVEL_PINCLIENT::CODE_RANGES</a></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Map of code ranges in image. Key is base address of code range, Value is size of the range. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a03b643cf8ed4f53d9578ae1c0ea80ff1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GET_EMULATED_REGISTER_CALLBACK\" ref=\"a03b643cf8ed4f53d9578ae1c0ea80ff1\" args=\")(unsigned toolRegId, THREADID tid, CONTEXT *ctxt, VOID *data, VOID *v)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">typedef VOID(* <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a03b643cf8ed4f53d9578ae1c0ea80ff1\">LEVEL_PINCLIENT::GET_EMULATED_REGISTER_CALLBACK</a>)(unsigned toolRegId, <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, VOID *data, VOID *v)</td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call-back function that Pin calls to get the value of a register emulated by the tool.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">toolRegId</td><td>Identifies the emulated register (from the <em>registerDescriptions</em> parameter to <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#afefe009e0072dbf80e266586a2ab9987\">PIN_AddDebuggerRegisterEmulator()</a>). </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">tid</td><td>Identifies the thread whose register is read. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">ctxt</td><td>Architected register state for the thread. </td></tr>\n    <tr><td class=\"paramdir\">[out]</td><td class=\"paramname\">data</td><td>Points to a buffer that receives the value of the register. The value must be stored in little-endian format (least significant bytes first). If the register size is not an even multiple of bytes, the upper bits of the last byte (most significant byte) are unused. If the register size is 2, 4, or 8 bytes, <em>data</em> is naturally aligned, so it may be cast to a pointer of the appropriate type. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">v</td><td>The tool's call-back value. </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a9c0055d850f5c7299b4e3b9e3b26e53c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GET_TARGET_DESCRIPTION_CALLBACK\" ref=\"a9c0055d850f5c7299b4e3b9e3b26e53c\" args=\")(const std::string &amp;name, USIZE size, VOID *buf, VOID *v)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">typedef USIZE(* <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a9c0055d850f5c7299b4e3b9e3b26e53c\">LEVEL_PINCLIENT::GET_TARGET_DESCRIPTION_CALLBACK</a>)(const std::string &amp;name, USIZE size, VOID *buf, VOID *v)</td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call-back function that Pin calls to get the content of a document that describes an emulated target processor to an application-level debugger. This is useful, for example, when a Pin tool emulates additional registers beyond those defined by the native CPU. A debugger can use this document to understand the emulated registers and how to display them.</p>\n<p>The format of the returned document varies depending on the debugger that is connected to Pin. Tools can use <a class=\"el\" href=\"group__APPDEBUG__API.html#ga00b8b40b94841bd54585a68f790417a7\">PIN_GetDebuggerType()</a> to tell which debugger is connected.</p>\n<p>When used with GDB, the description should be an XML \"target feature\" document, as described in the GDB user manual, \"Debugging With GDB\". See the appendix titled \"Target Descriptions\" for details of the XML document format. GDB starts by asking for a document titled \"target.xml\". However, this document may reference other documents via \"include\" statements. If so, GDB will ask for those additional documents by their names.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">name</td><td>The name of the requested document. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">size</td><td>Size (bytes) of the <em>buf</em> buffer. </td></tr>\n    <tr><td class=\"paramdir\">[out]</td><td class=\"paramname\">buf</td><td>Points to a buffer that receives the content of the document. If the document requires more than <em>size</em> bytes, the tool need not write anything into <em>buf</em>. Instead, the tool should return the required size. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">v</td><td>The tool's call-back value.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>If the tool knows how to provide the document named <em>name</em>, it returns the size (bytes) of that document. If that size is less than or equal to <em>size</em>, the tool should also write the content of the document to <em>buf</em>. If the tool does not know how to provide this document, it should return zero. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a371d93560a7f7ae5ec4b97c228197fce\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INTERCEPT_DEBUGGING_EVENT_CALLBACK\" ref=\"a371d93560a7f7ae5ec4b97c228197fce\" args=\")(THREADID tid, DEBUGGING_EVENT eventType, CONTEXT *ctxt, VOID *arg)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">typedef BOOL(* <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a371d93560a7f7ae5ec4b97c228197fce\">LEVEL_PINCLIENT::INTERCEPT_DEBUGGING_EVENT_CALLBACK</a>)(<a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, DEBUGGING_EVENT eventType, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, VOID *arg)</td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call-back function when the tool intercepts a debugging event with <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#adfb0406b9445f953a6caff6cd8570a19\">PIN_InterceptDebuggingEvent()</a>.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">tid</td><td>The Pin thread ID of the thread that received the debugging event. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">eventType</td><td>Tells the debugging event. </td></tr>\n    <tr><td class=\"paramdir\">[in,out]</td><td class=\"paramname\">ctxt</td><td>On input, gives the register state at the point the thread received the event. The tool may change <em>ctxt</em>. If the event is passed on to the debugger, the debugger sees the modified register state. If the event is not passed on to the debugger, the thread resumes execution at the new register state. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">arg</td><td>The tool's call-back value.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>Returning TRUE tells Pin to pass the debugging event on to the debugger. Returning FALSE tells Pin to squash the event and the thread resumes without stopping in the debugger.</dd></dl>\n<p>The following scenarios are not allowed:</p>\n<ul>\n<li>The call-back may not return FALSE for DEBUGGING_EVENT_ASYNC_BREAK.</li>\n<li>If the call-back returns TRUE for DEBUGGING_EVENT_BREAKPOINT or DEBUGGING_EVENT_SINGLE_STEP, it may not change the value of REG_INST_PC in <em>ctxt</em>. This restriction exists because debuggers typically make assumptions on the PC value when these events trigger. </li>\n</ul>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aa9709409d9f414af22b6c3f0a12c95a3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SET_EMULATED_REGISTER_CALLBACK\" ref=\"aa9709409d9f414af22b6c3f0a12c95a3\" args=\")(unsigned toolRegId, THREADID tid, CONTEXT *ctxt, const VOID *data, VOID *v)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">typedef VOID(* <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aa9709409d9f414af22b6c3f0a12c95a3\">LEVEL_PINCLIENT::SET_EMULATED_REGISTER_CALLBACK</a>)(unsigned toolRegId, <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a> tid, <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *ctxt, const VOID *data, VOID *v)</td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call-back function that Pin calls to set the value of a register emulated by the tool.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">toolRegId</td><td>Identifies the emulated register (from the <em>registerDescriptions</em> parameter to <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#afefe009e0072dbf80e266586a2ab9987\">PIN_AddDebuggerRegisterEmulator()</a>). </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">tid</td><td>Identifies the thread whose register is written. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">ctxt</td><td>Architected register state for the thread. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">data</td><td>Points to the new value for the register. The value is stored in the same format as described in GET_EMULATED_REGISTER_CALLBACK. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">v</td><td>The tool's call-back value. </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ad2ae6fe95412a7e60c6e2687215e7d96\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP\" ref=\"ad2ae6fe95412a7e60c6e2687215e7d96\" args=\"\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">typedef map&lt;SYM, ADDRINT&gt; <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ad2ae6fe95412a7e60c6e2687215e7d96\">LEVEL_PINCLIENT::SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP</a></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This map is used during the ifunc symbol processing. It maps between ifunc symbol names and the actual function addresses which doesn't have a symbol associated with them. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a64ca0820c096be9a8425fc0d9a70f7a8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACEGENCODE_CALLBACK\" ref=\"a64ca0820c096be9a8425fc0d9a70f7a8\" args=\")(TRACE trace, VOID *v)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">typedef VOID(* <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a64ca0820c096be9a8425fc0d9a70f7a8\">LEVEL_PINCLIENT::TRACEGENCODE_CALLBACK</a>)(<a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> trace, VOID *v)</td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call back function when Pin has to generate a rogue trace for an exit </p>\n\n</div>\n</div>\n<hr/><h2>Enumeration Type Documentation</h2>\n<a class=\"anchor\" id=\"a40634ac1007bcb5ba26fe037d5c73422\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::@17\" ref=\"a40634ac1007bcb5ba26fe037d5c73422\" args=\"\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">anonymous enum</td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Keys to access client data in the thread local storage </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aee3bb3cf999bb595aee75ad4d0745a9e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMAGE_LOAD_FLAGS\" ref=\"aee3bb3cf999bb595aee75ad4d0745a9e\" args=\"\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">enum <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aee3bb3cf999bb595aee75ad4d0745a9e\">LEVEL_PINCLIENT::IMAGE_LOAD_FLAGS</a></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Names for flags to construct the arguments to ProcessImageLoad and ImgLoad Without these you get a list of cryptic BOOL arguments; by using these you see what the arguments being passed mean. </p>\n<dl><dt><b>Enumerator: </b></dt><dd><table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n<tr><td valign=\"top\"><em><a class=\"anchor\" id=\"aee3bb3cf999bb595aee75ad4d0745a9ea6f623c8327e2d18e98947584512a9be4\"></a><!-- doxytag: member=\"IMAGE_LOAD_MAINEXECUTABLE\" ref=\"aee3bb3cf999bb595aee75ad4d0745a9ea6f623c8327e2d18e98947584512a9be4\" args=\"\" -->IMAGE_LOAD_MAINEXECUTABLE</em>&nbsp;</td><td>\n<p>Set for the main executable. </p>\n</td></tr>\n<tr><td valign=\"top\"><em><a class=\"anchor\" id=\"aee3bb3cf999bb595aee75ad4d0745a9ea57e940bb73df0b6928809abc9e78c2ae\"></a><!-- doxytag: member=\"IMAGE_LOAD_FOUNDINMEMORY\" ref=\"aee3bb3cf999bb595aee75ad4d0745a9ea57e940bb73df0b6928809abc9e78c2ae\" args=\"\" -->IMAGE_LOAD_FOUNDINMEMORY</em>&nbsp;</td><td>\n<p>Set if the image was found in memory during Pin initalization (only Windows at present) </p>\n</td></tr>\n<tr><td valign=\"top\"><em><a class=\"anchor\" id=\"aee3bb3cf999bb595aee75ad4d0745a9ead1484fb8b885e9f54b79efac5c2066e0\"></a><!-- doxytag: member=\"IMAGE_LOAD_RUNTIME\" ref=\"aee3bb3cf999bb595aee75ad4d0745a9ead1484fb8b885e9f54b79efac5c2066e0\" args=\"\" -->IMAGE_LOAD_RUNTIME</em>&nbsp;</td><td>\n<p>Set if the image was loaded at runtime. </p>\n</td></tr>\n<tr><td valign=\"top\"><em><a class=\"anchor\" id=\"aee3bb3cf999bb595aee75ad4d0745a9ea6296486ba50d398ec22b841e97e1b11c\"></a><!-- doxytag: member=\"IMAGE_LOAD_TEXTFROMIMAGE\" ref=\"aee3bb3cf999bb595aee75ad4d0745a9ea6296486ba50d398ec22b841e97e1b11c\" args=\"\" -->IMAGE_LOAD_TEXTFROMIMAGE</em>&nbsp;</td><td>\n<p>Set if RTNs should get their code from Pin's copy of the image, rather than the one mapped by the OS. (For replay where the OS' one may not exist yet). </p>\n</td></tr>\n<tr><td valign=\"top\"><em><a class=\"anchor\" id=\"aee3bb3cf999bb595aee75ad4d0745a9ea8ece880802674715efdfa82b17ceea3e\"></a><!-- doxytag: member=\"IMAGE_LOAD_INTERPRETER\" ref=\"aee3bb3cf999bb595aee75ad4d0745a9ea8ece880802674715efdfa82b17ceea3e\" args=\"\" -->IMAGE_LOAD_INTERPRETER</em>&nbsp;</td><td>\n<p>Set for the program's interpreter (loader) </p>\n</td></tr>\n</table>\n</dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ab17933d09ef2378f9a385e00e041911e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::REPLAY_IMAGE_TYPE\" ref=\"ab17933d09ef2378f9a385e00e041911e\" args=\"\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">enum <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ab17933d09ef2378f9a385e00e041911e\">LEVEL_PINCLIENT::REPLAY_IMAGE_TYPE</a></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Image types for <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ae6d4291b91c0f4cdf30e9f789ac9f6ab\">PIN_ReplayImageLoad()</a> </p>\n<dl><dt><b>Enumerator: </b></dt><dd><table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n<tr><td valign=\"top\"><em><a class=\"anchor\" id=\"ab17933d09ef2378f9a385e00e041911ea736a565b689088f245e364274dc94e52\"></a><!-- doxytag: member=\"REPLAY_IMAGE_TYPE_REGULAR\" ref=\"ab17933d09ef2378f9a385e00e041911ea736a565b689088f245e364274dc94e52\" args=\"\" -->REPLAY_IMAGE_TYPE_REGULAR</em>&nbsp;</td><td>\n<p>Regular image. </p>\n</td></tr>\n<tr><td valign=\"top\"><em><a class=\"anchor\" id=\"ab17933d09ef2378f9a385e00e041911ea876a84ec97b14930a5890e80a39c7eab\"></a><!-- doxytag: member=\"REPLAY_IMAGE_TYPE_MAIN_EXE\" ref=\"ab17933d09ef2378f9a385e00e041911ea876a84ec97b14930a5890e80a39c7eab\" args=\"\" -->REPLAY_IMAGE_TYPE_MAIN_EXE</em>&nbsp;</td><td>\n<p>Main executable image. </p>\n</td></tr>\n<tr><td valign=\"top\"><em><a class=\"anchor\" id=\"ab17933d09ef2378f9a385e00e041911ea387edc1bb726b8dc3d6f8d99f5afb219\"></a><!-- doxytag: member=\"REPLAY_IMAGE_TYPE_INTERPRETER\" ref=\"ab17933d09ef2378f9a385e00e041911ea387edc1bb726b8dc3d6f8d99f5afb219\" args=\"\" -->REPLAY_IMAGE_TYPE_INTERPRETER</em>&nbsp;</td><td>\n<p>The image of the interpreter (loader) </p>\n</td></tr>\n</table>\n</dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ae69d9a1cd56064e0397c268953ac7de7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::REPLAY_MODE\" ref=\"ae69d9a1cd56064e0397c268953ac7de7\" args=\"\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">enum <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ae69d9a1cd56064e0397c268953ac7de7\">LEVEL_PINCLIENT::REPLAY_MODE</a></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Flags passed to PIN_SetReplayMode. </p>\n<dl><dt><b>Enumerator: </b></dt><dd><table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">\n<tr><td valign=\"top\"><em><a class=\"anchor\" id=\"ae69d9a1cd56064e0397c268953ac7de7a670480aefd15f6ef98e64835e176f6d6\"></a><!-- doxytag: member=\"REPLAY_MODE_IMAGEOPS\" ref=\"ae69d9a1cd56064e0397c268953ac7de7a670480aefd15f6ef98e64835e176f6d6\" args=\"\" -->REPLAY_MODE_IMAGEOPS</em>&nbsp;</td><td>\n<p>Replayer will handle image ops. </p>\n</td></tr>\n</table>\n</dd>\n</dl>\n\n</div>\n</div>\n<hr/><h2>Function Documentation</h2>\n<a class=\"anchor\" id=\"a8af54e336d13d0a50e3a1c45c426559b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AInsertCall\" ref=\"a8af54e336d13d0a50e3a1c45c426559b\" args=\"(INS ins, IPOINT ipoint, PREDICATE pred, COND_CALL_TYPE condCallType, AFUNPTR funptr, va_list ap)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::AInsertCall </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a>&#160;</td>\n          <td class=\"paramname\"><em>ipoint</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">PREDICATE&#160;</td>\n          <td class=\"paramname\"><em>pred</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">COND_CALL_TYPE&#160;</td>\n          <td class=\"paramname\"><em>condCallType</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">AFUNPTR&#160;</td>\n          <td class=\"paramname\"><em>funptr</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">va_list&#160;</td>\n          <td class=\"paramname\"><em>ap</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>If \"condFun\" is non-zero, then this analysis call will be invoked only if condFun (which is an analysis function called immediately before \"funptr\") returns a non-zero value.</p>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux, Windows &amp; OS X*<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a7bc27a1f2ee76485897d0b3d46b6ebf3\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AInsertVersionCase\" ref=\"a7bc27a1f2ee76485897d0b3d46b6ebf3\" args=\"(INS ins, REG reg, INT32 case_value, ADDRINT version, va_list ap)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::AInsertVersionCase </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">REG&#160;</td>\n          <td class=\"paramname\"><em>reg</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">INT32&#160;</td>\n          <td class=\"paramname\"><em>case_value</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>version</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">va_list&#160;</td>\n          <td class=\"paramname\"><em>ap</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux, Windows &amp; OS X*<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aa33fad786d51ff6db7a51ad37f374c06\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AotiInstrumentationExists\" ref=\"aa33fad786d51ff6db7a51ad37f374c06\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::AotiInstrumentationExists </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>TRUE if there are any AOTI requests. Only used for an assertion to check that all AOTI has been cleared when all images are unloaded. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ab118b0b829996ea668ed5b3c43ff8e44\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AotiPlaybackCall\" ref=\"ab118b0b829996ea668ed5b3c43ff8e44\" args=\"(INS ins)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::AotiPlaybackCall </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>x internal </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a3de79db7ac47bc101333fc8d2e0310ae\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AotiRecordCall\" ref=\"a3de79db7ac47bc101333fc8d2e0310ae\" args=\"(IPOINT action, INS ins, ACALL const *acall)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::AotiRecordCall </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a>&#160;</td>\n          <td class=\"paramname\"><em>action</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ACALL const *&#160;</td>\n          <td class=\"paramname\"><em>acall</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>x internal </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a99baa03aa92b6b342069040d11c49d76\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AotiRecordMutation\" ref=\"a99baa03aa92b6b342069040d11c49d76\" args=\"(INS ins, EXT ext)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::AotiRecordMutation </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">EXT&#160;</td>\n          <td class=\"paramname\"><em>ext</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>x internal </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aa40d88269593cc522e42dd9069689434\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::AotiRemoveImageInstrumentation\" ref=\"aa40d88269593cc522e42dd9069689434\" args=\"(IMG img)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::AotiRemoveImageInstrumentation </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Remove any AOTI that has been applied to instructions in the given image. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a8a51b784d4c613aa0689e96e7a267cc1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::BBL_InsertFillBuffer\" ref=\"a8a51b784d4c613aa0689e96e7a267cc1\" args=\"(BBL bbl, IPOINT action, BUFFER_ID id,...)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::BBL_InsertFillBuffer </td>\n          <td>(</td>\n          <td class=\"paramtype\">BBL&#160;</td>\n          <td class=\"paramname\"><em>bbl</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a>&#160;</td>\n          <td class=\"paramname\"><em>action</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">BUFFER_ID&#160;</td>\n          <td class=\"paramname\"><em>id</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&#160;</td>\n          <td class=\"paramname\"><em>...</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Insert analysis code to fill one record in a trace buffer, relative to a BBL.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">bbl</td><td>The application BBL </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">action</td><td>Whether the record is filled before or after the BBL </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">id</td><td>The ID of the buffer whose record is filled </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">...</td><td><a class=\"el\" href=\"group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d\">IARG_TYPE</a>. Additional arguments to specify the fields of the trace buffer.</td></tr>\n  </table>\n  </dd>\n</dl>\n<p>Certain IARG_TYPEs cannot be used with the *_InsertFillBuffer APIs. The unsupported IARG_TYPEs are: IARG_CONTEXT, IARG_REG_REFERENCE, and IARG_REG_CONST_REFERENCE.</p>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux &amp; Windows<br/>\n <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a0af73397284764d03efb7033eca6ee3a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::BBL_InvalidForProbe\" ref=\"a0af73397284764d03efb7033eca6ee3a\" args=\"(BBL bbl)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::BBL_InvalidForProbe </td>\n          <td>(</td>\n          <td class=\"paramtype\">BBL&#160;</td>\n          <td class=\"paramname\"><em>bbl</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This routine tests whether the basic block can be replaced with probe The function return TRUE when the basic block has a problem</p>\n<ul>\n<li>bb size &lt; probe size</li>\n<li>a call instruction is inside bbl and its return address is inside the probe </li>\n</ul>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ac1e81d9d0d09a669a18bff1ca6c56247\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::BBL_Type\" ref=\"ac1e81d9d0d09a669a18bff1ca6c56247\" args=\"(BBL x)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BBL_TYPE LEVEL_PINCLIENT::BBL_Type </td>\n          <td>(</td>\n          <td class=\"paramtype\">BBL&#160;</td>\n          <td class=\"paramname\"><em>x</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>The type of the basic block </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ae9d9e8c8e1773ac38fece9849fa5f628\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallAllBufferFullCallbacks\" ref=\"ae9d9e8c8e1773ac38fece9849fa5f628\" args=\"(THREADID tid, CONTEXT *ctxt)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::CallAllBufferFullCallbacks </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Calls all of the buffer full functions in turn. Generally, this is useful when a thread terminates, since that's the only time we definitely will call all of the buffer full callbacks. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aae0f15e77f8bd505e412a86f5d6ae7c8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallApplicationFunctionUnchecked\" ref=\"aae0f15e77f8bd505e412a86f5d6ae7c8\" args=\"(const CONTEXT *ctxt, THREADID tid, CALLINGSTD_TYPE cstype, AFUNPTR origFunPtr, CALL_APPLICATION_FUNCTION_PARAM *param,...)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::CallApplicationFunctionUnchecked </td>\n          <td>(</td>\n          <td class=\"paramtype\">const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PROTO__API.html#gacfd9f3c8dc22310ce9b9152e8c61b17c\">CALLINGSTD_TYPE</a>&#160;</td>\n          <td class=\"paramname\"><em>cstype</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">AFUNPTR&#160;</td>\n          <td class=\"paramname\"><em>origFunPtr</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"structCALL__APPLICATION__FUNCTION__PARAM.html\">CALL_APPLICATION_FUNCTION_PARAM</a> *&#160;</td>\n          <td class=\"paramname\"><em>param</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&#160;</td>\n          <td class=\"paramname\"><em>...</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Equivalent version of <a class=\"el\" href=\"group__PIN__CONTROL.html#ga5ae5853e6600a23f9c552cba784870cc\">PIN_CallApplicationFunction()</a> to be used internally by Pin. This function doesn't perform the checks that <a class=\"el\" href=\"group__PIN__CONTROL.html#ga5ae5853e6600a23f9c552cba784870cc\">PIN_CallApplicationFunction()</a> does so it allows Pin to call an application function in cases where Pin tool cannot. We assume here that if you call this function then you know what you're doing.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">ctxt</td><td>The application register state to use when calling the function. Pin changes the register state in order to pass arguments to the function, but the <em>ctxt</em> parameter isn't changed. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">tid</td><td>The Pin id of the current thread (see <a class=\"el\" href=\"group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451daadb6e5681193cc8435b9e57d13acf5d4\">IARG_THREAD_ID</a>). </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">cstype</td><td>The calling standard used for calling this function (CALLINGSTD_DEFAULT recommended). </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">origFunPtr</td><td>The entry point of the application function. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">param</td><td>Additional parameters to define the exact behavior of this function invocation (or NULL for using the defaults). See <a class=\"el\" href=\"structCALL__APPLICATION__FUNCTION__PARAM.html\">CALL_APPLICATION_FUNCTION_PARAM</a> . </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">...</td><td>List of function argument type and size. </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ab6cad33f4573660889e02d65241cd6f8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallApplicationStart\" ref=\"ab6cad33f4573660889e02d65241cd6f8\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::CallApplicationStart </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<ul>\n<li>Notify VM about application start</li>\n<li>Call application start callback functions </li>\n</ul>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"add06479e9277d6495e56ed43a6244393\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallBreakpointHandlers\" ref=\"add06479e9277d6495e56ed43a6244393\" args=\"(ADDRINT, USIZE, BOOL)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN BOOL LEVEL_PINCLIENT::CallBreakpointHandlers </td>\n          <td>(</td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>addr</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">USIZE&#160;</td>\n          <td class=\"paramname\"><em>size</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">BOOL&#160;</td>\n          <td class=\"paramname\"><em>insert</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call any breakpoint handlers to handle a breakpoint set/delete command.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">addr</td><td>The address of the requested breakpoint. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">size</td><td>The size of the breakpoint (HW/SW) </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">insert</td><td>Whether if this is a breakpoint insertion or deletion.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>TRUE if any handler takes control over the breakpoint. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"afdc368dbbaf5fa963fac258622a7a63f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallBufferFullCallback\" ref=\"afdc368dbbaf5fa963fac258622a7a63f\" args=\"(BUFFER_ID id, THREADID tid, CONTEXT *ctxt, VOID *buf, UINT64 numElts)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID* LEVEL_PINCLIENT::CallBufferFullCallback </td>\n          <td>(</td>\n          <td class=\"paramtype\">BUFFER_ID&#160;</td>\n          <td class=\"paramname\"><em>id</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">VOID *&#160;</td>\n          <td class=\"paramname\"><em>buf</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">UINT64&#160;</td>\n          <td class=\"paramname\"><em>numElts</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Calls the buffer full function (as specified by PIN_DefineTraceBuffer) when either the buffer is full or the thread terminates.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">id</td><td>The ID of the trace buffer. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">tid</td><td>The ID of the thread whose buffer filled </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">buf</td><td>Pointer to the base of the filled buffer </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">numElts</td><td>Number of elements in buffer </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aa5de4339e0e000dbdb81471cad2382b7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallContextChanges\" ref=\"aa5de4339e0e000dbdb81471cad2382b7\" args=\"(THREADID threadIndex, CONTEXT_CHANGE_REASON reason, const CONTEXT *from, CONTEXT *to, INT32 info)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::CallContextChanges </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga8e4e6511a0e09fdc5ec7d6dbf395b3a8\">CONTEXT_CHANGE_REASON</a>&#160;</td>\n          <td class=\"paramname\"><em>reason</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>from</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>to</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">INT32&#160;</td>\n          <td class=\"paramname\"><em>info</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call context change callbacks. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"af562a0c721c14988965a5e367b2f7797\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallDebugInterpreters\" ref=\"af562a0c721c14988965a5e367b2f7797\" args=\"(THREADID, CONTEXT *, const char *, const char **)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN BOOL LEVEL_PINCLIENT::CallDebugInterpreters </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const char *&#160;</td>\n          <td class=\"paramname\"><em>cmd</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const char **&#160;</td>\n          <td class=\"paramname\"><em>reply</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call any debug interpreters to handle a debugger command.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">threadIndex</td><td>Pin thread ID of debugger focus thread. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">ctxt</td><td>Application register state of focus thread, which could be changed. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">cmd</td><td>Debugger command. </td></tr>\n    <tr><td class=\"paramdir\">[out]</td><td class=\"paramname\">reply</td><td>Receives a pointer to the command's response, if it is handled.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>TRUE if any interpreter handles <em>cmd</em>. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a622417b787f3af47c1bf78ef6c7a1b26\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallDetachCompletionCallback\" ref=\"a622417b787f3af47c1bf78ef6c7a1b26\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::CallDetachCompletionCallback </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call detach probed completion callbacks. When this callback function is called, it is guaranteed that Pin removed all probes from the application code and that no other callback function will be called afterwards (except from additional Detach callback functions). </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aa2681511ab60e48e3bd1db8c815ab2d5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallFinis\" ref=\"aa2681511ab60e48e3bd1db8c815ab2d5\" args=\"(INT32 code)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::CallFinis </td>\n          <td>(</td>\n          <td class=\"paramtype\">INT32&#160;</td>\n          <td class=\"paramname\"><em>code</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>x </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a6ac9f850dbebce7bbe95f7e96eacace8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallFollowChildProcess\" ref=\"a6ac9f850dbebce7bbe95f7e96eacace8\" args=\"(CHILD_PROCESS childProcess, const char **toolAppend)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN BOOL LEVEL_PINCLIENT::CallFollowChildProcess </td>\n          <td>(</td>\n          <td class=\"paramtype\">CHILD_PROCESS&#160;</td>\n          <td class=\"paramname\"><em>childProcess</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const char **&#160;</td>\n          <td class=\"paramname\"><em>toolAppend</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call Follow child process callback</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">childProcess</td><td>Child process handle </td></tr>\n    <tr><td class=\"paramdir\">[out]</td><td class=\"paramname\">toolAppend</td><td>If Pin should automatically add the \"KnobAppendLogFile\" switch to the tool's command line, <em>toolAppend</em> is set to the name of that switch. If the switch should not be automatically added, it is set to NULL.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>TRUE If user is interested to inject Pin (and tool) into child/exec-ed process<br/>\n FALSE If user is not interested to inject Pin (and tool) into child/exec-ed process<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ac870ed7f318d38ecc29792c1405a886e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallForksAfterInChild\" ref=\"ac870ed7f318d38ecc29792c1405a886e\" args=\"(THREADID threadId, const CONTEXT *ctxt)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::CallForksAfterInChild </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadId</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>notify child after fork </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a79e4460dea1b39fb174638a48f72952e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallForksAfterInParent\" ref=\"a79e4460dea1b39fb174638a48f72952e\" args=\"(THREADID threadId, const CONTEXT *ctxt)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::CallForksAfterInParent </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadId</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>notify parent after fork </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aeffae3f5bdc9b9e05ccd2957ec93cabf\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallForksBefore\" ref=\"aeffae3f5bdc9b9e05ccd2957ec93cabf\" args=\"(THREADID threadId, const CONTEXT *ctxt)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::CallForksBefore </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadId</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>notify before fork </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aac62d19ea850c5202aca9c662a9170e7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallInterceptedDebuggingEvent\" ref=\"aac62d19ea850c5202aca9c662a9170e7\" args=\"(THREADID, DEBUGGING_EVENT, CONTEXT *)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN BOOL LEVEL_PINCLIENT::CallInterceptedDebuggingEvent </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">DEBUGGING_EVENT&#160;</td>\n          <td class=\"paramname\"><em>eventType</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call a client debugging event interceptor function.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">tid</td><td>Thread that received the debugging event. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">eventType</td><td>Tells the debugging event. </td></tr>\n    <tr><td class=\"paramdir\">[in,out]</td><td class=\"paramname\">ctxt</td><td>Register state when the event was received, which the tool can modify.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>TRUE tells Pin to pass the even on to the debugger, FALSE tells Pin to squash the event.</dd></dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ac5af6e1448c76411194b5d77bd361b8f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallInterceptSignal\" ref=\"ac5af6e1448c76411194b5d77bd361b8f\" args=\"(THREADID tid, INT32 sig, CONTEXT *ctxt, BOOL hasHandler, const EXCEPTION_INFO *pExceptInfo)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN BOOL LEVEL_PINCLIENT::CallInterceptSignal </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">INT32&#160;</td>\n          <td class=\"paramname\"><em>sig</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">BOOL&#160;</td>\n          <td class=\"paramname\"><em>hasHandler</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const <a class=\"el\" href=\"group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5\">EXCEPTION_INFO</a> *&#160;</td>\n          <td class=\"paramname\"><em>pExceptInfo</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call signal \"intercept\" callbacks. Returns TRUE if signal should be passed on to the application. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a1c2a79b9049f8a9ab48dd784b53be8ff\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallMemoryAddrTrans\" ref=\"a1c2a79b9049f8a9ab48dd784b53be8ff\" args=\"(PIN_MEM_TRANS_INFO *memTransInfo, void *)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN ADDRINT PIN_FAST_ANALYSIS_CALL LEVEL_PINCLIENT::CallMemoryAddrTrans </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"structPIN__MEM__TRANS__INFO.html\">PIN_MEM_TRANS_INFO</a> *&#160;</td>\n          <td class=\"paramname\"><em>memTransInfo</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">void *&#160;</td>\n          <td class=\"paramname\">&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Tools callback function to tell PIN to use a different memory address. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a900f475870cb230ee9b8a98233feffad\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallProbesInserted\" ref=\"a900f475870cb230ee9b8a98233feffad\" args=\"(IMG img)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::CallProbesInserted </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call callbacks when Pin is done inserting probes. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"abfd805493ad262757ea268fbe1e60dc1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallRtnCallbacks\" ref=\"abfd805493ad262757ea268fbe1e60dc1\" args=\"(RTN rtn)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::CallRtnCallbacks </td>\n          <td>(</td>\n          <td class=\"paramtype\">RTN&#160;</td>\n          <td class=\"paramname\"><em>rtn</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Calls all rtn callbacks for given routine </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ab29eb4fae54c8a104e811af43ac4d916\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallSmcCallbacks\" ref=\"ab29eb4fae54c8a104e811af43ac4d916\" args=\"(ADDRINT traceStartAddress, ADDRINT traceEndAddress)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::CallSmcCallbacks </td>\n          <td>(</td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>traceStartAddress</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>traceEndAddress</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call SMC callbacks. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aa52208efeab7bd250e87838239b897d9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallSyscallEntry\" ref=\"aa52208efeab7bd250e87838239b897d9\" args=\"(THREADID threadIndex, CONTEXT *ctxt, SYSCALL_STANDARD std)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::CallSyscallEntry </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">SYSCALL_STANDARD&#160;</td>\n          <td class=\"paramname\"><em>std</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call syscall entry callbacks. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a841e66c6ef638d7c61edd9dcf5ab38a9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallSyscallExit\" ref=\"a841e66c6ef638d7c61edd9dcf5ab38a9\" args=\"(THREADID threadIndex, CONTEXT *ctxt, SYSCALL_STANDARD std)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::CallSyscallExit </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">SYSCALL_STANDARD&#160;</td>\n          <td class=\"paramname\"><em>std</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call syscall exit callbacks. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"af97df78b685115c02e1f43ffd119c9c0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallThreadAttachInJitMode\" ref=\"af97df78b685115c02e1f43ffd119c9c0\" args=\"(THREADID threadIndex, CONTEXT *ctxt)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::CallThreadAttachInJitMode </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call attached thread callback in JIT mode </p>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a559f28d92aef38a62230ad30a5a5b692\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallThreadAttachInProbeMode\" ref=\"a559f28d92aef38a62230ad30a5a5b692\" args=\"(VOID *sigmask)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::CallThreadAttachInProbeMode </td>\n          <td>(</td>\n          <td class=\"paramtype\">VOID *&#160;</td>\n          <td class=\"paramname\"><em>sigmask</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call attached thread callback in probe mode </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a6db5bfe9dd4fd5813f6ea524942894e0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallThreadDetachInJitMode\" ref=\"a6db5bfe9dd4fd5813f6ea524942894e0\" args=\"(THREADID threadIndex, const CONTEXT *ctxt)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::CallThreadDetachInJitMode </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call detach thread callback in JIT mode </p>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a33979b57dc3a084f7eaa5b2ee99d6a03\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallThreadDetachInProbeMode\" ref=\"a33979b57dc3a084f7eaa5b2ee99d6a03\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::CallThreadDetachInProbeMode </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call detach thread callback in probe mode </p>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aa37067a024fe890ef1f75990d847d704\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallThreadFinis\" ref=\"aa37067a024fe890ef1f75990d847d704\" args=\"(THREADID threadIndex, const CONTEXT *ctxt, INT32 code)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::CallThreadFinis </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">INT32&#160;</td>\n          <td class=\"paramname\"><em>code</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call Thread Fini callbacks </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ad0af5a85f4b90c58305ceb49b56e190b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallThreadStarts\" ref=\"ad0af5a85f4b90c58305ceb49b56e190b\" args=\"(THREADID threadIndex, CONTEXT *ctxt, INT32 flags)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::CallThreadStarts </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">INT32&#160;</td>\n          <td class=\"paramname\"><em>flags</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call Thread Start callbacks </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a2b7c73780476c5c06a3c9553841c0661\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CallTraceCallbacks\" ref=\"a2b7c73780476c5c06a3c9553841c0661\" args=\"(REGION *region)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::CallTraceCallbacks </td>\n          <td>(</td>\n          <td class=\"paramtype\">REGION *&#160;</td>\n          <td class=\"paramname\"><em>region</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Walk the list of trace instrumentors and call them </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"acd925b36779e20f1a4aac18ecc736957\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckForProbeOverlap\" ref=\"acd925b36779e20f1a4aac18ecc736957\" args=\"(INS ins, USIZE probe_size, BOOL allowPOP)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN PROBE_TAG LEVEL_PINCLIENT::CheckForProbeOverlap </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">USIZE&#160;</td>\n          <td class=\"paramname\"><em>probe_size</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">BOOL&#160;</td>\n          <td class=\"paramname\"><em>allowPOP</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>CheckForProbeOverlap - Tests if a probe already exists for a code location</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">ins</td><td>the instruction where the probe should be inserted </td></tr>\n    <tr><td class=\"paramname\">probe_size</td><td>the size of the probe </td></tr>\n    <tr><td class=\"paramname\">allowPOP</td><td>is POP (probe on probe) allowed</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>tag which indicates whether code location can be probed Possible values: PROBE_TAG_OK PROBE_TAG_PREV_PROBE </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a71ee07774932285f8bdb639f0b8897f9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckForSafeProbe\" ref=\"a71ee07774932285f8bdb639f0b8897f9\" args=\"(INS ins, BOOL allowPOP, USIZE *probe_size, USIZE suggested_probe_size, PROBE_MODE mode, BOOL checkForPadding)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN PROBE_TAG LEVEL_PINCLIENT::CheckForSafeProbe </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">BOOL&#160;</td>\n          <td class=\"paramname\"><em>allowPOP</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">USIZE *&#160;</td>\n          <td class=\"paramname\"><em>probe_size</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">USIZE&#160;</td>\n          <td class=\"paramname\"><em>suggested_probe_size</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">PROBE_MODE&#160;</td>\n          <td class=\"paramname\"><em>mode</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">BOOL&#160;</td>\n          <td class=\"paramname\"><em>checkForPadding</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Makes the various probe tests.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">ins</td><td>The instruction where the probe should be inserted </td></tr>\n    <tr><td class=\"paramname\">allowPOP</td><td>Probe on probe is allowed </td></tr>\n    <tr><td class=\"paramname\">probe_size</td><td>An output parameter. The size of the probe that was tested for safety. </td></tr>\n    <tr><td class=\"paramname\">suggested_probe_size</td><td>A suggested probe size. If USIZE_INVALID() is passed then PIN will choose the smaller probe size (6 bytes) </td></tr>\n    <tr><td class=\"paramname\">mode</td><td>The probe mode (PROBE_MODE_DEFAULT /PROBE_MODE_ALLOW_RELOCATION) </td></tr>\n    <tr><td class=\"paramname\">checkForPadding</td><td>Check that the bytes which follow the first RTN_Size bytes up to the RTN_Range are all nops </td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>tag The PROBE_TAG is set to describe why the function cannot be probed, or PROBE_OK or PROBE_RELOCATABLE. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"af1d748476519707c91124bacb9eda9a7\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckNotInCallback\" ref=\"af1d748476519707c91124bacb9eda9a7\" args=\"(THREADID tid, const char *function)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::CheckNotInCallback </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const char *&#160;</td>\n          <td class=\"paramname\"><em>function</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Check that a Pin client user interface call has been made from an analysis function, not a callback. </p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">tid</td><td>Thread ID of the thread making the call </td></tr>\n    <tr><td class=\"paramname\">function</td><td>Name of the interface function being called</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux, Windows, BSD<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aa6376f0f3895bc1ecfbc0b4d0959293a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckPinClientLock\" ref=\"aa6376f0f3895bc1ecfbc0b4d0959293a\" args=\"(const CHAR *funname)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::CheckPinClientLock </td>\n          <td>(</td>\n          <td class=\"paramtype\">const CHAR *&#160;</td>\n          <td class=\"paramname\"><em>funname</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Check that we have the client lock.</p>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br/>\n <b>O/S</b>: Linux, Windows &amp; OS X*<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a35f082729a54d94c0404f1d60f10dca6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckPinInitialized\" ref=\"a35f082729a54d94c0404f1d60f10dca6\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::CheckPinInitialized </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Raise an error if pin has not been initialized. Call this from pin api functions to ensure that <a class=\"el\" href=\"group__PIN__CONTROL.html#ga783d3bd40c3fb2ca51b1f9af31a70c9c\">PIN_Init()</a> has been called first. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a45c8eb634b2c3fb728a520b1503a8455\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CheckProbeSafetyStatically\" ref=\"a45c8eb634b2c3fb728a520b1503a8455\" args=\"(INS ins, RTN rtn, BOOL checkForPadding, UINT32 probe_size)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN PROBE_TAG LEVEL_PINCLIENT::CheckProbeSafetyStatically </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">RTN&#160;</td>\n          <td class=\"paramname\"><em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">BOOL&#160;</td>\n          <td class=\"paramname\"><em>checkForPadding</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">UINT32&#160;</td>\n          <td class=\"paramname\"><em>probe_size</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>CheckProbeSafetyStatically - Tests if the given RTN is a candidate for function insertion using probes.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">ins</td><td>the instruction where the probe should be inserted </td></tr>\n    <tr><td class=\"paramname\">rtn</td><td>the routine to be checked for replacement </td></tr>\n    <tr><td class=\"paramname\">checkForPadding</td><td>checkForPadding rtn boundaries to its annotated size, otherwise next SYM address defines the size. </td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>tag which indicates whether function can be probed. Possible values: PROBE_TAG_OK PROBE_TAG_TOO_SMALL PROBE_TAG_BRANCH_TARGET PROBE_TAG_POSSIBLE_UNIDENTIFIED_BRANCH_TARGET PROBE_TAG_RUNTIME_FIXUP </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"af377b565131f78619a601361d21f72b5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ClientInt\" ref=\"af377b565131f78619a601361d21f72b5\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">SECTION_END GLOBALDLLFUN PINCLIENTINT* LEVEL_PINCLIENT::ClientInt </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>x </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a1ba7380410fb3c87de838eae9e87d913\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ClientIntC\" ref=\"a1ba7380410fb3c87de838eae9e87d913\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">GLOBALDLLCFUN PINCLIENTINT* LEVEL_PINCLIENT::ClientIntC </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>x </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ac10e5a998df02e25ba25f567e424d08d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::Close_Rtn\" ref=\"ac10e5a998df02e25ba25f567e424d08d\" args=\"(RTN rtn)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::Close_Rtn </td>\n          <td>(</td>\n          <td class=\"paramtype\">RTN&#160;</td>\n          <td class=\"paramname\"><em>rtn</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Close the given RTN. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ac8e782e5b73d7578df307fbf803518f8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CompleteImageLoad\" ref=\"ac8e782e5b73d7578df307fbf803518f8\" args=\"(IMG img, void *arg)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::CompleteImageLoad </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">void *&#160;</td>\n          <td class=\"paramname\"><em>arg</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>When the application loads a new image, do some bookkeeping. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a4827df1144e026140854053f6260e004\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CompleteProbesInstrumentationForCurrentModule\" ref=\"a4827df1144e026140854053f6260e004\" args=\"(IMG img)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::CompleteProbesInstrumentationForCurrentModule </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>In probes mode, if the user inserted any calls, generate the code now. This was not done during ImageLoad() because users can insert several calls on one RTN. This method restricts users to inserting probes in ImageLoad(). This is OK, because it is the only thread- safe place to do it.</p>\n<p>Register all unwind frames </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a9d11d9715b1647d8454699309168b389\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CookRegsym\" ref=\"a9d11d9715b1647d8454699309168b389\" args=\"(IMG img, SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP *sym_resolver_vs_actual_address_ifunc_map)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::CookRegsym </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">SYM_RESOLVER_VS_ACTUAL_ADDRESS_IFUNC_MAP *&#160;</td>\n          <td class=\"paramname\"><em>sym_resolver_vs_actual_address_ifunc_map</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>cook .symtab, like IMG_CookRegsym, but less error checking so it won't assert on valid images name_vs_actual_address_ifunc_map is a temporary data structure which is used during the processing of ifunc symbols. Contains only ifunc symbols that their corresponding actual function addresses don't have a symbol which is associated with them. This map will be processed afterwards by the function: \"CreateRtnOriginatedFromIfunc\", where an rtn object will be created for each instance in the map. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a6ca1e80a9b07359325653e26b2bd460f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DebuggerClientInitialize\" ref=\"a6ca1e80a9b07359325653e26b2bd460f\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::DebuggerClientInitialize </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Initialize the client library call-backs for the application-level debugger API's. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a508ed445511af017a35bafb36134f856\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DeprecatedCallSignalAfters\" ref=\"a508ed445511af017a35bafb36134f856\" args=\"(THREADID threadIndex, const CONTEXT *from, const CONTEXT *to)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::DeprecatedCallSignalAfters </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>from</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>to</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call signal \"after\" callbacks. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a32ba8de38eaf8c944cd602a756c2adff\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DeprecatedCallSignalBefores\" ref=\"a32ba8de38eaf8c944cd602a756c2adff\" args=\"(THREADID threadIndex, INT32 sig, const CONTEXT *from, const CONTEXT *to)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::DeprecatedCallSignalBefores </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">INT32&#160;</td>\n          <td class=\"paramname\"><em>sig</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>from</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>to</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call signal \"before\" callbacks. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"acec3a8376aede04a6af2aed6706ceb2c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DeprecatedCallThreadBegins\" ref=\"acec3a8376aede04a6af2aed6706ceb2c\" args=\"(THREADID threadIndex, VOID *sp, int flags)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::DeprecatedCallThreadBegins </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">VOID *&#160;</td>\n          <td class=\"paramname\"><em>sp</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">int&#160;</td>\n          <td class=\"paramname\"><em>flags</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call thread \"begin\" callbacks. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a81fa093db0b8a9bbff132e64b68691bc\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DeprecatedCallThreadEnds\" ref=\"a81fa093db0b8a9bbff132e64b68691bc\" args=\"(THREADID threadIndex, INT32 code)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::DeprecatedCallThreadEnds </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadIndex</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">INT32&#160;</td>\n          <td class=\"paramname\"><em>code</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call thread \"end\" callbacks. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ae29376630884d0b2b76de2c5ca3ec305\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DestroyClientTls\" ref=\"ae29376630884d0b2b76de2c5ca3ec305\" args=\"(THREADID threadIndex)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::DestroyClientTls </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadIndex</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Destroy client TLS in the given thread. </p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">threadIndex</td><td>ID of the target thread </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ad2dc3f523c9139e9b34fd992f8cf4def\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DisassembleRegion\" ref=\"ad2dc3f523c9139e9b34fd992f8cf4def\" args=\"(RTN rtn, BBL bbl, const VOID *current, const VOID *end, ADDRINT rtnStart, ADDRINT rtnEnd, ADDRINT rtnLimit, ADDRINT virtual_offset)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::DisassembleRegion </td>\n          <td>(</td>\n          <td class=\"paramtype\">RTN&#160;</td>\n          <td class=\"paramname\"><em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">BBL&#160;</td>\n          <td class=\"paramname\"><em>bbl</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const VOID *&#160;</td>\n          <td class=\"paramname\"><em>current</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const VOID *&#160;</td>\n          <td class=\"paramname\"><em>end</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>rtnStart</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>rtnEnd</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>rtnLimit</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>virtual_offset</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n\n<p><p>RtnOutsideRangesManager().HaveRet() </p>\n</p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a91b20661756eb216ce79a1a00cf28c7c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoAttachsProbed\" ref=\"a91b20661756eb216ce79a1a00cf28c7c\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::DoAttachsProbed </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Perfrom probed attach operations </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a9ae6545b0de8e11ceeb2a156fbddb308\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoDetachs\" ref=\"a9ae6545b0de8e11ceeb2a156fbddb308\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::DoDetachs </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Walk the list of detach functions </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a37517ef9880857f380a896b503385f53\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::DoDetachsProbed\" ref=\"a37517ef9880857f380a896b503385f53\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::DoDetachsProbed </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>On Linux distributions, this function is called by the dedicated thread. It is called when all of the thread detach callbacks from all the application threads have been given. On non Linux distributions, this function is called by the dedicated detach thread while all of the application threads are stopped. The function performs:</p>\n<ul>\n<li>Remove callbacks and probes.</li>\n<li>Unload all images (and ask to remove probes),</li>\n<li>Set pin state to be detached.,</li>\n<li>Call the detach completion callbacks(Only on non linux).</li>\n<li>Notify about detach completion (Only on non linux). </li>\n</ul>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a53f3fcf0151e3349d95416e25ee4d9c6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::EDG_INVALID\" ref=\"a53f3fcf0151e3349d95416e25ee4d9c6\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">EDG LEVEL_PINCLIENT::EDG_INVALID </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>An invalid edge </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a3fac8ea1c46bf047849cdf42c369f2df\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::EDG_NextSucc\" ref=\"a3fac8ea1c46bf047849cdf42c369f2df\" args=\"(EDG x)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">EDG LEVEL_PINCLIENT::EDG_NextSucc </td>\n          <td>(</td>\n          <td class=\"paramtype\">EDG&#160;</td>\n          <td class=\"paramname\"><em>x</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>The next successor edge </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a1b2f4b1757a053c6670262210511ffd8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::EDG_Type\" ref=\"a1b2f4b1757a053c6670262210511ffd8\" args=\"(EDG x)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">EDG_TYPE LEVEL_PINCLIENT::EDG_Type </td>\n          <td>(</td>\n          <td class=\"paramtype\">EDG&#160;</td>\n          <td class=\"paramname\"><em>x</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>The type of the edge </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a0ab2a735ea8ee72c359d758b526be822\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::EDG_Valid\" ref=\"a0ab2a735ea8ee72c359d758b526be822\" args=\"(EDG x)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::EDG_Valid </td>\n          <td>(</td>\n          <td class=\"paramtype\">EDG&#160;</td>\n          <td class=\"paramname\"><em>x</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>True if x is not <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a53f3fcf0151e3349d95416e25ee4d9c6\">EDG_INVALID()</a> </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a34ff185bcb1194021bc0c00dc5394b6e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::EnterPinClientMasterMode\" ref=\"a34ff185bcb1194021bc0c00dc5394b6e\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::EnterPinClientMasterMode </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>The VM has called into the pin client </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a97b8e7b9232fe94a75d5a8860d542daa\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ExitPinClientMasterMode\" ref=\"a97b8e7b9232fe94a75d5a8860d542daa\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::ExitPinClientMasterMode </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Returning from pin client to VM </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a3bfb3f37ebea5ae134fc1a35f0c10a34\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FindCodeRanges\" ref=\"a3bfb3f37ebea5ae134fc1a35f0c10a34\" args=\"(IMG img, CODE_RANGES *rangeMap)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::FindCodeRanges </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">CODE_RANGES *&#160;</td>\n          <td class=\"paramname\"><em>rangeMap</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Find all code ranges in binary image according to information from image headers. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a9f66eabbfb8a323c113902c49b0d918a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::FindGnuDebugLinkFile\" ref=\"a9f66eabbfb8a323c113902c49b0d918a\" args=\"(IMG img, CHAR **imageStart, size_t *imageSize)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">string LEVEL_PINCLIENT::FindGnuDebugLinkFile </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">CHAR **&#160;</td>\n          <td class=\"paramname\"><em>imageStart</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">size_t *&#160;</td>\n          <td class=\"paramname\"><em>imageSize</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Find the filename of a .gnu_debug_link section. Return the filename of the debug link and an open file descriptor for it. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a3550baa3be6c6f98a4cd4b43c7a69e13\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetCurrentSysId\" ref=\"a3550baa3be6c6f98a4cd4b43c7a69e13\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALINLINE <a class=\"el\" href=\"group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e\">OS_THREAD_ID</a> LEVEL_PINCLIENT::GetCurrentSysId </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>The OS thread ID for the calling thread. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a5e21abe87547bf0b628e611f239f11e6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetCurrentSysIdById\" ref=\"a5e21abe87547bf0b628e611f239f11e6\" args=\"(THREADID tid)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e\">OS_THREAD_ID</a> LEVEL_PINCLIENT::GetCurrentSysIdById </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>tid</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Get the OS thread ID for the calling thread.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">tid</td><td>Pin ID for the calling thread.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>OS ID for the calling thread. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a7e114cbfb7f867187ad29a618a6fd0ec\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetEmulatedRegister\" ref=\"a7e114cbfb7f867187ad29a618a6fd0ec\" args=\"(unsigned, THREADID, CONTEXT *, VOID *)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::GetEmulatedRegister </td>\n          <td>(</td>\n          <td class=\"paramtype\">unsigned&#160;</td>\n          <td class=\"paramname\"><em>toolRegId</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">VOID *&#160;</td>\n          <td class=\"paramname\"><em>data</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call a client function to get the value of an emulated register.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">toolRegId</td><td>Tool's ID which identifies the emulated register. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">tid</td><td>The thread whose register is requested. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">ctxt</td><td>Architected register state for the thread. </td></tr>\n    <tr><td class=\"paramdir\">[out]</td><td class=\"paramname\">data</td><td>Receives the value of the register. </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ad64eb00b9187bdd65bf2f1ff694c4647\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetInTraceCallbacks\" ref=\"ad64eb00b9187bdd65bf2f1ff694c4647\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::GetInTraceCallbacks </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Get the value of inTraceCallbacks </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a27719fdb1dc48dc421e36c15fa2c2e53\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetOpenImg\" ref=\"a27719fdb1dc48dc421e36c15fa2c2e53\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">IMG LEVEL_PINCLIENT::GetOpenImg </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This function provides the IMG structure of the image opened by IMG_Open </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a584437695086199ec608222e1c98125c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetTargetDescription\" ref=\"a584437695086199ec608222e1c98125c\" args=\"(const std::string &amp;, USIZE, VOID *)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN USIZE LEVEL_PINCLIENT::GetTargetDescription </td>\n          <td>(</td>\n          <td class=\"paramtype\">const std::string &amp;&#160;</td>\n          <td class=\"paramname\"><em>name</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">USIZE&#160;</td>\n          <td class=\"paramname\"><em>size</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">VOID *&#160;</td>\n          <td class=\"paramname\"><em>buf</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call a client function to get a document that describes the target machine's registers.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">name</td><td>The name of the requested document. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">size</td><td>Size (bytes) of the <em>buf</em> buffer. </td></tr>\n    <tr><td class=\"paramdir\">[out]</td><td class=\"paramname\">buf</td><td>Points to a buffer that receives the content of the document.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>The size of the requested document or zero if the tool doesn't know this document. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a56c2d268d45b26ac3513437d45ae19ef\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::GetVmLock\" ref=\"a56c2d268d45b26ac3513437d45ae19ef\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::GetVmLock </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Get the vm lock.</p>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux, Windows &amp; OS X*<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a6796500f41701a58428c24ba32b2fa3d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImageInitialize\" ref=\"a6796500f41701a58428c24ba32b2fa3d\" args=\"(BOOL forReplay)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::ImageInitialize </td>\n          <td>(</td>\n          <td class=\"paramtype\">BOOL&#160;</td>\n          <td class=\"paramname\"><em>forReplay</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Initialize the image tracking code.</p>\n<ul>\n<li>Load the main image</li>\n<li>If we are attaching and the loader has initialized, scan the shared libraries</li>\n<li>If we are not attaching, find the loader and explicitly scan it </li>\n</ul>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a173100747aaaf9a7a5ea268ea03d689e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImageInitializeFirst\" ref=\"a173100747aaaf9a7a5ea268ea03d689e\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::ImageInitializeFirst </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Initialize images before Pin client started.</p>\n<ul>\n<li>Clear Pin client list of registered images.</li>\n<li>Enumerate and register all already loaded images.</li>\n<li>Call image load callback function for every registered image. Called by VM in _startProgram() </li>\n</ul>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a0599c5d25723d9156ba2c3b40ce916a8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImageInstrument\" ref=\"a0599c5d25723d9156ba2c3b40ce916a8\" args=\"(TRACE trace)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::ImageInstrument </td>\n          <td>(</td>\n          <td class=\"paramtype\">TRACE&#160;</td>\n          <td class=\"paramname\"><em>trace</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Called when each trace is instrumented to support code for tracking images.</p>\n<ul>\n<li>Instruments the shared library loader entry that is called every time an image is loaded The instrumentation will scan for shared libraries</li>\n<li>Captures the pointer to the LoaderInfo when ld-linux has initialized DT_DEBUG </li>\n</ul>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a6d3018f88c9d1070213adee2748711d8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ImageUnInitialize\" ref=\"a6d3018f88c9d1070213adee2748711d8\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::ImageUnInitialize </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Uninitialize the image tracking code. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aadd937a10996937e8601c196bbb22bde\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_CreateAt\" ref=\"aadd937a10996937e8601c196bbb22bde\" args=\"(const char *filename, ADDRINT start, USIZE size, ADDRINT loadOffset, BOOL mainExecutable)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">IMG LEVEL_PINCLIENT::IMG_CreateAt </td>\n          <td>(</td>\n          <td class=\"paramtype\">const char *&#160;</td>\n          <td class=\"paramname\"><em>filename</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>start</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">USIZE&#160;</td>\n          <td class=\"paramname\"><em>size</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>loadOffset</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">BOOL&#160;</td>\n          <td class=\"paramname\"><em>mainExecutable</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Returns a IMG object for image loaded outside of PIN's loader. Tool should use this IMG object to mark the routines inside it, using <a class=\"el\" href=\"group__RTN__BASIC__API.html#gaa6c9c5c444bffe61f7a37cb478517eff\">RTN_CreateAt()</a>. After all the routines are marked, tool should call <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a12b4fb22826ca2519efbaae1b473f065\">IMG_ReplayImageLoad()</a> to finalize the image load procedure.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">filename</td><td>name of the image visible to Pin tools </td></tr>\n    <tr><td class=\"paramname\">start</td><td>memory address where first byte of the image is loaded to </td></tr>\n    <tr><td class=\"paramname\">size</td><td>the size of the image in memory. This means that the image region in memory will be at [start .. start+size) </td></tr>\n    <tr><td class=\"paramname\">loadOffset</td><td>the offset between the memory addresses specified in the executable/library files and the memory addresses where this image was actaully loaded </td></tr>\n    <tr><td class=\"paramname\">mainImage</td><td>TRUE if this is the main image</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>IMG object that represents the image. Please make sure to call <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a12b4fb22826ca2519efbaae1b473f065\">IMG_ReplayImageLoad()</a> on the IMG object after you're done creating all the routines in the IMG object.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: All<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"abae8411a46a9d56cd275314f8c37d2c8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_ExecuteRecordedLoadOps\" ref=\"abae8411a46a9d56cd275314f8c37d2c8\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::IMG_ExecuteRecordedLoadOps </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Execute the list of recorded image load operations and clean the list as we go. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a636f5a30b095a80e421afd7b01a871c8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_FindBySectionsAddress\" ref=\"a636f5a30b095a80e421afd7b01a871c8\" args=\"(ADDRINT address)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">IMG LEVEL_PINCLIENT::IMG_FindBySectionsAddress </td>\n          <td>(</td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>address</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Find image by address. Given an address, it is considered belonging to an image only if the address equals to one of the following: the start address of the text segment, the start address of the data segment or the lowest address loaded by the image. </p>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>IMG object, valid or invalid</dd></dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br/>\n <b>O/S</b>: Linux, Windows &amp; MacOS<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ab55faf03bbd86c746ddd7bd04733c4e2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_FindByUnloadAddress\" ref=\"ab55faf03bbd86c746ddd7bd04733c4e2\" args=\"(ADDRINT startAddress)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">IMG LEVEL_PINCLIENT::IMG_FindByUnloadAddress </td>\n          <td>(</td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>startAddress</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Find image by the address which the loader uses when it frees the memory of an image. For Linux and OS X*, for each image, check if the address equals to the start address of the text segment. For Windows, for each image, check if the address equals to the start of the Image. This function should be used to determined if ProcessImageUnload should be called when unmapping an address.</p>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>IMG object, valid or invalid</dd></dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br/>\n <b>O/S</b>: Linux, Windows &amp; MacOS<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a6051e14b16661669c01ae646f7a96b75\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_FindDataSymbolAddress\" ref=\"a6051e14b16661669c01ae646f7a96b75\" args=\"(IMG origImg, const CHAR *symname)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">ADDRINT LEVEL_PINCLIENT::IMG_FindDataSymbolAddress </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>origImg</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const CHAR *&#160;</td>\n          <td class=\"paramname\"><em>symname</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Find the address of a data symbol in an image. Since that image doesn't have the symbol table in memory anymore (it was unmapped), we need to read the image into a temporary image. This is quite expensive so it is not recommended to expose it to the API or use it frequently. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ade7195737db5709d9d52e4820ded936e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_FindRtnByName\" ref=\"ade7195737db5709d9d52e4820ded936e\" args=\"(IMG img, const string &amp;name)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">RTN LEVEL_PINCLIENT::IMG_FindRtnByName </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const string &amp;&#160;</td>\n          <td class=\"paramname\"><em>name</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Find a particular routine by name in the given image </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a54299136511761dd2d608374b8f12df0\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_FreeDebugInfo\" ref=\"a54299136511761dd2d608374b8f12df0\" args=\"(IMG img)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::IMG_FreeDebugInfo </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Free debug info </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ad6b4454f38290f1668a10f0b1a8b45e9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_GetLoaderInfo\" ref=\"ad6b4454f38290f1668a10f0b1a8b45e9\" args=\"(IMG img)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID* LEVEL_PINCLIENT::IMG_GetLoaderInfo </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Gets a read-only copy of loader information for the image which is used in PIN ADX debugger.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">img</td><td>The image object to act on</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>Pointer to OS specific structure that holds data about loader information. On Linux, this is a pointer to struct LINUX_LOADER_IMAGE_INFO.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a0c5031ea2a7abe33d2687421ad35137b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_GetSubprogramsInfo\" ref=\"a0c5031ea2a7abe33d2687421ad35137b\" args=\"(IMG img, map&lt; ADDRINT, SymbolDebugInfo &gt; &amp;routines)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::IMG_GetSubprogramsInfo </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">map&lt; ADDRINT, SymbolDebugInfo &gt; &amp;&#160;</td>\n          <td class=\"paramname\"><em>routines</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Return subprograms debug info for an image. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ab8582ba61e6db66849f527b44559d836\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_IsStandardGccLibrary\" ref=\"ab8582ba61e6db66849f527b44559d836\" args=\"(IMG img)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::IMG_IsStandardGccLibrary </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Return TRUE if the specified image is libgcc library </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ae79710cbf7a04731f43365063bf807f4\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_IsStandardLoaderLibrary\" ref=\"ae79710cbf7a04731f43365063bf807f4\" args=\"(IMG img)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::IMG_IsStandardLoaderLibrary </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Return TRUE if the specified image is ld library </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a68bc9abe10e95a074674f1b1bdafe672\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_IsStandardSystemLibrary\" ref=\"a68bc9abe10e95a074674f1b1bdafe672\" args=\"(IMG img)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::IMG_IsStandardSystemLibrary </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Return TRUE if the specified image is libc library </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ac37eba6a29c7d594c11984f744052353\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_IsStandardThreadLibrary\" ref=\"ac37eba6a29c7d594c11984f744052353\" args=\"(IMG img)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::IMG_IsStandardThreadLibrary </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Return TRUE if the specified image is libpthread library </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a6f8fe5b67c1f6c020af0197c224b27c8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_RecordLoadOp\" ref=\"a6f8fe5b67c1f6c020af0197c224b27c8\" args=\"(const string &amp;imageName, const char *fileName, ADDRINT lo, UINT32 fl)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::IMG_RecordLoadOp </td>\n          <td>(</td>\n          <td class=\"paramtype\">const string &amp;&#160;</td>\n          <td class=\"paramname\"><em>imageName</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const char *&#160;</td>\n          <td class=\"paramname\"><em>fileName</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>lo</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">UINT32&#160;</td>\n          <td class=\"paramname\"><em>fl</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Remember an imge load operation so that we can execute it when PIN_StartProgram is called. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ad8e7dc716b74328e4678af5254dd61bc\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_RecordLoadOp\" ref=\"ad8e7dc716b74328e4678af5254dd61bc\" args=\"(IMG img)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::IMG_RecordLoadOp </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Remember an imge load operation so that we can execute it when PIN_StartProgram is called. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a83b7d0a3393009112f8aa269daf76bde\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_RemoveToolCallbacks\" ref=\"a83b7d0a3393009112f8aa269daf76bde\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::IMG_RemoveToolCallbacks </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Remove all image notification functions </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a12b4fb22826ca2519efbaae1b473f065\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_ReplayImageLoad\" ref=\"a12b4fb22826ca2519efbaae1b473f065\" args=\"(IMG img)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::IMG_ReplayImageLoad </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Replays the image load of an IMG object (created by <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#aadd937a10996937e8601c196bbb22bde\">IMG_CreateAt()</a>). This means that all the image load callbacks will be called for the specified IMG object. If <a class=\"el\" href=\"group__PIN__CONTROL.html#gaded401aeb030a76ee3396137b06ad808\">PIN_StartProgram()</a> wasn't called yet, PIN will enqueue this request and will process this request after <a class=\"el\" href=\"group__PIN__CONTROL.html#gaded401aeb030a76ee3396137b06ad808\">PIN_StartProgram()</a> was called</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">img</td><td>The image object to replay its load</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: All<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a2e19c3407381daae95c0b8c302e2eb7c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_SetLoaderInfo\" ref=\"a2e19c3407381daae95c0b8c302e2eb7c\" args=\"(IMG img, VOID *loaderInfo)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::IMG_SetLoaderInfo </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">VOID *&#160;</td>\n          <td class=\"paramname\"><em>loaderInfo</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Sets the loader information for the image which are used in PIN ADX debugger.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">img</td><td>The image object to act on </td></tr>\n    <tr><td class=\"paramname\">loaderInfo</td><td>Points to OS specific structure that holds data about loader information. On Linux, this is a pointer to struct LINUX_LOADER_IMAGE_INFO.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a70582d67b216e4d32c5eb57a96940f54\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IMG_UnmapImage\" ref=\"a70582d67b216e4d32c5eb57a96940f54\" args=\"(IMG img)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::IMG_UnmapImage </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Unmap file </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a6e89485f4d64a274f849636054a79e03\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InitDynamicCodeImage\" ref=\"a6e89485f4d64a274f849636054a79e03\" args=\"(IMG newImg)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::InitDynamicCodeImage </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>newImg</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Initialize an dynamic code image after it has been allocated. An dynamic code image contains dynamically created code, e.g. Jitted functions. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a594102de771efeea2fe096fb4a863841\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InitializeApp\" ref=\"a594102de771efeea2fe096fb4a863841\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::InitializeApp </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Initialize app for usage </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aba984baec4378aafe754751c02c7fa5f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InitializeClientTls\" ref=\"aba984baec4378aafe754751c02c7fa5f\" args=\"(THREADID threadIndex)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::InitializeClientTls </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>threadIndex</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Initialize client TLS in the current thread. </p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">threadIndex</td><td>ID of the current thread </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a9bb9b372e5702a51fb9bf390b1b08e7c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InitializeFollowChildClient\" ref=\"a9bb9b372e5702a51fb9bf390b1b08e7c\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::InitializeFollowChildClient </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Initialize follow-child callbacks </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a7869d6cf8708e35c81aec2ba8697e34d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_InsertCallProbed\" ref=\"a7869d6cf8708e35c81aec2ba8697e34d\" args=\"(INS orgIns, IPOINT action, AFUNPTR funPtr,...)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::INS_InsertCallProbed </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>orgIns</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a>&#160;</td>\n          <td class=\"paramname\"><em>action</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">AFUNPTR&#160;</td>\n          <td class=\"paramname\"><em>funPtr</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&#160;</td>\n          <td class=\"paramname\"><em>...</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This routine inserts a call before/after one instruction </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a113cc21664dc0b7431b23e7c0c072d56\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_IsNativeCall\" ref=\"a113cc21664dc0b7431b23e7c0c072d56\" args=\"(INS ins)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::INS_IsNativeCall </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>TRUE if a call instruction is marked to be executed natively. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a8a9254d5fb8ca4f675bf394b6b95b688\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_IsNativeXfer\" ref=\"a8a9254d5fb8ca4f675bf394b6b95b688\" args=\"(INS ins)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::INS_IsNativeXfer </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>TRUE if a control flow instruction has been setup to transfer control back to the native code on the taken path. This is the default mechanism. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aaf7404039cd1f80f9b11877cb9fe7514\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_IsPinXfer\" ref=\"aaf7404039cd1f80f9b11877cb9fe7514\" args=\"(INS ins)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::INS_IsPinXfer </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>TRUE if a control flow instruction has been setup to transfer control to trace generator upon the taken path. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ade23e9e0cbe9ef7a0eb0af6e92aab648\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_IsXlateCall\" ref=\"ade23e9e0cbe9ef7a0eb0af6e92aab648\" args=\"(INS ins)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::INS_IsXlateCall </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>TRUE if a call instruction is marked to be traslated to a push and a jump to the target to ensure transparency to the application as to where the call originated from. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a7fc556909765b5c53d83a4e43dce53b4\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_ReplaceSignatureProbed\" ref=\"a7fc556909765b5c53d83a4e43dce53b4\" args=\"(INS orgIns, AFUNPTR replacementFunptr,...)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::INS_ReplaceSignatureProbed </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>orgIns</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">AFUNPTR&#160;</td>\n          <td class=\"paramname\"><em>replacementFunptr</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&#160;</td>\n          <td class=\"paramname\"><em>...</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This routine replaces one instruction The caller checks whether the routine CFG allows this replacement. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ac59d3b948aae49f7e0ef78ab5fc1a0cb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_SetNativeCall\" ref=\"ac59d3b948aae49f7e0ef78ab5fc1a0cb\" args=\"(INS ins)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::INS_SetNativeCall </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>A call instruction is not translated into a PUSH and a JUMP. This implies that the application might realize that the call is being made from the trace in the code cache and thus any code that depends on the return address at the target site is no longer valid and thus results in program corruption. Doing this implies any instruction following the call in the trace is executed. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ae3a6085d1927a8f339a250ce48aa7e61\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_SetNativeXfer\" ref=\"ae3a6085d1927a8f339a250ce48aa7e61\" args=\"(INS ins)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::INS_SetNativeXfer </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Set a control flow instruction to transfer control back to the native code on the taken path. This is the default mechanism. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a0e46cb329ac1fda6ccc52e8c6be97760\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_SetPinXfer\" ref=\"a0e46cb329ac1fda6ccc52e8c6be97760\" args=\"(INS ins)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::INS_SetPinXfer </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Set a control flow instruction to transfer control back to the trace generator upon the taken path. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ab1605a8c9ecb9af1028a30a82ecba468\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_SetXlateCall\" ref=\"ab1605a8c9ecb9af1028a30a82ecba468\" args=\"(INS ins)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::INS_SetXlateCall </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>A call instruction is translated into a return address PUSH and a JMP to ensure that the application does not realize that the call occured in the code cache if it looked at the return address on the stack since we put the original application return address on the stack. This implies that when a return is executed at the call target the control returns to the original application. Any fallthrough instructions in the trace are not executed. Also see <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ac59d3b948aae49f7e0ef78ab5fc1a0cb\">INS_SetNativeCall</a> for otherwise. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a9dfb00c2773416c3f18b271ca4762c83\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::INS_skip_xlate_set\" ref=\"a9dfb00c2773416c3f18b271ca4762c83\" args=\"(INS ins, BOOL b)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::INS_skip_xlate_set </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">BOOL&#160;</td>\n          <td class=\"paramname\"><em>b</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>mark this instruction so it will not be translated by the VM. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aaff64400633bd73fd02b76cb7970155f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::InstFetcher\" ref=\"aaff64400633bd73fd02b76cb7970155f\" args=\"(void *copyBuf, const VOID *address, size_t maxSizeToCopy, EXCEPTION_INFO *pExceptInfo)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN size_t LEVEL_PINCLIENT::InstFetcher </td>\n          <td>(</td>\n          <td class=\"paramtype\">void *&#160;</td>\n          <td class=\"paramname\"><em>copyBuf</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const VOID *&#160;</td>\n          <td class=\"paramname\"><em>address</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">size_t&#160;</td>\n          <td class=\"paramname\"><em>maxSizeToCopy</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__EXCEPTION__API.html#ga95d87b1df51db38b0c1ed311a1fff5a5\">EXCEPTION_INFO</a> *&#160;</td>\n          <td class=\"paramname\"><em>pExceptInfo</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This is the function that is called to fetch instruction bytes from the tool's registered callback fetch function (if any).</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[out]</td><td class=\"paramname\">copyBuf</td><td>A buffer which receives the fetched instruction bytes. This buffer is at least size bytes long. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">address</td><td>Starting address from which instruction bytes should be fetched. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">maxSizeToCopy</td><td>The number of bytes that should be fetched. </td></tr>\n    <tr><td class=\"paramdir\">[out]</td><td class=\"paramname\">pExceptInfo</td><td>If less than <em>maxSizeToCopy</em> bytes are fetched, <em>pExceptInfo</em> receives an exception that describes why more bytes could not be fetched. If Pin needs more bytes to decode the next instruction, this exception will be delivered to the application.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>The number of bytes successfully fetched into <em>copyBuf</em>. This may be less than <em>maxSizeToCopy</em> (or even zero) if Pin attempts to fetch instructions from an invalid address. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a5f6603e4222111db606b2cbf67dea7fe\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IsPinLoaded\" ref=\"a5f6603e4222111db606b2cbf67dea7fe\" args=\"(const string &amp;name)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::IsPinLoaded </td>\n          <td>(</td>\n          <td class=\"paramtype\">const string &amp;&#160;</td>\n          <td class=\"paramname\"><em>name</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>x </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"adb79f43519a66afb7026cfea36c7cf82\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IsProcessExiting\" ref=\"adb79f43519a66afb7026cfea36c7cf82\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::IsProcessExiting </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Check to see if the current process is about to exit.</p>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>TRUE, if the current process is exiting.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: All<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ae1a0ec37fc6b360cb87f21ebf086f6a4\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::IsThreadInFiniCallback\" ref=\"ae1a0ec37fc6b360cb87f21ebf086f6a4\" args=\"(OS_THREAD_ID sysId)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::IsThreadInFiniCallback </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e\">OS_THREAD_ID</a>&#160;</td>\n          <td class=\"paramname\"><em>sysId</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Tells whether the given thread is currently executing a thread-fini callback.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">sysId</td><td>O/S ID for a thread.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>TRUE if the thread <em>sysId</em> is currently executing a thread-fini callback. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a597f1a848e384f3ea3682a72ff009bfa\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobAppendLogFile\" ref=\"a597f1a848e384f3ea3682a72ff009bfa\" args=\"(KNOB_MODE_WRITEONCE,&quot;supported&quot;,&quot;append_logfile&quot;,&quot;0&quot;,&quot;Append to the end of the log file if it already exists&quot;)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">KNOB&lt;BOOL&gt; LEVEL_PINCLIENT::KnobAppendLogFile </td>\n          <td>(</td>\n          <td class=\"paramtype\">KNOB_MODE_WRITEONCE&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;supported&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;append_logfile&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;0&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;Append to the end of the log file if it already exists&quot;&#160;</td>\n          <td class=\"paramname\">&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>New log messages should be appended to the end of the log file if it already exists. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a965db2da01b01a6f3f1b2b714cb9e68d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::KnobJitApi\" ref=\"a965db2da01b01a6f3f1b2b714cb9e68d\" args=\"(KNOB_MODE_WRITEONCE,&quot;pintool:sym&quot;,&quot;support_jit_api&quot;,&quot;0&quot;,&quot;Enables the Jitted Functions Support&quot;)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">KNOB&lt;BOOL&gt; LEVEL_PINCLIENT::KnobJitApi </td>\n          <td>(</td>\n          <td class=\"paramtype\">KNOB_MODE_WRITEONCE&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;pintool:sym&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;support_jit_api&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;0&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;Enables the Jitted Functions Support&quot;&#160;</td>\n          <td class=\"paramname\">&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This knob enables the Jitted Functions Support. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a330863d93ba1490c1e6095145abb0f22\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MessageTypeLogBuffer\" ref=\"a330863d93ba1490c1e6095145abb0f22\" args=\"(&quot;log_buffer&quot;,&quot;&quot;, false, false, false, true, LOGTYPE_LOGFILE,&quot;pin log: buffering&quot;)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">MESSAGE_TYPE LEVEL_PINCLIENT::MessageTypeLogBuffer </td>\n          <td>(</td>\n          <td class=\"paramtype\">&quot;log_buffer&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">true&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">LOGTYPE_LOGFILE&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;pin log: buffering&quot;&#160;</td>\n          <td class=\"paramname\">&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>messages associated with fast buffering API </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a6ff7cf915b4d32c6e4518de0c8ff1767\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MessageTypeLogFetchRtnIns\" ref=\"a6ff7cf915b4d32c6e4518de0c8ff1767\" args=\"(&quot;log_fetch_rtn_ins&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: fetch rtn ins information&quot;)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">MESSAGE_TYPE LEVEL_PINCLIENT::MessageTypeLogFetchRtnIns </td>\n          <td>(</td>\n          <td class=\"paramtype\">&quot;log_fetch_rtn_ins&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">LOGTYPE_LOGFILE&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;pin log: fetch rtn ins information&quot;&#160;</td>\n          <td class=\"paramname\">&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Fetch RTN INS log message </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ae3cf23142dd361a5388d198c8971e14e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MessageTypeLogImage\" ref=\"ae3cf23142dd361a5388d198c8971e14e\" args=\"(&quot;log_image&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: image API&quot;)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">MESSAGE_TYPE LEVEL_PINCLIENT::MessageTypeLogImage </td>\n          <td>(</td>\n          <td class=\"paramtype\">&quot;log_image&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">LOGTYPE_LOGFILE&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;pin log: image API&quot;&#160;</td>\n          <td class=\"paramname\">&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Logging for image api </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a5f739dea50f93f289f36b605e465a22a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MessageTypeLogProbe\" ref=\"a5f739dea50f93f289f36b605e465a22a\" args=\"(&quot;log_probe&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: probe information&quot;)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">MESSAGE_TYPE LEVEL_PINCLIENT::MessageTypeLogProbe </td>\n          <td>(</td>\n          <td class=\"paramtype\">&quot;log_probe&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">LOGTYPE_LOGFILE&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;pin log: probe information&quot;&#160;</td>\n          <td class=\"paramname\">&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Probe log message </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"af82bb0cef427898c7e7596a5351967d4\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MessageTypeLogSym\" ref=\"af82bb0cef427898c7e7596a5351967d4\" args=\"(&quot;log_sym&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: symbol API&quot;)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">MESSAGE_TYPE LEVEL_PINCLIENT::MessageTypeLogSym </td>\n          <td>(</td>\n          <td class=\"paramtype\">&quot;log_sym&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">LOGTYPE_LOGFILE&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;pin log: symbol API&quot;&#160;</td>\n          <td class=\"paramname\">&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Logging for symbols in image api </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ad8d0947f828dbfa7e225ceb85d12ed8a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MessageTypeLogUnwind\" ref=\"ad8d0947f828dbfa7e225ceb85d12ed8a\" args=\"(&quot;log_unwind&quot;,&quot;&quot;, false, false, false, false, LOGTYPE_LOGFILE,&quot;pin log: unwind&quot;)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">MESSAGE_TYPE LEVEL_PINCLIENT::MessageTypeLogUnwind </td>\n          <td>(</td>\n          <td class=\"paramtype\">&quot;log_unwind&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;&quot;&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">false&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">LOGTYPE_LOGFILE&#160;</td>\n          <td class=\"paramname\">, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&quot;pin log: unwind&quot;&#160;</td>\n          <td class=\"paramname\">&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>messages associated with PinProbes </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a231d65c3bf9fe87bc7aa830f8548ea45\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyDataRange\" ref=\"a231d65c3bf9fe87bc7aa830f8548ea45\" args=\"(CODE_RANGES *rangeMap, ADDRINT base, USIZE size)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::NotifyDataRange </td>\n          <td>(</td>\n          <td class=\"paramtype\">CODE_RANGES *&#160;</td>\n          <td class=\"paramname\"><em>rangeMap</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>base</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">USIZE&#160;</td>\n          <td class=\"paramname\"><em>size</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Update code range database to take into account the specified data range. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a6b14fbaff11247c8c8008d72e83997fd\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyDataRanges\" ref=\"a6b14fbaff11247c8c8008d72e83997fd\" args=\"(IMG img, CODE_RANGES *rangeMap)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::NotifyDataRanges </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">CODE_RANGES *&#160;</td>\n          <td class=\"paramname\"><em>rangeMap</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Update original map of code ranges in binary image taking into account known data ranges that may overlap with the original code ranges. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a397ff749e5f8ae8ba184138e9ca9c9bf\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyDebuggerOnImageLoad\" ref=\"a397ff749e5f8ae8ba184138e9ca9c9bf\" args=\"(BOOL isMain, VOID *loaderInfo)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::NotifyDebuggerOnImageLoad </td>\n          <td>(</td>\n          <td class=\"paramtype\">BOOL&#160;</td>\n          <td class=\"paramname\"><em>isMain</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">VOID *&#160;</td>\n          <td class=\"paramname\"><em>loaderInfo</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Notifies the debugger that new image had been loaded </p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">isMain</td><td>True is the image is the main executable </td></tr>\n    <tr><td class=\"paramname\">loaderInfo</td><td>Points to a LINUX_LOADER_IMAGE_INFO that holds image information for PINADX </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"aca76650323000be4b8c6f7c9466f8d5e\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyDebuggerOnImageUnload\" ref=\"aca76650323000be4b8c6f7c9466f8d5e\" args=\"(VOID *loaderInfo)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::NotifyDebuggerOnImageUnload </td>\n          <td>(</td>\n          <td class=\"paramtype\">VOID *&#160;</td>\n          <td class=\"paramname\"><em>loaderInfo</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Notifies the debugger that an image was unloaded </p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">loaderInfo</td><td>Points to a LINUX_LOADER_IMAGE_INFO that holds image information for PINADX </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"afa31ee9aebf2996a8bff0ad0ddabdc7c\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyDetachCompletedJitMode\" ref=\"afa31ee9aebf2996a8bff0ad0ddabdc7c\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::NotifyDetachCompletedJitMode </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Remove all client callbacks after detach </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a401b23264662f635d37ef4b093dabc23\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyOutOfMemory\" ref=\"a401b23264662f635d37ef4b093dabc23\" args=\"(size_t size)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::NotifyOutOfMemory </td>\n          <td>(</td>\n          <td class=\"paramtype\">size_t&#160;</td>\n          <td class=\"paramname\"><em>size</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Notify pin / pin tool is out of memory. Do minimal actions in here due to the subtle location (i.e. no memory)</p>\n<ul>\n<li>Don't serialize the callback</li>\n<li>Don't use any STL in here </li>\n</ul>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a4b81d1361174167557d948ea6eb1a7dc\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::NotifyPrepareForFini\" ref=\"a4b81d1361174167557d948ea6eb1a7dc\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::NotifyPrepareForFini </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Notify that Pin is about to detach from terminating process. The function that is registered by this callback may do the following:</p>\n<ul>\n<li>Force all the internal threads of the tool to finish using return from the main function of the thread or calling PIN_ExitThread.</li>\n<li>Wait until all the internal threads are finished before it will continue to run. </li>\n</ul>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ad4cd44dc0a1ca88938976161c979d026\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::Open_Rtn\" ref=\"ad4cd44dc0a1ca88938976161c979d026\" args=\"(RTN rtn)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::Open_Rtn </td>\n          <td>(</td>\n          <td class=\"paramtype\">RTN&#160;</td>\n          <td class=\"paramname\"><em>rtn</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Open the given RTN. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"afefe009e0072dbf80e266586a2ab9987\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_AddDebuggerRegisterEmulator\" ref=\"afefe009e0072dbf80e266586a2ab9987\" args=\"(unsigned numRegisters, const DEBUGGER_REG_DESCRIPTION *registerDescriptions, GET_EMULATED_REGISTER_CALLBACK getFun, SET_EMULATED_REGISTER_CALLBACK setFun, GET_TARGET_DESCRIPTION_CALLBACK getDescriptionFun, VOID *val)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::PIN_AddDebuggerRegisterEmulator </td>\n          <td>(</td>\n          <td class=\"paramtype\">unsigned&#160;</td>\n          <td class=\"paramname\"><em>numRegisters</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const <a class=\"el\" href=\"structDEBUGGER__REG__DESCRIPTION.html\">DEBUGGER_REG_DESCRIPTION</a> *&#160;</td>\n          <td class=\"paramname\"><em>registerDescriptions</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">GET_EMULATED_REGISTER_CALLBACK&#160;</td>\n          <td class=\"paramname\"><em>getFun</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">SET_EMULATED_REGISTER_CALLBACK&#160;</td>\n          <td class=\"paramname\"><em>setFun</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">GET_TARGET_DESCRIPTION_CALLBACK&#160;</td>\n          <td class=\"paramname\"><em>getDescriptionFun</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">VOID *&#160;</td>\n          <td class=\"paramname\"><em>val</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This API is useful for Pin tools that emulate registers that do not exist in the host machine's ISA. If an application debugger is attached to Pin, this API informs the debugger about the extended registers, allowing users to display and manipulate the emulated registers as though they were native registers. Of course, not all debuggers have this capability. Calling this API for such a non-conforming debugger is legal, but ineffective. A non-conforming debugger will ignore the emulated registers and just display the native ones.</p>\n<p>When using this API, the set of registers presented to the debugger is specified in two redundant ways, and it is the tool's responsibility to ensure that they are consistent. One specification is a text document that the debugger reads. This document can have any format that the tool and the debugger agree upon, and could convey information about the registers, how they should be displayed in the debugger, etc. The tool provides this document via the <em>getDescriptionFun</em> call-back. The second register specification is through the <em>registerDescriptions</em> parameter, which Pin uses when communicating the register values to the debugger.</p>\n<p>If this API is called, it must be called before calling <a class=\"el\" href=\"group__PIN__CONTROL.html#gaded401aeb030a76ee3396137b06ad808\">PIN_StartProgram()</a>. Also, a tool can install only one debugger register emulator, so a call to <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#afefe009e0072dbf80e266586a2ab9987\">PIN_AddDebuggerRegisterEmulator()</a> will overwrite any previous call.</p>\n<p>When used with GDB, this API is effective only for versions of GDB that support register extensions in the XML \"feature document\". This includes GDB versions 7.2 and later, as well as some distributions of earlier GDB versions.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">numRegisters</td><td>The number of entries in <em>registerDescriptions</em>. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">registerDescriptions</td><td>An array describing each register that the debugger will know about. This includes both native registers and emulated registers. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">getFun</td><td>Call-back function that Pin calls to get the value of an emulated register. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">setFun</td><td>Call-back function that Pin calls to set the value of an emulated register. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">getDescriptionFun</td><td>Call-back function that Pin calls to get the content of a text document that tells the debugger about the registers defined in <em>registerDescriptions</em>. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">val</td><td>Value passed to the call-back functions.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux, Windows<br/>\n <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a242a7c455a425daf7f88b593eda19e95\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_CallerOwnsClientMutex\" ref=\"a242a7c455a425daf7f88b593eda19e95\" args=\"(OS_THREAD_ID osid)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::PIN_CallerOwnsClientMutex </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e\">OS_THREAD_ID</a>&#160;</td>\n          <td class=\"paramname\"><em>osid</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Return TRUE if calling thread is the owner of the lock.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">osid</td><td>OS ID of calling thread.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br/>\n <b>O/S</b>: Linux, Windows &amp; OS X*<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a2853e9235fb6484c4048916f51c1f4dd\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_CallerOwnsClientMutex\" ref=\"a2853e9235fb6484c4048916f51c1f4dd\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::PIN_CallerOwnsClientMutex </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Return TRUE if calling thread is the owner of the lock.</p>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br/>\n <b>O/S</b>: Linux, Windows &amp; OS X*<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a22dc9c2b2d797118827d2680bdcc239a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_ClientFork\" ref=\"a22dc9c2b2d797118827d2680bdcc239a\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e\">OS_THREAD_ID</a> LEVEL_PINCLIENT::PIN_ClientFork </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Allow a Pintool to safely fork. Call the fork system call and notify the VM appropriately. </p>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>Parent: ID of the child, child: 0, INVALID_THREADID if fork failed</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux &amp; OS X*<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a10ae4e3b3638ebaedff562b6a68be3ad\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_InsertProbe\" ref=\"a10ae4e3b3638ebaedff562b6a68be3ad\" args=\"(ADDRINT src_addr, ADDRINT dst_addr)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::PIN_InsertProbe </td>\n          <td>(</td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>src_addr</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>dst_addr</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This is an internal Pin API. It is not supported for use in general tools. We reserve the right to change or remove this API at any time without advanced notice.</p>\n<p>This API must be used in conjunction with other internal APIs. Do not use this API.</p>\n<p>Inserts a probe at an address.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">src_addr</td><td>Address to insert the probe at </td></tr>\n    <tr><td class=\"paramname\">dst_addr</td><td>Target to where the probe should point to </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"adfb0406b9445f953a6caff6cd8570a19\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_InterceptDebuggingEvent\" ref=\"adfb0406b9445f953a6caff6cd8570a19\" args=\"(DEBUGGING_EVENT eventType, INTERCEPT_DEBUGGING_EVENT_CALLBACK fun, VOID *arg)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::PIN_InterceptDebuggingEvent </td>\n          <td>(</td>\n          <td class=\"paramtype\">DEBUGGING_EVENT&#160;</td>\n          <td class=\"paramname\"><em>eventType</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">INTERCEPT_DEBUGGING_EVENT_CALLBACK&#160;</td>\n          <td class=\"paramname\"><em>fun</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">VOID *&#160;</td>\n          <td class=\"paramname\"><em>arg</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Establish an interceptor function for debugging events that Pin sends to an external debugger. This API allows a tool to filter these events before they are visible to the debugger.</p>\n<p>A tool can set only one \"intercept\" function for a particular event, so a new function overwrites any previous one for the same event. To disable an interceptor, pass a NULL function pointer.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">eventType</td><td>Tells the type of events to intercept. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">fun</td><td>The tool's interceptor function, or NULL. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">val</td><td>Value to pass to the interceptor function.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux, Windows<br/>\n <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ac44f566bcb26066051a1f7c775670a0a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_RemoveFollowChildProcessFunctions\" ref=\"ac44f566bcb26066051a1f7c775670a0a\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::PIN_RemoveFollowChildProcessFunctions </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Remove all follow child notification functions </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a0616c43a557393a0f1b5120fc1025262\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_RemoveProbe\" ref=\"a0616c43a557393a0f1b5120fc1025262\" args=\"(ADDRINT address)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::PIN_RemoveProbe </td>\n          <td>(</td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>address</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This is an internal Pin API. It is not supported for use in general tools. We reserve the right to change or remove this API at any time without advanced notice.</p>\n<p>Remove a probe that was previously inserted at address</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">src_addr</td><td>Address at which a probe was previously inserted </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a98ae9555107bb81ab2499e3519e74525\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_ReplayContextChange\" ref=\"a98ae9555107bb81ab2499e3519e74525\" args=\"(THREADID tid, const CONTEXT *from, CONTEXT *to, CONTEXT_CHANGE_REASON reason, INT32 info)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::PIN_ReplayContextChange </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>from</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>to</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__CONTROL.html#ga8e4e6511a0e09fdc5ec7d6dbf395b3a8\">CONTEXT_CHANGE_REASON</a>&#160;</td>\n          <td class=\"paramname\"><em>reason</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">INT32&#160;</td>\n          <td class=\"paramname\"><em>info</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This API is intended for use by tools that replay the execution of an application and need to replay an asynchronous context change that was received by the application at record time. This API is not intended as a general way to send a forced context change (signal, exception, APC) to the application. To do that, see <a class=\"el\" href=\"group__EXCEPTION__API.html#ga656279818bb8972fbdac576b57854561\">PIN_RaiseException()</a>.</p>\n<p>Calling this API causes Pin to call back on the tool's context-changed notification function if one was set up with <a class=\"el\" href=\"group__PIN__CONTROL.html#ga786fd61c9be3c42a1a6deefc71dffadf\">PIN_AddContextChangeFunction()</a>. Thus, the tool is notified about the context change as though the application really received it. Calling this API may also notify an external debugger if one is attached to Pin via the -appdebug switch, which gives the debugger a chance to stop execution of the application when it receives the replayed context change. (Whether this happens depends on the CONTEXT_CHANGE_REASON, and the expected behavior of the debugger on different platforms).</p>\n<p><a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a98ae9555107bb81ab2499e3519e74525\">PIN_ReplayContextChange()</a> does not return to its caller. If the <em>to</em> parameter is not NULL, execution resumes at that context after it has been potentially modified by the tool's context-changed call-back. If <em>reason</em> is CONTEXT_CHANGE_REASON_FATALSIGNAL, Pin emulates a fatal signal and execution terminates gracefully after calling the tool's Fini functions.</p>\n<p>This API can be called from an analysis routine or a replacement routine, but not from a callback.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">tid</td><td>The ID of the calling thread. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">from</td><td>The register state prior to the context change (e.g. the register state at the point when the signal is received for CONTEXT_CHANGE_REASON_SIGNAL). </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">to</td><td>The register state immediately after the context change. This should be NULL for CONTEXT_CHANGE_REASON_FATALSIGNAL. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">reason</td><td>The type of the context change. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">info</td><td>Additional information, depending on <em>reason</em>. (Ignored for <em>reason</em> codes not listed below.) <ul>\n<li>CONTEXT_CHANGE_REASON_FATALSIGNAL: The Unix signal number. </li>\n<li>CONTEXT_CHANGE_REASON_SIGNAL: The Unix signal number. </li>\n<li>CONTEXT_CHANGE_REASON_EXCEPTION: The Windows exception code. </li>\n</ul>\n</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>This function does not return.</dd></dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux &amp; Windows<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ae6d4291b91c0f4cdf30e9f789ac9f6ab\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_ReplayImageLoad\" ref=\"ae6d4291b91c0f4cdf30e9f789ac9f6ab\" args=\"(const char *imageName, const char *fileName, ADDRINT loadOffset, REPLAY_IMAGE_TYPE imageType)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">IMG LEVEL_PINCLIENT::PIN_ReplayImageLoad </td>\n          <td>(</td>\n          <td class=\"paramtype\">const char *&#160;</td>\n          <td class=\"paramname\"><em>imageName</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const char *&#160;</td>\n          <td class=\"paramname\"><em>fileName</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>loadOffset</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">REPLAY_IMAGE_TYPE&#160;</td>\n          <td class=\"paramname\"><em>imageType</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Ask Pin to perform all the functions it would normally do when it detects that a new shared library has been loaded. This is intended for use in a replay system, where the replay tool has recorded library load operations, and now wants to replay them.</p>\n<p>The code calling this routine need <b>not</b> ensure that the loaded sections of the image have already been restored. Using this interface causes Pin to use its private copy of the image information to satisfy the IMG, SEC and RTN functions.</p>\n<p>This routine can be called <b>before</b> PIN_StartProgram to set up image load operations for images which were loaded before Pin took control of the program at record time (on Unix systems these are normally the main executable and the dynamic linker; on Windows more system libraries may be present). When called at this point the image load callbacks are remembered internally, and replayed when PIN_StartProgram is called. (This is the same time they would have been made at record time, and ensures that all relevant callbacks have been registered).</p>\n<p>PIN_ReplayImageLoad can also be called from analysis or callback routines, in which case the relevant callbacks are made immediately. If called from an analysis routine, the Pin client lock must be claimed before calling PIN_ReplayImageLoad (the Pin client lock is already held when in a callback routine, so there is no need to claim it again).</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">imageName</td><td>name of the image visible to Pin tools </td></tr>\n    <tr><td class=\"paramname\">fileName</td><td>name of the file from which the image is read </td></tr>\n    <tr><td class=\"paramname\">loadOffset</td><td>offset from the address at which the image is naturally loaded to the address at which it has been loaded </td></tr>\n    <tr><td class=\"paramname\">imageType</td><td>Type of the image to load</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>the image id of the loaded img, or IMG_INVALID() when called before PIN_StartProgram</dd></dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux (others to follow)<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a52379b3dd9e24ddeda2a8d828f89050a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_ReplayImageUnload\" ref=\"a52379b3dd9e24ddeda2a8d828f89050a\" args=\"(IMG img)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::PIN_ReplayImageUnload </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Ask Pin to perform all the functions it would normally do when it detects that a shared library has been unloaded. This is intended for use in a replay system, where the replay tool has recorded library unload operations, and now wants to replay them.</p>\n<p>Note that a replay system need not explicitly call this function to cause image unload callbacks at the end of process execution. Pin will generate those callbacks itself provided that images were created using the <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ae6d4291b91c0f4cdf30e9f789ac9f6ab\">PIN_ReplayImageLoad</a> call. However, this function is required to handle explicit image unloads (for instance those caused by <code>dlclose()</code> )</p>\n<p>PIN_ReplayImageUnload can be called from analysis or callback routines. If called from an analysis routine, the Pin client lock must be claimed before calling PIN_ReplayImageUnload (the Pin client lock is already held when in a callback routine, so there is no need to claim it again).</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">img</td><td>the IMG to be unloaded</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux (others to follow)<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"af2d0628d04cad7be70e60df70079bc94\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_ReplaySyscallEntry\" ref=\"af2d0628d04cad7be70e60df70079bc94\" args=\"(THREADID tid, CONTEXT *ctxt, SYSCALL_STANDARD std)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::PIN_ReplaySyscallEntry </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">SYSCALL_STANDARD&#160;</td>\n          <td class=\"paramname\"><em>std</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This API is intended for use by tools that replay the execution of an application and need to behave as if a system call has been made, calling all callbacks registered with PIN_AddSysCallEntry function. However, no system call is actually performed.</p>\n<p>This API can be called from an analysis routine or a replacement routine, but not from a call-back.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">tid</td><td>The ID of the thread in which the system call appears to execute. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">from</td><td>The register state at the point when the system call appears to execute. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">std</td><td>The calling standard of the system call.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux,Windows,BSD<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a45dda023dabf1443df8fd629a2557a8d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_ReplaySyscallExit\" ref=\"a45dda023dabf1443df8fd629a2557a8d\" args=\"(THREADID tid, CONTEXT *ctxt, SYSCALL_STANDARD std)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::PIN_ReplaySyscallExit </td>\n          <td>(</td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">SYSCALL_STANDARD&#160;</td>\n          <td class=\"paramname\"><em>std</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This API is intended for use by tools that replay the execution of an application and need to behave as if a system call has been made, calling all callbacks registered with PIN_AddSysCallExit function. However, no system call is actually performed.</p>\n<p>This API can be called from an analysis routine or a replacement routine, but not from a call-back.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">tid</td><td>The ID of the thread in which the system call appears to execute. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">from</td><td>The register state at the point after the system call has executed. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">std</td><td>The calling standard of the system call.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux,Windows,BSD<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a0b084c12668f64a8f5631ffe014bcfaf\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_SetReplayMode\" ref=\"a0b084c12668f64a8f5631ffe014bcfaf\" args=\"(UINT32 flags)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::PIN_SetReplayMode </td>\n          <td>(</td>\n          <td class=\"paramtype\">UINT32&#160;</td>\n          <td class=\"paramname\"><em>flags</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Tell Pin to execute different sets of operations in replay mode.</p>\n<p>The only flag currently supported is REPLAY_MODE_IMAGEOPS which disables Pin's normal detection of image load and unload events, which are expected to be replayed through the <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#ae6d4291b91c0f4cdf30e9f789ac9f6ab\">PIN_ReplayImageLoad</a> and <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a52379b3dd9e24ddeda2a8d828f89050a\">PIN_ReplayImageUnload</a> calls. It also avoids Pin loading information about the initial image given on the command line.</p>\n<p>Other flags may be added as required in the future.</p>\n<p>Must be called before <a class=\"el\" href=\"group__PIN__CONTROL.html#gaded401aeb030a76ee3396137b06ad808\">PIN_StartProgram</a></p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">flags</td><td>A mask created from the PIN_REPLAY_MODE_FLAGS enum describing the operations the replayer will take control of.</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux (others later)<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a878b8da6dfffd13a7cae68c3d6428792\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_SpawnApplicationThread\" ref=\"a878b8da6dfffd13a7cae68c3d6428792\" args=\"(const CONTEXT *ctxt)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::PIN_SpawnApplicationThread </td>\n          <td>(</td>\n          <td class=\"paramtype\">const <a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Start a new thread which will begin to execute with the register state from the context. At least the flags register in the context must be sensible (even if all of the thread's registers will be set in the thread start callback).</p>\n<p>This function requires the VM lock to operate, so will acquire and release it if it is not already held.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">ctxt</td><td>context for the new thread. </td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>TRUE if a new thread was sucessfully spawned, FALSE if not.</dd></dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API. </dd>\n<dd>\nThis function must be used on applications that are running with the (newer) NPTL version of pthread library. Running this function on an application that is running with the (older) LinuxThreads version of pthread can prevent PIN from shuting down the VM when the application exits.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux<br/>\n <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a5adbfb1ca2cd769ad1a2a93693f06eb8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_TryClientLock\" ref=\"a5adbfb1ca2cd769ad1a2a93693f06eb8\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::PIN_TryClientLock </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Atempts to acquire the client lock, but does not block the caller. </p>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>Returns TRUE if the lock is acquired, FALSE if not. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a378032ed84e6a188b5ac8553ddd42f56\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_UnloadAllImages\" ref=\"a378032ed84e6a188b5ac8553ddd42f56\" args=\"(BOOL copyBits)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::PIN_UnloadAllImages </td>\n          <td>(</td>\n          <td class=\"paramtype\">BOOL&#160;</td>\n          <td class=\"paramname\"><em>copyBits</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Destroy all image objects. Remove probes. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a8d243673a6238afe734e70be901c7af1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PIN_WasMemoryReservedInLoadTime\" ref=\"a8d243673a6238afe734e70be901c7af1\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::PIN_WasMemoryReservedInLoadTime </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Return TRUE if PIN was successfully reserved the neccessary memory at application load time (specified on the -reserve_memory knob), and was successfully restricted the memory from the loader (specified on the -restrict_memory knob). It is guaranteed this is the return value is FALSE then none the memory specified in the mentioned knobs was reserved/restricted</p>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>TRUE if all the memory was reserved/restricted</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"af387339f038e94df9fa404c7f0d97b35\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::PinClientState\" ref=\"af387339f038e94df9fa404c7f0d97b35\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">PIN_CLIENT_STATE&amp; LEVEL_PINCLIENT::PinClientState </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Return reference to the instance of the PIN_CLIENT_STATE singleton </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"abb6b7ba49de88820d087a2a43ab8bc53\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ProbeMayOverwriteBranchTarget\" ref=\"abb6b7ba49de88820d087a2a43ab8bc53\" args=\"(INS target_ins, UINT32 probe_size, BOOL *mayOverwriteUnidentifiedBranchTarget)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN BOOL LEVEL_PINCLIENT::ProbeMayOverwriteBranchTarget </td>\n          <td>(</td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>target_ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">UINT32&#160;</td>\n          <td class=\"paramname\"><em>probe_size</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">BOOL *&#160;</td>\n          <td class=\"paramname\"><em>mayOverwriteUnidentifiedBranchTarget</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This routine tests to see if the probe may overwrite the target of a branch/call </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a9dca1c25a1b23e9d43b7e27b7c56bf6a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ProcessImageLoad\" ref=\"a9dca1c25a1b23e9d43b7e27b7c56bf6a\" args=\"(const string &amp;filename, const CHAR *trueFilename, ADDRINT load_offset, UINT32 flags, void *loaderInfo, void *arg)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">IMG LEVEL_PINCLIENT::ProcessImageLoad </td>\n          <td>(</td>\n          <td class=\"paramtype\">const string &amp;&#160;</td>\n          <td class=\"paramname\"><em>filename</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const CHAR *&#160;</td>\n          <td class=\"paramname\"><em>trueFilename</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>load_offset</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">UINT32&#160;</td>\n          <td class=\"paramname\"><em>flags</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">void *&#160;</td>\n          <td class=\"paramname\"><em>loaderInfo</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">void *&#160;</td>\n          <td class=\"paramname\"><em>arg</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>When the application loads a new image, do some bookkeeping.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">filename</td><td>The filename seen by the user </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">trueFilename</td><td>The file actually read (or NULL if filename should be used)</td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">load_offset</td><td>The offset from the images linked address to its load address </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">flags</td><td>Flags for the new image (an | of values from IMAGE_LOAD_FLAGS enumeration)</td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">loaderInfo</td><td>Points to OS specific struct containing loader information about the image to be used for PINADX debugger.</td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">arg</td><td>Argument specific to the image type</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>New IMG object corresponding to the loaded image. IMG_INVALID() if load was unsuccessful. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a73a27a7179751469a966b7794a875a5b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ProcessImageLoad\" ref=\"a73a27a7179751469a966b7794a875a5b\" args=\"(const string &amp;filename, const CHAR *trueFilename, ADDRINT load_offset, UINT32 flags, void *arg)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">IMG LEVEL_PINCLIENT::ProcessImageLoad </td>\n          <td>(</td>\n          <td class=\"paramtype\">const string &amp;&#160;</td>\n          <td class=\"paramname\"><em>filename</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const CHAR *&#160;</td>\n          <td class=\"paramname\"><em>trueFilename</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>load_offset</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">UINT32&#160;</td>\n          <td class=\"paramname\"><em>flags</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">void *&#160;</td>\n          <td class=\"paramname\"><em>arg</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>When the application loads a new image, do some bookeeping.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">filename</td><td>The filename seen by the user </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">trueFilename</td><td>The file actually read (or NULL if filename should be used)</td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">load_offset</td><td>The offset from the images linked address to its load address </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">flags</td><td>Flags for the new image (an | of values from IMAGE_LOAD_FLAGS enumeration)</td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">arg</td><td>Argument specific to the image type</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>New IMG object corresponding to the loaded image. IMG_INVALID() if load was unsuccessful. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a99b914317dfaaaf652b87dc8dc5496eb\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ProcessImageUnload\" ref=\"a99b914317dfaaaf652b87dc8dc5496eb\" args=\"(IMG img, BOOL copyBits)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::ProcessImageUnload </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">BOOL&#160;</td>\n          <td class=\"paramname\"><em>copyBits</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Process image unload notification. </p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">img</td><td>unloaded image </td></tr>\n    <tr><td class=\"paramname\">copyBits</td><td>should pin restore original probed bits back to the image code </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a97b3b556deafad660b25d2cfa5961d09\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ProcessModuleUnload\" ref=\"a97b3b556deafad660b25d2cfa5961d09\" args=\"(ADDRINT base)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::ProcessModuleUnload </td>\n          <td>(</td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>base</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Process module unload.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">base</td><td>base address of the module </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a05f11ab955128ccc7dd936280c211da1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ReadElfHeader\" ref=\"a05f11ab955128ccc7dd936280c211da1\" args=\"(CHAR const *file, EHDR *ehdr)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::ReadElfHeader </td>\n          <td>(</td>\n          <td class=\"paramtype\">CHAR const *&#160;</td>\n          <td class=\"paramname\"><em>file</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">EHDR *&#160;</td>\n          <td class=\"paramname\"><em>ehdr</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Read the elf header of a binary </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a7bd7512514651e76d2cab0e86f897e03\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ReleaseVmLock\" ref=\"a7bd7512514651e76d2cab0e86f897e03\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::ReleaseVmLock </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Release the vm lock.</p>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux, Windows &amp; OS X*<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ac011223a420ad84e67025c76652d2234\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ResetOpenImg\" ref=\"ac011223a420ad84e67025c76652d2234\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::ResetOpenImg </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>x </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a2a2baa8394fbab603d57712dd827f14d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ResetOpenRtn\" ref=\"a2a2baa8394fbab603d57712dd827f14d\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::ResetOpenRtn </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>x </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a4c9a3bd423c80fbca9d581a47b943b29\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ResolveIFunc\" ref=\"a4c9a3bd423c80fbca9d581a47b943b29\" args=\"(ADDRINT resolver)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">ADDRINT LEVEL_PINCLIENT::ResolveIFunc </td>\n          <td>(</td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>resolver</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Resolve IFUNC address by calling its resolver.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">rtn</td><td>Handle of RTN object </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"afede320485ede702f65075f0428cadc4\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_CheckFixups\" ref=\"afede320485ede702f65075f0428cadc4\" args=\"(RTN rtn, INS target_ins, UINT32 probe_size)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::RTN_CheckFixups </td>\n          <td>(</td>\n          <td class=\"paramtype\">RTN&#160;</td>\n          <td class=\"paramname\"><em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>target_ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">UINT32&#160;</td>\n          <td class=\"paramname\"><em>probe_size</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Return TRUE if fixup bytes intercept replaced bytes of the rtn entry point probe.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">rtn</td><td>Handle of RTN object </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a00e3461bafde757b3234ef4a60cfd3e9\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_CheckRtnSizeForProbe\" ref=\"a00e3461bafde757b3234ef4a60cfd3e9\" args=\"(RTN rtn, INS target_ins, BOOL checkForPadding, UINT32 probe_size)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN BOOL LEVEL_PINCLIENT::RTN_CheckRtnSizeForProbe </td>\n          <td>(</td>\n          <td class=\"paramtype\">RTN&#160;</td>\n          <td class=\"paramname\"><em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">INS&#160;</td>\n          <td class=\"paramname\"><em>target_ins</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">BOOL&#160;</td>\n          <td class=\"paramname\"><em>checkForPadding</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">UINT32&#160;</td>\n          <td class=\"paramname\"><em>probe_size</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This routine tests the size of a function, starting at the probe target instruction, to ensure that a probe will not overflow its bounds. The function returns TRUE in case rtn size is not fit for probe. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a34300d01ab3b416b0f310038785d55fc\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_CreateJitFunction\" ref=\"a34300d01ab3b416b0f310038785d55fc\" args=\"(IMG img, ADDRINT address, const string &amp;name, USIZE size)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">RTN LEVEL_PINCLIENT::RTN_CreateJitFunction </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>address</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const string &amp;&#160;</td>\n          <td class=\"paramname\"><em>name</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">USIZE&#160;</td>\n          <td class=\"paramname\"><em>size</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Create a Jitted function at the given address.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">address</td><td>The start address of the new routine </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">name</td><td>The assigned name of the new routine</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>RTN object The new created routine object.</dd></dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>Close any open routine before calling this interface with <a class=\"el\" href=\"group__RTN__BASIC__API.html#ga37272253377eb65c9eb5ff47ec4f1e6b\">RTN_Close()</a>.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: All<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a22a3dc3f37c8807e398207ae3c9ae18f\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_Destroy\" ref=\"a22a3dc3f37c8807e398207ae3c9ae18f\" args=\"(RTN rtn)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::RTN_Destroy </td>\n          <td>(</td>\n          <td class=\"paramtype\">RTN&#160;</td>\n          <td class=\"paramname\"><em>rtn</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>an rtn No RTN can be open when destroying an RTN </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ae4d47dafafa0234f556207c029cec943\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_DestroyJitFunction\" ref=\"ae4d47dafafa0234f556207c029cec943\" args=\"(ADDRINT address)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::RTN_DestroyJitFunction </td>\n          <td>(</td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>address</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Destroy a Jitted function object at the given address.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">address</td><td>The start address of the routine to destroy</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>Close any open routine before calling this interface with <a class=\"el\" href=\"group__RTN__BASIC__API.html#ga37272253377eb65c9eb5ff47ec4f1e6b\">RTN_Close()</a>.</dd></dl>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br/>\n <b>O/S</b>: Linux, Windows &amp; MacOS<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ab443407913cc8da0d33f50b2e83a8cb2\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_InsertCallProbedImpl\" ref=\"ab443407913cc8da0d33f50b2e83a8cb2\" args=\"(RTN rtn, IPOINT action, AFUNPTR funptr, PROBE_MODE mode, va_list argList)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::RTN_InsertCallProbedImpl </td>\n          <td>(</td>\n          <td class=\"paramtype\">RTN&#160;</td>\n          <td class=\"paramname\"><em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a>&#160;</td>\n          <td class=\"paramname\"><em>action</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">AFUNPTR&#160;</td>\n          <td class=\"paramname\"><em>funptr</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">PROBE_MODE&#160;</td>\n          <td class=\"paramname\"><em>mode</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">va_list&#160;</td>\n          <td class=\"paramname\"><em>argList</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Insert a probe at a routine enty</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">orgRtn</td><td>The application routine to instrument </td></tr>\n    <tr><td class=\"paramname\">action</td><td>Use IPOINT_BEFORE or IPOINT_AFTER to call funptr before or after execution. </td></tr>\n    <tr><td class=\"paramname\">funptr</td><td>The analysis function </td></tr>\n    <tr><td class=\"paramname\">mode</td><td>The probe mode (PROBE_MODE_DEFAULT /PROBE_MODE_ALLOW_RELOCATION) </td></tr>\n    <tr><td class=\"paramname\">argList</td><td>a signature of \"replacement\" specified as a variable list of arguments </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a7e992d7d2ee72a2c9f0d718c74f7f76a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_InsertFillBuffer\" ref=\"a7e992d7d2ee72a2c9f0d718c74f7f76a\" args=\"(RTN rtn, IPOINT action, BUFFER_ID id,...)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::RTN_InsertFillBuffer </td>\n          <td>(</td>\n          <td class=\"paramtype\">RTN&#160;</td>\n          <td class=\"paramname\"><em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7\">IPOINT</a>&#160;</td>\n          <td class=\"paramname\"><em>action</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">BUFFER_ID&#160;</td>\n          <td class=\"paramname\"><em>id</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">&#160;</td>\n          <td class=\"paramname\"><em>...</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Insert analysis code to fill one record in a trace buffer, relative to a RTN.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">rtn</td><td>The application RTN </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">action</td><td>Whether the record is filled before or after the RTN </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">id</td><td>The ID of the bufer whose record is filled </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">...</td><td><a class=\"el\" href=\"group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d\">IARG_TYPE</a>. Additional arguments to specify the fields of the trace buffer.</td></tr>\n  </table>\n  </dd>\n</dl>\n<p>Certain IARG_TYPEs cannot be used with the *_InsertFillBuffer APIs. The unsupported IARG_TYPEs are: IARG_CONTEXT, IARG_REG_REFERENCE, and IARG_REG_CONST_REFERENCE.</p>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>\n <b>O/S</b>: Linux &amp; Windows<br/>\n <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a95268c597d6a7374f0fb025b5ea1f6cd\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_InsertProbe\" ref=\"a95268c597d6a7374f0fb025b5ea1f6cd\" args=\"(RTN rtn, AFUNPTR replacement, PROBE_MODE mode)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">AFUNPTR LEVEL_PINCLIENT::RTN_InsertProbe </td>\n          <td>(</td>\n          <td class=\"paramtype\">RTN&#160;</td>\n          <td class=\"paramname\"><em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">AFUNPTR&#160;</td>\n          <td class=\"paramname\"><em>replacement</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">PROBE_MODE&#160;</td>\n          <td class=\"paramname\"><em>mode</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This is an internal Pin API. It is not supported for use in general tools. We reserve the right to change or remove this API at any time without advanced notice.</p>\n<p>This API must be used in conjunction with other internal APIs. Do not use this API.</p>\n<p>Install a probe at the entry point of a routine</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">rtn</td><td>routine to be probed </td></tr>\n    <tr><td class=\"paramname\">probe</td><td>routine to call at the probe point </td></tr>\n    <tr><td class=\"paramname\">mode</td><td>- specifies whether the routine can be relocated if probe insertion is impossible due to small first bb </td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>function pointer that to be called to execute the original unprobed routine</dd></dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ac5f5e2c7eb0d86fb1147d299bbaf1cda\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::RTN_OpenAndFetch\" ref=\"ac5f5e2c7eb0d86fb1147d299bbaf1cda\" args=\"(RTN rtn)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::RTN_OpenAndFetch </td>\n          <td>(</td>\n          <td class=\"paramtype\">RTN&#160;</td>\n          <td class=\"paramname\"><em>rtn</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Open the given rtn and fetch all the instructions</p>\n<dl class=\"user\"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br/>\n <b>O/S</b>: Linux, Windows &amp; MacOS<br/>\n <b>CPU:</b> All<br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a0e36dab2a480daa8b416f76b6df377ff\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ScanLibraries\" ref=\"a0e36dab2a480daa8b416f76b6df377ff\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::ScanLibraries </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Search for DLLs that Pin hasn't yet seen. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a09a3f51b12ef413c052ae8711d6f1149\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ScanLibrariesLocked\" ref=\"a09a3f51b12ef413c052ae8711d6f1149\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::ScanLibrariesLocked </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Take VM lock and client lock before scan.</p>\n<p>In the probe mode we also take VmLock because in attach mode one thread may be still in Vm and another thread may be in dlopen process. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a75e177e0b75ff6e0745f0cdec0e5651a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ScanLibrariesUnlocked\" ref=\"a75e177e0b75ff6e0745f0cdec0e5651a\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::ScanLibrariesUnlocked </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>All necessary locks are already taken (the function's name is misleading). Search for DLLs that Pin hasn't yet seen. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a11140bb045d91fe035c4929dcc25ea5a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SetEmulatedRegister\" ref=\"a11140bb045d91fe035c4929dcc25ea5a\" args=\"(unsigned, THREADID, CONTEXT *, const VOID *)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::SetEmulatedRegister </td>\n          <td>(</td>\n          <td class=\"paramtype\">unsigned&#160;</td>\n          <td class=\"paramname\"><em>toolRegId</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3\">THREADID</a>&#160;</td>\n          <td class=\"paramname\"><em>tid</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\"><a class=\"el\" href=\"group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676\">CONTEXT</a> *&#160;</td>\n          <td class=\"paramname\"><em>ctxt</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">const VOID *&#160;</td>\n          <td class=\"paramname\"><em>data</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Call a client function to set the value of an emulated register.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">toolRegId</td><td>Tool's ID which identifies the emulated register. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">tid</td><td>The thread whose register is requested. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">ctxt</td><td>Architected register state for the thread. </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">data</td><td>Buffer with the value of the register. </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a2237ed51b22e4d29cdcd02d7c6b05ea8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::Shutdown\" ref=\"a2237ed51b22e4d29cdcd02d7c6b05ea8\" args=\"(INT32 exitCode)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN VOID LEVEL_PINCLIENT::Shutdown </td>\n          <td>(</td>\n          <td class=\"paramtype\">INT32&#160;</td>\n          <td class=\"paramname\"><em>exitCode</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Shutdown the client when the application is about to terminate. </p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">exitCode</td><td>OS specific termination code for the application. </td></tr>\n  </table>\n  </dd>\n</dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ad5a0a2ae6adab89ea1f155d4136588ef\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYM_IsDataMarker\" ref=\"ad5a0a2ae6adab89ea1f155d4136588ef\" args=\"(SYM sym)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::SYM_IsDataMarker </td>\n          <td>(</td>\n          <td class=\"paramtype\">SYM&#160;</td>\n          <td class=\"paramname\"><em>sym</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>xxx </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a264d769aeff8fcaad10dec15db64a079\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::SYM_UndecorateName\" ref=\"a264d769aeff8fcaad10dec15db64a079\" args=\"(const string &amp;symbolName, UNDECORATION style)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">string LEVEL_PINCLIENT::SYM_UndecorateName </td>\n          <td>(</td>\n          <td class=\"paramtype\">const string &amp;&#160;</td>\n          <td class=\"paramname\"><em>symbolName</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">UNDECORATION&#160;</td>\n          <td class=\"paramname\"><em>style</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Undecorate symbol name. <br/>\n Provides undecoration of C++ names and decorated C names. The behavior of this function <br/>\n is compiler and OS specific. <br/>\n</p>\n<p>C++ decorated name is undecorated either to full signature (UNDECORATION_COMPLETE style) <br/>\n or to [scope::]name form (UNDECORATION_NAME_ONLY style). <br/>\n</p>\n<p>Example of undecoration of symbol generated by GCC compiler on Linux:<br/>\n</p>\n<div class=\"fragment\"><pre class=\"fragment\">  Style                   Original name                      Undecorated name\n  =====================   ==================                 ======================================\n  <a class=\"code\" href=\"group__SYM__BASIC__API.html#gga2b7e9b0b1d3e5d38135695bdb1b380fea97005f7701a8e2ce6a060b31f7fb3287\" title=\"Undecorate to full symbol signature.\">UNDECORATION_COMPLETE</a>   _ZN1A7method1ERKSt6vectorIiSaIiEE  A::method1(std::vector&lt;<span class=\"keywordtype\">int</span>, std::allocator&lt;int&gt; &gt; <span class=\"keyword\">const</span>&amp;)\n  <a class=\"code\" href=\"group__SYM__BASIC__API.html#gga2b7e9b0b1d3e5d38135695bdb1b380fea22890064021b2aa1f9f2754d181b7073\" title=\"Undecorate to [scope::]name.\">UNDECORATION_NAME_ONLY</a>                                     A::method1\n</pre></div><dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">symbolName</td><td>Decorated name <br/>\n </td></tr>\n    <tr><td class=\"paramdir\">[in]</td><td class=\"paramname\">style</td><td>Undecoration style, relevant only to C++ undecoration <br/>\n Values: <br/>\n UNDECORATION_COMPLETE undecorate to full signature <br/>\n UNDECORATION_NAME_ONLY undecorate to [scope::]name <br/>\n</td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>string containing undecorated symbol name. <br/>\n If undecoration fails or is not supported, the function returns the unmodified original name. <br/>\n </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"affb5a0ee4b3aaff697b0cfffbcd36c82\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ToolUseImageAPI\" ref=\"affb5a0ee4b3aaff697b0cfffbcd36c82\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BOOL LEVEL_PINCLIENT::ToolUseImageAPI </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Return TRUE if the Pintool uses any image API support. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a45df0793879feb51088aac93a00ab445\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_AddBranchEdg\" ref=\"a45df0793879feb51088aac93a00ab445\" args=\"(TRACE trace)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BBL LEVEL_PINCLIENT::TRACE_AddBranchEdg </td>\n          <td>(</td>\n          <td class=\"paramtype\">TRACE&#160;</td>\n          <td class=\"paramname\"><em>trace</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>If the last instruction of the trace is a direct branch then add the target path bbl as the fallthrough path into the trace. <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a05c7f6a42280e66aa8d7e52637268d3b\">TRACE_StraightenControlFlow</a> must be invoked prior to compiling the trace to ensure that the branches are invereted.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">trace</td><td>Trace to add the new basic block to </td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>bbl A handle to the newly added basic block </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ad2a16414294c509cc41912bc341f8317\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_AddFallthroughEdg\" ref=\"ad2a16414294c509cc41912bc341f8317\" args=\"(TRACE trace)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BBL LEVEL_PINCLIENT::TRACE_AddFallthroughEdg </td>\n          <td>(</td>\n          <td class=\"paramtype\">TRACE&#160;</td>\n          <td class=\"paramname\"><em>trace</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Add the fallthrough path bbl of the current last instruction in the trace to the end of the trace.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">trace</td><td>Trace to add the new basic block to </td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>bbl A handle to the newly added basic block </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a8af18c7c1f7c32d14d9a38d60556c2f5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_AddInlineCallEdg\" ref=\"a8af18c7c1f7c32d14d9a38d60556c2f5\" args=\"(TRACE trace)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BBL LEVEL_PINCLIENT::TRACE_AddInlineCallEdg </td>\n          <td>(</td>\n          <td class=\"paramtype\">TRACE&#160;</td>\n          <td class=\"paramname\"><em>trace</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>If the last instruction of the trace is a direct call then inline the call target into the trace.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">trace</td><td>Trace to add the new basic block to </td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>bbl A handle to the newly added basic block </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a60639d7058702b7bc9b83388e2ed2cce\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_AddInlineReturnEdg\" ref=\"a60639d7058702b7bc9b83388e2ed2cce\" args=\"(TRACE trace)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">BBL LEVEL_PINCLIENT::TRACE_AddInlineReturnEdg </td>\n          <td>(</td>\n          <td class=\"paramtype\">TRACE&#160;</td>\n          <td class=\"paramname\"><em>trace</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Inline the return path of a call that has been previously inlined in this trace using <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a8af18c7c1f7c32d14d9a38d60556c2f5\">TRACE_AddInlineCallEdg</a>. This requires that the tail instruction of the trace is a return instruction.</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">trace</td><td>Trace to add the new basic block to </td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>bbl A handle to the newly added basic block </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ab066724c31a244041d5850216840fc52\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_Allocate\" ref=\"ab066724c31a244041d5850216840fc52\" args=\"(ADDRINT addr)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> LEVEL_PINCLIENT::TRACE_Allocate </td>\n          <td>(</td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>addr</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Create a new trace. The trace is initialized with a bbl starting at the requested address</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">addr</td><td>The address from where to fetch the initialization bbl </td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>TRACE A handle to a trace initialized with a bbl begining at address</dd></dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"adccb4c741e7b559636ed11944109c278\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_AllocateForProbe\" ref=\"adccb4c741e7b559636ed11944109c278\" args=\"(PROBE_TYPE probeType, ADDRINT addr, RTN rtn, USIZE probeSize, BOOL mustReadAtLeastProbesizeBytes)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\"><a class=\"el\" href=\"group__TRACE__BASIC__API.html#gaf9f3009a146688d5230a16f8d3e575be\">TRACE</a> LEVEL_PINCLIENT::TRACE_AllocateForProbe </td>\n          <td>(</td>\n          <td class=\"paramtype\">PROBE_TYPE&#160;</td>\n          <td class=\"paramname\"><em>probeType</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>addr</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">RTN&#160;</td>\n          <td class=\"paramname\"><em>rtn</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">USIZE&#160;</td>\n          <td class=\"paramname\"><em>probeSize</em>, </td>\n        </tr>\n        <tr>\n          <td class=\"paramkey\"></td>\n          <td></td>\n          <td class=\"paramtype\">BOOL&#160;</td>\n          <td class=\"paramname\"><em>mustReadAtLeastProbesizeBytes</em>&#160;</td>\n        </tr>\n        <tr>\n          <td></td>\n          <td>)</td>\n          <td></td><td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Like TRACE_Allocate, but only fetch enough instructions to cover a probe</p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">probeType</td><td>See PROBE_TYPE </td></tr>\n    <tr><td class=\"paramname\">addr</td><td>The address from where to fetch the initialization bbl </td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>TRACE A handle to a trace initialized with a bbl begining at address</dd></dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a13e6a00c19122a0c2369540fb6d84ba6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_CodeRtn\" ref=\"a13e6a00c19122a0c2369540fb6d84ba6\" args=\"(TRACE trace)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">RTN LEVEL_PINCLIENT::TRACE_CodeRtn </td>\n          <td>(</td>\n          <td class=\"paramtype\">TRACE&#160;</td>\n          <td class=\"paramname\"><em>trace</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>x </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ac729f22ec7341faf38d82a9e0ba73db6\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_Deallocate\" ref=\"ac729f22ec7341faf38d82a9e0ba73db6\" args=\"(TRACE trace)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::TRACE_Deallocate </td>\n          <td>(</td>\n          <td class=\"paramtype\">TRACE&#160;</td>\n          <td class=\"paramname\"><em>trace</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Deallocate a prev. allocated trace.</p>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a29b1cc638bb5ccc9fa63185386b74f5b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_ExitsXferToNative\" ref=\"a29b1cc638bb5ccc9fa63185386b74f5b\" args=\"(TRACE trace)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::TRACE_ExitsXferToNative </td>\n          <td>(</td>\n          <td class=\"paramtype\">TRACE&#160;</td>\n          <td class=\"paramname\"><em>trace</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>All exits from this trace go back to original code </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a18ec62f2e936ef49a1700c8b17e6ce81\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_GenerateCode\" ref=\"a18ec62f2e936ef49a1700c8b17e6ce81\" args=\"(TRACE trace)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">ADDRINT LEVEL_PINCLIENT::TRACE_GenerateCode </td>\n          <td>(</td>\n          <td class=\"paramtype\">TRACE&#160;</td>\n          <td class=\"paramname\"><em>trace</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Compile and put trace in the code cache.</p>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>Address where the trace has been placed </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"ae3e15336d0231e3c06f7622b54466685\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_Oaddr\" ref=\"ae3e15336d0231e3c06f7622b54466685\" args=\"(TRACE trace)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN ADDRINT LEVEL_PINCLIENT::TRACE_Oaddr </td>\n          <td>(</td>\n          <td class=\"paramtype\">TRACE&#160;</td>\n          <td class=\"paramname\"><em>trace</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>This routine determines the starting code cache address of a trace (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) </p>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>Code Cache Address </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a9c3568e4ff3275f8869bf6f1c31fab92\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_RelocateOriginalInsAddr\" ref=\"a9c3568e4ff3275f8869bf6f1c31fab92\" args=\"(ADDRINT addr)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">ADDRINT LEVEL_PINCLIENT::TRACE_RelocateOriginalInsAddr </td>\n          <td>(</td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>addr</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Create a trace from a specified address, Transfer all exits to native generated a code, put in in code cache and return an address </p>\n<dl><dt><b>Parameters:</b></dt><dd>\n  <table class=\"params\">\n    <tr><td class=\"paramname\">addr</td><td>- trace entry address </td></tr>\n  </table>\n  </dd>\n</dl>\n<dl class=\"return\"><dt><b>Returns:</b></dt><dd>address of the generated code in code cache</dd></dl>\n<dl class=\"note\"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API. </dd></dl>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a05c7f6a42280e66aa8d7e52637268d3b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TRACE_StraightenControlFlow\" ref=\"a05c7f6a42280e66aa8d7e52637268d3b\" args=\"(TRACE trace)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::TRACE_StraightenControlFlow </td>\n          <td>(</td>\n          <td class=\"paramtype\">TRACE&#160;</td>\n          <td class=\"paramname\"><em>trace</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Build the control flow for the trace just generated; allows the traversing of the instructions inserted into the trace. This must be called prior to looking at a trace that has applied <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a8af18c7c1f7c32d14d9a38d60556c2f5\">TRACE_AddInlineCallEdg</a> or <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a60639d7058702b7bc9b83388e2ed2cce\">TRACE_AddInlineReturnEdg</a> functions for the adding of basic blocks to the trace. Upon invoking this function, the trace's control flow is fixed up to look as it would in the memory afer compilation. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a1b2ed34f406f5224a3cc97d79bad3fd8\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::TraceFirstIns\" ref=\"a1b2ed34f406f5224a3cc97d79bad3fd8\" args=\"(ADDRINT currTraceAddr)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">INS LEVEL_PINCLIENT::TraceFirstIns </td>\n          <td>(</td>\n          <td class=\"paramtype\">ADDRINT&#160;</td>\n          <td class=\"paramname\"><em>currTraceAddr</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Returns the first instruction in the given trace. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a1bcddc1b9f7d528b4fa332bb663de28d\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::UnInitializeApp\" ref=\"a1bcddc1b9f7d528b4fa332bb663de28d\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::UnInitializeApp </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Uninitialize app </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a43a58c48d2d39493be740bbe37f60f93\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::updateHasLinesData\" ref=\"a43a58c48d2d39493be740bbe37f60f93\" args=\"(IMG img)\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::updateHasLinesData </td>\n          <td>(</td>\n          <td class=\"paramtype\">IMG&#160;</td>\n          <td class=\"paramname\"><em>img</em></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Update HasLinesData's img attribute. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a03224476813833bcf3d474649ef31bf5\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::VdsoAddress\" ref=\"a03224476813833bcf3d474649ef31bf5\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALFUN ADDRINT LEVEL_PINCLIENT::VdsoAddress </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Return VDSO image base address </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a7aa1ce4877e9a29e504fdf1afd092a14\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::VmFunctionNotInitialized\" ref=\"a7aa1ce4877e9a29e504fdf1afd092a14\" args=\"()\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">VOID LEVEL_PINCLIENT::VmFunctionNotInitialized </td>\n          <td>(</td>\n          <td class=\"paramname\"></td><td>)</td>\n          <td></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>If the pintool is executed without a vm, then some of the function pointers in ClientIntData will not be defined. Rather than jump to 0 and segv, we print a message. </p>\n\n</div>\n</div>\n<hr/><h2>Variable Documentation</h2>\n<a class=\"anchor\" id=\"a54e0dc2e438a1924e754695ecf0140e4\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::CLIENT_TLS_KEY_ALLOCATOR\" ref=\"a54e0dc2e438a1924e754695ecf0140e4\" args=\"\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALTYPE typedef TLS_KEY_ALLOCATOR&lt;TLS_KEY_CLIENT_FIRST, TLS_KEY_CLIENT_LAST&gt; <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a54e0dc2e438a1924e754695ecf0140e4\">LEVEL_PINCLIENT::CLIENT_TLS_KEY_ALLOCATOR</a></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Allocator of TLS keys in client TLS. </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a01f2cffd10d802e5131696e06125c54a\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::ClientIntData\" ref=\"a01f2cffd10d802e5131696e06125c54a\" args=\"\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALVAR PINCLIENTINT LEVEL_PINCLIENT::ClientIntData</td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<b>Initial value:</b><div class=\"fragment\"><pre class=\"fragment\">\n    {\n    \n    \n    (UINT32)PINCLIENTINT::MAGIC,\n    InitializeCallBacks\n}\n</pre></div>\n</div>\n</div>\n<a class=\"anchor\" id=\"a28715588ef8741d97df6b914ea713e0b\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::MAX_IEH_CALLBACKS\" ref=\"a28715588ef8741d97df6b914ea713e0b\" args=\"\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">GLOBALCONST UINT32 <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a28715588ef8741d97df6b914ea713e0b\">LEVEL_PINCLIENT::MAX_IEH_CALLBACKS</a> = 32</td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Maximum number of internal exception handling callbacks </p>\n\n</div>\n</div>\n<a class=\"anchor\" id=\"a6cd19d87592e2fa8b69b59c8c12e54a1\"></a><!-- doxytag: member=\"LEVEL_PINCLIENT::pClientTlsKeyAllocator\" ref=\"a6cd19d87592e2fa8b69b59c8c12e54a1\" args=\"\" -->\n<div class=\"memitem\">\n<div class=\"memproto\">\n      <table class=\"memname\">\n        <tr>\n          <td class=\"memname\">LOCALVAR <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a54e0dc2e438a1924e754695ecf0140e4\">CLIENT_TLS_KEY_ALLOCATOR</a>* <a class=\"el\" href=\"namespaceLEVEL__PINCLIENT.html#a6cd19d87592e2fa8b69b59c8c12e54a1\">LEVEL_PINCLIENT::pClientTlsKeyAllocator</a></td>\n        </tr>\n      </table>\n</div>\n<div class=\"memdoc\">\n<p>Single instance of the allocator of TLS keys in client TLS. </p>\n\n</div>\n</div>\n</div>\n<!-- window showing the filter options -->\n<div id=\"MSearchSelectWindow\"\n     onmouseover=\"return searchBox.OnSearchSelectShow()\"\n     onmouseout=\"return searchBox.OnSearchSelectHide()\"\n     onkeydown=\"return searchBox.OnSearchSelectKey(event)\">\n<a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(0)\"><span class=\"SelectionMark\">&#160;</span>All</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(1)\"><span class=\"SelectionMark\">&#160;</span>Classes</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(2)\"><span class=\"SelectionMark\">&#160;</span>Namespaces</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(3)\"><span class=\"SelectionMark\">&#160;</span>Functions</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(4)\"><span class=\"SelectionMark\">&#160;</span>Variables</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(5)\"><span class=\"SelectionMark\">&#160;</span>Typedefs</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(6)\"><span class=\"SelectionMark\">&#160;</span>Enumerations</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(7)\"><span class=\"SelectionMark\">&#160;</span>Enumerator</a></div>\n\n<!-- iframe showing the search results (closed by default) -->\n<div id=\"MSearchResultsWindow\">\n<iframe src=\"javascript:void(0)\" frameborder=\"0\" \n        name=\"MSearchResults\" id=\"MSearchResults\">\n</iframe>\n</div>\n\n<hr class=\"footer\"/><address class=\"footer\"><small>Generated on Tue May 8 2018 23:39:06 for Pin by&#160;\n<a href=\"http://www.doxygen.org/index.html\">\n<img class=\"footer\" src=\"doxygen.png\" alt=\"doxygen\"/></a> 1.7.4 </small></address>\n</body>\n</html>\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/group__KNOBS.html": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/xhtml;charset=UTF-8\"/>\n<title>Pin: Command Line Switches</title>\n<link href=\"tabs.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<link href=\"search/search.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<script type=\"text/javascript\" src=\"search/search.js\"></script>\n<link href=\"doxygen.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>\n<body onload='searchBox.OnSelectItem(0);'>\n<!-- Generated by Doxygen 1.7.4 -->\n<script type=\"text/javascript\"><!--\nvar searchBox = new SearchBox(\"searchBox\", \"search\",false,'Search');\n--></script>\n<div id=\"top\">\n<div id=\"titlearea\">\n<table cellspacing=\"0\" cellpadding=\"0\">\n <tbody>\n <tr style=\"height: 56px;\">\n  <td style=\"padding-left: 0.5em;\">\n   <div id=\"projectname\">Pin</div>\n  </td>\n </tr>\n </tbody>\n</table>\n</div>\n  <div id=\"navrow1\" class=\"tabs\">\n    <ul class=\"tablist\">\n      <li><a href=\"index.html\"><span>Main&#160;Page</span></a></li>\n      <li><a href=\"modules.html\"><span>Modules</span></a></li>\n      <li><a href=\"namespaces.html\"><span>Namespaces</span></a></li>\n      <li><a href=\"annotated.html\"><span>Classes</span></a></li>\n      <li id=\"searchli\">\n        <div id=\"MSearchBox\" class=\"MSearchBoxInactive\">\n        <span class=\"left\">\n          <img id=\"MSearchSelect\" src=\"search/mag_sel.png\"\n               onmouseover=\"return searchBox.OnSearchSelectShow()\"\n               onmouseout=\"return searchBox.OnSearchSelectHide()\"\n               alt=\"\"/>\n          <input type=\"text\" id=\"MSearchField\" value=\"Search\" accesskey=\"S\"\n               onfocus=\"searchBox.OnSearchFieldFocus(true)\" \n               onblur=\"searchBox.OnSearchFieldFocus(false)\" \n               onkeyup=\"searchBox.OnSearchFieldChange(event)\"/>\n          </span><span class=\"right\">\n            <a id=\"MSearchClose\" href=\"javascript:searchBox.CloseResultsWindow()\"><img id=\"MSearchCloseImg\" border=\"0\" src=\"search/close.png\" alt=\"\"/></a>\n          </span>\n        </div>\n      </li>\n    </ul>\n  </div>\n</div>\n<div class=\"header\">\n  <div class=\"headertitle\">\n<div class=\"title\">Command Line Switches</div>  </div>\n</div>\n<div class=\"contents\">\n<table class=\"memberdecls\">\n</table>\n<p>This section describes the command line switches that are currently supported by Pin.</p>\n<p>Pin switches should appear after the pin command, but before the -t &lt;tool&gt; option. The following Pin switches are supported:</p>\n<table  frame=\"void\" rules=\"none\" cellspacing=\"10\">\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-follow_execv </td><td>Execute all processes spawned by the execv class system calls with Pin.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-help </td><td>Print the help message.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pause_tool &lt;n&gt; </td><td>Pause and print the PID so the debugger can be attached after the tool is loaded. Processing will resume after \"n\" seconds.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-logfile </td><td>Indicates the path and name of the log file. The default path is the current working directory. The default name is pin.log.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-unique_logfile </td><td>Appends the pid to the log file name.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-error_file </td><td>Indicates the path and name of the error file. The default path is the current working directory. If an error file is specified, all errors will be written to the error file, and will not be displayed on the console. If an error file is not specified, no error file will be created. The error file is designed to be parsed by tools that layer on top of Pin. See <a class=\"el\" href=\"group__ERROR__FILE__BASIC.html\">Pin Error Reporting Support</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-unique_error_file </td><td>Appends the pid to the error file name.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-injection &lt;mode&gt; </td><td>Where &lt;mode&gt; is one of dynamic, self, child, parent. UNIX-only. See <a class=\"el\" href=\"index.html#INJECTION\">Injection</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-inline </td><td>Inline simple analysis routines.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-log_inline </td><td>Report which analysis routines have been inlined in the pin.log file.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-cc_memory_size &lt;n&gt; </td><td>Max (in bytes) code cache size (0==unlimited, default). Must be a multiple of the code cache block size   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pid &lt;pid #&gt; </td><td>Attach Pin and the Pintool to an already running executable with the given process id.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pin_memory_range </td><td>Restrict Pin to a memory range, 0x80000000:0x90000000 or size: 0:0x10000000.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-restrict_memory </td><td>Prevent PIN's dynamic loader from using these memory regions, 0x10000000:0x20000000   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pin_memory_size </td><td>Limit the number of bytes that can be dynamically allocated by PIN and PIN tool Note that the number of bytes allocated by PIN is defined by the total number of memory pages allocated by PIN multiplied by the page size   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-tool_load_option </td><td>Load the tool with additional flags. Currently supported flags are:<br/>\n <b>deepbind:</b> (Linux only) Load the tool with the RTLD_DEEPBIND flag to make it a self-contained library. For more information see the dlopen man pages.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-t &lt;toolname&gt; </td><td>Specify the Pintool to use. If you are running a 32-bit application in an IA-32 architecture, or a 64-bit application on an Intel(R) 64 architecture, only -t &lt;toolname&gt; is needed. If you are running an application on an Intel(R) 64 architecture, where all of the components in the chain are either 32-bit or 64-bit, but not both, only -t &lt;toolname&gt; is needed. If you are running an application on an Intel(R) 64 architecture, where components in the chain are both 32-bit and 64-bit, use -t64 &lt;64-bit toolname&gt; to specify the 64-bit tool binary followed by -t &lt;32-bit toolname&gt; to specify the 32-bit tool binary and the tool options. For more information, see <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-t64 &lt;64-bit toolname&gt; </td><td>Specify 64-bit tool binary for Intel(R) 64 architecture. If you are running an application on an Intel(R) 64 architecture, where components in the chain are both 32-bit and 64-bit, use -t64 together with -t as described above. See <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>. <br/>\n <b>Important</b>: Using -t64 without -t is not recommended, since in this case when given a 32-bit application, Pin will run the application without applying any tool.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-p32 &lt;toolname&gt; </td><td>Specify Pin binary for IA-32 architecture. See <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-p64 &lt;toolname&gt; </td><td>Specify Pin binary for Intel(R) 64 architecture. See <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-smc_support [1][0] </td><td>Enable (1) or disable (0) support for self-modifying code (SMC) in the application. This option is enabled by default.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-smc_strict [0][1] </td><td>Enable (1) or disable (0) support for SMC inside basic blocks. By default (0), Pin assumes that basic blocks do not modify their own code.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG\"></a> -appdebug  </td><td>Debug the application, stopping in the debugger as soon as the application is launched.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG_ENABLE\"></a> -appdebug_enable  </td><td>Enable application level debugger support, but do not stop when the application is launched. Instead, you can connect a debugger after launch.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG_SILENT\"></a> -appdebug_silent  </td><td>When application debugging is enabled, Pin normally prints a message telling how to connect an external debugger. This knob disables the message. Pin never prints this message when -appdebug_connection is specified.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG_EXCLUDE\"></a> -appdebug_exclude  </td><td>When application debugging and -follow_execv are both specified, the default behavior is to enable debugging on all child processes. This knob, which is repeatable, specifies an application name for which debugging is disabled. Debugging is disabled for a process if it's argv[0] value matches one of the -appdebug_exclude names.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG_ALLOW_REMOTE\"></a> -appdebug_allow_remote  </td><td>When application debugging is enabled, the default behavior requires the debugger to run on the same system as Pin. This knob allows Pin to connect to an external debugger that runs on a remote system. This knob is ignored when -appdebug_connection is specified because -appdebug_connection explicitly specifies the machine on which the debugger runs.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG_CONNECTION\"></a> -appdebug_connection  </td><td>When application debugging is enabled, Pin's default behavior is to open a TCP port and wait for a debugger to connect. This knob reverses the roles; the debugger opens a TCP port and waits for Pin to connect to the port specified in this knob. The format of the knob value should be \"[ip]:port\". If the \"ip\" address is specified, it should be in dot-decimal notation. If \"ip\" is omitted, Pin connects to the specified port on the local machine. The port number should be specified in decimal. Note that this knob is never used when debugging with GDB.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-detach_reattach </td><td>Allow detach and reattach in probe mode. Windows* only.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-debug_instrumented_processes </td><td>Print message to allow debugger attach to instrumented processes. Windows* only.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-slow_asserts </td><td>Perform expensive sanity checks   </td></tr>\n</table>\n<p>Pin also supports the following tool switches. Tool switches should be placed after the tool name, but before the double dash (\"--\").</p>\n<table  frame=\"void\" rules=\"none\" cellspacing=\"10\">\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-logfile </td><td>Indicates the path and name of the log file. The default path is the current working directory. The default name is pintool.log.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-unique_logfile </td><td>Appends the pid to the log file name.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-discard_line_info &lt;module_name&gt; </td><td>Discard line information for specific module. Module name should be a short name without path, and not a symbolic link   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-discard_line_info_all </td><td>Discard line information for all modules.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-help </td><td>Print the help message.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-support_jit_api </td><td>Enables managed platforms support.  </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-short_name </td><td>Use the shortest name for the RTN. Names with version substrings are preferred over the same name without the substring.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-symbol_path &lt;list of paths&gt; </td><td>Specifies list of paths separated with semicolons that are searched to find symbol and line information. The list is searched when necessary after default search algorithm is applied. Default list is empty. Windows* only.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-slow_asserts </td><td>Perform expensive sanity checks. Recommended to be used in development and testing phase.   </td></tr>\n</table>\n<p>If you want to add your own command line options to your tool, please see <a class=\"el\" href=\"group__KNOB__API.html\">KNOBS</a>. </p>\n</div>\n<!-- window showing the filter options -->\n<div id=\"MSearchSelectWindow\"\n     onmouseover=\"return searchBox.OnSearchSelectShow()\"\n     onmouseout=\"return searchBox.OnSearchSelectHide()\"\n     onkeydown=\"return searchBox.OnSearchSelectKey(event)\">\n<a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(0)\"><span class=\"SelectionMark\">&#160;</span>All</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(1)\"><span class=\"SelectionMark\">&#160;</span>Classes</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(2)\"><span class=\"SelectionMark\">&#160;</span>Namespaces</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(3)\"><span class=\"SelectionMark\">&#160;</span>Functions</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(4)\"><span class=\"SelectionMark\">&#160;</span>Variables</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(5)\"><span class=\"SelectionMark\">&#160;</span>Typedefs</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(6)\"><span class=\"SelectionMark\">&#160;</span>Enumerations</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(7)\"><span class=\"SelectionMark\">&#160;</span>Enumerator</a></div>\n\n<!-- iframe showing the search results (closed by default) -->\n<div id=\"MSearchResultsWindow\">\n<iframe src=\"javascript:void(0)\" frameborder=\"0\" \n        name=\"MSearchResults\" id=\"MSearchResults\">\n</iframe>\n</div>\n\n<hr class=\"footer\"/><address class=\"footer\"><small>Generated on Tue May 8 2018 23:39:04 for Pin by&#160;\n<a href=\"http://www.doxygen.org/index.html\">\n<img class=\"footer\" src=\"doxygen.png\" alt=\"doxygen\"/></a> 1.7.4 </small></address>\n</body>\n</html>\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/lib/libpin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/lib/libpinjitprofiling.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/lib/libpin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/lib/libsapin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/lib/libsapin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/lib-ext/libpin3dwarf.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/runtime/pincrt/libunwind-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/runtime/pincrt/crtbeginS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/runtime/pincrt/libc-static.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/runtime/pincrt/crtendS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/runtime/pincrt/crtend.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/runtime/pincrt/crtbegin.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/runtime/pincrt/libdl-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/runtime/pincrt/libos-apis.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/runtime/pincrt/libstlport-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/runtime/pincrt/libm-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/intel64/runtime/pincrt/libc-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/I18N/win_unicode_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/I18N/win_unicode_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/I18N/win_unicode_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/I18N/win_unicode_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/probefastcall_app.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/before_after_defaultcall_app_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/probefastcall_app.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/before_after_fastcall_app_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/before_after_defaultcall_app_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/before_after_stdcall_app_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/before_after_fastcall_app_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/probestdcall_app.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/before_after_stdcall_app_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/before_after_fastcall_app_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/before_after_defaultcall_app_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/before_after_stdcall_app_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/before_after_fastcall_app_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/before_after_defaultcall_app_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/probestdcall_app.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Probes/before_after_stdcall_app_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Tests/winapp_runs_pin_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Tests/winapp_runs_pin.ico",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/source/tools/Tests/winapp_runs_pin_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/lib/libpin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/lib/libpinjitprofiling.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/lib/libpin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/lib/libsapin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/lib/libsapin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/lib-ext/libpin3dwarf.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/runtime/pincrt/libunwind-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/runtime/pincrt/crtbeginS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/runtime/pincrt/libc-static.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/runtime/pincrt/crtendS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/runtime/pincrt/crtend.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/runtime/pincrt/crtbegin.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/runtime/pincrt/libdl-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/runtime/pincrt/libos-apis.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/runtime/pincrt/libstlport-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/runtime/pincrt/libm-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/ia32/runtime/pincrt/libc-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/xed-intel64/lib/libxed.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/components/lib/intel64/libatomic.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/components/lib/intel64/libdebugger-protocol.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/components/lib/intel64/libdebugger-protocol.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/components/lib/ia32/libatomic.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/components/lib/ia32/libdebugger-protocol.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/components/lib/ia32/libdebugger-protocol.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/doc/html/tab_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/doc/html/tab_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/doc/html/tab_a.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/doc/html/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/doc/html/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/doc/html/open.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/doc/html/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/doc/html/nav_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/doc/html/closed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/doc/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/doc/html/search/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/doc/html/search/search_m.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/doc/html/search/search_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/doc/html/search/mag_sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/crt/doc/html/search/search_l.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/extras/xed-ia32/lib/libxed.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/tab_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/tab_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/tab_a.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/pin-debugger-project-properties1.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/pin-debugger-option-pages-properties.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/pin-debugger-attach.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/open.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/stack-debugger-commands.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/nav_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/pin-debugger-project-properties2.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/stack-debugger-custom-break.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/closed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/search/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/search/search_m.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/search/search_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/search/mag_sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.7-ufpozajzpm2o4hsnusynja5cioqykm2d/spack-src/doc/html/search/search_l.png"
    ],
    "total_files": 4357
}