{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/AttachDetach/secondary_attach_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n   Test the scenario when Pin attaches to an application, using PIN_AttachProbed API,\n   which one of its secondary thread is a zombie thread .\n   Pin wouldn't attach to the zombie thread and wouldn't give a thread detach callbacks on detach\n   to the zombie thread.\n*/\n\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <pthread.h>\n#include <sstream>\n#include <fstream>\n#include <sys/wait.h>\n#include \"zombie_utils.h\"\n#include <string.h>\n#define MAX_COMMAND_LINE_SIZE 15    // the size for the array of arguments to execv (this value is arbitrary)\n\nEXPORT_SYM bool AfterAttach1();\n\nconst char *imageToLoad;\n\npid_t zombieThreadPid;\n\npid_t parentPid;\n\nbool AfterAttach1()\n{\n    // Pin sets an analysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\n// This function is invoked when the secondary thread starts to execute.\nvoid* SecondaryThreadMain(void* v) \n{\n    void *handle = dlopen(imageToLoad, RTLD_LAZY); \n\n    if(!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", imageToLoad, dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    pthread_exit(0);\n    return NULL;\n}\n\n// Expected argv arguments:\n// [1] pin executable\n// [2] Pin flags (e.g. -slow_asserts)\n//     >> zero or more flags possible\n// [3] \"-t\"\n// [4] tool\n// [5] imageName\n// [6] output file\n\nint main(int argc, char** argv)\n{\n    if(argc < 6)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n    if (argc > MAX_COMMAND_LINE_SIZE - 4){      // added: -pid attachPid -probe -o NULL\n        fprintf(stderr, \"Too many arguments\\n\" );\n        fflush(stderr);\n        exit(RES_INVALID_ARGS);\n    }\n    imageToLoad = argv[argc-2];     // argv[argc-2] is imageName\n    parentPid = getpid();\n    pid_t child = fork();\n    if (child < 0)\n    {\n        perror(\"Fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    {\n        // Pin sets an analysis function here to notify the application\n        // when Pin attaches to it in the first attach session.\n        while(!AfterAttach1())\n        {\n            sleep(1);\n        }\n\n        NotifyTestType(TEST_TYPE_SECONDARY_THREAD_ZOMBIE_IN_REATTACH);\n\n        pthread_t tid;\n        pthread_create(&tid, NULL, SecondaryThreadMain, NULL);\n        fprintf(stderr, \"APP: tid of zombie: %d\\n\", (int)tid);\n        \n        while(1);\n    }\n    \n    if (child == 0)\n    {\n        // Inside child \n        pid_t second_child_pid = fork ();\n        \n        if (second_child_pid < 0)\n        {\n            perror(\"Fork failed while creating application process\");\n            exit(RES_FORK_FAILED);\n        }\n\n        if (second_child_pid > 0)\n        {\n            // Inside parent 2\n            waitpid(second_child_pid, 0, 0); // wait until Pin is injected to the application process.\n            exit(RES_SUCCESS);\n        }\n        else\n        {\n            // Inside child 2\n            char attachPid[MAX_SIZE];\n            snprintf(attachPid, MAX_SIZE , \"%d\", parentPid);\n\n            char* args[MAX_COMMAND_LINE_SIZE] = {NULL};  // arguments for execv command\n            int args_count = 0;\n            int argv_count = 1;                          // to start from argv[1]...\n            args[args_count++] = argv[argv_count++];     // by convention, first arg is the filename of the executed file (pin)\n            args[args_count++] = (char*)\"-probe\";\n            args[args_count++] = (char*)\"-pid\";\n            args[args_count++] = attachPid;\n            while (strcmp(argv[argv_count], \"-t\") != 0){   // additional Pin flags (optional)\n                args[args_count++] = argv[argv_count++];\n            }\n            args[args_count++] = argv[argv_count++];     // \"-t\"\n            args[args_count++] = argv[argv_count++];     // tool\n            argv_count++;                                // skip the imageName, not needed for the execv command\n            args[args_count++] = (char*)\"-o\";\n            args[args_count++] = argv[argv_count++];     // output file\n            args[args_count++] = NULL;                   // end\n            // Pin attaches to the application.\n            execv(argv[1], (char * const *)args);        // never returns\n            perror(\"execv failed while trying to attach Pin to the application\\n\");\n            exit(RES_EXEC_FAILED);\n        }\n    }\n\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/AttachDetach/reattach_probed_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*! @file\n *  Test detaching - reattach Pin on Linux\n *  The application creates threads in a loop. Each thread does some work and exits.\n *  The process in endless, expected to be stopped by tool.\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <math.h>\n#include \"../Utils/threadlib.h\"\n\n#define NTHREADS 20\n\n#ifdef TARGET_LINUX\n\n#define DLL_SUFFIX \".so\"\n\n#elif defined(TARGET_MAC)\n\n#define DLL_SUFFIX \".dylib\"\n\n#endif\n\n# define TLS_GET_GS_REG() \\\n  ({ int __seg; __asm (\"movw %%gs, %w0\" : \"=q\" (__seg)); __seg & 0xffff; })\n\n\nvolatile bool loop1, loop2 ;\nvoid * thread_func (void *arg)\n{    \n    while (loop2)\n    {\n        void *space = malloc(300);\n        //sleep(1);\n        free(space);\n    }\n    return 0;\n\n}\n\ntypedef  double (*DLL_FUNC)(double x);\ntypedef  int (*DLL_INT_FUNC)(int x);\n\n\nvoid * thread_dlopen_func (void *arg)\n{    \n    double number = 0.2;\n    double calculatedValue = 0;\n    while (loop1)\n    {\n        void *handle = dlopen(\"libmy_dll\" DLL_SUFFIX, RTLD_LAZY);\n        if (handle)\n        {\n            DLL_FUNC fptr = (DLL_FUNC)dlsym(handle, \"my_dll_sin\");\n            calculatedValue += (*fptr)(number);\n            \n            //sleep(1);\n            dlclose(handle);\n        }\n        else \n        {\n            fprintf(stderr, \"error opening my_dll\" DLL_SUFFIX \", thread %ld\\n\", GetTid());\n            exit(-1);\n        } \n        number += 0.01;\n    }\n        \n    return 0;\n}\n\nint main (int argc, char *argv[])\n{\n    unsigned long gs_val = TLS_GET_GS_REG();\n    while (1)\n    {\n        loop1 = true;\n        loop2 = true;\n        pthread_t h[NTHREADS];\n        \n        pthread_create (&h[0], 0, thread_dlopen_func, 0);\n        for (unsigned long i = 1; i < NTHREADS; i++)\n        {\n            pthread_create (&h[i], 0, thread_func, 0);\n        }\n        sleep(1);\n\n        loop1 = false;\n        loop2 = false;\n\n        for (unsigned long i = 0; i < NTHREADS; i++)\n        {\n            pthread_join (h[i], 0);\n        }\n    }    \n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/AttachDetach/attachReattachThreadDetachCallbacks_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <pthread.h>\n#include <string.h>\n#define MAX_COMMAND_LINE_SIZE 15    // the size for the array of arguments to execv (this value is arbitrary)\n\n#define EXPORT_SYM extern \"C\"\n\n#define NTHREADS 20\n\nvolatile bool loop;\n\nEXPORT_SYM bool AfterAttach1();\n\nEXPORT_SYM bool AfterAttach2();\n\nstatic int MAX_SIZE = 128; /*maximum line size*/\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_FORK_FAILED,      // 1\n    RES_EXEC_FAILED,      // 2\n    RES_LOAD_FAILED,      // 3\n    RES_INVALID_ARGS      // 4\n};\n\nbool AfterAttach1()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nvoid * thread_func (void *arg)\n{    \n    while (loop)\n    {\n         sched_yield();\n    }\n    return 0;\n}\n\n/*\n    Expected argv arguments:\n    [1] pin executable\n    [2] Pin flags (e.g. -slow_asserts)\n        >> zero or more flags possible\n    [3] \"-t\"\n    [4] tool\n    [5] output file\n    [6] First imageName\n\t[7] Second imageName\n*/\nint main(int argc, char** argv)\n{\n    fprintf(stderr, \"Start main\\n\");\n    if(argc < 7)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n    if (argc > MAX_COMMAND_LINE_SIZE - 3){      // added: -pid attachPid -o NULL\n        fprintf(stderr, \"Too many arguments\\n\" );\n        fflush(stderr);\n        exit(RES_INVALID_ARGS);\n    }\n\n    loop  = true;\n\n    int ret_val;\n    pthread_t h[NTHREADS];\n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        ret_val= pthread_create (&h[i], 0, thread_func, 0);\n        if(ret_val) \n        {\n            perror(\"ERROR, pthread_create failed\");\n            exit(1);\n        }\n    }\n\t\n    pid_t parentPid = getpid();\n    pid_t child = fork();\n    if (child < 0)\n    {\n        perror(\"Fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    {\n        while(!AfterAttach1())\n        {\n            sleep(1);\n        }\n        void *handle = dlopen(argv[argc-2], RTLD_LAZY); // argv[argc-2] is First imageName\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[argc-2], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n        while(!AfterAttach2())\n        {\n            sleep(1);\n        }\n        handle = dlopen(argv[argc-1], RTLD_LAZY);   // argv[argc-1] is Second imageName\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[argc-1], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n        while(1)\n        {\n            // expected to be stopped by tool.\n            sleep(1);\n        }\n    }\n    if ( child == 0 )\n    {\n        // Inside child\n        char attachPid[MAX_SIZE];\n        snprintf(attachPid ,MAX_SIZE , \"%d\", parentPid);\n        char* args[MAX_COMMAND_LINE_SIZE] = {NULL};  // arguments for execv command\n        int args_count = 0;\n        int argv_count = 1;                          // to start from argv[1]...\n        args[args_count++] = argv[argv_count++];     // by convention, first arg is the filename of the executed file (pin)\n        args[args_count++] = (char*)\"-pid\";\n        args[args_count++] = attachPid;\n        while (strcmp(argv[argv_count], \"-t\") != 0){   // additional Pin flags (optional)\n            args[args_count++] = argv[argv_count++];\n        }\n        args[args_count++] = argv[argv_count++];     // \"-t\"\n        args[args_count++] = argv[argv_count++];     // tool\n        args[args_count++] = (char*)\"-o\";\n        args[args_count++] = argv[argv_count++];     // output file\n        args[args_count++] = NULL;                   // end\n        execv(argv[1], (char * const *)args);        // never returns\n        perror(\"execv failed while trying to attach Pin to the application\\n\");\n        exit(RES_EXEC_FAILED);\n    }\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/AttachDetach/detach_probed_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*! @file\n *  Test detaching Pin from running process on a Unix compatible system\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n\n#define NTHREADS 20\n\n#ifdef TARGET_MAC\n# define DLL_SUFFIX \".dylib\"\n#else\n# define DLL_SUFFIX \".so\"\n#endif\n\nextern \"C\" void TellPinToDetach(unsigned long *updateWhenReady)\n{\n    return;\n}\n\nvolatile bool loop2 = true;\nvoid * thread_func (void *arg)\n{    \n    while (loop2)\n    {\n        void *space = malloc(300);\n        sleep(1);\n        free(space);\n    }\n    return 0;\n\n}\n\nvolatile bool loop1 = true;\ntypedef  double (*SIN_FUNC)(double x);\n\nvoid * thread_dlopen_func (void *arg)\n{    \n\tdouble number = 0.2;\n    while (loop1)\n    {\n        void *handle = dlopen(\"libm\" DLL_SUFFIX, RTLD_LAZY);\n        if (handle)\n        {\n            SIN_FUNC sin_fptr = (SIN_FUNC)dlsym(handle, \"sin\");\n            if (sin_fptr)\n            {\n                double val = (*sin_fptr)(number);\n                printf(\"val = %.4f\\n\", val);\n            }\n            sleep(2);\n            dlclose(handle);\n        }\n\t\tnumber += 0.01;\n    }\n        \n    return 0;\n\n}\n\nint main (int argc, char *argv[])\n{\n    pthread_t h[NTHREADS];\n    \n    pthread_create (&h[0], 0, thread_dlopen_func, 0);\n    for (unsigned long i = 1; i < NTHREADS; i++)\n    {\n        pthread_create (&h[i], 0, thread_func, 0);\n    }\n    \n\tunsigned long pinDetached = false;\n    TellPinToDetach(&pinDetached);\n    \n\twhile (!pinDetached)\n\t{\n    \tsleep(2);\n\t}\n    \n    loop1 = false;\n    loop2 = false;\n    \n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        pthread_join (h[i], 0);\n    }\n    printf(\"All threads exited. The test PASSED\\n\");    \n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/AttachDetach/main_attach_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n   Test the scenario where Pin tries to reattach to an application, using PIN_AttachProbed API,\n   when the main thread of the application is a zombie thread.\n   Pin wouldn't attach to the application in this scenario. \n   Instead, Pin will give a message to the user notifying why Pin didn't attach to the application and the\n   application will continue to run natively\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <fstream>\n#include <sstream>\n#include \"zombie_utils.h\"\n#include <string.h>\n#define MAX_COMMAND_LINE_SIZE 15    // the size for the array of arguments to execv (this value is arbitrary)\n\nEXPORT_SYM bool AfterAttach1();\n\npid_t zombieThreadPid;\n\nconst char * fileName;\n\nconst char *imageToLoad;\n\nbool AfterAttach1()\n{\n    // Pin sets an analysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\n// This function is invoked when the secondary thread starts execution.\nvoid* SecondaryThreadMain(void* v)\n{\n    // Wait until Pin notifies the application that it can't reattach to it since\n    // the main thread of the application is a zombie thread.\n    while(!NotifyUserPinUnableToAttach(fileName)) sleep(1);\n    pthread_exit(0);\n    return NULL;\n}\n\n// Expected argv arguments:\n// [1] pin executable\n// [2] Pin flags (e.g. -slow_asserts)\n//     >> zero or more flags possible\n// [3] \"-t\"\n// [4] tool\n// [5] imageName\n// [6] output file\nint main(int argc, char** argv)\n{\n    if(argc < 6)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n    if (argc > MAX_COMMAND_LINE_SIZE - 3){      // added: -probe -pid attachPid -o NULL, omitted: argv[0], imageName\n        fprintf(stderr, \"Too many arguments\\n\" );\n        fflush(stderr);\n        exit(RES_INVALID_ARGS);\n    }\n    imageToLoad = argv[argc-2];     // argv[argc-2] is imageName\n    fileName = argv[argc-1];        // argv[argc-1] is output file\n    zombieThreadPid = getpid();\n    pid_t child = fork();\n    if (child < 0)\n    {\n        perror(\"Fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    { \n        // Pin sets an analysis function here to notify the application\n        // when Pin attaches to it in the first attach session.\n        while(!AfterAttach1())\n        {\n            sleep(1);\n        }\n\n        NotifyTestType(TEST_TYPE_MAIN_THREAD_ZOMBIE_IN_REATTACH);\n\n        NotifyZombiePid(zombieThreadPid);\n\n        pthread_t tid;\n        pthread_create(&tid, NULL, SecondaryThreadMain, NULL);\n\n        // When the image is loaded into the memory,\n        // the tool instructs Pin to detach from the application.\n        void *handle = dlopen(imageToLoad, RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", imageToLoad, dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }  \n\n        // After calling to thread_exit(0) function, the main thread is going to become a zombie thread.\n        // Pin should not attach to the application.\n        // Instead, Pin should give a message to the user notifying why Pin didn't attach to the application.\n        pthread_exit(0);\n    }\n\n    if (child == 0)\n    {\n        // Inside child 1\n        pid_t second_child_pid = fork ();\n        \n        if (second_child_pid < 0)\n        {\n            perror(\"Fork failed while creating application process\");\n            exit(RES_FORK_FAILED);\n        }\n\n        if (second_child_pid > 0)\n        {\n            // Inside parent 2\n            waitpid(second_child_pid, 0, 0); // wait until Pin is injected to the application process.\n            exit(RES_SUCCESS);\n        }\n        else\n        {\n            //Inside child 2\n            char attachPid[MAX_SIZE];\n            snprintf(attachPid, MAX_SIZE , \"%d\", zombieThreadPid);\n\n            char* args[MAX_COMMAND_LINE_SIZE] = {NULL};  // arguments for execv command\n            int args_count = 0;\n            int argv_count = 1;                          // to start from argv[1]...\n            args[args_count++] = argv[argv_count++];     // by convention, first arg is the filename of the executed file (pin)\n            args[args_count++] = (char*)\"-probe\";\n            args[args_count++] = (char*)\"-pid\";\n            args[args_count++] = attachPid;\n            while (strcmp(argv[argv_count], \"-t\") != 0){   // additional Pin flags (optional)\n                args[args_count++] = argv[argv_count++];\n            }\n            args[args_count++] = argv[argv_count++];     // \"-t\"\n            args[args_count++] = argv[argv_count++];     // tool\n            args[args_count++] = (char*)\"-o\";\n            argv_count++;                                // skip the imageName, not needed for the execv command\n            args[args_count++] = argv[argv_count++];     // output file\n            args[args_count++] = NULL;                   // end\n            // Pin  attaches to the application.\n            execv(argv[1], (char * const *)args);        // never returns\n            perror(\"execv failed while trying to attach Pin to the application\\n\");\n            exit(RES_EXEC_FAILED);\n        }\n    }\n\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/AttachDetach/reattach_jit_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*! @file\n *  Test detaching - reattach Pin on Linux\n *  The application creates threads in a loop. Each thread does some work and exits.\n *  The process in signaled by the pintool (by replacing AppShouldExit()) that it should exit.\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <math.h>\n#include \"../Utils/threadlib.h\"\n\n#define NTHREADS 20\n\nvolatile bool loop1, loop2 ;\nvoid * thread_func (void *arg)\n{\n    do\n    {\n        void *space = malloc(300);\n        //sleep(1);\n        free(space);\n    }\n    while (loop2);\n\n    return 0;\n}\n\nextern \"C\" int AppShouldExit()\n{\n    return 0;\n}\n\ntypedef  double (*DLL_FUNC)(double x);\ntypedef  int (*DLL_INT_FUNC)(int x);\n\n\nvoid * thread_dlopen_func (void *arg)\n{\n    double number = 0.2;\n    double calculatedValue = 0;\n    do\n    {\n        void *handle = dlopen(\"libmy_dll.so\", RTLD_LAZY);\n        if (handle)\n        {\n            DLL_FUNC fptr = (DLL_FUNC)dlsym(handle, \"my_dll_sin\");\n            calculatedValue += (*fptr)(number);\n\n            //sleep(1);\n            dlclose(handle);\n        }\n        else\n        {\n            fprintf(stderr, \"error opening my_dll.so, thread %d\\n\", GetTid());\n            exit(-1);\n        }\n        number += 0.01;\n    }\n    while (loop1);\n\n    return 0;\n}\n\nint main (int argc, char *argv[])\n{\n    const unsigned int numOfSeconds = 5 * 60; // allow 5 minutes\n    unsigned int secondsRemaining = numOfSeconds;\n    for (; secondsRemaining && (!AppShouldExit()) ; --secondsRemaining)\n    {\n        loop1 = true;\n        loop2 = true;\n        pthread_t h[NTHREADS];\n\n        pthread_create (&h[0], 0, thread_dlopen_func, 0);\n        for (unsigned long i = 1; i < NTHREADS; i++)\n        {\n            pthread_create (&h[i], 0, thread_func, 0);\n        }\n        sleep(1);\n\n        loop1 = false;\n        loop2 = false;\n\n        for (unsigned long i = 0; i < NTHREADS; i++)\n        {\n            pthread_join (h[i], 0);\n        }\n    }\n    if (secondsRemaining == 0)\n    {\n        fprintf(stderr, \"ERROR: The application ran for %u seconds without completion\\n\", numOfSeconds);\n        return 1;\n    }\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/AttachDetach/launchReattachThreadDetachCallbacks_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <pthread.h>\n\n#define EXPORT_SYM extern \"C\"\n\n#define NTHREADS 20\n\n\nvolatile bool loop;\n\nEXPORT_SYM bool AfterAttach2();\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_LOAD_FAILED,      // 1\n    RES_INVALID_ARGS      // 2    \n};\n\n\n\nvoid * thread_func (void *arg)\n{    \n    while (loop)\n    {\n         sched_yield();\n    }\n    return 0;\n}\n\n/*\n    Expected argv arguments:\n    [1]\tFirst image to load\t\n    [2]\tSecond image to load\n*/\nint main (int argc, char *argv[])\n{\n    if(argc!=3)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n\n    loop = true;\n\t\n    pthread_t h[NTHREADS];\n    int ret_val;\n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        ret_val= pthread_create (&h[i], 0, thread_func, 0);\n        if(ret_val) \n        {\n            perror(\"ERROR, pthread_create failed\");\n            exit(1);\n        }\n    }\n\n\tvoid *handle = dlopen(argv[1], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n    \n\twhile(!AfterAttach2())\n    {\n        sleep(1);\n    }\n    \n    handle = dlopen(argv[2], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[2], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        pthread_join (h[i], 0);\n    }\n\n    return RES_SUCCESS;\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/MemTranslate/malloc_translation_app.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#define _GNU_SOURCE\n#include <dlfcn.h>\n#include <link.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// The highest bit value in a pointer\n#define HIGHEST_BIT ((uintptr_t)1 << (8 * sizeof(void*) - 1))\n// Turn on the highest bit in a pointer\n#define MK_PTR(ptr) ((void*)(((uintptr_t)ptr) | HIGHEST_BIT))\n// Turn off the highest bit in a pointer\n#define STRIP_PTR(ptr) ((void*)((uintptr_t)ptr & ~HIGHEST_BIT))\n\n// Initial allocator buffer (see below for explnaition).\nstatic char initial_buf[1024*1024];\nstatic size_t initial_buf_idx = 0;\n\nstatic void* (*libc_malloc)(size_t) = NULL;\nstatic void* (*libc_calloc)(size_t, size_t) = NULL;\nstatic void* (*libc_realloc)(void *ptr, size_t) = NULL;\nstatic void (*libc_free)(void*) = NULL;\n\n/*\n * Initialize all malloc related symbols from libc\n */\nvoid __attribute__((constructor)) init()\n{\n    libc_malloc = dlsym(RTLD_NEXT, \"malloc\");\n    libc_calloc = dlsym(RTLD_NEXT, \"calloc\");\n    libc_realloc = dlsym(RTLD_NEXT, \"realloc\");\n    libc_free = dlsym(RTLD_NEXT, \"free\");\n}\n\n/*********************************************************\n * Below we implement an initial allocator.\n * The first allocated bytes cannot be allocate with libc's\n * memory allocation function.\n * This is merely because calling dlsym() in the loader, to\n * get the address of libc's memory allocation function,\n * causes the loader to call calloc() (the overriden version\n * of calloc()) and if we call dlsym() in calloc() it will\n * eventually cause an infinite recursion.\n * To overcome this, we implement a simple allocator here\n * that allocates the first bytes of the program from\n * the static buffer initial_buf[].\n *********************************************************/\nvoid *initial_malloc(size_t size)\n{\n    void* ret;\n    if (sizeof(initial_buf) < initial_buf_idx + size + sizeof(size_t))\n    {\n        return NULL;\n    }\n    *((size_t*)&initial_buf[initial_buf_idx]) = size;\n    ret = (void*)&initial_buf[initial_buf_idx + sizeof(size_t)];\n    initial_buf_idx += ((size + 2 * sizeof(size_t) - 1) / sizeof(size_t)) * sizeof(size_t);\n    return ret;\n}\n\nsize_t initial_free(void* ptr)\n{\n    if ((ptr >= (void*)initial_buf) && (ptr < (void*)&initial_buf[initial_buf_idx]))\n    {\n        return *((size_t*)ptr - 1);\n    }\n    return 0;\n}\n\n/*********************************************************\n * Wrapper functions for libc memory allocation functions.\n * Here we translate the memory addresses in and out of\n * memory allocation function so the highest bit in the\n * memory address will be turn on.\n *********************************************************/\nvoid *malloc(size_t size)\n{\n    void* ret;\n    if (NULL != (ret = initial_malloc(size)))\n    {\n        return MK_PTR(ret);\n    }\n    return MK_PTR(libc_malloc(size));\n}\n\nvoid *calloc(size_t nmemb, size_t size)\n{\n    void* ret;\n    if (NULL != (ret = initial_malloc(nmemb*size)))\n    {\n        return MK_PTR(ret);\n    }\n    return MK_PTR(libc_calloc(nmemb, size));\n}\n\nvoid *realloc(void *ptr, size_t size)\n{\n    size_t old_size;\n    if (0 != (old_size = initial_free(STRIP_PTR(ptr))))\n    {\n        void* new_ptr = malloc(size);\n        memcpy(STRIP_PTR(new_ptr), STRIP_PTR(ptr), size<old_size?size:old_size);\n        return new_ptr;\n    }\n    return MK_PTR(libc_realloc(STRIP_PTR(ptr), size));\n}\n\nvoid free(void *ptr)\n{\n    if (0 < initial_free(STRIP_PTR(ptr)))\n    {\n        return;\n    }\n    return libc_free(STRIP_PTR(ptr));\n}\n\n/*\n * This simple program just loads the library which its filename was\n * provided ain the command line arguments\n */\nint main(int argc, char* argv[])\n{\n    if (argc != 2)\n    {\n        fprintf(stderr, \"Usage: %s <path to dynamic library>\\n\", argv[0]);\n        exit(1);\n    }\n    const char* file = argv[1];\n    printf(\"Loading shared object %s\\n\", file);\n    fflush(stdout);\n    void *handle = dlopen(file, RTLD_NOW | RTLD_LOCAL);\n    if (NULL == handle)\n    {\n        fprintf(stderr,\"Failed to load %s - %s\\n\", file, dlerror());\n        exit(1);\n    }\n    printf(\"Unloading shared object %s\\n\", file);\n    fflush(stdout);\n    dlclose(handle);\n\n    printf(\"Application finished successfully!\\n\");\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Replay/ia32_cross_os_replay.reference": "[ 0]+ /disk/PinTools/Utils/obj-ia32/cp-pin    \nFunction 'main' loaded at 8048d90\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n[ 1]+ /lib/ld-linux.so.2                      \nFunction 'rtld_lock_default_unlock_recursive' loaded at 555558c0\nFunction 'relocate_doit' loaded at 55556770\nFunction 'fillin_rpath' loaded at 5555a3c0\nFunction 'decompose_rpath' loaded at 5555c9f0\nFunction 'do_lookup_x' loaded at 5555e380\nFunction '_dl_map_object_deps' loaded at 55560e40\nFunction '_dl_sort_fini' loaded at 55562ba0\nFunction 'match_symbol' loaded at 55563930\nFunction '_dl_next_tls_modid' loaded at 55564e10\nFunction '_dl_tls_setup' loaded at 55565940\nFunction '_dl_runtime_resolve' loaded at 55567930\nFunction '__assert_fail' loaded at 55568870\nFunction 'calloc' loaded at 55568f60\nFunction 'profil_counter' loaded at 55569560\nFunction '__lseek' loaded at 555698d0\nFunction '__madvise' loaded at 55569e50\nFunction 'strlen' loaded at 5556a270\nFunction '__i686.get_pc_thunk.cx' loaded at 5556ae47\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n[ 2]+ /usr/lib/libstdc++.so.6                 \nFunction '_ZN9__gnu_cxx17__pool_alloc_base12_M_get_mutexEv' loaded at 56d760f0\nFunction '_ZN9__gnu_cxx6__poolILb1EE13_M_initializeEPFvPvE' loaded at 56d774d0\nFunction '_ZNKSt7codecvtIwc11__mbstate_tE16do_always_noconvEv' loaded at 56d78800\nFunction '_ZNSt7codecvtIcc11__mbstate_tEC1Ej' loaded at 56d78c10\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE7_M_copyEPwPKwj' loaded at 56d78f70\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE15_M_check_lengthEjjPKc' loaded at 56d791c0\nFunction '_ZNKSt14basic_ofstreamIwSt11char_traitsIwEE7is_openEv' loaded at 56d79900\nFunction '_ZStlsIdcSt11char_traitsIcEERSt13basic_ostreamIT0_T1_ES6_RKSt7complexIT_E' loaded at 56d7a7f0\nFunction '_ZNKSt5ctypeIcE9do_narrowEPKcS2_cPc' loaded at 56d7bdf0\nFunction '_ZNSt5ctypeIcED2Ev' loaded at 56d7c340\nFunction '_ZNSt12ctype_bynameIwEC2EPKcj' loaded at 56d7c880\nFunction '_ZN11__gnu_debug19_Safe_sequence_base7_M_swapERS0_' loaded at 56d7da10\nFunction '_ZSt18__throw_bad_typeidv' loaded at 56d7de60\nFunction '_ZNSt12out_of_rangeD0Ev' loaded at 56d7e0f0\nFunction '_ZSt23__throw_underflow_errorPKc' loaded at 56d7e480\nFunction '_ZNSt8ios_base6xallocEv' loaded at 56d7edd0\nFunction '_ZNSt8ios_base7failureC1ERKSs' loaded at 56d7f3c0\nFunction '_ZNSt8ios_base7_M_initEv' loaded at 56d808d0\nFunction '_ZNSt6localeC2ERKS_' loaded at 56d80b10\nFunction '_ZNSt6locale5_ImplD2Ev' loaded at 56d81310\nFunction '_ZNSt6locale5_ImplC2Ej' loaded at 56d81e00\nFunction '_ZNSt6localeC2ERKS_S1_i' loaded at 56d84170\nFunction '_ZNSt11logic_errorC2ERKSs' loaded at 56d86830\nFunction '_ZNSt13runtime_errorC2ERKSs' loaded at 56d86af0\nFunction '_ZNSt13runtime_errorD0Ev' loaded at 56d86e20\nFunction '_ZNSt12strstreambuf7_M_freeEPc' loaded at 56d870e0\nFunction '_ZNSt12strstreambuf9underflowEv' loaded at 56d87330\nFunction '_ZNSt12strstreambufC2EPaiS0_' loaded at 56d87c80\nFunction '_ZNSt12strstreambufC1EPKhi' loaded at 56d88450\nFunction '_ZNSt10ostrstreamD2Ev' loaded at 56d88cb0\nFunction '_ZNSt10istrstreamD1Ev' loaded at 56d89480\nFunction '_ZNSt9strstreamD0Ev' loaded at 56d89bf0\nFunction '_ZSt18_Rb_tree_decrementPKSt18_Rb_tree_node_base' loaded at 56d8a2d0\nFunction '_ZNSaIwED1Ev' loaded at 56d8a8c0\nFunction '_ZNSt13basic_filebufIcSt11char_traitsIcEE13_M_set_bufferEi' loaded at 56d8b6c0\nFunction '_ZNSt13basic_filebufIwSt11char_traitsIwEE27_M_allocate_internal_bufferEv' loaded at 56d8b8b0\nFunction '_ZNSt13basic_filebufIwSt11char_traitsIwEE9pbackfailEj' loaded at 56d8be20\nFunction '_ZNSt13basic_filebufIcSt11char_traitsIcEE6xsgetnEPci' loaded at 56d8d060\nFunction '_ZNSt14basic_ifstreamIwSt11char_traitsIwEE7is_openEv' loaded at 56d8e080\nFunction '_ZNSt13basic_filebufIwSt11char_traitsIwEED0Ev' loaded at 56d8e980\nFunction '_ZNSt13basic_filebufIcSt11char_traitsIcEE9showmanycEv' loaded at 56d8f250\nFunction '_ZNSt14basic_ofstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode' loaded at 56d8f860\nFunction '_ZNSt14basic_ofstreamIwSt11char_traitsIwEEC2Ev' loaded at 56d8fe60\nFunction '_ZNSt14basic_ofstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode' loaded at 56d904d0\nFunction '_ZNSt14basic_ifstreamIcSt11char_traitsIcEEC1Ev' loaded at 56d90d40\nFunction '_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev' loaded at 56d91430\nFunction '_ZTv0_n12_NSt13basic_fstreamIcSt11char_traitsIcEED0Ev' loaded at 56d91dc0\nFunction '_ZNSt13basic_fstreamIwSt11char_traitsIwEED2Ev' loaded at 56d92260\nFunction '_ZNKSt9basic_iosIwSt11char_traitsIwEE7rdstateEv' loaded at 56d93680\nFunction '_ZNSt9basic_iosIcSt11char_traitsIcEEC1Ev' loaded at 56d938f0\nFunction '_ZNSt9basic_iosIcSt11char_traitsIcEED2Ev' loaded at 56d93c00\nFunction '_ZNKSt9basic_iosIwSt11char_traitsIwEE3badEv' loaded at 56d93fe0\nFunction '_ZNSt9basic_iosIwSt11char_traitsIwEE10exceptionsESt12_Ios_Iostate' loaded at 56d941d0\nFunction '_ZNSt9basic_iosIwSt11char_traitsIwEE5imbueERKSt6locale' loaded at 56d944a0\nFunction '_ZNSt14basic_iostreamIwSt11char_traitsIwEEC1Ev' loaded at 56d94f60\nFunction '_ZNSdC1Ev' loaded at 56d95280\nFunction '_ZNSirsEPFRSt8ios_baseS0_E' loaded at 56d954d0\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEErsEPFRSt8ios_baseS4_E' loaded at 56d95600\nFunction '_ZStrsISt11char_traitsIcEERSt13basic_istreamIcT_ES5_Pa' loaded at 56d958a0\nFunction '_ZStrsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_St12_Setiosflags' loaded at 56d95b40\nFunction '_ZTv0_n12_NSt13basic_istreamIwSt11char_traitsIwEED1Ev' loaded at 56d95e20\nFunction '_ZStrsIcSt11char_traitsIcEERSt13basic_istreamIT_T0_ES6_RS3_' loaded at 56d96650\nFunction '_ZNSi3getERSt15basic_streambufIcSt11char_traitsIcEE' loaded at 56d96fa0\nFunction '_ZNSirsERy' loaded at 56d97a40\nFunction '_ZSt2wsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_' loaded at 56d987a0\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEE3getERSt15basic_streambufIwS1_Ew' loaded at 56d99390\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEErsERf' loaded at 56d99e80\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEE6sentryC2ERS2_b' loaded at 56d9abf0\nFunction '_ZNKSt10moneypunctIcLb0EE13thousands_sepEv' loaded at 56d9c540\nFunction '_ZNKSt10moneypunctIcLb0EE14do_frac_digitsEv' loaded at 56d9c6c0\nFunction '_ZNKSt10moneypunctIcLb1EE10pos_formatEv' loaded at 56d9c890\nFunction '_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' loaded at 56d9cb50\nFunction '_ZNSt16__numpunct_cacheIcEC1Ej' loaded at 56d9cda0\nFunction '_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRe' loaded at 56d9d200\nFunction '_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPKv' loaded at 56d9d5f0\nFunction '_ZNSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEEC2Ej' loaded at 56d9d850\nFunction '_ZNKSt8messagesIcE4openERKSsRKSt6locale' loaded at 56d9db80\nFunction '_ZNSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED0Ev' loaded at 56d9dfc0\nFunction '_ZNSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEED1Ev' loaded at 56d9e1e0\nFunction '_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED2Ev' loaded at 56d9e3f0\nFunction '_ZSt9has_facetISt8numpunctIcEEbRKSt6locale' loaded at 56d9e810\nFunction '_ZSt9use_facetISt10moneypunctIcLb0EEERKT_RKSt6locale' loaded at 56d9ebb0\nFunction '_ZNSt7collateIcEC2Ej' loaded at 56d9ef10\nFunction '_ZNSt8messagesIcED1Ev' loaded at 56d9f290\nFunction '_ZNSt16__numpunct_cacheIcED2Ev' loaded at 56d9f6d0\nFunction '_ZNSt15numpunct_bynameIcED2Ev' loaded at 56d9fb30\nFunction '_ZNSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' loaded at 56d9ffb0\nFunction '_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' loaded at 56da0310\nFunction '_ZNSt15messages_bynameIcEC2EPKcj' loaded at 56da07c0\nFunction '_ZNSt11__timepunctIcEC2Ej' loaded at 56da0fc0\nFunction '_ZNKSt8numpunctIcE12do_falsenameEv' loaded at 56da12f0\nFunction '_ZNSt10moneypunctIcLb1EEC2EP15__locale_structPKcj' loaded at 56da17f0\nFunction '_ZNKSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPK2tmPKcSB_' loaded at 56da1c80\nFunction '_ZNSt15numpunct_bynameIcEC1EPKcj' loaded at 56da2180\nFunction '_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE14do_get_weekdayES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm' loaded at 56da3b00\nFunction '_ZNKSt7collateIcE12do_transformEPKcS2_' loaded at 56da68d0\nFunction '_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' loaded at 56dac390\nFunction '_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE15_M_insert_floatIeEES3_S3_RSt8ios_baseccT_' loaded at 56daeb10\nFunction '_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE6do_putES3_RSt8ios_basecm' loaded at 56db0310\nFunction '_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRm' loaded at 56db2f10\nFunction '_ZStlsIcSt11char_traitsIcESaIcEERSt13basic_ostreamIT_T0_ES7_RKSbIS4_S5_T1_E' loaded at 56db5520\nFunction '_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEPFRS2_S3_E' loaded at 56db5a10\nFunction '_ZNSoC2EPSt15basic_streambufIcSt11char_traitsIcEE' loaded at 56db5ba0\nFunction '_ZNSoC1Ev' loaded at 56db5e20\nFunction '_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_' loaded at 56db6470\nFunction '_ZNSoD2Ev' loaded at 56db6a40\nFunction '_ZNSolsEs' loaded at 56db6d50\nFunction '_ZNSo5writeEPKci' loaded at 56db7af0\nFunction '_ZNSolsEx' loaded at 56db8a50\nFunction '_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEi' loaded at 56db9e90\nFunction '_ZSt4endsIwSt11char_traitsIwEERSt13basic_ostreamIT_T0_ES6_' loaded at 56dbb170\nFunction '_ZNKSt19basic_ostringstreamIcSt11char_traitsIcESaIcEE5rdbufEv' loaded at 56dbba10\nFunction '_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE6setbufEPwi' loaded at 56dbbd40\nFunction '_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE3strERKSbIwS1_S2_E' loaded at 56dbc7f0\nFunction '_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode' loaded at 56dbcc90\nFunction '_ZNKSt18basic_stringstreamIcSt11char_traitsIcESaIcEE3strEv' loaded at 56dbd7f0\nFunction '_ZNKSt19basic_istringstreamIwSt11char_traitsIwESaIwEE3strEv' loaded at 56dbdfc0\nFunction '_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEED2Ev' loaded at 56dbe670\nFunction '_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode' loaded at 56dbee50\nFunction '_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode' loaded at 56dbf9a0\nFunction '_ZTv0_n12_NSt19basic_istringstreamIwSt11char_traitsIwESaIwEED0Ev' loaded at 56dc0180\nFunction '_ZTv0_n12_NSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev' loaded at 56dc0a90\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEE10pubseekposESt4fposI11__mbstate_tESt13_Ios_Openmode' loaded at 56dc12e0\nFunction '_ZNKSt15basic_streambufIcSt11char_traitsIcEE4pptrEv' loaded at 56dc1420\nFunction '_ZNSt15basic_streambufIwSt11char_traitsIwEE10pubseekoffExSt12_Ios_SeekdirSt13_Ios_Openmode' loaded at 56dc14f0\nFunction '_ZNKSt15basic_streambufIwSt11char_traitsIwEE5pbaseEv' loaded at 56dc1680\nFunction '_ZNSt15basic_streambufIwSt11char_traitsIwEEaSERKS2_' loaded at 56dc1740\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEEC1Ev' loaded at 56dc1a40\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEED1Ev' loaded at 56dc1ce0\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEE7seekposESt4fposI11__mbstate_tESt13_Ios_Openmode' loaded at 56dc1e40\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEE5sputcEc' loaded at 56dc2150\nFunction '_ZNKSs7_M_dataEv' loaded at 56dc26e0\nFunction '_ZNKSs4sizeEv' loaded at 56dc2820\nFunction '_ZNSs4_Rep15_M_set_sharableEv' loaded at 56dc28e0\nFunction '_ZNKSs5emptyEv' loaded at 56dc2d70\nFunction '_ZNKSs16find_last_not_ofEcj' loaded at 56dc3010\nFunction '_ZNKSs13find_first_ofEcj' loaded at 56dc33e0\nFunction '_ZNKSs4rendEv' loaded at 56dc3740\nFunction '_ZNKSs7compareEjjRKSs' loaded at 56dc3b60\nFunction '_ZNSsC2EPKcjRKSaIcE' loaded at 56dc4040\nFunction '_ZNSsC1IPcEET_S1_RKSaIcE' loaded at 56dc4470\nFunction '_ZNSs6appendEPKcj' loaded at 56dc4a00\nFunction '_ZNSs6assignEPKc' loaded at 56dc5100\nFunction '_ZNSs6insertEN9__gnu_cxx17__normal_iteratorIPcSsEEjc' loaded at 56dc54e0\nFunction '_ZNSs7_M_leakEv' loaded at 56dc59b0\nFunction '_ZNSsD2Ev' loaded at 56dc5d10\nFunction '_ZNSs7replaceEjjPKc' loaded at 56dc63b0\nFunction '_ZNSt8valarrayIjED2Ev' loaded at 56dc6700\nFunction '_ZNKSt10moneypunctIwLb0EE13positive_signEv' loaded at 56dc6dc0\nFunction '_ZNKSt10moneypunctIwLb1EE13decimal_pointEv' loaded at 56dc6f70\nFunction '_ZNKSt10moneypunctIwLb1EE16do_thousands_sepEv' loaded at 56dc7100\nFunction '_ZNKSt8numpunctIwE13decimal_pointEv' loaded at 56dc74b0\nFunction '_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRt' loaded at 56dc76f0\nFunction '_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE3putES3_RSt8ios_basewb' loaded at 56dc7b10\nFunction '_ZNKSt11__timepunctIwE20_M_date_time_formatsEPPKw' loaded at 56dc7ea0\nFunction '_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10date_orderEv' loaded at 56dc8130\nFunction '_ZNKSt8messagesIwE8do_closeEi' loaded at 56dc8430\nFunction '_ZNSt8time_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED0Ev' loaded at 56dc87b0\nFunction '_ZNSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEED1Ev' loaded at 56dc89d0\nFunction '_ZSt9has_facetISt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEEbRKSt6locale' loaded at 56dc8cb0\nFunction '_ZSt9has_facetISt7codecvtIwc11__mbstate_tEEbRKSt6locale' loaded at 56dc9110\nFunction '_ZSt9use_facetISt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEERKT_RKSt6locale' loaded at 56dc9470\nFunction '_ZNSt14codecvt_bynameIwc11__mbstate_tED1Ev' loaded at 56dc97d0\nFunction '_ZNSt15messages_bynameIwED0Ev' loaded at 56dc9bb0\nFunction '_ZNSt18__moneypunct_cacheIwLb1EED1Ev' loaded at 56dca010\nFunction '_ZNSt17moneypunct_bynameIwLb1EED1Ev' loaded at 56dca3f0\nFunction '_ZNSt8numpunctIwEC1EP15__locale_structj' loaded at 56dca870\nFunction '_ZNSt18__moneypunct_cacheIwLb0EEC2Ej' loaded at 56dcabf0\nFunction '_ZNSt17__timepunct_cacheIwEC1Ej' loaded at 56dcb110\nFunction '_ZNKSt10moneypunctIwLb0EE16do_negative_signEv' loaded at 56dcb8b0\nFunction '_ZNSt10moneypunctIwLb1EEC1EPSt18__moneypunct_cacheIwLb1EEj' loaded at 56dcbe10\nFunction '_ZNSt8messagesIwEC1EP15__locale_structPKcj' loaded at 56dcc1f0\nFunction '_ZNSt15time_get_bynameIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEC2EPKcj' loaded at 56dcc8d0\nFunction '_ZNSt17moneypunct_bynameIwLb0EEC2EPKcj' loaded at 56dccd40\nFunction '_ZNSt14collate_bynameIwEC2EPKcj' loaded at 56dcf9b0\nFunction '_ZNKSt9money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb1EEES3_S3_RSt8ios_basewRKSbIwS2_SaIwEE' loaded at 56dd1030\nFunction '_ZNKSt9money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10_M_extractILb0EEES3_S3_S3_RSt8ios_baseRSt12_Ios_IostateRSs' loaded at 56dd4110\nFunction '_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE13_M_insert_intIxEES3_S3_RSt8ios_basewT_' loaded at 56dd7b60\nFunction '_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRx' loaded at 56dda050\nFunction '_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_putES3_RSt8ios_basewb' loaded at 56ddcfc0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE5beginEv' loaded at 56ddd810\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE4_Rep12_M_is_sharedEv' loaded at 56ddd8e0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE4findEPKwjj' loaded at 56dddca0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE17find_first_not_ofEwj' loaded at 56dddf40\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE13find_first_ofEPKwjj' loaded at 56dde330\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE12find_last_ofEPKwj' loaded at 56dde6a0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE7compareEjjRKS2_jj' loaded at 56dde9c0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_jjRKS1_' loaded at 56ddefa0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEEC1EPKwRKS1_' loaded at 56ddf3b0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE9push_backEw' loaded at 56ddf8d0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEED2Ev' loaded at 56ddfe30\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPwS2_EEw' loaded at 56de0420\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE6insertEjRKS2_jj' loaded at 56de0910\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE6rbeginEv' loaded at 56de0c30\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE7replaceEjjPKw' loaded at 56de1210\nFunction '_ZNKSt7codecvtIwc11__mbstate_tE9do_lengthERS0_PKcS4_j' loaded at 56de15e0\nFunction '_ZNKSt5ctypeIwE11do_scan_notEtPKwS2_' loaded at 56de1dc0\nFunction '_ZNKSt5ctypeIwE10do_toupperEw' loaded at 56de21e0\nFunction '_ZNSt10moneypunctIwLb0EED2Ev' loaded at 56de2ab0\nFunction '_ZNSt10moneypunctIcLb0EE24_M_initialize_moneypunctEP15__locale_structPKc' loaded at 56de3090\nFunction '_ZNSt8numpunctIwE22_M_initialize_numpunctEP15__locale_struct' loaded at 56de4390\nFunction '_ZNSt12__basic_fileIcE4syncEv' loaded at 56de5a80\nFunction '_ZNSt12__basic_fileIcE6xsgetnEPci' loaded at 56de5f30\nFunction '_ZdlPvRKSt9nothrow_t' loaded at 56de62c0\nFunction '__cxa_begin_catch' loaded at 56de66c0\nFunction '__cxa_call_unexpected' loaded at 56de6d30\nFunction '__cxa_guard_release' loaded at 56de7630\nFunction '__cxa_pure_virtual' loaded at 56de7970\nFunction '_ZN10__cxxabiv117__class_type_infoD0Ev' loaded at 56de7b30\nFunction '_ZNSt10bad_typeidD1Ev' loaded at 56de7d50\nFunction '_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_' loaded at 56de8060\nFunction '_ZN10__cxxabiv117__pbase_type_infoD2Ev' loaded at 56de8a60\nFunction '_ZN10__cxxabiv120__function_type_infoD0Ev' loaded at 56de8c70\nFunction '_ZNK10__cxxabiv119__pointer_type_info15__pointer_catchEPKNS_17__pbase_type_infoEPPvj' loaded at 56de8ef0\nFunction '__cxa_vec_new' loaded at 56de95e0\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n[ 3]+ /lib/libm.so.6                          \nFunction '__i686.get_pc_thunk.bx' loaded at 56e2e4c7\nFunction 'fegetenv' loaded at 56e30a90\nFunction '__ieee754_asin' loaded at 56e30db0\nFunction '__ieee754_y0' loaded at 56e314e0\nFunction '__ieee754_log10' loaded at 56e32c10\nFunction 'cbrt' loaded at 56e335f0\nFunction 'logb' loaded at 56e340d0\nFunction 'asin' loaded at 56e34840\nFunction 'hypot' loaded at 56e34e30\nFunction 'log10' loaded at 56e35560\nFunction 'nan' loaded at 56e35b00\nFunction 'creal' loaded at 56e35f10\nFunction 'csin' loaded at 56e36b80\nFunction 'clog10' loaded at 56e37d60\nFunction '__finite' loaded at 56e382b0\nFunction '__ieee754_atan2f' loaded at 56e386d0\nFunction 'ponef' loaded at 56e38ee0\nFunction '__ieee754_remainderf' loaded at 56e3a280\nFunction 'cbrtf' loaded at 56e3ab60\nFunction 'logbf' loaded at 56e3b4d0\nFunction 'asinf' loaded at 56e3b9e0\nFunction 'hypotf' loaded at 56e3bff0\nFunction 'log10f' loaded at 56e3c6c0\nFunction 'nanf' loaded at 56e3cc50\nFunction 'crealf' loaded at 56e3cf60\nFunction 'csinf' loaded at 56e3dab0\nFunction 'clog10f' loaded at 56e3e9d0\nFunction 'finitef' loaded at 56e3ee00\nFunction '__ieee754_atan2l' loaded at 56e3f320\nFunction 'pone' loaded at 56e3fff0\nFunction '__ieee754_remainderl' loaded at 56e41730\nFunction 'cbrtl' loaded at 56e41ca0\nFunction 'logbl' loaded at 56e42800\nFunction 'atan2l' loaded at 56e42db0\nFunction 'y0l' loaded at 56e43420\nFunction 'powl' loaded at 56e43b90\nFunction 'truncl' loaded at 56e44180\nFunction 'cabsl' loaded at 56e444c0\nFunction 'ctanl' loaded at 56e45540\nFunction 'fmal' loaded at 56e466c0\nFunction 'copysignl' loaded at 56e46ae0\nFunction '__divdc3' loaded at 56e48190\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n[ 4]+ /lib/libgcc_s.so.1                      \nFunction '__ashldi3' loaded at 56e5a8e0\nFunction '__subvsi3' loaded at 56e5abe0\nFunction '__ctzdi2' loaded at 56e5b030\nFunction '__mulxc3' loaded at 56e5bd70\nFunction '__fixdfdi' loaded at 56e5d020\nFunction '__udivmoddi4' loaded at 56e5d8e0\nFunction '_Unwind_GetGR' loaded at 56e5dcd0\nFunction '__register_frame_info' loaded at 56e60260\nFunction '.fini' loaded at 56e62104\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n[ 5]+ /lib/libc.so.6                          \nFunction 'gnu_get_libc_version' loaded at 56e79980\nFunction '__divdi3' loaded at 56e79ee0\nFunction '__gconv_close' loaded at 56e7adc0\nFunction '__gconv_find_transform' loaded at 56e7bab0\nFunction 'add_alias' loaded at 56e7c180\nFunction '__gconv_transform_ascii_internal' loaded at 56e7e080\nFunction '__gconv_translit_find' loaded at 56e81e20\nFunction '__gconv_lookup_cache' loaded at 56e82780\nFunction '_L_unlock_996' loaded at 56e838fc\nFunction 'rangecmp' loaded at 56e84640\nFunction '__duplocale' loaded at 56e85ad0\nFunction '__collseq_table_lookup' loaded at 56e85f30\nFunction 'isdigit' loaded at 56e86400\nFunction '__isascii_l' loaded at 56e866a0\nFunction 'ispunct_l' loaded at 56e86810\nFunction 'set_binding_values' loaded at 56e869d0\nFunction '__dcigettext' loaded at 56e87a10\nFunction 'dcngettext' loaded at 56e88220\nFunction '_nl_expand_alias' loaded at 56e89d40\nFunction 'new_exp_2' loaded at 56e8a920\nFunction 'finite' loaded at 56e8bd40\nFunction 'copysignf' loaded at 56e8c0f0\nFunction 'modfl' loaded at 56e8c3b0\nFunction '__libc_longjmp' loaded at 56e8c810\nFunction 'sigpending' loaded at 56e8cd90\nFunction 'sigpause' loaded at 56e8d1f0\nFunction 'sigaddset' loaded at 56e8d5a0\nFunction '__libc_current_sigrtmax_private' loaded at 56e8d8f0\nFunction 'sigset' loaded at 56e8de10\nFunction '_quicksort' loaded at 56e8e360\nFunction '_L_lock_22' loaded at 56e8f45a\nFunction 'exit' loaded at 56e8f530\nFunction 'div' loaded at 56e8f9d0\nFunction 'initstate' loaded at 56e8fef0\nFunction 'setstate_r' loaded at 56e90070\nFunction 'mrand48' loaded at 56e90610\nFunction 'jrand48_r' loaded at 56e908d0\nFunction 'strtoll' loaded at 56e90ca0\nFunction 'strtoull_l' loaded at 56e92390\nFunction '__strtof_l' loaded at 56e948e0\nFunction 'do_system' loaded at 56e99720\nFunction 'realpath' loaded at 56e99cf0\nFunction '__xpg_basename' loaded at 56e9b780\nFunction 'wcstoimax' loaded at 56e9c020\nFunction '__mpn_add_n' loaded at 56e9c4a0\nFunction '__mpn_impn_sqr_n_basecase' loaded at 56e9cfa0\nFunction '__mpn_construct_double' loaded at 56e9ddf0\nFunction '_itowa' loaded at 56e9e690\nFunction '_L_unlock_11056' loaded at 56ea35aa\nFunction 'printf_size_info' loaded at 56ea77b0\nFunction 'group_number' loaded at 56ea8220\nFunction 'vfscanf' loaded at 56eb2050\nFunction 'perror_internal' loaded at 56eb6cd0\nFunction '__path_search' loaded at 56eb7770\nFunction 'ftrylockfile' loaded at 56eb7ea0\nFunction '_IO_file_doallocate' loaded at 56eb8b50\nFunction '_L_unlock_161' loaded at 56eb9245\nFunction '__fopen_internal' loaded at 56eb9690\nFunction '_L_lock_41' loaded at 56eb9bdc\nFunction '_L_unlock_185' loaded at 56eb9ecf\nFunction '_L_lock_47' loaded at 56eba57b\nFunction '_IO_proc_close' loaded at 56ebaa70\nFunction '_L_unlock_110' loaded at 56ebb13e\nFunction '_IO_setbuffer' loaded at 56ebb4a0\nFunction '_L_unlock_95' loaded at 56ebb894\nFunction '_L_unlock_105' loaded at 56ebbda2\nFunction 'getwchar' loaded at 56ebc020\nFunction '_L_lock_43' loaded at 56ebc4e9\nFunction 'putwc' loaded at 56ebc940\nFunction '_L_unlock_81' loaded at 56ebcc61\nFunction 'vswprintf' loaded at 56ebcf20\nFunction '_IO_sungetwc' loaded at 56ebd360\nFunction 'save_for_wbackup' loaded at 56ebd7c0\nFunction '_IO_wstr_finish' loaded at 56ebe140\nFunction '_IO_wdo_write' loaded at 56ebf2a0\nFunction 'do_out' loaded at 56ebfb00\nFunction '_L_lock_29' loaded at 56ec0220\nFunction '_L_lock_30' loaded at 56ec04ae\nFunction '_L_lock_29' loaded at 56ec08df\nFunction '_L_lock_30' loaded at 56ec0c7e\nFunction '_IO_strn_overflow' loaded at 56ec1080\nFunction 'ftello' loaded at 56ec1670\nFunction 'ftello64' loaded at 56ec1b60\nFunction '__fpending' loaded at 56ec1e00\nFunction '_L_unlock_17' loaded at 56ec25f2\nFunction '_L_lock_29' loaded at 56ec2814\nFunction '_IO_file_sync_mmap' loaded at 56ec2d30\nFunction '_IO_do_write' loaded at 56ec3a10\nFunction '_IO_file_setbuf_mmap' loaded at 56ec44a0\nFunction 'flush_cleanup' loaded at 56ec4fa0\nFunction '_IO_sgetn' loaded at 56ec55a0\nFunction '_IO_adjust_column' loaded at 56ec5960\nFunction '_IO_default_seek' loaded at 56ec5fc0\nFunction '_IO_list_lock' loaded at 56ec6070\nFunction '_IO_default_doallocate' loaded at 56ec67e0\nFunction '_L_unlock_280' loaded at 56ec6c3e\nFunction '_L_lock_1784' loaded at 56ec6cca\nFunction '_IO_str_pbackfail' loaded at 56ec6f60\nFunction '__failing_morecore' loaded at 56ec75a0\nFunction 'ptmalloc_init' loaded at 56ec7ef0\nFunction 'cfree' loaded at 56ec91a0\nFunction 'realloc_check' loaded at 56ecaaa0\nFunction 'realloc_hook_ini' loaded at 56ecbad0\nFunction '_L_unlock_2466' loaded at 56ecc04a\nFunction '_L_unlock_4424' loaded at 56ecc0e2\nFunction '_L_unlock_8320' loaded at 56ecc17a\nFunction '_L_lock_9316' loaded at 56ecc20f\nFunction '_L_unlock_9886' loaded at 56ecc29b\nFunction '_L_unlock_10772' loaded at 56ecc327\nFunction 'mprobe' loaded at 56ecc510\nFunction 'mtrace' loaded at 56eccc10\nFunction '_L_lock_751' loaded at 56ecd4f3\nFunction '_obstack_memory_used' loaded at 56ecd8f0\nFunction '__strdup' loaded at 56ecdfd0\nFunction 'strpbrk' loaded at 56ece820\nFunction 'bcmp' loaded at 56ecf180\nFunction 'ffsll' loaded at 56ecfd90\nFunction '_wordcopy_fwd_aligned' loaded at 56ed0310\nFunction 'rawmemchr' loaded at 56ed0b90\nFunction 'argz_insert' loaded at 56ed1180\nFunction 'envz_add' loaded at 56ed1970\nFunction '__memset_gcn_by4' loaded at 56ed3700\nFunction '__strncat_g' loaded at 56ed3950\nFunction '__strcspn_g' loaded at 56ed3b40\nFunction '__strcspn_c1' loaded at 56ed3f70\nFunction '__strsep_3c' loaded at 56ed4270\nFunction '__xpg_strerror_r' loaded at 56ed4680\nFunction 'wcsncpy' loaded at 56ed4aa0\nFunction 'wmemset' loaded at 56ed4f80\nFunction 'mbsrtowcs' loaded at 56ed58e0\nFunction 'wcstoll' loaded at 56ed6550\nFunction '____wcstol_l_internal' loaded at 56ed6870\nFunction '____wcstod_l_internal' loaded at 56ed8040\nFunction 'wcscoll' loaded at 56ede440\nFunction '_nl_cleanup_ctype' loaded at 56ee0000\nFunction 'asctime' loaded at 56ee0c60\nFunction 'guess_time_tm' loaded at 56ee0eb0\nFunction '__tzstring' loaded at 56ee1be0\nFunction '_L_unlock_2123' loaded at 56ee287f\nFunction 'ftime' loaded at 56ee39c0\nFunction 'memcpy_uppcase' loaded at 56ee68e0\nFunction '_nl_init_alt_digit' loaded at 56eeab60\nFunction '_nl_cleanup_time' loaded at 56eeafe0\nFunction '_L_unlock_119' loaded at 56eeb4ac\nFunction 'alphasort' loaded at 56eeb840\nFunction '_L_lock_246' loaded at 56eebee0\nFunction '_L_lock_27' loaded at 56eec50a\nFunction 'getgrgid' loaded at 56eecca0\nFunction '_L_unlock_290' loaded at 56eed201\nFunction 'getgrgid_r' loaded at 56eed4e0\nFunction '_L_unlock_116' loaded at 56eee03e\nFunction '_L_lock_25' loaded at 56eee5d6\nFunction '_L_unlock_233' loaded at 56eee8bd\nFunction 'times' loaded at 56eef2d0\nFunction 'pause' loaded at 56eefb10\nFunction 'execle' loaded at 56ef0120\nFunction 'getegid' loaded at 56ef09a0\nFunction 'getsid' loaded at 56ef0c60\nFunction 'setlogin' loaded at 56ef1140\nFunction 'handle_intel' loaded at 56ef1a00\nFunction 'collated_compare' loaded at 56ef3be0\nFunction 'end_pattern' loaded at 56ef5f50\nFunction 're_node_set_contains' loaded at 56efa780\nFunction 'find_subexp_node' loaded at 56efad00\nFunction 'lower_subexps' loaded at 56efb590\nFunction 'free_dfa_content' loaded at 56efb9d0\nFunction 'check_arrival_expand_ecl' loaded at 56efc4b0\nFunction 're_node_set_init_copy' loaded at 56efd1f0\nFunction 'build_upper_buffer' loaded at 56efe6f0\nFunction 'check_arrival' loaded at 56efffa0\nFunction 'parse_bracket_exp' loaded at 56f02cf0\nFunction 'set_regs' loaded at 56f05f40\nFunction 're_exec' loaded at 56f08f60\nFunction '_getopt_long_only_r' loaded at 56f0a650\nFunction '__sched_get_priority_min' loaded at 56f0a940\nFunction 'in6aicmp' loaded at 56f0ad30\nFunction '_L_lock_9088' loaded at 56f0e70d\nFunction 'eval_expr' loaded at 56f0ed40\nFunction 'pread' loaded at 56f12850\nFunction 'posix_spawn_file_actions_addclose' loaded at 56f12cb0\nFunction 'posix_spawnattr_setpgroup' loaded at 56f12fa0\nFunction 'posix_spawnattr_setschedparam' loaded at 56f13760\nFunction '__xstat64' loaded at 56f13b70\nFunction 'fstatfs64' loaded at 56f143f0\nFunction 'mkdir' loaded at 56f14a00\nFunction '__close' loaded at 56f15160\nFunction '__fcntl_nocancel' loaded at 56f15750\nFunction 'creat64' loaded at 56f15cc0\nFunction 'getttyname' loaded at 56f162f0\nFunction 'readlinkat' loaded at 56f17050\nFunction 'object_compare' loaded at 56f184b0\nFunction 'fts_palloc' loaded at 56f19850\nFunction 'posix_fadvise' loaded at 56f1afc0\nFunction '__internal_statvfs' loaded at 56f1bea0\nFunction 'tcsetpgrp' loaded at 56f1c4c0\nFunction 'setrlimit64' loaded at 56f1c8f0\nFunction '__sbrk' loaded at 56f1cdb0\nFunction 'setregid' loaded at 56f1d440\nFunction '___newselect_nocancel' loaded at 56f1d84a\nFunction 'sethostid' loaded at 56f1de50\nFunction 'usleep' loaded at 56f1e150\nFunction 'getfsspec' loaded at 56f1e570\nFunction '_L_lock_1062' loaded at 56f1f144\nFunction 'ftruncate64' loaded at 56f1f5c0\nFunction 'endusershell' loaded at 56f1fcc0\nFunction 'openlog_internal' loaded at 56f20390\nFunction '_L_lock_1085' loaded at 56f20c4c\nFunction 'madvise' loaded at 56f21070\nFunction 'fcvt_r' loaded at 56f21420\nFunction 'hsearch_r' loaded at 56f22060\nFunction 'tsearch' loaded at 56f22a40\nFunction 'errx' loaded at 56f23040\nFunction 'dirname' loaded at 56f238b0\nFunction 'listxattr' loaded at 56f23d30\nFunction 'vm86' loaded at 56f24080\nFunction 'gnu_dev_major' loaded at 56f24450\nFunction 'capget' loaded at 56f24730\nFunction 'inotify_add_watch' loaded at 56f24a30\nFunction 'prctl' loaded at 56f24d60\nFunction 'getpeername' loaded at 56f250c0\nFunction 'setsockopt' loaded at 56f25500\nFunction '__libc_msgsnd' loaded at 56f259a0\nFunction 'shmget' loaded at 56f25f10\nFunction 'pc_to_index' loaded at 56f26b80\nFunction 'iswxdigit' loaded at 56f27410\nFunction 'iswpunct' loaded at 56f27c50\nFunction 'iswalpha_l' loaded at 56f28270\nFunction '__towlower_l' loaded at 56f28880\nFunction '_L_unlock_111' loaded at 56f28cd6\nFunction 'getspent_r' loaded at 56f29440\nFunction '_nss_files_parse_spent' loaded at 56f298b0\nFunction '_L_lock_34' loaded at 56f2a3eb\nFunction '__argp_fmtstream_update' loaded at 56f2a500\nFunction '__argp_fmtstream_puts' loaded at 56f2af00\nFunction 'until_short' loaded at 56f2b2d0\nFunction 'usage_argful_short_opt' loaded at 56f2c270\nFunction 'argp_help' loaded at 56f2e4a0\nFunction 'argp_usage' loaded at 56f2f580\nFunction 'pthread_attr_setschedparam' loaded at 56f2f7d0\nFunction 'pthread_cond_signal' loaded at 56f2fa10\nFunction 'pthread_self' loaded at 56f2fc50\nFunction '_L_lock_116' loaded at 56f2ff5a\nFunction 'inet_ntop4' loaded at 56f30490\nFunction 'net_mask' loaded at 56f30ec0\nFunction 'skip_ws' loaded at 56f324c0\nFunction '_L_unlock_68' loaded at 56f3306e\nFunction '__nss_configure_lookup' loaded at 56f33a70\nFunction '__nss_getent' loaded at 56f34000\nFunction '__nss_group_lookup' loaded at 56f34eb0\nFunction '__backtrace' loaded at 56f35490\nFunction '__sprintf_chk' loaded at 56f35e60\nFunction '_L_unlock_99' loaded at 56f362af\nFunction '_L_unlock_302' loaded at 56f36680\nFunction '__pread64_chk' loaded at 56f36be0\nFunction '__wmemcpy_chk' loaded at 56f36ee0\nFunction '__vswprintf_chk' loaded at 56f37220\nFunction '_L_lock_35' loaded at 56f376ca\nFunction '_L_unlock_247' loaded at 56f379a7\nFunction '__wcsnrtombs_chk' loaded at 56f37c70\nFunction '_L_unlock_63' loaded at 56f38084\nFunction '__h_errno_location' loaded at 56f38530\nFunction '_L_unlock_149' loaded at 56f38ddb\nFunction '_L_unlock_73' loaded at 56f396ee\nFunction '_L_lock_28' loaded at 56f39c55\nFunction '_L_lock_148' loaded at 56f39fee\nFunction '_L_lock_24' loaded at 56f3a5ed\nFunction '_L_unlock_237' loaded at 56f3a8ce\nFunction '_L_lock_27' loaded at 56f3b036\nFunction '_L_unlock_72' loaded at 56f3b54e\nFunction '_L_unlock_111' loaded at 56f3b7b6\nFunction '_L_unlock_167' loaded at 56f3bbce\nFunction 'ether_ntoa_r' loaded at 56f3c510\nFunction 'rresvport_af' loaded at 56f3d200\nFunction '__internal_setnetgrent_reuse' loaded at 56f3ed70\nFunction '_L_unlock_711' loaded at 56f3f622\nFunction '_L_lock_28' loaded at 56f3f9ad\nFunction '_L_lock_25' loaded at 56f3fc16\nFunction 'if_nameindex' loaded at 56f40ba0\nFunction 'inet6_option_init' loaded at 56f41ee0\nFunction 'setsourcefilter' loaded at 56f42720\nFunction 'authnone_create_once' loaded at 56f43340\nFunction 'xdr_authunix_parms' loaded at 56f43b70\nFunction 'clntraw_geterr' loaded at 56f448e0\nFunction 'clnttcp_freeres' loaded at 56f44fc0\nFunction 'clntudp_freeres' loaded at 56f45930\nFunction 'pmap_unset' loaded at 56f46810\nFunction 'pmap_rmtcall' loaded at 56f47720\nFunction '__rpc_thread_variables' loaded at 56f480a0\nFunction 'svcerr_weakauth' loaded at 56f483b0\nFunction 'xprt_unregister' loaded at 56f48920\nFunction 'svcraw_getargs' loaded at 56f48e30\nFunction 'svctcp_freeargs' loaded at 56f495e0\nFunction 'svctcp_rendezvous_abort' loaded at 56f49c40\nFunction 'svcudp_recv' loaded at 56f4a4f0\nFunction 'xdr_u_longlong_t' loaded at 56f4ab90\nFunction 'xdr_wrapstring' loaded at 56f4afb0\nFunction 'xdrmem_setpos' loaded at 56f4b520\nFunction 'skip_input_bytes' loaded at 56f4b7c0\nFunction 'xdrrec_getbytes' loaded at 56f4bb50\nFunction 'xdrstdio_create' loaded at 56f4c150\nFunction 'xdrstdio_getpos' loaded at 56f4c400\nFunction 'x_destroy' loaded at 56f4c790\nFunction 'xdr_authdes_cred' loaded at 56f4d030\nFunction 'key_get_conv' loaded at 56f4e400\nFunction '_L_unlock_445' loaded at 56f4e8df\nFunction 'xdr_keystatus' loaded at 56f4ec90\nFunction '_svcauth_des' loaded at 56f4f730\nFunction 'clntunix_create' loaded at 56f50340\nFunction 'svcunixfd_create' loaded at 56f50ed0\nFunction '_create_xid' loaded at 56f516a0\nFunction 'xdr_uint8_t' loaded at 56f51ac0\nFunction '__nscd_gethostbyname2_r' loaded at 56f52fd0\nFunction 'get_mapping' loaded at 56f53dc0\nFunction 'getutent' loaded at 56f546c0\nFunction 'endutent' loaded at 56f549f0\nFunction 'getutline' loaded at 56f54b40\nFunction '__utmp_equal' loaded at 56f55040\nFunction 'updwtmp' loaded at 56f55fb0\nFunction 'setutxent' loaded at 56f56cb0\nFunction 'dl_iterate_phdr' loaded at 56f56e70\nFunction '__libc_dlopen_mode' loaded at 56f57510\nFunction 'fde_unencoded_compare' loaded at 56f57b40\nFunction '__register_frame' loaded at 56f58350\nFunction '_L_lock_136' loaded at 56f59129\nFunction '_Unwind_GetIP' loaded at 56f591e0\nFunction 'read_uleb128' loaded at 56f59b50\nFunction '_IO_old_cookie_seek' loaded at 56f59eb0\nFunction '_L_lock_68' loaded at 56f5a7ea\nFunction '_L_lock_36' loaded at 56f5ab9c\nFunction '_IO_file_xsputn' loaded at 56f5af40\nFunction '_IO_old_file_finish' loaded at 56f5bae0\nFunction 'versionsort64' loaded at 56f5c090\nFunction 'sched_setaffinity' loaded at 56f5d210\nFunction 'getspent_r' loaded at 56f5d550\nFunction 'gethostbyname2_r' loaded at 56f5d7f0\nFunction 'getservbyport_r' loaded at 56f5dbe0\nFunction 'free_mem' loaded at 56f5dff0\nFunction 'free_mem' loaded at 56f5e5c0\nFunction '_L_unlock_44' loaded at 56f5e905\nFunction '__rpc_thread_destroy' loaded at 56f5ec70\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 6]- /disk/PinTools/Utils/obj-ia32/cp-pin    \n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 5]- /lib/ld-linux.so.2                      \n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 4]- /usr/lib/libstdc++.so.6                 \n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 3]- /lib/libm.so.6                          \n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 2]- /lib/libgcc_s.so.1                      \n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 1]- /lib/libc.so.6                          \n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Replay/ia32_cross_os_replay.record": "L '/disk/PinTools/Utils/obj-ia32/cp-pin' 8048ad8 781 0 1 \n\t'main' 8048d90\nEND_RTN_LIST\nL '/lib/ld-linux.so.2' 555557c0 157ab 55555000 0 \n\t'rtld_lock_default_unlock_recursive' 555558c0\n\t'relocate_doit' 55556770\n\t'fillin_rpath' 5555a3c0\n\t'decompose_rpath' 5555c9f0\n\t'do_lookup_x' 5555e380\n\t'_dl_map_object_deps' 55560e40\n\t'_dl_sort_fini' 55562ba0\n\t'match_symbol' 55563930\n\t'_dl_next_tls_modid' 55564e10\n\t'_dl_tls_setup' 55565940\n\t'_dl_runtime_resolve' 55567930\n\t'__assert_fail' 55568870\n\t'calloc' 55568f60\n\t'profil_counter' 55569560\n\t'__lseek' 555698d0\n\t'__madvise' 55569e50\n\t'strlen' 5556a270\n\t'__i686.get_pc_thunk.cx' 5556ae47\nEND_RTN_LIST\nL '/usr/lib/libstdc++.so.6' 56d7182c 7c6b5 56d37000 0 \n\t'_ZN9__gnu_cxx17__pool_alloc_base12_M_get_mutexEv' 56d760f0\n\t'_ZN9__gnu_cxx6__poolILb1EE13_M_initializeEPFvPvE' 56d774d0\n\t'_ZNKSt7codecvtIwc11__mbstate_tE16do_always_noconvEv' 56d78800\n\t'_ZNSt7codecvtIcc11__mbstate_tEC1Ej' 56d78c10\n\t'_ZNSbIwSt11char_traitsIwESaIwEE7_M_copyEPwPKwj' 56d78f70\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE15_M_check_lengthEjjPKc' 56d791c0\n\t'_ZNKSt14basic_ofstreamIwSt11char_traitsIwEE7is_openEv' 56d79900\n\t'_ZStlsIdcSt11char_traitsIcEERSt13basic_ostreamIT0_T1_ES6_RKSt7complexIT_E' 56d7a7f0\n\t'_ZNKSt5ctypeIcE9do_narrowEPKcS2_cPc' 56d7bdf0\n\t'_ZNSt5ctypeIcED2Ev' 56d7c340\n\t'_ZNSt12ctype_bynameIwEC2EPKcj' 56d7c880\n\t'_ZN11__gnu_debug19_Safe_sequence_base7_M_swapERS0_' 56d7da10\n\t'_ZSt18__throw_bad_typeidv' 56d7de60\n\t'_ZNSt12out_of_rangeD0Ev' 56d7e0f0\n\t'_ZSt23__throw_underflow_errorPKc' 56d7e480\n\t'_ZNSt8ios_base6xallocEv' 56d7edd0\n\t'_ZNSt8ios_base7failureC1ERKSs' 56d7f3c0\n\t'_ZNSt8ios_base7_M_initEv' 56d808d0\n\t'_ZNSt6localeC2ERKS_' 56d80b10\n\t'_ZNSt6locale5_ImplD2Ev' 56d81310\n\t'_ZNSt6locale5_ImplC2Ej' 56d81e00\n\t'_ZNSt6localeC2ERKS_S1_i' 56d84170\n\t'_ZNSt11logic_errorC2ERKSs' 56d86830\n\t'_ZNSt13runtime_errorC2ERKSs' 56d86af0\n\t'_ZNSt13runtime_errorD0Ev' 56d86e20\n\t'_ZNSt12strstreambuf7_M_freeEPc' 56d870e0\n\t'_ZNSt12strstreambuf9underflowEv' 56d87330\n\t'_ZNSt12strstreambufC2EPaiS0_' 56d87c80\n\t'_ZNSt12strstreambufC1EPKhi' 56d88450\n\t'_ZNSt10ostrstreamD2Ev' 56d88cb0\n\t'_ZNSt10istrstreamD1Ev' 56d89480\n\t'_ZNSt9strstreamD0Ev' 56d89bf0\n\t'_ZSt18_Rb_tree_decrementPKSt18_Rb_tree_node_base' 56d8a2d0\n\t'_ZNSaIwED1Ev' 56d8a8c0\n\t'_ZNSt13basic_filebufIcSt11char_traitsIcEE13_M_set_bufferEi' 56d8b6c0\n\t'_ZNSt13basic_filebufIwSt11char_traitsIwEE27_M_allocate_internal_bufferEv' 56d8b8b0\n\t'_ZNSt13basic_filebufIwSt11char_traitsIwEE9pbackfailEj' 56d8be20\n\t'_ZNSt13basic_filebufIcSt11char_traitsIcEE6xsgetnEPci' 56d8d060\n\t'_ZNSt14basic_ifstreamIwSt11char_traitsIwEE7is_openEv' 56d8e080\n\t'_ZNSt13basic_filebufIwSt11char_traitsIwEED0Ev' 56d8e980\n\t'_ZNSt13basic_filebufIcSt11char_traitsIcEE9showmanycEv' 56d8f250\n\t'_ZNSt14basic_ofstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode' 56d8f860\n\t'_ZNSt14basic_ofstreamIwSt11char_traitsIwEEC2Ev' 56d8fe60\n\t'_ZNSt14basic_ofstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode' 56d904d0\n\t'_ZNSt14basic_ifstreamIcSt11char_traitsIcEEC1Ev' 56d90d40\n\t'_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev' 56d91430\n\t'_ZTv0_n12_NSt13basic_fstreamIcSt11char_traitsIcEED0Ev' 56d91dc0\n\t'_ZNSt13basic_fstreamIwSt11char_traitsIwEED2Ev' 56d92260\n\t'_ZNKSt9basic_iosIwSt11char_traitsIwEE7rdstateEv' 56d93680\n\t'_ZNSt9basic_iosIcSt11char_traitsIcEEC1Ev' 56d938f0\n\t'_ZNSt9basic_iosIcSt11char_traitsIcEED2Ev' 56d93c00\n\t'_ZNKSt9basic_iosIwSt11char_traitsIwEE3badEv' 56d93fe0\n\t'_ZNSt9basic_iosIwSt11char_traitsIwEE10exceptionsESt12_Ios_Iostate' 56d941d0\n\t'_ZNSt9basic_iosIwSt11char_traitsIwEE5imbueERKSt6locale' 56d944a0\n\t'_ZNSt14basic_iostreamIwSt11char_traitsIwEEC1Ev' 56d94f60\n\t'_ZNSdC1Ev' 56d95280\n\t'_ZNSirsEPFRSt8ios_baseS0_E' 56d954d0\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEErsEPFRSt8ios_baseS4_E' 56d95600\n\t'_ZStrsISt11char_traitsIcEERSt13basic_istreamIcT_ES5_Pa' 56d958a0\n\t'_ZStrsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_St12_Setiosflags' 56d95b40\n\t'_ZTv0_n12_NSt13basic_istreamIwSt11char_traitsIwEED1Ev' 56d95e20\n\t'_ZStrsIcSt11char_traitsIcEERSt13basic_istreamIT_T0_ES6_RS3_' 56d96650\n\t'_ZNSi3getERSt15basic_streambufIcSt11char_traitsIcEE' 56d96fa0\n\t'_ZNSirsERy' 56d97a40\n\t'_ZSt2wsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_' 56d987a0\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEE3getERSt15basic_streambufIwS1_Ew' 56d99390\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEErsERf' 56d99e80\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEE6sentryC2ERS2_b' 56d9abf0\n\t'_ZNKSt10moneypunctIcLb0EE13thousands_sepEv' 56d9c540\n\t'_ZNKSt10moneypunctIcLb0EE14do_frac_digitsEv' 56d9c6c0\n\t'_ZNKSt10moneypunctIcLb1EE10pos_formatEv' 56d9c890\n\t'_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' 56d9cb50\n\t'_ZNSt16__numpunct_cacheIcEC1Ej' 56d9cda0\n\t'_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRe' 56d9d200\n\t'_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPKv' 56d9d5f0\n\t'_ZNSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEEC2Ej' 56d9d850\n\t'_ZNKSt8messagesIcE4openERKSsRKSt6locale' 56d9db80\n\t'_ZNSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED0Ev' 56d9dfc0\n\t'_ZNSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEED1Ev' 56d9e1e0\n\t'_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED2Ev' 56d9e3f0\n\t'_ZSt9has_facetISt8numpunctIcEEbRKSt6locale' 56d9e810\n\t'_ZSt9use_facetISt10moneypunctIcLb0EEERKT_RKSt6locale' 56d9ebb0\n\t'_ZNSt7collateIcEC2Ej' 56d9ef10\n\t'_ZNSt8messagesIcED1Ev' 56d9f290\n\t'_ZNSt16__numpunct_cacheIcED2Ev' 56d9f6d0\n\t'_ZNSt15numpunct_bynameIcED2Ev' 56d9fb30\n\t'_ZNSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' 56d9ffb0\n\t'_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' 56da0310\n\t'_ZNSt15messages_bynameIcEC2EPKcj' 56da07c0\n\t'_ZNSt11__timepunctIcEC2Ej' 56da0fc0\n\t'_ZNKSt8numpunctIcE12do_falsenameEv' 56da12f0\n\t'_ZNSt10moneypunctIcLb1EEC2EP15__locale_structPKcj' 56da17f0\n\t'_ZNKSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPK2tmPKcSB_' 56da1c80\n\t'_ZNSt15numpunct_bynameIcEC1EPKcj' 56da2180\n\t'_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE14do_get_weekdayES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm' 56da3b00\n\t'_ZNKSt7collateIcE12do_transformEPKcS2_' 56da68d0\n\t'_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' 56dac390\n\t'_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE15_M_insert_floatIeEES3_S3_RSt8ios_baseccT_' 56daeb10\n\t'_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE6do_putES3_RSt8ios_basecm' 56db0310\n\t'_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRm' 56db2f10\n\t'_ZStlsIcSt11char_traitsIcESaIcEERSt13basic_ostreamIT_T0_ES7_RKSbIS4_S5_T1_E' 56db5520\n\t'_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEPFRS2_S3_E' 56db5a10\n\t'_ZNSoC2EPSt15basic_streambufIcSt11char_traitsIcEE' 56db5ba0\n\t'_ZNSoC1Ev' 56db5e20\n\t'_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_' 56db6470\n\t'_ZNSoD2Ev' 56db6a40\n\t'_ZNSolsEs' 56db6d50\n\t'_ZNSo5writeEPKci' 56db7af0\n\t'_ZNSolsEx' 56db8a50\n\t'_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEi' 56db9e90\n\t'_ZSt4endsIwSt11char_traitsIwEERSt13basic_ostreamIT_T0_ES6_' 56dbb170\n\t'_ZNKSt19basic_ostringstreamIcSt11char_traitsIcESaIcEE5rdbufEv' 56dbba10\n\t'_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE6setbufEPwi' 56dbbd40\n\t'_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE3strERKSbIwS1_S2_E' 56dbc7f0\n\t'_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode' 56dbcc90\n\t'_ZNKSt18basic_stringstreamIcSt11char_traitsIcESaIcEE3strEv' 56dbd7f0\n\t'_ZNKSt19basic_istringstreamIwSt11char_traitsIwESaIwEE3strEv' 56dbdfc0\n\t'_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEED2Ev' 56dbe670\n\t'_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode' 56dbee50\n\t'_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode' 56dbf9a0\n\t'_ZTv0_n12_NSt19basic_istringstreamIwSt11char_traitsIwESaIwEED0Ev' 56dc0180\n\t'_ZTv0_n12_NSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev' 56dc0a90\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEE10pubseekposESt4fposI11__mbstate_tESt13_Ios_Openmode' 56dc12e0\n\t'_ZNKSt15basic_streambufIcSt11char_traitsIcEE4pptrEv' 56dc1420\n\t'_ZNSt15basic_streambufIwSt11char_traitsIwEE10pubseekoffExSt12_Ios_SeekdirSt13_Ios_Openmode' 56dc14f0\n\t'_ZNKSt15basic_streambufIwSt11char_traitsIwEE5pbaseEv' 56dc1680\n\t'_ZNSt15basic_streambufIwSt11char_traitsIwEEaSERKS2_' 56dc1740\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEEC1Ev' 56dc1a40\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEED1Ev' 56dc1ce0\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEE7seekposESt4fposI11__mbstate_tESt13_Ios_Openmode' 56dc1e40\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEE5sputcEc' 56dc2150\n\t'_ZNKSs7_M_dataEv' 56dc26e0\n\t'_ZNKSs4sizeEv' 56dc2820\n\t'_ZNSs4_Rep15_M_set_sharableEv' 56dc28e0\n\t'_ZNKSs5emptyEv' 56dc2d70\n\t'_ZNKSs16find_last_not_ofEcj' 56dc3010\n\t'_ZNKSs13find_first_ofEcj' 56dc33e0\n\t'_ZNKSs4rendEv' 56dc3740\n\t'_ZNKSs7compareEjjRKSs' 56dc3b60\n\t'_ZNSsC2EPKcjRKSaIcE' 56dc4040\n\t'_ZNSsC1IPcEET_S1_RKSaIcE' 56dc4470\n\t'_ZNSs6appendEPKcj' 56dc4a00\n\t'_ZNSs6assignEPKc' 56dc5100\n\t'_ZNSs6insertEN9__gnu_cxx17__normal_iteratorIPcSsEEjc' 56dc54e0\n\t'_ZNSs7_M_leakEv' 56dc59b0\n\t'_ZNSsD2Ev' 56dc5d10\n\t'_ZNSs7replaceEjjPKc' 56dc63b0\n\t'_ZNSt8valarrayIjED2Ev' 56dc6700\n\t'_ZNKSt10moneypunctIwLb0EE13positive_signEv' 56dc6dc0\n\t'_ZNKSt10moneypunctIwLb1EE13decimal_pointEv' 56dc6f70\n\t'_ZNKSt10moneypunctIwLb1EE16do_thousands_sepEv' 56dc7100\n\t'_ZNKSt8numpunctIwE13decimal_pointEv' 56dc74b0\n\t'_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRt' 56dc76f0\n\t'_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE3putES3_RSt8ios_basewb' 56dc7b10\n\t'_ZNKSt11__timepunctIwE20_M_date_time_formatsEPPKw' 56dc7ea0\n\t'_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10date_orderEv' 56dc8130\n\t'_ZNKSt8messagesIwE8do_closeEi' 56dc8430\n\t'_ZNSt8time_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED0Ev' 56dc87b0\n\t'_ZNSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEED1Ev' 56dc89d0\n\t'_ZSt9has_facetISt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEEbRKSt6locale' 56dc8cb0\n\t'_ZSt9has_facetISt7codecvtIwc11__mbstate_tEEbRKSt6locale' 56dc9110\n\t'_ZSt9use_facetISt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEERKT_RKSt6locale' 56dc9470\n\t'_ZNSt14codecvt_bynameIwc11__mbstate_tED1Ev' 56dc97d0\n\t'_ZNSt15messages_bynameIwED0Ev' 56dc9bb0\n\t'_ZNSt18__moneypunct_cacheIwLb1EED1Ev' 56dca010\n\t'_ZNSt17moneypunct_bynameIwLb1EED1Ev' 56dca3f0\n\t'_ZNSt8numpunctIwEC1EP15__locale_structj' 56dca870\n\t'_ZNSt18__moneypunct_cacheIwLb0EEC2Ej' 56dcabf0\n\t'_ZNSt17__timepunct_cacheIwEC1Ej' 56dcb110\n\t'_ZNKSt10moneypunctIwLb0EE16do_negative_signEv' 56dcb8b0\n\t'_ZNSt10moneypunctIwLb1EEC1EPSt18__moneypunct_cacheIwLb1EEj' 56dcbe10\n\t'_ZNSt8messagesIwEC1EP15__locale_structPKcj' 56dcc1f0\n\t'_ZNSt15time_get_bynameIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEC2EPKcj' 56dcc8d0\n\t'_ZNSt17moneypunct_bynameIwLb0EEC2EPKcj' 56dccd40\n\t'_ZNSt14collate_bynameIwEC2EPKcj' 56dcf9b0\n\t'_ZNKSt9money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb1EEES3_S3_RSt8ios_basewRKSbIwS2_SaIwEE' 56dd1030\n\t'_ZNKSt9money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10_M_extractILb0EEES3_S3_S3_RSt8ios_baseRSt12_Ios_IostateRSs' 56dd4110\n\t'_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE13_M_insert_intIxEES3_S3_RSt8ios_basewT_' 56dd7b60\n\t'_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRx' 56dda050\n\t'_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_putES3_RSt8ios_basewb' 56ddcfc0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE5beginEv' 56ddd810\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE4_Rep12_M_is_sharedEv' 56ddd8e0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE4findEPKwjj' 56dddca0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE17find_first_not_ofEwj' 56dddf40\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE13find_first_ofEPKwjj' 56dde330\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE12find_last_ofEPKwj' 56dde6a0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE7compareEjjRKS2_jj' 56dde9c0\n\t'_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_jjRKS1_' 56ddefa0\n\t'_ZNSbIwSt11char_traitsIwESaIwEEC1EPKwRKS1_' 56ddf3b0\n\t'_ZNSbIwSt11char_traitsIwESaIwEE9push_backEw' 56ddf8d0\n\t'_ZNSbIwSt11char_traitsIwESaIwEED2Ev' 56ddfe30\n\t'_ZNSbIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPwS2_EEw' 56de0420\n\t'_ZNSbIwSt11char_traitsIwESaIwEE6insertEjRKS2_jj' 56de0910\n\t'_ZNSbIwSt11char_traitsIwESaIwEE6rbeginEv' 56de0c30\n\t'_ZNSbIwSt11char_traitsIwESaIwEE7replaceEjjPKw' 56de1210\n\t'_ZNKSt7codecvtIwc11__mbstate_tE9do_lengthERS0_PKcS4_j' 56de15e0\n\t'_ZNKSt5ctypeIwE11do_scan_notEtPKwS2_' 56de1dc0\n\t'_ZNKSt5ctypeIwE10do_toupperEw' 56de21e0\n\t'_ZNSt10moneypunctIwLb0EED2Ev' 56de2ab0\n\t'_ZNSt10moneypunctIcLb0EE24_M_initialize_moneypunctEP15__locale_structPKc' 56de3090\n\t'_ZNSt8numpunctIwE22_M_initialize_numpunctEP15__locale_struct' 56de4390\n\t'_ZNSt12__basic_fileIcE4syncEv' 56de5a80\n\t'_ZNSt12__basic_fileIcE6xsgetnEPci' 56de5f30\n\t'_ZdlPvRKSt9nothrow_t' 56de62c0\n\t'__cxa_begin_catch' 56de66c0\n\t'__cxa_call_unexpected' 56de6d30\n\t'__cxa_guard_release' 56de7630\n\t'__cxa_pure_virtual' 56de7970\n\t'_ZN10__cxxabiv117__class_type_infoD0Ev' 56de7b30\n\t'_ZNSt10bad_typeidD1Ev' 56de7d50\n\t'_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_' 56de8060\n\t'_ZN10__cxxabiv117__pbase_type_infoD2Ev' 56de8a60\n\t'_ZN10__cxxabiv120__function_type_infoD0Ev' 56de8c70\n\t'_ZNK10__cxxabiv119__pointer_type_info15__pointer_catchEPKNS_17__pbase_type_infoEPPvj' 56de8ef0\n\t'__cxa_vec_new' 56de95e0\nEND_RTN_LIST\nL '/lib/libm.so.6' 56e2e314 1a5dd 56e2b000 0 \n\t'__i686.get_pc_thunk.bx' 56e2e4c7\n\t'fegetenv' 56e30a90\n\t'__ieee754_asin' 56e30db0\n\t'__ieee754_y0' 56e314e0\n\t'__ieee754_log10' 56e32c10\n\t'cbrt' 56e335f0\n\t'logb' 56e340d0\n\t'asin' 56e34840\n\t'hypot' 56e34e30\n\t'log10' 56e35560\n\t'nan' 56e35b00\n\t'creal' 56e35f10\n\t'csin' 56e36b80\n\t'clog10' 56e37d60\n\t'__finite' 56e382b0\n\t'__ieee754_atan2f' 56e386d0\n\t'ponef' 56e38ee0\n\t'__ieee754_remainderf' 56e3a280\n\t'cbrtf' 56e3ab60\n\t'logbf' 56e3b4d0\n\t'asinf' 56e3b9e0\n\t'hypotf' 56e3bff0\n\t'log10f' 56e3c6c0\n\t'nanf' 56e3cc50\n\t'crealf' 56e3cf60\n\t'csinf' 56e3dab0\n\t'clog10f' 56e3e9d0\n\t'finitef' 56e3ee00\n\t'__ieee754_atan2l' 56e3f320\n\t'pone' 56e3fff0\n\t'__ieee754_remainderl' 56e41730\n\t'cbrtl' 56e41ca0\n\t'logbl' 56e42800\n\t'atan2l' 56e42db0\n\t'y0l' 56e43420\n\t'powl' 56e43b90\n\t'truncl' 56e44180\n\t'cabsl' 56e444c0\n\t'ctanl' 56e45540\n\t'fmal' 56e466c0\n\t'copysignl' 56e46ae0\n\t'__divdc3' 56e48190\nEND_RTN_LIST\nL '/lib/libgcc_s.so.1' 56e5a4fc 7c25 56e59000 0 \n\t'__ashldi3' 56e5a8e0\n\t'__subvsi3' 56e5abe0\n\t'__ctzdi2' 56e5b030\n\t'__mulxc3' 56e5bd70\n\t'__fixdfdi' 56e5d020\n\t'__udivmoddi4' 56e5d8e0\n\t'_Unwind_GetGR' 56e5dcd0\n\t'__register_frame_info' 56e60260\n\t'.fini' 56e62104\nEND_RTN_LIST\nL '/lib/libc.so.6' 56e795d8 e5747 56e64000 0 \n\t'gnu_get_libc_version' 56e79980\n\t'__divdi3' 56e79ee0\n\t'__gconv_close' 56e7adc0\n\t'__gconv_find_transform' 56e7bab0\n\t'add_alias' 56e7c180\n\t'__gconv_transform_ascii_internal' 56e7e080\n\t'__gconv_translit_find' 56e81e20\n\t'__gconv_lookup_cache' 56e82780\n\t'_L_unlock_996' 56e838fc\n\t'rangecmp' 56e84640\n\t'__duplocale' 56e85ad0\n\t'__collseq_table_lookup' 56e85f30\n\t'isdigit' 56e86400\n\t'__isascii_l' 56e866a0\n\t'ispunct_l' 56e86810\n\t'set_binding_values' 56e869d0\n\t'__dcigettext' 56e87a10\n\t'dcngettext' 56e88220\n\t'_nl_expand_alias' 56e89d40\n\t'new_exp_2' 56e8a920\n\t'finite' 56e8bd40\n\t'copysignf' 56e8c0f0\n\t'modfl' 56e8c3b0\n\t'__libc_longjmp' 56e8c810\n\t'sigpending' 56e8cd90\n\t'sigpause' 56e8d1f0\n\t'sigaddset' 56e8d5a0\n\t'__libc_current_sigrtmax_private' 56e8d8f0\n\t'sigset' 56e8de10\n\t'_quicksort' 56e8e360\n\t'_L_lock_22' 56e8f45a\n\t'exit' 56e8f530\n\t'div' 56e8f9d0\n\t'initstate' 56e8fef0\n\t'setstate_r' 56e90070\n\t'mrand48' 56e90610\n\t'jrand48_r' 56e908d0\n\t'strtoll' 56e90ca0\n\t'strtoull_l' 56e92390\n\t'__strtof_l' 56e948e0\n\t'do_system' 56e99720\n\t'realpath' 56e99cf0\n\t'__xpg_basename' 56e9b780\n\t'wcstoimax' 56e9c020\n\t'__mpn_add_n' 56e9c4a0\n\t'__mpn_impn_sqr_n_basecase' 56e9cfa0\n\t'__mpn_construct_double' 56e9ddf0\n\t'_itowa' 56e9e690\n\t'_L_unlock_11056' 56ea35aa\n\t'printf_size_info' 56ea77b0\n\t'group_number' 56ea8220\n\t'vfscanf' 56eb2050\n\t'perror_internal' 56eb6cd0\n\t'__path_search' 56eb7770\n\t'ftrylockfile' 56eb7ea0\n\t'_IO_file_doallocate' 56eb8b50\n\t'_L_unlock_161' 56eb9245\n\t'__fopen_internal' 56eb9690\n\t'_L_lock_41' 56eb9bdc\n\t'_L_unlock_185' 56eb9ecf\n\t'_L_lock_47' 56eba57b\n\t'_IO_proc_close' 56ebaa70\n\t'_L_unlock_110' 56ebb13e\n\t'_IO_setbuffer' 56ebb4a0\n\t'_L_unlock_95' 56ebb894\n\t'_L_unlock_105' 56ebbda2\n\t'getwchar' 56ebc020\n\t'_L_lock_43' 56ebc4e9\n\t'putwc' 56ebc940\n\t'_L_unlock_81' 56ebcc61\n\t'vswprintf' 56ebcf20\n\t'_IO_sungetwc' 56ebd360\n\t'save_for_wbackup' 56ebd7c0\n\t'_IO_wstr_finish' 56ebe140\n\t'_IO_wdo_write' 56ebf2a0\n\t'do_out' 56ebfb00\n\t'_L_lock_29' 56ec0220\n\t'_L_lock_30' 56ec04ae\n\t'_L_lock_29' 56ec08df\n\t'_L_lock_30' 56ec0c7e\n\t'_IO_strn_overflow' 56ec1080\n\t'ftello' 56ec1670\n\t'ftello64' 56ec1b60\n\t'__fpending' 56ec1e00\n\t'_L_unlock_17' 56ec25f2\n\t'_L_lock_29' 56ec2814\n\t'_IO_file_sync_mmap' 56ec2d30\n\t'_IO_do_write' 56ec3a10\n\t'_IO_file_setbuf_mmap' 56ec44a0\n\t'flush_cleanup' 56ec4fa0\n\t'_IO_sgetn' 56ec55a0\n\t'_IO_adjust_column' 56ec5960\n\t'_IO_default_seek' 56ec5fc0\n\t'_IO_list_lock' 56ec6070\n\t'_IO_default_doallocate' 56ec67e0\n\t'_L_unlock_280' 56ec6c3e\n\t'_L_lock_1784' 56ec6cca\n\t'_IO_str_pbackfail' 56ec6f60\n\t'__failing_morecore' 56ec75a0\n\t'ptmalloc_init' 56ec7ef0\n\t'cfree' 56ec91a0\n\t'realloc_check' 56ecaaa0\n\t'realloc_hook_ini' 56ecbad0\n\t'_L_unlock_2466' 56ecc04a\n\t'_L_unlock_4424' 56ecc0e2\n\t'_L_unlock_8320' 56ecc17a\n\t'_L_lock_9316' 56ecc20f\n\t'_L_unlock_9886' 56ecc29b\n\t'_L_unlock_10772' 56ecc327\n\t'mprobe' 56ecc510\n\t'mtrace' 56eccc10\n\t'_L_lock_751' 56ecd4f3\n\t'_obstack_memory_used' 56ecd8f0\n\t'__strdup' 56ecdfd0\n\t'strpbrk' 56ece820\n\t'bcmp' 56ecf180\n\t'ffsll' 56ecfd90\n\t'_wordcopy_fwd_aligned' 56ed0310\n\t'rawmemchr' 56ed0b90\n\t'argz_insert' 56ed1180\n\t'envz_add' 56ed1970\n\t'__memset_gcn_by4' 56ed3700\n\t'__strncat_g' 56ed3950\n\t'__strcspn_g' 56ed3b40\n\t'__strcspn_c1' 56ed3f70\n\t'__strsep_3c' 56ed4270\n\t'__xpg_strerror_r' 56ed4680\n\t'wcsncpy' 56ed4aa0\n\t'wmemset' 56ed4f80\n\t'mbsrtowcs' 56ed58e0\n\t'wcstoll' 56ed6550\n\t'____wcstol_l_internal' 56ed6870\n\t'____wcstod_l_internal' 56ed8040\n\t'wcscoll' 56ede440\n\t'_nl_cleanup_ctype' 56ee0000\n\t'asctime' 56ee0c60\n\t'guess_time_tm' 56ee0eb0\n\t'__tzstring' 56ee1be0\n\t'_L_unlock_2123' 56ee287f\n\t'ftime' 56ee39c0\n\t'memcpy_uppcase' 56ee68e0\n\t'_nl_init_alt_digit' 56eeab60\n\t'_nl_cleanup_time' 56eeafe0\n\t'_L_unlock_119' 56eeb4ac\n\t'alphasort' 56eeb840\n\t'_L_lock_246' 56eebee0\n\t'_L_lock_27' 56eec50a\n\t'getgrgid' 56eecca0\n\t'_L_unlock_290' 56eed201\n\t'getgrgid_r' 56eed4e0\n\t'_L_unlock_116' 56eee03e\n\t'_L_lock_25' 56eee5d6\n\t'_L_unlock_233' 56eee8bd\n\t'times' 56eef2d0\n\t'pause' 56eefb10\n\t'execle' 56ef0120\n\t'getegid' 56ef09a0\n\t'getsid' 56ef0c60\n\t'setlogin' 56ef1140\n\t'handle_intel' 56ef1a00\n\t'collated_compare' 56ef3be0\n\t'end_pattern' 56ef5f50\n\t're_node_set_contains' 56efa780\n\t'find_subexp_node' 56efad00\n\t'lower_subexps' 56efb590\n\t'free_dfa_content' 56efb9d0\n\t'check_arrival_expand_ecl' 56efc4b0\n\t're_node_set_init_copy' 56efd1f0\n\t'build_upper_buffer' 56efe6f0\n\t'check_arrival' 56efffa0\n\t'parse_bracket_exp' 56f02cf0\n\t'set_regs' 56f05f40\n\t're_exec' 56f08f60\n\t'_getopt_long_only_r' 56f0a650\n\t'__sched_get_priority_min' 56f0a940\n\t'in6aicmp' 56f0ad30\n\t'_L_lock_9088' 56f0e70d\n\t'eval_expr' 56f0ed40\n\t'pread' 56f12850\n\t'posix_spawn_file_actions_addclose' 56f12cb0\n\t'posix_spawnattr_setpgroup' 56f12fa0\n\t'posix_spawnattr_setschedparam' 56f13760\n\t'__xstat64' 56f13b70\n\t'fstatfs64' 56f143f0\n\t'mkdir' 56f14a00\n\t'__close' 56f15160\n\t'__fcntl_nocancel' 56f15750\n\t'creat64' 56f15cc0\n\t'getttyname' 56f162f0\n\t'readlinkat' 56f17050\n\t'object_compare' 56f184b0\n\t'fts_palloc' 56f19850\n\t'posix_fadvise' 56f1afc0\n\t'__internal_statvfs' 56f1bea0\n\t'tcsetpgrp' 56f1c4c0\n\t'setrlimit64' 56f1c8f0\n\t'__sbrk' 56f1cdb0\n\t'setregid' 56f1d440\n\t'___newselect_nocancel' 56f1d84a\n\t'sethostid' 56f1de50\n\t'usleep' 56f1e150\n\t'getfsspec' 56f1e570\n\t'_L_lock_1062' 56f1f144\n\t'ftruncate64' 56f1f5c0\n\t'endusershell' 56f1fcc0\n\t'openlog_internal' 56f20390\n\t'_L_lock_1085' 56f20c4c\n\t'madvise' 56f21070\n\t'fcvt_r' 56f21420\n\t'hsearch_r' 56f22060\n\t'tsearch' 56f22a40\n\t'errx' 56f23040\n\t'dirname' 56f238b0\n\t'listxattr' 56f23d30\n\t'vm86' 56f24080\n\t'gnu_dev_major' 56f24450\n\t'capget' 56f24730\n\t'inotify_add_watch' 56f24a30\n\t'prctl' 56f24d60\n\t'getpeername' 56f250c0\n\t'setsockopt' 56f25500\n\t'__libc_msgsnd' 56f259a0\n\t'shmget' 56f25f10\n\t'pc_to_index' 56f26b80\n\t'iswxdigit' 56f27410\n\t'iswpunct' 56f27c50\n\t'iswalpha_l' 56f28270\n\t'__towlower_l' 56f28880\n\t'_L_unlock_111' 56f28cd6\n\t'getspent_r' 56f29440\n\t'_nss_files_parse_spent' 56f298b0\n\t'_L_lock_34' 56f2a3eb\n\t'__argp_fmtstream_update' 56f2a500\n\t'__argp_fmtstream_puts' 56f2af00\n\t'until_short' 56f2b2d0\n\t'usage_argful_short_opt' 56f2c270\n\t'argp_help' 56f2e4a0\n\t'argp_usage' 56f2f580\n\t'pthread_attr_setschedparam' 56f2f7d0\n\t'pthread_cond_signal' 56f2fa10\n\t'pthread_self' 56f2fc50\n\t'_L_lock_116' 56f2ff5a\n\t'inet_ntop4' 56f30490\n\t'net_mask' 56f30ec0\n\t'skip_ws' 56f324c0\n\t'_L_unlock_68' 56f3306e\n\t'__nss_configure_lookup' 56f33a70\n\t'__nss_getent' 56f34000\n\t'__nss_group_lookup' 56f34eb0\n\t'__backtrace' 56f35490\n\t'__sprintf_chk' 56f35e60\n\t'_L_unlock_99' 56f362af\n\t'_L_unlock_302' 56f36680\n\t'__pread64_chk' 56f36be0\n\t'__wmemcpy_chk' 56f36ee0\n\t'__vswprintf_chk' 56f37220\n\t'_L_lock_35' 56f376ca\n\t'_L_unlock_247' 56f379a7\n\t'__wcsnrtombs_chk' 56f37c70\n\t'_L_unlock_63' 56f38084\n\t'__h_errno_location' 56f38530\n\t'_L_unlock_149' 56f38ddb\n\t'_L_unlock_73' 56f396ee\n\t'_L_lock_28' 56f39c55\n\t'_L_lock_148' 56f39fee\n\t'_L_lock_24' 56f3a5ed\n\t'_L_unlock_237' 56f3a8ce\n\t'_L_lock_27' 56f3b036\n\t'_L_unlock_72' 56f3b54e\n\t'_L_unlock_111' 56f3b7b6\n\t'_L_unlock_167' 56f3bbce\n\t'ether_ntoa_r' 56f3c510\n\t'rresvport_af' 56f3d200\n\t'__internal_setnetgrent_reuse' 56f3ed70\n\t'_L_unlock_711' 56f3f622\n\t'_L_lock_28' 56f3f9ad\n\t'_L_lock_25' 56f3fc16\n\t'if_nameindex' 56f40ba0\n\t'inet6_option_init' 56f41ee0\n\t'setsourcefilter' 56f42720\n\t'authnone_create_once' 56f43340\n\t'xdr_authunix_parms' 56f43b70\n\t'clntraw_geterr' 56f448e0\n\t'clnttcp_freeres' 56f44fc0\n\t'clntudp_freeres' 56f45930\n\t'pmap_unset' 56f46810\n\t'pmap_rmtcall' 56f47720\n\t'__rpc_thread_variables' 56f480a0\n\t'svcerr_weakauth' 56f483b0\n\t'xprt_unregister' 56f48920\n\t'svcraw_getargs' 56f48e30\n\t'svctcp_freeargs' 56f495e0\n\t'svctcp_rendezvous_abort' 56f49c40\n\t'svcudp_recv' 56f4a4f0\n\t'xdr_u_longlong_t' 56f4ab90\n\t'xdr_wrapstring' 56f4afb0\n\t'xdrmem_setpos' 56f4b520\n\t'skip_input_bytes' 56f4b7c0\n\t'xdrrec_getbytes' 56f4bb50\n\t'xdrstdio_create' 56f4c150\n\t'xdrstdio_getpos' 56f4c400\n\t'x_destroy' 56f4c790\n\t'xdr_authdes_cred' 56f4d030\n\t'key_get_conv' 56f4e400\n\t'_L_unlock_445' 56f4e8df\n\t'xdr_keystatus' 56f4ec90\n\t'_svcauth_des' 56f4f730\n\t'clntunix_create' 56f50340\n\t'svcunixfd_create' 56f50ed0\n\t'_create_xid' 56f516a0\n\t'xdr_uint8_t' 56f51ac0\n\t'__nscd_gethostbyname2_r' 56f52fd0\n\t'get_mapping' 56f53dc0\n\t'getutent' 56f546c0\n\t'endutent' 56f549f0\n\t'getutline' 56f54b40\n\t'__utmp_equal' 56f55040\n\t'updwtmp' 56f55fb0\n\t'setutxent' 56f56cb0\n\t'dl_iterate_phdr' 56f56e70\n\t'__libc_dlopen_mode' 56f57510\n\t'fde_unencoded_compare' 56f57b40\n\t'__register_frame' 56f58350\n\t'_L_lock_136' 56f59129\n\t'_Unwind_GetIP' 56f591e0\n\t'read_uleb128' 56f59b50\n\t'_IO_old_cookie_seek' 56f59eb0\n\t'_L_lock_68' 56f5a7ea\n\t'_L_lock_36' 56f5ab9c\n\t'_IO_file_xsputn' 56f5af40\n\t'_IO_old_file_finish' 56f5bae0\n\t'versionsort64' 56f5c090\n\t'sched_setaffinity' 56f5d210\n\t'getspent_r' 56f5d550\n\t'gethostbyname2_r' 56f5d7f0\n\t'getservbyport_r' 56f5dbe0\n\t'free_mem' 56f5dff0\n\t'free_mem' 56f5e5c0\n\t'_L_unlock_44' 56f5e905\n\t'__rpc_thread_destroy' 56f5ec70\nEND_RTN_LIST\nU '/disk/PinTools/Utils/obj-ia32/cp-pin'\nU '/lib/ld-linux.so.2'\nU '/usr/lib/libstdc++.so.6'\nU '/lib/libm.so.6'\nU '/lib/libgcc_s.so.1'\nU '/lib/libc.so.6'\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Debugger/makefile.rules": "##############################################################\n#\n# This file includes all the test targets as well as all the\n# non-default build rules and test recipes.\n#\n##############################################################\n\n###### Additional includes that are specific to this directory ######\n\ninclude $(TOOLS_ROOT)/Config/makefile.debug.rules\n\n\n##############################################################\n#\n# Test targets\n#\n##############################################################\n\n###### Place all generic definitions here ######\n\n# This defines tests which run tools of the same name.  This is simply for convenience to avoid\n# defining the test name twice (once in TOOL_ROOTS and again in TEST_ROOTS).\n# Tests defined here should not be defined in TOOL_ROOTS and TEST_ROOTS.\nTEST_TOOL_ROOTS :=\n\n# This defines the tests to be run that were not already defined in TEST_TOOL_ROOTS.\nTEST_ROOTS :=\n\n# This defines the tools which will be run during the the tests, and were not already defined in\n# TEST_TOOL_ROOTS.\nTOOL_ROOTS :=\n\n# This defines the static analysis tools which will be run during the the tests. They should not\n# be defined in TEST_TOOL_ROOTS. If a test with the same name exists, it should be defined in\n# TEST_ROOTS.\n# Note: Static analysis tools are in fact executables linked with the Pin Static Analysis Library.\n# This library provides a subset of the Pin APIs which allows the tool to perform static analysis\n# of an application or dll. Pin itself is not used when this tool runs.\nSA_TOOL_ROOTS :=\n\n# This defines all the applications that will be run during the tests.\nAPP_ROOTS :=\n\n# This defines any additional object files that need to be compiled.\nOBJECT_ROOTS :=\n\n# This defines any additional dlls (shared objects), other than the pintools, that need to be compiled.\nDLL_ROOTS :=\n\n# This defines any static libraries (archives), that need to be built.\nLIB_ROOTS :=\n\n###### Place OS-specific definitions here ######\n\n\n\n# Linux\nifeq ($(TARGET_OS),linux)\n    TEST_TOOL_ROOTS += stop-resume-when-suspended check-if-thread-stopped\n    TEST_ROOTS += simple-pindb-launch pindb-start-fini pindb-noprompt-kill pindb-detach pindb-abrupt-disconnect \\\n                  pindb-kill-like-gdb pindb-simple-command pindb-step-custom-break pindb-simultaneous-toolbreak \\\n                  pindb-simultaneous-toolbreak-serialize pindb-simultaneous-toolbreak-squash pindb-invalidate-regs \\\n                  pindb-simultaneous-toolbreak-change pindb-simultaneous-toolbreak-step pindb-simple-simultaneous-multi \\\n                  pindb-simple-simultaneous-multi-serialize simple execfail fork breaktool breaktool_const_context \\\n                  breaktool-wait breaktool-nodebugger bp-icount action-pending thread launch-gdb stack-debugger pindb-zmm \\\n                  debugger-shell-breakpoints debugger-shell-tracepoints start-fini intercept-breakpoint emu-simple ymm zmm \\\n                  pc-change-bp pc-change-async interpreter-remove mt-exit debugger-type signal-step siginfo xmm-$(TARGET) \\\n                  pindb-attach-after-custom-stop allow-remote set-mode gdb-detach-reattach invalid-write bptest-$(TARGET) \\\n                  pindb-pthread-step-exit gdb-pthread-step-exit pindb-pthread-cont-exitgroup pindb-pthread-step-exitgroup \\\n                  simultaneous-toolbreak simultaneous-toolbreak-squash simultaneous-toolbreak-change \\\n                  simultaneous-toolbreak-attach pindb-simultaneous-multi pindb-simultaneous-multi-serialize \\\n                  pindb-simultaneous-toolbreak-attach launch-gdb_const_context ymm_with_set_xmm_scratch_regs_tool \\\n                  watchpoint_const_context simultaneous-toolbreak_const_context \\\n                  xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool \\\n                  xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_const_context \\\n                  xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_and_set_xmm_reg \\\n                  app-pause-in-app-thread app-pause-in-int-thread bphandler gdb-svr4-libraries-extension simple-pindb-attach\n    TOOL_ROOTS += stack-debugger start-fini-callback simple-command-tool use-debugger-shell simultaneous-toolbreak \\\n                  breaktool int3-count action-pending-tool checkpoint watchpoint launch-gdb-tool intercept-tool \\\n                  pc-change-async-tool interpreter-remove mt-exit-tool debugger-type set-mode-tool invalidate-regs \\\n                  set_xmm_scratches set_xmm_scratches_before_breakpoint set_xmm_scratches_before_breakpoint_and_set_xmm_reg \\\n                  set_xmm_scratches_for_ymmtest null-emulator-$(TARGET) \\\n                  app-pause-in-app-thread-tool app-pause-in-int-thread-tool library-load-tool\n    APP_ROOTS += simple-pindb simple simple-static exec fork action-pending-app thread checkpoint-app bptest-$(TARGET) \\\n                 watchpoint-app callerapp fibonacci sleep-unix intercept-app pc-change-bp pc-change-async xmm-$(TARGET) \\\n                 mt-exit signal-catch reattach-loop pthread-bare-exit pthread-bare-exitgroup thread-$(OS_TYPE) \\\n                 ymm-$(TARGET) zmm-$(TARGET) debugger-shell-app-$(TARGET) app-pause-app pick-random-port bphandler_app \\\n                 dlopen-dlclose\n    OBJECT_ROOTS += simple-pindb-asm-$(TARGET) zmm-asm-$(TARGET)\n    ifeq ($(TARGET),ia32)\n        TEST_ROOTS += access-64-on-32\n    endif\n\n    ifeq ($(shell $(TOOLS_ROOT)/Utils/testStaticLibs), 1)\n        TEST_ROOTS := $(filter-out bp-icount, $(TEST_ROOTS))\n        TOOL_ROOTS := $(filter-out int3-count, $(TOOL_ROOTS))\n        APP_ROOTS := $(filter-out simple-static, $(APP_ROOTS))\n    endif\n\n    # see mantis 4779 debugger update caused 32 bit to fail on ubuntu 18.04\n    # threrefore we filter them till debugger is fixed\n    FILTER_DEBUG_32BIT := 0\n    ifeq ($(TARGET),ia32)\n      ifeq ($(DIST_NAME_UBUNTU),1)\n        FILTER_DEBUG_32BIT := $(shell $(TOOLS_ROOT)/Utils/testLinuxDistVersion eq 18.04)\n      endif\n    endif\n    ifeq ($(FILTER_DEBUG_32BIT),1)\n        TEST_ROOTS := $(filter-out action-pending allow-remote bphandler bptest-ia32 breaktool_const_context breaktool-wait breaktool \\\n                                   debugger-shell-breakpoints debugger-shell-tracepoints emu-simple execfail fork gdb-detach-reattach \\\n                                   gdb-pthread-step-exit intercept-breakpoint pc-change-async pc-change-bp set-mode siginfo signal-step simple \\\n                                   simultaneous-toolbreak_const_context simultaneous-toolbreak-change simultaneous-toolbreak-squash \\\n                                   simultaneous-toolbreak stack-debugger thread watchpoint_const_context \\\n                                   xmm-ia32_with_set_xmm_scratch_regs_before_breakpoint_tool_and_set_xmm_reg \\\n                                   xmm-ia32_with_set_xmm_scratch_regs_before_breakpoint_tool_const_context \\\n                                   xmm-ia32_with_set_xmm_scratch_regs_before_breakpoint_tool xmm-ia32 \\\n                                   ymm_with_set_xmm_scratch_regs_tool ymm zmm , $(TEST_ROOTS))\n    endif \nendif\n\n# macOS*\nifeq ($(TARGET_OS),mac)\n    TEST_ROOTS += app-pause-in-app-thread app-pause-in-int-thread \\\n                  simple-pindb-launch pindb-start-fini pindb-noprompt-kill pindb-detach pindb-abrupt-disconnect \\\n                  pindb-kill-like-gdb pindb-simple-command pindb-step-custom-break pindb-simultaneous-toolbreak \\\n                  pindb-simultaneous-toolbreak-serialize pindb-simultaneous-toolbreak-squash pindb-invalidate-regs \\\n                  pindb-simultaneous-toolbreak-change pindb-simultaneous-toolbreak-step pindb-simple-simultaneous-multi \\\n                  pindb-simple-simultaneous-multi-serialize pindb-pthread-step-exit pindb-pthread-cont-exitgroup \\\n                  pindb-pthread-step-exitgroup pindb-simultaneous-multi pindb-simultaneous-multi-serialize pindb-zmm \\\n                  simple execfail fork breaktool bphandler stack-debugger debugger-type simple-pindb-attach\n# pindb-attach-after-custom-stop pindb-simultaneous-toolbreak-attach\n    TOOL_ROOTS += app-pause-in-app-thread-tool app-pause-in-int-thread-tool default_mac_tool simple-command-tool \\\n                  invalidate-regs use-debugger-shell breaktool bphandler stack-debugger debugger-type\n    APP_ROOTS += app-pause-app simple simple-pindb thread-$(OS_TYPE) pthread-bare-exit pthread-bare-exitgroup \\\n    \t\t\t zmm-$(TARGET) bphandler_app fibonacci\n    OBJECT_ROOTS += simple-pindb-asm-$(TARGET) zmm-asm-$(TARGET)\nendif\n\n# Windows\nifeq ($(TARGET_OS),windows)\n    TEST_TOOL_ROOTS += stop-resume-when-suspended check-if-thread-stopped\n    TEST_ROOTS += simple-pindb-launch pindb-start-fini pindb-noprompt-kill pindb-detach pindb-abrupt-disconnect \\\n                  pindb-kill-like-gdb pindb-simple-command pindb-step-custom-break pindb-simultaneous-toolbreak \\\n                  pindb-simultaneous-toolbreak-serialize pindb-simultaneous-toolbreak-squash pindb-invalidate-regs \\\n                  pindb-simultaneous-toolbreak-change pindb-simultaneous-toolbreak-step pindb-simple-simultaneous-multi \\\n                  pindb-simple-simultaneous-multi-serialize pindb-win-unhandled-exception pindb-win-handled-exception \\\n                  pindb-win-continued-exception1 pindb-win-continued-exception2 pindb-win-software-exception \\\n                  pindb-win-cpp-exception pindb-win-squash-exception pindb-win-step-exception pindb-zmm \\\n                  pindb-win-library-notifications pindb-win-step-library pindb-win-thread-stress \\\n                  pindb-win-exception-after-exit app-pause-in-app-thread app-pause-in-int-thread simple-pindb-attach\n    TOOL_ROOTS += stack-debugger start-fini-callback simple-command-tool use-debugger-shell simultaneous-toolbreak \\\n                  invalidate-regs app-pause-in-app-thread-tool app-pause-in-int-thread-tool\n    APP_ROOTS += simple-pindb simple win-unhandled-exception win-handled-exception win-continued-exception1 \\\n                 win-continued-exception2 win-software-exception win-cpp-exception win-load-library \\\n                 win-thread-stress thread-$(OS_TYPE) app-pause-app win-exception-after-exit zmm-$(TARGET)\n    OBJECT_ROOTS += simple-pindb-asm-$(TARGET) win-foo-library zmm-asm-$(TARGET)\n    DLL_ROOTS += win-foo-library win-exception-after-exit-dll\n    ifeq ($(TARGET),ia32)\n        TEST_ROOTS += access-64-on-32\n    endif\nendif\n\n###### Handle exceptions here ######\n\n\nifeq ($(TARGET_OS),windows)\n    # This test is disabled until Mantis 1839 is fixed.\n    TEST_ROOTS := $(filter-out simple-pindb-attach, $(TEST_ROOTS))\n    # This test is disabled until Mantis 4566 is fixed\n    TEST_TOOL_ROOTS := $(filter-out stop-resume-when-suspended, $(TEST_TOOL_ROOTS))\nendif\n\n# There is a bug with PinADX when using early-injection (the default) on 32-bit applications when running\n# on a 64-bit host and when using versions of Windows earlier than Vista.  That bug causes this test to\n# fail, so we disable it in this case.  We can re-enable this test when Mantis #2385 is fixed.\n#\nosname := $(shell uname -s)\nifeq ($(findstring CYGWIN_NT-5,$(osname))-$(HOST_ARCH)-$(TARGET),CYGWIN_NT-5-intel64-ia32)\n    TEST_ROOTS := $(filter-out pindb-start-fini, $(TEST_ROOTS))\nendif\n\nifeq ($(TARGET_OS),linux)\n    GDB_VERSION_IF_BEFORE_66 := $(shell $(TOOLS_ROOT)/Utils/testToolVersion $(GDB) le 6.6)\n    GDB_VERSION_IF_BEFORE_74 := $(shell $(TOOLS_ROOT)/Utils/testToolVersion $(GDB) le 7.4)\n    GDB_VERSION_IF_BEFORE_80 := $(shell $(TOOLS_ROOT)/Utils/testToolVersion $(GDB) le 8.0)\n    ifeq ($(GDB_VERSION_IF_BEFORE_66),1)\n#   Versions of gdb older than 6.6 do not understand the XMM registers, so disable the xmm tests.\n#\n        TEST_ROOTS := $(filter-out xmm-$(TARGET) xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool \\\n                                   xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_const_context \\\n                                   xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_and_set_xmm_reg, \\\n                                   $(TEST_ROOTS))\n        TOOL_ROOTS := $(filter-out set_xmm_scratches_before_breakpoint \\\n                                   set_xmm_scratches_before_breakpoint_and_set_xmm_reg set_xmm_scratches, $(TOOL_ROOTS))\n        APP_ROOTS := $(filter-out xmm-$(TARGET), $(APP_ROOTS))\n    endif\n    ifeq ($(GDB_VERSION_IF_BEFORE_74),1)\n#   Versions of gdb older than 7.4 do not understand svr4 libraries query\n#\n        TEST_ROOTS := $(filter-out gdb-svr4-libraries-extension, $(TEST_ROOTS))\n        TOOL_ROOTS := $(filter-out library-load-tool, $(TOOL_ROOTS))\n        APP_ROOTS := $(filter-out dlopen-dlclose, $(APP_ROOTS))\n    endif\n    ifeq ($(GDB_VERSION_IF_BEFORE_80),1)\n#   Versions of gdb older than 8.0 do not support AVX512 registers\n#\n        TEST_ROOTS := $(filter-out zmm, $(TEST_ROOTS))\n    endif\nendif\n\nifeq ($(TARGET_OS),linux)\n    # See mantis 4613\n    TEST_ROOTS := $(filter-out gdb-svr4-libraries-extension, $(TEST_ROOTS))\n    \n    ifeq ($(DIST_NAME_RHEL),1)\n        ifeq ($(TARGET),ia32)\n            DIST_VER_75_OR_76 := $(shell $(TOOLS_ROOT)/Utils/testLinuxDistVersion eq 7.5)\n            ifeq ($(DIST_VER_75_OR_76),0)\n                DIST_VER_75_OR_76 := $(shell $(TOOLS_ROOT)/Utils/testLinuxDistVersion eq 7.6)\n            endif\n            \n            ifeq ($(DIST_VER_75_OR_76),1)\n                # Disable 32 bit tests on rhel7.5 & thel7.6 - see mantis 4677\n                TEST_ROOTS := $(filter-out action-pending allow-remote bphandler bptest-ia32 breaktool_const_context \\\n                                  breaktool-wait breaktool debugger-shell-breakpoints debugger-shell-tracepoints execfail fork \\\n                                  gdb-detach-reattach gdb-pthread-step-exit intercept-breakpoint invalid-write pc-change-async \\\n                                  pc-change-bp set-mode siginfo signal-step simple simultaneous-toolbreak_const_context \\\n                                  simultaneous-toolbreak-change simultaneous-toolbreak-squash simultaneous-toolbreak \\\n                                  stack-debugger thread watchpoint_const_context \\\n                                  xmm-ia32_with_set_xmm_scratch_regs_before_breakpoint_tool_and_set_xmm_reg \\\n                                  xmm-ia32_with_set_xmm_scratch_regs_before_breakpoint_tool_const_context \\\n                                  xmm-ia32_with_set_xmm_scratch_regs_before_breakpoint_tool xmm-ia32 \\\n                                  ymm_with_set_xmm_scratch_regs_tool ymm pindb-simultaneous-toolbreak, $(TEST_ROOTS))\n            endif\n        endif\n    endif\n    \nendif\n\n# See mantis 4570\nifeq ($(TARGET_OS),windows)\n    TEST_ROOTS := $(filter-out pindb-zmm, $(TEST_ROOTS))\nendif\n\n###### Define the sanity subset ######\n\n# This defines the list of tests that should run in sanity. It should include all the tests listed in\n# TEST_TOOL_ROOTS and TEST_ROOTS excluding only unstable tests.\nSANITY_SUBSET := $(TEST_TOOL_ROOTS) $(TEST_ROOTS)\n\nifeq ($(TARGET_OS),mac)\n    # See mantis 4598\n    SANITY_SUBSET := $(filter-out pindb-simultaneous-toolbreak pindb-simultaneous-toolbreak-serialize \\\n                                  pindb-simultaneous-toolbreak-squash pindb-simultaneous-toolbreak-change \\\n                                  pindb-simultaneous-toolbreak-step, $(SANITY_SUBSET))\n\n    ifeq ($(TARGET),ia32)\n        # See mantis 4602\n        SANITY_SUBSET := $(filter-out pindb-invalidate-regs, $(SANITY_SUBSET))\n    endif\n\n    # See mantis 4679\n    SANITY_SUBSET := $(filter-out pindb-simultaneous-multi-serialize, $(SANITY_SUBSET))\nendif\n\n\n##############################################################\n#\n# Test recipes\n#\n##############################################################\n\n# This section contains recipes for tests other than the default.\n# See makefile.default.rules for the default test rules.\n# All tests in this section should adhere to the naming convention: <testname>.test\n\n# This is a time limit (in seconds) we use for some of the tests below.  It's intentionally high\n# to avoid timeouts when the system load is very high, which can happen in our nightly tests.\n#\n\nTLIMIT := 120\n\nifeq ($(TARGET_OS),mac)\n    BATCH_CMD_CONNECT_REMOTE :=gdb-remote\n    BATCH_CMD_TIMEOUT_LIMIT:=\n    DBG:=lldb\n    DBG_STR:=$(DBG)\n    DBG_CMD_SRC_FLAG:=-s\n    DBG_CMD_MORE_FLAGS:=-x --batch\n    DEFAULT_TOOL:=$(OBJDIR)default_mac_tool$(PINTOOL_SUFFIX)\n    PIN_CMD_DEFAULT_TOOL:= -t $(DEFAULT_TOOL)\n    COMPARE_RE_FILE_SUFFIX:=.lldb \nendif\nifeq ($(TARGET_OS),linux)\n    BATCH_CMD_CONNECT_REMOTE :=target remote\n    BATCH_CMD_TIMEOUT_LIMIT:= set remotetimeout $(TLIMIT)\n    DBG:=$(GDB)\n    DBG_STR:=gdb\n    DBG_CMD_SRC_FLAG=-x\n    DBG_CMD_MORE_FLAGS:=-n -batch\n    COMPARE_RE_FILE_SUFFIX:=\nendif\n\n# This is the example tool from the manual run such that you can attach the debugger after it triggers a stack\n# breakpoint.\n#\nstack-debugger-late.test: $(OBJDIR)fibonacci$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_silent -t $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX) \\\n\t  -stackbreak 4000 -o $(OBJDIR)$(@:.test=.toolout) -timeout $(TLIMIT) \\\n\t    -- $(OBJDIR)fibonacci$(EXE_SUFFIX) 1000 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.toolout) > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.toolout) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)fibonacci$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Basic test of debugger features.\n#\nsimple.test: $(OBJDIR)simple$(EXE_SUFFIX) $(DEFAULT_TOOL)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) $(PIN_CMD_DEFAULT_TOOL) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Basic test for breakpoint handling features.\n#\nbphandler.test: $(OBJDIR)bphandler$(PINTOOL_SUFFIX) $(OBJDIR)bphandler_app$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)bphandler$(PINTOOL_SUFFIX) -- $(OBJDIR)bphandler_app$(EXE_SUFFIX) > \\\n      $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)bphandler_app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Verify we can debug across a failed exec() call.\n#\nexecfail.test: $(OBJDIR)exec$(EXE_SUFFIX) $(DEFAULT_TOOL)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -follow_execv $(PIN_CMD_DEFAULT_TOOL) -- $(OBJDIR)exec$(EXE_SUFFIX) ./does-not-exist > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)exec$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Verify we can debug across a parent call to fork().\n#\nfork.test: $(OBJDIR)fork$(EXE_SUFFIX) $(DEFAULT_TOOL)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) $(PIN_CMD_DEFAULT_TOOL) -- $(OBJDIR)fork$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)fork$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Basic test of PIN_ApplicationBreakpoint()\n#\nbreaktool.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 0 \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\nbreaktool_const_context.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 0 -const_context 1 \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Verify that PIN_ApplicationBreakpoint(.., TRUE, ..) will wait if there's no debugger.\n#\nbreaktool-wait.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) \\\n\t  -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 1 -port $(OBJDIR)$(@:.test=.out) \\\n\t    -- $(OBJDIR)simple$(EXE_SUFFIX) &\n\tcount=0; \\\n\tuntil $(BASHTEST) -s $(OBJDIR)$(@:.test=.out) -o $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tsleep 5\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tport=`cat $(OBJDIR)$(@:.test=.out)`; echo \"target remote :$$port\" >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Verify that PIN_ApplicationBreakpoint(.., FALSE, ..) does not wait if there's no debugger.\n#\nbreaktool-nodebugger.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 0 \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX)\n\n# Test breakpoints in various circumstances.\n#\nbptest-$(TARGET).test: $(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.)$(COMPARE_EXT) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that breakpoints do not cause the tool to see any extra instructions (e.g. INT3).\n#\nbp-icount.test: $(OBJDIR)simple-static$(EXE_SUFFIX) $(OBJDIR)int3-count$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) -t $(OBJDIR)int3-count$(PINTOOL_SUFFIX) -func main -o $(OBJDIR)bp-icount.reference \\\n\t  -- $(OBJDIR)simple-static$(EXE_SUFFIX)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)int3-count$(PINTOOL_SUFFIX) -func main -o $(OBJDIR)bp-icount.count \\\n\t  -- $(OBJDIR)simple-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(CMP) $(OBJDIR)bp-icount.reference $(OBJDIR)bp-icount.count\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test the PIN_IsActionPending() API.\n#\naction-pending.test: $(OBJDIR)action-pending-app$(EXE_SUFFIX) $(OBJDIR)action-pending-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)action-pending-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)action-pending-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)action-pending-app$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that we can print out XMM registers.  Older GDB's don't know how to print XMM registers well,\n# so use a modern GDB for this test.\n#\n# We first test that GDB itself will run.  If not, we just skip the body of this test.  The modern\n# GDB won't run on some old test systems.\n#\nxmm-$(TARGET).test: $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool.test: $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratches_before_breakpoint.out \\\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(QGREP) \"$$1 = 0x[0]*3f800000\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"$$2 = 0x[0]*40000000\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"$$3 = 0xff00ff000a550a55123456789abcdef0\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"exited normally.\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"instrumented the movdqa\" $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\t$(QGREP) \"did setApplicationBreakpoint\" $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\t$(QGREP) \"regular_context\" $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_const_context.test: $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN)  $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out -const_context 1 \\\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(QGREP) \"$$1 = 0x[0]*3f800000\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"$$2 = 0x[0]*40000000\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"$$3 = 0xff00ff000a550a55123456789abcdef0\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"exited normally.\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"instrumented the movdqa\" $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\t$(QGREP) \"did setApplicationBreakpoint\" $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\t$(QGREP) \"const_context\" $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_and_set_xmm_reg.test: $(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN)  $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out \\\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(QGREP) \"$$1 = 0x[0]*3f800000\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"$$2 = 0x[0]*40000000\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"$$3 = 0xff00ff000a550a55123456789abcdef0\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"$$4 = 0x5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"exited normally.\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"instrumented the movdqa\" $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\t$(QGREP) \"tool got the expected gdb command\" $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\t$(QGREP) \"tool properly set xmm3\" $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_tool.test: $(OBJDIR)set_xmm_scratches$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN)  $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratches.out \\\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) instrumented $(OBJDIR)set_xmm_scratches.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)set_xmm_scratches.out\n\n# Simple test of a threaded program.\n#\nthread.test: $(OBJDIR)thread$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)thread$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat thread.$(DBG_STR) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)thread$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p thread.compare -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Simple test of a threaded program built statically (uses non-nptl thread package on Linux).\n# NOTE: This test is disabled, so it does not run automatically.  Modern versions of GDB do not\n#   support non-nptl threads well.\n#\nthread-static.test: $(OBJDIR)thread-static$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)thread-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat thread.$(DBG_STR) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)thread-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p thread.compare -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Simple test of the 'pindb' debugger.  We launch Pin separatly and pindb attaches.\n#\nsimple-pindb-attach.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) basic $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.compare)\n\t$(PYTHON) launch-pin-attach-debugger.py --pin=$(BARE_PIN) --pin-exe=$(BARE_PIN) \\\n\t    --pindb=$(PINDB) --pindb-libpath=$(PINDB_LIBPATH) \\\n\t    --tool=$(OBJDIR)stack-debugger$(PINTOOL_SUFFIX) --app=$(OBJDIR)simple-pindb$(EXE_SUFFIX) \\\n\t    --cpu=$(TARGET) --timeout=$(TLIMIT) \\\n\t    --pin-out=$(OBJDIR)$(@:.test=.out) --pindb-in=$(OBJDIR)$(@:.test=.pindbin) \\\n\t    --pindb-out=$(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.compare) $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.pindbout)\n\n# Simple test of the 'pindb' debugger.  We use the pindb \"run\" command to launch and attach to pin.\n#\nsimple-pindb-launch.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) basic $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple-pindb$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(OBJDIR)$(@:.test=.pindbin.0) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare) $(OBJDIR)$(@:.test=.pindbout) \\\n\t      $(OBJDIR)$(@:.test=.pindbin)\n\n# Test the checkpoint tool.\n#\ncheckpoint.test: $(OBJDIR)checkpoint-app$(EXE_SUFFIX) $(OBJDIR)checkpoint$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)checkpoint$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)checkpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)checkpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p checkpoint-gdb.compare -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p checkpoint-app.compare -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test the watchpoint tool.\n#\nwatchpoint.test: $(OBJDIR)watchpoint-app$(EXE_SUFFIX) $(OBJDIR)watchpoint$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)watchpoint-app 1 > $(OBJDIR)$(@:.test=.$(DBG_STR))\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)watchpoint$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out) $(OBJDIR)$(@:.test=.$(DBG_STR))\n\nwatchpoint_const_context.test: $(OBJDIR)watchpoint-app$(EXE_SUFFIX) $(OBJDIR)watchpoint$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)watchpoint-app$(EXE_SUFFIX) 1 > $(OBJDIR)$(@:.test=.$(DBG_STR))\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)watchpoint$(PINTOOL_SUFFIX) -const_context 1 \\\n\t  -- $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out) $(OBJDIR)$(@:.test=.$(DBG_STR))\n\n# This test starts Pin with debugger support enabled, but Pin does not stop at\n# the first instruction waiting for a debugger to attach.  Instead, the\n# application runs under Pin immediately.  Later, if the tool finds something\n# interesting, it can ask the user (or a GUI shell) to start the debugger and\n# attach at the interesting point.\n#\nlaunch-gdb.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) -timeout $(TLIMIT) \\\n\t  -o $(OBJDIR)$(@:.test=.$(DBG_STR)in) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.$(DBG_STR)in) > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# This tests the -appdebug_server_port <PORT> option of PIN.\n# We pick an available TCP port randomly, then we run PIN with -appdebug_server_port specifying the random port\n# We expect to connect with GDB to the port we specified\n#\ngdb-fixed-port.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(OBJDIR)pick-random-port$(EXE_SUFFIX) unused > $(OBJDIR)$(@:.test=.random)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_server_port `cat $(OBJDIR)$(@:.test=.random)` -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) -timeout $(TLIMIT) \\\n\t  -o $(OBJDIR)$(@:.test=.$(DBG_STR)in) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote :'`cat $(OBJDIR)$(@:.test=.random)` $(OBJDIR)$(@:.test=.$(DBG_STR)in) > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# This tests the -appdebug_server_port <PORT> option of PIN when we.\n# provide a port which is already taken by another application\n# We expect PIN to fail because it won't acquire the port\n#\ngdb-fixed-port-used.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(OBJDIR)pick-random-port$(EXE_SUFFIX) used > $(OBJDIR)$(@:.test=.random)\n\t! ( $(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_server_port `cat $(OBJDIR)$(@:.test=.random)` -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) \\\n\t    -timeout $(TLIMIT) -o $(OBJDIR)$(@:.test=.$(DBG_STR)in) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) )\n\t$(QGREP) \"E:Unable to create debugger connection\" $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.random)\n\n# This tests the -appdebug_server_port <PORT> option of PIN when we\n# provide an invalid TCP port number.\n# We expect PIN to fail because the TCP port number is invalid\n#\ngdb-fixed-bad-port.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t! ( $(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_server_port 100000 -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) \\\n\t    -timeout $(TLIMIT) -o $(OBJDIR)$(@:.test=.$(DBG_STR)in) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) )\n\t$(QGREP) \"E:Invalid TCP server port: 100000\" $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\nlaunch-gdb_const_context.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) -const_context 1 -timeout $(TLIMIT) \\\n\t  -o $(OBJDIR)$(@:.test=.$(DBG_STR)in) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.$(DBG_STR)in) > /dev/null 2>&1 || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# This is the example tool we describe in the manual, which demonstrates the major features\n# of the application-level debugging API.  The tool tracks the application's stack usage\n# and allows breakpoints to be set when the stack usage crosses a threshold.\n#\nstack-debugger.test: $(OBJDIR)fibonacci$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)fibonacci$(EXE_SUFFIX) 1000 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)fibonacci$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that we can asynchronously stop the target in PinDB by sending CTRL-C (SIGINT).\n# TODO: This is disabled until Mantis #2055 is fixed.\n#\npindb-async-stop.test: $(OBJDIR)sleep-unix$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)sleep-unix$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout) & \\\n\t    pid=$$!; \\\n\t    sleep 2; \\\n\t    while kill -INT $$pid > /dev/null 2>&1; \\\n\t    do \\\n\t        sleep 2; \\\n\t    done; \\\n\t    wait\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test of breakpoint commands in the \"debugger-shell\" instrumentation library.\n#\ndebugger-shell-breakpoints.test: $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) breakpoints $(OBJDIR)$(@:.test=.$(DBG_STR)in.0) $(OBJDIR)$(@:.test=.compare)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.$(DBG_STR)in.0) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in.0) $(OBJDIR)$(@:.test=.compare) \\\n\t      $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test of tracepoint commands in the \"debugger-shell\" instrumentation library.\n#\ndebugger-shell-tracepoints.test: $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) tracepoints $(OBJDIR)$(@:.test=.$(DBG_STR)in.0) $(OBJDIR)$(@:.test=.compare)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.$(DBG_STR)in.0) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in.0) $(OBJDIR)$(@:.test=.compare) \\\n\t      $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that the thread-start, thread-fini, and fini call-backs are correctly called even when GDB\n# immediately terminates the application .\n#\nstart-fini.test: $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) -o $(OBJDIR)$(@:.test=.toolout) \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) & \\\n\t    count=0; \\\n\t    until $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t        do sleep 1; count=`expr $$count + 1`; done; \\\n\t    echo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in); \\\n\t    $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in); \\\n\t    cat quit.$(DBG_STR) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in); \\\n\t    $(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1; \\\n\twait\n\t$(CMP) start-fini.reference $(OBJDIR)$(@:.test=.toolout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that the thread-start, thread-fini, and fini call-backs are correctly called when PinDB\n# immediately terminates the application (tested on both Linux and Windows).\n#\npindb-start-fini.test: $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) \\\n\t    -o $(OBJDIR)$(@:.test=.toolout)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(DIFF) start-fini.reference $(OBJDIR)$(@:.test=.toolout)\n\t$(SYNC)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\nstop-resume-when-suspended.test: $(OBJDIR)stop-resume-when-suspended$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)stop-resume-when-suspended$(PINTOOL_SUFFIX) \\\n\t    -o $(OBJDIR)$(@:.test=.toolout)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\tsleep 5\n\t$(DIFF) stop-resume-when-suspended.reference $(OBJDIR)$(@:.test=.toolout)\n\t$(QGREP) \"Sum is 55\" $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Verify that PIN_InterceptDebuggingEvent() can intercept and squash breakpoints.\n#\nintercept-breakpoint.test: $(OBJDIR)intercept-app$(EXE_SUFFIX) $(OBJDIR)intercept-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)intercept-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)intercept-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)intercept-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=-gdb.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=-app.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test the PIN_AddDebuggerRegisterEmulator() API.  This test is legal to run with any version of GDB,\n# but it only tests the API well when run with a GDB that supports register extensions in the XML\n# \"feature document\".  This includes GDB 7.2 and later, and a few special earlier distributions.\n#\nemu-simple.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)null-emulator-$(TARGET)$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)null-emulator-$(TARGET)$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat simple.$(DBG_STR) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p simple.compare -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Verify that the debugger can print the value of a YMM register when running on native AVX hardware.\n# This test will pass even when run on non-AVX hardware.  However, it's only effective when run on\n# AVX hardware and when run with a GDB that supports AVX.\n#\nymm.test: $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\nymm_with_set_xmm_scratch_regs_tool.test: $(OBJDIR)set_xmm_scratches_for_ymmtest$(PINTOOL_SUFFIX) $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_for_ymmtest$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\tsleep 5\n\tcat set_xmm_scratches_for_ymmtest.out\n\t$(QGREP) instrumented set_xmm_scratches_for_ymmtest.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f instrumented set_xmm_scratches_for_ymmtest.out\n\n# Verify that the debugger can print the value of a ZMM register when running on native AVX512 hardware.\n# This test will pass even when run on non-AVX512 hardware.  However, it's only effective when run on\n# AVX512 hardware and when run with a GDB that supports AVX512.\n#\nzmm.test: $(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t-$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\tif ! $(QGREP) \"HandleSigill\" $(OBJDIR)$(@:.test=.$(DBG_STR)out) ; then \\\n\t  $(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out); \\\n\tfi\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\npindb-zmm.test: $(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX)\n\techo \"set pinargs \" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\tif ! $(QGREP) \"Processor does not support AVX512\" $(OBJDIR)$(@:.test=.pindbout) ; then \\\n\t  $(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout); \\\n\tfi\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Verify that the debugger change the the PC when stopped after an indirect JMP instruction.\n#\npc-change-bp.test: $(OBJDIR)pc-change-bp$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)pc-change-bp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)pc-change-bp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Verify that the tool can change the PC from an ASYNC_BREAK intercept function when the thread\n# is stopped after an indirect JMP instruction.\n#\npc-change-async.test: $(OBJDIR)pc-change-async$(EXE_SUFFIX) $(OBJDIR)pc-change-async-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)pc-change-async-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)pc-change-async$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)pc-change-async$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test the PIN_RemoveDebugInterpreter() API.\n#\ninterpreter-remove.test: $(OBJDIR)interpreter-remove$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) -appdebug -t $(OBJDIR)interpreter-remove$(PINTOOL_SUFFIX) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t  do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\techo 'monitor bdio' >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\techo 'c' >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > /dev/null 2>&1\n\t! $(GREP) 'PIN_RemoveDebugInterpreter failed' $(OBJDIR)$(@:.test=.out) > /dev/null\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\n# Verify that GDB can terminate an application where one thread is blocked in\n# a system call.  Previously, the Pin process would sometimes hang when this\n# happened, so the test checks that the process exits.  (Note, \"kill -s 0 <pid>\"\n# just checks if a process exists, it doesn't send a signal.)\n#\nmt-exit.test: $(OBJDIR)mt-exit$(EXE_SUFFIX) $(OBJDIR)mt-exit-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.toolout)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)mt-exit-tool$(PINTOOL_SUFFIX) -o $(OBJDIR)$(@:.test=.toolout) \\\n\t  -- $(OBJDIR)mt-exit$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)mt-exit$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\tpid=`cat $(OBJDIR)$(@:.test=.toolout)`; \\\n\tcount=0; \\\n\tuntil ! kill -s 0 $$pid > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done; \\\n\t$(BASHTEST) $$count -le $(TLIMIT)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out) $(OBJDIR)$(@:.test=.toolout)\n\n# Simple test of the PIN_GetDebuggerType() API.\n#\ndebugger-type.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)debugger-type$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)debugger-type$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(GREP) -i 'Debugger Type is $(DBG_STR)' $(OBJDIR)$(@:.test=.out) > /dev/null\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that we can single-step into a signal handler.\n#\nsignal-step.test: $(OBJDIR)signal-catch$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that GDB can print $_siginfo and get the signal information structure from Pin.\n#\nsiginfo.test: $(OBJDIR)signal-catch$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that PinDB can attach after the Pin tool has stopped at a custom breakpoint and that PinDB\n# can still get the tool's custom stop message (see Mantis #2357).\n#\n# This is disabled on Windows, but it could probably be enabled there when Mantis #1839 is fixed.\n#\npindb-attach-after-custom-stop.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) \\\n\t  -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -where main -wait_for_debugger 1 -port $(OBJDIR)$(@:.test=.port) \\\n\t    -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'Tool stopping at breakpoint' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    --gdb-protocol=:`cat $(OBJDIR)$(@:.test=.port)` $(PINDB_USERFLAGS) < $(@:.test=.pindbin) > \\\n\t    $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows unhandled exception with PinDB.\n#\npindb-win-unhandled-exception.test: $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows handled exception with PinDB.\n#\npindb-win-handled-exception.test: $(OBJDIR)win-handled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-handled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows continued exception with PinDB.  The exception filter continues the search.\npindb-win-continued-exception1.test: $(OBJDIR)win-continued-exception1$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-continued-exception1$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows continued exception with PinDB.  The exception filter executes the handler.\npindb-win-continued-exception2.test: $(OBJDIR)win-continued-exception2$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-continued-exception2$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows software exception with PinDB.  The exception is raised via RaiseException() and is unhandled.\n#\npindb-win-software-exception.test: $(OBJDIR)win-software-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-software-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows C++ exception with PinDB.\n#\npindb-win-cpp-exception.test: $(OBJDIR)win-cpp-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-cpp-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test ability to squash a Windows exception.  Squashing a first-chance exception re-executes\n# the excepting instruction, which raises a new first-chance exception.  Squashing a last-chance\n# exception also re-executes the excepting instruction, which raises a new first-chance exception.\n#\npindb-win-squash-exception.test: $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test ability to single-step after receiving a Windows exception.  Stepping from a first-chance\n# exception should go to the first instruction in the handler.  Stepping from a last-chance\n# exception should cause the application to terminate.\n#\npindb-win-step-exception.test: $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that Pin properly handles exception which happens after beginning of process exit flow\n# when PinADX is disabled.\n#\npindb-win-exception-after-exit.test: $(OBJDIR)win-exception-after-exit$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-exception-after-exit$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --noprompt $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\tsleep 2\n\t$(QGREP) \"Caught exception C0000005\" $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test DLL load / unload notifications with PinDB.\n#\npindb-win-library-notifications.test: $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test ability to single-step after receiving a Windows library load / unload notification.\n#\npindb-win-step-library.test: $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Make sure PinDB does not wait for confirmation when killing the target process when --noprompt is specified.\n#\npindb-noprompt-kill.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test the -appdebug_allow_remote knob, which allows GDB to run on a different machine than Pin.\n# However, it's difficult to actually run GDB on a different machine as part of this test, so\n# we still run them both on the same machine.\n#\nallow-remote.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -appdebug_allow_remote -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat simple.$(DBG_STR) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p simple.compare -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Verify that Pin doesn't crash if the debugger attempts to access a 64-bit address for a 32-bit Pin process.\n#\naccess-64-on-32.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Make sure we can ebable debugging via PIN_SetDebugMode() from the tool.  This test should\n# be run without -appdebug.\n#\nset-mode.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)set-mode-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) -t $(OBJDIR)set-mode-tool$(PINTOOL_SUFFIX) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat simple.$(DBG_STR) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p simple.compare -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that PinDB can detach from Pin.\n#\npindb-detach.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) detach $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple-pindb$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(OBJDIR)$(@:.test=.pindbin.0) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.pindbin.0) \\\n\t      $(OBJDIR)$(@:.test=.compare)\n\n# Abruptly disconnect PinDB from Pin.  This simulates the behavior when the debugger unexpectedly dies.\n# We expect an error from Pin, but Pin shouldn't hang.\n#\npindb-abrupt-disconnect.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs -logfile $(OBJDIR)$(@:.test=.pin.log) $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(SYNC)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pin.log) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbin) \\\n\t      $(OBJDIR)$(@:.test=.pindbout)\n\n# Test the \"kill-like-gdb\" command in PinDB.  This sends the same legacy \"kill\" command to PinADX that\n# GDB uses.\n#\npindb-kill-like-gdb.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that GDB can detach from Pin and then re-attach later.\n#\ngdb-detach-reattach.test: $(OBJDIR)reattach-loop$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > $(OBJDIR)$(@:.test=.port)\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=-1.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-1.$(DBG_STR)in)\n\tcat $(@:.test=-1.$(DBG_STR)) >> $(OBJDIR)$(@:.test=-1.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=-1.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-1.$(DBG_STR)out)\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=-2.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-2.$(DBG_STR)in)\n\tcat $(@:.test=-2.$(DBG_STR)) >> $(OBJDIR)$(@:.test=-2.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=-2.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-2.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-1.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=-1.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-2.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=-2.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=-app.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port) $(OBJDIR)$(@:.test=-1.$(DBG_STR)in) \\\n\t      $(OBJDIR)$(@:.test=-1.$(DBG_STR)out) $(OBJDIR)$(@:.test=-2.$(DBG_STR)in) $(OBJDIR)$(@:.test=-2.$(DBG_STR)out)\n\n# Test that GDB can detach from Pin and then re-attach later.\n#\ngdb-detach-reattach-fixed-port.test: $(OBJDIR)reattach-loop$(EXE_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)pick-random-port$(EXE_SUFFIX) unused > $(OBJDIR)$(@:.test=.random)\n\t$(PIN) $(PINFLAGS_DEBUG) -appdebug_server_port `cat $(OBJDIR)$(@:.test=.random)` -- \\\n\t    $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote :'`cat $(OBJDIR)$(@:.test=.random)` \\\n\t    $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(GREP) 'target remote :'`cat $(OBJDIR)$(@:.test=.random)` $(OBJDIR)$(@:.test=.out) > $(OBJDIR)$(@:.test=.port)\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=-1.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-1.$(DBG_STR)in)\n\tcat $(@:.test=-1.$(DBG_STR)) >> $(OBJDIR)$(@:.test=-1.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=-1.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-1.$(DBG_STR)out)\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=-2.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-2.$(DBG_STR)in)\n\tcat $(@:.test=-2.$(DBG_STR)) >> $(OBJDIR)$(@:.test=-2.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=-2.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-2.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-1.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=-1.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-2.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=-2.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=-app.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port) $(OBJDIR)$(@:.test=-1.$(DBG_STR)in) \\\n\t    $(OBJDIR)$(@:.test=-1.$(DBG_STR)out) $(OBJDIR)$(@:.test=-2.$(DBG_STR)in) $(OBJDIR)$(@:.test=-2.$(DBG_STR)out) \\\n\t    $(OBJDIR)$(@:.test=.random)\n\n# Test that extended commands work using PinDB.  This also checks that the tool does _not_ receive\n# commands that start with the \"pin \" prefix.\n#\npindb-simple-command.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)simple-command-tool$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simple-command-tool$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that the debugger can write to an invalid address in the application.\n#\ninvalid-write.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t-$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Try debugging an application with lots of threads that exit at the same time.\n#\npindb-win-thread-stress.test: $(OBJDIR)win-thread-stress$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-thread-stress$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that we can single-step over an instruction that exits the calling thread while another thread\n# still exists.  We expect the debugger to stop after the thread exits, leaving the focus on\n# the one remaining thread.\n#\npindb-pthread-step-exit.test: $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Same test as above, but use GDB instead of PinDB.\n#\ngdb-pthread-step-exit.test: $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that we can debug an application where one thread exits the entire process\n# while another thread still exists.\n#\npindb-pthread-cont-exitgroup.test: $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that we can single-step over an instruction that exits the entire process while\n# another thread still exists.  We expect the debugger to stop after the exit call\n# and indicate that the process is terminated.\n#\npindb-pthread-step-exitgroup.test: $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that we can single-step over an instruction that triggers a custom breakpoint.\n# This should stop due to the custom breakpoint, without stepping over the instruction.\n# A subsequent step should skip the custom breakpoint and step over the instruction.\n#\npindb-step-custom-break.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX) $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) step-custom-break $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple-pindb$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(OBJDIR)$(@:.test=.pindbin.0) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare) $(OBJDIR)$(@:.test=.pindbin) \\\n\t      $(OBJDIR)$(@:.test=.pindbout)\n\n# Test the behavior when several threads stop at simultaneous tool breakpoints.\n# After one breakpoint is delivered, the others are pending.  This test makes\n# sure that the pending events are delivered one-at-a-time to GDB.  It also\n# tests that the tool can list the pending breakpoints.\n#\nsimultaneous-toolbreak.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\nsimultaneous-toolbreak_const_context.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 -const_context 1 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# After one breakpoint is delivered, the others are pending.  This test\n# squashes the pending breakpoints and then makes sure they are not\n# delivered to GDB.\n#\nsimultaneous-toolbreak-squash.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# After one breakpoint is delivered, the others are pending.  This test\n# changes the message of the pending breakpoints and then makes sure they\n# are delivered with the new message.\n#\nsimultaneous-toolbreak-change.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that we can attach GDB to the application after it has stopped\n# at several simultaneous tool breakpoints.  We expect GDB to attach\n# at the context of one of those breakpoints, and we expect the others\n# to be pending.\n#\nsimultaneous-toolbreak-attach.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) \\\n\t  -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 -wait_for_debugger \\\n\t    -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'Waiting for debugger to attach' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test runs with PinDB, which expects all breakpoints to be delivered\n# simultaneously.  Make sure that all 4 breakpoints are delivered at once,\n# and that none are pending.\n#\npindb-simultaneous-toolbreak.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test runs PinDB in a mode where each breakpoint is delivered one-\n# at-a-time (similar to GDB).  We make sure that there are pending breakpoints\n# after the first is delivered, and we make sure that all breakpoints are\n# delivered one-at-a-time.\n#\npindb-simultaneous-toolbreak-serialize.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test also runs PinDB in a mode where each breakpoint is delivered\n# one-at-a-time.  In this test, we squash the remaining breakpoints after\n# the first is delivered and then make sure that the squashed breakpoints\n# are not delivered.\n#\npindb-simultaneous-toolbreak-squash.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test also runs PinDB in a mode where each breakpoint is delivered\n# one-at-a-time.  In this test, we change the message of the remaining\n# breakpoints after the first is delivered and then make sure that the\n# breakpoints are delivered with the changed message.\n#\npindb-simultaneous-toolbreak-change.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# When breakpoints are delivered one-at-a-time, try single-stepping one\n# thread while there are pending breakpoints on the others.  The pending\n# breakpoints should not be delivered because the single-step doesn't\n# advance the execution of those threads.\n#\npindb-simultaneous-toolbreak-step.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# This is a stress test for simultaneous debugger events.  Each thread stops when\n# the thread is created, at a normal breakpoint, at a tool breakpoint, and stops\n# when the thread exits.  There is no serialization in this variant of the test,\n# so we expect that many events will be reported to the debugger simultaneously.\n# The test verifies that we get all the events.\n#\npindb-simultaneous-multi.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n        $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare3) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare4) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This test is identical to the one above except that we don't stop when new\n# threads are created or when they exit.  We use this test on Windows to avoid\n# a problem with the virus scanner.  If a virus scan happens when this test runs,\n# the scanner injects a new thread into the test application.  If the debugger\n# stops when new threads are created, the scanner thread causes an extra stop in\n# the debugger which causes the test to fail.  This variant of the test avoids\n# the problem by not stopping in the debugger when new threads start or exit.\n# We also run this test on Unix because it tests different code paths in Pin.\n#\npindb-simple-simultaneous-multi.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n        $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This is another stress test for simultaneous debugger events, similar to the\n# one above.  In this variant, Pin delivers the events one-at-a-time to the\n# debugger.  Again, we verifiy that the debugger gets them all.\n#\npindb-simultaneous-multi-serialize.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare3) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare4) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This test is identical to the one above except that we don't stop when new\n# threads are created or when they exit.  We use this test on Windows to avoid\n# a problem with the virus scanner.  See \"pindb-simple-simultaneous-multi.test\"\n# for more information.  We also run it on Unix because it tests different code\n# paths in Pin.\n#\npindb-simple-simultaneous-multi-serialize.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This is similar to \"simultaneous-toolbreak-attach\", but we use PinDB\n# instead of GDB.  The application stops at several simultaneous breakpoints\n# before PinDB attaches.  Since PinDB allows multiple simultaneous breakpoints,\n# we expect all of them to be visible when PinDB attaches, and there will be\n# no pending breakpoints.\n#\n# This is disabled on Windows, but it could probably be enabled there when Mantis #1839 is fixed.\n#\npindb-simultaneous-toolbreak-attach.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -wait_for_debugger -port $(OBJDIR)$(@:.test=.port) -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 \\\n\t    > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'Waiting for debugger to attach' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    --gdb-protocol=:`cat $(OBJDIR)$(@:.test=.port)` $(PINDB_USERFLAGS) < $(@:.test=.pindbin) > \\\n\t    $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address) \\\n\t  $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port)\n\n# Test that we can use a custom command to change the register state of the target application,\n# and then use the \"invalidate registers\" API to invalidate any stale register data in the\n# debugger protocol library.\n#\npindb-invalidate-regs.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)invalidate-regs$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)invalidate-regs$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --noprompt $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# This test validates stopping threads API called in application thread.\napp-pause-in-app-thread.test: $(OBJDIR)app-pause-in-app-thread-tool$(PINTOOL_SUFFIX) $(OBJDIR)app-pause-app$(EXE_SUFFIX)\n\t$(PIN) -t $(OBJDIR)app-pause-in-app-thread-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)app-pause-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out)\n\t$(CGREP) 'Threads stopped by application thread' $(OBJDIR)$(@:.test=.out) | $(QGREP) \"3\"\n\t$(RM) $(OBJDIR)$(@:.test=.out)\n\n# This test validates stopping threads API called in internal thread.\napp-pause-in-int-thread.test: $(OBJDIR)app-pause-in-int-thread-tool$(PINTOOL_SUFFIX) $(OBJDIR)app-pause-app$(EXE_SUFFIX)\n\t$(PIN) -t $(OBJDIR)app-pause-in-int-thread-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)app-pause-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out)\n\t$(CGREP) 'Threads stopped by internal thread' $(OBJDIR)$(@:.test=.out) | $(QGREP) \"3\"\n\t$(RM) $(OBJDIR)$(@:.test=.out)\n\ncheck-if-thread-stopped.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)check-if-thread-stopped$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)check-if-thread-stopped$(PINTOOL_SUFFIX) -threads 4\" \\\n\t  -o $(OBJDIR)$(@:.test=.toolout) > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\tsleep 5\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(QGREP) \"Finished\" $(OBJDIR)$(@:.test=.toolout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.toolout)\n\n# Tests GDB extension of retrieving loaded shared libraries\n# Also, this test changes the base address of libc.so as seen\n# by GDB to 0xd00dead and checks that GDB reports the expected\n# base address.\n#\ngdb-svr4-libraries-extension.test: $(OBJDIR)dlopen-dlclose$(EXE_SUFFIX) $(OBJDIR)library-load-tool$(PINTOOL_SUFFIX)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)library-load-tool$(PINTOOL_SUFFIX) -- \\\n\t    $(OBJDIR)dlopen-dlclose$(EXE_SUFFIX) `$(CXX) $(COMP_OBJ) /dev/null -print-file-name=libm.so` > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)dlopen-dlclose$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n\n##############################################################\n#\n# Build rules\n#\n##############################################################\n\n# This section contains the build rules for all binaries that have special build rules.\n# See makefile.default.rules for the default build rules.\n\n###### Special tools' build rules ######\n\n$(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX): $(OBJDIR)use-debugger-shell$(OBJ_SUFFIX) $(OBJDIR)debugger-shell$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches_before_breakpoint$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches_for_ymmtest$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches_for_ymmtest$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n###### Special applications' build rules ######\n\n$(OBJDIR)simple$(EXE_SUFFIX): simple.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)bphandler_app$(EXE_SUFFIX): bphandler_app.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)simple-static$(EXE_SUFFIX): simple.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(STATIC) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)exec$(EXE_SUFFIX): exec.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)fork$(EXE_SUFFIX): fork.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX): bptest.cpp bptest-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)action-pending-app$(EXE_SUFFIX): action-pending-app.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX): xmm.c xmm-asm-$(TARGET).s\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)thread$(EXE_SUFFIX): thread.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)thread-static$(EXE_SUFFIX): thread.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(STATIC) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)simple-pindb$(EXE_SUFFIX): simple-pindb.cpp $(OBJDIR)simple-pindb-asm-$(TARGET)$(OBJ_SUFFIX)\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(NO_RANDOM) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)checkpoint-app$(EXE_SUFFIX): checkpoint-app.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)watchpoint-app$(EXE_SUFFIX): watchpoint-app.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)callerapp$(EXE_SUFFIX): callerapp.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)fibonacci$(EXE_SUFFIX): $(TOOLS_ROOT)/ManualExamples/fibonacci.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)sleep-unix$(EXE_SUFFIX): sleep-unix.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX): debugger-shell-app.cpp debugger-shell-app-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)intercept-app$(EXE_SUFFIX): intercept-app.cpp intercept-app-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX): ymm.cpp ymm-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX): zmm.cpp $(OBJDIR)zmm-asm-$(TARGET)$(OBJ_SUFFIX)\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pc-change-bp$(EXE_SUFFIX): pc-change-bp.cpp pc-change-bp-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pc-change-async$(EXE_SUFFIX): pc-change-async.cpp pc-change-async-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)mt-exit$(EXE_SUFFIX): mt-exit.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)signal-catch$(EXE_SUFFIX): signal-catch.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-unhandled-exception$(EXE_SUFFIX): win-unhandled-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n \n$(OBJDIR)win-handled-exception$(EXE_SUFFIX): win-handled-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-continued-exception1$(EXE_SUFFIX): win-continued-exception1.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-continued-exception2$(EXE_SUFFIX): win-continued-exception2.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-software-exception$(EXE_SUFFIX): win-software-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-cpp-exception$(EXE_SUFFIX): win-cpp-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-exception-after-exit$(EXE_SUFFIX): win-exception-after-exit.cpp $(OBJDIR)$(DLL_PREFIX)win-exception-after-exit-dll$(DLL_SUFFIX)\n\t$(APP_CXX) $(APP_CXXFLAGS) $(COMP_EXE)$@ $< $(APP_LDFLAGS) $(APP_LIBS) $(OBJDIR)win-exception-after-exit-dll$(LIB_SUFFIX)\n\n$(OBJDIR)win-load-library$(EXE_SUFFIX): win-load-library.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)reattach-loop$(EXE_SUFFIX): reattach-loop.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(NO_PIC) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-thread-stress$(EXE_SUFFIX): win-thread-stress.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pthread-bare-exit$(EXE_SUFFIX): pthread-bare-exit.cpp pthread-bare-exit-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX): pthread-bare-exitgroup.cpp pthread-bare-exitgroup-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n# A simple threaded application that we use for several tests.  Both Windows and Posix (Unix)\n# versions export the function \"GlobalFunction()\", which the tests rely on.\n#\n$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX): thread-$(OS_TYPE).cpp\n\t$(APP_CXX) $(COMPONENT_INCLUDES) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)app-pause-app$(EXE_SUFFIX): app-pause-app.cpp $(THREADLIB)\n\t$(APP_CXX) $(COMPONENT_INCLUDES) $(APP_CXXFLAGS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS) $(APP_LPATHS) $(APP_LIBS) $(APP_LIB_ATOMIC)\n\n###### Special objects' build rules ######\n\n$(OBJDIR)stack-debugger$(OBJ_SUFFIX): $(TOOLS_ROOT)/ManualExamples/stack-debugger.cpp\n\t$(CXX) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)debugger-shell$(OBJ_SUFFIX): $(TOOLS_ROOT)/InstLib/debugger-shell.cpp\n\t$(CXX) $(TOOL_CXXFLAGS) $(SUPPRESS_WARNING_ALIGNED_NEW) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)start-fini-callback$(OBJ_SUFFIX): start-fini-callback.cpp\n\t$(CXX) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)simple-pindb-asm-$(TARGET)$(OBJ_SUFFIX): simple-pindb-asm-$(TARGET)$(ASM_SUFFIX)\n\t$(ASMBLR) $(ASM_FLAGS) $(DBG_INFO_CXX_ALWAYS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)win-foo-library$(OBJ_SUFFIX): win-foo-library.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DLL_CXXFLAGS) $(DBG_INFO_CXX_ALWAYS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX): set_xmm_scratches_$(TARGET)$(ASM_SUFFIX)\n\t$(ASMBLR) $(ASM_FLAGS) $(DBG_INFO_CXX_ALWAYS) $(COMP_OBJ)$@ $<\n\n###### Special dlls' build rules ######\n\n$(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX): $(OBJDIR)win-foo-library$(OBJ_SUFFIX)\n\t$(LINKER) $(APP_LDFLAGS_NOOPT) $(DLL_LDFLAGS) $(LINK_EXE)$@ $< $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)$(DLL_PREFIX)win-exception-after-exit-dll$(DLL_SUFFIX): win-exception-after-exit-dll.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS) $(DLL_CXXFLAGS) $(COMP_EXE)$@ $< $(APP_LDFLAGS) $(DLL_LDFLAGS) $(APP_LIBS)\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Debugger/dlopen-dlclose.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#define _GNU_SOURCE\n#include <dlfcn.h>\n#include <link.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// Macro to create empty function which won't be opt-out by\n// the compiler\n#define EMPTY_FUNCTION(name) \\\n    void name();        \\\n    __asm__(              \\\n    \".global \" #name \"\\n\" \\\n    #name \":\\n\"          \\\n    \"ret\\n\"               \\\n    )\n\nEMPTY_FUNCTION(AfterLoadLibrary);\nEMPTY_FUNCTION(AfterUnloadLibrary);\n\nint main(int argc, char* argv[])\n{\n    if (argc != 2)\n    {\n        fprintf(stderr, \"Usage: %s <path to dynamic library>\\n\", argv[0]);\n        exit(1);\n    }\n    const char* file = argv[1];\n    printf(\"Loading shared object %s\\n\", file);\n    fflush(stdout);\n    void *handle = dlopen(file, RTLD_NOW | RTLD_LOCAL);\n    if (NULL == handle)\n    {\n        fprintf(stderr,\"Failed to load %s - %s\\n\", file, dlerror());\n        exit(1);\n    }\n    AfterLoadLibrary();\n    printf(\"Unloading shared object %s\\n\", file);\n    fflush(stdout);\n    dlclose(handle);\n    AfterUnloadLibrary();\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/ToolUnitTests/dltest.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define ONE \"libone.dylib\"\n#define TWO \"libtwo.dylib\"\n#else\n#define ONE \"libone.so\"\n#define TWO \"libtwo.so\"\n#endif\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n#if defined(TARGET_MAC) || defined(TARGET_BSD)\n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);\n#else    \n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n#endif    \n    fprintf(stderr, \"Allocated %p\\n\",mem);\n    // This unmap should not trigger a flush\n    munmap(mem, 0x2000);\n    \n    Load(ONE, 1);\n    Load(TWO, 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/ToolUnitTests/dltest2.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define ONE \"libone.dylib\"\n#define TWO \"libtwo.dylib\"\n#else\n#define ONE \"libone.so\"\n#define TWO \"libtwo.so\"\n#endif\n\nvoid Load(char *name, int expect)\n{\n    int val;\n    double dval;\n    \n    void *handle;\n    int (*sym)();\n    double (*fsin)(double);\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n        \n    val = sym();\n    if (val != expect)\n        exit(1);\n\n    dlclose(handle);\n}\n\nint main()\n{\n    int i;\n    for(i = 0; i < 100; i++)\n    {\n        switch(1 + rand() % 2) {\n        case 1:\n            Load(ONE, 1);\n            break;\n        case 2:\n            Load(TWO, 2);\n            break;\n        }\n    }\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/ToolUnitTests/main_dll.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*! @file\n *  pin tool combined from multi-DLLs (main_dll, dynamic_secondary_dll, static_secondary_dll). \n *  This is the \"main DLL\", use PIN API only in this DLL\n *  usage of PIN API in dynamic_secondary_dll and static_secondary_dll is not allowed\n *  (see README for more inforamtion)\n *\n *  NOTE: New Pin image loader supports dynamic loading of Pin DLLs.\n *        Look at Mantis 3280 for implementation details.\n *        The test also validates the dynamic loading feature.\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"pin.H\"\n\nusing std::cerr;\nusing std::endl;\nusing std::hex;\n\nKNOB<BOOL> KnobEnumerate(KNOB_MODE_WRITEONCE, \"pintool\",\n    \"enumerate\", \"0\", \"Enumerate modules loaded by Pin\");\n\n/* ===================================================================== */\n/* Global Variables and Declerations */\n/* ===================================================================== */\n\nPIN_LOCK pinLock;\n\ntypedef VOID (* BEFORE_BBL)(ADDRINT ip);\ntypedef int (* INIT_F)(bool enumerate);\ntypedef VOID (* FINI_F)();\n\n// Functions pointers for dynamic_secondary_dll\nBEFORE_BBL pBeforeBBL2;\nINIT_F pInit2;\nFINI_F pFini2;\n\n// Dll imports for static_secondary_dll\nextern \"C\" __declspec( dllimport ) VOID BeforeBBL1(ADDRINT ip);\nextern \"C\" __declspec( dllimport ) VOID Init1();\nextern \"C\" __declspec( dllimport ) VOID Fini1();\n\n/* ===================================================================== */\n\n// This function is called before every basic block\nVOID PIN_FAST_ANALYSIS_CALL BeforeBBL(ADDRINT ip) \n{\n    PIN_GetLock(&pinLock, PIN_GetTid());\n    BeforeBBL1(ip);\n    pBeforeBBL2(ip);\n    PIN_ReleaseLock(&pinLock);\n}\n\n/* ===================================================================== */\n\n// Pin calls this function every time a new trace is encountered\nVOID Trace(TRACE trace, VOID *v)\n{\n    // Visit every basic block  in the trace\n    for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl))\n    {\n        // Insert a call to BeforeBBL before every bbl, passing the ip address.\n        BBL_InsertCall(bbl, IPOINT_BEFORE, (AFUNPTR)BeforeBBL, IARG_FAST_ANALYSIS_CALL, \n                       IARG_INST_PTR, IARG_END);\n    }\n}\n\nVOID ThreadStart(THREADID threadid, CONTEXT *ctxt, INT32 flags, VOID *v)\n{\n    PIN_GetLock(&pinLock, PIN_GetTid());\n    BeforeBBL1(0);\n    pBeforeBBL2(0);\n    PIN_ReleaseLock(&pinLock);\n}\n\nVOID ThreadFini(THREADID threadid, const CONTEXT *ctxt, INT32 code, VOID *v)\n{\n    PIN_GetLock(&pinLock, PIN_GetTid());\n    BeforeBBL1(0);\n    pBeforeBBL2(0);\n    PIN_ReleaseLock(&pinLock);\n}\n\n/* ===================================================================== */\n\n// This function is called when the application exits\nVOID Fini(INT32 code, VOID *v)\n{\n    Fini1();\n    pFini2();\n}\n\n// This function gets info of an image loaded by Pin loader.\n// Invoked by dl_iterate_phdr()\nint dl_iterate_callback(struct dl_phdr_info * info, size_t size, VOID * data)\n{\n    cerr << info->dlpi_name << \" \" << hex << info->dlpi_addr << \" \" << info->dlpi_phdr->p_memsz << endl;\n    // Increment module counter.\n    ++(*reinterpret_cast<int *>(data));\n    return 0;\n}\n\n/* ===================================================================== */\n\nint main(int argc, char * argv[])\n{\n    // Initialize pin\n    PIN_Init(argc, argv);\n\n    PIN_InitLock(&pinLock);\n\n    // Register Trace() to be called to instrument traces\n    TRACE_AddInstrumentFunction(Trace, 0);\n\n    // Register Fini() to be called when the application exits\n    PIN_AddFiniFunction(Fini, 0);\n\n    // Call Static secondary dll Init1()\n    Init1();\n\n    int nModules;\n\n    // Dynamic secondary dll - load library, initialize function pointers\n    // and call Init2()\n    VOID * module = dlopen(\"dynamic_secondary_dll.dll\", RTLD_NOW);\n    if (module == NULL)\n    {\n        cerr << \"Failed to load dynamic_secondary_dll.dll\" << endl;\n        exit(1);\n    }\n    pInit2 = reinterpret_cast<INIT_F>(dlsym(module, \"Init2\"));\n    pBeforeBBL2 = reinterpret_cast<BEFORE_BBL>(dlsym(module, \"BeforeBBL2\"));\n    pFini2 = reinterpret_cast<FINI_F>(dlsym(module, \"Fini2\"));\n    if (pInit2 == NULL || pBeforeBBL2 == NULL || pFini2 == NULL)\n    {\n        cerr << \"Failed to find proc addresses in dynamic_secondary_dll.dll\" << endl;\n        exit(1);\n    }\n\n    nModules = pInit2(KnobEnumerate);\n\n    int nModulesMain = 0;\n    // Enumerate DLLs currently loaded by Pin loader.\n    dl_iterate_phdr(dl_iterate_callback, &nModulesMain);\n\n    if (KnobEnumerate && ((nModulesMain <= 0) || (nModulesMain != nModules)))\n    {\n        // Failure. Module enumeration results in main and dynamic Dlls don't match.\n        PIN_ExitApplication(1);\n    }\n\n    // Start the program, never returns\n    PIN_StartProgram();\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/ToolUnitTests/security_w_pin_dll_load.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n * This tool verifies that change of current working directory by application\n * doesn't affect DLL search algorithm in subsequent loading of DLLs by Pin loader.\n * Search directories list for Pin loader remains persistent and determined\n * by Pin launcher before applications start to run instrumented.\n */\n\n#include \"pin.H\"\n#include <string>\n#include <iostream>\n\n#include <link.h>\n#include <dlfcn.h>\n\nusing std::string;\nusing std::endl;\nusing std::flush;\nusing std::cerr;\n\n/* ===================================================================== */\n\nint afterSetCurrentDirectory(void)\n{\n    cerr <<  \"Load dynamic_secondary_dll.dll\" << endl;\n    void * dllHandle = dlopen(\"dynamic_secondary_dll.dll\", RTLD_NOW);\n    if (NULL == dllHandle)\n    {\n        cerr << \"Failure loading dynamic_secondary_dll.dll : \" << dlerror() << endl << flush;\n        return 1;\n    }\n    return 0;\n    // Returns 1 on failure, 0 on success.\n}\n\nstatic VOID imageLoad(IMG img, VOID *v)\n{\n    if (IMG_IsMainExecutable(img))\n    {\n        cerr <<  \"Instrument AfterSetCurrentDirectory function\" << endl;\n        RTN rtn = RTN_FindByName(img, \"AfterSetCurrentDirectory\");\n        if (RTN_Valid(rtn))\n        {\n            if (!PIN_IsProbeMode())\n            {\n                // JIT mode\n                RTN_Replace(rtn, AFUNPTR(afterSetCurrentDirectory));\n                return;\n            }\n            else if (RTN_IsSafeForProbedReplacement(rtn))\n            {\n                // Probe mode\n                RTN_ReplaceProbed(rtn, AFUNPTR(afterSetCurrentDirectory));\n                return;\n            }\n        }\n        cerr <<  \"AfterSetCurrentDirectory function is not found or unsafe to instrument\" << endl << flush;\n        PIN_ExitProcess(2);\n    }\n}\n\nint main(int argc, char * argv[])\n{\n    PIN_InitSymbols();\n\n    // Initialize Pin\n    PIN_Init(argc, argv);\n\n    IMG_AddInstrumentFunction(imageLoad, 0);\n\n    // Start the program, never returns\n    PIN_StartProgram();\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/ToolUnitTests/dlclose_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define LIBCLOSE \"libclose1.dylib\"\n#else\n#define LIBCLOSE \"libclose1.so\"\n#endif\n\nvoid Load(const char * name)\n{\n    void * handle;\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    dlclose(handle);\n}\n\nint main()\n{\n    Load(LIBCLOSE);\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/tpss_lin_libc_tool.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n * This tool mimics the behavior of TPSS on Linux by adding probes to various libc functions.\n * However, in this tool these probes are merely empty wrappers that call the original functions.\n * The objective of the test is to verify that probe generation and insertion don't cause Pin\n * to crash.\n *\n * This file is part of the tpss_lin_libc tool and compiles against the tool's libc (e.g. PIN CRT).\n * This file implements all the intrumenting logic thus requires PIN headers.\n */\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <ctime>\n#include <unistd.h>\nusing std::string;\nusing std::ios;\nusing std::hex;\nusing std::cerr;\nusing std::ofstream;\nusing std::endl;\n\n/* ===================================================================== */\n/* Commandline Switches                                                  */\n/* ===================================================================== */\n\ntypedef int * INT_PTR;\n\ntypedef void * VOID_PTR;\n\ntypedef char * CHAR_PTR;\n\nofstream OutFile;\n\nKNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\", \"o\", \"tpss_lin_libc.txt\",\n        \"specify tool log file name\");\n\n/* ===================================================================== */\n/* Pointers to the original functions that we probe                      */\n/* ===================================================================== */\nextern AFUNPTR fptrnanosleep;\nextern AFUNPTR fptrdl_iterate_phdr;\nextern AFUNPTR fptrsystem;\nextern AFUNPTR fptralarm;\nextern AFUNPTR fptrrecvmsg;\nextern AFUNPTR fptrsendmsg;\nextern AFUNPTR fptrpause;\nextern AFUNPTR fptrsigtimedwait;\nextern AFUNPTR fptrsigwaitinfo;\nextern AFUNPTR fptrepoll_wait;\nextern AFUNPTR fptrppoll;\nextern AFUNPTR fptrmsgsnd;\nextern AFUNPTR fptrmsgrcv;\nextern AFUNPTR fptrsemop;\nextern AFUNPTR fptrsemtimedop;\nextern AFUNPTR fptrusleep;\nextern AFUNPTR fptrualarm;\nextern AFUNPTR fptrgetitimer;\nextern AFUNPTR fptrsigwait;\nextern AFUNPTR fptrmsgget;\nextern AFUNPTR fptrsemget;\nextern AFUNPTR fptrwait;\nextern AFUNPTR fptrwaitpid;\nextern AFUNPTR fptrwaitid;\nextern AFUNPTR fptrwait3;\nextern AFUNPTR fptrwait4;\nextern AFUNPTR fptrreadv;\nextern AFUNPTR fptrwritev;\nextern AFUNPTR fptrflock;\nextern AFUNPTR fptrflockfile;\nextern AFUNPTR fptrfunlockfile;\nextern AFUNPTR fptrlockf;\nextern AFUNPTR fptrsetenv;\nextern AFUNPTR fptrunsetenv;\nextern AFUNPTR fptrgetenv;\nextern AFUNPTR fptrperror;\nextern AFUNPTR fptrmmap;\nextern AFUNPTR fptrmunmap;\nextern AFUNPTR fptrfileno;\nextern AFUNPTR fptrgetpid;\nextern AFUNPTR fptrgetppid;\nextern AFUNPTR fptrmemset;\nextern AFUNPTR fptrmemcpy;\nextern AFUNPTR fptraccess;\nextern AFUNPTR fptrlseek;\nextern AFUNPTR fptrlseek64;\nextern AFUNPTR fptrfdatasync;\nextern AFUNPTR fptrunlink;\nextern AFUNPTR fptrstrlen;\nextern AFUNPTR fptrwcslen;\nextern AFUNPTR fptrstrcpy;\nextern AFUNPTR fptrstrncpy;\nextern AFUNPTR fptrstrcat;\nextern AFUNPTR fptrstrstr;\nextern AFUNPTR fptrstrrchr;\nextern AFUNPTR fptrstrcmp;\nextern AFUNPTR fptrstrncmp;\nextern AFUNPTR fptrsigaddset;\nextern AFUNPTR fptrsigdelset;\nextern AFUNPTR fptrstrerror;\nextern AFUNPTR fptrbind;\nextern AFUNPTR fptrlisten;\nextern AFUNPTR fptruname;\nextern AFUNPTR fptrgethostname;\nextern AFUNPTR fptrkill;\nextern AFUNPTR fptrsched_yield;\nextern AFUNPTR fptrtimer_settime;\nextern AFUNPTR fptrsigaltstack;\nextern AFUNPTR fptrshutdown;\nextern AFUNPTR fptrsleep;\nextern AFUNPTR fptrsocket;\nextern AFUNPTR fptrselect;\nextern AFUNPTR fptrpoll;\nextern AFUNPTR fptraccept;\nextern AFUNPTR fptrconnect;\nextern AFUNPTR fptrrecv;\nextern AFUNPTR fptrrecvfrom;\nextern AFUNPTR fptrsend;\nextern AFUNPTR fptrgetwc;\nextern AFUNPTR fptrsetitimer;\nextern AFUNPTR fptrsigpending;\nextern AFUNPTR fptrsigaction;\nextern AFUNPTR fptrsignal;\nextern AFUNPTR fptrabort;\nextern AFUNPTR fptrsendto;\nextern AFUNPTR fptr_IO_getc;\nextern AFUNPTR fptrgetchar;\nextern AFUNPTR fptrgetwchar;\nextern AFUNPTR fptrgets;\nextern AFUNPTR fptrfgets;\nextern AFUNPTR fptrfgetwc;\nextern AFUNPTR fptrfread;\nextern AFUNPTR fptrfwrite;\nextern AFUNPTR fptropen;\nextern AFUNPTR fptrgetw;\nextern AFUNPTR fptrfgetc;\nextern AFUNPTR fptrfgetws;\nextern AFUNPTR fptrpipe;\nextern AFUNPTR fptrread;\nextern AFUNPTR fptrwrite;\nextern AFUNPTR fptrfopen;\nextern AFUNPTR fptrfdopen;\nextern AFUNPTR fptrclose;\nextern AFUNPTR fptrfclose;\nextern AFUNPTR fptrcallrpc;\nextern AFUNPTR fptrclnt_broadcast;\nextern AFUNPTR fptrclntudp_create;\nextern AFUNPTR fptrclntudp_bufcreate;\nextern AFUNPTR fptrpmap_getmaps;\nextern AFUNPTR fptrpmap_getport;\nextern AFUNPTR fptrpmap_rmtcall;\nextern AFUNPTR fptrpmap_set;\nextern AFUNPTR fptrclntraw_create;\nextern AFUNPTR fptrsvc_run;\nextern AFUNPTR fptrsvc_sendreply;\nextern AFUNPTR fptrsvcraw_create;\nextern AFUNPTR fptrsvctcp_create;\nextern AFUNPTR fptrsvcudp_bufcreate;\nextern AFUNPTR fptrsvcudp_create;\nextern AFUNPTR fptr_exit;\nextern AFUNPTR fptrsigprocmask;\nextern AFUNPTR fptrexit;\nextern AFUNPTR fptrpselect;\nextern AFUNPTR fptrioctl;\nextern AFUNPTR fptr__libc_dlopen_mode;\nextern AFUNPTR fptr__errno_location;\nextern AFUNPTR fptrsyscall;\n\n/* ===================================================================== */\n/* Replacement functions implemented in the other part of the tool       */\n/* ===================================================================== */\nextern \"C\"\n{\nvoid mysleep();\nvoid mysocket();\nvoid myshutdown();\nvoid myselect();\nvoid mypoll();\nvoid mypselect();\nvoid myaccept();\nvoid myconnect();\nvoid myrecv();\nvoid myrecvfrom();\nvoid mysend();\nvoid mysendto();\nvoid mygetwc();\nvoid mygetw();\nvoid my_IO_getc();\nvoid mygetchar();\nvoid mygetwchar();\nvoid mygets();\nvoid myfgetc();\nvoid myfgetwc();\nvoid myfgets();\nvoid myfgetws();\nvoid myfread();\nvoid myfwrite();\nvoid mypipe();\nvoid myread();\nvoid mywrite();\nvoid myopen();\nvoid myfopen();\nvoid myfdopen();\nvoid myclose();\nvoid myfclose();\nvoid mycallrpc();\nvoid myclnt_broadcast();\nvoid myclntudp_create();\nvoid myclntudp_bufcreate();\nvoid mypmap_getmaps();\nvoid mypmap_getport();\nvoid mypmap_rmtcall();\nvoid mypmap_set();\nvoid myclntraw_create();\nvoid mysvc_run();\nvoid mysvc_sendreply();\nvoid mysvcraw_create();\nvoid mysvctcp_create();\nvoid mysvcudp_bufcreate();\nvoid mysvcudp_create();\nvoid myabort();\nvoid my_exit();\nvoid my_nanosleep();\nvoid mysignal();\nvoid mysigprocmask();\nvoid mysigpending();\nvoid mysigaction();\nvoid mysetitimer();\nvoid myexit();\nvoid mydl_iterate_phdr();\nvoid mysystem();\nvoid myalarm();\nvoid myrecvmsg();\nvoid mysendmsg();\nvoid mypause();\nvoid mysigtimedwait();\nvoid mysigwaitinfo();\nvoid myepoll_wait();\nvoid myppoll();\nvoid mymsgsnd();\nvoid mymsgrcv();\nvoid mymsgrcv();\nvoid mysemtimedop();\nvoid myusleep();\nvoid myualarm();\nvoid mygetitimer();\nvoid mysigwait();\nvoid mymsgget();\nvoid mysemget();\nvoid mywait();\nvoid mywaitpid();\nvoid mywaitid();\nvoid mywait3();\nvoid mywait4();\nvoid myreadv();\nvoid mywritev();\nvoid myflockfile();\nvoid mylockf();\nvoid mysetenv();\nvoid myunsetenv();\nvoid mygetenv();\nvoid myperror();\nvoid mymmap();\nvoid mymunmap();\nvoid myfileno();\nvoid mygetpid();\nvoid mygetppid();\nvoid mymemset();\nvoid mymemcpy();\nvoid myaccess();\nvoid mylseek();\nvoid mylseek64();\nvoid myfdatasync();\nvoid myunlink();\nvoid mystrlen();\nvoid mywcslen();\nvoid mystrcpy();\nvoid mystrcpy();\nvoid mystrcat();\nvoid mystrstr();\nvoid mystrchr0();\nvoid mystrrchr();\nvoid mystrcmp();\nvoid mystrncmp();\nvoid mysigaddset();\nvoid mysigdelset();\nvoid mysigismember();\nvoid mystrerror();\nvoid mybind();\nvoid mylisten();\nvoid myuname();\nvoid mygethostname();\nvoid mykill();\nvoid mysched_yield();\nvoid mytimer_settime();\nvoid mysigaltstack();\nvoid myioctl();\nvoid myflock();\nvoid my__libc_dlopen_mode();\nvoid my__errno_location();\nvoid mysyscall();\nvoid myfunlockfile();\n}\n\n/* ===================================================================== */\n/* Utility functions                                                     */\n/* ===================================================================== */\n\n// Print help information\nINT32 Usage() {\n    cerr\n            << \"This tool mimics the behavior of TPSS on Linux by adding probes to various libc functions.\"\n            << endl;\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return 1;\n}\n\n// Utility function to return the time\nstring CurrentTime() {\n    char tmpbuf[128];\n    time_t thetime = time(NULL);\n    ctime_r(&thetime, tmpbuf);\n    return tmpbuf;\n}\n\nextern \"C\" void printFunctionCalled(const char* funcName)\n{\n    OutFile << CurrentTime() << funcName << \" called \" << endl;\n    OutFile.flush();\n}\n\nbool is_GLIBC2_24_or_newer(IMG img)\n{\n    char path[PATH_MAX] = {0};\n    if (0 <= readlink(IMG_Name(img).c_str(), path, sizeof(path)-1))\n    {\n        return (string(\"libc-2.24.so\") == basename(path));\n    }\n    return false;\n}\n\n/* ===================================================================== */\n/* Instrumnetation functions                                             */\n/* ===================================================================== */\n\n// Image load callback - inserts the probes.\nvoid ImgLoad(IMG img, VOID_PTR v) {\n    // Called every time a new image is loaded\n    if ((IMG_Name(img).find(\"libc.so\") != string::npos)\n            || (IMG_Name(img).find(\"LIBC.SO\") != string::npos)\n            || (IMG_Name(img).find(\"LIBC.so\") != string::npos))\n    {\n\n        RTN rtnsleep = RTN_FindByName(img, \"sleep\");\n        if (RTN_Valid(rtnsleep) && RTN_IsSafeForProbedReplacement(rtnsleep))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sleep at \"\n                    << RTN_Address(rtnsleep) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsleep, AFUNPTR(mysleep)));\n            fptrsleep = fptr;\n        }\n\n        RTN rtnsocket = RTN_FindByName(img, \"socket\");\n        if (RTN_Valid(rtnsocket) && RTN_IsSafeForProbedReplacement(rtnsocket))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for socket at \"\n                    << RTN_Address(rtnsocket) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsocket, AFUNPTR(mysocket)));\n            fptrsocket = fptr;\n        }\n\n        RTN rtnshutdown = RTN_FindByName(img, \"shutdown\");\n        if (RTN_Valid(rtnshutdown)\n                && RTN_IsSafeForProbedReplacement(rtnshutdown))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for shutdown at \" << RTN_Address(rtnshutdown) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnshutdown, AFUNPTR(myshutdown)));\n            fptrshutdown = fptr;\n        }\n\n        RTN rtnselect = RTN_FindByName(img, \"select\");\n        if (RTN_Valid(rtnselect) && RTN_IsSafeForProbedReplacement(rtnselect))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for select at \" << RTN_Address(rtnselect) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnselect, AFUNPTR(myselect)));\n            fptrselect = fptr;\n        }\n\n        RTN rtnpoll = RTN_FindByName(img, \"poll\");\n        if (RTN_Valid(rtnpoll) && RTN_IsSafeForProbedReplacement(rtnpoll))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for poll at \" << RTN_Address(rtnpoll) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpoll, AFUNPTR(mypoll)));\n            fptrpoll = fptr;\n        }\n\n        RTN rtnpselect = RTN_FindByName(img, \"pselect\");\n        if (RTN_Valid(rtnpselect)\n                && RTN_IsSafeForProbedReplacement(rtnpselect))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pselect at \"\n                    << RTN_Address(rtnpselect) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpselect, AFUNPTR(mypselect)));\n            fptrpselect = fptr;\n        }\n\n        RTN rtnaccept = RTN_FindByName(img, \"accept\");\n        if (RTN_Valid(rtnaccept) && RTN_IsSafeForProbedReplacement(rtnaccept))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for accept at \" << RTN_Address(rtnaccept) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnaccept, AFUNPTR(myaccept)));\n            fptraccept = fptr;\n        }\n\n        RTN rtnconnect = RTN_FindByName(img, \"connect\");\n        if (RTN_Valid(rtnconnect) && RTN_IsSafeForProbedReplacement(rtnconnect))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for connect at \" << RTN_Address(rtnconnect) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnconnect, AFUNPTR(myconnect)));\n            fptrconnect = fptr;\n        }\n\n        RTN rtnrecv = RTN_FindByName(img, \"recv\");\n        if (RTN_Valid(rtnrecv) && RTN_IsSafeForProbedReplacement(rtnrecv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for recv at \" << RTN_Address(rtnrecv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnrecv, AFUNPTR(myrecv)));\n            fptrrecv = fptr;\n        }\n\n        RTN rtnrecvfrom = RTN_FindByName(img, \"recvfrom\");\n        if (RTN_Valid(rtnrecvfrom) && RTN_IsSafeForProbedReplacement(rtnrecvfrom))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for recvfrom at \" << RTN_Address(rtnrecvfrom) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnrecvfrom, AFUNPTR(myrecvfrom)));\n            fptrrecvfrom = fptr;\n        }\n\n        RTN rtnsend = RTN_FindByName(img, \"send\");\n        if (RTN_Valid(rtnsend) && RTN_IsSafeForProbedReplacement(rtnsend))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for send at \" << RTN_Address(rtnsend) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsend, AFUNPTR(mysend)));\n            fptrsend = fptr;\n        }\n\n        RTN rtnsendto = RTN_FindByName(img, \"sendto\");\n        if (RTN_Valid(rtnsendto) && RTN_IsSafeForProbedReplacement(rtnsendto))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sendto at \" << RTN_Address(rtnsendto) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsendto, AFUNPTR(mysendto)));\n            fptrsendto = fptr;\n        }\n\n        RTN rtngetwc = RTN_FindByName(img, \"getwc\");\n        if (RTN_Valid(rtngetwc) && RTN_IsSafeForProbedReplacement(rtngetwc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getwc at \" << RTN_Address(rtngetwc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetwc, AFUNPTR(mygetwc)));\n            fptrgetwc = fptr;\n        }\n\n        RTN rtngetw = RTN_FindByName(img, \"getw\");\n        if (RTN_Valid(rtngetw) && RTN_IsSafeForProbedReplacement(rtngetw))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getw at \" << RTN_Address(rtngetw) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetw, AFUNPTR(mygetw)));\n            fptrgetw = fptr;\n        }\n\n        RTN rtn_IO_getc = RTN_FindByName(img, \"_IO_getc\");\n        if (RTN_Valid(rtn_IO_getc)\n                && RTN_IsSafeForProbedReplacement(rtn_IO_getc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for _IO_getc at \" << RTN_Address(rtn_IO_getc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn_IO_getc, AFUNPTR(my_IO_getc)));\n            fptr_IO_getc = fptr;\n        }\n\n        RTN rtngetchar = RTN_FindByName(img, \"getchar\");\n        if (RTN_Valid(rtngetchar) && RTN_IsSafeForProbedReplacement(rtngetchar))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getchar at \" << RTN_Address(rtngetchar) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetchar, AFUNPTR(mygetchar)));\n            fptrgetchar = fptr;\n        }\n\n        RTN rtngetwchar = RTN_FindByName(img, \"getwchar\");\n        if (RTN_Valid(rtngetwchar) && RTN_IsSafeForProbedReplacement(rtngetwchar))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getwchar at \"\n                    << RTN_Address(rtngetwchar) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetwchar, AFUNPTR(mygetwchar)));\n            fptrgetwchar = fptr;\n        }\n\n        RTN rtngets = RTN_FindByName(img, \"gets\");\n        if (RTN_Valid(rtngets) && RTN_IsSafeForProbedReplacement(rtngets))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for gets at \" << RTN_Address(rtngets) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngets, AFUNPTR(mygets)));\n            fptrgets = fptr;\n        }\n\n        RTN rtnfgetc = RTN_FindByName(img, \"fgetc\");\n        if (RTN_Valid(rtnfgetc) && RTN_IsSafeForProbedReplacement(rtnfgetc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgetc at \" << RTN_Address(rtnfgetc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgetc, AFUNPTR(myfgetc)));\n            fptrfgetc = fptr;\n        }\n\n        RTN rtnfgetwc = RTN_FindByName(img, \"fgetwc\");\n        if (RTN_Valid(rtnfgetwc) && RTN_IsSafeForProbedReplacement(rtnfgetwc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgetwc at \" << RTN_Address(rtnfgetwc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgetwc, AFUNPTR(myfgetwc)));\n            fptrfgetwc = fptr;\n        }\n\n        RTN rtnfgets = RTN_FindByName(img, \"fgets\");\n        if (RTN_Valid(rtnfgets) && RTN_IsSafeForProbedReplacement(rtnfgets))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgets at \" << RTN_Address(rtnfgets) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgets, AFUNPTR(myfgets)));\n            fptrfgets = fptr;\n        }\n\n        RTN rtnfgetws = RTN_FindByName(img, \"fgetws\");\n        if (RTN_Valid(rtnfgetws) && RTN_IsSafeForProbedReplacement(rtnfgetws))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgetws at \" << RTN_Address(rtnfgetws) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgetws, AFUNPTR(myfgetws)));\n            fptrfgetws = fptr;\n        }\n\n        RTN rtnfread = RTN_FindByName(img, \"fread\");\n        if (RTN_Valid(rtnfread) && RTN_IsSafeForProbedReplacement(rtnfread))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fread at \" << RTN_Address(rtnfread) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfread, AFUNPTR(myfread)));\n            fptrfread = fptr;\n        }\n\n        RTN rtnfwrite = RTN_FindByName(img, \"fwrite\");\n        if (RTN_Valid(rtnfwrite) && RTN_IsSafeForProbedReplacement(rtnfwrite))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fwrite at \" << RTN_Address(rtnfwrite) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfwrite, AFUNPTR(myfwrite)));\n            fptrfwrite = fptr;\n        }\n\n        RTN rtnpipe = RTN_FindByName(img, \"pipe\");\n        if (RTN_Valid(rtnpipe) && RTN_IsSafeForProbedReplacement(rtnpipe))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pipe at \" << RTN_Address(rtnpipe) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpipe, AFUNPTR(mypipe)));\n            fptrpipe = fptr;\n        }\n\n        RTN rtnread = RTN_FindByName(img, \"read\");\n        if (RTN_Valid(rtnread) && RTN_IsSafeForProbedReplacement(rtnread))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for read at \" << RTN_Address(rtnread) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnread, AFUNPTR(myread)));\n            fptrread = fptr;\n        }\n\n        RTN rtnwrite = RTN_FindByName(img, \"write\");\n        if (RTN_Valid(rtnwrite) && RTN_IsSafeForProbedReplacement(rtnwrite))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for write at \" << RTN_Address(rtnwrite) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwrite, AFUNPTR(mywrite)));\n            fptrwrite = fptr;\n        }\n\n        RTN rtnopen = RTN_FindByName(img, \"open\");\n        if (RTN_Valid(rtnopen) && RTN_IsSafeForProbedReplacement(rtnopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for open at \" << RTN_Address(rtnopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnopen, AFUNPTR(myopen)));\n            fptropen = fptr;\n        }\n\n        RTN rtnfopen = RTN_FindByName(img, \"fopen\");\n        if (RTN_Valid(rtnfopen) && RTN_IsSafeForProbedReplacement(rtnfopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fopen at \" << RTN_Address(rtnfopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfopen, AFUNPTR(myfopen)));\n            fptrfopen = fptr;\n        }\n\n        RTN rtnfdopen = RTN_FindByName(img, \"fdopen\");\n        if (RTN_Valid(rtnfdopen) && RTN_IsSafeForProbedReplacement(rtnfdopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fdopen at \" << RTN_Address(rtnfdopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfdopen, AFUNPTR(myfdopen)));\n            fptrfdopen = fptr;\n        }\n\n        RTN rtnclose = RTN_FindByName(img, \"close\");\n        if (RTN_Valid(rtnclose) && RTN_IsSafeForProbedReplacement(rtnclose))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for close at \" << RTN_Address(rtnclose) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclose, AFUNPTR(myclose)));\n            fptrclose = fptr;\n        }\n\n        RTN rtnfclose = RTN_FindByName(img, \"fclose\");\n        if (RTN_Valid(rtnfclose) && RTN_IsSafeForProbedReplacement(rtnfclose))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fclose at \" << RTN_Address(rtnfclose) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfclose, AFUNPTR(myfclose)));\n            fptrfclose = fptr;\n        }\n\n        RTN rtncallrpc = RTN_FindByName(img, \"callrpc\");\n        if (RTN_Valid(rtncallrpc)&& RTN_IsSafeForProbedReplacement(rtncallrpc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for callrpc at \" << RTN_Address(rtncallrpc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtncallrpc, AFUNPTR(mycallrpc)));\n            fptrcallrpc = fptr;\n        }\n\n        RTN rtnclnt_broadcast = RTN_FindByName(img, \"clnt_broadcast\");\n        if (RTN_Valid(rtnclnt_broadcast)\n                && RTN_IsSafeForProbedReplacement(rtnclnt_broadcast))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for clnt_broadcast at \" << RTN_Address(rtnclnt_broadcast) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclnt_broadcast, AFUNPTR(myclnt_broadcast)));\n            fptrclnt_broadcast = fptr;\n        }\n\n        RTN rtnclntudp_create = RTN_FindByName(img, \"clntudp_create\");\n        if (RTN_Valid(rtnclntudp_create)\n                && RTN_IsSafeForProbedReplacement(rtnclntudp_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for clntudp_create at \" << RTN_Address(rtnclntudp_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclntudp_create, AFUNPTR(myclntudp_create)));\n            fptrclntudp_create = fptr;\n        }\n\n        RTN rtnclntudp_bufcreate = RTN_FindByName(img, \"clntudp_bufcreate\");\n        if (RTN_Valid(rtnclntudp_bufcreate) && RTN_IsSafeForProbedReplacement(rtnclntudp_bufcreate))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for clntudp_bufcreate at \" << RTN_Address(rtnclntudp_bufcreate) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclntudp_bufcreate, AFUNPTR(myclntudp_bufcreate)));\n            fptrclntudp_bufcreate = fptr;\n        }\n\n        RTN rtnpmap_getmaps = RTN_FindByName(img, \"pmap_getmaps\");\n        if (RTN_Valid(rtnpmap_getmaps) && RTN_IsSafeForProbedReplacement(rtnpmap_getmaps))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_getmaps at \" << RTN_Address(rtnpmap_getmaps) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_getmaps, AFUNPTR(mypmap_getmaps)));\n            fptrpmap_getmaps = fptr;\n        }\n\n        RTN rtnpmap_getport = RTN_FindByName(img, \"pmap_getport\");\n        if (RTN_Valid(rtnpmap_getport) && RTN_IsSafeForProbedReplacement(rtnpmap_getport))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_getport at \" << RTN_Address(rtnpmap_getport) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_getport, AFUNPTR(mypmap_getport)));\n            fptrpmap_getport = fptr;\n        }\n\n        RTN rtnpmap_rmtcall = RTN_FindByName(img, \"pmap_rmtcall\");\n        if (RTN_Valid(rtnpmap_rmtcall) && RTN_IsSafeForProbedReplacement(rtnpmap_rmtcall))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_rmtcall at \" << RTN_Address(rtnpmap_rmtcall) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_rmtcall, AFUNPTR(mypmap_rmtcall)));\n            fptrpmap_rmtcall = fptr;\n        }\n\n        RTN rtnpmap_set = RTN_FindByName(img, \"pmap_set\");\n        if (RTN_Valid(rtnpmap_set) && RTN_IsSafeForProbedReplacement(rtnpmap_set))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_set at \" << RTN_Address(rtnpmap_set) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_set, AFUNPTR(mypmap_set)));\n            fptrpmap_set = fptr;\n        }\n\n        RTN rtnclntraw_create = RTN_FindByName(img, \"clntraw_create\");\n        if (RTN_Valid(rtnclntraw_create)\n                && RTN_IsSafeForProbedReplacement(rtnclntraw_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for clntraw_create at \" << RTN_Address(rtnclntraw_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclntraw_create, AFUNPTR(myclntraw_create)));\n            fptrclntraw_create = fptr;\n        }\n\n        RTN rtnsvc_run = RTN_FindByName(img, \"svc_run\");\n        if (RTN_Valid(rtnsvc_run) && RTN_IsSafeForProbedReplacement(rtnsvc_run))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svc_run at \"\n                    << RTN_Address(rtnsvc_run) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvc_run, AFUNPTR(mysvc_run)));\n            fptrsvc_run = fptr;\n        }\n\n        RTN rtnsvc_sendreply = RTN_FindByName(img, \"svc_sendreply\");\n        if (RTN_Valid(rtnsvc_sendreply) && RTN_IsSafeForProbedReplacement(rtnsvc_sendreply))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svc_sendreply at \" << RTN_Address(rtnsvc_sendreply) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvc_sendreply, AFUNPTR(mysvc_sendreply)));\n            fptrsvc_sendreply = fptr;\n        }\n\n        RTN rtnsvcraw_create = RTN_FindByName(img, \"svcraw_create\");\n        if (RTN_Valid(rtnsvcraw_create) && RTN_IsSafeForProbedReplacement(rtnsvcraw_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svcraw_create at \" << RTN_Address(rtnsvcraw_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvcraw_create, AFUNPTR(mysvcraw_create)));\n            fptrsvcraw_create = fptr;\n        }\n\n        RTN rtnsvctcp_create = RTN_FindByName(img, \"svctcp_create\");\n        if (RTN_Valid(rtnsvctcp_create) && RTN_IsSafeForProbedReplacement(rtnsvctcp_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svctcp_create at \" << RTN_Address(rtnsvctcp_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvctcp_create, AFUNPTR(mysvctcp_create)));\n            fptrsvctcp_create = fptr;\n        }\n\n        RTN rtnsvcudp_bufcreate = RTN_FindByName(img, \"svcudp_bufcreate\");\n        if (RTN_Valid(rtnsvcudp_bufcreate) && RTN_IsSafeForProbedReplacement(rtnsvcudp_bufcreate))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svcudp_bufcreate at \" << RTN_Address(rtnsvcudp_bufcreate) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvcudp_bufcreate, AFUNPTR(mysvcudp_bufcreate)));\n            fptrsvcudp_bufcreate = fptr;\n        }\n\n        RTN rtnsvcudp_create = RTN_FindByName(img, \"svcudp_create\");\n        if (RTN_Valid(rtnsvcudp_create) && RTN_IsSafeForProbedReplacement(rtnsvcudp_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svcudp_create at \" << RTN_Address(rtnsvcudp_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvcudp_create, AFUNPTR(mysvcudp_create)));\n            fptrsvcudp_create = fptr;\n        }\n\n        RTN rtnabort = RTN_FindByName(img, \"abort\");\n        if (RTN_Valid(rtnabort) && RTN_IsSafeForProbedReplacement(rtnabort))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for abort at \" << RTN_Address(rtnabort) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnabort, AFUNPTR(myabort)));\n            fptrabort = fptr;\n        }\n\n        RTN rtn_exit = RTN_FindByName(img, \"_exit\");\n        if (RTN_Valid(rtn_exit) && RTN_IsSafeForProbedReplacement(rtn_exit))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for _exit at \" << RTN_Address(rtn_exit) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn_exit, AFUNPTR(my_exit)));\n            fptr_exit = fptr;\n        }\n\n        RTN rtnnanosleep = RTN_FindByName(img, \"nanosleep\");\n        if (RTN_Valid(rtnnanosleep) && RTN_IsSafeForProbedReplacement(rtnnanosleep))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for nanosleep at \" << RTN_Address(rtnnanosleep) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnnanosleep, AFUNPTR(my_nanosleep)));\n            fptrnanosleep = fptr;\n        }\n\n        RTN rtnsignal = RTN_FindByName(img, \"signal\");\n        if (RTN_Valid(rtnsignal) && RTN_IsSafeForProbedReplacement(rtnsignal))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for signal at \" << RTN_Address(rtnsignal) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsignal, AFUNPTR(mysignal)));\n            fptrsignal = fptr;\n        }\n\n        RTN rtnsigprocmask = RTN_FindByName(img, \"sigprocmask\");\n        if (RTN_Valid(rtnsigprocmask) && RTN_IsSafeForProbedReplacement(rtnsigprocmask))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigprocmask at \" << RTN_Address(rtnsigprocmask) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigprocmask, AFUNPTR(mysigprocmask)));\n            fptrsigprocmask = fptr;\n        }\n\n        RTN rtnsigpending = RTN_FindByName(img, \"sigpending\");\n        if (RTN_Valid(rtnsigpending) && RTN_IsSafeForProbedReplacement(rtnsigpending))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigpending at \" << RTN_Address(rtnsigpending) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigpending, AFUNPTR(mysigpending)));\n            fptrsigpending = fptr;\n        }\n\n        RTN rtnsigaction = RTN_FindByName(img, \"sigaction\");\n        if (RTN_Valid(rtnsigaction) && RTN_IsSafeForProbedReplacement(rtnsigaction))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigaction at \" << RTN_Address(rtnsigaction) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigaction, AFUNPTR(mysigaction)));\n            fptrsigaction = fptr;\n        }\n\n        RTN rtnsetitimer = RTN_FindByName(img, \"setitimer\");\n        if (RTN_Valid(rtnsetitimer) && RTN_IsSafeForProbedReplacement(rtnsetitimer))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for setitimer at \" << RTN_Address(rtnsetitimer) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsetitimer, AFUNPTR(mysetitimer)));\n            fptrsetitimer = fptr;\n        }\n\n        RTN rtnexit = RTN_FindByName(img, \"exit\");\n        if (RTN_Valid(rtnexit) && RTN_IsSafeForProbedReplacement(rtnexit))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for exit at \" << RTN_Address(rtnexit) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnexit, AFUNPTR(myexit)));\n            fptrexit = fptr;\n        }\n\n        RTN rtndl_iterate_phdr = RTN_FindByName(img, \"dl_iterate_phdr\");\n        if (RTN_Valid(rtnexit) && RTN_IsSafeForProbedReplacement(rtndl_iterate_phdr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dl_iterate_phdr at \" << RTN_Address(rtndl_iterate_phdr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndl_iterate_phdr, AFUNPTR(mydl_iterate_phdr)));\n            fptrdl_iterate_phdr = fptr;\n        }\n\n        RTN rtnsystem = RTN_FindByName(img, \"system\");\n        if (RTN_Valid(rtnsystem) && RTN_IsSafeForProbedReplacement(rtnsystem))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for system at \"\n                    << RTN_Address(rtnsystem) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsystem, AFUNPTR(mysystem)));\n            fptrsystem = fptr;\n        }\n\n        RTN rtnalarm = RTN_FindByName(img, \"alarm\");\n        if (RTN_Valid(rtnalarm) && RTN_IsSafeForProbedReplacement(rtnalarm))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for alarm at \"\n                    << RTN_Address(rtnalarm) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnalarm, AFUNPTR(myalarm)));\n            fptralarm = fptr;\n        }\n\n        RTN rtnrecvmsg = RTN_FindByName(img, \"recvmsg\");\n        if (RTN_Valid(rtnrecvmsg) && RTN_IsSafeForProbedReplacement(rtnrecvmsg))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for recvmsg at \" << RTN_Address(rtnrecvmsg) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnrecvmsg, AFUNPTR(myrecvmsg)));\n            fptrrecvmsg = fptr;\n        }\n\n        RTN rtnsendmsg = RTN_FindByName(img, \"sendmsg\");\n        if (RTN_Valid(rtnsendmsg) && RTN_IsSafeForProbedReplacement(rtnsendmsg))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sendmsg at \"\n                    << RTN_Address(rtnsendmsg) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsendmsg, AFUNPTR(mysendmsg)));\n            fptrsendmsg = fptr;\n        }\n\n        RTN rtnpause = RTN_FindByName(img, \"pause\");\n        if (RTN_Valid(rtnpause) && RTN_IsSafeForProbedReplacement(rtnpause))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pause at \"\n                    << RTN_Address(rtnpause) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpause, AFUNPTR(mypause)));\n            fptrpause = fptr;\n        }\n\n        RTN rtnsigtimedwait = RTN_FindByName(img, \"sigtimedwait\");\n        if (RTN_Valid(rtnsigtimedwait) && RTN_IsSafeForProbedReplacement(rtnsigtimedwait))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigtimedwait at \" << RTN_Address(rtnsigtimedwait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigtimedwait, AFUNPTR(mysigtimedwait)));\n            fptrsigtimedwait = fptr;\n        }\n\n        RTN rtnsigwaitinfo = RTN_FindByName(img, \"sigwaitinfo\");\n        if (RTN_Valid(rtnsigwaitinfo) && RTN_IsSafeForProbedReplacement(rtnsigwaitinfo))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigwaitinfo at \" << RTN_Address(rtnsigwaitinfo) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigwaitinfo, AFUNPTR(mysigwaitinfo)));\n            fptrsigwaitinfo = fptr;\n        }\n\n        RTN rtnepoll_wait = RTN_FindByName(img, \"epoll_wait\");\n        if (RTN_Valid(rtnepoll_wait) && RTN_IsSafeForProbedReplacement(rtnepoll_wait))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for epoll_wait at \" << RTN_Address(rtnepoll_wait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnepoll_wait, AFUNPTR(myepoll_wait)));\n            fptrepoll_wait = fptr;\n        }\n\n        RTN rtnppoll = RTN_FindByName(img, \"ppoll\");\n        if (RTN_Valid(rtnppoll) && RTN_IsSafeForProbedReplacement(rtnppoll))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for ppoll at \" << RTN_Address(rtnppoll) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnppoll, AFUNPTR(myppoll)));\n            fptrppoll = fptr;\n        }\n\n        RTN rtnmsgsnd = RTN_FindByName(img, \"msgsnd\");\n        if (RTN_Valid(rtnmsgsnd) && RTN_IsSafeForProbedReplacement(rtnmsgsnd))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for msgsnd at \" << RTN_Address(rtnmsgsnd) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmsgsnd, AFUNPTR(mymsgsnd)));\n            fptrmsgsnd = fptr;\n        }\n\n        RTN rtnmsgrcv = RTN_FindByName(img, \"msgrcv\");\n        if (RTN_Valid(rtnmsgrcv) && RTN_IsSafeForProbedReplacement(rtnmsgrcv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for msgrcv at \" << RTN_Address(rtnmsgrcv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmsgrcv, AFUNPTR(mymsgrcv)));\n            fptrmsgrcv = fptr;\n        }\n\n        RTN rtnsemop = RTN_FindByName(img, \"semop\");\n        if (RTN_Valid(rtnsemop) && RTN_IsSafeForProbedReplacement(rtnsemop))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for semop at \" << RTN_Address(rtnsemop) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsemop, AFUNPTR(mymsgrcv)));\n            fptrsemop = fptr;\n        }\n\n        RTN rtnsemtimedop = RTN_FindByName(img, \"semtimedop\");\n        if (RTN_Valid(rtnsemtimedop)\n                && RTN_IsSafeForProbedReplacement(rtnsemtimedop)) {\n            OutFile << CurrentTime() << \"Inserting probe for semtimedop at \"\n                    << RTN_Address(rtnsemtimedop) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = RTN_ReplaceProbed(rtnsemtimedop, AFUNPTR(mysemtimedop));\n            fptrsemtimedop = fptr;\n        }\n\n        RTN rtnusleep = RTN_FindByName(img, \"usleep\");\n        if (RTN_Valid(rtnusleep) && RTN_IsSafeForProbedReplacement(rtnusleep)) {\n            OutFile << CurrentTime() << \"Inserting probe for usleep at \"\n                    << RTN_Address(rtnusleep) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnusleep, AFUNPTR(myusleep)));\n            fptrusleep = fptr;}\n\n        RTN rtnualarm = RTN_FindByName(img, \"ualarm\");\n        if (RTN_Valid(rtnualarm) && RTN_IsSafeForProbedReplacement(rtnualarm)) {\n            OutFile << CurrentTime() << \"Inserting probe for ualarm at \"\n                    << RTN_Address(rtnualarm) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnualarm, AFUNPTR(myualarm)));\n            fptrualarm = fptr;}\n\n        RTN rtngetitimer = RTN_FindByName(img, \"getitimer\");\n        if (RTN_Valid(rtngetitimer) && RTN_IsSafeForProbedReplacement(rtngetitimer))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getitimer at \" << RTN_Address(rtngetitimer) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetitimer, AFUNPTR(mygetitimer)));\n            fptrgetitimer = fptr;}\n\n        RTN rtnsigwait = RTN_FindByName(img, \"sigwait\");\n        if (RTN_Valid(rtnsigwait) && RTN_IsSafeForProbedReplacement(rtnsigwait))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigwait at \" << RTN_Address(rtnsigwait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigwait, AFUNPTR(mysigwait)));\n            fptrsigwait = fptr;\n        }\n\n        RTN rtnmsgget = RTN_FindByName(img, \"msgget\");\n        if (RTN_Valid(rtnmsgget) && RTN_IsSafeForProbedReplacement(rtnmsgget))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for msgget at \" << RTN_Address(rtnmsgget) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmsgget, AFUNPTR(mymsgget)));\n            fptrmsgget = fptr;\n        }\n\n        RTN rtnsemget = RTN_FindByName(img, \"semget\");\n        if (RTN_Valid(rtnsemget) && RTN_IsSafeForProbedReplacement(rtnsemget))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for semget at \" << RTN_Address(rtnsemget) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsemget, AFUNPTR(mysemget)));\n            fptrsemget = fptr;\n        }\n\n        RTN rtnwait = RTN_FindByName(img, \"wait\");\n        if (RTN_Valid(rtnwait) && RTN_IsSafeForProbedReplacement(rtnwait))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for wait at \" << RTN_Address(rtnwait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwait, AFUNPTR(mywait)));\n            fptrwait = fptr;\n        }\n\n        RTN rtnwaitpid = RTN_FindByName(img, \"waitpid\");\n        if (RTN_Valid(rtnwaitpid) && RTN_IsSafeForProbedReplacement(rtnwaitpid))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for waitpid at \" << RTN_Address(rtnwaitpid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwaitpid, AFUNPTR(mywaitpid)));\n            fptrwaitpid = fptr;\n        }\n\n        RTN rtnwaitid = RTN_FindByName(img, \"waitid\");\n        if (RTN_Valid(rtnwaitid) && RTN_IsSafeForProbedReplacement(rtnwaitid))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for waitid at \" << RTN_Address(rtnwaitid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwaitid, AFUNPTR(mywaitid)));\n            fptrwaitid = fptr;\n        }\n\n        RTN rtnwait3 = RTN_FindByName(img, \"wait3\");\n        if (RTN_Valid(rtnwait3) && RTN_IsSafeForProbedReplacement(rtnwait3))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for wait3 at \" << RTN_Address(rtnwait3) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwait3, AFUNPTR(mywait3)));\n            fptrwait3 = fptr;\n        }\n\n        RTN rtnwait4 = RTN_FindByName(img, \"wait4\");\n        if (RTN_Valid(rtnwait3) && RTN_IsSafeForProbedReplacement(rtnwait4))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for wait4 at \" << RTN_Address(rtnwait4) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwait3, AFUNPTR(mywait4)));\n            fptrwait4 = fptr;\n        }\n\n        RTN rtnreadv = RTN_FindByName(img, \"readv\");\n        if (RTN_Valid(rtnreadv) && RTN_IsSafeForProbedReplacement(rtnreadv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for readv at \" << RTN_Address(rtnreadv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnreadv, AFUNPTR(myreadv)));\n            fptrreadv = fptr;\n        }\n\n        RTN rtnwritev = RTN_FindByName(img, \"writev\");\n        if (RTN_Valid(rtnwritev) && RTN_IsSafeForProbedReplacement(rtnwritev))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for writev at \" << RTN_Address(rtnwritev) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwritev, AFUNPTR(mywritev)));\n            fptrwritev = fptr;\n        }\n\n        RTN rtnflockfile = RTN_FindByName(img, \"flockfile\");\n        if (RTN_Valid(rtnflockfile) && RTN_IsSafeForProbedReplacement(rtnflockfile))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for flockfile at \" << RTN_Address(rtnflockfile) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnflockfile, AFUNPTR(myflockfile)));\n            fptrflockfile = fptr;\n        }\n        RTN rtnfunlockfile = RTN_FindByName(img, \"funlockfile\");\n        if (RTN_Valid(rtnfunlockfile)\n                && RTN_IsSafeForProbedReplacement(rtnfunlockfile)) {\n            OutFile << CurrentTime() << \"Inserting probe for funlockfile at \"\n                    << RTN_Address(rtnfunlockfile) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfunlockfile,\n                    AFUNPTR(myfunlockfile)));\n            fptrfunlockfile = fptr;}\n\n        RTN rtnlockf = RTN_FindByName(img, \"lockf\");\n        if (RTN_Valid(rtnlockf) && RTN_IsSafeForProbedReplacement(rtnlockf))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for lockf at \" << RTN_Address(rtnlockf) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlockf, AFUNPTR(mylockf)));\n            fptrlockf = fptr;\n        }\n\n        RTN rtnsetenv = RTN_FindByName(img, \"setenv\");\n        if (RTN_Valid(rtnsetenv) && RTN_IsSafeForProbedReplacement(rtnsetenv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for setenv at \" << RTN_Address(rtnsetenv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsetenv, AFUNPTR(mysetenv)));\n            fptrsetenv = fptr;\n        }\n\n        RTN rtnunsetenv = RTN_FindByName(img, \"unsetenv\");\n        if (RTN_Valid(rtnunsetenv) && RTN_IsSafeForProbedReplacement(rtnunsetenv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for unsetenv at \" << RTN_Address(rtnunsetenv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnunsetenv, AFUNPTR(myunsetenv)));\n            fptrunsetenv = fptr;\n        }\n\n        RTN rtngetenv = RTN_FindByName(img, \"getenv\");\n        if (RTN_Valid(rtngetenv) && RTN_IsSafeForProbedReplacement(rtngetenv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getenv at \"\n                    << RTN_Address(rtngetenv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetenv, AFUNPTR(mygetenv)));\n            fptrgetenv = fptr;\n        }\n\n        RTN rtnperror = RTN_FindByName(img, \"perror\");\n        if (RTN_Valid(rtnperror) && RTN_IsSafeForProbedReplacement(rtnperror))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for perror at \"\n                    << RTN_Address(rtnperror) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnperror, AFUNPTR(myperror)));\n            fptrperror = fptr;\n        }\n\n        RTN rtnmmap = RTN_FindByName(img, \"mmap\");\n        if (RTN_Valid(rtnmmap) && RTN_IsSafeForProbedReplacement(rtnmmap))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for mmap at \"\n                    << RTN_Address(rtnmmap) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmmap, AFUNPTR(mymmap)));\n            fptrmmap = fptr;\n        }\n\n        RTN rtnmunmap = RTN_FindByName(img, \"munmap\");\n        if (RTN_Valid(rtnmunmap) && RTN_IsSafeForProbedReplacement(rtnmunmap))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for munmap at \"\n                    << RTN_Address(rtnmunmap) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmunmap, AFUNPTR(mymunmap)));\n            fptrmunmap = fptr;\n        }\n\n        RTN rtnfileno = RTN_FindByName(img, \"fileno\");\n        if (RTN_Valid(rtnfileno) && RTN_IsSafeForProbedReplacement(rtnfileno))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fileno at \"\n                    << RTN_Address(rtnfileno) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfileno, AFUNPTR(myfileno)));\n            fptrfileno = fptr;\n        }\n\n        RTN rtngetpid = RTN_FindByName(img, \"getpid\");\n        if (RTN_Valid(rtngetpid) && RTN_IsSafeForProbedReplacement(rtngetpid))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getpid at \"\n                    << RTN_Address(rtngetpid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetpid, AFUNPTR(mygetpid)));\n            fptrgetpid = fptr;\n        }\n\n        RTN rtngetppid = RTN_FindByName(img, \"getppid\");\n        if (RTN_Valid(rtngetppid) && RTN_IsSafeForProbedReplacement(rtngetppid))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getppid at \" << RTN_Address(rtngetppid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetppid, AFUNPTR(mygetppid)));\n            fptrgetppid = fptr;\n        }\n\n        RTN rtnmemset = RTN_FindByName(img, \"memset\");\n        if (RTN_Valid(rtnmemset) && RTN_IsSafeForProbedReplacement(rtnmemset))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for memset at \" << RTN_Address(rtnmemset) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmemset, AFUNPTR(mymemset)));\n            fptrmemset = fptr;\n        }\n\n        RTN rtnmemcpy = RTN_FindByName(img, \"memcpy\");\n        if (RTN_Valid(rtnmemcpy) && RTN_IsSafeForProbedReplacement(rtnmemcpy))\n        {\n            if (!is_GLIBC2_24_or_newer(img))\n            {\n                OutFile << CurrentTime() << \"Inserting probe for memcpy at \" << RTN_Address(rtnmemcpy) << endl;\n                OutFile.flush();\n                AFUNPTR fptr = (RTN_ReplaceProbed(rtnmemcpy, AFUNPTR(mymemcpy)));\n                fptrmemcpy = fptr;\n            }\n        }\n\n        RTN rtnaccess = RTN_FindByName(img, \"access\");\n        if (RTN_Valid(rtnaccess) && RTN_IsSafeForProbedReplacement(rtnaccess))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for access at \" << RTN_Address(rtnaccess) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnaccess, AFUNPTR(myaccess)));\n            fptraccess = fptr;\n        }\n\n        RTN rtnlseek = RTN_FindByName(img, \"lseek\");\n        if (RTN_Valid(rtnlseek) && RTN_IsSafeForProbedReplacement(rtnlseek))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for lseek at \" << RTN_Address(rtnlseek) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlseek, AFUNPTR(mylseek)));\n            fptrlseek = fptr;\n        }\n\n        RTN rtnlseek64 = RTN_FindByName(img, \"lseek64\");\n        if (RTN_Valid(rtnlseek64) && RTN_IsSafeForProbedReplacement(rtnlseek64))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for lseek64 at \" << RTN_Address(rtnlseek64) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlseek64, AFUNPTR(mylseek64)));\n            fptrlseek64 = fptr;\n        }\n\n        RTN rtnfdatasync = RTN_FindByName(img, \"fdatasync\");\n        if (RTN_Valid(rtnfdatasync) && RTN_IsSafeForProbedReplacement(rtnfdatasync))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fdatasync at \" << RTN_Address(rtnfdatasync) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfdatasync, AFUNPTR(myfdatasync)));\n            fptrfdatasync = fptr;\n        }\n\n        RTN rtnunlink = RTN_FindByName(img, \"unlink\");\n        if (RTN_Valid(rtnunlink) && RTN_IsSafeForProbedReplacement(rtnunlink))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for unlink at \" << RTN_Address(rtnunlink) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnunlink, AFUNPTR(myunlink)));\n            fptrunlink = fptr;\n        }\n\n        RTN rtnstrlen = RTN_FindByName(img, \"strlen\");\n        if (RTN_Valid(rtnstrlen) && RTN_IsSafeForProbedReplacement(rtnstrlen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strlen at \" << RTN_Address(rtnstrlen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrlen, AFUNPTR(mystrlen)));\n            fptrstrlen = fptr;\n        }\n\n        RTN rtnwcslen = RTN_FindByName(img, \"wcslen\");\n        if (RTN_Valid(rtnwcslen) && RTN_IsSafeForProbedReplacement(rtnwcslen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for wcslen at \"<< RTN_Address(rtnwcslen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwcslen, AFUNPTR(mywcslen)));\n            fptrwcslen = fptr;\n        }\n\n        RTN rtnstrcpy = RTN_FindByName(img, \"strcpy\");\n        if (RTN_Valid(rtnstrcpy) && RTN_IsSafeForProbedReplacement(rtnstrcpy))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strcpy at \" << RTN_Address(rtnstrcpy) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrcpy, AFUNPTR(mystrcpy)));\n            fptrstrcpy = fptr;\n        }\n\n        RTN rtnstrncpy = RTN_FindByName(img, \"strncpy\");\n        if (RTN_Valid(rtnstrncpy) && RTN_IsSafeForProbedReplacement(rtnstrncpy))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strncpy at \" << RTN_Address(rtnstrncpy) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrncpy, AFUNPTR(mystrcpy)));\n            fptrstrncpy = fptr;\n        }\n\n        RTN rtnstrcat = RTN_FindByName(img, \"strcat\");\n        if (RTN_Valid(rtnstrcat) && RTN_IsSafeForProbedReplacement(rtnstrcat))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strcat at \" << RTN_Address(rtnstrcat) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrcat, AFUNPTR(mystrcat)));\n            fptrstrcat = fptr;\n        }\n\n        RTN rtnstrstr = RTN_FindByName(img, \"strstr\");\n        if (RTN_Valid(rtnstrstr) && RTN_IsSafeForProbedReplacement(rtnstrstr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strstr at \" << RTN_Address(rtnstrstr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrstr, AFUNPTR(mystrstr)));\n            fptrstrstr = fptr;\n        }\n\n        RTN rtnstrchr0 = RTN_FindByName(img, \"strchr0\");\n        if (RTN_Valid(rtnstrchr0) && RTN_IsSafeForProbedReplacement(rtnstrchr0))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strchr0 at \" << RTN_Address(rtnstrchr0) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrchr0, AFUNPTR(mystrchr0)));\n            fptrstrrchr = fptr;\n        }\n\n        RTN rtnstrrchr = RTN_FindByName(img, \"strrchr\");\n        if (RTN_Valid(rtnstrrchr) && RTN_IsSafeForProbedReplacement(rtnstrrchr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strrchr at \"\n                    << RTN_Address(rtnstrrchr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrrchr, AFUNPTR(mystrrchr)));\n            fptrstrrchr = fptr;\n        }\n\n        RTN rtnstrcmp = RTN_FindByName(img, \"strcmp\");\n        if (RTN_Valid(rtnstrcmp) && RTN_IsSafeForProbedReplacement(rtnstrcmp))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strcmp at \" << RTN_Address(rtnstrcmp) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrcmp, AFUNPTR(mystrcmp)));\n            fptrstrcmp = fptr;\n        }\n\n        RTN rtnstrncmp = RTN_FindByName(img, \"strncmp\");\n        if (RTN_Valid(rtnstrncmp) && RTN_IsSafeForProbedReplacement(rtnstrncmp))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strncmp at \" << RTN_Address(rtnstrncmp) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrncmp, AFUNPTR(mystrncmp)));\n            fptrstrncmp = fptr;\n        }\n\n        RTN rtnsigaddset = RTN_FindByName(img, \"sigaddset\");\n        if (RTN_Valid(rtnsigaddset) && RTN_IsSafeForProbedReplacement(rtnsigaddset))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigaddset at \" << RTN_Address(rtnsigaddset) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigaddset, AFUNPTR(mysigaddset)));\n            fptrsigaddset = fptr;\n        }\n\n        RTN rtnsigdelset = RTN_FindByName(img, \"sigdelset\");\n        if (RTN_Valid(rtnsigdelset) && RTN_IsSafeForProbedReplacement(rtnsigdelset))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigdelset at \"<< RTN_Address(rtnsigdelset) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigdelset, AFUNPTR(mysigdelset)));\n            fptrsigdelset = fptr;\n        }\n\n        RTN rtnsigismember = RTN_FindByName(img, \"sigismember\");\n        if (RTN_Valid(rtnsigismember) && RTN_IsSafeForProbedReplacement(rtnsigismember))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigismember at \" << RTN_Address(rtnsigismember) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigismember, AFUNPTR(mysigismember)));\n            fptrsigdelset = fptr;\n        }\n\n        RTN rtnstrerror = RTN_FindByName(img, \"strerror\");\n        if (RTN_Valid(rtnstrerror) && RTN_IsSafeForProbedReplacement(rtnstrerror))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strerror at \" << RTN_Address(rtnstrerror) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrerror, AFUNPTR(mystrerror)));\n            fptrstrerror = fptr;\n        }\n\n        RTN rtnbind = RTN_FindByName(img, \"bind\");\n        if (RTN_Valid(rtnbind) && RTN_IsSafeForProbedReplacement(rtnbind))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for bind at \" << RTN_Address(rtnbind) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnbind, AFUNPTR(mybind)));\n            fptrbind = fptr;\n        }\n\n        RTN rtnlisten = RTN_FindByName(img, \"listen\");\n        if (RTN_Valid(rtnlisten) && RTN_IsSafeForProbedReplacement(rtnlisten))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for listen at \" << RTN_Address(rtnlisten) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlisten, AFUNPTR(mylisten)));\n            fptrlisten = fptr;\n        }\n\n        RTN rtnuname = RTN_FindByName(img, \"uname\");\n        if (RTN_Valid(rtnuname) && RTN_IsSafeForProbedReplacement(rtnuname))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for uname at \"    << RTN_Address(rtnuname) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnuname, AFUNPTR(myuname)));\n            fptruname = fptr;\n        }\n\n        RTN rtngethostname = RTN_FindByName(img, \"gethostname\");\n        if (RTN_Valid(rtngethostname) && RTN_IsSafeForProbedReplacement(rtngethostname))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for gethostname at \" << RTN_Address(rtngethostname) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngethostname, AFUNPTR(mygethostname)));\n            fptrgethostname = fptr;\n        }\n\n        RTN rtnkill = RTN_FindByName(img, \"kill\");\n        if (RTN_Valid(rtnkill) && RTN_IsSafeForProbedReplacement(rtnkill))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for kill at \" << RTN_Address(rtnkill) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnkill, AFUNPTR(mykill)));\n            fptrkill = fptr;\n        }\n\n        RTN rtnsched_yield = RTN_FindByName(img, \"sched_yield\");\n        if (RTN_Valid(rtnsched_yield) && RTN_IsSafeForProbedReplacement(rtnsched_yield)) {\n            OutFile << CurrentTime() << \"Inserting probe for sched_yield at \" << RTN_Address(rtnsched_yield) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsched_yield, AFUNPTR(mysched_yield)));\n            fptrsched_yield = fptr;\n        }\n\n        RTN rtntimer_settime = RTN_FindByName(img, \"timer_settime\");\n        if (RTN_Valid(rtntimer_settime) && RTN_IsSafeForProbedReplacement(rtntimer_settime))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for timer_settime at \" << RTN_Address(rtntimer_settime) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtntimer_settime, AFUNPTR(mytimer_settime)));\n            fptrtimer_settime = fptr;\n        }\n\n        RTN rtnsigaltstack = RTN_FindByName(img, \"sigaltstack\");\n        if (RTN_Valid(rtnsigaltstack) && RTN_IsSafeForProbedReplacement(rtnsigaltstack))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigaltstack at \" << RTN_Address(rtnsigaltstack) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigaltstack, AFUNPTR(mysigaltstack)));\n            fptrsigaltstack = fptr;\n        }\n\n        RTN rtnioctl = RTN_FindByName(img, \"ioctl\");\n        if (RTN_Valid(rtnioctl) && RTN_IsSafeForProbedReplacement(rtnioctl))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for ioctl at \" << RTN_Address(rtnioctl) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnioctl, AFUNPTR(myioctl)));\n            fptrioctl = fptr;\n        }\n\n        RTN rtnflock = RTN_FindByName(img, \"flock\");\n        if (RTN_Valid(rtnflock) && RTN_IsSafeForProbedReplacement(rtnflock))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for flock at \" << RTN_Address(rtnflock) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnflock, AFUNPTR(myflock)));\n            fptrflock = fptr;\n        }\n\n        RTN rtn__libc_dlopen_mode = RTN_FindByName(img, \"__libc_dlopen_mode\");\n        if (RTN_Valid(rtn__libc_dlopen_mode) && RTN_IsSafeForProbedReplacement(rtn__libc_dlopen_mode))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for __libc_dlopen_mode at \" << RTN_Address(rtn__libc_dlopen_mode) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn__libc_dlopen_mode, AFUNPTR(my__libc_dlopen_mode)));\n            fptr__libc_dlopen_mode = fptr;\n        }\n\n        RTN rtn__errno_location = RTN_FindByName(img, \"__errno_location\");\n        if (RTN_Valid(rtn__errno_location) && RTN_IsSafeForProbedReplacement(rtn__errno_location))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for __errno_location at \" << RTN_Address(rtn__errno_location) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn__errno_location, AFUNPTR(my__errno_location)));\n            fptr__errno_location = fptr;\n        }\n\n        RTN rtnsyscall = RTN_FindByName(img, \"syscall\");\n        if (RTN_Valid(rtnsyscall) && RTN_IsSafeForProbedReplacement(rtnsyscall))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for syscall at \" << RTN_Address(rtnsyscall) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsyscall, AFUNPTR(mysyscall)));\n            fptrsyscall = fptr;}\n        }\n        // finished instrumentation\n    }\n\n/* ===================================================================== */\n/* Main function                                                         */\n/* ===================================================================== */\n\nint main(int argc, char *argv[]) {\n    // Initialize Pin\n    PIN_InitSymbols();\n    if (PIN_Init(argc, argv)) {\n        return Usage();\n    }\n\n    OutFile.open(KnobOutputFile.Value().c_str());\n    OutFile << hex;\n    OutFile.setf(ios::showbase);\n    OutFile << CurrentTime() << \"started!\" << endl;\n    OutFile.flush();\n\n    // Register the instrumentation callback\n    IMG_AddInstrumentFunction(ImgLoad, 0);\n\n    // Start the application\n    PIN_StartProgramProbed(); // never returns\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/dltest_unix.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include \"tool_macros.h\"\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n#if defined(TARGET_MAC) || defined(TARGET_BSD)\n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);\n#else    \n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n#endif    \n    fprintf(stderr, \"Allocated %p\\n\",mem);\n    // This unmap should not trigger a flush\n    munmap(mem, 0x2000);\n\n    Load(SHARED_LIB(\"libone\"), 1);\n    Load(SHARED_LIB(\"libtwo\"), 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/malloctrace2.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*! @file\n The test shows how wrappers may be implemented in DLL loaded in runtime.\n The dopen() is being called from application space. But it can't be called\n before libc is initialized.\n In this example I call dlopen before main().\n */\n\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"tool_macros.h\"\nusing std::cerr;\nusing std::endl;\nusing std::cout;\n\n#ifdef TARGET_MAC\n# define MALLOC_LIB \"libsystem_malloc.dylib\"\n#else\n# define MALLOC_LIB \"libc.so\"\n#endif\n\n\n\n/* ===================================================================== */\n\nINT32 Usage()\n{\n    cerr <<\n        \"This pin tool inserts a user-written version of malloc() and free() into the application.\\n\"\n        \"\\n\";\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return -1;\n}\n\n\n/* ===================================================================== */\n/* Definitions for Probe mode */\n/* ===================================================================== */\n\ntypedef typeof(malloc) * MallocType;\ntypedef typeof(free) * FreeType;\ntypedef typeof(dlopen) * DlopenType;\ntypedef typeof(dlsym) * DlsymType;\n\nMallocType MallocWrapper = 0;\nMallocType origMalloc = 0;\n\nFreeType FreeWrapper = 0;\nFreeType origFree = 0;\n\nvoid * MallocTraceHandle = 0;\n\nDlopenType AppDlopen = 0;\nDlsymType AppDlsym = 0;\n\ntypedef VOID (*SET_ORIG_FPTR)(MallocType mallocPtr, FreeType freePtr);\n\n/* ===================================================================== */\n/* Probe mode tool */\n/* ===================================================================== */\n\nVOID *MallocWrapperInTool(size_t size)\n{\n    if (MallocWrapper)\n    {\n        return (*MallocWrapper)(size);\n    }\n    else\n    {\n        ASSERTX(origMalloc != 0);\n        return (*origMalloc)(size);\n    }\n}\n\nVOID FreeWrapperInTool(void *p)\n{\n    if (FreeWrapper)\n    {\n        (*FreeWrapper)(p);\n    }\n    else\n    {\n        ASSERTX(origFree != 0);\n        (*origFree)(p);\n    }\n}\n\n/* I'm calling dlopen before main.\n * Some malloc-free may be lost, of course.\n * But the earliest point you can call dlopen is after init of libc\n */\nVOID MainRtnCallback()\n{\n    cout << \"In main callback\" << endl;\n    // inject libmallocwrappers.so into application by executing application dlopen\n\n    MallocTraceHandle = AppDlopen(SHARED_LIB(\"libmallocwrappers\"), RTLD_LAZY);\n    ASSERTX(MallocTraceHandle);\n\n    // Get function pointers for the wrappers\n    MallocWrapper = MallocType(AppDlsym(MallocTraceHandle, \"mallocWrapper\"));\n    FreeWrapper = FreeType(AppDlsym(MallocTraceHandle, \"freeWrapper\"));\n    ASSERTX(MallocWrapper && FreeWrapper);\n\n    // Send original function pointers to libmallocwrappers.so\n    SET_ORIG_FPTR setOriginalFptr = (SET_ORIG_FPTR) AppDlsym(MallocTraceHandle, \"SetOriginalFptr\");\n    ASSERTX(setOriginalFptr != 0);\n    (*setOriginalFptr)(origMalloc, origFree);\n}\n\nVOID ImageLoad(IMG img, VOID *v)\n{\n    if (strstr(IMG_Name(img).c_str(), \"libdl.so\"))\n    {\n        // Get the function pointer for the application dlopen:\n        // dlopen@@GLIBC_2.1 is the official, versioned name.\n        //\n        // The exact suffix must match the ABI of the libdl header files\n        // this source code gets compiled against. Makefile/configure\n        // trickery would be needed to figure this suffix out, so it\n        // is simply hard-coded here.\n        //\n        // To keep the resulting binaries compatible with future libdl.so\n        // versions, this code also checks for backwards compatibility\n        // versions of the calls as they would be provided in such a\n        // future version.\n\n#if defined(TARGET_IA32E)\n# define DLOPEN_VERSION \"GLIBC_2.2.5\"\n# define DLSYM_VERSION \"GLIBC_2.2.5\"\n#elif defined(TARGET_IA32)\n# define DLOPEN_VERSION \"GLIBC_2.1\"\n# define DLSYM_VERSION \"GLIBC_2.0\"\n#else\n# error symbol versions unknown for this target\n#endif\n\n        RTN dlopenRtn = RTN_FindByName(img, \"dlopen@@\" DLOPEN_VERSION);\n        if (!RTN_Valid(dlopenRtn))\n        {\n            dlopenRtn = RTN_FindByName(img, \"dlopen@\" DLOPEN_VERSION);\n        }\n\n        if (!RTN_Valid(dlopenRtn))\n        {\n            // fallback for the cases in which symbols do not have a version\n            dlopenRtn = RTN_FindByName(img, \"dlopen\");\n        }\n\n        ASSERTX(RTN_Valid(dlopenRtn));\n        AppDlopen = DlopenType(RTN_Funptr(dlopenRtn));\n\n        // Get the function pointer for the application dlsym\n        RTN dlsymRtn = RTN_FindByName(img, \"dlsym@@\" DLSYM_VERSION);\n        if (!RTN_Valid(dlsymRtn)) {\n            dlsymRtn = RTN_FindByName(img, \"dlsym@\" DLSYM_VERSION);\n        }\n        if (!RTN_Valid(dlsymRtn)) {\n            // fallback for the cases in which symbols do not have a version\n            dlsymRtn = RTN_FindByName(img, \"dlsym\");\n        }\n\n        ASSERTX(RTN_Valid(dlsymRtn));\n        AppDlsym = DlsymType(RTN_Funptr(dlsymRtn));\n\n\n    }\n    if (strstr(IMG_Name(img).c_str(), \"libdyld.dylib\"))\n    {\n        RTN dlopenRtn = RTN_FindByName(img, C_MANGLE(\"dlopen\") );\n\n        // Get the function pointer for the application dlsym\n        RTN dlsymRtn = RTN_FindByName(img, C_MANGLE(\"dlsym\") );\n\n        // In some systems, dlsym and dlopen symbols don't exist.\n        // In this case, exit with special return code.\n        if (!RTN_Valid(dlsymRtn) && !RTN_Valid(dlopenRtn))\n        {\n            cerr << \"Error: dlsym and dlopen not found\" << endl;\n            PIN_ExitApplication(13);\n        }\n\n        AppDlopen = DlopenType(RTN_Funptr(dlopenRtn));\n        AppDlsym = DlsymType(RTN_Funptr(dlsymRtn));\n\n    }\n\n    if (strstr(IMG_Name(img).c_str(), MALLOC_LIB))\n    {\n        // Replace malloc and free in application libc with wrappers in libmallocwrappers.so\n        RTN mallocRtn = RTN_FindByName(img, C_MANGLE(\"malloc\"));\n        ASSERTX(RTN_Valid(mallocRtn));\n\n        if ( ! RTN_IsSafeForProbedReplacement( mallocRtn ) )\n        {\n            cout << \"Cannot replace malloc in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n        RTN freeRtn = RTN_FindByName(img, C_MANGLE(\"free\"));\n        ASSERTX(RTN_Valid(freeRtn));\n\n        if ( ! RTN_IsSafeForProbedReplacement( freeRtn ) )\n        {\n            cout << \"Cannot replace free in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n\n        origMalloc = (MallocType)RTN_ReplaceProbed(mallocRtn, AFUNPTR(MallocWrapperInTool));\n\n        origFree = (FreeType)RTN_ReplaceProbed(freeRtn, AFUNPTR(FreeWrapperInTool));\n\n    }\n\n    /* I call dopen before main. If this point is too late for you,\n    catch init() of libc and call dlopen after init() is done\n    */\n    if (IMG_IsMainExecutable(img))\n    {\n        RTN mainRtn = RTN_FindByName(img, \"_main\");\n        if (!RTN_Valid(mainRtn))\n            mainRtn = RTN_FindByName(img, \"main\");\n\n        if (!RTN_Valid(mainRtn))\n        {\n            cout << \"Can't find the main routine in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n        RTN_InsertCallProbed(mainRtn, IPOINT_BEFORE, AFUNPTR(MainRtnCallback), IARG_END);\n    }\n}\n\n\n\n/* ===================================================================== */\n/* main */\n/* ===================================================================== */\n\nint main(int argc, CHAR *argv[])\n{\n    PIN_InitSymbols();\n\n    if( PIN_Init(argc,argv) )\n    {\n        return Usage();\n    }\n\n    IMG_AddInstrumentFunction(ImageLoad, 0);\n\n    PIN_StartProgramProbed();\n\n    return 0;\n}\n\n/* ===================================================================== */\n/* eof */\n/* ===================================================================== */\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/tpss_lin_libc.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n * This tool mimics the behavior of TPSS on Linux by adding probes to various libc functions.\n * However, in this tool these probes are merely empty wrappers that call the original functions.\n * The objective of the test is to verify that probe generation and insertion don't cause Pin\n * to crash.\n *\n * This file is part of the tpss_lin_libc tool and compiles against the native\n * libc of the machine/compiler in order to extact data types definition from it's headers.\n */\n\n#define _GNU_SOURCE\n#include <link.h>\n#include <sys/types.h>\n#include <sys/timeb.h>\n#include <rpc/rpc.h>\n#include <rpc/pmap_clnt.h>\n#include <semaphore.h>\n#include <dlfcn.h>\n#include <signal.h>\n#include <poll.h>\n#include <time.h>\n#include <link.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <sys/ipc.h>\n#include <sys/sem.h>\n#include <signal.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <stdio.h>\n#include <string.h>\n#include <wchar.h>\n#include <sys/socket.h>\n#include <sys/utsname.h>\n#include <sched.h>\n#include <time.h>\n\ntypedef int * INT_PTR;\n\ntypedef void * VOID_PTR;\n\ntypedef char * CHAR_PTR;\n\nvoid printFunctionCalled(const char* funcName);\n\n/* ===================================================================== */\n/* Function signatures - these functions will be probed                  */\n/* ===================================================================== */\n\nint (*fptrnanosleep)(const struct timespec *__rqtp, struct timespec *__rmtp);\n\nint (*fptrdl_iterate_phdr)(int (*__callback)(struct dl_phdr_info *__info, size_t __size,\n    VOID_PTR __data), VOID_PTR __data);\n\nint (*fptrsystem)(const CHAR_PTR __command);\n\nunsigned int (*fptralarm)(unsigned int __seconds);\n\nssize_t (*fptrrecvmsg)(int __socket, struct msghdr *__message, int __flags);\n\nssize_t (*fptrsendmsg)(int __sockfd, const struct msghdr *__msg, int __flags);\n\nint (*fptrpause)(void);\n\nint (*fptrsigtimedwait)(const sigset_t *__set, siginfo_t *__info, const struct timespec *__timeout);\n\nint (*fptrsigwaitinfo)(const sigset_t *__set, siginfo_t *__info);\n\nint (*fptrepoll_wait)(int __epfd, struct epoll_event *__events, int __maxevents,\n    int __timeout);\n\nint (*fptrepoll_pwait)(int __epfd, struct epoll_event *__events,\n    int __maxevents, int __timeout, const sigset_t *__sigmask);\n\nint (*fptrppoll)(struct pollfd *__fds, nfds_t __nfds,\n    const struct timespec *__timeout_ts, const sigset_t *__sigmask);\n\nint (*fptrmsgsnd)(int __msqid, const VOID_PTR __msgp, size_t __msgsz, int __msgflg);\n\nssize_t (*fptrmsgrcv)(int __msqid, VOID_PTR __msgp, size_t __msgsz, long __msgtyp, int __msgflg);\n\nint (*fptrsemop)(int __semid, struct sembuf *__sops, unsigned __nsops);\n\nint (*fptrsemtimedop)(int __semid, struct sembuf *__sops);\n\nint (*fptrusleep)(useconds_t __usec);\n\nuseconds_t (*fptrualarm)(useconds_t __usecs, useconds_t __interval);\n\nint (*fptrgetitimer)(int __which, struct itimerval *__curr_value);\n\nint (*fptrsigwait)(const sigset_t *__set, INT_PTR __sig);\n\nint (*fptrmsgget)(key_t __key, int __msgflg);\n\nint (*fptrsemget)(key_t __key, int __nsems, int __semflg);\n\npid_t (*fptrwait)(INT_PTR __status);\n\npid_t (*fptrwaitpid)(pid_t __pid, INT_PTR __atus, int __options);\n\nint (*fptrwaitid)(idtype_t __idtype, id_t __id, siginfo_t *__infop,int __options);\n\npid_t (*fptrwait3)(INT_PTR __status, int __options, struct rusage *__rusage);\n\npid_t (*fptrwait4)(pid_t __pid, INT_PTR status, int __options, struct rusage *__rusage);\n\nssize_t (*fptrreadv)(int __fd, const struct iovec *__iov, int __iovcnt);\n\nssize_t (*fptrwritev)(int __fd, const struct iovec *__iov, int __iovcnt);\n\nint (*fptrflock)(int __fd, int __operation);\n\nvoid (*fptrflockfile)(FILE *__filehandle);\n\nvoid (*fptrfunlockfile)(FILE *__filehandle);\n\nint (*fptrlockf)(int __fd, int __cmd, off_t __len);\n\nint (*fptrsetenv)(const CHAR_PTR __name, const CHAR_PTR __value, int __overwrite);\n\nint (*fptrunsetenv)(const CHAR_PTR __name);\n\nCHAR_PTR (*fptrgetenv)(const CHAR_PTR __name);\n\nvoid (*fptrperror)(const CHAR_PTR __s);\n\nVOID_PTR (*fptrmmap)(VOID_PTR __addr, size_t __len, int __prot, int __flags,\n        int __fildes, off_t __off);\n\nint (*fptrmunmap)(VOID_PTR __addr, size_t __len);\n\nint (*fptrfileno)(FILE *__stream);\n\npid_t (*fptrgetpid)(void);\n\npid_t (*fptrgetppid)(void);\n\nVOID_PTR (*fptrmemset)(VOID_PTR __s, int __c, size_t __n);\n\nVOID_PTR (*fptrmemcpy)(VOID_PTR __dest, const VOID_PTR __src, size_t __n);\n\nint (*fptraccess)(const CHAR_PTR __pathname, int __mode);\n\noff_t (*fptrlseek)(int __fd, off_t __offset, int __whence);\n\noff64_t (*fptrlseek64)(int __fd, off64_t __offset, int __whence);\n\nint (*fptrfdatasync)(int __fd);\n\nint (*fptrunlink)(const CHAR_PTR __pathname);\n\nsize_t (*fptrstrlen)(const CHAR_PTR __s);\n\nsize_t (*fptrwcslen)(const wchar_t *__s);\n\nCHAR_PTR (*fptrstrcpy)(CHAR_PTR __dest, const CHAR_PTR __src);\n\nCHAR_PTR (*fptrstrncpy)(CHAR_PTR __dest, const CHAR_PTR __src, size_t __n);\n\nCHAR_PTR (*fptrstrcat)(CHAR_PTR __dest, const CHAR_PTR __src);\n\nCHAR_PTR (*fptrstrstr)(const CHAR_PTR __haystack, const CHAR_PTR __needle);\n\nCHAR_PTR (*fptrstrchr0)(const CHAR_PTR __s, int __c);\n\nCHAR_PTR (*fptrstrrchr)(const CHAR_PTR __s, int __c);\n\nint (*fptrstrcmp)(const CHAR_PTR __s1, const CHAR_PTR __s2);\n\nint (*fptrstrncmp)(const CHAR_PTR __s1, const CHAR_PTR __s2, size_t __n);\n\nint (*fptrsigaddset)(sigset_t *__set, int __signum);\n\nint (*fptrsigdelset)(sigset_t *__set, int __signum);\n\nint (*fptrsigismember)(const sigset_t *__set, int __signum);\n\nCHAR_PTR (*fptrstrerror)(int __errnum);\n\nint (*fptrbind)(int __sockfd, const struct sockaddr *__addr, socklen_t __addrlen);\n\nint (*fptrlisten)(int __sockfd, int __backlog);\n\nint (*fptruname)(struct utsname *__name);\n\nint (*fptrgethostname)(CHAR_PTR __name, size_t __len);\n\nint (*fptrkill)(pid_t __pid, int __sig);\n\nint (*fptrsched_yield)(void);\n\nint (*fptrtimer_settime)(timer_t __timerid, int __flags, const struct itimerspec * __value, struct itimerspec * __ovalue);\n\nint (*fptrsigaltstack)(const stack_t *__ss, stack_t *__oss);\n\nint (*fptrshutdown)(int, int);\n\nint (*fptrsleep)(unsigned int);\n\nint (*fptrsocket)(int, int, int);\n\nint (*fptrselect)(int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict, struct timeval *__restrict);\n\nint (*fptrpoll)(struct pollfd *, nfds_t, int);\n\nint (*fptraccept)(int, __SOCKADDR_ARG, socklen_t *__restrict);\n\nint (*fptrconnect)(int, __CONST_SOCKADDR_ARG, socklen_t);\n\nssize_t (*fptrrecv)(int, VOID_PTR , size_t, int);\n\nssize_t (*fptrrecvfrom)(int, VOID_PTR __restrict, size_t, int, __SOCKADDR_ARG, socklen_t *__restrict);\n\nssize_t (*fptrsend)(int, __const VOID_PTR , size_t, int);\n\nwint_t (*fptrgetwc)(__FILE *);\n\nint (*fptrsetitimer)(__itimer_which_t, __const struct itimerval *__restrict, struct itimerval *__restrict);\n\nint (*fptrsigpending)(sigset_t *);\n\nint (*fptrsigaction)(int, __const struct sigaction *__restrict, struct sigaction *__restrict);\n\n__sighandler_t (*fptrsignal)(int, __sighandler_t);\n\nvoid (*fptrabort)();\n\nssize_t (*fptrsendto)(int, __const VOID_PTR , size_t, int, __CONST_SOCKADDR_ARG, socklen_t);\n\nint (*fptr_IO_getc)(FILE *);\n\nint (*fptrgetchar)();\n\nwint_t (*fptrgetwchar)();\n\nCHAR_PTR  (*fptrgets)(CHAR_PTR );\n\nCHAR_PTR  (*fptrfgets)(CHAR_PTR __restrict, int, FILE *__restrict);\n\nwint_t (*fptrfgetwc)(__FILE *);\n\nsize_t (*fptrfread)(VOID_PTR __restrict, size_t, size_t, FILE *__restrict);\n\nsize_t (*fptrfwrite)(__const VOID_PTR __restrict, size_t, size_t, FILE *__restrict);\n\nint (*fptropen)(__const CHAR_PTR , int, mode_t);\n\nint (*fptrgetw)(FILE *);\n\nvoid (*fptrfgetc)(__FILE *);\n\nwchar_t * (*fptrfgetws)(wchar_t *__restrict, int, __FILE *__restrict);\n\nint (*fptrpipe)(int[2]);\n\nssize_t (*fptrread)(int, VOID_PTR , size_t);\n\nssize_t (*fptrwrite)(int, __const VOID_PTR , size_t);\n\nFILE * (*fptrfopen)(__const CHAR_PTR __restrict, __const CHAR_PTR __restrict);\n\nFILE * (*fptrfdopen)(int, __const CHAR_PTR );\n\nint (*fptrclose)(int);\n\nint (*fptrfclose)(FILE *);\n\nint (*fptrcallrpc)(__const CHAR_PTR , u_long, u_long, u_long, xdrproc_t, __const CHAR_PTR , xdrproc_t, CHAR_PTR );\n\nenum clnt_stat (*fptrclnt_broadcast)(u_long, u_long, u_long, xdrproc_t, caddr_t,\n        xdrproc_t, caddr_t, resultproc_t);\n\nCLIENT * (*fptrclntudp_create)(struct sockaddr_in *, u_long, u_long, struct timeval, INT_PTR );\n\nCLIENT * (*fptrclntudp_bufcreate)(struct sockaddr_in *, u_long, u_long, struct timeval, INT_PTR , u_int, u_int);\n\nstruct pmaplist * (*fptrpmap_getmaps)(struct sockaddr_in *);\n\nu_short (*fptrpmap_getport)(struct sockaddr_in *, u_long, u_long, u_int);\n\nenum clnt_stat (*fptrpmap_rmtcall)(struct sockaddr_in *, u_long, u_long, u_long, xdrproc_t, caddr_t, xdrproc_t, caddr_t, struct timeval, u_long *);\n\nbool_t (*fptrpmap_set)(u_long, u_long, int, u_short);\n\nCLIENT * (*fptrclntraw_create)(u_long, u_long);\n\nvoid (*fptrsvc_run)();\n\nbool_t (*fptrsvc_sendreply)(SVCXPRT *, xdrproc_t, caddr_t);\n\nSVCXPRT * (*fptrsvcraw_create)();\n\nSVCXPRT * (*fptrsvctcp_create)(int, u_int, u_int);\n\nSVCXPRT * (*fptrsvcudp_bufcreate)(int, u_int, u_int);\n\nSVCXPRT * (*fptrsvcudp_create)(int);\n\nvoid (*fptr_exit)(int);\n\nint (*fptrsigprocmask)(int, __const sigset_t *__restrict, sigset_t *__restrict);\n\nvoid (*fptrexit)(int);\n\nint (*fptrpselect)(int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict, \n    const struct timespec *__restrict, const __sigset_t *__restrict);\n\nint (*fptrioctl)(int __d, int __request, CHAR_PTR  __argp);\n\nint (*fptrfcntl)(int __fd, int __cmd, VOID_PTR  __argp);\n\nVOID_PTR (*fptr__libc_dlopen_mode)(const CHAR_PTR __name, int __mode);\n\nINT_PTR  (*fptr__errno_location)(void);\n\nint (*fptrsyscall)(int __number, long int __arg1, long int __arg2, long int __arg3,\n     long int __arg4, long int __arg5, long int __arg6, long int __arg7);\n\n/* ===================================================================== */\n/* Probes - implementation of the wrapper functions                      */\n/* ===================================================================== */\n\nint mynanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) \n{\n    printFunctionCalled(\"mynanosleep\");\n    int res = fptrnanosleep(__rqtp, __rmtp);\n\n    return res;\n}\nint mydl_iterate_phdr(\n        int (*__callback)(struct dl_phdr_info *__info, size_t __size,\n                VOID_PTR __data), VOID_PTR __sec_data) \n{\n    printFunctionCalled(\"mydl_iterate_phdr\");\n    int res = fptrdl_iterate_phdr((__callback), __sec_data);\n    return res;\n}\n\nint mysystem(const CHAR_PTR __command) \n{\n    printFunctionCalled(\"mysystem\");\n    int res = fptrsystem(__command);\n\n    return res;\n}\n\nunsigned int myalarm(unsigned int __seconds)\n{\n    printFunctionCalled(\"myalarm\");\n    unsigned int res = fptralarm(__seconds);\n\n    return res;\n}\n\nssize_t myrecvmsg(int __socket, struct msghdr *__message, int __flags)\n{\n    printFunctionCalled(\"myrecvmsg\");\n    ssize_t res = fptrrecvmsg(__socket, __message, __flags);\n\n    return res;\n}\n\nssize_t mysendmsg(int __sockfd, const struct msghdr *__msg, int __flags) \n{\n    printFunctionCalled(\"mysendmsg\");\n    ssize_t res = fptrsendmsg(__sockfd, __msg, __flags);\n\n    return res;\n}\n\nint mypause(void) \n{\n    printFunctionCalled(\"mypause\");\n    int res = fptrpause();\n\n    return res;\n}\n\nint mysigtimedwait(const sigset_t *__set, siginfo_t *__info,\n        const struct timespec *__timeout) \n{\n    printFunctionCalled(\"mysigtimedwait\");\n    int res = fptrsigtimedwait(__set, __info, __timeout);\n\n    return res;\n}\n\nint mysigwaitinfo(const sigset_t *__set, siginfo_t *__info) \n{\n    printFunctionCalled(\"mysigwaitinfo\");\n    int res = fptrsigwaitinfo(__set, __info);\n\n    return res;\n}\n\nint myepoll_wait(int __epfd, struct epoll_event *__events, int __maxevents,\n        int __timeout) \n{\n    printFunctionCalled(\"myepoll_wait\");\n    int res = fptrepoll_wait(__epfd, __events, __maxevents, __timeout);\n\n    return res;\n}\n\nint myepoll_pwait(int __epfd, struct epoll_event *__events, int __maxevents,\n        int __timeout) \n{\n    printFunctionCalled(\"myepoll_pwait\");\n    int res = fptrepoll_wait(__epfd, __events, __maxevents, __timeout);\n\n    return res;\n}\n\nint myppoll(struct pollfd *__fds, nfds_t __nfds,\n        const struct timespec *__timeout_ts, const sigset_t *__sigmask) \n{\n    printFunctionCalled(\"myppoll\");\n    int res = fptrppoll(__fds, __nfds, __timeout_ts, __sigmask);\n\n    return res;\n}\n\nint mymsgsnd(int __msqid, const VOID_PTR __msgp, size_t __msgsz, int __msgflg) \n{\n    printFunctionCalled(\"mymsgsnd\");\n    int res = fptrmsgsnd(__msqid, __msgp, __msgsz, __msgflg);\n\n    return res;\n}\n\nssize_t mymsgrcv(int __msqid, VOID_PTR __msgp, size_t __msgsz, long __msgtyp,\n        int __msgflg) \n{\n    printFunctionCalled(\"mymsgrcv\");\n    ssize_t res = fptrmsgrcv(__msqid, __msgp, __msgsz, __msgtyp, __msgflg);\n\n    return res;\n}\n\nint mysemtimedop(int __semid, struct sembuf *__sops) \n{\n    printFunctionCalled(\"mysemtimedop\");\n    int res = fptrsemtimedop(__semid, __sops);\n\n    return res;\n}\n\nint myusleep(useconds_t __usecs) \n{\n    printFunctionCalled(\"myusleep\");\n    int res = fptrusleep(__usecs);\n\n    return res;\n}\n\nuseconds_t myualarm(useconds_t __usecs, useconds_t __interval) \n{\n    printFunctionCalled(\"myualarm\");\n    useconds_t res = fptrualarm(__usecs, __interval);\n\n    return res;\n}\n\nint mygetitimer(int __which, struct itimerval *__curr_value) \n{\n    printFunctionCalled(\"mygetitimer\");\n    int res = fptrgetitimer(__which, __curr_value);\n\n    return res;\n}\n\nint mysigwait(const sigset_t *__set, INT_PTR __sig) \n{\n    printFunctionCalled(\"mysigwait\");\n    int res = fptrsigwait(__set, __sig);\n\n    return res;\n}\n\nint mymsgget(key_t __key, int __msgflg) \n{\n    printFunctionCalled(\"mymsgget\");\n    int res = fptrmsgget(__key, __msgflg);\n\n    return res;\n}\n\nint mysemget(key_t __key, int __nsems, int __semflg) \n{\n    printFunctionCalled(\"mysemget\");\n    int res = fptrsemget(__key, __nsems, __semflg);\n\n    return res;\n}\n\npid_t mywaitpid(pid_t __pid, INT_PTR __status, int __options) \n{\n    printFunctionCalled(\"mywaitpid\");\n    pid_t res = fptrwaitpid(__pid, __status, __options);\n\n    return res;\n}\n\nint mywaitid(idtype_t __idtype, id_t __id, siginfo_t *__infop, int __options)\n{\n    printFunctionCalled(\"mywaittid\");\n    int res = fptrwaitid(__idtype, __id, __infop, __options);\n\n    return res;\n}\n\npid_t mywait3(INT_PTR __status, int __options, struct rusage *__rusage) \n{\n    printFunctionCalled(\"mywait3\");\n    pid_t res = fptrwait3(__status, __options, __rusage);\n\n    return res;\n}\n\npid_t mywait4(pid_t __pid, INT_PTR __status, int __options,\n        struct rusage *__rusage) \n{\n    printFunctionCalled(\"mywait4\");\n    pid_t res = fptrwait4(__pid, __status, __options, __rusage);\n\n    return res;\n}\n\nssize_t myreadv(int __fd, const struct iovec *__iov, int __iovcnt) \n{\n    printFunctionCalled(\"myreadv\");\n    ssize_t res = fptrreadv(__fd, __iov, __iovcnt);\n\n    return res;\n}\n\nssize_t mywritev(int __fd, const struct iovec *__iov, int __iovcnt) \n{\n    printFunctionCalled(\"mywritev\");\n    ssize_t res = fptrwritev(__fd, __iov, __iovcnt);\n\n    return res;\n}\n\nint myflock(int __fd, int __operation) \n{\n    printFunctionCalled(\"myflock\");\n    int res = fptrflock(__fd, __operation);\n\n    return res;\n}\n\nvoid myflockfile(FILE *__filehandle) \n{\n    printFunctionCalled(\"myflockfile\");\n    fptrflockfile(__filehandle);\n}\n\nvoid myfunlockfile(FILE *__filehandle) \n{\n    printFunctionCalled(\"myfunlockfile\");\n    fptrfunlockfile(__filehandle);\n}\n\nint mylockf(int __fd, int __cmd, off_t __len) \n{\n    printFunctionCalled(\"mylockf\");\n    int res = fptrlockf(__fd, __cmd, __len);\n\n    return res;\n}\n\nint mysetenv(const CHAR_PTR __name, const CHAR_PTR __value, int __overwrite) \n{\n    printFunctionCalled(\"mysetenv\");\n    int res = fptrsetenv(__name, __value, __overwrite);\n\n    return res;\n}\n\nint myunsetenv(const CHAR_PTR __name) \n{\n    printFunctionCalled(\"myunsetenv\");\n    int res = fptrunsetenv(__name);\n\n    return res;\n}\n\nCHAR_PTR  mygetenv(const CHAR_PTR __name) \n{\n    printFunctionCalled(\"mygetenv\");\n    CHAR_PTR  res = fptrgetenv(__name);\n\n    return res;\n}\n\nvoid myperror(const CHAR_PTR __s) \n{\n    printFunctionCalled(\"myperror\");\n    fptrperror(__s);\n\n}\n\nVOID_PTR  mymmap(VOID_PTR __addr, size_t __len, int __prot, int __flags, int __fildes,\n        off_t __off) \n{\n    printFunctionCalled(\"mymmap\");\n    VOID_PTR  res = fptrmmap(__addr, __len, __prot, __flags, __fildes, __off);\n\n    return res;\n}\n\nint mymunmap(VOID_PTR __addr, size_t __len) \n{\n    printFunctionCalled(\"mymunmap\");\n    int res = fptrmunmap(__addr, __len);\n\n    return res;\n}\n\nint myfileno(FILE *__stream)\n{   \n    printFunctionCalled(\"myfileno\");\n    int res = fptrfileno(__stream);\n\n    return res;\n}\n\npid_t mygetpid(void) \n{\n    printFunctionCalled(\"mygetpid\");\n    pid_t res = fptrgetpid();\n\n    return res;\n}\n\npid_t mygetppid(void) \n{\n    printFunctionCalled(\"mygetppid\");\n    pid_t res = fptrgetppid();\n\n    return res;\n}\n\nVOID_PTR  mymemset(VOID_PTR __s, int __c, size_t __n) {\n    printFunctionCalled(\"mymemset\");\n    VOID_PTR  res = fptrmemset(__s, __c, __n);\n\n    return res;\n}\n\nVOID_PTR  mymemcpy(VOID_PTR __dest, const VOID_PTR __src, size_t __n) \n{\n    printFunctionCalled(\"mymemcpy\");\n    VOID_PTR  res = fptrmemcpy(__dest, __src, __n);\n\n    return res;\n}\n\nint myaccess(const CHAR_PTR __pathname, int __mode) \n{\n    printFunctionCalled(\"myaccess\");\n    int res = fptraccess(__pathname, __mode);\n\n    return res;\n}\n\noff_t mylseek(int __fd, off_t __offset, int __whence) \n{\n    printFunctionCalled(\"mylseek\");\n    off_t res = fptrlseek(__fd, __offset, __whence);\n\n    return res;\n}\n\noff64_t mylseek64(int __fd, off64_t __offset, int __whence) \n{\n    printFunctionCalled(\"mylseek64\");\n    off64_t res = fptrlseek64(__fd, __offset, __whence);\n\n    return res;\n}\n\nint myfdatasync(int __fd) {\n    printFunctionCalled(\"myfdatasync\");\n    int res = fptrfdatasync(__fd);\n\n    return res;\n}\n\nint myunlink(const CHAR_PTR __pathname) \n{\n    printFunctionCalled(\"myunlink\");\n    int res = fptrunlink(__pathname);\n\n    return res;\n}\n\nsize_t mystrlen(const CHAR_PTR __s) \n{\n    printFunctionCalled(\"mystrlen\");\n    size_t res = fptrstrlen(__s);\n\n    return res;\n}\n\nsize_t mywcslen(const wchar_t *__s)\n{\n    printFunctionCalled(\"mywcslen\");\n    size_t res = fptrwcslen(__s);\n\n    return res;\n}\n\nCHAR_PTR  mystrcpy(CHAR_PTR __dest, const CHAR_PTR __src) \n{\n    printFunctionCalled(\"mystrcpy\");\n    CHAR_PTR  res = fptrstrcpy(__dest, __src);\n\n    return res;\n}\n\nCHAR_PTR  mystrncpy(CHAR_PTR __dest, const CHAR_PTR __src, size_t __n) \n{\n    printFunctionCalled(\"mystrncpy\");\n    CHAR_PTR  res = fptrstrncpy(__dest, __src, __n);\n\n    return res;\n}\n\nCHAR_PTR  mystrcat(CHAR_PTR __dest, const CHAR_PTR __src) \n{\n    printFunctionCalled(\"mystrcat\");\n    CHAR_PTR  res = fptrstrcat(__dest, __src);\n\n    return res;\n}\n\nCHAR_PTR  mystrstr(const CHAR_PTR __haystack, const CHAR_PTR __needle) \n{\n    printFunctionCalled(\"mystrstr\");\n    CHAR_PTR  res = fptrstrstr(__haystack, __needle);\n\n    return res;\n}\n\nCHAR_PTR  mystrchr0(const CHAR_PTR __s, int __c) \n{\n    printFunctionCalled(\"mystrchr0\");\n    CHAR_PTR  res = fptrstrchr0(__s, __c);\n\n    return res;\n}\n\nCHAR_PTR  mystrrchr(const CHAR_PTR __s, int __c) \n{\n    printFunctionCalled(\"mystrrchr\");\n    CHAR_PTR  res = fptrstrrchr(__s, __c);\n\n    return res;\n}\n\nint mystrcmp(const CHAR_PTR __s1, const CHAR_PTR __s2) \n{\n    printFunctionCalled(\"mystrcmp\");\n    int res = fptrstrcmp(__s1, __s2);\n\n    return res;\n}\n\nint mystrncmp(const CHAR_PTR __s1, const CHAR_PTR __s2, size_t __n) \n{\n    printFunctionCalled(\"mystrncmp\");\n    int res = fptrstrncmp(__s1, __s2, __n);\n\n    return res;\n}\n\nint mysigaddset(sigset_t *__set, int __signum) \n{\n    printFunctionCalled(\"mysigaddset\");\n    int res = fptrsigaddset(__set, __signum);\n\n    return res;\n}\n\nint mysigdelset(sigset_t *__set, int __signum) {\n    printFunctionCalled(\"mysigdelset\");\n    int res = fptrsigdelset(__set, __signum);\n\n    return res;\n}\n\nint mysigismember(sigset_t *__set, int __signum)\n{\n    printFunctionCalled(\"mysigismember\");\n    int res = fptrsigismember(__set, __signum);\n\n    return res;\n}\n\nCHAR_PTR  mystrerror(int __errnum) \n{\n    printFunctionCalled(\"mystrerror\");\n    CHAR_PTR  res = fptrstrerror(__errnum);\n\n    return res;\n}\n\nint mybind(int __sockfd, const struct sockaddr *__addr, socklen_t __addrlen) \n{\n    printFunctionCalled(\"mybind\");\n    int res = fptrbind(__sockfd, __addr, __addrlen);\n\n    return res;\n}\n\nint mylisten(int __sockfd, int __backlog) \n{\n    printFunctionCalled(\"mylisten\");\n    int res = fptrlisten(__sockfd, __backlog);\n\n    return res;\n}\n\nint myuname(struct utsname *__name) \n{\n    printFunctionCalled(\"myuname\");\n    int res = fptruname(__name);\n\n    return res;\n}\n\nint mygethostname(CHAR_PTR __name, size_t __len) \n{\n    printFunctionCalled(\"mygethostname\");\n    int res = fptrgethostname(__name, __len);\n\n    return res;\n}\n\nint mykill(pid_t __pid, int __sig) \n{\n    printFunctionCalled(\"mykill\");\n    int res = fptrkill(__pid, __sig);\n\n    return res;\n}\n\nint mysched_yield(void) \n{\n    printFunctionCalled(\"mysched_yield\");\n    int res = fptrsched_yield();\n\n    return res;\n}\n\nint mytimer_settime(timer_t __timerid, int __flags,\n        const struct itimerspec * __value, struct itimerspec * __ovalue) \n{\n    printFunctionCalled(\"mytimer_settime\");\n    int res = fptrtimer_settime(__timerid, __flags, __value, __ovalue);\n\n    return res;\n}\n\nint mysigaltstack(const stack_t *__ss, stack_t *__oss) \n{\n    printFunctionCalled(\"mysigaltstacke\");\n    int res = fptrsigaltstack(__ss, __oss);\n\n    return res;\n}\n\nint mysleep(unsigned int __seconds) \n{\n    printFunctionCalled(\"mysleep\");\n    int res = fptrsleep(__seconds);\n\n    return res;\n}\n\nint mysocket(int __domain, int __type, int __protocol) \n{\n    printFunctionCalled(\"mysocket\");\n    int res = fptrsocket(__domain, __type, __protocol);\n\n    return res;\n}\n\nint myshutdown(int __fd, int __how) \n{\n    printFunctionCalled(\"myshutdown\");\n    int res = fptrshutdown(__fd, __how);\n\n    return res;\n}\n\nint myselect(int __nfds, fd_set *__restrict __readfds,\n        fd_set *__restrict __writefds, fd_set *__restrict __exceptfds,\n        struct timeval *__restrict __timeout) \n{\n    printFunctionCalled(\"myselect\");\n    int res = fptrselect(__nfds, __readfds, __writefds, __exceptfds, __timeout);\n\n    return res;\n}\n\nint mypoll(struct pollfd * __fds, nfds_t __nfds, int __timeout) \n{\n    printFunctionCalled(\"mypoll\");\n    int res = fptrpoll(__fds, __nfds, __timeout);\n\n    return res;\n}\n\nint myaccept(int __fd, __SOCKADDR_ARG __addr,\n        socklen_t *__restrict __addr_len) \n{\n    printFunctionCalled(\"myaccept\");\n    int res = fptraccept(__fd, __addr, __addr_len);\n\n    return res;\n}\n\nint myconnect(int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len) \n{\n    printFunctionCalled(\"myconnect\");\n    int res = fptrconnect(__fd, __addr, __len);\n\n    return res;\n}\n\nssize_t myrecv(int __fd, VOID_PTR  __buf, size_t __n, int __flags) \n{\n    printFunctionCalled(\"myrecv\");\n    ssize_t res = fptrrecv(__fd, __buf, __n, __flags);\n\n    return res;\n}\n\nssize_t myrecvfrom(int __fd, VOID_PTR __restrict __buf, size_t __n, int __flags,\n        __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len) \n{\n    printFunctionCalled(\"myrecvfrom\");\n    ssize_t res = fptrrecvfrom(__fd, __buf, __n, __flags, __addr, __addr_len);\n\n    return res;\n}\n\nssize_t mysend(int __fd, __const VOID_PTR  __buf, size_t __n, int __flags) \n{\n    printFunctionCalled(\"mysend\");\n    ssize_t res = fptrsend(__fd, __buf, __n, __flags);\n\n    return res;\n}\n\nwint_t mygetwc(__FILE * __stream) \n{\n    printFunctionCalled(\"mygetwc\");\n    wint_t res = fptrgetwc(__stream);\n\n    return res;\n}\n\nvoid myexit(int __status) \n{\n    printFunctionCalled(\"myexit\");\n    fptrexit(__status);\n\n}\n\nint mysetitimer(__itimer_which_t  __which, __const\n        struct itimerval *__restrict __new,\n        struct itimerval *__restrict __old) \n{\n    printFunctionCalled(\"mysetitimer\");\n    int res = fptrsetitimer(__which, __new, __old);\n\n    return res;\n}\n\nint mysigpending(sigset_t * __set) \n{\n    printFunctionCalled(\"mysigpending\");\n    int res = fptrsigpending(__set);\n\n    return res;\n}\n\n__sighandler_t mysignal(int __sig, __sighandler_t  __handler) \n\n{\n    printFunctionCalled(\"mysignal\");\n    __sighandler_t res = fptrsignal(__sig, __handler);\n\n    return res;\n}\n\nvoid myabort() \n{\n    printFunctionCalled(\"myabort\");\n    fptrabort();\n}\n\nint myclose(int __fd) \n{\n    printFunctionCalled(\"myclose\");\n    int res = fptrclose(__fd);\n\n    return res;\n}\n\nssize_t mysendto(int __fd, __const VOID_PTR  __buf, size_t __n, int __flags,\n        __CONST_SOCKADDR_ARG __addr, socklen_t __addr_len) \n{\n    printFunctionCalled(\"mysendto\");\n    ssize_t res = fptrsendto(__fd, __buf, __n, __flags, __addr, __addr_len);\n\n    return res;\n}\n\nint my_IO_getc(FILE * __stream) \n{\n    printFunctionCalled(\"my_IO_getc\");\n    int res = fptr_IO_getc(__stream);\n\n    return res;\n}\n\nint mygetchar()\n{\n    printFunctionCalled(\"mygetchar\");\n    int res = fptrgetchar();\n\n    return res;\n}\n\nwint_t mygetwchar() \n{\n    printFunctionCalled(\"mygetwchar\");\n    wint_t res = fptrgetwchar();\n\n    return res;\n}\n\nCHAR_PTR  mygets(CHAR_PTR  __s) \n{\n    printFunctionCalled(\"mygets\");\n    CHAR_PTR  res = fptrgets(__s);\n\n    return res;\n}\n\nCHAR_PTR  myfgets(CHAR_PTR __restrict __s, int __n, FILE *__restrict __stream) \n{\n    printFunctionCalled(\"myfgets\");\n    CHAR_PTR  res = fptrfgets(__s, __n, __stream);\n\n    return res;\n}\n\nwint_t myfgetwc(__FILE * __stream) \n{\n    printFunctionCalled(\"myfgetwc\");\n    wint_t res = fptrfgetwc(__stream);\n\n    return res;\n}\n\nsize_t myfread(VOID_PTR __restrict __ptr, size_t __size, size_t __n,\n        FILE *__restrict __stream)\n{\n    printFunctionCalled(\"myfread\");\n    size_t res = fptrfread(__ptr, __size, __n, __stream);\n\n    return res;\n}\n\nsize_t myfwrite(__const VOID_PTR __restrict __ptr, size_t __size, size_t __n,\n        FILE *__restrict __s) \n{\n    printFunctionCalled(\"myfwrite\");\n    size_t res = fptrfwrite(__ptr, __size, __n, __s);\n\n    return res;\n}\n\nint myopen(__const CHAR_PTR  __file, int __flags, mode_t __mode) \n{\n    printFunctionCalled(\"myopen\");\n    int res = fptropen(__file, __flags, __mode);\n\n    return res;\n}\n\nint mygetw(FILE * __stream) \n{\n    printFunctionCalled(\"mygetw\");\n    int res = fptrgetw(__stream);\n\n    return res;\n}\n\nvoid myfgetc(__FILE * __stream) \n{\n    printFunctionCalled(\"myfgetc\");\n    fptrfgetc(__stream);\n\n}\n\nwchar_t * myfgetws(wchar_t *__restrict __ws, int __n,\n        __FILE *__restrict __stream) \n        {\n    printFunctionCalled(\"myfgetws\");\n    wchar_t * res = fptrfgetws(__ws, __n, __stream);\n\n    return res;\n}\n\nint mypipe(int* __pipedes) \n{\n    printFunctionCalled(\"mypipe\");\n    int res = fptrpipe(__pipedes);\n\n    return res;\n}\n\nssize_t myread(int __fd, VOID_PTR  __buf, size_t __nbytes) \n{\n    printFunctionCalled(\"myread\");\n    ssize_t res = fptrread(__fd, __buf, __nbytes);\n\n    return res;\n}\n\nssize_t mywrite(int __fd, __const VOID_PTR  __buf, size_t __n) \n{\n    printFunctionCalled(\"mywrite\");\n    ssize_t res = fptrwrite(__fd, __buf, __n);\n\n    return res;\n}\n\nFILE * myfopen(__const CHAR_PTR __restrict __filename,\n        __const CHAR_PTR __restrict __modes) \n{\n    printFunctionCalled(\"myfopen\");\n    FILE * res = fptrfopen(__filename, __modes);\n\n    return res;\n}\n\nFILE * myfdopen(int __fd, __const CHAR_PTR  __modes) \n{\n    printFunctionCalled(\"myfdopen\");\n    FILE * res = fptrfdopen(__fd, __modes);\n\n    return res;\n}\n\nint mycallrpc(__const CHAR_PTR  __host, u_long __prognum, u_long __versnum,\n        u_long __procnum, xdrproc_t __inproc, __const CHAR_PTR  __in,\n        xdrproc_t __outproc, CHAR_PTR  __out) \n{\n    printFunctionCalled(\"mycallrpc\");\n    int res = fptrcallrpc(__host, __prognum, __versnum, __procnum, __inproc,\n            __in, __outproc, __out);\n\n    return res;\n}\n\nenum clnt_stat myclnt_broadcast(u_long __prog, u_long __vers, u_long __proc,\n        xdrproc_t __xargs, caddr_t __argsp, xdrproc_t __xresults,\n        caddr_t __resultsp, resultproc_t __eachresult) \n{\n    printFunctionCalled(\"myclnt_broadcast\");\n    enum clnt_stat res = fptrclnt_broadcast(__prog, __vers, __proc, __xargs,\n            __argsp, __xresults, __resultsp, __eachresult);\n\n    return res;\n}\n\nCLIENT * myclntudp_create(struct sockaddr_in * __raddr, u_long __program,\n        u_long __version, struct timeval __wait_resend, INT_PTR  __sockp) \n{\n    printFunctionCalled(\"myclntudp_create\");\n    CLIENT * res = fptrclntudp_create(__raddr, __program, __version,\n            __wait_resend, __sockp);\n\n    return res;\n}\n\nCLIENT * myclntudp_bufcreate(struct sockaddr_in * __raddr, u_long __program,\n        u_long __version, struct timeval __wait_resend, INT_PTR  __sockp,\n        u_int __sendsz, u_int __recvsz) \n{\n    printFunctionCalled(\"myclntudp_bufcreate\");\n    CLIENT * res = fptrclntudp_bufcreate(__raddr, __program, __version,\n            __wait_resend, __sockp, __sendsz, __recvsz);\n\n    return res;\n}\n\nstruct pmaplist * mypmap_getmaps(struct sockaddr_in * __address) \n{\n    printFunctionCalled(\"mypmap_getmaps\");\n    struct pmaplist * res = fptrpmap_getmaps(__address);\n\n    return res;\n}\n\nu_short mypmap_getport(struct sockaddr_in * __address, u_long __program,\n        u_long __version, u_int __protocol) \n{\n    printFunctionCalled(\"mypmap_getport\");\n    u_short res = fptrpmap_getport(__address, __program, __version, __protocol);\n\n    return res;\n}\n\nenum clnt_stat mypmap_rmtcall(struct sockaddr_in * __addr, u_long __prog,\n        u_long __vers, u_long __proc, xdrproc_t __xdrargs, caddr_t __argsp,\n        xdrproc_t __xdrres, caddr_t __resp, struct timeval __tout,\n        u_long * __port_ptr) \n{\n    printFunctionCalled(\"mypmap_rmtcall\");\n    enum clnt_stat res = fptrpmap_rmtcall(__addr, __prog, __vers, __proc,\n            __xdrargs, __argsp, __xdrres, __resp, __tout, __port_ptr);\n\n    return res;\n}\n\nbool_t mypmap_set(u_long __program, u_long __vers, int __protocol, u_short __port) \n{\n    printFunctionCalled(\"mypmap_set\");\n    bool_t res = fptrpmap_set(__program, __vers, __protocol, __port);\n\n    return res;\n}\n\nCLIENT * myclntraw_create(u_long __prog, u_long __vers) \n{\n    printFunctionCalled(\"myclntraw_create\");\n    CLIENT * res = fptrclntraw_create(__prog, __vers);\n\n    return res;\n}\n\nvoid mysvc_run()\n{\n    printFunctionCalled(\"mysvc_run\");\n    fptrsvc_run();\n}\n\nbool_t mysvc_sendreply(SVCXPRT * xprt, xdrproc_t __xdr_results,\n        caddr_t __xdr_location) \n{\n    printFunctionCalled(\"mysvc_sendreply\");\n    bool_t res = fptrsvc_sendreply(xprt, __xdr_results, __xdr_location);\n\n    return res;\n}\n\nSVCXPRT * mysvcraw_create() \n{\n    printFunctionCalled(\"mysvcraw_create\");\n    SVCXPRT * res = fptrsvcraw_create();\n\n    return res;\n}\n\nSVCXPRT * mysvctcp_create(int __sock, u_int __sendsize, u_int __recvsize) \n{\n    printFunctionCalled(\"mypmap_rmtcall\");\n    SVCXPRT * res = fptrsvctcp_create(__sock, __sendsize, __recvsize);\n\n    return res;\n}\n\nSVCXPRT * mysvcudp_bufcreate(int __sock, u_int __sendsz, u_int __recvsz)\n{\n    printFunctionCalled(\"mysvcudp_bufcreate\");\n    SVCXPRT * res = fptrsvcudp_bufcreate(__sock, __sendsz, __recvsz);\n\n    return res;\n}\n\nSVCXPRT * mysvcudp_create(int __sock)\n{\n    printFunctionCalled(\"mysvcudp_create\");\n    SVCXPRT * res = fptrsvcudp_create(__sock);\n\n    return res;\n}\n\nvoid my_exit(int __status)\n{\n    printFunctionCalled(\"my_exit\");\n    fptr_exit(__status);\n\n}\n\nint my_nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) \n{\n    printFunctionCalled(\"my_nanosleep\");\n    int res = fptrnanosleep(__rqtp, __rmtp);\n\n    return res;\n}\n\nint mysigprocmask(int __how, __const sigset_t *__restrict __set,\n        sigset_t *__restrict __oset) \n{\n    printFunctionCalled(\"mysigprocmask\");\n    int res = fptrsigprocmask(__how, __set, __oset);\n\n    return res;\n}\n\nint mypselect(int __nfds, fd_set *__restrict __readfds,\n        fd_set *__restrict __writefds, fd_set *__restrict __exceptfds,\n        const struct timespec *__restrict __timeout,\n        const __sigset_t *__restrict __sigmask) \n{\n    printFunctionCalled(\"mypselect\");\n    int res = fptrpselect(__nfds, __readfds, __writefds, __exceptfds, __timeout,\n            __sigmask);\n\n    return res;\n}\n\npid_t mywait(INT_PTR __status) \n{\n    printFunctionCalled(\"mywait\");\n    int res = fptrwait(__status);\n\n    return res;\n}\n\nint myfclose(FILE * __stream) \n{\n    printFunctionCalled(\"myfclose\");\n    int res = fptrfclose(__stream);\n\n    return res;\n}\n\nint myioctl(int __d, int __request, CHAR_PTR  __argp) \n{\n    printFunctionCalled(\"myioctl\");\n    int res = fptrioctl(__d, __request, __argp);\n\n    return res;\n}\n\nint myfcntl(int __fd, int __cmd, VOID_PTR  __argp) \n{\n    printFunctionCalled(\"myfcntl\");\n    int res = fptrfcntl(__fd, __cmd, __argp);\n\n    return res;\n}\n\nVOID_PTR  my__libc_dlopen_mode(const CHAR_PTR __name, int __mode) \n{\n    printFunctionCalled(\"my__libc_dlopen_mode\");\n    VOID_PTR  res = fptr__libc_dlopen_mode(__name, __mode);\n\n    return res;\n}\n\nINT_PTR  my__errno_location(void) \n{\n    printFunctionCalled(\"my__errno_location\");\n    INT_PTR  res = fptr__errno_location();\n\n    return res;\n}\n\nint mysyscall(int __number, long int __arg1, long int __arg2, long int __arg3,\n        long int __arg4, long int __arg5, long int __arg6, long int __arg7) \n{\n    printFunctionCalled(\"mysyscall\");\n    int res = fptrsyscall(__number, __arg1, __arg2, __arg3, __arg4, __arg5,\n            __arg6, __arg7);\n\n    return res;\n}\n\nint mysigaction(int __sig, __const struct sigaction *__restrict __act,\n        struct sigaction *__restrict __oact) \n{\n    printFunctionCalled(\"mysigaction\");\n    int res = fptrsigaction(__sig, __act, __oact);\n\n    return res;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/tpss_lin_libdl.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n * This tool mimics the behavior of TPSS on Linux by adding probes to various libdl functions.\n * However, in this tool these probes are merely empty wrappers that call the original functions.\n * The objective of the test is to verify that probe generation and insertion don't cause Pin\n * to crash.\n */\n\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <dlfcn.h>\nusing std::string;\nusing std::ios;\nusing std::hex;\nusing std::cerr;\nusing std::ofstream;\nusing std::endl;\n\ntypedef char * CHAR_PTR;\n\ntypedef void * VOID_PTR;\n\nofstream OutFile;\n\n/* ===================================================================== */\n/* Commandline Switches                                                  */\n/* ===================================================================== */\n\nKNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\",\n    \"o\", \"tpss_lin_libdl.txt\", \"specify tool log file name\");\n\n/* ===================================================================== */\n/* Utility functions                                                     */\n/* ===================================================================== */\n\n// Print help information\nINT32 Usage()\n{\n    cerr << \"This tool mimics the behavior of TPSS on Linux by adding probes to various libdl functions.\" << endl;\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return 1;\n}\n\n// Utility function to return the time\nstring CurrentTime()\n{\n    char tmpbuf[128];\n    time_t thetime = time(NULL);\n    ctime_r(&thetime, tmpbuf);\n    return tmpbuf;\n}\n\n\n/* ===================================================================== */\n/* Function signatures - these functions will be probed                  */\n/* ===================================================================== */\n\nVOID_PTR (*fptrdlopen)(__const CHAR_PTR __file, int  __mode);\n\nint (*fptrdlclose)(VOID_PTR __handle);\n\nVOID_PTR (*fptrdlsym)(VOID_PTR __handle , __const CHAR_PTR __name );\n\nVOID_PTR (*fptrdlvsym)( VOID_PTR __handle, __const CHAR_PTR __name,__const CHAR_PTR __version);\n\nint (*fptrdladdr)(__const void *__address , Dl_info * __info);\n\nint (*fptrdladdr1)(__const void * __address , Dl_info * __info, void ** __extra_info, int __flags);\n\nCHAR_PTR (*fptrdlerror)(void);\n\n/* ===================================================================== */\n/* Probes - implementation of the wrapper functions                      */\n/* ===================================================================== */\n\nVOID_PTR mydlopen(__const CHAR_PTR __file, int __mode)\n{\n   OutFile << CurrentTime() << \"mydlopen called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlopen(__file, __mode);\n\n   return res;\n}\n\nint mydlclose(VOID_PTR __handle)\n{\n   OutFile << CurrentTime() << \"mydlclose called \" << endl;\n   OutFile.flush();\n   int res = fptrdlclose(__handle);\n\n   return res;\n}\n\nVOID_PTR mydlsym(VOID_PTR  __handle, __const CHAR_PTR  __name)\n{\n   OutFile << CurrentTime() << \"mydlsym called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlsym(__handle, __name);\n\n   return res;\n}\n\nVOID_PTR mydlvsym(VOID_PTR  __handle, __const CHAR_PTR  __name, __const CHAR_PTR __version)\n{\n   OutFile << CurrentTime() << \"mydlvsym called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlvsym(__handle, __name, __version);\n\n   return res;\n}\n\nint mydladdr(__const void * __address, Dl_info * __info)\n{\n   OutFile << CurrentTime() << \"mydladdr called \" << endl;\n   OutFile.flush();\n   int res = fptrdladdr(__address, __info);\n\n   return res;\n}\n\nint mydladdr1(__const void * __address, Dl_info * __info, void ** __extra_info, int __flags)\n{\n   OutFile << CurrentTime() << \"mydladdr1 called \" << endl;\n   OutFile.flush();\n   int res = fptrdladdr1(__address, __info, __extra_info, __flags);\n\n   return res;\n}\n\nCHAR_PTR mydlerror(void)\n{\n   OutFile << CurrentTime() << \"CHAR_PTR called \" << endl;\n   OutFile.flush();\n   CHAR_PTR res = fptrdlerror();\n\n   return res;\n}\n\n/* ===================================================================== */\n/* Instrumnetation functions                                             */\n/* ===================================================================== */\n\n// Image load callback - inserts the probes.\nvoid ImgLoad(IMG img, void *v)\n{\n    // Called every time a new image is loaded\n\n    if ( (IMG_Name(img).find(\"libdl.so\") != string::npos) ||\n         (IMG_Name(img).find(\"LIBDL.SO\") != string::npos) ||\n         (IMG_Name(img).find(\"LIBDL.so\") != string::npos) )\n    {\n        RTN rtndlclose = RTN_FindByName(img, \"dlclose\");\n        if (RTN_Valid(rtndlclose) && RTN_IsSafeForProbedReplacement(rtndlclose))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlclose at \" << RTN_Address(rtndlclose) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlclose, AFUNPTR(mydlclose)));\n            fptrdlclose = (int (*)(VOID_PTR ))fptr;\n        }\n\n        RTN rtndlopen = RTN_FindByName(img, \"dlopen\");\n        if (RTN_Valid(rtndlopen) && RTN_IsSafeForProbedReplacement(rtndlopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlopen at \" << RTN_Address(rtndlopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlopen, AFUNPTR(mydlopen)));\n            fptrdlopen = (VOID_PTR (*)(__const CHAR_PTR , int ))fptr;\n        }\n\n        RTN rtndlsym = RTN_FindByName(img, \"dlsym\");\n        if (RTN_Valid(rtndlsym) && RTN_IsSafeForProbedReplacement(rtndlsym))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlsym at \" << RTN_Address(rtndlsym) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlsym, AFUNPTR(mydlsym)));\n            fptrdlsym = (VOID_PTR (*)(VOID_PTR, __const CHAR_PTR ))fptr;\n        }\n\n        RTN rtndlvsym = RTN_FindByName(img, \"dlvsym\");\n        if (RTN_Valid(rtndlvsym) && RTN_IsSafeForProbedReplacement(rtndlvsym))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlvsym at \" << RTN_Address(rtndlvsym) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlvsym, AFUNPTR(mydlvsym)));\n            fptrdlvsym = (VOID_PTR (*)(VOID_PTR, __const CHAR_PTR, __const CHAR_PTR))fptr;\n        }\n\n        RTN rtndladdr = RTN_FindByName(img, \"dladdr\");\n        if (RTN_Valid(rtndladdr) && RTN_IsSafeForProbedReplacement(rtndladdr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dladdr at \" << RTN_Address(rtndladdr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndladdr, AFUNPTR(mydladdr)));\n            fptrdladdr = (int (*)(__const void * , Dl_info * ))fptr;\n        }\n\n        RTN rtndladdr1 = RTN_FindByName(img, \"dladdr1\");\n        if (RTN_Valid(rtndladdr) && RTN_IsSafeForProbedReplacement(rtndladdr1))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dladdr1 at \" << RTN_Address(rtndladdr1) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndladdr, AFUNPTR(mydladdr1)));\n            fptrdladdr1 = (int (*)(__const void * , Dl_info *, void **, int ))fptr;\n        }\n\n        RTN rtndlerror = RTN_FindByName(img, \"dlerror\");\n        if (RTN_Valid(rtndlerror) && RTN_IsSafeForProbedReplacement(rtndlerror))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlerror at \" << RTN_Address(rtndlerror) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlerror, AFUNPTR(mydlerror)));\n            fptrdlerror = (CHAR_PTR (*)(void ))fptr;\n        }\n    }\n    // finished instrumentation\n}\n\n/* ===================================================================== */\n/* Main function                                                         */\n/* ===================================================================== */\n\nint main(int argc, char *argv[])\n{\n    // Initialize Pin\n    PIN_InitSymbols();\n    if (PIN_Init(argc,argv))\n    {\n        return Usage();\n    }\n\n    OutFile.open(KnobOutputFile.Value().c_str());\n    OutFile << hex;\n    OutFile.setf(ios::showbase);\n    OutFile << CurrentTime() << \"started!\" << endl;\n    OutFile.flush();\n\n    // Register the instrumentation callback\n    IMG_AddInstrumentFunction(ImgLoad, 0);\n\n\n    // Start the application\n    PIN_StartProgramProbed(); // never returns\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/unloadtest_unix.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include \"tool_macros.h\"\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n    Load(SHARED_LIB(\"libone\"), 1);\n    Load(SHARED_LIB(\"libtwo\"), 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Tests/sourceLocation_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n * This app checks a bug in the debug_elf cache mechanism. The cache contains images\n * that have previously been searched for debug information. When a pintool calls the\n * PIN_GetSourceLocation API, this cache is searched first (for the nearest address\n * which is greater or equal to the one being searched for). However, unloaded images\n * were never removed from the cache. When the API was used during an image unload\n * callback, if the images at high addresses were removed first, the search could be\n * conducted on images in the cache that had already been removed from Pin's internal\n * data structures, thus causing an assertion. The solution was to remove these images\n * from the cache as well as from the other data structres.\n * This app loads two images and then unloads the higher addressed one first in order\n * to recreate the conditions mentioned above.\n */\n\n#include <dlfcn.h>\n#include <iostream>\n#include <cstdlib>\n\nusing std::cerr;\nusing std::endl;\n\nvoid* DLopen(const char* filename) {\n    void* handle = dlopen(filename, RTLD_LAZY);\n    if (handle == NULL) {\n        cerr << \"APP ERROR: failed to open \" << filename << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n    return handle;\n}\n\nvoid* DLsym(void* handle, const char* symname) {\n    dlerror(); // clear errors\n    void* sym = dlsym(handle, symname);\n    char* error = dlerror();\n    if (error != NULL) {\n        cerr << \"APP ERROR: failed to get address for symbol \" << symname << \" - \" << error << endl;\n        exit(-1);\n    }\n    return sym;\n}\n\nvoid DLcloseBoth(void* first, void* second) {\n    if (dlclose(first) != 0) {\n        cerr << \"APP ERROR: failed to close image at \" << first << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n    if (dlclose(second) != 0) {\n        cerr << \"APP ERROR: failed to close image at \" << second << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n}\n\n/*\n * Expected argv arguments:\n * [1] image1\n * [2] image2\n */\nint main(int argc, char* argv[]) {\n    \n    void* handle1 = DLopen(argv[1]);            // open image1\n    void* handle2 = DLopen(argv[2]);            // open image2\n    void* dummy1 = DLsym(handle1, \"dummy1\");    // get address from image1\n    void* dummy2 = DLsym(handle2, \"dummy2\");    // get address from image2\n\n    // unload images - higher addressed image first\n    if (dummy1 > dummy2) {\n        DLcloseBoth(handle1, handle2);\n    }\n    else {\n        DLcloseBoth(handle2, handle1);\n    }\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/ImageTests/l_imageLoad_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <dlfcn.h>\n#include <string.h>\n\n#define MAX_COMMAND_LINE_SIZE 15    // the size for the array of arguments to execv (this value is arbitrary)\n#define EXPORT_SYM extern \"C\"\n\nEXPORT_SYM int AfterAttach();\n\nstatic int MAX_SIZE = 128; /*maximum line size*/\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_FORK_FAILED,      // 1\n    RES_EXEC_FAILED,      // 2\n    RES_LOAD_FAILED,      // 3\n    RES_RES_INVALID_ARGS  // 4\n};\n\nvoid UnixOpen(char* filename)\n{\n    void* dlh = dlopen(filename, RTLD_LAZY);\n    if( !dlh )\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", filename, dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n    dlclose(dlh);\n}\n\nint AfterAttach()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return 0;\n}\n\n/*\n    Expected argv arguments:\n    [1] first image to load\n    [2] second image to load\n    [3] pin executable\n    [4] Pin flags (e.g. -slow_asserts)\n        >> zero or more flags possible\n    [5] \"-probe\"\n    [6] \"-t\"\n    [7] tool\n    [8] \"-o\"\n    [9] tool's output file\n*/\n\nint main(int argc, char** argv)\n{\n    if(argc < 8)\n    {\n        fprintf(stderr, \"l_imageLoad_app received too few arguments.\\n\" );\n        exit(RES_RES_INVALID_ARGS);\n    }\n    if(argc > MAX_COMMAND_LINE_SIZE - 2)    // added: -pid attachPid NULL, omitted: argv[0..2]\n    {\n        fprintf(stderr, \"l_imageLoad_app received too many arguments\\n\" );\n        exit(RES_RES_INVALID_ARGS);\n    }\n\n    UnixOpen(argv[1]);\n\n    pid_t parentPid = getpid();\n    pid_t child = fork();\n    if (child < 0) {\n        perror(\"fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n    if (child)\n    {\n        // inside parent\n        while(!AfterAttach())\n        {\n            sleep(1);\n        }\n\n        UnixOpen(argv[2]);\n    }\n    if ( child == 0 )\n    {\n        // inside child\n        char attachPid[MAX_SIZE];\n        sprintf(attachPid, \"%d\", parentPid);\n        char* args[MAX_COMMAND_LINE_SIZE] = {NULL};    // arguments for execv command\n        int args_count = 0;\n        int argv_count = 3;                            // to start from argv[3]...\n        args[args_count++] = argv[argv_count++];       // by convention, first arg is the filename of the executed file (pin)\n        args[args_count++] = (char*)\"-pid\";\n        args[args_count++] = attachPid;\n        while (strcmp(argv[argv_count], \"-t\") != 0){   // additional Pin flags (optional)\n            args[args_count++] = argv[argv_count++];   // including \"-probe\" (mandatory for test)\n        }\n        args[args_count++] = argv[argv_count++];       // \"-t\"\n        args[args_count++] = argv[argv_count++];       // tool\n        args[args_count++] = argv[argv_count++];       // \"-o\"\n        args[args_count++] = argv[argv_count++];       // tool's output file\n        args[args_count++] = NULL;                     // end\n        execv(argv[3], (char * const *)args);          // never returns\n        perror(\"execv failed while trying to attach Pin to the application\\n\");\n        exit(RES_EXEC_FAILED);\n    }\n    return RES_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/ImageTests/imageUnload_app.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <dlfcn.h>\n\nvoid Open(char* filename)\n{\n    void* dlh = dlopen(filename, RTLD_LAZY);\n    if( !dlh )\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\", filename, dlerror());\n        exit(2);\n    }\n    dlclose(dlh);\n}\n\nint main(int argc, char** argv)\n{\n    if(argc<1)\n    {\n        fprintf(stderr, \"No image name to load has been supplied\" );\n        fflush(stderr);\n        return 1;\n    }\n\n    Open(argv[1]);\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/ImageTests/full_path_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdio.h>\n#include <dlfcn.h>\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_LOAD_FAILED,      // 1\n    RES_RES_INVALID_ARGS  // 2\n};\n\n/*\n    Expected argv arguments:\n    [1] image to load\n*/\nint main(int argc, char** argv)\n{\n    if(argc!=2)\n    {\n        fprintf(stderr, \"No enough arguments\\n\" );\n        fflush(stderr);\n        return RES_RES_INVALID_ARGS;\n    }\n\n    void* handle;\n\n    handle = dlopen(argv[1], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        return RES_LOAD_FAILED;\n    }\n\n    return RES_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/ImageTests/split_image_linux_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <vector>\n#include <dlfcn.h>\n#include <limits.h>\n#include <link.h>\nusing std::pair;\nusing std::vector;\n\n// The executable filename of this program\nchar progname[4096];\n\n\n/*\n * Iterate over all images known to the loader and print their memory regions\n */\nint dl_iterate(struct dl_phdr_info *info, size_t size, void *data)\n{\n    const char* realname = info->dlpi_name;\n    vector<pair<void*, void*> > vecSegments;\n    if (strstr(realname, \"linux-gate.so\") == realname || strstr(realname, \"linux-vdso.so\") == realname)\n    {\n        // Don't count VDSO, PIN doesn't repont it intentionally\n        return 0;\n    }\n    for (int j = 0; j < info->dlpi_phnum; j++)\n    {\n        if (info->dlpi_phdr[j].p_type == PT_LOAD)\n        {\n            void* start = (void *) (info->dlpi_addr + info->dlpi_phdr[j].p_vaddr);\n            void* end = (void*)((char*)start + info->dlpi_phdr[j].p_memsz - 1);\n            vecSegments.push_back(pair<void*, void*>(start, end));\n            if (*realname == 0 && (void*)dl_iterate >= start && (void*)dl_iterate < end)\n            {\n                realname = progname;\n            }\n        }\n    }\n    if (*realname != 0)\n    {\n        for (vector<pair<void*, void*> >::iterator it = vecSegments.begin(); it != vecSegments.end(); it++)\n        {\n            printf(\"%s, %p-%p\\n\", realname, it->first, it->second);\n        }\n    }\n    return 0;\n}\n\nint main(int argc, const char* argv[], char** envp)\n{\n    if (argc != 2)\n    {\n        printf(\"Usage: %s <path to lib>\\n\", argv[0]);\n        return 1;\n    }\n    realpath(argv[0], progname);\n    void* hDll = dlopen(argv[1], RTLD_LAZY | RTLD_GLOBAL);\n    if (NULL == hDll)\n    {\n        printf(\"Failed to open %s - %s\\n\", argv[1], dlerror());\n        return 1;\n    }\n    int (*return2)() = (int (*)())dlsym(hDll, \"return2\");\n    if (NULL == return2)\n    {\n        printf(\"Failed to locate 'return2' - %s\\n\", dlerror());\n        return 1;\n    }\n\n    if (return2() != 2)\n    {\n        printf(\"Bad value returned from 'return2'\\n\");\n        return 1;\n    }\n    dl_iterate_phdr(dl_iterate, NULL);\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/ImageTests/launchReattachImageLoadCallbacks_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n\n#define EXPORT_SYM extern \"C\"\n\nEXPORT_SYM bool AfterAttach2();\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_LOAD_FAILED,      // 1\n};\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nint main (int argc, char *argv[])\n{\n    void *handle = dlopen(argv[1], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    while(!AfterAttach2())\n    {\n        sleep(1);\n    }\n\n    handle = dlopen(argv[2], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    while(1)\n    {\n        // expected to be stopped by tool.\n        sleep(1);\n    }\n\n    return RES_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/ImageTests/attachReattachImageLoadCallbacks_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_COMMAND_LINE_SIZE 15    // the size for the array of arguments to execv (this value is arbitrary)\n#define EXPORT_SYM extern \"C\"\n\nEXPORT_SYM bool AfterAttach1();\n\nEXPORT_SYM bool AfterAttach2();\n\nstatic int MAX_SIZE = 128; /*maximum line size*/\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_FORK_FAILED,      // 1\n    RES_EXEC_FAILED,      // 2\n    RES_LOAD_FAILED,      // 3\n    RES_RES_INVALID_ARGS  // 4\n};\n\n\nbool AfterAttach1()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\n/*\n * block only the signals in the list: \"signalsListToBlock\"\n */\nvoid BlockSignals(int signalsListToBlock[] , int len, sigset_t * sigmask)\n{\n    sigemptyset(sigmask);\n    int i;\n    for(i=0; i< len; ++i) \n        sigaddset(sigmask, signalsListToBlock[i]);\n    pthread_sigmask(SIG_SETMASK, sigmask, NULL);\n}\n\n\n/*\n    Expected argv arguments:\n    [1] first image to load\n    [2] second image to load\n    [3] pin executable\n    [4] Pin flags (e.g. -slow_asserts)\n        >> zero or more flags possible\n    [5] \"-probe\"\n    [6] \"-t\"\n    [7] tool\n    [8] output file\n    [9] represent if SIGTRAP should be blocked by the application\n    argv[9]=0 - SIGTRAP shouldn't be blocked\n    argv[9]=1 - SIGTRAP should be blocked\n*/\n\nint main(int argc, char** argv)\n{\n    if(argc < 9)\n    {\n        fprintf(stderr, \"No enough arguments\\n\" );\n        fflush(stderr);\n        exit(RES_RES_INVALID_ARGS);\n    }\n    if (argc > MAX_COMMAND_LINE_SIZE){      // added: -pid attachPid -o NULL, omitted: argv[0..2], argv[9]\n        fprintf(stderr, \"Too many arguments\\n\" );\n        fflush(stderr);\n        exit(RES_RES_INVALID_ARGS);\n    }\n    if (strcmp(argv[argc-1], \"1\") == 0) // Need to block the SIGTRAP signal\n    {\n        int sigList[1] = {SIGTRAP};\n        sigset_t sigmask;\n        BlockSignals(sigList, 1, &sigmask);\n    }\n   \n    pid_t parentPid = getpid();\n    pid_t child = fork();\n    if (child < 0)\n    {\n        perror(\"fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    {\n        // inside parent\n        while(!AfterAttach1())\n        {\n            sleep(1);\n        }\n\n        void *handle = dlopen(argv[1], RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n\n        while(!AfterAttach2())\n        {\n            sleep(1);\n        }\n\n        handle = dlopen(argv[2], RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[2], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n\n        while(1)\n        {\n            // expected to be stopped by tool.\n            sleep(1);\n        }\n    }\n\n    if ( child == 0 )\n    {\n        // inside child\n        char attachPid[MAX_SIZE];\n        snprintf(attachPid ,MAX_SIZE , \"%d\", parentPid);\n        char* args[MAX_COMMAND_LINE_SIZE] = {NULL};    // arguments for execv command\n        int args_count = 0;\n        int argv_count = 3;                            // to start from argv[3]...\n        args[args_count++] = argv[argv_count++];       // by convention, first arg is the filename of the executed file (pin)\n        args[args_count++] = (char*)\"-pid\";\n        args[args_count++] = attachPid;\n        while (strcmp(argv[argv_count], \"-t\") != 0){   // additional Pin flags (optional)\n            args[args_count++] = argv[argv_count++];   // including \"-probe\" (mandatory for test)\n        }\n        args[args_count++] = argv[argv_count++];       // \"-t\"\n        args[args_count++] = argv[argv_count++];       // tool\n        args[args_count++] = (char*)\"-o\";\n        args[args_count++] = argv[argv_count++];       // output file\n        args[args_count++] = NULL;                     // end\n        execv(argv[3], (char * const *)args);          // never returns\n        perror(\"execv failed while trying to attach Pin to the application\\n\");\n        exit(RES_EXEC_FAILED);\n    }\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/ImageTests/images_on_attach_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n *  This application should be used with the images_on_attach_tool tool.\n *  See documentation in the tool for the test details.\n */\n\n#include <iostream>\n#include <cstdlib>\n#include <dlfcn.h>\n#include <unistd.h>\n\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\n\nextern \"C\"\n{\nvoid DoRelease(volatile bool* doRelease)\n{\n    // Do nothing\n}\n} // extern \"C\"\n\n\nstatic void WaitForAttach()\n{\n    const unsigned int timeout = 300;\n    unsigned int releaseCounter = 0;\n    volatile bool released = false;\n    while (!released)\n    {\n        if (timeout == releaseCounter)\n        {\n            cerr << \"APP ERROR: Timeout reached and the tool did not release the application.\" << endl;\n            exit(1);\n        }\n        ++releaseCounter;\n        DoRelease(&released);\n        sleep(1);\n    }\n}\n\n\nstatic void LoadAdditionalLibraries(const char* usrlib)\n{\n    const void *libutil = dlopen(\"libutil.so.1\", RTLD_LAZY);\n    if(NULL == libutil)\n    {\n        cerr << \"APP ERROR: Failed to load libutil.so.1\" << endl;\n        exit(1);\n    }\n    const void *usrlibptr = dlopen(usrlib, RTLD_LAZY);\n    if(NULL == usrlibptr)\n    {\n        cerr << \"APP ERROR: Failed to load \" << usrlib << endl;\n        exit(1);\n    }\n}\n\n\n/*\n * Expected arguments:\n *\n * [1] - Shared object to load dynamically\n */\nint main( int argc, char *argv[] )\n{\n    // Check the number of parameters.\n    if (2 != argc)\n    {\n        cerr << \"Usage: \" << argv[0] << \" <shared object to load>\" << endl;\n        return 1;\n    }\n\n    // Wait for the tool to attach to the application.\n    WaitForAttach();\n\n    // Pin is attached, now load two more shared objects.\n    LoadAdditionalLibraries(argv[1]);\n\n    // Done.\n    cout << \"APP: Application completed successfully.\" << endl;\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/include/dlfcn.h": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software and the related documents are Intel copyrighted materials, and your\n * use of them is governed by the express license under which they were provided to\n * you (\"License\"). Unless the License provides otherwise, you may not use, modify,\n * copy, publish, distribute, disclose or transmit this software or the related\n * documents without Intel's prior written permission.\n * \n * This software and the related documents are provided as is, with no express or\n * implied warranties, other than those that are expressly stated in the License.\n * \n * This file incorporates work covered by the following copyright and permission notice:\n */\n\n/*\n * Copyright (C) 2008 The Android Open Source Project\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#ifndef __DLFCN_H__\n#define __DLFCN_H__\n\n#include <sys/cdefs.h>\n\n__BEGIN_DECLS\n\ntypedef struct {\n    const char *dli_fname;  /* Pathname of shared object that\n                               contains address */\n    void       *dli_fbase;  /* Address at which shared object\n                               is loaded */\n    const char *dli_sname;  /* Name of nearest symbol with address\n                               lower than addr */\n    void       *dli_saddr;  /* Exact address of symbol named\n                               in dli_sname */\n} Dl_info;\n\nextern void*        dlopen(const char*  filename, int flag);\nextern int          dlclose(void*  handle);\nextern const char*  dlerror(void);\nextern void*        dlsym(void*  handle, const char*  symbol);\nextern int          dladdr(const void* addr, Dl_info *info);\n\nenum {\n#if defined(__APPLE__)\n  RTLD_LAZY   = 1,\n  RTLD_NOW    = 2,\n  RTLD_LOCAL  = 4,\n  RTLD_GLOBAL = 8,\n  RTLD_NOLOAD = 0x10,\n  RTLD_NODELETE = 0x80,\n  RTLD_FIRST = 0x100,   /* macOS 10.5 and later */\n#else\n# if defined(__LP64__)\n  RTLD_NOW  = 2,\n# else\n  RTLD_NOW  = 0,\n# endif\n  RTLD_LAZY = 1,\n\n  RTLD_LOCAL  = 0,\n# if defined(__LP64__)\n  RTLD_GLOBAL = 0x00100,\n# else\n  RTLD_GLOBAL = 2,\n# endif\n  RTLD_NOLOAD = 4,\n#endif\n};\n\n#if defined(__APPLE__)\n# define RTLD_NEXT       ((void *) -1)   /* Search subsequent objects. */\n# define RTLD_DEFAULT    ((void *) -2)   /* Use default search algorithm. */\n# define RTLD_SELF       ((void *) -3)   /* Search this and subsequent objects (macOS 10.5 and later) */\n# define RTLD_MAIN_ONLY  ((void *) -5)   /* Search main executable only (macOS 10.5 and later) */\n#else\n# if defined (__LP64__)\n#  define RTLD_DEFAULT  ((void*) 0)\n#  define RTLD_NEXT     ((void*) -1L)\n# else\n#  define RTLD_DEFAULT  ((void*) 0xffffffff)\n#  define RTLD_NEXT     ((void*) 0xfffffffe)\n# endif\n#endif\n\n#if defined(__APPLE__) && defined(__NEED_DYLD_PRIVATE)\n#include <mach-o/dyld.h>\n#include <mach-o/dyld_images.h>\n\nstruct dyld_unwind_sections\n{\n\tconst struct mach_header*\t\tmh;\n\tconst void*\t\t\t\t\t\tdwarf_section;\n\tuintptr_t\t\t\t\t\t\tdwarf_section_length;\n\tconst void*\t\t\t\t\t\tcompact_unwind_section;\n\tuintptr_t\t\t\t\t\t\tcompact_unwind_section_length;\n};\n\nextern bool _dyld_find_unwind_sections(void* addr, struct dyld_unwind_sections* info);\nextern void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide));\nextern void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide));\n\n#endif\n\n__END_DECLS\n\n#endif /* __DLFCN_H */\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/include/nsswitch.h": "/*\t$NetBSD: nsswitch.h,v 1.21 2011/07/17 20:54:34 joerg Exp $\t*/\n\n/*-\n * Copyright (c) 1997, 1998, 1999, 2004 The NetBSD Foundation, Inc.\n * All rights reserved.\n *\n * This code is derived from software contributed to The NetBSD Foundation\n * by Luke Mewburn.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef _NSSWITCH_H\n#define _NSSWITCH_H\t1\n\n#include <sys/types.h>\n#include <stdarg.h>\n\n#define\tNSS_MODULE_INTERFACE_VERSION\t0\n\n#ifndef _PATH_NS_CONF\n#define _PATH_NS_CONF\t\"/etc/nsswitch.conf\"\n#endif\n\n#define\tNS_CONTINUE\t0\n#define\tNS_RETURN\t1\n\n/*\n * Layout of:\n *\tuint32_t ns_src.flags\n */\n\t/* nsswitch.conf status codes and nsdispatch(3) return values */\n#define\tNS_SUCCESS\t(1<<0)\t\t/* entry was found */\n#define\tNS_UNAVAIL\t(1<<1)\t\t/* source not responding, or corrupt */\n#define\tNS_NOTFOUND\t(1<<2)\t\t/* source responded 'no such entry' */\n#define\tNS_TRYAGAIN\t(1<<3)\t\t/* source busy, may respond to retrys */\n#define\tNS_STATUSMASK\t0x000000ff\t/* bitmask to get the status flags */\n\n\t/* internal nsdispatch(3) flags; not settable in nsswitch.conf(5)  */\n#define\tNS_FORCEALL\t(1<<8)\t\t/* force all methods to be invoked; */\n\n/*\n * Currently implemented sources.\n */\n#define NSSRC_FILES\t\"files\"\t\t/* local files */\n#define\tNSSRC_DNS\t\"dns\"\t\t/* DNS; IN for hosts, HS for others */\n#define\tNSSRC_NIS\t\"nis\"\t\t/* YP/NIS */\n#define\tNSSRC_COMPAT\t\"compat\"\t/* passwd,group in YP compat mode */\n\n/*\n * Currently implemented databases.\n */\n#define NSDB_HOSTS\t\t\"hosts\"\n#define NSDB_GROUP\t\t\"group\"\n#define NSDB_GROUP_COMPAT\t\"group_compat\"\n#define NSDB_NETGROUP\t\t\"netgroup\"\n#define NSDB_NETWORKS\t\t\"networks\"\n#define NSDB_PASSWD\t\t\"passwd\"\n#define NSDB_PASSWD_COMPAT\t\"passwd_compat\"\n#define NSDB_SHELLS\t\t\"shells\"\n\n/*\n * Suggested databases to implement.\n */\n#define NSDB_ALIASES\t\t\"aliases\"\n#define NSDB_AUTH\t\t\"auth\"\n#define NSDB_AUTOMOUNT\t\t\"automount\"\n#define NSDB_BOOTPARAMS\t\t\"bootparams\"\n#define NSDB_ETHERS\t\t\"ethers\"\n#define NSDB_EXPORTS\t\t\"exports\"\n#define NSDB_NETMASKS\t\t\"netmasks\"\n#define NSDB_PHONES\t\t\"phones\"\n#define NSDB_PRINTCAP\t\t\"printcap\"\n#define NSDB_PROTOCOLS\t\t\"protocols\"\n#define NSDB_REMOTE\t\t\"remote\"\n#define NSDB_RPC\t\t\"rpc\"\n#define NSDB_SENDMAILVARS\t\"sendmailvars\"\n#define NSDB_SERVICES\t\t\"services\"\n#define NSDB_TERMCAP\t\t\"termcap\"\n#define NSDB_TTYS\t\t\"ttys\"\n\n/*\n * ns_dtab `callback' function signature.\n */\ntypedef\tint (*nss_method)(void *, void *, va_list);\n\n/*\n * ns_dtab - `nsswitch dispatch table'\n * Contains an entry for each source and the appropriate function to call.\n */\ntypedef struct {\n\tconst char\t *src;\n\tnss_method\t callback;\n\tvoid\t\t *cb_data;\n} ns_dtab;\n\n/*\n * Macros to help build an ns_dtab[]\n */\n#define NS_FILES_CB(F,C)\t{ NSSRC_FILES,\tF,\t__UNCONST(C) },\n#define NS_COMPAT_CB(F,C)\t{ NSSRC_COMPAT,\tF,\t__UNCONST(C) },\n\n#ifdef HESIOD\n#   define NS_DNS_CB(F,C)\t{ NSSRC_DNS,\tF,\t__UNCONST(C) },\n#else\n#   define NS_DNS_CB(F,C)\n#endif\n\n#ifdef YP\n#   define NS_NIS_CB(F,C)\t{ NSSRC_NIS,\tF,\t__UNCONST(C) },\n#else\n#   define NS_NIS_CB(F,C)\n#endif\n#define\tNS_NULL_CB\t\t{ .src = NULL },\n\n/*\n * ns_src - `nsswitch source'\n * Used by the nsparser routines to store a mapping between a source\n * and its dispatch control flags for a given database.\n */\ntypedef struct {\n\tconst char\t*name;\n\tuint32_t\t flags;\n} ns_src;\n\n\n/*\n * Default sourcelists (if nsswitch.conf is missing, corrupt,\n * or the requested database doesn't have an entry)\n */\nextern const ns_src __nsdefaultsrc[];\nextern const ns_src __nsdefaultcompat[];\nextern const ns_src __nsdefaultcompat_forceall[];\nextern const ns_src __nsdefaultfiles[];\nextern const ns_src __nsdefaultfiles_forceall[];\nextern const ns_src __nsdefaultnis[];\nextern const ns_src __nsdefaultnis_forceall[];\n\n\n/*\n * ns_mtab - `nsswitch method table'\n * An nsswitch module provides a mapping from (database name, method name)\n * tuples to the nss_method and associated callback data.  Effectively,\n * ns_dtab, but used for dynamically loaded modules.\n */\ntypedef struct {\n\tconst char\t*database;\n\tconst char\t*name;\n\tnss_method\t method;\n\tvoid\t\t*mdata;\n} ns_mtab;\n\n/*\n * nss_module_register_fn - module registration function\n *\tcalled at module load\n * nss_module_unregister_fn - module un-registration function\n *\tcalled at module unload\n */\ntypedef\tvoid (*nss_module_unregister_fn)(ns_mtab *, u_int);\ntypedef\tns_mtab *(*nss_module_register_fn)(const char *, u_int *,\n\t\t\t\t\t   nss_module_unregister_fn *);\n\n#ifdef _NS_PRIVATE\n\n/*\n * Private data structures for back-end nsswitch implementation.\n */\n\n/*\n * ns_dbt - `nsswitch database thang'\n * For each database in /etc/nsswitch.conf there is a ns_dbt, with its\n * name and a list of ns_src's containing the source information.\n */\ntypedef struct {\n\tconst char\t*name;\t\t/* name of database */\n\tns_src\t\t*srclist;\t/* list of sources */\n\tu_int\t\t srclistsize;\t/* size of srclist */\n} ns_dbt;\n\n/*\n * ns_mod - `nsswitch module'\n */\ntypedef struct {\n\tconst char\t*name;\t\t/* module name */\n\tvoid\t\t*handle;\t/* handle from dlopen() */\n\tns_mtab\t\t*mtab;\t\t/* method table */\n\tu_int\t\t mtabsize;\t/* size of mtab */\n\t\t\t\t\t/* called to unload module */\n\tnss_module_unregister_fn unregister;\n} ns_mod;\n\n#endif /* _NS_PRIVATE */\n\n\n#include <sys/cdefs.h>\n\n__BEGIN_DECLS\nint\tnsdispatch(void *, const ns_dtab [], const char *,\n\t\t\tconst char *, const ns_src [], ...) __LIBC_ABI_PUBLIC__;\n\n#ifdef _NS_PRIVATE\nint\t\t _nsdbtaddsrc(ns_dbt *, const ns_src *);\nvoid\t\t _nsdbtdump(const ns_dbt *);\nint\t\t _nsdbtput(const ns_dbt *);\nvoid\t\t _nsyyerror(const char *);\nint\t\t _nsyylex(void);\n#endif /* _NS_PRIVATE */\n\n__END_DECLS\n\n#endif /* !_NSSWITCH_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/include/android/dlext.h": "/*\n * Copyright (C) 2014 The Android Open Source Project\n\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef __ANDROID_DLEXT_H__\n#define __ANDROID_DLEXT_H__\n\n#include <stddef.h>\n#include <sys/cdefs.h>\n\n__BEGIN_DECLS\n\n/* bitfield definitions for android_dlextinfo.flags */\nenum {\n  /* When set, the reserved_addr and reserved_size fields must point to an\n   * already-reserved region of address space which will be used to load the\n   * library if it fits. If the reserved region is not large enough, the load\n   * will fail.\n   */\n  ANDROID_DLEXT_RESERVED_ADDRESS      = 0x1,\n\n  /* As DLEXT_RESERVED_ADDRESS, but if the reserved region is not large enough,\n   * the linker will choose an available address instead.\n   */\n  ANDROID_DLEXT_RESERVED_ADDRESS_HINT = 0x2,\n\n  /* When set, write the GNU RELRO section of the mapped library to relro_fd\n   * after relocation has been performed, to allow it to be reused by another\n   * process loading the same library at the same address. This implies\n   * ANDROID_DLEXT_USE_RELRO.\n   */\n  ANDROID_DLEXT_WRITE_RELRO           = 0x4,\n\n  /* When set, compare the GNU RELRO section of the mapped library to relro_fd\n   * after relocation has been performed, and replace any relocated pages that\n   * are identical with a version mapped from the file.\n   */\n  ANDROID_DLEXT_USE_RELRO             = 0x8,\n\n  /* Instruct dlopen to use library_fd instead of opening file by name.\n   * The filename parameter is still used to identify the library.\n   */\n  ANDROID_DLEXT_USE_LIBRARY_FD        = 0x10,\n\n  /* Mask of valid bits */\n  ANDROID_DLEXT_VALID_FLAG_BITS       = ANDROID_DLEXT_RESERVED_ADDRESS |\n                                        ANDROID_DLEXT_RESERVED_ADDRESS_HINT |\n                                        ANDROID_DLEXT_WRITE_RELRO |\n                                        ANDROID_DLEXT_USE_RELRO |\n                                        ANDROID_DLEXT_USE_LIBRARY_FD,\n};\n\ntypedef struct {\n  uint64_t flags;\n  void*   reserved_addr;\n  size_t  reserved_size;\n  int     relro_fd;\n  int     library_fd;\n} android_dlextinfo;\n\nextern void* android_dlopen_ext(const char* filename, int flag, const android_dlextinfo* extinfo);\n\n__END_DECLS\n\n#endif /* __ANDROID_DLEXT_H__ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/include/freebsd/3rd-party/sys/sys/elf_common.h": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software and the related documents are Intel copyrighted materials, and your\n * use of them is governed by the express license under which they were provided to\n * you (\"License\"). Unless the License provides otherwise, you may not use, modify,\n * copy, publish, distribute, disclose or transmit this software or the related\n * documents without Intel's prior written permission.\n * \n * This software and the related documents are provided as is, with no express or\n * implied warranties, other than those that are expressly stated in the License.\n * \n * This file incorporates work covered by the following copyright and permission notice:\n */\n\n/*-\n * SPDX-License-Identifier: BSD-2-Clause-FreeBSD\n *\n * Copyright (c) 2017, 2018 Dell EMC\n * Copyright (c) 2000, 2001, 2008, 2011, David E. O'Brien\n * Copyright (c) 1998 John D. Polstra.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * $FreeBSD$\n */\n\n#ifndef _SYS_ELF_COMMON_H_\n#define\t_SYS_ELF_COMMON_H_ 1\n\n/*\n * ELF definitions that are independent of architecture or word size.\n */\n\n/*\n * Note header.  The \".note\" section contains an array of notes.  Each\n * begins with this header, aligned to a word boundary.  Immediately\n * following the note header is n_namesz bytes of name, padded to the\n * next word boundary.  Then comes n_descsz bytes of descriptor, again\n * padded to a word boundary.  The values of n_namesz and n_descsz do\n * not include the padding.\n */\n\ntypedef struct {\n\tu_int32_t\tn_namesz;\t/* Length of name. */\n\tu_int32_t\tn_descsz;\t/* Length of descriptor. */\n\tu_int32_t\tn_type;\t\t/* Type of this note. */\n} Elf_Note;\ntypedef Elf_Note Elf_Nhdr;\n\n/*\n * Option kinds.\n */\n#define\tODK_NULL\t0\t/* undefined */\n#define\tODK_REGINFO\t1\t/* register usage info */\n#define\tODK_EXCEPTIONS\t2\t/* exception processing info */\n#define\tODK_PAD\t\t3\t/* section padding */\n#define\tODK_HWPATCH\t4\t/* hardware patch applied */\n#define\tODK_FILL\t5\t/* fill value used by the linker */\n#define\tODK_TAGS\t6\t/* reserved space for tools */\n#define\tODK_HWAND\t7\t/* hardware AND patch applied */\n#define\tODK_HWOR\t8\t/* hardware OR patch applied */\n#define\tODK_GP_GROUP\t9\t/* GP group for text/data sections */\n#define\tODK_IDENT\t10\t/* ID information */\n#define\tODK_PAGESIZE\t11\t/* page size information */\n\n/*\n * ODK_EXCEPTIONS info field masks.\n */\n#define\tOEX_FPU_MIN\t0x0000001f\t/* min FPU exception required */\n#define\tOEX_FPU_MAX\t0x00001f00\t/* max FPU exception allowed */\n#define\tOEX_PAGE0\t0x00010000\t/* page zero must be mapped */\n#define\tOEX_SMM\t\t0x00020000\t/* run in sequential memory mode */\n#define\tOEX_PRECISEFP\t0x00040000\t/* run in precise FP exception mode */\n#define\tOEX_DISMISS\t0x00080000\t/* dismiss invalid address traps */\n\n/*\n * ODK_PAD info field masks.\n */\n#define\tOPAD_PREFIX\t0x0001\n#define\tOPAD_POSTFIX\t0x0002\n#define\tOPAD_SYMBOL\t0x0004\n\n/*\n * ODK_HWPATCH info field masks.\n */\n#define\tOHW_R4KEOP\t0x00000001\t/* patch for R4000 branch at end-of-page bug */\n#define\tOHW_R8KPFETCH\t0x00000002\t/* R8000 prefetch bug may occur */\n#define\tOHW_R5KEOP\t0x00000004\t/* patch for R5000 branch at end-of-page bug */\n#define\tOHW_R5KCVTL\t0x00000008\t/* R5000 cvt.[ds].l bug: clean == 1 */\n#define\tOHW_R10KLDL\t0x00000010UL\t/* need patch for R10000 misaligned load */\n\n/*\n * ODK_HWAND/ODK_HWOR info field and hwp_flags[12] masks.\n */\n#define\tOHWA0_R4KEOP_CHECKED\t0x00000001\t/* object checked for R4000 end-of-page bug */\n#define\tOHWA0_R4KEOP_CLEAN\t0x00000002\t/* object verified clean for R4000 end-of-page bug */\n#define\tOHWO0_FIXADE\t\t0x00000001\t/* object requires call to fixade */\n\n/*\n * ODK_IDENT/ODK_GP_GROUP info field masks.\n */\n#define\tOGP_GROUP\t0x0000ffff\t/* GP group number */\n#define\tOGP_SELF\t0x00010000\t/* GP group is self-contained */\n\n/*\n * The header for GNU-style hash sections.\n */\n\ntypedef struct {\n\tu_int32_t\tgh_nbuckets;\t/* Number of hash buckets. */\n\tu_int32_t\tgh_symndx;\t/* First visible symbol in .dynsym. */\n\tu_int32_t\tgh_maskwords;\t/* #maskwords used in bloom filter. */\n\tu_int32_t\tgh_shift2;\t/* Bloom filter shift count. */\n} Elf_GNU_Hash_Header;\n\n/* Indexes into the e_ident array.  Keep synced with\n   http://www.sco.com/developers/gabi/latest/ch4.eheader.html */\n#define\tEI_MAG0\t\t0\t/* Magic number, byte 0. */\n#define\tEI_MAG1\t\t1\t/* Magic number, byte 1. */\n#define\tEI_MAG2\t\t2\t/* Magic number, byte 2. */\n#define\tEI_MAG3\t\t3\t/* Magic number, byte 3. */\n#define\tEI_CLASS\t4\t/* Class of machine. */\n#define\tEI_DATA\t\t5\t/* Data format. */\n#define\tEI_VERSION\t6\t/* ELF format version. */\n#define\tEI_OSABI\t7\t/* Operating system / ABI identification */\n#define\tEI_ABIVERSION\t8\t/* ABI version */\n#define\tOLD_EI_BRAND\t8\t/* Start of architecture identification. */\n#define\tEI_PAD\t\t9\t/* Start of padding (per SVR4 ABI). */\n#define\tEI_NIDENT\t16\t/* Size of e_ident array. */\n\n/* Values for the magic number bytes. */\n#define\tELFMAG0\t\t0x7f\n#define\tELFMAG1\t\t'E'\n#define\tELFMAG2\t\t'L'\n#define\tELFMAG3\t\t'F'\n#define\tELFMAG\t\t\"\\177ELF\"\t/* magic string */\n#define\tSELFMAG\t\t4\t\t/* magic string size */\n\n/* Values for e_ident[EI_VERSION] and e_version. */\n#define\tEV_NONE\t\t0\n#define\tEV_CURRENT\t1\n\n/* Values for e_ident[EI_CLASS]. */\n#define\tELFCLASSNONE\t0\t/* Unknown class. */\n#define\tELFCLASS32\t1\t/* 32-bit architecture. */\n#define\tELFCLASS64\t2\t/* 64-bit architecture. */\n\n/* Values for e_ident[EI_DATA]. */\n#define\tELFDATANONE\t0\t/* Unknown data format. */\n#define\tELFDATA2LSB\t1\t/* 2's complement little-endian. */\n#define\tELFDATA2MSB\t2\t/* 2's complement big-endian. */\n\n/* Values for e_ident[EI_OSABI]. */\n#define\tELFOSABI_NONE\t\t0\t/* UNIX System V ABI */\n#define\tELFOSABI_HPUX\t\t1\t/* HP-UX operating system */\n#define\tELFOSABI_NETBSD\t\t2\t/* NetBSD */\n#define\tELFOSABI_LINUX\t\t3\t/* GNU/Linux */\n#define\tELFOSABI_HURD\t\t4\t/* GNU/Hurd */\n#define\tELFOSABI_86OPEN\t\t5\t/* 86Open common IA32 ABI */\n#define\tELFOSABI_SOLARIS\t6\t/* Solaris */\n#define\tELFOSABI_AIX\t\t7\t/* AIX */\n#define\tELFOSABI_IRIX\t\t8\t/* IRIX */\n#define\tELFOSABI_FREEBSD\t9\t/* FreeBSD */\n#define\tELFOSABI_TRU64\t\t10\t/* TRU64 UNIX */\n#define\tELFOSABI_MODESTO\t11\t/* Novell Modesto */\n#define\tELFOSABI_OPENBSD\t12\t/* OpenBSD */\n#define\tELFOSABI_OPENVMS\t13\t/* Open VMS */\n#define\tELFOSABI_NSK\t\t14\t/* HP Non-Stop Kernel */\n#define\tELFOSABI_AROS\t\t15\t/* Amiga Research OS */\n#define\tELFOSABI_FENIXOS\t16\t/* FenixOS */\n#define\tELFOSABI_CLOUDABI\t17\t/* Nuxi CloudABI */\n#define\tELFOSABI_ARM_AEABI\t64\t/* ARM EABI */\n#define\tELFOSABI_ARM\t\t97\t/* ARM */\n#define\tELFOSABI_STANDALONE\t255\t/* Standalone (embedded) application */\n\n#define\tELFOSABI_SYSV\t\tELFOSABI_NONE\t/* symbol used in old spec */\n#define\tELFOSABI_MONTEREY\tELFOSABI_AIX\t/* Monterey */\n#define\tELFOSABI_GNU\t\tELFOSABI_LINUX\n\n/* e_ident */\n#define\tIS_ELF(ehdr)\t((ehdr).e_ident[EI_MAG0] == ELFMAG0 && \\\n\t\t\t (ehdr).e_ident[EI_MAG1] == ELFMAG1 && \\\n\t\t\t (ehdr).e_ident[EI_MAG2] == ELFMAG2 && \\\n\t\t\t (ehdr).e_ident[EI_MAG3] == ELFMAG3)\n\n/* Values for e_type. */\n#define\tET_NONE\t\t0\t/* Unknown type. */\n#define\tET_REL\t\t1\t/* Relocatable. */\n#define\tET_EXEC\t\t2\t/* Executable. */\n#define\tET_DYN\t\t3\t/* Shared object. */\n#define\tET_CORE\t\t4\t/* Core file. */\n#define\tET_LOOS\t\t0xfe00\t/* First operating system specific. */\n#define\tET_HIOS\t\t0xfeff\t/* Last operating system-specific. */\n#define\tET_LOPROC\t0xff00\t/* First processor-specific. */\n#define\tET_HIPROC\t0xffff\t/* Last processor-specific. */\n\n/* Values for e_machine. */\n#define\tEM_NONE\t\t0\t/* Unknown machine. */\n#define\tEM_M32\t\t1\t/* AT&T WE32100. */\n#define\tEM_SPARC\t2\t/* Sun SPARC. */\n#define\tEM_386\t\t3\t/* Intel i386. */\n#define\tEM_68K\t\t4\t/* Motorola 68000. */\n#define\tEM_88K\t\t5\t/* Motorola 88000. */\n#define\tEM_IAMCU\t6\t/* Intel MCU. */\n#define\tEM_860\t\t7\t/* Intel i860. */\n#define\tEM_MIPS\t\t8\t/* MIPS R3000 Big-Endian only. */\n#define\tEM_S370\t\t9\t/* IBM System/370. */\n#define\tEM_MIPS_RS3_LE\t10\t/* MIPS R3000 Little-Endian. */\n#define\tEM_PARISC\t15\t/* HP PA-RISC. */\n#define\tEM_VPP500\t17\t/* Fujitsu VPP500. */\n#define\tEM_SPARC32PLUS\t18\t/* SPARC v8plus. */\n#define\tEM_960\t\t19\t/* Intel 80960. */\n#define\tEM_PPC\t\t20\t/* PowerPC 32-bit. */\n#define\tEM_PPC64\t21\t/* PowerPC 64-bit. */\n#define\tEM_S390\t\t22\t/* IBM System/390. */\n#define\tEM_V800\t\t36\t/* NEC V800. */\n#define\tEM_FR20\t\t37\t/* Fujitsu FR20. */\n#define\tEM_RH32\t\t38\t/* TRW RH-32. */\n#define\tEM_RCE\t\t39\t/* Motorola RCE. */\n#define\tEM_ARM\t\t40\t/* ARM. */\n#define\tEM_SH\t\t42\t/* Hitachi SH. */\n#define\tEM_SPARCV9\t43\t/* SPARC v9 64-bit. */\n#define\tEM_TRICORE\t44\t/* Siemens TriCore embedded processor. */\n#define\tEM_ARC\t\t45\t/* Argonaut RISC Core. */\n#define\tEM_H8_300\t46\t/* Hitachi H8/300. */\n#define\tEM_H8_300H\t47\t/* Hitachi H8/300H. */\n#define\tEM_H8S\t\t48\t/* Hitachi H8S. */\n#define\tEM_H8_500\t49\t/* Hitachi H8/500. */\n#define\tEM_IA_64\t50\t/* Intel IA-64 Processor. */\n#define\tEM_MIPS_X\t51\t/* Stanford MIPS-X. */\n#define\tEM_COLDFIRE\t52\t/* Motorola ColdFire. */\n#define\tEM_68HC12\t53\t/* Motorola M68HC12. */\n#define\tEM_MMA\t\t54\t/* Fujitsu MMA. */\n#define\tEM_PCP\t\t55\t/* Siemens PCP. */\n#define\tEM_NCPU\t\t56\t/* Sony nCPU. */\n#define\tEM_NDR1\t\t57\t/* Denso NDR1 microprocessor. */\n#define\tEM_STARCORE\t58\t/* Motorola Star*Core processor. */\n#define\tEM_ME16\t\t59\t/* Toyota ME16 processor. */\n#define\tEM_ST100\t60\t/* STMicroelectronics ST100 processor. */\n#define\tEM_TINYJ\t61\t/* Advanced Logic Corp. TinyJ processor. */\n#define\tEM_X86_64\t62\t/* Advanced Micro Devices x86-64 */\n#define\tEM_AMD64\tEM_X86_64\t/* Advanced Micro Devices x86-64 (compat) */\n#define\tEM_PDSP\t\t63\t/* Sony DSP Processor. */\n#define\tEM_FX66\t\t66\t/* Siemens FX66 microcontroller. */\n#define\tEM_ST9PLUS\t67\t/* STMicroelectronics ST9+ 8/16\n\t\t\t\t   microcontroller. */\n#define\tEM_ST7\t\t68\t/* STmicroelectronics ST7 8-bit\n\t\t\t\t   microcontroller. */\n#define\tEM_68HC16\t69\t/* Motorola MC68HC16 microcontroller. */\n#define\tEM_68HC11\t70\t/* Motorola MC68HC11 microcontroller. */\n#define\tEM_68HC08\t71\t/* Motorola MC68HC08 microcontroller. */\n#define\tEM_68HC05\t72\t/* Motorola MC68HC05 microcontroller. */\n#define\tEM_SVX\t\t73\t/* Silicon Graphics SVx. */\n#define\tEM_ST19\t\t74\t/* STMicroelectronics ST19 8-bit mc. */\n#define\tEM_VAX\t\t75\t/* Digital VAX. */\n#define\tEM_CRIS\t\t76\t/* Axis Communications 32-bit embedded\n\t\t\t\t   processor. */\n#define\tEM_JAVELIN\t77\t/* Infineon Technologies 32-bit embedded\n\t\t\t\t   processor. */\n#define\tEM_FIREPATH\t78\t/* Element 14 64-bit DSP Processor. */\n#define\tEM_ZSP\t\t79\t/* LSI Logic 16-bit DSP Processor. */\n#define\tEM_MMIX\t\t80\t/* Donald Knuth's educational 64-bit proc. */\n#define\tEM_HUANY\t81\t/* Harvard University machine-independent\n\t\t\t\t   object files. */\n#define\tEM_PRISM\t82\t/* SiTera Prism. */\n#define\tEM_AVR\t\t83\t/* Atmel AVR 8-bit microcontroller. */\n#define\tEM_FR30\t\t84\t/* Fujitsu FR30. */\n#define\tEM_D10V\t\t85\t/* Mitsubishi D10V. */\n#define\tEM_D30V\t\t86\t/* Mitsubishi D30V. */\n#define\tEM_V850\t\t87\t/* NEC v850. */\n#define\tEM_M32R\t\t88\t/* Mitsubishi M32R. */\n#define\tEM_MN10300\t89\t/* Matsushita MN10300. */\n#define\tEM_MN10200\t90\t/* Matsushita MN10200. */\n#define\tEM_PJ\t\t91\t/* picoJava. */\n#define\tEM_OPENRISC\t92\t/* OpenRISC 32-bit embedded processor. */\n#define\tEM_ARC_A5\t93\t/* ARC Cores Tangent-A5. */\n#define\tEM_XTENSA\t94\t/* Tensilica Xtensa Architecture. */\n#define\tEM_VIDEOCORE\t95\t/* Alphamosaic VideoCore processor. */\n#define\tEM_TMM_GPP\t96\t/* Thompson Multimedia General Purpose\n\t\t\t\t   Processor. */\n#define\tEM_NS32K\t97\t/* National Semiconductor 32000 series. */\n#define\tEM_TPC\t\t98\t/* Tenor Network TPC processor. */\n#define\tEM_SNP1K\t99\t/* Trebia SNP 1000 processor. */\n#define\tEM_ST200\t100\t/* STMicroelectronics ST200 microcontroller. */\n#define\tEM_IP2K\t\t101\t/* Ubicom IP2xxx microcontroller family. */\n#define\tEM_MAX\t\t102\t/* MAX Processor. */\n#define\tEM_CR\t\t103\t/* National Semiconductor CompactRISC\n\t\t\t\t   microprocessor. */\n#define\tEM_F2MC16\t104\t/* Fujitsu F2MC16. */\n#define\tEM_MSP430\t105\t/* Texas Instruments embedded microcontroller\n\t\t\t\t   msp430. */\n#define\tEM_BLACKFIN\t106\t/* Analog Devices Blackfin (DSP) processor. */\n#define\tEM_SE_C33\t107\t/* S1C33 Family of Seiko Epson processors. */\n#define\tEM_SEP\t\t108\t/* Sharp embedded microprocessor. */\n#define\tEM_ARCA\t\t109\t/* Arca RISC Microprocessor. */\n#define\tEM_UNICORE\t110\t/* Microprocessor series from PKU-Unity Ltd.\n\t\t\t\t   and MPRC of Peking University */\n#define\tEM_AARCH64\t183\t/* AArch64 (64-bit ARM) */\n#define\tEM_RISCV\t243\t/* RISC-V */\n\n/* Non-standard or deprecated. */\n#define\tEM_486\t\t6\t/* Intel i486. */\n#define\tEM_MIPS_RS4_BE\t10\t/* MIPS R4000 Big-Endian */\n#define\tEM_ALPHA_STD\t41\t/* Digital Alpha (standard value). */\n#define\tEM_ALPHA\t0x9026\t/* Alpha (written in the absence of an ABI) */\n\n/**\n * e_flags\n */\n#define\tEF_ARM_RELEXEC\t0x1\n#define\tEF_ARM_HASENTRY\t0x2\n#define\tEF_ARM_SYMSARESORTED\t0x4\n#define\tEF_ARM_DYNSYMSUSESEGIDX\t0x8\n#define\tEF_ARM_MAPSYMSFIRST\t0x10\n#define\tEF_ARM_LE8\t\t0x00400000\n#define\tEF_ARM_BE8\t\t0x00800000\n#define\tEF_ARM_EABIMASK\t\t0xFF000000\n#define\tEF_ARM_EABI_UNKNOWN\t0x00000000\n#define\tEF_ARM_EABI_VER1\t0x01000000\n#define\tEF_ARM_EABI_VER2\t0x02000000\n#define\tEF_ARM_EABI_VER3\t0x03000000\n#define\tEF_ARM_EABI_VER4\t0x04000000\n#define\tEF_ARM_EABI_VER5\t0x05000000\n#define\tEF_ARM_INTERWORK\t0x00000004\n#define\tEF_ARM_APCS_26\t\t0x00000008\n#define\tEF_ARM_APCS_FLOAT\t0x00000010\n#define\tEF_ARM_PIC\t\t0x00000020\n#define\tEF_ARM_ALIGN8\t\t0x00000040\n#define\tEF_ARM_NEW_ABI\t\t0x00000080\n#define\tEF_ARM_OLD_ABI\t\t0x00000100\n#define\tEF_ARM_ABI_FLOAT_SOFT\t0x00000200\n#define\tEF_ARM_SOFT_FLOAT\tEF_ARM_ABI_FLOAT_SOFT /* Pre-V5 ABI name */\n#define\tEF_ARM_ABI_FLOAT_HARD\t0x00000400\n#define\tEF_ARM_VFP_FLOAT\tEF_ARM_ABI_FLOAT_HARD /* Pre-V5 ABI name */\n#define\tEF_ARM_MAVERICK_FLOAT\t0x00000800\n\n#define\tEF_MIPS_NOREORDER\t0x00000001\n#define\tEF_MIPS_PIC\t\t0x00000002\t/* Contains PIC code */\n#define\tEF_MIPS_CPIC\t\t0x00000004\t/* STD PIC calling sequence */\n#define\tEF_MIPS_UCODE\t\t0x00000010\n#define\tEF_MIPS_ABI2\t\t0x00000020\t/* N32 */\n#define\tEF_MIPS_OPTIONS_FIRST\t0x00000080\n#define\tEF_MIPS_ABI\t\t0x0000F000\n#define\tEF_MIPS_ABI_O32\t\t0x00001000\n#define\tEF_MIPS_ABI_O64\t\t0x00002000\n#define\tEF_MIPS_ABI_EABI32\t0x00003000\n#define\tEF_MIPS_ABI_EABI64\t0x00004000\n#define\tEF_MIPS_ARCH_ASE\t0x0F000000\t/* Architectural extensions */\n#define\tEF_MIPS_ARCH_ASE_MDMX\t0x08000000\t/* MDMX multimedia extension */\n#define\tEF_MIPS_ARCH_ASE_M16\t0x04000000\t/* MIPS-16 ISA extensions */\n#define\tEF_MIPS_ARCH\t\t0xF0000000\t/* Architecture field */\n#define\tEF_MIPS_ARCH_1\t\t0x00000000\t/* -mips1 code */\n#define\tEF_MIPS_ARCH_2\t\t0x10000000\t/* -mips2 code */\n#define\tEF_MIPS_ARCH_3\t\t0x20000000\t/* -mips3 code */\n#define\tEF_MIPS_ARCH_4\t\t0x30000000\t/* -mips4 code */\n#define\tEF_MIPS_ARCH_5\t\t0x40000000\t/* -mips5 code */\n#define\tEF_MIPS_ARCH_32\t\t0x50000000\t/* -mips32 code */\n#define\tEF_MIPS_ARCH_64\t\t0x60000000\t/* -mips64 code */\n#define\tEF_MIPS_ARCH_32R2\t0x70000000\t/* -mips32r2 code */\n#define\tEF_MIPS_ARCH_64R2\t0x80000000\t/* -mips64r2 code */\n\n#define\tEF_PPC_EMB\t\t0x80000000\n#define\tEF_PPC_RELOCATABLE\t0x00010000\n#define\tEF_PPC_RELOCATABLE_LIB\t0x00008000\n\n#define\tEF_RISCV_RVC\t\t0x00000001\n#define\tEF_RISCV_FLOAT_ABI_MASK\t0x00000006\n#define\tEF_RISCV_FLOAT_ABI_SOFT\t0x00000000\n#define\tEF_RISCV_FLOAT_ABI_SINGLE 0x000002\n#define\tEF_RISCV_FLOAT_ABI_DOUBLE 0x000004\n#define\tEF_RISCV_FLOAT_ABI_QUAD\t0x00000006\n#define\tEF_RISCV_RVE\t\t0x00000008\n#define\tEF_RISCV_TSO\t\t0x00000010\n\n#define\tEF_SPARC_EXT_MASK\t0x00ffff00\n#define\tEF_SPARC_32PLUS\t\t0x00000100\n#define\tEF_SPARC_SUN_US1\t0x00000200\n#define\tEF_SPARC_HAL_R1\t\t0x00000200\n#define\tEF_SPARC_SUN_US3\t0x00000800\n\n#define\tEF_SPARCV9_MM\t\t0x00000003\n#define\tEF_SPARCV9_TSO\t\t0x00000000\n#define\tEF_SPARCV9_PSO\t\t0x00000001\n#define\tEF_SPARCV9_RMO\t\t0x00000002\n\n/* Special section indexes. */\n#define\tSHN_UNDEF\t     0\t\t/* Undefined, missing, irrelevant. */\n#define\tSHN_LORESERVE\t0xff00\t\t/* First of reserved range. */\n#define\tSHN_LOPROC\t0xff00\t\t/* First processor-specific. */\n#define\tSHN_HIPROC\t0xff1f\t\t/* Last processor-specific. */\n#define\tSHN_LOOS\t0xff20\t\t/* First operating system-specific. */\n#define\tSHN_FBSD_CACHED\tSHN_LOOS\t/* Transient, for sys/kern/link_elf_obj\n\t\t\t\t\t   linker only: Cached global in local\n\t\t\t\t\t   symtab. */\n#define\tSHN_HIOS\t0xff3f\t\t/* Last operating system-specific. */\n#define\tSHN_ABS\t\t0xfff1\t\t/* Absolute values. */\n#define\tSHN_COMMON\t0xfff2\t\t/* Common data. */\n#define\tSHN_XINDEX\t0xffff\t\t/* Escape -- index stored elsewhere. */\n#define\tSHN_HIRESERVE\t0xffff\t\t/* Last of reserved range. */\n\n/* sh_type */\n#define\tSHT_NULL\t\t0\t/* inactive */\n#define\tSHT_PROGBITS\t\t1\t/* program defined information */\n#define\tSHT_SYMTAB\t\t2\t/* symbol table section */\n#define\tSHT_STRTAB\t\t3\t/* string table section */\n#define\tSHT_RELA\t\t4\t/* relocation section with addends */\n#define\tSHT_HASH\t\t5\t/* symbol hash table section */\n#define\tSHT_DYNAMIC\t\t6\t/* dynamic section */\n#define\tSHT_NOTE\t\t7\t/* note section */\n#define\tSHT_NOBITS\t\t8\t/* no space section */\n#define\tSHT_REL\t\t\t9\t/* relocation section - no addends */\n#define\tSHT_SHLIB\t\t10\t/* reserved - purpose unknown */\n#define\tSHT_DYNSYM\t\t11\t/* dynamic symbol table section */\n#define\tSHT_INIT_ARRAY\t\t14\t/* Initialization function pointers. */\n#define\tSHT_FINI_ARRAY\t\t15\t/* Termination function pointers. */\n#define\tSHT_PREINIT_ARRAY\t16\t/* Pre-initialization function ptrs. */\n#define\tSHT_GROUP\t\t17\t/* Section group. */\n#define\tSHT_SYMTAB_SHNDX\t18\t/* Section indexes (see SHN_XINDEX). */\n#define\tSHT_LOOS\t\t0x60000000\t/* First of OS specific semantics */\n#define\tSHT_LOSUNW\t\t0x6ffffff4\n#define\tSHT_SUNW_dof\t\t0x6ffffff4\n#define\tSHT_SUNW_cap\t\t0x6ffffff5\n#define\tSHT_GNU_ATTRIBUTES\t0x6ffffff5\n#define\tSHT_SUNW_SIGNATURE\t0x6ffffff6\n#define\tSHT_GNU_HASH\t\t0x6ffffff6\n#define\tSHT_GNU_LIBLIST\t\t0x6ffffff7\n#define\tSHT_SUNW_ANNOTATE\t0x6ffffff7\n#define\tSHT_SUNW_DEBUGSTR\t0x6ffffff8\n#define\tSHT_SUNW_DEBUG\t\t0x6ffffff9\n#define\tSHT_SUNW_move\t\t0x6ffffffa\n#define\tSHT_SUNW_COMDAT\t\t0x6ffffffb\n#define\tSHT_SUNW_syminfo\t0x6ffffffc\n#define\tSHT_SUNW_verdef\t\t0x6ffffffd\n#define\tSHT_GNU_verdef\t\t0x6ffffffd\t/* Symbol versions provided */\n#define\tSHT_SUNW_verneed\t0x6ffffffe\n#define\tSHT_GNU_verneed\t\t0x6ffffffe\t/* Symbol versions required */\n#define\tSHT_SUNW_versym\t\t0x6fffffff\n#define\tSHT_GNU_versym\t\t0x6fffffff\t/* Symbol version table */\n#define\tSHT_HISUNW\t\t0x6fffffff\n#define\tSHT_HIOS\t\t0x6fffffff\t/* Last of OS specific semantics */\n#define\tSHT_LOPROC\t\t0x70000000\t/* reserved range for processor */\n#define\tSHT_X86_64_UNWIND\t0x70000001\t/* unwind information */\n#define\tSHT_AMD64_UNWIND\tSHT_X86_64_UNWIND \n\n#define\tSHT_ARM_EXIDX\t\t0x70000001\t/* Exception index table. */\n#define\tSHT_ARM_PREEMPTMAP\t0x70000002\t/* BPABI DLL dynamic linking \n\t\t\t\t\t\t   pre-emption map. */\n#define\tSHT_ARM_ATTRIBUTES\t0x70000003\t/* Object file compatibility \n\t\t\t\t\t\t   attributes. */\n#define\tSHT_ARM_DEBUGOVERLAY\t0x70000004\t/* See DBGOVL for details. */\n#define\tSHT_ARM_OVERLAYSECTION\t0x70000005\t/* See DBGOVL for details. */\n#define\tSHT_MIPS_LIBLIST\t0x70000000\n#define\tSHT_MIPS_MSYM\t\t0x70000001\n#define\tSHT_MIPS_CONFLICT\t0x70000002\n#define\tSHT_MIPS_GPTAB\t\t0x70000003\n#define\tSHT_MIPS_UCODE\t\t0x70000004\n#define\tSHT_MIPS_DEBUG\t\t0x70000005\n#define\tSHT_MIPS_REGINFO\t0x70000006\n#define\tSHT_MIPS_PACKAGE\t0x70000007\n#define\tSHT_MIPS_PACKSYM\t0x70000008\n#define\tSHT_MIPS_RELD\t\t0x70000009\n#define\tSHT_MIPS_IFACE\t\t0x7000000b\n#define\tSHT_MIPS_CONTENT\t0x7000000c\n#define\tSHT_MIPS_OPTIONS\t0x7000000d\n#define\tSHT_MIPS_DELTASYM\t0x7000001b\n#define\tSHT_MIPS_DELTAINST\t0x7000001c\n#define\tSHT_MIPS_DELTACLASS\t0x7000001d\n#define\tSHT_MIPS_DWARF\t\t0x7000001e\t/* MIPS gcc uses MIPS_DWARF */\n#define\tSHT_MIPS_DELTADECL\t0x7000001f\n#define\tSHT_MIPS_SYMBOL_LIB\t0x70000020\n#define\tSHT_MIPS_EVENTS\t\t0x70000021\n#define\tSHT_MIPS_TRANSLATE\t0x70000022\n#define\tSHT_MIPS_PIXIE\t\t0x70000023\n#define\tSHT_MIPS_XLATE\t\t0x70000024\n#define\tSHT_MIPS_XLATE_DEBUG\t0x70000025\n#define\tSHT_MIPS_WHIRL\t\t0x70000026\n#define\tSHT_MIPS_EH_REGION\t0x70000027\n#define\tSHT_MIPS_XLATE_OLD\t0x70000028\n#define\tSHT_MIPS_PDR_EXCEPTION\t0x70000029\n#define\tSHT_MIPS_ABIFLAGS\t0x7000002a\n\n#define\tSHT_SPARC_GOTDATA\t0x70000000\n\n#define\tSHTORDERED\n#define\tSHT_HIPROC\t\t0x7fffffff\t/* specific section header types */\n#define\tSHT_LOUSER\t\t0x80000000\t/* reserved range for application */\n#define\tSHT_HIUSER\t\t0xffffffff\t/* specific indexes */\n\n/* Flags for sh_flags. */\n#define\tSHF_WRITE\t\t0x1\t/* Section contains writable data. */\n#define\tSHF_ALLOC\t\t0x2\t/* Section occupies memory. */\n#define\tSHF_EXECINSTR\t\t0x4\t/* Section contains instructions. */\n#define\tSHF_MERGE\t\t0x10\t/* Section may be merged. */\n#define\tSHF_STRINGS\t\t0x20\t/* Section contains strings. */\n#define\tSHF_INFO_LINK\t\t0x40\t/* sh_info holds section index. */\n#define\tSHF_LINK_ORDER\t\t0x80\t/* Special ordering requirements. */\n#define\tSHF_OS_NONCONFORMING\t0x100\t/* OS-specific processing required. */\n#define\tSHF_GROUP\t\t0x200\t/* Member of section group. */\n#define\tSHF_TLS\t\t\t0x400\t/* Section contains TLS data. */\n#define\tSHF_COMPRESSED\t\t0x800\t/* Section contains compressed data. */\n#define\tSHF_MASKOS\t0x0ff00000\t/* OS-specific semantics. */\n#define\tSHF_MASKPROC\t0xf0000000\t/* Processor-specific semantics. */\n\n/* Flags for section groups. */\n#define\tGRP_COMDAT\t0x1\t/* COMDAT semantics. */\n\n/*\n * Flags / mask for .gnu.versym sections.\n */\n#define\tVERSYM_VERSION\t0x7fff\n#define\tVERSYM_HIDDEN\t0x8000\n\n/* Values for p_type. */\n#define\tPT_NULL\t\t0\t/* Unused entry. */\n#define\tPT_LOAD\t\t1\t/* Loadable segment. */\n#define\tPT_DYNAMIC\t2\t/* Dynamic linking information segment. */\n#define\tPT_INTERP\t3\t/* Pathname of interpreter. */\n#define\tPT_NOTE\t\t4\t/* Auxiliary information. */\n#define\tPT_SHLIB\t5\t/* Reserved (not used). */\n#define\tPT_PHDR\t\t6\t/* Location of program header itself. */\n#define\tPT_TLS\t\t7\t/* Thread local storage segment */\n#define\tPT_LOOS\t\t0x60000000\t/* First OS-specific. */\n#define\tPT_SUNW_UNWIND\t0x6464e550\t/* amd64 UNWIND program header */\n#define\tPT_GNU_EH_FRAME\t0x6474e550\n#define\tPT_GNU_STACK\t0x6474e551\n#define\tPT_GNU_RELRO\t0x6474e552\n#define\tPT_DUMP_DELTA\t0x6fb5d000\t/* va->pa map for kernel dumps\n\t\t\t\t\t   (currently arm). */\n#define\tPT_LOSUNW\t0x6ffffffa\n#define\tPT_SUNWBSS\t0x6ffffffa\t/* Sun Specific segment */\n#define\tPT_SUNWSTACK\t0x6ffffffb\t/* describes the stack segment */\n#define\tPT_SUNWDTRACE\t0x6ffffffc\t/* private */\n#define\tPT_SUNWCAP\t0x6ffffffd\t/* hard/soft capabilities segment */\n#define\tPT_HISUNW\t0x6fffffff\n#define\tPT_HIOS\t\t0x6fffffff\t/* Last OS-specific. */\n#define\tPT_LOPROC\t0x70000000\t/* First processor-specific type. */\n#define\tPT_ARM_ARCHEXT\t0x70000000\t/* ARM arch compat information. */\n#define\tPT_ARM_EXIDX\t0x70000001\t/* ARM exception unwind tables. */\n#define\tPT_HIPROC\t0x7fffffff\t/* Last processor-specific type. */\n\n/* Values for p_flags. */\n#define\tPF_X\t\t0x1\t\t/* Executable. */\n#define\tPF_W\t\t0x2\t\t/* Writable. */\n#define\tPF_R\t\t0x4\t\t/* Readable. */\n#define\tPF_MASKOS\t0x0ff00000\t/* Operating system-specific. */\n#define\tPF_MASKPROC\t0xf0000000\t/* Processor-specific. */\n\n/* Extended program header index. */\n#define\tPN_XNUM\t\t0xffff\n\n/* Values for d_tag. */\n#define\tDT_NULL\t\t0\t/* Terminating entry. */\n#define\tDT_NEEDED\t1\t/* String table offset of a needed shared\n\t\t\t\t   library. */\n#define\tDT_PLTRELSZ\t2\t/* Total size in bytes of PLT relocations. */\n#define\tDT_PLTGOT\t3\t/* Processor-dependent address. */\n#define\tDT_HASH\t\t4\t/* Address of symbol hash table. */\n#define\tDT_STRTAB\t5\t/* Address of string table. */\n#define\tDT_SYMTAB\t6\t/* Address of symbol table. */\n#define\tDT_RELA\t\t7\t/* Address of ElfNN_Rela relocations. */\n#define\tDT_RELASZ\t8\t/* Total size of ElfNN_Rela relocations. */\n#define\tDT_RELAENT\t9\t/* Size of each ElfNN_Rela relocation entry. */\n#define\tDT_STRSZ\t10\t/* Size of string table. */\n#define\tDT_SYMENT\t11\t/* Size of each symbol table entry. */\n#define\tDT_INIT\t\t12\t/* Address of initialization function. */\n#define\tDT_FINI\t\t13\t/* Address of finalization function. */\n#define\tDT_SONAME\t14\t/* String table offset of shared object\n\t\t\t\t   name. */\n#define\tDT_RPATH\t15\t/* String table offset of library path. [sup] */\n#define\tDT_SYMBOLIC\t16\t/* Indicates \"symbolic\" linking. [sup] */\n#define\tDT_REL\t\t17\t/* Address of ElfNN_Rel relocations. */\n#define\tDT_RELSZ\t18\t/* Total size of ElfNN_Rel relocations. */\n#define\tDT_RELENT\t19\t/* Size of each ElfNN_Rel relocation. */\n#define\tDT_PLTREL\t20\t/* Type of relocation used for PLT. */\n#define\tDT_DEBUG\t21\t/* Reserved (not used). */\n#define\tDT_TEXTREL\t22\t/* Indicates there may be relocations in\n\t\t\t\t   non-writable segments. [sup] */\n#define\tDT_JMPREL\t23\t/* Address of PLT relocations. */\n#define\tDT_BIND_NOW\t24\t/* [sup] */\n#define\tDT_INIT_ARRAY\t25\t/* Address of the array of pointers to\n\t\t\t\t   initialization functions */\n#define\tDT_FINI_ARRAY\t26\t/* Address of the array of pointers to\n\t\t\t\t   termination functions */\n#define\tDT_INIT_ARRAYSZ\t27\t/* Size in bytes of the array of\n\t\t\t\t   initialization functions. */\n#define\tDT_FINI_ARRAYSZ\t28\t/* Size in bytes of the array of\n\t\t\t\t   termination functions. */\n#define\tDT_RUNPATH\t29\t/* String table offset of a null-terminated\n\t\t\t\t   library search path string. */\n#define\tDT_FLAGS\t30\t/* Object specific flag values. */\n#define\tDT_ENCODING\t32\t/* Values greater than or equal to DT_ENCODING\n\t\t\t\t   and less than DT_LOOS follow the rules for\n\t\t\t\t   the interpretation of the d_un union\n\t\t\t\t   as follows: even == 'd_ptr', odd == 'd_val'\n\t\t\t\t   or none */\n#define\tDT_PREINIT_ARRAY 32\t/* Address of the array of pointers to\n\t\t\t\t   pre-initialization functions. */\n#define\tDT_PREINIT_ARRAYSZ 33\t/* Size in bytes of the array of\n\t\t\t\t   pre-initialization functions. */\n#define\tDT_MAXPOSTAGS\t34\t/* number of positive tags */\n#define\tDT_LOOS\t\t0x6000000d\t/* First OS-specific */\n#define\tDT_SUNW_AUXILIARY\t0x6000000d\t/* symbol auxiliary name */\n#define\tDT_SUNW_RTLDINF\t\t0x6000000e\t/* ld.so.1 info (private) */\n#define\tDT_SUNW_FILTER\t\t0x6000000f\t/* symbol filter name */\n#define\tDT_SUNW_CAP\t\t0x60000010\t/* hardware/software */\n#define\tDT_SUNW_ASLR\t\t0x60000023\t/* ASLR control */\n#define\tDT_HIOS\t\t0x6ffff000\t/* Last OS-specific */\n\n/*\n * DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the\n * Dyn.d_un.d_val field of the Elf*_Dyn structure.\n */\n#define\tDT_VALRNGLO\t0x6ffffd00\n#define\tDT_GNU_PRELINKED\t0x6ffffdf5 /* prelinking timestamp */\n#define\tDT_GNU_CONFLICTSZ\t0x6ffffdf6 /* size of conflict section */\n#define\tDT_GNU_LIBLISTSZ\t0x6ffffdf7 /* size of library list */\n#define\tDT_CHECKSUM\t0x6ffffdf8\t/* elf checksum */\n#define\tDT_PLTPADSZ\t0x6ffffdf9\t/* pltpadding size */\n#define\tDT_MOVEENT\t0x6ffffdfa\t/* move table entry size */\n#define\tDT_MOVESZ\t0x6ffffdfb\t/* move table size */\n#define\tDT_FEATURE\t0x6ffffdfc\t/* feature holder */\n#define\tDT_FEATURE_1\tDT_FEATURE\n#define\tDT_POSFLAG_1\t0x6ffffdfd\t/* flags for DT_* entries, effecting */\n\t\t\t\t\t/*\tthe following DT_* entry. */\n\t\t\t\t\t/*\tSee DF_P1_* definitions */\n#define\tDT_SYMINSZ\t0x6ffffdfe\t/* syminfo table size (in bytes) */\n#define\tDT_SYMINENT\t0x6ffffdff\t/* syminfo entry size (in bytes) */\n#define\tDT_VALRNGHI\t0x6ffffdff\n\n/*\n * DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the\n * Dyn.d_un.d_ptr field of the Elf*_Dyn structure.\n *\n * If any adjustment is made to the ELF object after it has been\n * built, these entries will need to be adjusted.\n */\n#define\tDT_ADDRRNGLO\t0x6ffffe00\n#define\tDT_GNU_HASH\t0x6ffffef5\t/* GNU-style hash table */\n#define\tDT_TLSDESC_PLT\t0x6ffffef6\t/* loc. of PLT for tlsdesc resolver */\n#define\tDT_TLSDESC_GOT\t0x6ffffef7\t/* loc. of GOT for tlsdesc resolver */\n#define\tDT_GNU_CONFLICT\t0x6ffffef8\t/* address of conflict section */\n#define\tDT_GNU_LIBLIST\t0x6ffffef9\t/* address of library list */\n#define\tDT_CONFIG\t0x6ffffefa\t/* configuration information */\n#define\tDT_DEPAUDIT\t0x6ffffefb\t/* dependency auditing */\n#define\tDT_AUDIT\t0x6ffffefc\t/* object auditing */\n#define\tDT_PLTPAD\t0x6ffffefd\t/* pltpadding (sparcv9) */\n#define\tDT_MOVETAB\t0x6ffffefe\t/* move table */\n#define\tDT_SYMINFO\t0x6ffffeff\t/* syminfo table */\n#define\tDT_ADDRRNGHI\t0x6ffffeff\n\n#define\tDT_VERSYM\t0x6ffffff0\t/* Address of versym section. */\n#define\tDT_RELACOUNT\t0x6ffffff9\t/* number of RELATIVE relocations */\n#define\tDT_RELCOUNT\t0x6ffffffa\t/* number of RELATIVE relocations */\n#define\tDT_FLAGS_1\t0x6ffffffb\t/* state flags - see DF_1_* defs */\n#define\tDT_VERDEF\t0x6ffffffc\t/* Address of verdef section. */\n#define\tDT_VERDEFNUM\t0x6ffffffd\t/* Number of elems in verdef section */\n#define\tDT_VERNEED\t0x6ffffffe\t/* Address of verneed section. */\n#define\tDT_VERNEEDNUM\t0x6fffffff\t/* Number of elems in verneed section */\n\n#define\tDT_LOPROC\t0x70000000\t/* First processor-specific type. */\n\n#define\tDT_ARM_SYMTABSZ\t\t\t0x70000001\n#define\tDT_ARM_PREEMPTMAP\t\t0x70000002\n\n#define\tDT_SPARC_REGISTER\t\t0x70000001\n#define\tDT_DEPRECATED_SPARC_REGISTER\t0x7000001\n\n#define\tDT_MIPS_RLD_VERSION\t\t0x70000001\n#define\tDT_MIPS_TIME_STAMP\t\t0x70000002\n#define\tDT_MIPS_ICHECKSUM\t\t0x70000003\n#define\tDT_MIPS_IVERSION\t\t0x70000004\n#define\tDT_MIPS_FLAGS\t\t\t0x70000005\n#define\tDT_MIPS_BASE_ADDRESS\t\t0x70000006\n#define\tDT_MIPS_CONFLICT\t\t0x70000008\n#define\tDT_MIPS_LIBLIST\t\t\t0x70000009\n#define\tDT_MIPS_LOCAL_GOTNO\t\t0x7000000a\n#define\tDT_MIPS_CONFLICTNO\t\t0x7000000b\n#define\tDT_MIPS_LIBLISTNO\t\t0x70000010\n#define\tDT_MIPS_SYMTABNO\t\t0x70000011\n#define\tDT_MIPS_UNREFEXTNO\t\t0x70000012\n#define\tDT_MIPS_GOTSYM\t\t\t0x70000013\n#define\tDT_MIPS_HIPAGENO\t\t0x70000014\n#define\tDT_MIPS_RLD_MAP\t\t\t0x70000016\n#define\tDT_MIPS_DELTA_CLASS\t\t0x70000017\n#define\tDT_MIPS_DELTA_CLASS_NO\t\t0x70000018\n#define\tDT_MIPS_DELTA_INSTANCE\t\t0x70000019\n#define\tDT_MIPS_DELTA_INSTANCE_NO\t0x7000001A\n#define\tDT_MIPS_DELTA_RELOC\t\t0x7000001B\n#define\tDT_MIPS_DELTA_RELOC_NO\t\t0x7000001C\n#define\tDT_MIPS_DELTA_SYM\t\t0x7000001D\n#define\tDT_MIPS_DELTA_SYM_NO\t\t0x7000001E\n#define\tDT_MIPS_DELTA_CLASSSYM\t\t0x70000020\n#define\tDT_MIPS_DELTA_CLASSSYM_NO\t0x70000021\n#define\tDT_MIPS_CXX_FLAGS\t\t0x70000022\n#define\tDT_MIPS_PIXIE_INIT\t\t0x70000023\n#define\tDT_MIPS_SYMBOL_LIB\t\t0x70000024\n#define\tDT_MIPS_LOCALPAGE_GOTIDX\t0x70000025\n#define\tDT_MIPS_LOCAL_GOTIDX\t\t0x70000026\n#define\tDT_MIPS_HIDDEN_GOTIDX\t\t0x70000027\n#define\tDT_MIPS_PROTECTED_GOTIDX\t0x70000028\n#define\tDT_MIPS_OPTIONS\t\t\t0x70000029\n#define\tDT_MIPS_INTERFACE\t\t0x7000002A\n#define\tDT_MIPS_DYNSTR_ALIGN\t\t0x7000002B\n#define\tDT_MIPS_INTERFACE_SIZE\t\t0x7000002C\n#define\tDT_MIPS_RLD_TEXT_RESOLVE_ADDR\t0x7000002D\n#define\tDT_MIPS_PERF_SUFFIX\t\t0x7000002E\n#define\tDT_MIPS_COMPACT_SIZE\t\t0x7000002F\n#define\tDT_MIPS_GP_VALUE\t\t0x70000030\n#define\tDT_MIPS_AUX_DYNAMIC\t\t0x70000031\n#define\tDT_MIPS_PLTGOT\t\t\t0x70000032\n#define\tDT_MIPS_RLD_OBJ_UPDATE\t\t0x70000033\n#define\tDT_MIPS_RWPLT\t\t\t0x70000034\n\n#define\tDT_PPC_GOT\t\t\t0x70000000\n#define\tDT_PPC_TLSOPT\t\t\t0x70000001\n\n#define\tDT_PPC64_GLINK\t\t\t0x70000000\n#define\tDT_PPC64_OPD\t\t\t0x70000001\n#define\tDT_PPC64_OPDSZ\t\t\t0x70000002\n#define\tDT_PPC64_TLSOPT\t\t\t0x70000003\n\n#define\tDT_AUXILIARY\t0x7ffffffd\t/* shared library auxiliary name */\n#define\tDT_USED\t\t0x7ffffffe\t/* ignored - same as needed */\n#define\tDT_FILTER\t0x7fffffff\t/* shared library filter name */\n#define\tDT_HIPROC\t0x7fffffff\t/* Last processor-specific type. */\n\n/* Values for DT_FLAGS */\n#define\tDF_ORIGIN\t0x0001\t/* Indicates that the object being loaded may\n\t\t\t\t   make reference to the $ORIGIN substitution\n\t\t\t\t   string */\n#define\tDF_SYMBOLIC\t0x0002\t/* Indicates \"symbolic\" linking. */\n#define\tDF_TEXTREL\t0x0004\t/* Indicates there may be relocations in\n\t\t\t\t   non-writable segments. */\n#define\tDF_BIND_NOW\t0x0008\t/* Indicates that the dynamic linker should\n\t\t\t\t   process all relocations for the object\n\t\t\t\t   containing this entry before transferring\n\t\t\t\t   control to the program. */\n#define\tDF_STATIC_TLS\t0x0010\t/* Indicates that the shared object or\n\t\t\t\t   executable contains code using a static\n\t\t\t\t   thread-local storage scheme. */\n\n/* Values for DT_FLAGS_1 */\n#define\tDF_1_BIND_NOW\t0x00000001\t/* Same as DF_BIND_NOW */\n#define\tDF_1_GLOBAL\t0x00000002\t/* Set the RTLD_GLOBAL for object */\n#define\tDF_1_NODELETE\t0x00000008\t/* Set the RTLD_NODELETE for object */\n#define\tDF_1_LOADFLTR\t0x00000010\t/* Immediate loading of filtees */\n#define\tDF_1_NOOPEN     0x00000040\t/* Do not allow loading on dlopen() */\n#define\tDF_1_ORIGIN\t0x00000080\t/* Process $ORIGIN */\n#define\tDF_1_INTERPOSE\t0x00000400\t/* Interpose all objects but main */\n#define\tDF_1_NODEFLIB\t0x00000800\t/* Do not search default paths */\n\n/* Values for l_flags. */\n#define\tLL_NONE\t\t\t0x0\t/* no flags */\n#define\tLL_EXACT_MATCH\t\t0x1\t/* require an exact match */\n#define\tLL_IGNORE_INT_VER\t0x2\t/* ignore version incompatibilities */\n#define\tLL_REQUIRE_MINOR\t0x4\n#define\tLL_EXPORTS\t\t0x8\n#define\tLL_DELAY_LOAD\t\t0x10\n#define\tLL_DELTA\t\t0x20\n\n/* Values for n_type used in executables. */\n#define\tNT_FREEBSD_ABI_TAG\t1\n#define\tNT_FREEBSD_NOINIT_TAG\t2\n#define\tNT_FREEBSD_ARCH_TAG\t3\n#define\tNT_FREEBSD_FEATURE_CTL\t4\n\n/* NT_FREEBSD_FEATURE_CTL desc[0] bits */\n#define\tNT_FREEBSD_FCTL_ASLR_DISABLE\t0x00000001\n\n/* Values for n_type.  Used in core files. */\n#define\tNT_PRSTATUS\t1\t/* Process status. */\n#define\tNT_FPREGSET\t2\t/* Floating point registers. */\n#define\tNT_PRPSINFO\t3\t/* Process state info. */\n#define\tNT_THRMISC\t7\t/* Thread miscellaneous info. */\n#define\tNT_PROCSTAT_PROC\t8\t/* Procstat proc data. */\n#define\tNT_PROCSTAT_FILES\t9\t/* Procstat files data. */\n#define\tNT_PROCSTAT_VMMAP\t10\t/* Procstat vmmap data. */\n#define\tNT_PROCSTAT_GROUPS\t11\t/* Procstat groups data. */\n#define\tNT_PROCSTAT_UMASK\t12\t/* Procstat umask data. */\n#define\tNT_PROCSTAT_RLIMIT\t13\t/* Procstat rlimit data. */\n#define\tNT_PROCSTAT_OSREL\t14\t/* Procstat osreldate data. */\n#define\tNT_PROCSTAT_PSSTRINGS\t15\t/* Procstat ps_strings data. */\n#define\tNT_PROCSTAT_AUXV\t16\t/* Procstat auxv data. */\n#define\tNT_PTLWPINFO\t\t17\t/* Thread ptrace miscellaneous info. */\n#define\tNT_PPC_VMX\t0x100\t/* PowerPC Altivec/VMX registers */\n#define\tNT_PPC_VSX\t0x102\t/* PowerPC VSX registers */\n#define\tNT_X86_XSTATE\t0x202\t/* x86 XSAVE extended state. */\n#define\tNT_ARM_VFP\t0x400\t/* ARM VFP registers */\n\n/* GNU note types. */\n#define\tNT_GNU_ABI_TAG\t\t1\n#define\tNT_GNU_HWCAP\t\t2\n#define\tNT_GNU_BUILD_ID\t\t3\n#define\tNT_GNU_GOLD_VERSION\t4\n#define\tNT_GNU_PROPERTY_TYPE_0\t5\n\n#define\tGNU_PROPERTY_LOPROC\t\t\t0xc0000000\n#define\tGNU_PROPERTY_HIPROC\t\t\t0xdfffffff\n\n#define\tGNU_PROPERTY_X86_FEATURE_1_AND\t\t0xc0000002\n\n#define\tGNU_PROPERTY_X86_FEATURE_1_IBT\t\t0x00000001\n#define\tGNU_PROPERTY_X86_FEATURE_1_SHSTK\t0x00000002\n\n/* Symbol Binding - ELFNN_ST_BIND - st_info */\n#define\tSTB_LOCAL\t0\t/* Local symbol */\n#define\tSTB_GLOBAL\t1\t/* Global symbol */\n#define\tSTB_WEAK\t2\t/* like global - lower precedence */\n#define\tSTB_LOOS\t10\t/* Start of operating system reserved range. */\n#define\tSTB_GNU_UNIQUE\t10\t/* Unique symbol (GNU) */\n#define\tSTB_HIOS\t12\t/* End of operating system reserved range. */\n#define\tSTB_LOPROC\t13\t/* reserved range for processor */\n#define\tSTB_HIPROC\t15\t/*   specific semantics. */\n\n/* Symbol type - ELFNN_ST_TYPE - st_info */\n#define\tSTT_NOTYPE\t0\t/* Unspecified type. */\n#define\tSTT_OBJECT\t1\t/* Data object. */\n#define\tSTT_FUNC\t2\t/* Function. */\n#define\tSTT_SECTION\t3\t/* Section. */\n#define\tSTT_FILE\t4\t/* Source file. */\n#define\tSTT_COMMON\t5\t/* Uninitialized common block. */\n#define\tSTT_TLS\t\t6\t/* TLS object. */\n#define\tSTT_NUM\t\t7\n#define\tSTT_LOOS\t10\t/* Reserved range for operating system */\n#define\tSTT_GNU_IFUNC\t10\n#define\tSTT_HIOS\t12\t/*   specific semantics. */\n#define\tSTT_LOPROC\t13\t/* Start of processor reserved range. */\n#define\tSTT_SPARC_REGISTER 13\t/* SPARC register information. */\n#define\tSTT_HIPROC\t15\t/* End of processor reserved range. */\n\n/* Symbol visibility - ELFNN_ST_VISIBILITY - st_other */\n#define\tSTV_DEFAULT\t0x0\t/* Default visibility (see binding). */\n#define\tSTV_INTERNAL\t0x1\t/* Special meaning in relocatable objects. */\n#define\tSTV_HIDDEN\t0x2\t/* Not visible. */\n#define\tSTV_PROTECTED\t0x3\t/* Visible but not preemptible. */\n#define\tSTV_EXPORTED\t0x4\n#define\tSTV_SINGLETON\t0x5\n#define\tSTV_ELIMINATE\t0x6\n\n/* Special symbol table indexes. */\n#define\tSTN_UNDEF\t0\t/* Undefined symbol index. */\n\n/* Symbol versioning flags. */\n#define\tVER_DEF_CURRENT\t1\n#define\tVER_DEF_IDX(x)\tVER_NDX(x)\n\n#define\tVER_FLG_BASE\t0x01\n#define\tVER_FLG_WEAK\t0x02\n\n#define\tVER_NEED_CURRENT\t1\n#define\tVER_NEED_WEAK\t(1u << 15)\n#define\tVER_NEED_HIDDEN\tVER_NDX_HIDDEN\n#define\tVER_NEED_IDX(x)\tVER_NDX(x)\n\n#define\tVER_NDX_LOCAL\t0\n#define\tVER_NDX_GLOBAL\t1\n#define\tVER_NDX_GIVEN\t2\n\n#define\tVER_NDX_HIDDEN\t(1u << 15)\n#define\tVER_NDX(x)\t((x) & ~(1u << 15))\n\n#define\tCA_SUNW_NULL\t0\n#define\tCA_SUNW_HW_1\t1\t\t/* first hardware capabilities entry */\n#define\tCA_SUNW_SF_1\t2\t\t/* first software capabilities entry */\n\n/*\n * Syminfo flag values\n */\n#define\tSYMINFO_FLG_DIRECT\t0x0001\t/* symbol ref has direct association */\n\t\t\t\t\t/*\tto object containing defn. */\n#define\tSYMINFO_FLG_PASSTHRU\t0x0002\t/* ignored - see SYMINFO_FLG_FILTER */\n#define\tSYMINFO_FLG_COPY\t0x0004\t/* symbol is a copy-reloc */\n#define\tSYMINFO_FLG_LAZYLOAD\t0x0008\t/* object containing defn should be */\n\t\t\t\t\t/*\tlazily-loaded */\n#define\tSYMINFO_FLG_DIRECTBIND\t0x0010\t/* ref should be bound directly to */\n\t\t\t\t\t/*\tobject containing defn. */\n#define\tSYMINFO_FLG_NOEXTDIRECT\t0x0020\t/* don't let an external reference */\n\t\t\t\t\t/*\tdirectly bind to this symbol */\n#define\tSYMINFO_FLG_FILTER\t0x0002\t/* symbol ref is associated to a */\n#define\tSYMINFO_FLG_AUXILIARY\t0x0040\t/* \tstandard or auxiliary filter */\n\n/*\n * Syminfo.si_boundto values.\n */\n#define\tSYMINFO_BT_SELF\t\t0xffff\t/* symbol bound to self */\n#define\tSYMINFO_BT_PARENT\t0xfffe\t/* symbol bound to parent */\n#define\tSYMINFO_BT_NONE\t\t0xfffd\t/* no special symbol binding */\n#define\tSYMINFO_BT_EXTERN\t0xfffc\t/* symbol defined as external */\n#define\tSYMINFO_BT_LOWRESERVE\t0xff00\t/* beginning of reserved entries */\n\n/*\n * Syminfo version values.\n */\n#define\tSYMINFO_NONE\t\t0\t/* Syminfo version */\n#define\tSYMINFO_CURRENT\t\t1\n#define\tSYMINFO_NUM\t\t2\n\n/* Values for ch_type (compressed section headers). */\n#define\tELFCOMPRESS_ZLIB\t1\t/* ZLIB/DEFLATE */\n#define\tELFCOMPRESS_LOOS\t0x60000000\t/* OS-specific */\n#define\tELFCOMPRESS_HIOS\t0x6fffffff\n#define\tELFCOMPRESS_LOPROC\t0x70000000\t/* Processor-specific */\n#define\tELFCOMPRESS_HIPROC\t0x7fffffff\n\n/*\n * Relocation types.\n *\n * All machine architectures are defined here to allow tools on one to\n * handle others.\n */\n\n#define\tR_386_NONE\t\t0\t/* No relocation. */\n#define\tR_386_32\t\t1\t/* Add symbol value. */\n#define\tR_386_PC32\t\t2\t/* Add PC-relative symbol value. */\n#define\tR_386_GOT32\t\t3\t/* Add PC-relative GOT offset. */\n#define\tR_386_PLT32\t\t4\t/* Add PC-relative PLT offset. */\n#define\tR_386_COPY\t\t5\t/* Copy data from shared object. */\n#define\tR_386_GLOB_DAT\t\t6\t/* Set GOT entry to data address. */\n#define\tR_386_JMP_SLOT\t\t7\t/* Set GOT entry to code address. */\n#define\tR_386_RELATIVE\t\t8\t/* Add load address of shared object. */\n#define\tR_386_GOTOFF\t\t9\t/* Add GOT-relative symbol address. */\n#define\tR_386_GOTPC\t\t10\t/* Add PC-relative GOT table address. */\n#define\tR_386_TLS_TPOFF\t\t14\t/* Negative offset in static TLS block */\n#define\tR_386_TLS_IE\t\t15\t/* Absolute address of GOT for -ve static TLS */\n#define\tR_386_TLS_GOTIE\t\t16\t/* GOT entry for negative static TLS block */\n#define\tR_386_TLS_LE\t\t17\t/* Negative offset relative to static TLS */\n#define\tR_386_TLS_GD\t\t18\t/* 32 bit offset to GOT (index,off) pair */\n#define\tR_386_TLS_LDM\t\t19\t/* 32 bit offset to GOT (index,zero) pair */\n#define\tR_386_TLS_GD_32\t\t24\t/* 32 bit offset to GOT (index,off) pair */\n#define\tR_386_TLS_GD_PUSH\t25\t/* pushl instruction for Sun ABI GD sequence */\n#define\tR_386_TLS_GD_CALL\t26\t/* call instruction for Sun ABI GD sequence */\n#define\tR_386_TLS_GD_POP\t27\t/* popl instruction for Sun ABI GD sequence */\n#define\tR_386_TLS_LDM_32\t28\t/* 32 bit offset to GOT (index,zero) pair */\n#define\tR_386_TLS_LDM_PUSH\t29\t/* pushl instruction for Sun ABI LD sequence */\n#define\tR_386_TLS_LDM_CALL\t30\t/* call instruction for Sun ABI LD sequence */\n#define\tR_386_TLS_LDM_POP\t31\t/* popl instruction for Sun ABI LD sequence */\n#define\tR_386_TLS_LDO_32\t32\t/* 32 bit offset from start of TLS block */\n#define\tR_386_TLS_IE_32\t\t33\t/* 32 bit offset to GOT static TLS offset entry */\n#define\tR_386_TLS_LE_32\t\t34\t/* 32 bit offset within static TLS block */\n#define\tR_386_TLS_DTPMOD32\t35\t/* GOT entry containing TLS index */\n#define\tR_386_TLS_DTPOFF32\t36\t/* GOT entry containing TLS offset */\n#define\tR_386_TLS_TPOFF32\t37\t/* GOT entry of -ve static TLS offset */\n#define\tR_386_IRELATIVE\t\t42\t/* PLT entry resolved indirectly at runtime */\n\n#define\tR_AARCH64_NONE\t\t0\t/* No relocation */\n#define\tR_AARCH64_ABS64\t\t257\t/* Absolute offset */\n#define\tR_AARCH64_ABS32\t\t258\t/* Absolute, 32-bit overflow check */\n#define\tR_AARCH64_ABS16\t\t259\t/* Absolute, 16-bit overflow check */\n#define\tR_AARCH64_PREL64\t260\t/* PC relative */\n#define\tR_AARCH64_PREL32\t261\t/* PC relative, 32-bit overflow check */\n#define\tR_AARCH64_PREL16\t262\t/* PC relative, 16-bit overflow check */\n#define\tR_AARCH64_COPY\t\t1024\t/* Copy data from shared object */\n#define\tR_AARCH64_GLOB_DAT\t1025\t/* Set GOT entry to data address */\n#define\tR_AARCH64_JUMP_SLOT\t1026\t/* Set GOT entry to code address */\n#define\tR_AARCH64_RELATIVE \t1027\t/* Add load address of shared object */\n#define\tR_AARCH64_TLS_DTPREL64\t1028\n#define\tR_AARCH64_TLS_DTPMOD64\t1029\n#define\tR_AARCH64_TLS_TPREL64 \t1030\n#define\tR_AARCH64_TLSDESC \t1031\t/* Identify the TLS descriptor */\n#define\tR_AARCH64_IRELATIVE\t1032\n\n#define\tR_ARM_NONE\t\t0\t/* No relocation. */\n#define\tR_ARM_PC24\t\t1\n#define\tR_ARM_ABS32\t\t2\n#define\tR_ARM_REL32\t\t3\n#define\tR_ARM_PC13\t\t4\n#define\tR_ARM_ABS16\t\t5\n#define\tR_ARM_ABS12\t\t6\n#define\tR_ARM_THM_ABS5\t\t7\n#define\tR_ARM_ABS8\t\t8\n#define\tR_ARM_SBREL32\t\t9\n#define\tR_ARM_THM_PC22\t\t10\n#define\tR_ARM_THM_PC8\t\t11\n#define\tR_ARM_AMP_VCALL9\t12\n#define\tR_ARM_SWI24\t\t13\n#define\tR_ARM_THM_SWI8\t\t14\n#define\tR_ARM_XPC25\t\t15\n#define\tR_ARM_THM_XPC22\t\t16\n/* TLS relocations */\n#define\tR_ARM_TLS_DTPMOD32\t17\t/* ID of module containing symbol */\n#define\tR_ARM_TLS_DTPOFF32\t18\t/* Offset in TLS block */\n#define\tR_ARM_TLS_TPOFF32\t19\t/* Offset in static TLS block */\n#define\tR_ARM_COPY\t\t20\t/* Copy data from shared object. */\n#define\tR_ARM_GLOB_DAT\t\t21\t/* Set GOT entry to data address. */\n#define\tR_ARM_JUMP_SLOT\t\t22\t/* Set GOT entry to code address. */\n#define\tR_ARM_RELATIVE\t\t23\t/* Add load address of shared object. */\n#define\tR_ARM_GOTOFF\t\t24\t/* Add GOT-relative symbol address. */\n#define\tR_ARM_GOTPC\t\t25\t/* Add PC-relative GOT table address. */\n#define\tR_ARM_GOT32\t\t26\t/* Add PC-relative GOT offset. */\n#define\tR_ARM_PLT32\t\t27\t/* Add PC-relative PLT offset. */\n#define\tR_ARM_GNU_VTENTRY\t100\n#define\tR_ARM_GNU_VTINHERIT\t101\n#define\tR_ARM_RSBREL32\t\t250\n#define\tR_ARM_THM_RPC22\t\t251\n#define\tR_ARM_RREL32\t\t252\n#define\tR_ARM_RABS32\t\t253\n#define\tR_ARM_RPC24\t\t254\n#define\tR_ARM_RBASE\t\t255\n\n/*\tName\t\t\tValue\t   Field\tCalculation */\n#define\tR_IA_64_NONE\t\t0\t/* None */\n#define\tR_IA_64_IMM14\t\t0x21\t/* immediate14\tS + A */\n#define\tR_IA_64_IMM22\t\t0x22\t/* immediate22\tS + A */\n#define\tR_IA_64_IMM64\t\t0x23\t/* immediate64\tS + A */\n#define\tR_IA_64_DIR32MSB\t0x24\t/* word32 MSB\tS + A */\n#define\tR_IA_64_DIR32LSB\t0x25\t/* word32 LSB\tS + A */\n#define\tR_IA_64_DIR64MSB\t0x26\t/* word64 MSB\tS + A */\n#define\tR_IA_64_DIR64LSB\t0x27\t/* word64 LSB\tS + A */\n#define\tR_IA_64_GPREL22\t\t0x2a\t/* immediate22\t@gprel(S + A) */\n#define\tR_IA_64_GPREL64I\t0x2b\t/* immediate64\t@gprel(S + A) */\n#define\tR_IA_64_GPREL32MSB\t0x2c\t/* word32 MSB\t@gprel(S + A) */\n#define\tR_IA_64_GPREL32LSB\t0x2d\t/* word32 LSB\t@gprel(S + A) */\n#define\tR_IA_64_GPREL64MSB\t0x2e\t/* word64 MSB\t@gprel(S + A) */\n#define\tR_IA_64_GPREL64LSB\t0x2f\t/* word64 LSB\t@gprel(S + A) */\n#define\tR_IA_64_LTOFF22\t\t0x32\t/* immediate22\t@ltoff(S + A) */\n#define\tR_IA_64_LTOFF64I\t0x33\t/* immediate64\t@ltoff(S + A) */\n#define\tR_IA_64_PLTOFF22\t0x3a\t/* immediate22\t@pltoff(S + A) */\n#define\tR_IA_64_PLTOFF64I\t0x3b\t/* immediate64\t@pltoff(S + A) */\n#define\tR_IA_64_PLTOFF64MSB\t0x3e\t/* word64 MSB\t@pltoff(S + A) */\n#define\tR_IA_64_PLTOFF64LSB\t0x3f\t/* word64 LSB\t@pltoff(S + A) */\n#define\tR_IA_64_FPTR64I\t\t0x43\t/* immediate64\t@fptr(S + A) */\n#define\tR_IA_64_FPTR32MSB\t0x44\t/* word32 MSB\t@fptr(S + A) */\n#define\tR_IA_64_FPTR32LSB\t0x45\t/* word32 LSB\t@fptr(S + A) */\n#define\tR_IA_64_FPTR64MSB\t0x46\t/* word64 MSB\t@fptr(S + A) */\n#define\tR_IA_64_FPTR64LSB\t0x47\t/* word64 LSB\t@fptr(S + A) */\n#define\tR_IA_64_PCREL60B\t0x48\t/* immediate60 form1 S + A - P */\n#define\tR_IA_64_PCREL21B\t0x49\t/* immediate21 form1 S + A - P */\n#define\tR_IA_64_PCREL21M\t0x4a\t/* immediate21 form2 S + A - P */\n#define\tR_IA_64_PCREL21F\t0x4b\t/* immediate21 form3 S + A - P */\n#define\tR_IA_64_PCREL32MSB\t0x4c\t/* word32 MSB\tS + A - P */\n#define\tR_IA_64_PCREL32LSB\t0x4d\t/* word32 LSB\tS + A - P */\n#define\tR_IA_64_PCREL64MSB\t0x4e\t/* word64 MSB\tS + A - P */\n#define\tR_IA_64_PCREL64LSB\t0x4f\t/* word64 LSB\tS + A - P */\n#define\tR_IA_64_LTOFF_FPTR22\t0x52\t/* immediate22\t@ltoff(@fptr(S + A)) */\n#define\tR_IA_64_LTOFF_FPTR64I\t0x53\t/* immediate64\t@ltoff(@fptr(S + A)) */\n#define\tR_IA_64_LTOFF_FPTR32MSB\t0x54\t/* word32 MSB\t@ltoff(@fptr(S + A)) */\n#define\tR_IA_64_LTOFF_FPTR32LSB\t0x55\t/* word32 LSB\t@ltoff(@fptr(S + A)) */\n#define\tR_IA_64_LTOFF_FPTR64MSB\t0x56\t/* word64 MSB\t@ltoff(@fptr(S + A)) */\n#define\tR_IA_64_LTOFF_FPTR64LSB\t0x57\t/* word64 LSB\t@ltoff(@fptr(S + A)) */\n#define\tR_IA_64_SEGREL32MSB\t0x5c\t/* word32 MSB\t@segrel(S + A) */\n#define\tR_IA_64_SEGREL32LSB\t0x5d\t/* word32 LSB\t@segrel(S + A) */\n#define\tR_IA_64_SEGREL64MSB\t0x5e\t/* word64 MSB\t@segrel(S + A) */\n#define\tR_IA_64_SEGREL64LSB\t0x5f\t/* word64 LSB\t@segrel(S + A) */\n#define\tR_IA_64_SECREL32MSB\t0x64\t/* word32 MSB\t@secrel(S + A) */\n#define\tR_IA_64_SECREL32LSB\t0x65\t/* word32 LSB\t@secrel(S + A) */\n#define\tR_IA_64_SECREL64MSB\t0x66\t/* word64 MSB\t@secrel(S + A) */\n#define\tR_IA_64_SECREL64LSB\t0x67\t/* word64 LSB\t@secrel(S + A) */\n#define\tR_IA_64_REL32MSB\t0x6c\t/* word32 MSB\tBD + A */\n#define\tR_IA_64_REL32LSB\t0x6d\t/* word32 LSB\tBD + A */\n#define\tR_IA_64_REL64MSB\t0x6e\t/* word64 MSB\tBD + A */\n#define\tR_IA_64_REL64LSB\t0x6f\t/* word64 LSB\tBD + A */\n#define\tR_IA_64_LTV32MSB\t0x74\t/* word32 MSB\tS + A */\n#define\tR_IA_64_LTV32LSB\t0x75\t/* word32 LSB\tS + A */\n#define\tR_IA_64_LTV64MSB\t0x76\t/* word64 MSB\tS + A */\n#define\tR_IA_64_LTV64LSB\t0x77\t/* word64 LSB\tS + A */\n#define\tR_IA_64_PCREL21BI\t0x79\t/* immediate21 form1 S + A - P */\n#define\tR_IA_64_PCREL22\t\t0x7a\t/* immediate22\tS + A - P */\n#define\tR_IA_64_PCREL64I\t0x7b\t/* immediate64\tS + A - P */\n#define\tR_IA_64_IPLTMSB\t\t0x80\t/* function descriptor MSB special */\n#define\tR_IA_64_IPLTLSB\t\t0x81\t/* function descriptor LSB speciaal */\n#define\tR_IA_64_SUB\t\t0x85\t/* immediate64\tA - S */\n#define\tR_IA_64_LTOFF22X\t0x86\t/* immediate22\tspecial */\n#define\tR_IA_64_LDXMOV\t\t0x87\t/* immediate22\tspecial */\n#define\tR_IA_64_TPREL14\t\t0x91\t/* imm14\t@tprel(S + A) */\n#define\tR_IA_64_TPREL22\t\t0x92\t/* imm22\t@tprel(S + A) */\n#define\tR_IA_64_TPREL64I\t0x93\t/* imm64\t@tprel(S + A) */\n#define\tR_IA_64_TPREL64MSB\t0x96\t/* word64 MSB\t@tprel(S + A) */\n#define\tR_IA_64_TPREL64LSB\t0x97\t/* word64 LSB\t@tprel(S + A) */\n#define\tR_IA_64_LTOFF_TPREL22\t0x9a\t/* imm22\t@ltoff(@tprel(S+A)) */\n#define\tR_IA_64_DTPMOD64MSB\t0xa6\t/* word64 MSB\t@dtpmod(S + A) */\n#define\tR_IA_64_DTPMOD64LSB\t0xa7\t/* word64 LSB\t@dtpmod(S + A) */\n#define\tR_IA_64_LTOFF_DTPMOD22\t0xaa\t/* imm22\t@ltoff(@dtpmod(S+A)) */\n#define\tR_IA_64_DTPREL14\t0xb1\t/* imm14\t@dtprel(S + A) */\n#define\tR_IA_64_DTPREL22\t0xb2\t/* imm22\t@dtprel(S + A) */\n#define\tR_IA_64_DTPREL64I\t0xb3\t/* imm64\t@dtprel(S + A) */\n#define\tR_IA_64_DTPREL32MSB\t0xb4\t/* word32 MSB\t@dtprel(S + A) */\n#define\tR_IA_64_DTPREL32LSB\t0xb5\t/* word32 LSB\t@dtprel(S + A) */\n#define\tR_IA_64_DTPREL64MSB\t0xb6\t/* word64 MSB\t@dtprel(S + A) */\n#define\tR_IA_64_DTPREL64LSB\t0xb7\t/* word64 LSB\t@dtprel(S + A) */\n#define\tR_IA_64_LTOFF_DTPREL22\t0xba\t/* imm22\t@ltoff(@dtprel(S+A)) */\n\n#define\tR_MIPS_NONE\t0\t/* No reloc */\n#define\tR_MIPS_16\t1\t/* Direct 16 bit */\n#define\tR_MIPS_32\t2\t/* Direct 32 bit */\n#define\tR_MIPS_REL32\t3\t/* PC relative 32 bit */\n#define\tR_MIPS_26\t4\t/* Direct 26 bit shifted */\n#define\tR_MIPS_HI16\t5\t/* High 16 bit */\n#define\tR_MIPS_LO16\t6\t/* Low 16 bit */\n#define\tR_MIPS_GPREL16\t7\t/* GP relative 16 bit */\n#define\tR_MIPS_LITERAL\t8\t/* 16 bit literal entry */\n#define\tR_MIPS_GOT16\t9\t/* 16 bit GOT entry */\n#define\tR_MIPS_PC16\t10\t/* PC relative 16 bit */\n#define\tR_MIPS_CALL16\t11\t/* 16 bit GOT entry for function */\n#define\tR_MIPS_GPREL32\t12\t/* GP relative 32 bit */\n#define\tR_MIPS_64\t18\t/* Direct 64 bit */\n#define\tR_MIPS_GOT_DISP\t19\n#define\tR_MIPS_GOT_PAGE\t20\n#define\tR_MIPS_GOT_OFST\t21\n#define\tR_MIPS_GOT_HI16\t22\t/* GOT HI 16 bit */\n#define\tR_MIPS_GOT_LO16\t23\t/* GOT LO 16 bit */\n#define\tR_MIPS_SUB\t24\n#define\tR_MIPS_CALLHI16 30\t/* upper 16 bit GOT entry for function */\n#define\tR_MIPS_CALLLO16 31\t/* lower 16 bit GOT entry for function */\n#define\tR_MIPS_JALR\t37\n#define\tR_MIPS_TLS_GD\t42\n#define\tR_MIPS_COPY\t126\n#define\tR_MIPS_JUMP_SLOT\t127\n\n#define\tR_PPC_NONE\t\t0\t/* No relocation. */\n#define\tR_PPC_ADDR32\t\t1\n#define\tR_PPC_ADDR24\t\t2\n#define\tR_PPC_ADDR16\t\t3\n#define\tR_PPC_ADDR16_LO\t\t4\n#define\tR_PPC_ADDR16_HI\t\t5\n#define\tR_PPC_ADDR16_HA\t\t6\n#define\tR_PPC_ADDR14\t\t7\n#define\tR_PPC_ADDR14_BRTAKEN\t8\n#define\tR_PPC_ADDR14_BRNTAKEN\t9\n#define\tR_PPC_REL24\t\t10\n#define\tR_PPC_REL14\t\t11\n#define\tR_PPC_REL14_BRTAKEN\t12\n#define\tR_PPC_REL14_BRNTAKEN\t13\n#define\tR_PPC_GOT16\t\t14\n#define\tR_PPC_GOT16_LO\t\t15\n#define\tR_PPC_GOT16_HI\t\t16\n#define\tR_PPC_GOT16_HA\t\t17\n#define\tR_PPC_PLTREL24\t\t18\n#define\tR_PPC_COPY\t\t19\n#define\tR_PPC_GLOB_DAT\t\t20\n#define\tR_PPC_JMP_SLOT\t\t21\n#define\tR_PPC_RELATIVE\t\t22\n#define\tR_PPC_LOCAL24PC\t\t23\n#define\tR_PPC_UADDR32\t\t24\n#define\tR_PPC_UADDR16\t\t25\n#define\tR_PPC_REL32\t\t26\n#define\tR_PPC_PLT32\t\t27\n#define\tR_PPC_PLTREL32\t\t28\n#define\tR_PPC_PLT16_LO\t\t29\n#define\tR_PPC_PLT16_HI\t\t30\n#define\tR_PPC_PLT16_HA\t\t31\n#define\tR_PPC_SDAREL16\t\t32\n#define\tR_PPC_SECTOFF\t\t33\n#define\tR_PPC_SECTOFF_LO\t34\n#define\tR_PPC_SECTOFF_HI\t35\n#define\tR_PPC_SECTOFF_HA\t36\n\n/*\n * 64-bit relocations\n */\n#define\tR_PPC64_ADDR64\t\t38\n#define\tR_PPC64_ADDR16_HIGHER\t39\n#define\tR_PPC64_ADDR16_HIGHERA\t40\n#define\tR_PPC64_ADDR16_HIGHEST\t41\n#define\tR_PPC64_ADDR16_HIGHESTA\t42\n#define\tR_PPC64_UADDR64\t\t43\n#define\tR_PPC64_REL64\t\t44\n#define\tR_PPC64_PLT64\t\t45\n#define\tR_PPC64_PLTREL64\t46\n#define\tR_PPC64_TOC16\t\t47\n#define\tR_PPC64_TOC16_LO\t48\n#define\tR_PPC64_TOC16_HI\t49\n#define\tR_PPC64_TOC16_HA\t50\n#define\tR_PPC64_TOC\t\t51\n#define\tR_PPC64_DTPMOD64\t68\n#define\tR_PPC64_TPREL64\t\t73\n#define\tR_PPC64_DTPREL64\t78\n\n/*\n * TLS relocations\n */\n#define\tR_PPC_TLS\t\t67\n#define\tR_PPC_DTPMOD32\t\t68\n#define\tR_PPC_TPREL16\t\t69\n#define\tR_PPC_TPREL16_LO\t70\n#define\tR_PPC_TPREL16_HI\t71\n#define\tR_PPC_TPREL16_HA\t72\n#define\tR_PPC_TPREL32\t\t73\n#define\tR_PPC_DTPREL16\t\t74\n#define\tR_PPC_DTPREL16_LO\t75\n#define\tR_PPC_DTPREL16_HI\t76\n#define\tR_PPC_DTPREL16_HA\t77\n#define\tR_PPC_DTPREL32\t\t78\n#define\tR_PPC_GOT_TLSGD16\t79\n#define\tR_PPC_GOT_TLSGD16_LO\t80\n#define\tR_PPC_GOT_TLSGD16_HI\t81\n#define\tR_PPC_GOT_TLSGD16_HA\t82\n#define\tR_PPC_GOT_TLSLD16\t83\n#define\tR_PPC_GOT_TLSLD16_LO\t84\n#define\tR_PPC_GOT_TLSLD16_HI\t85\n#define\tR_PPC_GOT_TLSLD16_HA\t86\n#define\tR_PPC_GOT_TPREL16\t87\n#define\tR_PPC_GOT_TPREL16_LO\t88\n#define\tR_PPC_GOT_TPREL16_HI\t89\n#define\tR_PPC_GOT_TPREL16_HA\t90\n\n/*\n * The remaining relocs are from the Embedded ELF ABI, and are not in the\n *  SVR4 ELF ABI.\n */\n\n#define\tR_PPC_EMB_NADDR32\t101\n#define\tR_PPC_EMB_NADDR16\t102\n#define\tR_PPC_EMB_NADDR16_LO\t103\n#define\tR_PPC_EMB_NADDR16_HI\t104\n#define\tR_PPC_EMB_NADDR16_HA\t105\n#define\tR_PPC_EMB_SDAI16\t106\n#define\tR_PPC_EMB_SDA2I16\t107\n#define\tR_PPC_EMB_SDA2REL\t108\n#define\tR_PPC_EMB_SDA21\t\t109\n#define\tR_PPC_EMB_MRKREF\t110\n#define\tR_PPC_EMB_RELSEC16\t111\n#define\tR_PPC_EMB_RELST_LO\t112\n#define\tR_PPC_EMB_RELST_HI\t113\n#define\tR_PPC_EMB_RELST_HA\t114\n#define\tR_PPC_EMB_BIT_FLD\t115\n#define\tR_PPC_EMB_RELSDA\t116\n\n/*\n * RISC-V relocation types.\n */\n\n/* Relocation types used by the dynamic linker. */\n#define\tR_RISCV_NONE\t\t0\n#define\tR_RISCV_32\t\t1\n#define\tR_RISCV_64\t\t2\n#define\tR_RISCV_RELATIVE\t3\n#define\tR_RISCV_COPY\t\t4\n#define\tR_RISCV_JUMP_SLOT\t5\n#define\tR_RISCV_TLS_DTPMOD32\t6\n#define\tR_RISCV_TLS_DTPMOD64\t7\n#define\tR_RISCV_TLS_DTPREL32\t8\n#define\tR_RISCV_TLS_DTPREL64\t9\n#define\tR_RISCV_TLS_TPREL32\t10\n#define\tR_RISCV_TLS_TPREL64\t11\n\n/* Relocation types not used by the dynamic linker. */\n#define\tR_RISCV_BRANCH\t\t16\n#define\tR_RISCV_JAL\t\t17\n#define\tR_RISCV_CALL\t\t18\n#define\tR_RISCV_CALL_PLT\t19\n#define\tR_RISCV_GOT_HI20\t20\n#define\tR_RISCV_TLS_GOT_HI20\t21\n#define\tR_RISCV_TLS_GD_HI20\t22\n#define\tR_RISCV_PCREL_HI20\t23\n#define\tR_RISCV_PCREL_LO12_I\t24\n#define\tR_RISCV_PCREL_LO12_S\t25\n#define\tR_RISCV_HI20\t\t26\n#define\tR_RISCV_LO12_I\t\t27\n#define\tR_RISCV_LO12_S\t\t28\n#define\tR_RISCV_TPREL_HI20\t29\n#define\tR_RISCV_TPREL_LO12_I\t30\n#define\tR_RISCV_TPREL_LO12_S\t31\n#define\tR_RISCV_TPREL_ADD\t32\n#define\tR_RISCV_ADD8\t\t33\n#define\tR_RISCV_ADD16\t\t34\n#define\tR_RISCV_ADD32\t\t35\n#define\tR_RISCV_ADD64\t\t36\n#define\tR_RISCV_SUB8\t\t37\n#define\tR_RISCV_SUB16\t\t38\n#define\tR_RISCV_SUB32\t\t39\n#define\tR_RISCV_SUB64\t\t40\n#define\tR_RISCV_GNU_VTINHERIT\t41\n#define\tR_RISCV_GNU_VTENTRY\t42\n#define\tR_RISCV_ALIGN\t\t43\n#define\tR_RISCV_RVC_BRANCH\t44\n#define\tR_RISCV_RVC_JUMP\t45\n#define\tR_RISCV_RVC_LUI\t\t46\n#define\tR_RISCV_GPREL_I\t\t47\n#define\tR_RISCV_GPREL_S\t\t48\n#define\tR_RISCV_TPREL_I\t\t49\n#define\tR_RISCV_TPREL_S\t\t50\n#define\tR_RISCV_RELAX\t\t51\n#define\tR_RISCV_SUB6\t\t52\n#define\tR_RISCV_SET6\t\t53\n#define\tR_RISCV_SET8\t\t54\n#define\tR_RISCV_SET16\t\t55\n#define\tR_RISCV_SET32\t\t56\n\n#define\tR_SPARC_NONE\t\t0\n#define\tR_SPARC_8\t\t1\n#define\tR_SPARC_16\t\t2\n#define\tR_SPARC_32\t\t3\n#define\tR_SPARC_DISP8\t\t4\n#define\tR_SPARC_DISP16\t\t5\n#define\tR_SPARC_DISP32\t\t6\n#define\tR_SPARC_WDISP30\t\t7\n#define\tR_SPARC_WDISP22\t\t8\n#define\tR_SPARC_HI22\t\t9\n#define\tR_SPARC_22\t\t10\n#define\tR_SPARC_13\t\t11\n#define\tR_SPARC_LO10\t\t12\n#define\tR_SPARC_GOT10\t\t13\n#define\tR_SPARC_GOT13\t\t14\n#define\tR_SPARC_GOT22\t\t15\n#define\tR_SPARC_PC10\t\t16\n#define\tR_SPARC_PC22\t\t17\n#define\tR_SPARC_WPLT30\t\t18\n#define\tR_SPARC_COPY\t\t19\n#define\tR_SPARC_GLOB_DAT\t20\n#define\tR_SPARC_JMP_SLOT\t21\n#define\tR_SPARC_RELATIVE\t22\n#define\tR_SPARC_UA32\t\t23\n#define\tR_SPARC_PLT32\t\t24\n#define\tR_SPARC_HIPLT22\t\t25\n#define\tR_SPARC_LOPLT10\t\t26\n#define\tR_SPARC_PCPLT32\t\t27\n#define\tR_SPARC_PCPLT22\t\t28\n#define\tR_SPARC_PCPLT10\t\t29\n#define\tR_SPARC_10\t\t30\n#define\tR_SPARC_11\t\t31\n#define\tR_SPARC_64\t\t32\n#define\tR_SPARC_OLO10\t\t33\n#define\tR_SPARC_HH22\t\t34\n#define\tR_SPARC_HM10\t\t35\n#define\tR_SPARC_LM22\t\t36\n#define\tR_SPARC_PC_HH22\t\t37\n#define\tR_SPARC_PC_HM10\t\t38\n#define\tR_SPARC_PC_LM22\t\t39\n#define\tR_SPARC_WDISP16\t\t40\n#define\tR_SPARC_WDISP19\t\t41\n#define\tR_SPARC_GLOB_JMP\t42\n#define\tR_SPARC_7\t\t43\n#define\tR_SPARC_5\t\t44\n#define\tR_SPARC_6\t\t45\n#define\tR_SPARC_DISP64\t\t46\n#define\tR_SPARC_PLT64\t\t47\n#define\tR_SPARC_HIX22\t\t48\n#define\tR_SPARC_LOX10\t\t49\n#define\tR_SPARC_H44\t\t50\n#define\tR_SPARC_M44\t\t51\n#define\tR_SPARC_L44\t\t52\n#define\tR_SPARC_REGISTER\t53\n#define\tR_SPARC_UA64\t\t54\n#define\tR_SPARC_UA16\t\t55\n#define\tR_SPARC_TLS_GD_HI22\t56\n#define\tR_SPARC_TLS_GD_LO10\t57\n#define\tR_SPARC_TLS_GD_ADD\t58\n#define\tR_SPARC_TLS_GD_CALL\t59\n#define\tR_SPARC_TLS_LDM_HI22\t60\n#define\tR_SPARC_TLS_LDM_LO10\t61\n#define\tR_SPARC_TLS_LDM_ADD\t62\n#define\tR_SPARC_TLS_LDM_CALL\t63\n#define\tR_SPARC_TLS_LDO_HIX22\t64\n#define\tR_SPARC_TLS_LDO_LOX10\t65\n#define\tR_SPARC_TLS_LDO_ADD\t66\n#define\tR_SPARC_TLS_IE_HI22\t67\n#define\tR_SPARC_TLS_IE_LO10\t68\n#define\tR_SPARC_TLS_IE_LD\t69\n#define\tR_SPARC_TLS_IE_LDX\t70\n#define\tR_SPARC_TLS_IE_ADD\t71\n#define\tR_SPARC_TLS_LE_HIX22\t72\n#define\tR_SPARC_TLS_LE_LOX10\t73\n#define\tR_SPARC_TLS_DTPMOD32\t74\n#define\tR_SPARC_TLS_DTPMOD64\t75\n#define\tR_SPARC_TLS_DTPOFF32\t76\n#define\tR_SPARC_TLS_DTPOFF64\t77\n#define\tR_SPARC_TLS_TPOFF32\t78\n#define\tR_SPARC_TLS_TPOFF64\t79\n\n#define\tR_X86_64_NONE\t\t0\t/* No relocation. */\n#define\tR_X86_64_64\t\t1\t/* Add 64 bit symbol value. */\n#define\tR_X86_64_PC32\t\t2\t/* PC-relative 32 bit signed sym value. */\n#define\tR_X86_64_GOT32\t\t3\t/* PC-relative 32 bit GOT offset. */\n#define\tR_X86_64_PLT32\t\t4\t/* PC-relative 32 bit PLT offset. */\n#define\tR_X86_64_COPY\t\t5\t/* Copy data from shared object. */\n#define\tR_X86_64_GLOB_DAT\t6\t/* Set GOT entry to data address. */\n#define\tR_X86_64_JMP_SLOT\t7\t/* Set GOT entry to code address. */\n#define\tR_X86_64_RELATIVE\t8\t/* Add load address of shared object. */\n#define\tR_X86_64_GOTPCREL\t9\t/* Add 32 bit signed pcrel offset to GOT. */\n#define\tR_X86_64_32\t\t10\t/* Add 32 bit zero extended symbol value */\n#define\tR_X86_64_32S\t\t11\t/* Add 32 bit sign extended symbol value */\n#define\tR_X86_64_16\t\t12\t/* Add 16 bit zero extended symbol value */\n#define\tR_X86_64_PC16\t\t13\t/* Add 16 bit signed extended pc relative symbol value */\n#define\tR_X86_64_8\t\t14\t/* Add 8 bit zero extended symbol value */\n#define\tR_X86_64_PC8\t\t15\t/* Add 8 bit signed extended pc relative symbol value */\n#define\tR_X86_64_DTPMOD64\t16\t/* ID of module containing symbol */\n#define\tR_X86_64_DTPOFF64\t17\t/* Offset in TLS block */\n#define\tR_X86_64_TPOFF64\t18\t/* Offset in static TLS block */\n#define\tR_X86_64_TLSGD\t\t19\t/* PC relative offset to GD GOT entry */\n#define\tR_X86_64_TLSLD\t\t20\t/* PC relative offset to LD GOT entry */\n#define\tR_X86_64_DTPOFF32\t21\t/* Offset in TLS block */\n#define\tR_X86_64_GOTTPOFF\t22\t/* PC relative offset to IE GOT entry */\n#define\tR_X86_64_TPOFF32\t23\t/* Offset in static TLS block */\n#define\tR_X86_64_PC64\t\t24\t/* PC-relative 64 bit signed sym value. */\n#define\tR_X86_64_GOTOFF64\t25\n#define\tR_X86_64_GOTPC32\t26\n#define\tR_X86_64_GOT64\t\t27\n#define\tR_X86_64_GOTPCREL64\t28\n#define\tR_X86_64_GOTPC64\t29\n#define\tR_X86_64_GOTPLT64\t30\n#define\tR_X86_64_PLTOFF64\t31\n#define\tR_X86_64_SIZE32\t\t32\n#define\tR_X86_64_SIZE64\t\t33\n#define\tR_X86_64_GOTPC32_TLSDESC 34\n#define\tR_X86_64_TLSDESC_CALL\t35\n#define\tR_X86_64_TLSDESC\t36\n#define\tR_X86_64_IRELATIVE\t37\n\n\n#endif /* !_SYS_ELF_COMMON_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/group__KNOBS.html": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/xhtml;charset=UTF-8\"/>\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=9\"/>\n<meta name=\"generator\" content=\"Doxygen 1.8.13\"/>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>\n<title>Pin: Command Line Switches</title>\n<link href=\"tabs.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<script type=\"text/javascript\" src=\"jquery.js\"></script>\n<script type=\"text/javascript\" src=\"dynsections.js\"></script>\n<link href=\"search/search.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<script type=\"text/javascript\" src=\"search/searchdata.js\"></script>\n<script type=\"text/javascript\" src=\"search/search.js\"></script>\n<link href=\"doxygen.css\" rel=\"stylesheet\" type=\"text/css\" />\n</head>\n<body>\n<div id=\"top\"><!-- do not remove this div, it is closed by doxygen! -->\n<div id=\"titlearea\">\n<table cellspacing=\"0\" cellpadding=\"0\">\n <tbody>\n <tr style=\"height: 56px;\">\n  <td id=\"projectalign\" style=\"padding-left: 0.5em;\">\n   <div id=\"projectname\">Pin\n   </div>\n  </td>\n </tr>\n </tbody>\n</table>\n</div>\n<!-- end header part -->\n<!-- Generated by Doxygen 1.8.13 -->\n<script type=\"text/javascript\">\nvar searchBox = new SearchBox(\"searchBox\", \"search\",false,'Search');\n</script>\n<script type=\"text/javascript\" src=\"menudata.js\"></script>\n<script type=\"text/javascript\" src=\"menu.js\"></script>\n<script type=\"text/javascript\">\n$(function() {\n  initMenu('',true,false,'search.php','Search');\n  $(document).ready(function() { init_search(); });\n});\n</script>\n<div id=\"main-nav\"></div>\n</div><!-- top -->\n<!-- window showing the filter options -->\n<div id=\"MSearchSelectWindow\"\n     onmouseover=\"return searchBox.OnSearchSelectShow()\"\n     onmouseout=\"return searchBox.OnSearchSelectHide()\"\n     onkeydown=\"return searchBox.OnSearchSelectKey(event)\">\n</div>\n\n<!-- iframe showing the search results (closed by default) -->\n<div id=\"MSearchResultsWindow\">\n<iframe src=\"javascript:void(0)\" frameborder=\"0\" \n        name=\"MSearchResults\" id=\"MSearchResults\">\n</iframe>\n</div>\n\n<div class=\"header\">\n  <div class=\"headertitle\">\n<div class=\"title\">Command Line Switches</div>  </div>\n</div><!--header-->\n<div class=\"contents\">\n<p>This section describes the command line switches that are currently supported by Pin.</p>\n<p>Pin switches should appear after the pin command, but before the -t &lt;tool&gt; option. The following Pin switches are supported:</p>\n<table frame=\"void\" rules=\"none\" cellspacing=\"10\">\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-follow_execv </td><td>Execute all processes spawned by the execv class system calls with Pin.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-help </td><td>Print the help message.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pause_tool &lt;n&gt; </td><td>Pause and print the PID so the debugger can be attached after the tool is loaded. Processing will resume after \"n\" seconds.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-logfile </td><td>Indicates the path and name of the log file. The default path is the current working directory. The default name is pin.log.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-unique_logfile </td><td>Appends the pid to the log file name.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-error_file </td><td>Indicates the path and name of the error file. The default path is the current working directory. If an error file is specified, all errors will be written to the error file, and will not be displayed on the console. If an error file is not specified, no error file will be created. The error file is designed to be parsed by tools that layer on top of Pin. See <a class=\"el\" href=\"group__ERROR__FILE__BASIC.html\">Pin Error Reporting Support</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-unique_error_file </td><td>Appends the pid to the error file name.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-injection &lt;mode&gt; </td><td>Where &lt;mode&gt; is one of dynamic, self, child, parent. UNIX-only. See <a class=\"el\" href=\"index.html#INJECTION\">Injection</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-inline </td><td>Inline simple analysis routines.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-log_inline </td><td>Report which analysis routines have been inlined in the pin.log file.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-cc_memory_size &lt;n&gt; </td><td>Max (in bytes) code cache size (0==unlimited, default). Must be a multiple of the code cache block size   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pid &lt;pid #&gt; </td><td>Attach Pin and the Pintool to an already running executable with the given process id.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pin_memory_range </td><td>Restrict Pin to a memory range, 0x80000000:0x90000000 or size: 0:0x10000000.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-restrict_memory </td><td>Prevent PIN's dynamic loader from using these memory regions, 0x10000000:0x20000000   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pin_memory_size </td><td>Limit the number of bytes that can be dynamically allocated by PIN and PIN tool Note that the number of bytes allocated by PIN is defined by the total number of memory pages allocated by PIN multiplied by the page size   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-tool_load_option </td><td>Load the tool with additional flags. Currently supported flags are:<br />\n <b>deepbind:</b> (Linux only) Load the tool with the RTLD_DEEPBIND flag to make it a self-contained library. For more information see the dlopen man pages.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-t &lt;toolname&gt; </td><td>Specify the Pintool to use. If you are running a 32-bit application in an IA-32 architecture, or a 64-bit application on an Intel(R) 64 architecture, only -t &lt;toolname&gt; is needed. If you are running an application on an Intel(R) 64 architecture, where all of the components in the chain are either 32-bit or 64-bit, but not both, only -t &lt;toolname&gt; is needed. If you are running an application on an Intel(R) 64 architecture, where components in the chain are both 32-bit and 64-bit, use -t64 &lt;64-bit toolname&gt; to specify the 64-bit tool binary followed by -t &lt;32-bit toolname&gt; to specify the 32-bit tool binary and the tool options. For more information, see <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-t64 &lt;64-bit toolname&gt; </td><td>Specify 64-bit tool binary for Intel(R) 64 architecture. If you are running an application on an Intel(R) 64 architecture, where components in the chain are both 32-bit and 64-bit, use -t64 together with -t as described above. See <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>. <br />\n <b>Important</b>: Using -t64 without -t is not recommended, since in this case when given a 32-bit application, Pin will run the application without applying any tool.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-p32 &lt;toolname&gt; </td><td>Specify Pin binary for IA-32 architecture. See <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-p64 &lt;toolname&gt; </td><td>Specify Pin binary for Intel(R) 64 architecture. See <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-smc_support [1][0] </td><td>Enable (1) or disable (0) support for self-modifying code (SMC) in the application. This option is enabled by default.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-smc_strict [0][1] </td><td>Enable (1) or disable (0) support for SMC inside basic blocks. By default (0), Pin assumes that basic blocks do not modify their own code.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG\"></a> -appdebug  </td><td>Debug the application, stopping in the debugger as soon as the application is launched.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG_ENABLE\"></a> -appdebug_enable  </td><td>Enable application level debugger support, but do not stop when the application is launched. Instead, you can connect a debugger after launch.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG_SILENT\"></a> -appdebug_silent  </td><td>When application debugging is enabled, Pin normally prints a message telling how to connect an external debugger. This knob disables the message. Pin never prints this message when -appdebug_connection is specified.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG_EXCLUDE\"></a> -appdebug_exclude  </td><td>When application debugging and -follow_execv are both specified, the default behavior is to enable debugging on all child processes. This knob, which is repeatable, specifies an application name for which debugging is disabled. Debugging is disabled for a process if it's argv[0] value matches one of the -appdebug_exclude names.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG_ALLOW_REMOTE\"></a> -appdebug_allow_remote  </td><td>When application debugging is enabled, the default behavior requires the debugger to run on the same system as Pin. This knob allows Pin to connect to an external debugger that runs on a remote system. This knob is ignored when -appdebug_connection is specified because -appdebug_connection explicitly specifies the machine on which the debugger runs.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG_CONNECTION\"></a> -appdebug_connection  </td><td>When application debugging is enabled, Pin's default behavior is to open a TCP port and wait for a debugger to connect. This knob reverses the roles; the debugger opens a TCP port and waits for Pin to connect to the port specified in this knob. The format of the knob value should be \"[ip]:port\". If the \"ip\" address is specified, it should be in dot-decimal notation. If \"ip\" is omitted, Pin connects to the specified port on the local machine. The port number should be specified in decimal. Note that this knob is never used when debugging with GDB.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-detach_reattach </td><td>Allow detach and reattach in probe mode. Windows* only.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-debug_instrumented_processes </td><td>Print message to allow debugger attach to instrumented processes. Windows* only.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-slow_asserts </td><td>Perform expensive sanity checks   </td></tr>\n</table>\n<p>Pin also supports the following tool switches. Tool switches should be placed after the tool name, but before the double dash (\"--\").</p>\n<table frame=\"void\" rules=\"none\" cellspacing=\"10\">\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-logfile </td><td>Indicates the path and name of the log file. The default path is the current working directory. The default name is pintool.log.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-unique_logfile </td><td>Appends the pid to the log file name.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-discard_line_info &lt;module_name&gt; </td><td>Discard line information for specific module. Module name should be a short name without path, and not a symbolic link   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-discard_line_info_all </td><td>Discard line information for all modules.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-help </td><td>Print the help message.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-support_jit_api </td><td>Enables managed platforms support.  </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-short_name </td><td>Use the shortest name for the RTN. Names with version substrings are preferred over the same name without the substring.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-symbol_path &lt;list of paths&gt; </td><td>Specifies list of paths separated with semicolons that are searched to find symbol and line information. The list is searched when necessary after default search algorithm is applied. Default list is empty. Windows* only.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-slow_asserts </td><td>Perform expensive sanity checks. Recommended to be used in development and testing phase.   </td></tr>\n</table>\n<p>If you want to add your own command line options to your tool, please see <a class=\"el\" href=\"group__KNOB__API.html\">KNOBS</a>. </p>\n</div><!-- contents -->\n<!-- start footer part -->\n<hr class=\"footer\"/><address class=\"footer\"><small>\nGenerated by &#160;<a href=\"http://www.doxygen.org/index.html\">\n<img class=\"footer\" src=\"doxygen.png\" alt=\"doxygen\"/>\n</a> 1.8.13\n</small></address>\n</body>\n</html>\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/pin.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/bin/pindb.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/bin/pinbin.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/lib/libpin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/lib/libsapin.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/lib/libpinjitprofiling.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/lib/libpin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/lib/libsapin-icc.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/lib/libpin.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/lib/libsapin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/lib/libsapin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/lib/libpin-icc.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/lib/libpinjitprofiling.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/lib-ext/libpin3dwarf.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/lib-ext/libpin3dwarf.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/libunwind-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/crtbegin.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/linker.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/crtbeginS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/libc-static.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/libunwind-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/libstlport-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/crtendS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/crtend.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/crtbegin.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/libdl-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/crtend.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/libc-static.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/libos-apis.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/libos-apis.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/libm-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/libc-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/libstlport-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/libm-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/crtendS.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/libc-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/libdl-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/intel64/runtime/pincrt/crtbeginS.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/I18N/win_unicode_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/I18N/win_unicode_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/I18N/win_unicode_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/I18N/win_unicode_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/probefastcall_app.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/before_after_defaultcall_app_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/probefastcall_app.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/before_after_fastcall_app_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/before_after_defaultcall_app_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/before_after_stdcall_app_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/before_after_fastcall_app_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/probestdcall_app.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/before_after_stdcall_app_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/before_after_fastcall_app_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/before_after_defaultcall_app_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/before_after_stdcall_app_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/before_after_fastcall_app_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/before_after_defaultcall_app_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/probestdcall_app.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Probes/before_after_stdcall_app_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Tests/winapp_runs_pin_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Tests/winapp_runs_pin.ico",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/source/tools/Tests/winapp_runs_pin_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/bin/pindb.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/bin/pinbin.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/lib/libpin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/lib/libsapin.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/lib/libpinjitprofiling.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/lib/libpin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/lib/libsapin-icc.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/lib/libpin.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/lib/libsapin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/lib/libsapin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/lib/libpin-icc.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/lib/libpinjitprofiling.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/lib-ext/libpin3dwarf.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/lib-ext/libpin3dwarf.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/libunwind-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/crtbegin.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/linker.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/crtbeginS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/libc-static.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/libunwind-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/libstlport-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/crtendS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/crtend.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/crtbegin.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/libdl-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/crtend.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/libc-static.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/libos-apis.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/libos-apis.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/libm-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/libc-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/libstlport-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/libm-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/crtendS.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/libc-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/libdl-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/ia32/runtime/pincrt/crtbeginS.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/xed-intel64/lib/libxed.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/xed-intel64/lib/libxed.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/components/lib/intel64/libatomic.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/components/lib/intel64/libdebugger-protocol.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/components/lib/intel64/libatomic.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/components/lib/intel64/libdebugger-protocol.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/components/lib/intel64/libdebugger-protocol.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/components/lib/intel64/libdebugger-protocol.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/components/lib/ia32/libatomic.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/components/lib/ia32/libdebugger-protocol.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/components/lib/ia32/libatomic.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/components/lib/ia32/libdebugger-protocol.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/components/lib/ia32/libdebugger-protocol.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/components/lib/ia32/libdebugger-protocol.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/nav_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/splitbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/tab_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/tab_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/tab_a.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/folderopen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/sync_on.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/folderclosed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/open.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/bdwn.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/nav_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/sync_off.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/closed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/search/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/search/search_m.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/search/search_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/search/mag_sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/crt/doc/html/search/search_l.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/xed-ia32/lib/libxed.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/extras/xed-ia32/lib/libxed.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/nav_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/splitbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/tab_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/tab_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/tab_a.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/pin-debugger-project-properties1.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/pin-debugger-option-pages-properties.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/pin-debugger-attach.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/folderopen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/sync_on.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/folderclosed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/open.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/bdwn.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/stack-debugger-commands.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/nav_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/pin-debugger-project-properties2.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/stack-debugger-custom-break.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/sync_off.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/closed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/search/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/search/search_m.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/search/search_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/search/mag_sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.13-ajbxmdhw6cvzrtrwwmsibgbx6cuzk6ml/spack-src/doc/html/search/search_l.png"
    ],
    "total_files": 4390
}